---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2021/1265';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Special Soundness in the Random Oracle Model';
const AUTHORS_HTML = 'Douglas Wikström';

const CONTENT = `    <p class="text-gray-300">Douglas Wikström</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">We generalize the knowledge extractor for constant-round special sound protocols presented by <em>Wikström (2018)</em> to a knowledge extractor for the corresponding non-interactive Fiat-Shamir proofs in the random oracle model and give an exact analysis of the extraction error and running time.</p>

    <p class="text-gray-300">Relative the interactive case the extraction error is increased by a factor <span class="math">\\ell</span> and the running time is increased by a factor <span class="math">O(\\ell)</span>, where <span class="math">\\ell</span> is the number of oracle queries made by the prover.</p>

    <p class="text-gray-300">Through carefully chosen notation and concepts, and a technical lemma, we effectively recast the extraction problem of the notoriously complex non-interactive case to the interactive case. Thus, our approach may be of independent interest.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Zero knowledge proofs and proofs of knowledge. Zero knowledge proofs were discovered by Goldwasser, Micali, and Rackoff <em>[10]</em>. They allow a prover to interactively convince a verifier that a statement is true without disclosing anything else. A related notion discovered by Bellare and Goldreich <em>[5]</em>, are proofs of knowledge. In such protocols the prover not only shows that a statement is true, but that it holds a witness of this fact.</p>

    <p class="text-gray-300">The completeness of a protocol is the probability that it completes successfully when both parties follow the protocol on a valid common input. The soundness error of a protocol is the probability that a malicious prover convinces an honest verifier that a false statement is true.</p>

    <p class="text-gray-300">If there is an extraction algorithm such that for every prover and every statement a witness is output in expected time (over the internal randomness of the extractor) <span class="math">\\operatorname{poly}/(\\Delta-\\epsilon)</span>, where <span class="math">\\Delta</span> is the probability that the honest verifier is convinced and <span class="math">\\epsilon</span> is the knowledge error, then the protocol is called a proof of knowledge. Thus, the knowledge error is an upper bound on the probability that a prover convinces a verifier without knowing a witness.</p>

    <p class="text-gray-300">The extractor may rewind and complete multiple executions from any point of the execution, i.e., it treats the prover as a deterministic oracle. A knowledge error <span class="math">\\epsilon</span> implies a soundness error of at most <span class="math">\\epsilon</span>, since the analysis of the knowledge extractor may be seen as a probabilistic proof <em>[1]</em>. Due to the efficiency requirement on the extractor the reverse implication does not hold. Readers are referred to <em>[9]</em> for a thorough discussion of variations of these notions.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Special soundness</h4>

    <p class="text-gray-300">A three-message public-coin protocol <em>[10, 3]</em> is defined to be <em>special sound</em> if a witness can be computed efficiently from two accepting transcripts with a common first prover message, but distinct verifier messages. This notion was introduced by Cramer et al. <em>[7]</em> as a generalization of a property of Schnorr’s proof of knowledge of a discrete logarithm <em>[11]</em>.</p>

    <p class="text-gray-300">In the generalization of Wikström <em>[12]</em> a <span class="math">(2r+1)</span>-round protocol is special sound if: (1) the <span class="math">i</span>th verifier message is chosen uniformly at random from the ground set <span class="math">S_{i}</span> of a matroid <span class="math">\\mathbb{M}_{i}</span> for <span class="math">i\\in[r]</span>, and (2) a witness can be computed from a tree of accepting transcripts such that for each <span class="math">i\\in[r]</span> and each node at depth <span class="math">i-1</span> the verifier messages form a basis of <span class="math">\\mathbb{M}_{i}</span>. Matroids capture independence abstractly, but examples from the literature include inequality <em>[11]</em> or linear independence <em>[4]</em>.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Fiat-Shamir heuristic</h4>

    <p class="text-gray-300">Recall that a public coin protocol may be converted into a non-interactive protocol using the Fiat-Shamir transform <em>[8]</em>. This replaces each verifier message by the output of a hash function evaluated on the common input and the current partial transcript. This is important in practice to reduce the number of rounds.</p>

    <p class="text-gray-300">The Fiat-Shamir heuristic suggests that we may analyze such protocols by replacing the hash function by a random oracle. The random oracle model was generalized and formalized by Bellare and Rogaway <em>[6]</em>. When we analyze the protocol in the random oracle model we are effectively assuming that it suffices to consider adversaries which treats the hash function as if it was ideal and never inspects its definition.</p>

    <p class="text-gray-300">However, the adversary may still exploit the fact that it may query the random oracle repeatedly on inputs of its choice. This enables it to probe a tree of partial executions until it can extend at least one interaction with the random oracle to a complete accepting transcript that it outputs as its non-interactive proof.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Grafting protocols</h4>

    <p class="text-gray-300">It is more convenient to think of the interaction between the prover and the random oracle as a <em>grafting protocol</em> where the prover may extend the execution from any previous existing verifier message by grafting a new branch, i.e., a reply, to a verifier message. The verifier is easily adapted correspondly to give the prover this ability. An execution is then considered to be accepting if any path from the root to a leaf in the resulting tree of transcripts, corresponding to a transcript of the basic protocol, is accepting.</p>

    <p class="text-gray-300">We stress that neither party rewinds to a previous point in the execution; branches are <em>grafted</em> to the existing tree of executions which remains part of the view. Furthermore, the branches are added in a particular order by the prover, i.e., each prover-verifier message exchange is associated with an integer index. This means that an execution of the grafting protocol may be identified with a topologically ordered subtree of the tree of all possible executions of the basic protocol.</p>

    <p class="text-gray-300">Provided that the verifier messages have high entropy the computation of a Fiat-Shamir proof is statistically close in distribution to the execution of the corresponding grafting protocol. Thus, we study knowledge extraction for grafting protocols.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">1.1 Contribution</h3>

    <p class="text-gray-300">It is well known <em>[11]</em> that if a prover convinces a verifier with probability <span class="math">\\Delta</span> in a three-message special sound protocol, then a witness can be extracted in expected time</p>

    <p class="text-gray-300"><span class="math">p/(\\Delta-\\epsilon)</span>, where <span class="math">p</span> is polynomial and <span class="math">\\epsilon</span> is the knowledge error. Wikström <em>[12]</em> generalized the notion to constant-round special sound protocols and gave an exact and tight bound. The concrete contribution of this work is a corresponding theorem for grafting protocols.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Theorem 1</h6>

    <p class="text-gray-300">(Informal). Let <span class="math">(\\mathcal{P},\\mathcal{V})</span> be a <span class="math">(2r+1)</span>-message <span class="math">(\\mathbb{M}_{1},\\ldots,\\mathbb{M}_{r})</span>-special sound protocol with soundness error <span class="math">\\epsilon_{S}</span> and knowledge error <span class="math">\\epsilon_{K}</span> for a knowledge extractor that for any instance and prover that convinces the verifier with probability <span class="math">\\Delta&gt;\\epsilon_{K}</span>, for a constant <span class="math">c</span> is expected to execute the protocol <span class="math">c/(\\Delta-\\epsilon_{K})</span> times.</p>

    <p class="text-gray-300">Then its <span class="math">(2\\ell+1)</span>-message grafting protocol <span class="math">(\\mathsf{G}[\\mathcal{P}],\\mathsf{G}[\\mathcal{V}])</span> has soundness error <span class="math">\\ell\\epsilon_{S}</span> and knowledge error <span class="math">\\ell\\epsilon_{K}</span> for a knowledge extractor that for any instance and prover that convinces the verifier with probability <span class="math">\\Delta&gt;\\ell\\epsilon_{K}</span> is expected to execute the grafting protocol <span class="math">4\\cdot 3^{r+1}\\ell\\cdot c/(\\Delta-\\ell\\epsilon_{K})</span> times.</p>

    <p class="text-gray-300">In applications we may often choose parameters of the protocol to reduce the soundness and knowledge errors by a factor of <span class="math">1/\\ell</span>. Thus, in practice the Fiat-Shamir transform causes a loss of roughly <span class="math">\\log\\ell+O\\left(1\\right)</span> bits of security.</p>

    <p class="text-gray-300">A careful choice of notation and concepts, and a technical lemma, allow us to effectively reduce the problem of constructing an extractor to the combinatorial problem of finding an accepting basis in a suitably defined matroid tree, but the distribution of the verifier messages is influenced by the adversary and not necessarily uniform. The main technical challenge is to prove that this distribution can be sampled efficiently. Apart from this the analysis from <em>[12]</em> applies mutatis mutandi.</p>

    <h5 id="sec-9" class="text-base font-semibold mt-4">Remark.</h5>

    <p class="text-gray-300">Attema, Fehr, and Klooss recently informed us, that a few months after our discovery, they independently discovered a theorem similar to our main theorem. Interestingly, their work is based on Attema et al. <em>[2]</em>, while we rely on the work of Wikström <em>[12]</em>. Thus, in future work we hope to understand the strengths and weaknesses of both approaches.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">1.2 Proof Strategy</h3>

    <h5 id="sec-11" class="text-base font-semibold mt-4">Grafting protocols.</h5>

    <p class="text-gray-300">We first formalize the computation of a non-interactive Fiat-Shamir proof, based on a special sound protocol, as the execution of a grafting protocol. In such protocols the verifier allows the prover to repeatedly: (1) spawn a new execution of the basic protocol, or (2) extend an existing partial execution of the basic protocol by grafting an additional round to it.</p>

    <p class="text-gray-300">Thus, at any point during execution the transcript may be viewed as a tree of partial executions that grows one edge for each round. We stress that the prover may choose the location of each grafted round and that this may depend on both the structure of the tree and the verifier messages seen so far. The verifier accepts if there exists an embedded accepting transcript of the basic protocol corresponding to a path from the root to a leaf.</p>

    <p class="text-gray-300">This captures the computation of a Fiat-Shamir proof faithfully except that the prover may only execute a round after the previous rounds have been executed, i.e., it is effectively restricted to queries to the random oracle that do not amount to guessing any reply correctly. The entropy of verifier messages is typically high in applications,</p>

    <p class="text-gray-300">and applying the Fiat-Shamir transform at all to a round with small entropy is pointless. Thus, for such protocols a prover can only guess correctly with exponentially small probability, and the grafting protocol is essentially a faithful model.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">Extraction problem for grafting protocols</h4>

    <p class="text-gray-300">An extractor for a special sound protocol repeatedly, and recursively: (1) samples an accepting transcript, and (2) samples other accepting transcripts from a prefix of the first. If this fails within reasonable time it gives up and rewinds before restarting the recursive procedure. Additionally, the verifier messages at a given depth are sampled such that the children of each node form a basis of a matroid determined by the protocol.</p>

    <p class="text-gray-300">An extractor that treats the prover as a blackbox must rewind it to extract a suitable tree of transcripts. Rewinding is easy to visualize for interactive protocols, but for a grafting protocol this means that leaves are pruned in the reverse order in which they were grafted to the tree of partial executions. Furthermore, when the protocol is executed with fresh randomness from a partial grafting transcript the tree of partial transcripts may regrow into a differently shaped tree and not only have different verifier messages associated with the nodes.</p>

    <p class="text-gray-300">To understand the added complexity in the extraction problem for grafting protocols it is worthwhile to consider an embedded accepting transcript in a grafting transcript. To rewind the execution of the embedded execution to a given round requires rewinding the execution of the grafting protocol.</p>

    <p class="text-gray-300">The problem is that even if we complete an accepting execution from the rewinded state there is no guarantee that the resulting embedded accepting transcript is a completion of the prefix of the original embedded accepting transcript. Indeed, the prover may spawn a new execution of the special sound protocol, or graft additional rounds to any of the existing partial executions to form a new embedded accepting transcript.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">Linearization and grafted sequences</h4>

    <p class="text-gray-300">The prover messages are a deterministic function of the verifier messages induced by the prover, which means that we can view: (1) the entire protocol execution, and (2) the verdict of the verifier as a single predicate and focus on the verifier messages.</p>

    <p class="text-gray-300">The added complexity that comes with a tree of partial transcripts is partially superficial, since the the actual execution of the grafting protocol proceeds linearly and the transcript is simply a list of messages that appears in topological order with respect to the tree if we encode the position of a grafted round as an integer index.</p>

    <p class="text-gray-300">Furthermore, although each index for grafting a round is adversarially controlled, it is a deterministic function of the verifier messages thus far in the execution. Thus, the distribution of the list of verifier messages is induced by the prover and can be efficiently sampled. We call the sequence of verifier messages that is generated by this process a grafted sequence.</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">Shadow sequences and sampling</h4>

    <p class="text-gray-300">From a complete accepting grafted sequence <span class="math">z</span> of the verifier we know the positions of the verifier messages belonging to the corresponding embedded accepting transcript, and the corresponding prover messages can be computed deterministically.</p>

    <p class="text-gray-300">Thus, given a grafted sequence <span class="math">z</span>, we can partition it into a <em>shadow sequence</em> of the form <span class="math">(w_{1},\\ldots,w_{r})</span>, where <span class="math">w_{i}</span> ends with the <span class="math">i</span>th verifier message of the embedded transcript (except <span class="math">w_{r}</span> which is slightly different). We call this a shadow sequence, since prefixes are not stable under the addition of elements. More precisely, suppose that <span class="math">z</span> is a grafted sequence with shadow sequence <span class="math">w</span>, and that the shadow prefix <span class="math">w_{[i]}</span> equals the prefix <span class="math">z_{[k]}</span> if we concatenate its components. If <span class="math">z^{\\prime}</span> is a grafted sequence with prefix <span class="math">z_{[k]}</span>, then the prefix <span class="math">w^{\\prime}_{[i]}</span> of its shadow sequence may have no common elements with <span class="math">w_{[i]}</span>.</p>

    <p class="text-gray-300">We may still think of each shadow element <span class="math">w_{i}</span> as sampled from a ground set of a <em>shadow matroid</em> <span class="math">\\mathbb{M}_{i}^{*}</span>, which inherits the essential combinatorical structure from the corresponding matroid <span class="math">\\mathbb{M}_{i}</span> of the special sound protocol, but the distribution is influenced by the prover.</p>

    <p class="text-gray-300">If we from any prefix <span class="math">w_{[i]}</span> of an accepting shadow sequence <span class="math">w</span> with reasonable probability could sample a complete shadow sequence <span class="math">w^{\\prime}</span>, then we would have reduced the extraction problem for grafting protocols to that of basic special sound protocols, i.e., the analysis from <em>[12]</em> would apply with minor syntactical changes.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">Sampling shadow sequences.</h4>

    <p class="text-gray-300">Unfortunately, we can only sample <em>grafted</em> sequences directly. Suppose that <span class="math">w</span> is the shadow sequence of grafted sequence <span class="math">z</span> and that the prefix <span class="math">w_{[i]}</span> corresponds to a prefix <span class="math">z_{[k]}</span> of <span class="math">z</span>. Then if a randomly sampled <span class="math">z^{\\prime}</span> conditioned on <span class="math">z^{\\prime}_{[k]}=z_{[k]}</span> is accepting with probability <span class="math">\\Delta</span> we can certainly sample an accepting grafted sequence <span class="math">z^{\\prime}</span> from the prefix <span class="math">z_{[k]}</span> in time roughly <span class="math">1/\\Delta</span>, but in general the probability that its shadow sequence <span class="math">w^{\\prime}</span> satisfies <span class="math">w^{\\prime}_{[i]}=w_{[i]}</span> may be arbitrarily low.</p>

    <p class="text-gray-300">Similarly, if we ignore the requirement on acceptance, and focus on keeping the prefix of the shadow sequence it is not hard to see that a random prefix can be extended with conditional probability roughly <span class="math">1/\\ell</span> throughout the recursive process.</p>

    <p class="text-gray-300">We show that both properties can be maintained simultaneously throughout an execution with constant probability of failure in each step of the process and thereby allow sampling accepting shaddow sequences that extend the prefixes that appear in the algorithm. Thus, the difference between the extraction problem for a special sound protocol and its grafting protocol is surprisingly small.</p>

    <h2 id="sec-16" class="text-2xl font-bold">2 Background</h2>

    <p class="text-gray-300">We need a number of definitions and concepts from <em>[12]</em>. Recall that a matroid <span class="math">\\mathbb{M}=(S,I)</span> consists of a ground set <span class="math">S</span> and a set <span class="math">I</span> of subsets of <span class="math">S</span> that is closed downwards and satisfy the independent set exchange property. A basis is a set <span class="math">B\\in I</span> such that <span class="math">B\\cup\\{x\\}\\not\\in I</span> for every <span class="math">x\\in S\\setminus B</span>. The rank <span class="math">\\mathsf{rank}(\\mathbb{M})</span> of a matroid is the unique maximal number of elements in a basis. The span of a set <span class="math">A</span> is defined by <span class="math">\\mathsf{span}(A)=\\{x\\in S\\mid\\mathsf{rank}(A\\cup\\{x\\})=\\mathsf{rank}(A)\\}</span>. A flat is a set which is its own span. Section F provides explicit definitions. Throughout <span class="math">d_{i}</span> denotes the rank of <span class="math">\\mathbb{M}_{i}</span>.</p>

    <p class="text-gray-300">A matroid tree <span class="math">(\\{v_{0}\\},\\mathbb{M}_{1},\\ldots,\\mathbb{M}_{r})</span>, where <span class="math">v_{0}</span> is an arbitrary singleton, represents the set of verifier messages in a special sound protocol as well as the independence relations needed from a set of accepting transcripts to allow computation of the witness. A subtree is a basis if for each node at depth <span class="math">i-1</span> its children form a basis of <span class="math">\\mathbb{M}_{i}</span>.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Definition 1 (Matroid Tree).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The <em>matroid tree</em> associated with a list of matroids <span class="math">\\mathbb{M}=(\\{v_{0}\\},\\mathbb{M}_{1},\\ldots,\\mathbb{M}_{r})</span> is the vertex-labeled rooted unordered directed tree of depth <span class="math">r</span> such that: the root is labeled <span class="math">v_{0}</span> and every node at depth <span class="math">i-1</span> has edges to $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> children which are uniquely labeled with the elements of the ground set </span>S_{i}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-18" class="text-base font-medium mt-4">Definition 2 (Basis).</h6>

    <p class="text-gray-300">A <em>basis</em> of a matroid tree <span class="math">\\mathbb{M}</span> of depth <span class="math">r</span> is a maximal subgraph such that for every <span class="math">i\\in[r]</span> the set of children of every node at depth <span class="math">i-1</span> is a basis of <span class="math">\\mathbb{M}_{i}</span>.</p>

    <p class="text-gray-300">The subdensity captures the fraction of elements of the ground set which is outside a flat. This was introduced in <em>[12]</em> to allow analysis of protocols where verifier messages are chosen from a subset of the algebraic structure which defines the independence sets.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Definition 3 (Subdensity).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbb{M}=(S,I)</span> be a matroid of rank <span class="math">d</span>. Then its <span class="math">i</span>th <em>subdensity</em> is <span class="math">\\omega_{\\mathbb{M},i}</span> if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\omega_{\\mathbb{M},i}<span class="math"> for every flat </span>A<span class="math"> of rank </span>i-1<span class="math">, and it has <em>maximal subdensity</em> </span>\\omega_{\\mathbb{M}}=\\omega_{\\mathbb{M},d}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">After abstracting the execution of a protocol and the verdict of the verifier as a predicate <span class="math">\\rho</span> on verifier messages the extraction problem amounts to finding a basis of a matroid tree. Let <span class="math">S=\\times_{i\\in[r]}S_{i}</span> and <span class="math">\\Delta_{\\rho}(\\mathbb{M})=\\Pr\\left[\\rho(v)=1\\right]</span>, where <span class="math">v</span> is sampled uniformly over a matroid tree <span class="math">\\mathbb{M}</span>.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Definition 4 (Accepting Basis Extractor).</h6>

    <p class="text-gray-300">A probabilistic polynomial time algorithm <span class="math">\\mathcal{X}_{\\kappa}</span> parametrized by <span class="math">\\kappa\\in\\{0,1\\}^{<em>}</span> is a <span class="math">(\\epsilon_{\\kappa},\\mathsf{D}_{\\kappa}(\\Delta))</span>-accepting basis extractor with </em>extraction error* <span class="math">\\epsilon_{\\kappa}</span> for a matroid tree <span class="math">\\mathbb{M}</span>, where <span class="math">\\mathsf{D}_{\\kappa}(\\Delta)</span> for fixed <span class="math">\\kappa</span> is a family of distributions on <span class="math">\\mathbb{N}</span> parametrized by <span class="math">\\Delta\\in[0,1]</span>, if for every <span class="math">\\mathbb{M}</span>-predicate <span class="math">\\rho:S\\rightarrow\\{0,1\\}</span> and <span class="math">\\Delta_{\\rho}(\\mathbb{M})\\geq\\Delta_{0}&gt;\\epsilon_{\\kappa}</span>: <span class="math">\\mathcal{X}_{\\kappa}^{\\rho(\\cdot)}(\\mathbb{M},\\Delta_{0})</span> outputs a <span class="math">\\rho</span>-accepting basis of <span class="math">\\mathbb{M}</span>, where the distribution of the number of <span class="math">\\rho(\\cdot)</span>-queries is bounded by <span class="math">\\mathsf{D}_{\\kappa}(\\Delta_{0})</span>.</p>

    <h2 id="sec-21" class="text-2xl font-bold">3 Grafting Protocols</h2>

    <p class="text-gray-300">Before we introduce grafting protocols we need some notation. The <span class="math">i</span>th message of the prover is a pair <span class="math">(p_{i},a_{i})</span>, where <span class="math">p_{i}</span> is the index of a previous verifier message onto which the new branch is grafted and <span class="math">a_{i}</span> is a prover message of the basic protocol. The verifier always sends its next challenge message immediately, so there is no need for an additional index for the verifier’s messages. One round of interaction is therefore always a triple <span class="math">(p_{i},a_{i},v_{i+1})</span>, where <span class="math">p_{i}=0</span> if the prover starts a fresh execution of the basic protocol. Every path in the tree of partial executions of the basic protocol then has the form <span class="math">(a_{j_{1}-1},v_{j_{1}},\\ldots,a_{j_{i}-1},v_{j_{i}})</span>, where <span class="math">p_{j_{i}}=j_{i-1}</span>, i.e., it is an embedded transcript of the basic protocol. To ensure that the distribution of verifier messages is correct, the grafting verifier keeps state and samples each message from the appropriate set.</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">3.1 Functions of Transcripts</h3>

    <p class="text-gray-300">After each prover message during an execution of the grafting protocol on common input <span class="math">x</span> the current transcript has the form <span class="math">\\big{(}x,(p_{1},a_{1},v_{2}),\\ldots,(p_{i-1},a_{i-1},v_{i}),(p_{i},a_{i})\\big{)}</span> for some <span class="math">i</span>. We call this a <em>truncated transcript</em> and denote it by <span class="math">t_{[i]}</span>, where <span class="math">t</span> may be a complete or truncated transcript itself. This allows us to define a natural depth function.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Definition 5 (Depth Function)</h6>

    <p class="text-gray-300">The depth function <span class="math">\\delta</span> takes a truncated transcript of a grafting protocol as input and is defined by</p>

    <p class="text-gray-300">\\[ \\delta(t_{[i]})=\\left\\{\\begin{array}[]{cc}1&\\mbox{if }p_{i}=0\\\\ 1+\\delta(t_{[p_{i}]})&\\mbox{otherwise}\\end{array}\\right.. \\]</p>

    <p class="text-gray-300">When the truncated transcript is clear from the context we abuse notation and simply write <span class="math">\\delta(p_{i})</span> to mean <span class="math">\\delta(t_{[i]})</span>.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Definition 6 (Index Function)</h6>

    <p class="text-gray-300">The index function <span class="math">\\iota(\\cdot)</span> takes a truncated transcript of a grafting protocol as input and is defined by <span class="math">\\iota(t_{[i]})=(j_{1},\\ldots,j_{d})</span>, where <span class="math">d=\\delta(t_{[i]})</span>, <span class="math">j_{d}=p_{i}</span>, and <span class="math">j_{l}=p_{j_{l+1}}</span> for <span class="math">l=d-1,\\ldots,1</span>.</p>

    <p class="text-gray-300">These functions merely gives a way to refer to the unique embedded partial transcript that was most recently extended by a round of interaction. Finally, we introduce notation for extracting the embedded transcript itself using the index function.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Definition 7 (Path Projection)</h6>

    <p class="text-gray-300">The path projection <span class="math">\\tau(\\cdot)</span> takes a truncated transcript of a grafting protocol as input and is defined by</p>

    <p class="text-gray-300"><span class="math">\\tau(t_{[i]})=(x,a_{j_{1}-1},v_{j_{1}},\\ldots,a_{j_{d}-1},v_{j_{d}},a_{i})\\enspace,\\quad\\mbox{where }(j_{1},\\ldots,j_{d})=\\iota(t_{[i]})\\enspace.</span></p>

    <p class="text-gray-300">Note that if <span class="math">d=r</span>, then the embedded transcript is complete and is either accepting or rejecting.</p>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">3.2 Grafting Verifier</h3>

    <p class="text-gray-300">We give an explicit transformation of a public coin verifier into a grafting verifier for completeness. It is implicit that it rejects if an index <span class="math">p_{i}</span> provided by the prover is invalid, i.e., if there does not exist a verifier message with the index <span class="math">p_{i}</span> in the existing partial transcript onto which a round can be grafted.</p>

    <p class="text-gray-300">Without loss of generality we assume that the verifier sends exactly <span class="math">\\ell</span> messages and that the prover’s final message corresponds to a final reply of an accepting execution of the basic protocol, if any exists at all.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Definition 8 (Grafting Verifier)</h6>

    <p class="text-gray-300">If <span class="math">(\\mathcal{P},\\mathcal{V})</span> is a <span class="math">(\\mathbb{M}_{1},\\ldots,\\mathbb{M}_{r})</span>-special sound protocol, then on common input <span class="math">x</span> its <span class="math">\\ell</span>-grafting verifier <span class="math">\\mathsf{G}[\\mathcal{V}]</span> proceeds as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initialize an empty table <span class="math">T[\\cdot,\\cdot]</span>.</li>

      <li>For <span class="math">i=0,\\ldots,\\ell-1</span>:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Wait for a message <span class="math">(p_{i},a_{i})</span> from the prover.</li>

      <li>If <span class="math">T[p_{i},a_{i}]\\neq\\varnothing</span>, then set <span class="math">v_{i+1}=T[p_{i},a_{i}]</span>, and otherwise choose <span class="math">v_{i+1}\\in S_{\\delta(p_{i})}</span> randomly, set <span class="math">T[p_{i},a_{i}]=v_{i+1}</span>, and hand <span class="math">v_{i+1}</span> to the prover.</li>

      <li>Wait for a message <span class="math">(p_{\\ell},a_{\\ell})</span> from the prover.</li>

      <li>Return the verdict <span class="math">\\mathcal{V}\\big{(}\\tau(x,(p_{i},a_{i},v_{i+1})_{i\\in[0,\\ell-1]},p_{\\ell},a_{\\ell})\\big{)}</span> of the verifier <span class="math">\\mathcal{V}</span></li>

    </ol>

    <p class="text-gray-300">Each verifier message is chosen from the ground set associated with the appropriate round in the basic protocol due to the depth function. To avoid grafting more than once at a given index with the same prover message the verifier uses a table. This mirrors the same property of a random oracle, i.e., once sampled it returns the same output every time it is queried on the same input.</p>

    <p class="text-gray-300">We are interested in malicious provers which graft branches during the execution, but for completeness we describe in Section D the corresponding honest prover which is merely a wrapper of the honest prover of the basic protocol.</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">3.3 Grafting Protocols vs Non-interactive Fiat-Shamir Proofs</h3>

    <p class="text-gray-300">We may interpret the execution of a grafting protocol as the prover computing a Fiat-Shamir proof in the random oracle model using a random oracle <span class="math">\\mathcal{RO}</span> as follows. Relative to the current truncated transcript <span class="math">t_{[c]}</span> a prover message <span class="math">(p_{i},a_{i})</span> with <span class="math">i\\leq c</span> uniquely identifies an embedded transcript <span class="math">\\tau(t_{[i]})</span>. For this embedded transcript the next verifier message <span class="math">v_{i+1}</span> is independently and uniformly distributed in the appropriate matroid ground set and sampled exactly once.</p>

    <p class="text-gray-300">When the min entropy of the verifier message in each round is high this is essentially equivalent to the computation of a Fiat-Shamir proof, where the next verifier message is defined by <span class="math">v_{i+1}=\\mathcal{RO}(\\tau(t_{[i]}))</span>. Indeed, if the min entropy <span class="math">\\eta</span> is high, then the probability that a prover queries the random oracle in advance at a point partially defined by random verifier messages that it has not yet received is bounded by <span class="math">\\ell 2^{-\\eta}</span>.</p>

    <p class="text-gray-300">In general we cannot expect that it is infeasible to: (1) determine if a prover message is likely to be part of an accepting execution, or (2) use re-randomization to generate arbitrarily many such prover messages from one. This means that a prover can probe up to <span class="math">\\ell</span> verifier messages. Thus, if the min entropy is not exponentially smaller than <span class="math">1/\\ell</span> the protocol may loose all soundness, i.e., it is unwise to apply the Fiat-Shamir transform at all.</p>

    <h2 id="sec-29" class="text-2xl font-bold">4 Grafted Sequences</h2>

    <p class="text-gray-300">Recall that in <em>[12]</em> the extraction problem is reduced to the problem of extracting an accepting basis of a matroid tree relative a prover predicate that captures both the execution of the protocol and the verdict of the verifier.</p>

    <p class="text-gray-300">We proceed similarly to abstract the extraction of a tree of transcripts of a grafting protocol which correspond to an accepting basis tree in the basic protocol, but in our case the distribution of verifier messages depends on the prover.</p>

    <p class="text-gray-300">A grafting function determines, from the list of verifier messages so far, at which point an additional branch is grafted to a sequence, i.e., given a sequence as input it outputs an integer index of an existing element in the sequence. This abstracts the choice made by the prover in a grafting protocol. A depth function makes explicit the depth at which a branch is grafted.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Definition 9 (Grafting Function)</h6>

    <p class="text-gray-300">A function <span class="math">f</span> such that <span class="math">f(\\varnothing)=0</span> and <span class="math">f(z_{1},\\ldots,z_{i})\\in[0,i]</span> for every <span class="math">z_{1},\\ldots,z_{i}\\in\\{0,1\\}^{*}</span> and every <span class="math">i\\in\\mathbb{N}</span> is a grafting function.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Definition 10 (Depth Function).</h6>

    <p class="text-gray-300">The <em>depth function</em> <span class="math">\\delta_{f}</span> of a grafting function <span class="math">f</span> is defined as follows:</p>

    <p class="text-gray-300">\\[ \\delta_{f}(z_{1},\\ldots,z_{i})=\\left\\{\\begin{array}[]{cc}1&\\mbox{if }f(z_{[i]})=0\\\\ 1+\\delta_{f}(z_{[f(z_{[i-1]})]})&\\mbox{otherwise}\\end{array}\\right.. \\]</p>

    <p class="text-gray-300">A grafted sequence is an abstraction of a transcript of a grafted protocol where the verifier messages are explicit, and the prover messages are implicit.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Definition 11 (Grafted Sequence).</h6>

    <p class="text-gray-300">An <span class="math">(\\mathbb{M},f)</span>-grafted sequence of length <span class="math">\\ell</span>, where <span class="math">\\mathbb{M}=(\\mathbb{M}_{1},\\ldots,\\mathbb{M}_{r})</span> is matroid tree with <span class="math">\\mathbb{M}_{i}=(S_{i},I_{i})</span> is a sequence <span class="math">z=(z_{1},\\ldots,z_{\\ell})</span> such that <span class="math">\\delta_{f}(z_{[i-1]})\\leq r</span> and <span class="math">z_{i}\\in S_{\\delta_{f}(z_{[i-1]})}</span> for every <span class="math">i\\in[\\ell]</span>. We denote the set of <span class="math">(\\mathbb{M},f)</span>-grafted sequences of length <span class="math">\\ell</span> by <span class="math">G_{\\mathbb{M},f,\\ell}</span>.</p>

    <p class="text-gray-300">Similarly to how we extracted indices from a grafted protocol transcript we extract indices of the verifier messages of an (implicitly defined) embedded truncated transcript of the basic protocol. It is not meaningful to define a path projection since the prover messages are defined by the complete grafted sequence.</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Definition 12 (Index Function).</h6>

    <p class="text-gray-300">The <em>index function</em> <span class="math">\\iota_{f}</span> takes a grafted sequence <span class="math">z\\in G_{\\mathbb{M},f,\\ell}</span> as input and outputs indices <span class="math">(j_{1},\\ldots,j_{d})</span> defined by <span class="math">j^{\\prime}=f(z)</span>, <span class="math">d=\\delta_{f}(z_{[j^{\\prime}]})</span>, <span class="math">j_{d}=j^{\\prime}</span>, and <span class="math">j_{i}=f(z_{[j_{i+1}-1]})</span> for <span class="math">i=d-1,\\ldots,1</span>.</p>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">4.1 Shadow Sequences</h3>

    <p class="text-gray-300">We introduce shadow sequences and shadow matroids as a conceptual step to emphasize the similarity with the analysis in <em>[12]</em>.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Definition 13 (Shadow Sequence).</h6>

    <p class="text-gray-300">If <span class="math">z</span> is a grafted sequence over <span class="math">G_{\\mathbb{M},f,\\ell}</span>, <span class="math">(j_{1},\\ldots,j_{d})=\\iota_{f}(z)</span>, <span class="math">j_{0}=0</span>, and <span class="math">w_{i}=(z_{j_{i-1}+1},\\ldots,z_{j_{i}})</span> for <span class="math">i\\in[1,d-1]</span>, and <span class="math">w_{d}=(z_{j_{d-1}+1},\\ldots,z_{\\ell})</span>, then <span class="math">\\sigma_{f}(z)=(w_{1},\\ldots,w_{d})</span> is its <em>shadow sequence</em>.</p>

    <p class="text-gray-300">The last shadow element ends at index <span class="math">\\ell</span> and not index <span class="math">j_{d}</span>, so there may be some additional elements beyond the last embedded verifier message of the basic protocol. This is necessary, but it does not impact the analysis technically.</p>

    <p class="text-gray-300">For every grafted sequence <span class="math">z</span> there is a shadow sequence <span class="math">w=\\sigma_{f}(z)</span> and we may view a predicate <span class="math">\\rho</span> over grafted sequences as a predicate <span class="math">\\rho^{*}</span> over shadow sequences. The last component of the <span class="math">i</span>th shadow element is an element from <span class="math">S_{i}</span>. Thus, the <span class="math">i</span>th shadow element is contained in the following matroid.</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Definition 14 (Shadow Matroid).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">\\mathbb{M}=(S,I)</span> is a matroid, then its <em>shadow matroid</em> <span class="math">\\mathbb{M}^{<em>}=(S^{</em>},I^{<em>})</span> is defined by <span class="math">S^{</em>}=\\{0,1\\}^{<em>}\\times S\\times\\{0,1\\}^{</em>}</span> and letting <span class="math">C</span> be an independence set in <span class="math">I^{*}</span> if and only if <span class="math">B=\\{b\\mid(a,b,c)\\in C\\}</span> is an independence set in <span class="math">I</span> and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Intuitively, we would like to think of a shadow sequence as a redundant representation of a list of verifier messages in the basic special sound protocol, but the prefixes/postfixes influence the implicitly defined prover messages and the output of the grafting function, so this remains an intuitive view.</p>

    <p class="text-gray-300">4.2 Grafting Function and Predicate of a Prover</p>

    <p class="text-gray-300">We define a grafting function in terms of a grafting protocol and use the definition of a prover predicate from <em>[12]</em>, which is restated below with adapted notation for easy reference.</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Definition 15 (Grafting Function of Prover).</h6>

    <p class="text-gray-300">The <em>grafting function</em> <span class="math">f[\\mathcal{P}^{<em>},\\mathcal{V}]</span> of <span class="math">\\mathcal{P}^{</em>}</span> for an <span class="math">\\ell</span>-grafting protocol of a public-coin protocol <span class="math">(\\mathcal{P},\\mathcal{V})</span> and common input <span class="math">x</span> is defined as follows: On input <span class="math">z=(z_{1},\\ldots,z_{i})</span>, simulate <span class="math">(\\mathcal{P}^{<em>},\\mathsf{G}[\\mathcal{V}])</span> using <span class="math">z</span> as the random tape for <span class="math">\\mathsf{G}[\\mathcal{V}]</span> until <span class="math">\\mathcal{P}^{</em>}</span> outputs its <span class="math">i</span>th message <span class="math">(p_{i},a_{i})</span> and output <span class="math">p_{i}</span>.</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Definition 16 (Prover Predicate).</h6>

    <p class="text-gray-300">The <em>prover <span class="math">\\mathbb{M}</span>-predicate</em> <span class="math">\\rho[\\mathcal{P}^{<em>},\\mathcal{V},x]</span> of <span class="math">\\mathcal{P}^{</em>}</span> for the <span class="math">\\ell</span>-grafting protocol of a public-coin protocol <span class="math">(\\mathcal{P},\\mathcal{V})</span> and common input <span class="math">x</span> is defined by <span class="math">\\rho<a href="z">\\mathcal{P}^{<em>},\\mathcal{V},x</a>=\\langle\\mathcal{P}^{</em>},\\mathsf{G}[\\mathcal{V}]_{z}\\rangle(x)</span>, where <span class="math">z=(z_{1},\\ldots,z_{\\ell})</span>.</p>

    <h3 id="sec-39" class="text-xl font-semibold mt-8">4.3 Random Grafted Sequences</h3>

    <p class="text-gray-300">Suppose that <span class="math">\\mathbb{M}=(\\mathbb{M}_{1},\\ldots,\\mathbb{M}_{r})</span> is a matroid tree and let <span class="math">f</span> be a grafting function. A random variable over <span class="math">G_{\\mathbb{M},f,\\ell}</span> representing the verifier messages of an execution of a grafting protocol is readily defined by stipulating that each verifier message is uniformly and independently distributed over a ground set identified by the depth function.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Definition 17 (Random Grafted Sequence).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The distribution of a random grafted sequence <span class="math">Z</span> over <span class="math">G_{\\mathbb{M},f,\\ell}</span> is defined by $\\mathsf{P}_{Z_{i}\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}Z_{[i-1]}}\\ \\big{(}\\cdot\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}z_{[i-1]}\\big{)}=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{\\delta_{f}(z_{[i-1]})}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-1}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Although each element <span class="math">Z_{i}</span> is uniformly and independently distributed, the sequence is not necessarily uniformly distributed, since the choice of ground set is determined by previous elements and the grafting function. Consequently, the distribution of the shadow sequence <span class="math">W=\\sigma_{f}(Z)</span> is not necessarily uniform.</p>

    <h2 id="sec-41" class="text-2xl font-bold">5 Random Shadow Sequences</h2>

    <p class="text-gray-300">In each recursive call of the extractor the probability that the current prefix of a shadow sequence leads to an accepting sequence is assumed to be some quantity <span class="math">\\Delta</span>, but we must also be able to efficiently sample extensions of the prefix.</p>

    <p class="text-gray-300">The problem is that even if the prefix has probability <span class="math">\\Delta</span> to lead to an accepting grafted sequence it may be the case that the resulting grafted sequence does not have the same prefix as a shadow sequence. Indeed, partitioning of the grafted sequence into a shadow sequence is determined by the grafted sequence as a whole. Conversely, if we focus on sampling a shadow sequence with a given prefix, then the acceptance probability under this conditioning may be significantly lower than <span class="math">\\Delta</span>. Thus, we must prove that a random prefix has both properties at once with reasonable probability. We formalize the property we need below.</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Definition 18 (Extendable Shadow Prefix).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{M}=(\\mathbb{M}_{1},\\ldots,\\mathbb{M}_{r})</span> be a matroid tree, let <span class="math">f</span> be a grafting function, let <span class="math">Z</span> be a random grafted sequence over <span class="math">G_{\\mathbb{M},f,\\ell}</span></p>

    <p class="text-gray-300">define <span class="math">J = \\iota_f(Z)</span>, and <span class="math">W = \\sigma_f(Z)</span>, and let <span class="math">\\rho : G_{\\mathbb{M},f,\\ell} \\to \\{0,1\\}</span> be a predicate. Define for every <span class="math">i \\in [0,r-1]</span>, <span class="math">w \\in [W_{[i]}]</span>, and <span class="math">\\beta \\in (0,1)</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\zeta_{w}^{\\rho} = \\Pr \\left[ \\rho(Z) = 1 \\mid Z_{[k]} = w \\right] \\tag{1}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\theta_{w}^{\\rho} = \\Pr \\left[ J_{i} = k \\mid \\rho(Z) = 1 \\wedge Z_{[k]} = w \\right] \\tag{2}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\xi_{\\rho}(w, \\Delta, \\beta) = \\left(\\zeta_{w}^{\\rho} \\geq \\Delta \\wedge \\theta_{w}^{\\rho} \\geq \\beta^{2}/\\ell\\right) \\tag{3}</span></div>

    <p class="text-gray-300">We can always sample a complete grafting sequence <span class="math">Z</span> starting with <span class="math">w_{[i]}</span> and if <span class="math">\\xi_{\\rho}(w_{[i]}, \\Delta, \\beta) = 1</span>, then we have <span class="math">\\rho(Z) = 1 \\wedge J_i = k</span> with probability at least <span class="math">\\beta^{2}\\Delta/\\ell</span>. Below we show that this implies <span class="math">\\rho^{*}(W) = 1</span> and <span class="math">W_{[i]} = w_{[i]}</span>. Thus, we need roughly <span class="math">\\ell / (\\beta^{2}\\Delta)</span> sampled grafted sequences starting from <span class="math">w_{[i]}</span> to find an accepting shadow sequence starting from <span class="math">w_{[i]}</span>. We maintain a sufficient acceptance probability by application of the following well known lemma, which is proven in Section E.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 1 (Markov Conditioning).</strong> If <span class="math">H = (X, Y)</span> is a random variable, <span class="math">E</span> is an event in <span class="math">[H]</span>, $\\delta_x = \\operatorname{Pr}_H[E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X = x]<span class="math">, and </span>\\operatorname{Pr}_H[E] \\geq \\Delta<span class="math">, then </span>\\operatorname{Pr}_H[\\delta_X &lt; \\alpha\\Delta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E] \\leq \\alpha$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-43" class="text-2xl font-bold">5.1 Coinciding Indices</h2>

    <p class="text-gray-300">It should be clear that if <span class="math">z</span> and <span class="math">z&#x27;</span> share a prefix <span class="math">z_{[k]}</span> corresponding to a prefix <span class="math">w_{[i]}</span> of the shadow sequence <span class="math">w</span> of <span class="math">z</span>, and the <span class="math">i</span>th element of the shadow sequence <span class="math">w&#x27;</span> of <span class="math">z&#x27;</span> end at index <span class="math">k</span>, then <span class="math">w_{[i]}&#x27; = w_{[i]}</span>.</p>

    <p class="text-gray-300"><strong>Lemma 2 (Pinching).</strong> For every <span class="math">z, z&#x27; \\in G_{\\mathbb{M},f,\\ell}</span> and every <span class="math">i \\in [1,r-1]</span>, with <span class="math">j = \\iota_f(z)</span> and <span class="math">w = \\sigma_f(z)</span>, and similarly for <span class="math">j&#x27;</span> and <span class="math">w&#x27;</span>, we have</p>

    <div class="my-4 text-center"><span class="math-block">z_{[j_i]}&#x27; = z_{[j_i]} \\quad \\text{and} \\quad j_i&#x27; = j_i \\quad \\Longrightarrow \\quad j_{[i]}&#x27; = j_{[i]} \\quad \\text{and} \\quad w_{[i]}&#x27; = w_{[i]}.</span></div>

    <p class="text-gray-300"><strong>Proof.</strong> If we define <span class="math">p_t = f(z_{[t-1]})</span> for <span class="math">t \\in [\\ell]</span> and similarly for <span class="math">p_t&#x27;</span> and <span class="math">z_{[t-1]}&#x27;</span>, then by assumption <span class="math">p_{[i]}&#x27; = p_{[i]}</span>. Thus, if <span class="math">j_i&#x27; = j_i</span>, then <span class="math">j_{[i]}&#x27; = j_{[i]}</span> which implies that <span class="math">w_{[i]}&#x27; = w_{[i]}</span>.</p>

    <p class="text-gray-300">Suppose that we sample a grafted sequence <span class="math">z</span> and let <span class="math">w_{[i]}</span> be a prefix of its shadow sequence <span class="math">w</span>, which viewed as a prefix of the grafted sequence has the form <span class="math">z_{[k]}</span> for some <span class="math">k</span>. If we sample a fresh completion <span class="math">z_{[k+1,\\ell]}&#x27;</span> of <span class="math">z_{[k]}</span>, and define <span class="math">w&#x27; = \\sigma_f(z_{[k]}, z_{[k+1,\\ell]}&#x27;)</span> and <span class="math">j&#x27; = \\iota_f(z_{[k]}, z_{[k+1,\\ell]}&#x27;)</span>, then Lemma 2 says that it is sufficient to require that <span class="math">j_i&#x27; = j_i</span> to guarantee that <span class="math">w_{[i]}&#x27; = w_{[i]}</span>. The next lemma is used to prove that over the random choice of <span class="math">w_{[i]}</span> this happens with reasonable probability.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 3 (Coinciding Indices).</strong> Let <span class="math">Z = (Z_1, \\ldots, Z_\\ell)</span> be a random variable, let <span class="math">\\iota : [Z] \\to [0, \\ell-1]</span> be a function, define <span class="math">K = \\iota(Z)</span>, <span class="math">X = (Z_1, \\ldots, Z_K)</span>, and let <span class="math">Y</span> be independently distributed with $\\mathsf{P}_{Y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X}(\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x) = \\mathsf{P}_{Z_{k+1}, \\ldots, Z_\\ell</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X}(\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x)<span class="math">, where </span>x<span class="math"> has length </span>k<span class="math">. If we define </span>\\theta_x = \\operatorname{Pr}[\\iota(X,Y) = k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X = x]<span class="math">, then for every </span>\\beta \\in (0,1/2)$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\theta_{X} &amp;lt; \\beta^{2}/\\ell \\right] \\leq 2\\beta. \\tag{4}</span></div>

    <p class="text-gray-300">Proof. By definition we have</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf {P} _ {X, K} (x, k) = \\mathsf {P} _ {Z _ {[ k ]}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K} (x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k) \\mathsf {P} _ {K} (k), \\tag {5}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where it is understood that  <span class="math">\\mathsf{P}_{X,K}(x,k) = 0</span>  if the length of  <span class="math">x</span>  is not equal to  <span class="math">k</span> . Thus, to sample  <span class="math">x</span>  we may: sample a length  <span class="math">k</span> , sample  <span class="math">z_{[k]}</span>  as a prefix of a complete sequence  <span class="math">z</span>  conditioned on  <span class="math">\\iota(z) = k</span> , and set  <span class="math">x = z_{[k]}</span> . Furthermore, from independence we have</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\iota (X, Y) = k \\mid X = x \\right] = \\Pr \\left[ \\iota (Z) = k \\mid Z _ {[ k ]} = x \\right] \\tag {6}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">which means that  $\\theta_{x} = \\operatorname*{Pr}\\left[\\iota (Z) = k\\big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_{[k]} = x\\right]$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If we let  <span class="math">\\beta \\in (0,1)</span>  and define  <span class="math">B = \\{k\\mid \\mathsf{P}_K(k) &amp;lt; \\beta /\\ell \\}</span> , then we trivially have  <span class="math">\\operatorname <em>{Pr}[K\\in B] &amp;lt; \\sum_{k\\in [0,\\ell -1]}\\beta /\\ell = \\beta</span> . For every  <span class="math">k\\notin B</span>  we have  <span class="math">\\operatorname </em>{Pr}[\\iota (Z) = k] = \\operatorname *{Pr}[K = k]\\geq \\frac{\\beta}{\\ell}</span>  from the definitions of  <span class="math">K</span>  and the set  <span class="math">B</span> . For  <span class="math">k\\notin B</span>  and every  <span class="math">\\alpha \\in (0,1)</span>  Lemma 1 then implies that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\theta_ {Z _ {[ k ]}} &amp;lt;   \\alpha \\beta / \\ell \\mid \\iota (Z) = k \\right] \\leq \\alpha , \\tag {7}</span></div>

    <p class="text-gray-300">which implies that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\theta_ {X} &amp;lt;   \\alpha \\beta / \\ell \\right] = \\sum_ {k \\in [ 0, \\ell - 1 ]} \\mathrm {P} _ {K} (k) \\Pr \\left[ \\theta_ {Z _ {[ k ]}} &amp;lt;   \\alpha \\beta / \\ell \\mid \\iota (Z) = k \\right] \\tag {8} \\\\ \\leq \\Pr [ K \\in B ] + \\sum_ {k \\notin B} \\mathrm {P} _ {K} (k) \\Pr \\left[ \\theta_ {Z _ {[ k ]}} &amp;lt;   \\alpha \\beta / \\ell \\mid \\iota (Z) = k \\right] \\tag {9} \\\\ \\leq \\beta + \\alpha \\sum_ {k \\notin B} \\mathrm {P} _ {K} (k) \\leq \\alpha + \\beta . \\tag {10} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">The proof is completed by setting  <span class="math">\\alpha = \\beta</span> .</p>

    <h2 id="sec-44" class="text-2xl font-bold">5.2 Extendable Shadow Sequence</h2>

    <p class="text-gray-300">The following theorem follows from the two lemmas above and the union bound.</p>

    <p class="text-gray-300"><strong>Theorem 2 (Extendable Shadow Sequence).</strong> Let  <span class="math">\\mathbb{M} = (\\mathbb{M}_1, \\ldots, \\mathbb{M}_r)</span>  be a matroid tree, let  <span class="math">f</span>  be a grafting function, let  <span class="math">Z</span>  be a random grafted transcript over  <span class="math">G_{\\mathbb{M}, f, \\ell}</span> , and define  <span class="math">J = \\iota_f(Z)</span>  and  <span class="math">W = \\sigma_f(Z)</span> . Let  <span class="math">\\rho: G_{\\mathbb{M}, f, \\ell} \\to \\{0, 1\\}</span>  be a predicate. For every  <span class="math">i \\in [r-1]</span> ,  <span class="math">w \\in [W_{[i-1]}]</span>  such that  <span class="math">\\zeta_w^\\rho \\geq \\Delta</span> ,  <span class="math">\\alpha \\in (0, 1)</span> , and  <span class="math">\\beta \\in (0, (1 - \\alpha)/2)</span> .</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\xi_ {\\rho} \\left(W _ {[ i ]}, \\alpha \\Delta , \\beta\\right) = 1 \\mid \\rho^ {*} (W) = 1, W _ {[ i - 1 ]} = w \\right] \\geq 1 - \\alpha - 2 \\beta . \\tag {11}</span></div>

    <p class="text-gray-300"><strong>Proof.</strong> We define the random variable  <span class="math">(J_{i},X)</span> , by</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf {P} _ {J _ {i}, X} (\\cdot) = \\mathsf {P} _ {J _ {i}, W _ {[ i ]} \\mid W _ {[ i - 1 ]}} (\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w) \\tag {12}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">In other words,  <span class="math">X</span>  effectively captures the distribution of the  <span class="math">i</span> th shadow element and its ending index conditioned on the  <span class="math">i - 1</span>  previous shadow elements in  <span class="math">w</span> . Next we define  <span class="math">H = (X,Y)</span>  by defining an independently distributed random variable  <span class="math">Y</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf {P} _ {Y \\mid X} (\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x) = \\mathsf {P} _ {Z _ {[ k + 1, \\ell ]} \\mid Z _ {[ k ]}} (\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x). \\tag {13}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">The random variable <span class="math">Y</span> represents the sampling of a completion of a grafting sequence starting with <span class="math">x</span>. Finally, we define <span class="math">K=\\#(X)</span>, i.e., <span class="math">K</span> is the index of what we expect to be the last element of the <span class="math">i</span>th element of the shadow sequence.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By assumption <span class="math">\\Pr\\left[\\rho(H)=1\\right]\\geq\\Delta</span>. Thus, if we define $\\zeta_{x}^{\\rho}=\\Pr\\left[\\rho(H)=1\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X=x\\right]<span class="math">, then from Lemma 1 we have the bound </span>\\Pr\\left[\\zeta_{X}^{\\rho}<\\alpha\\Delta\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho(H)=1\\right.\\right]\\leq\\alpha<span class="math">. If we define </span>\\theta_{x}^{\\rho}=\\Pr\\left[J_{i}=k\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho(H)=1\\wedge X=x\\right.\\right]<span class="math">, where </span>k<span class="math"> is the length of </span>x<span class="math">, then Lemma 3 implies that </span>\\Pr\\left[\\theta_{X}^{\\rho}<\\beta^{2}/\\ell\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho(H)=1\\right.\\right]\\leq 2\\beta$. The union bound finally gives</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[\\theta_{X}^{\\rho}\\geq\\alpha\\Delta\\wedge\\zeta_{X}^{\\rho}\\geq\\beta\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho(H)=1\\right.\\right]\\geq 1-\\alpha-2\\beta\\enspace,$ (14)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">which concludes the proof.</p>

    <h2 id="sec-45" class="text-2xl font-bold">6 Accepting Basis Extractor for Shadow Sequences</h2>

    <p class="text-gray-300">To construct an extractor for grafting protocols we first show that shadow sequences can be sampled. This trivially gives a basic extractor and a basic sampler of shadow sequences corresponding to the basic algorithms in <em>[12]</em>. The recursive extractor follows by syntactic changes, since it is is defined in terms of the expected value and tail bound for each recursive call and the tail bounds do not change.</p>

    <h3 id="sec-46" class="text-xl font-semibold mt-8">6.1 Shadow Sampler</h3>

    <p class="text-gray-300">Theorem 2 says that from a suitable prefix <span class="math">w_{[i]}</span> of shadow sequences we can sample a complete accepting shadow sequence <span class="math">w</span> that keeps the prefix intact, but we also need to ensure that <span class="math">w_{i+1}\\in\\mathbb{M}_{i+1}^{<em>}\\backslash\\mathsf{span}(B^{</em>})</span>, where <span class="math">B^{<em>}</span> is the shadow version of an independent set <span class="math">B\\in I_{i+1}</span>, to ensure that we end up with a basis of <span class="math">\\mathbb{M}^{</em>}</span>. This can be accomplished by sampling every grafting element at depth <span class="math">i+1</span> from <span class="math">I_{i+1}\\setminus\\mathsf{span}(B)</span> instead of from <span class="math">I_{i+1}</span>. There are at most <span class="math">\\ell</span> such elements in a sequence so the statistical distance between this modified distribution and the original is at most <span class="math">\\ell\\omega_{\\mathbb{M}_{i+1}}</span>. Theorem 2 then implies the following lemma, which is proven in Section B for completeness.</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Lemma 4</h6>

    <p class="text-gray-300">(Shadow Sampler). There exists a sampler <span class="math">\\mathcal{S}_{\\alpha_{1}}^{f,\\rho}</span> of shadow sequences such that for every grafting function <span class="math">f</span>, predicate <span class="math">\\rho</span>, and <span class="math">\\alpha_{1}\\in(0,1)</span>, and any input <span class="math">(\\mathbb{M},w_{[i]},B,\\Delta_{0})</span> such that <span class="math">\\xi_{\\rho}\\left(w_{[i]},\\Delta_{0},\\beta_{0}\\right)=1</span> with <span class="math">\\Delta_{0}&gt;\\ell\\omega_{\\mathbb{M}_{i+1}}</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the distribution of the number of calls to <span class="math">\\rho</span> is bounded by <span class="math">\\mathsf{Geo}(\\beta_{0}^{2}\\Delta_{1}^{\\prime}/\\ell)</span>, and</li>

      <li>the output <span class="math">w</span> has prefix <span class="math">w_{[i]}</span>, <span class="math">\\rho^{<em>}(w)=1</span>, and <span class="math">w_{i+1}\\in\\mathbb{M}_{i+1}\\setminus\\mathsf{span}(B^{</em>})</span>, and</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\xi_{\\rho}\\left(w_{[i+1]},\\Delta_{1},\\beta_{1}\\right)=1\\right]\\geq\\beta_{1}</span>,</p>

    <p class="text-gray-300">where <span class="math">\\Delta_{1}^{\\prime}=\\Delta_{0}-\\ell\\omega_{\\mathbb{M}_{i+1}}</span>, <span class="math">\\Delta_{1}=\\alpha\\Delta_{1}^{\\prime}</span>, and <span class="math">\\beta_{1}=\\frac{1}{3}(1-\\alpha_{1})</span>:</p>

    <p class="text-gray-300">We need to change the syntax slightly to accomodate for prefixes needed to sample correctly, but the shadow sampler makes it trivial to construct a basic sampler <span class="math">\\mathcal{S}_{\\alpha}^{f,\\rho}</span> that from an extendable prefix samples the next shadow element conditioned on acceptance. We similarly denote by <span class="math">\\mathcal{B}_{\\alpha}^{f,\\rho}</span> the basic extractor for shadow sequences that takes an input <span class="math">w_{[r-1]}</span> and invokes the shadow sampler <span class="math">d_{r}</span> times with the parameter <span class="math">\\alpha</span>, storing the new elements in an initially empty set <span class="math">B^{<em>}</span>, to find accepting a set of transcripts with the prefix <span class="math">w_{[r-1]}</span> such that their <span class="math">r</span>th elements form a basis over <span class="math">\\mathbb{M}_{r}^{</em>}</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">6.2 Accepting Basis Extractor</p>

    <p class="text-gray-300">The recursive extractor <span class="math">\\mathcal{R}_{\\kappa}[\\mathcal{R}]</span>, parametrized by a parameter <span class="math">\\kappa</span>, and making recursive calls to <span class="math">\\mathcal{R}</span>, is virtually identical to that in <em>[12]</em>, since it is defined in terms of expected values and tail bounds of a recursive call or the basic extractor. Analytically the situation is equivalent to the original analysis of the basic strategy except for three changes: (1) <span class="math">\\ell\\omega_{\\mathbb{M}_{i}}</span> replaces the subdensity <span class="math">\\omega_{\\mathbb{M}_{i}}</span>, (2) we loose a factor <span class="math">3</span> for each recursive call due to the threefold use of the union bound, and (3) the expected running time of the basic extractor increases by a factor of <span class="math">\\ell/(1-\\alpha_{r-1})^{2}</span>. Thus, if we set <span class="math">\\nu_{i}=1/\\alpha_{i}</span>, then we may simply restate the main theorem from <em>[12]</em> with these changes, but we provide a proof in Section C.</p>

    <p class="text-gray-300">We consider families of distributions <span class="math">\\mathsf{D}(s,\\Delta)</span> parametrized by <span class="math">s\\in\\mathbb{N}^{+}</span> and <span class="math">\\Delta\\in[0,1]</span>, which satisfy a tail bound of the form <span class="math">\\Pr\\left[X\\geq k\\mu_{\\mathsf{D}(s,\\Delta)}\\right]\\leq t_{s}^{a}(k)</span>, where <span class="math">X</span> is distributed according to <span class="math">\\mathsf{D}(s,\\Delta)</span> and <span class="math">\\mu_{\\mathsf{D}(s,\\Delta)}</span> is the expected value of <span class="math">\\mathsf{D}(s,\\Delta)</span>. For compound geometric distributions we have <span class="math">t_{s}^{c_{0}}(k)=e^{-(k-1-\\ln k)s}</span> from <em>[12]</em>.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Theorem 3 (Extractor).</h6>

    <p class="text-gray-300">For every <span class="math">\\nu_{1},\\ldots,\\nu_{r-1}\\in(1,\\infty)</span> with <span class="math">\\nu_{i}\\geq\\nu_{i+1}</span> there exist parameters <span class="math">\\kappa_{i}=(\\alpha_{i},\\lambda_{i})</span> such that the algorithm <span class="math">\\mathcal{X}_{\\kappa}=\\mathcal{R}_{\\kappa_{1}}[\\mathcal{R}_{\\kappa_{2}}[\\cdots\\mathcal{R}_{\\kappa_{r-2}}[\\mathcal{B}]\\cdots]]</span>, is a <span class="math">(\\epsilon_{0},\\mathsf{D}_{\\kappa}(\\Delta_{0}))</span>-accepting basis extractor for shadow matroid tree of <span class="math">\\mathbb{M}</span> where:</p>

    <p class="text-gray-300"><span class="math">\\epsilon_{0}=\\ell\\sum_{i\\in[r]}\\omega_{\\mathbb{M}_{i}}\\prod_{j\\in[i-1]}\\nu_{j}\\hskip 28.45274pt(\\text{extraction error})</span> (15) <span class="math">\\mu_{\\mathsf{D}_{0}(\\Delta_{0})}\\leq\\ell\\cdot\\frac{c_{0}\\prod_{j\\in[r]}d_{j}}{\\Delta_{0}-\\epsilon_{0}}\\hskip 56.9055pt(\\text{expected number of queries})</span> (16) <span class="math">t_{d_{1}}^{c_{0}}(k)\\leq t_{d_{1}}^{c_{0}}(k)\\quad\\text{for }k&gt;1\\enspace,\\hskip 28.45274pt\\text{(tail bound)}</span> (17)</p>

    <p class="text-gray-300">where the constant <span class="math">c_{0}</span> is defined by</p>

    <p class="text-gray-300"><span class="math">c_{0}=3^{r+1}\\frac{\\nu_{r-1}^{2}}{(\\nu_{r-1}-1)^{2}}\\prod_{i\\in[r-1]}\\frac{\\nu_{i}^{2}}{(\\nu_{i}-1)}\\cdot\\min_{k_{i}\\in(0,1)}\\left\\{\\frac{k_{i}}{h_{d_{i}}^{c_{0}}(k_{i})}\\right\\}\\enspace.</span> (18)</p>

    <h2 id="sec-49" class="text-2xl font-bold">7 Interpretation</h2>

    <p class="text-gray-300">We refer the reader to <em>[12]</em> for an in depth intuitive interpretation of the overall recursive formulas. To see that the extraction error <span class="math">\\epsilon_{0}</span> is tight up to a factor <span class="math">r</span> first recall that it upper bounds the soundness error. Then consider a protocol such that: (1) guessing the verifier message of the special sound protocol in any round is necessary to convince the verifier of a false statement, and (2) that the prover can determine if a guess is correct before the execution is continued. For such a protocol the soundness error is roughly <span class="math">\\epsilon=\\sum_{i=1}^{r}\\omega_{\\mathbb{M}_{i}}</span>. In the grafting protocol the prover may probe any round independently with <span class="math">\\ell</span> queries, so the soundness error is bounded by <span class="math">\\ell\\max_{i\\in[r]}\\{\\omega_{\\mathbb{M}_{i}}\\}\\geq\\epsilon_{0}/r</span>.</p>

    <p class="text-gray-300">When <span class="math">\\Delta_{0}\\gg\\epsilon_{0}</span> the factor <span class="math">\\ell</span> in the extraction error can be ignored and if we set <span class="math">\\nu_{i}=2</span> the running time is <span class="math">4\\cdot 3^{r+1}\\ell</span> times the running time in the interactive case. Consider a prover that effectively executes the basic special sound protocol without</p>

    <p class="text-gray-300">grafting any forks until the <span class="math">(r-2)</span>th round where it probes <span class="math">\\ell-r-3</span> round <span class="math">r-1</span> messages before completing the last round in exactly one randomly chosen partial execution. Then forking in round <span class="math">r-2</span> requires roughly <span class="math">\\ell</span> samples. Thus, the factor <span class="math">\\ell</span> is necessary and the running time is relatively tight up to a factor <span class="math">4\\cdot 3^{r+1}</span>.</p>

    <p class="text-gray-300">To summarize, our results show that for any constant <span class="math">r</span> and any <span class="math">(2r+1)</span>-message special sound protocol the application of the Fiat-Shamir heuristic comes at a cost of a factor <span class="math">\\ell</span> in extraction error and <span class="math">O\\left(\\ell\\right)</span> extraction time, respectively, but with the same type of distribution as in the interactive case. In practice the matroid subdensities can typically be decreased by a factor of <span class="math">1/\\ell</span> by a different choice of parameters for the protocol and cancel the effect on the extraction error at modest cost in efficiency. Thus, the loss of security from the application of the Fiat-Shamir heuristic in practice is typically no more than <span class="math">\\log\\ell+O\\left(1\\right)</span> bits of security which is intuitively appealing.</p>

    <h2 id="sec-50" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] N. Alon and J. H. Spencer. The Probabilistic Method, Third Edition. Wiley-Interscience series in discrete mathematics and optimization. Wiley, 2008.</li>

      <li>[2] T. Attema, R. Cramer, and L. Kohl. A compressed <span class="math">\\text{varsigma}</span>-protocol theory for lattices. In T. Malkin and C. Peikert, editors, Advances in Cryptology - CRYPTO 2021 - 41st Annual International Cryptology Conference, CRYPTO 2021, Virtual Event, August 16-20, 2021, Proceedings, Part II, volume 12826 of Lecture Notes in Computer Science, pages 549–579. Springer, 2021.</li>

      <li>[3] L. Babai. Trading group theory for randomness. In R. Sedgewick, editor, Proceedings of the 17th Annual ACM Symposium on Theory of Computing, May 6-8, 1985, Providence, Rhode Island, USA, pages 421–429. ACM, 1985.</li>

      <li>[4] M. Bellare, J. A. Garay, and T. Rabin. Fast batch verification for modular exponentiation and digital signatures. In K. Nyberg, editor, Advances in Cryptology - EUROCRYPT ’98, International Conference on the Theory and Application of Cryptographic Techniques, Espoo, Finland, May 31 - June 4, 1998, Proceeding, volume 1403 of Lecture Notes in Computer Science, pages 236–250. Springer, 1998.</li>

      <li>[5] M. Bellare and O. Goldreich. On defining proofs of knowledge. In E. F. Brickell, editor, Advances in Cryptology - CRYPTO ’92, 12th Annual International Cryptology Conference, Santa Barbara, California, USA, August 16-20, 1992, Proceedings, volume 740 of Lecture Notes in Computer Science, pages 390–420. Springer, 1992.</li>

      <li>[6] M. Bellare and P. Rogaway. Random oracles are practical: A paradigm for designing efficient protocols. In D. E. Denning, R. Pyle, R. Ganesan, R. S. Sandhu, and V. Ashby, editors, CCS ’93, Proceedings of the 1st ACM Conference on Computer and Communications Security, Fairfax, Virginia, USA, November 3-5, 1993., pages 62–73. ACM, 1993.</li>

      <li>[7] R. Cramer, I. Damgård, and B. Schoenmakers. Proofs of partial knowledge and simplified design of witness hiding protocols. In Y. Desmedt, editor, Advances in Cryptology - CRYPTO ’94, 14th Annual International Cryptology Conference, Santa Barbara, California, USA, August 21-25, 1994, Proceedings, volume 839 of Lecture Notes in Computer Science, pages 174–187. Springer, 1994.</li>

      <li>[8] A. Fiat and A. Shamir. How to prove yourself: Practical solutions to identification and signature problems. In A. M. Odlyzko, editor, Advances in Cryptology - CRYPTO ’86, Santa Barbara, California, USA, 1986, Proceedings, volume 263 of Lecture Notes in Computer Science, pages 186–194. Springer, 1986.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>O. Goldreich. Foundations of Cryptography: Basic Tools. Cambridge University Press, New York, NY, USA, 2000.</li>

      <li>S. Goldwasser, S. Micali, and C. Rackoff. The knowledge complexity of interactive proof systems. SIAM J. Comput., 18(1):186–208, 1989.</li>

      <li>C. Schnorr. Efficient signature generation by smart cards. J. Cryptology, 4(3):161–174, 1991.</li>

      <li>D. Wikström. Special soundness revisited. IACR Cryptol. ePrint Arch., 2018:1157, 2018.</li>

    </ol>

    <h2 id="sec-51" class="text-2xl font-bold">Appendix A Definitions</h2>

    <p class="text-gray-300">We recall the definitions introduced in <em>[12]</em>.</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Definition 19 (Accepting Basis).</h6>

    <p class="text-gray-300">A basis <span class="math">B</span> of a matroid tree <span class="math">\\mathbb{M}</span> is <span class="math">\\rho</span>-accepting for an <span class="math">\\mathbb{M}</span>-predicate <span class="math">\\rho</span> if <span class="math">\\rho(v)=1</span> for each path <span class="math">v</span> of maximal length in <span class="math">B</span>.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Definition 20 (Accepting Transcript Tree).</h6>

    <p class="text-gray-300">A rooted unordered directed tree <span class="math">T</span> with vertex labels <span class="math">\\ell(\\cdot)</span> is an <em>accepting transcript tree</em> for <span class="math">\\mathcal{V}</span> if every leaf has depth <span class="math">r</span> and for every path <span class="math">(u_{0},\\ldots,u_{r})</span> in <span class="math">T</span>: <span class="math">(v_{u_{0}},a_{u_{0}},\\ldots,v_{u_{r}},a_{u_{r}})</span> is accepting, where <span class="math">\\ell(u_{i})=(v_{u_{i}},a_{u_{i}})</span>.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Definition 21 (Challenge Tree).</h6>

    <p class="text-gray-300">The <em>challenge tree</em> <span class="math">\\mathbb{V}(T)</span> of an accepting transcript tree <span class="math">T</span> with vertex labels <span class="math">\\ell(\\cdot)</span> has the same nodes and vertices, but labels defined by <span class="math">\\ell^{\\prime}(u)=v</span>, where <span class="math">\\ell(u)=(v,a)</span>.</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Definition 22 (Special Soundness).</h6>

    <p class="text-gray-300">A <span class="math">(2r+1)</span>-message public coin-protocol <span class="math">(\\mathcal{P},\\mathcal{V})</span> is <span class="math">\\big{(}(\\mathbb{M}_{1},\\ldots,\\mathbb{M}_{r}),p\\big{)}</span>-special-sound for an NP relation <span class="math">\\mathsf{R}</span>, where <span class="math">\\mathbb{M}_{i}=(S_{i},I_{i})</span> is a matroid, if the <span class="math">i</span>th message of <span class="math">\\mathcal{V}</span> is chosen randomly from <span class="math">S_{i}</span>, and there exists a <em>witness extraction algorithm</em> <span class="math">\\mathcal{W}</span> that given an accepting transcript tree <span class="math">T</span> such that <span class="math">\\mathbb{V}(T)</span> is basis subtree of <span class="math">(\\{x\\},\\mathbb{M}_{1},\\ldots,\\mathbb{M}_{r})</span> outputs a witness <span class="math">w</span> such that <span class="math">(x,w)\\in\\mathsf{R}</span> in time <span class="math">p</span>.</p>

    <h2 id="sec-56" class="text-2xl font-bold">Appendix B Proof of Lemma 4</h2>

    <p class="text-gray-300">The extractor in <em>[12]</em> repeatedly samples complete lists of accepting verifier messages with a slight bias to guarantee independence properties. We intend to essentially execute the original extractor with a shadow predicate <span class="math">\\rho^{<em>}</span> over a shadow matroid tree <span class="math">\\mathbb{M}^{</em>}</span>.</p>

    <p class="text-gray-300">The original analysis assumes that the lists of verifier messages are sampled uniformly from a matroid, but what is actually necessary for the analysis to work is that they are sampled identically as in the protocol. Thus, nothing prevent us from invoking a modified extractor for our shadow matroid tree, provided that the verifier messages are sampled with the right distribution. Consider the following algorithm.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Definition 23 (Grafted Sequence Sampler).</h6>

    <p class="text-gray-300">The <em>grafted sequence sampler</em> <span class="math">\\mathsf{Z}^{f}</span> takes as input a tuple <span class="math">(\\mathbb{M},\\ell,z,b,B)</span>, where <span class="math">f</span> is a grafting function, <span class="math">\\mathbb{M}=(\\mathbb{M}_{1},\\ldots,\\mathbb{M}_{r})</span> is a matroid tree with <span class="math">\\mathbb{M}_{i}=(S_{i},I_{i})</span>, <span class="math">z\\in G_{\\mathbb{M},f,k}</span>, and <span class="math">B\\in I_{b}</span> is not a basis and proceeds as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">i=k+1,\\ldots,\\ell</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">d=\\delta_{f}(z)</span> and sample <span class="math">z_{i}</span> randomly, in <span class="math">S_{d}\\setminus\\mathsf{span}(B)</span> if <span class="math">d=b</span>, and in <span class="math">S_{d}</span> otherwise.</li>

      <li>Append <span class="math">z_{i}</span> to <span class="math">z</span>.</li>

      <li>Return <span class="math">z</span>.</li>

    </ol>

    <p class="text-gray-300">The running time of the algorithm is, apart from sampling in the complement of <span class="math">\\mathsf{span}(B)</span>, identical to executing the protocol, i.e., its running time corresponds to evaluating the predicate <span class="math">\\rho</span> if we ignore the cost of sampling verifier messages.</p>

    <p class="text-gray-300">The algorithm is used below to sample an accepting shadow sequence which has a prefix <span class="math">w_{[i-1]}</span> and we need <span class="math">w_{i}</span> to not be contained in a set <span class="math">B^{<em>}\\in I_{b}^{</em>}</span>, but at the time of sampling the grafted elements we do not know which sample from <span class="math">S_{i}</span> will determine independence in <span class="math">I_{b}^{<em>}</span>. Thus, we make sure that all grafted elements from <span class="math">S_{b}</span> that make up <span class="math">w_{i}</span> are from <span class="math">S_{b}\\setminus B</span> instead, where <span class="math">B</span> is the projection of <span class="math">B^{</em>}</span> to their middle elements. It may seem that this approach introduces an unnecessarily large error in the distribution of the output, i.e., roughly <span class="math">\\ell\\omega_{\\mathbb{M}_{k}}</span> instead of <span class="math">\\omega_{\\mathbb{M}_{k}}</span>, but this seems unavoidable. Next we use the grafted sequence sampler to implement a shadow sampler.</p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Definition 24 (Shadow Sampler).</h6>

    <p class="text-gray-300">The <em>shadow sampler</em> algorithm <span class="math">\\mathsf{W}^{f,\\rho}</span>, where <span class="math">f</span> is a grafting function and <span class="math">\\rho</span> is a predicate, takes as input a tuple <span class="math">(\\mathbb{M},\\ell,w_{[i]},B)</span>, where <span class="math">\\mathbb{M}=(\\mathbb{M}_{0},\\ldots,\\mathbb{M}_{r})</span> is a matroid tree, <span class="math">\\rho:G_{\\mathbb{M},f,\\ell}\\to\\{0,1\\}</span>, <span class="math">w_{[i]}</span> is a prefix of a shadow sequence corresponding to a grafted sequence <span class="math">z_{[k]}\\in G_{\\mathbb{M},f,k}</span>, and <span class="math">B\\in I_{i+1}</span> is not a basis. Repeat:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">z=\\mathsf{Z}^{f}(\\mathbb{M},\\ell,z_{[k]},i+1,B)</span> and set <span class="math">j=\\iota_{f}(z)</span> and <span class="math">w^{\\prime}=\\sigma_{f}(z)</span>.</li>

      <li>If <span class="math">\\rho(z)=1</span> and <span class="math">j_{i}=k</span>, then return <span class="math">w^{\\prime}</span>.</li>

    </ol>

    <p class="text-gray-300">Let <span class="math">z</span> be the grafted sequence sampled by <span class="math">\\mathsf{W}^{f,\\rho}</span> such that <span class="math">w^{\\prime}=\\sigma_{f}(z)</span> is returned, and set <span class="math">j=\\iota_{f}(z)</span>. By construction <span class="math">w_{[i]}</span> is a prefix of <span class="math">w^{\\prime}</span> viewed as grafted sequences and it only returns if <span class="math">j_{i}=k</span>. Thus, Lemma 2 implies that <span class="math">w_{[i]}^{\\prime}=w_{[i]}</span>. Furthermore, <span class="math">\\mathsf{W}^{f,\\rho}</span> only returns if <span class="math">\\rho(z)=1</span> which implies that <span class="math">\\rho^{<em>}(w^{\\prime})=1</span>. Finally, every element from <span class="math">S_{i+1}</span> is sampled from the subset <span class="math">S_{i+1}\\setminus B</span>, which implies that <span class="math">w_{i+1}\\in S_{i+1}^{</em>}\\setminus B^{*}</span>. This proves the first claim.</p>

    <p class="text-gray-300">If <span class="math">\\xi_{\\rho}(w_{[i]},\\Delta_{0},\\beta_{0})=1</span>, then in each iteration the probability of returning is at least <span class="math">\\beta_{0}^{2}\\Delta_{0}/\\ell</span>. Thus, the distribution of the number of calls to <span class="math">\\rho</span> is bounded according to the second claim. The third claim follows directly from Theorem 2.</p>

    <h2 id="sec-59" class="text-2xl font-bold">Appendix C Proof of Theorem 3</h2>

    <p class="text-gray-300">We now have the subroutines needed to derive a recursive extractor from the construction in <em>[12]</em> almost by syntactic changes. The only essential difference is that all algorithms need the complete prefix of a partial shadow sequence as input to sample completions with the right distribution.</p>

    <p class="text-gray-300">We need to modify the notion of an accepting basis extractor to allow for the additional parameter <span class="math">\\ell</span> and the parameter <span class="math">\\beta</span> from Theorem 2.</p>

    <p class="text-gray-300">Definition 25 (Accepting Basis Extractor). A probabilistic polynomial time algorithm <span class="math">\\mathcal{X}_{\\kappa}</span> parametrized by <span class="math">\\kappa \\in \\{0,1\\}^<em></span> is a <span class="math">(\\epsilon_{\\kappa},\\mathsf{D}_{\\kappa}^{\\ell}(\\varDelta,\\beta))</span>-accepting basis extractor with extraction error <span class="math">\\epsilon_{\\kappa}</span> for the matroid tree <span class="math">\\mathbb{M}&#x27; = (\\{w_{[i]}\\},\\mathbb{M}_{i + 1}^{</em>},\\ldots ,\\mathbb{M}_r^*)</span>, where <span class="math">\\mathsf{D}_{\\kappa}^{\\ell}(\\varDelta,\\beta)</span> for fixed <span class="math">\\kappa</span> is a family of distributions on <span class="math">\\mathbb{N}</span> parametrized by <span class="math">\\ell \\in \\mathbb{N}</span>, <span class="math">\\varDelta\\in[0,1]</span>, <span class="math">\\beta\\in(0,1)</span>, if for every grafting function <span class="math">f</span> and predicate <span class="math">\\rho :G_{\\mathbb{M},f,\\ell}\\to \\{0,1\\}</span> the following holds.</p>

    <p class="text-gray-300">If <span class="math">\\Delta_i &amp;gt; \\epsilon_\\kappa, \\beta_i &amp;gt; 0</span>, and <span class="math">\\xi_\\rho(w_{[i]},\\Delta_i,\\beta_i) = 1</span>, then <span class="math">\\mathcal{X}_{\\kappa}^{f,\\rho}(\\mathbb{M},\\ell ,w_{[i]},\\Delta_i,\\beta_i)</span> outputs a <span class="math">\\rho</span>-accepting basis of <span class="math">\\mathbb{M}&#x27;</span>, where the distribution of the number of <span class="math">\\rho(\\cdot)</span>-queries is bounded by <span class="math">\\mathsf{D}_{\\kappa}^{\\ell}(\\Delta_i,\\beta_i)</span>.</p>

    <p class="text-gray-300">Definition 26 (Recursive Extractor). Let <span class="math">\\mathbb{M} = (\\mathbb{M}_1, \\ldots, \\mathbb{M}_r)</span> be a matroid tree and assume that <span class="math">\\mathcal{R}</span> is a <span class="math">(\\epsilon_i, \\mathsf{D}_i^\\ell(\\Delta, \\beta))</span>-accepting basis extractor for matroid trees of the form <span class="math">(\\{w_{[i]}\\}, \\mathbb{M}_{i+1}^<em>, \\ldots, \\mathbb{M}_r^</em>)</span>. The recursive extractor <span class="math">\\mathcal{R}_\\kappa[\\mathcal{R}]</span>, where <span class="math">\\kappa = (\\alpha_i, \\lambda_i)</span> and <span class="math">\\alpha_i, \\lambda_i \\in (0,1)</span> proceeds as follows on input <span class="math">(\\mathbb{M}, \\ell, w_{[i-1]}, \\Delta_{i-1}, \\beta_{i-1})</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">\\Delta_{i} = \\alpha_{i}(\\Delta_{i - 1} - \\ell \\omega_{\\mathbb{M}_{i}})</span>, <span class="math">\\beta_{i} = \\frac{1}{3} (1 - \\alpha_{i})</span>, <span class="math">k = k^{\\mathrm{D}_i}(\\lambda_i)</span>, and <span class="math">\\mu = \\mu_{\\mathsf{D}_i^\\ell (\\Delta_i,\\beta_i)}</span>.</li>

      <li>Set <span class="math">B^{*} = \\varnothing</span> and <span class="math">T = \\varnothing</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. While $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; d_{i}$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(a) Compute <span class="math">w = \\mathcal{S}_{\\alpha_i}^{f,\\rho}(\\mathbb{M},\\ell ,w_{[i - 1]},B^{*},\\varDelta_{i - 1},\\beta_{i - 1})</span>.</p>

    <p class="text-gray-300">(b) Extract subtree <span class="math">t = \\mathcal{R}^{f,\\rho}(\\mathbb{M},\\ell ,w_{[i]},\\Delta_i,\\beta_i)</span>, but interrupt the execution and set <span class="math">t = \\bot</span> if it attempts to make more than <span class="math">k\\mu</span> queries.</p>

    <p class="text-gray-300">(c) If <span class="math">t \\neq \\bot</span>, then set <span class="math">B^{<em>} = B^{</em>} \\cup \\{w_{i}\\}</span> and <span class="math">T = T \\cup \\{t\\}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Return the accepting basis tree <span class="math">T</span>.</li>

    </ol>

    <p class="text-gray-300">The following lemma and corollary follows mutatatis mutandi from the corresponding proof in [12], where we use indices to illustrate the similarity with the original recursive formulas.</p>

    <p class="text-gray-300">Lemma 5 (Recursive Extractor). The algorithm <span class="math">\\mathcal{R}_{\\kappa}[\\mathcal{R}]</span> is a <span class="math">(\\epsilon_{i-1}, \\mathsf{D}_{i-1}^{\\ell}(\\Delta_{i-1}, \\beta_{i-1}))</span>-accepting basis extractor, where <span class="math">\\epsilon_{i-1} = \\epsilon_i / \\alpha_i + \\ell \\omega_{\\mathbb{M}_i}</span> and</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {G} _ {\\mathrm {D} _ {i - 1} ^ {\\ell} \\left(\\Delta_ {i - 1}, \\beta_ {i - 1}\\right)} (z) = \\prod_ {i = 1} ^ {d _ {i}} \\mathcal {G} _ {\\text {G e o} \\left(\\beta_ {i} \\lambda_ {i}\\right)} \\left(\\mathcal {G} _ {\\text {G e o} \\left(\\beta_ {i - 1} ^ {2} \\Delta_ {i - 1} / \\ell\\right)} (z) z ^ {k ^ {\\mathrm {D} _ {i}} \\left(\\lambda_ {i}\\right) \\mu_ {\\mathrm {D} _ {i} ^ {\\ell} \\left(\\Delta_ {i}, \\alpha_ {i}\\right)}}\\right), \\tag {19}</span></div>

    <p class="text-gray-300">defined by <span class="math">\\beta_{i} = \\frac{1}{3} (1 - \\alpha_{i})</span> and <span class="math">\\Delta_{i} = \\alpha_{i}(\\Delta_{i - 1} - \\ell \\omega_{\\mathbb{M}_{i}})</span>.</p>

    <p class="text-gray-300">Corollary 1 (Recursive Extractor). The distribution <span class="math">\\mathsf{D}_{i - 1}^{\\ell}(\\varDelta,\\beta)</span> satisfies</p>

    <div class="my-4 text-center"><span class="math-block">\\mu_ {\\mathrm {D} _ {i - 1} ^ {\\ell} \\left(\\Delta_ {i - 1}, \\beta_ {i - 1}\\right)} = \\frac {3 d _ {i}}{(1 - \\alpha_ {i}) \\lambda_ {i}} \\left(\\frac {\\ell}{\\beta_ {i - 1} ^ {2} \\Delta_ {i}} + k ^ {\\mathrm {D} _ {i}} (\\lambda_ {i}) \\mu_ {\\mathrm {D} _ {i} ^ {\\ell} \\left(\\Delta_ {i}, \\alpha_ {i}\\right)}\\right) \\tag {20}</span></div>

    <div class="my-4 text-center"><span class="math-block">t _ {d _ {i}} ^ {\\mathrm {D} _ {i - 1}} (k) \\leq t _ {d _ {i}} ^ {\\mathrm {C G}} (k) \\quad \\text {for} k \\in (1, \\infty). \\tag {21}</span></div>

    <p class="text-gray-300">If <span class="math">\\beta_{i-1}^2 \\geq \\beta_i^2 \\alpha_i</span>, then the term <span class="math">\\ell / (\\beta_{i-1}^2 \\Delta_i)</span> can be dropped by observing that the initial sample can be reused in the recursive call and recursive calls are slightly more expensive. When <span class="math">\\beta_i = \\frac{1}{3} (1 - \\alpha_i)</span> this is always the case, since <span class="math">(1 - \\alpha_{i-1})^2 \\geq \\alpha_i (1 - \\alpha_i)^2</span> for <span class="math">\\alpha_{i-1}, \\alpha_i \\in (0, 1)</span>.</p>

    <p class="text-gray-300">Thus, the only change in the expected value compared to the basic case in [12] is a factor of three in each recursive call (and there are <span class="math">r - 1</span> levels of recursion), and that the expected value for the basic extractor is increased by a factor of <span class="math">3^{2}\\ell /(1 - \\alpha_{r - 1})^{2}</span>. Setting <span class="math">\\nu_{i} = 1 / \\alpha_{i}</span> gives the theorem.</p>

    <p class="text-gray-300">18</p>

    <p class="text-gray-300">D Grafting Prover</p>

    <p class="text-gray-300">An honest grafting prover obviously does not need the liberty to graft additional branches to an execution.</p>

    <p class="text-gray-300">Definition 27 (Grafting Prover). If <span class="math">(\\mathcal{P},\\mathcal{V})</span> is a <span class="math">(\\mathbb{M}_1,\\ldots ,\\mathbb{M}_r)</span>-special sound protocol, then on common input <span class="math">x</span>, and private input <span class="math">w</span> such that <span class="math">(x,w)\\in \\mathbb{R}</span>, the grafting prover <span class="math">\\mathsf{G}[\\mathcal{P}]</span> proceeds as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Start a simulation of <span class="math">\\mathcal{P}</span> on input <span class="math">(x, w)</span> and when it outputs a message <span class="math">a_0</span>, hand <span class="math">(0, a_0)</span> to the verifier.</li>

      <li>For <span class="math">i = 1, \\ldots, r</span>:</li>

    </ol>

    <p class="text-gray-300">(a) Wait for a message <span class="math">v_i</span> from the verifier. (b) Continue the simulation of <span class="math">\\mathcal{P}</span> on input <span class="math">v_i</span>, until it outputs a message <span class="math">a_i</span>, hand <span class="math">(i, a_i)</span> to the verifier.</p>

    <p class="text-gray-300">E Omitted Proofs</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof (Lemma 1). We have $\\operatorname{E}[1 / \\delta_X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E] = \\sum_{x \\in [X]} \\operatorname{Pr}[X = x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E] / \\delta_X = 1 / \\operatorname{Pr}[E] \\leq 1 / \\Delta<span class="math">. Markov&#x27;s inequality then implies </span>\\operatorname{Pr}[\\delta_X &lt; \\alpha \\Delta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E] = \\operatorname{Pr}[1 / \\delta_X &gt; 1 / (\\alpha \\Delta)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E] \\leq \\alpha$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">F Basic Definitions</p>

    <p class="text-gray-300">Definition 28 (Matroid). A matroid is a pair <span class="math">(S, I)</span> of a ground set <span class="math">S</span> and a set <span class="math">I \\subset 2^S</span> of independence sets such that:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">I</span> is non-empty,</li>

      <li>if <span class="math">A \\in I</span> and <span class="math">B \\subset A</span>, then <span class="math">B \\in I</span>, and</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. if <span class="math">A, B \\in I</span> and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, then there exists an element </span>a \\in A \\setminus B<span class="math"> such that </span>\\{a\\} \\cup B \\in I$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Definition 29 (Submatroid). Let <span class="math">(S, I)</span> be a matroid and <span class="math">S&#x27; \\subset S</span>. The submatroid induced by <span class="math">S&#x27;</span> is the pair <span class="math">(S&#x27;, I&#x27;)</span> defined by <span class="math">I&#x27; = I \\cap 2^{S&#x27;}</span>.</p>

    <p class="text-gray-300">Definition 30 (Basis). Let <span class="math">(S, I)</span> be a matroid. A set <span class="math">B \\in I</span> such that <span class="math">B \\cup \\{x\\} \\notin I</span> for every <span class="math">x \\in S \\setminus B</span> is a basis.</p>

    <p class="text-gray-300">Definition 31 (Rank). The rank of a matroid <span class="math">(S, I)</span> is the unique cardinality of each basis in <span class="math">I</span>.</p>

    <p class="text-gray-300">Definition 32 (Rank of Set). Let <span class="math">(S, I)</span> be a matroid and <span class="math">A \\subset S</span>. The rank <span class="math">\\operatorname{rank}(A)</span> of <span class="math">A</span> is the rank of the submatroid induced by <span class="math">A</span>.</p>

    <p class="text-gray-300">Definition 33 (Span and Flats). Let <span class="math">(S, I)</span> be a matroid and <span class="math">A \\subset S</span>. The span of <span class="math">A</span> is defined by <span class="math">\\operatorname{span}(A) = \\{x \\in S \\mid \\operatorname{rank}(A \\cup \\{x\\}) = \\operatorname{rank}(A)\\}</span> and <span class="math">A</span> is a flat if <span class="math">\\operatorname{span}(A) = A</span>.</p>

    <p class="text-gray-300">19</p>`;
---

<BaseLayout title="Special Soundness in the Random Oracle Model (2021/1265)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2021 &middot; eprint 2021/1265
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
