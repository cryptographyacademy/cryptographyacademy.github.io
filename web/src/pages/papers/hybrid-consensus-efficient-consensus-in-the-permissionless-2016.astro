---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/917';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Hybrid Consensus: Efficient Consensus in the Permissionless Model';
const AUTHORS_HTML = 'Rafael Pass, Elaine Shi';

const CONTENT = `    <p class="text-gray-300">Rafael Pass and Elaine Shi</p>

    <p class="text-gray-300">CornellTech, Cornell, Initiative for CryptoCurrency and Contracts (IC3)</p>

    <h2 id="sec-2" class="text-2xl font-bold">Abstract</h2>

    <p class="text-gray-300">Consensus, or state machine replication is a foundational building block of distributed systems and modern cryptography. Consensus in the classical, permissioned setting has been extensively studied in the 30 years of distributed systems literature. Recent developments in Bitcoin and other decentralized cryptocurrencies popularized a new form of consensus in a "permissionless" setting, where anyone can join and leave dynamically, and there is no a-priori knowledge of the consensus nodes. Despite this exciting breakthrough, today's permissionless consensus protocols, often referred to as "blockchains", are known to have terrible performance, which has resulted in heated, and at times acrimonious debates in the community. First, we show that unfortunately a performance loss is inherent for any protocol that secures against at least 1/3 corruptions in hashpower. Specifically, we formally define a new performance measure called responsiveness, and show that any responsive permissionless consensus protocol cannot tolerate 1/3 or more corruptions in hashpower. Next, we show a tightly matching upper bound. Specifically, we propose a new permissionless consensus protocol called hybrid consensus, that is responsive and secures against up to 1/3 corruptions (approximately) in hashpower. Hybrid consensus's idea is to bootstrap fast permissionless consensus by combining an inefficient blockchain protocol with a fast permissioned consensus protocol. Hybrid consensus uses the blockchain not to agree on transactions, but to agree on rotating committees which in turn execute permissioned consensus protocols to agree on transactions. Our paper is the first to give a formal treatment of how to correctly combine a proof-of-work blockchain with classical consensus to achieve a responsive permissionless consensus protocol. Our effort exposes a multitude of non-trivial technical subtleties and challenges that are crucial to the correctness of the protocol, but have been overlooked by earlier and concurrent ad-hoc approaches.</p>

    <p class="text-gray-300">*http://www.initc3.org</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">The distributed systems and cryptography literature traditionally has focused on protocols whose participants are known a priori. Bitcoin’s rapid rise to fame represents an exciting breakthrough: Bitcoin empirically demonstrated that by leveraging assumptions such as proofs-of-work, non-trivial secure applications can be built on top of a fully decentralized network where nodes join and leave freely and dynamically, and there is no pre-established trust between participants. In the remainder of the paper, we will refer to the two network settings as the permissioned setting and the permissionless setting respectively.</p>

    <p class="text-gray-300">Informally speaking, Bitcoin’s core consensus protocol, often referred to as Nakamoto consensus <em>[46]</em>, realizes a “replicated state machine” abstraction, where nodes in a permissionless network reach agreement about a set of transactions committed as well as their ordering. Since the protocol relies on chaining of blocks of transactions, it is often referred to as the “blockchain”.</p>

    <p class="text-gray-300">Achieving consensus in the traditional permissioned model turns out to be a classical distributed systems problem, and there is a long line of research that seeks to design and optimize Byzantine consensus protocols <em>[21, 25, 42]</em>. The fact that we can obtain consensus in a permissionless model (relying on proofs-of-work) was the novel contribution of Bitcoin. In a sense, Bitcoin popularized a new model of distributed systems that was rarely considered in 30 years of classical distributed systems literature.</p>

    <p class="text-gray-300">Known permissionless consensus protocols such as Bitcoin’s Nakamoto consensus <em>[46]</em>, however, come at a cost. Since identities of nodes are not known a priori, it is imperative to defend against a Sybil attack where an attacker makes up arbitrarily many identities to outvote honest nodes. The Bitcoin protocol critically relies on proofs-of-work to roughly enforce the idea of “one vote per hashpower”. Unfortunately, Bitcoin is known to have terrible performance. As <em>Croman et al. [22]</em> point out, the Bitcoin network can sustain at most 7 tx/sec, at a transaction confirmation time of 10+ min (c.f. a main-stream payment processor such as Visa handles an average rate of <span class="math">2,000</span> tx/sec, and a peak rate of <span class="math">59,000</span> tx/sec). Further, each confirmed transaction costs roughly <span class="math">1 to </span>6 if we were to amortize the network’s total electricity consumption over all transactions being confirmed — today, this cost is in some sense being subsidized by the speculators of Bitcoin.</p>

    <p class="text-gray-300">This naturally raises an important question.</p>

    <p class="text-gray-300">Is it possible to design an efficient consensus protocol in the permissionless model?</p>

    <p class="text-gray-300">We formally explore this important question in this paper.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.1 Our Results and Contributions</h3>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Understanding the limits: performance vs. security.</h4>

    <p class="text-gray-300">To understand this formally, let us first try to understand why the Nakamoto consensus protocol <em>[46]</em> (adopted by Bitcoin) is inefficient. As <em>Garay et al. [30]</em> and <em>Pass et al. [47]</em> point out, the Nakamoto consensus protocol crucially relies on a-priori knowledge of an upper bound of the network’s delay (henceforth denoted <span class="math">\\Delta</span>) to parametrize its puzzle difficulty, and the protocol’s transaction confirmation time is roughly <span class="math">O(\\lambda\\Delta)</span> to achieve <span class="math">\\exp(-\\Omega(\\lambda))</span> security failure — one way to think about this is that the block interval needs to be <span class="math">O(\\Delta)</span> to achieve security against any constant fraction of corruption (in hashpower), and one must wait for <span class="math">O(\\lambda)</span> blocks to obtain <span class="math">\\exp(-\\Omega(\\lambda))</span> security failure. Nakamoto is clearly inefficient since the a-priori parameter <span class="math">\\Delta</span> needs to be set conservatively upfront to ensure the security of the protocol; and the transaction confirmation time suffers from looseness in the estimate <span class="math">\\Delta</span>. While there are other possible metrics of efficiency, for now, we will focus on this one.</p>

    <p class="text-gray-300">Therefore, one natural question to ask is whether we can have a protocol whose transaction confirmation time depends only on the network’s actual performance, but not any a-priori known upper bound. We formally define a performance metric called <em>responsiveness</em> that captures this intuition: a protocol is said to be responsive, if its transaction confirmation time depends only on the network’s actual delay <span class="math">\\delta</span>, but not on any a-prior known upper-bound <span class="math">\\Delta</span> (or simply no a-priori upper bound is known). In particular, in practice the actual <span class="math">\\delta</span> is often (much) smaller than the upper bound <span class="math">\\Delta</span>. In this case, responsiveness will be a useful measure of performance.</p>

    <h6 id="sec-5" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">(informal.) No secure and responsive consensus protocol can tolerate <span class="math">1/3</span> or more corruptions, even when the adversary is constrained to static corruptions — and this holds in both the classical permissioned setting (even when PKI is assumed), as well as in the permissionless setting with proofs-of-work (where corruptions are stated in terms of hashpower).</p>

    <p class="text-gray-300">The bad news is that we show that no responsive consensus protocol can tolerate <span class="math">1/3</span> or more corruptions, even when the adversary is constrained and can only statically corrupt parties. This lower bound result holds both in the classical permissioned setting (even when PKI is assumed), as well as in the permissionless setting with proofs-of-work — in this setting corruptions are counted in terms of hashpower and not the number of nodes. To put this in perspective, observe that Nakamoto is not responsive, but can tolerate up to <span class="math">1/2</span> corruptions in hashpower <em>[47]</em>.</p>

    <p class="text-gray-300">The proof of this lower bound is related to the lower bound by Dwork et al. <em>[25]</em> who showed that in an asynchronous (or partially synchronous) network, no classical permissioned consensus protocol (even with PKI) can tolerate <span class="math">1/3</span> or more Byzantine corruptions. In our paper, we will show how to adapt their proof to the permissionless and proof-of-work setting, and for responsive protocols.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">A responsive protocol with (almost) optimal resilience.</h3>

    <p class="text-gray-300">The next obvious question is the following: suppose we are willing to relax the model and assume only <span class="math">&lt;1/3</span> corruptions in hashpower, can we have a responsive consensus protocol in the permissionless setting? We answer this question in the positive.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Theorem 2.</h6>

    <p class="text-gray-300">(informal.) Assume a proof-of-work random oracle. There exists a responsive permissionless consensus protocol that is secure against <span class="math">1/3-\\epsilon</span> corruptions in hashpower against a mildly adaptive adversary.</p>

    <p class="text-gray-300">To this end, we propose hybrid consensus. Hybrid consensus provides “efficiency bootstrapping” for permissionless consensus, much as the well-known hybrid encryption and OT-extension are “efficiency bootstrapping” constructions. Since classical permissioned consensus <em>[19, 15, 40, 42, 25, 21, 45]</em> has been studied and optimized for decades and have been shown to achieve <em>responsiveness</em> against <span class="math">1/3</span> corruptions, our idea is to use a slow blockchain protocol (called snailchain) such as Nakamoto consensus <em>[30, 46]</em> to bootstrap fast permissioned byzantine consensus, the end result being a scalable consensus protocol in the permissionless model. For this reason, we call our protocol “hybrid consensus”.</p>

    <p class="text-gray-300">Hybrid consensus is the first known <em>responsive</em> permissionless consensus protocol, even heuristically. We formally prove that hybrid consensus achieves security against a malicious (i.e., Byzantine) adversary with the following capabilities: 1) wields roughly or <span class="math">\\frac{1}{3}</span> fraction of the total computation power; 2) can corrupt nodes adaptively but corruptions take a while to be effective (henceforth</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">TX conf. time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Processing/tx</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">% honest</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Nakamoto [46], BitcoinNG [27]</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(λΔ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">~1/2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Fruitchain [48] (concurrent work)</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(λΔ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">~1/2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Hybrid consensus over Nakamoto</td>

            <td class="px-3 py-2 border-b border-gray-700">Opt: O(δ), Worst: O(λδ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">~3/4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Hybrid consensus over Fruitchain</td>

            <td class="px-3 py-2 border-b border-gray-700">Opt: O(δ), Worst: O(λδ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">~2/3</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Summary of our results.  <span class="math">n</span>  denotes the total number of nodes (assuming all nodes have equal hashpower);  <span class="math">\\Delta</span>  denotes a pre-determined upper-bound on the network's transmission delay;  <span class="math">\\delta</span>  denotes the actual delay of the network;  <span class="math">\\lambda</span>  is the security parameter for attaining  <span class="math">2^{-\\lambda}</span>  security failure.</p>

    <p class="text-gray-300">referred to as a mildly adaptive adversary); and 3) and can reorder messages during transmission, and delay messages up to a bound of  <span class="math">\\delta</span>  time steps.</p>

    <p class="text-gray-300">Other practical benefits. Besides providing responsiveness, hybrid consensus also brings additional benefits in practice: for smart contract applications, it lowers the cost of processing to  <span class="math">O(\\lambda)</span>  (i.e., independent of the total number of miners) while existing blockchains such as Nakamoto require that all miners execute the smart contracts. Finally, hybrid consensus can help increase the overall throughput of the consensus protocol since we expect a higher bandwidth throughput among the elected committee (in comparison with the full peer-to-peer network). Although hybrid consensus does not remove the proof-of-work, it reduces the cost per confirmed transaction by amortizing the proof-of-work cost over a higher transactional throughput.</p>

    <p class="text-gray-300">Although the idea of combining permissionless consensus and permissioned consensus has been discussed in the community (e.g., the recent work by Decker et al. [23] and the concurrent and independent work ByzCoin [37]), to the best of our knowledge, no prior work has provided a formal treatment.</p>

    <p class="text-gray-300">Technical subtleties. As our work shows, combining permissioned and permissionless protocols is non-trivial both in terms of construction and in terms of proving security. Our endeavor reveals numerous subtleties that could have been easily overlooked without a formal treatment: e.g., how to defend against selfish mining and achieve optimal resilience; how to rely on an on-chain stamping technique to defend against retroactive committee corruptions; how to deal with an adversarial selective opening of the committees; how to correctly handle committee switchover to ensure compositional security when multiple classical BFT instances can be running concurrently over short windows during the switchover.</p>

    <p class="text-gray-300">Comparison with closely related works. In comparison, the prior work by Decker et al. [23] and the concurrent work Byzcoin [37] take a heuristic approach towards security: upon close examination, these works appear to have neglected one or more of the above subtleties (and additional ones). First, both works [23,37] claim to attain optimal resilience (i.e., tolerating 1/3 corruption), but their claim is incorrect — since these works use Nakamoto as the underlying snailchain, due to a well-known selfish mining attack [28], they can at best tolerate 1/4 corruption absent non-trivial</p>

    <p class="text-gray-300">changes to their protocol. Besides this notable issue, there are additional apparent vulnerabilities with the Byzcoin protocol <em>[37]</em>: for example, their protocol does not remove trailing blocks in committee election, and thus there may not be agreement on the committee — this can harm the consistency and/or liveness of their protocol (these vulnerabilities of Byzcoin were also independently observed by others <em>[1]</em>). Indeed, since Byzcoin <em>[37]</em> was published in Usenix Security’16, the authors themselves have acknowledged some of these vulnerabilities in subsequent blog posts <em>[3, 4]</em>. Notably, in their most recent blog <em>[4]</em>, they cite our paper as a potential solution for achieving optimal resilience — however, thus far they still do not provide a formally correct protocol. Since their work seems to have neglected multiple subtleties that our effort has exposed, it is not clear what security guarantees they provide or in what security model their protocol gives any guarantees at all.</p>

    <p class="text-gray-300">Therefore, our work is distinct in that we provide the first provably correct approach for combining proof-of-work blockchains and classical consensus to achieve responsiveness.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">1.3 Paper Organization</h3>

    <p class="text-gray-300">Our formal treatment is a rather significant endeavor (and necessary as argued above) — thus for readability, we first present a semi-formal technical roadmap in Section 2 before we give formal definitions, protocol description, and proofs.</p>

    <h2 id="sec-10" class="text-2xl font-bold">2 Technical Roadmap</h2>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">2.1 Preliminaries and Building Blocks</h3>

    <p class="text-gray-300">In this section, we present semi-formal or informal definitions for permissionless consensus which is the abstraction that we aim to realize, as well as the building blocks we rely on. The formal definitions will be presented later in the paper.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">2.1.1 Permissionless Consensus</h4>

    <p class="text-gray-300">Our goal is to realize a state machine replication abstraction in the permissionless model — henceforth referred to as permissionless consensus.</p>

    <p class="text-gray-300">In a permissionless consensus protocol, each node outputs a LOG in every time step — this LOG represents the set of committed transactions. Two important security requirements, namely, consistency and liveness must be guaranteed with overwhelming probability.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Consistency: Consistency includes the following:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Common prefix. Suppose that an honest node <span class="math">i</span> outputs LOG to <span class="math">\\mathcal{Z}</span> at time <span class="math">t</span>, and an honest node <span class="math">j</span> (same or different) outputs <span class="math">\\mathsf{LOG^{\\prime}}</span> to <span class="math">\\mathcal{Z}</span> at time <span class="math">t^{\\prime}</span>, it holds that either <span class="math">\\mathsf{LOG}\\prec\\mathsf{LOG^{\\prime}}</span> or <span class="math">\\mathsf{LOG^{\\prime}}\\prec\\mathsf{LOG}</span>. Here the relation <span class="math">\\prec</span> means “is a prefix of”. By convention we assume that <span class="math">\\emptyset\\prec x</span> and <span class="math">x\\prec x</span> for any <span class="math">x</span>.</li>

      <li>Self-consistency. Suppose that a node <span class="math">i</span> is honest at time <span class="math">t</span> and <span class="math">t^{\\prime}\\geq t</span>, and outputs <span class="math">\\mathsf{LOG}</span> and <span class="math">\\mathsf{LOG^{\\prime}}</span> at times <span class="math">t</span> and <span class="math">t^{\\prime}</span> respectively, it holds that <span class="math">\\mathsf{LOG}\\prec\\mathsf{LOG^{\\prime}}</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Liveness</em>: Suppose that transactions <span class="math">\\mathsf{TXs}</span> is input to an honest node at time <span class="math">t\\geq T_{\\text{warmup}}</span>. Then, if any node that is honest at time <span class="math">t^{\\prime}\\geq t+T_{\\text{confirm}}</span> outputs <span class="math">\\mathsf{LOG}</span> at time <span class="math">t^{\\prime}</span>, it holds that <span class="math">\\mathsf{TXs}\\subseteq\\mathsf{LOG}</span>.</li>

    </ul>

    <p class="text-gray-300">Intuitively, liveness says that transactions get included in honest nodes’ <span class="math">\\mathsf{LOG}</span>s within <span class="math">T_{\\text{confirm}}</span> time. There are two liveness parameters <span class="math">T_{\\text{confirm}}</span> and <span class="math">T_{\\text{warmup}}</span>. <span class="math">T_{\\text{warmup}}</span> is the protocol’s warmup time; and <span class="math">T_{\\text{confirm}}</span> is the maximum wait time for a transaction (proposed after <span class="math">T_{\\text{warmup}}</span>) to be confirmed.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">2.1.2 Blockchains</h4>

    <p class="text-gray-300">Hybrid consensus relies on a proof-of-work blockchain (henceforth referred to as a snailchain) as a building block. A proof-of-work blockchain can be regarded as a special case of a permissionless consensus protocol — in fact, we will formally show this in the full version of our paper. The formal abstractions for blockchains were proposed by <em>Garay et al. [30]</em> and <em>Pass et al. [47]</em>. We provide a semi-formal definition of blockchains in this section while deferring the formal definitions to later sections. Imprecisely speaking, a snailchain satisfies the following properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Consistency</em>. All honest nodes’ chains (at any time) agree with each other except for the trailing <span class="math">\\lambda</span> blocks where <span class="math">\\lambda</span> is the security parameter. Further, a node’s chain agrees with its future self.</li>

      <li><em>Chain quality</em>. Among any consecutive <span class="math">\\lambda</span> blocks in an honest node’s chain, a sufficient fraction of the blocks are mined by honest miners.</li>

      <li><em>Chain growth</em>. Honest nodes’ chains grow at a steady rate, neither too fast nor too slow.</li>

    </ul>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">2.1.3 Permissioned BFT</h4>

    <p class="text-gray-300">Permissioned BFT protocols have been extensively studied in the classical distributed systems literature. Typically, known permissioned BFT <em>[21, 25, 42]</em> satisfy exactly the same consistency and liveness guarantees as defined earlier — but here for the permissioned setting.</p>

    <p class="text-gray-300">Hybrid consensus will consume a permissioned BFT protocol as a building block. In turns out that in our context, an interesting technical subtlety arises in formalizing the abstractions required of the permissioned BFT. A property-based security definition (as is customarily done in the distributed systems literature) turns out to be insufficient due to a <em>selective opening</em> attack. In particular, the adversary is allowed to first look at nodes’ public keys, and then adaptively influence the way the committee is chosen. In Section 4.2, we argue that there exists a (somewhat contrived) permissioned BFT protocol that is provably secure under property-based definitions, but would be completely broken if subject to adversarial selective opening.</p>

    <p class="text-gray-300">As a result, we define a strengthened security notion for our underlying permissioned BFT building block. Not only do we require that the aforementioned consistency and liveness properties be satisfied with overwhelming probability, we need the following stronger statement:</p>

    <p class="text-gray-300">There exists a p.p.t. reduction <span class="math">\\mathcal{B}</span> such that given any p.p.t. adversary that can break the BFT’s security properties over any set of public keys, the reduction <span class="math">\\mathcal{B}</span> which makes blackbox calls to this adversary can forge a signature on behalf of an honest party.</p>

    <p class="text-gray-300">Later in the paper, we will formalize the above notion and additionally show how to realize this abstraction by augmenting the PBFT algorithm <em>[21]</em>.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">2.1.4 Execution Model</h4>

    <p class="text-gray-300">We consider an open enrollment network with a proof-of-work oracle that is modelled a random oracle as in earlier works <em>[30, 47]</em>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Network assumptions. We assume a partially synchronous model, where any message sent by an honest node is guaranteed to arrive at all honest nodes within <span class="math">\\delta</span> time steps. The adversary is allowed to reorder messages subject to the above constraints.</p>

    <p class="text-gray-300">Our protocol needs to know a possibly loose upper bound of <span class="math">\\delta</span> to parametrize the scheme (in particular, to parametrize the puzzle difficulty of the underlying snailchain). We henceforth use the notation <span class="math">\\Delta</span> to denote this pre-determined upper bound. Our protocol achieves responsiveness: even though we use the a-priori upper bound <span class="math">\\Delta</span> as an input parameter, our protocol achieves transaction confirmation time that depends on the network’s actual delay <span class="math">\\delta</span>, not the possibly loose upper bound <span class="math">\\Delta</span>. This requirement makes our setting fundamentally different than the synchronous model — since if the protocol simply takes <span class="math">\\Delta</span> time steps to be a synchronous round, the protocol would not be responsive.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">Mildly adaptive corruption.</h4>

    <p class="text-gray-300">Although we allow the adversary to adaptively decide which nodes to corrupt, corruption does not take place instantly. In our model, when the adversary issues a “target corrupt” instruction to a node, it takes <span class="math">\\tau</span> time for the node to actually become corrupt (where <span class="math">\\tau</span> will be parametrized later in the full version). Once a node actually becomes corrupt, the adversary can kill the node. Finally, new nodes can spawn at any time.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">Admissible parameters.</h4>

    <p class="text-gray-300">Henceforth we will assume that the underlying blockchain chooses a suitable difficulty parameter, such that the expected inter-block time is a suitable constant fraction larger than the network delay between honest nodes. We formalize these admissibility requirements later in the paper.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">2.2 The Hybrid Consensus Protocol: Overview</h3>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">Underlying snailchain.</h4>

    <p class="text-gray-300">We build atop of an underlying blockchain protocol (denoted snailchain) whose formal abstractions were defined by <em>Garay et al. [30]</em> and <em>Pass et al. [47]</em>. There are two possible realizations of such a snailchain abstraction, the original Nakamoto consensus <em>[46, 30, 47]</em>, and the more recent <em>Fruitchain [48]</em> protocol. For conceptual simplicity, in our exposition, we will assume that Nakamoto is the underlying snailchain. However, as we explain later, using Nakamoto as the snailchain allows us to secure against <span class="math">1/4-\\epsilon</span> corruption (in hashpower).</p>

    <p class="text-gray-300"><em>Fruitchain [48]</em> realizes the same abstraction as the Nakamoto snailchain— however, as Fruitchain provably secures against the selfish-mining attack, it achieves (almost) ideal chain quality. As we argue later, if we instead adopt Fruitchain as a drop-in replacement of the underlying snailchain, we can defend against <span class="math">1/3-\\epsilon</span> corruption (in hashpower) for an arbitrarily small constant <span class="math">\\epsilon</span>, thus achieving (almost) optimal resilience. Incidentally, this also demonstrates the compelling advantage of modular protocol design and composition.</p>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">2.2.1 Warmup: Static Committee</h4>

    <p class="text-gray-300">Fundamentally, a blockchain such as Nakamoto consensus (henceforth denoted snailchain) relies on proofs-of-work puzzles such that nodes can establish Sybil-resilient identities. Our first idea is to leverage snailchain to elect a static committee. To do this, honest nodes run the blockchain for <span class="math">\\mathsf{csize}+\\lambda</span> blocks where <span class="math">\\mathsf{csize}=\\Theta(\\lambda)</span> denotes the targeted committee size, and <span class="math">\\lambda</span> denotes a security parameter. At this moment, an honest node would remove the trailing, unstablized <span class="math">\\lambda</span> blocks from its local chain, and call the miners of the first <span class="math">\\mathsf{csize}</span> blocks the BFT committee.</p>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">Roughly speaking, such a protocol can be proven secure under a static corruption model due to the following.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Due to the consistency property of snailchain, all honest nodes agree on the same BFT committee. We stress that it is important to remove the trailing <span class="math">\\lambda</span> unstable blocks since otherwise honest nodes will have differing opinions on who should be the BFT committee (e.g., due to possible forks in the snailchain) — in this case we cannot guarantee the protocol secure.</li>

      <li>Due to the chain quality property of snailchain, with appropriate overall parameters, we can ensure that more than 2/3 of the committee members are honest which is sufficient to ensure the security of the permissioned BFT protocol.</li>

      <li>Due to the chain growth property of snailchain, it will not take too long for the BFT committee to form.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Finally, committee members sign any transaction committed as well as its sequence number. For any node that was not elected as a committee member, it can simply count $\\lceil\\frac{1}{3}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\texttt{csize}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rceil<span class="math"> number of signatures from committee members for deciding its own output log. Since more than 2/3 of the committee members are honest, there is at least one honest committee member if at least </span>\\lceil\\frac{1}{3}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\texttt{csize}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rceil$ vouch for the same transaction and its sequence number (i.e., its relative position within the output log). It is not hard to see that responsiveness holds for this simple protocol assuming that the BFT protocol employed is responsive.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h5 id="sec-21" class="text-base font-semibold mt-4">An interesting paradox.</h5>

    <p class="text-gray-300">Despite the apparent simplicity of this proposal, this scheme is nonetheless thought provoking. One intriguing apparent paradox is the following: since we do not rely on the snailchain to agree on transactions any more, why not stop running the snailchain after the committee is elected? Although this proposal may seem tempting initially, one quickly realizes that it is not secure. In particular, for any protocol that stops performing proofs-of-work after bounded polynomial amount of time, an adversary can always create a simulated execution that is identically distributed as the real execution, such that a node that spawns late is unable to distinguish the real execution from the simulated one. We formalize this lower bound in Section 9, and show that any secure permissionless consensus protocol must call proofs-of-work infinitely often (even for static security and the synchronous model).</p>

    <h4 id="sec-22" class="text-lg font-semibold mt-6">2.2.2 Handling Mildly Adaptive Corruption</h4>

    <h5 id="sec-23" class="text-base font-semibold mt-4">From static to mildly adaptive corruptions.</h5>

    <p class="text-gray-300">The aforementioned scheme with a static committee fails to be secure against an adaptive adversary, since the adversary can simply corrupt the committee once it is elected. Unfortunately, any scheme that down-selects from <span class="math">n</span> nodes to a <span class="math">\\lambda</span>-sized committee must be vulnerable to such adaptive attacks.</p>

    <p class="text-gray-300">In reality, however, corruption of a node is typically not instant, since it takes a while to infect an otherwise clean host. We therefore define a slightly relaxed and nonetheless realistic corruption model henceforth referred to as <span class="math">\\tau</span>-agile corruptions. In this model, roughly speaking, an adversary can issue “target corrupt” instructions to nodes; however, a node that receives “target corrupt” does not become corrupt until <span class="math">\\tau</span> time steps later.</p>

    <p class="text-gray-300">We show a positive result under this <span class="math">\\tau</span>-agile corruption model. Our key idea is to rely on rotating committees. When an honest node’s chain reaches <span class="math">R\\cdot\\texttt{csize}+\\lambda</span> in length, the <span class="math">R</span>-th committee is elected by first removing the trailing <span class="math">\\lambda</span> number of blocks, and then from this pruned chain, we elect</p>

    <p class="text-gray-300">the last csize blocks’ miners as the committee. The idea is that if an adversary targets a committee member once he mines a block (that will allow him to be included in a committee), it will be too late. With an appropriate <span class="math">\\tau</span>, by the time the node actually becomes corrupt, the committee’s term will have been ended, and the next committee will have already taken over! We leave it as an exciting open question whether fully adaptive security is possible for responsive permissionless consensus protocols.</p>

    <h5 id="sec-24" class="text-base font-semibold mt-4">Technical challenges.</h5>

    <p class="text-gray-300">While the high-level idea may seem straightforward, it turns out that defining and handling mildly adaptive corruptions introduces various technical subtleties — specifically, we need to correctly handle committee switchover in a way that guarantees concurrent composition; moreover, the possibility that an adversary can retroactively corrupt old committees also introduces new challenges.</p>

    <h5 id="sec-25" class="text-base font-semibold mt-4">Daily operations.</h5>

    <p class="text-gray-300">Henceforth for convenience, we will say that each committee serves for a day, and outputs a daily log. Our hybrid consensus protocol essentially outputs the concatenation of these daily logs. We now describe the daily operations of both committee members and non-members.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Committee members. On each day <span class="math">R</span>, the <span class="math">R</span>-th committee will run a BFT instance. A committee member will continue running the BFT protocol to commit transactions until it receives a “stop” instruction at which point a special stopping procedure is invoked. Therefore, committee members will output committed transactions gradually over time. Committed transactions will populate a node’s daily log denoted <span class="math">\\mathsf{log}_{R}</span>.</li>

    </ul>

    <p class="text-gray-300">Whenever an honest committee member adds a new transaction <span class="math">\\mathsf{tx}</span> to its <span class="math">\\mathsf{log}_{R}</span>, it will sign the tuple <span class="math">(R,\\ell,\\mathsf{tx})</span> where <span class="math">R</span> denotes the current day and <span class="math">\\ell</span> denotes the sequence number of <span class="math">\\mathsf{tx}</span> within the day. The honest committee member then gossips the signed tuple to the network.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Committee non-members. Non-members hear signed transactions from the network. Whenever a non-member hears that a tuple <span class="math">(R,\\ell,\\mathsf{tx})</span> has been signed by more than <span class="math">\\frac{1}{3}</span> fraction of <span class="math">\\mathsf{comm}_{R}</span> members, he adds the <span class="math">\\mathsf{tx}</span> to its <span class="math">\\mathsf{log}_{R}</span>:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\text{if }\\mathsf{log}_{R}[\\ell]\\text{ is not populated }:\\ \\ \\mathsf{log}_{R}[\\ell]:=\\mathsf{tx}</span></p>

    <p class="text-gray-300">Observe that a committee non-member can write to its <span class="math">\\mathsf{log}_{R}[\\ell]</span> out of order since messages may be received out of order. However, a transaction cannot be processed until all preceding transactions have been committed. Later, when we define each node’s output <span class="math">\\mathsf{LOG}</span>, we enforce that transactions are always written to <span class="math">\\mathsf{LOG}</span> in sequential order — and this can be achieved if committee non-members output the longest contiguous prefix of <span class="math">\\mathsf{log}_{R}</span> to its <span class="math">\\mathsf{LOG}</span>.</p>

    <h5 id="sec-26" class="text-base font-semibold mt-4">Committee switchover.</h5>

    <p class="text-gray-300">Whenever a node enters a new day denoted <span class="math">R+1</span>, a committee switchover is needed. Realizing committee switchover correctly without leaving gaps of inactivity in between is somewhat tricky. We propose an approach where at the beginning of each day, the new committee starts a new BFT instance, and at the same time the old committee initiates a stopping procedure of the existing instance. This would introduce several subtleties because in transient windows, two (or more) instances of BFT protocols may be concurrently executing — in these cases, nodes need to correctly linearize the outputs of the multiple instances; and we also need to ensure concurrent composition of the multiple BFT instances.</p>

    <p class="text-gray-300">Below we first describe the stopping procedure of the previous BFT instance; we then describe how nodes output a linearized log in the presence of possibly concurrently executing BFT instances.</p>

    <p class="text-gray-300">In the following, let <span class="math">R</span> be the previous day.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Member of the previous committee. If a node is a member of the <span class="math">R</span>-th committee denoted <span class="math">\\mathsf{comm}_{R}</span>, it inputs a special, signed <span class="math">\\mathsf{stop}</span> transaction to the previous <span class="math">\\mathsf{BFT}</span>— a node may run multiple <span class="math">\\mathsf{BFT}</span> virtual nodes, in which case one signed <span class="math">\\mathsf{stop}</span> transaction is input to each <span class="math">\\mathsf{BFT}</span> virtual node. When the <span class="math">\\mathsf{BFT}</span>’s log collects sufficiently many of these <span class="math">\\mathsf{stop}</span> transactions signed by distinct committee member public keys, the log is finalized and all later transactions are ignored. At this moment, we say that the previous <span class="math">\\mathsf{BFT}</span> has terminated. When the previous <span class="math">\\mathsf{BFT}</span> has terminated, a member of <span class="math">\\mathsf{comm}_{R}</span> will sign the tuple $(R,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{log}_{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> and gossip the signed tuple to the network. This allows non-members of </span>\\mathsf{comm}_{R}<span class="math"> to determine when </span>\\mathsf{log}_{R}$ ends.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Further, an honest committee member signs <span class="math">(R,\\mathsf{hash}(\\mathsf{log}_{R}))</span> where <span class="math">\\mathsf{hash}</span> is collision-resistant, and proposes the signed tuple to the underlying <span class="math">\\mathsf{snailchain}</span>— we henceforth refer to this action as <em>stamping</em>. As we explain later, timely stamping secures against an adversary that can retroactively corrupt old committee members in the future.</p>

    <p class="text-gray-300">At this point, the honest <span class="math">\\mathsf{comm}_{R}</span> member outputs “done”.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Non-member of the previous committee. If the node is not a committee member of the BFT instance for day <span class="math">R</span>, it waits for more than <span class="math">\\frac{1}{3}</span> fraction of <span class="math">\\mathsf{comm}_{R}</span> members to vouch for a tuple <span class="math">(R,\\ell)</span>. When this happens, it knows that <span class="math">\\ell</span> is the final sequence number of <span class="math">\\mathsf{log}_{R}</span>. Therefore, it simply waits for all of <span class="math">\\mathsf{log}_{R}</span>[: <span class="math">\\ell</span>] to be populated before outputting “done”.</li>

    </ul>

    <p class="text-gray-300">Whenever a node (either member of non-member of <span class="math">\\mathsf{comm}_{R}</span>) outputs “done”, its <span class="math">\\mathsf{log}_{R}</span> is said to be <em>final</em>. We note that honest <span class="math">\\mathsf{comm}_{R+1}</span> members start the new BFT instance for day <span class="math">R+1</span> as soon as they perceive the start of day <span class="math">R+1</span>, and without waiting for their <span class="math">\\mathsf{log}_{R}</span> to be final. This ensures that all <span class="math">\\mathsf{comm}_{R+1}</span> members start the new BFT instance within a short duration from each other (whereas waiting for <span class="math">\\mathsf{log}_{R}</span> to be final will incur extra drift in the start time of the next BFT instance).</p>

    <h4 id="sec-27" class="text-lg font-semibold mt-6">Output a linearized log.</h4>

    <p class="text-gray-300">Nodes need to collect their daily logs into a final log denoted <span class="math">\\mathsf{LOG}</span> — and this final log must satisfy the properties defined in Section 3.2. In particular, this final log <span class="math">\\mathsf{LOG}</span> outputs transactions in increasing order, since one may not be able to process a transaction until all preceding transactions have been accumulated. As we pointed out, committee non-members may write to its daily log denoted <span class="math">\\mathsf{log}_{R}</span> out of order. Further, when the BFT instance on the <span class="math">R</span>-th day is started, the previous BFT instance may not have fully completed, and therefore <span class="math">\\mathsf{log}_{R}</span> would have to wait for <span class="math">\\mathsf{log}_{R-1}</span> to be final.</p>

    <p class="text-gray-300">Therefore, to output the final log <span class="math">\\mathsf{LOG}</span> in order, we simply define <span class="math">\\mathsf{LOG}</span> to contain:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A maximal, consecutive sequence of daily logs <span class="math">\\mathsf{log}_{1}</span>, <span class="math">\\mathsf{log}_{2}</span>, <span class="math">\\ldots</span>, <span class="math">\\mathsf{log}_{r-1}</span> all of which must be <em>final</em>.</li>

      <li>The longest contiguous prefix of the daily log <span class="math">\\mathsf{log}_{r}^{t}</span>.</li>

    </ul>

    <h4 id="sec-28" class="text-lg font-semibold mt-6">On-chain stamping: defending against retroactive corruption.</h4>

    <p class="text-gray-300">Given long enough time, an adversary can eventually corrupt sufficiently many BFT committee members, and at this point, the adversary can forge BFT committee members’ signatures over any message of its choice. Therefore, signatures from BFT committee members are of no worth after a long enough time. Under the possibility of such retroactive attacks, nodes that spawn late cannot rely on counting committee members’ signatures for deciding logs that are too ancient.</p>

    <p class="text-gray-300">To address this challenge, we rely on an <em>on-chain stamping</em> technique. When honest BFT committee members terminate their BFT instances, they would sign a hash of the daily log and propose the tuple as a transaction to the underlying <span class="math">\\mathsf{snailchain}</span>. We prove that under appropriate</p>

    <p class="text-gray-300">parameter choices, sufficiently many honest BFT committee members’ daily log hashes get stamped on snailchain in a timely manner (in particular before the nodes actually become corrupt). In this way, nodes who spawn late can recover the correct hash of past daily logs from the underlying snailchain (instead of counting signatures from ancient committee members who may by then be corrupt). We stress that the on-chain stamping is only for late-joining nodes to recover historical daily logs. Transaction confirmation online requires only counting signatures from the present committee, and need not wait for the on-chain stamping to take place.</p>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">2.2.3 Chain Quality and Resilience</h4>

    <p class="text-gray-300">It would be ideal if mining were a random lottery, where for each block, nature draws a winner at random. If this were indeed the case, we could achieve perfect chain quality, i.e., roughly <span class="math">1-\\alpha</span> chain quality if <span class="math">\\alpha</span> fraction of nodes are corrupt. Unfortunately, several previous works <em>[28, 30, 47]</em> have shown that Nakamoto consensus cannot be thought of as a perfect lottery due to a selfish mining attack. When honest nodes mine a block, they announce the block immediately, but corrupt nodes need not follow this rule. In a selfish-mining attack, roughly speaking, when corrupt nodes mine a block <span class="math">B^{<em>}</span> off the currently longest chain, they withhold the block <span class="math">B^{</em>}</span> from the public and continue to mine on its own private fork. If at some point honest nodes happen to mine a new block <span class="math">B</span> off chain, at this moment the adversary immediately releases the block <span class="math">B^{<em>}</span>, and combined with a network rushing attack, the block <span class="math">B^{</em>}</span> will get to other nodes more quickly than <span class="math">B</span>. In this manner, the adversary has successfully erased the work of honest nodes — and in fact every time corrupt nodes mine a block, they have an opportunity to erase an honest node’s block. Consequently, Nakamoto consensus would require roughly 3/4 overall honest to achieve 2/3-chain quality (and 2/3-chain quality is needed to ensure that 2/3 of the BFT committee are honest) — in fact, this is also the reason why previous works (Decker et al. <em>[23]</em> and Byzcoin <em>[37]</em>) that claim to achieve optimal resilience were incorrect.</p>

    <p class="text-gray-300">The loss of resilience arising from chain quality loss can be mostly avoided, if instead of Nakamoto consensus, we adopt Fruitchain <em>[48]</em> as the underlying blockchain protocol. As shown by Pass and Shi <em>[48]</em>, Fruitchain provably defends against such a selfish-mining attack, and therefore attains almost perfect chain quality, i.e., it achieves roughly <span class="math">(1-\\alpha)</span>-chain quality with any <span class="math">\\alpha&lt;1/2</span> corruption under typical parametrizations. Therefore, hybrid consensus over Fruitchain requires only 2/3 overall honest hashpower (approximately) to achieve security.</p>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">2.2.4 Modular Protocol Composition and Formal Reasoning</h4>

    <p class="text-gray-300">To aid formal reasoning and presentation, our protocols are described through a modular composition approach.</p>

    <h5 id="sec-31" class="text-base font-semibold mt-4">Daily offchain consensus.</h5>

    <p class="text-gray-300">We first construct an intermediate abstraction called DailyBFT which describes what committee members and non-members do respectively to agree on each day’s daily log. Our hybrid consensus protocol will fork one instance of DailyBFT[<span class="math">R</span>] for each day where <span class="math">R</span> is the day number as well as the unique session identifier for the DailyBFT instance. Hybrid consensus then concatenates the daily logs output by these DailyBFT instances.</p>

    <p class="text-gray-300">In a DailyBFT instance, each elected committee member spawns one or more BFT virtual nodes, depending on how many of its public keys were included in the committee. If a node has not been elected as the committee, it would count signatures from committee members to decide its daily log.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Variable</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Meaning</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">tx</td>

            <td class="px-3 py-2 border-b border-gray-700">a transaction</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">l</td>

            <td class="px-3 py-2 border-b border-gray-700">sequence number of a transaction within each BFT instance</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">LOG</td>

            <td class="px-3 py-2 border-b border-gray-700">the totally ordered log each node outputs, LOG is always populated in order</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">log</td>

            <td class="px-3 py-2 border-b border-gray-700">log of one BFT instance, referred to as daily log</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">log[l : l']</td>

            <td class="px-3 py-2 border-b border-gray-700">transactions numbered l to l' in log</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">log[: l]</td>

            <td class="px-3 py-2 border-b border-gray-700">log[1 : l]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">λ</td>

            <td class="px-3 py-2 border-b border-gray-700">security parameter</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">α</td>

            <td class="px-3 py-2 border-b border-gray-700">adversary's fraction of hashpower</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">δ</td>

            <td class="px-3 py-2 border-b border-gray-700">network's maximum actual delay</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Δ</td>

            <td class="px-3 py-2 border-b border-gray-700">a-priori upper bound of the network's delay (typically loose)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">csize</td>

            <td class="px-3 py-2 border-b border-gray-700">committee size, our protocol sets csize := λ</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">th</td>

            <td class="px-3 py-2 border-b border-gray-700">th := [csize/3], a threshold</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">lower(R), upper(R)</td>

            <td class="px-3 py-2 border-b border-gray-700">lower(R) := (R-1)csize + 1, upper(R) := R·csize</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">chain</td>

            <td class="px-3 py-2 border-b border-gray-700">a node's local chain in the underlying snailchain protocol</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">chain[: -λ]</td>

            <td class="px-3 py-2 border-b border-gray-700">all but the last λ blocks of a node's local chain</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MinersOf(chain[s : t])</td>

            <td class="px-3 py-2 border-b border-gray-700">the public keys that mined each block in chain[s : t]. It is possible that several public keys belong to the same node.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">{msg}pk-1</td>

            <td class="px-3 py-2 border-b border-gray-700">a signed message msg, whose verification key is pk</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Tbft</td>

            <td class="px-3 py-2 border-b border-gray-700">liveness parameter of the underlying BFT scheme</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: Notations</p>

    <p class="text-gray-300">We formalize and prove the security properties of DailyBFT: Below are a few things to keep in mind when reading the detailed formalism presented in Section 5.2.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>While the lower-level BFT building block states its security properties (i.e., consistency and liveness) for committee members only, in DailyBFT, these security properties are extended to non-committee members as well.</li>

      <li>The lower-level BFT building block assumes that all committee members are spawned before the BFT instance starts. In DailyBFT, however, these security properties need to extend to committee non-members who potentially spawned later (but not too late).</li>

      <li>On the other hand, DailyBFT does not guarantee security (i.e., consistency and liveness) for nodes that join too late, since committee members may become corrupt far out in the future, at which point committee members can sign arbitrary tuples, and thus late joining nodes cannot rely on counting signatures to decide their daily logs any more. We defer it to hybrid consensus to deal with this attack, by having late joining nodes recover ancient daily logs by examining daily log hashes stamped on the snailchain.</li>

      <li>DailyBFT offers a keygen abstraction: upon every keygen query, DailyBFT generates and outputs a new miner public key pk — the hybrid consensus protocol will incorporate pk into the block being mined. Later, DailyBFT will receive input from the environment which set of pks have been selected as committee members. This is where the adversarial selective opening of committee keys is handled. The security proof of DailyBFT therefore makes use of the strong security of the BFT protocol, to argue that the BFT protocol, when run inside DailyBFT as a subprotocol,</li>

    </ul>

    <p class="text-gray-300">will respect the stated security properties including consistency and liveness — otherwise one could construct a reduction that breaks signature security.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Finally, in comparison with BFT, DailyBFT additionally implements a termination procedure that satisfies two properties, <em>timely termination</em>, and <em>termination agreement</em>. Timely termination says that the BFT protocol terminates quickly upon honest nodes receiving stop instructions. Termination agreement says that all honest nodes output identical final logs upon termination.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Termination is realized by having honest BFT virtual nodes input a special, signed stop transaction to the underlying BFT. When $\\lceil</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textsf{comm}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/3\\rceil$ stop transactions signed by distinct committee member keys have accumulated in the log, all later transactions are ignored and the log is finalized.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h5 id="sec-32" class="text-base font-semibold mt-4">Hybrid consensus.</h5>

    <p class="text-gray-300">We now describe our final product, the hybrid consensus protocol. Hybrid consensus consumes multiple instances of DailyBFT where rotating committees agree on daily logs. Hybrid consensus primarily does the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>It manages the spawning and termination of DailyBFT instances effectively using snailchain as a global clock that offers weak synchronization among honest nodes;</li>

      <li>Recall that each DailyBFT instance does not ensure security for nodes that spawn too late, since committee members can become corrupt far out in the future at which point they can sign arbitrary tuples. Therefore, hybrid consensus introduces an on-chain stamping mechanism to extend security guarantees to even nodes that spawn late. Specifically, committee members stamp their signed daily log hash onto snailchain when their BFT instance terminates. Nodes that spawn late will rely on this on-chain stamp to identify and recover ancient daily logs in the past (rather than counting off-chain signatures from committee members).</li>

    </ul>

    <h4 id="sec-33" class="text-lg font-semibold mt-6">2.2.5 Main Theorem</h4>

    <p class="text-gray-300">Below we state our main theorem: by using Fruitchain as the underlying snailchain in hybrid consensus, we obtain the first responsive permissionless consensus protocol with optimal resilience. The proof of the main theorem will be presented later in the paper.</p>

    <p class="text-gray-300">Let <span class="math">\\alpha</span> denote the adversarial fraction, let <span class="math">\\rho</span> denote the probability that a single node mines a block in each time step, let <span class="math">\\lambda</span> denote a security parameter for Hybrid Consensus, and let <span class="math">\\eta</span> be an additional parameter expected by Hybrid Consensus (such that the committee size will be chosen as <span class="math">\\frac{\\lambda}{\\eta}</span>), let <span class="math">\\kappa</span> denote a security parameter for the underlying Fruitchain protocol, we have the following theorem:</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Theorem 3 (Hybrid consensus over Fruitchain).</h6>

    <p class="text-gray-300">For any (arbitrarily small) constant <span class="math">\\epsilon&gt;0</span>, let <span class="math">\\alpha=\\frac{1}{3}-\\epsilon</span>, for every <span class="math">n,\\delta</span>, there exists a sufficiently small <span class="math">\\rho:=\\Theta(\\frac{1}{\\delta n})</span>, a suitable <span class="math">\\kappa=\\Theta(\\lambda)</span>, and constant <span class="math">\\eta&gt;0</span>, such that HybridConsensus^{λ,η} over Fruitchain with parameters <span class="math">(\\rho,\\kappa)</span>, is secure w.r.t. any p.p.t. <span class="math">(n,\\alpha,\\delta,\\tau)</span>-valid <span class="math">(\\mathcal{A},\\mathcal{Z})</span> for any suitable <span class="math">\\tau</span> such that <span class="math">\\Gamma_{\\rho,\\eta}^{\\textsf{hcfruit}}(n,\\alpha,\\delta,\\tau)=1</span> achieving</p>

    <p class="text-gray-300"><span class="math">T_{warmup}:=1.5\\lambda(1+\\frac{1}{\\eta})/(1-5\\eta)n\\rho,\\quad T_{confirm}:=O(\\lambda\\delta)</span></p>

    <p class="text-gray-300">5Formal definitions of admissible adversary will be presented in the formal sections to follow.</p>

    <p class="text-gray-300">Note that in the above theorem, the <span class="math">T_{\\text{confirm}}</span> parameter is stated for the worst-case transaction confirmation time even when under attack. In the optimistic case, hybrid consensus achieves a transaction confirmation time of <span class="math">O(\\delta)</span>. Further, although the theorem is stated in terms of the network’s actual delay <span class="math">\\delta</span>, in practice we must predetermine an upper bound estimate (denoted <span class="math">\\Delta</span>) of <span class="math">\\delta</span> to parametrize the puzzle difficulty level <span class="math">\\rho</span>. As long as <span class="math">\\Delta</span> is indeed an upper bound on <span class="math">\\delta</span>, security is guaranteed by the above theorem, and the scheme achieves responsiveness, i.e., the transaction confirmation time does not depend on the upper bound <span class="math">\\Delta</span>, but the actual network delay <span class="math">\\delta</span>. As mentioned earlier, if we choose a looser estimate <span class="math">\\Delta</span> (i.e., a greater value of <span class="math">\\Delta</span>), the scheme will then be parametrized with a more difficult puzzle — on one hand this allows us to tolerate potentially a higher fraction of corrupt nodes; on the other hand, the agility parameter <span class="math">\\tau</span> as well as the protocol’s warmup time will increase accordingly.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Remark 1 (A note on responsiveness).</h6>

    <p class="text-gray-300">It may seem counter-intuitive that since our scheme is responsive, why do we still need a-priori knowledge of <span class="math">\\Delta</span>, an upper bound of the network’s delay? In particular, can we simply choose the parameter <span class="math">\\Delta</span> to be infinity? Upon closer examination, our agility parameter <span class="math">\\tau</span> and the protocol’s warmup time <span class="math">T_{\\text{warmup}}</span> will both depend on <span class="math">\\Delta</span>. If we choose a bigger <span class="math">\\Delta</span>, the underlying snailchain would adopt a more difficult puzzle and hence tolerate a higher fraction of corrupt nodes; but on the other hand, we are trading off agility and the protocol’s warmup time.</p>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">2.3 Additional Related Work</h3>

    <p class="text-gray-300">We now review additional related work. Comparsion with most closely related work, including Decker et al. <em>[23]</em> and Byzcoin <em>[37]</em> were described earlier.</p>

    <h5 id="sec-37" class="text-base font-semibold mt-4">Scaling decentralized consensus.</h5>

    <p class="text-gray-300">The scalability of Bitcoin and decentralized, permissionless cryptocurrencies is a highly visible issue, and has resulted in heated, and at times acrimonious debates in the community <em>[22, 53]</em>. The cryptocurrency community have proposed various incremental patches to alleviate the scalability pressure in the near term, including adjusting the block size and others <em>[8, 26, 31, 32, 54]</em>.</p>

    <p class="text-gray-300">Eyal et al. propose BitcoinNG <em>[27]</em>, where a slow snailchain protocol is used to elect a single leader every epoch, and the leader is in charge of incorporating and linearizing transactions during its appointment. In essence, BitcoinNG can be viewed as pipelining block transmission by breaking it up and spreading block transmission over time — effectively reducing upper-bound on the worst-case delay <span class="math">\\Delta</span> in Nakamoto consensus. BitcoinNG still requires nodes to wait for <span class="math">\\Theta(\\lambda)</span> blocks in the underlying snailchain (referred to as key blocks in BitcoinNG) to stabilize for transactions to be confirmed where <span class="math">\\lambda</span> is the security parameter. In comparison, hybrid consensus is responsive, and the transaction confirmation time in the optimistic case is only <span class="math">O(\\delta)</span> where <span class="math">\\delta</span> is the network’s actual delay, not the a priori known upper bound <span class="math">\\Delta</span>. BitcoinNG did not give a formal treatment of their protocol, but it is conceivable that their protocol can be proven to realize a permissionless consensus abstraction.</p>

    <p class="text-gray-300">Side-chain <em>[9]</em> is another notable effort at addressing Bitcoin’s scalability painpoint. Side-chain’s idea is to support consensus protocols off the main Bitcoin blockchain, and the currency in the side chain is pegged to Bitcoin. The side-chain protocol lacks formal guarantees, and the protocol description and implementation remain somewhat incomplete.</p>

    <p class="text-gray-300">Various other approaches <em>[11, 38, 49, 50, 51, 52]</em> have been proposed recently to attain consensus in different variants of “decentralized” settings with varying trust assumptions.</p>

    <p class="text-gray-300">###</p>

    <h4 id="sec-38" class="text-lg font-semibold mt-6">Permissioned consensus.</h4>

    <p class="text-gray-300">Consensus protocols in the permissioned model have been extensively investigated by the community in the past 30 years <em>[14, 15, 21, 25, 29, 35, 39, 40, 41]</em>. These works typically consider three different models: 1) the synchronous model <em>[24]</em> where protocols proceed in rounds, and messages delivered in one round are guaranteed to arrive at the recipient at the beginning of the next round; 2) the partial synchrony model <em>[25]</em> where the network has a bounded delay parameter but the protocol does not know this delay; and 3) the asynchronous model <em>[14, 15]</em> where the network’s delay may grow unbounded.</p>

    <p class="text-gray-300">Our network model is akin to the standard notion of partial synchrony <em>[25]</em> but not the same. Although we allow the protocol to know an a-priori upper bound on the network’s delay, we aim to achieve responsiveness. We stress that any protocol that waits for the network delay and treats the delay as a synchronous round inherently cannot be responsive. If the protocol did wait for the network delay as a synchronous round, this would indeed translate to the synchronous model, however, our responsiveness requirement makes the design of protocols non-trivial in our network model.</p>

    <p class="text-gray-300">Earlier works on permissioned consensus have also considered group reconfiguration. For example, Vertical Paxos <em>[40]</em> and BFT-SMART <em>[12]</em> allow nodes to be reconfigured in a dynamic fashion. These works consider group reconfiguration for a related but somewhat different purpose. It would be interesting to investigate whether these techniques can be adapted to our setting to perform the switchover of committee members. We point out, however, that earlier group reconfiguration techniques do not prove security under the selective opening attack (in fact, most of these works do not adopt a cryptographically sound framework of reasoning). If we are to adapt these techniques, a new, cryptographically sound treatment is necessary.</p>

    <h4 id="sec-39" class="text-lg font-semibold mt-6">Distributed systems and cryptography.</h4>

    <p class="text-gray-300">Consensus and distributed systems interact closely with cryptography such as multi-party computation (MPC). On one hand, multi-party computation (MPC) essentially relies on broadcast or distributed consensus primitives to achieve consistency and potentially livenss, often referred to as guaranteed output in the MPC context. On the other hand, distributed consensus protocols often make use of cryptography to ensure security. For example, the authenticated Byzantine model <em>[24]</em> makes use of digital signatures, and cryptographers refer to this setup assumption as the public-key infrastructure <em>[16, 17, 20]</em>.</p>

    <p class="text-gray-300">On the other hand, the non-authenticated Byzantine model <em>[41]</em> in distributed systems is actually referred to as the authenticated channels model by cryptographers <em>[16, 17, 20]</em>. When protocols employ computationally secure cryptographic primitives, implicitly we assume that the network’s delay must be polynomially bounded in the security parameter (but can be an unbounded polynomial in the asynchrony case), since we cannot guarantee security for protocols that run exponentially long. When distributed consensus protocols make use of computationally secure primitives, a best practice is to rely on computational reductions to prove the security of the protocols — it has become well-understood that modeling cryptography as the most natural blackbox without careful scrutiny can be error-prone and flawed <em>[5, 6, 7, 10, 13, 33, 34, 43, 44]</em>.</p>

    <p class="text-gray-300">Our paper demonstrates such an approach where we adopt the protocol composition frameworks <em>[16, 17, 20]</em> developed by the cryptographers to reason about distributed systems protocols — we show that doing so is necessary in particular through the handling of the selective opening attack. Such issues can easily be overlooked if we did not adopt a formal, cryptographically sound framework of reasoning.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">3 Problem Definitions</p>

    <h4 id="sec-40" class="text-lg font-semibold mt-6">Strongly negligible functions.</h4>

    <p class="text-gray-300">All security failures in this paper will be expressed as (exponentially) strongly negligible functions in terms of some security parameter <span class="math">\\lambda\\in\\mathbb{N}</span>. We say that a function <span class="math">\\mathsf{negl}(\\cdot)</span> is strongly negligible, if there exist some constants <span class="math">c_{0}&gt;0,c_{1}</span>, such that for all <span class="math">\\lambda\\in\\mathbb{N}</span>, <span class="math">\\mathsf{negl}(\\lambda)\\leq\\exp(-(c_{0}\\lambda+c_{1}))</span>. In the remainder of the paper, we simply use the term negligible for simplicity, but all uses of it can be automatically replaced by strongly negligible.</p>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">3.1 Formal Model</h3>

    <h4 id="sec-42" class="text-lg font-semibold mt-6">Execution model.</h4>

    <p class="text-gray-300">We assume the following execution model:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Interactive Turing Machines</em>. We assume a standard Interactive Turing Machine (ITM) model <em>[16, 17, 20]</em> often adopted in the cryptography literature (but augmented with proof-of-work as explained later). There is an underlying, global clock that increments over time; each clock tick is referred to as an <em>atomic time step</em>.</li>

    </ul>

    <p class="text-gray-300">Nodes can perform unbounded polynomial amount of computation in each atomic time step, as well as send and receive polynomially many messages. Although not explicitly noted in the paper, nodes receive inputs from an environment <span class="math">\\mathcal{Z}</span> and send their outputs to an environment.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Proof-of-work</em>. We assume that there is a random oracle denoted by a pair <span class="math">(\\mathsf{H},\\mathsf{H.ver})</span>. In each atomic time step, each node can make at most one <span class="math">\\mathsf{H}</span> oracle query, but an unbounded (polynomial) number of <span class="math">\\mathsf{H.ver}</span> queries. If there are multiple instances of the blockchain protocol, we assume that each protocol instance has its own independent random oracle. The environment cannot directly query the random oracle, but can query the random oracle through the help of the adversary.</li>

      <li><em>Corruption</em>. At any point of time, the environment <span class="math">\\mathcal{Z}</span> can communicate with corrupt nodes in arbitrary manners. This also implies that the environment can see the internal state of corrupt nodes. Corrupt nodes can deviate from the prescribed protocol arbitrarily, i.e., exhibit byzantine faults. All corrupt nodes are controlled by a probabilistic polynomial-time adversary denoted <span class="math">\\mathcal{A}</span>, and the adversary can see the internal states of corrupt nodes.</li>

    </ul>

    <p class="text-gray-300">For honest nodes, the environment cannot observe their internal state, but can observe any information honest nodes output to the environment by the protocol definition. Details on corruption models will be described later.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Network delivery</em>. The adversary is responsible for delivering messages between nodes. We assume that the adversary is capable of delaying or reordering messages, possibly subject to certain restrictions as described below.</li>

    </ul>

    <h4 id="sec-43" class="text-lg font-semibold mt-6"><span class="math">\\tau</span>-agile corruption.</h4>

    <p class="text-gray-300">In standard adaptive corruption models, whenever the environment wishes to corrupt a node, the corruption takes place instantly. Our protocol is proven secure under a slightly relaxed adaptive corruption model which we refer to as <span class="math">\\tau</span>-agile corruption. Roughly speaking, <span class="math">\\tau</span>-agile corruption says that it takes a short while for the environment to actually corrupt a node. More formally, the environment is allowed to corrupt and spawn new nodes according to the following procedures:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Delayed corruption</em>. We assume that the environment can adaptively corrupt a node but with the following restrictions. To corrupt a node <span class="math">i</span>, the environment must issue a “target corrupt”</li>

    </ul>

    <p class="text-gray-300">instruction to node <span class="math">i</span> at some point of time denoted <span class="math">t</span>. Node <span class="math">i</span> does not become corrupt immediately, but rather remains honest till <span class="math">t+\\tau</span>, and becomes corrupt at time <span class="math">t+\\tau</span> — at this point, the the corrupt node <span class="math">i</span> communicates arbitrarily with the environment and can deviate arbitrarily from the protocol.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Killing a corrupt node. Once a node actually becomes corrupt, the environment can issue a “kill” instruction to kill the node. A killed node is no longer live. The environment cannot kill honest nodes directly without corrupting them first.</li>

      <li>Spawning new nodes. The environment is also allowed to spawn fresh nodes, either honest or corrupt ones. A node spawned at time <span class="math">t_{\\text{spawn}}</span> is considered live at time <span class="math">t_{\\text{spawn}}</span>. Spawning a corrupt node is equivalent to increasing the hashpower of the adversary which takes place instantly. If an honest node is spawned, the environment must follow the delayed corruption procedure if it wishes to corrupt this node later. An honest, newly spawned node starts running the main protocol.</li>

    </ul>

    <p class="text-gray-300">We say that a node (that has been spawned and has not been killed) can be in three mutually exclusive states:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Intact: An honest node that has not received a “target corrupt” instruction.</li>

      <li>Pre-corrupt: An honest node that has received a “target corrupt” instruction, but has not become corrupt yet.</li>

      <li>Corrupt: A node that is either spawned to be corrupt, or spawned to be honest, but then received a “target corrupt” instruction and actually became corrupt.</li>

    </ol>

    <p class="text-gray-300">Both intact nodes and pre-corrupt nodes are considered honest.</p>

    <p class="text-gray-300">Henceforth, whenever we say that “an honest node <span class="math">i</span> performs certain actions at time <span class="math">t</span>”, we mean that the node <span class="math">i</span> is honest at time <span class="math">t</span>. For example, if we say that an honest node outputs a message to the environment <span class="math">\\mathcal{Z}</span> at time <span class="math">t</span>, we implicitly mean that the node is honest at time <span class="math">t</span> (but may become corrupt later). Alternatively, if we say that an honest node performs an action, it means that the node is honest at the time it performs the action, although it may become corrupt sometime in the future.</p>

    <h4 id="sec-44" class="text-lg font-semibold mt-6">Fully adaptive corruption and static corruption.</h4>

    <p class="text-gray-300">We note that <span class="math">0</span>-agile corruption is equivalent to the fully adaptive corrupt model where the environment <span class="math">\\mathcal{Z}</span> can corrupt nodes instantly. Under a fully adaptive corruption model, a node is intact iff it is honest.</p>

    <p class="text-gray-300">We also define static corruption in the permissionless model — static corruption is a weaker corruption model and is only used for the purpose of proving our lower bounds — note that assuming a weaker corruption model yields stronger lower bounds. We assume that in the static corruption model, environment can spawn honest or corrupt nodes at any time. However, once an honest node is spawned, the environment is unable to corrupt it later on.</p>

    <h4 id="sec-45" class="text-lg font-semibold mt-6">Gossip network model.</h4>

    <p class="text-gray-300">We assume that all messages sent by honest nodes are spread over a gossip network and can eventually be heard by all other honest nodes. For nodes that join at time <span class="math">T</span>, it will receive all messages sent by honest nodes after time <span class="math">T</span>. An honest node need not know the identities of other nodes in the network to gossip a message to all other nodes.</p>

    <p class="text-gray-300">The adversary cannot drop or modify messages by honest nodes, but is allowed to reorder or delay messages subject to certain restrictions. The adversary may selectively deliver a message to a subset but not all of the honest nodes.</p>

    <p class="text-gray-300">We assume that the identity of a message’s sender is unknown. Messages can be signed, but an honest node does not know the correspondence between public keys and physical identities of nodes.</p>

    <p class="text-gray-300">We define the following types of gossip networks which impose different restrictions on the adversary’s ability to delay and reorder messages:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

      <li>Synchronous model. In the synchronous model, messages gossiped by an honest node at time <span class="math">t</span> are guaranteed to arrive at all honest nodes, possibly out of order, in time step <span class="math">t+1</span>. Moreover, historical messages are delivered to newly spawned nodes instantly.</li>

      <li><span class="math">\\delta</span>-partially synchronous model. In a <span class="math">\\delta</span>-partially synchronous model, messages gossiped by an honest node at time <span class="math">t</span> are guaranteed to arrive at all honest nodes, possibly out of order, by time <span class="math">t+\\delta</span>. Moreover, historical messages are delivered to newly spawned nodes instantly.</li>

    </ul>

    <p class="text-gray-300">More formally, suppose an honest node gossips a message in time step <span class="math">t\\leq t^{<em>}</span>, then if a node <span class="math">i</span> is honest in time step <span class="math">t^{</em>}+\\delta</span>, then it must have received the message.</p>

    <p class="text-gray-300">Note that in practice, honest nodes can implement a historical transcript retrieval service — this way, a node can obtain a copy of the entire historical transcript when spawning a consensus instance. It is not hard to see that if any honest node remains honest and live for at least <span class="math">3\\delta</span> time, no historical transcript will be lost.</p>

    <p class="text-gray-300">As mentioned later in Section 3.2, we allow our protocol to know a possibly loose upper bound <span class="math">\\Delta</span> on the network’s delay, since the underlying snailchain must know such an upper bound for parametrizing the mining difficulty. However, we require that the protocol be responsive, i.e., its actual performance must depend only on the network’s actual <span class="math">\\delta</span> value, not the loose upper bound <span class="math">\\Delta</span>.</p>

    <h4 id="sec-46" class="text-lg font-semibold mt-6">Randomized protocol execution and probability space.</h4>

    <p class="text-gray-300">Let <span class="math">\\Pi</span> be some protocol, let <span class="math">\\mathcal{A},\\mathcal{Z}</span> be probabilistic polynomial-time (or p.p.t. for short) algorithms, and let <span class="math">\\lambda\\in\\mathbb{N}</span>. Let <span class="math">\\textsc{exec}<a href="\\mathcal{A},\\mathcal{Z},\\lambda">\\Pi</a></span> be a random variable denoting the joint view of all nodes (i.e., all their inputs, random coins, and messages received, including those from random oracles) in the above execution.</p>

    <p class="text-gray-300">Let property be a function that takes as input a fixed view and outputs either <span class="math">0</span> or <span class="math">1</span>. Throughout the paper, whenever we say that some property holds for <span class="math">\\textsc{exec}<a href="\\mathcal{A},\\mathcal{Z},\\lambda">\\Pi</a></span> with probability p, we formally mean that</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left<a href="\\mathcal{A},\\mathcal{Z},\\lambda">\\textsf{view}\\overset{\\textsf{\\</span>}}{\\leftarrow}\\textsc{exec}[\\Pi</a>:\\textsf{property}(\\textsf{view})=1\\right]=\\textsf{p}$</p>

    <p class="text-gray-300">where probability is taken over all random coins of <span class="math">\\mathcal{A}</span>, <span class="math">\\mathcal{Z}</span>, all honest nodes, and all random oracles.</p>

    <h4 id="sec-47" class="text-lg font-semibold mt-6">Compliant execution.</h4>

    <p class="text-gray-300">We often impose constraints on the adversary <span class="math">\\mathcal{A}</span> and <span class="math">\\mathcal{Z}</span> to prove security properties of protocols. We therefore define what we consider as compliant executions, in terms of constraints on the pair <span class="math">(\\mathcal{A},\\mathcal{Z})</span>.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Definition 1 (<span class="math">(n,\\delta,\\tau)</span>-valid <span class="math">(\\mathcal{A},\\mathcal{Z})</span>).</h6>

    <p class="text-gray-300">We say that the pair <span class="math">(\\mathcal{A},\\mathcal{Z})</span> is <span class="math">(n,\\delta,\\tau)</span>-valid w.r.t. protocol <span class="math">\\Pi</span> if <span class="math">\\mathcal{A}</span> and <span class="math">\\mathcal{Z}</span> are probabilistic polynomial-time algorithms such that for every <span class="math">\\lambda\\in\\mathbb{N}</span>, the following properties hold with probability <span class="math">1</span> for <span class="math">\\textsc{exec}<a href="\\mathcal{A},\\mathcal{Z},\\lambda">\\Pi</a></span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At any point of time, the number of live nodes is <span class="math">n</span>;</li>

      <li><span class="math">\\mathcal{A}</span> delays messages from honest nodes in at most <span class="math">\\delta</span> time steps;</li>

      <li>Once an honest node receives input “target corrupt” from the environment, it takes at least <span class="math">\\tau</span> time before the node becomes corrupt.</li>

    </ol>

    <p class="text-gray-300"><strong>Definition 2</strong> (<span class="math">(n, \\alpha, \\delta, \\tau)</span>-valid <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>). We say that the pair <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> is <span class="math">(n, \\alpha, \\delta, \\tau)</span>-valid w.r.t. protocol <span class="math">\\Pi</span>, such that <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> is <span class="math">(n, \\delta, \\tau)</span>-valid as per Definition 1, and moreover, for any <span class="math">\\lambda \\in \\mathbb{N}</span>, in any view in support of <span class="math">\\mathrm{exec}<a href="\\mathcal{A}, \\mathcal{Z}, \\lambda">\\Pi</a></span>, it holds that at any time, no more than <span class="math">\\alpha</span> fraction of the live nodes are either in corrupt or pre-corrupt states.</p>

    <p class="text-gray-300">Throughout the paper, although not noted explicitly, all parameters including <span class="math">n, \\alpha, \\delta</span>, and <span class="math">\\tau</span> are functions in the security parameter <span class="math">\\lambda</span>. Further, for notational simplicity, in this paper we do not explicitly define validity rules for transaction inputs. However, it is not difficult to extend our definitions to incorporate transaction validity rules like Garay et al. [30] and Pass et al. [47].</p>

    <p class="text-gray-300">Our protocols may be secure under choices of parameters including <span class="math">n, \\alpha, \\delta</span>, and <span class="math">\\tau</span> that satisfy specific constraints. We therefore define the notion of <span class="math">\\Gamma</span>-admissibility where <span class="math">\\Gamma</span> is a function that imposes constraints on parameter choices.</p>

    <p class="text-gray-300"><strong>Definition 3</strong> (<span class="math">\\Gamma</span>-admissible). Let <span class="math">\\Gamma</span> be a binary function in parameters <span class="math">n, \\alpha, \\delta, \\tau</span>. We say that a p.p.t. pair <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> is <span class="math">\\Gamma</span>-admissible w.r.t. some protocol <span class="math">\\Pi</span> iff there exists <span class="math">n, \\delta &amp;gt; 0</span> and <span class="math">\\alpha, \\tau \\geq 0</span> such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\Gamma(n, \\alpha, \\delta, \\tau) = 1</span>;</li>

      <li><span class="math">(\\mathcal{A}, \\mathcal{Z})</span> is <span class="math">(n, \\alpha, \\delta, \\tau)</span>-valid w.r.t. <span class="math">\\Pi</span> by Definition 2;</li>

    </ul>

    <h2 id="sec-49" class="text-2xl font-bold">3.2 Problem Definition: Permissionless Consensus</h2>

    <p class="text-gray-300">Our HybridConsensus protocol realizes a state machine replication abstraction in the permissionless model — henceforth we refer to this abstraction as permissionless consensus. In a permissionless consensus protocol, nodes maintain a LOG over time that is a list of transactions; and further, consistency and liveness are guaranteed. Our permissionless consensus abstraction is a variant of the “public ledger” abstraction adopted by Garay et al. [30] and Pass et al. [47]. The differences are non-essential. In particular, we essentially incorporate the transaction mempool into our abstraction, such that maintaining the transaction mempool is not left to the caller. By contrast, the public ledger abstraction by Garay et al. [30] and Pass et al. [47] leaves it to the caller to maintain a transaction mempool.</p>

    <p class="text-gray-300">More formally, a permissionless consensus satisfies the following abstractions.</p>

    <p class="text-gray-300"><strong>Inputs and outputs.</strong> The environment <span class="math">\\mathcal{Z}</span> may input a set of transactions <span class="math">\\mathsf{TXs}</span> to each honest node in every time step. In each time step, an honest node outputs to the environment <span class="math">\\mathcal{Z}</span> a totally ordered LOG of transactions (possibly empty).</p>

    <p class="text-gray-300">18</p>

    <p class="text-gray-300">.</p>

    <h4 id="sec-50" class="text-lg font-semibold mt-6">Security definitions.</h4>

    <p class="text-gray-300">Let p.p.t. algorithms <span class="math">(\\mathcal{A},\\mathcal{Z})</span> be <span class="math">(n,\\alpha,\\delta,\\tau)</span>-valid w.r.t. a permissionless consensus protocol <span class="math">\\Pi</span>. Let <span class="math">T_{\\text{warmup}}</span>, <span class="math">T_{\\text{confirm}}</span>, <span class="math">T_{\\text{bootstrap}}</span> be polynomial functions in <span class="math">\\lambda,n,\\alpha</span>, <span class="math">\\delta</span>, and <span class="math">\\Delta</span>. We say that a permissionless consensus protocol <span class="math">\\Pi</span> is secure w.r.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> with parameters (<span class="math">T_{\\text{warmup}}</span>, <span class="math">T_{\\text{confirm}}</span>, <span class="math">T_{\\text{bootstrap}}</span>), if there exists a negligible function <span class="math">\\mathsf{negl}</span> such that for every <span class="math">\\lambda\\in\\mathbb{N}</span>, with <span class="math">1-\\mathsf{negl}(\\lambda)</span> probability, the following properties hold for <span class="math">\\mathrm{exec}<a href="\\mathcal{A},\\mathcal{Z},\\lambda">\\Pi</a></span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Consistency: Consistency includes the following properties:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Common prefix. Suppose that an honest node <span class="math">i</span> outputs <span class="math">\\mathsf{LOG}</span> to <span class="math">\\mathcal{Z}</span> at time <span class="math">t</span>, and an honest node <span class="math">j</span> (same or different) outputs <span class="math">\\mathsf{LOG^{\\prime}}</span> to <span class="math">\\mathcal{Z}</span> at time <span class="math">t^{\\prime}</span>, it holds that either <span class="math">\\mathsf{LOG}\\prec\\mathsf{LOG^{\\prime}}</span> or <span class="math">\\mathsf{LOG^{\\prime}}\\prec\\mathsf{LOG}</span>. Here the relation <span class="math">\\prec</span> means “is a prefix of”. By convention we assume that <span class="math">\\emptyset\\prec x</span> and <span class="math">x\\prec x</span> for any <span class="math">x</span>.</li>

      <li>Self-consistency. Suppose that a node <span class="math">i</span> is honest at time <span class="math">t</span> and <span class="math">t^{\\prime}\\geq t</span>, and outputs <span class="math">\\mathsf{LOG}</span> and <span class="math">\\mathsf{LOG^{\\prime}}</span> at times <span class="math">t</span> and <span class="math">t^{\\prime}</span> respectively, it holds that <span class="math">\\mathsf{LOG}\\prec\\mathsf{LOG^{\\prime}}</span>.</li>

      <li>Liveness: Suppose that the environment <span class="math">\\mathcal{Z}</span> inputs <span class="math">\\mathsf{TXs}</span> to an honest node at time <span class="math">t\\geq T_{\\text{warmup}}</span>. Suppose that some node <span class="math">i</span> spawned at time <span class="math">t_{\\text{spawn}}</span> and remains honest till <span class="math">t^{\\prime}\\geq\\max(t_{\\text{spawn}}+T_{\\text{bootstrap}},t+T_{\\text{confirm}})</span>. Let <span class="math">\\mathsf{LOG}</span> be the output of node <span class="math">i</span> at time <span class="math">t^{\\prime}</span>, it holds that any <span class="math">\\mathsf{tx}\\in\\mathsf{TXs}</span> is included in <span class="math">\\mathsf{LOG}</span>.</li>

    </ul>

    <p class="text-gray-300">Intuitively, liveness says that transactions input to an honest node gets included in their <span class="math">\\mathsf{LOG}</span>s within <span class="math">T_{\\text{confirm}}</span> time. Further, <span class="math">T_{\\text{warmup}}</span> is referred to as the protocol’s warmup time.</p>

    <p class="text-gray-300">Note that the above definitions are with respect to a specific <span class="math">(\\mathcal{A},\\mathcal{Z})</span> pair. However, our main theorem later will state the security of the HybridConsensus protocol for any p.p.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> as long as they respect certain constraints.</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Remark 2.</h6>

    <p class="text-gray-300">For our hybrid consensus protocol, <span class="math">T_{\\text{bootstrap}}=0</span>, i.e., newly spawned nodes are bootstrapped instantly. Therefore we often omit writing the term <span class="math">T_{\\text{bootstrap}}=0</span> without risk of ambiguity. However, our problem definition admits a polynomial <span class="math">T_{\\text{bootstrap}}</span> since this will allow us to prove a stronger lower bound.</p>

    <h4 id="sec-52" class="text-lg font-semibold mt-6">Responsiveness.</h4>

    <p class="text-gray-300">We say that a permissionless consensus protocol is responsive if the liveness parameter <span class="math">T_{\\text{confirm}}</span> depends only on the network’s actual <span class="math">\\delta</span>, not on the loose upper bound <span class="math">\\Delta</span> that is used to parametrize the protocol.</p>

    <h2 id="sec-53" class="text-2xl font-bold">4 Building Blocks</h2>

    <h3 id="sec-54" class="text-xl font-semibold mt-8">4.1 Underlying Blockchain Protocol snailchain</h3>

    <p class="text-gray-300">Our main scheme is of an efficiency bootstrapping nature, where we bootstrap from an underlying, slow blockchain denoted snailchain to obtain a permissionless consensus protocol with fast transaction confirmation and high throughput.</p>

    <p class="text-gray-300">We assume the underlying slow consensus protocol denoted snailchain (e.g., Bitcoin’s Nakamoto consensus <em>[46]</em>) realizes a “blockchain” abstraction, which can be considered as a special-case permissionless consensus protocol as defined in Section 3.2.</p>

    <p class="text-gray-300">Abstraction.</p>

    <p class="text-gray-300">We assume that the snailchain protocol provides the following input/output abstraction.</p>

    <h4 id="sec-55" class="text-lg font-semibold mt-6">Inputs.</h4>

    <p class="text-gray-300">In each time step, the environment <span class="math">\\mathcal{Z}</span> inputs to each honest node <span class="math">(\\mathsf{recs},\\mathsf{pk})</span> where <span class="math">\\mathsf{recs}</span> denotes a set of records and <span class="math">\\mathsf{pk}</span> denotes a public key.</p>

    <h4 id="sec-56" class="text-lg font-semibold mt-6">Outputs.</h4>

    <p class="text-gray-300">In each time step, honest nodes output to the environment the following:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{chain}:=\\{(\\mathsf{recs}_{i},\\mathsf{pk}_{i})\\}_{i}</span></p>

    <h4 id="sec-57" class="text-lg font-semibold mt-6">Useful notions.</h4>

    <p class="text-gray-300">We define the following notions that will be useful later.</p>

    <h4 id="sec-58" class="text-lg font-semibold mt-6">Local chain.</h4>

    <p class="text-gray-300">In each time step, an honest node outputs to the environment some chain, for simplicity we refer to this chain as the honest node’s local chain in this time step.</p>

    <h4 id="sec-59" class="text-lg font-semibold mt-6">Intact and honest blocks.</h4>

    <p class="text-gray-300">Given chain which denotes an honest node’s local chain at some time <span class="math">t</span>, we can define whether each block in chain is intact (or honest resp.) with respect to a prefix of chain. A block <span class="math">\\mathsf{chain}[j]:=(\\mathsf{recs},\\mathsf{pk})</span> is said to be intact (or honest resp.) w.r.t. a prefix <span class="math">\\mathsf{chain}[:j^{\\prime}]</span> where <span class="math">j^{\\prime}&lt;j</span> if there exists some node <span class="math">i</span> intact (or honest resp.) at some time <span class="math">t^{\\prime}\\leq t</span>, such that 1) node <span class="math">i</span> output <span class="math">\\mathsf{chain}^{\\prime}</span> to <span class="math">\\mathcal{Z}</span> at time <span class="math">t^{\\prime}</span> such that <span class="math">\\mathsf{chain}[:j^{\\prime}]\\prec\\mathsf{chain}^{\\prime}</span>, and 2) <span class="math">\\mathcal{Z}</span> input <span class="math">(\\mathsf{recs},\\mathsf{pk})</span> to node <span class="math">i</span> at time <span class="math">t^{\\prime}+1</span>. Informally, for an honest party’s chain denoted chain, a block <span class="math">B:=\\mathsf{chain}[j]</span> is intact (or honest resp.) w.r.t. a prefix <span class="math">\\mathsf{chain}[:j^{\\prime}]</span> where <span class="math">j^{\\prime}&lt;j</span>, if earlier there is some honest node who received the block <span class="math">B</span> as input when its local chain contains the prefix <span class="math">\\mathsf{chain}[:j^{\\prime}]</span>.</p>

    <h4 id="sec-60" class="text-lg font-semibold mt-6">Security definitions.</h4>

    <p class="text-gray-300">Similar to earlier works <em>[27, 30, 36, 47]</em>, we define the following properties for a snailchain protocol. In all of the following, the probability is defined over randomness consumed by all honest nodes, the environment <span class="math">\\mathcal{Z}</span>, as well as the adversary <span class="math">\\mathcal{A}</span> in the execution.</p>

    <p class="text-gray-300">Suppose that <span class="math">(\\mathcal{A},\\mathcal{Z})</span> is <span class="math">(n,\\alpha,\\delta,\\tau)</span>-valid w.r.t. snailchain. Let <span class="math">W_{C},W_{Q},W_{G}</span> be polynomial functions in <span class="math">\\lambda</span>. Let <span class="math">Q,G,G^{\\prime}</span> be polynomial functions in <span class="math">\\lambda,n,\\alpha,\\delta</span>, and <span class="math">\\Delta</span>. We say that a snailchain protocol satisfies <span class="math">W_{C}</span>-consistency, <span class="math">(W_{Q},Q)</span>-chain quality, and <span class="math">(W_{G},G,G^{\\prime})</span>-chain growth w.r.t. to <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, if there exists a negligible function <span class="math">\\mathsf{negl}</span> such that for any <span class="math">\\lambda\\in N</span>, except with <span class="math">\\mathsf{negl}(\\lambda)</span> failure probability, the following properties hold for <span class="math">\\mathrm{exec}<a href="\\mathcal{A},\\mathcal{Z},\\lambda">\\mathsf{snailchain}</a></span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Consistency. For any node <span class="math">i</span> that is honest at time <span class="math">t</span>, and any <span class="math">j</span> (same or different) that is honest at time <span class="math">t^{\\prime}\\geq t</span>, let chain denote what node <span class="math">i</span> outputs to <span class="math">\\mathcal{Z}</span> at time <span class="math">t</span>, and let <span class="math">\\mathsf{chain}^{\\prime}</span> denote what node <span class="math">j</span> outputs to <span class="math">\\mathcal{Z}</span> at time <span class="math">t^{\\prime}</span>, it holds that</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{chain}[:-W_{C}]\\prec\\mathsf{chain}^{\\prime}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Chain quality. Let chain denote what an honest node outputs to <span class="math">\\mathcal{Z}</span> at any time <span class="math">t</span>. Then for any <span class="math">\\lambda_{1}\\geq W_{Q}(\\lambda)</span>, if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{chain}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\lambda_{1}<span class="math">, it holds that for any </span>i\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{chain}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-\\lambda_{1}<span class="math">, at least </span>\\lceil Q\\lambda_{1}\\rceil<span class="math"> number of blocks in </span>\\mathsf{chain}[i:i+\\lambda_{1}]<span class="math"> are intact w.r.t. </span>\\mathsf{chain}[:i-1]<span class="math">. In other words, at any time, among any </span>\\lambda_{1}\\geq W_{Q}(\\lambda)<span class="math"> consecutive window of blocks in an honest node’s output chain, at least </span>Q$ fraction of the blocks are intact w.r.t. the prefix of the window.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Chain growth. In every time step, the following properties hold:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Consistent length. Suppose that an honest node outputs chain at time <span class="math">t</span>. It holds that any honest node must output a chain of length at least $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{chain}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> at any </span>t^{\\prime}\\geq t+\\delta$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Therefore, intuitively, chain growth says that 1) honest nodes have roughly the same chain length, and 2) honest nodes' chains cannot grow too slowly.</p>

    <p class="text-gray-300">For convenience, we now define a derived property called <em>liveness</em>. If <span class="math">i</span> is an honest node at <span class="math">t</span>, let <span class="math">(\\mathsf{recs}_{i, - }^{t})</span> denote what the environment <span class="math">\\mathcal{Z}</span> inputs to honest node <span class="math">i</span> at time <span class="math">t</span>. Let <span class="math">\\mathsf{rec}</span> be some record. We say that <span class="math">\\mathcal{Z}</span> <em>proposes</em> <span class="math">\\mathsf{rec}</span> to node <span class="math">i</span> at time <span class="math">t</span> if <span class="math">\\mathsf{rec} \\in \\mathsf{recs}_{i}^{t}</span>.</p>

    <p class="text-gray-300">We say that a <strong>snailchain</strong> protocol satisfies liveness w.r.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> with liveness parameter <span class="math">T_{\\mathrm{snail}}</span>, if there exists a negligible function <span class="math">\\mathrm{negl}</span> such that for any <span class="math">\\lambda \\in \\mathbb{N}</span>, with <span class="math">1 - \\mathrm{negl}(\\lambda)</span> probability, the following holds for <span class="math">\\mathrm{exec}<a href="\\mathcal{A},\\mathcal{Z},\\lambda">\\mathrm{snailchain}</a></span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Liveness.</strong> Let <span class="math">\\mathsf{rec}</span> be some record. If for every honest node <span class="math">i</span>, for each <span class="math">t&#x27; = t, t + 1, \\ldots</span> the environment <span class="math">\\mathcal{Z}</span> proposes <span class="math">\\mathsf{rec}</span> unless <span class="math">\\mathsf{rec}</span> is already contained in node <span class="math">i</span>'s output <span class="math">^8</span> chain <span class="math">[: -\\lambda]</span>, then we have that at time any <span class="math">t_1 \\geq t + T_{\\mathrm{snail}}</span>, if an honest node outputs <span class="math">\\mathsf{chain}&#x27;</span>, then <span class="math">\\mathsf{rec}</span> must be included in <span class="math">\\mathsf{chain}&#x27;[: -\\lambda]</span>.</li>

    </ul>

    <p class="text-gray-300">Intuitively, liveness simply says that if the environment <span class="math">\\mathcal{Z}</span> continues to input the same record <span class="math">\\mathsf{rec}</span> to all honest nodes for <span class="math">T_{\\mathrm{snail}}</span> amount of time, then <span class="math">\\mathsf{rec}</span> will get included in all honest nodes' local chain in at most <span class="math">T_{\\mathrm{snail}}</span> time.</p>

    <p class="text-gray-300"><strong>Lemma 1 (Liveness as a derived property).</strong> For any p.p.t. algorithms <span class="math">\\mathcal{A},\\mathcal{Z}</span>, any <span class="math">Q &amp;gt; 0, G&#x27; \\geq G &amp;gt; 0</span>, any <span class="math">W_{C}, W_{Q}, W_{G}</span> such that <span class="math">W_{C}(\\lambda) + W_{Q}(\\lambda) + \\lambda \\geq W_{G}(\\lambda)</span> for all <span class="math">\\lambda</span>, if <strong>snailchain</strong> satisfies <span class="math">W_{C}</span>-consistency, <span class="math">(W_{Q}, Q)</span>-chain quality and <span class="math">(W_{G}, G, G&#x27;)</span>-chain growth w.r.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, then <strong>snailchain</strong> satisfies liveness w.r.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> with liveness parameter <span class="math">T_{\\text{snail}} = (W_{C} + W_{Q} + \\lambda) / G</span>.</p>

    <p class="text-gray-300">Note that for convenience of application later, we define a slightly modified version of liveness in comparison with Garay et al. [30], Pass et al. [47], and Fruitchain [48]. It is straightforward to see that our liveness notion is implied by those adopted in Pass et al. [47] and Fruitchain [48].</p>

    <p class="text-gray-300"><strong>Underlying snailchain is an non-responsive permissionless consensus.</strong> It is not hard to see that our underlying <strong>snailchain</strong> abstraction defined in Section 4.1 can be regarded as a special-case instantiation of a “permissionless consensus” protocol. In particular, each node’s <strong>LOG</strong> can be the ordered list of records in <strong>chain</strong> <span class="math">[: -\\lambda]</span>. Such a permissionless consensus protocol is non-responsive since we need to set the expected block interval to be <span class="math">\\Theta(\\Delta)</span> under typical parameters, where <span class="math">\\Delta</span> is an a priori upper bound on the network’s delay. Therefore <span class="math">T_{\\mathrm{confirm}} := \\Theta(\\lambda \\Delta)</span>.</p>

    <h2 id="sec-61" class="text-2xl font-bold">4.1.1 Nakamoto as the underlying snailchain</h2>

    <p class="text-gray-300">Garay et al. [30] prove that Nakamoto consensus [46] satisfies variants of the above properties assuming a fully synchronous model, i.e., messages are delivered instantly and cannot be delayed by the adversary. Pass et al. [47] strengthen these properties and prove that Nakamoto consensus satisfies them in a <span class="math">\\delta</span>-partially synchronous network under appropriate conditions on <span class="math">\\delta</span>.</p>

    <p class="text-gray-300">Below we restate the main theorem of Pass et al. [47] for the underlying <strong>snailchain</strong>. Let <span class="math">\\alpha</span> and <span class="math">\\beta</span> denote the fraction of corrupt and honest nodes respectively where <span class="math">\\alpha + \\beta = 1</span>, and let <span class="math">\\rho</span> denote the probability that a single node mines a valid block in one time step. <span class="math">\\rho</span> is closely related to the mining difficulty parameter.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">p \\coloneqq 1 - (1 - \\rho)^{\\beta n}</span> denote the probability that some honest node succeeds in mining a block in a single time step.</li>

    </ul>

    <p class="text-gray-300">8In practice, we can perform the following optimization within the Nakamoto protocol: the honest algorithm can suppress a record rec if it is already contained in the longest chain that it tries to extend.</p>

    <p class="text-gray-300">21</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">q:=\\alpha n\\rho</span> denote an upper bound on the expected number of blocks that the adversary can mine in a single time step.</li>

      <li>Let <span class="math">\\gamma:=\\frac{p}{1+\\delta p}</span> which can be thought of as a version of <span class="math">p</span> discounted by the network’s delay <span class="math">\\delta</span>.</li>

    </ul>

    <h6 id="sec-62" class="text-base font-medium mt-4">Definition 4 (Admissible parameters for snailchain <span class="math">\\Gamma_{\\rho}^{\\mathsf{snail}}</span>).</h6>

    <p class="text-gray-300">We define <span class="math">\\Gamma_{\\rho}^{\\mathsf{snail}}(n,\\alpha,\\delta,\\tau)=1</span> iff the following holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">n&gt;0</span>, <span class="math">\\delta&gt;0</span>, <span class="math">\\tau\\geq 0</span> are all polynomial functions in <span class="math">\\lambda</span>; <span class="math">\\alpha&gt;0</span> is a constant;</li>

      <li>There exists a constant <span class="math">\\eta&gt;0</span> such that <span class="math">p(1-(2\\delta+2)p)\\geq(1+\\eta)q</span>.</li>

    </ul>

    <h6 id="sec-63" class="text-base font-medium mt-4">Theorem 4 (Nakamoto as the underlying snailchain <em>[47]</em>).</h6>

    <p class="text-gray-300">For any constants <span class="math">\\eta_{0},\\eta_{1},\\eta_{2},\\eta,\\rho&gt;0</span>, let <span class="math">Q=1-(1+\\eta_{0})\\frac{q}{\\gamma}</span>, let <span class="math">G=\\gamma/(1+\\eta_{1})</span>, let <span class="math">G^{\\prime}=(1+\\eta_{2})n\\rho</span>, the Nakamoto consensus protocol <em>[46, 47]</em> (henceforth referred to as snailchain) parametrized with mining difficulty parameter <span class="math">\\rho</span> satisfies <span class="math">\\eta\\lambda</span>-consistency, <span class="math">(\\eta\\lambda,Q)</span>-chain quality, and <span class="math">(\\eta\\lambda,G,G^{\\prime})</span>-chain growth w.r.t. to any p.p.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> that is <span class="math">\\Gamma_{\\rho}^{\\mathsf{snail}}</span>-admissible w.r.t. snailchain.</p>

    <h4 id="sec-64" class="text-lg font-semibold mt-6">Typical parametrizations.</h4>

    <p class="text-gray-300">Typically in practice, we would set the puzzle’s difficulty parameter <span class="math">\\rho:=\\Theta(\\frac{1}{\\Delta n})</span> where <span class="math">\\Delta</span> be an a-priori known upper bound of the network’s delay <span class="math">\\delta</span>. Under such typical parametrizations, we would need roughly <span class="math">3/4</span> overall honest to ensure roughly <span class="math">2/3</span>-chain quality.</p>

    <h6 id="sec-65" class="text-base font-medium mt-4">Corollary 1 (Nakamoto as the underlying snailchain <em>[47]</em>).</h6>

    <p class="text-gray-300">For any (arbitrarily small) constant <span class="math">\\epsilon&gt;0</span>, let <span class="math">\\alpha=\\frac{1}{4}-\\epsilon</span>, then for every <span class="math">n,\\delta</span>, there exists sufficiently small <span class="math">\\rho_{0}:=\\Theta(\\frac{1}{\\delta n})</span> such that for any constant <span class="math">\\eta&gt;0</span>, <span class="math">\\eta^{\\prime}&gt;0</span>, Nakamoto’s protocol with mining difficulty parameter <span class="math">\\rho&lt;\\rho_{0}</span> satisfies <span class="math">\\eta^{\\prime}\\lambda</span>-consistency, <span class="math">(\\eta^{\\prime}\\lambda,Q)</span>-chain quality and <span class="math">(\\eta^{\\prime}\\lambda,G,G^{\\prime})</span>-chain growth w.r.t. any <span class="math">\\Gamma_{\\rho}^{\\mathsf{snail}}</span>-admissible <span class="math">(\\mathcal{A},\\mathcal{Z})</span> where</p>

    <p class="text-gray-300"><span class="math">Q&gt;\\frac{2}{3},\\quad G=\\frac{3}{4}n\\rho,\\quad G^{\\prime}=(1+\\eta)n\\rho</span></p>

    <p class="text-gray-300">Or more simply (and informally) put, for every <span class="math">\\alpha=\\frac{1}{4}-\\epsilon</span> for an arbitrarily small constant <span class="math">\\epsilon&gt;0</span>, there exists an appropriately parametrized Nakamoto consensus protocol that achieves <span class="math">Q&gt;\\frac{2}{3}</span> chain quality.</p>

    <h4 id="sec-66" class="text-lg font-semibold mt-6">4.1.2 Fruitchain as the underlying snailchain</h4>

    <p class="text-gray-300">The problem with using Nakamoto as the underlying snailchain is chain quality loss. Due to a selfish mining attack, Nakamoto requires <span class="math">3/4+\\epsilon</span> overall honest to attain <span class="math">2/3</span>-chain quality which is needed for the elected committees to be <span class="math">2/3</span> honest. Since hybrid consensus takes a modular approach, we can instead use a drop-in replacement, the Fruitchain <em>[48]</em> protocol, which realizes (almost) the same formal abstraction as Nakamoto.</p>

    <p class="text-gray-300">At a high level, the Fruitchain protocol runs a Nakamoto consensus underneath; however, miners mine fruits simultaneously as they search for blocks. Fruits contain the transactions, and blocks in the underlying Nakamoto blockchain contain the fruits (but not the transactions). In the Fruitchain protocol, a fruit is regarded as the new block and viewed as part of the blockchain abstraction, but the underlying Nakamoto can be regarded as simply an internal detail of the protocol and need not be exposed to the outside. We will assume that the Fruitchain protocol takes in the following parameters as inputs (see the Fruitchain paper for details <em>[48]</em>)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Mining difficulty parameters <span class="math">\\rho</span> and <span class="math">\\rho_f</span>, for mining the block and fruit respectively. Henceforth we shall assume that <span class="math">\\rho_f := \\rho</span> is hardcoded (although <span class="math">\\rho_f := c\\rho</span> for any constant <span class="math">c \\geq 1</span> should also work), and therefore we do not mention <span class="math">\\rho_f</span> explicitly any more.</li>

      <li>The look-back parameter <span class="math">\\kappa</span>, i.e., how far back in the blockchain to hang a fruit from;</li>

      <li>The recency parameter <span class="math">\\mathsf{R}</span>, that is, a fruit is considered fresh if it is hanging from a <span class="math">(\\mathsf{R} \\cdot \\kappa)</span>-recent block in the underlying blockchain. Henceforth we will simply assume that <span class="math">\\mathsf{R} := 17</span> is hardcoded (although any other constant great than 1 should also work), and therefore we do not explicitly mention the recency parameter any more henceforth<span class="math">^9</span>.</li>

    </ul>

    <p class="text-gray-300"><strong>Theorem 5 (Fruitchain as the underlying snailchain [48]).</strong> For any <span class="math">0 &amp;lt; \\eta &amp;lt; 1</span>, <span class="math">\\rho &amp;gt; 0</span>, let <span class="math">G = (1 - 5\\eta)(1 - \\alpha)n\\rho</span>, <span class="math">G&#x27; = (1 + 5\\eta)n\\rho</span>, and <span class="math">Q = (1 - 5\\eta)(1 - \\alpha)</span>, the Fruitchain protocol [48] parametrized with <span class="math">(\\rho, \\kappa = \\frac{\\lambda}{34})</span> satisfies <span class="math">\\lambda</span>-consistency, <span class="math">(\\lambda/\\eta, Q)</span>-fruit quality, <span class="math">(\\lambda/\\eta, G, G&#x27;)</span>-fruit growth w.r.t. any p.p.t. <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> that is <span class="math">\\Gamma_{\\rho}^{\\text{snail}}</span>-admissible w.r.t. snailchain.</p>

    <p class="text-gray-300"><strong>Corollary 2 (Fruitchain as the underlying snailchain [48]).</strong> For any (arbitrarily small) constant <span class="math">\\epsilon &amp;gt; 0</span>, let <span class="math">\\alpha = \\frac{1}{3} - \\epsilon</span>, there exists a suitable <span class="math">\\kappa = \\Theta(\\lambda)</span> and a constant <span class="math">0 &amp;lt; \\eta &amp;lt; 1</span> (related to <span class="math">\\epsilon</span>); moreover for every <span class="math">n, \\delta &amp;gt; 0</span>, there exists a sufficiently small <span class="math">\\rho := \\Theta\\left(\\frac{1}{\\delta n}\\right)</span>, such that Fruitchain with parameters <span class="math">(\\rho, \\kappa)</span> satisfies <span class="math">\\lambda</span>-consistency, <span class="math">(\\frac{\\lambda}{\\eta}, Q)</span>-chain quality and <span class="math">(\\frac{\\lambda}{\\eta}, G, G&#x27;)</span>-chain growth w.r.t. any <span class="math">\\Gamma_{\\rho}^{\\text{snail}}</span>-admissible <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> where</p>

    <div class="my-4 text-center"><span class="math-block">Q &amp;gt; \\frac{2}{3}, \\quad G = \\frac{2}{3}n\\rho, \\quad G&#x27; = (1 + 5\\eta)n\\rho</span></div>

    <p class="text-gray-300">Or more simply (and informally) put, for every <span class="math">\\alpha = \\frac{1}{3} - \\epsilon</span> where <span class="math">\\epsilon &amp;gt; 0</span> is an arbitrarily small constant, there is an appropriately parametrized Fruitchain protocol that achieves <span class="math">Q &amp;gt; \\frac{2}{3}</span> chain quality.</p>

    <h2 id="sec-67" class="text-2xl font-bold">4.2 Strongly Secure Permissioned Byzantine Fault Tolerance</h2>

    <p class="text-gray-300">We will rely on a permissioned consensus protocol. It is well-known how to construct Byzantine Fault Tolerance (BFT) protocols in partially synchronous networks [21, 25, 42]; and furthermore, these protocols achieve responsiveness.</p>

    <p class="text-gray-300">Due to technical subtleties related to a selective opening attack, we need to define a stronger security notion for our BFT building block than the most natural property-based notion. We consider BFT protocols that make blackbox usage of a signing algorithm. Let <span class="math">\\Sigma := (\\text{Gen}, \\text{Sign}, \\text{Verify})</span> denote a signature scheme. We use the notation <span class="math">\\mathsf{BFT}^{\\Sigma}</span> to mean that the protocol BFT is parametrized by the signature scheme <span class="math">\\Sigma</span>. Moreover, we require that BFT only makes blackbox usage of <span class="math">\\Sigma.\\text{Gen}</span> and <span class="math">\\Sigma.\\text{Sign}</span> functionalities — and in our formulation below, BFT nodes query the environment <span class="math">\\mathcal{Z}</span> that will provide <span class="math">\\Sigma.\\text{Gen}</span> and <span class="math">\\Sigma.\\text{Sign}</span> oracles. Formally, we assume that a <span class="math">\\mathsf{BFT}^{\\Sigma}</span> protocol, parametrized by a signature scheme <span class="math">\\Sigma := (\\text{Gen}, \\text{Sign}, \\text{Verify})</span>, realizes the following abstractions.</p>

    <p class="text-gray-300"><strong>Inputs.</strong> The environment is allowed to send the following inputs to honest nodes. All other inputs are ignored.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The environment <span class="math">\\mathcal{Z}</span> can send <span class="math">\\text{start}(\\mathsf{pk}_i, \\mathsf{comm})</span> once to an honest node <span class="math">i</span>.</li>

    </ul>

    <p class="text-gray-300"><span class="math">^9</span>We pick <span class="math">\\mathsf{R} = 17</span> based on Theorem 3.1 in the Fruitchain paper [48]. However, note that a tighter bound can be proven for any constant <span class="math">\\mathsf{R} &amp;gt; 1</span>. This could be done by using a tighter version of the fruit freshness lemma in Fruitchain [48].</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If a start command has been input, the environment <span class="math">\\mathcal{Z}</span> can in each time step input a set of transactions TXs to an honest node.</li>

      <li>Answers to <span class="math">\\text{sign}(\\text{msg})</span> queries.</li>

    </ul>

    <p class="text-gray-300">Outputs. Honest nodes output the following terms to <span class="math">\\mathcal{Z}</span> over time.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If a start command has been input, an honest node will in each time step, output to <span class="math">\\mathcal{Z}</span> a totally ordered log of transactions <span class="math">\\log</span>.</li>

      <li>If a start command has been input, an honest node can output to <span class="math">\\mathcal{Z}</span> queries of the form <span class="math">\\text{sign}(\\text{msg})</span> where <span class="math">\\text{msg} \\in \\{0,1\\}^*</span> denotes a message.</li>

    </ul>

    <p class="text-gray-300">Compliant executions. We consider execution of a BFT protocol in a partially synchronous network with somewhat static corruptions as elaborated below. The environment <span class="math">\\mathcal{Z}</span> and the adversary <span class="math">\\mathcal{A}</span> must also satisfy certain constraints. Let <span class="math">T_{\\text{stamp}}</span> be a polynomially-bounded function in <span class="math">\\lambda, n, Q</span>, and <span class="math">\\delta</span>. A pair of probabilistic polynomial-time algorithms <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> is said to be <span class="math">(n, Q, \\delta, \\tau, T_{\\text{stamp}})</span>-valid w.r.t. BFT iff the following hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathcal{A}, \\mathcal{Z})</span> is <span class="math">(n, \\delta, \\tau)</span>-valid w.r.t. BFT as per Definition 1.</li>

      <li>Somewhat static corruption. All "spawn" and "target corrupt" instructions must be declared before <span class="math">T_{\\text{start}}</span>, where <span class="math">T_{\\text{start}}</span> denotes the time when a start command is first input to an honest node by <span class="math">\\mathcal{Z}</span>.</li>

      <li>Committee agreement. If honest node <span class="math">i</span> receives input <span class="math">\\text{start}(\\mathsf{pk}_i, \\mathsf{comm})</span> from <span class="math">\\mathcal{Z}</span> at time <span class="math">t</span>, and honest node <span class="math">j</span> receives input <span class="math">\\text{start}(\\mathsf{pk}_j, \\mathsf{comm}&#x27;)</span> at time <span class="math">t&#x27;</span>, it holds that <span class="math">\\mathsf{comm} = \\mathsf{comm}&#x27;</span>. Further, if <span class="math">i \\neq j</span>, then <span class="math">\\mathsf{pk}_i \\neq \\mathsf{pk}_j</span>.</li>

      <li>Close start. Let <span class="math">T_{\\text{start}}</span> be the earliest time an honest node receives input <span class="math">\\text{start}(-, -)</span>. Then, for any node <span class="math">i</span> honest at time <span class="math">T_{\\text{start}} + \\delta</span>, <span class="math">i</span> must receive input <span class="math">\\text{start}(-, -)</span> by time <span class="math">T_{\\text{start}} + \\delta</span>. Each node receives start at most once when it is honest.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Resilience. At least $\\lceil Q \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{comm}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rceil<span class="math"> number of </span>\\mathsf{pk}_i \\in \\mathsf{comm}<span class="math"> must be specified in start commands that are input to nodes that remain honest till </span>T_{\\text{stamp}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Signature oracle correctness. For any <span class="math">\\text{start}(\\mathsf{pk}_i, -)</span> command input to an honest node, <span class="math">\\mathsf{pk}_i</span> must be in the range of the valid public keys for the signature scheme <span class="math">\\Sigma</span>.</li>

    </ul>

    <p class="text-gray-300">Upon any <span class="math">\\text{sign}(\\text{msg})</span> query from an honest node <span class="math">i</span>, <span class="math">\\mathcal{Z}</span> returns an answer <span class="math">\\sigma</span> immediately such that <span class="math">\\Sigma.\\text{Verify}(\\mathsf{pk}_i, \\mathsf{msg}, \\sigma) = 1</span>.</p>

    <p class="text-gray-300">Security definitions. Let <span class="math">T_{\\text{stamp}}, T_{\\text{bft}}</span> be polynomially-bounded functions in <span class="math">\\lambda, n, Q</span>, and <span class="math">\\delta</span>. Suppose that <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> is <span class="math">(n, Q, \\delta, \\tau, T_{\\text{stamp}})</span>-valid w.r.t. BFT. Then, for any view in the support of <span class="math">\\text{exec}<a href="\\mathcal{A}, \\mathcal{Z}, \\lambda">\\text{BFT}</a></span>, we say that <span class="math">\\text{secure}^{T_{\\text{bft}}}(\\text{view}) = 1</span> iff the following properties hold.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Consistency. Consistency incorporates the following properties:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Common prefix. If an honest node <span class="math">i</span> outputs <span class="math">\\log</span> at any time <span class="math">t &amp;lt; T_{\\text{stamp}}</span>, and honest node <span class="math">j</span> (same or different) outputs <span class="math">\\log&#x27;</span> at any time <span class="math">t&#x27; &amp;lt; T_{\\text{stamp}}</span>, it holds that either <span class="math">\\log \\prec \\log&#x27; \\text{ or } \\log&#x27; \\prec \\log</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Self-consistency. Suppose an honest node <span class="math">i</span> outputs <span class="math">\\mathsf{log}</span> and <span class="math">\\mathsf{log}^{\\prime}</span> at times <span class="math">t</span> and <span class="math">t^{\\prime}</span> respectively such that <span class="math">t&lt;t^{\\prime}&lt;T_{\\text{stamp}}</span>, it must hold that <span class="math">\\mathsf{log}\\prec\\mathsf{log}^{\\prime}</span>.</li>

      <li>Liveness. If <span class="math">\\mathcal{Z}</span> inputs <span class="math">\\mathsf{TXs}</span> to an honest node at time <span class="math">T_{\\text{start}}\\leq t&lt;T_{\\text{stamp}}-T_{\\text{bft}}</span>, then any node that is honest at time <span class="math">t^{\\prime}=t+T_{\\text{bft}}</span> will output a <span class="math">\\mathsf{log}</span> at time <span class="math">t^{\\prime}</span> such that <span class="math">\\mathsf{TXs}\\subseteq\\mathsf{log}</span>. <span class="math">T_{\\text{bft}}</span> is referred to as the liveness parameter.</li>

    </ul>

    <h6 id="sec-68" class="text-base font-medium mt-4">Definition 5 (Strongly secure <span class="math">\\mathsf{BFT}</span> protocols).</h6>

    <p class="text-gray-300">Let <span class="math">T_{\\text{bft}}</span> be a positive polynomial in <span class="math">\\lambda</span>, <span class="math">n</span>, <span class="math">Q</span>, and <span class="math">\\delta</span>. We say that a protocol <span class="math">\\mathsf{BFT}</span> is strongly secure against <span class="math">(1-Q)</span>-corruption with liveness parameter <span class="math">T_{\\text{bft}}</span> iff for any <span class="math">n,\\delta&gt;0</span>, <span class="math">\\tau\\geq 0</span>, any positive polynomial <span class="math">T_{\\text{stamp}}</span>, for any p.p.t. <span class="math">\\mathcal{A}</span> and any polynomial <span class="math">g</span>, there exists a p.p.t. adversary <span class="math">\\mathcal{B}</span> and polynomial <span class="math">g^{\\prime}</span>, such that for any <span class="math">(\\mathcal{A},\\mathcal{Z})</span> is <span class="math">(n,Q,\\delta,\\tau,T_{\\text{stamp}})</span>-valid w.r.t. <span class="math">\\mathsf{BFT}</span>, for any <span class="math">\\lambda\\in\\mathbb{N}</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left<a href="\\mathcal{A},\\mathcal{Z},\\lambda">\\mathsf{view}\\leftarrow\\exec[\\mathsf{BFT}</a>:\\mathsf{secure}^{T_{\\text{bft}}}(\\mathsf{view})\\neq 1\\right]\\geq g(\\lambda)</span> <span class="math">\\implies\\Pr\\left<a href="\\mathcal{B},\\mathcal{Z},\\lambda">\\mathsf{view}\\leftarrow\\exec[\\mathsf{BFT}</a>:\\mathsf{forgery}(\\mathsf{view})=1\\right]\\geq g^{\\prime}(\\lambda)</span></p>

    <p class="text-gray-300">where <span class="math">\\mathsf{forgery}(\\mathsf{view})=1</span>, iff in <span class="math">\\mathsf{view}</span>,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>at some time <span class="math">t</span> the adversary outputs to the environment <span class="math">\\mathcal{Z}</span> a forgery pair <span class="math">(i,\\mathsf{msg},\\sigma)</span> such that node <span class="math">i</span> is honest at time <span class="math">t</span>;</li>

      <li>by time <span class="math">t</span> the environment <span class="math">\\mathcal{Z}</span> has input <span class="math">\\mathsf{start}(\\mathsf{pk}_{i},\\_)</span> to node <span class="math">i</span>;</li>

      <li><span class="math">\\Sigma.\\mathsf{Verify}(\\mathsf{pk}_{i},\\mathsf{msg},\\sigma)=1</span>; and</li>

      <li>by time <span class="math">t</span>, node <span class="math">i</span> has not submitted a query <span class="math">\\mathsf{sign}(\\mathsf{msg})</span> to <span class="math">\\mathcal{Z}</span> where the answer was <span class="math">\\sigma</span>.</li>

    </ul>

    <h4 id="sec-69" class="text-lg font-semibold mt-6">Definitional subtleties: corruption model for <span class="math">\\mathsf{BFT}</span>.</h4>

    <p class="text-gray-300">Our <span class="math">\\mathsf{BFT}</span> building block must be secure under the “somewhat static” corruption model. We now elaborate the related definitional subtleties. First, any “spawn” or “target corrupt” instructions must be issued before <span class="math">T_{\\text{start}}</span>, i.e., when the first <span class="math">\\mathsf{start}</span> is input to an honest node — in this sense, the security notion seems “somewhat static”. On the other hand, our security notion is stronger than a standard “static” notion of security due to the following: for nodes that are in precorrupt state before <span class="math">T_{\\text{start}}</span>, there is an opportunity that they will become corrupt during the course of the BFT protocol and before <span class="math">T_{\\text{stamp}}</span>. Importantly, all of our security properties, including consistency and liveness properties, must hold before <span class="math">T_{\\text{stamp}}</span> for any node that has not become corrupt yet. In comparison, the static notion does not need to extend security guarantees to precorrupt nodes. In fact, it is not hard to show that our “somewhat static” security notion is strictly stronger than a standard “static” notion of security, and it is not difficult to construct a (possibly contrived) BFT protocol that demonstrates this separation.</p>

    <h4 id="sec-70" class="text-lg font-semibold mt-6">Definitional subtleties: strong security of <span class="math">\\mathsf{BFT}</span>.</h4>

    <p class="text-gray-300">We remark that due to technical subtleties related to an adversarial selective opening attack, we need to define the above stronger notion of security for the <span class="math">\\mathsf{BFT}</span> subprotocol. Below we compare this notion with the most natural property-based security notion.</p>

    <p class="text-gray-300">First, while most other security definitions for protocols follow a most natural property-based definitional style, the above security notion for the <span class="math">\\mathsf{BFT}</span> building block is stronger. In particular, if <span class="math">\\mathsf{BFT}</span> satisfies the above strong security notion, then a natural instantiation, where honest nodes now generate their own signing key pairs and implement their own signing oracles, would satisfy the most natural property-based notion. Of course, to make the description complete, a valid environment <span class="math">\\mathcal{Z}</span> in this case would wait to hear each honest <span class="math">\\mathsf{BFT}</span> node <span class="math">i</span> output a public key <span class="math">\\mathsf{pk}_{i}</span>, and</p>

    <p class="text-gray-300">then input <span class="math">\\mathtt{start}(\\mathtt{comm})</span> to all honest nodes where <span class="math">\\mathtt{comm}</span> contain sufficiently many honest nodes’ public keys.</p>

    <p class="text-gray-300">When honest nodes implement their own key generation and signing oracles, we can group the honest nodes’ key generation and signing oracle implementations into the environment <span class="math">\\mathcal{Z}^{<em>}</span>. Then, this specific <span class="math">\\mathcal{Z}^{</em>}</span> would never disclose honest nodes’ respective secret signing keys. Therefore, if there exists some adversary p.p.t. <span class="math">\\mathcal{A}</span>, such that <span class="math">\\mathrm{exec}<a href="\\mathcal{A},\\mathcal{Z}^{<em>},\\lambda">\\mathsf{BFT}</a></span> fails any of these properties with non-negligible probability, then we can construct an adversary <span class="math">\\mathcal{B}</span> such that during the interaction <span class="math">\\mathrm{exec}<a href="\\mathcal{A},\\mathcal{Z}^{</em>},\\lambda">\\mathsf{BFT}</a></span>, <span class="math">\\mathcal{B}</span> effectively breaks the security of the signature scheme.</p>

    <p class="text-gray-300">Second, we point out that the natural property-based definitions are weaker and not sufficient for our purposes. In particular, later in the HybridConsensus protocol, the environment <span class="math">\\mathcal{Z}</span> for <span class="math">\\mathsf{BFT}</span> can selectively open a set of public keys to include in the <span class="math">\\mathtt{start}</span> command for the <span class="math">\\mathsf{BFT}</span> protocol. For example, one can easily imagine a somewhat contrived BFT protocol that would be secure under the most natural property-based definition (like all other definitions in this paper), but would be vulnerable to selective opening attacks: imagine that honest nodes disclose their secret signing keys if some predicate over the chosen public keys is satisfied — this predicate can easily be chosen such that it is satisfied with only <span class="math">\\mathsf{negl}(\\lambda)</span> probability for an honestly generated set of public keys not subject to adversarial selective opening, but satisfied with overwhelming property under adversarial selective opening (e.g., if all public keys end with 1).</p>

    <p class="text-gray-300">Fortunately, it is not hard to see that many known instantiations of permissioned BFT protocols satisfy this strong notion of security, e.g., PBFT <em>[21]</em> with digital signatures.</p>

    <h5 id="sec-71" class="text-base font-semibold mt-4">Remarks about the signing oracle.</h5>

    <p class="text-gray-300">We note that alternatively, it is possible to partition away the signing oracle into a global signing functionality adopting the GUC approach <em>[17]</em>. In particular, GUC is necessary since the same signature scheme is shared by multiple protocols, the inner BFT protocol, and our outer DailyBFT protocol. If we adopted the GUC approach, our blackbox reduction notion of security might also be simpler since we need not deal with environment having the signing key. On the other hand, using GUC will likely introduce other complexities in terms of notation. The two approaches are essentially equivalent by repartitioning of algorithm boundaries.</p>

    <h6 id="sec-72" class="text-base font-medium mt-4">Theorem 6 (Castro and Liskov <em>[21]</em>, briefly described in Appendix A).</h6>

    <p class="text-gray-300">There exists a <span class="math">\\mathsf{BFT}</span> protocol that is strongly secure against <span class="math">(1-Q)&lt;\\frac{1}{3}</span> corruption with liveness parameter <span class="math">T_{bft}:=O(n\\delta)</span>.</p>

    <p class="text-gray-300">To achieve the above, we can modify PBFT’s exponential timeout strategy such that nodes double the time-out every <span class="math">n</span> view changes. For completeness, in Appendix A, we briefly describe the PBFT protocol, and we refer the reader to Castro and Liskov <em>[21]</em> for further details and optimizations. Note that later when we use <span class="math">\\mathsf{BFT}</span> as a subprotocol in hybrid consensus, the number of <span class="math">\\mathsf{BFT}</span> nodes <span class="math">n</span> will be substituted with <span class="math">\\mathsf{csize}:=\\lambda</span>.</p>

    <h2 id="sec-73" class="text-2xl font-bold">5 Formal Scheme: Hybrid Consensus over Nakamoto</h2>

    <h3 id="sec-74" class="text-xl font-semibold mt-8">5.1 Notational Conventions</h3>

    <h5 id="sec-75" class="text-base font-semibold mt-4">Choice of formal framework.</h5>

    <p class="text-gray-300">We use the well-accepted Universal Composition <em>[16, 17, 20]</em> framework for formalizing and modularly composing protocols. For the presentation of our construction, we will take a modular approach. For each (sub)protocol, we formally describe its abstraction — not by defining an ideal functionality, but using a property-based approach. We then show how to compose these subprotocols to eventually construct our HybridConsensus protocol.</p>

    <h5 id="sec-76" class="text-base font-semibold mt-4">Session identifier conventions.</h5>

    <p class="text-gray-300">For any protocol prot, if we write prot[sid], then sid (or whatever variable is in square brackets) denotes the session identifier of the protocol instance. If we write prot only without the square brackets, then it means we only care about one specific session of the protocol (although a higher-level protocol can invoke multiple sessions), and therefore we do not denote the session identifier explicitly.</p>

    <h3 id="sec-77" class="text-xl font-semibold mt-8">5.2 Daily Offchain Consensus Protocol</h3>

    <p class="text-gray-300">For modular protocol composition, we define an intermediate abstraction called a daily offchain consensus protocol, denoted DailyBFT. In DailyBFT, committee members run an offchain BFT instance to decide a daily log, whereas non-members count signatures from committee members.</p>

    <h5 id="sec-78" class="text-base font-semibold mt-4">Overview of DailyBFT.</h5>

    <p class="text-gray-300">The definition of the DailyBFT intermediate abstraction extends BFT in the following ways:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Extends security to committee non-members and late-spawning nodes.</em> At a definitional level, the DailyBFT definition extends that of BFT to incorporate committee non-members as well. In particular, in the formal definition of DailyBFT below, all security properties must be satisfied not only by committee members, but also by committee non-members as well. Further, while the BFT definition assumes that all nodes are spawned prior to <span class="math">T_{\\text{start}}</span>, the definition of DailyBFT allows nodes to be spawned later. Therefore, here our security definitions including consistency and liveness apply to any node (committee member or non-member alike) that spawns early enough, i.e., before the deadline <span class="math">T_{\\text{stamp}}</span>. These security guarantees do not extend to nodes that spawn too late, since committee members can become corrupt far out in the future, at which point they can sign arbitrary tuples. For exactly this reason, our hybrid consensus protocol, which consumes DailyBFT as a building block, will need to explicitly handle late spawning to extend the security guarantees to nodes that spawn late.</li>

      <li><em>Termination.</em> DailyBFT makes explicit a termination procedure which must satisfy two requirements, namely, <em>termination agreement</em> and <em>timely termination</em>. Specifically, the environment <span class="math">\\mathcal{Z}</span> is allowed send a stop instruction to nodes. Timely termination requires that the BFT instance terminate quickly after honest nodes receive input stop. Termination agreement requires that all honest nodes agree on the same final log upon termination.</li>

      <li><em>Signed daily log hashes.</em> In DailyBFT, committee members output signed daily log hashes which will later be consumed by the hybrid consensus protocol. These signed daily log hashes satisfy <em>completeness</em> and <em>unforgeability</em>. Completeness says that honest committee members output the correctly signed hash of their daily logs. Unforgeability says that the environment/adversary cannot forge signatures on any other values besides the correct hash.</li>

    </ul>

    <p class="text-gray-300">Formally, suppose that an DailyBFT<span class="math">[R]^{\\mathcal{D}}</span> protocol, with <span class="math">R</span> being the session identifier (also referred to as the day), and parametrized by the distribution <span class="math">\\mathcal{D}</span>, provides the following abstraction.</p>

    <h5 id="sec-79" class="text-base font-semibold mt-4">Inputs.</h5>

    <p class="text-gray-300">In each time step, the environment <span class="math">\\mathcal{Z}</span> can provide the following types of inputs multiple times: 1) keygen; 2) start(comm) where <span class="math">\\textsf{comm}=\\{\\textsf{pk}_{i}\\}_{i\\in[m]};</span> 3) TXs; and 4) stop.</p>

    <h5 id="sec-80" class="text-base font-semibold mt-4">Outputs.</h5>

    <p class="text-gray-300">Honest nodes output the following type of messages to <span class="math">\\mathcal{Z}</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>On input keygen, honest nodes output <span class="math">\\textsf{pk}\\leftarrow\\mathcal{D}</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In each time step <span class="math">t</span>, honest nodes output to the environment <span class="math">\\mathcal{Z}</span> <span class="math">\\texttt{notdone}(\\texttt{log}^t)</span>, until in one final step <span class="math">t^<em></span>, it outputs <span class="math">\\texttt{done}(\\texttt{log}^{t^</em>},\\texttt{recs})</span>, where <span class="math">\\texttt{recs}</span> is either <span class="math">\\emptyset</span> or a set of signed tuples vouching for the hash of the final daily log. After outputting <span class="math">\\texttt{done}(\\texttt{log}^{t^*},\\texttt{recs})</span>, honest nodes stop outputting in future time steps.</li>

    </ul>

    <p class="text-gray-300">Terminology. Suppose that in a specific view in the support of <span class="math">\\texttt{exec}<a href="\\mathcal{A},\\mathcal{Z},\\lambda">\\texttt{DailyBFT}</a></span>, the environment <span class="math">\\mathcal{Z}</span> inputs a unique <span class="math">\\texttt{start}(\\texttt{comm})</span> command to all honest nodes — later our compliance rule will require that this be the case, then <span class="math">\\texttt{comm}:=\\{\\texttt{pk}_i\\}_i</span> is referred to as the elected committee.</p>

    <p class="text-gray-300">We say that a node <span class="math">i</span> is an honest committee member at time <span class="math">t</span>, if the following holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Before the first start(comm) command was input to any honest node, node <span class="math">i</span> output to <span class="math">\\mathcal{Z}</span> a pk that was included in comm.</li>

      <li>Node <span class="math">i</span> remains honest till time <span class="math">t</span> (but could become corrupt later).</li>

    </ul>

    <p class="text-gray-300">Henceforth, if we say "an honest committee member <span class="math">i</span> performs some action or is the receiver of some action at time <span class="math">t</span> in some view", we implicitly mean that node <span class="math">i</span> is an honest committee member at time <span class="math">t</span>, i.e., it remains honest till time <span class="math">t</span> but could be corrupt later.</p>

    <p class="text-gray-300">The earliest time at which an honest committee member receives input start is denoted <span class="math">T_{\\text{start}}</span>. The earliest time at which an honest committee member receives input stop is denoted <span class="math">T_{\\text{stop}}</span>.</p>

    <p class="text-gray-300">We say that an honest node outputs log as a shorthand to mean that it outputs either done(log, _) or notdone(log).</p>

    <p class="text-gray-300">When an honest node <span class="math">i</span> outputs done(log, _) at some time, we say that log is node <span class="math">i</span>'s final daily log.</p>

    <p class="text-gray-300">Compliant executions. We say that a pair <span class="math">(\\mathcal{A},\\mathcal{Z})</span> is <span class="math">(n,Q,\\delta,\\tau,T_{\\mathrm{stamp}},T_{\\mathrm{bft}})</span>-valid w.r.t. DailyBFT, if <span class="math">(\\mathcal{A},\\mathcal{Z})</span> is not only <span class="math">(n,\\delta,\\tau)</span>-valid w.r.t. DailyBFT by Definition 1, but the following also holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Committee agreement. If honest node <span class="math">i</span> receives input start(comm) from <span class="math">\\mathcal{Z}</span> at time <span class="math">t</span>, and honest node <span class="math">j</span> receives input start(comm') from <span class="math">\\mathcal{Z}</span> at time <span class="math">t&#x27;</span>, it holds that <span class="math">\\texttt{comm}=\\texttt{comm}&#x27;</span>.</li>

      <li>Close start and stop. Let <span class="math">T_{\\text{start}}</span> be the earliest time an honest node receives input start(_). Then, for any node <span class="math">i</span> honest at time <span class="math">T_{\\text{start}} + \\delta</span>, <span class="math">i</span> must receive input start(_) by time <span class="math">T_{\\text{start}} + \\delta</span>.</li>

    </ul>

    <p class="text-gray-300">Similarly, let <span class="math">T_{\\mathrm{stop}}</span> be the earliest time an honest node receives input stop. Then, for any node <span class="math">i</span> honest at time <span class="math">T_{\\mathrm{stop}} + \\delta</span>, <span class="math">i</span> must receive input stop by time <span class="math">T_{\\mathrm{stop}} + \\delta</span>. For any honest node <span class="math">i</span> that receives stop at time <span class="math">t</span>, it must have received start at some time <span class="math">t&#x27; &amp;lt; t</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Resilience. At least $\\lceil Q \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\texttt{comm}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rceil<span class="math"> number of </span>\\mathsf{pk}_i \\in \\mathsf{comm}<span class="math"> must be output, earlier than the first start command input to any honest node, by nodes that remain honest till </span>T_{\\mathrm{stamp}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Early enough stop. <span class="math">T_{\\mathrm{stop}} + T_{\\mathrm{bft}} + \\delta \\leq T_{\\mathrm{stamp}}</span>, where <span class="math">T_{\\mathrm{stop}}</span> is the time at which the earliest honest committee member receives input stop.</li>

      <li>Temporary static corruption. For any <span class="math">\\mathsf{pk} \\in \\mathsf{comm}</span>, if <span class="math">\\mathsf{pk}</span> was output by a node that became corrupt before <span class="math">T_{\\mathrm{stamp}}</span>, then the "target corrupt" instruction must have been issued before <span class="math">T_{\\mathrm{start}}</span>.</li>

    </ul>

    <p class="text-gray-300">Security definitions. A DailyBFT protocol is said to be secure against <span class="math">(1 - Q)</span>-corruption with liveness parameter <span class="math">T_{\\mathrm{bft}}</span>, if for any <span class="math">n &amp;gt; 0</span>, <span class="math">\\delta &amp;gt; 0</span>, any <span class="math">\\tau \\geq 0</span>, any <span class="math">T_{\\mathrm{stamp}} &amp;gt; 0</span>, for any <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> that is <span class="math">(n, Q, \\delta, \\tau, T_{\\mathrm{stamp}}, T_{\\mathrm{bft}})</span>-valid w.r.t. DailyBFT, there exists a negligible function negl such that for every <span class="math">\\lambda \\in \\mathbb{N}</span>, except with <span class="math">\\mathsf{negl}(\\lambda)</span> probability, the following properties hold for <span class="math">\\texttt{exec}<a href="\\mathcal{A}, \\mathcal{Z}, \\lambda">\\texttt{DailyBFT}</a></span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Timely termination. Time termination encompasses the following:</li>

    </ul>

    <p class="text-gray-300">28</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Any committee member <span class="math">i</span> that is honest at time <span class="math">T_{\\mathrm{stop}} + T_{\\mathrm{bft}}</span> must have output done(log, _) by time <span class="math">T_{\\mathrm{stop}} + T_{\\mathrm{bft}}</span>.</li>

      <li>For any node <span class="math">i</span> that is honest at time <span class="math">t \\geq T_{\\mathrm{stop}} + T_{\\mathrm{bft}} + \\delta</span>, it must have output done(log, _) by time <span class="math">t</span>.</li>

    </ul>

    <p class="text-gray-300">In both cases, when an honest node outputs done(log, _), we refer to log as the node's final daily log.</p>

    <p class="text-gray-300">Note that since <span class="math">(\\mathcal{A},\\mathcal{Z})</span> is <span class="math">(n,Q,\\delta ,\\tau ,T_{\\mathrm{stamp}},T_{\\mathrm{bft}})</span>-valid w.r.t. DailyBFT, timely termination implies the following: any node that spawned before <span class="math">T_{\\mathrm{stamp}}</span> and remains honest till <span class="math">T_{\\mathrm{stamp}}</span> must have output done(_,_) by <span class="math">T_{\\mathrm{stamp}}</span>. In other words, if any node spawned before <span class="math">T_{\\mathrm{stamp}}</span> and outputs done(_,_) when it is honest, done(_,_) must be output no later than <span class="math">T_{\\mathrm{stamp}}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Consistency. Consistency encompasses the following:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Self-consistency. For any node <span class="math">i</span> that spawned before <span class="math">T_{\\mathrm{stamp}}</span>, and is honest at time <span class="math">t&#x27;</span>, suppose node <span class="math">i</span> outputs <span class="math">\\log</span> at time <span class="math">t \\leq t&#x27;</span> and outputs <span class="math">\\log&#x27;</span> at time <span class="math">t&#x27;</span>, it holds that <span class="math">\\log \\prec \\log&#x27;</span>.</li>

      <li>Termination agreement. For any node <span class="math">i</span> that spawned before <span class="math">T_{\\mathrm{stamp}}</span>, and any node <span class="math">j</span> that also spawned before <span class="math">T_{\\mathrm{stamp}}</span>, suppose node <span class="math">i</span> outputs done(log',_) and node <span class="math">j</span> outputs done(log',_) before they become corrupt, it holds that <span class="math">\\log = \\log&#x27;</span>.</li>

      <li>Common prefix. For any nodes <span class="math">i, j</span> that spawned before <span class="math">T_{\\mathrm{stamp}}</span>, suppose that <span class="math">i</span> is honest at time <span class="math">t</span> and outputs <span class="math">\\log</span> at time <span class="math">t</span>, and <span class="math">j</span> is honest at time <span class="math">t&#x27;</span> and outputs <span class="math">\\log</span> at time <span class="math">t&#x27;</span>, it holds that either <span class="math">\\log \\prec \\log&#x27;</span> or <span class="math">\\log&#x27; \\prec \\log</span>.</li>

    </ul>

    <p class="text-gray-300">Note that it may seem like common prefix is implied by termination agreement and self-consistency, but keep in mind that common prefix must additionally hold for nodes that never have an opportunity to output done(_,_) before becoming corrupt.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Liveness. Suppose that <span class="math">\\mathcal{Z}</span> inputs TXs to an honest committee member at time <span class="math">T_{\\mathrm{start}} \\leq t &amp;lt; T_{\\mathrm{stop}} - T_{\\mathrm{bft}}</span>. Then, for any honest node <span class="math">i</span> that spawns at time <span class="math">t_{\\mathrm{spawn}} \\leq T_{\\mathrm{stamp}}</span>, if <span class="math">i</span> is honest at time <span class="math">t&#x27; \\geq t + T_{\\mathrm{bft}} + \\delta</span>, then node <span class="math">i</span> must have output log at some time <span class="math">t^* \\leq t&#x27;</span> such that <span class="math">\\mathsf{TXs} \\subseteq \\log</span>.</li>

      <li>Completeness. Let comm be the unique set included in start commands input to honest nodes. For every <span class="math">\\mathsf{pk} \\in \\mathsf{comm}</span> that is output by a node <span class="math">i</span> honest at sometime <span class="math">t</span> and if node <span class="math">i</span> outputs done(log, recs) at time <span class="math">t</span>, then it holds that a valid record <span class="math">\\{R, \\text{hash}(\\log)\\}_{\\mathsf{pk}^{-1}} \\in \\mathsf{recs}</span> where validity is defined by correct signature verification with <span class="math">\\mathsf{pk}</span>.</li>

      <li>Unforgeability. Let <span class="math">t \\leq T_{\\mathrm{stamp}}</span>, and let <span class="math">\\mathsf{pk} \\in \\mathsf{comm}</span> be output by a node <span class="math">i</span> that is honest at time <span class="math">t</span>. Then, if by time <span class="math">t</span> the adversary <span class="math">\\mathcal{A}</span> outputs to the environment <span class="math">\\mathcal{Z}</span> a valid tuple <span class="math">\\{R, h\\}_{\\mathsf{pk}^{-1}}</span> where <span class="math">R</span> is the current DailyBFT instance's session identifier, then it must hold that node <span class="math">i</span> has output done(log,_) by <span class="math">t</span> and <span class="math">h = \\text{hash}(\\log)</span>.</li>

    </ul>

    <p class="text-gray-300">Construction. We present a construction of the DailyBFT protocol from BFT in Figure 1. Below is an informal description of the operations of DailyBFT:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>BFT virtual nodes and selective opening of committee. A DailyBFT node outputs fresh public keys to its environment upon a keygen query. Then when it receives a start(comm) command, if comm contains one or more of its own public keys, then the node is elected as a committee member. In this case, the node will fork a BFT virtual node for each public key in comm that belongs to itself. Here the committee is selectively opened by the environment through the start(comm) command, later our proof will need to leverage the strong security of BFT.</li>

    </ul>

    <p class="text-gray-300">29</p>

    <p class="text-gray-300">On input init:  <span class="math">\\ell \\coloneqq 0</span> ,  <span class="math">\\log \\coloneqq \\emptyset</span> , mykeys  <span class="math">\\coloneqq \\emptyset</span></p>

    <p class="text-gray-300">On input keygen:  <span class="math">(\\mathsf{pk},\\mathsf{sk})\\stackrel {\\S}{\\leftarrow}\\Sigma .\\mathsf{Gen}(1^{\\lambda})</span>  , add pk to mykeys, output pk</p>

    <p class="text-gray-300">On input stop : for each  <span class="math">\\mathsf{BFT}^{\\mathsf{pk}}</span>  virtual node forked: input TXs :=  <span class="math">\\{\\{\\mathsf{stop}\\}_{\\mathsf{pk}^{-1}}\\}</span>  to  <span class="math">\\mathsf{BFT}^{\\mathsf{pk}}</span></p>

    <p class="text-gray-300">On input start(comm): if mykeys  <span class="math">\\cap</span>  comm  <span class="math">\\neq \\emptyset</span> : isMember = true, else isMember = false</p>

    <p class="text-gray-300">For each  <span class="math">\\mathsf{pk} \\in \\mathsf{mykeys} \\cap \\mathsf{comm}</span> : fork a BFT virtual node, and BFT.start(pk, comm).</p>

    <p class="text-gray-300">// henceforth this BFT virtual node is denoted  <span class="math">\\mathsf{BFT}^{\\mathsf{pk}}</span></p>

    <p class="text-gray-300">Every time some  <span class="math">\\mathsf{BFT}^{\\mathsf{pk}}</span>  virtual node outputs sign(msg): return  <span class="math">\\{\\mathsf{msg}\\}_{\\mathsf{pk}^{-1}}</span></p>

    <p class="text-gray-300">// implements a signing oracle for BFT virtual nodes</p>

    <p class="text-gray-300">On input TXs: input TXs to each BFT virtual node forked</p>

    <p class="text-gray-300">Let  <span class="math">\\mathsf{BFT}_0</span>  denote the first such BFT virtual node forked</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let complete(log) = true iff log contains stop correctly signed by th :=  $\\lceil</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{comm}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ 3\\rceil$  distinct pks in comm</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Every time step  <span class="math">t</span>  if start has been received and done has not been output:</p>

    <p class="text-gray-300">Receive output  <span class="math">\\log^{*}</span>  from  <span class="math">\\mathsf{BFT}_0</span></p>

    <p class="text-gray-300">If complete  <span class="math">(\\log^{<em>})</span>  then  <span class="math">\\log^{</em>} :=</span>  shortest prefix of  <span class="math">\\log^{<em>}</span>  such that complete  <span class="math">(\\log^{</em>})</span></p>

    <p class="text-gray-300">For each  <span class="math">\\mathsf{tx} \\in \\log^* - \\log</span>  that is not a stop transaction:</p>

    <p class="text-gray-300">Let  <span class="math">\\ell := \\ell + 1</span> , for each  <span class="math">\\mathsf{pk} \\in \\mathsf{mykeys} \\cap \\mathsf{comm}</span> : gossip  <span class="math">\\{R, \\ell, \\mathsf{tx}\\}_{\\mathsf{pk}^{-1}}</span></p>

    <p class="text-gray-300"><span class="math">\\log := \\log^{*}</span></p>

    <p class="text-gray-300">If complete(log): call Finalize; else output notdone(log)</p>

    <p class="text-gray-300">Finalize:</p>

    <p class="text-gray-300">recs :=  <span class="math">\\emptyset</span> , remove all stop transactions from log</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For each  <span class="math">\\mathsf{pk} \\in \\mathsf{mykeys} \\cap \\mathsf{comm}</span> : let  $x := \\{R,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}_{\\mathsf{pk}^{-1}}<span class="math"> ,  </span>\\mathsf{recs} := \\mathsf{recs} \\cup \\{x\\}<span class="math"> , gossip  </span>x$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Output done(log, recs), and stop outputting in future time steps.</p>

    <p class="text-gray-300">On receive  <span class="math">\\{R,\\ell \\}_{\\mathsf{pk}^{-1}}</span>  or  <span class="math">\\{R,\\ell ,\\mathsf{tx}\\}_{\\mathsf{pk}^{-1}}</span>  : add message to history and check the following:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">On collect  <span class="math">(r,\\ell ,\\mathsf{tx})</span>  and signatures s.t.  <span class="math">r = R</span>  and th  $\\coloneqq \\lceil</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{comm}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ 3\\rceil$  distinct pks</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">in comm signed the tuple correctly:</p>

    <p class="text-gray-300">If  <span class="math">\\log[\\ell]</span>  has not been set, let  <span class="math">\\log[\\ell] := \\mathsf{tx}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">On collect  <span class="math">(r,\\ell)</span>  and signatures s.t.  <span class="math">r = R</span>  and th  $\\coloneqq \\lceil</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{comm}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ 3\\rceil$  distinct pks</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">in comm signed the tuple correctly:</p>

    <p class="text-gray-300">Wait till  <span class="math">\\log [\\ell ]</span>  all populated</p>

    <p class="text-gray-300">Output done(log,∅), and stop outputting in future time steps.</p>

    <p class="text-gray-300">Each time step until done is output:</p>

    <p class="text-gray-300">let  <span class="math">\\log^{\\prime} :=</span>  longest contiguous prefix of  <span class="math">\\log</span> , output notdone  <span class="math">(\\log^{\\prime})</span></p>

    <p class="text-gray-300">Figure 1: Daily offchain consensus protocol. Since each signing key is reused for both the inner BFT protocol and the outer DailyBFT protocol, we assume that the signing algorithm tags each message for the inner BFT instance with the prefix "0", and each message for the outer DailyBFT with the prefix "1" to avoid namespace collision.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 2: Modular composition of the hybrid consensus protocol. Figure 3: The mempool subprotocol keeps track of transactions, and upon query, proposes a set of outstanding transactions. An obvious practical optimization not documented here for simplicity is that the mempool can purge transactions that are already confirmed in LOG.</p>

    <p class="text-gray-300">On initialize: TXs := 0</p>

    <p class="text-gray-300">On receive  <span class="math">\\mathsf{TXs}_1</span> :  <span class="math">\\mathsf{TXs} := \\mathsf{TXs} \\cup \\mathsf{TXs}_1</span></p>

    <p class="text-gray-300">On input propose(TXs1): TXs := TXs  <span class="math">\\cup</span>  TXs1, gossip TXs1</p>

    <p class="text-gray-300">On input query(confirmed): return TXs\\confirmed</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Member and non-member basic operations. Committee members populate their daily logs relying on the BFT protocol, whereas committee non-members count signatures from committee members to populate their logs.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Termination. Nodes implement a termination procedure as follows: whenever an honest committee member receives a stop instruction, it inputs a special, signed stop transaction to each of its BFT virtual node. As soon as the inner BFT instance outputs a log containing stop transactions signed by at least  $\\lceil</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{comm}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ 3\\rceil<span class="math">  distinct committee public keys, the log is finalized and output. All transactions after the first  </span>\\lceil</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{comm}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ 3\\rceil$  stop transactions (with distinct committee public keys) are ignored.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Signed daily log hashes. When committee members output done, they also output a signed digest of the final daily log — later, our HybridConsensus protocol will stamp this digest onto the snailchain.</li>

    </ul>

    <p class="text-gray-300">Theorem 7 (DailyBFT from BFT). Suppose that the signature scheme  <span class="math">\\Sigma</span>  employed by DailyBFT is secure, and that hash is a random oracle. Suppose that BFT is secure against  <span class="math">(1 - Q)</span> -corruption with liveness parameter  <span class="math">T_{bft}&#x27;</span>  for  <span class="math">Q &amp;gt; \\frac{2}{3}</span> . Then, DailyBFT is secure against  <span class="math">(1 - Q)</span> -corruption with liveness parameter  <span class="math">T_{bft} := T_{bft}&#x27; + \\delta</span> .</p>

    <p class="text-gray-300">The proof of this theorem is deferred to Section 8.</p>

    <p class="text-gray-300">We now describe our final product, the hybrid consensus protocol. Hybrid consensus consumes multiple instances of DailyBFT where rotating committees agree on daily logs. Hybrid consensus primarily does the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>It manages the spawning and termination of DailyBFT instances effectively using snailchain as a global clock that offers weak synchronization among honest nodes;</li>

    </ul>

    <p class="text-gray-300">On init:  <span class="math">R \\coloneqq 0</span> ,  <span class="math">\\mathsf{LOG}_s \\coloneqq \\emptyset</span> ,  <span class="math">\\mathsf{LOG} \\coloneqq \\emptyset</span> ,  <span class="math">\\mathsf{csize} \\coloneqq \\lambda</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Fork an instance of mempool denoted snailpool that stores pending records for snailchain.</li>

      <li>Fork another instance of mempool that stores pending transactions, denoted txpool.</li>

      <li>On input TXs: txpool.propose(TXs).</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>let chain denote the current local chain</li>

      <li>let  <span class="math">\\mathsf{pk} := \\mathsf{DailyBFT}[R + 1]</span> .keygen where  <span class="math">R</span>  denotes the current day</li>

      <li>let recs := snailpool.query(ExtractRecs(chain[: -λ])), input (recs, pk) to snailchain</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Wait till  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{chain}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\mathrm{csize} + \\lambda$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">L \\coloneqq</span>  Find in history maximal, ordered list of  <span class="math">(R, \\log_R)</span>  tuples such that  <span class="math">R</span>  is incrementing with no gaps, and  <span class="math">(R, \\text{hash}(\\log_R))</span>  is on-chain valid w.r.t. chain</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{LOG} \\coloneqq \\log_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  $R \\coloneqq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , fork an instance of DailyBFT  </span>[R + 1]$ :</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Loop:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Wait till  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{chain}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\mathrm{upper}(R + 1) + \\lambda<span class="math">  , let  </span>R\\coloneqq R + 1$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let  <span class="math">\\mathsf{comm}_R\\coloneqq \\mathsf{MinersOf}(\\mathsf{chain}[\\mathsf{lower}(R):\\mathsf{upper}(R)])</span>  where MinersOf parses each block as  <span class="math">(\\mathsf{recs}_i,\\mathsf{pk}_i)</span>  and returns a list containing all  <span class="math">\\mathsf{pk}_i\\mathsf{s}</span></p>

    <p class="text-gray-300">If an instance DailyBFT  <span class="math">[R - 1]</span>  exists, DailyBFT  <span class="math">[R - 1]</span> .stop</p>

    <p class="text-gray-300">Fork an instance of DailyBFT  <span class="math">[R + 1]</span></p>

    <p class="text-gray-300">DailyBFT  <span class="math">[R]</span>  .start(commR)</p>

    <p class="text-gray-300">Each time step: let  <span class="math">\\mathsf{TXs} \\coloneqq \\mathsf{txpool}.\\mathsf{query}(\\mathsf{LOG})</span> , input  <span class="math">\\mathsf{TXs}</span>  to DailyBFT  <span class="math">[R]</span></p>

    <p class="text-gray-300">Output: In each time step: let  <span class="math">R</span>  denote the current day. Let isdone  <span class="math">(r) =</span>  true if DailyBFT  <span class="math">[r]</span>  has output done in this or earlier time steps.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- If DailyBFT  <span class="math">[R - 1]</span>  outputs done  <span class="math">(\\log_{-1},\\mathrm{recs})</span>  in this time step:  $\\mathsf{LOG}_s\\coloneqq \\mathsf{LOG}_s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log_{-1}$ , snailpool.propose(recs)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let  <span class="math">\\log_{-1}</span>  and  <span class="math">\\log</span>  be the output logs of DailyBFT  <span class="math">[R - 1]</span>  and DailyBFT  <span class="math">[R]</span>  in this time step respectively (or  <span class="math">\\emptyset</span>  if nothing is output)</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- If isdone  <span class="math">(R - 1)</span> : LOG := LOGs</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">log; else LOG := LOGs</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">log-1. Output LOG</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For at least  <span class="math">\\mathsf{th} := \\lceil \\mathsf{csize} / 3 \\rceil</span>  distinct  <span class="math">\\mathsf{pk} \\in \\mathsf{MinersOf}(\\mathsf{chain}[\\mathsf{lower}(R), \\mathsf{upper}(R)])</span> :</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\{R,h\\}_{\\mathsf{pk}^{-1}}</span>  is the first occurrence in chain[:  <span class="math">-\\lambda ]</span>  where pk signed some tuple of the form  <span class="math">(R, - )</span></p>

    <p class="text-gray-300">Figure 4: Main HybridConsensus protocol. A newly spawned, honest node starts running this protocol. We assume history is the set of all historical transcripts sent and received. We assume that message routing to subprotocol instances is implicit: whenever any subprot[sid] instance is forked, history[subprot[sid]] and protocol messages pertaining to subprot[sid] are automatically routed to the subprot[sid] instance.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Recall that each DailyBFT instance does not ensure security for nodes that spawn too late, since committee members can become corrupt far out in the future at which point they can sign arbitrary tuples. Therefore, hybrid consensus introduces an on-chain stamping mechanism to extend security guarantees to even nodes that spawn late.</li>

    </ul>

    <p class="text-gray-300">Figure 4 is an algorithmic description of the HybridConsensus protocol. Figure 2 illustrates the modular composition of the hybrid consensus protocol. Specifically, the hybrid consensus protocol internally runs the following subprotocol instances: two mempool instances denoted snailpool and txpool respectively, a snailchain instance, and multiple DailyBFT instances. We now explain these subprotocol instances more concretely.</p>

    <h4 id="sec-92" class="text-lg font-semibold mt-6">Transaction mempools.</h4>

    <p class="text-gray-300">The HybridConsensus protocol maintains two instances of the mempools protocol (see Figure 3), denoted txpool and snailpool respectively. The txpool is a mempool used for maintaining outstanding transactions to be confirmed with DailyBFT instances, and the snailpool is used for maintaining daily log digests to be stamped on the snailchain. The mempool protocol is very simple: it gossips transactions over the network whenever the environment inputs new transactions. Whenever it hears transactions from the network, it saves them in the mempool.</p>

    <h4 id="sec-93" class="text-lg font-semibold mt-6">snailchain.</h4>

    <p class="text-gray-300">The HybridConsensus protocol internally forks a snailchain instance. First, the snailchain is used for reaching agreement on committees who will then run the offchain BFT consensus. The committee is selected as the miners of csize <span class="math">:=\\lambda</span> consecutive blocks. The chain quality property of the underlying snailchain ensures that sufficiently many of these miners are honest for sufficiently long. Second, this snailchain instance is used not for committing transactions, but for stamping daily log digests such that the protocol can resist retroactive corruptions where the adversary corrupts committee members in the future.</p>

    <h4 id="sec-94" class="text-lg font-semibold mt-6">DailyBFT instances.</h4>

    <p class="text-gray-300">The HybridConsensus protocol forks multiple instances of the DailyBFT protocol, and we use the index <span class="math">R</span> to denote the session identifier of each instance. <span class="math">R</span> is also referred to as the day number, and hence each DailyBFT<span class="math">[R]</span> instance outputs a “daily log”. In each DailyBFT<span class="math">[R]</span> instance, the elected committee members rely on the underlying BFT protocol to commit transactions and output a daily log over time, whereas committee non-members count signatures from committee members to populate their daily logs.</p>

    <h4 id="sec-95" class="text-lg font-semibold mt-6">Operations.</h4>

    <p class="text-gray-300">Each node maintains a history of all past transcripts denoted history — we assume this for simplicity of formalism, and it can be optimized away in practice. Nodes that newly spawn obtain the historical transcripts instantly (in practice this can be instantiated by having honest nodes offer a history retrieval service).</p>

    <p class="text-gray-300">When a new node spawns, it populates its LOG as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Matching on-chain valid tuples. A newly spawned node first identifies all on-chain valid tuples of the form <span class="math">(R,h)</span>, where <span class="math">R</span> is the day number and <span class="math">h</span> is the hash of the daily log. Then, the node will search history and identify an appropriate daily log <span class="math">\\mathsf{log}_{R}</span> that is consistent with <span class="math">h</span>. The node populates LOG with these daily logs. This on-chain matching process effectively provides a safe mechanism for a newly spawned node to catch up and populate old entries of its output LOG.</li>

      <li>Through daily offchain consensus. Once this catch-up process is complete, the node will henceforth rely on DailyBFT instances to further populate remaining entries of its output LOG. In each DailyBFT instance, a node can act as a committee member of a committee non-member.</li>

    </ul>

    <p class="text-gray-300">To do this, a node monitors its output chain from the snailchain instance. As soon as the chain length exceeds <span class="math">\\operatorname{\\mathsf{csize}}\\cdot R+\\lambda</span>, the <span class="math">R</span>-th day starts, at which point the node inputs stop to the previous <span class="math">\\operatorname{\\mathsf{DailyBFT}}[R-1]</span> instance (if one exists), and inputs start(MinersOf(chain[lower(<span class="math">R</span>): <span class="math">\\operatorname{\\mathsf{upper}}(R)</span>])) to the <span class="math">\\operatorname{\\mathsf{DailyBFT}}[R]</span> instance. There is typically a period of overlap during which both <span class="math">\\operatorname{\\mathsf{DailyBFT}}[R-1]</span> and <span class="math">\\operatorname{\\mathsf{DailyBFT}}[R]</span> instances are running simultaneously and outputting their respective daily logs. When nodes assimilate their daily logs into the final output LOG, they make sure that LOG is always contiguous leaving no gaps in between. Due to the timely termination property of <span class="math">\\operatorname{\\mathsf{DailyBFT}}</span>, the old <span class="math">\\operatorname{\\mathsf{DailyBFT}}[R-1]</span> will terminate fairly soon at which point the new <span class="math">\\operatorname{\\mathsf{DailyBFT}}[R]</span> instance fully takes over.</p>

    <h3 id="sec-96" class="text-xl font-semibold mt-8">5.4 Theorem Statements</h3>

    <h6 id="sec-97" class="text-base font-medium mt-4">Definition 6 (Admissible parameters for hybrid consensus <span class="math">\\Gamma^{\\mathsf{hc}}_{\\rho}</span>).</h6>

    <p class="text-gray-300">Let <span class="math">T_{\\mathsf{bft}}:=O(m\\delta)</span> be the liveness parameter for <span class="math">\\mathsf{BFT}</span> with <span class="math">m</span> nodes. We define <span class="math">\\Gamma^{\\mathsf{hc}}_{\\rho}(n,\\alpha,\\delta,\\tau)=1</span> iff the following holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">n&gt;0</span>, <span class="math">\\delta&gt;0</span>, <span class="math">\\tau\\geq 0</span> are all polynomial functions in <span class="math">\\lambda</span>; <span class="math">\\alpha&gt;0</span> is a constant;</li>

      <li>There exists a constant <span class="math">\\eta&gt;0</span> such that <span class="math">p(1-(2\\delta+2)p)\\geq(1+\\eta)q</span>. (This is needed for the underlying snailchain to be secure.)</li>

      <li>There exists a constant <span class="math">\\eta_{0}&gt;0</span> such that <span class="math">Q:=1-(1+\\eta_{0})\\frac{q}{\\gamma}&gt;\\frac{2}{3}</span>. (This is needed such that we get <span class="math">&gt;2/3</span> chain quality for snailchain.)</li>

      <li>There exists a constant <span class="math">\\eta_{1}&gt;0</span> such that <span class="math">G^{\\prime}:=(1+\\eta_{1})n\\rho&lt;\\frac{\\lambda}{T_{\\mathsf{bft}}+\\delta}</span> for any <span class="math">\\lambda\\in\\mathbb{N}</span>. (This is needed such that the chain does not grow too fast to ensure liveness.)</li>

      <li>There exists a constant <span class="math">\\eta_{2}&gt;0</span> such that <span class="math">\\tau&gt;4\\lambda(1+\\eta_{2})/\\gamma+c\\lambda\\delta</span> for some appropriately large constant <span class="math">c</span>. (This is needed such that the adversary is sufficiently constrained in agility.)</li>

    </ul>

    <p class="text-gray-300">In the above, parameters <span class="math">p,q,\\gamma</span> are functions in <span class="math">n,\\alpha,\\delta</span> as defined in Section 4.1.</p>

    <h6 id="sec-98" class="text-base font-medium mt-4">Theorem 8 (Main theorem for HybridConsensus).</h6>

    <p class="text-gray-300">Suppose that <span class="math">\\mathsf{hash},\\mathsf{H}:\\{0,1\\}^{*}\\to\\{0,1\\}^{\\lambda}</span> are independent random oracles, and that the signature scheme <span class="math">\\Sigma</span> is secure. Then, for any constant <span class="math">\\eta&gt;0</span>, hybrid consensus instantiated with Nakamoto as snailchain and with mining difficulty parameter <span class="math">\\rho</span> is secure with liveness parameters <span class="math">(T_{\\mathsf{warmup}},T_{\\mathsf{confirm}})</span> w.r.t. any p.p.t. <span class="math">\\Gamma^{\\mathsf{hc}}_{\\rho}</span>-admissible <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, where</p>

    <p class="text-gray-300"><span class="math">T_{\\mathsf{warmup}}:=2\\lambda(1+\\eta)/\\gamma,\\quad T_{\\mathsf{confirm}}:=O(\\lambda\\delta)</span></p>

    <p class="text-gray-300">Note that the above <span class="math">T_{\\mathsf{confirm}}</span> parameter is for the worst-case, in the optimistic case, hybrid consensus achieves a transaction confirmation time of <span class="math">O(\\delta)</span>.</p>

    <p class="text-gray-300">The proofs of the above theorem will be presented in Section 8.</p>

    <h4 id="sec-99" class="text-lg font-semibold mt-6">Typical parametrizations.</h4>

    <p class="text-gray-300">Typically in practice, if we set the puzzle’s difficulty parameter <span class="math">\\rho:=\\Theta(\\frac{1}{n\\Delta})</span> to be sufficiently small, where <span class="math">\\Delta</span> is a possibly loose upper bound on the network’s delay known a priori. Under such parametrization, if the overall corruption <span class="math">\\alpha</span> is roughly <span class="math">3/4</span>, then we ensure roughly <span class="math">2/3</span> chain quality.</p>

    <h6 id="sec-100" class="text-base font-medium mt-4">Corollary 3 (Typical parameters for hybrid consensus over Nakamoto: restatement of Theorem LABEL:thm:1).</h6>

    <p class="text-gray-300">Assume that <span class="math">\\alpha=\\frac{1}{4}-\\epsilon</span> for an arbitrary constant <span class="math">\\epsilon&gt;0</span>. Then for every <span class="math">n,\\delta</span>, there exists sufficiently small <span class="math">\\rho_{0}:=\\Theta(\\frac{1}{\\delta n})</span> such that hybrid consensus with Nakamoto as the underlying</p>

    <p class="text-gray-300"><span class="math">\\mathsf{snailchain}</span> and with mining difficulty parameter <span class="math">\\rho&amp;lt;\\rho_{0}</span> is secure w.r.t. any p.p.t. <span class="math">(n,\\alpha,\\delta,\\tau)</span>-valid <span class="math">(\\mathcal{A},\\mathcal{Z})</span> for any <span class="math">\\tau</span> such that <span class="math">\\Gamma_{\\rho}^{\\mathsf{hc}}(n,\\alpha,\\delta,\\tau)=1</span>, achieving</p>

    <p class="text-gray-300"><span class="math">T_{warmup}:=8\\lambda/3n\\rho,\\quad T_{confirm}:=O(\\lambda\\delta)</span></p>

    <h3 id="sec-101" class="text-xl font-semibold mt-8">5.5 Practical Considerations and Possible Optimizations</h3>

    <p class="text-gray-300">The scheme described above is optimized for simplicity and to aid formal analysis, but not for practical performance. There are many possible optimizations. For example, instead of having committee members sign each transaction one by one, they could instead sign a batch of transactions at a time. During stamping, instead of having each node send a separate signature onto <span class="math">\\mathsf{snailchain}</span>, we can rely on a threshold signature scheme and stamp a single signature of the daily log’s hash onto <span class="math">\\mathsf{snailchain}</span>. It is also easy to prune storage of old transcripts. We leave practical optimizations and implementation to future work.</p>

    <h2 id="sec-102" class="text-2xl font-bold">6 Extension: Fruitchain as the Underlying snailchain</h2>

    <p class="text-gray-300">Pass and Shi recently propose a new blockchain protocol called Fruitchain <em>[48]</em>. For a sufficiently small puzzle difficulty parameter <span class="math">\\rho:=\\Theta(\\frac{1}{n\\delta})</span>, and <span class="math">\\alpha:=\\frac{1}{3}-\\epsilon</span> for an arbitrarily small constant <span class="math">\\epsilon&amp;gt;0</span>, Fruitchain achieves <span class="math">Q&amp;gt;\\frac{2}{3}</span> chain quality over any sufficiently large window of consecutive blocks. It is not too hard to compose hybrid consensus and Fruitchains to obtain a responsive permissionless consensus protocol that is resilient against <span class="math">1/3-\\epsilon</span> overall corruption for an arbitrarily small constant <span class="math">\\epsilon&amp;gt;0</span>.</p>

    <p class="text-gray-300">Fruitchain provides the same formal abstraction as Nakamoto consensus, but with different parameters. Henceforth we will use the term “fruit quality” to mean Fruitchain’s chain quality, and “fruit growth” to mean Fruitchain’s chain growth. Under typical parameters stated in Section 4.1.2 and Corollary 2, to obtain <span class="math">\\eta</span>-optimal chain quality, Fruitchain requires the fruit quality window to be reasonably large, i.e., <span class="math">\\Theta(\\lambda/\\eta)</span>. Similarly, fruit growth also requires the time window to be reasonably long. In light of this, when we adopt Fruitchain as the underlying <span class="math">\\mathsf{snailchain}</span>, we need to make the following changes to the protocol described in Section 5:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathsf{HybridConsensus}^{\\lambda,\\eta}</span> be parametrized with parameters <span class="math">\\lambda</span>, and <span class="math">\\eta</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Redefine <span class="math">\\mathsf{csize}:=\\frac{\\lambda}{\\eta}</span>, <span class="math">\\mathsf{lower}(R):=\\frac{(R-1)\\lambda}{\\eta}+1</span>, and <span class="math">\\mathsf{upper}(R):=\\frac{R\\cdot\\lambda}{\\eta}</span>. In other words, the committee size is set to <span class="math">\\frac{\\lambda}{\\eta}</span>, and the protocol waits for the chain length $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{chain}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\mathsf{upper}(R)+\\lambda<span class="math"> to start the </span>R$-th day.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-103" class="text-base font-medium mt-4">Definition 7 (Admissible parameters for hybrid consensus over Fruitchain <span class="math">\\Gamma_{\\rho,\\eta}^{\\mathsf{hcfruit}}</span>).</h6>

    <p class="text-gray-300">Let <span class="math">T_{\\mathsf{bft}}:=O(m\\delta)</span> be the liveness parameter for <span class="math">\\mathsf{BFT}</span> with <span class="math">m</span> nodes. We define <span class="math">\\Gamma_{\\rho,\\eta}^{\\mathsf{hcfruit}}(n,\\alpha,\\delta,\\tau)=1</span> iff the following holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">n&amp;gt;0</span>, <span class="math">\\delta&amp;gt;0</span>, <span class="math">\\tau\\geq 0</span> are all polynomial functions in <span class="math">\\lambda</span>; <span class="math">\\alpha&amp;gt;0</span> is a constant;</li>

      <li>There exists a constant <span class="math">\\eta^{\\prime}&amp;gt;0</span> such that <span class="math">p(1-(2\\delta+2)p)\\geq(1+\\eta^{\\prime})q</span>. (This is needed for the underlying <span class="math">\\mathsf{snailchain}</span> to be secure.)</li>

      <li><span class="math">Q:=(1-5\\eta)(1-\\alpha)&amp;gt;\\frac{2}{3}</span>. (This is needed such that we get <span class="math">&amp;gt;2/3</span> chain quality for <span class="math">\\mathsf{snailchain}</span>.)</li>

      <li><span class="math">G^{\\prime}:=(1+5\\eta)n\\rho&amp;lt;\\frac{\\lambda}{\\eta(T_{\\mathsf{bft}}+\\delta)}</span> for any <span class="math">\\lambda\\in\\mathbb{N}</span>. (This is needed such that the chain does not grow too fast to ensure liveness.)</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\tau&gt;3\\lambda(1+\\frac{1}{\\eta})/((1-5\\eta)(1-\\alpha)n\\rho)+c\\lambda\\delta</span> for some appropriately large constant <span class="math">c</span>. (This is needed such that the adversary is sufficiently constrained in agility.)</li>

    </ul>

    <p class="text-gray-300">In the above, parameters <span class="math">p,q,\\gamma</span> are functions in <span class="math">n,\\alpha,\\delta</span> as defined in Section 4.1.</p>

    <h6 id="sec-104" class="text-base font-medium mt-4">Theorem 9 (Hybrid consensus over Fruitchain: restatement of Theorem 3).</h6>

    <p class="text-gray-300">For any (arbitrarily small) constant <span class="math">\\epsilon&gt;0</span>, let <span class="math">\\alpha=\\frac{1}{3}-\\epsilon</span>, and for every <span class="math">n,\\delta</span>, there exists a sufficiently small <span class="math">\\rho:=\\Theta(\\frac{1}{\\delta n})</span>, a suitable <span class="math">\\kappa=\\Theta(\\lambda)</span>, and constant <span class="math">\\eta&gt;0</span>, such that HybridConsensus^{λ,η} over Fruitchain with parameters <span class="math">(\\rho,\\kappa)</span>, is secure w.r.t. any p.p.t. <span class="math">(n,\\alpha,\\delta,\\tau)</span>-valid<span class="math">(\\mathcal{A},\\mathcal{Z})</span> for any suitable <span class="math">\\tau</span> such that <span class="math">\\Gamma_{\\rho,\\eta}^{\\text{hcfruit}}(n,\\alpha,\\delta,\\tau)=1</span> where</p>

    <p class="text-gray-300"><span class="math">T_{warmup}:=1.5\\lambda(1+\\frac{1}{\\eta})/(1-5\\eta)n\\rho,\\quad T_{confirm}:=O(\\lambda\\delta)</span></p>

    <p class="text-gray-300">Again, the above <span class="math">T_{\\text{confirm}}=O(\\lambda\\delta)</span> is the worst-case transaction confirmation time (i.e., even when under attack). The optimistic transaction confirmation time is <span class="math">O(\\delta)</span>, i.e., independent of the security parameter <span class="math">\\lambda</span>.</p>

    <h2 id="sec-105" class="text-2xl font-bold">7 Proof Roadmap</h2>

    <p class="text-gray-300">Before presenting the detailed proofs, we first describe a high-level roadmap to aid understanding. For simplicity, we use hybrid consensus over Nakamoto as an example in our description, since the proof for hybrid consensus over Fruitchain is the same except with different parameters.</p>

    <h5 id="sec-106" class="text-base font-semibold mt-4">HybridConsensus from DailyBFT.</h5>

    <p class="text-gray-300">Our proof will proceed in the following steps.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First, primarily in Lemma 2, Lemma 3, and Fact 4, we prove that when executing as a subprotocol of HybridConsensus, all instances of DailyBFT have a valid environment with overwhelming probability. Once we show this, we can henceforth rely on the the security properties of DailyBFT in the remainder of the proof.</li>

      <li>Next, we prove a pair of lemmas that establishes <span class="math">T_{\\text{stamp}}(R)</span> as a “deadline” for each day <span class="math">R</span>. All honest committee members’ actions will have completed and taken effect by time <span class="math">T_{\\text{stamp}}(R)</span>.</li>

    </ol>

    <p class="text-gray-300">Lemma 4 says, roughly, that all honest committee members for day <span class="math">R</span> will have stamped a correct signed daily hash to snailchain by time <span class="math">T_{\\text{stamp}}(R)</span>. Fact 5 says, roughly, that nodes which spawn later than <span class="math">T_{\\text{stamp}}(R)</span> will not create a DailyBFT(<span class="math">R</span>) instance, but will rely on on-chain stamped daily log hashes to decide the <span class="math">R</span>-th day’s daily log.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Having established <span class="math">T_{\\text{stamp}}(R)</span> as a deadline for day <span class="math">R</span>, we then prove consistency using the following strategy (Lemma 5 and Theorem 10):</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For nodes that actually created a DailyBFT(<span class="math">R</span>) instance, we know that they must have spawned before <span class="math">T_{\\text{stamp}}(R)</span>. We therefore rely on properties of DailyBFT(<span class="math">R</span>) to prove consistency for such nodes (committee member or non-member alike).</li>

      <li>For nodes that did not spawn a DailyBFT(<span class="math">R</span>) instance, we show that they would satisfy consistency too if they recovered their daily log by examining what is stamped on the snailchain. Intuitively, committee members always stamp the correctly signed daily log hash on snailchain before they ever become corrupt. Therefore, even if they become corrupt later and can henceforth stamp arbitrary things onto snailchain, it will be too late since honest node only recognize the first stamped daily log hash for committee member’s public key.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Finally, we prove the liveness of hybrid consensus (Theorem 11) roughly as follows. Informally, suppose the environment inputs <span class="math">\\mathsf{tx}</span> to an honest node during day <span class="math">R</span> (roughly speaking). There are two cases: 1) <span class="math">\\mathsf{tx}</span> is proposed early enough in day <span class="math">R</span>, such that the liveness property of the <span class="math">\\mathsf{DailyBFT}[R]</span> instance applies; and 2) <span class="math">\\mathsf{tx}</span> is proposed too late to be incorporated in day <span class="math">R</span>’s log since <span class="math">\\mathsf{tx}</span> is closed very close to the end of day. In this case, <span class="math">\\mathsf{tx}</span> will be rolled over to day <span class="math">R+1</span>. Intuitively since the <span class="math">\\mathsf{DailyBFT}[R]</span> instance will terminate quickly, and by the liveness property of <span class="math">\\mathsf{DailyBFT}[R+1]</span>, it also will not take too long before <span class="math">\\mathsf{tx}</span> is incorporated into the log of day <span class="math">R+1</span>.</li>

    </ol>

    <p class="text-gray-300">The above, however, only applies to nodes who actually spawned a <span class="math">\\mathsf{DailyBFT}[R]</span> (or <span class="math">\\mathsf{DailyBFT}[R+1]</span>) instance. For any node that joins too late and did not spawn a <span class="math">\\mathsf{DailyBFT}[R]</span> (or <span class="math">\\mathsf{DailyBFT}[R+1]</span>), it will output some daily log for day <span class="math">R</span> the moment they spawn by processing historical transcripts. Now, by the consistency property, we know that whatever daily log the late node outputs, it will contain <span class="math">\\mathsf{tx}</span> as well.</p>

    <h4 id="sec-107" class="text-lg font-semibold mt-6">DailyBFT from BFT.</h4>

    <p class="text-gray-300">The most technical part of this proof involves proving the following. Observe that when BFT is run as a subprotocol inside <span class="math">\\mathsf{DailyBFT}</span>, the environment perceived by BFT is partially specified by the <span class="math">\\mathsf{DailyBFT}</span> protocol. Recall that the environment for BFT needs to implement a signing oracle for BFT. When run inside <span class="math">\\mathsf{DailyBFT}</span> as a subprotocol, the signing oracle is implemented by the <span class="math">\\mathsf{DailyBFT}</span> protocol. By definition of the honest <span class="math">\\mathsf{DailyBFT}</span> protocol, honest nodes never disclose their signature secret keys. For such an environment (of BFT), if the security properties specified in Section 4.2 can be broken by a p.p.t. adversary <span class="math">\\mathcal{A}</span>, we can construct a reduction <span class="math">\\mathsf{Re}</span> that breaks signature security.</p>

    <p class="text-gray-300">The above essentially allows us to prove that when BFT is run inside <span class="math">\\mathsf{DailyBFT}</span> as a subprotocol instance, the environment for BFT is nice such that all of the stated security properties for BFT will hold except with negligible probability. The remainder of this proof henceforth relies on these properties of BFT to make arguments.</p>

    <h2 id="sec-108" class="text-2xl font-bold">8 Detailed Proofs</h2>

    <p class="text-gray-300">Below we present our proofs for hybrid consensus over Nakamoto, and the proof for hybrid consensus over Fruitchain is the same except with altered parameters.</p>

    <h3 id="sec-109" class="text-xl font-semibold mt-8">8.1 Terminology and Simple Facts</h3>

    <h4 id="sec-110" class="text-lg font-semibold mt-6">Environment for a subprotocol.</h4>

    <p class="text-gray-300">In an execution of the protocol <span class="math">\\mathsf{HybridConsensus}</span> with <span class="math">\\mathcal{A},\\mathcal{Z}</span>, let <span class="math">(\\mathcal{A},\\mathcal{Z})[\\mathsf{subprot}[\\mathsf{sid}]]</span> be the adversary/environment pair that subprotocol instance <span class="math">\\mathsf{subprot}[\\mathsf{sid}]</span> interfaces with. <span class="math">(\\mathcal{A},\\mathcal{Z})[\\mathsf{subprot}[\\mathsf{sid}]]</span> is defined by <span class="math">(\\mathcal{A},\\mathcal{Z})</span> and the part of <span class="math">\\mathsf{HybridConsensus}</span> outer to <span class="math">\\mathsf{subprot}[\\mathsf{sid}]</span>. We also use the notation <span class="math">\\mathcal{Z}[\\mathsf{subprot}[\\mathsf{sid}]]</span> to denote the environment that subprotocol instance <span class="math">\\mathsf{subprot}[\\mathsf{sid}]</span> interfaces with. Recall that Figure 2 in Section 5.3 illustrates the modular composition of our <span class="math">\\mathsf{HybridConsensus}</span> protocol.</p>

    <p class="text-gray-300">The following fact says that if <span class="math">\\mathsf{DailyBFT}</span>’s environment inputs some <span class="math">\\mathsf{start}(\\mathsf{comm})</span> where <span class="math">\\mathsf{comm}</span> contains a <span class="math">\\mathsf{pk}</span> output by a node <span class="math">i</span> that is honest at time <span class="math">t\\geq T_{\\text{start}}</span>, then node <span class="math">i</span> must have output <span class="math">\\mathsf{pk}</span> before <span class="math">T_{\\text{start}}</span>. In other words, <span class="math">\\mathsf{DailyBFT}</span>’s environment cannot predict future <span class="math">\\mathsf{pk}</span> pairs output by honest nodes. This simple fact is handy throughout, since whenever we say that some <span class="math">\\mathsf{pk}\\in\\mathsf{comm}</span> is output by an honest node <span class="math">i</span>, this honest node is implicitly a committee member. Recall that by definition, for a node <span class="math">i</span> to be considered a committee member, it must have output some <span class="math">\\mathsf{pk}\\in\\mathsf{comm}</span> prior to <span class="math">T_{\\text{start}}</span>.</p>

    <p class="text-gray-300">.</p>

    <h6 id="sec-111" class="text-base font-medium mt-4">Fact 1 (Unpredictability of public keys.).</h6>

    <p class="text-gray-300">Assume that the signature scheme is secure, it must hold that for any p.p.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> and any <span class="math">\\lambda\\in\\mathbb{N}</span>, the following property holds for <span class="math">\\mathrm{exec}<a href="\\mathcal{A},\\mathcal{Z},\\lambda">\\mathsf{DailyBFT}</a></span>, with <span class="math">1-\\mathsf{negl}(\\lambda)</span> probability:</p>

    <p class="text-gray-300">If the <span class="math">\\mathcal{Z}</span> inputs to any honest node <span class="math">\\mathsf{start}(\\mathsf{comm})</span>, and let <span class="math">i</span> be a node that is honest at time <span class="math">t\\geq T_{start}</span> and moreover has output <span class="math">\\mathsf{pk}\\in\\mathsf{comm}</span>, then it holds that node <span class="math">i</span> is an honest committee member w.r.t. <span class="math">\\mathsf{DailyBFT}</span> at time <span class="math">t</span>, i.e., the aforementioned <span class="math">\\mathsf{pk}\\in\\mathsf{comm}</span> must be output by <span class="math">i</span> before <span class="math">T_{start}</span>.</p>

    <h6 id="sec-112" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Straightforward by the fact that a secure signature scheme must have high-entropy public keys. ∎</p>

    <h6 id="sec-113" class="text-base font-medium mt-4">Fact 2.</h6>

    <p class="text-gray-300">For a secure signature scheme, polynomially many honestly generated public keys will not collide with <span class="math">1-\\mathsf{negl}(\\lambda)</span> probability.</p>

    <p class="text-gray-300">Therefore henceforth we simply assume that signature public keys generated by honest nodes do not collide.</p>

    <h3 id="sec-114" class="text-xl font-semibold mt-8">8.2 Hybrid Consensus Proofs</h3>

    <h4 id="sec-115" class="text-lg font-semibold mt-6">Times for notable events.</h4>

    <p class="text-gray-300">Given Lemma 2, we know that for every polynomially bounded <span class="math">R\\in N</span>, <span class="math">(\\mathcal{A},\\mathcal{Z})[\\mathsf{DailyBFT}[R]]</span> respects committee agreement. Therefore the notion of an honest committee member is well-defined for protocol instance <span class="math">\\mathsf{DailyBFT}[R]</span>. For convenience, we explicitly define the following times for important events.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">T_{\\mathrm{start}}(R)</span>: earliest time that an honest committee member inputs <span class="math">\\mathsf{start}</span> to its <span class="math">\\mathsf{DailyBFT}[R]</span> instance;</li>

      <li><span class="math">T_{\\mathrm{stop}}(R)</span>: earliest time that an honest committee member inputs <span class="math">\\mathsf{stop}</span> to its <span class="math">\\mathsf{DailyBFT}[R]</span> instance.</li>

      <li><span class="math">T_{\\mathrm{stamp}}(R):=T_{\\mathrm{start}}(R)+\\lambda/G+T_{\\mathrm{bft}}+\\delta+T_{\\mathrm{snail}}</span>.</li>

    </ul>

    <h6 id="sec-116" class="text-base font-medium mt-4">Lemma 2 (<span class="math">\\mathsf{DailyBFT}</span>’s environment satisfies committee agreement, close start and stop, and temporary static corruption).</h6>

    <p class="text-gray-300">Let <span class="math">(\\mathcal{A},\\mathcal{Z})</span> be <span class="math">(n,\\alpha,\\delta,\\tau)</span>-valid w.r.t. <span class="math">\\mathsf{HybridConsensus}</span> for any <span class="math">n\\in\\mathbb{N},\\alpha&gt;0,\\delta&gt;0</span>, and <span class="math">\\tau&gt;3\\lambda/G+T_{\\mathrm{bft}}+\\delta+T_{\\mathrm{snail}}</span> such that <span class="math">\\mathsf{snailchain}</span> satisfies consistency, <span class="math">Q</span>-chain quality, and <span class="math">(G,G^{\\prime})</span>-chain growth w.r.t. <span class="math">(\\mathcal{A},\\mathcal{Z})[\\mathsf{snailchain}]</span>. Then, for any <span class="math">\\lambda\\in\\mathbb{N}</span>, the following properties hold for <span class="math">\\mathrm{exec}<a href="\\mathcal{A},\\mathcal{Z},\\lambda">\\mathsf{HybridConsensus}</a></span> with <span class="math">1-\\mathsf{negl}(\\lambda)</span> probability:</p>

    <p class="text-gray-300">For any <span class="math">R=\\mathsf{poly}(\\lambda)\\in\\mathbb{N}</span>, <span class="math">(\\mathcal{A},\\mathcal{Z})[\\mathsf{DailyBFT}[R]]</span> satisfies committee agreement, close start and stop, and temporary static corruption.</p>

    <h6 id="sec-117" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Committee agreement follows in a straightforward manner from the definition of <span class="math">\\mathsf{HybridConsensus}</span> and from the consistency property of <span class="math">\\mathsf{snailchain}</span>.</p>

    <p class="text-gray-300">Close start and stop follows in a straightforward manner from the definition of <span class="math">\\mathsf{HybridConsensus}</span> and from the consistent length property of <span class="math">\\mathsf{snailchain}</span> (which is part of chain growth).</p>

    <p class="text-gray-300">Temporary static corruption follows in a straightforward manner from the definition of <span class="math">T_{\\mathrm{stamp}}(R)</span> and the underlying <span class="math">\\tau</span>-agile corruption model. ∎</p>

    <h6 id="sec-118" class="text-base font-medium mt-4">Fact 3 (Bounded day length).</h6>

    <p class="text-gray-300">Let <span class="math">(\\mathcal{A},\\mathcal{Z})</span> be <span class="math">(n,\\alpha,\\delta,\\tau)</span>-valid w.r.t. <span class="math">\\mathsf{HybridConsensus}</span> for any <span class="math">n\\in\\mathbb{N},\\alpha&gt;0,\\delta&gt;0</span>, and <span class="math">\\tau\\geq 0</span> such that <span class="math">\\mathsf{snailchain}</span> satisfies consistency, <span class="math">Q</span>-chain quality, and <span class="math">(G,G^{\\prime})</span>-chain growth w.r.t. <span class="math">(\\mathcal{A},\\mathcal{Z})[\\mathsf{snailchain}]</span>. Then, for any <span class="math">\\lambda\\in\\mathbb{N}</span>, the following holds for <span class="math">\\mathrm{exec}<a href="\\mathcal{A},\\mathcal{Z},\\lambda">\\mathsf{HybridConsensus}</a></span> with <span class="math">1-\\mathsf{negl}(\\lambda)</span> probability:</p>

    <p class="text-gray-300"><span class="math">2\\lambda/G^{\\prime}\\leq T_{start}(1)\\leq 2\\lambda/G,</span> <span class="math">\\forall R=\\mathsf{poly}(\\lambda)\\in\\mathbb{N}:T_{start}(R)+\\lambda/G^{\\prime}\\leq T_{stop}(R)=T_{start}(R+1)\\leq T_{start}(R)+\\lambda/G</span></p>

    <h6 id="sec-119" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">For a <span class="math">(\\mathcal{A},\\mathcal{Z})</span> pair satisfying the above requirements, the following statements hold with <span class="math">1-\\mathsf{negl}(\\lambda)</span> probability for <span class="math">\\mathrm{exec}<a href="\\mathcal{A},\\mathcal{Z},\\lambda">\\mathsf{HybridConsensus}</a></span> for any <span class="math">\\lambda\\in\\mathbb{N}</span>.</p>

    <p class="text-gray-300">The fact that <span class="math">T_{\\mathrm{stop}}(R)=T_{\\mathrm{start}}(R+1)</span> follows in a straightforward manner from the definition of the honest <span class="math">\\mathsf{HybridConsensus}</span> protocol. Further, by the definition of the honest <span class="math">\\mathsf{HybridConsensus}</span> protocol, honest nodes send <span class="math">\\mathsf{stop}</span> to <span class="math">\\mathsf{DailyBFT}[R-1]</span> when their local chain length reaches <span class="math">\\mathsf{csize}R+\\lambda</span>. By <span class="math">(G,G^{\\prime})</span>-chain growth, it follows that <span class="math">T_{\\mathrm{start}}(R)+\\lambda/G^{\\prime}\\leq T_{\\mathrm{stop}}(R)=T_{\\mathrm{start}}(R+1)\\leq T_{\\mathrm{start}}(R)+\\mathsf{csize}/G=T_{\\mathrm{start}}(R)+\\lambda/G</span>. Similarly, by <span class="math">(G,G^{\\prime})</span>-chain growth, it holds that <span class="math">2\\lambda/G^{\\prime}\\leq T_{\\mathrm{start}}(1)\\leq 2\\lambda/G</span>. ∎</p>

    <p class="text-gray-300">Henceforth, we will assume that <span class="math">\\mathrm{exec}<a href="\\mathcal{A},\\mathcal{Z},\\lambda">\\mathsf{HybridConsensus}</a></span> will assert the bad events declared in Fact 1, Lemma 2, and Fact 3. If such bad events ever happen, the execution aborts. Since all these bad events occur with <span class="math">\\mathsf{negl}(\\lambda)</span> probability, the new execution with the bad events asserted is computationally indistinguishable to an <span class="math">(\\mathcal{A},\\mathcal{Z})</span> pair that satisfies the conditions specified in Fact 1, Lemma 2, and Fact 3.</p>

    <p class="text-gray-300">In particular, since we assume committee agreement, henceforth we will use the notation <span class="math">\\mathsf{comm}_{R}</span> to denote the globally agreed upon committee for the <span class="math">R</span>-th day in any specific view in the support of <span class="math">\\mathrm{exec}<a href="\\mathcal{A},\\mathcal{Z},\\lambda">\\mathsf{HybridConsensus}</a></span>.</p>

    <h6 id="sec-120" class="text-base font-medium mt-4">Lemma 3 (Sufficiently many <span class="math">\\mathsf{comm}_{R}</span> members remain honest till <span class="math">T_{\\mathrm{stamp}}(R)</span>).</h6>

    <p class="text-gray-300">Let <span class="math">Q,G,G^{\\prime}</span> be polynomially-bounded functions in <span class="math">\\lambda,n,\\alpha,\\delta</span>. For any <span class="math">T_{bft}&gt;0</span>, and any constant <span class="math">\\eta&gt;0</span>, let <span class="math">T_{snail}:=(1+\\eta)\\lambda/G</span>, let <span class="math">(\\mathcal{A},\\mathcal{Z})</span> be <span class="math">(n,\\alpha,\\delta,\\tau)</span>-valid w.r.t. <span class="math">\\mathsf{HybridConsensus}</span> for any <span class="math">n\\in\\mathbb{N},\\alpha&gt;0,\\delta&gt;0</span>, and <span class="math">\\tau&gt;3\\lambda/G+T_{bft}+\\delta+T_{snail}</span> such that <span class="math">\\mathsf{snailchain}</span> satisfies consistency, <span class="math">Q</span>-chain quality, and <span class="math">(G,G^{\\prime})</span>-chain growth w.r.t. <span class="math">(\\mathcal{A},\\mathcal{Z})[\\mathsf{snailchain}]</span>. Then, for any <span class="math">\\lambda\\in\\mathbb{N}</span>, the following property holds for <span class="math">\\mathrm{exec}<a href="\\mathcal{A},\\mathcal{Z},\\lambda">\\mathsf{HybridConsensus}</a></span> with <span class="math">1-\\mathsf{negl}(\\lambda)</span> probability:</p>

    <p class="text-gray-300">For any <span class="math">R=\\mathsf{poly}(\\lambda)\\in\\mathbb{N}</span>, at least <span class="math">Q</span> fraction of <span class="math">\\mathsf{comm}_{R}</span> are output by nodes that remain honest till</p>

    <p class="text-gray-300"><span class="math">T_{stamp}(R):=T_{start}(R)+\\lambda/G+T_{bft}+\\delta+T_{snail},</span></p>

    <h6 id="sec-121" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">For a <span class="math">(\\mathcal{A},\\mathcal{Z})</span> pair satisfying the above requirements, the following statements hold with <span class="math">1-\\mathsf{negl}(\\lambda)</span> probability for <span class="math">\\mathrm{exec}<a href="\\mathcal{A},\\mathcal{Z},\\lambda">\\mathsf{HybridConsensus}</a></span> for any <span class="math">\\lambda\\in\\mathbb{N}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathsf{chain}</span> be an honest node’s local chain at any time s.t. $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{chain}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\mathsf{upper}(R)<span class="math">. By </span>Q<span class="math">-chain quality and since </span>\\mathsf{csize}=\\lambda<span class="math">, at least </span>Q<span class="math">-fraction of </span>\\mathsf{chain}[\\mathsf{lower}(R),\\mathsf{upper}(R)]<span class="math"> are intact blocks w.r.t. </span>\\mathsf{chain}[:\\mathsf{lower}(R)-1]<span class="math">. This means that for at least </span>Q<span class="math"> fraction of indices </span>i\\in[\\mathsf{lower}(R),\\mathsf{upper}(R)]<span class="math">, there exists a node </span>j<span class="math"> that was intact at some earlier time </span>t<span class="math">, such that it output to </span>\\mathcal{Z}[\\mathsf{snailchain}]<span class="math"> </span>\\mathsf{chain}^{\\prime}<span class="math"> that contains the prefix </span>\\mathsf{chain}[:\\mathsf{lower}(R)-1]<span class="math"> at time </span>t-1<span class="math">, and </span>\\mathcal{Z}[\\mathsf{snailchain}]<span class="math"> provided input </span>\\mathsf{chain}[i]:=(\\mathsf{recs},\\mathsf{pk})<span class="math"> to node </span>j<span class="math"> at time </span>t<span class="math">. By definition of the </span>\\mathsf{HybridConsensus}<span class="math"> protocol, </span>\\mathsf{pk}\\in\\mathsf{comm}_{R}<span class="math"> and </span>\\mathsf{pk}<span class="math"> must be an output of some </span>\\mathsf{DailyBFT}[R]<span class="math"> instance of node </span>j<span class="math"> at time </span>t<span class="math">. Now due to </span>(G,G^{\\prime})<span class="math">-chain growth, at most </span>(\\mathsf{csize}+\\lambda)/G=2\\lambda/G<span class="math"> time elapsed between </span>t<span class="math"> and </span>T_{\\mathrm{start}}(R)<span class="math">. Finally, due to </span>\\tau>(3\\lambda/G+T_{\\mathrm{bft}}+\\delta+T_{\\mathrm{snail}})<span class="math">-agility, we have that node </span>j<span class="math"> remains honest till </span>T_{\\mathrm{stamp}}(R)<span class="math">. Therefore, at least </span>Q<span class="math"> fraction of </span>\\mathsf{comm}_{R}<span class="math"> are output by nodes that remain honest till </span>T_{\\mathrm{stamp}}(R)$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Next, we show that <span class="math">T_{\\mathrm{stamp}}(R)</span> is chosen sufficiently far out to give enough time for all <span class="math">\\mathsf{comm}_{R}</span> members’ <span class="math">\\mathsf{DailyBFT}</span> instances to output a final daily log (possibly empty) that is consistent with each other.</p>

    <p class="text-gray-300">Fact 4 (DailyBFT's environment is valid). Let <span class="math">Q, G, G&#x27;</span> be polynomially-bounded functions in <span class="math">\\lambda, n, \\alpha, \\delta</span>. For any <span class="math">T_{bft} &amp;gt; 0</span>, and any constant <span class="math">\\eta &amp;gt; 0</span>, let <span class="math">T_{snail} := (1 + \\eta)\\lambda / G</span>, let <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> be <span class="math">(n, \\alpha, \\delta, \\tau)</span>-valid w.r.t. HybridConsensus for any <span class="math">n \\in \\mathbb{N}, \\alpha &amp;gt; 0, \\delta &amp;gt; 0</span>, and <span class="math">\\tau &amp;gt; 3\\lambda / G + T_{bft} + \\delta + T_{snail}</span> such that snailchain satisfies consistency, <span class="math">Q</span>-chain quality, and <span class="math">(G, G&#x27;)</span>-chain growth w.r.t. <span class="math">(\\mathcal{A}, \\mathcal{Z})[\\text{snailchain}]</span>.</p>

    <p class="text-gray-300">Then, for any <span class="math">\\lambda \\in \\mathbb{N}</span>, with <span class="math">1 - \\mathrm{negl}(\\lambda)</span> probability, the following holds for EXECHybridConsensus: <span class="math">(\\mathcal{A}, \\mathcal{Z}, \\lambda): (\\mathcal{A}, \\mathcal{Z})[\\text{DailyBFT}[R]]</span> is <span class="math">(n, Q, \\delta, \\tau, T_{\\text{stamp}}(R), T_{bft})</span>-valid w.r.t. DailyBFT.</p>

    <p class="text-gray-300">Proof. Straightforward by combining Lemmas 2, 3 and Fact 3.  <span class="math">\\square</span></p>

    <p class="text-gray-300">Lemma 4 (Timely stamping). Let <span class="math">G, G&#x27;, Q</span> be polynomially-bounded functions in <span class="math">\\lambda, n, \\alpha, \\delta</span>. Suppose that DailyBFT is secure against <span class="math">(1 - Q)</span>-corruption with liveness parameter <span class="math">T_{bft}</span>. For any constant <span class="math">\\eta &amp;gt; 0</span>, let <span class="math">T_{snail} := (1 + \\eta)\\lambda / G</span>. Let <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> be <span class="math">(n, \\alpha, \\delta, \\tau)</span>-valid w.r.t. HybridConsensus for some <span class="math">n \\in \\mathbb{N}, \\alpha &amp;gt; 0, \\delta &amp;gt; 0</span>, and <span class="math">\\tau &amp;gt; 3\\lambda / G + T_{bft} + \\delta + T_{snail}</span> such that snailchain satisfies consistency, <span class="math">Q</span>-chain quality, and <span class="math">(G, G&#x27;)</span>-chain growth except w.r.t. <span class="math">(\\mathcal{A}, \\mathcal{Z})[\\text{snailchain}]</span>. Then, for any <span class="math">\\lambda \\in \\mathbb{N}</span>, with <span class="math">1 - \\mathrm{negl}(\\lambda)</span> probability, the following property holds for EXECHybridConsensus $$ for any <span class="math">R = \\mathrm{poly}(\\lambda) \\in \\mathbb{N}</span>.</p>

    <p class="text-gray-300">Suppose that any honest node outputs a chain at time <span class="math">t \\geq T_{\\text{stamp}}(R)</span>. For any <span class="math">\\mathsf{pk} \\in \\mathsf{comm}_R</span> output by some node <span class="math">i</span> that is honest at <span class="math">T_{\\text{stamp}}(R)</span>, let <span class="math">h := \\mathsf{hash}(\\log_R)</span> where <span class="math">\\log_R</span> represents the final log output by node <span class="math">i</span>'s DailyBFT[R] instance, then, a valid record of the form <span class="math">\\{R, h\\}_{\\mathsf{pk}^{-1}}</span> (where validity is defined by signature verification) is included in chain[: <span class="math">-\\lambda</span>], and it is not preceded by any other valid record of the form <span class="math">\\{R, h&#x27;\\}_{\\mathsf{pk}^{-1}}</span> for a different <span class="math">h&#x27; \\neq h</span>.</p>

    <p class="text-gray-300">Proof. For a <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> pair satisfying the above requirements, the following statements hold with <span class="math">1 - \\mathrm{negl}(\\lambda)</span> probability for EXECHybridConsensus $$ for any <span class="math">\\lambda \\in \\mathbb{N}</span>.</p>

    <p class="text-gray-300">Due to Fact 4, <span class="math">(\\mathcal{A}, \\mathcal{Z})[\\text{DailyBFT}[R]]</span> is <span class="math">(n, \\alpha, \\delta, \\tau, Q, T_{\\text{stamp}}(R), T_{\\text{bft}})</span>-valid w.r.t. DailyBFT. By Fact 1, for such a <span class="math">\\mathsf{pk} \\in \\mathsf{comm}_R</span> output by node <span class="math">i</span> that is honest at time <span class="math">T_{\\text{stamp}}(R)</span>, node <span class="math">i</span> is an honest committee member w.r.t. DailyBFT[R]. Therefore, by timely termination of DailyBFT, node <span class="math">i</span>'s DailyBFT[R] instance will have output some tuple done(log, recs) by time <span class="math">T_{\\text{stop}}(R) + T_{\\text{bft}}</span>. By definition of honest HybridConsensus algorithm, node <span class="math">i</span> will have called snailpool.propose(recs) by <span class="math">T_{\\text{stop}}(R) + T_{\\text{bft}}</span>; and by definition of the mempool protocol, every honest node's snailpool.TXs will contain recs by <span class="math">T_{\\text{stop}}(R) + T_{\\text{bft}} + \\delta</span>. Therefore, starting at time <span class="math">T_{\\text{stop}}(R) + T_{\\text{bft}} + \\delta</span>, in every time step, <span class="math">\\mathcal{Z}[\\text{snailchain}]</span> will include recs in its input to snailchain for every honest node whose local chain[: <span class="math">-\\lambda</span>] does not yet contain rec. By the liveness property of snailchain, any time after <span class="math">T_{\\text{stop}}(R) + T_{\\text{bft}} + \\delta + T_{\\text{snail}}</span>, recs will appear in every honest node's local chain[: <span class="math">-\\lambda</span>]. By the completeness property of the DailyBFT protocol, <span class="math">\\{R, h\\}_{\\mathsf{pk}^{-1}} \\in \\mathsf{recs}</span>, where <span class="math">h := \\mathsf{hash}(\\log)</span>. Finally, due to Fact 3, <span class="math">T_{\\text{stop}}(R) - T_{\\text{start}}(R) &amp;lt; \\lambda / G</span>. Therefore it holds that by time <span class="math">T_{\\text{stamp}}(R) = T_{\\text{start}}(R) + \\lambda / G + T_{\\text{bft}} + \\delta + T_{\\text{snail}}</span>, every honest node's local chain[: <span class="math">-\\lambda</span>] will contain <span class="math">\\{R, \\mathsf{hash}(\\log)\\}_{\\mathsf{pk}^{-1}}</span>, where log is the final daily log output by node <span class="math">i</span>'s DailyBFT[R] instance.</p>

    <p class="text-gray-300">We now prove that such a tuple <span class="math">\\mathsf{rec} := \\{R, h\\}_{\\mathsf{pk}^{-1}}</span> is the first of its kind to appear in chain[: <span class="math">-\\lambda</span>], i.e., there is no other valid record of the form <span class="math">\\mathsf{rec}&#x27; := \\{R, h&#x27;\\}_{\\mathsf{pk}^{-1}}</span> where <span class="math">h&#x27; \\neq h</span> preceding rec in chain. We prove by contradiction. Suppose there is such a tuple <span class="math">\\mathsf{rec}&#x27;</span> preceding rec in chain[: <span class="math">-\\lambda</span>]. Since rec must have appeared in chain[: <span class="math">-\\lambda</span>] at time <span class="math">T_{\\text{stamp}}</span>, due to the consistency property of snailchain, so must <span class="math">\\mathsf{rec}&#x27;</span>. However, by the definition of the honest DailyBFT algorithm, an honest node should not have output two different done(_,_) messages with different final logs. Therefore, if <span class="math">\\mathsf{rec}&#x27;</span> appears in an honest node's chain[: <span class="math">-\\lambda</span>] by time <span class="math">T_{\\text{stamp}}</span>, this would obviously violate the unforgeability property of DailyBFT.</p>

    <p class="text-gray-300">Fact 5 (No late spawning of DailyBFT). Let <span class="math">G, G&#x27;, Q</span> be polynomially-bounded functions in <span class="math">\\lambda, n, \\alpha, \\delta</span>. Suppose that DailyBFT is secure against <span class="math">(1 - Q)</span>-corruption with liveness parameter <span class="math">T_{bft}</span>. For any</p>

    <p class="text-gray-300">40</p>

    <p class="text-gray-300">constant <span class="math">\\eta&gt;0</span>, let <span class="math">T_{snail}:=(1+\\eta)\\lambda/G</span>. Let <span class="math">(\\mathcal{A},\\mathcal{Z})</span> be <span class="math">(n,\\alpha,\\delta,\\tau)</span>-valid w.r.t. <span class="math">\\mathsf{HybridConsensus}</span> for some <span class="math">n\\in\\mathbb{N},\\alpha&gt;0,\\delta&gt;0</span>, and <span class="math">\\tau&gt;3\\lambda/G+T_{bft}+\\delta+T_{snail}</span> such that <span class="math">\\mathsf{snailchain}</span> satisfies consistency, <span class="math">Q</span>-chain quality, and <span class="math">(G,G^{\\prime})</span>-chain growth w.r.t. <span class="math">(\\mathcal{A},\\mathcal{Z})[\\mathsf{snailchain}]</span>. Then, for any <span class="math">\\lambda\\in\\mathbb{N}</span>, with <span class="math">1-\\mathsf{negl}(\\lambda)</span> probability, the following property holds for <span class="math">\\mathrm{exec}<a href="\\mathcal{A},\\mathcal{Z},\\lambda">\\mathsf{HybridConsensus}</a></span> and for any <span class="math">R=\\mathsf{poly}(\\lambda)\\in\\mathbb{N}</span>.</p>

    <p class="text-gray-300">An honest node only forks an <span class="math">\\mathsf{DailyBFT}[R]</span> instance if it spawns by time <span class="math">T_{stamp}(R)</span>.</p>

    <h6 id="sec-122" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Straightforward by the definition of the <span class="math">\\mathsf{HybridConsensus}</span> algorithm and Lemma 4. ∎</p>

    <h6 id="sec-123" class="text-base font-medium mt-4">Lemma 5 (Retroactive consistency).</h6>

    <p class="text-gray-300">Let <span class="math">Q&gt;\\frac{2}{3}</span>, let <span class="math">G,G^{\\prime}</span> be polynomially-bounded functions in <span class="math">\\lambda,n,\\alpha,\\delta</span>. Suppose that <span class="math">\\mathsf{DailyBFT}</span> is secure against <span class="math">(1-Q)</span>-corruption with liveness parameter <span class="math">T_{bft}</span>. For any constant <span class="math">\\eta&gt;0</span>, let <span class="math">T_{snail}:=(1+\\eta)\\lambda/G</span>, let <span class="math">(\\mathcal{A},\\mathcal{Z})</span> be <span class="math">(n,\\alpha,\\delta,\\tau)</span>-valid w.r.t. <span class="math">\\mathsf{HybridConsensus}</span> for some <span class="math">n\\in\\mathbb{N},\\alpha&gt;0,\\delta&gt;0</span>, and <span class="math">\\tau&gt;3\\lambda/G+T_{bft}+\\delta+T_{snail}</span> such that <span class="math">\\mathsf{snailchain}</span> satisfies consistency, <span class="math">Q</span>-chain quality, and <span class="math">(G,G^{\\prime})</span>-chain growth w.r.t. <span class="math">(\\mathcal{A},\\mathcal{Z})[\\mathsf{snailchain}]</span>. Then, for any <span class="math">\\lambda\\in\\mathbb{N}</span>, with <span class="math">1-\\mathsf{negl}(\\lambda)</span> probability, the following property holds for <span class="math">\\mathrm{exec}<a href="\\mathcal{A},\\mathcal{Z},\\lambda">\\mathsf{HybridConsensus}</a></span> and for any <span class="math">R=\\mathsf{poly}(\\lambda)\\in\\mathbb{N}</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\mathsf{chain}</span> denote the output of an honest node at any time. Suppose that <span class="math">(R,h)</span> is an on-chain valid tuple w.r.t. <span class="math">\\mathsf{chain}</span>, it holds that there exists a <span class="math">\\mathsf{pk}\\in\\mathsf{comm}_{R}</span> output by a node <span class="math">i</span> that is honest at <span class="math">T_{stamp}(R)</span>, and <span class="math">h=\\mathsf{hash}(\\mathsf{log}_{R})</span> where <span class="math">\\mathsf{log}_{R}</span> is the (unique) final daily log output by node <span class="math">i</span>’s <span class="math">\\mathsf{DailyBFT}[R]</span> instance.</p>

    <h6 id="sec-124" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">For a <span class="math">(\\mathcal{A},\\mathcal{Z})</span> pair satisfying the above requirements, the following statements hold with <span class="math">1-\\mathsf{negl}(\\lambda)</span> probability for <span class="math">\\mathrm{exec}<a href="\\mathcal{A},\\mathcal{Z},\\lambda">\\mathsf{HybridConsensus}</a></span> for any <span class="math">\\lambda\\in\\mathbb{N}</span>.</p>

    <p class="text-gray-300">For <span class="math">(R,h)</span> to be a valid on-chain tuple w.r.t. <span class="math">\\mathsf{chain}</span>, for at least <span class="math">\\lceil\\mathsf{csize}/3\\rceil</span> number of <span class="math">\\mathsf{pk}\\in\\mathsf{comm}_{R}</span>: 1) a correctly signed tuple <span class="math">\\{R,h\\}_{\\mathsf{pk}^{-1}}</span> must appear in <span class="math">\\mathsf{chain}[:-\\lambda]</span>; and 2) this tuple is the first occurrence of any valid tuple of the form <span class="math">\\{R,_{-}\\}_{\\mathsf{pk}^{-1}}</span> on <span class="math">\\mathsf{chain}</span>.</p>

    <p class="text-gray-300">By Fact 4, at least <span class="math">Q</span> fraction of <span class="math">\\mathsf{comm}_{R}</span> were output by nodes that are honest at time <span class="math">T_{\\mathrm{stamp}}(R)</span>. By assumption <span class="math">Q&gt;\\frac{2}{3}</span>, and due to the pigeon-hole principle, for at least one such signature signed by some public key <span class="math">\\mathsf{pk}</span>, it must hold that it is output by a node <span class="math">i</span> (prior to <span class="math">T_{\\mathrm{start}}(R)</span>) that remains honest till <span class="math">T_{\\mathrm{stamp}}(R)</span>. By Lemma 4, this signature must vouch for <span class="math">(R,\\mathsf{hash}(\\mathsf{log}))</span> where <span class="math">\\mathsf{log}</span> denotes the (unique) final log output by node <span class="math">i</span>. ∎</p>

    <h6 id="sec-125" class="text-base font-medium mt-4">Theorem 10 (Consistency for Hybrid Consensus).</h6>

    <p class="text-gray-300">Suppose that <span class="math">\\mathsf{hash},\\mathsf{H}:\\{0,1\\}^{*}\\to\\{0,1\\}^{\\lambda}</span> are independent random oracles, and that the signature scheme <span class="math">\\Sigma</span> is secure. Let <span class="math">Q&gt;\\frac{2}{3}</span>, let <span class="math">G,G^{\\prime}</span> be polynomially bounded functions in <span class="math">\\lambda,n,\\alpha,\\delta</span>. Suppose that <span class="math">\\mathsf{DailyBFT}</span> is secure against <span class="math">(1-Q)</span>-corruption with liveness parameter <span class="math">T_{bft}</span>. For any constant <span class="math">\\eta&gt;0</span>, let <span class="math">T_{snail}:=(1+\\eta)\\lambda/G</span>. Let <span class="math">(\\mathcal{A},\\mathcal{Z})</span> be <span class="math">(n,\\alpha,\\delta,\\tau)</span>-valid w.r.t. <span class="math">\\mathsf{HybridConsensus}</span> for some <span class="math">n\\in\\mathbb{N},\\alpha&gt;0,\\delta&gt;0</span>, and <span class="math">\\tau&gt;3\\lambda/G+T_{bft}+\\delta+T_{snail}</span> such that <span class="math">\\mathsf{snailchain}</span> satisfies consistency, <span class="math">Q</span>-chain quality, and <span class="math">(G,G^{\\prime})</span>-chain growth w.r.t. <span class="math">(\\mathcal{A},\\mathcal{Z})[\\mathsf{snailchain}]</span>. Then, for any <span class="math">\\lambda\\in\\mathbb{N}</span>, with <span class="math">1-\\mathsf{negl}(\\lambda)</span> probability, <span class="math">\\mathrm{exec}<a href="\\mathcal{A},\\mathcal{Z},\\lambda">\\mathsf{HybridConsensus}</a></span> satisfies consistency as defined in Section 3.2.</p>

    <h6 id="sec-126" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Self-consistency holds trivially from the definition of <span class="math">\\mathsf{HybridConsensus}</span>. Below we focus on proving common prefix. For a <span class="math">(\\mathcal{A},\\mathcal{Z})</span> pair satisfying the above requirements, the following statements hold with <span class="math">1-\\mathsf{negl}(\\lambda)</span> probability for <span class="math">\\mathrm{exec}<a href="\\mathcal{A},\\mathcal{Z},\\lambda">\\mathsf{HybridConsensus}</a></span> for any <span class="math">\\lambda\\in\\mathbb{N}</span>.</p>

    <p class="text-gray-300">By definition of the honest <span class="math">\\mathsf{HybridConsensus}</span> algorithm, we can parse an honest node’s <span class="math">\\mathsf{LOG}</span> as the following for some <span class="math">R\\in\\mathbb{N}</span>:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{LOG}:=\\mathsf{log}_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{log}_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{log}_{R-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{log}_{R}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For each <span class="math">\\mathsf{log}_{r}</span> where <span class="math">r\\in[R]</span>, it can be one of the following cases:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Final log of daily offchain consensus. <span class="math">\\log_r</span> is the final log output by a DailyBFT<span class="math">[r]</span> instance. By Fact 5, it holds that this node spawned before <span class="math">T_{\\mathrm{stamp}}(r)</span>.</li>

      <li>Non-final log of daily offchain consensus. <span class="math">\\log_r</span> is contained in an output of a DailyBFT<span class="math">[r]</span> instance, where the output is in the form of <span class="math">\\mathsf{notdone}(\\log_r)</span> — in this case, by definition of the honest HybridConsensus algorithm, it must be the case that <span class="math">\\log_r</span> is the last daily log included in LOG. Further, by Fact 5, it holds that this node spawned before <span class="math">T_{\\mathrm{stamp}}(r)</span>.</li>

      <li>Matching on-chain valid tuple. There is an on-chain valid tuple <span class="math">(r,h)</span> w.r.t. the honest node’s local chain<span class="math">[:-\\lambda]</span> such that <span class="math">\\mathsf{hash}(\\log_r)=h</span>.</li>

    </ol>

    <p class="text-gray-300">First, note that if an honest node <span class="math">i</span>’s DailyBFT<span class="math">[r]</span> instance outputs <span class="math">\\log_r</span> due to 1, and an honest node <span class="math">j</span>’s DailyBFT<span class="math">[r]</span> instance (same or different), outputs <span class="math">\\log_r&#x27;</span> due to 1, it must hold that <span class="math">\\log_r=\\log_r&#x27;</span>. This is straightforward by the consistency property of DailyBFT.</p>

    <p class="text-gray-300">Second, note that if an honest node <span class="math">i</span>’s DailyBFT<span class="math">[r]</span> instance outputs <span class="math">\\log_r</span> due to 1, and an honest node <span class="math">j</span>’s DailyBFT<span class="math">[r]</span> instance (same or different), outputs <span class="math">\\log_r&#x27;</span> due to 2, then it must hold that <span class="math">\\log_r&#x27; \\prec \\log_r</span>. This follows immediately from the consistency property of DailyBFT.</p>

    <p class="text-gray-300">Next, if an honest node <span class="math">j</span> (same or different), outputs <span class="math">\\log_r&#x27;</span> due to 3, there must exist an honest node <span class="math">i</span> that outputs <span class="math">\\log_r</span> due to 1, such that <span class="math">\\log_r = \\log_r&#x27;</span>. This follows directly from Lemma 5, as well as the fact that the hash oracle has negligible probability of collision.</p>

    <p class="text-gray-300">The rest of the proof follows in a straightforward manner, by observing that day lengths are polynomially bounded in <span class="math">\\lambda</span> due to Fact 3; and that for all <span class="math">r = \\mathsf{poly}(\\lambda) \\in \\mathbb{N}</span>, at least at least one <span class="math">\\mathsf{pk} \\in \\mathsf{comm}_r</span> is honest at <span class="math">T_{\\mathrm{stamp}}(r)</span> and will have output <span class="math">\\mathsf{done}(\\neg, -)</span> by time <span class="math">T_{\\mathrm{stamp}}(r)</span>.</p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300">Theorem 11 (Liveness for Hybrid Consensus). Suppose that <span class="math">\\mathsf{hash}, \\mathsf{H} : \\{0,1\\}^* \\to \\{0,1\\}^\\lambda</span> are independent random oracles, and that the signature scheme <span class="math">\\Sigma</span> is secure. Let <span class="math">Q &amp;gt; \\frac{2}{3}</span>, let <span class="math">G</span> be a function in <span class="math">\\lambda, n, \\alpha, \\delta</span>. Suppose that DailyBFT is secure against <span class="math">(1 - Q)</span>-corruption with liveness parameter <span class="math">T_{bft}</span>. For any constant <span class="math">\\eta &amp;gt; 0</span>, let <span class="math">T_{snail} := (1 + \\eta)\\lambda / G</span>. Let <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> be <span class="math">(n, \\alpha, \\delta, \\tau)</span>-valid w.r.t. HybridConsensus for some <span class="math">n \\in \\mathbb{N}, \\alpha &amp;gt; 0, \\delta &amp;gt; 0</span>, and <span class="math">\\tau &amp;gt; 3\\lambda / G + T_{bft} + \\delta + T_{snail}</span> such that snailchain satisfies consistency, <span class="math">Q</span>-chain quality, and <span class="math">(G, G&#x27;)</span>-chain growth w.r.t. <span class="math">(\\mathcal{A}, \\mathcal{Z})[\\mathsf{snailchain}]</span> for some <span class="math">G&#x27; &amp;lt; \\frac{\\lambda}{T_{bft} + \\delta}</span>. Then, for any <span class="math">\\lambda \\in \\mathbb{N}</span>, with <span class="math">1 - \\mathsf{negl}(\\lambda)</span> probability, <span class="math">\\mathrm{exec}<a href="\\mathcal{A}, \\mathcal{Z}, \\lambda">\\mathsf{HybridConsensus}</a></span> satisfies liveness as defined in Section 3.2 with parameters <span class="math">T_{warmup} := 2\\lambda / G</span>, and <span class="math">T_{confirm} := 2T_{bft} + 2\\delta</span>.</p>

    <p class="text-gray-300">Proof. For a <span class="math">(\\mathcal{A},\\mathcal{Z})</span> pair satisfying the above requirements, the following statements hold with <span class="math">1 - \\mathsf{negl}(\\lambda)</span> probability for <span class="math">\\mathrm{exec}<a href="\\mathcal{A},\\mathcal{Z},\\lambda">\\mathrm{HybridConsensus}</a></span> for any <span class="math">\\lambda \\in \\mathbb{N}</span>.</p>

    <p class="text-gray-300">Suppose that <span class="math">\\mathcal{Z}</span> inputs <span class="math">\\mathsf{TXs}</span> to some honest node at time <span class="math">t \\geq T_{\\mathrm{warmup}} = 2\\lambda / G</span>. By definition of the txpool protocol, at time <span class="math">t + \\delta</span>, all honest nodes have <span class="math">\\mathsf{TXs} \\subseteq \\mathsf{txpool}.\\mathsf{TXs}</span>. Suppose that an honest node <span class="math">i</span> is honest at some time <span class="math">t&#x27; \\geq t + T_{\\mathrm{confirm}} = t + 2T_{\\mathrm{bft}} + 2\\delta</span>, and we show that node <span class="math">i</span>'s output LOG at time <span class="math">t&#x27;</span> must include all of <span class="math">\\mathsf{TXs}</span>.</p>

    <p class="text-gray-300">By Fact 3, and the fact that <span class="math">G&#x27; &amp;gt; \\frac{\\lambda}{T_{\\mathrm{bft}} + \\delta}</span>, <span class="math">T_{\\mathrm{start}}(1) \\leq 2\\lambda / G = T_{\\mathrm{warmup}}</span>. Further, for any <span class="math">R \\in \\mathbb{N}</span>, <span class="math">T_{\\mathrm{start}}(R) &amp;lt; T_{\\mathrm{stop}}(R) - T_{\\mathrm{bft}} - \\delta &amp;lt; T_{\\mathrm{start}}(R + 1)</span>. Let <span class="math">R</span> be the smallest integer such that <span class="math">t \\leq T_{\\mathrm{stop}}(R) - T_{\\mathrm{bft}} - \\delta</span>. Now, one of the following two cases has to be true:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 1: <span class="math">t \\geq T_{\\mathrm{start}}(R) = T_{\\mathrm{stop}}(R - 1)</span>.</li>

    </ul>

    <p class="text-gray-300">In this case, by definition of HybridConsensus and Fact 4, there exists an honest <span class="math">\\mathsf{comm}_R</span> member whose <span class="math">\\mathcal{Z}[\\mathsf{DailyBFT}[R]]</span> will include <span class="math">\\mathsf{TXs} \\backslash \\mathsf{LOG}</span> to in its input to <span class="math">\\mathsf{DailyBFT}[R]</span> by <span class="math">t + \\delta &amp;lt; T_{\\mathrm{stop}}(R) - T_{\\mathrm{bft}}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 2: <span class="math">T_{\\mathrm{stop}}(R - 1) - T_{\\mathrm{bft}} - \\delta &amp;lt; t &amp;lt; T_{\\mathrm{stop}}(R - 1) = T_{\\mathrm{start}}(R) &amp;lt; T_{\\mathrm{stop}}(R) - T_{\\mathrm{bft}}</span></li>

    </ul>

    <p class="text-gray-300">In this case, by definition of HybridConsensus and Fact 4, there exists an honest <span class="math">\\mathsf{comm}_R</span> member whose <span class="math">\\mathcal{Z}[\\mathsf{DailyBFT}[R]]</span> will include <span class="math">\\mathsf{TXs}\\backslash \\mathsf{LOG}</span> to in its input to <span class="math">\\mathsf{DailyBFT}[R]</span> by <span class="math">T_{\\mathrm{start}}(R) &amp;lt; t + T_{\\mathrm{bft}} + \\delta</span>.</p>

    <p class="text-gray-300">Therefore, in either case, there exists an honest <span class="math">\\mathsf{comm}_R</span> member whose <span class="math">\\mathcal{Z}[\\mathsf{DailyBFT}[R]]</span> will include <span class="math">\\mathsf{TXs}\\backslash \\mathsf{LOG}</span> to in its input to <span class="math">\\mathsf{DailyBFT}[R]</span> by at time <span class="math">t^{<em>} &amp;lt; t + T_{\\mathrm{bft}} + \\delta</span> such that <span class="math">T_{\\mathrm{start}}(R) \\leq t^{</em>} &amp;lt; T_{\\mathrm{stop}}(R) - T_{\\mathrm{bft}}</span>. Henceforth let the <span class="math">\\mathsf{LOG}^<em></span> denote the output LOG of this committee member at time <span class="math">t^</em></span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We first show that if node <span class="math">i</span> ever forked a DailyBFT[R] instance, and is honest at time <span class="math">t&#x27; \\geq t + 2T_{\\mathrm{bft}} + 2\\delta</span>, then node <span class="math">i</span>'s output LOG at time <span class="math">t&#x27;</span> will include all of TXs.</li>

    </ul>

    <p class="text-gray-300">By Fact 5, if a node <span class="math">i</span> forked a DailyBFT[R] instance, its <span class="math">t_{\\mathrm{spawn}} \\leq T_{\\mathrm{stamp}}(R)</span>. By the liveness property of the DailyBFT protocol and Fact 4, if node <span class="math">i</span> is honest at time <span class="math">t&#x27; \\geq t + 2T_{\\mathrm{bft}} + 2\\delta</span>, then by <span class="math">t&#x27;</span> node <span class="math">i</span>'s DailyBFT[R] instance must have output done <span class="math">(\\log_R, -)</span> such that <span class="math">\\mathsf{TXs}\\backslash \\mathsf{LOG}^* \\subseteq \\log_R</span>.</p>

    <p class="text-gray-300">Now, for any <span class="math">1 \\leq r \\leq R - 1</span>, by definition of the honest HybridConsensus protocol, either node <span class="math">i</span> did not fork a DailyBFT[r] instance and <span class="math">\\log_r</span> was computed during Preprocess (see Figure 4); or node <span class="math">i</span> did fork a DailyBFT[r] instance. In the latter case, we know that node <span class="math">i</span> forked by <span class="math">T_{\\mathrm{stamp}}(r)</span> due to Fact 5. By Fact 4 and the timely termination property of the the DailyBFT protocol, if node <span class="math">i</span> is honest at time <span class="math">t&#x27; \\geq t + 2T_{\\mathrm{bft}} + 2\\delta</span>, node <span class="math">i</span>'s DailyBFT[r] instance will have output done by time <span class="math">t&#x27;</span>.</p>

    <p class="text-gray-300">By the definition of the honest HybridConsensus protocol, if node <span class="math">i</span>'s honest at time <span class="math">t&#x27; \\geq t + 2T_{\\mathrm{bft}} + 2\\delta</span>, its output LOG will contain all of <span class="math">\\mathsf{TXs}\\backslash \\mathsf{LOG}^*</span> at time <span class="math">t&#x27;</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Now, consider the case when node <span class="math">i</span> did not fork a DailyBFT[R] instance. In this case, node <span class="math">i</span> must have computed <span class="math">\\log_R</span> by matching on-chain valid tuples, and <span class="math">\\log_R</span> is output in time <span class="math">t_{\\mathrm{spawn}}</span>.</li>

    </ul>

    <p class="text-gray-300">Due to the Fact 4, there must exist at least one <span class="math">\\mathsf{pk} \\in \\mathsf{comm}_R</span> output by some node <span class="math">\\nu</span> that is honest at time <span class="math">T_{\\mathrm{stamp}}(R)</span>, and by the timely termination property of DailyBFT, node <span class="math">\\nu</span>'s DailyBFT[R] instance will output <span class="math">\\log_R</span> during the time it is honest. By the liveness property of DailyBFT, this final log <span class="math">\\log_R</span> output by node <span class="math">\\nu</span> must include all of <span class="math">\\mathsf{TXs}\\backslash \\mathsf{LOG}^*</span>.</p>

    <p class="text-gray-300">Due to Theorem 10, the <span class="math">\\log_R</span> output by node <span class="math">i</span> must be the same as that output by node <span class="math">\\nu</span>'s DailyBFT[R] instance, and thus must include all of <span class="math">\\mathsf{TXs}\\backslash \\mathsf{LOG}^*</span> as well.</p>

    <p class="text-gray-300">Finally, due to the consistency property of HybridConsensus, for any node that is honest at time <span class="math">t&#x27; \\geq t + 2T_{\\mathrm{bft}} + 2\\delta &amp;gt; t^<em></span> let LOG be its output at time <span class="math">t&#x27;</span>, then it holds that either <span class="math">\\mathsf{LOG}^</em> \\prec \\mathsf{LOG}</span> or <span class="math">\\mathsf{LOG} \\prec \\mathsf{LOG}^<em></span>. However, since <span class="math">\\mathsf{TXs}\\backslash \\mathsf{LOG}^</em> \\subseteq \\mathsf{LOG}</span>, it must be the case that <span class="math">\\mathsf{LOG}^* \\prec \\mathsf{LOG}</span>. Therefore we conclude that <span class="math">\\mathsf{TXs} \\subseteq \\mathsf{LOG}</span>.</p>

    <p class="text-gray-300">□</p>

    <h2 id="sec-127" class="text-2xl font-bold">8.3 Daily Offchain Consensus Proofs</h2>

    <p class="text-gray-300">In some view, suppose that <span class="math">(\\mathcal{A},\\mathcal{Z})</span> is an adversary/environment pair for the protocol DailyBFT, we use the notation <span class="math">(\\mathcal{A},\\mathcal{Z})[\\mathsf{BFT}]</span> to denote the adversary/environment pair that interfaces with a BFT subprotocol instance. <span class="math">(\\mathcal{A},\\mathcal{Z})[\\mathsf{BFT}]</span> is jointly defined by <span class="math">(\\mathcal{A},\\mathcal{Z})</span> as well as the honest DailyBFT protocol. Notice that upon corruption of a node <span class="math">i</span>, <span class="math">\\mathcal{Z}[\\mathsf{BFT}]</span> reveals to <span class="math">\\mathcal{A}[\\mathsf{BFT}]</span> all public/secret keys of all BFT instances running on node <span class="math">i</span>.</p>

    <p class="text-gray-300"><strong>Lemma 6 (BFT security within the context of DailyBFT).</strong> If BFT is strongly secure against <span class="math">(1 - Q)</span> corruption and with liveness parameter <span class="math">T_{bft}</span> by Definition 5, and further BFT is instantiated with a secure signature scheme <span class="math">\\Sigma</span>, then for any <span class="math">n, \\delta, T_{\\text{stamp}} &amp;gt; 0</span>, <span class="math">\\tau \\geq 0</span>, for any p.p.t. <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> that is</p>

    <p class="text-gray-300"><span class="math">(n,Q,\\delta,\\tau,T_{stamp},T_{bft})</span>-valid w.r.t. <span class="math">\\mathsf{DailyBFT}</span>, there exists a negligible function <span class="math">\\mathsf{negl}</span> such that for any <span class="math">\\lambda\\in\\mathbb{N}</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left<a href="\\mathcal{A},\\mathcal{Z},\\lambda">\\mathsf{view}\\leftarrow\\mathsf{exec}[\\mathsf{DailyBFT}</a>:\\ \\mathsf{secure}^{T_{bft}}(\\mathsf{view})=1\\right]\\geq 1-\\mathsf{negl}(\\lambda)</span></p>

    <p class="text-gray-300">where <span class="math">\\mathsf{secure}^{T_{bft}}(\\mathsf{view})</span> is as defined as in Section 4.2 — but replace any occurrence of “an honest node” with “an honest <span class="math">\\mathsf{BFT}</span> virtual node”.</p>

    <h6 id="sec-128" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We construct a p.p.t. reduction <span class="math">\\mathsf{Re}</span> as below.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The reduction <span class="math">\\mathsf{Re}</span> interacts with a signature challenger <span class="math">\\Sigma^{<em>}</span>, and obtains a signature public key denoted <span class="math">\\mathsf{pk}^{</em>}</span> upfront. Henceforth we refer to <span class="math">\\mathsf{pk}^{*}</span> as the challenge public key.</li>

      <li>The reduction <span class="math">\\mathsf{Re}</span> will simulate in its head all honest nodes running <span class="math">\\mathsf{DailyBFT}</span>. When some honest node’s <span class="math">\\mathsf{BFT}</span> virtual node asks for <span class="math">\\mathsf{keygen}</span>, <span class="math">\\mathsf{Re}</span> flips a random coin, and with probability <span class="math">1/n</span>, it will return the challenge public key <span class="math">\\mathsf{pk}^{<em>}</span>; otherwise, the reduction <span class="math">\\mathsf{Re}</span> generates the signing key pair using the honest algorithm. Therefore, the reduction <span class="math">\\mathsf{Re}</span> knows all secret signing keys except for the coordinate where the challenge public key <span class="math">\\mathsf{pk}^{</em>}</span> is embedded. Whenever an honest node’s <span class="math">\\mathsf{BFT}</span> virtual node issues a <span class="math">\\mathsf{sign}</span> query for the challenge public key <span class="math">\\mathsf{pk}^{*}</span>, <span class="math">\\mathsf{Re}</span> simply forwards the query to the signature challenger.</li>

      <li>The reduction <span class="math">\\mathsf{Re}</span> interacts with the environment <span class="math">\\mathcal{Z}</span>. Whenever <span class="math">\\mathcal{Z}</span> inputs anything to honest nodes, <span class="math">\\mathsf{Re}</span> simply forwards the message to the corresponding honest node being simulated in its head. Whenever a simulated honest node needs to output anything to <span class="math">\\mathcal{Z}</span>, the reduction <span class="math">\\mathsf{Re}</span> simply forwards the message. Similarly, the reduction <span class="math">\\mathsf{Re}</span> also forwards any messages between <span class="math">\\mathcal{Z}</span> and <span class="math">\\mathcal{A}</span>.</li>

    </ul>

    <p class="text-gray-300">Now, if an honest node becomes corrupt at some point, <span class="math">\\mathsf{Re}</span> needs to return the node’s private state to <span class="math">\\mathcal{Z}</span>. As long as the corrupt node is not the one where <span class="math">\\mathsf{pk}^{<em>}</span> is embedded, the reduction <span class="math">\\mathsf{Re}</span> can successfully simulate. If the corrupt node happens to be where <span class="math">\\mathsf{pk}^{</em>}</span> is embedded, the reduction simply aborts. It is obvious that the probability that the reduction does not abort is non-negligible.</p>

    <p class="text-gray-300">It is obvious that conditioned on the event that the reduction <span class="math">\\mathsf{Re}</span> does not abort, the reduction’s interfaces to <span class="math">(\\mathcal{A},\\mathcal{Z})</span> are identically distributed as a real execution of the <span class="math">\\mathsf{DailyBFT}</span> protocol.</p>

    <p class="text-gray-300">It is not hard to see that if <span class="math">(\\mathcal{A},\\mathcal{Z})</span> is <span class="math">(n,Q,\\delta,\\tau,T_{\\mathrm{stamp}},T_{\\mathrm{bft}})</span>-valid w.r.t. <span class="math">\\mathsf{DailyBFT}</span>, then with <span class="math">1-\\mathsf{negl}(\\lambda)</span> probability, <span class="math">(\\mathcal{A},\\mathcal{Z})[\\mathsf{BFT}]</span> is <span class="math">(n,Q,\\delta,\\tau,T_{\\mathrm{stamp}})</span>-valid w.r.t. <span class="math">\\mathsf{BFT}</span>. In particular, honestly generated public keys using the <span class="math">\\Sigma.\\mathsf{Gen}(1^{\\lambda})</span> algorithm have <span class="math">\\mathsf{negl}(\\lambda)</span> probability of collision, since otherwise the signature scheme can easily be broken.</p>

    <p class="text-gray-300">For the sake of a contradiction, suppose that the lemma is not true, i.e., there exists some polynomial <span class="math">g</span> and p.p.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> that is <span class="math">(n,Q,\\delta,\\tau,T_{\\mathrm{stamp}},T_{\\mathrm{bft}})</span>-valid w.r.t. <span class="math">\\mathsf{DailyBFT}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left<a href="\\mathcal{A},\\mathcal{Z},\\lambda">\\mathsf{view}\\leftarrow\\mathsf{exec}[\\mathsf{DailyBFT}</a>:\\ \\mathsf{secure}^{T_{\\mathrm{bft}}}(\\mathsf{view})\\neq 1\\right]\\geq g(\\lambda)</span></p>

    <p class="text-gray-300">where <span class="math">\\mathsf{secure}^{T_{\\mathrm{bft}}}(\\mathsf{view})</span> is defined just like in Section 4.2, but with respect to the virtual <span class="math">\\mathsf{BFT}</span> nodes inside <span class="math">\\mathsf{DailyBFT}</span>. By definition of strong security (see Definition 5), we know that there exists a p.p.t. adversary <span class="math">\\mathcal{B}</span> and polynomial <span class="math">g^{\\prime}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left<a href="\\mathcal{B},\\mathcal{Z},\\lambda">\\mathsf{view}\\leftarrow\\mathsf{exec}[\\mathsf{DailyBFT}</a>:\\ \\mathsf{forgery}(\\mathsf{view})=1\\right]\\geq g^{\\prime}(\\lambda)</span></p>

    <p class="text-gray-300">Now, consider an execution where the reduction <span class="math">\\mathsf{Re}</span> is interacting with <span class="math">(\\mathcal{B},\\mathcal{Z})</span>. As mentioned earlier, as long as the execution does not abort, the execution is identically distributed as a real execution from the perspectives of <span class="math">(\\mathcal{B},\\mathcal{Z})</span>. Therefore, with non-negligible probability, <span class="math">\\mathcal{B}</span> will output to <span class="math">\\mathsf{Re}</span> some forgery, and if the forgery happens to be for <span class="math">\\mathsf{pk}^{*}</span> which happens with non-negligible probability, the reduction <span class="math">\\mathsf{Re}</span> will have found a forgery to the signature scheme. ∎</p>

    <p class="text-gray-300">Theorem 12 (DailyBFT from BFT, restatement of Theorem 7). Suppose that the signature scheme <span class="math">\\Sigma</span> employed by DailyBFT is secure, and that hash is a random oracle. Suppose that BFT is secure against <span class="math">(1 - Q)</span>-corruption with liveness parameter <span class="math">T_{bft}&#x27;</span> for <span class="math">Q &amp;gt; \\frac{2}{3}</span>. Then, DailyBFT is secure against <span class="math">(1 - Q)</span>-corruption with liveness parameter <span class="math">T_{bft} := T_{bft}&#x27; + \\delta</span>.</p>

    <p class="text-gray-300">Proof. For any <span class="math">n, \\delta, T_{\\mathrm{stamp}} &amp;gt; 0</span>, any <span class="math">\\tau \\geq 0</span>, for any <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> that is <span class="math">(n, Q, \\delta, \\tau, T_{\\mathrm{stamp}}, T_{\\mathrm{bft}})</span>-valid w.r.t. DailyBFT, the following properties hold for <span class="math">\\mathrm{EXEC<a href="}\\mathcal{A}, \\mathcal{Z}, \\lambda">DailyBFT</a></span> except with negligible probability:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Timely termination. Since the environment of BFT respects close stop, all BFT virtual nodes receive stop by <span class="math">T_{\\mathrm{stop}} + \\delta</span>. By the liveness property of BFT, and definition of DailyBFT, all honest committee members that remain honest till <span class="math">T_{\\mathrm{stop}} + T_{\\mathrm{bft}}&#x27; + \\delta = T_{\\mathrm{stop}} + T_{\\mathrm{bft}}</span> will have in their log by time <span class="math">T_{\\mathrm{stop}} + T_{\\mathrm{bft}}</span>, stop transactions signed by $\\lceil</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{comm}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ 3 \\rceil<span class="math"> distinct public keys in comm. When this happens, by definition of DailyBFT honest committee members gossip the signed hash of their daily log, and output done(_, _). Since at least </span>Q &gt; \\frac{2}{3}<span class="math"> fraction of comm were output by committee members that remain honest till </span>T_{\\mathrm{stamp}} &gt; T_{\\mathrm{stop}} + T_{\\mathrm{bft}}<span class="math">, it is not hard to see that if a committee non-member is honest at time </span>T_{\\mathrm{stop}} + T_{\\mathrm{bft}} + \\delta$, it will have collected enough signatures and will have output done(_, _).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Consistency.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Self-consistency. Self-consistency is obvious by definition of DailyBFT.</li>

      <li>Termination agreement. By definition, DailyBFT an honest committee member simply outputs the same final log as the final log output by the inner <span class="math">\\mathsf{BFT}_0</span> virtual node (with stop transactions removed). By the consistency property of the underlying BFT, if an honest committee member <span class="math">i</span>'s BFT outputs log at some time <span class="math">t &amp;lt; T_{\\mathrm{stamp}}</span>, and an honest committee member <span class="math">j</span>'s BFT outputs <span class="math">\\log&#x27;</span> at some time <span class="math">t&#x27; &amp;lt; T_{\\mathrm{stamp}}</span>, it must hold that <span class="math">\\log \\prec \\log&#x27;</span> or <span class="math">\\log \\prec \\log&#x27;</span>.</li>

    </ul>

    <p class="text-gray-300">If both node <span class="math">i</span> and <span class="math">j</span> spawned before <span class="math">T_{\\mathrm{stamp}}</span> and output done(_, _) while they are still honest, then done(_, _) must be output no later than <span class="math">T_{\\mathrm{stamp}}</span>. By the definition of the honest DailyBFT algorithm, it must be the case they output identical daily logs upon termination.</p>

    <p class="text-gray-300">We now extend the termination agreement proof to committee non-members who spawned before <span class="math">T_{\\mathrm{stamp}}</span>. This will rely on the security of the signature scheme. Suppose that some committee non-member <span class="math">k</span> spawned before <span class="math">T_{\\mathrm{stamp}}</span>, and outputs done <span class="math">(\\log^*, \\_)</span> at some time at which it is honest. It must be the case that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>done <span class="math">(\\log^*, \\_)</span> is output by time <span class="math">T_{\\mathrm{stamp}}</span> due to the timely termination property;</li>

      <li><span class="math">\\log^{*}</span> can be parsed as</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log^ {<em>} = \\mathrm {t x} _ {1} ^ {</em>}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm {t x} _ {2} ^ {*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots \\mathrm {t x} _ {\\ell^ {<em>}} ^ {</em>}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. For each <span class="math">(R,i,\\mathsf{tx}_i)</span> where <span class="math">i\\in [\\ell^{*}]</span>, and for the tuple <span class="math">(R,\\ell)</span> where <span class="math">R</span> is the session identifier, node <span class="math">k</span> has received valid signatures signed by at least $\\lceil \\frac{1}{3}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{comm}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rceil$ number of distinct public keys in comm.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Due to the fact that that at least <span class="math">Q</span> fraction of comm are output by committee members which are honest at <span class="math">T_{\\mathrm{stamp}}</span>, and by the pigeonhole principle, at least one valid signature on each tuple <span class="math">(R,i,\\mathsf{tx}_i)</span> or the tuple <span class="math">(R,\\ell^{*})</span> is by <span class="math">\\mathsf{pk} \\in \\mathsf{comm}</span> output by a node <span class="math">\\nu</span> that remains honest till <span class="math">T_{\\mathrm{stamp}}</span>. As mentioned earlier, honest committee members output identical final daily logs, henceforth denoted <span class="math">\\log</span>. Parse $\\log := \\mathsf{tx}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{tx}_{\\ell}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Suppose for a contradiction that <span class="math">\\log^<em> \\neq \\log</span>. Then there must exist a tuple <span class="math">(R, i, \\mathsf{tx}_i^</em>)</span> or <span class="math">(R, \\ell^<em>)</span> such that <span class="math">\\mathsf{tx}_i^</em> \\neq \\mathsf{tx}_i</span> or <span class="math">\\ell^<em> \\neq \\ell</span>. Without loss of generality, assume that <span class="math">\\mathsf{tx}_i^</em> \\neq \\mathsf{tx}_i</span> (the other case</p>

    <p class="text-gray-300">45</p>

    <p class="text-gray-300">is similar). Then, node <span class="math">k</span> will have received at least one valid signature on <span class="math">(R,i,\\mathsf{tx}_i^<em>)</span> signed by a <span class="math">\\mathsf{pk} \\in \\mathsf{comm}</span> output by a node <span class="math">\\nu</span> that remains honest till <span class="math">T_{\\mathrm{stamp}}</span>. If there exists p.p.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> such that <span class="math">\\log^{</em>} \\neq \\log</span> with non-negligible probability, then we can build a reduction that breaks the signature scheme. Basically this reduction simulates all honest users and interact with the <span class="math">(\\mathcal{A},\\mathcal{Z})</span> pair. Whenever <span class="math">\\mathcal{Z}</span> inputs keygen, it has a choice of embedding a <span class="math">\\mathsf{pk}</span> from the signature's challenger. To do this, every time a keygen is queried, the reduction makes a random guess and decides whether to embed the signature challenger's <span class="math">\\mathsf{pk}</span>. Such guesses are correct with <span class="math">1 / \\mathsf{poly}(\\lambda)</span> probability – and if the guess turns out to be wrong later the reduction simply aborts. Whenever the embedded <span class="math">\\mathsf{pk}</span> needs to sign something, the reduction queries the signature challenger. For all other key pairs the reduction knows the corresponding secret key and can disclose it to <span class="math">(\\mathcal{A},\\mathcal{Z})</span> when a node becomes corrupt. Finally, when <span class="math">(\\mathcal{A},\\mathcal{Z})</span> outputs a valid signature on such a tuple <span class="math">\\{R,i,\\mathsf{tx}_i^<em>\\}_{\\mathsf{pk}^{-1}}</span>, the reduction outputs this as a forgery. Note that the reduction should never have to make such a query to the signature challenger since <span class="math">\\mathsf{tx}_i^</em> \\neq \\mathsf{tx}_i</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Common prefix.</strong> Suppose that committee members <span class="math">i</span> and <span class="math">j</span> are honest at times <span class="math">t</span> and <span class="math">t&#x27;</span> respectively and <span class="math">i</span> outputs <span class="math">\\log</span> at time <span class="math">t</span> and <span class="math">j</span> outputs <span class="math">\\log</span> at time <span class="math">t&#x27;</span>. Due to the timely termination property, it must be the case that <span class="math">t &amp;lt; T_{\\mathrm{stamp}}</span> and <span class="math">t&#x27; &amp;lt; T_{\\mathrm{stamp}}</span>. Now, due to the consistency property of the underlying BFT and definition of DailyBFT, it is not hard to see that either <span class="math">\\log \\prec \\log&#x27;</span> or <span class="math">\\log&#x27; \\prec \\log</span>.</li>

    </ul>

    <p class="text-gray-300">We now extend the argument to committee non-members who spawned before <span class="math">T_{\\mathrm{stamp}}</span>. Here we rely on the security of the signature scheme. Let <span class="math">k</span> be any committee non-member that spawned before <span class="math">T_{\\mathrm{stamp}}</span>. We have argued that if node <span class="math">k</span> outputs <span class="math">\\text{done}(\\log&#x27;, -)</span> then <span class="math">\\log&#x27;</span> must agree with honest committee members' final log denoted <span class="math">\\log</span> — as we argued earlier, all honest committee members must output an identical final <span class="math">\\log</span>; and by definition there exists at least one committee member who remains honest till <span class="math">T_{\\mathrm{stamp}}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If node <span class="math">k</span> outputs <span class="math">\\text{notdone}(\\log^<em>)</span> at a time when it is honest, then due to the timely termination property and the fact that honest nodes never output again after outputting <span class="math">\\text{done}(-, -)</span>, it must hold that <span class="math">\\text{notdone}(\\log^</em>)</span> is output before <span class="math">T_{\\mathrm{stamp}}</span>. Now parse $\\log^<em> := \\log_1^</em></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log_m^*<span class="math">, and parse </span>\\log := \\log_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log_\\ell<span class="math">. Then it must hold that </span>\\ell \\geq m<span class="math"> and </span>\\log_i^* = \\log_i$ — the latter can be shown using exactly the same type of argument as termination agreement.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Liveness.</strong> By definition of the DailyBFT protocol, any TXs input to an honest committee member at time <span class="math">t</span> is input to the inner BFT virtual nodes in the same time step <span class="math">t</span>. Further, the inner BFT virtual nodes have the same <span class="math">T_{\\mathrm{start}}</span> and <span class="math">T_{\\mathrm{stop}}</span> as the outer DailyBFT, since honest committee members simply pass start and stop commands to the inner BFT virtual nodes.</li>

    </ul>

    <p class="text-gray-300">By liveness of the BFT protocol, if <span class="math">T_{\\mathrm{start}} \\leq t &amp;lt; T_{\\mathrm{stop}} - T_{\\mathrm{bft}}</span>, for any committee member honest at time <span class="math">t + T_{\\mathrm{bft}}</span>, its inner BFT virtual nodes will have output a log that includes all of TXs by time <span class="math">t + T_{\\mathrm{bft}}</span>. Since <span class="math">t &amp;lt; T_{\\mathrm{stop}} - T_{\\mathrm{bft}}</span>, complete(log) must return false, since otherwise we can easily construct an adversary that breaks signature security.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Now consider the set of all committee members honest at time <span class="math">t + T_{\\mathrm{bft}}</span>, for each committee member, consider the longest log it has output by time <span class="math">t + T_{\\mathrm{bft}}</span>. Now take the intersection of all such logs and denote it as <span class="math">\\log&#x27;</span>. We have argued that <span class="math">\\mathsf{TXs} \\subseteq \\log&#x27;</span>, and clearly <span class="math">\\mathsf{complete}(\\log&#x27;) = \\mathsf{false}</span>. Now, by definition of the DailyBFT protocol, for every $i \\in [</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]<span class="math">, for every </span>\\mathsf{pk} \\in \\mathsf{comm}<span class="math"> output by some node that is honest at </span>T_{\\mathrm{stamp}}<span class="math">, it must hold that every node honest at time </span>t + T_{\\mathrm{bft}} + \\delta<span class="math"> must have received a validly signed tuple </span>\\{R, i, \\log'[i]\\}_{\\mathsf{pk}^{-1}}<span class="math"> where </span>R<span class="math"> is the session identifier of DailyBFT. There must be at least </span>\\lceil Q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{comm}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rceil<span class="math"> number of </span>\\mathsf{pk}<span class="math">s in comm output by nodes who remain honest till </span>T_{\\mathrm{stamp}} &gt; t + T_{\\mathrm{bft}} + \\delta<span class="math">. Since </span>Q &gt; \\frac{2}{3}$, any node honest at time</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">46</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">t + T_{\\mathrm{bft}} + \\delta</span> will have output a <span class="math">\\log^*</span> s.t. $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log^*</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq i<span class="math"> by time </span>t + T_{\\mathrm{bft}} + \\delta<span class="math">. By consistency of DailyBFT, </span>\\log^<em>[i] = \\log'[i]<span class="math">, and therefore </span>\\mathrm{tx} \\in \\log^</em>$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. Obvious by definition of DailyBFT and correctness of the signature scheme.</li>

      <li>Unforgeability. If there exists p.p.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> such that unforgeability can be broken with nonnegligible probability, then we can build a reduction that breaks the signature scheme. Basically this reduction simulates all honest users and interact with the <span class="math">(\\mathcal{A},\\mathcal{Z})</span> pair. Whenever <span class="math">\\mathcal{Z}</span> inputs keygen, it has a choice of embedding a pk from the signature's challenger. To do this, every time a keygen is queried, the reduction makes a random guess and decides whether to embed the signature challenger's pk. Such guesses are correct with <span class="math">1 / \\text{poly}(\\lambda)</span> probability – and if the guess turns out to be wrong later the reduction simply aborts. Whenever the embedded pk needs to sign something, the reduction queries the signature challenger. For all other key pairs the reduction knows the corresponding secret key and can disclose it to <span class="math">(\\mathcal{A},\\mathcal{Z})</span> when a node becomes corrupt. Henceforth we assume that the embedded pk belongs to node <span class="math">i</span>. Finally, when <span class="math">(\\mathcal{A},\\mathcal{Z})</span> outputs a valid signature on such a tuple <span class="math">\\{R,h\\}_{\\mathrm{pk}^{-1}}</span>, the reduction outputs this as a forgery. Note that the reduction should never have to make such a query <span class="math">(R,h)</span> to the signature challenger since by definition, for the <span class="math">(\\mathcal{A},\\mathcal{Z})</span> pair to break unforgeability, it must be the case that node <span class="math">i</span> has not output done(log, _) by the forgery such that <span class="math">h = \\text{hash}(\\log)</span>.</li>

    </ul>

    <p class="text-gray-300">∎</p>

    <h2 id="sec-129" class="text-2xl font-bold">8.4 Extending the Proof for Hybrid Consensus over Fruitchain</h2>

    <p class="text-gray-300">So far, we have completed the proof for hybrid consensus over Nakamoto. When we use Fruitchain as the underlying snailchain, the proof is almost the same, except that parameters must be readjusted.</p>

    <p class="text-gray-300">Consider HybridConsensus<span class="math">^{\\lambda, \\eta}</span> parametrized with <span class="math">\\eta</span>. In other words, the committee size csize is chosen to be <span class="math">\\text{csize} := \\lambda / \\eta</span>. In the proof, we can plug in the following modified parameters:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">T_{\\text{snail}} := (2\\lambda + \\frac{\\lambda}{\\eta}) / G</span>;</li>

      <li><span class="math">T_{\\text{stamp}}(R) := T_{\\text{start}}(R) + \\frac{\\lambda}{\\eta G} + T_{\\text{bft}} + \\delta + T_{\\text{snail}}</span>;</li>

      <li><span class="math">\\tau &amp;gt; \\left(\\frac{2\\lambda}{\\eta} + \\lambda\\right) / G + T_{\\text{bft}} + \\delta + T_{\\text{snail}} = 3\\lambda \\left(1 + \\frac{1}{\\eta}\\right) / G + T_{\\text{bft}} + \\delta</span>;</li>

      <li><span class="math">T_{\\text{warmup}} := \\lambda \\left(1 + \\frac{1}{\\eta}\\right) / G</span>;</li>

      <li><span class="math">G&#x27; &amp;gt; \\frac{\\lambda}{\\eta (T_{\\mathrm{bft}} + \\delta)}</span>;</li>

      <li><span class="math">G = (1 - 5\\eta)(1 - \\alpha)n\\rho</span>, and <span class="math">G&#x27; = (1 + 5\\eta)n\\rho</span>.</li>

    </ul>

    <p class="text-gray-300">With these new parameters, the rest of the proof follows in the same manner as hybrid consensus over Nakamoto.</p>

    <h2 id="sec-130" class="text-2xl font-bold">9 Lower Bound</h2>

    <h3 id="sec-131" class="text-xl font-semibold mt-8">9.1 Proof-of-Work Cannot Stop</h3>

    <p class="text-gray-300">We now prove a lower bound suggesting that any secure permissionless consensus protocol must invoke proofs-of-work infinitely often, assuming no additional trust assumptions. We stress that this lower bound does not rule out approaches that rely on additional trust assumptions such as proofs-of-stake [11, 38, 49, 50].</p>

    <p class="text-gray-300">Theorem 13 (Any secure permissionless consensus protocol must call proofs-of-work infinitely often.). Let <span class="math">\\Gamma</span> denote any binary function in <span class="math">n,\\alpha,\\delta,\\tau</span> such that <span class="math">\\Gamma(n,\\alpha,\\delta,\\tau)=1</span> for some <span class="math">n,\\delta</span> that are positive polynomials (in <span class="math">\\lambda</span>), non-negative polynomial <span class="math">\\tau</span>, and <span class="math">\\alpha&gt;1/\\mathsf{poly}</span> for some positive polynomial <span class="math">\\mathsf{poly}</span>. Let <span class="math">\\Pi</span> be a protocol such that for any p.p.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> that is <span class="math">\\Gamma</span>-admissible, there exists a polynomial function <span class="math">\\mathsf{poly}</span> such that for every <span class="math">\\lambda\\in\\mathbb{N}</span>, <span class="math">\\mathrm{exec}<a href="\\mathcal{A},\\mathcal{Z},\\lambda">\\Pi</a></span> satisfies the following properties with <span class="math">1/\\mathsf{poly}(\\lambda)</span> probability:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Bounded proof-of-work. Honest nodes stop querying <span class="math">\\mathsf{H}</span> after some time <span class="math">T_{\\text{pow}}:=\\mathsf{poly}_{0}(n,\\alpha,\\delta,\\lambda)</span> for some polynomial <span class="math">\\mathsf{poly}_{0}</span>;</li>

      <li>Liveness. Liveness as defined in Section 3.2 is satisfied with parameters <span class="math">T_{\\text{confirm}}=\\mathsf{poly}_{1}(n,\\alpha,\\delta,\\lambda)</span>, <span class="math">T_{\\text{warmup}}=\\mathsf{poly}_{2}(n,\\alpha,\\delta,\\lambda)</span>, and <span class="math">T_{\\text{bootstrap}}=\\mathsf{poly}_{3}(n,\\alpha,\\delta,\\lambda)</span>, for some non-negative polynomial <span class="math">\\mathsf{poly}_{1}</span>, <span class="math">\\mathsf{poly}_{2}</span>, and <span class="math">\\mathsf{poly}_{3}</span>.</li>

    </ul>

    <p class="text-gray-300">Then, there exists p.p.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> that is <span class="math">\\Gamma</span>-admissible, such that for any <span class="math">\\lambda\\in\\mathbb{N}</span>, <span class="math">\\mathrm{exec}<a href="\\mathcal{A},\\mathcal{Z},\\lambda">\\Pi</a></span> does not satisfy consistency with probability <span class="math">1/\\mathsf{poly}(\\lambda)</span> for some polynomial <span class="math">\\mathsf{poly}</span>.</p>

    <p class="text-gray-300">Intuitively, this theorem says that any permissionless consensus protocol secure against <span class="math">1/\\mathsf{poly}(\\lambda)</span> fraction of corruption must call proofs-of-work infinitely often — even in the synchronous network model and against static corruptions.</p>

    <h6 id="sec-132" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi</span> be any protocol such that for any p.p.t. <span class="math">(\\mathcal{A}^{\\prime},\\mathcal{Z}^{\\prime})</span> that is <span class="math">\\Gamma</span>-admissible, there exists a polynomial function <span class="math">\\mathsf{poly}</span> such that for every <span class="math">\\lambda\\in\\mathbb{N}</span>, with <span class="math">1/\\mathsf{poly}(\\lambda)</span> probability, <span class="math">\\mathrm{exec}<a href="\\mathcal{A}^{\\prime},\\mathcal{Z}^{\\prime},\\lambda">\\Pi</a></span> satisfies bounded proof-of-work and liveness as defined above. We now show how to construct p.p.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> that is <span class="math">\\Gamma</span>-admissible such that <span class="math">\\mathrm{exec}<a href="\\mathcal{A},\\mathcal{Z},\\lambda">\\Pi</a></span> breaks the common prefix property with <span class="math">1/\\mathsf{poly}(\\lambda)</span> probability for some polynomial <span class="math">\\mathsf{poly}</span>.</p>

    <p class="text-gray-300">We consider a pair <span class="math">(\\mathcal{A},\\mathcal{Z})</span> that is <span class="math">\\Gamma</span>-admissible w.r.t. <span class="math">\\Pi</span>, and behaves as follows.</p>

    <h4 id="sec-133" class="text-lg font-semibold mt-6">Transaction input.</h4>

    <p class="text-gray-300">At time <span class="math">T_{\\text{warmup}}</span>, <span class="math">\\mathcal{Z}</span> samples <span class="math">\\mathsf{tx}^{\\S}\\{0,1\\}^{\\lambda}</span>, and inputs <span class="math">\\mathsf{TXs}:=\\{\\mathsf{tx}\\}</span> to an honest node. Besides this, <span class="math">\\mathcal{Z}</span> does not input any other transactions.</p>

    <h4 id="sec-134" class="text-lg font-semibold mt-6">Real execution.</h4>

    <p class="text-gray-300"><span class="math">\\mathcal{A}</span> instructs all corrupt nodes to behave honestly in the real execution.</p>

    <h4 id="sec-135" class="text-lg font-semibold mt-6">Simulated execution.</h4>

    <p class="text-gray-300">Starting at time <span class="math">T_{\\text{pow}}</span>, <span class="math">\\mathcal{A}</span> also simulates an imaginary execution in its head. To do this, <span class="math">\\mathcal{A}</span> simulates the execution of all honest nodes and the environment <span class="math">\\mathcal{Z}</span>. Suppose that in this simulated execution, the simulated environment <span class="math">\\mathcal{Z}</span> inputs <span class="math">\\mathsf{TXs}:=\\{\\mathsf{tx}^{<em>}\\}</span> where <span class="math">\\mathsf{tx}^{</em>}\\overset{\\S}{\\leftarrow}\\{0,1\\}^{\\lambda}</span> at simulated time <span class="math">T_{\\text{warmup}}</span>.</p>

    <h4 id="sec-136" class="text-lg font-semibold mt-6">Network and corruption.</h4>

    <p class="text-gray-300">In both the real and the simulated execution, the adversary <span class="math">\\mathcal{A}</span> delivers messages instantly, i.e., within the next time step. The environment statically corrupts <span class="math">\\alpha</span> fraction of the nodes.</p>

    <h4 id="sec-137" class="text-lg font-semibold mt-6">Late spawning node.</h4>

    <p class="text-gray-300">Suppose that a new node <span class="math">i</span> spawns at time <span class="math">t_{\\text{spawn}}:=\\max(T_{\\text{pow}}+T_{\\text{pow}}/\\alpha,T_{\\text{warmup}}+T_{\\text{confirm}})+1</span>. At this moment, the adversary <span class="math">\\mathcal{A}</span> will have all the simulated honest nodes interact with node <span class="math">i</span> where all simulated honest nodes follow the honest protocol. Whenever node <span class="math">i</span> gossips a message, the message is delivered to both the honest nodes in the real execution within <span class="math">\\delta=1</span> time, as well as delivered to honest nodes in the simulated execution.</p>

    <h5 id="sec-138" class="text-base font-semibold mt-4">No consistency.</h5>

    <p class="text-gray-300">Now, with <span class="math">1/\\mathsf{poly}(\\lambda)</span> probability, both bounded proof-of-work and liveness are satisfied for the real and simulated execution. Conditioned on the fact these properties are satisfied for the real and simulated execution, we argue that consistency cannot be satisfied with at least <span class="math">1/2</span> probability.</p>

    <p class="text-gray-300">Given that <span class="math">\\alpha</span> fraction of the nodes are corrupt, it is not hard to see that at any time <span class="math">t\\geq t_{\\text{spawn}}-1</span>, the adversary <span class="math">\\mathcal{A}</span> is able to output a simulated execution that is identically distributed as the real execution, since the adversary <span class="math">\\mathcal{A}</span> will have enough time to make all the necessary <span class="math">\\mathsf{H}</span> queries.</p>

    <p class="text-gray-300">Now, due to liveness, honest nodes in the real execution must have output a <span class="math">\\mathsf{LOG}</span> by <span class="math">t_{\\text{spawn}}-1</span> where <span class="math">\\mathsf{tx}\\in\\mathsf{LOG}</span> and <span class="math">\\mathsf{tx}^{<em>}\\notin\\mathsf{LOG}</span> — except with <span class="math">\\mathsf{negl}(\\lambda)</span> probability since the the real execution cannot know <span class="math">\\mathsf{tx}^{</em>}</span> before <span class="math">t_{\\text{spawn}}</span>. Similarly, except with <span class="math">\\mathsf{negl}(\\lambda)</span> probability, honest nodes in the simulated execution must have output a <span class="math">\\mathsf{LOG}</span> by <span class="math">t_{\\text{spawn}}-1</span> and where <span class="math">\\mathsf{tx}^{*}\\in\\mathsf{LOG}</span> and <span class="math">\\mathsf{tx}\\notin\\mathsf{LOG}</span>.</p>

    <p class="text-gray-300">Due to liveness, the newly spawned node <span class="math">i</span> must output a non-empty <span class="math">\\mathsf{LOG}</span> by time <span class="math">\\max(t_{\\text{spawn}}+T_{\\text{bootstrap}},T_{\\text{warmup}}+T_{\\text{confirm}})</span> such that <span class="math">\\mathsf{tx}\\in\\mathsf{LOG}</span>. And since the real and simulated execution are identically distributed, <span class="math">\\mathsf{tx}^{<em>}\\in\\mathsf{LOG}</span> too. Since the real and simulated execution are identically distributed, the probability that <span class="math">\\mathsf{tx}^{</em>}</span> precedes <span class="math">\\mathsf{tx}</span> in <span class="math">\\mathsf{LOG}</span> is at least <span class="math">1/2</span> — in which case consistency (for the real execution) cannot be satisfied.</p>

    <p class="text-gray-300">∎</p>

    <h3 id="sec-139" class="text-xl font-semibold mt-8">9.2 <span class="math">1/3</span> Corruption is Tight for Responsive Protocols</h3>

    <p class="text-gray-300">We now show that in the permissionless model, even when the protocol knows an a-priori upper bound <span class="math">\\Delta</span> of the network’s delay, there does not exist responsive protocols that can tolerate <span class="math">1/3</span> or more corruption in terms of hashpower. Since our hybrid consensus protocol tolerates <span class="math">1/3-\\epsilon</span> corruption, it is (nearly) tight since no responsive protocol can tolerate more than <span class="math">1/3</span> corruption.</p>

    <p class="text-gray-300">Our lower bound is a straightforward modification of a related lower bound proven by Sompolinsky <em>[2]</em>, who showed that in the partially synchronous setting, if the network’s delay upper bound is unknown to the protocol, then no secure permissionless consensus protocol can tolerate more than <span class="math">1/3</span> corruption. Our lower bound proof (and also Sompolinsky’s) is also close in spirit to the partially synchronous lower bound shown by Dwork, Lynch, and Stockmeyer <em>[25]</em> — however, their bound needs to be adapted to the permissionless setting with proof-of-work. In particular, Dwork et al.’s lower bound constructs an explicit attack with <span class="math">3</span> nodes, where one node controlled by the adversary acts as two separate nodes with different inputs, and interact with two honest nodes to split their views. In the proof-of-work setting, the difficulty is that the adversary cannot simultaneously simulate two nodes since to do that it would have to solve twice the proof-of-work. However, we use a trick similar to Sompolinsky <em>[2]</em>, where the adversary still acts as two players, but space out the proof-of-work over time — and the victim honest node cannot distinguish whether the adversary started solving puzzles late, or simply the network delay is large.</p>

    <h6 id="sec-140" class="text-base font-medium mt-4">Theorem 14 (Responsive protocols cannot tolerate <span class="math">1/3</span> corruption).</h6>

    <p class="text-gray-300">No secure permissionless consensus protocol that is also responsive can tolerate <span class="math">1/3</span> or more corruption.</p>

    <h6 id="sec-141" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose that there exists a protocol <span class="math">\\Pi</span> that defends against <span class="math">1/3</span> corruption and is responsive, i.e., its liveness parameter <span class="math">T_{\\text{confirm}}=T_{\\text{confirm}}(\\lambda,n,\\alpha,\\delta)</span> is a function of the network’s actual delay <span class="math">\\delta</span>, but not of the a-priori known upper bound delay <span class="math">\\Delta</span>. This means that after some <span class="math">T_{\\text{warmup}}=\\mathsf{poly}(\\lambda,n,\\alpha,\\delta,\\Delta)</span> time, a transaction input to an honest node will be included in any honest node’s output <span class="math">\\mathsf{LOG}</span> within <span class="math">T_{\\text{confirm}}</span> time, even when <span class="math">1/3</span> of the nodes crash.</p>

    <p class="text-gray-300">We now describe an explicit attack that can break consistency when <span class="math">\\alpha=1/3</span>. Suppose that there are <span class="math">3</span> nodes, <span class="math">A</span>, <span class="math">P_{0}</span>, and <span class="math">P_{1}</span>, where <span class="math">A</span> is controlled by the adversary <span class="math">\\mathcal{A}</span>, and <span class="math">P_{0}</span> and <span class="math">P_{1}</span> are honest. Let <span class="math">\\Delta:=2T_{\\text{confirm}}(\\lambda,n,\\alpha,T_{\\text{confirm}}(\\lambda,n,\\alpha,1))</span> which is polynomial bounded in terms of <span class="math">\\lambda</span>. The</p>

    <p class="text-gray-300">adversary <span class="math">\\mathcal{A}</span> first behaves honestly and delivers all messages instantly until <span class="math">T_{\\text{warmup}}(\\lambda,n,\\alpha,1,\\Delta)</span> time has passed.</p>

    <p class="text-gray-300">At this time, the adversary <span class="math">\\mathcal{A}</span> starts to delay messages between <span class="math">P_{0}</span> and <span class="math">P_{1}</span> for the maximum amount <span class="math">\\Delta</span>, but delivers messages instantly between <span class="math">P_{0}</span> and <span class="math">A</span>. At this time, the environment <span class="math">\\mathcal{Z}</span> inputs a transaction <span class="math">\\textsf{tx}\\overset{\\textsf{\\</span>}}{\\leftarrow}\\{0,1\\}^{\\lambda}<span class="math"> to </span>P_{0}<span class="math"> and a different transaction </span>\\textsf{tx}^{\\prime}\\overset{\\textsf{\\<span class="math">}}{\\leftarrow}\\{0,1\\}^{\\lambda}</span> to <span class="math">P_{1}</span>. Further, the corrupt node <span class="math">A</span> stops sending messages to <span class="math">P_{1}</span>; however, it remembers and stores every message received from <span class="math">P_{1}</span>. The corrupt node follows the honest protocol when interacting with <span class="math">P_{0}</span>. Since the protocol is responsive even when <span class="math">1/3</span> nodes crash, except with negligible probability, <span class="math">P_{0}</span>’s output LOG will include tx in some fixed polynomial time <span class="math">T_{\\text{confirm}}(\\lambda,n,\\alpha,1)&lt;\\Delta</span>.</p>

    <p class="text-gray-300">Let <span class="math">t^{<em>}=T_{\\text{warmup}}(\\lambda,n,\\alpha,1,\\Delta)+T_{\\text{confirm}}(\\lambda,n,\\alpha,1)</span> denote an upper bound on the time when tx is included in <span class="math">P_{0}</span>’s output LOG. At time <span class="math">t^{</em>}</span>, the corrupt node <span class="math">A</span> stops sending messages to <span class="math">P_{0}</span>, but begins interating with <span class="math">P_{1}</span> as follows. First, <span class="math">A</span> resets its internal state to what it was at time <span class="math">T_{\\text{warmup}}</span>. Recall that <span class="math">A</span> queues all messages received <span class="math">P_{1}</span> in a buffer. It will now pretend that any real time <span class="math">t\\geq t^{*}</span> is fake time <span class="math">t-T_{\\text{confirm}}(\\lambda,n,\\alpha,1)</span>, and that it replays (from the buffer) all messages received from <span class="math">P_{1}</span> during the real time step <span class="math">t-T_{\\text{confirm}}(\\lambda,n,\\alpha,1)</span>. Now <span class="math">A</span> follows the honest protocol, and for every message destined for <span class="math">P_{1}</span>, the adversary delivers the message instantly. Note that <span class="math">P_{1}</span> cannot distinguish whether <span class="math">A</span> started solving proofs-of-work <span class="math">T_{\\text{confirm}}(\\lambda,n,\\alpha,1)</span> time late, or whether the network link from <span class="math">A</span> to <span class="math">P_{1}</span> has <span class="math">T_{\\text{confirm}}(\\lambda,n,\\alpha,1)</span> actual delay, but the <span class="math">P_{1}</span> to <span class="math">A</span> link delivers messages instantly. Since the protocol is responsive even when <span class="math">1/3</span> nodes crash, <span class="math">P_{1}</span> will include <span class="math">\\textsf{tx}^{\\prime}\\neq\\textsf{tx}</span> in its output LOG in <span class="math">T_{\\text{confirm}}(\\lambda,n,\\alpha,T_{\\text{confirm}}(\\lambda,n,\\alpha,1))&lt;\\Delta</span> time. Note that since <span class="math">\\Delta</span> is large, <span class="math">P_{1}</span> has not heard the transaction tx from <span class="math">P_{0}</span> yet. Therefore, the probability that tx is in <span class="math">P_{1}</span>’s output log at time <span class="math">T_{\\text{confirm}}(\\lambda,n,\\alpha,T_{\\text{confirm}}(\\lambda,n,\\alpha,1))</span> is negligibly small in <span class="math">\\lambda</span>. Clearly, this breaks consistency. ∎</p>

    <h5 id="sec-142" class="text-base font-semibold mt-4">Remark.</h5>

    <p class="text-gray-300">We note that it is not hard to show a similar lower bound for the classical permissioned setting. Specifically, in the classical permissioned setting even when assuming PKI, any responsive, secure consensus protocol cannot tolerate <span class="math">1/3</span> corruption or more. Such a lower bound would be a straightforward generalization of Dwork et al.’s lower bound proof for partial synchrony with an unknown <span class="math">\\Delta</span> (in the permissioned setting).</p>

    <h2 id="sec-143" class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">We thank Kyle Croman, Ittay Eyal, Ari Juels, Antonio Marcedone, Andrew Miller, Emin Gun Sirer, Yonatan Sompolinsky, Dawn Song, and Fan Zhang for helpful discussions, and especially Dominic Williams for several excellent discussions that inspired us to tackle this problem.</p>

    <p class="text-gray-300">This work is supported in part by NSF grants CNS-1217821, CNS-1314857, CNS-1514261, CNS-1544613, CNS-1561209, CNS-1601879, CNS-1617676, AFOSR Award FA9550-15-1-0262, an Office of Naval Research Young Investigator Program Award, a Microsoft Faculty Fellowship, a Packard Fellowship, a Sloan Fellowship, Google Faculty Research Awards, and a VMWare Research Award. This work was done in part while a subset of the authors were visiting the Simons Institute for the Theory of Computing, supported by the Simons Foundation and by the DIMACS/Simons Collaboration in Cryptography through NSF grant CNS-1523467.</p>

    <h2 id="sec-144" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Personal communication with Kartik Nayak and Ling Ren.</li>

      <li>[2] Personal communication with Yonatan Sompolinsky.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[3] Byzcoin: Securely scaling blockchains. http://hackingdistributed.com/2016/08/04/byzcoin/.</li>

      <li>[4] Untangling mining incentives in bitcoin and byzcoin. http://bford.github.io/2016/10/25/mining/.</li>

      <li>[5] Martín Abadi and Jan Jürjens. Formal eavesdropping and its computational interpretation. In Theoretical Aspects of Computer Software, 4th International Symposium (TACS), pages 82–94, 2001.</li>

      <li>[6] Martín Abadi and Phillip Rogaway. Reconciling two views of cryptography (the computational soundness of formal encryption). J. Cryptology, 20(3):395, 2007.</li>

      <li>[7] Pedro Adão, Gergei Bana, Jonathan Herzog, and Andre Scedrov. Soundness of formal encryption in the presence of key-cycles. In Computer Security - ESORICS 2005, 10th European Symposium on Research in Computer Security, Milan, Italy, September 12-14, 2005, Proceedings, pages 374–396, 2005.</li>

      <li>[8] Gavin Andresen. Increase maximum block size (bip 101). https://github.com/bitcoin/bips/blob/master/bip-0101.mediawiki, retrieved October 2015.</li>

      <li>[9] Adam Back, Matt Corallo, Luke Dashjr, Mark Friedenbach, Gregory Maxwell, Andrew Miller, Andrew Poelstra, Jorge Timon, and Pieter Wuille. Enabling blockchain innovations with pegged sidechains. https://blockstream.com/sidechains.pdf.</li>

      <li>[10] Michael Backes, Birgit Pfitzmann, and Michael Waidner. A universally composable cryptographic library. IACR Cryptology ePrint Archive, 2003:15, 2003.</li>

      <li>[11] Iddo Bentov, Ariel Gabizon, and Alex Mizrahi. Cryptocurrencies without proof of work. CoRR, abs/1406.5694, 2014.</li>

      <li>[12] Alysson Neves Bessani, João Sousa, and Eduardo Adílio Pelinson Alchieri. State machine replication for the masses with BFT-SMART. In 44th Annual IEEE/IFIP International Conference on Dependable Systems and Networks, DSN 2014, Atlanta, GA, USA, June 23-26, 2014, pages 355–362, 2014.</li>

      <li>[13] Florian Bohl and Dominique Unruh. Symbolic universal composability. In Proceedings of the 2013 IEEE 26th Computer Security Foundations Symposium, CSF ’13, pages 257–271, 2013.</li>

      <li>[14] Gabriel Bracha and Sam Toueg. Asynchronous consensus and broadcast protocols. J. ACM, 32(4):824–840, October 1985.</li>

      <li>[15] Christian Cachin, Klaus Kursawe, Frank Petzold, and Victor Shoup. Secure and efficient asynchronous broadcast protocols. In Advances in Cryptology - CRYPTO 2001, 21st Annual International Cryptology Conference, Santa Barbara, California, USA, August 19-23, 2001, Proceedings, pages 524–541, 2001.</li>

      <li>[16] R. Canetti. Universally composable security: A new paradigm for cryptographic protocols. In FOCS, 2001.</li>

      <li>[17] Ran Canetti, Yevgeniy Dodis, Rafael Pass, and Shabsi Walfish. Universally composable security with global setup. In Theory of Cryptography, pages 61–85. Springer, 2007.</li>

    </ul>

    <p class="text-gray-300">[18] Ran Canetti and Jonathan Herzog. Universally composable symbolic security analysis. J. Cryptology, 24(1):83–147, 2011.</p>

    <p class="text-gray-300">[19] Ran Canetti and Tal Rabin. Fast asynchronous byzantine agreement with optimal resilience. In Proceedings of the Twenty-fifth Annual ACM Symposium on Theory of Computing, STOC '93, pages 42–51, 1993.</p>

    <p class="text-gray-300">[20] Ran Canetti and Tal Rabin. Universal composition with joint state. In CRYPTO, 2003.</p>

    <p class="text-gray-300">[21] Miguel Castro and Barbara Liskov. Practical byzantine fault tolerance. In OSDI, 1999.</p>

    <p class="text-gray-300">[22] Kyle Croman, Christian Decker, Ittay Eyal, Adem Efe Gencer, Ari Juels, Ahmed Kosba, Andrew Miller, Prateek Saxena, Elaine Shi, Emin Gun Sirer, Dawn Song, and Roger Wattenhofer. On scaling decentralized blockchains (a position paper). In <em>Bitcoin Workshop</em>, 2016.</p>

    <p class="text-gray-300">[23] Christian Decker, Jochen Seidel, and Roger Wattenhofer. Bitcoin meets strong consistency. In Proceedings of the 17th International Conference on Distributed Computing and Networking, ICDCN '16, 2016.</p>

    <p class="text-gray-300">[24] Danny Dolev and H. Raymond Strong. Authenticated algorithms for byzantine agreement. Siam Journal on Computing - SIAMCOMP, 12(4):656–666, 1983.</p>

    <p class="text-gray-300">[25] Cynthia Dwork, Nancy Lynch, and Larry Stockmeyer. Consensus in the presence of partial synchrony. J. ACM, 1988.</p>

    <p class="text-gray-300">[26] Pieter Wuille Eric Lombrozo, Johnson Lau. Segregated witness (consensus layer). https://github.com/CodeShark/bips/blob/segwit/bip-codeshark-j12012-segwit.mediawiki.</p>

    <p class="text-gray-300">[27] Ittay Eyal, Adem Efe Gencer, Emin Gun Sirer, and Robbert van Renesse. Bitcoin-NG: A scalable blockchain protocol. In NSDI, 2016.</p>

    <p class="text-gray-300">[28] Ittay Eyal and Emin Gun Sirer. Majority is not enough: Bitcoin mining is vulnerable. In FC, 2014.</p>

    <p class="text-gray-300">[29] Michael J. Fischer, Nancy A. Lynch, and Michael S. Paterson. Impossibility of distributed consensus with one faulty process. J. ACM, 32(2):374–382, April 1985.</p>

    <p class="text-gray-300">[30] Juan Garay, Aggelos Kiayias, and Nikos Leonardos. The Bitcoin Backbone Protocol: Analysis and Applications. Cryptology ePrint Archive, Report 2014/765, 2014.</p>

    <p class="text-gray-300">[31] Jeff Garzik. Block size increase to 2mb (bip 102). https://github.com/bitcoin/bips/blob/master/bip-0102.mediawiki, retrieved October 2015.</p>

    <p class="text-gray-300">[32] Jeff Garzik. Making decentralized economic policy. http://gtf.org/garzik/bitcoin/BIP100-blocksizechangeproposal.pdf.</p>

    <p class="text-gray-300">[33] Omer Horvitz and Virgil D. Gligor. Weak key authenticity and the computational completeness of formal encryption. In CRYPTO, pages 530–547, 2003.</p>

    <p class="text-gray-300">[34] Romain Janvier, Yassine Lakhnech, and Laurent Mazaré. Completing the picture: Soundness of formal encryption in the presence of active adversaries. In <em>Programming Languages and Systems, 14th European Symposium on Programming, ESOP 2005, Held as Part of the Joint European Conferences on Theory and Practice of Software (ETAPS)</em>, pages 172–185, 2005.</p>

    <p class="text-gray-300">52</p>

    <p class="text-gray-300">[35] Jonathan Katz and Chiu-Yuen Koo. On expected constant-round protocols for byzantine agreement. J. Comput. Syst. Sci., 75(2):91–112, February 2009.</p>

    <p class="text-gray-300">[36] Aggelos Kiayias and Giorgos Panagiotakos. Speed-security tradeoffs in blockchain protocols. Cryptology ePrint Archive, Report 2015/1019, 2015.</p>

    <p class="text-gray-300">[37] Eleftherios Kokoris-Kogias, Philipp Jovanovic, Nicolas Gailly, Ismail Khoffi, Linus Gasser, and Bryan Ford. Enhancing bitcoin security and performance with strong consistency via collective signing. CoRR, abs/1602.06997, 2016.</p>

    <p class="text-gray-300">[38] Jae Kwon. TenderMint: Consensus without Mining, August 2014.</p>

    <p class="text-gray-300">[39] Leslie Lamport. Fast paxos. Distributed Computing, 19(2):79–103, 2006.</p>

    <p class="text-gray-300">[40] Leslie Lamport, Dahlia Malkhi, and Lidong Zhou. Vertical paxos and primary-backup replication. In Proceedings of the 28th ACM Symposium on Principles of Distributed Computing, PODC '09, pages 312–313, 2009.</p>

    <p class="text-gray-300">[41] Leslie Lamport, Robert Shostak, and Marshall Pease. The byzantine generals problem. ACM Trans. Program. Lang. Syst., 4(3):382–401, July 1982.</p>

    <p class="text-gray-300">[42] Jean-Philippe Martin and Lorenzo Alvisi. Fast byzantine consensus. IEEE Trans. Dependable Secur. Comput., 3(3), 2006.</p>

    <p class="text-gray-300">[43] Daniele Micciancio and Bogdan Warinschi. Completeness theorems for the Abadi-Rogaway language of encrypted expressions. J. Comput. Secur., 12(1):99–129, January 2004.</p>

    <p class="text-gray-300">[44] Daniele Micciancio and Bogdan Warinschi. Soundness of formal encryption in the presence of active adversaries. In Theory of Cryptography Conference (TCC), 2004.</p>

    <p class="text-gray-300">[45] Andrew Miller, Yu Xia, Kyle Croman, Elaine Shi, and Dawn Song. The honey badger of BFT protocols. Cryptology ePrint Archive, Report 2016/199, 2016. http://eprint.iacr.org/.</p>

    <p class="text-gray-300">[46] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system. 2008.</p>

    <p class="text-gray-300">[47] Rafael Pass, Lior Seeman, and Abhi Shelat. Analysis of the blockchain protocol in asynchronous networks. In Eurocrypt, 2017.</p>

    <p class="text-gray-300">[48] Rafael Pass and Elaine Shi. Fruitchains: A fair blockchain. Manuscript, 2016.</p>

    <p class="text-gray-300">[49] Ryan Pfeiffer. The decrits consensus algorithm: Decentralized agreement without proof of work. CoRR, abs/1411.1101, 2014.</p>

    <p class="text-gray-300">[50] QuantumMechanic. Proof of stake instead of proof of work. bitcointalk.org, July 2011.</p>

    <p class="text-gray-300">[51] David Schwartz, Noah Youngs, and Arthur Britto. The Ripple Protocol Consensus Algorithm, September 2014.</p>

    <p class="text-gray-300">[52] Isaac C. Sheff, Robbert van Renesse, and Andrew C. Myers. Distributed protocols and heterogeneous trust: Technical report. CoRR, abs/1412.3136, 2014.</p>

    <p class="text-gray-300">[53] Marko Vukolic. The quest for scalable blockchain fabric: Proof-of-work vs. BFT replication. In Open Problems in Network Security - IFIP WG 11.4 International Workshop, iNetSec 2015, Zurich, Switzerland, October 29, 2015, Revised Selected Papers, pages 112–125, 2015.</p>

    <p class="text-gray-300">[54] Pieter Wuille. Block size following technological growth (bip 103). https://github.com/bitcoin/bips/blob/master/bip-0103.mediawiki.</p>

    <p class="text-gray-300">53</p>

    <p class="text-gray-300">Appendix</p>

    <h2 id="sec-145" class="text-2xl font-bold">Appendix A Background on Permissioned BFT</h2>

    <p class="text-gray-300">We briefly describe one possible instantiation of the permissioned BFT protocol using PBFT <em>[21]</em> as an example. Roughly speaking, PBFT <em>[21]</em> is a partially synchronous protocol for Byzantine state machine replication.</p>

    <p class="text-gray-300">Below we informally describe the protocol for the case when <span class="math">n=3f+1</span>. It is not hard to modify the protocol for the more general case <span class="math">n&gt;3f+1</span>. In our description, we assume transactions are proposed in units called batches.</p>

    <h5 id="sec-146" class="text-base font-semibold mt-4">Normal-case operations.</h5>

    <p class="text-gray-300">We first describe the normal-case operations of the PBFT protocol, where all messages are signed by the sender.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The leader of the current view proposes a tuple (“propose”,<span class="math">v,\\ell,\\mathsf{batch}</span>) to all nodes where <span class="math">v</span> denotes the view number and <span class="math">\\ell</span> denotes the sequence number.</li>

      <li>When an honest node hears (“propose”,<span class="math">v,\\ell,\\mathsf{batch}</span>), if it has not sent a prepare message for <span class="math">(v,\\ell)</span>, it multicasts (“prepare”,<span class="math">v,\\ell,\\mathsf{batch}</span>).</li>

      <li>When an honest node collects (“prepare”,<span class="math">v,\\ell,\\mathsf{batch}</span>) from <span class="math">2f+1</span> distinct nodes for the same <span class="math">(v,\\ell,\\mathsf{batch})</span> tuple, it multicasts (“commit”,<span class="math">v,\\ell,\\mathsf{batch}</span>). Further, the honest node now considers <span class="math">\\mathsf{prepared}(v,\\ell,\\mathsf{batch}):=1</span>.</li>

      <li>When an honest node first collects (“commit”,<span class="math">v,\\ell,\\mathsf{batch}</span>) from <span class="math">2f+1</span> distinct nodes for the same <span class="math">(v,\\ell,\\mathsf{batch})</span> tuple; or when it first collects (“committed”,<span class="math">v,\\ell,\\mathsf{batch}</span>) from <span class="math">f+1</span> distinct nodes for the same <span class="math">(v,\\ell,\\mathsf{batch})</span> tuple: the node considers <span class="math">\\mathsf{lcommitted}(v,\\ell,\\mathsf{batch}):=1</span> and multicasts (“committed”,<span class="math">v,\\ell,\\mathsf{batch}</span>). Here <span class="math">\\mathsf{lcommitted}</span> is short for “locally committed”.</li>

    </ol>

    <p class="text-gray-300">The normal-case protocol satisfies the following important properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Agreement.</em> If two honest nodes each believes that <span class="math">\\mathsf{prepared}(v,\\ell,\\mathsf{batch}):=1</span> and <span class="math">\\mathsf{prepared}(v,\\ell,\\mathsf{batch}^{\\prime}):=1</span> respectively, then <span class="math">\\mathsf{batch}=\\mathsf{batch}^{\\prime}</span>.</li>

      <li><em>Liveness under an honest leader.</em> If the leader is honest and no honest node has timed out since start of the latest view, then any batch submitted by an honest node will be locally committed by all honest nodes in <span class="math">O(1)</span> atomic time steps.</li>

      <li><em>Ample proofs of preparedness.</em> If at least one honest node considers <span class="math">\\mathsf{lcommitted}(v,\\ell,\\mathsf{batch}):=1</span>, then at least <span class="math">f+1</span> honest node considers <span class="math">\\mathsf{prepared}(v,\\ell,\\mathsf{batch}):=1</span>.</li>

    </ul>

    <p class="text-gray-300">If an honest node believes that <span class="math">\\mathsf{prepared}(v,\\ell,\\mathsf{batch}):=1</span>, then it can produce <span class="math">2f+1</span> signed prepare messages that led to this belief. We refer to the collection of these <span class="math">2f+1</span> prepare messages a <em>proof-of-preparedness</em>.</p>

    <p class="text-gray-300">Notice that an immediate corrolary of the agreement property is that if two honest nodes each believes that <span class="math">\\mathsf{lcommitted}(v,\\ell,\\mathsf{batch}):=1</span> and <span class="math">\\mathsf{lcommitted}(v,\\ell,\\mathsf{batch}^{\\prime}):=1</span> respectively, then <span class="math">\\mathsf{batch}=\\mathsf{batch}^{\\prime}</span>. However, the normal-case operation does not guarantee, under a potentially corrupt leader, that if one honest node thinks <span class="math">\\mathsf{lcommitted}(v,\\ell,\\mathsf{batch}):=1</span>, other honest nodes will necessarily think <span class="math">\\mathsf{lcommitted}(v,\\ell,\\mathsf{batch}):=1</span>. This therefore motivates the view change protocol.</p>

    <h5 id="sec-147" class="text-base font-semibold mt-4">View change.</h5>

    <p class="text-gray-300">The normal-case protocol alone does not guarantee liveness when the leader is corrupt. To guarantee liveness even when the leader is corrupt, a view change protocol is invoked upon timeouts. To obtain <span class="math">O(n\\delta)</span> worst-case response time, we can make a small modification to PBFT’s original exponential backoff strategy: instead, the timeouts could double every <span class="math">n</span> view changes. In the partially synchronous model, when the timeout backs off to <span class="math">\\Theta(\\delta)</span> and the leader is honest, liveness ensues.</p>

    <p class="text-gray-300">Roughly speaking, if an honest node hears <span class="math">f+1</span> valid view change requests for a new view <span class="math">v^{\\prime}</span>, it will echo the view change request by multicasting a view change message itself for view <span class="math">v^{\\prime}</span>.</p>

    <p class="text-gray-300">When the new view’s leader collects <span class="math">2f+1</span> valid view change requests, the set of <span class="math">2f+1</span> valid view change requests together form a <em>new-view</em> message. The leader then proposes the new-view message to all nodes. When an honest node receives the new-view message, For every <span class="math">(v,\\ell,\\mathsf{batch})</span> with a valid proof-of-preparedness contained in the new-view message, the node acts as if it has just received a (“propose”, <span class="math">v,\\ell,\\mathsf{batch})</span> message, therefore multicasts a prepare message for the tuple, and continues as in the normal-case operations.</p>

    <p class="text-gray-300">Due to the “ample proofs of preparedness” property of the normal-case operation, the following property holds: If an honest node believes that <span class="math">\\mathsf{lcommitted}(v,\\ell,\\mathsf{batch})=1</span>, then at least one valid proof-of-preparedness will be included in any valid new-view message. This ensures that if at least one honest node believes that <span class="math">\\mathsf{lcommitted}(v,\\ell,\\mathsf{batch})=1</span>, the tuple <span class="math">(v,\\ell,\\mathsf{batch})</span> is guaranteed to carry over to the new view, and therefore if other honest nodes locally commits <span class="math">(v,\\ell,\\mathsf{batch}^{\\prime})</span> in the new view, it holds that <span class="math">\\mathsf{batch}=\\mathsf{batch}^{\\prime}</span>.</p>

    <p class="text-gray-300">Finally, as long as the new leader is honest and no honest node has timed out yet in the new view, then liveness ensues for the new view.</p>

    <p class="text-gray-300">We refer the reader to the PBFT paper <em>[21]</em> for a detailed description of the view change protocol as well as the checkpointing optimization. It is not difficult to formalize the proofs in the PBFT paper <em>[21]</em> and extend them to a cryptographically sound framework. Further, it is not difficult to show that the PBFT protocol realizes our strong notion of security as defined in Section 4.2.</p>

    <p class="text-gray-300">##</p>`;
---

<BaseLayout title="Hybrid Consensus: Efficient Consensus in the Permissionless ... (2016/917)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/917
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
