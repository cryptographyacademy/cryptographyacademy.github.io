---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/917';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-21';
const TITLE_HTML = 'Hybrid Consensus: Efficient Consensus in the Permissionless Model';
const AUTHORS_HTML = 'Rafael Pass, Elaine Shi';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">Consensus, or state machine replication is a foundational building block of distributed systems and modern cryptography. Consensus in the classical, permissioned setting has been extensively studied in the 30 years of distributed systems literature. Recent developments in Bitcoin and other decentralized cryptocurrencies popularized a new form of consensus in a &ldquo;permissionless&rdquo; setting, where anyone can join and leave dynamically, and there is no a-priori knowledge of the consensus nodes. Despite this exciting breakthrough, today&rsquo;s permissionless consensus protocols, often referred to as &ldquo;blockchains&rdquo;, are known to have terrible performance, which has
resulted in heated, and at times acrimonious debates in the community.
First, we show that unfortunately a performance loss is inherent for any protocol that secures against at least 1/3 corruptions in hashpower. Specifically, we formally define a new performance
measure called responsiveness, and show that any responsive permissionless consensus protocol cannot tolerate 1/3 or more corruptions in hashpower. Next, we show a tightly matching uppper bound. Specifically, we propose a new permissionless consensus protocol called hybrid consensus, that is responsive and secures against up to 1/3 corruptions in hashpower. Hybrid consensus&#x27;s idea is to bootstrap fast permissionless consensus by combining an inefficient blockchain protocol with a fast permissioned consensus protocol.
Hybrid consensus uses the blockchain not to agree on transactions, but to agree on rotating committees which in turn execute permissioned consensus protocols to agree on transactions. While the high-level idea is intuitive, formally instantiating and reasoning about the protocol exposed a multitude of non-trivial technical subtleties and challenges.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> consensus &middot; blockchains &middot; optimal resilience &middot; distributed systems &middot; cryptocurrency</p>
    </section>

    <p class="text-gray-300">The distributed systems and cryptography literature traditionally has focused on protocols whose participants are known a priori. Bitcoin's rapid rise to fame represents an exciting breakthrough: Bitcoin empirically demonstrated that by leveraging assumptions such as proofs-of-work, non-trivial secure applications can be built on top of a fully decentralized network where nodes join and leave freely and dynamically, and there is no pre-established trust between participants. In the remainder of the paper, we will refer to the two network settings as the permissioned setting and the permissionless setting respectively.</p>

    <p class="text-gray-300">Informally speaking, Bitcoin's core consensus protocol, often referred to as Nakamoto consensus <a href="#page-53-0">[46]</a>, realizes a &quot;replicated state machine&quot; abstraction, where nodes in a permissionless network reach agreement about a set of transactions committed as well as their ordering. Since the protocol relies on chaining of blocks of transactions, it is often referred to as the &quot;blockchain&quot;.</p>

    <p class="text-gray-300">Achieving consensus in the traditional permissioned model turns out to be a classical distributed systems problem, and there is a long line of research that seeks to design and optimize Byzantine consensus protocols <a href="#page-52-0">[21,</a> <a href="#page-52-1">25,</a> <a href="#page-53-1">42]</a>. The fact that we can obtain consensus in a permissionless model (relying on proofs-of-work) was the novel contribution of Bitcoin. In a sense, Bitcoin popularized a new model of distributed systems that was rarely considered in 30 years of classical distributed systems literature.</p>

    <p class="text-gray-300">Known permissionless consensus protocols such as Bitcoin's Nakamoto consensus <a href="#page-53-0">[46]</a>, however, come at a cost. Since identities of nodes are not known a priori, it is imperative to defend against a Sybil attack where an attacker makes up arbitrarily many identities to outvote honest nodes. The Bitcoin protocol critically relies on proofs-of-work to roughly enforce the idea of &quot;one vote per hashpower&quot;. Unfortunately, Bitcoin is known to have terrible performance. As Croman et al. <a href="#page-52-2">[22]</a> point out, the Bitcoin network can sustain at most 7 tx/sec, at a transaction confirmation time of 10+ min (c.f. a main-stream payment processor such as Visa handles an average rate of 2, 000 tx/sec, and a peak rate of 59, 000 tx/sec). Further, each confirmed transaction costs roughly $1 to $6 if we were to amortize the network's total electricity consumption over all transactions being confirmed &mdash; today, this cost is in some sense being subsidized by the speculators of Bitcoin.</p>

    <p class="text-gray-300">This naturally raises an important question.</p>

    <p class="text-gray-300">Is it possible to design an efficient consensus protocol in the permissionless model?</p>

    <p class="text-gray-300">We formally explore this important question in this paper.</p>

      <h3 id="sec-1.1" class="text-xl font-semibold mt-8">1.1 Our Results and Contributions</h3>

    <p class="text-gray-300">Understanding the limits: performance vs. security. To understand this formally, let us first try to understand why the Nakamoto consensus protocol <a href="#page-53-0">[46]</a> (adopted by Bitcoin) is inefficient. As Garay et al. <a href="#page-52-3">[30]</a> and Pass et al. <a href="#page-53-2">[47]</a> point out, the Nakamoto consensus protocol crucially relies on a-priori knowledge of an upper bound of the network's delay (henceforth denoted &#8710;) to parametrize its puzzle difficulty, and the protocol's transaction confirmation time is roughly O(&lambda;&#8710;) to achieve exp(&minus;&Omega;(&lambda;)) security failure &mdash; one way to think about this is that the block interval needs to be O(&#8710;) to achieve security against any constant fraction of corruption (in hashpower), and one must wait for O(&lambda;) blocks to obtain exp(&minus;&Omega;(&lambda;)) security failure. Nakamoto is clearly inefficient since the a-priori parameter &#8710; needs to be set conservatively upfront to ensure the security of the protocol; and the transaction confirmation time suffers from looseness in the estimate &#8710;. While there are other possible metrics of efficiency, for now, we will focus on this one.</p>

    <p class="text-gray-300">Therefore, one natural question to ask is whether we can have a protocol whose transaction confirmation time depends only on the network's actual performance, but not any a-priori known upper bound. We formally define a performance metric called  <span class="math">responsiveness^1</span>  that captures this intuition: a protocol is said to be responsive, if its transaction confirmation time depends only on the network's actual delay  <span class="math">\\delta</span> , but not on any a-prior known upper-bound  <span class="math">\\Delta</span>  (or simply no a-priori upper bound is known). In particular, in practice the actual  <span class="math">\\delta</span>  is often (much) smaller than the upper bound  <span class="math">\\Delta</span> . In this case, responsiveness will be a useful measure of performance.</p>

    <p class="text-gray-300"><strong>Theorem 1.</strong> (informal.) No secure and responsive consensus protocol can tolerate 1/3 or more corruptions, even when the adversary is constrained to static corruptions &mdash; and this holds in both the classical permissioned setting (even when PKI is assumed), as well as in the permissionless setting with proofs-of-work (where corruptions are stated in terms of hashpower).</p>

    <p class="text-gray-300">The bad news is that we show that no responsive consensus protocol can tolerate 1/3 or more corruptions, even when the adversary is constrained and can only statically corrupt parties. This lower bound result holds both in the classical permissioned setting (even when PKI is assumed), as well as in the permissionless setting with proofs-of-work &mdash; in this setting corruptions are counted in terms of hashpower and not the number of nodes. To put this in perspective, observe that Nakamoto is not responsive, but can tolerate up to 1/2 corruptions in hashpower [47].</p>

    <p class="text-gray-300">The proof of this lower bound is related to the lower bound by Dwork et al. [25] who showed that in an asynchronous (or partially synchronous) network, no classical permissioned consensus protocol (even with PKI) can tolerate 1/3 or more Byzantine corruptions. In our paper, we will show how to adapt their proof to the permissionless and proof-of-work setting, and for responsive protocols.</p>

    <p class="text-gray-300">A responsive protocol with (almost) optimal resilience. The next obvious question is the following: suppose we are willing to relax the model and assume only &lt; 1/3 corruptions in hashpower, can we have a responsive consensus protocol in the permissionless setting? We answer this question in the positive.</p>

    <p class="text-gray-300"><strong>Theorem 2.</strong> (informal.) Assume a proof-of-work random oracle. There exists a responsive permissionless consensus protocol that is secure against  <span class="math">1/3 - \\epsilon</span>  corruptions in hashpower against a mildly adaptive adversary.</p>

    <p class="text-gray-300">To this end, we propose hybrid consensus. Hybrid consensus provides &quot;efficiency bootstrapping&quot; for permissionless consensus, much as the well-known hybrid encryption and OT-extension are &quot;efficiency bootstrapping&quot; constructions. Since classical permissioned consensus [15, 19, 21, 25, 39, 40, 42, 45] has been studied and optimized for decades and have been shown to achieve responsiveness against 1/3 corruptions, our idea is to use a slow blockchain protocol (called snailchain) such as Nakamoto consensus [30, 46] to bootstrap fast permissioned byzantine consensus, the end result being a scalable consensus protocol in the permissionless model. For this reason, we call our protocol &quot;hybrid consensus&quot;.</p>

    <p class="text-gray-300">Hybrid consensus is the first known responsive permissionless consensus protocol, even heuristically. We formally prove that hybrid consensus achieves security against a malicious (i.e., Byzantine) adversary with the following capabilities: 1) wields roughly or  <span class="math">\\frac{1}{3}</span>  fraction of the total computation power; 2) can corrupt nodes adaptively but corruptions take a while to be effective (henceforth</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;1</sup>Note that responsiveness is not to be mistaken with liveness which was defined by Garay et al. [30] and Pass et al. [47] in the permissionless setting. Liveness requires that transactions be confirmed within a bounded amount of time indicated by a liveness parameter T; whereas responsiveness in turn requires that T depend only on the network's actual delay  <span class="math">\\delta</span>  but not the (possibly loose) a-priori upper bound  <span class="math">\\Delta</span> .</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Scheme</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">TX conf. time</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Processing/tx</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">% honest</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Nakamoto [46], BitcoinNG [27]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&Theta;(&lambda;&#8710;)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">O(n)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1<br>&sim;<br>2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Fruitchain [48] (concurrent work)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&Theta;(&lambda;&#8710;)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">O(n)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1<br>&sim;<br>2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Hybrid consensus over Nakamoto</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Opt:<br>O(&delta;), Worst:<br>O(&lambda;&delta;)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">O(&lambda;)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3<br>&sim;<br>4</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Hybrid consensus over Fruitchain</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Opt:<br>O(&delta;), Worst:<br>O(&lambda;&delta;)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">O(&lambda;)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2<br>&sim;<br>3</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 1: Summary of our results. n denotes the total number of nodes (assuming all nodes have equal hashpower); &#8710; denotes a pre-determined upper-bound on the network's transmission delay; &delta; denotes the actual delay of the network; &lambda; is the security parameter for attaining 2&minus;<sup>&lambda;</sup> security failure.</p>

    <p class="text-gray-300">referred to as a mildly adaptive adversary); and 3) and can reorder messages during transmission, and delay messages up to a bound of &delta; time steps.</p>

    <p class="text-gray-300">Other practical benefits. Besides providing responsiveness, hybrid consensus also brings additional benefits in practice: for smart contract applications, it lowers the cost of processing to O(&lambda;) (i.e., independent of the total number of miners) while existing blockchains such as Nakamoto require that all miners execute the smart contracts. Finally, hybrid consensus can help increase the overall throughput of the consensus protocol since we expect a higher bandwidth throughput among the elected committee (in comparison with the full peer-to-peer network). Although hybrid consensus does not remove the proof-of-work, it reduces the cost per confirmed transaction by amortizing the proof-of-work cost over a higher transactional throughput.</p>

      <h3 id="sec-1.2" class="text-xl font-semibold mt-8">1.2 Technical Subtleties and Comparison with Closely Related Works</h3>

    <p class="text-gray-300">Although the idea of combining permissionless consensus and permissioned consensus has been discussed in the community (e.g., the recent work by Decker et al. <a href="#page-52-6">[23]</a> and the concurrent and independent work ByzCoin <a href="#page-53-7">[37]</a>), to the best of our knowledge, no prior work has provided a formal treatment.</p>

    <p class="text-gray-300">Technical subtleties. As our work shows, combining permissioned and permissionless protocols is non-trivial both in terms of construction and in terms of proving security. Our endeavor reveals numerous subtleties that could have been easily overlooked without a formal treatment: e.g., how to defend against selfish mining and achieve optimal resilience; how to rely on an on-chain stamping technique to defend against retroactive committee corruptions; how to deal with an adversarial selective opening of the committees; how to correctly handle committee switchover to ensure compositional security when multiple classical BFT instances can be running concurrently over short windows during the switchover.</p>

    <p class="text-gray-300">Comparison with closely related works. In comparison, the prior work by Decker et al. <a href="#page-52-6">[23]</a> and the concurrent work Byzcoin <a href="#page-53-7">[37]</a> take a heuristic approach towards security: upon close examination, these works appear to have neglected one or more of the above subtleties (and additional ones). First, both works <a href="#page-52-6">[23,</a> <a href="#page-53-7">37]</a> claim to attain optimal resilience (i.e., tolerating 1/3 corruption), but their claim is incorrect &mdash; since these works use Nakamoto as the underlying snailchain, due to a well-known selfish mining attack <a href="#page-52-7">[28]</a>, they can at best tolerate 1/4 corruption absent non-trivial changes to their protocol. Besides this notable issue, there are additional apparent vulnerabilities with the Byzcoin protocol <a href="#page-53-7">[37]</a>: for example, their protocol does not remove trailing blocks in committee election, and thus there may not be agreement on the committee &mdash; this can harm the consistency and/or liveness of their protocol (these vulnerabilities of Byzcoin were also independently observed by others <a href="#page-50-0">[1]</a>). Indeed, since Byzcoin <a href="#page-53-7">[37]</a> was published in Usenix Security'16, the authors themselves have acknowledged some of these vulnerabilities in subsequent blog posts <a href="#page-51-1">[3,</a> <a href="#page-51-2">4]</a>. Notably, in their most recent blog <a href="#page-51-2">[4]</a>, they cite our paper as a potential solution for achieving optimal resilience &mdash; however, thus far they still do not provide a formally correct protocol. Since their work seems to have neglected multiple subtleties that our effort has exposed, it is not clear what security guarantees they provide or in what security model their protocol gives any guarantees at all.</p>

    <p class="text-gray-300">Therefore, our work is distinct in that we provide the first provably correct approach for combining proof-of-work blockchains and classical consensus to achieve responsiveness.</p>

      <h3 id="sec-1.3" class="text-xl font-semibold mt-8">1.3 Paper Organization</h3>

    <p class="text-gray-300">Our formal treatment is a rather significant endeavor (and necessary as argued above) &mdash; thus for readability, we first present a semi-formal technical roadmap in Section <a href="#page-4-0">2</a> before we give formal definitions, protocol description, and proofs.</p>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 Technical Roadmap</h2>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8">2.1 Preliminaries and Building Blocks</h3>

    <p class="text-gray-300">In this section, we present semi-formal or informal definitions for permissionless consensus which is the abstraction that we aim to realize, as well as the building blocks we rely on. The formal definitions will be presented later in the paper.</p>

      <h4 id="sec-2.1.1" class="text-lg font-semibold mt-6">2.1.1 Permissionless Consensus</h4>

    <p class="text-gray-300">Our goal is to realize a state machine replication abstraction in the permissionless model &mdash; henceforth referred to as permissionless consensus<a href="#page-4-1">2</a> .</p>

    <p class="text-gray-300">In a permissionless consensus protocol, each node outputs a LOG in every time step &mdash; this LOG represents the set of committed transactions. Two important security requirements, namely, consistency and liveness must be guaranteed with overwhelming probability.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Consistency: Consistency includes the following:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Common prefix. Suppose that an honest node i outputs LOG to Z at time t, and an honest node j (same or different) outputs LOG<sup>0</sup> to Z at time t 0 , it holds that either LOG &#8826; LOG<sup>0</sup> or LOG<sup>0</sup> &#8826; LOG. Here the relation &#8826; means &quot;is a prefix of&quot;. By convention we assume that &empty; &#8826; x and x &#8826; x for any x.</li>
      <li>Self-consistency. Suppose that a node i is honest at time t and t <sup>0</sup> &ge; t, and outputs LOG and LOG<sup>0</sup> at times t and t 0 respectively, it holds that LOG &#8826; LOG<sup>0</sup> .</li>
    </ul></li>
    </ul>

    <p class="text-gray-300"><sup>2</sup>The term consensus is also used in the classical distributed systems literature to mean single-shot agreement protocols. In this paper, consensus means state machine replication, where nodes would like to agree on a linearly ordered log that grows over time.</p>

    <p class="text-gray-300">&bull; Liveness: Suppose that transactions TXs is input to an honest node at time  <span class="math">t \\geq T_{\\text{warmup}}</span> . Then, if any node that is honest at time  <span class="math">t&#x27; \\geq t + T_{\\text{confirm}}</span>  outputs LOG at time t', it holds that TXs  <span class="math">\\subseteq</span>  LOG.</p>

    <p class="text-gray-300">Intuitively, liveness says that transactions get included in honest nodes' LOGs within  <span class="math">T_{\\rm confirm}</span>  time. There are two liveness parameters  <span class="math">T_{\\rm confirm}</span>  and  <span class="math">T_{\\rm warmup}</span> .  <span class="math">T_{\\rm warmup}</span>  is the protocol's warmup time; and  <span class="math">T_{\\rm confirm}</span>  is the maximum wait time for a transaction (proposed after  <span class="math">T_{\\rm warmup}</span> ) to be confirmed.</p>

      <h4 id="sec-2.1.2" class="text-lg font-semibold mt-6">2.1.2 Blockchains</h4>

    <p class="text-gray-300">Hybrid consensus relies on a proof-of-work blockchain (henceforth referred to as a snailchain) as a building block. A proof-of-work blockchain can be regarded as a special case of a permissionless consensus protocol &mdash; in fact, we will formally show this in the full version of our paper. The formal abstractions for blockchains were proposed by Garay et al. [30] and Pass et al. [47]. We provide a semi-formal definition of blockchains in this section while deferring the formal definitions to later sections. Imprecisely speaking, a snailchain satisfies the following properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Consistency. All honest nodes' chains (at any time) agree with each other except for the trailing  <span class="math">\\lambda</span>  blocks where  <span class="math">\\lambda</span>  is the security parameter. Further, a node's chain agrees with its future self.</li>
      <li>Chain quality. Among any consecutive  <span class="math">\\lambda</span>  blocks in an honest node's chain, a sufficient fraction of the blocks are mined by honest miners.</li>
      <li>Chain growth. Honest nodes' chains grow at a steady rate, neither too fast nor too slow.</li>
    </ul>

      <h4 id="sec-2.1.3" class="text-lg font-semibold mt-6">2.1.3 Permissioned BFT</h4>

    <p class="text-gray-300">Permissioned BFT protocols have been extensively studied in the classical distributed systems literature. Typically, known permissioned BFT [21,25,42] satisfy exactly the same consistency and liveness guarantees as defined earlier &mdash; but here for the permissioned setting.</p>

    <p class="text-gray-300">Hybrid consensus will consume a permissioned BFT protocol as a building block. In turns out that in our context, an interesting technical subtlety arises in formalizing the abstractions required of the permissioned BFT. A property-based security definition (as is customarily done in the distributed systems literature) turns out to be insufficient due to a <em>selective opening</em> attack. In particular, the adversary is allowed to first look at nodes' public keys, and then adaptively influence the way the committee is chosen. In Section 4.2, we argue that there exists a (somewhat contrived) permissioned BFT protocol that is provably secure under property-based definitions, but would be completely broken if subject to adversarial selective opening.</p>

    <p class="text-gray-300">As a result, we define a strengthened security notion for our underlying permissioned BFT building block. Not only do we require that the aforementioned consistency and liveness properties be satisfied with overwhelming probability, we need the following stronger statement:</p>

    <p class="text-gray-300">There exists a p.p.t. reduction  <span class="math">\\mathcal{B}</span>  such that given any p.p.t. adversary that can break the BFT's security properties over any set of public keys, the reduction  <span class="math">\\mathcal{B}</span>  which makes blackbox calls to this adversary can forge a signature on behalf of an honest party.</p>

    <p class="text-gray-300">Later in the paper, we will formalize the above notion and additionally show how to realize this abstraction by augmenting the PBFT algorithm [21].</p>

      <h4 id="sec-2.1.4" class="text-lg font-semibold mt-6">2.1.4 Execution Model</h4>

    <p class="text-gray-300">We consider an open enrollment network with a proof-of-work oracle that is modelled a random oracle as in earlier works [30, 47].</p>

    <p class="text-gray-300">Network assumptions. We assume a partially synchronous model, where any message sent by an honest node is guaranteed to arrive at all honest nodes within &delta; time steps. The adversary is allowed to reorder messages subject to the above constraints.</p>

    <p class="text-gray-300">Our protocol needs to know a possibly loose upper bound of &delta; to parametrize the scheme (in particular, to parametrize the puzzle difficulty of the underlying snailchain). We henceforth use the notation &#8710; to denote this pre-determined upper bound. Our protocol achieves responsiveness: even though we use the a-priori upper bound &#8710; as an input parameter, our protocol achieves transaction confirmation time that depends on the network's actual delay &delta;, not the possibly loose upper bound &#8710;. This requirement makes our setting fundamentally different than the synchronous model &mdash; since if the protocol simply takes &#8710; time steps to be a synchronous round, the protocol would not be responsive.</p>

    <p class="text-gray-300">Mildly adaptive corruption. Although we allow the adversary to adaptively decide which nodes to corrupt, corruption does not take place instantly. In our model, when the adversary issues a &quot;target corrupt&quot; instruction to a node, it takes &tau; time for the node to actually become corrupt (where &tau; will be parametrized later in the full version). Once a node actually becomes corrupt, the adversary can kill the node. Finally, new nodes can spawn at any time.</p>

    <p class="text-gray-300">Admissible parameters. Henceforth we will assume that the underlying blockchain chooses a suitable difficulty parameter, such that the expected inter-block time is a suitable constant fraction larger than the network delay between honest nodes. We formalize these admissibility requirements later in the paper.</p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8">2.2 The Hybrid Consensus Protocol: Overview</h3>

    <p class="text-gray-300">Underlying snailchain. We build atop of an underlying blockchain protocol (denoted snailchain) whose formal abstractions were defined by Garay et al. <a href="#page-52-3">[30]</a> and Pass et al. <a href="#page-53-2">[47]</a>. There are two possible realizations of such a snailchain abstraction, the original Nakamoto consenus <a href="#page-52-3">[30,</a> <a href="#page-53-0">46,</a> <a href="#page-53-2">47]</a>, and the more recent Fruitchain <a href="#page-53-6">[48]</a> protocol. For conceptual simplicity, in our exposition, we will assume that Nakamoto is the underlying snailchain. However, as we explain later, using Nakamoto as the snailchain allows us to secure against 1/4 &minus; corruption (in hashpower).</p>

    <p class="text-gray-300">Fruitchain <a href="#page-53-6">[48]</a> realizes the same abstraction as the Nakamoto snailchain&mdash; however, as Fruitchain provably secures against the selfish-mining attack, it achieves (almost) ideal chain quality. As we argue later, if we instead adopt Fruitchain as a drop-in replacement of the underlying snailchain, we can defend against 1/3 &minus; corruption (in hashpower) for an arbitrarily small constant , thus achieving (almost) optimal resilience. Incidentally, this also demonstrates the compelling advantage of modular protocol design and composition.</p>

      <h4 id="sec-2.2.1" class="text-lg font-semibold mt-6">2.2.1 Warmup: Static Committee</h4>

    <p class="text-gray-300">Fundamentally, a blockchain such as Nakamoto consensus (henceforth denoted snailchain) relies on proofs-of-work puzzles such that nodes can establish Sybil-resilient identities. Our first idea is to leverage snailchain to elect a static committee. To do this, honest nodes run the blockchain for csize + &lambda; blocks where csize = &Theta;(&lambda;) denotes the targeted committee size, and &lambda; denotes a security parameter. At this moment, an honest node would remove the trailing, unstablized &lambda; blocks from its local chain, and call the miners of the first csize blocks the BFT committee<a href="#page-6-0">3</a> .</p>

    <p class="text-gray-300"><sup>3</sup> If multiple blocks are mined by the same miner, that miner can simply act as multiple virtual nodes in the BFT protocol &mdash; for this reason, the protocol works for n &lt; &lambda; as well (and so does our final scheme hybrid consensus).</p>

    <p class="text-gray-300">Roughly speaking, such a protocol can be proven secure under a static corruption model due to the following.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Due to the consistency property of snailchain, all honest nodes agree on the same BFT committee. We stress that it is important to remove the trailing &lambda; unstable blocks since otherwise honest nodes will have differing opinions on who should be the BFT committee (e.g., due to possible forks in the snailchain) &mdash; in this case we cannot guarantee the protocol secure<a href="#page-7-0">4</a> .</li>
      <li>Due to the chain quality property of snailchain, with appropriate overall parameters, we can ensure that more than 2/3 of the committee members are honest which is sufficient to ensure the security of the permissioned BFT protocol.</li>
      <li>Due to the chain growth property of snailchain, it will not take too long for the BFT committee to form.</li>
    </ul>

    <p class="text-gray-300">Finally, committee members sign any transaction committed as well as its sequence number. For any node that was not elected as a committee member, it can simply count d 3 |csize|e number of signatures from committee members for deciding its own output log. Since more than 2/3 of the committee members are honest, there is at least one honest committee member if at least d 1 3 |csize|e vouch for the same transaction and its sequence number (i.e., its relative position within the output log). It is not hard to see that responsiveness holds for this simple protocol assuming that the BFT protocol employed is responsive.</p>

    <p class="text-gray-300">An interesting paradox. Despite the apparent simplicity of this proposal, this scheme is nonetheless thought provoking. One intriguing apparent paradox is the following: since we do not rely on the snailchain to agree on transactions any more, why not stop running the snailchain after the committee is elected? Although this proposal may seem tempting initially, one quickly realizes that it is not secure. In particular, for any protocol that stops performing proofs-of-work after bounded polynomial amount of time, an adversary can always create a simulated execution that is identically distributed as the real execution, such that a node that spawns late is unable to distinguish the real execution from the simulated one. We formalize this lower bound in Section <a href="#page-47-0">9,</a> and show that any secure permissionless consensus protocol must call proofs-of-work infinitely often (even for static security and the synchronous model).</p>

      <h4 id="sec-2.2.2" class="text-lg font-semibold mt-6">2.2.2 Handling Mildly Adaptive Corruption</h4>

    <p class="text-gray-300">From static to mildly adaptive corruptions. The aforementioned scheme with a static committee fails to be secure against an adaptive adversary, since the adversary can simply corrupt the committee once it is elected. Unfortunately, any scheme that down-selects from n nodes to a &lambda;-sized committee must be vulnerable to such adaptive attacks.</p>

    <p class="text-gray-300">In reality, however, corruption of a node is typically not instant, since it takes a while to infect an otherwise clean host. We therefore define a slightly relaxed and nonetheless realistic corruption model henceforth referred to as &tau; -agile corruptions. In this model, roughly speaking, an adversary can issue &quot;target corrupt&quot; instructions to nodes; however, a node that receives &quot;target corrupt&quot; does not become corrupt until &tau; time steps later.</p>

    <p class="text-gray-300">We show a positive result under this &tau; -agile corruption model. Our key idea is to rely on rotating committees. When an honest node's chain reaches R &middot; csize + &lambda; in length, the R-th committee is elected by first removing the trailing &lambda; number of blocks, and then from this pruned chain, we elect</p>

    <p class="text-gray-300"><sup>4</sup>Note that in comparison, the concurrent and independent work Byzcoin <a href="#page-53-7">[37]</a> does not explicitly make this observation, and therefore their protocol and security guarantees appear under-specified.</p>

    <p class="text-gray-300">the last csize blocks' miners as the committee. The idea is that if an adversary targets a committee member once he mines a block (that will allow him to be included in a committee), it will be too late. With an appropriate &tau; , by the time the node actually becomes corrupt, the committee's term will have been ended, and the next committee will have already taken over! We leave it as an exciting open question whether fully adaptive security is possible for responsive permissionless consensus protocols.</p>

    <p class="text-gray-300">Technical challenges. While the high-level idea may seem straightforward, it turns out that defining and handling mildly adaptive corruptions introduces various technical subtleties &mdash; specifically, we need to correctly handle committee switchover in a way that guarantees concurrent composition; moreover, the possibility that an adversary can retroactively corrupt old committees also introduces new challenges.</p>

    <p class="text-gray-300">Daily operations. Henceforth for convenience, we will say that each committee serves for a day, and outputs a daily log. Our hybrid consensus protocol essentially outputs the concatenation of these daily logs. We now describe the daily operations of both committee members and nonmembers.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Committee members. On each day R, the R-th committee will run a BFT instance. A committee member will continue running the BFT protocol to commit transactions until it receives a &quot;stop&quot; instruction at which point a special stopping procedure is invoked. Therefore, committee members will output committed transactions gradually over time. Committed transactions will populate a node's daily log denoted logR.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Whenever an honest committee member adds a new transaction tx to its logR, it will sign the tuple (R, <code>,tx) where R denotes the current day and </code> denotes the sequence number of tx within the day. The honest committee member then gossips the signed tuple to the network.</li>
    </ul></li>
      <li>Committee non-members. Non-members hear signed transactions from the network. Whenever a non-member hears that a tuple (R, \`,tx) has been signed by more than <sup>1</sup> 3 fraction of comm<sup>R</sup> members, he adds the tx to its logR:</li>
    </ul>

    <p class="text-gray-300">if
<span class="math">$\\mathsf{log}_R[\\ell]</span>$
is not populated :  <span class="math">\\mathsf{log}_R[\\ell] := \\mathsf{tx}</span></p>

    <p class="text-gray-300">Observe that a committee non-member can write to its logR[\`] out of order since messages may be received out of order. However, a transaction cannot be processed until all preceding transactions have been committed. Later, when we define each node's output LOG, we enforce that transactions are always written to LOG in sequential order &mdash; and this can be achieved if committee non-members output the longest contiguous prefix of log<sup>R</sup> to its LOG.</p>

    <p class="text-gray-300">Committee switchover. Whenever a node enters a new day denoted R + 1, a committee switchover is needed. Realizing committee switchover correctly without leaving gaps of inactivity in between is somewhat tricky. We propose an approach where at the beginning of each day, the new committee starts a new BFT instance, and at the same time the old committee initiates a stopping procedure of the existing instance. This would introduce several subtleties because in transient windows, two (or more) instances of BFT protocols may be concurrently executing &mdash; in these cases, nodes need to correctly linearize the outputs of the multiple instances; and we also need to ensure concurrent composition of the multiple BFT instances.</p>

    <p class="text-gray-300">Below we first describe the stopping procedure of the previous BFT instance; we then describe how nodes output a linearized log in the presence of possibly concurrently executing BFT instances.</p>

    <p class="text-gray-300">In the following, let R be the previous day.</p>

    <p class="text-gray-300">&bull; Member of the previous committee. If a node is a member of the R-th committee denoted  <span class="math">\\mathsf{comm}_R</span> , it inputs a special, signed  <span class="math">\\mathsf{stop}</span>  transaction to the previous  <span class="math">\\mathsf{BFT}</span> &mdash; a node may run multiple  <span class="math">\\mathsf{BFT}</span>  virtual nodes, in which case one signed  <span class="math">\\mathsf{stop}</span>  transaction is input to each  <span class="math">\\mathsf{BFT}</span>  virtual node. When the  <span class="math">\\mathsf{BFT}</span> 's log collects sufficiently many of these  <span class="math">\\mathsf{stop}</span>  transactions signed by distinct committee member public keys, the log is finalized and all later transactions are ignored. At this moment, we say that the previous  <span class="math">\\mathsf{BFT}</span>  has terminated. When the previous  <span class="math">\\mathsf{BFT}</span>  has terminated, a member of  <span class="math">\\mathsf{comm}_R</span>  will sign the tuple  <span class="math">(R, |\\mathsf{log}_R|)</span>  and gossip the signed tuple to the network. This allows non-members of  <span class="math">\\mathsf{comm}_R</span>  to determine when  <span class="math">\\mathsf{log}_R</span>  ends.</p>

    <p class="text-gray-300">Further, an honest committee member signs  <span class="math">(R, \\mathsf{hash}(\\mathsf{log}_R))</span>  where  <span class="math">\\mathsf{hash}</span>  is collision-resistant, and proposes the signed tuple to the underlying snailchain&mdash;we henceforth refer to this action as stamping. As we explain later, timely stamping secures against an adversary that can retroactively corrupt old committee members in the future.</p>

    <p class="text-gray-300">At this point, the honest  <span class="math">comm_R</span>  member outputs &quot;done&quot;.</p>

    <p class="text-gray-300">&bull; Non-member of the previous committee. If the node is not a committee member of the BFT instance for day R, it waits for more than  <span class="math">\\frac{1}{3}</span>  fraction of  <span class="math">\\mathsf{comm}_R</span>  members to vouch for a tuple  <span class="math">(R,\\ell)</span> . When this happens, it knows that  <span class="math">\\ell</span>  is the final sequence number of  <span class="math">\\mathsf{log}_R</span> . Therefore, it simply waits for all of  <span class="math">\\mathsf{log}_R[:\\ell]</span>  to be populated before outputting &quot;done&quot;.</p>

    <p class="text-gray-300">Whenever a node (either member of non-member of  <span class="math">comm_R</span> ) outputs &quot;done&quot;, its  <span class="math">log_R</span>  is said to be final. We note that honest  <span class="math">comm_{R+1}</span>  members start the new BFT instance for day R+1 as soon as they perceive the start of day R+1, and without waiting for their  <span class="math">log_R</span>  to be final. This ensures that all  <span class="math">comm_{R+1}</span>  members start the new BFT instance within a short duration from each other (whereas waiting for  <span class="math">log_R</span>  to be final will incur extra drift in the start time of the next BFT instance).</p>

    <p class="text-gray-300">Output a linearized log. Nodes need to collect their daily logs into a final log denoted LOG&mdash;and this final log must satisfy the properties defined in Section 3.2. In particular, this final log LOG outputs transactions in increasing order, since one may not be able to process a transaction until all preceding transactions have been accumulated. As we pointed out, committee non-members may write to its daily log denoted  <span class="math">\\log_R</span>  out of order. Further, when the BFT instance on the R-th day is started, the previous BFT instance may not have fully completed, and therefore  <span class="math">\\log_R</span>  would have to wait for  <span class="math">\\log_{R-1}</span>  to be final.</p>

    <p class="text-gray-300">Therefore, to output the final log LOG in order, we simply define LOG to contain:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A maximal, consecutive sequence of daily logs  <span class="math">\\log_1</span> ,  <span class="math">\\log_2</span> , ...,  <span class="math">\\log_{r-1}</span>  all of which must be final.</li>
      <li>The longest contiguous prefix of the daily  <span class="math">\\log \\log_r&#x27;</span> .</li>
    </ul>

    <p class="text-gray-300">On-chain stamping: defending against retroactive corruption. Given long enough time, an adversary can eventually corrupt sufficiently many BFT committee members, and at this point, the adversary can forge BFT committee members' signatures over any message of its choice. Therefore, signatures from BFT committee members are of no worth after a long enough time. Under the possibility of such retroactive attacks, nodes that spawn late cannot rely on counting committee members' signatures for deciding logs that are too ancient.</p>

    <p class="text-gray-300">To address this challenge, we rely on an <em>on-chain stamping</em> technique. When honest BFT committee members terminate their BFT instances, they would sign a hash of the daily log and propose the tuple as a transaction to the underlying snailchain. We prove that under appropriate</p>

    <p class="text-gray-300">parameter choices, sufficiently many honest BFT committee members' daily log hashes get stamped on snailchain in a timely manner (in particular before the nodes actually become corrupt). In this way, nodes who spawn late can recover the correct hash of past daily logs from the underlying snailchain (instead of counting signatures from ancient committee members who may by then be corrupt). We stress that the on-chain stamping is only for late-joining nodes to recover historical daily logs. Transaction confirmation online requires only counting signatures from the present committee, and need not wait for the on-chain stamping to take place.</p>

      <h4 id="sec-2.2.3" class="text-lg font-semibold mt-6">2.2.3 Chain Quality and Resilience</h4>

    <p class="text-gray-300">It would be ideal if mining were a random lottery, where for each block, nature draws a winner at random. If this were indeed the case, we could achieve perfect chain quality, i.e., roughly 1&minus;&alpha; chain quality if &alpha; fraction of nodes are corrupt. Unfortunately, several previous works <a href="#page-52-7">[28,</a> <a href="#page-52-3">30,</a> <a href="#page-53-2">47]</a> have shown that Nakamoto consensus cannot be thought of as a perfect lottery due to a selfish mining attack. When honest nodes mine a block, they announce the block immediately, but corrupt nodes need not follow this rule. In a selfish-mining attack, roughly speaking, when corrupt nodes mine a block B<sup>&lowast;</sup> off the currently longest chain, they withhold the block B<sup>&lowast;</sup> from the public and continue to mine on its own private fork. If at some point honest nodes happen to mine a new block B off chain, at this moment the adversary immediately releases the block B<sup>&lowast;</sup> , and combined with a network rushing attack, the block B<sup>&lowast;</sup> will get to other nodes more quickly than B. In this manner, the adversary has successfully erased the work of honest nodes &mdash; and in fact every time corrupt nodes mine a block, they have an opportunity to erase an honest node's block. Consequently, Nakamoto consensus would require roughly 3/4 overall honest to achieve 2/3-chain quality (and 2/3-chain quality is needed to ensure that 2/3 of the BFT committee are honest) &mdash; in fact, this is also the reason why previous works (Decker et al. <a href="#page-52-6">[23]</a> and Byzcoin <a href="#page-53-7">[37]</a>) that claim to achieve optimal resilience were incorrect.</p>

    <p class="text-gray-300">The loss of resilience arising from chain quality loss can be mostly avoided, if instead of Nakamoto consensus, we adopt Fruitchain <a href="#page-53-6">[48]</a> as the underlying blockchain protocol. As shown by Pass and Shi <a href="#page-53-6">[48]</a>, Fruitchain provably defends against such a selfish-mining attack, and therefore attains almost perfect chain quality, i.e., it achieves roughly (1 &minus;&alpha;)-chain quality with any &alpha; &lt; 1/2 corruption under typical parametrizations. Therefore, hybrid consensus over Fruitchain requires only 2/3 overall honest hashpower (approximately) to achieve security.</p>

      <h4 id="sec-2.2.4" class="text-lg font-semibold mt-6">2.2.4 Modular Protocol Composition and Formal Reasoning</h4>

    <p class="text-gray-300">To aid formal reasoning and presentation, our protocols are described through a modular composition approach.</p>

    <p class="text-gray-300">Daily offchain consensus. We first construct an intermediate abstraction called DailyBFT which describes what committee members and non-members do respectively to agree on each day's daily log. Our hybrid consensus protocol will fork one instance of DailyBFT[R] for each day where R is the day number as well as the unique session identifier for the DailyBFT instance. Hybrid consensus then concatenates the daily logs output by these DailyBFT instances.</p>

    <p class="text-gray-300">In a DailyBFT instance, each elected committee member spawns one or more BFT virtual nodes, depending on how many of its public keys were included in the committee. If a node has not been elected as the committee, it would count signatures from committee members to decide its daily log.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Variable</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Meaning</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">tx</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">a transaction</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">\`</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">sequence number of a transaction within each BFT instance</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">LOG</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">the totally ordered log each node outputs,<br>LOG<br>is always populated</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">in order</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">log</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">log of one<br>BFT<br>instance, referred to as daily log</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0<br>log[<code>&lt;br&gt;:&lt;br&gt;</code><br>]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0<br>transactions numbered<br><code>&lt;br&gt;to&lt;br&gt;</code><br>in<br>log</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">log[:<br>\`]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">log[1 :<br>\`]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&lambda;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">security parameter</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">adversary's fraction of hashpower</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&delta;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">network's maximum actual delay</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#8710;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">a-priori upper bound of the network's delay (typically loose)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">csize</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">committee size, our protocol sets<br>csize<br>:=<br>&lambda;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">th</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">th<br>:=<br>dcsize/3e, a threshold</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">lower(R),<br>upper(R)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">lower(R) := (R<br>&minus;<br>1)csize<br>+ 1,<br>upper(R) :=<br>R<br>&middot;<br>csize</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">chain</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">a node's local chain in the underlying<br>snailchain<br>protocol</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&minus;&lambda;]<br>chain[:</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">all but the last<br>&lambda;<br>blocks of a node's local<br>chain</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">MinersOf(chain[s<br>:<br>t])</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">the public keys that mined each block in<br>chain[s<br>:<br>t].<br>It is possible</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">that several public keys belong to the same node.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">{msg}pk&minus;1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">a signed message<br>msg, whose verification key is<br>pk</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Tbft</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">liveness parameter of the underlying BFT scheme</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 2: Notations</p>

    <p class="text-gray-300">We formalize and prove the security properties of DailyBFT: Below are a few things to keep in mind when reading the detailed formalism presented in Section <a href="#page-27-0">5.2.</a></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>While the lower-level BFT building block states its security properties (i.e., consistency and liveness) for committee members only, in DailyBFT, these security properties are extended to non-committee members as well.</li>
      <li>The lower-level BFT building block assumes that all committee members are spawned before the BFT instance starts. In DailyBFT, however, these security properties need to extend to committee non-members who potentially spawned later (but not too late).</li>
      <li>On the other hand, DailyBFT does not guarantee security (i.e., consistency and liveness) for nodes that join too late, since committee members may become corrupt far out in the future, at which point committee members can sign arbitrary tuples, and thus late joining nodes cannot rely on counting signatures to decide their daily logs any more. We defer it to hybrid consensus to deal with this attack, by having late joining nodes recover ancient daily logs by examining daily log hashes stamped on the snailchain.</li>
      <li>DailyBFT offers a keygen abstraction: upon every keygen query, DailyBFT generates and outputs a new miner public key pk &mdash; the hybrid consensus protocol will incorporate pk into the block being mined. Later, DailyBFT will receive input from the environment which set of pks have been selected as committee members. This is where the adversarial selective opening of committee keys is handled. The security proof of DailyBFT therefore makes use of the strong security of the BFT protocol, to argue that the BFT protocol, when run inside DailyBFT as a subprotocol,</li>
    </ul>

    <p class="text-gray-300">will respect the stated security properties including consistency and liveness &mdash; otherwise one could construct a reduction that breaks signature security.</p>

    <p class="text-gray-300">&bull; Finally, in comparison with BFT, DailyBFT additionally implements a termination procedure that satisfies two properties, timely termination, and termination agreement. Timely termination says that the BFT protocol terminates quickly upon honest nodes receiving stop instructions. Termination agreement says that all honest nodes output identical final logs upon termination. Termination is realized by having honest BFT virtual nodes input a special, signed stop transaction to the underlying BFT. When [|comm|/3] stop transactions signed by distinct committee member keys have accumulated in the log, all later transactions are ignored and the log is finalized.</p>

    <p class="text-gray-300"><strong>Hybrid consensus.</strong> We now describe our final product, the hybrid consensus protocol. Hybrid consensus consumes multiple instances of DailyBFT where rotating committees agree on daily logs. Hybrid consensus primarily does the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>It manages the spawning and termination of DailyBFT instances effectively using snailchain as a global clock that offers weak synchronization among honest nodes;</li>
      <li>Recall that each DailyBFT instance does not ensure security for nodes that spawn too late, since committee members can become corrupt far out in the future at which point they can sign arbitrary tuples. Therefore, hybrid consensus introduces an on-chain stamping mechanism to extend security guarantees to even nodes that spawn late. Specifically, committee members stamp their signed daily log hash onto snailchain when their BFT instance terminates. Nodes that spawn late will rely on this on-chain stamp to identify and recover ancient daily logs in the past (rather than counting off-chain signatures from committee members).</li>
    </ul>

      <h4 id="sec-2.2.5" class="text-lg font-semibold mt-6">2.2.5 Main Theorem</h4>

    <p class="text-gray-300">Below we state our main theorem: by using Fruitchain as the underlying snailchain in hybrid consensus, we obtain the first responsive permissionless consensus protocol with optimal resilience. The proof of the main theorem will be presented later in the paper.</p>

    <p class="text-gray-300">Let  <span class="math">\\alpha</span>  denote the adversarial fraction, let  <span class="math">\\rho</span>  denote the probability that a single node mines a block in each time step, let  <span class="math">\\lambda</span>  denote a security parameter for Hybrid Consensus, and let  <span class="math">\\eta</span>  be an additional parameter expected by Hybrid Consensus (such that the committee size will be chosen as  <span class="math">\\frac{\\lambda}{\\eta}</span> ), let  <span class="math">\\kappa</span>  denote a security parameter for the underlying Fruitchain protocol, we have the following theorem:</p>

    <p class="text-gray-300"><strong>Theorem 3</strong> (Hybrid consensus over Fruitchain). For any (arbitrarily small) constant  <span class="math">\\epsilon &gt; 0</span> , let  <span class="math">\\alpha = \\frac{1}{3} - \\epsilon</span> , for every  <span class="math">n, \\delta</span> , there exists a sufficiently small  <span class="math">\\rho := \\Theta(\\frac{1}{\\delta n})</span> , a suitable  <span class="math">\\kappa = \\Theta(\\lambda)</span> , and constant  <span class="math">\\eta &gt; 0</span> , such that HybridConsensus<sup> <span class="math">\\lambda,\\eta</span> </sup> over Fruitchain with parameters  <span class="math">(\\rho,\\kappa)</span> , is secure w.r.t. any p.p.t.  <span class="math">(n,\\alpha,\\delta,\\tau)</span> -valid  <span class="math">(\\mathcal{A},\\mathcal{Z})</span>  for any suitable  <span class="math">\\tau</span>  such that  <span class="math">\\Gamma_{\\rho,\\eta}^{\\text{hcfruit}}(n,\\alpha,\\delta,\\tau) = 1^{-5}</span>  achieving</p>

    <p class="text-gray-300"><span class="math">$T_{warmup} := 1.5\\lambda(1 + \\frac{1}{\\eta})/(1 - 5\\eta)n\\rho, \\quad T_{confirm} := O(\\lambda\\delta)</span>$</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;5</sup>Formal definitions of admissible adversary will be presented in the formal sections to follow.</p>

    <p class="text-gray-300">Note that in the above theorem, the Tconfirm parameter is stated for the worst-case transaction confirmation time even when under attack. In the optimistic case, hybrid consensus achieves a transaction confirmation time of O(&delta;). Further, although the theorem is stated in terms of the network's actual delay &delta;, in practice we must predetermine an upper bound estimate (denoted &#8710;) of &delta; to parametrize the puzzle difficulty level &rho;. As long as &#8710; is indeed an upper bound on &delta;, security is guaranteed by the above theorem, and the scheme achieves responsiveness, i.e., the transaction confirmation time does not depend on the upper bound &#8710;, but the actual network delay &delta;. As mentioned earlier, if we choose a looser estimate &#8710; (i.e., a greater value of &#8710;), the scheme will then be parametrized with a more difficult puzzle &mdash; on one hand this allows us to tolerate potentially a higher fraction of corrupt nodes; on the other hand, the agility parameter &tau; as well as the protocol's warmup time will increase accordingly.</p>

    <p class="text-gray-300">Remark 1 (A note on responsiveness). It may seem counter-intuitive that since our scheme is responsive, why do we still need a-priori knowledge of &#8710;, an upper bound of the network's delay? In particular, can we simply choose the parameter &#8710; to be infinity? Upon closer examination, our agility parameter &tau; and the protocol's warmup time Twarmup will both depend on &#8710;. If we choose a bigger &#8710;, the underlying snailchain would adopt a more difficult puzzle and hence tolerate a higher fraction of corrupt nodes; but on the other hand, we are trading off agility and the protocol's warmup time.</p>

      <h3 id="sec-2.3" class="text-xl font-semibold mt-8">2.3 Additional Related Work</h3>

    <p class="text-gray-300">We now review additional related work. Comparsion with most closely related work, including Decker et al. <a href="#page-52-6">[23]</a> and Byzcoin <a href="#page-53-7">[37]</a> were described earlier.</p>

    <p class="text-gray-300">Scaling decentralized consensus. The scalability of Bitcoin and decentralized, permissionless cryptocurrencies is a highly visible issue, and has resulted in heated, and at times acrimonious debates in the community <a href="#page-52-2">[22,</a><a href="#page-53-8">53]</a>. The cryptocurrency community have proposed various incremental patches to alleviate the scalability pressure in the near term, including adjusting the block size and others <a href="#page-51-3">[8,</a> <a href="#page-52-8">26,</a> <a href="#page-52-9">31,</a> <a href="#page-52-10">32,</a> <a href="#page-53-9">54]</a>.</p>

    <p class="text-gray-300">Eyal et al. propose BitcoinNG <a href="#page-52-5">[27]</a>, where a slow snailchain protocol is used to elect a single leader every epoch, and the leader is in charge of incorporating and linearizing transactions during its appointment. In essence, BitcoinNG can be viewed as pipelining block transmission by breaking it up and spreading block transmission over time &mdash; effectively reducing upper-bound on the worstcase delay &#8710; in Nakamoto consensus. BitcoinNG still requires nodes to wait for &Theta;(&lambda;) blocks in the underlying snailchain (referred to as key blocks in BitcoinNG) to stabilize for transactions to be confirmed where &lambda; is the security parameter. In comparison, hybrid consensus is responsive, and the transaction confirmation time in the optimistic case is only O(&delta;) where &delta; is the network's actual delay, not the a priori known upper bound &#8710;. BitcoinNG did not give a formal treatment of their protocol, but it is conceivable that their protocol can be proven to realize a permissionless consensus abstraction.</p>

    <p class="text-gray-300">Side-chain <a href="#page-51-4">[9]</a> is another notable effort at addressing Bitcoin's scalability painpoint. Side-chain's idea is to support consensus protocols off the main Bitcoin blockchain, and the currency in the side chain is pegged to Bitcoin. The side-chain protocol lacks formal guarantees, and the protocol description and implementation remain somewhat incomplete.</p>

    <p class="text-gray-300">Various other approaches <a href="#page-51-5">[11,</a> <a href="#page-53-10">38,</a> <a href="#page-53-11">49&ndash;</a><a href="#page-53-12">52]</a> have been proposed recently to attain consensus in different variants of &quot;decentralized&quot; settings with varying trust assumptions.</p>

    <p class="text-gray-300">Permissioned consensus. Consensus protocols in the permissioned model have been extensively investigated by the community in the past 30 years <a href="#page-51-6">[14,</a><a href="#page-51-0">15,</a><a href="#page-52-0">21,</a><a href="#page-52-1">25,</a><a href="#page-52-11">29,</a><a href="#page-53-13">35,</a><a href="#page-53-3">39&ndash;</a><a href="#page-53-14">41]</a>. These works typically consider three different models: 1) the synchronous model <a href="#page-52-12">[24]</a> where protocols proceed in rounds, and messages delivered in one round are guaranteed to arrive at the recipient at the beginning of the next round; 2) the partial synchrony model <a href="#page-52-1">[25]</a> where the network has a bounded delay parameter but the protocol does not know this delay; and 3) the asynchronous model <a href="#page-51-6">[14,</a><a href="#page-51-0">15]</a> where the network's delay may grow unbounded.</p>

    <p class="text-gray-300">Our network model is akin to the standard notion of partial synchrony <a href="#page-52-1">[25]</a> but not the same. Although we allow the protocol to know an a-priori upper bound on the network's delay, we aim to achieve responsiveness. We stress that any protocol that waits for the network delay and treats the delay as a synchronous round inherently cannot be responsive. If the protocol did wait for the network delay as a synchronous round, this would indeed translate to the synchronous model, however, our responsiveness requirement makes the design of protocols non-trivial in our network model.</p>

    <p class="text-gray-300">Earlier works on permissioned consensus have also considered group reconfiguration. For example, Vertical Paxos <a href="#page-53-4">[40]</a> and BFT-SMART <a href="#page-51-7">[12]</a> allow nodes to be reconfigured in a dynamic fashion. These works consider group reconfiguration for a related but somewhat different purpose. It would be interesting to investigate whether these techniques can be adapted to our setting to perform the switchover of committee members. We point out, however, that earlier group reconfiguration techniques do not prove security under the selective opening attack (in fact, most of these works do not adopt a cryptographically sound framework of reasoning). If we are to adapt these techniques, a new, cryptographically sound treatment is necessary.</p>

    <p class="text-gray-300">Distributed systems and cryptography. Consensus and distributed systems interact closely with cryptography such as multi-party computation (MPC). On one hand, multi-party computation (MPC) essentially relies on broadcast or distributed consensus primitives to achieve consistency and potentially livenss, often referred to as guaranteed output in the MPC context. On the other hand, distributed consensus protocols often make use of cryptography to ensure security. For example, the authenticated Byzantine model <a href="#page-52-12">[24]</a> makes use of digital signatures, and cryptographers refer to this setup assumption as the public-key infrastructure <a href="#page-51-8">[16,</a> <a href="#page-51-9">17,</a> <a href="#page-52-13">20]</a>.</p>

    <p class="text-gray-300">On the other hand, the non-authenticated Byzantine model <a href="#page-53-14">[41]</a> in distributed systems is actually referred to as the authenticated channels model by cryptographers <a href="#page-51-8">[16,</a> <a href="#page-51-9">17,</a> <a href="#page-52-13">20]</a>. When protocols employ computationally secure cryptographic primitives, implicitly we assume that the network's delay must be polynomially bounded in the security parameter (but can be an unbounded polynomial in the asynchrony case), since we cannot guarantee security for protocols that run exponentially long. When distributed consensus protocols make use of computationally secure primitives, a best practice is to rely on computational reductions to prove the security of the protocols &mdash; it has become well-understood that modeling cryptography as the most natural blackbox without careful scrutiny can be error-prone and flawed <a href="#page-51-10">[5&ndash;</a><a href="#page-51-11">7,</a> <a href="#page-51-12">10,</a> <a href="#page-51-13">13,</a> <a href="#page-52-14">18,</a> <a href="#page-52-15">33,</a> <a href="#page-52-16">34,</a> <a href="#page-53-15">43,</a> <a href="#page-53-16">44]</a>.</p>

    <p class="text-gray-300">Our paper demonstrates such an approach where we adopt the protocol composition frameworks <a href="#page-51-8">[16,</a> <a href="#page-51-9">17,</a> <a href="#page-52-13">20]</a> developed by the cryptographers to reason about distributed systems protocols &mdash; we show that doing so is necessary in particular through the handling of the selective opening attack. Such issues can easily be overlooked if we did not adopt a formal, cryptographically sound framework of reasoning.</p>

    <p class="text-gray-300">Strongly negligible functions. All security failures in this paper will be expressed as (exponentially) strongly negligible functions in terms of some security parameter &lambda; &isin; N. We say that a function negl(&middot;) is strongly negligible, if there exist some constants c<sup>0</sup> &gt; 0, c1, such that for all &lambda; &isin; N, negl(&lambda;) &le; exp(&minus;(c0&lambda;+c1)). In the remainder of the paper, we simply use the term negligible for simplicity, but all uses of it can be automatically replaced by strongly negligible.</p>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8">3.1 Formal Model</h3>

    <p class="text-gray-300">Execution model. We assume the following execution model:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Interactive Turing Machines. We assume a standard Interactive Turing Machine (ITM) model <a href="#page-51-8">[16,</a> <a href="#page-51-9">17,</a> <a href="#page-52-13">20]</a> often adopted in the cryptography literature (but augmented with proof-of-work as explained later). There is an underlying, global clock that increments over time; each clock tick is referred to as an atomic time step.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Nodes can perform unbounded polynomial amount of computation in each atomic time step, as well as send and receive polynomially many messages. Although not explicitly noted in the paper, nodes receive inputs from an environment Z and send their outputs to an environment.</li>
    </ul></li>
      <li>Proof-of-work. We assume that there is a random oracle denoted by a pair (H, H.ver). In each atomic time step, each node can make at most one H oracle query, but an unbounded (polynomial) number of H.ver queries. If there are multiple instances of the blockchain protocol, we assume that each protocol instance has its own independent random oracle. The environment cannot directly query the random oracle, but can query the random oracle through the help of the adversary.</li>
      <li>Corruption. At any point of time, the environment Z can communicate with corrupt nodes in arbitrary manners. This also implies that the environment can see the internal state of corrupt nodes. Corrupt nodes can deviate from the prescribed protocol arbitrarily, i.e., exhibit byzantine faults. All corrupt nodes are controlled by a probabilistic polynomial-time adversary denoted A, and the adversary can see the internal states of corrupt nodes.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For honest nodes, the environment cannot observe their internal state, but can observe any information honest nodes output to the environment by the protocol definition. Details on corruption models will be described later.</li>
    </ul></li>
      <li>Network delivery. The adversary is responsible for delivering messages between nodes. We assume that the adversary is capable of delaying or reordering messages, possibly subject to certain restrictions as described below.</li>
      <li>&tau; -agile corruption. In standard adaptive corruption models, whenever the environment wishes to corrupt a node, the corruption takes place instantly. Our protocol is proven secure under a slightly relaxed adaptive corruption model which we refer to as &tau; -agile corruption. Roughly speaking, &tau; -agile corruption says that it takes a short while for the environment to actually corrupt a node. More formally, the environment is allowed to corrupt and spawn new nodes according to the following procedures:</li>
      <li>Delayed corruption. We assume that the environment can adaptively corrupt a node but with the following restrictions. To corrupt a node i, the environment must issue a &quot;target corrupt&quot;</li>
    </ul>

    <p class="text-gray-300">instruction to node i at some point of time denoted t. Node i does not become corrupt immediately, but rather remains honest till t+&tau; , and becomes corrupt at time t+&tau; &mdash; at this point, the the corrupt node i communicates arbitrarily with the environment and can deviate arbitrarily from the protocol.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Killing a corrupt node. Once a node actually becomes corrupt, the environment can issue a &quot;kill&quot; instruction to kill the node. A killed node is no longer live. The environment cannot kill honest nodes directly without corrupting them first.</li>
      <li>Spawning new nodes. The environment is also allowed to spawn fresh nodes, either honest or corrupt ones. A node spawned at time tspawn is considered live at time tspawn. Spawning a corrupt node is equivalent to increasing the hashpower of the adversary which takes place instantly. If an honest node is spawned, the environment must follow the delayed corruption procedure if it wishes to corrupt this node later. An honest, newly spawned node starts running the main protocol.</li>
    </ul>

    <p class="text-gray-300">We say that a node (that has been spawned and has not been killed) can be in three mutually exclusive states:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Intact: An honest node that has not received a &quot;target corrupt&quot; instruction.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Pre-corrupt: An honest node that has received a &quot;target corrupt&quot; instruction, but has not become corrupt yet.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Corrupt: A node that is either spawned to be corrupt, or spawned to be honest, but then received a &quot;target corrupt&quot; instruction and actually became corrupt.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Both intact nodes and pre-corrupt nodes are considered honest.</p>

    <p class="text-gray-300">Henceforth, whenever we say that &quot;an honest node i performs certain actions at time t&quot;, we mean that the node i is honest at time t. For example, if we say that an honest node outputs a message to the environment Z at time t, we implicitly mean that the node is honest at time t (but may become corrupt later). Alternatively, if we say that an honest node performs an action, it means that the node is honest at the time it performs the action, although it may become corrupt sometime in the future.</p>

    <p class="text-gray-300">Fully adaptive corruption and static corruption. We note that 0-agile corruption is equivalent to the fully adaptive corrupt model where the environment Z can corrupt nodes instantly. Under a fully adaptive corruption model, a node is intact iff it is honest.</p>

    <p class="text-gray-300">We also define static corruption in the permissionless model &mdash; static corruption is a weaker corruption model and is only used for the purpose of proving our lower bounds &mdash; note that assuming a weaker corruption model yields stronger lower bounds. We assume that in the static corruption model, environment can spawn honest or corrupt nodes at any time. However, once an honest node is spawned, the environment is unable to corrupt it later on.</p>

    <p class="text-gray-300">Gossip network model. We assume that all messages sent by honest nodes are spread over a gossip network and can eventually be heard by all other honest nodes. For nodes that join at time T, it will receive all messages sent by honest nodes after time T. An honest node need not know the identities of other nodes in the network to gossip a message to all other nodes.</p>

    <p class="text-gray-300">The adversary cannot drop or modify messages by honest nodes, but is allowed to reorder or delay messages subject to certain restrictions. The adversary may selectively deliver a message to a subset but not all of the honest nodes.</p>

    <p class="text-gray-300">We assume that the identity of a message's sender is unknown. Messages can be signed, but an honest node does not know the correspondence between public keys and physical identities of nodes.</p>

    <p class="text-gray-300">We define the following types of gossip networks which impose different restrictions on the adversary's ability to delay and reorder messages:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Synchronous model. In the synchronous model, messages gossiped by an honest node at time t are guaranteed to arrive at all honest nodes, possibly out of order, in time step t + 1. Moreover, historical messages are delivered to newly spawned nodes instantly.</li>
      <li>&delta;-partially synchronous model. In a &delta;-partially synchronous model, messages gossiped by an honest node at time t are guaranteed to arrive at all honest nodes, possibly out of order, by time t + &delta;. Moreover, historical messages are delivered to newly spawned nodes instantly.</li>
    </ul>

    <p class="text-gray-300">More formally, suppose an honest node gossips a message in time step t &le; t &lowast; , then if a node i is honest in time step t <sup>&lowast;</sup> + &delta;, then it must have received the message.</p>

    <p class="text-gray-300">Note that in practice, honest nodes can implement a historical transcript retrieval service this way, a node can obtain a copy of the entire historical transcript when spawning a consensus instance. It is not hard to see that if any honest node remains honest and live for at least 3&delta; time, no historical transcript will be lost.</p>

    <p class="text-gray-300">As mentioned later in Section <a href="#page-18-0">3.2,</a> we allow our protocol to know a possibly loose upper bound &#8710; on the network's delay, since the underlying snailchain must know such an upper bound for parametrizing the mining difficulty. However, we require that the protocol be responsive, i.e., its actual performance must depend only on the network's actual &delta; value, not the loose upper bound &#8710;.</p>

    <p class="text-gray-300">Randomized protocol execution and probability space. Let &Pi; be some protocol, let A, Z be probabilistic polynomial-time (or p.p.t. for short) algorithms, and let &lambda; &isin; N. Let exec[&Pi;](A, Z, &lambda;) be a random variable denoting the joint view of all nodes (i.e., all their inputs, random coins, and messages received, including those from random oracles) in the above execution.</p>

    <p class="text-gray-300">Let property be a function that takes as input a fixed view and outputs either 0 or 1. Throughout the paper, whenever we say that some property holds for exec[&Pi;](A, Z, &lambda;) with probability p, we formally mean that</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathsf{view} \\overset{\\</span>}{\\leftarrow} \\mathtt{EXEC}[\\Pi](\\mathcal{A}, \\mathcal{Z}, \\lambda) : \\mathsf{property}(\\mathsf{view}) = 1\\right] = \\mathsf{p}$$</p>

    <p class="text-gray-300">where probability is taken over all random coins of A, Z, all honest nodes, and all random oracles.</p>

    <p class="text-gray-300">Compliant execution. We often impose constraints on the adversary A and Z to prove security properties of protocols. We therefore define what we consider as compliant executions, in terms of constraints on the pair (A, Z).</p>

    <p class="text-gray-300">Definition 1 ((n, &delta;, &tau; )-valid (A, Z)). We say that the pair (A, Z) is (n, &delta;, &tau; )-valid w.r.t. protocol &Pi; if A and Z are probabilistic polynomial-time algorithms such that for every &lambda; &isin; N, the following properties hold with probability 1 for exec[&Pi;](A, Z, &lambda;):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>At any point of time, the number of live nodes<a href="#page-18-1">6</a> is n;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A delays messages from honest nodes in at most &delta; time steps;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Once an honest node receives input &quot;target corrupt&quot; from the environment, it takes at least &tau; time before the node becomes corrupt.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Definition 2 ((n, &alpha;, &delta;, &tau; )-valid (A, Z)). We say that the pair (A, Z) is (n, &alpha;, &delta;, &tau; )-valid w.r.t. protocol &Pi;, such that (A, Z) is (n, &delta;, &tau; )-valid as per Definition <a href="#page-17-0">1,</a> and moreover, for any &lambda; &isin; N, in any view in support of exec[&Pi;](A, Z, &lambda;), it holds that at any time, no more than &alpha; fraction of the live nodes are either in corrupt or pre-corrupt states.</p>

    <p class="text-gray-300">Throughout the paper, although not noted explicitly, all parameters including n, &alpha;, &delta;, and &tau; are functions in the security parameter &lambda;. Further, for notational simplicity, in this paper we do not explicitly define validity rules for transaction inputs. However, it is not difficult to extend our definitions to incorporate transaction validity rules like Garay et al. <a href="#page-52-3">[30]</a> and Pass et al. <a href="#page-53-2">[47]</a>.</p>

    <p class="text-gray-300">Our protocols may be secure under choices of parameters including n, &alpha;, &delta;, and &tau; that satisfy specific constraints. We therefore define the notion of &Gamma;-admissibility where &Gamma; is a function that imposes constraints on parameter choices.</p>

    <p class="text-gray-300">Definition 3 (&Gamma;-admissible). Let &Gamma; be a binary function in parameters n, &alpha;, &delta;, &tau; . We say that a p.p.t. pair (A, Z) is &Gamma;-admissible w.r.t. some protocol &Pi; iff there exists n, &delta; &gt; 0 and &alpha;, &tau; &ge; 0 such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>&Gamma;(n, &alpha;, &delta;, &tau; ) = 1;</li>
      <li>(A, Z) is (n, &alpha;, &delta;, &tau; )-valid w.r.t. &Pi; by Definition <a href="#page-18-2">2;</a></li>
    </ul>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8">3.2 Problem Definition: Permissionless Consensus</h3>

    <p class="text-gray-300">Our HybridConsensus protocol realizes a state machine replication abstraction in the permissionless model &mdash; henceforth we refer to this abstraction as permissionless consensus<a href="#page-18-3">7</a> . In a permissionless consensus protocol, nodes maintain a LOG over time that is a list of transactions; and further, consistency and liveness are guaranteed. Our permissionless consensus abstraction is a variant of the &quot;public ledger&quot; abstraction adopted by Garay et al. <a href="#page-52-3">[30]</a> and Pass et al. <a href="#page-53-2">[47]</a>. The differences are nonessential. In particular, we essentially incorporate the transaction mempool into our abstraction, such that maintaining the transaction mempool is not left to the caller. By contrast, the public ledger abstraction by Garay et al. <a href="#page-52-3">[30]</a> and Pass et al. <a href="#page-53-2">[47]</a> leaves it to the caller to maintain a transaction mempool.</p>

    <p class="text-gray-300">More formally, a permissionless consensus satisfies the following abstractions.</p>

    <p class="text-gray-300">Inputs and outputs. The environment Z may input a set of transactions TXs to each honest node in every time step. In each time step, an honest node outputs to the environment Z a totally ordered LOG of transactions (possibly empty).</p>

    <p class="text-gray-300"><sup>6</sup> In principle, it is not difficult to relax this requirement and allow the number of nodes to vary up to a constant factor, but the chain growth parameter of the underlying snailchain needs to be adjusted accordingly.</p>

    <p class="text-gray-300"><sup>7</sup>The term consensus is also used in the classical distributed systems literature to mean single-shot agreement protocols. In this paper, consensus means state machine replication, where nodes would like to agree on a linearly ordered log that grows over time.</p>

    <p class="text-gray-300">Security definitions. Let p.p.t. algorithms (A, Z) be (n, &alpha;, &delta;, &tau; )-valid w.r.t. a permissionless consensus protocol &Pi;. Let Twarmup, Tconfirm, Tbootstrap be polynomial functions in &lambda;, n, &alpha;, &delta;, and &#8710;. We say that a permissionless consensus protocol &Pi; is secure w.r.t. (A, Z) with parameters (Twarmup, Tconfirm, Tbootstrap), if there exists a negligible function negl such that for every &lambda; &isin; N, with 1 &minus; negl(&lambda;) probability, the following properties hold for exec[&Pi;](A, Z, &lambda;):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Consistency: Consistency includes the following properties:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Common prefix. Suppose that an honest node i outputs LOG to Z at time t, and an honest node j (same or different) outputs LOG<sup>0</sup> to Z at time t 0 , it holds that either LOG &#8826; LOG<sup>0</sup> or LOG<sup>0</sup> &#8826; LOG. Here the relation &#8826; means &quot;is a prefix of&quot;. By convention we assume that &empty; &#8826; x and x &#8826; x for any x.</li>
      <li>Self-consistency. Suppose that a node i is honest at time t and t <sup>0</sup> &ge; t, and outputs LOG and LOG<sup>0</sup> at times t and t 0 respectively, it holds that LOG &#8826; LOG<sup>0</sup> .</li>
    </ul></li>
      <li>Liveness: Suppose that the environment Z inputs TXs to an honest node at time t &ge; Twarmup. Suppose that some node i spawned at time tspawn and remains honest till t <sup>0</sup> &ge; max(tspawn + Tbootstrap, t + Tconfirm). Let LOG be the output of node i at time t 0 , it holds that any tx &isin; TXs is included in LOG.</li>
    </ul>

    <p class="text-gray-300">Intuitively, liveness says that transactions input to an honest node gets included in their LOGs within Tconfirm time. Further, Twarmup is referred to as the protocol's warmup time.</p>

    <p class="text-gray-300">Note that the above definitions are with respect to a specific (A, Z) pair. However, our main theorem later will state the security of the HybridConsensus protocol for any p.p.t. (A, Z) as long as they respect certain constraints.</p>

    <p class="text-gray-300">Remark 2. For our hybrid consensus protocol, Tbootstrap = 0, i.e., newly spawned nodes are bootstrapped instantly. Therefore we often omit writing the term Tbootstrap = 0 without risk of ambiguity. However, our problem definition admits a polynomial Tbootstrap since this will allow us to prove a stronger lower bound.</p>

    <p class="text-gray-300">Responsiveness. We say that a permissionless consensus protocol is responsive if the liveness parameter Tconfirm depends only on the network's actual &delta;, not on the loose upper bound &#8710; that is used to parametrize the protocol.</p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 Underlying Blockchain Protocol snailchain</h3>

    <p class="text-gray-300">Our main scheme is of an efficiency bootstrapping nature, where we bootstrap from an underlying, slow blockchain denoted snailchain to obtain a permissionless consensus protocol with fast transaction confirmation and high throughput.</p>

    <p class="text-gray-300">We assume the underlying slow consensus protocol denoted snailchain (e.g., Bitcoin's Nakamoto consensus <a href="#page-53-0">[46]</a>) realizes a &quot;blockchain&quot; abstraction, which can be considered as a special-case permissionless consensus protocol as defined in Section <a href="#page-18-0">3.2.</a></p>

    <p class="text-gray-300">Abstraction. We assume that the snailchain protocol provides the following input/output abstraction.</p>

    <p class="text-gray-300">Inputs. In each time step, the environment Z inputs to each honest node (recs, pk) where recs denotes a set of records and pk denotes a public key.</p>

    <p class="text-gray-300">Outputs. In each time step, honest nodes output to the environment the following:</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{chain} := \\{(\\mathsf{recs}_i, \\mathsf{pk}_i)\\}_i</span>$</p>

    <p class="text-gray-300">Useful notions. We define the following notions that will be useful later.</p>

    <p class="text-gray-300">Local chain. In each time step, an honest node outputs to the environment some chain, for simplicity we refer to this chain as the honest node's local chain in this time step.</p>

    <p class="text-gray-300">Intact and honest blocks. Given chain which denotes an honest node's local chain at some time t, we can define whether each block in chain is intact (or honest resp.) with respect to a prefix of chain. A block chain[j] := (recs, pk) is said to be intact (or honest resp.) w.r.t. a prefix chain[: j 0 ] where j <sup>0</sup> &lt; j if there exists some node i intact (or honest resp.) at some time t <sup>0</sup> &le; t, such that 1) node i output chain<sup>0</sup> to Z at time t 0 such that chain[: j 0 ] &#8826; chain<sup>0</sup> , and 2) Z input (recs, pk) to node i at time t <sup>0</sup> + 1. Informally, for an honest party's chain denoted chain, a block B := chain[j] is intact (or honest resp.) w.r.t. a prefix chain[: j 0 ] where j <sup>0</sup> &lt; j, if earlier there is some honest node who received the block B as input when its local chain contains the prefix chain[: j 0 ].</p>

    <p class="text-gray-300">Security definitions. Similar to earlier works <a href="#page-52-5">[27,</a> <a href="#page-52-3">30,</a> <a href="#page-53-17">36,</a> <a href="#page-53-2">47]</a>, we define the following properties for a snailchain protocol. In all of the following, the probability is defined over randomness consumed by all honest nodes, the environment Z, as well as the adversary A in the execution.</p>

    <p class="text-gray-300">Suppose that (A, Z) is (n, &alpha;, &delta;, &tau; )-valid w.r.t. snailchain. Let WC, WQ, W<sup>G</sup> be polynomial functions in &lambda;. Let Q, G, G<sup>0</sup> be polynomial functions in &lambda;, n, &alpha;, &delta;, and &#8710;. We say that a snailchain protocol satisfies WC-consistency, (WQ, Q)-chain quality, and (WG, G, G<sup>0</sup> )-chain growth w.r.t. to (A, Z), if there exists a negligible function negl such that for any &lambda; &isin; N, except with negl(&lambda;) failure probability, the following properties hold for exec[snailchain](A, Z, &lambda;):</p>

    <p class="text-gray-300">&bull; Consistency. For any node i that is honest at time t, and any j (same or different) that is honest at time t <sup>0</sup> &ge; t, let chain denote what node i outputs to Z at time t, and let chain<sup>0</sup> denote what node j outputs to Z at time t 0 , it holds that</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{chain}[:-W_C] \\prec \\mathsf{chain}&#x27;</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Chain quality. Let chain denote what an honest node outputs to Z at any time t. Then for any &lambda;<sup>1</sup> &ge; WQ(&lambda;), if |chain| &ge; &lambda;1, it holds that for any i &le; |chain| &minus; &lambda;1, at least dQ&lambda;1e number of blocks in chain[i : i + &lambda;1] are intact w.r.t. chain[: i &minus; 1]. In other words, at any time, among any &lambda;<sup>1</sup> &ge; WQ(&lambda;) consecutive window of blocks in an honest node's output chain, at least Q fraction of the blocks are intact w.r.t. the prefix of the window.</li>
      <li>Chain growth. In every time step, the following properties hold:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Consistent length. Suppose that an honest node outputs chain at time t. It holds that any honest node must output a chain of length at least |chain| at any t <sup>0</sup> &ge; t + &delta;.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Chain growth. Suppose that an honest node i outputs chain at time t, an honest node j (same or different) outputs chain<sup>0</sup> at time t <sup>0</sup> &ge; t, suppose that G &middot; (t <sup>0</sup> &minus; t) &ge; WG(&lambda;), it holds that G &middot; (t <sup>0</sup> &minus; t) &le; |chain<sup>0</sup> | &minus; |chain| &le; G<sup>0</sup> &middot; (t <sup>0</sup> &minus; t).</li>
    </ol></li>
    </ul></li>
    </ul>

    <p class="text-gray-300">Therefore, intuitively, chain growth says that 1) honest nodes have roughly the same chain length, and 2) honest nodes' chains cannot grow too slowly.</p>

    <p class="text-gray-300">For convenience, we now define a derived property called <em>liveness</em>. If i is an honest node at t, let  <span class="math">(\\mathsf{recs}_i^t, \\_)</span>  denote what the environment  <span class="math">\\mathcal Z</span>  inputs to honest node i at time t. Let  <span class="math">\\mathsf{rec}</span>  be some record. We say that  <span class="math">\\mathcal Z</span>  proposes  <span class="math">\\mathsf{rec}</span>  to node i at time t if  <span class="math">\\mathsf{rec} \\in \\mathsf{recs}_i^t</span> .</p>

    <p class="text-gray-300">We say that a snailchain protocol satisfies liveness w.r.t.  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  with liveness parameter  <span class="math">T_{\\text{snail}}</span> , if there exists a negligible function negl such that for any  <span class="math">\\lambda \\in \\mathbb{N}</span> , with  <span class="math">1 - \\text{negl}(\\lambda)</span>  probability, the following holds for EXEC[snailchain] <span class="math">(\\mathcal{A}, \\mathcal{Z}, \\lambda)</span> :</p>

    <p class="text-gray-300">&bull; Liveness. Let rec be some record. If for every honest node i, for each t' = t, t + 1, ... the environment  <span class="math">\\mathcal{Z}</span>  proposes rec unless rec is already contained in node i's output<sup>8</sup> chain[:  <span class="math">-\\lambda</span> ], then we have that at time any  <span class="math">t_1 \\geq t + T_{\\text{snail}}</span> , if an honest node outputs chain', then rec must be included in chain'[:  <span class="math">-\\lambda</span> ].</p>

    <p class="text-gray-300">Intuitively, liveness simply says that if the environment  <span class="math">\\mathcal{Z}</span>  continues to input the same record rec to all honest nodes for  <span class="math">T_{\\text{snail}}</span>  amount of time, then rec will get included in all honest nodes' local chain in at most  <span class="math">T_{\\text{snail}}</span>  time.</p>

    <p class="text-gray-300"><strong>Lemma 1</strong> (Liveness as a derived property). For any p.p.t. algorithms  <span class="math">\\mathcal{A}, \\mathcal{Z}</span> , any  <span class="math">Q &gt; 0, G&#x27; \\geq G &gt; 0</span> , any  <span class="math">W_C, W_Q, W_G</span>  such that  <span class="math">W_C(\\lambda) + W_Q(\\lambda) + \\lambda \\geq W_G(\\lambda)</span>  for all  <span class="math">\\lambda</span> , if snailchain satisfies  <span class="math">W_C</span> -consistency,  <span class="math">(W_Q, Q)</span> -chain quality and  <span class="math">(W_G, G, G&#x27;)</span> -chain growth w.r.t.  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> , then snailchain satisfies liveness w.r.t.  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  with liveness parameter  <span class="math">T_{snail} = (W_C + W_Q + \\lambda)/G</span> .</p>

    <p class="text-gray-300">Note that for convenience of application later, we define a slightly modified version of liveness in comparison with Garay et al. [30], Pass et al. [47], and Fruitchain [48]. It is straightforward to see that our liveness notion is implied by those adopted in Pass et al. [47] and Fruitchain [48].</p>

    <p class="text-gray-300">Underlying snailchain is an non-responsive permissionless consensus. It is not hard to see that that our underlying snailchain abstraction defined in Section 4.1 can be regarded as a special-case instantiation of a &quot;permissionless consensus&quot; protocol. In particular, each node's LOG can be the ordered list of records in chain[:  <span class="math">-\\lambda</span> ]. Such a permissionless consensus protocol is non-responsive since we need to set the expected block interval to be  <span class="math">\\Theta(\\Delta)</span>  under typical parameters, where  <span class="math">\\Delta</span>  is an a priori upper bound on the network's delay. Therefore  <span class="math">T_{\\text{confirm}} := \\Theta(\\lambda \\Delta)</span> .</p>

      <h4 id="sec-4.1.1" class="text-lg font-semibold mt-6">4.1.1 Nakamoto as the underlying snailchain</h4>

    <p class="text-gray-300">Garay et al. [30] prove that Nakamoto consensus [46] satisfies variants of the above properties assuming a fully synchronous model, i.e., messages are delivered instantly and cannot be delayed by the adversary. Pass et al. [47] strengthen these properties and prove that Nakamoto consensus satisfies them in a  <span class="math">\\delta</span> -partially synchronous network under appropriate conditions on  <span class="math">\\delta</span> .</p>

    <p class="text-gray-300">Below we restate the main theorem of Pass et al. [47] for the underlying snailchain. Let  <span class="math">\\alpha</span>  and  <span class="math">\\beta</span>  denote the fraction of corrupt and honest nodes respectively where  <span class="math">\\alpha + \\beta = 1</span> , and let  <span class="math">\\rho</span>  denote the probability that a single node mines a valid block in one time step.  <span class="math">\\rho</span>  is closely related to the mining difficulty parameter.</p>

    <p class="text-gray-300">&bull; Let  <span class="math">p := 1 - (1 - \\rho)^{\\beta n}</span>  denote the probability that some honest node succeeds in mining a block in a single time step.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;8</sup>In practice, we can perform the following optimization within the Nakamoto protocol: the honest algorithm can suppress a record rec if it is already contained in the longest chain that it tries to extend.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let  <span class="math">q := \\alpha n \\rho</span>  denote an upper bound on the expected number of blocks that the adversary can mine in a single time step.</li>
      <li>Let  <span class="math">\\gamma := \\frac{p}{1+\\delta p}</span>  which can be thought of as a version of p discounted by the network's delay  <span class="math">\\delta</span> .</li>
    </ul>

    <p class="text-gray-300"><strong>Definition 4</strong> (Admissible parameters for snailchain  <span class="math">\\Gamma_{\\rho}^{\\text{snail}}</span> ). We define  <span class="math">\\Gamma_{\\rho}^{\\text{snail}}(n, \\alpha, \\delta, \\tau) = 1</span>  iff the following holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">n &gt; 0, \\, \\delta &gt; 0, \\, \\tau \\geq 0</span>  are all polynomial functions in  <span class="math">\\lambda; \\, \\alpha &gt; 0</span>  is a constant;</li>
      <li>There exists a constant  <span class="math">\\eta &gt; 0</span>  such that  <span class="math">p(1 (2\\delta + 2)p) \\ge (1 + \\eta)q</span> .</li>
    </ul>

    <p class="text-gray-300"><strong>Theorem 4</strong> (Nakamoto as the underlying snailchain [47]). For any constants  <span class="math">\\eta_0, \\eta_1, \\eta_2, \\eta, \\rho &gt; 0</span> , let  <span class="math">Q = 1 - (1 + \\eta_0) \\frac{q}{\\gamma}</span> , let  <span class="math">G = \\gamma/(1 + \\eta_1)</span> , let  <span class="math">G&#x27; = (1 + \\eta_2) n \\rho</span> , the Nakamoto consensus protocol [46,47] (henceforth referred to as snailchain) parametrized with mining difficulty parameter  <span class="math">\\rho</span>  satisfies  <span class="math">\\eta \\lambda</span> -consistency,  <span class="math">(\\eta \\lambda, Q)</span> -chain quality, and  <span class="math">(\\eta \\lambda, G, G&#x27;)</span> -chain growth w.r.t. to any p.p.t.  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  that is  <span class="math">\\Gamma_0^{\\text{snail}}</span> -admissible w.r.t. snailchain.</p>

    <p class="text-gray-300"><strong>Typical parametrizations.</strong> Typically in practice, we would set the puzzle's difficulty parameter  <span class="math">\\rho := \\Theta(\\frac{1}{\\Delta n})</span>  where  <span class="math">\\Delta</span>  be an a-priori known upper bound of the network's delay  <span class="math">\\delta</span> . Under such typical parametrizations, we would need roughly 3/4 overall honest to ensure roughly 2/3-chain quality.</p>

    <p class="text-gray-300">Corollary 1 (Nakamoto as the underlying snailchain [47]). For any (arbitrarily small) constant  <span class="math">\\epsilon &gt; 0</span> , let  <span class="math">\\alpha = \\frac{1}{4} - \\epsilon</span> , then for every  <span class="math">n, \\delta</span> , there exists sufficiently small  <span class="math">\\rho_0 := \\Theta(\\frac{1}{\\delta n})</span>  such that for any constant  <span class="math">\\eta &gt; 0</span> ,  <span class="math">\\eta&#x27; &gt; 0</span> , Nakamoto's protocol with mining difficulty parameter  <span class="math">\\rho &lt; \\rho_0</span>  satisfies  <span class="math">\\eta&#x27; \\lambda</span> -consistency,  <span class="math">(\\eta&#x27; \\lambda, Q)</span> -chain quality and  <span class="math">(\\eta&#x27; \\lambda, G, G&#x27;)</span> -chain growth w.r.t. any  <span class="math">\\Gamma_{\\rho}^{\\text{snail}}</span> -admissible  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  where</p>

    <p class="text-gray-300"><span class="math">$Q &gt; \\frac{2}{3}, \\quad G = \\frac{3}{4}n\\rho, \\quad G&#x27; = (1+\\eta)n\\rho</span>$</p>

    <p class="text-gray-300">Or more simply (and informally) put, for every  <span class="math">\\alpha = \\frac{1}{4} - \\epsilon</span>  for an arbitrarily small constant  <span class="math">\\epsilon &gt; 0</span> , there exists an appropriately parametrized Nakamoto consensus protocol that achieves  <span class="math">Q &gt; \\frac{2}{3}</span>  chain quality.</p>

      <h4 id="sec-4.1.2" class="text-lg font-semibold mt-6">4.1.2 Fruitchain as the underlying snailchain</h4>

    <p class="text-gray-300">The problem with using Nakamoto as the underlying snailchain is chain quality loss. Due to a selfish mining attack, Nakamoto requires  <span class="math">3/4 + \\epsilon</span>  overall honest to attain 2/3-chain quality which is needed for the elected committees to be 2/3 honest. Since hybrid consensus takes a modular approach, we can instead use a drop-in replacement, the Fruitchain [48] protocol, which realizes (almost) the same formal abstraction as Nakamoto.</p>

    <p class="text-gray-300">At a high level, the Fruitchain protocol runs a Nakamoto consensus underneath; however, miners mine fruits simultaneously as they search for blocks. Fruits contain the transactions, and blocks in the underlying Nakamoto blockchain contain the fruits (but not the transactions). In the Fruitchain protocol, a fruit is regarded as the new block and viewed as part of the blockchain abstraction, but the underlying Nakamoto can be regarded as simply an internal detail of the protocol and need not be exposed to the outside. We will assume that the Fruitchain protocol takes in the following parameters as inputs (see the Fruitchain paper for details [48]):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Mining difficulty parameters  <span class="math">\\rho</span>  and  <span class="math">\\rho_f</span> , for mining the block and fruit respectively. Henceforth we shall assume that  <span class="math">\\rho_f := \\rho</span>  is hardcoded (although  <span class="math">\\rho_f := c\\rho</span>  for any constant  <span class="math">c \\ge 1</span>  should also work), and therefore we do not mention  <span class="math">\\rho_f</span>  explicitly any more.</li>
      <li>The look-back parameter  <span class="math">\\kappa</span> , i.e., how far back in the blockchain to hang a fruit from;</li>
      <li>The recency parameter R, that is, a fruit is considered fresh if it is hanging from a  <span class="math">(R \\cdot \\kappa)</span> -recent block in the underlying blockchain. Henceforth we will simply assume that R := 17 is hardcoded (although any other constant great than 1 should also work), and therefore we do not explicitly mention the recency parameter any more henceforth<sup>9</sup>.</li>
    </ul>

    <p class="text-gray-300"><strong>Theorem 5</strong> (Fruitchain as the underlying snailchain [48]). For any  <span class="math">0 &lt; \\eta &lt; 1</span> ,  <span class="math">\\rho &gt; 0</span> , let  <span class="math">G = (1-5\\eta)(1-\\alpha)n\\rho</span> ,  <span class="math">G&#x27; = (1+5\\eta)n\\rho</span> , and  <span class="math">Q = (1-5\\eta)(1-\\alpha)</span> , the Fruitchain protocol [48] parametrized with  <span class="math">(\\rho, \\kappa = \\frac{\\lambda}{34})</span>  satisfies  <span class="math">\\lambda</span> -consistency,  <span class="math">(\\lambda/\\eta, Q)</span> -fruit quality,  <span class="math">(\\lambda/\\eta, G, G&#x27;)</span> -fruit growth w.r.t. any p.p.t.  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  that is  <span class="math">\\Gamma_{\\rho}^{\\text{snail}}</span> -admissible w.r.t. snailchain.</p>

    <p class="text-gray-300">Corollary 2 (Fruitchain as the underlying snailchain [48]). For any (arbitrarily small) constant  <span class="math">\\epsilon &gt; 0</span> , let  <span class="math">\\alpha = \\frac{1}{3} - \\epsilon</span> , there exists a suitable  <span class="math">\\kappa = \\Theta(\\lambda)</span>  and a constant  <span class="math">0 &lt; \\eta &lt; 1</span>  (related to  <span class="math">\\epsilon</span> ); moreover for every  <span class="math">n, \\delta &gt; 0</span> , there exists a sufficiently small  <span class="math">\\rho := \\Theta(\\frac{1}{\\delta n})</span> , such that Fruitchain with parameters  <span class="math">(\\rho, \\kappa)</span>  satisfies  <span class="math">\\lambda</span> -consistency,  <span class="math">(\\frac{\\lambda}{\\eta}, Q)</span> -chain quality and  <span class="math">(\\frac{\\lambda}{\\eta}, G, G&#x27;)</span> -chain growth w.r.t. any  <span class="math">\\Gamma_{\\rho}^{\\text{snail}}</span> -admissible  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  where</p>

    <p class="text-gray-300"><span class="math">$Q &gt; \\frac{2}{3}, \\quad G = \\frac{2}{3}n\\rho, \\quad G&#x27; = (1+5\\eta)n\\rho</span>$</p>

    <p class="text-gray-300">Or more simply (and informally) put, for every  <span class="math">\\alpha = \\frac{1}{3} - \\epsilon</span>  where  <span class="math">\\epsilon &gt; 0</span>  is an arbitrarily small constant, there is an appropriately parametrized Fruitchain protocol that achieves  <span class="math">Q &gt; \\frac{2}{3}</span>  chain quality.</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">4.2 Strongly Secure Permissioned Byzantine Fault Tolerance</h3>

    <p class="text-gray-300">We will rely on a permissioned consensus protocol. It is well-known how to construct Byzantine Fault Tolerance (BFT) protocols in partially synchronous networks [21, 25, 42]; and furthermore, these protocols achieve responsiveness.</p>

    <p class="text-gray-300">Due to technical subtleties related to a selective opening attack, we need to define a stronger security notion for our BFT building block than the most natural property-based notion. We consider BFT protocols that make blackbox usage of a signing algorithm. Let  <span class="math">\\Sigma := (\\mathsf{Gen}, \\mathsf{Sign}, \\mathsf{Verify})</span>  denote a signature scheme. We use the notation  <span class="math">\\mathsf{BFT}^\\Sigma</span>  to mean that the protocol BFT is parametrized by the signature scheme  <span class="math">\\Sigma</span> . Moreover, we require that BFT only makes blackbox usage of  <span class="math">\\Sigma</span> .Gen and  <span class="math">\\Sigma</span> .Sign functionalities &mdash; and in our formulation below, BFT nodes query the environment  <span class="math">\\mathcal Z</span>  that will provide  <span class="math">\\Sigma</span> .Gen and  <span class="math">\\Sigma</span> .Sign oracles. Formally, we assume that a  <span class="math">\\mathsf{BFT}^\\Sigma</span>  protocol, parametrized by a signature scheme  <span class="math">\\Sigma := (\\mathsf{Gen}, \\mathsf{Sign}, \\mathsf{Verify})</span> , realizes the following abstractions.</p>

    <p class="text-gray-300"><strong>Inputs.</strong> The environment is allowed to send the following inputs to honest nodes. All other inputs are ignored.</p>

    <p class="text-gray-300">&bull; The environment  <span class="math">\\mathcal{Z}</span>  can send  <span class="math">start(pk_i, comm)</span>  once to an honest node i.</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^9&lt;/sup&gt;</span> We pick R=17 based on Theorem 3.1 in the Fruitchain paper [48]. However, note that a tighter bound can be proven for any constant R&gt;1. This could be done by using a tighter version of the fruit freshness lemma in Fruitchain [48].</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\bullet</span>  If a start command has been input, the environment  <span class="math">\\mathcal Z</span>  can in each time step input a set of transactions TXs to an honest node.</li>
      <li>Answers to sign(msg) queries.</li>
    </ul>

    <p class="text-gray-300"><strong>Outputs.</strong> Honest nodes output the following terms to  <span class="math">\\mathcal{Z}</span>  over time.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If a start command has been input, an honest node will in each time step, output to  <span class="math">\\mathcal{Z}</span>  a totally ordered log of transactions log.</li>
      <li>If a start command has been input, an honest node can output to  <span class="math">\\mathcal{Z}</span>  queries of the form sign(msg) where  <span class="math">msg \\in \\{0,1\\}^*</span>  denotes a message.</li>
    </ul>

    <p class="text-gray-300">Compliant executions. We consider execution of a BFT protocol in a partially synchronous network with somewhat static corruptions as elaborated below. The environment  <span class="math">\\mathcal{Z}</span>  and the adversary  <span class="math">\\mathcal{A}</span>  must also satisfy certain constraints. Let  <span class="math">T_{\\text{stamp}}</span>  be a polynomially-bounded function in  <span class="math">\\lambda, n, Q</span> , and  <span class="math">\\delta</span> . A pair of probabilistic polynomial-time algorithms  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  is said to be  <span class="math">(n, Q, \\delta, \\tau, T_{\\text{stamp}})</span> -valid w.r.t. BFT iff the following hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  is  <span class="math">(n, \\delta, \\tau)</span> -valid w.r.t. BFT as per Definition 1.</li>
      <li>Somewhat static corruption. All &quot;spawn&quot; and &quot;target corrupt&quot; instructions must be declared before  <span class="math">T_{\\text{start}}</span> , where  <span class="math">T_{\\text{start}}</span>  denotes the time when a start command is first input to an honest node by  <span class="math">\\mathcal{Z}</span> .</li>
      <li>Committee agreement. If honest node i receives input  <span class="math">\\mathtt{start}(\\mathsf{pk}_i, \\mathsf{comm})</span>  from  <span class="math">\\mathcal Z</span>  at time t, and honest node j receives input  <span class="math">\\mathtt{start}(\\mathsf{pk}_j, \\mathsf{comm}&#x27;)</span>  at time t', it holds that  <span class="math">\\mathsf{comm} = \\mathsf{comm}&#x27;</span> . Further, if  <span class="math">i \\neq j</span> , then  <span class="math">\\mathsf{pk}_i \\neq \\mathsf{pk}_j</span> .</li>
      <li>Close start. Let  <span class="math">T_{\\text{start}}</span>  be the earliest time an honest node receives input  <span class="math">\\text{start}(\\_,\\_)</span> . Then, for any node i honest at time  <span class="math">T_{\\text{start}} + \\delta</span> , i must receive input  <span class="math">\\text{start}(\\_,\\_)</span>  by time  <span class="math">T_{\\text{start}} + \\delta</span> . Each node receives start at most once when it is honest.</li>
      <li>Resilience. At least  <span class="math">\\lceil Q \\cdot |\\mathsf{comm}| \\rceil</span>  number of  <span class="math">\\mathsf{pk}_i \\in \\mathsf{comm}</span>  must be specified in start commands that are input to nodes that remain honest till  <span class="math">T_{\\mathsf{stamp}}</span> .</li>
      <li>Signature oracle correctness. For any  <span class="math">\\mathtt{start}(\\mathsf{pk}_i, \\_)</span>  command input to an honest node,  <span class="math">\\mathsf{pk}_i</span>  must be in the range of the valid public keys for the signature scheme  <span class="math">\\Sigma</span> .    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Upon any sign(msg) query from an honest node i,  <span class="math">\\mathcal{Z}</span>  returns an answer  <span class="math">\\sigma</span>  immediately such that  <span class="math">\\Sigma</span> . Verify( <span class="math">pk_i</span> , msg,  <span class="math">\\sigma</span> ) = 1.</li>
    </ul></li>
    </ul>

    <p class="text-gray-300"><strong>Security definitions.</strong> Let  <span class="math">T_{\\text{stamp}}</span> ,  <span class="math">T_{\\text{bft}}</span>  be polynomially-bounded functions in  <span class="math">\\lambda</span> , n, Q, and  <span class="math">\\delta</span> . Suppose that  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  is  <span class="math">(n, Q, \\delta, \\tau, T_{\\text{stamp}})</span> -valid w.r.t. BFT. Then, for any view in the support of  <span class="math">\\text{EXEC}[\\mathsf{BFT}](\\mathcal{A}, \\mathcal{Z}, \\lambda)</span> , we say that  <span class="math">\\mathsf{secure}^{T_{\\text{bft}}}(\\mathsf{view}) = 1</span>  iff the following properties hold.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">Consistency. Consistency incorporates the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Common prefix. If an honest node i outputs  <span class="math">\\log</span>  at any time  <span class="math">t &lt; T_{\\text{stamp}}</span> , and honest node j (same or different) outputs  <span class="math">\\log&#x27;</span>  at any time  <span class="math">t&#x27; &lt; T_{\\text{stamp}}</span> , it holds that either  <span class="math">\\log \\prec \\log&#x27;</span>  or  <span class="math">\\log&#x27; \\prec \\log</span> .</li>
    </ul></li>
      <li><p class="text-gray-300">Self-consistency. Suppose an honest node i outputs  <span class="math">\\log</span>  and  <span class="math">\\log&#x27;</span>  at times t and t' respectively such that  <span class="math">t &lt; t&#x27; &lt; T_{\\text{stamp}}</span> , it must hold that  <span class="math">\\log \\prec \\log&#x27;</span> .</p></li>
      <li><p class="text-gray-300">Liveness. If  <span class="math">\\mathcal{Z}</span>  inputs TXs to an honest node at time  <span class="math">T_{\\text{start}} \\leq t &lt; T_{\\text{stamp}} T_{\\text{bft}}</span> , then any node that is honest at time  <span class="math">t&#x27; = t + T_{\\text{bft}}</span>  will output a log at time t' such that TXs  <span class="math">\\subseteq</span>  log.  <span class="math">T_{\\text{bft}}</span>  is referred to as the liveness parameter.</p></li>
    </ul>

    <p class="text-gray-300"><strong>Definition 5</strong> (Strongly secure BFT protocols). Let  <span class="math">T_{bft}</span>  be a positive polynomial in  <span class="math">\\lambda</span> , n, Q, and  <span class="math">\\delta</span> . We say that a protocol BFT is strongly secure against (1-Q)-corruption with liveness parameter  <span class="math">T_{bft}</span>  iff for any  <span class="math">n, \\delta &gt; 0</span> ,  <span class="math">\\tau \\geq 0</span> , any positive polynomial  <span class="math">T_{stamp}</span> , for any p.p.t.  <span class="math">\\mathcal{A}</span>  and any polynomial g, there exists a p.p.t. adversary  <span class="math">\\mathcal{B}</span>  and polynomial g', such that for any p.p.t.  <span class="math">\\mathcal{Z}</span>  such that for any  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  is  <span class="math">(n, Q, \\delta, \\tau, T_{stamp})</span> -valid w.r.t. BFT, for any  <span class="math">\\lambda \\in \\mathbb{N}</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp; \\text{Pr}\\left[\\mathsf{view} \\leftarrow \\text{EXEC}[\\mathsf{BFT}](\\mathcal{A}, \\mathcal{Z}, \\lambda) : \\mathsf{secure}^{T_{\\mathrm{bft}}}(\\mathsf{view}) \\neq 1\\right] \\geq g(\\lambda) \\\\ \\Longrightarrow &amp; \\text{Pr}\\left[\\mathsf{view} \\leftarrow \\text{EXEC}[\\mathsf{BFT}](\\mathcal{B}, \\mathcal{Z}, \\lambda) : \\mathsf{forgery}(\\mathsf{view}) = 1\\right] \\geq g&#x27;(\\lambda) \\end{split}</span>$</p>

    <p class="text-gray-300">where forgery(view) = 1, iff in view,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>at some time t the adversary outputs to the environment  <span class="math">\\mathcal{Z}</span>  a forgery pair  <span class="math">(i, \\mathsf{msg}, \\sigma)</span>  such that node i is honest at time t;</li>
      <li>by time t the environment  <span class="math">\\mathcal Z</span>  has input  <span class="math">\\mathtt{start}(\\mathsf{pk}_i, \\_)</span>  to node i;</li>
      <li><span class="math">\\Sigma</span> .Verify( <span class="math">\\mathsf{pk}_i, \\mathsf{msg}, \\sigma</span> ) = 1; and</li>
      <li>by time t, node i has not submitted a query sign(msg) to  <span class="math">\\mathcal{Z}</span>  where the answer was  <span class="math">\\sigma</span> .</li>
    </ul>

    <p class="text-gray-300">Definitional subtleties: corruption model for BFT. Our BFT building block must be secure under the &quot;somewhat static&quot; corruption model. We now elaborate the related definitional subtleties. First, any &quot;spawn&quot; or &quot;target corrupt&quot; instructions must be issued before  <span class="math">T_{\\rm start}</span> , i.e., when the first start is input to an honest node &mdash; in this sense, the security notion seems &quot;somewhat static&quot;. On the other hand, our security notion is stronger than a standard &quot;static&quot; notion of security due to the following: for nodes that are in precorrupt state before  <span class="math">T_{\\rm start}</span> , there is an opportunity that they will become corrupt during the course of the BFT protocol and before  <span class="math">T_{\\rm stamp}</span> . Importantly, all of our security properties, including consistency and liveness properties, must hold before  <span class="math">T_{\\rm stamp}</span>  for any node that has not become corrupt yet. In comparison, the static notion does not need to extend security guarantees to precorrupt nodes. In fact, it is not hard to show that our &quot;somewhat static&quot; security notion is strictly stronger than a standard &quot;static&quot; notion of security, and it is not difficult to construct a (possibly contrived) BFT protocol that demonstrates this separation.</p>

    <p class="text-gray-300"><strong>Definitional subtleties: strong security of BFT.</strong> We remark that due to technical subtleties related to an adversarial selective opening attack, we need to define the above stronger notion of security for the BFT subprotocol. Below we compare this notion with the most natural property-based security notion.</p>

    <p class="text-gray-300">First, while most other security definitions for protocols follow a most natural property-based definitional style, the above security notion for the BFT building block is stronger. In particular, if BFT satisfies the above strong security notion, then a natural instantiation, where honest nodes now generate their own signing key pairs and implement their own signing oracles, would satisfy the most natural property-based notion. Of course, to make the description complete, a valid environment  <span class="math">\\mathcal{Z}</span>  in this case would wait to hear each honest BFT node i output a public key  <span class="math">\\mathsf{pk}_i</span> , and</p>

    <p class="text-gray-300">then input start(comm) to all honest nodes where comm contain sufficiently many honest nodes' public keys.</p>

    <p class="text-gray-300">When honest nodes implement their own key generation and signing oracles, we can group the honest nodes' key generation and signing oracle implementations into the environment Z &lowast; . Then, this specific Z <sup>&lowast;</sup> would never disclose honest nodes' respective secret signing keys. Therefore, if there exists some adversary p.p.t. A, such that exec[BFT](A, Z &lowast; , &lambda;) fails any of these properties with non-negligible probability, then we can construct an adversary B such that during the interaction exec[BFT](A, Z &lowast; , &lambda;), B effectively breaks the security of the signature scheme.</p>

    <p class="text-gray-300">Second, we point out that the natural property-based definitions are weaker and not sufficient for our purposes. In particular, later in the HybridConsensus protocol, the environment Z for BFT can selectively open a set of public keys to include in the start command for the BFT protocol. For example, one can easily imagine a somewhat contrived BFT protocol that would be secure under the most natural property-based definition (like all other definitions in this paper), but would be vulnerable to selective opening attacks: imagine that honest nodes disclose their secret signing keys if some predicate over the chosen public keys is satisfied &mdash; this predicate can easily be chosen such that it is satisfied with only negl(&lambda;) probability for an honestly generated set of public keys not subject to adversarial selective opening, but satisfied with overwhelming property under adversarial selective opening (e.g., if all public keys end with 1).</p>

    <p class="text-gray-300">Fortunately, it is not hard to see that many known instantiations of permissioned BFT protocols satisfy this strong notion of security, e.g., PBFT <a href="#page-52-0">[21]</a> with digital signatures.</p>

    <p class="text-gray-300">Remarks about the signing oracle. We note that alternatively, it is possible to partition away the signing oracle into a global signing functionality adopting the GUC approach <a href="#page-51-9">[17]</a>. In particular, GUC is necessary since the same signature scheme is shared by multiple protocols, the inner BFT protocol, and our outer DailyBFT protocol. If we adopted the GUC approach, our blackbox reduction notion of security might also be simpler since we need not deal with environment having the signing key. On the other hand, using GUC will likely introduce other complexities in terms of notation. The two approaches are essentially equivalent by repartitioning of algorithm boundaries.</p>

    <p class="text-gray-300">Theorem 6 (Castro and Liskov <a href="#page-52-0">[21]</a>, briefly described in Appendix <a href="#page-54-0">A)</a>. There exists a BFT protocol that is strongly secure against (1 &minus; Q) &lt; 1 3 corruption with liveness parameter Tbft := O(n&delta;).</p>

    <p class="text-gray-300">To achieve the above, we can modify PBFT's exponential timeout strategy such that nodes double the time-out every n view changes. For completeness, in Appendix <a href="#page-54-0">A,</a> we briefly describe the PBFT protocol, and we refer the reader to Castro and Liskov <a href="#page-52-0">[21]</a> for further details and optimizations. Note that later when we use BFT as a subprotocol in hybrid consensus, the number of BFT nodes n will be substituted with csize := &lambda;.</p>

      <h3 id="sec-5.1" class="text-xl font-semibold mt-8">5.1 Notational Conventions</h3>

    <p class="text-gray-300">Choice of formal framework. We use the well-accepted Universal Composition <a href="#page-51-8">[16,</a> <a href="#page-51-9">17,</a> <a href="#page-52-13">20]</a> framework for formalizing and modularly composing protocols. For the presentation of our construction, we will take a modular approach. For each (sub)protocol, we formally describe its abstraction &mdash; not by defining an ideal functionality, but using a property-based approach. We then show how to compose these subprotocols to eventually construct our HybridConsensus protocol.</p>

    <p class="text-gray-300">Session identifier conventions. For any protocol prot, if we write prot[sid], then sid (or whatever variable is in square brackets) denotes the session identifier of the protocol instance. If we write prot only without the square brackets, then it means we only care about one specific session of the protocol (although a higher-level protocol can invoke multiple sessions), and therefore we do not denote the session identifier explicitly.</p>

      <h3 id="sec-5.2" class="text-xl font-semibold mt-8">5.2 Daily Offchain Consensus Protocol</h3>

    <p class="text-gray-300">For modular protocol composition, we define an intermediate abstraction called a daily offchain consensus protocol, denoted DailyBFT. In DailyBFT, committee members run an offchain BFT instance to decide a daily log, whereas non-members count signatures from committee members.</p>

    <p class="text-gray-300">Overview of DailyBFT. The definition of the DailyBFT intermediate abstraction extends BFT in the following ways:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Extends security to committee non-members and late-spawning nodes. At a definitional level, the DailyBFT definition extends that of BFT to incorporate committee non-members as well. In particular, in the formal definition of DailyBFT below, all security properties must be satisfied not only by committee members, but also by committee non-members as well. Further, while the BFT definition assumes that all nodes are spawned prior to Tstart, the definition of DailyBFT allows nodes to be spawned later. Therefore, here our security definitions including consistency and liveness apply to any node (committee member or non-member alike) that spawns early enough, i.e., before the deadline Tstamp. These security guarantees do not extend to nodes that spawn too late, since committee members can become corrupt far out in the future, at which point they can sign arbitrary tuples. For exactly this reason, our hybrid consensus protocol, which consumes DailyBFT as a building block, will need to explicitly handle late spawning to extend the security guarantees to nodes that spawn late.</li>
      <li>Termination. DailyBFT makes explicit a termination procedure which must satisfy two requirements, namely, termination agreement and timely termination. Specifically, the environment Z is allowed send a stop instruction to nodes. Timely termination requires that the BFT instance terminate quickly after honest nodes receive input stop. Termination agreement requires that all honest nodes agree on the same final log upon termination.</li>
      <li>Signed daily log hashes. In DailyBFT, committee members output signed daily log hashes which will later be consumed by the hybrid consensus protocol. These signed daily log hashes satisfy completeness and unforgeability. Completeness says that honest committee members output the correctly signed hash of their daily logs. Unforgeability says that the environment/adversary cannot forge signatures on any other values besides the correct hash.</li>
    </ul>

    <p class="text-gray-300">Formally, suppose that an DailyBFT[R] <sup>D</sup> protocol, with R being the session identifier (also referred to as the day), and parametrized by the distribution D, provides the following abstraction.</p>

    <p class="text-gray-300">Inputs. In each time step, the environment Z can provide the following types of inputs multiple times: 1) keygen; 2) start(comm) where comm = {pki}i&isin;[m] ; 3) TXs; and 4) stop.</p>

    <p class="text-gray-300">Outputs. Honest nodes output the following type of messages to Z:</p>

    <p class="text-gray-300">&bull; On input keygen, honest nodes output pk &larr; D.</p>

    <p class="text-gray-300">&bull; In each time step t, honest nodes output to the environment  <span class="math">\\mathcal{Z}</span>  notdone( <span class="math">\\log^t</span> ), until in one final step  <span class="math">t^*</span> , it outputs done( <span class="math">\\log^{t^*}</span> , recs), where recs is either  <span class="math">\\emptyset</span>  or a set of signed tuples vouching for the hash of the final daily log. After outputting done( <span class="math">\\log^{t^*}</span> , recs), honest nodes stop outputting in future time steps.</p>

    <p class="text-gray-300"><strong>Terminology.</strong> Suppose that in a specific view in the support of EXEC[DailyBFT]( <span class="math">\\mathcal{A}, \\mathcal{Z}, \\lambda</span> ), the environment  <span class="math">\\mathcal{Z}</span>  inputs a unique start(comm) command to all honest nodes &mdash; later our compliance rule will require that this be the case, then comm :=  <span class="math">\\{pk_i\\}_i</span>  is referred to as the elected committee.</p>

    <p class="text-gray-300">We say that a node i is an honest committee member at time t, if the following holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Before the first start(comm) command was input to any honest node, node i output to  <span class="math">\\mathcal{Z}</span>  a pk that was included in comm.</li>
      <li>Node i remains honest till time t (but could become corrupt later).</li>
    </ul>

    <p class="text-gray-300">Henceforth, if we say &quot;an honest committee member i performs some action or is the receiver of some action at time t in some view&quot;, we implicitly mean that node i is an honest committee member at time t, i.e., it remains honest till time t but could be corrupt later.</p>

    <p class="text-gray-300">The earliest time at which an honest committee member receives input start is denoted  <span class="math">T_{\\rm start}</span> . The earliest time at which an honest committee member receives input stop is denoted  <span class="math">T_{\\rm stop}</span> .</p>

    <p class="text-gray-300">We say that an honest node outputs  <span class="math">\\log</span>  as a shorthand to mean that it outputs either  <span class="math">done(\\log, \\_)</span>  or  <span class="math">notdone(\\log)</span> .</p>

    <p class="text-gray-300">When an honest node i outputs  <span class="math">done(log, \\_)</span>  at some time, we say that log is node i's final daily log.</p>

    <p class="text-gray-300">Compliant executions. We say that a pair  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  is  <span class="math">(n, Q, \\delta, \\tau, T_{\\text{stamp}}, T_{\\text{bft}})</span> -valid w.r.t. DailyBFT, if  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  is not only  <span class="math">(n, \\delta, \\tau)</span> -valid w.r.t. DailyBFT by Definition 1, but the following also holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Committee agreement. If honest node i receives input start(comm) from  <span class="math">\\mathcal{Z}</span>  at time t, and honest node j receives input start(comm') from  <span class="math">\\mathcal{Z}</span>  at time t', it holds that comm = comm'.</li>
      <li>Close start and stop. Let  <span class="math">T_{\\text{start}}</span>  be the earliest time an honest node receives input  <span class="math">\\text{start}(_{-})</span> . Then, for any node i honest at time  <span class="math">T_{\\text{start}} + \\delta</span> , i must receive input  <span class="math">\\text{start}(_{-})</span>  by time  <span class="math">T_{\\text{start}} + \\delta</span> . Similarly, let  <span class="math">T_{\\text{stop}}</span>  be the earliest time an honest node receives input stop. Then, for any node i honest at time  <span class="math">T_{\\text{stop}} + \\delta</span> , i must receive input stop by time  <span class="math">T_{\\text{stop}} + \\delta</span> . For any honest node i that receives stop at time t, it must have received start at some time t' &lt; t.</li>
      <li>Resilience. At least  <span class="math">\\lceil Q \\cdot |\\mathsf{comm}| \\rceil</span>  number of  <span class="math">\\mathsf{pk}_i \\in \\mathsf{comm}</span>  must be output, earlier than the first start command input to any honest node, by nodes that remain honest till  <span class="math">T_{\\mathsf{stamp}}</span> .</li>
      <li>Early enough stop.  <span class="math">T_{\\text{stop}} + T_{\\text{bft}} + \\delta \\leq T_{\\text{stamp}}</span> , where  <span class="math">T_{\\text{stop}}</span>  is the time at which the earliest honest committee member receives input stop.</li>
      <li>Temporary static corruption. For any  <span class="math">pk \\in comm</span> , if pk was output by a node that became corrupt before  <span class="math">T_{stamp}</span> , then the &quot;target corrupt&quot; instruction must have been issued before  <span class="math">T_{start}</span> .</li>
    </ul>

    <p class="text-gray-300">Security definitions. A DailyBFT protocol is said to be secure against (1-Q)-corruption with liveness parameter  <span class="math">T_{\\rm bft}</span> , if for any n&gt;0,  <span class="math">\\delta&gt;0</span> , any  <span class="math">\\tau\\geq0</span> , any  <span class="math">T_{\\rm stamp}&gt;0</span> , for any  <span class="math">(\\mathcal{A},\\mathcal{Z})</span>  that is  <span class="math">(n,Q,\\delta,\\tau,T_{\\rm stamp},T_{\\rm bft})</span> -valid w.r.t. DailyBFT, there exists a negligible function negl such that for every  <span class="math">\\lambda\\in\\mathbb{N}</span> , except with  <span class="math">\\mathsf{negl}(\\lambda)</span>  probability, the following properties hold for  <span class="math">\\mathsf{EXEC}[\\mathsf{DailyBFT}](\\mathcal{A},\\mathcal{Z},\\lambda)</span> :</p>

    <p class="text-gray-300">&bull; Timely termination. Time termination encompasses the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Any committee member i that is honest at time  <span class="math">T_{\\text{stop}} + T_{\\text{bft}}</span>  must have output  <span class="math">\\text{done}(\\log, \\_)</span>  by time  <span class="math">T_{\\text{stop}} + T_{\\text{bft}}</span> .</li>
      <li>For any node i that is honest at time  <span class="math">t \\geq T_{\\text{stop}} + T_{\\text{bft}} + \\delta</span> , it must have output done(log, _) by time t.</li>
    </ul>

    <p class="text-gray-300">In both cases, when an honest node outputs done(log, _), we refer to log as the node's <em>final</em> daily log.</p>

    <p class="text-gray-300">Note that since  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  is  <span class="math">(n, Q, \\delta, \\tau, T_{\\text{stamp}}, T_{\\text{bft}})</span> -valid w.r.t. DailyBFT, timely termination implies the following: any node that spawned before  <span class="math">T_{\\text{stamp}}</span>  and remains honest till  <span class="math">T_{\\text{stamp}}</span>  must have output  <span class="math">done(\\_,\\_)</span>  by  <span class="math">T_{\\text{stamp}}</span> . In other words, if any node spawned before  <span class="math">T_{\\text{stamp}}</span>  and outputs  <span class="math">done(\\_,\\_)</span>  when it is honest,  <span class="math">done(\\_,\\_)</span>  must be output no later than  <span class="math">T_{\\text{stamp}}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Consistency. Consistency encompasses the following:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Self-consistency. For any node i that spawned before  <span class="math">T_{\\text{stamp}}</span> , and is honest at time t', suppose node i outputs log at time  <span class="math">t \\leq t&#x27;</span>  and outputs log' at time t', it holds that  <span class="math">\\log \\prec \\log&#x27;</span> .</li>
      <li>Termination agreement. For any node i that spawned before  <span class="math">T_{\\text{stamp}}</span> , and any node j that also spawned before  <span class="math">T_{\\text{stamp}}</span> , suppose node i outputs  <span class="math">done(log&#x27;, \\_)</span>  and node j outputs  <span class="math">done(log&#x27;, \\_)</span>  before they become corrupt, it holds that log = log'.</li>
      <li>Common prefix. For any nodes i, j that spawned before  <span class="math">T_{\\text{stamp}}</span> , suppose that i is honest at time t and outputs  <span class="math">\\log</span>  at time t, and j is honest at time t' and outputs  <span class="math">\\log</span>  at time t', it holds that either  <span class="math">\\log \\prec \\log&#x27;</span>  or  <span class="math">\\log&#x27; \\prec \\log</span> .</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">Note that it may seem like common prefix is implied by termination agreement and self-consistency, but keep in mind that common prefix must additionally hold for nodes that never have an opportunity to output done(_, _) before becoming corrupt.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Liveness. Suppose that  <span class="math">\\mathcal{Z}</span>  inputs TXs to an honest committee member at time  <span class="math">T_{\\text{start}} \\leq t &lt; T_{\\text{stop}} T_{\\text{bft}}</span> . Then, for any honest node i that spawns at time  <span class="math">t_{\\text{spawn}} \\leq T_{\\text{stamp}}</span> , if i is honest at time  <span class="math">t&#x27; \\geq t + T_{\\text{bft}} + \\delta</span> , then node i must have output  <span class="math">\\log</span>  at some time  <span class="math">t^* \\leq t&#x27;</span>  such that TXs  <span class="math">\\subseteq \\log</span> .</li>
      <li>Completeness. Let comm be the unique set included in start commands input to honest nodes. For every  <span class="math">pk \\in comm</span>  that is output by a node i honest at sometime t and if node i outputs done(log, recs) at time t, then it holds that a valid record  <span class="math">\\{R, hash(log)\\}_{pk^{-1}} \\in recs</span>  where validity is defined by correct signature verification with pk.</li>
      <li>Unforgeability. Let  <span class="math">t \\leq T_{\\text{stamp}}</span> , and let  <span class="math">\\mathsf{pk} \\in \\mathsf{comm}</span>  be output by a node i that is honest at time t. Then, if by time t the adversary  <span class="math">\\mathcal{A}</span>  outputs to the environment  <span class="math">\\mathcal{Z}</span>  a valid tuple  <span class="math">\\{R,h\\}_{\\mathsf{pk}^{-1}}</span>  where R is the current DailyBFT instance's session identifier, then it must hold that node i has output  <span class="math">\\mathsf{done}(\\mathsf{log}, \\_)</span>  by t and  <span class="math">h = \\mathsf{hash}(\\mathsf{log})</span> .</li>
    </ul>

    <p class="text-gray-300"><strong>Construction.</strong> We present a construction of the DailyBFT protocol from BFT in Figure 1. Below is an informal description of the operations of DailyBFT:</p>

    <p class="text-gray-300">&bull; BFT virtual nodes and selective opening of committee. A DailyBFT node outputs fresh public keys to its environment upon a keygen query. Then when it receives a start(comm) command, if comm contains one or more of its own public keys, then the node is elected as a committee member. In this case, the node will fork a BFT virtual node for each public key in comm that belongs to itself. Here the committee is selectively opened by the environment through the start(comm) command, later our proof will need to leverage the strong security of BFT.</p>

    <pre><code class="language-text">Subprotocol DailyBFT[R]
On input init: \\ell := 0, \\log := \\emptyset, mykeys := \\emptyset
On input keygen: (pk, sk) \\stackrel{\\$}{\\leftarrow} \\Sigma . Gen(1^{\\lambda}), add pk to mykeys, output pk
On input stop: for each BFT^{pk} virtual node forked: input TXs := \\{\\{stop\\}_{pk^{-1}}\\} to BFT^{pk}
On input start(comm): if mykeys \\cap comm \\neq \\emptyset: isMember = true, else isMember = false
                                           Case isMember = true
  For each pk \\in mykeys \\cap comm: fork a BFT virtual node, and BFT.start(pk, comm).
     // henceforth this BFT virtual node is denoted BFT&lt;sup&gt;pk&lt;/sup&gt;
  Every time some BFT&lt;sup&gt;pk&lt;/sup&gt; virtual node outputs sign(msg): return {msg}&lt;sub&gt;pk&lt;/sub&gt;&lt;sup&gt;-1&lt;/sup&gt;
     // implements a signing oracle for BFT virtual nodes
  On input TXs: input TXs to each BFT virtual node forked
  Let BFT&lt;sub&gt;0&lt;/sub&gt; denote the first such BFT virtual node forked
  Let complete(log) = true iff log contains stop correctly signed by th := &lt;math&gt;\\lceil |comm|/3 \\rceil
     distinct pks in comm
  Every time step t if start has been received and done has not been output:
     Receive output log* from BFT&lt;sub&gt;0&lt;/sub&gt;
     If complete(log^*) then log^* := shortest prefix of log^* such that complete(log^*)
     For each tx \\in log^* - log that is not a stop transaction:
       Let \\ell := \\ell + 1, for each \\mathsf{pk} \\in \\mathsf{mykeys} \\cap \\mathsf{comm}: gossip \\{R, \\ell, \\mathsf{tx}\\}_{\\mathsf{pk}^{-1}}
     \\log := \\log^*
     If complete(log): call Finalize; else output notdone(log)
  Finalize:
     recs := \\emptyset, remove all stop transactions from log
     For each \\mathsf{pk} \\in \\mathsf{mykeys} \\cap \\mathsf{comm}: let x := \\{R, |\\mathsf{log}|\\}_{\\mathsf{pk}^{-1}}, \\, \\mathsf{recs} := \\mathsf{recs} \\cup \\{x\\}, \\, \\mathsf{gossip} \\, x
     Output done(log, recs), and stop outputting in future time steps.
                                          Case isMember = false
  On receive \\{R,\\ell\\}_{pk^{-1}} or \\{R,\\ell,tx\\}_{pk^{-1}}: add message to history and check the following:
  On collect (r, \\ell, tx) and signatures s.t. r = R and th := \\lceil |comm|/3|  distinct pks
  in comm signed the tuple correctly:
     If \\log[\\ell] has not been set, let \\log[\\ell] := \\mathsf{tx}
  On collect (r,\\ell) and signatures s.t. r=R and th := \\lceil |\\mathsf{comm}|/3 \\rceil distinct pks
  in comm signed the tuple correctly:
     Wait till \\log[:\\ell] all populated
     Output done(\\log, \\emptyset), and stop outputting in future time steps.
  Each time step until done is output:
     let log&#x27; := longest contiguous prefix of log, output notdone(log&#x27;)
</code></pre>

    <p class="text-gray-300">Figure 1: <strong>Daily offchain consensus protocol.</strong> Since each signing key is reused for both the inner BFT protocol and the outer DailyBFT protocol, we assume that the signing algorithm tags each message for the inner BFT instance with the prefix &quot;0&quot;, and each message for the outer DailyBFT with the prefix &quot;1&quot; to avoid namespace collision.</p>

    <p class="text-gray-300">    <img src="_page_31_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 2: Modular composition of the hybrid consensus protocol.</p>

    <h2 id="sec-misc-1" class="text-2xl font-bold">Subprotocol mempool On initialize: TXs := &empty; On receive TXs1: TXs := TXs &cup; TXs<sup>1</sup> On input propose(TXs1): TXs := TXs &cup; TXs1, gossip TXs<sup>1</sup> On input query(confirmed): return TXs\\confirmed</h2>

    <p class="text-gray-300">Figure 3: The mempool subprotocol keeps track of transactions, and upon query, proposes a set of outstanding transactions. An obvious practical optimization not documented here for simplicity is that the mempool can purge transactions that are already confirmed in LOG.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Member and non-member basic operations. Committee members populate their daily logs relying on the BFT protocol, whereas committee non-members count signatures from committee members to populate their logs.</li>
      <li>Termination. Nodes implement a termination procedure as follows: whenever an honest committee member receives a stop instruction, it inputs a special, signed stop transaction to each of its BFT virtual node. As soon as the inner BFT instance outputs a log containing stop transactions signed by at least d|comm|/3e distinct committee public keys, the log is finalized and output. All transactions after the first d|comm|/3e stop transactions (with distinct committee public keys) are ignored.</li>
      <li>Signed daily log hashes. When committee members output done, they also output a signed digest of the final daily log &mdash; later, our HybridConsensus protocol will stamp this digest onto the snailchain.</li>
    </ul>

    <p class="text-gray-300">Theorem 7 (DailyBFT from BFT). Suppose that the signature scheme &Sigma; employed by DailyBFT is secure, and that hash is a random oracle. Suppose that BFT is secure against (1 &minus; Q)-corruption with liveness parameter Tbft 0 for Q &gt; <sup>2</sup> 3 . Then, DailyBFT is secure against (1 &minus; Q)-corruption with liveness parameter Tbft := Tbft <sup>0</sup> + &delta;.</p>

    <p class="text-gray-300">The proof of this theorem is deferred to Section <a href="#page-37-0">8.</a></p>

      <h3 id="sec-5.3" class="text-xl font-semibold mt-8">5.3 Hybrid Consensus Protocol</h3>

    <p class="text-gray-300">We now describe our final product, the hybrid consensus protocol. Hybrid consensus consumes multiple instances of DailyBFT where rotating committees agree on daily logs. Hybrid consensus primarily does the following:</p>

    <p class="text-gray-300">&bull; It manages the spawning and termination of DailyBFT instances effectively using snailchain as a global clock that offers weak synchronization among honest nodes;</p>

    <h2 id="sec-misc-2" class="text-2xl font-bold"><strong>Protocol</strong> HybridConsensus <span class="math">^{\\lambda}</span> , parametrized by <span class="math">\\lambda</span></h2>

    <p class="text-gray-300">On init: R := 0,  <span class="math">LOG_s := \\emptyset</span> ,  <span class="math">LOG := \\emptyset</span> , csize  <span class="math">:= \\lambda</span> .</p>

    <h2 id="sec-misc-3" class="text-2xl font-bold">Mempools:</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Fork an instance of mempool denoted snailpool that stores pending records for snailchain.</li>
      <li>Fork another instance of mempool that stores pending transactions, denoted txpool.</li>
      <li>On input TXs: txpool.propose(TXs).</li>
    </ul>

    <p class="text-gray-300">Snailchain: Fork an instance of snailchain, in each time step:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>let chain denote the current local chain</li>
      <li><span class="math">\\bullet</span>  let pk := DailyBFT[R+1].keygen where R denotes the current day</li>
      <li>let recs := snailpool.query(ExtractRecs(chain[:  <span class="math">-\\lambda</span> ])), input (recs, pk) to snailchain</li>
    </ul>

    <h2 id="sec-misc-4" class="text-2xl font-bold">Preprocess:</h2>

    <p class="text-gray-300">Wait till  <span class="math">|\\mathsf{chain}| \\ge \\mathsf{csize} + \\lambda</span></p>

    <p class="text-gray-300"><span class="math">L := \\text{Find in history maximal, ordered list of } (R, \\log_R) \\text{ tuples such that } R \\text{ is incrementing with no gaps, and } (R, \\mathsf{hash}(\\log_R)) \\text{ is on-chain valid w.r.t. chain}</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{LOG} := \\mathsf{log}_1 || \\mathsf{log}_2 || \\dots || \\mathsf{log}_{|L|}</span></p>

    <h2 id="sec-misc-5" class="text-2xl font-bold">Daily Offchain Consensus:</h2>

    <p class="text-gray-300">Let R := |L|, fork an instance of DailyBFT[R + 1]: Loop:</p>

    <p class="text-gray-300">Wait till  <span class="math">|chain| \\ge upper(R+1) + \\lambda</span> , let R := R+1</p>

    <p class="text-gray-300">Let  <span class="math">comm_R := MinersOf(chain[lower(R) : upper(R)])</span>  where MinersOf parses each block as  <span class="math">(recs_i, pk_i)</span>  and returns a list containing all  <span class="math">pk_i</span> s</p>

    <p class="text-gray-300">If an instance DailyBFT[R-1] exists, DailyBFT[R-1].stop</p>

    <p class="text-gray-300">Fork an instance of DailyBFT[R+1]</p>

    <p class="text-gray-300"><span class="math">\\mathsf{DailyBFT}[R].\\mathsf{start}(\\mathsf{comm}_R)</span></p>

    <p class="text-gray-300">Each time step: let TXs := txpool.query(LOG), input TXs to DailyBFT[R]</p>

    <p class="text-gray-300"><strong>Output:</strong> In each time step: let R denote the current day. Let  <span class="math">\\mathsf{isdone}(r) = \\mathsf{true}</span>  if  <span class="math">\\mathsf{DailyBFT}[r]</span>  has output done in this or earlier time steps.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">\\mathsf{DailyBFT}[R-1]</span>  outputs  <span class="math">\\mathsf{done}(\\mathsf{log}_{-1},\\mathsf{recs})</span>  in this time step:  <span class="math">\\mathsf{LOG}_s := \\mathsf{LOG}_s||\\mathsf{log}_{-1},\\mathsf{snailpool.propose}(\\mathsf{recs})</span></li>
      <li>Let  <span class="math">\\log_{-1}</span>  and  <span class="math">\\log</span>  be the output  <span class="math">\\log</span>  of  <span class="math">\\mathsf{DailyBFT}[R-1]</span>  and  <span class="math">\\mathsf{DailyBFT}[R]</span>  in this time step respectively (or  <span class="math">\\emptyset</span>  if nothing is output)</li>
      <li>If isdone(R-1):  <span class="math">LOG := LOG_s||log;</span>  else  <span class="math">LOG := LOG_s||log_{-1}</span> . Output LOG</li>
    </ul>

    <p class="text-gray-300">On-chain valid: A tuple (R, h) is on-chain valid w.r.t chain iff the following holds</p>

    <p class="text-gray-300">&bull; For at least th :=  <span class="math">\\lceil \\text{csize}/3 \\rceil</span>  distinct  <span class="math">pk \\in \\text{MinersOf}(\\text{chain}[\\text{lower}(R), \\text{upper}(R)])</span> :  <span class="math">\\{R, h\\}_{pk^{-1}}</span>  is the first occurrence in  <span class="math">\\text{chain}[: -\\lambda]</span>  where pk signed some tuple of the form  <span class="math">(R, \\_)</span> .</p>

    <p class="text-gray-300">Figure 4: <strong>Main</strong> HybridConsensus <strong>protocol.</strong> A newly spawned, honest node starts running this protocol. We assume history is the set of all historical transcripts sent and received. We assume that message routing to subprotocol instances is implicit: whenever any subprot[sid] instance is forked, history[subprot[sid]] and protocol messages pertaining to subprot[sid] are automatically routed to the subprot[sid] instance.</p>

    <p class="text-gray-300">&bull; Recall that each DailyBFT instance does not ensure security for nodes that spawn too late, since committee members can become corrupt far out in the future at which point they can sign arbitrary tuples. Therefore, hybrid consensus introduces an on-chain stamping mechanism to extend security guarantees to even nodes that spawn late.</p>

    <p class="text-gray-300">Figure <a href="#page-32-0">4</a> is an algorithmic description of the HybridConsensus protocol. Figure <a href="#page-31-0">2</a> illustrates the modular composition of the hybrid consensus protocol. Specifically, the hybrid consensus protocol internally runs the following subprotocol instances: two mempool instances denoted snailpool and txpool respectively, a snailchain instance, and multiple DailyBFT instances. We now explain these subprotocol instances more concretely.</p>

    <p class="text-gray-300">Transaction mempools. The HybridConsensus protocol maintains two instances of the mempools protocol (see Figure <a href="#page-31-1">3)</a>, denoted txpool and snailpool respectively. The txpool is a mempool used for maintaining outstanding transactions to be confirmed with DailyBFT instances, and the snailpool is used for maintaining daily log digests to be stamped on the snailchain. The mempool protocol is very simple: it gossips transactions over the network whenever the environment inputs new transactions. Whenever it hears transactions from the network, it saves them in the mempool.</p>

    <p class="text-gray-300">snailchain. The HybridConsensus protocol internally forks a snailchain instance. First, the snailchain is used for reaching agreement on committees who will then run the offchain BFT consensus. The committee is selected as the miners of csize := &lambda; consecutive blocks. The chain quality property of the underlying snailchain ensures that sufficiently many of these miners are honest for sufficiently long. Second, this snailchain instance is used not for committing transactions, but for stamping daily log digests such that the protocol can resist retroactive corruptions where the adversary corrupts committee members in the future.</p>

    <p class="text-gray-300">DailyBFT instances. The HybridConsensus protocol forks multiple instances of the DailyBFT protocol, and we use the index R to denote the session identifier of each instance. R is also referred to as the day number, and hence each DailyBFT[R] instance outputs a &quot;daily log&quot;. In each DailyBFT[R] instance, the elected committee members rely on the underlying BFT protocol to commit transactions and output a daily log over time, whereas committee non-members count signatures from committee members to populate their daily logs.</p>

    <p class="text-gray-300">Operations. Each node maintains a history of all past transcripts denoted history &mdash; we assume this for simplicity of formalism, and it can be optimized away in practice. Nodes that newly spawn obtain the historical transcripts instantly (in practice this can be instantiated by having honest nodes offer a history retrieval service).</p>

    <p class="text-gray-300">When a new node spawns, it populates its LOG as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Matching on-chain valid tuples. A newly spawned node first identifies all on-chain valid tuples of the form (R, h), where R is the day number and h is the hash of the daily log. Then, the node will search history and identify an appropriate daily log log<sup>R</sup> that is consistent with h. The node populates LOG with these daily logs. This on-chain matching process effectively provides a safe mechanism for a newly spawned node to catch up and populate old entries of its output LOG.</li>
      <li>Through daily offchain consensus. Once this catch-up process is complete, the node will henceforth rely on DailyBFT instances to further populate remaining entries of its output LOG. In each DailyBFT instance, a node can act as a committee member of a committee non-member.</li>
    </ul>

    <p class="text-gray-300">To do this, a node monitors its output chain from the snailchain instance. As soon as the chain length exceeds  <span class="math">\\operatorname{csize} \\cdot R + \\lambda</span> , the R-th day starts, at which point the node inputs  <span class="math">\\operatorname{stop}</span>  to the previous  <span class="math">\\operatorname{DailyBFT}[R-1]</span>  instance (if one exists), and inputs  <span class="math">\\operatorname{start}(\\operatorname{MinersOf}(\\operatorname{chain}[\\operatorname{lower}(R):\\operatorname{upper}(R)]))</span>  to the  <span class="math">\\operatorname{DailyBFT}[R]</span>  instance. There is typically a period of overlap during which both  <span class="math">\\operatorname{DailyBFT}[R-1]</span>  and  <span class="math">\\operatorname{DailyBFT}[R]</span>  instances are running simultaneously and outputting their respective daily logs. When nodes assimilate their daily logs into the final output LOG, they make sure that LOG is always contiguous leaving no gaps in between. Due to the timely termination property of  <span class="math">\\operatorname{DailyBFT}(R)</span>  instance fully takes over.</p>

      <h3 id="sec-5.4" class="text-xl font-semibold mt-8">5.4 Theorem Statements</h3>

    <p class="text-gray-300"><strong>Definition 6</strong> (Admissible parameters for hybrid consensus  <span class="math">\\Gamma_{\\rho}^{\\mathsf{hc}}</span> ). Let  <span class="math">T_{bft} := O(m\\delta)</span>  be the liveness parameter for BFT with m nodes. We define  <span class="math">\\Gamma_{\\rho}^{\\mathsf{hc}}(n,\\alpha,\\delta,\\tau) = 1</span>  iff the following holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">n &gt; 0, \\, \\delta &gt; 0, \\, \\tau \\geq 0</span>  are all polynomial functions in  <span class="math">\\lambda; \\, \\alpha &gt; 0</span>  is a constant;</li>
      <li>There exists a constant  <span class="math">\\eta &gt; 0</span>  such that  <span class="math">p(1 (2\\delta + 2)p) \\ge (1 + \\eta)q</span> . (This is needed for the underlying snailchain to be secure.)</li>
      <li>There exists a constant  <span class="math">\\eta_0 &gt; 0</span>  such that  <span class="math">Q := 1 (1 + \\eta_0) \\frac{q}{\\gamma} &gt; \\frac{2}{3}</span> . (This is needed such that we get &gt; 2/3 chain quality for snailchain.)</li>
      <li>There exists a constant  <span class="math">\\eta_1 &gt; 0</span>  such that  <span class="math">G&#x27; := (1 + \\eta_1)n\\rho &lt; \\frac{\\lambda}{T_{\\text{bft}} + \\delta}</span>  for any  <span class="math">\\lambda \\in \\mathbb{N}</span> . (This is needed such that the chain does not grow too fast to ensure liveness.)</li>
      <li>There exists a constant  <span class="math">\\eta_2 &gt; 0</span>  such that  <span class="math">\\tau &gt; 4\\lambda(1+\\eta_2)/\\gamma + c\\lambda\\delta</span>  for some appropriately large constant c. (This is needed such that the adversary is sufficiently constrained in agility.) In the above, parameters  <span class="math">p, q, \\gamma</span>  are functions in  <span class="math">n, \\alpha, \\delta</span>  as defined in Section 4.1.</li>
    </ul>

    <p class="text-gray-300"><strong>Theorem 8</strong> (Main theorem for HybridConsensus). Suppose that hash,  <span class="math">H:\\{0,1\\}^* \\to \\{0,1\\}^{\\lambda}</span>  are independent random oracles, and that the signature scheme  <span class="math">\\Sigma</span>  is secure. Then, for any constant  <span class="math">\\eta &gt; 0</span> , hybrid consensus instantiated with Nakamoto as snailchain and with mining difficulty parameter  <span class="math">\\rho</span>  is secure with liveness parameters  <span class="math">(T_{warmup}, T_{confirm})</span>  w.r.t. any p.p.t.  <span class="math">\\Gamma_{\\rho}^{hc}</span> -admissible  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> , where</p>

    <p class="text-gray-300"><span class="math">$T_{warmup} := 2\\lambda(1+\\eta)/\\gamma, \\quad T_{confirm} := O(\\lambda\\delta)</span>$</p>

    <p class="text-gray-300">Note that the above  <span class="math">T_{\\text{confirm}}</span>  parameter is for the worst-case, in the optimistic case, hybrid consensus achieves a transaction confirmation time of  <span class="math">O(\\delta)</span> .</p>

    <p class="text-gray-300">The proofs of the above theorem will be presented in Section 8.</p>

    <p class="text-gray-300"><strong>Typical parametrizations.</strong> Typically in practice, if we set the puzzle's difficulty parameter  <span class="math">\\rho := \\Theta(\\frac{1}{n\\Delta})</span>  to be sufficiently small, where  <span class="math">\\Delta</span>  is a possibly loose upper bound on the network's delay known a priori. Under such parametrization, if the overall corruption  <span class="math">\\alpha</span>  is roughly 3/4, then we ensure roughly 2/3 chain quality.</p>

    <p class="text-gray-300">Corollary 3 (Typical parameters for hybrid consensus over Nakamoto: restatement of Theorem ??). Assume that  <span class="math">\\alpha = \\frac{1}{4} - \\epsilon</span>  for an arbitrary constant  <span class="math">\\epsilon &gt; 0</span> . Then for every  <span class="math">n, \\delta</span> , there exists sufficiently small  <span class="math">\\rho_0 := \\Theta(\\frac{1}{\\delta n})</span>  such that hybrid consensus with Nakamoto as the underlying</p>

    <p class="text-gray-300">snailchain and with mining difficulty parameter  <span class="math">\\rho &lt; \\rho_0</span>  is secure w.r.t. any p.p.t.  <span class="math">(n, \\alpha, \\delta, \\tau)</span> -valid  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  for any  <span class="math">\\tau</span>  such that  <span class="math">\\Gamma_{\\rho}^{\\mathsf{hc}}(n, \\alpha, \\delta, \\tau) = 1</span> , achieving</p>

    <p class="text-gray-300"><span class="math">$T_{warmup} := 8\\lambda/3n\\rho, \\quad T_{confirm} := O(\\lambda\\delta)</span>$</p>

      <h3 id="sec-5.5" class="text-xl font-semibold mt-8">5.5 Practical Considerations and Possible Optimizations</h3>

    <p class="text-gray-300">The scheme described above is optimized for simplicity and to aid formal analysis, but not for practical performance. There are many possible optimizations. For example, instead of having committee members sign each transaction one by one, they could instead sign a batch of transactions at a time. During stamping, instead of having each node send a separate signature onto snailchain, we can rely on a threshold signature scheme and stamp a single signature of the daily log's hash onto snailchain. It is also easy to prune storage of old transcripts. We leave practical optimizations and implementation to future work.</p>

    <p class="text-gray-300">Pass and Shi recently propose a new blockchain protocol called Fruitchain [48]. For a sufficiently small puzzle difficulty parameter  <span class="math">\\rho := \\Theta(\\frac{1}{n\\delta})</span> , and  <span class="math">\\alpha := \\frac{1}{3} - \\epsilon</span>  for an arbitrarily small constant  <span class="math">\\epsilon &gt; 0</span> , Fruitchain achieves  <span class="math">Q &gt; \\frac{2}{3}</span>  chain quality over any sufficiently large window of consecutive blocks. It is not too hard to compose hybrid consensus and Fruitchains to obtain a responsive permissionless consensus protocol that is resilient against  <span class="math">1/3 - \\epsilon</span>  overall corruption for an arbitrarily small constant  <span class="math">\\epsilon &gt; 0</span> .</p>

    <p class="text-gray-300">Fruit chain provides the same formal abstraction as Nakamoto consensus, but with different parameters. Henceforth we will use the term &quot;fruit quality&quot; to mean Fruit chain's chain quality, and &quot;fruit growth&quot; to mean Fruit chain's chain growth. Under typical parameters stated in Section 4.1.2 and Corollary 2, to obtain  <span class="math">\\eta</span> -optimal chain quality, Fruit chain requires the fruit quality window to be reasonably large, i.e.,  <span class="math">\\Theta(\\lambda/\\eta)</span> . Similarly, fruit growth also requires the time window to be reasonably long. In light of this, when we adopt Fruit chain as the underlying snail chain, we need to make the following changes to the protocol described in Section 5:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let HybridConsensus <span class="math">^{\\lambda,\\eta}</span>  be parametrized with parameters  <span class="math">\\lambda</span> , and  <span class="math">\\eta</span> .</li>
      <li>Redefine  <span class="math">\\operatorname{csize} := \\frac{\\lambda}{\\eta}</span> ,  <span class="math">\\operatorname{lower}(R) := \\frac{(R-1)\\lambda}{\\eta} + 1</span> , and  <span class="math">\\operatorname{upper}(R) := \\frac{R \\cdot \\lambda}{\\eta}</span> . In other words, the committee size is set to  <span class="math">\\frac{\\lambda}{\\eta}</span> , and the protocol waits for the chain length  <span class="math">|\\operatorname{chain}| \\geq \\operatorname{upper}(R) + \\lambda</span>  to start the R-th day.</li>
    </ul>

    <p class="text-gray-300"><strong>Definition 7</strong> (Admissible parameters for hybrid consensus over Fruitchain  <span class="math">\\Gamma_{\\rho,\\eta}^{\\text{hcfruit}}</span> ). Let  <span class="math">T_{bft} := O(m\\delta)</span>  be the liveness parameter for BFT with m nodes. We define  <span class="math">\\Gamma_{\\rho,\\eta}^{\\text{hcfruit}}(n,\\alpha,\\delta,\\tau) = 1</span>  iff the following holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>n &gt; 0,  <span class="math">\\delta &gt; 0</span> ,  <span class="math">\\tau \\ge 0</span>  are all polynomial functions in  <span class="math">\\lambda</span> ;  <span class="math">\\alpha &gt; 0</span>  is a constant;</li>
      <li>There exists a constant  <span class="math">\\eta&#x27; &gt; 0</span>  such that  <span class="math">p(1 (2\\delta + 2)p) \\ge (1 + \\eta&#x27;)q</span> . (This is needed for the underlying snailchain to be secure.)</li>
      <li><span class="math">Q := (1 5\\eta)(1 \\alpha) &gt; \\frac{2}{3}</span> . (This is needed such that we get &gt; 2/3 chain quality for snailchain.)</li>
      <li><span class="math">G&#x27; := (1 + 5\\eta)n\\rho &lt; \\frac{\\lambda}{\\eta(T_{\\text{bft}} + \\delta)}</span>  for any  <span class="math">\\lambda \\in \\mathbb{N}</span> . (This is needed such that the chain does not grow too fast to ensure liveness.)</li>
    </ul>

    <p class="text-gray-300">&bull;  <span class="math">\\tau &gt; 3\\lambda(1+\\frac{1}{\\eta})/((1-5\\eta)(1-\\alpha)n\\rho) + c\\lambda\\delta</span>  for some appropriately large constant c. (This is needed such that the adversary is sufficiently constrained in agility.)</p>

    <p class="text-gray-300">In the above, parameters  <span class="math">p, q, \\gamma</span>  are functions in  <span class="math">n, \\alpha, \\delta</span>  as defined in Section 4.1.</p>

    <p class="text-gray-300"><strong>Theorem 9</strong> (Hybrid consensus over Fruitchain: restatement of Theorem 3). For any (arbitrarily small) constant  <span class="math">\\epsilon &gt; 0</span> , let  <span class="math">\\alpha = \\frac{1}{3} - \\epsilon</span> , and for every  <span class="math">n, \\delta</span> , there exists a sufficiently small  <span class="math">\\rho := \\Theta(\\frac{1}{\\delta n})</span> , a suitable  <span class="math">\\kappa = \\Theta(\\lambda)</span> , and constant  <span class="math">\\eta &gt; 0</span> , such that HybridConsensus<sup> <span class="math">\\lambda, \\eta</span> </sup> over Fruitchain with parameters  <span class="math">(\\rho, \\kappa)</span> , is secure w.r.t. any p.p.t.  <span class="math">(n, \\alpha, \\delta, \\tau)</span> -valid <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  for any suitable  <span class="math">\\tau</span>  such that  <span class="math">\\Gamma_{\\rho, \\eta}^{\\text{hcfruit}}(n, \\alpha, \\delta, \\tau) = 1</span>  where</p>

    <p class="text-gray-300"><span class="math">$T_{warmup} := 1.5\\lambda(1 + \\frac{1}{\\eta})/(1 - 5\\eta)n\\rho, \\quad T_{confirm} := O(\\lambda\\delta)</span>$</p>

    <p class="text-gray-300">Again, the above  <span class="math">T_{\\text{confirm}} = O(\\lambda \\delta)</span>  is the worst-case transaction confirmation time (i.e., even when under attack). The optimistic transaction confirmation time is  <span class="math">O(\\delta)</span> , i.e., independent of the security parameter  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">Before presenting the detailed proofs, we first describe a high-level roadmap to aid understanding. For simplicity, we use hybrid consensus over Nakamoto as an example in our description, since the proof for hybrid consensus over Fruitchain is the same except with different parameters.</p>

    <p class="text-gray-300">HybridConsensus from DailyBFT. Our proof will proceed in the following steps.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>First, primarily in Lemma 2, Lemma 3, and Fact 4, we prove that when executing as a subprotocol of HybridConsensus, all instances of DailyBFT have a valid environment with overwhelming probability. Once we show this, we can henceforth rely on the the security properties of DailyBFT in the remainder of the proof.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Next, we prove a pair of lemmas that establishes  <span class="math">T_{\\text{stamp}}(R)</span>  as a &quot;deadline&quot; for each day R. All honest committee members' actions will have completed and taken effect by time  <span class="math">T_{\\text{stamp}}(R)</span> . Lemma 4 says, roughly, that all honest committee members for day R will have stamped a correct signed daily hash to snailchain by time  <span class="math">T_{\\text{stamp}}(R)</span> . Fact 5 says, roughly, that nodes which spawn later than  <span class="math">T_{\\text{stamp}}(R)</span>  will not create a DailyBFT(R) instance, but will rely on on-chain stamped daily log hashes to decide the R-th day's daily log.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Having established  <span class="math">T_{\\text{stamp}}(R)</span>  as a deadline for day R, we then prove consistency using the following strategy (Lemma 5 and Theorem 10):</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For nodes that actually created a  <span class="math">\\mathsf{DailyBFT}(R)</span>  instance, we know that they must have spawned before  <span class="math">T_{\\mathsf{stamp}}(R)</span> . We therefore rely on properties of  <span class="math">\\mathsf{DailyBFT}(R)</span>  to prove consistency for such nodes (committee member or non-member alike).</li>
      <li>For nodes that did not spawn a DailyBFT(R) instance, we show that they would satisfy consistency too if they recovered their daily log by examining what is stamped on the snailchain. Intuitively, committee members always stamp the correctly signed daily log hash on snailchain before they ever become corrupt. Therefore, even if they become corrupt later and can henceforth stamp arbitrary things onto snailchain, it will be too late since honest node only recognize the first stamped daily log hash for committee member's public key.</li>
    </ul></li>
    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Finally, we prove the liveness of hybrid consensus (Theorem <a href="#page-42-0">11)</a> roughly as follows. Informally, suppose the environment inputs tx to an honest node during day R (roughly speaking). There are two cases: 1) tx is proposed early enough in day R, such that the liveness property of the DailyBFT[R] instance applies; and 2) tx is proposed too late to be incorporated in day R's log since tx is closed very close to the end of day. In this case, tx will be rolled over to day R + 1. Intuitively since the DailyBFT[R] instance will terminate quickly, and by the liveness property of DailyBFT[R + 1], it also will not take too long before tx is incorporated into the log of day R + 1.</li>
    </ol>

    <p class="text-gray-300">The above, however, only applies to nodes who actually spawned a DailyBFT[R] (or DailyBFT[R+ 1]) instance. For any node that joins too late and did not spawn a DailyBFT[R] (or DailyBFT[R+ 1]), it will output some daily log for day R the moment they spawn by processing historical transcripts. Now, by the consistency property, we know that whatever daily log the late node outputs, it will contain tx as well.</p>

    <p class="text-gray-300">DailyBFT from BFT. The most technical part of this proof involves proving the following. Observe that when BFT is run as a subprotocol inside DailyBFT, the environment perceived by BFT is partially specified by the DailyBFT protocol. Recall that the environment for BFT needs to implement a signing oracle for BFT. When run inside DailyBFT as a subprotocol, the signing oracle is implemented by the DailyBFT protocol. By definition of the honest DailyBFT protocol, honest nodes never disclose their signature secret keys. For such an environment (of BFT), if the security properties specified in Section <a href="#page-23-0">4.2</a> can be broken by a p.p.t. adversary A, we can construct a reduction Re that breaks signature security.</p>

    <p class="text-gray-300">The above essentially allows us to prove that when BFT is run inside DailyBFT as a subprotocol instance, the environment for BFT is nice such that all of the stated security properties for BFT will hold except with negligible probability. The remainder of this proof henceforth relies on these properties of BFT to make arguments.</p>

    <p class="text-gray-300">Below we present our proofs for hybrid consensus over Nakamoto, and the proof for hybrid consensus over Fruitchain is the same except with altered parameters.</p>

      <h3 id="sec-8.1" class="text-xl font-semibold mt-8">8.1 Terminology and Simple Facts</h3>

    <p class="text-gray-300">Environment for a subprotocol. In an execution of the protocol HybridConsensus with A, Z, let (A, Z)[subprot[sid]] be the adversary/environment pair that subprotocol instance subprot[sid] interfaces with. (A, Z)[subprot[sid]] is defined by (A, Z) and the part of HybridConsensus outer to subprot[sid]. We also use the notation Z[subprot[sid]] to denote the environment that subprotocol instance subprot[sid] interfaces with. Recall that Figure <a href="#page-31-0">2</a> in Section <a href="#page-31-2">5.3</a> illustrates the modular composition of our HybridConsensus protocol.</p>

    <p class="text-gray-300">The following fact says that if DailyBFT's environment inputs some start(comm) where comm contains a pk output by a node i that is honest at time t &ge; Tstart, then node i must have output pk before Tstart. In other words, DailyBFT's environment cannot predict future pk pairs output by honest nodes. This simple fact is handy throughout, since whenever we say that some pk &isin; comm is output by an honest node i, this honest node is implicitly a committee member. Recall that by definition, for a node i to be considered a committee member, it must have output some pk &isin; comm prior to Tstart.</p>

    <p class="text-gray-300">Fact 1 (Unpredictability of public keys.). Assume that the signature scheme is secure, it must hold that for any p.p.t.  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  and any  <span class="math">\\lambda \\in \\mathbb{N}</span> , the following property holds for EXEC[DailyBFT] <span class="math">(\\mathcal{A}, \\mathcal{Z}, \\lambda)</span> , with  <span class="math">1 - \\mathsf{negl}(\\lambda)</span>  probability:</p>

    <p class="text-gray-300">If the  <span class="math">\\mathcal Z</span>  inputs to any honest node  <span class="math">\\operatorname{start}(\\operatorname{comm})</span> , and let i be a node that is honest at time  <span class="math">t \\geq T_{start}</span>  and moreover has output  <span class="math">\\operatorname{pk} \\in \\operatorname{comm}</span> , then it holds that node i is an honest committee member w.r.t. DailyBFT at time t, i.e., the aforementioned  <span class="math">\\operatorname{pk} \\in \\operatorname{comm}</span>  must be output by i before  <span class="math">T_{start}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Straightforward by the fact that a secure signature scheme must have high-entropy public keys.  <span class="math">\\Box</span></p>

    <p class="text-gray-300">Fact 2. For a secure signature scheme, polynomially many honestly generated public keys will not collide with  <span class="math">1 - \\text{negl}(\\lambda)</span>  probability.</p>

    <p class="text-gray-300">Therefore henceforth we simply assume that signature public keys generated by honest nodes do not collide.</p>

      <h3 id="sec-8.2" class="text-xl font-semibold mt-8">8.2 Hybrid Consensus Proofs</h3>

    <p class="text-gray-300"><strong>Times for notable events.</strong> Given Lemma 2, we know that for every polynomially bounded  <span class="math">R \\in N</span> ,  <span class="math">(\\mathcal{A}, \\mathcal{Z})[\\mathsf{DailyBFT}[R]]</span>  respects committee agreement. Therefore the notion of an honest committee member is well-defined for protocol instance  <span class="math">\\mathsf{DailyBFT}[R]</span> . For convenience, we explicitly define the following times for important events.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">T_{\\text{start}}(R)</span> : earliest time that an honest committee member inputs start to its DailyBFT[R] instance;</li>
      <li><span class="math">T_{\\text{stop}}(R)</span> : earliest time that an honest committee member inputs stop to its DailyBFT[R] instance.</li>
      <li><span class="math">T_{\\text{stamp}}(R) := T_{\\text{start}}(R) + \\lambda/G + T_{\\text{bft}} + \\delta + T_{\\text{snail}}</span> .</li>
    </ul>

    <p class="text-gray-300"><strong>Lemma 2</strong> (DailyBFT's environment satisfies committee agreement, close start and stop, and temporary static corruption). Let  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  be  <span class="math">(n, \\alpha, \\delta, \\tau)</span> -valid w.r.t. HybridConsensus for any  <span class="math">n \\in \\mathbb{N}, \\alpha &gt; 0</span> ,  <span class="math">\\delta &gt; 0</span> , and  <span class="math">\\tau &gt; 3\\lambda/G + T_{bft} + \\delta + T_{snail}</span>  such that snailchain satisfies consistency, Q-chain quality, and (G, G')-chain growth w.r.t.  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> [snailchain]. Then, for any  <span class="math">\\lambda \\in \\mathbb{N}</span> , the following properties hold for EXEC[HybridConsensus] <span class="math">(\\mathcal{A}, \\mathcal{Z}, \\lambda)</span>  with  <span class="math">1 - \\mathsf{negl}(\\lambda)</span>  probability:</p>

    <p class="text-gray-300">For any  <span class="math">R = \\mathsf{poly}(\\lambda) \\in \\mathbb{N}</span> ,  <span class="math">(\\mathcal{A}, \\mathcal{Z})[\\mathsf{DailyBFT}[R]]</span>  satisfies committee agreement, close start and stop, and temporary static corruption.</p>

    <p class="text-gray-300"><em>Proof.</em> Committee agreement follows in a straightforward manner from the definition of HybridConsensus and from the consistency property of snailchain.</p>

    <p class="text-gray-300">Close start and stop follows in a straightforward manner from the definition of HybridConsensus and from the consistent length property of snailchain (which is part of chain growth).</p>

    <p class="text-gray-300">Temporary static corruption follows in a straightforward manner from the definition of  <span class="math">T_{\\text{stamp}}(R)</span>  and the underlying  <span class="math">\\tau</span> -agile corruption model.</p>

    <p class="text-gray-300">Fact 3 (Bounded day length). Let  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  be  <span class="math">(n, \\alpha, \\delta, \\tau)</span> -valid w.r.t. HybridConsensus for any  <span class="math">n \\in \\mathbb{N}, \\alpha &gt; 0, \\delta &gt; 0</span> , and  <span class="math">\\tau \\geq 0</span>  such that snailchain satisfies consistency, Q-chain quality, and (G, G')-chain growth w.r.t.  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> [snailchain]. Then, for any  <span class="math">\\lambda \\in \\mathbb{N}</span> , the following holds for  <span class="math">\\mathrm{EXEC}[\\mathsf{HybridConsensus}](\\mathcal{A}, \\mathcal{Z}, \\lambda)</span>  with  <span class="math">1 - \\mathrm{negl}(\\lambda)</span>  probability:</p>

    <p class="text-gray-300"><span class="math">$2\\lambda/G&#x27; \\leq T_{start}(1) \\leq 2\\lambda/G,</span>$</p>

    <p class="text-gray-300"><span class="math">$\\forall R = \\mathsf{poly}(\\lambda) \\in \\mathbb{N} : T_{start}(R) + \\lambda/G&#x27; \\leq T_{stop}(R) = T_{start}(R+1) \\leq T_{start}(R) + \\lambda/G</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> For a  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  pair satisfying the above requirements, the following statements hold with  <span class="math">1 - \\mathsf{negl}(\\lambda)</span>  probability for EXEC[HybridConsensus] <span class="math">(\\mathcal{A}, \\mathcal{Z}, \\lambda)</span>  for any  <span class="math">\\lambda \\in \\mathbb{N}</span> .</p>

    <p class="text-gray-300">The fact that  <span class="math">T_{\\text{stop}}(R) = T_{\\text{start}}(R+1)</span>  follows in a straightforward manner from the definition of the honest HybridConsensus protocol, honest nodes send stop to DailyBFT[R-1] when their local chain length reaches  <span class="math">\\text{csize}R+\\lambda</span> . By (G,G')-chain growth, it follows that  <span class="math">T_{\\text{start}}(R) + \\lambda/G&#x27; \\leq T_{\\text{stop}}(R) = T_{\\text{start}}(R+1) \\leq T_{\\text{start}}(R) + \\text{csize}/G = T_{\\text{start}}(R) + \\lambda/G</span> . Similarly, by (G,G')-chain growth, it holds that  <span class="math">2\\lambda/G&#x27; \\leq T_{\\text{start}}(1) \\leq 2\\lambda/G</span> .</p>

    <p class="text-gray-300">Henceforth, we will assume that EXEC[HybridConsensus]( <span class="math">\\mathcal{A}, \\mathcal{Z}, \\lambda</span> ) will assert the bad events declared in Fact 1, Lemma 2, and Fact 3. If such bad events ever happen, the execution aborts. Since all these bad events occur with  <span class="math">\\mathsf{negl}(\\lambda)</span>  probability, the new execution with the bad events asserted is computationally indistinguishable to an ( <span class="math">\\mathcal{A}, \\mathcal{Z}</span> ) pair that satisfies the conditions specified in Fact 1, Lemma 2, and Fact 3.</p>

    <p class="text-gray-300">In particular, since we assume committee agreement, henceforth we will use the notation  <span class="math">\\mathsf{comm}_R</span>  to denote the globally agreed upon committee for the R-th day in any specific view in the support of  <span class="math">\\mathsf{EXEC}[\\mathsf{HybridConsensus}](\\mathcal{A}, \\mathcal{Z}, \\lambda)</span> .</p>

    <p class="text-gray-300"><strong>Lemma 3</strong> (Sufficiently many comm<sub>R</sub> members remain honest till  <span class="math">T_{\\text{stamp}}(R)</span> ). Let Q, G, G' be polynomially-bounded functions in  <span class="math">\\lambda, n, \\alpha, \\delta</span> . For any  <span class="math">T_{bft} &gt; 0</span> , and any constant  <span class="math">\\eta &gt; 0</span> , let  <span class="math">T_{snail} := (1 + \\eta)\\lambda/G</span> , let  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  be  <span class="math">(n, \\alpha, \\delta, \\tau)</span> -valid w.r.t. HybridConsensus for any  <span class="math">n \\in \\mathbb{N}, \\alpha &gt; 0, \\delta &gt; 0</span> , and  <span class="math">\\tau &gt; 3\\lambda/G + T_{bft} + \\delta + T_{snail}</span>  such that snailchain satisfies consistency, Q-chain quality, and (G, G')-chain growth w.r.t.  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> [snailchain]. Then, for any  <span class="math">\\lambda \\in \\mathbb{N}</span> , the following property holds for EXEC[HybridConsensus] <span class="math">(\\mathcal{A}, \\mathcal{Z}, \\lambda)</span>  with  <span class="math">1 - \\text{negl}(\\lambda)</span>  probability:</p>

    <p class="text-gray-300">For any  <span class="math">R = \\mathsf{poly}(\\lambda) \\in \\mathbb{N}</span> , at least Q fraction of  <span class="math">\\mathsf{comm}_R</span>  are output by nodes that remain honest till</p>

    <p class="text-gray-300"><span class="math">$T_{stamp}(R) := T_{start}(R) + \\lambda/G + T_{bft} + \\delta + T_{snail},</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> For a  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  pair satisfying the above requirements, the following statements hold with  <span class="math">1 - \\mathsf{negl}(\\lambda)</span>  probability for EXEC[HybridConsensus] <span class="math">(\\mathcal{A}, \\mathcal{Z}, \\lambda)</span>  for any  <span class="math">\\lambda \\in \\mathbb{N}</span> .</p>

    <p class="text-gray-300">Let chain be an honest node's local chain at any time s.t.  <span class="math">|\\mathsf{chain}| \\geq \\mathsf{upper}(R)</span> . By Q-chain quality and since  <span class="math">\\mathsf{csize} = \\lambda</span> , at least Q-fraction of  <span class="math">\\mathsf{chain}[\\mathsf{lower}(R), \\mathsf{upper}(R)]</span>  are intact blocks w.r.t.  <span class="math">\\mathsf{chain}[:\\mathsf{lower}(R)-1]</span> . This means that for at least Q fraction of indices  <span class="math">i \\in [\\mathsf{lower}(R), \\mathsf{upper}(R)]</span> , there exists a node j that was intact at some earlier time t, such that it output to  <span class="math">\\mathcal{Z}[\\mathsf{snailchain}]</span>   <span class="math">\\mathsf{chain}&#x27;</span>  that contains the prefix  <span class="math">\\mathsf{chain}[:\\mathsf{lower}(R)-1]</span>  at time t-1, and  <span class="math">\\mathcal{Z}[\\mathsf{snailchain}]</span>  provided input  <span class="math">\\mathsf{chain}[i] := (\\mathsf{recs}, \\mathsf{pk})</span>  to node j at time t. By definition of the HybridConsensus protocol,  <span class="math">\\mathsf{pk} \\in \\mathsf{comm}_R</span>  and  <span class="math">\\mathsf{pk}</span>  must be an output of some  <span class="math">\\mathsf{DailyBFT}[R]</span>  instance of node j at time t. Now due to (G, G')-chain growth, at most  <span class="math">(\\mathsf{csize} + \\lambda)/G = 2\\lambda/G</span>  time elapsed between t and  <span class="math">T_{\\mathsf{start}}(R)</span> . Finally, due to  <span class="math">\\tau &gt; (3\\lambda/G + T_{\\mathsf{bft}} + \\delta + T_{\\mathsf{snail}})</span> -agility, we have that node j remains honest till  <span class="math">T_{\\mathsf{stamp}}(R)</span> . Therefore, at least Q fraction of  <span class="math">\\mathsf{comm}_R</span>  are output by nodes that remain honest till  <span class="math">T_{\\mathsf{stamp}}(R)</span> .</p>

    <p class="text-gray-300">Next, we show that  <span class="math">T_{\\text{stamp}}(R)</span>  is chosen sufficiently far out to give enough time for all  <span class="math">\\text{comm}_R</span>  members' DailyBFT instances to output a final daily log (possibly empty) that is consistent with each other.</p>

    <p class="text-gray-300">Fact 4 (DailyBFT's environment is valid.). Let Q,G,G' be polynomially-bounded functions in  <span class="math">\\lambda, n, \\alpha, \\delta</span> . For any  <span class="math">T_{bft} &gt; 0</span> , and any constant  <span class="math">\\eta &gt; 0</span> , let  <span class="math">T_{snail} := (1+\\eta)\\lambda/G</span> , let  <span class="math">(\\mathcal{A},\\mathcal{Z})</span>  be  <span class="math">(n,\\alpha,\\delta,\\tau)</span> -valid w.r.t. HybridConsensus for any  <span class="math">n \\in \\mathbb{N}, \\alpha &gt; 0, \\delta &gt; 0</span> , and  <span class="math">\\tau &gt; 3\\lambda/G + T_{bft} + \\delta + T_{snail}</span>  such that snailchain satisfies consistency, Q-chain quality, and (G,G')-chain growth w.r.t.  <span class="math">(\\mathcal{A},\\mathcal{Z})</span> [snailchain].</p>

    <p class="text-gray-300">Then, for any  <span class="math">\\lambda \\in \\mathbb{N}</span> , with  <span class="math">1-\\text{negl}(\\lambda)</span>  probability, the following holds for EXEC[HybridConsensus]( <span class="math">\\mathcal{A}, \\mathcal{Z}, \\lambda</span> ):  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> [DailyBFT[R]] is  <span class="math">(n, Q, \\delta, \\tau, T_{stamp}(R), T_{bft})</span> -valid w.r.t. DailyBFT.</p>

    <p class="text-gray-300"><em>Proof.</em> Straightforward by combining Lemmas 2, 3 and Fact 3.</p>

    <p class="text-gray-300">Lemma 4 (Timely stamping). Let G, G', Q be polynomially-bounded functions in  <span class="math">\\lambda, n, \\alpha, \\delta</span> , Suppose that DailyBFT is secure against (1-Q)-corruption with liveness parameter  <span class="math">T_{bft}</span> . For any constant  <span class="math">\\eta &gt; 0</span> , let  <span class="math">T_{snail} := (1+\\eta)\\lambda/G</span> . Let  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  be  <span class="math">(n, \\alpha, \\delta, \\tau)</span> -valid w.r.t. HybridConsensus for some  <span class="math">n \\in \\mathbb{N}, \\alpha &gt; 0, \\delta &gt; 0</span> , and  <span class="math">\\tau &gt; 3\\lambda/G + T_{bft} + \\delta + T_{snail}</span>  such that snailchain satisfies consistency, Q-chain quality, and (G, G')-chain growth except w.r.t.  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> [snailchain]. Then, for any  <span class="math">\\lambda \\in \\mathbb{N}</span> , with  <span class="math">1 - \\text{negl}(\\lambda)</span>  probability, the following property holds for EXEC[HybridConsensus] <span class="math">(\\mathcal{A}, \\mathcal{Z}, \\lambda)</span>  and for any  <span class="math">R = \\text{poly}(\\lambda) \\in \\mathbb{N}</span> .</p>

    <p class="text-gray-300">Suppose that any honest node outputs a chain at time  <span class="math">t \\geq T_{stamp}(R)</span> . For any  <span class="math">pk \\in comm_R</span>  output by some node i that is honest at  <span class="math">T_{stamp}(R)</span> , let  <span class="math">h := hash(log_R)</span>  where  <span class="math">log_R</span>  represents the final log output by node i's DailyBFT[R] instance, then, a valid record of the form  <span class="math">\\{R,h\\}_{pk^{-1}}</span>  (where validity is defined by signature verification) is included in chain <span class="math">[:-\\lambda]</span> , and it is not preceded by any other valid record of the form  <span class="math">\\{R,h&#x27;\\}_{pk^{-1}}</span>  for a different  <span class="math">h&#x27; \\neq h</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> For a  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  pair satisfying the above requirements, the following statements hold with  <span class="math">1 - \\mathsf{negl}(\\lambda)</span>  probability for EXEC[HybridConsensus] <span class="math">(\\mathcal{A}, \\mathcal{Z}, \\lambda)</span>  for any  <span class="math">\\lambda \\in \\mathbb{N}</span> .</p>

    <p class="text-gray-300">Due to Fact 4,  <span class="math">(\\mathcal{A}, \\mathcal{Z})[\\mathsf{DailyBFT}[R]]</span>  is  <span class="math">(n, \\alpha, \\delta, \\tau, Q, T_{\\mathsf{stamp}}(R), T_{\\mathsf{bft}})</span> -valid w.r.t. DailyBFT. By Fact 1, for such a  <span class="math">\\mathsf{pk} \\in \\mathsf{comm}_R</span>  output by node i that is honest at time  <span class="math">T_{\\mathsf{stamp}}(R)</span> , node i is an honest committee member w.r.t. DailyBFT[R]. Therefore, by timely termination of DailyBFT, node i's DailyBFT[R] instance will have output some tuple  <span class="math">\\mathsf{done}(\\log,\\mathsf{recs})</span>  by time  <span class="math">T_{\\mathsf{stop}}(R) + T_{\\mathsf{bft}}</span> . By definition of honest HybridConsensus algorithm, node i will have called snailpool.propose(recs) by  <span class="math">T_{\\mathsf{stop}}(R) + T_{\\mathsf{bft}}</span> ; and by definition of the mempool protocol, every honest node's snailpool.TXs will contain recs by  <span class="math">T_{\\mathsf{stop}}(R) + T_{\\mathsf{bft}} + \\delta</span> . Therefore, starting at time  <span class="math">T_{\\mathsf{stop}}(R) + T_{\\mathsf{bft}} + \\delta</span> , in every time step,  <span class="math">\\mathcal{Z}[\\mathsf{snailchain}]</span>  will include recs in its input to snailchain for every honest node whose local chain <span class="math">[:-\\lambda]</span>  does not yet contain rec. By the liveness property of snailchain, any time after  <span class="math">T_{\\mathsf{stop}}(R) + T_{\\mathsf{bft}} + \\delta + T_{\\mathsf{snail}}</span> , recs will appear in every honest node's local chain <span class="math">[:-\\lambda]</span> . By the completeness property of the DailyBFT protocol,  <span class="math">\\{R, h\\}_{\\mathsf{pk}^{-1}} \\in \\mathsf{recs}</span> , where  <span class="math">h := \\mathsf{hash}(\\log)</span> . Finally, due to Fact 3,  <span class="math">T_{\\mathsf{stop}}(R) - T_{\\mathsf{start}}(R) &lt; \\lambda/G</span> . Therefore it holds that by time  <span class="math">T_{\\mathsf{stamp}}(R) = T_{\\mathsf{start}}(R) + \\lambda/G + T_{\\mathsf{bft}} + \\delta + T_{\\mathsf{snail}}</span> , every honest node's local chain <span class="math">[:-\\lambda]</span>  will contain  <span class="math">\\{R, \\mathsf{hash}(\\log)\\}_{\\mathsf{pk}^{-1}}</span> , where log is the final daily log output by node i's DailyBFT[R] instance.</p>

    <p class="text-gray-300">We now prove that such a tuple  <span class="math">\\operatorname{rec} := \\{R,h\\}_{\\mathsf{pk}^{-1}}</span>  is the first of its kind to appear in  <span class="math">\\operatorname{chain}[:-\\lambda]</span> , i.e., there is no other valid record of the form  <span class="math">\\operatorname{rec}&#x27; := \\{R,h&#x27;\\}_{\\mathsf{pk}^{-1}}</span>  where  <span class="math">h&#x27; \\neq h</span>  preceding rec in chain. We prove by contradition. Suppose there is such a tuple  <span class="math">\\operatorname{rec}&#x27;</span>  preceding rec in  <span class="math">\\operatorname{chain}[:-\\lambda]</span> . Since rec must have appeared in  <span class="math">\\operatorname{chain}[:-\\lambda]</span>  at time  <span class="math">T_{\\mathsf{stamp}}</span> , due to the consistency property of  <span class="math">\\mathsf{snailchain}</span> , so must  <span class="math">\\mathsf{rec}&#x27;</span> . However, by the definition of the honest  <span class="math">\\mathsf{DailyBFT}</span>  algorithm, an honest node should not have output two different  <span class="math">\\mathsf{done}(\\_,\\_)</span>  messages with different final logs. Therefore, if  <span class="math">\\mathsf{rec}&#x27;</span>  appears in an honest node's  <span class="math">\\mathsf{chain}[:-\\lambda]</span>  by time  <span class="math">T_{\\mathsf{stamp}}</span> , this would obviously violate the unforgeability property of  <span class="math">\\mathsf{DailyBFT}</span> .</p>

    <p class="text-gray-300">Fact 5 (No late spawning of DailyBFT). Let G, G', Q be polynomially-bounded functions in  <span class="math">\\lambda, n, \\alpha, \\delta</span> , Suppose that DailyBFT is secure against (1-Q)-corruption with liveness parameter  <span class="math">T_{bft}</span> . For any</p>

    <p class="text-gray-300">constant  <span class="math">\\eta &gt; 0</span> , let  <span class="math">T_{snail} := (1 + \\eta)\\lambda/G</span> . Let  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  be  <span class="math">(n, \\alpha, \\delta, \\tau)</span> -valid w.r.t. HybridConsensus for some  <span class="math">n \\in \\mathbb{N}, \\alpha &gt; 0, \\delta &gt; 0</span> , and  <span class="math">\\tau &gt; 3\\lambda/G + T_{bft} + \\delta + T_{snail}</span>  such that snailchain satisfies consistency, Q-chain quality, and (G, G')-chain growth w.r.t.  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> [snailchain]. Then, for any  <span class="math">\\lambda \\in \\mathbb{N}</span> , with  <span class="math">1 - \\text{negl}(\\lambda)</span>  probability, the following property holds for EXEC[HybridConsensus] <span class="math">(\\mathcal{A}, \\mathcal{Z}, \\lambda)</span>  and for any  <span class="math">R = \\text{poly}(\\lambda) \\in \\mathbb{N}</span> .</p>

    <p class="text-gray-300">An honest node only forks an DailyBFT[R] instance if it spawns by time  <span class="math">T_{stamp}(R)</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Straightforward by the definition of the HybridConsensus algorithm and Lemma 4.  <span class="math">\\Box</span></p>

    <p class="text-gray-300">Lemma 5 (Retroactive consistency). Let  <span class="math">Q&gt;\\frac{2}{3}</span> , let G,G' be polynomially-bounded functions in  <span class="math">\\lambda, n, \\alpha, \\delta</span> . Suppose that DailyBFT is secure against (1-Q)-corruption with liveness parameter  <span class="math">T_{bft}</span> . For any constant  <span class="math">\\eta&gt;0</span> , let  <span class="math">T_{snail}:=(1+\\eta)\\lambda/G</span> , let  <span class="math">(\\mathcal{A},\\mathcal{Z})</span>  be  <span class="math">(n,\\alpha,\\delta,\\tau)</span> -valid w.r.t. HybridConsensus for some  <span class="math">n\\in\\mathbb{N}, \\alpha&gt;0, \\delta&gt;0</span> , and  <span class="math">\\tau&gt;3\\lambda/G+T_{bft}+\\delta+T_{snail}</span>  such that snailchain satisfies consistency, Q-chain quality, and (G,G')-chain growth w.r.t.  <span class="math">(\\mathcal{A},\\mathcal{Z})</span> [snailchain]. Then, for any  <span class="math">\\lambda\\in\\mathbb{N}</span> , with  <span class="math">1-\\text{negl}(\\lambda)</span>  probability, the following property holds for EXEC[HybridConsensus] <span class="math">(\\mathcal{A},\\mathcal{Z},\\lambda)</span>  and for any  <span class="math">R=\\text{poly}(\\lambda)\\in\\mathbb{N}</span> .</p>

    <p class="text-gray-300">Let chain denote the output of an honest node at any time. Suppose that (R,h) is an on-chain valid tuple w.r.t. chain, it holds that there exists a  <span class="math">pk \\in comm_R</span>  output by a node i that is honest at  <span class="math">T_{stamp}(R)</span> , and  <span class="math">h = hash(log_R)</span>  where  <span class="math">log_R</span>  is the (unique) final daily log output by node i's  <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span>   <span class="math">log_R</span></p>

    <p class="text-gray-300"><em>Proof.</em> For a (A, Z) pair satisfying the above requirements, the following statements hold with  <span class="math">1 - \\mathsf{negl}(\\lambda)</span>  probability for EXEC[HybridConsensus] <span class="math">(A, Z, \\lambda)</span>  for any  <span class="math">\\lambda \\in \\mathbb{N}</span> .</p>

    <p class="text-gray-300">For (R,h) to be a valid on-chain tuple w.r.t. chain, for at least  <span class="math">\\lceil \\text{csize}/3 \\rceil</span>  number of  <span class="math">pk \\in \\text{comm}_R</span> : 1) a correctly signed tuple  <span class="math">\\{R,h\\}_{pk^{-1}}</span>  must appear in  <span class="math">\\text{chain}[:-\\lambda]</span> ; and 2) this tuple is the first occurrence of any valid tuple of the form  <span class="math">\\{R,\\_\\}_{pk^{-1}}</span>  on chain.</p>

    <p class="text-gray-300">By Fact 4, at least Q fraction of  <span class="math">\\mathsf{comm}_R</span>  were output by nodes that are honest at time  <span class="math">T_{\\mathsf{stamp}}(R)</span> . By assumption  <span class="math">Q &gt; \\frac{2}{3}</span> , and due to the pigeon-hole principle, for at least one such signature signed by some public key  <span class="math">\\mathsf{pk}</span> , it must hold that it is output by a node i (prior to  <span class="math">T_{\\mathsf{start}}(R)</span> ) that remains honest till  <span class="math">T_{\\mathsf{stamp}}(R)</span> . By Lemma 4, this signature must vouch for  <span class="math">(R, \\mathsf{hash}(\\mathsf{log}))</span>  where  <span class="math">\\mathsf{log}</span>  denotes the (unique) final log output by node i.</p>

    <p class="text-gray-300"><strong>Theorem 10</strong> (Consistency for Hybrid Consensus). Suppose that hash,  <span class="math">H:\\{0,1\\}^* \\to \\{0,1\\}^{\\lambda}</span>  are independent random oracles, and that the signature scheme  <span class="math">\\Sigma</span>  is secure. Let  <span class="math">Q&gt;\\frac{2}{3}</span> , let G,G' be polynomially bounded functions in  <span class="math">\\lambda, n, \\alpha, \\delta</span> . Suppose that DailyBFT is secure against (1-Q)-corruption with liveness parameter  <span class="math">T_{bft}</span> . For any constant  <span class="math">\\eta&gt;0</span> , let  <span class="math">T_{snail}:=(1+\\eta)\\lambda/G</span> . Let  <span class="math">(\\mathcal{A},\\mathcal{Z})</span>  be  <span class="math">(n,\\alpha,\\delta,\\tau)</span> -valid w.r.t. HybridConsensus for some  <span class="math">n\\in\\mathbb{N},\\alpha&gt;0,\\delta&gt;0</span> , and  <span class="math">\\tau&gt;3\\lambda/G+T_{bft}+\\delta+T_{snail}</span>  such that snailchain satisfies consistency, Q-chain quality, and (G,G')-chain growth w.r.t.  <span class="math">(\\mathcal{A},\\mathcal{Z})</span> [snailchain]. Then, for any  <span class="math">\\lambda\\in\\mathbb{N}</span> , with  <span class="math">1-\\text{negl}(\\lambda)</span>  probability,  <span class="math">\\text{EXEC}[\\text{HybridConsensus}](\\mathcal{A},\\mathcal{Z},\\lambda)</span>  satisfies consistency as defined in Section 3.2.</p>

    <p class="text-gray-300"><em>Proof.</em> Self-consistency holds trivially from the definition of HybridConsensus. Below we focus on proving common prefix. For a  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  pair satisfying the above requirements, the following statements hold with  <span class="math">1 - \\mathsf{negl}(\\lambda)</span>  probability for  <span class="math">\\mathsf{EXEC}[\\mathsf{HybridConsensus}](\\mathcal{A}, \\mathcal{Z}, \\lambda)</span>  for any  <span class="math">\\lambda \\in \\mathbb{N}</span> .</p>

    <p class="text-gray-300">By definition of the honest HybridConsensus algorithm, we can parse an honest node's LOG as the following for some  <span class="math">R \\in \\mathbb{N}</span> :</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{LOG} := \\mathsf{log}_1 ||\\mathsf{log}_2|| \\dots ||\\mathsf{log}_{R-1}||\\mathsf{log}_R</span>$</p>

    <p class="text-gray-300">For each  <span class="math">\\log_r</span>  where  <span class="math">r \\in [R]</span> , it can be one of the following cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Final log of daily offchain consensus.  <span class="math">\\log_r</span>  is the final log output by a DailyBFT[r] instance. By Fact 5, it holds that this node spawned before  <span class="math">T_{\\text{stamp}}(r)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Non-final log of daily offchain consensus.  <span class="math">\\log_r</span>  is contained in an output of a DailyBFT[r] instance, where the output is in the form of  <span class="math">notdone(\\log_r)</span>  in this case, by definition of the honest HybridConsensus algorithm, it must be the case that  <span class="math">\\log_r</span>  is the last daily log included in LOG. Further, by Fact 5, it holds that this node spawned before  <span class="math">T_{\\text{stamp}}(r)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Matching on-chain valid tuple. There is an on-chain valid tuple (r,h) w.r.t. the honest node's local chain <span class="math">[:-\\lambda]</span>  such that  <span class="math">\\mathsf{hash}(\\mathsf{log}_r) = h</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">First, note that if an honest node i's  <span class="math">\\mathsf{DailyBFT}[r]</span>  instance outputs  <span class="math">\\mathsf{log}_r</span>  due to 1, and an honest node j's  <span class="math">\\mathsf{DailyBFT}[r]</span>  instance (same or different), outputs  <span class="math">\\mathsf{log}_r&#x27;</span>  due to 1, it must hold that  <span class="math">\\mathsf{log}_r = \\mathsf{log}_r&#x27;</span> . This is straightforward by the consistency property of  <span class="math">\\mathsf{DailyBFT}</span> .</p>

    <p class="text-gray-300">Second, note that if an honest node i's  <span class="math">\\mathsf{DailyBFT}[r]</span>  instance outputs  <span class="math">\\mathsf{log}_r</span>  due to 1, and an honest node j's  <span class="math">\\mathsf{DailyBFT}[r]</span>  instance (same or different), outputs  <span class="math">\\mathsf{log}_r&#x27;</span>  due to 2, then it must hold that  <span class="math">\\mathsf{log}_r&#x27; \\prec \\mathsf{log}_r</span> . This follows immediately from the consistency property of  <span class="math">\\mathsf{DailyBFT}</span> .</p>

    <p class="text-gray-300">Next, if an honest node j (same or different), outputs  <span class="math">\\log_r&#x27;</span>  due to 3, there must exist an honest node i that outputs  <span class="math">\\log_r</span>  due to 1, such that  <span class="math">\\log_r = \\log_r&#x27;</span> . This follows directly from Lemma 5, as well as the fact that the hash oracle has negligible probability of collision.</p>

    <p class="text-gray-300">The rest of the proof follows in a straightforward manner, by observing that day lengths are polynomially bounded in  <span class="math">\\lambda</span>  due to Fact 3; and that for all  <span class="math">r = \\operatorname{poly}(\\lambda) \\in \\mathbb{N}</span> , at least at least one  <span class="math">\\operatorname{pk} \\in \\operatorname{comm}_r</span>  is honest at  <span class="math">T_{\\operatorname{stamp}}(r)</span>  and will have output  <span class="math">\\operatorname{done}(\\underline{\\ },\\underline{\\ })</span>  by time  <span class="math">T_{\\operatorname{stamp}}(r)</span> .</p>

    <p class="text-gray-300"><strong>Theorem 11</strong> (Liveness for Hybrid Consensus). Suppose that hash,  <span class="math">\\mathsf{H}:\\{0,1\\}^* \\to \\{0,1\\}^\\lambda</span>  are independent random oracles, and that the signature scheme  <span class="math">\\Sigma</span>  is secure. Let  <span class="math">Q &gt; \\frac{2}{3}</span> , let G be a function in  <span class="math">\\lambda, n, \\alpha, \\delta</span> . Suppose that DailyBFT is secure against (1-Q)-corruption with liveness parameter  <span class="math">T_{bft}</span> . For any constant  <span class="math">\\eta &gt; 0</span> , let  <span class="math">T_{snail} := (1+\\eta)\\lambda/G</span> . Let  <span class="math">(\\mathcal{A},\\mathcal{Z})</span>  be  <span class="math">(n,\\alpha,\\delta,\\tau)</span> -valid w.r.t. HybridConsensus for some  <span class="math">n \\in \\mathbb{N}, \\alpha &gt; 0, \\delta &gt; 0</span> , and  <span class="math">\\tau &gt; 3\\lambda/G + T_{bft} + \\delta + T_{snail}</span>  such that snailchain satisfies consistency, Q-chain quality, and (G,G')-chain growth w.r.t.  <span class="math">(\\mathcal{A},\\mathcal{Z})</span> [snailchain] for some  <span class="math">G&#x27; &lt; \\frac{\\lambda}{T_{bft} + \\delta}</span> . Then, for any  <span class="math">\\lambda \\in \\mathbb{N}</span> , with  <span class="math">1 - \\mathsf{negl}(\\lambda)</span>  probability,  <span class="math">\\mathsf{EXEC}[\\mathsf{HybridConsensus}](\\mathcal{A},\\mathcal{Z},\\lambda)</span>  satisfies liveness as defined in Section 3.2 with parameters  <span class="math">T_{warmup} := 2\\lambda/G</span> , and  <span class="math">T_{confirm} := 2T_{bft} + 2\\delta</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> For a  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  pair satisfying the above requirements, the following statements hold with  <span class="math">1 - \\mathsf{negl}(\\lambda)</span>  probability for EXEC[HybridConsensus] <span class="math">(\\mathcal{A}, \\mathcal{Z}, \\lambda)</span>  for any  <span class="math">\\lambda \\in \\mathbb{N}</span> .</p>

    <p class="text-gray-300">Suppose that  <span class="math">\\mathcal{Z}</span>  inputs TXs to some honest node at time  <span class="math">t \\geq T_{\\text{warmup}} = 2\\lambda/G</span> . By definition of the txpool protocol, at time  <span class="math">t + \\delta</span> , all honest nodes have TXs  <span class="math">\\subseteq</span>  txpool.TXs. Suppose that an honest node i is honest at some time  <span class="math">t&#x27; \\geq t + T_{\\text{confirm}} = t + 2T_{\\text{bft}} + 2\\delta</span> , and we show that node i's output LOG at time t' must include all of TXs.</p>

    <p class="text-gray-300">By Fact 3, and the fact that  <span class="math">G&#x27; &gt; \\frac{\\lambda}{T_{\\text{bft}} + \\delta}</span> ,  <span class="math">T_{\\text{start}}(1) \\leq 2\\lambda/G = T_{\\text{warmup}}</span> . Further, for any  <span class="math">R \\in \\mathbb{N}</span> ,  <span class="math">T_{\\text{start}}(R) &lt; T_{\\text{stop}}(R) - T_{\\text{bft}} - \\delta &lt; T_{\\text{start}}(R+1)</span> . Let R be the <em>smallest</em> integer such that  <span class="math">t \\leq T_{\\text{stop}}(R) - T_{\\text{bft}} - \\delta</span> . Now, one of the following two cases has to be true:</p>

    <p class="text-gray-300">&bull; Case 1:  <span class="math">t \\ge T_{\\text{start}}(R) = T_{\\text{stop}}(R-1)</span> .</p>

    <p class="text-gray-300">In this case, by definition of HybridConsensus and Fact 4, there exists an honest  <span class="math">\\mathsf{comm}_R</span>  member whose  <span class="math">\\mathcal{Z}[\\mathsf{DailyBFT}[R]]</span>  will include TXs\\LOG to in its input to  <span class="math">\\mathsf{DailyBFT}[R]</span>  by  <span class="math">t+\\delta &lt; T_{\\mathrm{stop}}(R) - T_{\\mathrm{bft}}</span> .</p>

    <p class="text-gray-300">&bull; Case 2:  <span class="math">T_{\\text{stop}}(R-1) - T_{\\text{bft}} - \\delta &lt; t &lt; T_{\\text{stop}}(R-1) = T_{\\text{start}}(R) &lt; T_{\\text{stop}}(R) - T_{\\text{bft}}</span></p>

    <p class="text-gray-300">In this case, by definition of HybridConsensus and Fact 4, there exists an honest  <span class="math">\\mathsf{comm}_R</span>  member whose  <span class="math">\\mathcal{Z}[\\mathsf{DailyBFT}[R]]</span>  will include TXs\\LOG to in its input to  <span class="math">\\mathsf{DailyBFT}[R]</span>  by  <span class="math">T_{\\mathsf{start}}(R) &lt; t + T_{\\mathsf{bft}} + \\delta</span> .</p>

    <p class="text-gray-300">Therefore, in either case, there exists an honest  <span class="math">\\mathsf{comm}_R</span>  member whose  <span class="math">\\mathcal{Z}[\\mathsf{DailyBFT}[R]]</span>  will include  <span class="math">\\mathsf{TXs}\\setminus\\mathsf{LOG}</span>  to in its input to  <span class="math">\\mathsf{DailyBFT}[R]</span>  by at time  <span class="math">t^* &lt; t + T_{\\mathrm{bft}} + \\delta</span>  such that  <span class="math">T_{\\mathrm{start}}(R) \\le t^* &lt; T_{\\mathrm{stop}}(R) - T_{\\mathrm{bft}}</span> . Henceforth let the  <span class="math">\\mathsf{LOG}^*</span>  denote the output  <span class="math">\\mathsf{LOG}</span>  of this committee member at time  <span class="math">t^*</span> .</p>

    <p class="text-gray-300">&bull; We first show that if node i ever forked a DailyBFT[R] instance, and is honest at time  <span class="math">t&#x27; \\ge t + 2T_{\\rm bft} + 2\\delta</span> , then node i's output LOG at time t' will include all of TXs.</p>

    <p class="text-gray-300">By Fact 5, if a node i forked a DailyBFT[R] instance, its  <span class="math">t_{\\rm spawn} \\leq T_{\\rm stamp}(R)</span> . By the liveness property of the DailyBFT protocol and Fact 4, if node i is honest at time  <span class="math">t&#x27; \\geq t + 2T_{\\rm bft} + 2\\delta</span> , then by t' node i's DailyBFT[R] instance must have output done(log <span class="math">_R</span> ,  <span class="math">_-</span> ) such that TXs\\LOG*  <span class="math">\\subseteq</span>  log <span class="math">_R</span> . Now, for any  <span class="math">1 \\leq r \\leq R-1</span> , by definition of the honest HybridConsensus protocol, either node i did not fork a DailyBFT[r] instance and log <span class="math">_r</span>  was computed during Preprocess (see Figure 4); or node i did fork a DailyBFT[r] instance. In the latter case, we know that node i forked by  <span class="math">T_{\\rm stamp}(r)</span>  due to Fact 5. By Fact 4 and the timely termination property of the the DailyBFT protocol, if node i is honest at time  <span class="math">t&#x27; \\geq t + 2T_{\\rm bft} + 2\\delta</span> , node i's DailyBFT[r] instance will have output done</p>

    <p class="text-gray-300">By the definition of the honest HybridConsensus protocol, if node i' is honest at time  <span class="math">t&#x27; \\geq t + 2T_{\\rm bft} + 2\\delta</span> , its output LOG will contain all of TXs\\LOG* at time t'.</p>

    <p class="text-gray-300">&bull; Now, consider the case when node i did not fork a DailyBFT[R] instance. In this case, node i must have computed  <span class="math">\\log_R</span>  by matching on-chain valid tuples, and  <span class="math">\\log_R</span>  is output in time  <span class="math">t_{\\text{spawn}}</span> .</p>

    <p class="text-gray-300">Due to the Fact 4, there must exist at least one  <span class="math">\\mathsf{pk} \\in \\mathsf{comm}_R</span>  output by some node  <span class="math">\\nu</span>  that is honest at time  <span class="math">T_{\\mathsf{stamp}}(R)</span> , and by the timely termination property of  <span class="math">\\mathsf{DailyBFT}</span> , node  <span class="math">\\nu</span> 's  <span class="math">\\mathsf{DailyBFT}[R]</span>  instance will output  <span class="math">\\mathsf{log}_R</span>  during the time it is honest. By the liveness property of  <span class="math">\\mathsf{DailyBFT}</span> , this final  <span class="math">\\mathsf{log} \\mathsf{log}_R</span>  output by node  <span class="math">\\nu</span>  must include all of  <span class="math">\\mathsf{TXs} \\backslash \\mathsf{LOG}^*</span> .</p>

    <p class="text-gray-300">Due to Theorem 10, the  <span class="math">\\log_R</span>  output by node i must be the same as that output by node  <span class="math">\\nu</span> 's DailyBFT[R] instance, and thus must include all of TXs\\LOG* as well.</p>

    <p class="text-gray-300">Finally, due to the consistency property of HybridConsensus, for any node that is honest at time  <span class="math">t&#x27; \\geq t + 2T_{\\rm bft} + 2\\delta &gt; t^*</span>  let LOG be its output at time t', then it holds that either LOG*  <span class="math">\\prec</span>  LOG or LOG  <span class="math">\\prec</span>  LOG*. However, since TXs\\LOG*  <span class="math">\\subseteq</span>  LOG, it must be the case that LOG*  <span class="math">\\prec</span>  LOG. Therefore we conclude that TXs  <span class="math">\\subseteq</span>  LOG.</p>

      <h3 id="sec-8.3" class="text-xl font-semibold mt-8">8.3 Daily Offchain Consensus Proofs</h3>

    <p class="text-gray-300">by time t'.</p>

    <p class="text-gray-300">In some view, suppose that (A, Z) is an adversary/environment pair for the protocol DailyBFT, we use the notation (A, Z)[BFT] to denote the adversary/environment pair that interfaces with a BFT subprotocol instance. (A, Z)[BFT] is jointly defined by (A, Z) as well as the honest DailyBFT protocol. Notice that upon corruption of a node i, Z[BFT] reveals to A[BFT] all public/secret keys of all BFT instances running on node i.</p>

    <p class="text-gray-300"><strong>Lemma 6</strong> (BFT security within the context of DailyBFT). If BFT is strongly secure against (1-Q) corruption and with liveness parameter  <span class="math">T_{bft}</span>  by Definition 5, and further BFT is instantiated with a secure signature scheme  <span class="math">\\Sigma</span> , then for any  <span class="math">n, \\delta, T_{stamp} &gt; 0</span> ,  <span class="math">\\tau \\geq 0</span> , for any p.p.t.  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  that is</p>

    <p class="text-gray-300">(n, Q, &delta;, &tau;, Tstamp, Tbft)-valid w.r.t. DailyBFT, there exists a negligible function negl such that for any &lambda; &isin; N,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathsf{view} \\leftarrow \\mathsf{EXEC}[\\mathsf{DailyBFT}](\\mathcal{A}, \\mathcal{Z}, \\lambda) : \\ \\mathsf{secure}^{T_{bft}}(\\mathsf{view}) = 1\\right] \\geq 1 - \\mathsf{negl}(\\lambda)</span>$</p>

    <p class="text-gray-300">where secureTbft(view) is as defined as in Section <a href="#page-23-0">4.2</a> &mdash; but replace any occurrence of &quot;an honest node&quot; with &quot;an honest BFT virtual node&quot;.</p>

    <p class="text-gray-300">Proof. We construct a p.p.t. reduction Re as below.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The reduction Re interacts with a signature challenger &Sigma;<sup>&lowast;</sup> , and obtains a signature public key denoted pk<sup>&lowast;</sup> upfront. Henceforth we refer to pk<sup>&lowast;</sup> as the challenge public key.</li>
      <li>The reduction Re will simulate in its head all honest nodes running DailyBFT. When some honest node's BFT virtual node asks for keygen, Re flips a random coin, and with probability 1/n, it will return the challenge public key pk<sup>&lowast;</sup> ; otherwise, the reduction Re generates the signing key pair using the honest algorithm. Therefore, the reduction Re knows all secret signing keys except for the coordinate where the challenge public key pk<sup>&lowast;</sup> is embedded. Whenever an honest node's BFT virtual node issues a sign query for the challenge public key pk<sup>&lowast;</sup> , Re simply forwards the query to the signature challenger.</li>
      <li>The reduction Re interacts with the environment Z. Whenever Z inputs anything to honest nodes, Re simply forwards the message to the corresponding honest node being simulated in its head. Whenever a simulated honest node needs to output anything to Z, the reduction Re simply forwards the message. Similarly, the reduction Re also forwards any messages between Z and A.</li>
    </ul>

    <p class="text-gray-300">Now, if an honest node becomes corrupt at some point, Re needs to return the node's private state to Z. As long as the corrupt node is not the one where pk<sup>&lowast;</sup> is embedded, the reduction Re can successfully simulate. If the corrupt node happens to be where pk<sup>&lowast;</sup> is embedded, the reduction simply aborts. It is obvious that the probability that the reduction does not abort is non-negligible.</p>

    <p class="text-gray-300">It is obvious that conditioned on the event that the reduction Re does not abort, the reduction's interfaces to (A, Z) are identically distributed as a real execution of the DailyBFT protocol.</p>

    <p class="text-gray-300">It is not hard to see that if (A, Z) is (n, Q, &delta;, &tau;, Tstamp, Tbft)-valid w.r.t. DailyBFT, then with 1 &minus; negl(&lambda;) probability, (A, Z)[BFT] is (n, Q, &delta;, &tau;, Tstamp)-valid w.r.t. BFT. In particular, honestly generated public keys using the &Sigma;.Gen(1<sup>&lambda;</sup> ) algorithm have negl(&lambda;) probability of collision, since otherwise the signature scheme can easily be broken.</p>

    <p class="text-gray-300">For the sake of a contradition, suppose that the lemma is not true, i.e., there exists some polynomial g and p.p.t. (A, Z) that is (n, Q, &delta;, &tau;, Tstamp, Tbft)-valid w.r.t. DailyBFT such that</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathsf{view} \\leftarrow \\mathsf{EXEC}[\\mathsf{DailyBFT}](\\mathcal{A}, \\mathcal{Z}, \\lambda) : \\ \\mathsf{secure}^{T_{\\mathrm{bft}}}(\\mathsf{view}) \\neq 1\\right] \\geq g(\\lambda)</span>$</p>

    <p class="text-gray-300">where secureTbft (view) is defined just like in Section <a href="#page-23-0">4.2,</a> but with respect to the virtual BFT nodes inside DailyBFT. By definition of strong security (see Definition <a href="#page-25-0">5)</a>, we know that there exists a p.p.t. adversary B and polynomial g 0 such that</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathsf{view} \\leftarrow \\mathsf{EXEC}[\\mathsf{DailyBFT}](\\mathcal{B}, \\mathcal{Z}, \\lambda) : \\ \\mathsf{forgery}(\\mathsf{view}) = 1\\right] \\geq g&#x27;(\\lambda)</span>$</p>

    <p class="text-gray-300">Now, consider an execution where the reduction Re is interacting with (B, Z). As mentioned earlier, as long as the execution does not abort, the execution is identically distributed as a real execution from the perspectives of (B, Z). Therefore, with non-negligible probability, B will output to Re some forgery, and if the forgery happens to be for pk<sup>&lowast;</sup> which happens with non-negligible probability, the reduction Re will have found a forgery to the signature scheme.</p>

    <p class="text-gray-300"><strong>Theorem 12</strong> (DailyBFT from BFT, restatement of Theorem 7). Suppose that the signature scheme  <span class="math">\\Sigma</span>  employed by DailyBFT is secure, and that hash is a random oracle. Suppose that BFT is secure against (1-Q)-corruption with liveness parameter  <span class="math">T_{bft}&#x27;</span>  for  <span class="math">Q&gt;\\frac{2}{3}</span> . Then, DailyBFT is secure against (1-Q)-corruption with liveness parameter  <span class="math">T_{bft}:=T_{bft}&#x27;+\\delta</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> For any  <span class="math">n, \\delta, T_{\\text{stamp}} &gt; 0</span> , any  <span class="math">\\tau \\geq 0</span> , for any  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  that is  <span class="math">(n, Q, \\delta, \\tau, T_{\\text{stamp}}, T_{\\text{bft}})</span> -valid w.r.t. DailyBFT, the following properties hold for EXEC[DailyBFT] <span class="math">(\\mathcal{A}, \\mathcal{Z}, \\lambda)</span>  except with negligible probability:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Timely termination. Since the environment of BFT respects close stop, all BFT virtual nodes receive stop by  <span class="math">T_{\\text{stop}} + \\delta</span> . By the liveness property of BFT, and definition of DailyBFT, all honest committee members that remain honest till  <span class="math">T_{\\text{stop}} + T_{\\text{bft}}&#x27; + \\delta = T_{\\text{stop}} + T_{\\text{bft}}</span>  will have in their log by time  <span class="math">T_{\\text{stop}} + T_{\\text{bft}}</span> , stop transactions signed by  <span class="math">\\lceil |\\text{comm}|/3 \\rceil</span>  distinct public keys in comm. When this happens, by definition of DailyBFT honest committee members gossip the signed hash of their daily log, and output  <span class="math">\\text{done}(\\_,\\_)</span> . Since at least  <span class="math">Q &gt; \\frac{2}{3}</span>  fraction of comm were output by committee members that remain honest till  <span class="math">T_{\\text{stamp}} &gt; T_{\\text{stop}} + T_{\\text{bft}}</span> , it is not hard to see that if a committee non-member is honest at time  <span class="math">T_{\\text{stop}} + T_{\\text{bft}} + \\delta</span> , it will have collected enough signatures and will have output  <span class="math">\\text{done}(\\_,\\_)</span> .</li>
      <li>Consistency.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Self-consistency. Self-consistency is obvious by definition of DailyBFT.</li>
      <li>Termination agreement. By definition, DailyBFT an honest committee member simply outputs the same final log as the final log output by the inner BFT<sub>0</sub> virtual node (with stop transactions removed). By the consistency property of the underlying BFT, if an honest committee member i's BFT outputs log at some time  <span class="math">t &lt; T_{\\text{stamp}}</span> , and an honest committee member j's BFT outputs log' at some time  <span class="math">t&#x27; &lt; T_{\\text{stamp}}</span> , it must hold that  <span class="math">\\log \\prec \\log&#x27;</span>  or  <span class="math">\\log \\prec \\log&#x27;</span> .</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">If both node i and j spawned before  <span class="math">T_{\\text{stamp}}</span>  and output  <span class="math">done(\\_,\\_)</span>  while they are still honest, then  <span class="math">done(\\_,\\_)</span>  must be output no later than  <span class="math">T_{\\text{stamp}}</span> . By the definition of the honest DailyBFT algorithm, it must be the case they output identical daily logs upon termination.</p>

    <p class="text-gray-300">We now extend the termination agreement proof to committee non-members who spawned before  <span class="math">T_{\\text{stamp}}</span> . This will rely on the security of the signature scheme. Suppose that some committee non-member k spawned before  <span class="math">T_{\\text{stamp}}</span> , and outputs  <span class="math">\\text{done}(\\log^*, \\_)</span>  at some time at which it is honest. It must be the case that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">done(log^*, \\_)</span>  is output by time  <span class="math">T_{stamp}</span>  due to the timely termination property;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\log^*</span>  can be parsed as</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\log^* = tx_1^* || tx_2^* || \\dots tx_{\\ell^*}^*</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For each  <span class="math">(R, i, \\mathsf{tx}_i)</span>  where  <span class="math">i \\in [\\ell^*]</span> , and for the tuple  <span class="math">(R, \\ell)</span>  where R is the session identifier, node k has received valid signatures signed by at least  <span class="math">\\lceil \\frac{1}{3} |\\mathsf{comm}| \\rceil</span>  number of distinct public keys in comm.</li>
    </ol>

    <p class="text-gray-300">Due to the fact that that at least Q fraction of comm are output by committee members which are honest at  <span class="math">T_{\\text{stamp}}</span> , and by the pigeonhole principle, at least one valid signature on each tuple  <span class="math">(R, i, \\mathsf{tx}_i)</span>  or the tuple  <span class="math">(R, \\ell^*)</span>  is by  <span class="math">\\mathsf{pk} \\in \\mathsf{comm}</span>  output by a node  <span class="math">\\nu</span>  that remains honest till  <span class="math">T_{\\text{stamp}}</span> . As mentioned earlier, honest committee members output identical final daily logs, henceforth denoted  <span class="math">\\mathsf{log}</span> . Parse  <span class="math">\\mathsf{log} := \\mathsf{tx}_1 || \\dots || \\mathsf{tx}_\\ell</span> .</p>

    <p class="text-gray-300">Suppose for a contradiction that  <span class="math">\\log^* \\neq \\log</span> . Then there must exist a tuple  <span class="math">(R, i, \\mathsf{tx}_i^*)</span>  or  <span class="math">(R, \\ell^*)</span>  such that  <span class="math">\\mathsf{tx}_i^* \\neq \\mathsf{tx}_i</span>  or  <span class="math">\\ell^* \\neq \\ell</span> . Without loss of generality, assume that  <span class="math">\\mathsf{tx}_i^* \\neq \\mathsf{tx}_i</span>  (the other case</p>

    <p class="text-gray-300">is similar). Then, node k will have received at least one valid signature on  <span class="math">(R, i, \\mathsf{tx}_i^*)</span>  signed by a  <span class="math">\\mathsf{pk} \\in \\mathsf{comm}</span>  output by a node  <span class="math">\\nu</span>  that remains honest till  <span class="math">T_{\\mathsf{stamp}}</span> . If there exists p.p.t.  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  such that  <span class="math">\\mathsf{log}^* \\neq \\mathsf{log}</span>  with non-negligible probability, then we can build a reduction that break the signature scheme. Basically this reduction simulates all honest users and interact with the  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  pair. Whenever  <span class="math">\\mathcal{Z}</span>  inputs keygen, it has a choice of embedding a pk from the signature's challenger. To do this, every time a keygen is queried, the reduction makes a random guess and decides whether to embed the signature challenger's  <span class="math">\\mathsf{pk}</span> . Such guesses are correct with  <span class="math">1/\\mathsf{poly}(\\lambda)</span>  probability &ndash; and if the guess turns out to be wrong later the reduction simply aborts. Whenever the embedded  <span class="math">\\mathsf{pk}</span>  needs to sign something, the reduction queries the signature challenger. For all other key pairs the reduction knows the corresponding secret key and can disclose it to  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  when a node becomes corrupt. Finally, when  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  outputs a valid signature on such a tuple  <span class="math">\\{R, i, \\mathsf{tx}_i^*\\}_{\\mathsf{pk}^{-1}}</span> , the reduction outputs this as a forgery. Note that the reduction should never have to make such a query to the signature challenger since  <span class="math">\\mathsf{tx}_i^* \\neq \\mathsf{tx}_i</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Common prefix. Suppose that committee members i and j are honest at times t and t' respectively and i outputs  <span class="math">\\log</span>  at time t and j outputs  <span class="math">\\log</span>  at time t'. Due to the timely termination property, it must be the case that  <span class="math">t &lt; T_{\\text{stamp}}</span>  and  <span class="math">t&#x27; &lt; T_{\\text{stamp}}</span> . Now, due to the consistency property of the underlying BFT and definition of DailyBFT, it is not hard to see that either  <span class="math">\\log \\prec \\log&#x27;</span>  or  <span class="math">\\log&#x27; \\prec \\log</span> .</li>
    </ul>

    <p class="text-gray-300">We now extend the argument to committee non-members who spawned before  <span class="math">T_{\\text{stamp}}</span> . Here we rely on the security of the signature scheme. Let k be any committee non-member that spawned before  <span class="math">T_{\\text{stamp}}</span> . We have argued that if node k outputs  <span class="math">done(log&#x27;, \\_)</span>  then log' must agree with honest committee members' final log denoted log&mdash; as we argued earlier, all honest committee members must output an identical final log; and by definition there exists at least one committee member who remains honest till  <span class="math">T_{\\text{stamp}}</span> .</p>

    <p class="text-gray-300">If node k outputs  <span class="math">\\mathtt{notdone}(\\mathsf{log}^*)</span>  at a time when it is honest, then due to the timely termination property and the fact that honest nodes never output again after outputting  <span class="math">\\mathtt{done}(\\_,\\_)</span> , it must hold that  <span class="math">\\mathtt{notdone}(\\mathsf{log}^*)</span>  is output before  <span class="math">T_{\\mathsf{stamp}}</span> . Now parse  <span class="math">\\mathsf{log}^* := \\mathsf{log}_1^* || \\dots || \\mathsf{log}_m^*</span> , and parse  <span class="math">\\mathsf{log} := \\mathsf{log}_1 || \\dots || \\mathsf{log}_\\ell</span> . Then it must hold that  <span class="math">\\ell \\geq m</span>  and  <span class="math">\\mathsf{log}_i^* = \\mathsf{log}_i</span>  &mdash; the latter can be shown using exactly the same type of argument as termination agreement.</p>

    <p class="text-gray-300">&bull; Liveness. By definition of the DailyBFT protocol, any TXs input to an honest committee member at time t is input to the inner BFT virtual nodes in the same time step t. Further, the inner BFT virtual nodes have the same  <span class="math">T_{\\rm start}</span>  and  <span class="math">T_{\\rm stop}</span>  as the outer DailyBFT, since honest committee members simply pass start and stop commands to the inner BFT virtual nodes.</p>

    <p class="text-gray-300">By liveness of the BFT protocol, if  <span class="math">T_{\\rm start} \\leq t &lt; T_{\\rm stop} - T_{\\rm bft}</span> , for any committee member honest at time  <span class="math">t + T_{\\rm bft}</span> , its inner BFT virtual nodes will have output a log that includes all of TXs by time  <span class="math">t + T_{\\rm bft}</span> . Since  <span class="math">t &lt; T_{\\rm stop} - T_{\\rm bft}</span> , complete(log) must return false, since otherwise we can easily construct an adversary that breaks signature security.</p>

    <p class="text-gray-300">Now consider the set of all committee members honest at time  <span class="math">t+T_{\\rm bft}</span> , for each committee member, consider the longest log it has output by time  <span class="math">t+T_{\\rm bft}</span> . Now take the intersection of all such logs and denote it as log'. We have argued that  <span class="math">\\mathsf{TXs} \\subseteq \\mathsf{log&#x27;}</span> , and clearly complete( <span class="math">\\mathsf{log&#x27;}</span> ) = false. Now, by definition of the DailyBFT protocol, for every  <span class="math">i \\in [|\\mathsf{log&#x27;}|]</span> , for every  <span class="math">\\mathsf{pk} \\in \\mathsf{comm}</span>  output by some node that is honest at  <span class="math">T_{\\mathsf{stamp}}</span> , it must hold that every node honest at time  <span class="math">t+T_{\\mathsf{bft}}+\\delta</span>  must have received a validly signed tuple  <span class="math">\\{R,i,\\mathsf{log&#x27;}[i]\\}_{\\mathsf{pk}^{-1}}</span>  where R is the session identifier of DailyBFT. There must be at least  <span class="math">\\lceil Q | \\mathsf{comm} \\rceil \\rceil</span>  number of  <span class="math">\\mathsf{pks}</span>  in comm output by nodes who remain honest till  <span class="math">T_{\\mathsf{stamp}} &gt; t + T_{\\mathsf{bft}} + \\delta</span> . Since  <span class="math">Q &gt; \\frac{2}{3}</span> , any node honest at time</p>

    <p class="text-gray-300"><span class="math">t+T_{\\rm bft}+\\delta</span>  will have output a  <span class="math">\\log^*</span>  s.t.  <span class="math">|\\log^*| \\ge i</span>  by time  <span class="math">t+T_{\\rm bft}+\\delta</span> . By consistency of DailyBFT,  <span class="math">\\log^*[i] = \\log&#x27;[i]</span> , and therefore  <span class="math">\\mathsf{tx} \\in \\log^*</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Completeness. Obvious by definition of DailyBFT and correctness of the signature scheme.</li>
      <li>Unforgeability. If there exists p.p.t.  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  such that unforgeability can be broken with non-negligible probability, then we can build a reduction that break the signature scheme. Basically this reduction simulates all honest users and interact with the  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  pair. Whenever  <span class="math">\\mathcal{Z}</span>  inputs keygen, it has a choice of embedding a pk from the signature's challenger. To do this, every time a keygen is queried, the reduction makes a random guess and decides whether to embed the signature challenger's pk. Such guesses are correct with  <span class="math">1/\\text{poly}(\\lambda)</span>  probability and if the guess turns out to be wrong later the reduction simply aborts. Whenever the embedded pk needs to sign something, the reduction queries the signature challenger. For all other key pairs the reduction knows the corresponding secret key and can disclose it to  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  when a node becomes corrupt. Henceforth we assume that the embedded pk belongs to node i. Finally, when  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  outputs a valid signature on such a tuple  <span class="math">\\{R, h\\}_{pk^{-1}}</span> , the reduction outputs this as a forgery. Note that the reduction should never have to make such a query (R, h) to the signature challenger since by definition, for the  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  pair to break unforgeability, it must be the case that node i has not output done(log, _) by the forgery such that  <span class="math">h = \\text{hash}(\\log)</span> .</li>
    </ul>

      <h3 id="sec-8.4" class="text-xl font-semibold mt-8">8.4 Extending the Proof for Hybrid Consensus over Fruitchain</h3>

    <p class="text-gray-300">So far, we have completed the proof for hybrid consensus over Nakamoto. When we use Fruitchain as the underlying snailchain, the proof is almost the same, except that parameters must be readjusted.</p>

    <p class="text-gray-300">Consider HybridConsensus<sup> <span class="math">\\lambda,\\eta</span> </sup> parametrized with  <span class="math">\\eta</span> . In other words, the committee size csize is chosen to be csize :=  <span class="math">\\lambda/\\eta</span> . In the proof, we can plug in the following modified parameters:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">T_{\\text{snail}} := (2\\lambda + \\frac{\\lambda}{n})/G;</span></li>
      <li><span class="math">T_{\\text{stamp}}(R) := T_{\\text{start}}(R) + \\frac{\\lambda}{\\eta G} + T_{\\text{bft}} + \\delta + T_{\\text{snail}};</span></li>
      <li><span class="math">\\tau &gt; (\\frac{2\\lambda}{\\eta} + \\lambda)/G + T_{\\text{bft}} + \\delta + T_{\\text{snail}} = 3\\lambda(1 + \\frac{1}{\\eta})/G + T_{\\text{bft}} + \\delta;</span></li>
      <li><span class="math">T_{\\text{warmup}} := \\lambda (1 + \\frac{1}{n})/G;</span></li>
      <li><span class="math">G&#x27; &gt; \\frac{\\lambda}{\\eta(T_{\\text{bft}} + \\delta)};</span></li>
      <li><span class="math">G = (1 5\\eta)(1 \\alpha)n\\rho</span> , and  <span class="math">G&#x27; = (1 + 5\\eta)n\\rho</span> .</li>
    </ul>

    <p class="text-gray-300">With these new parameters, the rest of the proof follows in the same manner as hybrid consensus over Nakamoto.</p>

    </section>

    <section id="sec-9" class="mb-10">
      <h2 class="text-2xl font-bold">9 Lower Bound</h2>

      <h3 id="sec-9.1" class="text-xl font-semibold mt-8">9.1 Proof-of-Work Cannot Stop</h3>

    <p class="text-gray-300">We now prove a lower bound suggesting that any secure permissionless consensus protocol must invoke proofs-of-work infinitely often, assuming no additional trust assumptions. We stress that this lower bound does not rule out approaches that rely on additional trust assumptions such as proofs-of-stake [11,38,49,50].</p>

    <p class="text-gray-300">Theorem 13 (Any secure permissionless consensus protocol must call proofs-of-work infinitely often.). Let &Gamma; denote any binary function in n, &alpha;, &delta;, &tau; such that &Gamma;(n, &alpha;, &delta;, &tau; ) = 1 for some n, &delta; that are positive polynomials (in &lambda;), non-negative polynomial &tau; , and &alpha; &gt; 1/poly for some positive polynomial poly. Let &Pi; be a protocol such that for any p.p.t. (A, Z) that is &Gamma;-admissible, there exists a polynomial function poly such that for every &lambda; &isin; N, exec[&Pi;](A, Z, &lambda;) satisfies the following properties with 1/poly(&lambda;) probability:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Bounded proof-of-work. Honest nodes stop querying H after some time Tpow := poly<sup>0</sup> (n, &alpha;, &delta;, &lambda;) for some polynomial poly<sup>0</sup> ;</li>
      <li>Liveness. Liveness as defined in Section <a href="#page-18-0">3.2</a> is satisfied with parameters Tconfirm = poly<sup>1</sup> (n, &alpha;, &delta;, &lambda;), Twarmup = poly<sup>2</sup> (n, &alpha;, &delta;, &lambda;), and Tbootstrap = poly<sup>3</sup> (n, &alpha;, &delta;, &lambda;), for some non-negative polynomial poly<sup>1</sup> , poly<sup>2</sup> , and poly<sup>3</sup> .</li>
    </ul>

    <p class="text-gray-300">Then, there exists p.p.t. (A, Z) that is &Gamma;-admissible, such that for any &lambda; &isin; N, exec[&Pi;](A, Z, &lambda;) does not satisfy consistency with probability 1/poly(&lambda;) for some polynomial poly.</p>

    <p class="text-gray-300">Intuitively, this theorem says that any permissionless consensus protocol secure against 1/poly(&lambda;) fraction of corruption must call proofs-of-work infinitely often &mdash; even in the synchronous network model and against static corruptions.</p>

    <p class="text-gray-300">Proof. Let &Pi; be any protocol such that for any p.p.t. (A<sup>0</sup> , Z 0 ) that is &Gamma;-admissible, there exists a polynomial function poly such that for every &lambda; &isin; N, with 1/poly(&lambda;) probability, exec[&Pi;](A<sup>0</sup> , Z 0 , &lambda;) satisfies bounded proof-of-work and liveness as defined above. We now show how to construct p.p.t. (A, Z) that is &Gamma;-admissible such that exec[&Pi;](A, Z, &lambda;) breaks the common prefix property with 1/poly(&lambda;) probability for some polynomial poly.</p>

    <p class="text-gray-300">We consider a pair (A, Z) that is &Gamma;-admissible w.r.t. &Pi;, and behaves as follows.</p>

    <p class="text-gray-300">Transaction input. At time <sup>T</sup>warmup, <sup>Z</sup> samples tx $&larr;{0, <sup>1</sup>} &lambda; , and inputs TXs := {tx} to an honest node. Besides this, Z does not input any other transactions.</p>

    <p class="text-gray-300">Real execution. A instructs all corrupt nodes to behave honestly in the real execution.</p>

    <p class="text-gray-300">Simulated execution. Starting at time Tpow, A also simulates an imaginary execution in its head. To do this, A simulates the execution of all honest nodes and the environment Z. Suppose that in this simulated execution, the simulated environment Z inputs TXs := {tx&lowast;} where tx<sup>&lowast;</sup> $&larr;{0, 1} <sup>&lambda;</sup> at simulated time Twarmup.</p>

    <p class="text-gray-300">Network and corruption. In both the real and the simulated execution, the adversary A delivers messages instantly, i.e., within the next time step. The environment statically corrupts &alpha; fraction of the nodes.</p>

    <p class="text-gray-300">Late spawning node. Suppose that a new node i spawns at time tspawn := max(Tpow + Tpow/&alpha;, Twarmup + Tconfirm) + 1. At this moment, the adversary A will have all the simulated honest nodes interact with node i where all simulated honest nodes follow the honest protocol. Whenever node i gossips a message, the message is delivered to both the honest nodes in the real execution within &delta; = 1 time, as well as delivered to honest nodes in the simulated execution.</p>

    <p class="text-gray-300">No consistency. Now, with 1/poly(&lambda;) probability, both bounded proof-of-work and liveness are satisfied for the real and simulated execution. Conditioned on the fact these properties are satisfied for the real and simulated execution, we argue that consistency cannot be satisfied with at least 1/2 probability.</p>

    <p class="text-gray-300">Given that &alpha; fraction of the nodes are corrupt, it is not hard to see that at any time t &ge; tspawn&minus;1, the adversary A is able to output a simulated execution that is identically distributed as the real execution, since the adversary A will have enough time to make all the necessary H queries.</p>

    <p class="text-gray-300">Now, due to liveness, honest nodes in the real execution must have output a LOG by tspawn &minus; 1 where tx &isin; LOG and tx<sup>&lowast;</sup> &isin;/ LOG &mdash; except with negl(&lambda;) probability since the the real execution cannot know tx<sup>&lowast;</sup> before tspawn. Similarly, except with negl(&lambda;) probability, honest nodes in the simulated execution must have output a LOG by tspawn &minus; 1 and where tx<sup>&lowast;</sup> &isin; LOG and tx &isin;/ LOG.</p>

    <p class="text-gray-300">Due to liveness, the newly spawned node i must output a non-empty LOG by time max(tspawn + Tbootstrap, Twarmup + Tconfirm) such that tx &isin; LOG. And since the real and simulated execution are identically distributed, tx<sup>&lowast;</sup> &isin; LOG too. Since the real and simulated execution are identically distributed, the probability that tx<sup>&lowast;</sup> precedes tx in LOG is at least 1/2 &mdash; in which case consistency (for the real execution) cannot be satisfied.</p>

      <h3 id="sec-9.2" class="text-xl font-semibold mt-8">9.2 1/3 Corruption is Tight for Responsive Protocols</h3>

    <p class="text-gray-300">We now show that in the permissionless model, even when the protocol knows an a-priori upper bound &#8710; of the network's delay, there does not exist responsive protocols that can tolerate 1/3 or more corruption in terms of hashpower. Since our hybrid consensus protocol tolerates 1/3 &minus; corruption, it is (nearly) tight since no responsive protocol can tolerate more than 1/3 corruption.</p>

    <p class="text-gray-300">Our lower bound is a straightforward modification of a related lower bound proven by Sompolinsky <a href="#page-50-1">[2]</a>, who showed that in the partially synchronous setting, if the network's delay upper bound is unknown to the protocol, then no secure permissionless consensus protocol can tolerate more than 1/3 corruption. Our lower bound proof (and also Sompolinsky's) is also close in spirit to the partially synchronous lower bound shown by Dwork, Lynch, and Stockmeyer <a href="#page-52-1">[25]</a> &mdash; however, their bound needs to be adapted to the permissionless setting with proof-of-work. In particular, Dwork et al.'s lower bound constructs an explicit attack with 3 nodes, where one node controlled by the adversary acts as two separate nodes with different inputs, and interact with two honest nodes to split their views. In the proof-of-work setting, the difficulty is that the adversary cannot simultaneously simulate two nodes since to do that it would have to solve twice the proof-of-work. However, we use a trick similar to Sompolinsky <a href="#page-50-1">[2]</a>, where the adversary still acts as two players, but space out the proof-of-work over time &mdash; and the victim honest node cannot distinguish whether the adversary started solving puzzles late, or simply the network delay is large.</p>

    <p class="text-gray-300">Theorem 14 (Responsive protocols cannot tolerate 1/3 corruption). No secure permissionless consensus protocol that is also responsive can tolerate 1/3 or more corruption.</p>

    <p class="text-gray-300">Proof. Suppose that there exists a protocol &Pi; that defends against 1/3 corruption and is responsive, i.e., its liveness parameter Tconfirm = Tconfirm(&lambda;, n, &alpha;, &delta;) is a function of the network's actual delay &delta;, but not of the a-priori known upper bound delay &#8710;. This means that after some Twarmup = poly(&lambda;, n, &alpha;, &delta;, &#8710;) time, a transaction input to an honest node will be included in any honest node's output LOG within Tconfirm time, even when 1/3 of the nodes crash.</p>

    <p class="text-gray-300">We now describe an explicit attack that can break consistency when &alpha; = 1/3. Suppose that there are 3 nodes, A, P0, and P1, where A is controlled by the adversary A, and P<sup>0</sup> and P<sup>1</sup> are honest. Let &#8710; := 2Tconfirm(&lambda;, n, &alpha;, Tconfirm(&lambda;, n, &alpha;, 1)) which is polynomial bounded in terms of &lambda;. The adversary  <span class="math">\\mathcal{A}</span>  first behaves honestly and delivers all messages instantly until  <span class="math">T_{\\text{warmup}}(\\lambda, n, \\alpha, 1, \\Delta)</span>  time has passed.</p>

    <p class="text-gray-300">At this time, the adversary  <span class="math">\\mathcal{A}</span>  starts to delay messages between  <span class="math">P_0</span>  and  <span class="math">P_1</span>  for the maximum amount  <span class="math">\\Delta</span> , but delivers messages instantly between  <span class="math">P_0</span>  and A. At this time, the environment  <span class="math">\\mathcal{Z}</span>  inputs a transaction  <span class="math">\\mathsf{tx} \\overset{\\</span>}{\\leftarrow} {0,1}^{\\lambda}$  to  <span class="math">P_0</span>  and a different transaction  <span class="math">\\mathsf{tx}&#x27; \\overset{\\</span>}{\\leftarrow} {0,1}^{\\lambda}$  to  <span class="math">P_1</span> . Further, the corrupt node A stops sending messages to  <span class="math">P_1</span> ; however, it remembers and stores every message received from  <span class="math">P_1</span> . The corrupt node follows the honest protocol when interacting with  <span class="math">P_0</span> . Since the protocol is responsive even when 1/3 nodes crash, except with negligible probability,  <span class="math">P_0</span> 's output LOG will include  <span class="math">\\mathsf{tx}</span>  in some fixed polynomial time  <span class="math">T_{\\mathrm{confirm}}(\\lambda, n, \\alpha, 1) &lt; \\Delta</span> .</p>

    <p class="text-gray-300">Let  <span class="math">t^* = T_{\\text{warmup}}(\\lambda, n, \\alpha, 1, \\Delta) + T_{\\text{confirm}}(\\lambda, n, \\alpha, 1)</span>  denote an upper bound on the time when tx is included in  <span class="math">P_0</span> 's output LOG. At time  <span class="math">t^*</span> , the corrupt node A stops sending messages to  <span class="math">P_0</span> , but begins interating with  <span class="math">P_1</span>  as follows. First, A resets its internal state to what it was at time  <span class="math">T_{\\text{warmup}}</span> . Recall that A queues all messages received  <span class="math">P_1</span>  in a buffer. It will now pretend that any real time  <span class="math">t \\geq t^*</span>  is fake time  <span class="math">t - T_{\\text{confirm}}(\\lambda, n, \\alpha, 1)</span> , and that it replays (from the buffer) all messages received from  <span class="math">P_1</span>  during the real time step  <span class="math">t - T_{\\text{confirm}}(\\lambda, n, \\alpha, 1)</span> . Now A follows the honest protocol, and for every message destined for  <span class="math">P_1</span> , the adversary delivers the message instantly. Note that  <span class="math">P_1</span>  cannot distinguish whether A started solving proofs-of-work  <span class="math">T_{\\text{confirm}}(\\lambda, n, \\alpha, 1)</span>  time late, or whether the network link from A to  <span class="math">P_1</span>  has  <span class="math">T_{\\text{confirm}}(\\lambda, n, \\alpha, 1)</span>  actual delay, but the  <span class="math">P_1</span>  to A link delivers messages instantly. Since the protocol is responsive even when 1/3 nodes crash,  <span class="math">P_1</span>  will include  <span class="math">tx&#x27; \\neq tx</span>  in its output LOG in  <span class="math">T_{\\text{confirm}}(\\lambda, n, \\alpha, T_{\\text{confirm}}(\\lambda, n, \\alpha, 1)) &lt; \\Delta</span>  time. Note that since  <span class="math">\\Delta</span>  is large,  <span class="math">P_1</span>  has not heard the transaction tx from  <span class="math">P_0</span>  yet. Therefore, the probability that tx is in  <span class="math">P_1</span> 's output log at time  <span class="math">T_{\\text{confirm}}(\\lambda, n, \\alpha, T_{\\text{confirm}}(\\lambda, n, \\alpha, 1)</span> ) is negligibly small in  <span class="math">\\lambda</span> . Clearly, this breaks consistency.</p>

    <p class="text-gray-300"><strong>Remark.</strong> We note that it is not hard to show a similar lower bound for the classical permissioned setting. Specifically, in the classical permissioned setting even when assuming PKI, any responsive, secure consensus protocol cannot tolerate 1/3 corruption or more. Such a lower bound would be a straightforward generalization of Dwork et al.'s lower bound proof for partial synchrony with an unknown  <span class="math">\\Delta</span>  (in the permissioned setting).</p>

    <p class="text-gray-300">We thank Kyle Croman, Ittay Eyal, Ari Juels, Antonio Marcedone, Andrew Miller, Emin Gun Sirer, Yonatan Sompolinsky, Dawn Song, and Fan Zhang for helpful discussions, and especially Dominic Williams for several excellent discussions that inspired us to tackle this problem.</p>

    <p class="text-gray-300">This work is supported in part by NSF grants CNS-1217821, CNS-1314857, CNS-1514261, CNS-1544613, CNS-1561209, CNS-1601879, CNS-1617676, AFOSR Award FA9550-15-1-0262, an Office of Naval Research Young Investigator Program Award, a Microsoft Faculty Fellowship, a Packard Fellowship, a Sloan Fellowship, Google Faculty Research Awards, and a VMWare Research Award. This work was done in part while a subset of the authors were visiting the Simons Institute for the Theory of Computing, supported by the Simons Foundation and by the DIMACS/Simons Collaboration in Cryptography through NSF grant CNS-1523467.</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><p class="text-gray-300">[1] Personal communication with Kartik Nayak and Ling Ren.</p></li>
      <li><p class="text-gray-300">[2] Personal communication with Yonatan Sompolinsky.</p></li>
      <li><p class="text-gray-300">[3] Byzcoin: Securely scaling blockchains. <a href="http://hackingdistributed.com/2016/08/04/byzcoin/" target="_blank" rel="noopener noreferrer">http://hackingdistributed.com/2016/08/04/</a> <a href="http://hackingdistributed.com/2016/08/04/byzcoin/" target="_blank" rel="noopener noreferrer">byzcoin/</a>.</p></li>
      <li><p class="text-gray-300">[4] Untangling mining incentives in bitcoin and byzcoin. <a href="http://bford.github.io/2016/10/25/mining/" target="_blank" rel="noopener noreferrer">http://bford.github.io/2016/10/25/</a> <a href="http://bford.github.io/2016/10/25/mining/" target="_blank" rel="noopener noreferrer">mining/</a>.</p></li>
      <li><p class="text-gray-300">[5] Mart&acute;&#305;n Abadi and Jan J&uml;urjens. Formal eavesdropping and its computational interpretation. In Theoretical Aspects of Computer Software, 4th International Symposium (TACS), pages 82&ndash;94, 2001.</p></li>
      <li><p class="text-gray-300">[6] Mart&acute;&#305;n Abadi and Phillip Rogaway. Reconciling two views of cryptography (the computational soundness of formal encryption). J. Cryptology, 20(3):395, 2007.</p></li>
      <li><p class="text-gray-300">[7] Pedro Ad&tilde;ao, Gergei Bana, Jonathan Herzog, and Andre Scedrov. Soundness of formal encryption in the presence of key-cycles. In Computer Security - ESORICS 2005, 10th European Symposium on Research in Computer Security, Milan, Italy, September 12-14, 2005, Proceedings, pages 374&ndash;396, 2005.</p></li>
      <li><p class="text-gray-300">[8] Gavin Andresen. Increase maximum block size (bip 101). <a href="https://github.com/bitcoin/bips/blob/master/bip-0101.mediawiki" target="_blank" rel="noopener noreferrer">https://github.com/bitcoin/</a> <a href="https://github.com/bitcoin/bips/blob/master/bip-0101.mediawiki" target="_blank" rel="noopener noreferrer">bips/blob/master/bip-0101.mediawiki</a>, retrieved October 2015.</p></li>
      <li><p class="text-gray-300">[9] Adam Back, Matt Corallo, Luke Dashjr, Mark Friedenbach, Gregory Maxwell, Andrew Miller, Andrew Poelstra, Jorge Timon, and Pieter Wuille. Enabling blockchain innovations with pegged sidechains. https://blockstream.com/sidechains.pdf.</p></li>
      <li><p class="text-gray-300">[10] Michael Backes, Birgit Pfitzmann, and Michael Waidner. A universally composable cryptographic library. IACR Cryptology ePrint Archive, 2003:15, 2003.</p></li>
      <li><p class="text-gray-300">[11] Iddo Bentov, Ariel Gabizon, and Alex Mizrahi. Cryptocurrencies without proof of work. CoRR, abs/1406.5694, 2014.</p></li>
      <li><p class="text-gray-300">[12] Alysson Neves Bessani, Jo&tilde;ao Sousa, and Eduardo Ad&acute;&#305;lio Pelinson Alchieri. State machine replication for the masses with BFT-SMART. In 44th Annual IEEE/IFIP International Conference on Dependable Systems and Networks, DSN 2014, Atlanta, GA, USA, June 23-26, 2014, pages 355&ndash;362, 2014.</p></li>
      <li><p class="text-gray-300">[13] Florian Bohl and Dominique Unruh. Symbolic universal composability. In Proceedings of the 2013 IEEE 26th Computer Security Foundations Symposium, CSF '13, pages 257&ndash;271, 2013.</p></li>
      <li><p class="text-gray-300">[14] Gabriel Bracha and Sam Toueg. Asynchronous consensus and broadcast protocols. J. ACM, 32(4):824&ndash;840, October 1985.</p></li>
      <li><p class="text-gray-300">[15] Christian Cachin, Klaus Kursawe, Frank Petzold, and Victor Shoup. Secure and efficient asynchronous broadcast protocols. In Advances in Cryptology - CRYPTO 2001, 21st Annual International Cryptology Conference, Santa Barbara, California, USA, August 19-23, 2001, Proceedings, pages 524&ndash;541, 2001.</p></li>
      <li><p class="text-gray-300">[16] R. Canetti. Universally composable security: A new paradigm for cryptographic protocols. In FOCS, 2001.</p></li>
      <li><p class="text-gray-300">[17] Ran Canetti, Yevgeniy Dodis, Rafael Pass, and Shabsi Walfish. Universally composable security with global setup. In Theory of Cryptography, pages 61&ndash;85. Springer, 2007.</p></li>
      <li><p class="text-gray-300">[18] Ran Canetti and Jonathan Herzog. Universally composable symbolic security analysis. J. Cryptology, 24(1):83&ndash;147, 2011.</p></li>
      <li><p class="text-gray-300">[19] Ran Canetti and Tal Rabin. Fast asynchronous byzantine agreement with optimal resilience. In Proceedings of the Twenty-fifth Annual ACM Symposium on Theory of Computing, STOC '93, pages 42&ndash;51, 1993.</p></li>
      <li><p class="text-gray-300">[20] Ran Canetti and Tal Rabin. Universal composition with joint state. In CRYPTO, 2003.</p></li>
      <li><p class="text-gray-300">[21] Miguel Castro and Barbara Liskov. Practical byzantine fault tolerance. In OSDI, 1999.</p></li>
      <li><p class="text-gray-300">[22] Kyle Croman, Christian Decker, Ittay Eyal, Adem Efe Gencer, Ari Juels, Ahmed Kosba, Andrew Miller, Prateek Saxena, Elaine Shi, Emin Gun Sirer, Dawn Song, and Roger Wattenhofer. On scaling decentralized blockchains (a position paper). In Bitcoin Workshop, 2016.</p></li>
      <li><p class="text-gray-300">[23] Christian Decker, Jochen Seidel, and Roger Wattenhofer. Bitcoin meets strong consistency. In Proceedings of the 17th International Conference on Distributed Computing and Networking, ICDCN '16, 2016.</p></li>
      <li><p class="text-gray-300">[24] Danny Dolev and H. Raymond Strong. Authenticated algorithms for byzantine agreement. Siam Journal on Computing - SIAMCOMP, 12(4):656&ndash;666, 1983.</p></li>
      <li><p class="text-gray-300">[25] Cynthia Dwork, Nancy Lynch, and Larry Stockmeyer. Consensus in the presence of partial synchrony. J. ACM, 1988.</p></li>
      <li><p class="text-gray-300">[26] Pieter Wuille Eric Lombrozo, Johnson Lau. Segregated witness (consensus layer). <a href="https://github.com/CodeShark/bips/blob/segwit/bip-codeshark-jl2012-segwit.mediawiki" target="_blank" rel="noopener noreferrer">https:</a> <a href="https://github.com/CodeShark/bips/blob/segwit/bip-codeshark-jl2012-segwit.mediawiki" target="_blank" rel="noopener noreferrer">//github.com/CodeShark/bips/blob/segwit/bip-codeshark-jl2012-segwit.mediawiki</a>.</p></li>
      <li><p class="text-gray-300">[27] Ittay Eyal, Adem Efe Gencer, Emin Gun Sirer, and Robbert van Renesse. Bitcoin-NG: A scalable blockchain protocol. In NSDI, 2016.</p></li>
      <li><p class="text-gray-300">[28] Ittay Eyal and Emin Gun Sirer. Majority is not enough: Bitcoin mining is vulnerable. In FC, 2014.</p></li>
      <li><p class="text-gray-300">[29] Michael J. Fischer, Nancy A. Lynch, and Michael S. Paterson. Impossibility of distributed consensus with one faulty process. J. ACM, 32(2):374&ndash;382, April 1985.</p></li>
      <li><p class="text-gray-300">[30] Juan Garay, Aggelos Kiayias, and Nikos Leonardos. The Bitcoin Backbone Protocol: Analysis and Applications. Cryptology ePrint Archive, Report 2014/765, 2014.</p></li>
      <li><p class="text-gray-300">[31] Jeff Garzik. Block size increase to 2mb (bip 102). <a href="https://github.com/bitcoin/bips/blob/master/bip-0102.mediawiki" target="_blank" rel="noopener noreferrer">https://github.com/bitcoin/bips/blob/</a> <a href="https://github.com/bitcoin/bips/blob/master/bip-0102.mediawiki" target="_blank" rel="noopener noreferrer">master/bip-0102.mediawiki</a>, retrieved October 2015.</p></li>
      <li><p class="text-gray-300">[32] Jeff Garzik. Making decentralized economic policy. <a href="http://gtf.org/garzik/bitcoin/BIP100-blocksizechangeproposal.pdf" target="_blank" rel="noopener noreferrer">http://gtf.org/garzik/bitcoin/</a> <a href="http://gtf.org/garzik/bitcoin/BIP100-blocksizechangeproposal.pdf" target="_blank" rel="noopener noreferrer">BIP100-blocksizechangeproposal.pdf</a>.</p></li>
      <li><p class="text-gray-300">[33] Omer Horvitz and Virgil D. Gligor. Weak key authenticity and the computational completeness of formal encryption. In CRYPTO, pages 530&ndash;547, 2003.</p></li>
      <li><p class="text-gray-300">[34] Romain Janvier, Yassine Lakhnech, and Laurent Mazar&acute;e. Completing the picture: Soundness of formal encryption in the presence of active adversaries. In Programming Languages and Systems, 14th European Symposium on Programming,ESOP 2005, Held as Part of the Joint European Conferences on Theory and Practice of Software (ETAPS), pages 172&ndash;185, 2005.</p></li>
      <li><p class="text-gray-300">[35] Jonathan Katz and Chiu-Yuen Koo. On expected constant-round protocols for byzantine agreement. J. Comput. Syst. Sci., 75(2):91&ndash;112, February 2009.</p></li>
      <li><p class="text-gray-300">[36] Aggelos Kiayias and Giorgos Panagiotakos. Speed-security tradeoffs in blockchain protocols. Cryptology ePrint Archive, Report 2015/1019, 2015.</p></li>
      <li><p class="text-gray-300">[37] Eleftherios Kokoris-Kogias, Philipp Jovanovic, Nicolas Gailly, Ismail Khoffi, Linus Gasser, and Bryan Ford. Enhancing bitcoin security and performance with strong consistency via collective signing. CoRR, abs/1602.06997, 2016.</p></li>
      <li><p class="text-gray-300">[38] Jae Kwon. TenderMint: Consensus without Mining, August 2014.</p></li>
      <li><p class="text-gray-300">[39] Leslie Lamport. Fast paxos. Distributed Computing, 19(2):79&ndash;103, 2006.</p></li>
      <li><p class="text-gray-300">[40] Leslie Lamport, Dahlia Malkhi, and Lidong Zhou. Vertical paxos and primary-backup replication. In Proceedings of the 28th ACM Symposium on Principles of Distributed Computing, PODC '09, pages 312&ndash;313, 2009.</p></li>
      <li><p class="text-gray-300">[41] Leslie Lamport, Robert Shostak, and Marshall Pease. The byzantine generals problem. ACM Trans. Program. Lang. Syst., 4(3):382&ndash;401, July 1982.</p></li>
      <li><p class="text-gray-300">[42] Jean-Philippe Martin and Lorenzo Alvisi. Fast byzantine consensus. IEEE Trans. Dependable Secur. Comput., 3(3), 2006.</p></li>
      <li><p class="text-gray-300">[43] Daniele Micciancio and Bogdan Warinschi. Completeness theorems for the Abadi-Rogaway language of encrypted expressions. J. Comput. Secur., 12(1):99&ndash;129, January 2004.</p></li>
      <li><p class="text-gray-300">[44] Daniele Micciancio and Bogdan Warinschi. Soundness of formal encryption in the presence of active adversaries. In Theory of Cryptography Conference (TCC), 2004.</p></li>
      <li><p class="text-gray-300">[45] Andrew Miller, Yu Xia, Kyle Croman, Elaine Shi, and Dawn Song. The honey badger of BFT protocols. Cryptology ePrint Archive, Report 2016/199, 2016. <a href="http://eprint.iacr.org/" target="_blank" rel="noopener noreferrer">http://eprint.iacr.org/</a>.</p></li>
      <li><p class="text-gray-300">[46] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system. 2008.</p></li>
      <li><p class="text-gray-300">[47] Rafael Pass, Lior Seeman, and Abhi Shelat. Analysis of the blockchain protocol in asynchronous networks. In Eurocrypt, 2017.</p></li>
      <li><p class="text-gray-300">[48] Rafael Pass and Elaine Shi. Fruitchains: A fair blockchain. Manuscript, 2016.</p></li>
      <li><p class="text-gray-300">[49] Ryan Pfeiffer. The decrits consensus algorithm: Decentralized agreement without proof of work. CoRR, abs/1411.1101, 2014.</p></li>
      <li><p class="text-gray-300">[50] QuantumMechanic. Proof of stake instead of proof of work. &lt;bitcointalk.org&gt;, July 2011.</p></li>
      <li><p class="text-gray-300">[51] David Schwartz, Noah Youngs, and Arthur Britto. The Ripple Protocol Consensus Algorithm, September 2014.</p></li>
      <li><p class="text-gray-300">[52] Isaac C. Sheff, Robbert van Renesse, and Andrew C. Myers. Distributed protocols and heterogeneous trust: Technical report. CoRR, abs/1412.3136, 2014.</p></li>
      <li><p class="text-gray-300">[53] Marko Vukolic. The quest for scalable blockchain fabric: Proof-of-work vs. BFT replication. In Open Problems in Network Security - IFIP WG 11.4 International Workshop, iNetSec 2015, Zurich, Switzerland, October 29, 2015, Revised Selected Papers, pages 112&ndash;125, 2015.</p></li>
      <li><p class="text-gray-300">[54] Pieter Wuille. Block size following technological growth (bip 103). <a href="https://github.com/bitcoin/bips/blob/master/bip-0103.mediawiki" target="_blank" rel="noopener noreferrer">https://github.com/</a> <a href="https://github.com/bitcoin/bips/blob/master/bip-0103.mediawiki" target="_blank" rel="noopener noreferrer">bitcoin/bips/blob/master/bip-0103.mediawiki</a>.</p></li>
    </ul>

    <h2 id="sec-misc-6" class="text-2xl font-bold">Appendix</h2>

    </section>

    <section id="app-a" class="mb-10">
      <h2 class="text-2xl font-bold">A Background on Permissioned BFT</h2>

    <p class="text-gray-300">We briefly describe one possible instantiation of the permissioned BFT protocol using PBFT <a href="#page-52-0">[21]</a> as an example. Roughly speaking, PBFT <a href="#page-52-0">[21]</a> is a partially synchronous protocol for Byzantine state machine replication.</p>

    <p class="text-gray-300">Below we informally describe the protocol for the case when n = 3f +1. It is not hard to modify the protocol for the more general case n &gt; 3f + 1. In our description, we assume transactions are proposed in units called batches.</p>

    <p class="text-gray-300">Normal-case operations. We first describe the normal-case operations of the PBFT protocol, where all messages are signed by the sender.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The leader of the current view proposes a tuple (&quot;propose&quot;, v, <code>, batch) to all nodes where v denotes the view number and </code> denotes the sequence number.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>When an honest node hears (&quot;propose&quot;, v, <code>, batch), if it has not sent a prepare message for (v, </code>), it multicasts (&quot;prepare&quot;, v, \`, batch).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>When an honest node collects (&quot;prepare&quot;, v, <code>, batch) from 2f + 1 distinct nodes for the same (v, </code>, batch) tuple, it multicasts (&quot;commit&quot;, v, <code>, batch). Further, the honest node now considers prepared(v, </code>, batch) := 1.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>When an honest node first collects (&quot;commit&quot;, v, <code>, batch) from 2f +1 distinct nodes for the same (v, </code>, batch) tuple; or when it first collects (&quot;commited&quot;, v, <code>, batch) from f + 1 distinct nodes for the same (v, </code>, batch) tuple: the node considers lcommitted(v, <code>, batch) := 1 and multicasts (&quot;commited&quot;, v, </code>, batch). Here lcommitted is short for &quot;locally committed&quot;.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">The normal-case protocol satisfies the following important properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Agreement. If two honest nodes each believes that prepared(v, <code>, batch) := 1 and prepared(v, </code>, batch<sup>0</sup> ) := 1 respectively, then batch = batch<sup>0</sup> .</li>
      <li>Liveness under an honest leader. If the leader is honest and no honest node has timed out since start of the latest view, then any batch submitted by an honest node will be locally committed by all honest nodes in O(1) atomic time steps.</li>
      <li>Ample proofs of preparedness. If at least one honest node considers lcommitted(v, <code>, batch) := 1, then at least f + 1 honest node considers prepared(v, </code>, batch) := 1.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If an honest node believes that prepared(v, \`, batch) := 1, then it can produce 2f + 1 signed prepare messages that led to this belief. We refer to the collection of these 2f + 1 prepare messages a proof-of-preparedness.</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">Notice that an immediate corrolary of the agreement property is that if two honest nodes each believes that lcommitted(v, <code>, batch) := 1 and lcommitted(v, </code>, batch<sup>0</sup> ) := 1 respectively, then batch = batch<sup>0</sup> . However, the normal-case operation does not guarantee, under a potentially corrupt leader, that if one honest node thinks lcommitted(v, <code>, batch) := 1, other honest nodes will necessarily think lcommitted(v, </code>, batch) := 1. This therefore motivates the view change protocol.</p>

    <p class="text-gray-300">View change. The normal-case protocol alone does not guarantee liveness when the leader is corrupt. To guarantee liveness even when the leader is corrupt, a view change protocol is invoked upon timeouts. To obtain O(n&delta;) worst-case response time, we can make a small modification to PBFT's original exponential backoff strategy: instead, the timeouts could double every n view changes. In the partially synchronous model, when the timeout backs off to &Theta;(&delta;) and the leader is honest, liveness ensues.</p>

    <p class="text-gray-300">Roughly speaking, if an honest node hears f + 1 valid view change requests for a new view v 0 , it will echo the view change request by multicasting a view change message itself for view v 0 .</p>

    <p class="text-gray-300">When the new view's leader collects 2f + 1 valid view change requests, the set of 2f + 1 valid view change requests together form a new-view message. The leader then proposes the new-view message to all nodes. When an honest node receives the new-view message, For every (v, <code>, batch) with a valid proof-of-preparedness contained in the new-view message, the node acts as if it has just received a (&quot;propose&quot;, v, </code>, batch) message, therefore multicasts a prepare message for the tuple, and continues as in the normal-case operations.</p>

    <p class="text-gray-300">Due to the &quot;ample proofs of preparedness&quot; property of the normal-case operation, the following property holds: If an honest node believes that lcommitted(v, <code>, batch) = 1, then at least one valid proof-of-preparedness will be included in any valid new-view message. This ensures that if at least one honest node believes that lcommitted(v, </code>, batch) = 1, the tuple (v, <code>, batch) is guaranteed to carry over to the new view, and therefore if other honest nodes locally commits (v, </code>, batch<sup>0</sup> ) in the new view, it holds that batch = batch<sup>0</sup> .</p>

    <p class="text-gray-300">Finally, as long as the new leader is honest and no honest node has timed out yet in the new view, then liveness ensues for the new view.</p>

    <p class="text-gray-300">We refer the reader to the PBFT paper <a href="#page-52-0">[21]</a> for a detailed description of the view change protocol as well as the checkpointing optimization. It is not difficult to formalize the proofs in the PBFT paper <a href="#page-52-0">[21]</a> and extend them to a cryptographically sound framework. Further, it is not difficult to show that the PBFT protocol realizes our strong notion of security as defined in Section <a href="#page-23-0">4.2.</a></p>

    </section>
`;
---

<BaseLayout title="Hybrid Consensus: Efficient Consensus in the Permissionless ... (2016/917)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/917
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#abstract" class="hover:text-white">Abstract</a></li>
        <li>
          <a href="#sec-1" class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-1.1" class="hover:text-white">Our Results and Contributions</a></li>
            <li><a href="#sec-1.2" class="hover:text-white">Technical Subtleties and Comparison with Closely Related Works</a></li>
            <li><a href="#sec-1.3" class="hover:text-white">Paper Organization</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-2" class="hover:text-white">Technical Roadmap</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-2.1" class="hover:text-white">Preliminaries and Building Blocks</a></li>
            <li><a href="#sec-2.1.1" class="hover:text-white">Permissionless Consensus</a></li>
            <li><a href="#sec-2.1.2" class="hover:text-white">Blockchains</a></li>
            <li><a href="#sec-2.1.3" class="hover:text-white">Permissioned BFT</a></li>
            <li><a href="#sec-2.1.4" class="hover:text-white">Execution Model</a></li>
            <li><a href="#sec-2.2" class="hover:text-white">The Hybrid Consensus Protocol: Overview</a></li>
            <li><a href="#sec-2.2.1" class="hover:text-white">Warmup: Static Committee</a></li>
            <li><a href="#sec-2.2.2" class="hover:text-white">Handling Mildly Adaptive Corruption</a></li>
            <li><a href="#sec-2.2.3" class="hover:text-white">Chain Quality and Resilience</a></li>
            <li><a href="#sec-2.2.4" class="hover:text-white">Modular Protocol Composition and Formal Reasoning</a></li>
            <li><a href="#sec-2.2.5" class="hover:text-white">Main Theorem</a></li>
            <li><a href="#sec-2.3" class="hover:text-white">Additional Related Work</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-3" class="hover:text-white">Problem Definitions</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-3.1" class="hover:text-white">Formal Model</a></li>
            <li><a href="#sec-3.2" class="hover:text-white">Problem Definition: Permissionless Consensus</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-4" class="hover:text-white">Building Blocks</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-4.1" class="hover:text-white">Underlying Blockchain Protocol snailchain</a></li>
            <li><a href="#sec-4.1.1" class="hover:text-white">Nakamoto as the underlying snailchain</a></li>
            <li><a href="#sec-4.1.2" class="hover:text-white">Fruitchain as the underlying snailchain</a></li>
            <li><a href="#sec-4.2" class="hover:text-white">Strongly Secure Permissioned Byzantine Fault Tolerance</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-5" class="hover:text-white">Formal Scheme: Hybrid Consensus over Nakamoto</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-5.1" class="hover:text-white">Notational Conventions</a></li>
            <li><a href="#sec-5.2" class="hover:text-white">Daily Offchain Consensus Protocol</a></li>
            <li><a href="#sec-5.3" class="hover:text-white">Hybrid Consensus Protocol</a></li>
            <li><a href="#sec-5.4" class="hover:text-white">Theorem Statements</a></li>
            <li><a href="#sec-5.5" class="hover:text-white">Practical Considerations and Possible Optimizations</a></li>
          </ol>
        </li>
        <li><a href="#sec-6" class="hover:text-white">Extension: Fruitchain as the Underlying snailchain</a></li>
        <li><a href="#sec-7" class="hover:text-white">Proof Roadmap</a></li>
        <li>
          <a href="#sec-8" class="hover:text-white">Detailed Proofs</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-8.1" class="hover:text-white">Terminology and Simple Facts</a></li>
            <li><a href="#sec-8.2" class="hover:text-white">Hybrid Consensus Proofs</a></li>
            <li><a href="#sec-8.3" class="hover:text-white">Daily Offchain Consensus Proofs</a></li>
            <li><a href="#sec-8.4" class="hover:text-white">Extending the Proof for Hybrid Consensus over Fruitchain</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-9" class="hover:text-white">Lower Bound</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-9.1" class="hover:text-white">Proof-of-Work Cannot Stop</a></li>
            <li><a href="#sec-9.2" class="hover:text-white">1/3 Corruption is Tight for Responsive Protocols</a></li>
          </ol>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li><a href="#app-a" class="hover:text-white">Background on Permissioned BFT</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#acknowledgements" class="hover:text-white">Acknowledgements</a></li>
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="hybrid-consensus-efficient-consensus-in-the-permissionless-2016" />
  </article>
</BaseLayout>
