---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2022/1251';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Flashproofs: Efficient Zero-Knowledge Arguments of Range and Polynomial Evaluation with Transparent Setup';
const AUTHORS_HTML = 'Nan Wang, Sid Chi-Kin Chau';

const CONTENT = `    <p class="text-gray-300">Flashproofs: Efficient Zero-Knowledge Arguments of Range and Polynomial Evaluation with Transparent Setup</p>

    <p class="text-gray-300">Nan Wang and Sid Chi-Kin Chau</p>

    <p class="text-gray-300">Australian National University, Canberra, Australia {vincent.wang, sid.chau}@anu.edu.au</p>

    <p class="text-gray-300">Abstract. We propose Flashproofs, a new type of efficient special honest verifier zero-knowledge arguments with a transparent setup in the discrete logarithm (DL) setting. First, we put forth gas-efficient range arguments that achieve <span class="math">O(N^{\\frac{3}{2}})</span> communication cost, and involve <span class="math">O(N^{\\frac{3}{2}})</span> group exponentiations for verification and a slightly sub-linear number of group exponentiations for proving with respect to the range <span class="math">[0, 2^{N} - 1]</span>, where <span class="math">N</span> is the bit length of the range. For typical confidential transactions on blockchain platforms supporting smart contracts, verifying our range arguments consumes only 234K and 315K gas for 32-bit and 64-bit ranges, which are comparable to 220K gas incurred by verifying the most efficient zkSNARK with a trusted setup (EUROCRYPT '16) at present. Besides, the aggregation of multiple arguments can yield further efficiency improvement. Second, we present polynomial evaluation arguments based on the techniques of Bayer &amp; Groth (EUROCRYPT '13). We provide two zero-knowledge arguments, which are optimised for lower-degree (<span class="math">D \\in [3, 2^{9}]</span>) and higher-degree (<span class="math">D &amp;gt; 2^{9}</span>) polynomials, where <span class="math">D</span> is the polynomial degree. Our arguments yield a non-trivial improvement in the overall efficiency. Notably, the number of group exponentiations for proving drops from <span class="math">8\\log D</span> to <span class="math">3(\\log D + \\sqrt{\\log D})</span>. The communication cost and the number of group exponentiations for verification decrease from <span class="math">7\\log D</span> to <span class="math">(\\log D + 3\\sqrt{\\log D})</span>. To the best of our knowledge, our arguments instantiate the most communication-efficient arguments of membership and non-membership in the DL setting among those not requiring trusted setups. More importantly, our techniques enable a significantly asymptotic improvement in the efficiency of communication and verification (group exponentiations) from <span class="math">O(\\log D)</span> to <span class="math">O(\\sqrt{\\log D})</span> when multiple arguments satisfying different polynomials with the same degree and inputs are aggregated.</p>

    <p class="text-gray-300">Keywords: Zero-knowledge arguments, range arguments, polynomial evaluation arguments, confidential transactions, smart contracts.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>This paper appears in the proceedings of IACR Asiacrypt 2022</li>

    </ul>

    <p class="text-gray-300">** This research was supported by ARC Discovery Project No: GA69027/DP200101985.</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Zero-knowledge proofs play a critical role in modern secure applications and systems, e.g., confidential transactions, signature schemes, federated learning and multi-party computation. A zero-knowledge proof allows a prover to convince a verifier of the truth of a statement without revealing any secret information. More formally, given an NP-language <span class="math">\\mathcal{L}</span>, a prover aims to convince a verifier of knowing a witness <span class="math">\\omega</span> for a statement <span class="math">u\\in\\mathcal{L}</span> with high probability by a zero-knowledge proof that satisfies three properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. A prover can convince a verifier of <span class="math">u\\in\\mathcal{L}</span>, if <span class="math">u\\in\\mathcal{L}</span>.</li>

      <li>Soundness. A prover cannot convince a verifier of <span class="math">u\\in\\mathcal{L}</span>, if <span class="math">u\\notin\\mathcal{L}</span>.</li>

      <li>Zero-knowledge. The proof should reveal nothing except the truth that <span class="math">u\\in\\mathcal{L}</span>.</li>

    </ul>

    <p class="text-gray-300">There are varieties of zero-knowledge proofs <em>[2, 5, 6, 7, 13, 14, 17, 28, 37, 41, 46]</em> for general NP-complete languages, e.g., arithmetic circuits satisfiability. However, generic constructions used by these proofs tend to be sub-optimal and may not achieve the best efficiency as in specialised constructions for particular languages. This paper focuses on the zero-knowledge proofs for two particular languages in the discrete logarithm (DL) setting: range arguments and polynomial evaluation arguments. An argument is a computationally sound proof that no probabilistic polynomial-time provers are able to deceive a verifier into falsely accepting it.</p>

    <p class="text-gray-300">Range proofs are designed to prove a committed value is within a specific range. Several zero-knowledge range proofs have been applied to confidential transactions (CT) <em>[26]</em> on blockchain platforms. Blockchain has enabled a significant revolution towards decentralised peer-to-peer transactions. By default, blockchain does not ensure privacy but rather its transparency and immutability properties. However, with growing privacy concerns, confidential transactions have received increasing attention as they protect privacy by hiding transaction information. A plenty of confidential transaction protocols, e.g., AZTEC <em>[45]</em>, TornadoCash <em>[40]</em>, have been developed on blockchain platforms, e.g., Ethereum. As one of the most emerging blockchain technologies, smart contracts are playing an increasingly important role in promoting confidential transactions. They are publicly verifiable computer programs running on blockchain platforms to automate the execution of agreements without the intervention of intermediaries when some pre-determined conditions are met. To prevent inconsistent transactions, zero-knowledge range proofs are used to demonstrate sufficient funds in accounts for non-negative transfer values. However, many existing proposals for CT zero-knowledge proofs suffer from three drawbacks:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Trusted Setup: Prior zero-knowledge proofs (e.g., zkSNARK <em>[28]</em>) require a “trusted setup”, where a group of trusted parties use some secret information to generate public parameters and destroy the secret information without revealing it. However, introducing a trusted setup will compromise the security and notion of decentralisation, which leaves a backdoor for misbehaving provers to exploit and create false proofs.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Imbalanced Overhead: Recent zero-knowledge proofs have replaced trusted setups with transparent setups. However, achieving transparent setups may give rise to imbalanced overhead with either expensive computation costs or large communication costs, which would undermine the scalability of blockchain applications, where scalability refers to the capability of handling transactions in a short period. For example, Bulletproofs <em>[13]</em> achieve a logarithmic proof size but require a linear number of group exponentiations for both proving and verification. The zkSTARK <em>[5]</em> has poly-logarithmic verification efficiency but entails a large proof size about 45KB <em>[31]</em>.</li>

      <li>Trade-off With Soundness. There is a new class of range proofs (e.g. CKLR21 <em>[20]</em>) based on bounded integer commitments in the DL setting, which can attain efficient computational and communication costs. However, one has to make a trade-off between the range size and the soundness error for a given group, which undermines the applicability of these range proofs. Note that using RSA or class groups <em>[20]</em> could address this trade-off limitation by removing bounds on the size of integers, which, however, would either require a trusted setup or a different security assumption with considerably large groups.</li>

    </ul>

    <p class="text-gray-300">On the other hand, polynomial evaluation proofs are designed to prove a public polynomial relation <span class="math">y=P(x;D)</span> between two committed values <span class="math">x</span> and <span class="math">y</span>, where <span class="math">D</span> is the polynomial degree. Notably, polynomial evaluation proofs are a basic building block for constructing the zero-knowledge proofs of membership and non-membership. For example, a polynomial function <span class="math">y=P(x;D)=0</span> can be built for membership proofs to prove that a committed value <span class="math">x</span> belongs to a public set <span class="math">X</span>, where the roots are the elements of <span class="math">X</span>. For non-membership proofs, <span class="math">y\\neq 0</span> needs to be proved. A prover can commit to a value <span class="math">z=y^{-1}</span> and demonstrate <span class="math">z\\cdot y=1</span> with a multiplication proof. Proofs of membership and non-membership have extensive applications, e.g., anonymous credentials, group signatures, whitelist, and blacklist. Bayer & Groth <em>[3]</em> (BG13) presented polynomial evaluation arguments that achieve <span class="math">O(\\log D)</span> efficiency in verification (group exponentiations) and communication based on the DL assumption. Nevertheless, the computational and communication costs for higher-degree polynomials are still high.</p>

    <h3 id="sec-1" class="text-xl font-semibold mt-8">1.1 Contributions</h3>

    <p class="text-gray-300">In this paper, we propose Flashproofs, efficient special honest verifier zero-knowledge arguments of range and polynomial evaluation with a transparent setup. Flashproofs are 3-round public coin interactive protocols between a prover and a verifier. The prover sends an initial message to the verifier in the first round. The verifier replies with a uniformly random challenge, and then the prover responds to the challenge in the third round. Finally, the verifier decides</p>

    <p class="text-gray-300">N. Wang and S.C.K. Chau</p>

    <p class="text-gray-300">whether to accept or reject based on the conversation. Flashproofs have perfect completeness, computational witness-extended emulation and perfect special honest verifier zero-knowledge under the typical DL assumption that applies to elliptic curve groups. We follow the transparent approach [13] without resorting to a trusted setup with elliptic curve groups. Besides, our arguments can be made non-interactive via Fiat-Shamir heuristic [25], where provers can generate random challenges by computing the hashes of the initial messages instead of verifiers, with a collision-resistant hash function modelled as a random oracle.</p>

    <p class="text-gray-300">Range Arguments We put forth a new type of gas-efficient zero-knowledge range arguments to prove that a committed value lies in the range  <span class="math">[0, 2^N - 1]</span> , where  <span class="math">N</span>  indicates the bit length. Our range arguments involve  <span class="math">O(N^{\\frac{2}{3}})</span>  group exponentiations for verification and achieve  <span class="math">O(N^{\\frac{2}{3}})</span>  communication cost. Besides, as illustrated in Fig. 1, our arguments with optimisation use a sub-linear number of group exponentiations for proving (Please refer to Section 3.2 for optimisation). They are highly suitable for confidential transactions on blockchain platforms. In a nutshell, our work achieves sub-linearly overall efficiency without resorting to a trusted setup while maintaining a negligible soundness error. Especially, our arguments greatly reduce the verification gas costs to a practically affordable level on smart contract platforms.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1: Proving computational costs of our range arguments with optimisation.</p>

    <p class="text-gray-300">Techniques. Our range arguments are based upon the bit-decomposition approach to proving that a committed value can be represented in binary form. We devise a new strategy to achieve superior computational efficiency compared to conventional works. The intuition is to fold the sequence of the bits of a committed value as a matrix. Then we prove each element in the matrix is either 0 or a certain power of 2 by using a quadratic-term cancellation technique. Finally, we flatten the two-dimension matrix to a one-dimension vector in a column-wise manner and prove that the committed value is the sum of the vector values. We introduce an optimisation technique to refine the efficiency in both computation and communication. Besides, the aggregation of multiple arguments is supported for further efficiency improvement.</p>

    <p class="text-gray-300">Comparisons with State-of-the-art Range Proofs. Verifying our range arguments consumes about 234K and 315K gas for general 32-bit and 64-bit ranges. The gas costs are comparable to 220K gas incurred by verifying the most effi</p>

    <p class="text-gray-300">Flashproofs: Zero-Knowledge Arguments of Range &amp; Polynomial Evaluation</p>

    <p class="text-gray-300">Table 1: Efficiency comparison of range arguments for the range  <span class="math">[0,2^{N} - 1]</span> , where  <span class="math">N</span>  is the bit length of the range,  <span class="math">\\mathbb{G}</span>  indicates a cyclic group of prime order  <span class="math">p</span>  and  <span class="math">\\mathbb{Z}_p</span>  is the ring of integers modulo  <span class="math">p</span> . We essentially compare the involved group exponentiations as they dominate the computational cost. Besides, we take the nearest integer  <span class="math">\\lceil N^{\\frac{1}{3}} \\rceil</span>  as the cubic root of  <span class="math">\\mathbf{N}</span>  and  <span class="math">N^{\\frac{2}{3}}</span>  can thus be obtained by computing  <span class="math">N \\cdot \\lceil N^{-\\frac{1}{3}} \\rceil</span> .  <span class="math">F(N^{\\frac{1}{3}})</span>  is a function that yields constant values based on  <span class="math">N^{\\frac{1}{3}}</span> , where  <span class="math">F(2) = 3</span> ,  <span class="math">F(3) = 6</span> ,  <span class="math">F(4) = 8</span> ,  <span class="math">F(5) = 11</span> ,  <span class="math">F(6) = 13</span> ,  <span class="math">F(7) = 20</span> ,  <span class="math">F(8) = 27</span> ,  <span class="math">F(9) = 32</span> ,  <span class="math">F(10) = 37</span> . Please refer to Section 3.2 for the details of  <span class="math">F(N^{\\frac{1}{3}})</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Type</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Bulletproof</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This work (3.2)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This work with optimisation (3.2)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Prover No. of Exp (G)</td>

            <td class="px-3 py-2 border-b border-gray-700">14N + 4 log N + 12</td>

            <td class="px-3 py-2 border-b border-gray-700">1/2(N3/3 + 3N3/3 + 5N1/3 + N + 6)</td>

            <td class="px-3 py-2 border-b border-gray-700">(N2/3 + 1) · F(N1/3) + 2N1/3 + 2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verifier No. of Exp (G)</td>

            <td class="px-3 py-2 border-b border-gray-700">2N + 2 log N + 7</td>

            <td class="px-3 py-2 border-b border-gray-700">3/2(N2/3 + N1/3 + 2)</td>

            <td class="px-3 py-2 border-b border-gray-700">N2/3 + N1/3 + F(N1/3) + 2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Proof Size No. of Elements</td>

            <td class="px-3 py-2 border-b border-gray-700">2 log N + 4 (G) 5 (Zp)</td>

            <td class="px-3 py-2 border-b border-gray-700">N2/3 + 2 (G) 1/2(N2/3 + 3N1/3 + 4) (Zp)</td>

            <td class="px-3 py-2 border-b border-gray-700">N2/3 + 2 (G) N1/3 + F(N1/3) + 1 (Zp)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: Detailed efficiency comparison of Bulletproof with our optimised work, where  <span class="math">N</span>  is the bit length of the range. Note that our range arguments are more succinct in proof size when  <span class="math">N \\leq 22</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">8</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">10</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">12</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">14</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">16</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">18</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">20</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">22</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">32</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">52</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">64</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Prover</td>

            <td class="px-3 py-2 border-b border-gray-700">Bulletproof</td>

            <td class="px-3 py-2 border-b border-gray-700">136</td>

            <td class="px-3 py-2 border-b border-gray-700">252</td>

            <td class="px-3 py-2 border-b border-gray-700">252</td>

            <td class="px-3 py-2 border-b border-gray-700">252</td>

            <td class="px-3 py-2 border-b border-gray-700">252</td>

            <td class="px-3 py-2 border-b border-gray-700">480</td>

            <td class="px-3 py-2 border-b border-gray-700">480</td>

            <td class="px-3 py-2 border-b border-gray-700">480</td>

            <td class="px-3 py-2 border-b border-gray-700">480</td>

            <td class="px-3 py-2 border-b border-gray-700">932</td>

            <td class="px-3 py-2 border-b border-gray-700">932</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">No. of Exp (G)</td>

            <td class="px-3 py-2 border-b border-gray-700">This work</td>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700">30</td>

            <td class="px-3 py-2 border-b border-gray-700">33</td>

            <td class="px-3 py-2 border-b border-gray-700">36</td>

            <td class="px-3 py-2 border-b border-gray-700">39</td>

            <td class="px-3 py-2 border-b border-gray-700">42</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">122</td>

            <td class="px-3 py-2 border-b border-gray-700">146</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verifier</td>

            <td class="px-3 py-2 border-b border-gray-700">Bulletproof</td>

            <td class="px-3 py-2 border-b border-gray-700">29</td>

            <td class="px-3 py-2 border-b border-gray-700">47</td>

            <td class="px-3 py-2 border-b border-gray-700">47</td>

            <td class="px-3 py-2 border-b border-gray-700">47</td>

            <td class="px-3 py-2 border-b border-gray-700">47</td>

            <td class="px-3 py-2 border-b border-gray-700">81</td>

            <td class="px-3 py-2 border-b border-gray-700">81</td>

            <td class="px-3 py-2 border-b border-gray-700">81</td>

            <td class="px-3 py-2 border-b border-gray-700">81</td>

            <td class="px-3 py-2 border-b border-gray-700">147</td>

            <td class="px-3 py-2 border-b border-gray-700">147</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">No. of Exp (G)</td>

            <td class="px-3 py-2 border-b border-gray-700">This work</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700">30</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Proof Size</td>

            <td class="px-3 py-2 border-b border-gray-700">Bulletproof</td>

            <td class="px-3 py-2 border-b border-gray-700">482</td>

            <td class="px-3 py-2 border-b border-gray-700">546</td>

            <td class="px-3 py-2 border-b border-gray-700">546</td>

            <td class="px-3 py-2 border-b border-gray-700">546</td>

            <td class="px-3 py-2 border-b border-gray-700">546</td>

            <td class="px-3 py-2 border-b border-gray-700">610</td>

            <td class="px-3 py-2 border-b border-gray-700">610</td>

            <td class="px-3 py-2 border-b border-gray-700">610</td>

            <td class="px-3 py-2 border-b border-gray-700">610</td>

            <td class="px-3 py-2 border-b border-gray-700">674</td>

            <td class="px-3 py-2 border-b border-gray-700">674</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(Byte)</td>

            <td class="px-3 py-2 border-b border-gray-700">This work</td>

            <td class="px-3 py-2 border-b border-gray-700">385</td>

            <td class="px-3 py-2 border-b border-gray-700">417</td>

            <td class="px-3 py-2 border-b border-gray-700">449</td>

            <td class="px-3 py-2 border-b border-gray-700">481</td>

            <td class="px-3 py-2 border-b border-gray-700">513</td>

            <td class="px-3 py-2 border-b border-gray-700">545</td>

            <td class="px-3 py-2 border-b border-gray-700">577</td>

            <td class="px-3 py-2 border-b border-gray-700">609</td>

            <td class="px-3 py-2 border-b border-gray-700">738</td>

            <td class="px-3 py-2 border-b border-gray-700">898</td>

            <td class="px-3 py-2 border-b border-gray-700">994</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">cient zkSNARK (Groth16) [28], which requires three elliptic curve pairing operations for any arithmetic circuits with the aid of a trusted setup. For the aggregation of 16 of our range arguments, it is estimated that the allocated gas costs per argument would be reduced by  <span class="math">20\\%</span>  to about 184K and 251K. Thus, with respect to proving ranges, our arguments can be a suitable alternative to the zkSNARKs for confidential transactions on blockchain platforms. Bulletproofs [13] are generic-purpose arguments in the DL setting for any arithmetic circuits with a transparent setup, which can instantiate range arguments. Bulletproof² is designed to pursue  <span class="math">O(\\log N)</span>  communication efficiency at the expense of using  <span class="math">O(N)</span>  number of group exponentiations in computation for the range  <span class="math">[0,2^{N} - 1]</span> . Table 1 and 2 show efficiency comparisons with Bulletproof. Our arguments involve  <span class="math">15.7\\%</span>  and  <span class="math">20.4\\%</span>  of the group exponentiations used by</p>

    <p class="text-gray-300">N. Wang and S.C.K. Chau</p>

    <p class="text-gray-300">Bulletproof for <span class="math">N=64</span>, respectively, while incurring only 50% additional communication cost. For smaller 52-bit ranges, the advantage of our arguments in computational efficiency is even greater, whereas the discrepancy in communication efficiency is smaller. Moreover, our range arguments are more sensitive to <span class="math">N</span>, resulting in finer-grained performance and more flexible usage in different scenarios. Another range proof in the DL setting is CKLR21 <em>[20]</em>. It applies Legendre’s three squares theorem <em>[36]</em> to achieve constant efficiency in computation and communication by leveraging a bounded integer commitment scheme. However, it suffers an inherent trade-off between the range size and the soundness error (sometimes called “knowledge error”) for a certain group. Soundness errors indicate the probability of a malicious prover cheating a verifier into accepting false proofs. Confidential transactions typically have stringent security requirements, demanding highly negligible soundness errors. As for the mainstream 256-bit elliptic curve groups in confidential transactions, CKLR21 achieves a soundness error <span class="math">2^{-80}</span> for 32-bit ranges at the risk of a re-run with a 65% probability. The errors would rise to <span class="math">2^{-70}</span> on smart contract platforms due to the 256-bit word limit. Besides, for 64-bit and larger ranges, the errors would surge to no less than <span class="math">2^{-48}</span>. Thus, current CT platforms must increase the number of sequential iterations or use larger groups to obtain negligible soundness errors. Moving to larger groups is undesirable as it may require a major change to their infrastructure. Moreover, both ways would increase the computational and communication costs. Our arguments tend to be more efficient for verification and communication at a comparable level of soundness errors. For example, iterating CKLR21 three times helps achieve a negligible soundness error <span class="math">2^{-240}</span> for a 32-bit range but increases the proof size to about 827 bytes. Accordingly, the computational cost also grows. By comparison, our arguments have 738 bytes with a soundness error <span class="math">2^{-256}</span>. Please see Table 5 and 6 for a detailed efficiency comparison.</p>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">3.3.2 Polynomial Evaluation Arguments</h4>

    <p class="text-gray-300">Based on the techniques of BG13 <em>[3]</em>, we present two zero-knowledge arguments, which are optimised for the polynomials <span class="math">y=P(x;D)</span> of lower-degree <span class="math">(D\\in[3,2^{9}])</span> and higher-degree <span class="math">(D&amp;gt;2^{9})</span>, respectively. Two arguments are distinguished based on the proof size, with the higher-degree one outperforming the lower-degree one when the degree <span class="math">D</span> exceeds <span class="math">2^{9}</span>. Our arguments essentially leverage the <em>quadratic-term cancellation</em> technique to greatly reduce the number of group exponentiations and elements for superior efficiency in computation and communication. To the best of our knowledge, our arguments instantiate the most communication-efficient zero-knowledge arguments of membership and non-membership in the DL setting among those not requiring trusted setups. Furthermore, we propose an aggregation optimisation, where multiple arguments satisfying different polynomials with the same degree and inputs can be aggregated such that the efficiency in verification (group exponentiations per argument) and communication is asymptotically increased from</p>

    <p class="text-gray-300">3 A 52-bit range can cover all the values from 1 satoshi up to 21 million bitcoins.</p>

    <p class="text-gray-300">4 The size of one field element in CKLR21 is larger than 256 bits for 32-bit ranges.</p>

    <p class="text-gray-300">5 We skip the protocol for D \\in \\{1,2\\} , which is simpler than the lower-degree one.</p>

    <p class="text-gray-300">Flashproofs: Zero-Knowledge Arguments of Range &amp; Polynomial Evaluation</p>

    <p class="text-gray-300">Table 3: Efficiency comparison of polynomial evaluation arguments with a transparent setup in the DL setting, where  <span class="math">N</span>  is the polynomial degree. Note that  <span class="math">\\log N</span>  should be rounded up if  <span class="math">N</span>  is not a power of 2.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Type</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Bulletproofs</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BG13</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This Work(4.2)Lower-Deg N ∈ [3,29]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This Work (4.3)Higher-Deg N > 29</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ProverNo. of Exp (G)</td>

            <td class="px-3 py-2 border-b border-gray-700">14N + 4 log N + 12</td>

            <td class="px-3 py-2 border-b border-gray-700">8 log N - 4</td>

            <td class="px-3 py-2 border-b border-gray-700">4 log N + 2</td>

            <td class="px-3 py-2 border-b border-gray-700">3 log N + 3√log N + 2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">VerifierNo. of Exp (G)</td>

            <td class="px-3 py-2 border-b border-gray-700">2N + 2 log N + 7</td>

            <td class="px-3 py-2 border-b border-gray-700">7 log N - 1</td>

            <td class="px-3 py-2 border-b border-gray-700">2 log N + 7</td>

            <td class="px-3 py-2 border-b border-gray-700">log N + 3√log N + 6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Proof Size</td>

            <td class="px-3 py-2 border-b border-gray-700">2 log N + 8 (G)</td>

            <td class="px-3 py-2 border-b border-gray-700">4 log N - 2 (G)</td>

            <td class="px-3 py-2 border-b border-gray-700">log N + 3 (G)</td>

            <td class="px-3 py-2 border-b border-gray-700">2√log N + 3 (G)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">No. of Elements</td>

            <td class="px-3 py-2 border-b border-gray-700">5 (Zp)</td>

            <td class="px-3 py-2 border-b border-gray-700">3 log N (Zp)</td>

            <td class="px-3 py-2 border-b border-gray-700">log N + 3 (Zp)</td>

            <td class="px-3 py-2 border-b border-gray-700">log N + √log N + 4 (Zp)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">O(\\log D)</span>  to  <span class="math">O(\\sqrt{\\log D})</span> . In addition, our range arguments can adapt the polynomial evaluation arguments for scenarios where  <span class="math">y</span>  is even secretly committed without losing the sub-linear computational efficiency. For example, with the aid of the Maclaurin series [44], the polynomial evaluation arguments can satisfy complex mathematical relations between two committed values, e.g., trigonometric and exponential functions. The range arguments help confine the input  <span class="math">x</span>  to a specific range to ensure  <span class="math">y</span>  is in the safe range  <span class="math">[- \\frac{p - 1}{2}, \\frac{p - 1}{2}]</span>  without overflow, where  <span class="math">p</span>  is the group order.</p>

    <p class="text-gray-300">Comparisons with State-of-the-art Polynomial Evaluation Proofs. Table 3 shows an efficiency comparison of polynomial evaluation arguments in the DL setting with a transparent setup. As compared to BG13, it is observed that our arguments achieve a significant improvement in the efficiency of computation and communication without a trusted setup. More concretely, for polynomials of degree  <span class="math">D = 2^{16} - 1</span> , our arguments incur 1122 bytes over a 256-bit elliptic curve group, yielding a  <span class="math">3.1 \\times</span>  reduction in proof size. The allocated communication cost per argument would decrease by  <span class="math">72.4\\%</span>  to about 310 bytes for the aggregation of 16 distinct arguments. In addition, the efficiency in proving and verification is raised by a factor of 2 and 3.3, respectively. An alternative type of communication-efficient arguments with a transparent setup in the DL setting is the generic-purpose Bulletproofs, which require  <span class="math">2\\log N + 13</span>  elements for any arithmetic circuits, where  <span class="math">N</span>  is the number of multiplication gates. On the one hand, our arguments outperform Bulletproofs in the efficiency of computation and communication regarding the polynomial evaluation. On the other hand, our arguments only need three rounds, while Bulletproofs require  <span class="math">\\log N</span>  rounds.</p>

    <p class="text-gray-300">Our paper is organised as follows. First, we introduce the cryptographic preliminaries in Section 2. We elaborate on the core techniques of the range arguments and polynomial evaluation arguments as well as some optimisations in Section 3 and 4. A comprehensive evaluation of performance is given in Section 5. We provide the full protocols of our arguments and the security proofs in Section 6. We describe the related work in Section 7.</p>

    <h2 id="sec-4" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">We follow the definitions in <em>[13, 29]</em> to formalise homomorphic commitment schemes and zero-knowledge arguments of knowledge.</p>

    <p class="text-gray-300">Let <span class="math">\\lambda</span> and <span class="math">\\mathsf{negl}(\\lambda)</span> be the security parameter and the negligible function. PPT means probabilistic polynomial time. Denote a cyclic group of prime order <span class="math">p</span> by <span class="math">\\mathbb{G}</span>, and the ring of integers modulo <span class="math">p</span> by <span class="math">\\mathbb{Z}_{p}</span>. Let <span class="math">\\mathbb{Z}_{p}^{<em>}</span> be <span class="math">\\mathbb{Z}_{p}\\setminus\\{0\\}</span>. Let <span class="math">g,h\\xleftarrow{\\S}\\mathbb{G},(g_{i})_{i=0}^{n-1}\\xleftarrow{\\S}\\mathbb{G}^{n}</span> be uniformly random generators from <span class="math">\\mathbb{G}</span>. Let <span class="math">x\\xleftarrow{\\S}\\mathbb{Z}_{p}^{</em>}</span> be uniformly random element from <span class="math">\\mathbb{Z}_{p}^{*}</span>. Denote the vector spaces of dimension <span class="math">n</span> over <span class="math">\\mathbb{G}</span> and <span class="math">\\mathbb{Z}_{p}</span> by <span class="math">\\mathbb{G}^{n}</span> and <span class="math">\\mathbb{Z}_{p}^{n}</span>, respectively.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">2.1 Homomorphic Commitment Schemes</h3>

    <p class="text-gray-300">Homomorphic commitment schemes are a crucial building block for zero-knowledge proofs. A homomorphic commitment allows to commit to a value with a negligible chance of altering it before opening the commitment. A homomorphic commitment scheme is, hiding if a commitment does not reveal the value and, binding if a commitment can only be opened to one value.</p>

    <p class="text-gray-300">A homomorphic commitment scheme is a pair of PPT algorithms <span class="math">(\\mathcal{G},\\mathsf{Cm})</span>, where the setup algorithm <span class="math">\\mathcal{G}(\\lambda)</span> generates a commitment key <span class="math">\\mathsf{ck}</span> and the commitment algorithm <span class="math">\\mathsf{Cm}</span> defines a function <span class="math">\\mathsf{Cm}_{\\mathsf{ck}}:\\mathsf{M}_{\\mathsf{ck}}\\times\\mathsf{R}_{\\mathsf{ck}}\\to\\mathsf{C}_{\\mathsf{ck}}</span> for a message space <span class="math">\\mathsf{M}_{\\mathsf{ck}}</span>, a randomness space <span class="math">\\mathsf{R}_{\\mathsf{ck}}</span> and a commitment space <span class="math">\\mathsf{C}_{\\mathsf{ck}}</span>. For a message <span class="math">m\\in\\mathsf{M}_{\\mathsf{ck}}</span>, a uniformly randomness <span class="math">r\\in\\mathsf{R}_{\\mathsf{ck}}</span> can be picked to produce a commitment <span class="math">c=\\mathsf{Cm}_{\\mathsf{ck}}(m;r)</span>. The commitments are homomorphic for all well-formed commitment keys <span class="math">\\mathsf{ck}</span> and <span class="math">m_{0},m_{1}\\in\\mathsf{M}_{\\mathsf{ck}},r_{0},r_{1}\\in\\mathsf{R}_{\\mathsf{ck}}</span>:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Cm}_{\\mathsf{ck}}(m_{0};r_{0})\\cdot\\mathsf{Cm}_{\\mathsf{ck}}(m_{1};r_{1})</span> <span class="math">=\\mathsf{Cm}_{\\mathsf{ck}}(m_{0}+m_{1};r_{0}+r_{1})</span> <span class="math">\\mathsf{Cm}_{\\mathsf{ck}}(m_{0};r_{0})^{m_{1}}</span> <span class="math">=\\mathsf{Cm}_{\\mathsf{ck}}(m_{0}\\cdot m_{1};r_{0}\\cdot m_{1})</span></p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Definition 1 (Hiding).</h6>

    <p class="text-gray-300">A commitment scheme <span class="math">(\\mathcal{G},\\mathsf{Cm})</span> is hiding if a commitment does not reveal the value for all PPT adversaries <span class="math">\\mathcal{A}</span>:</p>

    <p class="text-gray-300">\\[ \\mathsf{Pr}\\begin{bmatrix}c=\\mathsf{Cm}_{\\mathsf{ck}}(m_{b}),\\ b\\in\\{0,1\\},\\\\ b^{\\prime}\\leftarrow\\mathcal{A}(c),\\ b=b^{\\prime}\\end{bmatrix}\\begin{vmatrix}\\mathsf{ck}\\leftarrow\\mathcal{G}(\\lambda),\\\\ (m_{0},m_{1}\\in\\mathsf{M}_{\\mathsf{ck}})\\leftarrow\\mathcal{A}(\\mathsf{ck})\\end{vmatrix}\\approx\\frac{1}{2} \\]</p>

    <p class="text-gray-300">The scheme is perfectly hiding if the probability is equal to <span class="math">\\frac{1}{2}</span>.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Definition 2 (Binding).</h6>

    <p class="text-gray-300">A commitment scheme <span class="math">(\\mathcal{G},\\mathsf{Cm})</span> is binding if a commitment can only be opened to one value for all PPT adversaries <span class="math">\\mathcal{A}</span>:</p>

    <p class="text-gray-300">\\[ \\mathsf{Pr}\\begin{bmatrix}\\mathsf{Cm}_{\\mathsf{ck}}(m_{0};r_{0})=\\mathsf{Cm}_{\\mathsf{ck}}(m_{1};r_{1}),\\\\ m_{0}\\neq m_{1}\\end{bmatrix}\\begin{vmatrix}\\mathsf{ck}\\leftarrow\\mathcal{G}(\\lambda),\\\\ (m_{0},m_{1}\\in\\mathsf{M}_{\\mathsf{ck}},r_{0},r_{1}\\in\\mathsf{R}_{\\mathsf{ck}})\\leftarrow\\mathcal{A}(\\mathsf{ck})\\end{vmatrix}\\leq\\mathsf{negl}(\\lambda) \\]</p>

    <p class="text-gray-300">The scheme is perfectly binding if the probability is equal to <span class="math">0</span>.</p>

    <p class="text-gray-300">We define the Pedersen commitment and Pedersen vector commitment as below, both of which are perfect hiding and computationally binding:</p>

    <p class="text-gray-300">Flashproofs: Zero-Knowledge Arguments of Range &amp; Polynomial Evaluation</p>

    <p class="text-gray-300">Definition 3 (Pedersen Commitment). Given  <span class="math">\\mathsf{M}_{\\mathrm{ck}} = \\mathbb{Z}_p, \\mathsf{R}_{\\mathrm{ck}} = \\mathbb{Z}_p^*</span> ,  <span class="math">\\mathsf{C}_{\\mathrm{ck}} = \\mathbb{G}</span>  of order  <span class="math">p</span>  and  <span class="math">g, h \\stackrel{8}{\\leftarrow} \\mathbb{G}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {C m} (m; r) = g ^ {m} h ^ {r} (\\mathrm {m o d} p)</span></div>

    <p class="text-gray-300">Definition 4 (Pedersen Vector Commitment). Given  <span class="math">\\mathsf{M}_{\\mathrm{ck}} = \\mathbb{Z}_p^n, \\mathsf{R}_{\\mathrm{ck}} = \\mathbb{Z}_p^*</span> ,  <span class="math">\\mathsf{C}_{\\mathrm{ck}} = \\mathbb{G}</span>  of order  <span class="math">p</span>  and  <span class="math">(g_0, \\dots, g_{n-1}) \\stackrel{8}{\\leftarrow} \\mathbb{G}^n</span> ,  <span class="math">h \\stackrel{8}{\\leftarrow} \\mathbb{G}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {C m} (m _ {0}, \\dots , m _ {n - 1}; r) = h ^ {r} \\prod_ {i = 0} ^ {n - 1} g _ {i} ^ {m _ {i}} (\\mathrm {m o d} p)</span></div>

    <h2 id="sec-8" class="text-2xl font-bold">2.2 Zero-Knowledge Arguments of Knowledge</h2>

    <p class="text-gray-300">Based upon the discrete logarithm assumption, Flashproofs are public-coin honest-verifier zero-knowledge arguments of knowledge. A zero-knowledge argument is comprised of three interactive probabilistic polynomial-time algorithms  <span class="math">(\\mathcal{G},\\mathcal{P},\\mathcal{V})</span> , where the setup algorithm  <span class="math">\\mathcal{G}(\\lambda)</span>  returns a common reference string  <span class="math">\\sigma</span> .  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  are the prover and verifier algorithms, which produce the public transcript,  <span class="math">tr\\gets \\langle \\mathcal{P}(v),\\mathcal{V}(t)\\rangle</span>  on inputs  <span class="math">v</span>  and  <span class="math">t</span> . Denote a polynomial-time decidable tertiary relation by  <span class="math">\\mathcal{R}\\subset \\{0,1\\} ^<em>\\times \\{0,1\\} ^</em>\\times \\{0,1\\} ^*</span> . A CRS-dependent language can be defined as  <span class="math">L_{\\sigma} = \\{u\\mid \\exists \\omega :(\\sigma ,u,\\omega)\\in \\mathcal{R}\\}</span> , where  <span class="math">\\omega</span>  is a witness for a statement  <span class="math">u</span>  in the relation  <span class="math">(\\sigma ,u,\\omega)\\in \\mathcal{R}</span> .</p>

    <p class="text-gray-300">Definition 5 (Argument of Knowledge). The triple  <span class="math">(\\mathcal{G},\\mathcal{P},\\mathcal{V})</span>  is called an argument of knowledge for the relation  <span class="math">\\mathcal{R}</span>  if it satisfies the perfect completeness and computational witness-extended emulation.</p>

    <p class="text-gray-300">Definition 6 (Perfect Completeness). An argument of knowledge  <span class="math">(\\mathcal{G},\\mathcal{P},\\mathcal{V})</span>  has perfect completeness if for all PPT adversaries  <span class="math">\\mathcal{A}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">P r \\left[ (\\sigma , u, \\omega) \\notin \\mathcal {R} o r \\langle \\mathcal {P} (\\sigma , u, \\omega), \\mathcal {V} (\\sigma , u) \\rangle = 1 \\mid \\sigma \\leftarrow \\mathcal {G} (\\lambda), (u, \\omega) \\leftarrow \\mathcal {A} (\\sigma) \\right] = 1</span></div>

    <p class="text-gray-300">Definition 7 (Computational Witness-Extended Emulation). An argument of knowledge  <span class="math">(\\mathcal{G},\\mathcal{P},\\mathcal{V})</span>  has witness-extended emulation if for all deterministic polynomial time  <span class="math">\\mathcal{P}^*</span> , there exists an expected polynomial time emulator  <span class="math">\\mathcal{E}</span>  such that for all PPT adversaries  <span class="math">\\mathcal{A}</span> :</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P r \\left[ \\mathcal {A} (t r) = 1 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\sigma \\leftarrow \\mathcal {G} (\\lambda) \\\\ (u, s) \\leftarrow \\mathcal {A} (\\sigma), \\\\ t r \\leftarrow \\mathcal {O} \\end{array} \\right. \\right] \\approx P r \\left[ \\begin{array}{l} \\mathcal {A} (t r) = 1 \\\\ \\wedge t r i s a c c e p t i n g \\\\ \\rightarrow (\\sigma , u, w) \\in \\mathcal {R} \\end{array} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\sigma \\leftarrow \\mathcal {G} (\\lambda), \\\\ (u, s) \\leftarrow \\mathcal {A} (\\sigma), \\\\ (t r, \\omega) \\leftarrow \\mathcal {E} ^ {O} (\\sigma , u) \\end{array} \\right. \\right. \\right. \\right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where the oracle is defined as  <span class="math">\\mathcal{O} = \\langle \\mathcal{P}^{*}(\\sigma ,u,s),\\mathcal{V}(\\sigma ,u)\\rangle</span></p>

    <p class="text-gray-300">Soundness can be defined based on the witness-extended emulation. Informally, whenever  <span class="math">\\mathcal{P}^*</span>  makes a convincing argument in state  <span class="math">s</span> , there exists a knowledge emulator  <span class="math">\\mathcal{E}</span>  that can extract a witness for  <span class="math">(\\sigma, u, \\omega) \\in \\mathcal{R}</span>  by rewinding the interaction to any specific points and running again with the same state for the prover, but fresh randomness for the verifier.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Definition 8 (Public Coin)</h6>

    <p class="text-gray-300">An argument of knowledge (<span class="math">\\mathcal{G}</span>, <span class="math">\\mathcal{P}</span>, <span class="math">\\mathcal{V}</span>) is called public coin if the verifier chooses her messages uniformly at random and independently of the messages sent by the prover.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 9 (Perfect Special Honest Verifier Zero-Knowledge, SHVZK)</h6>

    <p class="text-gray-300">A public coin argument of knowledge (<span class="math">\\mathcal{G}</span>, <span class="math">\\mathcal{P}</span>, <span class="math">\\mathcal{V}</span>) is called perfect special honest verifier zero-knowledge argument of knowledge for <span class="math">\\mathcal{R}</span> if there exists a PPT simulator <span class="math">\\mathcal{S}</span> such that for all interactive PPT adversaries <span class="math">\\mathcal{A}</span>:</p>

    <p class="text-gray-300">\\[ \\mathit{Pr}\\begin{bmatrix}(\\sigma,u,\\omega)\\in\\mathcal{R}&\\sigma\\leftarrow\\mathcal{G}(\\lambda),\\\\ \\land\\mathcal{A}(tr)=1&(u,\\omega,e)\\leftarrow\\mathcal{A}(\\sigma),\\\\ tr&\\leftarrow\\langle\\mathcal{P}(v),\\mathcal{V}(t)\\rangle\\end{bmatrix}=\\mathit{Pr}\\begin{bmatrix}(\\sigma,u,\\omega)\\in\\mathcal{R}&\\sigma\\leftarrow\\mathcal{G}(\\lambda),\\\\ \\land\\mathcal{A}(tr)=1&(u,\\omega,e)\\leftarrow\\mathcal{A}(\\sigma),\\\\ tr&\\leftarrow\\mathcal{S}(u,e)\\end{bmatrix} \\]</p>

    <p class="text-gray-300">where <span class="math">e</span> is a public coin challenge, <span class="math">v=(\\sigma,u,\\omega)</span> and <span class="math">t=(\\sigma,u,e)</span>.</p>

    <p class="text-gray-300">An argument is zero-knowledge if no extra information except the witness can be inferred from the statement. A general approach to proving that an argument has special honest verifier zero-knowledge is to construct a simulator that knows the challenge and can simulate the whole transcript of the argument without knowing the witness.</p>

    <h2 id="sec-11" class="text-2xl font-bold">3 Range Arguments</h2>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">3.1 Overview of Bit-Decomposition Approach</h3>

    <p class="text-gray-300">Bit-decomposition is a folklore approach for constructing range proofs. The challenge consists in seeking an efficient method to prove that a committed value can be represented in binary form. Bulletproof employs a variant of the bit-decomposition approach by using an inner product argument <em>[10]</em> (Please refer to their original paper <em>[13]</em> for more details). The intuition is that a prover prepares one vector commitment, which commits to the bit vector <span class="math">\\mathbf{b}</span> of the target value <span class="math">y</span> and to the vector <span class="math">\\mathbf{a}=\\mathbf{b}-\\mathbf{1^{N}}</span>. The prover constructs an equation in Eqn. (1) to prove the three constraints: (I) <span class="math">\\langle\\mathbf{b},\\mathbf{2^{N}}\\rangle=y</span>, (II) <span class="math">\\langle\\mathbf{b}-\\mathbf{1^{N}}-\\mathbf{a},\\mathbf{r}\\rangle=0</span> and (III) <span class="math">\\langle\\mathbf{b},\\mathbf{a}\\circ\\mathbf{r}\\rangle=0</span>.</p>

    <p class="text-gray-300"><span class="math">z^{2}\\cdot\\langle\\mathbf{b},\\mathbf{2^{N}}\\rangle+z\\cdot\\langle\\mathbf{b}-\\mathbf{1^{N}}-\\mathbf{a},\\mathbf{r}\\rangle+\\langle\\mathbf{b},\\mathbf{a}\\circ\\mathbf{r}\\rangle=z^{2}\\cdot y</span> (1)</p>

    <p class="text-gray-300">where <span class="math">z\\in\\mathbb{Z}_{p}^{<em>}</span> is a random value and <span class="math">\\mathbf{r}\\in\\mathbb{Z}_{p}^{</em>N}</span> is a vector of random values provided by the verifier. <span class="math">\\mathbf{1^{N}}=(1,1,...,1)</span> is a vector of <span class="math">1</span> and <span class="math">\\mathbf{2^{N}}=(2^{0},2^{1},...,2^{N-1})</span> is a vector of powers of <span class="math">2</span>. <span class="math">\\langle\\cdot,\\cdot\\rangle</span> and <span class="math">\\circ</span> denote the inner product and the Hadamard product, respectively.</p>

    <p class="text-gray-300">Then the prover takes advantage of the inner product argument to recursively compress the equation in <span class="math">O(\\log N)</span> rounds. The compression technique helps achieve <span class="math">O(\\log N)</span> communication efficiency but exposes two limitations:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The process is computationally expensive, demanding <span class="math">O(N)</span> group exponentiations for proving and verification.</li>

      <li>To a degree, the recursion impedes a parallel acceleration of proof generation.</li>

    </ul>

    <p class="text-gray-300">Flashproofs: Zero-Knowledge Arguments of Range &amp; Polynomial Evaluation</p>

    <p class="text-gray-300">We devise a new variant of the bit-decomposition approach that only needs three rounds. Our technique is highly lightweight in computation and does not require pairing operations. Compared to Bulletproof, our arguments involve far fewer group exponentiations in both proving and verification and also allow for a speedup of proof generation by parallelisation. In this section, we mainly concentrate on the core techniques of our arguments, whereas the full protocol is given in Section 6.1. Our techniques work as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Given a commitment  <span class="math">c_{y} = g^{y}h^{r_{y}}</span> , we express the committed value  <span class="math">y = \\sum_{i=0}^{N-1} 2^{i}b_{i}</span>  as a sequence of terms  <span class="math">(w_{0}, w_{1}, \\dots, w_{N-1})</span>  for the range  <span class="math">[0, 2^{N}-1]</span> , where  <span class="math">b_{i} \\in \\{0,1\\}</span>  and  <span class="math">w_{i} = 2^{i}b_{i}</span> ,  <span class="math">i \\in \\{0,1,\\dots,N-1\\}</span> . Then we fold the sequence and arrange all the terms  <span class="math">(w_{i})_{i=0}^{N-1}</span>  in an  <span class="math">L \\times K</span>  matrix in Eqn. (2), where  <span class="math">L</span>  and  <span class="math">K</span>  indicate the number of rows and columns, respectively. If  <span class="math">N</span>  is a prime integer, additional zeros of size  <span class="math">\\gamma \\in \\mathbb{Z}^{+}</span>  can be padded onto the high-order bits to make  <span class="math">N + \\gamma = K \\cdot L</span> .</li>

      <li>We prove each coefficient  <span class="math">w_{IK + k}</span>  is 0 or  <span class="math">2^{IK + k}</span> .</li>

      <li>We flatten the two-dimension matrix to a one-dimension vector and prove that  <span class="math">y</span>  is the sum of  <span class="math">K</span>  values, such that  <span class="math">y = \\sum_{k=0}^{K-1} s_k</span> , where  <span class="math">s_k = \\sum_{l=0}^{L-1} w_{lK+k}</span>  is the sum of  <span class="math">L</span>  coefficients  <span class="math">(w_{lK+k})_{l=0}^{L-1}</span>  in the  <span class="math">k</span> -th column.</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\left( \\begin{array}{c c c} 2 ^ {0} b _ {0} &amp;amp; \\dots &amp;amp; 2 ^ {K - 1} b _ {K - 1} \\\\ 2 ^ {K} b _ {K} &amp;amp; \\dots &amp;amp; 2 ^ {K + K - 1} b _ {K + K - 1} \\\\ \\vdots &amp;amp; \\ddots &amp;amp; \\vdots \\\\ 2 ^ {(L - 1) K} b _ {(L - 1) K} &amp;amp; \\dots &amp;amp; 2 ^ {(L - 1) K + K - 1} b _ {(L - 1) K + K - 1} \\end{array} \\right) = \\left( \\begin{array}{c c c} w _ {0} &amp;amp; \\dots &amp;amp; w _ {K - 1} \\\\ w _ {K} &amp;amp; \\dots &amp;amp; w _ {K + K - 1} \\\\ \\vdots &amp;amp; \\ddots &amp;amp; \\vdots \\\\ w _ {(L - 1) K} &amp;amp; \\dots &amp;amp; w _ {(L - 1) K + K - 1} \\end{array} \\right) \\tag {2}</span></div>

    <p class="text-gray-300">where the  <span class="math">i</span> -th term  <span class="math">w_{i}</span>  in the  <span class="math">l</span> -th row and the  <span class="math">k</span> -th column is also denoted by  <span class="math">w_{lK + k}</span> ,  <span class="math">k \\in \\{0, \\dots, K - 1\\}</span>  and  <span class="math">l \\in \\{0, \\dots, L - 1\\}</span> .</p>

    <p class="text-gray-300">Next, we describe the intuition in more details. Instead of proving each bit  <span class="math">b_{i} \\in \\{0,1\\}</span>  as Bulletproof, we turn to prove  <span class="math">w_{lK + k} \\in \\{0,2^{lK + k}\\}</span>  for each  <span class="math">(i = lK + k)</span> . In the third round of the protocol, the prover computes and sends a value  <span class="math">v_{l} = \\sum_{k = 0}^{K - 1}w_{lK + k}e_{k} + r_{l}</span>  to the verifier for each  <span class="math">l</span>  after acquiring a challenge vector  <span class="math">(e_0,\\dots,e_{K - 1})^\\intercal</span>  from the verifier.  <span class="math">v_{l}</span>  is a randomised inner product of the  <span class="math">l</span> -th row and the challenge vector, where  <span class="math">r_l \\in \\mathbb{Z}_p^*</span>  is used to prevent  <span class="math">v_{l}</span>  from leaking any information about the coefficients. The essence of our technique is an effective use of  <span class="math">v_{l}</span>  for verifying  <span class="math">w_{lK + k} \\in \\{0,2^{lK + k}\\}</span> . Unlike Bulletproof, which requires the prover to satisfy the constraint (II) in Eqn. (1), we design a new technique to relieve the prover of this burden, which greatly reduces proving computational costs. The technique allows the verifier to compute a value  <span class="math">f_{l}</span>  by subtracting  <span class="math">v_{l}</span>  from  <span class="math">\\sum_{k = 0}^{K - 1}2^{lK + k}e_k</span>  for each  <span class="math">l</span> :</p>

    <div class="my-4 text-center"><span class="math-block">f _ {l} = \\sum_ {k = 0} ^ {K - 1} 2 ^ {l K + k} e _ {k} - v _ {l} = \\sum_ {k = 0} ^ {K - 1} (2 ^ {l K + k} - w _ {l K + k}) e _ {k} - r _ {l}</span></div>

    <p class="text-gray-300">For the case where <span class="math">N</span> is a prime number, it suffices for the verifier to use <span class="math">0</span> rather than <span class="math">2^{lK+k}e_{k}</span> for the padded bits. Then computing <span class="math">f_{l}\\cdot v_{l}</span> for each <span class="math">l</span> will generate a series of cross-terms in the challenges:</p>

    <p class="text-gray-300"><span class="math">f_{l}\\cdot v_{l}\\stackrel{{\\scriptstyle?}}{{=}}\\underbrace{\\sum_{k=0}^{K-1}w_{lK+k}(2^{lK+k}-w_{lK+k})e_{k}^{2}}_{=~{}0,~{}\\text{if}~{}w_{lK+k}\\in\\{0,2^{lK+k}\\}}+\\sum_{k=0,j=1}^{k=K-2,j=K-1}t_{l,k,j}e_{k,j}+\\sum_{k=0}^{K-1}q_{l,k}e_{k}+q_{l,K}</span> (3)</p>

    <p class="text-gray-300">where <span class="math">t_{l,k,j}=w_{lK+k}(2^{lK+j}-w_{lK+j})+w_{lK+j}(2^{lK+k}-w_{lK+k})</span> and <span class="math">e_{k,j}=e_{k}\\cdot e_{j}</span> for <span class="math">k,j\\in\\{0,...,K-1\\}\\wedge k\\neq j</span>. <span class="math">q_{l,k}=2r_{l}(2^{lK+k-1}-w_{lK+k})</span> for <span class="math">k\\in\\{0,...,K-1\\}</span> and <span class="math">q_{l,K}=-r_{l}^{2}</span>. The number of terms <span class="math">e_{k,j}</span> is <span class="math">\\frac{K(K-1)}{2}</span>.</p>

    <p class="text-gray-300">The verifier needs to ensure that the quadratic terms <span class="math">(e_{k}^{2})_{k=0}^{K-1}</span> are all cancelled out by only using the commitments to the coefficients of the remaining terms in Eqn. (3) for verification. Before obtaining the challenges, the prover must provide these commitments in the first round. Thus, by the binding property of Pedersen commitment and the Schwartz-Zippel lemma, it is with an overwhelming probability that the coefficient of the <span class="math">k</span>-th quadratic term satisfies the constraint below:</p>

    <p class="text-gray-300"><span class="math">w_{lK+k}(2^{lK+k}-w_{lK+k})=0\\Longrightarrow w_{lK+k}\\in\\{0,2^{lK+k}\\}</span></p>

    <p class="text-gray-300">The prover also needs to provide the commitments <span class="math">(c_{s_{k}})_{k=0}^{K}</span> in the first round so that the verifier can check the validity of <span class="math">(s_{k})_{k=0}^{K}</span> based upon the equation below:</p>

    <p class="text-gray-300"><span class="math">\\sum_{l=0}^{L-1}v_{l}\\stackrel{{\\scriptstyle?}}{{=}}\\sum_{k=0}^{K-1}s_{k}e_{k}+s_{K},~{}~{}~{}s_{K}=\\sum_{l=0}^{L-1}r_{l}</span> (4)</p>

    <p class="text-gray-300">Finally, the verifier can be convinced that <span class="math">y</span> lies in the range <span class="math">[0,2^{N}-1]</span> by checking the equation <span class="math">y\\stackrel{{\\scriptstyle?}}{{=}}\\sum_{k=0}^{K-1}s_{k}</span>. As we use elliptic curve groups to instantiate the argument, where the group and field elements have roughly the same size, then the total number of elements would be:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=L+2K+\\frac{K(K-1)}{2}+4=\\lceil\\frac{N}{K}\\rceil+\\frac{K^{2}}{2}+\\frac{3K}{2}+4$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The number of group exponentiations for verification is $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1<span class="math">. We calculate the derivative </span>\\Delta_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}=K-\\frac{N}{K^{2}}+\\frac{3}{2}<span class="math">, such that when </span>K\\approx\\lceil N^{\\frac{1}{3}}\\rfloor<span class="math">, both </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and verification complexity achieve the minimum. Table 4a provides a set of </span>(L,K)$ values for different ranges.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">4.0.2 Optimisation.</h4>

    <p class="text-gray-300">We propose an optimisation technique to improve the overall efficiency. We change the way that the challenge vectors are generated at the expense of amplifying the soundness error from <span class="math">\\frac{(p-K)!}{p!}</span> to <span class="math">\\frac{1}{p}</span>, which is still sufficiently negligible with a large <span class="math">p</span>. The high-level idea is to allow the verifier to</p>

    <p class="text-gray-300">Flashproofs: Zero-Knowledge Arguments of Range &amp; Polynomial Evaluation</p>

    <p class="text-gray-300">Table 4: Comparison of range arguments (a) Values of  <span class="math">(L, K)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">8-bit</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">16-bit</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">32-bit</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">64-bit</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">K</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(b) Comparison of range arguments for 64-bit</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Type</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover No. of Exp (G)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier No. of Exp (G)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof Size (Byte)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Original Work</td>

            <td class="px-3 py-2 border-b border-gray-700">197</td>

            <td class="px-3 py-2 border-b border-gray-700">33</td>

            <td class="px-3 py-2 border-b border-gray-700">1090</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Optimised Work</td>

            <td class="px-3 py-2 border-b border-gray-700">146</td>

            <td class="px-3 py-2 border-b border-gray-700">30</td>

            <td class="px-3 py-2 border-b border-gray-700">994</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Saving</td>

            <td class="px-3 py-2 border-b border-gray-700">51 (25.9%)</td>

            <td class="px-3 py-2 border-b border-gray-700">3 (9.1%)</td>

            <td class="px-3 py-2 border-b border-gray-700">96 (8.8%)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">randomly produce a challenge  <span class="math">e</span> , such that the other challenges in the vector will be produced by taking different powers of  <span class="math">e</span> . This change opens the possibility of merging the terms of the same orders to reduce the number of group exponentiations in both proving and verification. We exemplify a concrete case with  <span class="math">K = 4</span>  and consider the 4 challenges  <span class="math">(e_k)_{k=0}^3 = (e^{-1}, e, e^4, e^5)</span>  for a simpler interpretation. To check whether the witness  <span class="math">y</span>  is correctly represented in binary form, the verifier needs to ensure that none of the terms  <span class="math">(e^{-2}, e^2, e^8, e^{10})</span>  will appear on the right-hand side of Eqn. (3). Computing  <span class="math">f_l \\cdot v_l</span>  will generate a polynomial with only 8 terms instead of the original  <span class="math">0.5 \\cdot 16 + 0.5 \\cdot 4 + 1 = 11</span> :</p>

    <div class="my-4 text-center"><span class="math-block">P (e) = w _ {9} e ^ {9} + w _ {6} e ^ {6} + w _ {5} e ^ {5} + w _ {4} e ^ {4} + w _ {3} e ^ {3} + w _ {1} e + w _ {- 1} e ^ {- 1} + w _ {0}</span></div>

    <p class="text-gray-300">where  <span class="math">w_{*}</span>  indicates the coefficients of the corresponding terms.</p>

    <p class="text-gray-300">The coefficients of the combined terms  <span class="math">e \\cdot e^{-1}</span> ,  <span class="math">e \\cdot e^4</span>  and  <span class="math">e^{-1} \\cdot e^5</span>  are respectively merged into  <span class="math">w_0</span> ,  <span class="math">w_5</span>  and  <span class="math">w_4</span> . As shown in Table 4b, this optimisation saves 51 and 3 group exponentiations for proving and verification, respectively, and 3 group elements for communication when  <span class="math">K = 4</span> . Notably, the optimisation increases the proving efficiency by  <span class="math">25.9\\%</span> . Note that a particular choice of  <span class="math">K</span>  challenges can yield  <span class="math">F(K)</span>  number of terms for computing  <span class="math">f_l \\cdot v_l</span> . We provide a possible combination of the challenge exponents for  <span class="math">F(K)</span>  as below and let the readers discover more possible combinations.</p>

    <p class="text-gray-300"><span class="math">K = 2</span>  ..  <span class="math">\\{-1,1\\}</span> <span class="math">K = 3</span>  ..  <span class="math">\\{-1,1,4\\}</span> <span class="math">K = 4</span>  ..  <span class="math">\\{-1,1,4,5\\}</span> <span class="math">K = 5</span>  ..  <span class="math">\\{-1,1, - 4,4,5\\}</span></p>

    <p class="text-gray-300"><span class="math">K = 6</span>  ..  <span class="math">\\{-1,1, - 4,4, - 5,5\\}</span> <span class="math">K = 7</span>  ..  <span class="math">\\{-1,1, - 4,4, - 5,5,16\\}</span></p>

    <p class="text-gray-300"><span class="math">K = 8</span>  ..  <span class="math">\\{-1,1, - 4,4, - 5,5, - 16,16\\}</span> <span class="math">K = 9</span>  ..  <span class="math">\\{-1,1, - 4,4, - 5,5, - 16,16,17\\}</span></p>

    <p class="text-gray-300"><span class="math">K = 10</span>  ..  <span class="math">\\{-1,1, - 4,4, - 5,5, - 16,16, - 17,17\\}</span></p>

    <p class="text-gray-300">Multiple arguments for the same range created by one prover can be aggregated for further efficiency gains. Given  <span class="math">M</span>  witnesses  <span class="math">(y_{m})_{m = 0}^{M - 1}</span> , the prover creates two unique sets  <span class="math">(v_{l}^{(m)})_{l = 0}^{L - 1}</span>  and  <span class="math">(s_k^{(m)})_{k = 0}^K</span>  for each  <span class="math">m\\in \\{0,\\dots,M - 1\\}</span> . The prover utilises  <span class="math">M\\cdot L</span>  generators, where the  <span class="math">(m,l)</span> -th generator is in charge of computing  <span class="math">f_{l}^{(m)}\\cdot v_{l}^{(m)}</span> . Hence, the  <span class="math">M</span>  coefficients of each term on the right-hand side of Eqn. (3) can be compacted in one commitment. Then we can apply the batch</p>

    <p class="text-gray-300">verification technique <em>[4]</em> to reduce the number of group exponentiations by simultaneously checking the equations in Eqn. (4) for these arguments. The technique is based on the principle that checking <span class="math">a=0\\wedge b=0</span> is equivalent to checking <span class="math">a+\\rho b=0</span> with high probability, where <span class="math">\\rho\\in\\mathbb{Z}_{p}^{<em>}</span> is a random value. Thus, the verifier can produce a new random challenge <span class="math">z\\in\\mathbb{Z}_{p}^{</em>}</span> and use the equation below to validate <span class="math">s_{k}^{(m)}</span> in batches:</p>

    <p class="text-gray-300"><span class="math">\\sum_{m=0}^{M-1}(\\sum_{l=0}^{L-1}v_{l}^{(m)})z^{m}\\stackrel{{\\scriptstyle?}}{{=}}\\sum_{k=0}^{K-1}(\\sum_{m=0}^{M-1}s_{k}^{(m)}z^{m})e_{k}+\\sum_{m=0}^{M-1}s_{K}^{(m)}z^{m}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Finally, the verifier can check <span class="math">y_{m}\\stackrel{{\\scriptstyle?}}{{=}}\\sum_{k=0}^{K-1}s_{k}^{(m)}</span> for each <span class="math">m</span>. The total number of elements is $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi_{\\text{total}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=M\\cdot(\\lceil\\frac{N}{K}\\rceil+K+1)+\\frac{K^{2}+K}{2}+3<span class="math">. When </span>K\\approx\\lceil(MN)^{\\frac{1}{2}}\\rceil\\wedge\\frac{N}{K}\\geq 1<span class="math">, the complexity of both communication and verification achieves the minimum. Then for aggregating </span>M<span class="math"> optimised range arguments, we can use the formula </span>\\frac{F(K)+2}{M}+\\lceil\\frac{N}{K}\\rceil+K+1$ to calculate the number of elements for communication cost or the allocated number of group exponentiations for verification per argument.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-16" class="text-2xl font-bold">4 Polynomial Evaluation Arguments</h2>

    <p class="text-gray-300">Built upon the techniques of Bayer & Groth (BG13) <em>[3]</em>, our polynomial evaluation arguments aim to prove that two committed values <span class="math">x</span> and <span class="math">y</span> satisfy a public polynomial relation <span class="math">y=P(x;D)</span>, where <span class="math">D</span> is the degree. They achieve non-trivial efficiency gains in computation and communication thanks to the <em>quadratic-term cancellation</em> technique. We give two protocols, which respectively excel in handling the polynomials of lower-degree <span class="math">D\\in[3,2^{9}]</span> and higher-degree <span class="math">D&gt;2^{9}</span>. We essentially focus on the core techniques of our arguments, whereas the full protocols are given in Section 6.2 and 6.3.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">4.1 Overview of BG13</h3>

    <p class="text-gray-300">We begin with an overview of BG13 (Please refer to their original paper <em>[3]</em> for more details). Consider a polynomial function <span class="math">P(x;D)=\\sum_{d=0}^{D}a_{d}x^{d}</span>, where we assume <span class="math">D=2^{J+1}-1</span> for <span class="math">J\\in\\{1,2,...\\}</span> without loss of generality by padding with zero-coefficients. First, the polynomial <span class="math">P(x;D)</span> can be re-written as below by substituting the <span class="math">d</span>-th term <span class="math">x^{d}</span> with <span class="math">x^{\\sum_{j=0}^{J}2^{j}b_{d}^{(j)}}=\\prod_{j=0}^{J}x^{2^{j}b_{d}^{(j)}}</span>, where <span class="math">d=\\sum_{j=0}^{J}2^{j}b_{d}^{(j)}</span>, <span class="math">b_{d}^{(j)}\\in\\{0,1\\}</span> and <span class="math">J+1=\\lceil\\log D\\rceil</span>:</p>

    <p class="text-gray-300"><span class="math">P(x;D)=\\sum_{d=0}^{D}a_{d}x^{d}=\\sum_{d=0}^{D}a_{d}x^{\\sum_{j=0}^{J}2^{j}b_{d}^{(j)}}=\\sum_{d=0}^{D}a_{d}\\prod_{j=0}^{J}x^{2^{j}b_{d}^{(j)}}</span></p>

    <p class="text-gray-300">Then BG13 defines a new polynomial <span class="math">Q(e;J+1)</span> by substituting <span class="math">x^{2^{j}}</span> with a masking value <span class="math">z_{j}=x^{2^{j}}e+m_{j}</span> for each <span class="math">j</span>, such that the coefficient of the leadin</p>

    <p class="text-gray-300">term <span class="math">e^{J+1}</span> is equal to <span class="math">P(x;D)</span>, where <span class="math">m_{j}</span> is a random value, <span class="math">e</span> is the verifier’s random challenge and <span class="math">w_{j}</span> is the coefficient of the term <span class="math">e^{j}</span>.</p>

    <p class="text-gray-300"><span class="math">Q(e;J+1)=\\sum_{d=0}^{D}(a_{d}\\prod_{j=0}^{J}e^{1-b_{d}^{(j)}}z_{j}^{b_{d}^{(j)}})=P(x;D)e^{J+1}+\\sum_{j=0}^{J}w_{j}e^{j}</span> (5)</p>

    <p class="text-gray-300">The prover must provide the commitment to <span class="math">P(x;D)</span> and the commitments to the coefficients <span class="math">(w_{j})_{j=0}^{J}</span> before acquiring the challenge <span class="math">e</span> to prove that the polynomial <span class="math">Q(e;J+1)</span> is well formed. In a nutshell, there are three constraints to satisfy:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">P(x;D)</span> is the coefficient of the leading term <span class="math">e^{J+1}</span>.</li>

      <li>The linearity between <span class="math">x^{2^{j}}</span> and <span class="math">z_{j}=x^{2^{j}}e+m_{j}</span> for <span class="math">j\\in\\{0,...,J\\}</span>.</li>

      <li>The quadratic relations between <span class="math">x^{2^{j}}</span> hidden in <span class="math">z_{j}</span> and <span class="math">x^{2^{j+1}}</span> hidden in <span class="math">z_{j+1}</span> for <span class="math">j\\in\\{0,...,J-1\\}</span>.</li>

    </ol>

    <p class="text-gray-300">BG13 creates three sets of group elements <span class="math">(c_{x^{2^{j}}})_{j=1}^{J}</span>, <span class="math">(c_{m_{j}})_{j=0}^{J}</span>, <span class="math">(c_{(x^{2^{j}}m_{j})})_{j=0}^{J-1}</span> and two sets of field elements <span class="math">(r_{j})_{j=0}^{J},(\\xi_{j})_{j=0}^{J-1}</span>. Then it utilises two equations to fulfil the constraints 2 and 3 for each <span class="math">j</span>:</p>

    <p class="text-gray-300"><span class="math">z_{j}\\stackrel{{\\scriptstyle?}}{{=}}x^{2^{j}}e+m_{j}\\Longrightarrow\\textsf{Cm}(z_{j};r_{j})\\stackrel{{\\scriptstyle?}}{{=}}c_{x^{2^{j}}}^{e}\\cdot c_{m_{j}}</span> <span class="math">0\\stackrel{{\\scriptstyle?}}{{=}}x^{2^{j+1}}e-x^{2^{j}}z_{j}+x^{2^{j}}m_{j}\\Longrightarrow\\textsf{Cm}(0;\\xi_{j})\\stackrel{{\\scriptstyle?}}{{=}}c_{x^{2^{j+1}}}^{e}\\cdot c_{x^{2^{j}}}^{-z_{j}}\\cdot c_{(x^{2^{j}}m_{j})}</span></p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">4.2 Techniques of Lower-Degree (LD) Protocol</h3>

    <p class="text-gray-300">In this protocol, we aim for optimisations to fulfil the constraint 2 and 3 for better computational and communication efficiency. Our technique is a new equation in Eqn. (6) that effectively leverages the field elements <span class="math">(z_{j})_{j=0}^{J}</span> rather than the group elements as in BG13 to achieve the verification, which significantly improves the computational efficiency by reducing the number of group exponentiations. The two equations for simultaneously satisfying the constraint 2 and 3 are:</p>

    <p class="text-gray-300"><span class="math">z_{0}\\stackrel{{\\scriptstyle?}}{{=}}xe+m_{0},\\hskip 17.07164ptz_{j}^{2}-z_{j+1}e\\stackrel{{\\scriptstyle?}}{{=}}(2x^{2^{j}}m_{j}-m_{j+1})e+m_{j}^{2},\\ j\\in\\{0,...,J-1\\}</span> (6)</p>

    <p class="text-gray-300">In Eqn. (6), first, we must ensure the linearity between the input <span class="math">x</span> and <span class="math">z_{0}</span>. Then computing <span class="math">z_{j}^{2}-z_{j+1}e</span> for <span class="math">j\\in\\{0,...,J-1\\}</span> will cancel out quadratic terms <span class="math">e^{2}</span> and leave the first-order term <span class="math">(2x^{2^{j}}m_{j}-m_{j+1})e</span> and the constant term <span class="math">m_{j}^{2}</span>. Our techniques only require the prover to provide the vector commitments to the coefficients of these two terms before acquiring the challenge <span class="math">e</span>. This not only ensures the quadratic relations between <span class="math">x^{2^{j}}</span> and <span class="math">x^{2^{j+1}}</span> but also justifies the linearity between <span class="math">x^{2^{j}}</span> and <span class="math">z_{j}=x^{2^{j}}e+m_{j}</span> for <span class="math">j\\in\\{1,...,J-1\\}</span>. Otherwise, the quadratic terms <span class="math">e^{2}</span> must have appeared on the right-hand side with overwhelming probability. Compared with the techniques of BG13, ours entail far fewer computationally expensive group operations. With respect to the communication cost, the reduction by <span class="math">5\\log D</span> elements is essentially attributed to the use of vector commitments. Moreover, our new equation in Eqn. (6) also contributes to decreasing the proof size.</p>

    <p class="text-gray-300">N. Wang and S.C.K. Chau</p>

    <p class="text-gray-300">On top of the lower-degree protocol, we aim for a further optimisation to fulfil the constraint 1. We attempt to trade <span class="math">\\log D</span> group elements in Eqn. (5) for <span class="math">3\\sqrt{\\log D}</span> group and field elements by applying the technique of the polynomial commitment [10]. Intuitively, we can factor out common polynomial factors from the polynomial <span class="math">\\sum_{j=0}^{J} w_{j} e^{j}</span>. First, we rewrite <span class="math">\\sum_{j=0}^{J} w_{j} e^{j}</span> as <span class="math">\\sum_{l=0}^{L-1} e^{lK} \\sum_{k=0}^{K-1} w_{lK+k} e^{k}</span> without loss of generality by padding with zero coefficients, where <span class="math">J + 1 = L \\cdot K</span> and <span class="math">l \\in \\{0,..,L-1\\}</span>, <span class="math">k \\in \\{0,..,K-1\\}</span>. <span class="math">L</span> polynomials <span class="math">(\\sum_{k=0}^{K-1} w_{lK+k} e^{k})_{l=0}^{L-1}</span> can be factored out to build a matrix in a way that each row contains the coefficients of the factored polynomials, and each column is a vector of the coefficients of the same-order of <span class="math">e</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\left( \\begin{array}{c c c c} w _ {0} + \\theta_ {0} &amp;amp; w _ {1} &amp;amp; \\ldots w _ {K - 1} \\\\ w _ {K} + \\theta_ {1} &amp;amp; w _ {K + 1} &amp;amp; \\ldots w _ {2 K - 1} \\\\ \\vdots &amp;amp; \\vdots &amp;amp; \\ddots &amp;amp; \\vdots \\\\ w _ {(L - 1) K} + \\theta_ {L - 1} &amp;amp; w _ {(L - 1) K + 1} &amp;amp; \\ldots w _ {L K - 1} \\end{array} \\right)</span></div>

    <p class="text-gray-300">The prover commits to all the columns as <span class="math">(c_{w_k})_{k=0}^{K-1}</span> using vector commitments and creates a field value <span class="math">f_l = \\sum_{k=0}^{K-1} w_{lK+k} e^k + \\theta_l</span> for each <span class="math">l</span>, which is a randomised inner product of the <span class="math">l</span>-th row and the challenge vector <span class="math">(1, e, \\dots, e^{K-1})^\\top</span>, where <span class="math">\\theta_l \\in \\mathbb{Z}_p^*</span> is a random value to prevent leaking information about the coefficients <span class="math">(w_{lK+k})_{k=0}^{K-1}</span>.</p>

    <div class="my-4 text-center"><span class="math-block">c _ {w _ {0}} = \\prod_ {l = 0} ^ {L - 1} g _ {l} ^ {w _ {l K} + \\theta_ {l}} \\cdot h ^ {r _ {w _ {0}}} \\quad (c _ {w _ {k}} = \\prod_ {l = 0} ^ {L - 1} g _ {l} ^ {w _ {l K + k}} \\cdot h ^ {r _ {w _ {k}}}) _ {k = 1} ^ {K - 1}</span></div>

    <p class="text-gray-300">where <span class="math">(g_l)_{l=0}^{L-1} \\stackrel{\\S}{\\leftarrow} \\mathbb{G}^L, h \\stackrel{\\S}{\\leftarrow} \\mathbb{G}</span> are distinct generators and <span class="math">(r_{w_k} \\stackrel{\\S}{\\leftarrow} \\mathbb{Z}_p^*)_{k=0}^{K-1}</span> are random values.</p>

    <p class="text-gray-300">The verifier computes <span class="math">\\prod_{l=0}^{L-1} g_l^{f_l} \\cdot h^s \\stackrel{?}{=} \\prod_{k=0}^{K-1} c_{w_k}^{e^k}</span> to check the correctness of <span class="math">(f_l)_{l=0}^{L-1}</span>, where <span class="math">s = \\sum_{k=0}^{K-1} r_{w_k} e^k</span>, and constructs a new equation in Eqn. (7) to replace Eqn. (5) for the constraint 1:</p>

    <div class="my-4 text-center"><span class="math-block">Q (e; J + 1) - \\sum_ {l = 0} ^ {L - 1} f _ {l} e ^ {l K} \\stackrel {?} {=} P (x; D) e ^ {J + 1} - \\sum_ {l = 0} ^ {L - 1} \\theta_ {l} e ^ {l K} \\tag {7}</span></div>

    <p class="text-gray-300">The prover is required to provide the commitments to <span class="math">(\\theta_l)_{l=0}^{L-1}</span> before obtaining the challenge <span class="math">e</span>. In addition to the proof size reduction, this technique greatly reduces the number of group exponentiations, which improves the efficiency in both communication and verification.</p>

    <p class="text-gray-300">The aggregation of multiple arguments is supported for a significant efficiency improvement. Recall that our techniques enable a non-trivial reduction in the</p>

    <p class="text-gray-300">Flashproofs: Zero-Knowledge Arguments of Range &amp; Polynomial Evaluation</p>

    <p class="text-gray-300">communication cost to <span class="math">\\log D + 3\\sqrt{\\log D} + 7</span> elements for higher-degree polynomials, where <span class="math">J + 1</span> field elements <span class="math">(z_{j} = x^{2^{j}}e + m_{j})_{j=0}^{J}</span> dominate the whole argument. Thus, multiple arguments satisfying different polynomials with the same degree and inputs can split the communication cost of these field elements. Given <span class="math">M</span> polynomials <span class="math">\\{P(x;D)^{(m)}\\}_{m=0}^{M-1}</span> of the same degree <span class="math">D</span>, the prover utilises <span class="math">M \\cdot L</span> generators to create <span class="math">K</span> commitments <span class="math">(c_{w_k})_{k=0}^{K-1}</span> by compacting the coefficients of all <span class="math">M</span> arguments. Then the prover provides two unique sets of <span class="math">(f_l^{(m)})_{l=0}^{L-1}</span> and <span class="math">(\\theta_l^{(m)})_{l=0}^{L-1}</span> for each <span class="math">m \\in \\{0, \\dots, M-1\\}</span>. Similar to the aggregate range argument, the verifier uses the equation below to check the constraint 1 for multiple arguments in batches, where <span class="math">z \\in \\mathbb{Z}_p^*</span> is a new random challenge provided by the verifier:</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{m = 0}^{M - 1} \\left(Q (e; J + 1) ^ {(m)} - \\sum_{l = 0}^{L - 1} f _ {l} ^ {(m)} e ^ {l K}\\right) z ^ {m} \\stackrel {?} {=} \\sum_{m = 0}^{M - 1} P (x; D) ^ {(m)} z ^ {m} e ^ {J + 1} - \\sum_{l = 0}^{L - 1} \\left(\\sum_{m = 0}^{M - 1} \\theta_ {l} ^ {(m)} z ^ {m}\\right) e ^ {l K}</span></div>

    <p class="text-gray-300">For aggregating <span class="math">M</span> arguments, we can use the formula <span class="math">\\frac{\\log D + \\sqrt{\\log D} + 7}{M} + 2\\sqrt{\\log D}</span> to calculate the number of elements for communication cost or the allocated number of group exponentiations for verification per argument. For a certain degree <span class="math">D</span>, the efficiency in verification (group exponentiations) and communication asymptotically approaches <span class="math">O(\\sqrt{\\log D})</span> when <span class="math">M</span> increases.</p>

    <h2 id="sec-21" class="text-2xl font-bold">4.5 Limitation &amp; Extension</h2>

    <p class="text-gray-300"><strong>Limitation</strong> Overall, our techniques aim to reduce the number of group exponentiations and elements for superior efficiency in computation and communication. Based on the techniques of BG13, unfortunately, our protocols still inherit its limitation of using a linear number of field multiplications in verification for evaluating the worse-case polynomials with few zero terms. The field multiplications would dominate the computational costs over the group exponentiations when the degrees are fairly large, even the latter ones are far more computationally expensive. However, the computational costs of high-order polynomials with quite a few zero terms are less subject to this limitation. Hence, the more zero terms, the less subject to this limitation.</p>

    <p class="text-gray-300"><strong>Extension</strong> Our arguments can be extended to satisfy multi-variate polynomial relations, e.g., the inner-product of two vectors. The efficiency in communication and computation would be linear in the number of variates.</p>

    <h2 id="sec-22" class="text-2xl font-bold">5 Empirical Experiments</h2>

    <p class="text-gray-300">In our experiments, we measured verification gas costs of the range proofs on Ethereum, one of the most popular blockchain platforms supporting smart contracts. We employed the 254-bit elliptic curve <span class="math">BN-128</span> [18] that ensures 127-bit</p>

    <p class="text-gray-300">6 Gas costs would be significantly reduced if precompiled contracts for non-pairing curves, e.g., secp256k1, are supported in future on smart contract platforms.</p>

    <p class="text-gray-300">N. Wang and S.C.K. Chau</p>

    <p class="text-gray-300">security as Ethereum provides gas-efficient precompiled contracts for BN-128 curve operations. We adopted keccak256 (Ethereum-SHA-3) as the hash function modelling the random oracle. Our empirical evaluation was conducted with the processor Intel Core i7-8700 CPU @3.2GHz.</p>

    <p class="text-gray-300">For range arguments, we conducted a full-scale performance comparison with several state-of-the-art range proofs with respect to the computational costs and gas costs on Ethereum. For polynomial evaluation arguments, we essentially compare the computational efficiency between ours and BG13. We skipped the measurement of Bulletproofs as its running time of both proving and verification is considerably greater than those two. The Java and Solidity code is published at this link <span class="math">^7</span> .</p>

    <p class="text-gray-300">Computational Cost We measured running time in milliseconds as an evaluation metric of the computational costs. We used the well-known Bouncy Castle Crypto APIs [12] to implement the BN-128 elliptic curve since they were initially used in the Java implementation <span class="math">^{8}</span>  of Bulletproofs [9], which facilitates a fair comparison. All the experiments were executed on the Java Virtual Machine 15 in a single thread, with results averaged over 50 instances. Note that the Java implementation was aimed at performance comparison. Rust programming language is more suited to commercial usage for high efficiency.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> (a) Computational costs. Fig. 2: Computational cost of our range arguments.</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> (b) Allocated verification costs.</p>

    <p class="text-gray-300">Fig. 2a describes the running time of proving and verification in milliseconds of our optimised range arguments. The verification running time is  <span class="math">O(N^{\\frac{2}{3}})</span>  sublinear in the range size. The proving running time is slightly sub-linear when  <span class="math">N \\leq 64</span> , which corresponds to the holistic sub-linearity in Fig. 1. Table 5 shows a detailed running time comparison with other state-of-the-art proofs. Our range arguments outperform Bulletproof in both proving and verification. Moreover, at a comparable level of soundness errors, our range arguments do not perform as efficiently as CKLR21 in proving but present higher efficiency in verification. Fig. 2b illustrates the allocated number of group exponentiations per argument for verifying aggregate range arguments with the increased aggregation size. The</p>

    <p class="text-gray-300">Flashproofs: Zero-Knowledge Arguments of Range &amp; Polynomial Evaluation</p>

    <p class="text-gray-300">Table 5: Running time of range proofs in milliseconds, where CKLR21 was respectively run 3 and 5 iterations for 32-bit and 64-bit ranges to achieve a soundness error  <span class="math">2^{-240}</span> , which is practically close to  <span class="math">2^{-254}</span>  of ours. For CKLR21, we considered the additional  <span class="math">54\\%</span>  of the proving computational costs caused by reruns (mentioned in their paper).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Type</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">8-bit</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">16-bit</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">32-bit</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">64-bit</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Prove</td>

            <td class="px-3 py-2 border-b border-gray-700">This work</td>

            <td class="px-3 py-2 border-b border-gray-700">21.8</td>

            <td class="px-3 py-2 border-b border-gray-700">36.4</td>

            <td class="px-3 py-2 border-b border-gray-700">64.4</td>

            <td class="px-3 py-2 border-b border-gray-700">111.5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">CKLR21</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">55.1</td>

            <td class="px-3 py-2 border-b border-gray-700">73.9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Bulletproof</td>

            <td class="px-3 py-2 border-b border-gray-700">132.2</td>

            <td class="px-3 py-2 border-b border-gray-700">251.4</td>

            <td class="px-3 py-2 border-b border-gray-700">482</td>

            <td class="px-3 py-2 border-b border-gray-700">950.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verify</td>

            <td class="px-3 py-2 border-b border-gray-700">This work</td>

            <td class="px-3 py-2 border-b border-gray-700">13.4</td>

            <td class="px-3 py-2 border-b border-gray-700">18.7</td>

            <td class="px-3 py-2 border-b border-gray-700">27.1</td>

            <td class="px-3 py-2 border-b border-gray-700">35.5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">CKLR21</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">37.9</td>

            <td class="px-3 py-2 border-b border-gray-700">50.8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Bulletproof</td>

            <td class="px-3 py-2 border-b border-gray-700">51</td>

            <td class="px-3 py-2 border-b border-gray-700">85.9</td>

            <td class="px-3 py-2 border-b border-gray-700">150.5</td>

            <td class="px-3 py-2 border-b border-gray-700">262.9</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Fig. 3: Computational costs of polynomial evaluation arguments.</p>

    <p class="text-gray-300">costs are reduced asymptotically as the aggregation size grows. About  <span class="math">35\\%</span>  of the group exponentiations per argument are saved when 16 arguments of the 64-bit range are aggregated.</p>

    <p class="text-gray-300">Fig. 3 shows a running time comparison between our polynomial evaluation arguments and BG13 for monomials of different degrees <span class="math">^9</span> . The computational costs grow logarithmically with the increased degrees. The higher-degree and lower-degree arguments significantly outperform BG13 in proving and verification. Besides, the running time discrepancy between higher-degree and lower-degree arguments diminishes with the increased degrees. It is foreseeable that the higher-degree ones would be more competitive for the degrees over  <span class="math">2^9</span> .</p>

    <p class="text-gray-300">Gas Cost We used the Solidity programming language [32] and the Truffle development framework [39] to measure the gas costs of verifying range proofs on Ethereum. We set 500,000 to the optimize-runs <span class="math">^{10}</span>  parameter of the Solidity</p>

    <p class="text-gray-300">N. Wang and S.C.K. Chau</p>

    <p class="text-gray-300">Table 6: Gas costs of verification on Ethereum in ascending order. SONIC* indicates that the gas costs are estimated based on the data in SONIC [35]. We used the latest standard prices of gas and ether for reference at the time of writing, which were 15 GWei and $1745 USD, respectively, taken from [24] and [19] at UTC 11:15 am 12 September 2022. Note that the prices are subject to market fluctuations, but the gas costs tend to be stable and more meaningful.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Type</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Transparent Setup</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Gas Cost</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ether</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">USD</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof Size (Byte)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">zkSNARK (Groth16)</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">220,100</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0033</td>

            <td class="px-3 py-2 border-b border-gray-700">$5.8</td>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This work (32-bit)</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">233,250</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0035</td>

            <td class="px-3 py-2 border-b border-gray-700">$6.1</td>

            <td class="px-3 py-2 border-b border-gray-700">738</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This work (64-bit)</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">314,140</td>

            <td class="px-3 py-2 border-b border-gray-700">0.00471</td>

            <td class="px-3 py-2 border-b border-gray-700">$8.2</td>

            <td class="px-3 py-2 border-b border-gray-700">994</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">zkSNARK (SONIC, Helped)*</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">492,000</td>

            <td class="px-3 py-2 border-b border-gray-700">0.00738</td>

            <td class="px-3 py-2 border-b border-gray-700">$12.9</td>

            <td class="px-3 py-2 border-b border-gray-700">385</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">zkSNARK (SONIC, Unhelped)*</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">655,000</td>

            <td class="px-3 py-2 border-b border-gray-700">0.00983</td>

            <td class="px-3 py-2 border-b border-gray-700">$17.2</td>

            <td class="px-3 py-2 border-b border-gray-700">1155</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">zkSNARK (BCTV14)</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">773,124</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0116</td>

            <td class="px-3 py-2 border-b border-gray-700">$20.2</td>

            <td class="px-3 py-2 border-b border-gray-700">288</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Bulletproofs (32-bit)</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">2,046,252</td>

            <td class="px-3 py-2 border-b border-gray-700">0.03069</td>

            <td class="px-3 py-2 border-b border-gray-700">$53.6</td>

            <td class="px-3 py-2 border-b border-gray-700">610</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Bulletproofs (64-bit)</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">3,703,549</td>

            <td class="px-3 py-2 border-b border-gray-700">0.05555</td>

            <td class="px-3 py-2 border-b border-gray-700">$96.9</td>

            <td class="px-3 py-2 border-b border-gray-700">674</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">compiler with version 0.8.0. We ran the solidity-based code [1] to measure the gas costs of Bulletproof. We also measured the gas costs of verifying a zkSNARK (Groth16) [28] and a zkSNARK (BCTV14) [7] by running the solidity code from [30] and [23]. Note that the code of two zkSNARKs may not be used for verifying range proofs. But we feel it is meaningful to provide the results for reference as the zkSNARKs benefit from trusted setups to achieve constant verification efficiency for any arithmetic circuits.</p>

    <p class="text-gray-300">Table 6 shows a comprehensive comparison of verification gas costs on Ethereum in ascending order. Benefitting from a trusted setup, the zkSNARK (Groth16) ranks first. Our range arguments incur a comparable amount of gas costs to Groth16 and the least gas costs among those not requiring trusted setups. Notably, there is hardly any discrepancy in gas costs between Groth16 and our 32-bit range argument. We also roughly estimated the gas costs of SONIC, a typical zkSNARK with an updatable structured reference string setup. The helped and unhelped arguments consume approximately 492K and 655K, where helped means their proofs use an additional "helper" batch verification technique to improve the verification efficiency. The zkSNARK (BCTV14) consumes a constant 773K gas with the second smallest proof size. However communication efficient, Bulletproof is the most gas-consuming proof, which incurs 2046K and 3703K gas for 32-bit and 64-bit ranges. Moreover, from Table 2b, the aggregation of 16 of our range arguments saves an average of 8.2 (49.2K gas) and 10.6 (63.6K gas) group exponentiations per argument for 32-bit and 64-bit ranges, respectively, where one group exponentiation costs 6K gas [16] for BN-128 elliptic curve on Ethereum. Thus, it is estimated that the allocated gas costs per argument can be reduced to about 184,050 gas (0.00276 ETH, <span class="math">4.8) and 250,540 gas (0.00376 ETH, </span>6.6).</p>

    <p class="text-gray-300">Flashproofs: Zero-Knowledge Arguments of Range &amp; Polynomial Evaluation</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Fig. 4: Allocated communication costs of aggregate range arguments.</p>

    <p class="text-gray-300">Communication Cost We measured proof sizes as communication costs over a 256-bit field, the standard word size on Ethereum. We used the compressed form of elliptic curve points, where one point can be stored as a 256-bit value plus one extra bit indicating one of the two possible y coordinates. In Table 6, Bulletproof is the most communication-efficient among those not requiring trusted setups for general 32-bit and 64-bit ranges. Our range arguments pursue superior computational efficiency through minor trade-offs in communication efficiency but still offer a slight advantage over CKLR21 at a comparable level of soundness errors. Fig. 4 shows a comparison of the communication costs of 64-bit aggregate range arguments <span class="math">^{11}</span>  between Bulletproof and ours. Despite being less efficient than Bulletproof, our range arguments still achieve satisfactory performance, whose allocated communication cost per argument is asymptotically reduced to 656 bytes for the aggregation of 16 arguments. For instance, regarding 50 million UTXOs from 22 million transactions with 52-bit bitcoins, the aggregate Bulletproof and ours would take up about 17GB [13] and 42GB. The communication cost is still a factor of  <span class="math">3.8 \\times</span>  reduction in size, compared to the 160GB data <span class="math">^{12}</span>  of less succinct proofs in the current systems. Please see Table 3 for the communication cost comparison of polynomial evaluation arguments.</p>

    <p class="text-gray-300">We describe the full protocol of our range arguments. Given a witness  <span class="math">y \\in \\mathbb{Z}_p</span> , a random  <span class="math">r_y \\stackrel{\\S}{\\leftarrow} \\mathbb{Z}_p^*</span> , a commitment  <span class="math">c_y = g^y h^{r_y} \\in \\mathbb{G}</span>  and the generators  <span class="math">g, h \\stackrel{\\S}{\\leftarrow} \\mathbb{G}</span> ,  <span class="math">(g_l)_{l=0}^{L-1} \\stackrel{\\S}{\\leftarrow} \\mathbb{G}^L</span> , the protocol aims to prove  <span class="math">y \\in [0, 2^N - 1]</span> :</p>

    <p class="text-gray-300">Prover :</p>

    <div class="my-4 text-center"><span class="math-block">y = \\sum_ {i = 0} ^ {N - 1} 2 ^ {i} b _ {i}, \\quad b _ {i} \\in \\{0, 1 \\}, \\quad N + \\gamma = L \\cdot K, L, K \\geq 2, \\text {f o r s o m e} \\gamma \\in \\mathbb {Z} ^ {0 +} \\tag {8}</span></div>

    <p class="text-gray-300">N. Wang and S.C.K. Chau</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=0}^{N-1} 2^{i} b_{i} \\rightarrow \\left(\\begin{array}{cccc} w_{0} &amp;amp; \\cdots &amp;amp; w_{K-1} \\\\ w_{K} &amp;amp; \\cdots &amp;amp; w_{K+K-1} \\\\ \\vdots &amp;amp; \\ddots &amp;amp; \\vdots \\\\ w_{(L-1)K} &amp;amp; \\cdots &amp;amp; w_{(L-1)K+K-1} \\end{array}\\right), \\tag{9}</span></div>

    <p class="text-gray-300">where <span class="math">w_{IK+k} = 2^{IK+k} b_{IK+k}</span> for <span class="math">l \\in \\{0, \\dots, L-1\\}</span>, <span class="math">k \\in \\{0, \\dots, K-1\\}</span></p>

    <div class="my-4 text-center"><span class="math-block">(r_{l} \\leftarrows \\mathbb{Z}_{p}^{*})_{l=0}^{L-1}, \\quad (r_{s_{k}} \\leftarrows \\mathbb{Z}_{p}^{*})_{k=1}^{K}, \\quad (r_{q_{k}} \\leftarrows \\mathbb{Z}_{p}^{*})_{k=0}^{K}, \\quad (r_{t_{k,j}} \\leftarrows \\mathbb{Z}_{p}^{*})_{k=0,j=1}^{k=K-2, j=K-1} \\tag{10}</span></div>

    <p class="text-gray-300"><strong>Prover <span class="math">\\Longrightarrow</span> Verifier :</strong></p>

    <div class="my-4 text-center"><span class="math-block">(c_{s_{k}} = g^{\\sum_{l=0}^{L-1} w_{IK+k}} h^{r_{s_{k}}})_{k=0}^{K-1}, \\quad c_{s_{K}} = g^{\\sum_{l=0}^{L-1} r_{l}} h^{r_{s_{K}}}, \\text{ where } r_{s_{0}} = r_{y} - \\sum_{k=1}^{K-1} r_{s_{k}} \\tag{11}</span></div>

    <div class="my-4 text-center"><span class="math-block">(c_{t_{k,j}} = \\prod_{l=0}^{L-1} g_{l}^{t_{l,k,j}} \\cdot h^{r_{t_{k,j}}})_{k=0,j=1}^{k=K-2, j=K-1}, \\text{ for } k \\neq j \\tag{12}</span></div>

    <p class="text-gray-300">where <span class="math">t_{l,k,j} = w_{IK+k}(2^{IK+j} - w_{IK+j}) + w_{IK+j}(2^{IK+k} - w_{IK+k})</span></p>

    <div class="my-4 text-center"><span class="math-block">(c_{q_{k}} = \\prod_{l=0}^{L-1} g_{l}^{q_{l,k}} \\cdot h^{r_{q_{k}}})_{k=0}^{K} \\tag{13}</span></div>

    <p class="text-gray-300">where <span class="math">(q_{l,k} = 2r_{l}(2^{IK+k-1} - w_{IK+k}))_{k=0}^{K-1}</span>, <span class="math">q_{l,K} = -r_{l}^{2}</span></p>

    <p class="text-gray-300"><strong>Prover <span class="math">\\Longleftarrow</span> Verifier :</strong> <span class="math">(e_{k} \\leftarrows \\mathbb{Z}_{p}^{*})_{k=0}^{K-1}</span></p>

    <p class="text-gray-300"><strong>Prover <span class="math">\\Longrightarrow</span> Verifier :</strong></p>

    <div class="my-4 text-center"><span class="math-block">(v_{l} = \\sum_{k=0}^{K-1} w_{IK+k} e_{k} + r_{l})_{l=0}^{L-1} \\tag{14}</span></div>

    <div class="my-4 text-center"><span class="math-block">u = \\sum_{k=0,j=1}^{k=K-2, j=K-1} r_{t_{k,j}} e_{k,j} + \\sum_{k=0}^{K-1} r_{q_{l,k}} e_{k} + r_{q_{l,K}}, \\quad \\epsilon = \\sum_{k=0}^{K-1} r_{s_{k}} e_{k} + r_{s_{K}} \\tag{15}</span></div>

    <p class="text-gray-300">where <span class="math">e_{k,j} = e_{k}e_{j}</span>, for <span class="math">k \\neq j</span></p>

    <p class="text-gray-300"><strong>Verifier :</strong></p>

    <div class="my-4 text-center"><span class="math-block">\\prod_{l=0}^{L-1} g_{l}^{f_{l} v_{l}} \\cdot h^{u} \\stackrel{?}{=} \\prod_{k=0,j=1}^{k=K-2, j=K-1} c_{t_{k,j}}^{e_{k,j}} \\cdot \\prod_{k=0}^{K-1} c_{q_{k}}^{e_{k}} \\cdot c_{q_{K}}, \\text{ where } f_{l} = \\sum_{k=0}^{K-1} 2^{IK+k} e_{k} - v_{l} \\tag{16}</span></div>

    <div class="my-4 text-center"><span class="math-block">g^{\\sum_{l=0}^{L-1} v_{l}} \\cdot h^{\\epsilon} \\stackrel{?}{=} \\prod_{k=0}^{K-1} c_{s_{k}}^{e_{k}} \\cdot c_{s_{K}} \\tag{17}</span></div>

    <div class="my-4 text-center"><span class="math-block">c_{y} \\stackrel{?}{=} \\prod_{k=0}^{K-1} c_{s_{k}} \\tag{18}</span></div>

    <p class="text-gray-300"><strong>Theorem 1.</strong> Our range arguments have perfect completeness, computational witness-extended emulation and perfect special honest verifier zero-knowledge (SHVZK).</p>

    <p class="text-gray-300">Flashproofs: Zero-Knowledge Arguments of Range &amp; Polynomial Evaluation</p>

    <p class="text-gray-300">Proof. Perfect completeness follows by a careful inspection of the protocol. Then we describe a perfect SHVZK simulation. Given a challenge vector  <span class="math">(e_k)_{k=0}^{K-1}</span> , a simulator randomly chooses group elements  <span class="math">(c_{t_{k,j}})_{k=0,j=1}^{k=K-2,j=K-1}</span> ,  <span class="math">(c_{s_k})_{k=1}^{K-1}</span> ,  <span class="math">(c_{q_k})_{k=1}^K</span>  and field elements  <span class="math">(\\nu_l)_{l=0}^{L-1}</span> ,  <span class="math">u, \\epsilon</span> . By the perfect hiding property, the commitments in a real argument are uniformly random as in the simulation. The field elements in a real argument are also uniformly random due to the random choices of  <span class="math">(r_l)_{l=0}^{L-1}</span> ,  <span class="math">r_{q_K}</span>  and  <span class="math">r_{s_K}</span> . Hence, in both real argument and simulation, the random elements uniquely determine the values  <span class="math">c_{q_K}</span>  in Eqn. (16),  <span class="math">c_{s_0}</span>  in Eqn. (18) and  <span class="math">c_{s_K}</span>  in (17). This means we have identical distributions of real and simulated arguments with the given challenge vector.</p>

    <p class="text-gray-300">Finally, we prove witness-extended emulation. An emulator  <span class="math">\\mathcal{E}</span>  runs the argument with uniformly random challenges and rewrites the prover until it acquires  <span class="math">T = \\frac{K^2 + K + 2}{2}</span>  accepting transcripts. We expect  <span class="math">\\mathcal{E}</span>  to rewind  <span class="math">\\frac{T}{B} \\cdot \\delta = T</span>  times, where  <span class="math">\\delta</span>  is the probability of a prover making a convincing argument. Thus,  <span class="math">\\mathcal{E}</span>  runs in expected polynomial time. Then we can obtain the openings of the commitments  <span class="math">(c_{t_{k,j}})_{k=0,j=1}^{k=K-2,j=K-1}</span>  and  <span class="math">(c_{q_k})_{k=0}^K</span>  by computing:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t1,0,1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r10,1</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">:</td>

            <td class="px-3 py-2 border-b border-gray-700">:</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">t1,K-2,K-1</td>

            <td class="px-3 py-2 border-b border-gray-700">r1K-2,K-1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">q1,0</td>

            <td class="px-3 py-2 border-b border-gray-700">rq0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">:</td>

            <td class="px-3 py-2 border-b border-gray-700">:</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">q1,K-1</td>

            <td class="px-3 py-2 border-b border-gray-700">rqK-1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">q1,K</td>

            <td class="px-3 py-2 border-b border-gray-700">rqK</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We can also extract the openings of the commitments  <span class="math">(c_{s_k})_{k=0}^K</span>  by computing:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">∑l=0L-1w1K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">rs0</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">:</td>

            <td class="px-3 py-2 border-b border-gray-700">:</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">∑l=0L-1w1K+K-1</td>

            <td class="px-3 py-2 border-b border-gray-700">rsK-1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">∑l=0L-1r1</td>

            <td class="px-3 py-2 border-b border-gray-700">rsK</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Both two left multiplying matrices on the right-hand side consist of uniformly random challenges. They are invertible for being full-rank matrices, where all the rows and columns are linearly independent. Finally, the witness  <span class="math">y</span>  can be obtained by summing up the openings of  <span class="math">(c_{s_k})_{k=0}^{K-1}</span> .</p>

    <p class="text-gray-300">We describe the full protocol of our lower-degree polynomial evaluation arguments. Given two witnesses  <span class="math">x, y \\in \\mathbb{Z}_p</span> , two randoms  <span class="math">r_x, r_y \\stackrel{\\S}{\\leftarrow} \\mathbb{Z}_p^*</span> , two commitments  <span class="math">c_x = g^x h^{r_x}, c_y = g^y h^{r_y} \\in \\mathbb{G}</span>  and the generators  <span class="math">g, h \\stackrel{\\S}{\\leftarrow} \\mathbb{G}, (g_j)_{j=0}^{J-1} \\stackrel{\\S}{\\leftarrow} \\mathbb{G}^J</span> ,</p>

    <p class="text-gray-300">N. Wang and S.C.K. Chau</p>

    <p class="text-gray-300">the protocol aims to prove <span class="math">y = P(x;D) = \\sum_{d=0}^{D} a_{d} x^{d}</span>, <span class="math">D = 2^{J+1} - 1</span>, <span class="math">J \\in \\{1,2,\\ldots\\}</span>:</p>

    <p class="text-gray-300"><strong>Prover :</strong></p>

    <div class="my-4 text-center"><span class="math-block">y = \\sum_{d=0}^{D} a_{d} x^{d} = \\sum_{d=0}^{D} a_{d} \\prod_{j=0}^{J} x^{2^{j} b_{d}^{(j)}}, \\quad d = \\sum_{j=0}^{J} 2^{j} b_{d}^{(j)}, \\quad b_{d}^{(j)} \\in \\{0,1\\}, \\quad J + 1 = \\lceil \\log D \\rceil \\tag{19}</span></div>

    <div class="my-4 text-center"><span class="math-block">(m_{j} \\stackrel{\\$}{\\leftarrow} \\mathbb{Z}_{p}^{*})_{j=0}^{J}, \\quad (r_{w_{j}} \\stackrel{\\$}{\\leftarrow} \\mathbb{Z}_{p}^{*})_{j=0}^{J}, \\quad r_{m}, \\quad r_{v_{0}}, \\quad r_{v_{1}}, \\quad \\dot{e} \\stackrel{\\$}{\\leftarrow} \\mathbb{Z}_{p}^{*}, \\quad (\\dot{z}_{j} = x^{2^{j}} \\dot{e} + m_{j})_{j=0}^{J} \\tag{20}</span></div>

    <div class="my-4 text-center"><span class="math-block">Q(\\dot{e}; J + 1) = \\sum_{d=0}^{D} \\left(a_{d} \\prod_{j=0}^{J} \\dot{e}^{1 - b_{d}^{(j)}} \\cdot \\dot{z}_{j}^{b_{d}^{(j)}}\\right) = y \\dot{e}^{J + 1} + \\sum_{j=0}^{J} w_{j} \\dot{e}^{j} \\tag{21}</span></div>

    <p class="text-gray-300"><strong>Prover <span class="math">\\Rightarrow</span> Verifier :</strong></p>

    <div class="my-4 text-center"><span class="math-block">c_{m} = g^{m_{0}} \\cdot h^{r_{m}} \\tag{22}</span></div>

    <div class="my-4 text-center"><span class="math-block">c_{v_{0}} = \\prod_{j=0}^{J-1} g_{j}^{m_{j}^{2}} \\cdot h^{r_{v_{0}}}, \\quad c_{v_{1}} = \\prod_{j=0}^{J-1} g_{j}^{2 m_{j} x^{2^{j}} - m_{j+1}} \\cdot h^{r_{v_{1}}} \\tag{23}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(c_{w_{j}} = g^{w_{j}} \\cdot h^{r_{w_{j}}}\\right)_{j=0}^{J} \\tag{24}</span></div>

    <p class="text-gray-300"><strong>Prover <span class="math">\\Leftarrow</span> Verifier :</strong> <span class="math">e \\stackrel{\\</span>}{\\leftarrow} \\mathbb{Z}_{p}^{*}$</p>

    <p class="text-gray-300"><strong>Prover <span class="math">\\Rightarrow</span> Verifier :</strong></p>

    <div class="my-4 text-center"><span class="math-block">\\left(z_{j} = x^{2^{j}} e + m_{j}\\right)_{j=0}^{J} \\tag{25}</span></div>

    <div class="my-4 text-center"><span class="math-block">t = r_{x} e + r_{m}, \\quad u = r_{v_{1}} e + r_{v_{0}}, \\quad s = r_{y} e^{J + 1} + \\sum_{j=0}^{J} r_{w_{j}} e^{j} \\tag{26}</span></div>

    <p class="text-gray-300"><strong>Verifier :</strong></p>

    <div class="my-4 text-center"><span class="math-block">g^{z_{0}} \\cdot h^{t} \\stackrel{?}{=} c_{s}^{e} \\cdot c_{m} \\tag{27}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\prod_{j=0}^{J-1} g_{j}^{z_{j}^{2} - z_{j+1} e} \\cdot h^{u} \\stackrel{?}{=} c_{v_{1}}^{e} \\cdot c_{v_{0}} \\tag{28}</span></div>

    <div class="my-4 text-center"><span class="math-block">g^{Q(e; J + 1)} \\cdot h^{s} \\stackrel{?}{=} c_{y}^{e^{J + 1}} \\cdot \\prod_{j=0}^{J} c_{w_{j}}^{e^{j}} \\tag{29}</span></div>

    <p class="text-gray-300"><strong>Theorem 2.</strong> Our polynomial evaluation arguments of lower-degree have perfect completeness, computational witness-extended emulation and perfect special honest verifier zero-knowledge (SHVZK).</p>

    <p class="text-gray-300"><strong>Proof.</strong> Perfect completeness follows by carefully inspecting the protocol. Next, we depict a perfect SHVZK simulation. Given a challenge <span class="math">e</span>, a simulator randomly picks up group elements <span class="math">c_{\\nu_1}, (c_{w_j})_{j=1}^J</span> and field elements <span class="math">(z_j)_{j=0}^J, t, u, s</span>. By the perfect hiding property and the random choices of <span class="math">(m_j)_{j=0}^J, r_m, r_{\\nu_0}, r_{w_0}</span>, the group and field elements are identically distributed in both real and simulated arguments. Therefore, in both real argument and simulation, the random elements uniquely determine the values <span class="math">c_m, c_{\\nu_0}</span> and <span class="math">c_{w_0}</span> in Eqn. (27), (28), (29).</p>

    <p class="text-gray-300">Flashproofs: Zero-Knowledge Arguments of Range &amp; Polynomial Evaluation</p>

    <p class="text-gray-300">Finally, we prove witness-extended emulation. An emulator  <span class="math">\\mathcal{E}</span>  runs the argument in expected polynomial time and rewrites the prover until it acquires  <span class="math">J + 2</span>  accepting transcripts. With the first two transcripts,  <span class="math">\\mathcal{E}</span>  is able to extract the witness  <span class="math">x = \\frac{z_0^{(1)} - z_0^{(0)}}{e_1 - e_0}</span>  and the random  <span class="math">r_x = \\frac{t_1 - t_0}{e_1 - e_0}</span> . We can also get the openings of  <span class="math">c_{v_1}</span>  and  <span class="math">c_{v_0}</span>  by computing:</p>

    <div class="my-4 text-center"><span class="math-block">\\left( \\begin{array}{c c} 2 m _ {j} x ^ {2 ^ {j}} - m _ {j + 1} &amp;amp; r _ {v _ {1}} \\\\ m _ {j} ^ {2} &amp;amp; r _ {v _ {0}} \\end{array} \\right) = \\left( \\begin{array}{c c} e _ {0} &amp;amp; 1 \\\\ e _ {1} &amp;amp; 1 \\end{array} \\right) ^ {- 1} \\cdot \\left( \\begin{array}{c} z _ {\\frac {j}{2}} ^ {2} - z _ {j + 1} e _ {0}   u _ {0} \\\\ z _ {j} ^ {2} - z _ {j + 1} e _ {1}   u _ {1} \\end{array} \\right)</span></div>

    <p class="text-gray-300">Similarly, for Eqn. (29), we obtain the openings of  <span class="math">c_{y}</span>  and  <span class="math">(c_{w_j})_{j=0}^{J-1}</span>  by computing:</p>

    <div class="my-4 text-center"><span class="math-block">\\left( \\begin{array}{c c} y &amp;amp; r _ {y} \\\\ w _ {J} &amp;amp; r _ {w _ {J}} \\\\ \\vdots &amp;amp; \\vdots \\\\ w _ {1} &amp;amp; r _ {w _ {1}} \\\\ w _ {0} &amp;amp; r _ {w _ {0}} \\end{array} \\right) = \\left( \\begin{array}{c c c c c} e _ {0} ^ {J + 1} &amp;amp; e _ {0} ^ {J} &amp;amp; \\ldots &amp;amp; e _ {0} &amp;amp; 1 \\\\ \\vdots &amp;amp; \\vdots &amp;amp; \\ddots &amp;amp; \\vdots &amp;amp; \\vdots \\\\ e _ {J + 1} ^ {J + 1} &amp;amp; e _ {J + 1} ^ {J} &amp;amp; \\ldots &amp;amp; e _ {J + 1} &amp;amp; 1 \\end{array} \\right) ^ {- 1} \\cdot \\left( \\begin{array}{c c} Q (e; J + 1) _ {0} &amp;amp; s _ {0} \\\\ \\vdots &amp;amp; \\vdots \\\\ Q (e; J + 1) _ {J + 1} &amp;amp; s _ {J + 1} \\end{array} \\right)</span></div>

    <p class="text-gray-300">where the left multiplying matrix is invertible for being a Vandermonde matrix. Thanks to the binding property of Pedersen commitment, we can conclude that  <span class="math">P(x;D)</span> , as the coefficient of the leading term of  <span class="math">Q(e;J + 1)</span> , is the opening of  <span class="math">c_{y}</span> .</p>

    <h2 id="sec-26" class="text-2xl font-bold">6.3 Polynomial Evaluation Arguments for Higher Degree</h2>

    <p class="text-gray-300">We describe the full protocol of our higher-degree polynomial evaluation arguments, where the witnesses are the same as those of lower-degree ones except using different generators  <span class="math">g, h \\stackrel{\\S}{\\leftarrow} \\mathbb{G}, (g_j)_{j=0}^{J-1} \\stackrel{\\S}{\\leftarrow} \\mathbb{G}^J, (g_l)_{l=0}^{L-1} \\stackrel{\\S}{\\leftarrow} \\mathbb{G}^L</span> :</p>

    <p class="text-gray-300"><strong>Prover :</strong></p>

    <div class="my-4 text-center"><span class="math-block">\\left(m _ {j} \\stackrel {\\S} {\\leftarrow} \\mathbb {Z} _ {p} ^ {*}\\right) _ {j = 0} ^ {J}, \\left(r _ {w _ {k}} \\stackrel {\\S} {\\leftarrow} \\mathbb {Z} _ {p} ^ {*}\\right) _ {k = 0} ^ {K - 1}, \\left(\\theta_ {l}, r _ {\\theta_ {l}} \\stackrel {\\S} {\\leftarrow} \\mathbb {Z} _ {p} ^ {*}\\right) _ {l = 0} ^ {L - 1}, r _ {m}, r _ {v _ {0}}, r _ {v _ {1}}, \\hat {e} \\stackrel {\\S} {\\leftarrow} \\mathbb {Z} _ {p} ^ {*} \\tag {30}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {j = 0} ^ {J} w _ {j} \\hat {e} ^ {j} = \\sum_ {l = 0} ^ {L - 1} \\hat {e} ^ {l K} \\sum_ {k = 0} ^ {K - 1} w _ {l K + k} \\hat {e} ^ {k}, \\quad J + 1 = \\lceil \\log D \\rceil = L \\cdot K, L, K \\geq 2 \\tag {31}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {l = 0} ^ {L - 1} \\theta_ {l} + \\sum_ {l = 0} ^ {L - 1} \\sum_ {k = 0} ^ {K - 1} w _ {l K + k} \\hat {e} ^ {k} = \\left( \\begin{array}{c c c c} w _ {0} + \\theta_ {0} &amp;amp; w _ {1} &amp;amp; \\ldots w _ {K - 1} \\\\ w _ {K} + \\theta_ {1} &amp;amp; w _ {K + 1} &amp;amp; \\ldots w _ {2 K - 1} \\\\ \\vdots &amp;amp; \\vdots &amp;amp; \\ddots &amp;amp; \\vdots \\\\ w _ {(L - 1) K} + \\theta_ {L - 1} &amp;amp; w _ {(L - 1) K + 1} &amp;amp; \\ldots w _ {L K - 1} \\end{array} \\right) \\cdot \\left( \\begin{array}{c} 1 \\\\ \\hat {e} \\\\ \\vdots \\\\ \\hat {e} ^ {K - 1} \\end{array} \\right) \\tag {32}</span></div>

    <p class="text-gray-300"><strong>Prover  <span class="math">\\Longrightarrow</span>  Verifier :</strong></p>

    <div class="my-4 text-center"><span class="math-block">c _ {m} = g ^ {m _ {0}} \\cdot h ^ {r _ {m}} \\tag {33}</span></div>

    <div class="my-4 text-center"><span class="math-block">c _ {v _ {0}} = \\prod_ {j = 0} ^ {J - 1} g _ {j} ^ {m _ {j} ^ {2}} \\cdot h ^ {r _ {v _ {0}}}, \\quad c _ {v _ {1}} = \\prod_ {j = 0} ^ {J - 1} g _ {j} ^ {2 m _ {j} x ^ {2 ^ {j}} - m _ {j + 1}} \\cdot h ^ {r _ {v _ {1}}} \\tag {34}</span></div>

    <div class="my-4 text-center"><span class="math-block">c _ {w _ {0}} = \\prod_ {l = 0} ^ {L - 1} g _ {l} ^ {w _ {l K} + \\theta_ {l}} \\cdot h ^ {r _ {w _ {0}}}, \\quad \\left(c _ {w _ {k}} = \\prod_ {l = 0} ^ {L - 1} g _ {l} ^ {w _ {l K + k}} \\cdot h ^ {r _ {w _ {k}}}\\right) _ {k = 1} ^ {K - 1} \\tag {35}</span></div>

    <p class="text-gray-300">N. Wang and S.C.K. Chau</p>

    <div class="my-4 text-center"><span class="math-block">\\left(c _ {\\theta_ {l}} = g ^ {- \\theta_ {l}} \\cdot h ^ {r _ {\\theta_ {l}}}\\right) _ {l = 0} ^ {L - 1} \\tag {36}</span></div>

    <p class="text-gray-300">Prover <span class="math">\\Longleftarrow</span> Verifier: <span class="math">e \\xleftarrow{\\S} \\mathbb{Z}_p^*</span></p>

    <p class="text-gray-300">Prover <span class="math">\\Longrightarrow</span> Verifier:</p>

    <div class="my-4 text-center"><span class="math-block">\\left(z _ {j} = x ^ {2 ^ {j}} e + m _ {j}\\right) _ {j = 0} ^ {J}, \\quad \\left(f _ {l} = \\sum_ {k = 0} ^ {K - 1} w _ {l K + k} e ^ {k} + \\theta_ {l}\\right) _ {l = 0} ^ {L - 1} \\tag {37}</span></div>

    <div class="my-4 text-center"><span class="math-block">t = r _ {x} e + r _ {m}, \\quad u = r _ {v _ {1}} e + r _ {v _ {0}}, \\quad s = \\sum_ {k = 0} ^ {K - 1} r _ {w _ {k}} e ^ {k}, \\quad q = r _ {y} e ^ {J + 1} + \\sum_ {l = 0} ^ {L - 1} r _ {\\theta_ {l}} e ^ {l K} \\tag {38}</span></div>

    <p class="text-gray-300">Verifier:</p>

    <div class="my-4 text-center"><span class="math-block">g ^ {z _ {0}} \\cdot h ^ {t} \\stackrel {?} {=} c _ {x} ^ {e} \\cdot c _ {m} \\tag {39}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\prod_ {j = 0} ^ {J - 1} g _ {j} ^ {z _ {j} ^ {2} - z _ {j + 1} e} \\cdot h ^ {u} \\stackrel {?} {=} c _ {v _ {1}} ^ {e} \\cdot c _ {v _ {0}} \\tag {40}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\prod_ {l = 0} ^ {L - 1} g _ {l} ^ {f _ {l}} \\cdot h ^ {s} \\stackrel {?} {=} \\prod_ {k = 0} ^ {K - 1} c _ {w _ {k}} ^ {e ^ {k}} \\tag {41}</span></div>

    <div class="my-4 text-center"><span class="math-block">g ^ {\\zeta} \\cdot h ^ {q} \\stackrel {?} {=} c _ {y} ^ {e ^ {J + 1}} \\cdot \\prod_ {l = 0} ^ {L - 1} c _ {\\theta_ {l}} ^ {e ^ {l K}}, \\quad \\text{where} \\ \\zeta = Q (e; J + 1) - \\sum_ {l = 0} ^ {L - 1} f _ {l} e ^ {l K} \\tag {42}</span></div>

    <p class="text-gray-300">Theorem 3. Our polynomial evaluation arguments of higher-degree have perfect completeness, computational witness-extended emulation and perfect special honest verifier zero-knowledge (SHVZK).</p>

    <p class="text-gray-300">Proof. Perfect completeness follows by a careful inspection of the protocol. Then, we provide a perfect SHVZK simulation. Given a challenge <span class="math">e</span>, a simulator randomly picks up group elements <span class="math">c_{\\nu_1}, (c_{w_k})_{k=1}^{K-1}, (c_{\\theta_l})_{l=1}^{L-1}</span> and field elements <span class="math">(z_j)_{j=0}^J, (f_l)_{l=0}^{L-1}, t, u, s, q</span>. By the perfect hiding property and the random choices of <span class="math">(m_j)_{j=0}^J, r_m, r_{\\nu_0}, r_{w_0}, (\\theta_l)_{l=0}^{L-1}</span>, the group and field elements are identically distributed in both real and simulated arguments. Therefore, in both real argument and simulation, the random elements uniquely determine the values <span class="math">c_m, c_{\\nu_0}, c_{w_0}</span> and <span class="math">c_{\\theta_0}</span> in Eqn. (39), (40), (41) and (42).</p>

    <p class="text-gray-300">Finally, we prove witness-extended emulation. We essentially describe the soundness of Eqn. (41) and (42) in this section. Please refer to Theorem 2 for the soundness of Eqn. (39) and (40). An emulator <span class="math">\\mathcal{E}</span> runs the argument and rewinds the prover until it acquires <span class="math">K</span> accepting transcripts. We have the openings of <span class="math">(c_{w_k})_{k=0}^{K-1}</span> by computing:</p>

    <div class="my-4 text-center"><span class="math-block">\\left( \\begin{array}{c c} w _ {l K + K - 1} &amp;amp; r _ {w _ {K - 1}} \\\\ \\vdots &amp;amp; \\vdots \\\\ w _ {l K + 1} &amp;amp; r _ {w _ {1}} \\\\ w _ {l K} + \\theta_ {l} &amp;amp; r _ {w _ {0}} \\end{array} \\right) = \\left( \\begin{array}{c c c c} e _ {0} ^ {K - 1} &amp;amp; \\ldots &amp;amp; e _ {0} &amp;amp; 1 \\\\ \\vdots &amp;amp; \\ddots &amp;amp; \\vdots &amp;amp; \\vdots \\\\ e _ {K - 1} ^ {K - 1} &amp;amp; \\ldots &amp;amp; e _ {K - 1} &amp;amp; 1 \\end{array} \\right) ^ {- 1} \\cdot \\left( \\begin{array}{c c} f _ {l} ^ {(0)} &amp;amp; s _ {0} \\\\ \\vdots &amp;amp; \\vdots \\\\ f _ {l} ^ {(K - 1)} &amp;amp; s _ {K - 1} \\end{array} \\right)</span></div>

    <p class="text-gray-300"><span class="math">\\mathcal{E}</span> rewinds the prover to acquire <span class="math">L+1</span> accepting transcripts for the openings of <span class="math">c_{\\mathrm{y}}</span> and <span class="math">(c_{\\theta_{0}})_{t=0}^{L-1}</span>:</p>

    <p class="text-gray-300">\\[ \\begin{pmatrix}y&r_{y}\\\\ -\\theta_{L-1}&r_{\\theta_{L-1}}\\\\ \\vdots&\\vdots\\\\ -\\theta_{0}&r_{\\theta_{0}}\\end{pmatrix}=\\begin{pmatrix}e_{0}^{J+1}&e_{0}^{(L-1)K}&\\ldots&1\\\\ \\vdots&\\vdots&\\ddots&\\vdots\\\\ e_{L}^{J+1}&e_{L}^{(L-1)K}&\\ldots&1\\end{pmatrix}^{-1}\\cdot\\begin{pmatrix}\\zeta_{0}&q_{0}\\\\ \\vdots&\\vdots\\\\ \\zeta_{L}&q_{L}\\end{pmatrix} \\]</p>

    <h2 id="sec-27" class="text-2xl font-bold">7 Related Work</h2>

    <h4 id="sec-28" class="text-lg font-semibold mt-6">7.0.1 Range Proofs</h4>

    <p class="text-gray-300">In 2003, Lipmaa <em>[33]</em> used Lagrange’s four-square theorem <em>[43]</em> to create a constant 1700-byte range proof with an arbitrary range. Groth <em>[27]</em> improved the proof by using Legendre’s three-square theorem. Deng et al. <em>[21]</em> also designed a constant-size range proof based on the RSA assumption by adapting Bulletproof for Lagrange’s four-square theorem. However, these proofs rely on the RSA assumption, which requires a trusted setup to generate the RSA modulus. In 2008, Camenisch et al. <em>[15]</em> proposed a range proof based on the signature approach that depends on the <span class="math">q</span>-Strong Diffie-Hellman assumption. Their method has <span class="math">O(N)</span> communication cost and requires a trusted setup to make the proof non-interactive, where <span class="math">N</span> is the bit length of the range. AZTEC protocol <em>[45]</em> also provided a signature-based range proof, which uses a trusted-setup protocol to build a huge signature database that contains every acceptable integer in the range. However, the security relies on trusting the parties that would destroy the private keys for generating the signatures. Bootle & Groth <em>[11]</em> presented a range argument under the DL assumption based on the bit-decomposition. Nonetheless, their approach achieves <span class="math">O(N)</span> complexity in communication and computation with a trusted setup. Besides, one could use the asymptotically efficient STARKS <em>[5]</em> to avoid a trusted setup. Nevertheless, the proof size is quite large at 45KB <em>[31]</em>. Supersonic <em>[14]</em> achieves efficient logarithmic efficiency in verification and communication based on class groups with a transparent setup. Nevertheless, class groups demand large groups to meet current security requirements, which are less commonly applied in practical systems.</p>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">7.0.2 Polynomial Evaluation Proofs</h4>

    <p class="text-gray-300">Table 1 lists a series of state-of-the-art generic-purpose zero-knowledge proofs with transparent setups. Most of them build on general NP-complete languages, which can be used for polynomial evaluation. Based on the hardness of the RSA assumption, Supersonic <em>[14]</em> is one of the most efficient proofs, which has <span class="math">O(\\log N)</span> efficiency in verification time and proof size. However, for a polynomial of degree <span class="math">D=2^{20}</span>, it still needs 10.1KB and 60 group exponentiations for verification, whereas our argument only needs 1.25KB and 40 group exponentiations. Bootle and Groth <em>[11]</em> also proposed a polynomial evaluation argument based on BG13. However, it relies on common reference strings as a trusted setup to achieve efficient <span class="math">O(\\frac{\\log N}{\\log\\log N})</span> complexity for proving and verification.</p>

    <p class="text-gray-300">N. Wang and S.C.K. Chau</p>

    <p class="text-gray-300">Table 7: An efficiency comparison [37] of generic-purpose zero-knowledge proofs with transparent setups for NP statements, where  <span class="math">N</span>  is the statement size.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Type</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ligero [2]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Bulletproofs [13]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">STARKs [5]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Aurora [6]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fractal [17]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Supersonic [14]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Spartan [37]</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Prover</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log2N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log N)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Running time |  |  |  |  |  |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(N)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(N)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(N log2N)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(N)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(log2N)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(log N)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(log2N)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Running time |  |  |  |  |  |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof Size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(√N)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(log N)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(log2N)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(log2N)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(log2N)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(log N)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(log2N)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Membership Proofs In this section, we provide a brief related work on membership proofs. Most membership proofs require trusted setups, exposing vulnerabilities that malicious provers can exploit. Proposed by Camenisch et al. [15] in 2008, the most classical membership argument is based on a bilinear-group signature scheme. Based on the  <span class="math">q</span> -Strong Diffie-Hellman assumption, the argument has  <span class="math">O(1)</span>  communication cost but requires  <span class="math">O(N)</span>  group elements as signatures of all elements in the given set for a preliminary procedure. Therefore, the argument needs a trusted setup to accomplish this procedure for non-interactivity. Furthermore, the authors also proposed an alternative approach using an RSA-based accumulator for short signatures. However, this approach does not remove the trusted setup, either. Recently, Benarroch et al. [8] presented an accumulator-based membership proof based on class groups without a trusted setup. For 128-bit security, the proof uses a 6000-bit discriminant class group to achieve a constant 6.4KB proof size. However, our membership argument requires a tremendous set of  <span class="math">2^{169} \\approx 7.5E50</span>  elements for this proof size, which tends to be more communication-efficient for general scenarios.</p>

    <p class="text-gray-300">In this paper, we proposed Flashproofs, a new type of efficient special honest verifier zero-knowledge arguments of knowledge with a transparent setup in the DL setting. First, we put forth new gas-efficient range arguments that achieve  <span class="math">O(N^{\\frac{2}{3}})</span>  communication cost, and involve  <span class="math">O(N^{\\frac{2}{3}})</span>  group exponentiations for verification and a slightly sub-linear number of group exponentiations for proving with respect to the range  <span class="math">[0, 2^{N} - 1]</span> . Our range arguments achieve a comparable amount of gas costs to the most efficient zkSNARK on blockchain platforms without resorting to a trusted setup. Second, we presented polynomial evaluation arguments based on the techniques of Bayer &amp; Groth. We provided two zero-knowledge protocols that excel in handling lower-degree  <span class="math">(D \\in [3, 2^{9}])</span>  and higher-degree  <span class="math">(D &amp;gt; 2^{9})</span>  polynomials, respectively. Our arguments make a significant improvement in the efficiency of computation and communication. To the best of our knowledge, our arguments instantiate the most communication-efficient zero-knowledge arguments of membership and non-membership in the DL setting among those not requiring trusted setups. In future work, we will incorporate Flashproofs in more real-world blockchain-based applications, e.g., energy sharing and sharing economy [34, 42].</p>

    <p class="text-gray-300">Flashproofs: Zero-Knowledge Arguments of Range &amp; Polynomial Evaluation</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Alex, V., Sergey, V.: Solidity implementation of bulletproof. https://github.com/BANKEX/BulletproofJS (2018)</li>

      <li>[2] Ames, S., Hazay, C., Ishai, Y., Venkitasubramaniam, M.: Ligero: Lightweight sublinear arguments without a trusted setup. In: Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security. CCS ’17 (2017)</li>

      <li>[3] Bayer, S., Groth, J.: Zero-knowledge argument for polynomial evaluation with application to blacklists. In: Advances in Cryptology - EUROCRYPT 2013 (2013)</li>

      <li>[4] Bellare, M., Garay, J.A., Rabin, T.: Fast batch verification for modular exponentiation and digital signatures. In: Advances in Cryptology — EUROCRYPT’98 (1998)</li>

      <li>[5] Ben-Sasson, E., Bentov, I., Horesh, Y., Riabzev, M.: Scalable, transparent, and post-quantum secure computational integrity. IACR Cryptol. ePrint Arch. (2018)</li>

      <li>[6] Ben-Sasson, E., Chiesa, A., Riabzev, M., Spooner, N., Virza, M., Ward, N.P.: Aurora: Transparent succinct arguments for r1cs. In: Advances in Cryptology – EUROCRYPT 2019 (2019)</li>

      <li>[7] Ben-Sasson, E., Chiesa, A., Tromer, E., Virza, M.: Succinct non-interactive zero knowledge for a von neumann architecture. In: 23rd USENIX Security Symposium (USENIX Security 14) (2014)</li>

      <li>[8] Benarroch, D., Campanelli, M., Fiore, D., Gurkan, K., Kolonelos, D.: Zero-knowledge proofs for set membership: Efficient, succinct, modular. In: Financial Cryptography and Data Security (2021)</li>

      <li>[9] Benedikt, B.: Java implementation of bulletproof. https://github.com/bbuenz/BulletProofLib (2017)</li>

      <li>[10] Bootle, J., Cerulli, A., Chaidos, P., Groth, J., Petit, C.: Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In: Advances in Cryptology – EUROCRYPT 2016 (2016)</li>

      <li>[11] Bootle, J., Groth, J.: Efficient batch zero-knowledge arguments for low degree polynomials. In: Public-Key Cryptography – PKC 2018 (2018)</li>

      <li>[12] BouncyCastle: Bouncycastle. https://www.bouncycastle.org/</li>

      <li>[13] Bunz, B., Bootle, J., Boneh, D., Poelstra, A., Wuille, P., Maxwell, G.: Bulletproofs: Short proofs for confidential transactions and more. pp. 315–334 (05 2018)</li>

      <li>[14] Bünz, B., Fisch, B., Szepieniec, A.: Transparent snarks from dark compilers. In: Advances in Cryptology – EUROCRYPT 2020 (2020)</li>

      <li>[15] Camenisch, J., Chaabouni, R., Shelat, A.: Efficient protocols for set membership and range proofs. In: Advances in Cryptology - ASIACRYPT 2008 (2008)</li>

      <li>[16] Cardozo, A.S., Williamson, Z.: https://eips.ethereum.org/EIPS/eip-1108</li>

      <li>[17] Chiesa, A., Ojha, D., Spooner, N.: Fractal: Post-quantum and transparent recursive proofs from holography. In: Advances in Cryptology – EUROCRYPT 2020 (2020)</li>

      <li>[18] Christian, R.: Eip-196: Precompiled contracts for addition and scalar multiplication on the elliptic curve <span class="math">a</span>!<span class="math">t_{b}$$s</span>128. https://eips.ethereum.org/EIPS/eip-196 (2017)</li>

      <li>[19] coindesk: https://www.coindesk.com/price/ethereum (2022)</li>

      <li>[20] Couteau, G., Klooß, M., Lin, H., Reichle, M.: Efficient range proofs with transparent setup from bounded integer commitments. In: Advances in Cryptology - CRYPTO 2021 (2021)</li>

      <li>[21] Deng, C., Tang, X., You, L., Hu, G.: Cuproof: A novel range proof with constant size. IACR Cryptol. ePrint Arch. (2021)</li>

      <li>[22] Dobson, S., Galbraith, S., Smith, B.: Trustless unknown-order groups. Mathematical Cryptology 1(2), 25–39 (Mar 2022), https://journals.flvc.org/mathcryptology/article/view/130579</li>

    </ul>

    <p class="text-gray-300">23] Etherscan: https://ropsten.etherscan.io/address/0xa1f11d83a5222692c0eff9eca32254a7452c4f29#code#L1</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[24] Etherscan: https://etherscan.io/gasTracker (2022)</li>

      <li>[25] Fiat, A., Shamir, A.: How to prove yourself: Practical solutions to identification and signature problems. In: Advances in Cryptology — CRYPTO’ 86 (1987)</li>

      <li>[26] Gregory, M.: Confidential transactions. https://elementsproject.org/features/confidential-transactions/investigation (2016)</li>

      <li>[27] Groth, J.: Non-interactive zero-knowledge arguments for voting. In: Applied Cryptography and Network Security (2005)</li>

      <li>[28] Groth, J.: On the size of pairing-based non-interactive arguments. In: Advances in Cryptology – EUROCRYPT 2016 (2016)</li>

      <li>[29] Groth, J., Kohlweiss, M.: One-out-of-many proofs: Or how to leak a secret and spend a coin. In: EUROCRYPTO (2015)</li>

      <li>[30] HarryR: https://github.com/HarryR/ethsnarks</li>

      <li>[31] matter labs: Awesome zero knowledge proofs. https://github.com/matter-labs/awesome-zero-knowledge-proofs</li>

      <li>[32] Language, S.P.: https://docs.soliditylang.org</li>

      <li>[33] Lipmaa, H.: On diophantine complexity and statistical zero-knowledge arguments. In: Advances in Cryptology - ASIACRYPT 2003 (2003)</li>

      <li>[34] Lyu, L., Chau, S.C.K., Wang, N., Zheng, Y.: Cloud-based privacy-preserving collaborative consumption for sharing economy. IEEE Transactions on Cloud Computing 10(3), 1647–1660 (2022)</li>

      <li>[35] Maller, M., Bowe, S., Kohlweiss, M., Meiklejohn, S.: Sonic: Zero-knowledge snarks from linear-size universal and updatable structured reference strings. In: Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communications Security. p. 2111–2128 (2019)</li>

      <li>[36] Michaud-Rodgers, P.: Sum of three squares. https://warwick.ac.uk/fac/sci/maths/people/staff/michaud/threesquarestalk.pdf (2019)</li>

      <li>[37] Setty, S.: Spartan: Efficient and general-purpose zksnarks without trusted setup. In: Advances in Cryptology – CRYPTO 2020</li>

      <li>[38] Solidity: Solidity optimizer. https://docs.soliditylang.org/en/v0.8.14/internals/optimizer.html#optimizer-parameter-runs (2022)</li>

      <li>[39] Suite, T.: https://www.trufflesuite.com</li>

      <li>[40] TornadoCash: Tornadocash. https://tornado.cash/ (2021)</li>

      <li>[41] Wahby, R., Tzialla, I., Shelat, A., Thaler, J., Walfish, M.: Doubly-efficient zksnarks without trusted setup. pp. 926–943 (05 2018)</li>

      <li>[42] Wang, N., Chau, S.C.K., Zhou, Y.: Privacy-preserving energy storage sharing with blockchain and secure multi-party computation. ACM SIGENERGY Energy Inform. Rev. 1(1), 32–50 (Dec 2022), https://doi.org/10.1145/3508467.3508471</li>

      <li>[43] Weisstein, E.W.: Lagrange’s four-square theorem. https://mathworld.wolfram.com/LagrangesFour-SquareTheorem.html (2021)</li>

      <li>[44] Weisstein, E.W.: Maclaurin series. https://mathworld.wolfram.com/MaclaurinSeries.html (2021)</li>

      <li>[45] Williamson, Z.J.: The aztec protocol. https://github.com/AztecProtocol/AZTEC/blob/master/AZTEC.pdf (2018)</li>

      <li>[46] Zhang, J., Xie, T., Zhang, Y., Song, D.X.: Transparent polynomial delegation and its applications to zero knowledge proof. 2020 IEEE Symposium on Security and Privacy (SP) pp. 859–876 (2020)</li>

    </ul>`;
---

<BaseLayout title="Flashproofs: Efficient Zero-Knowledge Arguments of Range and... (2022/1251)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2022 &middot; eprint 2022/1251
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
