---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2010/374';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Efficient Generation of Linear Secret Sharing Scheme Matrices from Threshold Access Trees';
const AUTHORS_HTML = 'Zhen Liu, Zhenfu Cao, Duncan S.  Wong';

const CONTENT = `    <p class="text-gray-300">1</p>

    <p class="text-gray-300">Zhen Liu, Zhenfu Cao, and Duncan S. Wong</p>

    <h2 id="sec-2" class="text-2xl font-bold">Abstract</h2>

    <p class="text-gray-300">Linear Secret Sharing Scheme (LSSS) matrices are commonly used for implementing monotone access structures in highly expressive Ciphertext-Policy Attribute-Based Encryption (CP-ABE) schemes. However, LSSS matrices are much less intuitive to use when compared with other approaches such as boolean formulas or access trees. To bridge the gap between the usability of an access structure representation method and the implementation technique required in a concrete CP-ABE construction, Lewko and Waters proposed an algorithm which can convert any monotone boolean formulas to LSSS matrices. This algorithm is very useful in practice as a ciphertext policy can now be intuitively expressed using a monotone boolean formula, which has good usability, and the corresponding LSSS for an actual CP-ABE construction can then be generated accordingly using this algorithm. However, in this algorithm, the non-leaf nodes of a monotone boolean formula, when viewed as an access tree, can only be AND or OR gates. For general monotone access structures, for example, in a <span class="math">(t,n)</span>-threshold access tree, the threshold gates of the tree have to be converted to AND and OR gates before we can apply the algorithm on this access tree. This results in generating a large LSSS matrix, and entailing a large CP-ABE ciphertext. To address this problem, in this paper, we propose a new algorithm which, in addition to AND and OR gates, can directly support threshold gates, and obtain much smaller LSSS matrices (or the same in the worst case when only AND and OR gates exist). This will particularly be useful for reducing the size of all ciphertexts with policies in the typical <span class="math">(t,n)</span>-threshold type. Furthermore, as AND and OR gates are the special cases of the general <span class="math">(t,n)</span>-threshold gates, not only an optimization, but also is this new algorithm a generalization of the Lewko-Waters algorithm.</p>

    <h2 id="sec-3" class="text-2xl font-bold">Index Terms</h2>

    <p class="text-gray-300">Attribute-Based Encryption, Access Policy, Monotone Access Structure, Linear Secret Sharing Scheme.</p>

    <p class="text-gray-300">Z. Liu (zhenliu7-c@my.cityu.edu.hk) and D. S. Wong (duncanwong@astri.org) are with the Security and Data Sciences, ASTRI, and Z. Cao (zfcao@sei.ecnu.edu.cn) is with East China Normal University. Part of the work was done when Z. Liu was jointly affiliated to Shanghai Jiao Tong University and City University of Hong Kong in 2012 and 2013.</p>

    <h2 id="sec-4" class="text-2xl font-bold">I Introduction</h2>

    <p class="text-gray-300">In a Ciphertext-Policy Attribute-Based Encryption (CP-ABE) system <em>[1]</em>, a ciphertext is generated by encrypting a message under an <em>access policy</em>, which is defined over attributes. The ciphertext can only be decrypted by users whose attributes satisfy the policy of the ciphertext. This is done by an authority who issues a decryption key to each user in the system according to the attributes the user possesses. As an illustration of this ciphertext access policy, suppose Alice is a secretary, who encrypts a message under a ciphertext policy denoted as “(Mathematics AND (PhD Student OR Alumni))”, where “Mathematics”, “PhD student” and “Alumni” are <em>attributes</em>. In order to decrypt the message, a receiver should have a decryption key corresponding to attributes which satisfy this access policy, for example, all PhD students and alumni in the Department of Mathematics. The set of eligible receivers is dynamic and Alice does not need to know the exact identities of the eligible receivers.</p>

    <p class="text-gray-300">One of the main objectives of CP-ABE is to allow users to implement fine-grained access control on their data in encrypted form. For applications related to access control, such as secure cloud storage access and sharing, enabling fine-grained access control is the appealing advantage of CP-ABE over traditional user-specific encryption systems, which include the conventional public key encryption <em>[2, 3, 4]</em>, identity-based encryption <em>[5, 6]</em>, and broadcast encryption <em>[7, 8]</em>.</p>

    <p class="text-gray-300">CP-ABE has attracted great attention in the research community, with a series of work being done recently <em>[9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]</em>. In provably secure CP-ABE schemes currently available for highly expressive access policies (i.e. supporting any monotone access structures), including <em>[12, 13, 14, 15, 16, 17, 18, 19, 20]</em>, a Linear Secret Sharing Scheme (LSSS) matrix <span class="math">(M,\\rho)</span> is included in each ciphertext, where <span class="math">M</span> is a matrix over <span class="math">\\mathbb{Z}_{p}</span> and <span class="math">\\rho</span> maps each row of <span class="math">M</span> to an attribute. This LSSS matrix is used for specifying and enforcing the access policy of the ciphertext, and as shown in <em>[21]</em>, LSSS matrices can realize any monotone access structures. Also worth noticing is that in all the highly expressive CP-ABE schemes <em>[12, 13, 14, 15, 16, 17, 18, 19, 20]</em>, <em>the ciphertext size is linear in the size of the associated LSSS matrix (i.e. the number of rows of <span class="math">M</span>)</em>.</p>

    <p class="text-gray-300">However, expressing monotone access structures in LSSS matrices is not obvious. It is also difficult to use and hard to comprehend when an access policy is expressed as an LSSS matrix. In practice, it is more intuitive and preferred if access policies are expressed in boolean formulas, access trees, or access structures themselves. To illustrate this, suppose we have an LSSS matrix given in Fig. 1. This LSSS matrix is representing an access policy, while it is obscure for everybody who is not an expert in</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 1. An LSSS example  <span class="math">(M, \\rho)</span> .  <span class="math">M</span>  is a matrix and  <span class="math">\\rho</span>  maps the 1st, 2nd, 3rd, 4th and 5th row of  <span class="math">M</span>  to attributes  <span class="math">E</span> ,  <span class="math">A</span> ,  <span class="math">B</span> ,  <span class="math">C</span>  and  <span class="math">D</span>  respectively. Given an attribute set  <span class="math">S</span> , if and only if the rows of  <span class="math">M</span>  labeled by the attributes in  <span class="math">S</span>  include the vector  <span class="math">(1,0,\\ldots,0)</span>  in their span, the LSSS is said to be satisfied by  <span class="math">S</span> . Fig. 2. A Threshold-gate access tree. Each non-leaf node is a threshold gate and each leaf is an attribute. Given an attribute set  <span class="math">S</span> , for a leaf node, if the associated attribute is in  <span class="math">S</span> , the leaf node is said to be satisfied by  <span class="math">S</span> . For a  <span class="math">(t,n)</span> -threshold node where  <span class="math">n</span>  is the number of children and  <span class="math">1 \\leq t \\leq n</span>  a threshold value, if and only if at least  <span class="math">t</span>  child nodes are satisfied, the threshold node is said to be satisfied. If and only if the root node of the access tree is satisfied, the access tree is said to be satisfied by  <span class="math">S</span> . Also note that when  <span class="math">t = 1</span> , a  <span class="math">(t,n)</span> -threshold gate is an OR gate and when  <span class="math">t = n</span> , it is an AND gate.</p>

    <p class="text-gray-300">LSSS. The LSSS matrix represents an access policy that "an eligible user should have attribute  <span class="math">E</span>  and in addition, at least two more attributes in  <span class="math">\\{A, B, C, D\\}</span> ". It can be expressed in a more comprehensible way, for example,  <span class="math">E \\wedge ((A \\wedge B) \\vee (A \\wedge C) \\vee (A \\wedge D) \\vee (B \\wedge C) \\vee (B \\wedge D) \\vee (C \\wedge D))</span> , which is a boolean formula, or an access tree, namely  <span class="math">(E, (A, B, C, D, 2), 2)</span> , as shown in Fig. 2, where each interior (i.e. non-leaf) node of the tree is a threshold gate and the leaf nodes are attributes.</p>

    <p class="text-gray-300">From the example above, we can see that there is a gap between the usability of an access policy representation method and the actual implementation technique (i.e. LSSS) used for realizing ciphertext policies in a concrete CP-ABE construction supporting highly expressive access policies (i.e. any monotone access structures). Ordinary users prefer using boolean formulas or access trees to represent policies</p>

    <p class="text-gray-300">while the aforementioned provably secure and highly expressive CP-ABE schemes, such as <em>[12, 13, 14, 15, 16, 17, 18, 19, 20]</em>, require LSSS to specify and enforce the policies in ciphertexts. General methods for constructing secret sharing schemes from monotone access structures can be found in <em>[22]</em>, and basic techniques have been provided, however, specific implementation and concrete construction details from any <span class="math">(t,n)</span>-threshold gate of an access tree to an LSSS matrix are yet to be elaborated. To address this problem, in <em>[23, Appendix G]</em>, Lewko and Waters proposed a detailed algorithm which converts any monotone boolean formulas to the corresponding LSSS matrices.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">I-A The Lewko-Waters Algorithm</h3>

    <p class="text-gray-300">The input of the algorithm <em>[23, Appendix G]</em> is an access tree, which represents a monotone boolean formula. The tree’s non-leaf nodes are AND and OR gates and leaf nodes are attributes. The output of the algorithm is the corresponding LSSS, whose size (i.e. the number of rows) is equal to the number of leaf nodes of the input access tree. Using the access policy “an eligible user should have attribute <span class="math">E</span> and in addition, at least two more attributes in <span class="math">\\{A,B,C,D\\}</span>” as an example, where the boolean formula form is <span class="math">E\\wedge((A\\wedge B)\\vee(A\\wedge C)\\vee(A\\wedge D)\\vee(B\\wedge C)\\vee(B\\wedge D)\\vee(C\\wedge D))</span>, Fig. 3 shows the details of the algorithm.</p>

    <p class="text-gray-300">Before applying the algorithm, we may first transform the monotone boolean formula to an equivalent but shorter one, namely, <span class="math">E\\wedge(((A\\wedge B)\\vee(C\\wedge D))\\vee((A\\vee B)\\wedge(C\\vee D)))</span>. This transformation is desirable, as will be illustrated later, that the size of the resulting LSSS is equal to the number of leaf nodes of the access tree, and the resulting LSSS will be smaller. As shown in Fig. 3, the Lewko-Waters algorithm takes the access tree representation of this transformed boolean formula as input, then labels the root node of the tree with vector <span class="math">(1)</span> (a vector of length 1) and initializes a global counter <span class="math">c</span> to 1. Then it goes down the tree, and labels the nodes as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if the parent node is an OR gate labeled with a vector <span class="math">v</span>, the algorithm labels both child nodes as <span class="math">v</span> and keeps the counter <span class="math">c</span> unchanged;</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. if the parent node is an AND gate labeled with a vector <span class="math">v</span>, the algorithm pads <span class="math">v</span> with <span class="math">0</span>’s at the end (if necessary) to make it of length <span class="math">c</span>, then the algorithm labels its right child node with the vector $v\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1<span class="math"> (where </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denotes concatenation) and the left child node with the vector </span>(0,\\ldots,0)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">-</span>1<span class="math">, where </span>(0,\\ldots,0)<span class="math"> is of length </span>c<span class="math">, and increases the value of </span>c$ by 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Boolean Formula:  <span class="math">E \\wedge \\left( (A \\wedge B) \\vee (A \\wedge C) \\vee (A \\wedge D) \\vee (B \\wedge C) \\vee (B \\wedge D) \\vee (C \\wedge D) \\right)</span></p>

    <p class="text-gray-300">(Equivalent but Compressed) Boolean Formula:  <span class="math">E \\wedge \\left( \\left( (A \\wedge B) \\vee (C \\wedge D) \\right) \\vee \\left( (A \\vee B) \\wedge (C \\vee D) \\right) \\right)</span></p>

    <p class="text-gray-300">Run Lewko-Waters Algorithm on the Access Tree with AND-OR gates:</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 3: Use Lewko-Waters algorithm to generate an LSSS for access policy “an eligible user should have attribute <span class="math">E</span> and in addition, at least two more attributes in <span class="math">\\{A,B,C,D\\}</span>”.</p>

    <p class="text-gray-300">LSSS Generated by Lewko-Waters Algorithm:</p>

    <p class="text-gray-300">\\[ \\begin{array}{rcl} &amp; 0 &amp; -1 &amp; 0 &amp; 0 &amp; 0 &amp; \\frac{\\rho(1) = E}{\\rho(2) = A} \\\\ &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; \\rho(3) = B \\\\ &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; \\rho(4) = C \\\\ &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; \\rho(5) = D \\\\ &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; 0 &amp; \\rho(6) = A \\\\ &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; 0 &amp; \\rho(7) = B \\\\ &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; \\rho(8) = C \\\\ &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; \\rho(9) = D \\end{array} \\end{array} \\quad \\begin{array}{r} \\rho(1) = E \\\\ \\rho(2) = A \\\\ \\rho(3) = B \\\\ \\rho(4) = C \\\\ \\rho(5) = D \\\\ \\rho(6) = A \\\\ \\rho(7) = B \\\\ \\rho(8) = C \\\\ \\rho(9) = D \\end{array} $$</p>

    <p class="text-gray-300">Once the algorithm finishes labeling the tree, the vectors labeled on the leaf nodes constitute the rows of an LSSS matrix, and if the vectors have different lengths, the algorithm pads the shorter ones with 0’s at the end until all the them are of the same length. Note that a set of the rows of the resulting matrix includes <span class="math">(1,0,\\ldots,0)</span> in its span if and only if the attributes corresponding to the rows in the set satisfy the input access tree.</p>

    <p class="text-gray-300">The Lewko-Waters algorithm requires each of the non-leaf nodes of an access tree to be either an AND gate or an OR gate. Although this is sufficient for expressing any monotone access structures, it may not always be efficient. Consider a typical <span class="math">(t,n)</span>-threshold type access structure. To generate the corresponding LSSS from the Lewko-Waters algorithm, we first need to convert the access structure to an access tree containing AND and OR gates only. This requires us to convert each of the <span class="math">(t,n)</span>-threshold gates in the access structure to a tree branch containing AND and OR nodes only, resulting in a larger LSSS matrix than a version which is generated directly from the <span class="math">(t,n)</span>-threshold gates that our algorithm, which is proposed later in this paper, can support. When this <span class="math">(t,n)</span>-threshold type access structure is a</p>

    <p class="text-gray-300">ciphertext policy in a CP-ABE scheme, the result of applying the Lewko-Waters algorithm will incur a bigger ciphertext when compared with the one obtained from the new LSSS generation algorithm that we will propose.</p>

    <p class="text-gray-300">Threshold policies, for example, the Majority Policy, namely <span class="math">(\\lfloor n/2\\rfloor+1,n)</span>-threshold, are common in practice. Given a <span class="math">(t,n)</span>-threshold policy, <span class="math">1\\leq t\\leq n</span>, before applying the Lewko-Waters algorithm, we first need to represent the threshold policy into a boolean formula so that it can be viewed as an AND-OR-gate access tree as exemplified in Fig. 3. For simplicity, if an access tree’s non-leaf nodes can only be AND and OR gates, we refer to it as an AND-OR-gate access tree, and if the non-leaf nodes can also be any threshold gates, we refer to the access tree as a Threshold-gate access tree. In the following, we discuss several important aspects regarding the efficiency and applicability related issues of the Lewko-Waters algorithm particularly for threshold policies.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>As the size of a generated LSSS matrix from the Lewko-Waters algorithm is equal to the number of leaf nodes of the input access tree, and the ciphertext size in a highly expressive (LSSS-based) CP-ABE scheme <em>[12, 13, 14, 15, 16, 17, 18, 19, 20]</em> is linear in the size of LSSS, before applying the Lewko-Waters algorithm to an AND-OR-gate access tree, we may try to optimize the tree so that it contains <em>fewer</em> leaf nodes (Fig. 3). This, however, is a challenging and expensive optimization problem. In <em>[24, Chapter 8]</em>, it is shown that (1) it is easy to design an optimal monotone boolean formula with size <span class="math">n\\log n</span> for a <span class="math">(2,n)</span>-threshold policy, but it is much harder to design an optimal monotone boolean formula for a <span class="math">(t,n)</span>-threshold policy if <span class="math">t&gt;2</span>; (2) given a <span class="math">(t,n)</span>-threshold policy, an equivalent monotone boolean formula of size <span class="math">c\\cdot n\\log n</span> can be built in polynomial time. However, <span class="math">c</span> is often large (though it is possible to reduce <span class="math">c</span> by some further complicated manipulations); and (3) it is generally hard to design an asymptotically optimal monotone boolean formula for a general <span class="math">(t,n)</span>-threshold policy.</li>

      <li>Given a <span class="math">(t,n)</span>-threshold policy, if there exists a preprocessing algorithm which can generate the corresponding optimal monotone boolean formula with size <span class="math">c\\cdot n\\log n</span> as outlined above, and we ignore the possibly expensive computational cost of this preprocessing, the resulting LSSS matrix generated by the Lewko-Waters algorithm will be of size <span class="math">c\\cdot n\\log n</span>. However, a smaller and equivalent LSSS matrix of size <span class="math">n</span> can readily be built from the <span class="math">(t,n)</span>-threshold policy <em>[25]</em> (later in this paper we will describe such an LSSS in detail). In other words, applying Lewko-Waters algorithm on a <span class="math">(t,n)</span>-threshold ciphertext policy for a highly expressive CP-ABE scheme will make the ciphertext size <span class="math">c\\cdot\\log n</span> times larger. For example, consider a <span class="math">(2,4)</span>-threshold policy over attributes <span class="math">\\{A,B,C,D\\}</span>. The possibly smallest size of the corresponding boolean formula is</li>

    </ol>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> <span class="math">(A,B,C,D,2)</span></p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Fig. 4. A Threshold-gate access tree and an equivalent LSSS Fig. 5. Example of a general Threshold-gate access tree</p>

    <p class="text-gray-300"><span class="math">n \\log n = 8</span> , that is,  <span class="math">((A \\wedge B) \\vee (C \\wedge D)) \\vee ((A \\vee B) \\wedge (C \\vee D))</span> . Taking this minimized boolean formula as input, Lewko-Waters algorithm will output an LSSS with size 8. However, as shown in Fig. 4, we can build an equivalent LSSS of size 4 from the same  <span class="math">(2,4)</span> -threshold policy.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If the original ciphertext policy is a general Threshold-gate access tree which may have multiple levels of  <span class="math">(t, n)</span> -threshold gates (for example, such as the one in Fig. 5), to the best of our knowledge, there is no efficient method for obtaining an optimal boolean formula. Also the corresponding boolean formula size is always larger than the number of leaf nodes in a Threshold-gate access tree.</li>

    </ol>

    <p class="text-gray-300">In this paper we propose a new LSSS generation algorithm which converts any general Threshold-gate access trees to their equivalent LSSS matrices. The non-leaf nodes of an access tree at the algorithm input can also be  <span class="math">(t, n)</span> -threshold gates, so that no more conversion to an AND-OR-gate access tree is required, in contrast to what the Lewko-Waters algorithm requires. Furthermore, the AND and OR gates are also supported directly without degrading the efficiency as they are the special cases of the  <span class="math">(t, n)</span> -threshold gates, where  <span class="math">t = n</span>  and  <span class="math">t = 1</span> , respectively. Below are the main merits of this new algorithm.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>This new algorithm is more general and covers the Lewko-Waters algorithm. For any monotone boolean formula (i.e. any AND-OR-gate access tree) that Lewko-Waters algorithm supports, we convert it to a Threshold-gate access tree first. This is done by replacing AND and OR gates with <span class="math">(2,2)</span>-threshold and <span class="math">(1,2)</span>-threshold gates, respectively (while keeping the other parts of the access tree unchanged). Then we apply the new algorithm on the Threshold-gate access tree. Note that the leaf nodes remain unchanged, and hence the size of the resulting LSSS will be the same as that of the LSSS generated by the Lewko-Waters algorithm.</li>

      <li>The new algorithm is more efficient than Lewko-Waters algorithm on general <span class="math">(t,n)</span>-threshold policies. Without incurring any possibly expensive preprocessing overhead, which is needed when applying Lewko-Waters algorithm, this new algorithm can be applied directly on Threshold-gate access trees. Furthermore and more importantly, applying this new algorithm can obtain LSSS with smaller size. This implies smaller ciphertext size in highly expressive CP-ABE schemes <em>[12, 13, 14, 15, 16, 17, 18, 19, 20]</em>. In particular, for a single <span class="math">(2,n)</span>-threshold policy, the new algorithm can generate an LSSS with size <span class="math">n</span>, while Lewko-Waters algorithm generates an LSSS with size at least <span class="math">n\\log n</span>. Besides, for a single <span class="math">(t,n)</span>-threshold policy with <span class="math">2&lt;t&lt;n</span>, the new algorithm can generate an LSSS with size <span class="math">n</span>, while Lewko-Waters algorithm generates an LSSS with size <span class="math">c\\cdot n\\log n</span> for a possibly large <span class="math">c</span>; for a general Threshold-gate access tree with multiple levels of general <span class="math">(t,n)</span>-threshold gates, the new algorithm can have even more advantages on generating LSSS with smaller size, although it is yet to come up with methods for estimating the order of performance optimization.</li>

    </ol>

    <p class="text-gray-300">In addition, the new algorithm has the following desirable features:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>As the Threshold-gate access tree is a more general, efficient and intuitive form to describe an access policy than a boolean formula does, the new algorithm is helpful to the applicability of CP-ABE in practice, especially on describing complicated (and highly expressive) ciphertext policies. The new algorithm allows an encryptor to directly use a natural and intuitive Threshold-gate access tree to specify a ciphertext policy without requiring any expensive preprocessing.</li>

      <li>Existing optimization algorithms applied to boolean formulas for obtaining equivalent ones with smaller/optimal size before invoking the Lewko-Waters algorithm can continue be applied before invoking this new algorithm. This follows the fact that the Threshold-gate access trees are the generalization of the AND-OR-gate access trees. In addition to this, some other optimization algorithms, for example, the one proposed in <em>[26]</em>, which allows a complex access structure to be realized by <em>possibly the fewest</em> number of threshold gates, can also be applied. Given an access</li>

    </ol>

    <p class="text-gray-300">policy which is in the form of neither a Threshold-gate access tree nor a boolean formula, we can run the optimization algorithm in <em>[26]</em> for obtaining threshold gates, and then build a Threshold-gate access tree by linking all the threshold gates together using a <span class="math">(1,n)</span>-threshold gate. The resulting Threshold-gate access tree will have two levels of threshold nodes and one level of leaf nodes. This Threshold-gate access tree will finally be passed to this new algorithm for generating a small LSSS. As a summary, this new algorithm can be used in the following fashion depending on how the access policy is originally specified: (1) if the original access policy is not specified in the form of a Threshold-gate access tree, we can apply some existing optimization algorithms for covering to a Threshold-gate access tree and optimizing its size; and (2) if the original access policy is already specified as a Threshold-gate access tree (e.g. Fig. 5), we can apply the new algorithm directly on it.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Specific to CP-ABE, this new algorithm is designed such that when applied to a highly expressive CP-ABE scheme, the algorithm can help reduce the overhead size for describing the policy of a ciphertext. In a highly expressive CP-ABE scheme <em>[12, 13, 14, 15, 16, 17, 18, 19, 20]</em>, a ciphertext policy is specified as an LSSS matrix <span class="math">(M,\\rho)</span>. As <span class="math">M</span> is a matrix over <span class="math">\\mathbb{Z}_{p}</span> where <span class="math">p</span> is a large prime, the overhead due to <span class="math">(M,\\rho)</span> could be large. In this new algorithm, both <span class="math">M</span> and <span class="math">\\rho</span> can be completely determined by a formatted string that describes the Threshold-gate access tree, and no extra strings are needed. Also, this formatted string consists of only attributes and several special symbols with size being approximately equal to that of <span class="math">\\rho</span>. As a result, the overhead for describing the ciphertext policy can be reduced as there is no need to specifically describe <span class="math">M</span>.</li>

    </ol>

    <p class="text-gray-300">Paper Organization. In the next section, we review some related notions and theoretical preliminaries. In Sec. III we outline our ideas, and in Sec. IV, we describe the new algorithm and its use in CP-ABE. Finally, we conclude the paper in Sec. V.</p>

    <h2 id="sec-7" class="text-2xl font-bold">II Background</h2>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">II-A Attribute-Based Encryption</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Sahai and Waters <em>[27]</em> introduced the concept of Attribute-Based Encryption (ABE) in 2005 when working on fuzzy Identity-Based Encryption. In their work, each user’s private key is described by an attribute set and each ciphertext is encrypted under an attribute set as well. For a private key with attribute set <span class="math">w</span>, to decrypt a ciphertext encrypted under an attribute set <span class="math">w^{\\prime}</span>, if and only if <span class="math">w</span> and <span class="math">w^{\\prime}</span> are close to each other as measured by the “set overlap distance metric” (i.e. $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w\\cap w^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq d<span class="math"> for some threshold value </span>d$), the decryption will succeed. In other words, this is an ABE scheme supporting threshold policies.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In 2006, Goyal et al. <em>[1]</em> formalized Key-Policy ABE (KP-ABE) and Ciphertext-Policy ABE (CP-ABE). In CP-ABE, each user’s private key is associated with an attribute set issued by an authority, and each ciphertext is associated with an access policy specified by the encryptor. The policy determines what users are eligible to decrypt the ciphertext. In KP-ABE, each user’s private key is associated with an access policy issued by an authority. The policy determines what ciphertexts that the user is eligible to decrypt, where each ciphertext is described by an attribute set. Though we focus on CP-ABE in this paper, it is worth mentioning that KP-ABE also have many applications, such as pay-TV and audit-log <em>[1]</em>. Among recently proposed KP-ABE schemes <em>[1, 14, 28, 29, 30, 31]</em>, some highly expressive ones (e.g. <em>[14, 29, 31]</em>) also use LSSS to specify the access policies for private keys.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">IV-B Access Policies and Realizations</h3>

    <p class="text-gray-300">An access policy can be described as an access structure which can be realized by a secret sharing scheme. In the following, we review their definitions.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 1 (Access Structure <em>[21]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{P}=\\{P_{1},P_{2},\\ldots,P_{n}\\}</span> be a set of parties. A collection <span class="math">\\mathbb{A}\\subseteq 2^{\\{P_{1},P_{2},\\ldots,P_{n}\\}}</span> is monotone if for any <span class="math">B</span> and <span class="math">C</span>: if <span class="math">B\\in\\mathbb{A}</span> <span class="math">and</span> <span class="math">B\\subseteq C</span> <span class="math">then</span> <span class="math">C\\in\\mathbb{A}</span>. An access structure (respectively, monotone access structure) is a collection (respectively, monotone collection) <span class="math">\\mathbb{A}</span> of non-empty subsets of <span class="math">\\{P_{1},P_{2},\\ldots,P_{n}\\}</span>, i.e., <span class="math">\\mathbb{A}\\subseteq 2^{\\{P_{1},P_{2},\\ldots,P_{n}\\}}\\setminus\\{\\emptyset\\}</span>. The sets in <span class="math">\\mathbb{A}</span> are called the authorized sets, and the sets not in <span class="math">\\mathbb{A}</span> are called the unauthorized sets.</p>

    <p class="text-gray-300">In an ABE system, the role of the parties is defined by attributes. An access structure <span class="math">\\mathbb{A}</span> in ABE contains the authorized sets of attributes. Unless otherwise stated, by an access structure we mean a monotone access structure for the rest of this paper. As shown in <em>[21]</em>, any monotone access structure can be realized by a linear secret sharing scheme. Below we use the definition from <em>[12, 21]</em>.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Definition 2 (Linear Secret-Sharing Schemes (LSSS) <em>[12]</em>).</h6>

    <p class="text-gray-300">A secret sharing scheme <span class="math">\\Pi</span> over a set of parties <span class="math">\\mathcal{P}</span> is called linear (over <span class="math">\\mathbb{Z}_{p}</span>) if</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the shares for each party form a vector over <span class="math">\\mathbb{Z}_{p}</span>, and</li>

      <li>there exists a matrix <span class="math">M</span> called the share-generating matrix for <span class="math">\\Pi</span>. The matrix <span class="math">M</span> has <span class="math">m</span> rows and <span class="math">d</span> columns. For <span class="math">i=1,\\ldots,m</span>, the <span class="math">i^{th}</span> row <span class="math">M_{i}</span> of <span class="math">M</span> is labeled by a party <span class="math">\\rho(i)</span> where <span class="math">\\rho</span> is a function from <span class="math">\\{1,\\ldots,m\\}</span> to <span class="math">\\mathcal{P}</span>. Given a column vector <span class="math">\\vec{v}=(s,r_{2},\\ldots,r_{d})</span>, where <span class="math">s\\in\\mathbb{Z}_{p}</span> is the secret to be shared and <span class="math">r_{2},\\ldots,r_{d}\\in\\mathbb{Z}_{p}</span> are randomly chosen, <span class="math">M\\vec{v}</span> is the vector of <span class="math">m</span> shares of the secret <span class="math">s</span> according to <span class="math">\\Pi</span>. The share <span class="math">\\lambda_{i}=(M\\vec{v})_{i}</span>, i.e., the inner product <span class="math">M_{i}\\cdot\\vec{v}</span>, belongs to party <span class="math">\\rho(i)</span>.</li>

    </ol>

    <p class="text-gray-300">Also as shown in <em>[21]</em>, any LSSS defined as above enjoys the linear reconstruction property defined as follows. Suppose that <span class="math">\\Pi</span> is an LSSS for access structure <span class="math">\\mathbb{A}</span>. Let <span class="math">S\\in\\mathbb{A}</span> be an authorized set, and <span class="math">I\\subset\\{1,\\ldots,m\\}</span> be defined as <span class="math">I=\\{i:\\rho(i)\\in S\\}</span>. There exist constants <span class="math">\\{\\omega_{i}\\in\\mathbb{Z}_{p}\\}_{i\\in I}</span> satisfying <span class="math">\\sum_{i\\in I}\\omega_{i}M_{i}=(1,0,\\ldots,0)</span>, so that if <span class="math">\\{\\lambda_{i}\\}</span> are valid shares of any secret <span class="math">s</span> according to <span class="math">\\Pi</span>, then <span class="math">\\sum_{i\\in I}\\omega_{i}\\lambda_{i}=s</span>. Furthermore, these constants <span class="math">\\{\\omega_{i}\\}</span> can be found in time polynomial in the size of the share-generating matrix <span class="math">M</span>. For any unauthorized set, no such constants exist. The LSSS is denoted by <span class="math">(M,\\rho)</span>, and its size is the number of rows of <span class="math">M</span>, that is, <span class="math">m</span>.</p>

    <p class="text-gray-300">In the highly expressive CP-ABE schemes mentioned above <em>[12, 13, 14, 15, 16, 17, 18, 19, 20]</em>, each ciphertext is associated with an LSSS <span class="math">(M,\\rho)</span> as its access policy, and the ciphertext size is linear in the size of <span class="math">(M,\\rho)</span>. In the highly expressive KP-ABE schemes <em>[14, 29]</em>, each private key is associated with an LSSS <span class="math">(M,\\rho)</span>, and the private key size is linear in the size of <span class="math">(M,\\rho)</span>.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">II-C Different Forms for Describing Access Policies</h3>

    <p class="text-gray-300">Besides the theoretical way of describing access policies using access structures, there are several more practical and efficient ways for describing policies. They are efficient because they can eliminate the redundancies as usually found in conventional access structures. Fig. 6 shows the different forms for describing a <span class="math">(2,4)</span>-threshold policy over the universe <span class="math">\\mathcal{P}=\\{A,B,C,D\\}</span>. They include the minimal form access structure, the boolean formula and two types of access trees.</p>

    <p class="text-gray-300">Minimal Form Access Structures. Due to the monotonicity, a monotone access structure <span class="math">\\mathbb{A}</span> can be efficiently described by a set <span class="math">\\mathbb{A}^{-}</span>, which consists of the <em>minimal elements (sets)</em> in <span class="math">\\mathbb{A}</span>, i.e., the elements in <span class="math">\\mathbb{A}</span> for which no proper subset is also in <span class="math">\\mathbb{A}</span>. Given <span class="math">\\mathbb{A}^{-}</span>, <span class="math">\\mathbb{A}</span> can be determined as follows. For any attribute set <span class="math">S\\subseteq\\mathcal{P}</span>, if and only if there exists some set <span class="math">A\\in\\mathbb{A}^{-}</span> such that <span class="math">S\\supseteq A</span>, <span class="math">S</span> is an authorized set (i.e., <span class="math">S\\in\\mathbb{A}</span>, or <span class="math">S</span> satisfies <span class="math">\\mathbb{A}</span>). We refer to <span class="math">\\mathbb{A}^{-}</span> as the <em>minimal form</em> of <span class="math">\\mathbb{A}</span>. Note that each minimal set in <span class="math">\\mathbb{A}^{-}</span> represents a distinct series of authorized sets in <span class="math">\\mathbb{A}</span>, i.e., suppose <span class="math">\\mathbb{A}^{-}=\\{A_{1},\\ldots,A_{n_{\\mathbb{A}}}\\}</span> and <span class="math">\\mathbb{A}_{n}=\\{S\\mid S\\supseteq A_{n}\\}</span> for <span class="math">1\\leq n\\leq n_{\\mathbb{A}}</span>, we have <span class="math">\\mathbb{A}=\\bigcup_{1\\leq n\\leq n_{\\mathbb{A}}}\\mathbb{A}_{n}</span>, and <span class="math">\\mathbb{A}_{n_{1}}\\neq\\mathbb{A}_{n_{2}}</span> for <span class="math">1\\leq n_{1}\\neq n_{2}\\leq n_{\\mathbb{A}}</span>. Obviously, it is more efficient to use the minimal form to describe an access policy rather than the access structure itself which may contain many redundancies.</p>

    <p class="text-gray-300">Montone Boolean Formulas. When compared with minimal form access structure, a monotone boolean formula is more general and efficient for describing the same access policy, where a monotone boolean formula is a boolean formula without <span class="math">\\mathsf{NOT}</span>. For any minimal form monotone access structure, say <span class="math">\\mathbb{A}^{-}=\\{A_{1},\\ldots,A_{n_{\\mathbb{A}}}\\}</span>, an equivalent monotone boolean formula, say <span class="math">F_{\\mathbb{A}}=\\bigvee_{1\\leq n\\leq n_{\\mathbb{A}}}(\\bigwedge_{x\\in A_{n}}x)</span> can be</p>

    <p class="text-gray-300">Access Structure:  <span class="math">\\left\\{ \\begin{array}{l}\\{A,B\\} ,\\{A,C\\} ,\\{A,D\\} ,\\{B,C\\} ,\\{B,D\\} ,\\{C,D\\} ,\\\\ \\{A,B,C\\} ,\\{A,B,D\\} ,\\{A,C,D\\} ,\\{B,C,D\\} ,\\{A,B,C,D\\} \\end{array} \\right\\}</span></p>

    <p class="text-gray-300">Access Structure in Minimal Form:  <span class="math">\\{\\{A,B\\} ,\\{A,C\\} ,\\{A,D\\} ,\\{B,C\\} ,\\{B,D\\} ,\\{C,D\\} \\}</span></p>

    <p class="text-gray-300">Boolean Formula:  <span class="math">\\left((A\\wedge B)\\vee (C\\wedge D)\\right)\\vee \\left((A\\vee B)\\wedge (C\\vee D)\\right)</span></p>

    <p class="text-gray-300">Access Tree with Threshold Gates:</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> (A,B,C,D,2)</p>

    <p class="text-gray-300">Access Tree with AND-OR Gates:</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> <span class="math">(A \\wedge B) \\vee (C \\wedge D)) \\vee ((A \\vee B) \\wedge (C \\vee D))</span> Fig. 6. Different forms for describing a  <span class="math">(2,4)</span> -threshold policy over the universe  <span class="math">\\{A,B,C,D\\}</span></p>

    <p class="text-gray-300">compressed and simplified further to obtain a version with smaller size, e.g.,  <span class="math">(A\\wedge B)\\vee (A\\wedge C) = A\\wedge (B\\vee C)</span>  (as shown in Fig. 6). On the other side, if we already have a monotone boolean formula which describes an access policy, and want to transform it to an equivalent minimal form access structure, we need to first convert the boolean formula to an equivalent DNF, whose size may be larger than the original boolean formula.</p>

    <p class="text-gray-300">Monotone Access Trees. On a monotone access tree, each leaf node corresponds to an attribute, and each non-leaf node represents a threshold gate, which is described by its children and a threshold value. This is generally termed as Threshold-gate access tree while a AND-OR-gate access tree (detailed below) is a special case of the Threshold-gate access tree. Whether an attribute set  <span class="math">S</span>  satisfies a monotone access tree is determined as follows. For a leaf node, if the corresponding attribute appears in  <span class="math">S</span> , the leaf node is said to be satisfied. For a  <span class="math">(t,n)</span> -threshold gate where  <span class="math">n</span>  is the number of its children and  <span class="math">1 \\leq t \\leq n</span>  is the threshold value, if and only if at least its  <span class="math">t</span>  (out of  <span class="math">n</span> ) child nodes are satisfied, the  <span class="math">(t,n)</span> -threshold node is satisfied. If and only if the root node of the access tree is satisfied, the access tree is said to be satisfied by  <span class="math">S</span> . For a  <span class="math">(t,n)</span> -threshold gate, when  <span class="math">t = 1</span> , the threshold gate is an OR gate and when  <span class="math">t = n</span> , it is an AND gate. Hence, an AND-gate can be expressed as an  <span class="math">(n,n)</span> -Threshold-gate, and an OR-gate can be expressed as a  <span class="math">(1,n)</span> -Threshold-gate, but reversely to express a general</p>

    <p class="text-gray-300"><span class="math">(t,n)</span>-threshold gate where <span class="math">1&lt;t&lt;n</span>, <span class="math">0&lt;t&lt;n</span>="" <span class="math">1&lt;t&lt;n</span>="" <span class="math">a=&quot;&quot; </span>a<span class="math">=&quot;&quot; </span>a\\geq="" <span class="math">a\\geq=&quot;&quot; </span>a\\geq="" <span class="math">t</span>,="" <span class="math">t&lt;n</span>="" <span class="math">t_{n}</span>)-threshold-gate="" <span class="math">t_{n+1}</span>)-threshold-gate="" <span class="math">t_{n+2}</span>),="" <span class="math">t_{n+3}</span>),="" <span class="math">t_{n+4}</span>),="" <span class="math">t_{n+5}</span>),="" <span class="math">t_{n+6}</span>),="" <span class="math">t_{n+7}</span>),="" <span class="math">t_{n+8}</span>),="" <span class="math">t_{n+9}</span>),="" <span class="math">t_{n+10}</span>),="" <span class="math">t_{n+11}</span>),="" <span class="math">t_{n+12}</span>),="" <span class="math">t_{n+13}</span>),="" <span class="math">t_{n+14}</span>),="" <span class="math">t_{n+15}</span>),="" <span class="math">t_{n+16}</span>),="" <span class="math">t_{n+17}</span>),="" <span class="math">t_{n+2}</span>).="" <span class="math">t_{n+3}</span>),="" <span class="math">t_{n+4}</span>),="" <span class="math">t_{n+5}</span>),="" <span class="math">t_{n+6}</span>),="" <span class="math">t_{n+7}</span>),="" <span class="math">t_{n+8}</span>),="" <span class="math">t_{n+9}</span>),="" <span class="math">t_{n+10}</span>),="" <span class="math">t_{n+11}</span>),="" <span class="math">t_{n+2}</span>).="" 13="" 13.="" 2.="" 3.="" 4.="" 5.="" a="" above,="" across="" an="" and="" and-="" and-0r="" are="" as="" at="" be="" because="" be,="" because="" be.="" boolean="" boolean.="" by="" called="" can="" case="" cases="" different="" different.="" do="" does="" each="" efficient="" efficient.="" efficient.="" e.g.="" each.="" effect="" efficiency="" efficiency,="" different="" different.="" do="" does.="" down="" e.g.="" each.="" edge="" edge.="" error="" example="" expressed="" fast="" form="" forms.="" formula="" formula,="" formula,="" formula.="" form.="" forms.="" form.0r="" formula,="" formula.="" form.0r-gate="" form.1="" formula.="" form.2="" formula.="" form.3="" formula.="" form.4="" formula.="" form.5="" form.6="" formula.="" form.7="" formula.="" form.8="" form.9="" formula.="" form.10="" formula.="" form.11="" form.12="" formula.="" form.2="" formula.="" following="" for="" form.="" form.3="" form.4="" formula.="" from="" full="" general="" generated="" get="" get.="" has="" have="" however,="" i.e.="" if="" illustration="" illus="" illustrated="" in="" included="" induced="" inner="" inspection="" is="" is,="" it="" its="" j.="" leaf="" line="" lines="" lines.="" main="" many="" model="" model.="" more="" most="" n<span class="math">=&quot;&quot; n</span>),="" n<span class="math">).=&quot;&quot; n</span>+<span class="math">=&quot;&quot; n</span>),="" n<span class="math">+</span>="" n<span class="math">+</span>2="" n<span class="math">+</span>3="" n<span class="math">+</span>4="" n<span class="math">+</span>5="" n<span class="math">+</span>6="" n<span class="math">+</span>7="" n<span class="math">+</span>8="" n<span class="math">+</span>9="" n<span class="math">+</span>10="" n<span class="math">+</span>11="" n<span class="math">+</span>12="" n<span class="math">+</span>13="" n<span class="math">+</span>14="" n<span class="math">+</span>15="" n<span class="math">+</span>16="" n<span class="math">+</span>17="" n<span class="math">+</span>18="" n<span class="math">+</span>19="" n<span class="math">+</span>20="" n<span class="math">+</span>21="" n<span class="math">+</span>22="" n<span class="math">+</span>23="" n<span class="math">+</span>24="" n<span class="math">+</span>25="" n<span class="math">+</span>26="" n<span class="math">+</span>27="" n<span class="math">+</span>28="" n<span class="math">+</span>29="" n<span class="math">+</span>30="" n<span class="math">+</span>31="" n<span class="math">+</span>32="" n<span class="math">+</span>33="" n<span class="math">+</span>34="" n<span class="math">+</span>35="" n<span class="math">+</span>36="" n<span class="math">+</span>37="" n<span class="math">+</span>38="" n<span class="math">+</span>39="" n<span class="math">+</span>40="" n<span class="math">+</span>41="" n<span class="math">+</span>42="" n<span class="math">+</span>43="" n<span class="math">+</span>44="" n<span class="math">+</span>45="" n<span class="math">+</span>46="" n<span class="math">+</span>47="" n<span class="math">+</span>48="" n<span class="math">+</span>49="" n<span class="math">+</span>50="" n<span class="math">+</span>51="" n<span class="math">+</span>52="" n<span class="math">+</span>53="" n<span class="math">+</span>54="" n<span class="math">+</span>55="" n<span class="math">+</span>56="" n<span class="math">+</span>57="" n<span class="math">+</span>58="" n<span class="math">+</span>59="" n<span class="math">+</span>60="" n<span class="math">+</span>61="" n<span class="math">+</span>62="" n<span class="math">+</span>63="" n<span class="math">+</span>64="" n<span class="math">+</span>65="" n<span class="math">+</span>66="" n<span class="math">+</span>67="" n<span class="math">+</span>68="" n<span class="math">+</span>69="" n<span class="math">+</span>70="" n<span class="math">+</span>71="" n<span class="math">+</span>72="" n<span class="math">+</span>73="" n<span class="math">+</span></t<n$,></p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-9.jpeg">img-9.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-10.jpeg">img-10.jpeg</a> Fig. 7. The insertion of access structure</p>

    <p class="text-gray-300">!<a href="img-11.jpeg">img-11.jpeg</a></p>

    <p class="text-gray-300">access structures. LSSS are in one-to-one correspondence with MSPs [21]. In the following, we review the work of Nikov and Nikova [32] which will later be modified and applied to the construction of our new algorithm.</p>

    <p class="text-gray-300">Definition 3 (The Insertion of Access Structure [32]). Let  <span class="math">\\mathbb{A}_1</span>  and  <span class="math">\\mathbb{A}_2</span>  be two monotone access structures on participant sets  <span class="math">\\mathcal{P}_1</span>  and  <span class="math">\\mathcal{P}_2</span> , respectively, and let  <span class="math">P_z \\in \\mathcal{P}_1</span> . Define "the insertion of  <span class="math">\\mathbb{A}_2</span>  at participant  <span class="math">P_z</span>  in  <span class="math">\\mathbb{A}_1</span> ", denoted by  <span class="math">\\mathbb{A}_1(P_z \\to \\mathbb{A}_2)</span> , as a monotone access structure on the set  <span class="math">(\\mathcal{P}_1 \\setminus \\{P_z\\}) \\cup \\mathcal{P}_2</span>  such that for  <span class="math">G \\subseteq (\\mathcal{P}_1 \\setminus \\{P_z\\}) \\cup \\mathcal{P}_2</span>  we have</p>

    <div class="my-4 text-center"><span class="math-block">G \\in \\mathbb {A} _ {1} (P _ {z} \\to \\mathbb {A} _ {2}) \\iff \\left\\{ \\begin{array}{l} (G \\cap \\mathcal {P} _ {1} \\in \\mathbb {A} _ {1}), \\text {o r} \\\\ ((G \\cap \\mathcal {P} _ {1}) \\cup \\{P _ {z} \\} \\in \\mathbb {A} _ {1} a n d G \\cap \\mathcal {P} _ {2} \\in \\mathbb {A} _ {2}). \\end{array} \\right.</span></div>

    <p class="text-gray-300">In other words,  <span class="math">\\mathbb{A}_1(P_z\\to \\mathbb{A}_2)</span>  is the monotone access structure  <span class="math">\\mathbb{A}_1</span>  with participant  <span class="math">P_{z}</span>  "replaced" by the sets of  <span class="math">\\mathbb{A}_2</span> .</p>

    <p class="text-gray-300">Fig. 7 shows an example of  <span class="math">\\mathbb{A}_1(P_1\\to \\mathbb{A}_2)</span> , where  <span class="math">\\mathbb{A}_1</span>  is a  <span class="math">(2,3)</span> -threshold policy on  <span class="math">\\{P_1,P_2,P_3\\}</span>  and  <span class="math">\\mathbb{A}_2</span>  is a  <span class="math">(3,4)</span> -threshold policy on  <span class="math">\\{A,B,C,D\\}</span> . To obtain a Threshold-gate access tree for  <span class="math">\\mathbb{A}_1(P_z\\to \\mathbb{A}_2)</span> , we simply need to replace the leaf node corresponding to  <span class="math">P_{z}</span>  in the access tree for  <span class="math">\\mathbb{A}_1</span>  with the access tree for  <span class="math">\\mathbb{A}_2</span> . In the example illustrated in Fig. 7, such as a hierarchical organization, to satisfy  <span class="math">\\mathbb{A}_1</span> , at least</p>

    <p class="text-gray-300">two of <span class="math">\\{P_1, P_2, P_3\\}</span> have to be present, and the privilege of <span class="math">P_1</span> may be distributed to a lower level so that only if at least three out of <span class="math">\\{A, B, C, D\\}</span> are present, can they achieve the privilege of <span class="math">P_1</span>.</p>

    <p class="text-gray-300">Theorem 1. [32] Let <span class="math">\\mathbb{A}_1</span> and <span class="math">\\mathbb{A}_2</span> be monotone access structures defined on participant sets <span class="math">\\mathcal{P}_1</span> and <span class="math">\\mathcal{P}_2</span>, realized by LSSS <span class="math">(M^{(1)},\\rho^{(1)})</span> of size <span class="math">m_1</span> and <span class="math">(M^{(2)},\\rho^{(2)})</span> of size <span class="math">m_2</span>, respectively. Let <span class="math">P_z\\in \\mathcal{P}_1</span>. There exists an LSSS <span class="math">(M,\\rho)</span> of size <span class="math">m_1 + (m_2 - 1)q</span> realizing the access structure <span class="math">\\mathbb{A}_1(P_z\\to \\mathbb{A}_2)</span>, where <span class="math">q</span> is the number of rows labeled by <span class="math">P_z</span> in <span class="math">(M^{(1)},\\rho^{(1)})</span>.</p>

    <p class="text-gray-300">The construction of LSSS <span class="math">(M,\\rho)</span> is given as follows [32]: Let <span class="math">M^{(1)} = \\left( \\begin{array}{c}M_{P_z}^{(1)}\\\\ \\overline{M}^{(1)} \\end{array} \\right)</span> and <span class="math">M^{(2)} = \\left( \\begin{array}{cc}\\vec{u}^{(2)} &amp;amp; \\widetilde{M}^{(2)}\\end{array} \\right)</span> be <span class="math">m_1\\times d_1</span> and <span class="math">m_2\\times d_2</span> matrices, respectively, where <span class="math">M_{P_z}^{(1)}</span> are the <span class="math">q</span> rows labeled by <span class="math">P_{z}</span> and <span class="math">\\vec{u}^{(2)}</span> is the first column, assuming that the rows of <span class="math">P_{z}</span> are the first rows in <span class="math">M^{(1)}</span>. Let <span class="math">M_{P_z}^{(1)} = \\left( \\begin{array}{c}\\vec{v}_1\\\\ \\vec{v}_2\\\\ \\vdots \\\\ \\vec{v}_q \\end{array} \\right)</span>, <span class="math">\\vec{u}^{(2)} = \\left( \\begin{array}{c}u_{1}\\\\ u_{2}\\\\ \\vdots \\\\ u_{m_{2}} \\end{array} \\right)</span>, and define <span class="math">\\vec{v}_i\\otimes \\vec{u}^{(2)} = \\left( \\begin{array}{c}u_1\\vec{v}_i\\\\ u_2\\vec{v}_i\\\\ \\vdots \\\\ u_{m_2}\\vec{v}_i \\end{array} \\right)</span>, where <span class="math">\\vec{v}_i</span> (<span class="math">i = 1,\\dots ,q</span>) are row vectors in <span class="math">\\mathbb{Z}_p^d</span>; and <span class="math">u_{j}\\in \\mathbb{Z}_{p}</span> (<span class="math">j = 1,\\ldots ,m_{2}</span>). Note that <span class="math">\\vec{v}_i\\otimes \\vec{u}^{(2)}</span> is an <span class="math">m_2\\times d_1</span> matrix. Using 0 to denote all-zero matrices, let <span class="math">M = \\left( \\begin{array}{cccccc}\\vec{v}_1\\otimes \\vec{u}^{(2)} &amp;amp; \\widetilde{M}^{(2)} &amp;amp; \\mathbf{0} &amp;amp; \\dots &amp;amp; \\mathbf{0}\\\\ \\vec{v}_2\\otimes \\vec{u}^{(2)} &amp;amp; \\mathbf{0} &amp;amp; \\widetilde{M}^{(2)} &amp;amp; \\ddots &amp;amp; \\vdots \\\\ \\vdots &amp;amp; \\vdots &amp;amp; \\ddots &amp;amp; \\ddots &amp;amp; \\mathbf{0}\\\\ \\vec{v}_q\\otimes \\vec{u}^{(2)} &amp;amp; \\mathbf{0} &amp;amp; \\dots &amp;amp; \\mathbf{0} &amp;amp; \\widetilde{M}^{(2)}\\\\ \\overline{M}^{(1)} &amp;amp; \\mathbf{0} &amp;amp; \\dots &amp;amp; \\mathbf{0} &amp;amp; \\mathbf{0} \\end{array} \\right)</span>, the rows of <span class="math">\\left( \\begin{array}{cccc}\\overline{M}^{(1)} &amp;amp; \\mathbf{0} \\end{array} \\right)</span> are labeled as the corresponding rows of <span class="math">\\overline{M}^{(1)}</span> in <span class="math">(M^{(1)},\\rho^{(1)})</span>. For <span class="math">i = 1</span> to <span class="math">q</span>, the rows of <span class="math">\\left( \\begin{array}{cccccc}\\vec{v}_i\\otimes \\vec{u}^{(2)} &amp;amp; \\mathbf{0} &amp;amp; \\widetilde{M}^{(2)} &amp;amp; \\mathbf{0} \\end{array} \\right)</span> are labeled as the corresponding rows of <span class="math">\\widetilde{M}^{(2)}</span> in <span class="math">(M^{(2)},\\rho^{(2)})</span>. Then <span class="math">M</span> computes the access structure <span class="math">\\mathbb{A}_1(P_z\\to \\mathbb{A}_2)</span>, and it is an <span class="math">(m_1 + (m_2 - 1)q)\\times (d_1 + (d_2 - 1)q)</span> matrix. We refer readers to [32] for the proof.</p>

    <h2 id="sec-13" class="text-2xl font-bold">III. OUR APPROACH – FROM THRESHOLD-GATE ACCESS TREES TO LSSS MATRICES</h2>

    <p class="text-gray-300">We now describe our method to construct an LSSS matrix from a Threshold-gate access tree. Inspired by Theorem 1, we repeatedly carry out the "insertion" operation on two Threshold access structures,</p>

    <p class="text-gray-300">and our ideas can be outlined as follows: (1) for a single <span class="math">(t,n)</span>-threshold gate, find its LSSS matrix; (2) repeatedly perform the “insertion” of Threshold-gate access trees according to the structure of the input Threshold-gate access tree; and (3) use a formatted string to describe the input Threshold-gate access tree and design an algorithm which can output <span class="math">(M,\\rho)</span> based on the formatted string alone.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">IV-A Recursive-Form Strings</h3>

    <p class="text-gray-300">Recall that in a Threshold-gate access tree, each leaf node corresponds to an attribute, and each non-leaf node is a threshold gate, described by its children and a threshold value. A Threshold-gate access tree can naturally be described using a recursive-form string as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Without loss of generality, we assume the symbols “(”, “,” and “)” are not in the attribute universe, where “()” will be used to define non-leaf nodes and “,” will work as separator to separate the child nodes of each non-leaf node.</li>

      <li>A Threshold-gate access tree <span class="math">\\mathbb{A}</span> is described by a string that describes its root node. In particular, suppose that the root node is a <span class="math">(t,n)</span>-threshold gate, the access tree can then be described by a string <span class="math">(F_{1},F_{2},\\ldots,F_{n},t)</span> where <span class="math">t</span> is the threshold value and <span class="math">F_{i}</span> <span class="math">(1\\leq i\\leq n)</span> represents the children of the root node.</li>

      <li><span class="math">F_{i}</span> is an attribute corresponding to a leaf node, or a non-leaf node described by its children and a threshold value, i.e. <span class="math">F_{i}=(F_{i,1},F_{i,2},\\ \\ldots,F_{i,n_{i}},t_{i})</span>, where <span class="math">F_{i,1},F_{i,2},\\ \\ldots,F_{i,n_{i}}</span> represent the <span class="math">n_{i}</span> children of <span class="math">F_{i}</span> and <span class="math">t_{i}</span> is a threshold value with <span class="math">1\\leq t_{i}\\leq n_{i}</span>.</li>

    </ol>

    <p class="text-gray-300">For example, the access tree in Fig. 5 can be described using a recursive-form string, namely, <span class="math">((A,B,C,2),</span> <span class="math">(D,E,F,2),(G,H,(I,J,K,L,3),2),2)</span>, where <span class="math">(A,B,C,2)</span>, <span class="math">(D,E,F,2)</span> and <span class="math">(G,H,(I,\\ J,K,L,3),2)</span> are the three children of the root node. For the node <span class="math">(G,H,(I,J,K,L,3),2)</span>, the first two children are the leaf nodes corresponding to attributes <span class="math">G</span> and <span class="math">H</span>, respectively, and the third child is a <span class="math">(3,4)</span>-threshold gate described by <span class="math">(I,J,K,L,3)</span>.</p>

    <p class="text-gray-300">We refer to such a recursive-form string as a threshold-tree-string. Furthermore, given a threshold-tree-string <span class="math">F_{\\mathbb{A}}</span>, when we say “<span class="math">i^{th}</span> attribute of <span class="math">F_{\\mathbb{A}}</span>” we mean the <span class="math">i^{th}</span> attribute, indexed from left to right, ignoring the symbols “(”, “)” and “,”. Suppose <span class="math">F_{\\mathbb{A}}=((A,B,C,2),(A,D,1),E,3)</span>, the <span class="math">1^{st}</span>, <span class="math">2^{nd}</span>, <span class="math">3^{rd}</span>, <span class="math">4^{th}</span>, <span class="math">5^{th}</span>, and <span class="math">6^{th}</span> attributes of <span class="math">F_{\\mathbb{A}}</span> are <span class="math">A</span>, <span class="math">B</span>, <span class="math">C</span>, <span class="math">A</span>, <span class="math">D</span>, and <span class="math">E</span>, respectively.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">IV-</h3>

    <p class="text-gray-300">B LSSS for Threshold Access Structures</p>

    <p class="text-gray-300">For a <span class="math">(t,n)</span>-threshold access structure <span class="math">(P_{1},P_{2},\\dots,P_{n},t)</span>, we can construct the corresponding LSSS over <span class="math">\\mathbb{Z}_{p}</span>, <span class="math">p&gt;n+1</span>, as</p>

    <p class="text-gray-300">\\[ M=\\left(\\begin{array}[]{cccc}1&1&1&\\dots&1\\\\ 1&2&2^{2}&\\dots&2^{t-1}\\\\ 1&3&3^{2}&\\dots&3^{t-1}\\\\ \\vdots&\\vdots&\\vdots&\\vdots&\\vdots\\\\ 1&n&n^{2}&\\dots&n^{t-1}\\end{array}\\right),\\ \\ \\rho(i)=P_{i}\\ \\text{(for <span class="math">i=1,\\dots,n</span>)}. \\] (1)</p>

    <p class="text-gray-300">We can verify that <span class="math">(M,\\rho)</span> realizes <span class="math">(P_{1},P_{2},\\dots,P_{n},t)</span> as follows. To share a secret <span class="math">s\\in\\mathbb{Z}_{p}</span> in a <span class="math">(t,n)</span>-threshold style, we choose a random vector <span class="math">\\vec{v}=(s,a_{1},\\dots,a_{t-1})\\in\\mathbb{Z}_{p}^{t}</span> and give the inner product <span class="math">\\lambda_{i}=(M_{i}\\cdot\\vec{v})</span> to participant <span class="math">P_{i}</span>. Consider the polynomial <span class="math">f(x)=s+a_{1}x+a_{2}x^{2}+\\dots+a_{t-1}x^{t-1}</span>, we have that <span class="math">\\lambda_{i}=f(i)</span>, that is, participant <span class="math">P_{i}</span> has the value <span class="math">f(i)</span>. In other words, we are implementing Shamir’s secret sharing scheme <em>[33]</em> for a <span class="math">(t,n)</span>-threshold function. According to the security of Shamir’s secret sharing scheme, we know that if and only if at least <span class="math">t</span> of <span class="math">\\{\\lambda_{i}\\}_{i=1}^{n}</span> are known, the secret <span class="math">s</span> can be reconstructed. Note that <span class="math">M</span> is completely determined by the values of <span class="math">n</span> and <span class="math">t</span>, and <span class="math">(M,\\rho)</span> is completely determined by the string <span class="math">(P_{1},P_{2},\\dots,P_{n},t)</span> as <span class="math">\\rho(i)=P_{i}</span>.</p>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">III-C Our Modified Construction for Theorem 1</h3>

    <p class="text-gray-300">In the construction for Theorem 1 (Section II-D), it is assumed that (1) the construction handles all the <span class="math">q</span> rows owned by <span class="math">P_{z}</span> in one “insertion”, and (2) all the <span class="math">q</span> rows of <span class="math">P_{z}</span> are the first rows in <span class="math">M^{(1)}</span>. As directly using the original construction <em>[32]</em> for Theorem 1 will incur complex codes and additional overhead, for example, which are entailed to finding all the rows owned by <span class="math">P_{z}</span> and arranging them in the first rows of <span class="math">M^{(1)}</span>, we propose to view and describe the construction in a different way:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">(M,\\rho)</span> be an LSSS realizing access structure <span class="math">\\mathbb{A}</span>, and its size be <span class="math">m</span>. For any <span class="math">1\\leq i,j\\leq m</span>, define <span class="math">(M^{\\prime},\\rho^{\\prime})</span> as follows:</li>

    </ol>

    <p class="text-gray-300"><span class="math">M^{\\prime}_{i}=M_{j},\\ \\ \\ \\ \\ M^{\\prime}_{j}=M_{i},\\ \\ \\ \\ \\ M^{\\prime}_{k}=M_{k}(\\forall\\ k\\neq i,j);</span> <span class="math">\\rho^{\\prime}(i)=\\rho(j),\\ \\ \\rho^{\\prime}(j)=\\rho(i),\\ \\ \\rho^{\\prime}(k)=\\rho(k)(\\forall\\ k\\neq i,j).</span></p>

    <p class="text-gray-300">Obviously <span class="math">(M^{\\prime},\\rho^{\\prime})</span> is also an LSSS realizing <span class="math">\\mathbb{A}</span>. This implies that when we use the construction for Theorem 1 we do not need to arrange the rows of <span class="math">P_{z}</span> to the first rows of the matrix.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>To design an efficient and easily comprehensible algorithm, it is desirable to handle one row in each “insertion” operation and by repeating the one-row-insertion operation to handle the cases</li>

    </ol>

    <p class="text-gray-300">18</p>

    <p class="text-gray-300">that <span class="math">P_{z}</span> owns multiple, say <span class="math">q</span> rows. The following example shows that we do not need to handle all the <span class="math">q</span> rows in one "insertion", instead, we can attain the same construction as the original one for Theorem 1 by repeating the one-row-insertion operation for <span class="math">q</span> times. Without loss of generality, suppose <span class="math">q = 2</span>, and <span class="math">\\vec{v}_{1}</span> and <span class="math">\\vec{v}_{2}</span> are labeled by <span class="math">P_{z}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">M ^ {(1)} = \\left( \\begin{array}{c} \\overline {{M}} ^ {(1 1)} \\\\ \\vec {v} _ {1} \\\\ \\overline {{M}} ^ {(1 2)} \\\\ \\vec {v} _ {2} \\\\ \\overline {{M}} ^ {(1 3)} \\end{array} \\right) \\xrightarrow [ \\text {i n s e r t i o n} ]{ \\text {r o w} \\vec {v} _ {1} } M ^ {(1)} = \\left( \\begin{array}{c c} \\overline {{M}} ^ {(1 1)} &amp;amp; \\mathbf {0} \\\\ \\vec {v} _ {1} \\otimes \\vec {u} ^ {(2)} &amp;amp; \\widetilde {M} ^ {(2)} \\\\ \\overline {{M}} ^ {(1 2)} &amp;amp; \\mathbf {0} \\\\ \\vec {v} _ {2} &amp;amp; \\vec {0} \\\\ \\overline {{M}} ^ {(1 3)} &amp;amp; \\mathbf {0} \\end{array} \\right) \\xrightarrow [ \\text {i n s e r t i o n} ]{ \\text {r o w} (\\vec {v} _ {2} \\vec {0}) } \\</span></div>

    <div class="my-4 text-center"><span class="math-block">M ^ {(1)} = \\left( \\begin{array}{c c c} \\overline {{M}} ^ {(1 1)} &amp;amp; \\mathbf {0} &amp;amp; \\mathbf {0} \\\\ \\vec {v} _ {1} \\otimes \\vec {u} ^ {(2)} &amp;amp; \\widetilde {M} ^ {(2)} &amp;amp; \\mathbf {0} \\\\ \\overline {{M}} ^ {(1 2)} &amp;amp; \\mathbf {0} &amp;amp; \\mathbf {0} \\\\ \\vec {v} _ {2} \\otimes \\vec {u} ^ {(2)} &amp;amp; \\vec {0} \\otimes \\vec {u} ^ {(2)} &amp;amp; \\widetilde {M} ^ {(2)} \\\\ \\overline {{M}} ^ {(1 3)} &amp;amp; \\mathbf {0} &amp;amp; \\mathbf {0} \\end{array} \\right) = \\left( \\begin{array}{c c c} \\overline {{M}} ^ {(1 1)} &amp;amp; \\mathbf {0} &amp;amp; \\mathbf {0} \\\\ \\vec {v} _ {1} \\otimes \\vec {u} ^ {(2)} &amp;amp; \\widetilde {M} ^ {(2)} &amp;amp; \\mathbf {0} \\\\ \\overline {{M}} ^ {(1 2)} &amp;amp; \\mathbf {0} &amp;amp; \\mathbf {0} \\\\ \\vec {v} _ {2} \\otimes \\vec {u} ^ {(2)} &amp;amp; \\mathbf {0} &amp;amp; \\widetilde {M} ^ {(2)} \\\\ \\overline {{M}} ^ {(1 3)} &amp;amp; \\mathbf {0} &amp;amp; \\mathbf {0} \\end{array} \\right).</span></div>

    <p class="text-gray-300">Note that handling insertion of multiple rows through repeating one-row-insertion as above is based on the fact that in the expanded columns in each insertion, all elements but those in <span class="math">\\widetilde{M}^{(2)}</span> are zero, so that in the next insertion we have <span class="math">\\vec{0} \\otimes \\vec{u}^{(2)} = \\mathbf{0}</span>.</p>

    <h2 id="sec-17" class="text-2xl font-bold">IV. THE NEW LSSS GENERATION ALGORITHM</h2>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">A. The Algorithm</h3>

    <p class="text-gray-300">For a Threshold-gate access tree <span class="math">\\mathbb{A}</span>, taking the corresponding threshold-tree-string <span class="math">F_{\\mathbb{A}}</span> as input, using an LSSS as in Equation (1) for each Threshold-gate, we can follow the threshold-tree-string's structure to repeatedly execute the one-row-insertion, and eventually output an LSSS <span class="math">(M,\\rho)</span> for <span class="math">\\mathbb{A}</span>, where <span class="math">\\rho</span> is determined by <span class="math">F_{\\mathbb{A}}</span> as the <span class="math">i</span>-th row of <span class="math">M</span> is labeled by the <span class="math">i</span>-th attribute of <span class="math">F_{\\mathbb{A}}</span>. In particular, each node of the access tree is regarded as a participant of a threshold access structure specified by its parent node. Then we start with a <span class="math">(1,1)</span>-threshold LSSS and consider the root node of the tree as its participant. We repeatedly execute the one-row-insertion on the non-leaf nodes of the tree, and will eventually obtain the desirable LSSS. Below is the LSSS generation algorithm with pseudo code given in Algorithm 1.</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">Algorithm Description.</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Input: A threshold-tree-string <span class="math">F_{\\mathbb{A}}</span> for a Threshold-gate access tree <span class="math">\\mathbb{A}</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output: A matrix <span class="math">M</span> and a function <span class="math">\\rho</span>, which maps the <span class="math">i^{th}</span> row of <span class="math">M</span> to the <span class="math">i^{th}</span> attribute in <span class="math">F_{\\mathbb{A}}</span>, <span class="math">(M,\\rho)</span> is the LSSS realizing <span class="math">\\mathbb{A}</span>.</li>

      <li>Convert<span class="math">(F_{\\mathbb{A}})</span>: In the following, <span class="math">M</span> is an <span class="math">m\\times d</span> matrix over <span class="math">\\mathbb{Z}_{p}</span>, and <span class="math">L=(L_{1},L_{2},\\ldots,L_{m})</span> a vector with <span class="math">m</span> coordinates, where each coordinate is an attribute or a threshold-tree-string. The <span class="math">i^{th}</span> coordinate of <span class="math">L</span> labels the <span class="math">i^{th}</span> row of <span class="math">M</span>.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let matrix <span class="math">M=(1)_{1\\times 1}</span>, vector <span class="math">L=(F_{\\mathbb{A}})</span>, and <span class="math">m=1,d=1</span>.</li>

      <li>Repeat the following until all coordinates of <span class="math">L</span> are attributes:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Consider <span class="math">M</span> to be an <span class="math">m\\times d</span> matrix over <span class="math">\\mathbb{Z}_{p}</span>, and <span class="math">L=(L_{1},L_{2},\\ldots,L_{m})</span>.</li>

      <li>Scan the coordinates of <span class="math">L</span> to find the first coordinate that is a threshold-tree-string rather than an attribute. Suppose the index of this coordinate is <span class="math">z</span>. We have a threshold-tree-string <span class="math">L_{z}=F_{z}=(F_{z,1},F_{z,2},\\ldots,F_{z,m_{2}},d_{2})</span>. Remark: If such a coordinate does not exist, it means that all the coordinates have been attributes and the algorithm should stop and output the matrix <span class="math">M</span>.</li>

      <li>Resolve <span class="math">F_{z}</span> to obtain its <span class="math">m_{2}</span> children <span class="math">F_{z,1},F_{z,2},\\ldots,F_{z,m_{2}}</span> and threshold value <span class="math">d_{2}</span>.</li>

      <li>For this <span class="math">(d_{2},m_{2})</span>-threshold access structure, construct the corresponding LSSS matrix according to Equation (1), then execute “insertion” of this <span class="math">(d_{2},m_{2})</span>-LSSS matrix on the <span class="math">z^{th}</span> row of <span class="math">M</span> to obtain a new <span class="math">M</span> with <span class="math">m-1+m_{2}</span> rows and <span class="math">d+d_{2}-1</span> columns. Set <span class="math">L=(L_{1},L_{2},\\ldots,L_{z-1},F_{z,1},F_{z,2},\\ldots,F_{z,m_{2}},L_{z+1},\\ldots,L_{m})</span>, and then set <span class="math">m=m-1+m_{2}</span>, and <span class="math">d=d-1+d_{2}</span>.</li>

      <li>Return the matrix <span class="math">M</span>.</li>

    </ol>

    <p class="text-gray-300">Note that “2.(c) Resolve <span class="math">F_{z}</span> to obtain its <span class="math">m_{2}</span> children <span class="math">F_{z,1},F_{z,2},\\ldots,F_{z,m_{2}}</span> and its threshold value <span class="math">d_{2}</span>” is easy and we do not discuss the detail here.</p>

    <p class="text-gray-300">The algorithm above is simple and efficient with rationale based on the following: (1) each time only one row labeled by a threshold-tree-string is handled; (2) using the construction of <span class="math">(d_{2},m_{2})</span>-LSSS from Equation (1) to ensure that the LSSS matrix for <span class="math">\\mathbb{A}</span> is completely determined by <span class="math">F_{\\mathbb{A}}</span> as the <span class="math">i^{th}</span> row of the resulting <span class="math">M</span> is labeled by the <span class="math">i^{th}</span> attribute in <span class="math">F_{\\mathbb{A}}</span>; (3) the first column of <span class="math">M_{2}</span>, i.e., <span class="math">\\vec{u}^{(2)}</span>, is an all-one vector, so that <span class="math">\\vec{v}_{z}\\otimes\\vec{u}^{(2)}</span> can easily be obtained by repeating the row <span class="math">\\vec{v}_{z}</span> <span class="math">d_{2}</span> times; and (4) the elements of <span class="math">\\widetilde{M}^{(2)}</span> can easily be obtained (the pseudo code, Algorithm 1, Line 29 to 33).</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">VI-B Complexity</h3>

    <p class="text-gray-300">Regarding the computational complexity of the algorithm, the major cost is on “<span class="math">x\\leftarrow x*a\\bmod p</span>”, that is, computing <span class="math">a^{j}\\bmod p</span> <span class="math">(a=1,\\ldots,n;j=1,\\ldots,t-1)</span> for each <span class="math">(t,n)</span>-threshold gate. While most</p>

    <p class="text-gray-300">Algorithm 1 Convert<span class="math">(F_{\\mathbb{A}})</span> 1: <span class="math">(M[1,1],L[1],m,d)\\leftarrow(1,F_{\\mathbb{A}},1,1),\\,z\\leftarrow 1</span> 2: while <span class="math">z\\neq 0</span> do 3: <span class="math">z\\leftarrow 0,i\\leftarrow 1</span> 4: while <span class="math">i\\leq m</span> <span class="math">AND</span> <span class="math">z=0</span> do 5: if L[i] is a threshold-tree-string then 6: <span class="math">z\\leftarrow i</span> 7: end if 8: <span class="math">i\\leftarrow i+1</span> 9: end while 10: if <span class="math">z\\neq 0</span> then 11: <span class="math">F_{z}\\leftarrow L[z]</span> 12: <span class="math">m_{2}\\leftarrow</span> the number of children of <span class="math">F_{z}</span>, <span class="math">d_{2}\\leftarrow</span> the threshold value of <span class="math">F_{z}</span> 13: <span class="math">L_{2}[i]\\leftarrow</span> the <span class="math">i^{th}</span> children of <span class="math">F_{z}</span> <span class="math">(i=1,2,\\ldots,m_{2})</span> 14: <span class="math">(M_{1},L_{1},m_{1},d_{1})\\leftarrow(M,L,m,d)</span> 15: for <span class="math">i=1</span> to <span class="math">z-1</span> step 1 do 16: <span class="math">L[i]\\leftarrow L_{1}[i]</span> 17: for <span class="math">j=1</span> to <span class="math">d_{1}</span> step 1 do 18: <span class="math">M[i,j]\\leftarrow M_{1}[i,j]</span> 19: end for 20: for <span class="math">j=d_{1}+1</span> to <span class="math">d_{1}+d_{2}-1</span> step 1 do 21: <span class="math">M[i,j]\\leftarrow 0</span> 22: end for 23: end for 24: for <span class="math">i=z</span> to <span class="math">z+m_{2}-1</span> step 1 do 25: <span class="math">L[i]\\leftarrow L_{2}[i-z+1]</span> 26: for <span class="math">j=1</span> to <span class="math">d_{1}</span> step 1 do 27: <span class="math">M[i,j]\\leftarrow M_{1}[z,j]</span> 28: end for 29: <span class="math">a\\leftarrow i-(z-1),\\,\\,\\,x\\leftarrow i-(z-1)</span> 30: for <span class="math">j=d_{1}+1</span> to <span class="math">d_{1}+d_{2}-1</span> step 1 do 31: <span class="math">M[i,j]\\leftarrow x</span> 32: <span class="math">x\\leftarrow x*a\\,\\,\\,{\\rm mod}\\,\\,p</span> 33: end for 34: end for 35: for <span class="math">i=z+m_{2}</span> to <span class="math">m_{1}+m_{2}-1</span> step 1 do 36: <span class="math">L[i]\\leftarrow L_{1}[i-m_{2}+1]</span> 37: for <span class="math">j=1</span> to <span class="math">d_{1}</span> step 1 do 38: <span class="math">M[i,j]\\leftarrow M_{1}[i-m_{2}+1,j]</span> 39: end for 40: for <span class="math">j=d_{1}+1</span> to <span class="math">d_{1}+d_{2}-1</span> step 1 do 41: <span class="math">M[i,j]\\leftarrow 0</span> 42: end for 43: end for 44: <span class="math">(m,d)\\leftarrow(m_{1}+m_{2}-1,d_{1}+d_{2}-1)</span> 45: end if 46: end while</p>

    <p class="text-gray-300">values will be used multiple times, the computation cost can be further reduced by storing the values of <span class="math">a^{j}\\bmod p</span>.</p>

    <p class="text-gray-300">Taking as input the number of leaf nodes in the Threshold-gate access tree, say <span class="math">n</span>, suppose there are <span class="math">I</span> non-leaf nodes, we can analyze the time complexity of the algorithm (Algorithm 1) as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Line 3 to 45 are executed <span class="math">I</span> times, one time for each non-leaf node. We use <span class="math">k=1,\\ldots,I</span> to index these executions.</li>

      <li>Line 3 to 9 are to find the first threshold-tree-string (if there exists one). Suppose the <span class="math">z_{k}</span>-th coordinate of <span class="math">L[]</span> is the first threshold-tree-string.</li>

      <li>Line 10 to 45 are to resolve <span class="math">L[z_{k}]</span> to its children and threshold value, and execute the “Insertion” operation. We use <span class="math">m_{1,k}\\times d_{1,k}</span> and <span class="math">m_{2,k}\\times d_{2,k}</span> to denote the size of corresponding matrices.</li>

    </ol>

    <p class="text-gray-300">The time complexity for the <span class="math">k</span>-th non-leaf node is</p>

    <p class="text-gray-300"><span class="math">z_{k}</span> <span class="math">\\text{ for Line 3 to Line 9}</span> <span class="math">+m_{2,k}</span> <span class="math">\\text{ for Line 13}</span> <span class="math">+(z_{k}-1)\\times(d_{1,k}+d_{2,k}-1)</span> <span class="math">\\text{ for Line 15 to Line 23}</span> <span class="math">+m_{2,k}\\times(d_{1,k}+d_{2,k}-1)</span> <span class="math">\\text{ for Line 24 to Line 34}</span> <span class="math">+(m_{1,k}-z_{k})\\times(d_{1,k}+d_{2,k}-1)</span> <span class="math">\\text{ for Line 35 to Line 43,}</span></p>

    <p class="text-gray-300">and hence the total complexity of the algorithm is</p>

    <p class="text-gray-300"><span class="math">T(n)=</span> <span class="math">\\sum_{k=1}^{I}z_{k}+m_{2,k}+(z_{k}-1+m_{2,k}+m_{1,k}-z_{k})\\times(d_{1,k}+d_{2,k}-1)</span> <span class="math">=</span> <span class="math">\\sum_{k=1}^{I}z_{k}+\\sum_{k=1}^{I}m_{2,k}+\\sum_{k=1}^{I}(m_{1,k}+m_{2,k}-1)\\times(d_{1,k}+d_{2,k}-1)</span> <span class="math">\\leq</span> <span class="math">\\sum_{k=1}^{I}z_{k}+\\sum_{k=1}^{I}m_{2,k}+\\sum_{k=1}^{I}(m_{1,k}+m_{2,k})\\times(d_{1,k}+d_{2,k})</span> <span class="math">(\\text{since }I\\leq n,\\ z_{k}\\leq n,\\ d_{1,k}\\leq m_{1,k}\\leq n,\\ d_{2,k}\\leq m_{2,k}\\leq n)</span> <span class="math">\\leq</span> <span class="math">n^{2}+n^{2}+2n\\cdot\\sum_{k=1}^{I}(m_{1,k}+m_{2,k})</span> <span class="math">=</span> <span class="math">2n^{2}+2n\\cdot\\sum_{k=1}^{I}m_{1,k}+2n\\cdot\\sum_{k=1}^{I}m_{2,k}.</span></p>

    <p class="text-gray-300">Note that the value of <span class="math">\\sum_{k=1}^{I}m_{1,k}</span> (resp. the value of <span class="math">\\sum_{k=1}^{I}m_{2,k}</span>) is the sum of the number of children of all the non-leaf nodes, this is, one less than the number of nodes in the Threshold-gate access tree</p>

    <p class="text-gray-300">(since the root node is not included). In a Threshold-gate access tree, if a non-leaf node has only one child node, the node and its child node can be combined to one node (without changing other parts), that is, any non-leaf node has no less than two children. Thus, a Threshold-gate access tree with <span class="math">n</span> leaf nodes will have at most <span class="math">2n</span> nodes (since the number of the parent nodes of the leaf nodes is at most <span class="math">\\frac{n}{2}</span>, the number of the parent nodes of these parent nodes is at most <span class="math">\\frac{n}{2^2}</span>, ...). This is also why we have <span class="math">I \\leq n</span>. Then</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} T(n) \\leq 2n^2 + 2n \\cdot \\sum_{k=1}^{I} m_{1,k} + 2n \\cdot \\sum_{k=1}^{I} m_{2,k} \\\\ \\leq 2n^2 + 2n \\cdot 2n + 2n \\cdot 2n \\\\ = 10n^2. \\end{array}</span></div>

    <p class="text-gray-300">Hence, the time complexity of Algorithm 1 is <span class="math">O(n^2)</span>.</p>

    <h2 id="sec-21" class="text-2xl font-bold">C. An Example</h2>

    <p class="text-gray-300">We now use the access tree shown in Fig. 5 as an example. As there are five Threshold-gates in the access tree, the algorithm will execute "one-row-insertion" for five times. The algorithm takes in the threshold-tree-strings <span class="math">((A,B,C,2),(D,E,F,2),(G,H,(I,J,K,L,3),2),2)</span> and works out the LSSS as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">M = \\left( \\begin{array}{ll}1 &amp;amp; ,L = \\end{array} \\right), L = \\left( \\begin{array}{ll}((A,B,C,2),(D,E,F,2),(G,H,(I,J,K,L,3),2),2) &amp;amp; \\end{array} \\right).</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">M = \\left( \\begin{array}{ll}1 &amp;amp; 1\\\\ 1 &amp;amp; 2\\\\ 1 &amp;amp; 3 \\end{array} \\right), L = \\left( \\begin{array}{c}(A,B,C,2)\\\\ (D,E,F,2)\\\\ (G,H,(I,J,K,L,3),2) \\end{array} \\right).</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">M = \\left( \\begin{array}{lll}1 &amp;amp; 1 &amp;amp; 1\\\\ 1 &amp;amp; 1 &amp;amp; 2\\\\ 1 &amp;amp; 1 &amp;amp; 3\\\\ 1 &amp;amp; 2 &amp;amp; 0\\\\ 1 &amp;amp; 3 &amp;amp; 0 \\end{array} \\right), L = \\left( \\begin{array}{c}A\\\\ B\\\\ C\\\\ (D,E,F,2)\\\\ (G,H,(I,J,K,L,3),2) \\end{array} \\right).</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">M = \\left( \\begin{array}{cccc}1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0\\\\ 1 &amp;amp; 1 &amp;amp; 2 &amp;amp; 0\\\\ 1 &amp;amp; 1 &amp;amp; 3 &amp;amp; 0\\\\ 1 &amp;amp; 2 &amp;amp; 0 &amp;amp; 1\\\\ 1 &amp;amp; 2 &amp;amp; 0 &amp;amp; 2\\\\ 1 &amp;amp; 2 &amp;amp; 0 &amp;amp; 3\\\\ 1 &amp;amp; 3 &amp;amp; 0 &amp;amp; 0 \\end{array} \\right), L = \\left( \\begin{array}{c}A\\\\ B\\\\ C\\\\ D\\\\ E\\\\ F\\\\ (G,H,(I,J,K,L,3),2) \\end{array} \\right).</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">M = \\left( \\begin{array}{cccc}1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0\\\\ 1 &amp;amp; 1 &amp;amp; 2 &amp;amp; 0 &amp;amp; 0\\\\ 1 &amp;amp; 1 &amp;amp; 3 &amp;amp; 0 &amp;amp; 0\\\\ 1 &amp;amp; 2 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0\\\\ 1 &amp;amp; 2 &amp;amp; 0 &amp;amp; 2 &amp;amp; 0\\\\ 1 &amp;amp; 2 &amp;amp; 0 &amp;amp; 3 &amp;amp; 0\\\\ 1 &amp;amp; 3 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1\\\\ 1 &amp;amp; 3 &amp;amp; 0 &amp;amp; 0 &amp;amp; 2\\\\ 1 &amp;amp; 3 &amp;amp; 0 &amp;amp; 0 &amp;amp; 3 \\end{array} \\right),L = \\left( \\begin{array}{c}A\\\\ B\\\\ C\\\\ D\\\\ E\\\\ F\\\\ G\\\\ H\\\\ (I,J,K,L,3) \\end{array} \\right).</span></li>

      <li><span class="math">M = \\left( \\begin{array}{cccccc}1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0\\\\ 1 &amp;amp; 1 &amp;amp; 2 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0\\\\ 1 &amp;amp; 1 &amp;amp; 3 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0\\\\ 1 &amp;amp; 2 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0\\\\ 1 &amp;amp; 2 &amp;amp; 0 &amp;amp; 2 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0\\\\ 1 &amp;amp; 2 &amp;amp; 0 &amp;amp; 3 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0\\\\ 1 &amp;amp; 3 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0\\\\ 1 &amp;amp; 3 &amp;amp; 0 &amp;amp; 0 &amp;amp; 2 &amp;amp; 0 &amp;amp; 0\\\\ 1 &amp;amp; 3 &amp;amp; 0 &amp;amp; 0 &amp;amp; 3 &amp;amp; 1 &amp;amp; 1\\\\ 1 &amp;amp; 3 &amp;amp; 0 &amp;amp; 0 &amp;amp; 3 &amp;amp; 2 &amp;amp; 4\\\\ 1 &amp;amp; 3 &amp;amp; 0 &amp;amp; 0 &amp;amp; 3 &amp;amp; 3 &amp;amp; 9\\\\ 1 &amp;amp; 3 &amp;amp; 0 &amp;amp; 0 &amp;amp; 3 &amp;amp; 4 &amp;amp; 16 \\end{array} \\right),L = \\left( \\begin{array}{c}A\\\\ B\\\\ C\\\\ D\\\\ E\\\\ F\\\\ G\\\\ H\\\\ I\\\\ J\\\\ K\\\\ L \\end{array} \\right).</span></li>

    </ol>

    <p class="text-gray-300">Algorithm 1 can be used in all the aforementioned provably secure and highly expressive CP-ABE schemes [12]–[20]. The algorithm can be embedded in the Encrypt and Decrypt algorithms, and the small-size threshold-tree-string can be included in the ciphertext as its policy. In this way, at the cost of running this new converting algorithm in the Decrypt process <span class="math">^4</span> , we should use the small-size threshold-tree-string (whose size is approximately equal to that of  <span class="math">\\rho</span> ) to specify ciphertext policies, rather than employing the large LSSS  <span class="math">(M,\\rho)</span>  directly. Besides, this new algorithm also results in achieving smaller (or the same in the worst case where all the non-leaf nodes of an access tree are AND or OR gates only) ciphertext size when compared with using the Lewko-Waters algorithm.</p>

    <p class="text-gray-300">More Efficient Converting Algorithm for the CP-ABE Decryption Process. In the Encrypt process of a CP-ABE system, the LSSS is completely generated using Algorithm 1. While in the Decrypt process, we observe that the LSSS does not need to be completely generated and hence can enhance the efficiency of this new converting algorithm specifically for the Decrypt process. In particular, only the rows labeled by the attributes that the user possesses need to be converted. We modify the algorithm so that it takes an attribute set <span class="math">S</span> as an additional input, and if <span class="math">L_{z}</span> does not contain any attribute in <span class="math">S</span>, we remove the <span class="math">z^{th}</span> row of <span class="math">M</span> and the <span class="math">z^{th}</span> coordinate of <span class="math">L</span>. As a result, the algorithm avoids executing unnecessary insertions. The following is the description of the modified algorithm, where the bold parts are different from the original Algorithm 1.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Input: A threshold-tree-string <span class="math">F_{\\mathbb{A}}</span> and an attribute set <span class="math">S</span>.</li>

      <li>Output: A matrix <span class="math">M</span> and a vector <span class="math">L</span> whose coordinates are the attributes in <span class="math">S</span>. The <span class="math">i^{th}</span> row of <span class="math">M</span> is labeled by the <span class="math">i^{th}</span> coordinate of <span class="math">L</span>.</li>

      <li>Convert<span class="math">(F_{\\mathbb{A}})</span>: In the following, <span class="math">M</span> is an <span class="math">m\\times d</span> matrix over <span class="math">\\mathbb{Z}_{p}</span>, and <span class="math">L</span> is a vector with <span class="math">m</span> coordinates, where each coordinate is an attribute or a threshold-tree-string. The <span class="math">i^{th}</span> coordinate of <span class="math">L</span> labels the <span class="math">i^{th}</span> row of <span class="math">M</span>.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let matrix <span class="math">M=(1)_{1\\times 1}</span>, vector <span class="math">L=(F_{\\mathbb{A}})</span>, and <span class="math">m=1,d=1</span>.</li>

      <li>Repeat the following until all coordinates of <span class="math">L</span> are attributes:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Consider <span class="math">M</span> to be an <span class="math">m\\times d</span> matrix over <span class="math">\\mathbb{Z}_{p}</span>, and <span class="math">L=(L_{1},L_{2},\\ldots,L_{m})</span>.</li>

      <li>Scan the coordinates of <span class="math">L</span> to find the first coordinate that is a threshold-tree-string rather than an attribute. Suppose the index is <span class="math">z</span>. We have a threshold-tree-string <span class="math">L_{z}=F_{z}=(F_{z,1},F_{z,2},\\ldots,F_{z,m_{2}},d_{2})</span>. If <span class="math">L_{z}</span> does not contain any attribute in <span class="math">S</span>, remove the <span class="math">z^{th}</span> row of <span class="math">M</span> and the <span class="math">z^{th}</span> coordinate of <span class="math">L</span>, set <span class="math">m=m-1</span>, and go to (a).</li>

      <li>Resolve <span class="math">F_{z}</span> to obtain its <span class="math">m_{2}</span> children <span class="math">F_{z,1},F_{z,2},\\ldots,F_{z,m_{2}}</span> and its threshold value <span class="math">d_{2}</span>.</li>

      <li>For this <span class="math">(d_{2},m_{2})</span>-threshold access structures, construct the corresponding LSSS matrix according to Equation (1), then execute “insertion” of this <span class="math">(d_{2},m_{2})</span>-LSSS matrix on the <span class="math">z^{th}</span> row of <span class="math">M</span> to obtain a new <span class="math">M</span> with <span class="math">m-1+m_{2}</span> rows and <span class="math">d-1+d_{2}</span> columns. Set <span class="math">L=(L_{1},L_{2},\\ldots,L_{z-1},F_{z,1},F_{z,2},\\ldots,F_{z,m_{2}},L_{z+1},\\ldots,L_{m})</span>, and then set <span class="math">m=m-1+m_{2}</span>, and <span class="math">d=d+d_{2}-1</span>.</li>

      <li>Remove the coordinates (i.e. attributes) of <span class="math">L</span> that do not appear in <span class="math">S</span>, and remove the corresponding rows of <span class="math">M</span>, then return the matrix <span class="math">M</span> and vector <span class="math">L</span>.</li>

    </ol>

    <p class="text-gray-300">This modified algorithm will work well for the Decrypt process because in the one-row-insertion</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">operation, all elements of the expanded columns, except those in  <span class="math">\\widetilde{M}^{(2)}</span> , are zero. For any  <span class="math">F_{\\mathbb{A}}</span>  and  <span class="math">S</span> , suppose that  <span class="math">M_S&#x27;</span>  is the output of this modified algorithm, and  <span class="math">M_S</span>  is the sub-matrix labeled by  <span class="math">S</span>  from  <span class="math">M</span>  output by the original converting algorithm, i.e., Algorithm 1, we have that  <span class="math">M_S&#x27;</span>  can be obtained from  <span class="math">M_S</span>  by removing some all-zero columns, so that for any row vector  $\\vec{\\omega} = (\\omega_1, \\ldots, \\omega_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math"> ,  </span>\\vec{\\omega} M_S = (1, 0, \\ldots, 0)<span class="math">  if and only if  </span>\\vec{\\omega} M_S' = (1, 0, \\ldots, 0)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As an example (use the one in Fig. 5 again), given</p>

    <div class="my-4 text-center"><span class="math-block">F _ {\\mathbb {A}} = ((A, B, C, 2), (D, E, F, 2), (G, H, (I, J, K, L, 3), 2), 2)</span></div>

    <p class="text-gray-300">and  <span class="math">S = \\{A,B,G,H\\}</span> , the modified algorithm works as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">M_S&#x27; = \\left( \\begin{array}{l} 1 \\end{array} \\right), L = \\left( \\begin{array}{l} ((A, B, C, 2), (D, E, F, 2), (G, H, (I, J, K, L, 3), 2), 2) \\end{array} \\right)</span> .</li>

      <li><span class="math">M_S&#x27; = \\left( \\begin{array}{ll}1 &amp;amp; 1\\\\ 1 &amp;amp; 2\\\\ 1 &amp;amp; 3 \\end{array} \\right), L = \\left( \\begin{array}{c}(A,B,C,2)\\\\ (D,E,F,2)\\\\ (G,H,(I,J,K,L,3),2) \\end{array} \\right).</span></li>

      <li><span class="math">M_S&#x27; = \\left( \\begin{array}{lll}1 &amp;amp; 1 &amp;amp; 1\\\\ 1 &amp;amp; 1 &amp;amp; 2\\\\ 1 &amp;amp; 1 &amp;amp; 3\\\\ 1 &amp;amp; 2 &amp;amp; 0\\\\ 1 &amp;amp; 3 &amp;amp; 0 \\end{array} \\right), L = \\left( \\begin{array}{c}A\\\\ B\\\\ C\\\\ (D,E,F,2)\\\\ (G,H,(I,J,K,L,3),2) \\end{array} \\right).</span></li>

      <li><span class="math">M_S&#x27; = \\left( \\begin{array}{lll}1 &amp;amp; 1 &amp;amp; 1\\\\ 1 &amp;amp; 1 &amp;amp; 2\\\\ 1 &amp;amp; 1 &amp;amp; 3\\\\ 1 &amp;amp; 3 &amp;amp; 0 \\end{array} \\right), L = \\left( \\begin{array}{c}A\\\\ B\\\\ C\\\\ (G,H,(I,J,K,L,3),2) \\end{array} \\right).</span></li>

      <li><span class="math">M_S&#x27; = \\left( \\begin{array}{cccc}1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0\\\\ 1 &amp;amp; 1 &amp;amp; 2 &amp;amp; 0\\\\ 1 &amp;amp; 1 &amp;amp; 3 &amp;amp; 0\\\\ 1 &amp;amp; 3 &amp;amp; 0 &amp;amp; 1\\\\ 1 &amp;amp; 3 &amp;amp; 0 &amp;amp; 2\\\\ 1 &amp;amp; 3 &amp;amp; 0 &amp;amp; 3 \\end{array} \\right), L = \\left( \\begin{array}{c}A\\\\ B\\\\ C\\\\ G\\\\ H\\\\ (I,J,K,L,3) \\end{array} \\right).</span></li>

      <li><span class="math">M_S&#x27; = \\left( \\begin{array}{cccc}1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0\\\\ 1 &amp;amp; 1 &amp;amp; 2 &amp;amp; 0\\\\ 1 &amp;amp; 1 &amp;amp; 3 &amp;amp; 0\\\\ 1 &amp;amp; 3 &amp;amp; 0 &amp;amp; 1\\\\ 1 &amp;amp; 3 &amp;amp; 0 &amp;amp; 2 \\end{array} \\right), L = \\left( \\begin{array}{c}A\\\\ B\\\\ C\\\\ G\\\\ H \\end{array} \\right).</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\[ M_{S}^{\\prime}=\\left(\\begin{array}[]{cccc}1&1&1&0\\\\</li>

    </ol>

    <p class="text-gray-300">1&1&2&0\\\\ 1&3&0&1\\\\ 1&3&0&2\\end{array}\\right),\\\\ L=\\left(\\begin{array}[]{c}A\\\\ B\\\\ G\\\\ H\\end{array}\\right) \\]. Note that <span class="math">M_{S}</span> obtained from the example in Section. IV-C is</p>

    <p class="text-gray-300">\\[ M_{S}=\\left(\\begin{array}[]{cccccccc}1&1&1&0&0&0&0\\\\ 1&1&2&0&0&0&0\\\\ 1&3&0&0&1&0&0\\\\ 1&3&0&0&2&0&0\\end{array}\\right), \\]</p>

    <p class="text-gray-300">and <span class="math">M_{S}^{\\prime}</span> can be obtained from <span class="math">M_{S}</span> by removing the all-zero columns (<span class="math">4^{th},6^{th}</span>, and <span class="math">7^{th}</span> columns).</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">IV-E The Application of the New Algorithm in KP-ABE Systems</h3>

    <p class="text-gray-300">As mentioned in Sec. II-A, fully secure and highly expressive KP-ABE schemes such as <em>[14, 29]</em> use LSSS to specify access policies of private keys, and the private key size is linear in the size of the associated LSSS. Applying this new converting algorithm in the key generation process of these KP-ABE schemes will result in private keys with smaller size than (or at most the same as) applying the Lewko-Waters algorithm.</p>

    <h2 id="sec-24" class="text-2xl font-bold">V Conclusion</h2>

    <p class="text-gray-300">In this paper, we proposed a new algorithm that converts any monotone access structures, in the most general and efficient form (i.e., Threshold-gate access trees, expressed by threshold-tree-strings), to the corresponding LSSS matrices. As Threshold-gate access tree is the most general and efficient form to describe a monotone access structure, for any given monotone access structures, this new algorithm can be applied directly, without requiring any preprocessing, and the size of the resulting LSSS matrix can achieve the best level among currently available work, and can also achieve much better efficiency when compared with the existing work especially for the cases where we have the general <span class="math">(t,n)</span>-threshold gates other than being limited to the special cases of AND and OR gates. For the highly expressive CP-ABE and KP-ABE systems that use LSSS as access policies, using this new converting algorithm can attain smaller ciphertext size for CP-ABE and smaller private key size for KP-ABE. In addition, as the resulting LSSS matrix is completely determined by the threshold-tree-string, for the CP-ABE schemes, we can associate threshold-tree-strings as access policies rather than the LSSS matrices to the ciphertexts, so that we can significantly reduce the overhead incurred by expressing the access policies, from an LSSS</p>

    <p class="text-gray-300">matrix <span class="math">(M,\\rho)</span> over <span class="math">\\mathbb{Z}_{p}</span> to a simple and intuitive threshold-tree-string, whose size is approximately equal to that of <span class="math">\\rho</span>.</p>

    <h2 id="sec-25" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] V. Goyal, O. Pandey, A. Sahai, and B. Waters, “Attribute-based encryption for fine-grained access control of encrypted data,” in <em>ACM Conference on Computer and Communications Security</em>. ACM, 2006, pp. 89–98.</li>

      <li>[2] R. L. Rivest, A. Shamir, and L. M. Adleman, “A method for obtaining digital signatures and public-key cryptosystems,” <em>Commun. ACM</em>, vol. 21, no. 2, pp. 120–126, 1978.</li>

      <li>[3] T. E. Gamal, “A public key cryptosystem and a signature scheme based on discrete logarithms,” <em>IEEE Transactions on Information Theory</em>, vol. 31, no. 4, pp. 469–472, 1985.</li>

      <li>[4] R. Cramer and V. Shoup, “A practical public key cryptosystem provably secure against adaptive chosen ciphertext attack,” in <em>CRYPTO</em>, ser. Lecture Notes in Computer Science, vol. 1462. Springer, 1998, pp. 13–25.</li>

      <li>[5] A. Shamir, “Identity-based cryptosystems and signature schemes,” in <em>CRYPTO</em>, ser. Lecture Notes in Computer Science, vol. 196. Springer, 1984, pp. 47–53.</li>

      <li>[6] D. Boneh and M. K. Franklin, “Identity-based encryption from the weil pairing,” in <em>CRYPTO</em>, ser. Lecture Notes in Computer Science, vol. 2139. Springer, 2001, pp. 213–229.</li>

      <li>[7] A. Fiat and M. Naor, “Broadcast encryption,” in <em>CRYPTO</em>, ser. Lecture Notes in Computer Science, vol. 773. Springer, 1993, pp. 480–491.</li>

      <li>[8] D. Boneh, C. Gentry, and B. Waters, “Collusion resistant broadcast encryption with short ciphertexts and private keys,” in <em>CRYPTO</em>, ser. Lecture Notes in Computer Science, vol. 3621. Springer, 2005, pp. 258–275.</li>

      <li>[9] J. Bethencourt, A. Sahai, and B. Waters, “Ciphertext-policy attribute-based encryption,” in <em>IEEE Symposium on Security and Privacy</em>. IEEE Computer Society, 2007, pp. 321–334.</li>

      <li>[10] L. Cheung and C. C. Newport, “Provably secure ciphertext policy ABE,” in <em>ACM Conference on Computer and Communications Security</em>. ACM, 2007, pp. 456–465.</li>

      <li>[11] V. Goyal, A. Jain, O. Pandey, and A. Sahai, “Bounded ciphertext policy attribute based encryption,” in <em>ICALP (2)</em>, ser. Lecture Notes in Computer Science, vol. 5126. Springer, 2008, pp. 579–591.</li>

      <li>[12] B. Waters, “Ciphertext-policy attribute-based encryption: An expressive, efficient, and provably secure realization,” in <em>Public Key Cryptography</em>, ser. Lecture Notes in Computer Science, vol. 6571. Springer, 2011, pp. 53–70.</li>

      <li>[13] A. B. Lewko, T. Okamoto, A. Sahai, K. Takashima, and B. Waters, “Fully secure functional encryption: Attribute-based encryption and (hierarchical) inner product encryption,” in <em>EUROCRYPT</em>, ser. Lecture Notes in Computer Science, vol. 6110. Springer, 2010, pp. 62–91.</li>

      <li>[14] T. Okamoto and K. Takashima, “Fully secure functional encryption with general relations from the decisional linear assumption,” in <em>CRYPTO</em>, ser. Lecture Notes in Computer Science, vol. 6223. Springer, 2010, pp. 191–208.</li>

      <li>[15] A. B. Lewko and B. Waters, “Decentralizing attribute-based encryption,” in <em>EUROCRYPT</em>, ser. Lecture Notes in Computer Science, vol. 6632. Springer, 2011, pp. 568–588.</li>

      <li>[16] Z. Liu, Z. Cao, Q. Huang, D. S. Wong, and T. H. Yuen, “Fully secure multi-authority ciphertext-policy attribute-based encryption without random oracles,” in <em>ESORICS</em>, ser. Lecture Notes in Computer Science, vol. 6879. Springer, 2011, pp. 278–297.</li>

      <li>[17] A. B. Lewko and B. Waters, “New proof methods for attribute-based encryption: Achieving full security through selective techniques,” in <em>CRYPTO</em>, ser. Lecture Notes in Computer Science, vol. 7417. Springer, 2012, pp. 180–198.</li>

    </ul>

    <p class="text-gray-300">[18] Z. Liu, Z. Cao, and D. S. Wong, “White-box traceable ciphertext-policy attribute-based encryption supporting any monotone access structures,” <em>IEEE Transactions on Information Forensics and Security</em>, vol. 8, no. 1, pp. 76–88, 2013.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[19] Y. Rouselakis and B. Waters, “Practical constructions and new proof methods for large universe attribute-based encryption,” in <em>ACM Conference on Computer and Communications Security</em>. ACM, 2013, pp. 463–474.</li>

      <li>[20] Z. Liu, Z. Cao, and D. S. Wong, “Blackbox traceable CP-ABE: how to catch people leaking their keys by selling decryption devices on ebay,” in <em>ACM Conference on Computer and Communications Security</em>. ACM, 2013, pp. 475–486.</li>

      <li>[21] A. Beimel, “Secure schemes for secret sharing and key distribution,” Ph.D. dissertation, Israel Institute of Technology, Technion, Haifa, Israel, 1996.</li>

      <li>[22] J. C. Benaloh and J. Leichter, “Generalized secret sharing and monotone functions,” in <em>CRYPTO</em>, ser. Lecture Notes in Computer Science, vol. 403. Springer, 1988, pp. 27–35.</li>

      <li>[23] A. B. Lewko and B. Waters, “Decentralizing attribute-based encryption,” IACR Cryptology ePrint Archive, Tech. Rep. 351, 2010.</li>

      <li>[24] I. Wegener, <em>The complexity of Boolean functions</em>. Wiley-Teubner, 1987.</li>

      <li>[25] M. Karchmer and A. Wigderson, “On span programs,” in <em>Structure in Complexity Theory Conference</em>, 1993, pp. 102–111.</li>

      <li>[26] C. Zhang, K.-Y. Lam, and S. Jajodia, “Scalable threshold closure,” <em>Theor. Comput. Sci.</em>, vol. 226, no. 1-2, pp. 185–206, 1999.</li>

      <li>[27] A. Sahai and B. Waters, “Fuzzy identity-based encryption,” in <em>EUROCRYPT</em>, ser. Lecture Notes in Computer Science, vol. 3494. Springer, 2005, pp. 457–473.</li>

      <li>[28] R. Ostrovsky, A. Sahai, and B. Waters, “Attribute-based encryption with non-monotonic access structures,” in <em>ACM Conference on Computer and Communications Security</em>. ACM, 2007, pp. 195–203.</li>

      <li>[29] A. B. Lewko, T. Okamoto, A. Sahai, K. Takashima, and B. Waters, “Fully secure functional encryption: Attribute-based encryption and (hierarchical) inner product encryption,” IACR Cryptology ePrint Archive, Tech. Rep. 110, 2010.</li>

      <li>[30] N. Attrapadung, B. Libert, and E. de Panafieu, “Expressive key-policy attribute-based encryption with constant-size ciphertexts,” in <em>Public Key Cryptography</em>, ser. Lecture Notes in Computer Science, vol. 6571. Springer, 2011, pp. 90–108.</li>

      <li>[31] R. Longo, C. Marcolla, and M. Sala, “Key-policy multi-authority attribute-based encryption,” in <em>Algebraic Informatics</em>, ser. Lecture Notes in Computer Science, vol. 9270. Springer, 2015, pp. 152–164.</li>

      <li>[32] V. Nikov and S. Nikova, “New monotone span programs from old,” IACR Cryptology ePrint Archive, Tech. Rep. 282, 2004.</li>

      <li>[33] A. Shamir, “How to share a secret,” <em>Commun. ACM</em>, vol. 22, no. 11, pp. 612–613, 1979.</li>

    </ul>`;
---

<BaseLayout title="Efficient Generation of Linear Secret Sharing Scheme Matrice... (2010/374)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2010 &middot; eprint 2010/374
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
