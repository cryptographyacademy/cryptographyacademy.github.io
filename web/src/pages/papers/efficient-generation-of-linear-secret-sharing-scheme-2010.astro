---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2010/374';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-18';
const TITLE_HTML = 'Efficient Generation of Linear Secret Sharing Scheme Matrices from Threshold Access Trees';
const AUTHORS_HTML = 'Zhen Liu, Zhenfu Cao, Duncan S.  Wong';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">Linear Secret Sharing Scheme (LSSS) matrices are commonly used for implementing monotone access structures in highly expressive Ciphertext-Policy Attribute-Based Encryption (CP-ABE) schemes. However, LSSS matrices are much less intuitive to use when compared with other approaches such as boolean formulas or access trees. To bridge the gap between the usability of an access structure representation method and the implementation technique required in a concrete CP-ABE construction, Lewko and Waters proposed an algorithm which can convert any monotone boolean formulas to LSSS matrices. This algorithm is very useful in practice as a ciphertext policy can now be intuitively expressed using a monotone boolean formula, which has good usability, and the corresponding LSSS for an actual CP-ABE construction can then be generated accordingly using this algorithm. However, in this algorithm, the non-leaf nodes of a monotone boolean formula, when viewed as an access tree, can only be \\textsf{AND} or \\textsf{OR} gates. For general monotone access structures, for example, in a $(t, n)$-threshold access tree, the threshold gates of the tree have to be converted to \\textsf{AND} and \\textsf{OR} gates before we can apply the algorithm on this access tree. This results in generating a large LSSS matrix, and entailing a large CP-ABE ciphertext. To address this problem, in this paper, we propose a new algorithm which, in addition to \\textsf{AND} and \\textsf{OR} gates, can directly support threshold gates, and obtain much smaller LSSS matrices (or the same in the worst case when only \\textsf{AND} and \\textsf{OR} gates exist). This will particularly be useful for reducing the size of all ciphertexts with policies in the typical $(t, n)$-threshold type. Furthermore, as \\textsf{AND} and \\textsf{OR} gates are the special cases of the general $(t, n)$-threshold gates, not only an optimization, but also is this new algorithm a generalization of the Lewko-Waters algorithm.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> Attribute-Based Encryption &middot; Access Policy &middot; Monotone Access Structure &middot; Linear Secret Sharing Scheme</p>
    </section>

    <h2 id="sec-misc-1" class="text-2xl font-bold"><em>A. Attribute-Based Encryption</em></h2>

    <p class="text-gray-300">Sahai and Waters [27] introduced the concept of Attribute-Based Encryption (ABE) in 2005 when working on fuzzy Identity-Based Encryption. In their work, each user's private key is described by an attribute set and each ciphertext is encrypted under an attribute set as well. For a private key with attribute set w, to decrypt a ciphertext encrypted under an attribute set w 0 , if and only if w and w 0 are close to each other as measured by the &quot;set overlap distance metric&quot; (i.e. |w &cap; w 0 | &ge; d for some threshold value d), the decryption will succeed. In other words, this is an ABE scheme supporting threshold policies.</p>

    <p class="text-gray-300">In 2006, Goyal et al. [1] formalized Key-Policy ABE (KP-ABE) and Ciphertext-Policy ABE (CP-ABE). In CP-ABE, each user's private key is associated with an attribute set issued by an authority, and each ciphertext is associated with an access policy specified by the encryptor. The policy determines what users are eligible to decrypt the ciphertext. In KP-ABE, each user's private key is associated with an access policy issued by an authority. The policy determines what ciphertexts that the user is eligible to decrypt, where each ciphertext is described by an attribute set. Though we focus on CP-ABE in this paper, it is worth mentioning that KP-ABE also have many applications, such as pay-TV and audit-log [1]. Among recently proposed KP-ABE schemes [1], [14], [28]&ndash;[31], some highly expressive ones (e.g. [14], [29], [31]) also use LSSS to specify the access policies for private keys.</p>

    <h2 id="sec-misc-2" class="text-2xl font-bold"><em>B. Access Policies and Realizations</em></h2>

    <p class="text-gray-300">An access policy can be described as an <em>access structure</em> which can be realized by a <em>secret sharing scheme</em>. In the following, we review their definitions.</p>

    <p class="text-gray-300">Definition 1 (Access Structure [21]). <em>Let</em> P = {P1, P2, . . . , Pn} <em>be a set of parties. A collection</em> A &sube; 2 {P1,P2,...,Pn} <em>is monotone if for any</em> B <em>and</em> C<em>: if</em> B &isin; A and B &sube; C then C &isin; A<em>. An access structure (respectively, monotone access structure) is a collection (respectively, monotone collection)</em> A <em>of nonempty subsets of</em> {P1, P2, . . . , Pn}<em>, i.e.,</em> A &sube; 2 {P1,P2,...,Pn} \\ {&empty;}<em>. The sets in</em> A <em>are called the authorized sets, and the sets not in</em> A <em>are called the unauthorized sets.</em></p>

    <p class="text-gray-300">In an ABE system, the role of the parties is defined by attributes. An access structure A in ABE contains the authorized sets of attributes. Unless otherwise stated, by an access structure we mean a monotone access structure for the rest of this paper. As shown in [21], any monotone access structure can be realized by a linear secret sharing scheme. Below we use the definition from [12], [21].</p>

    <p class="text-gray-300">Definition 2 (Linear Secret-Sharing Schemes (LSSS) [12]). <em>A secret sharing scheme</em> &Pi; <em>over a set of parties</em> P <em>is called linear (over</em> Zp<em>) if</em></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>the shares for each party form a vector over</em> Zp<em>, and</em></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>there exists a matrix</em> M <em>called the share-generating matrix for</em> &Pi;<em>. The matrix</em> M <em>has</em> m <em>rows and</em> d <em>columns. For</em> i = 1, . . . , m<em>, the</em> i th <em>row</em> M<sup>i</sup> <em>of</em> M <em>is labeled by a party</em> &rho;(i) <em>where</em> &rho; <em>is a function from</em> {1, . . . , m} <em>to</em> P<em>. Given a column vector</em> ~v = (s, r2, . . . , rd)<em>, where</em> s &isin; Z<sup>p</sup> <em>is the secret to be shared and</em> r2, . . . , r<sup>d</sup> &isin; Z<sup>p</sup> <em>are randomly chosen,</em> M~v <em>is the vector of</em> m <em>shares of the secret</em> s <em>according to</em> &Pi;<em>. The share</em> &lambda;<sup>i</sup> = (M~v)<sup>i</sup> <em>, i.e., the inner product</em> M<sup>i</sup> &middot; ~v<em>, belongs to party</em> &rho;(i)<em>.</em></li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Also as shown in [21], any LSSS defined as above enjoys the linear reconstruction property defined as follows. Suppose that &Pi; is an LSSS for access structure A. Let S &isin; A be an authorized set, and I &sub; {1, . . . , m} be defined as I = {i : &rho;(i) &isin; S}. There exist constants {&omega;<sup>i</sup> &isin; Zp}i&isin;<sup>I</sup> satisfying P <sup>i</sup>&isin;<sup>I</sup> &omega;iM<sup>i</sup> = (1, 0, . . . , 0), so that if {&lambda;i} are valid shares of any secret s according to &Pi;, then P <sup>i</sup>&isin;<sup>I</sup> &omega;i&lambda;<sup>i</sup> = s. Furthermore, these constants {&omega;i} can be found in time polynomial in the size of the share-generating matrix M. For any unauthorized set, no such constants exist. The LSSS is denoted by (M, &rho;), and its size is the number of rows of M, that is, m.</p>

    <p class="text-gray-300">In the highly expressive CP-ABE schemes mentioned above [12]&ndash;[20], each ciphertext is associated with an LSSS (M, &rho;) as its access policy, and the ciphertext size is linear in the size of (M, &rho;). In the highly expressive KP-ABE schemes [14], [29], each private key is associated with an LSSS (M, &rho;), and the private key size is linear in the size of (M, &rho;).</p>

    <p class="text-gray-300">Besides the theoretical way of describing access policies using access structures, there are several more practical and efficient ways for describing policies. They are efficient because they can eliminate the redundancies as usually found in conventional access structures. Fig. 6 shows the different forms for describing a (2, 4)-threshold policy over the universe P = {A, B, C, D}. They include the minimal form access structure, the boolean formula and two types of access trees.</p>

    <p class="text-gray-300">Minimal Form Access Structures. Due to the monotonicity, a monotone access structure A can be efficiently described by a set A <sup>&minus;</sup>, which consists of the <em>minimal elements (sets)</em> in A, i.e., the elements in A for which no proper subset is also in A. Given A <sup>&minus;</sup>, A can be determined as follows. For any attribute set S &sube; P, if and only if there exists some set A &isin; A <sup>&minus;</sup> such that S &supe; A, S is an authorized set (i.e., S &isin; A, or S satisfies A). We refer to A <sup>&minus;</sup> as the <em>minimal form</em> of A. Note that each minimal set in A <sup>&minus;</sup> represents a distinct series of authorized sets in A, i.e., suppose A <sup>&minus;</sup> = {A1, . . . , An<sup>A</sup> } and A<sup>n</sup> = {S | S &supe; An} for 1 &le; n &le; nA, we have A = S 1&le;n&le;n<sup>A</sup> An, and An<sup>1</sup> 6= An<sup>2</sup> for 1 &le; n<sup>1</sup> 6= n<sup>2</sup> &le; nA. Obviously, it is more efficient to use the minimal form to describe an access policy rather than the access structure itself which may contain many redundancies.</p>

    <p class="text-gray-300">Montone Boolean Formulas. When compared with minimal form access structure, a monotone boolean formula is more general and efficient for describing the same access policy, where a monotone boolean formula is a boolean formula without NOT. For any minimal form monotone access structure, say A <sup>&minus;</sup> = {A1, . . . , An<sup>A</sup> }, an equivalent monotone boolean formula, say F<sup>A</sup> = W 1&le;n&le;n<sup>A</sup> ( V x&isin;A<sup>n</sup> x) can be</p>

    <p class="text-gray-300">, &#1830;,&#1829; , &#1830; ,&#1828; , &#1829; ,&#1828; , &#1830; ,&#1827; , &#1829; ,&#1827; , &#1828; ,&#1827; :Structure Access &#1830; ,&#1829; ,&#1828; ,&#1827; , &#1830;,&#1829; ,&#1828; , &#1830; ,&#1829; ,&#1827; , &#1830; ,&#1828; ,&#1827; , &#1829; ,&#1828; ,&#1827;</p>

    <p class="text-gray-300">&#1830;,&#1829; , &#1830;,&#1828; , &#1829; ,&#1828; , &#1830; ,&#1827; , &#1829; ,&#1827; , &#1828; ,&#1827; :Form Minimal in Structure Access</p>

    <p class="text-gray-300">&#1830;&or;&#1829; &and; &#1828;&or;&#1827; &or; &#1830;&and;&#1829; &or; &#1828;&and;&#1827; :Formula Boolean</p>

    <p class="text-gray-300">Access Tree with Threshold Gates:</p>

    <p class="text-gray-300">Access Tree with AND&#8208;OR Gates:</p>

    <p class="text-gray-300">    <img src="_page_11_Figure_6.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 6. Different forms for describing a (2, 4)-threshold policy over the universe {A, B, C, D}</p>

    <p class="text-gray-300">compressed and simplified further to obtain a version with smaller size, e.g, (A&and;B)&or;(A&and;C) = A&and;(B&or;C) (as shown in Fig. 6). On the other side, if we already have a monotone boolean formula which describes an access policy, and want to transform it to an equivalent minimal form access structure, we need to first convert the boolean formula to an equivalent DNF, whose size may be larger than the original boolean formula.</p>

    <p class="text-gray-300">Monotone Access Trees. On a monotone access tree, each leaf node corresponds to an attribute, and each non-leaf node represents a threshold gate, which is described by its children and a threshold value. This is generally termed as Threshold-gate access tree while a AND-OR-gate access tree (detailed below) is a special case of the Threshold-gate access tree. Whether an attribute set S satisfies a monotone access tree is determined as follows. For a leaf node, if the corresponding attribute appears in S, the leaf node is said to be satisfied. For a (t, n)-threshold gate where n is the number of its children and 1 &le; t &le; n is the threshold value, if and only if at least its t (out of n) child nodes are satisfied, the (t, n)-threshold node is satisfied. If and only if the root node of the access tree is satisfied, the access tree is said to be satisfied by S. For a (t, n)-threshold gate, when t = 1, the threshold gate is an OR gate and when t = n, it is an AND gate. Hence, an AND-gate can be expressed as an (n, n)-Thresholdgate, and an OR-gate can be expressed as a (1, n)-Threshold-gate, but reversely to express a general</p>

    <p class="text-gray-300">(t, n)-threshold gate where 1 &lt; t &lt; n, multiple AND and OR gates have to be used. As a result, for an AND-OR-gate access tree, we can replace all the AND and OR gates on the tree with (n, n)- and (1, n)-threshold gates, respectively, and obtain a Threshold-gate access tree with the same number of leaf nodes. However, conversely for a Threshold-gate access tree, once general (t, n)-threshold gates with 1 &lt; t &lt; n are involved, an equivalent AND-OR-gate access tree will have more leaf nodes than the original Threshold-gate access tree. Also note that an AND-OR-gate access tree is the same as an equivalent monotone boolean formula in terms of generality and efficiency, where AND gate corresponds to &and; and OR gate to &or;.</p>

    <p class="text-gray-300">Efficiency of These Different Forms. The expressivity of minimal form access structure, monotone boolean formula, Threshold-gate access tree and AND-OR-gate access tree are equivalent. If we use A &gt; B (reps. A &equiv; B) to represent that form A is more efficient than form B (resp. form A is equally efficient to form B), we have the following relationships.</p>

    <p class="text-gray-300">Threshold-gate access tree &gt; AND-OR-gate access tree</p>

    <p class="text-gray-300">AND-OR-gate access tree &equiv; monotone boolean formula</p>

    <p class="text-gray-300">monotone boolean formula &gt; (minimal form) access structure</p>

    <p class="text-gray-300">As a summary of the above, we have the following facts.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Any monotone access structure can be described and determined by an equivalent minimal form access structure.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Any minimal form access structure can be written to an equivalent monotone boolean formula, i.e. a DNF.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Any monotone boolean formula can be illustrated as an AND-OR-gate access tree with the number of leaf nodes being equal to the size of the boolean formula.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Any AND-OR-gate access tree is a special case of a Threshold-gate access tree with the same number of leaf nodes.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Fig. 6 is also an example that Threshold-gate access tree is the most general and efficient form. When access policies are more complicated, the advantage of using Threshold-gate access trees (e.g. Fig. 5) is becoming more apparent and significant.</p>

    <h2 id="sec-misc-3" class="text-2xl font-bold"><em>D. The Insertion of Access Structure</em></h2>

    <p class="text-gray-300">The LSSS defined in Section II-B is induced from a linear algebra model of computation called <em>Monotone Span Program</em> (MSP), which was introduced by Karchmer and Widgerson [25] for computing</p>

    <p class="text-gray-300">    <img src="_page_13_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 7. The insertion of access structure</p>

    <p class="text-gray-300">access structures. LSSS are in one-to-one correspondence with MSPs [21]. In the following, we review the work of Nikov and Nikova [32] which will later be modified and applied to the construction of our new algorithm.</p>

    <p class="text-gray-300">Definition 3 (The Insertion of Access Structure [32]). <em>Let</em> A<sup>1</sup> <em>and</em> A<sup>2</sup> <em>be two monotone access structures on participant sets</em> P<sup>1</sup> <em>and</em> P2<em>, respectively, and let</em> P<sup>z</sup> &isin; P1<em>. Define &quot;the insertion of</em> A<sup>2</sup> <em>at participant</em> P<sup>z</sup> <em>in</em> A1<em>&quot;, denoted by</em> A1(P<sup>z</sup> &rarr; A2)<em>, as a monotone access structure on the set</em> (P<sup>1</sup> \\ {Pz}) &cup; P<sup>2</sup> <em>such that for</em> G &sube; (P<sup>1</sup> \\ {Pz}) &cup; P<sup>2</sup> <em>we have</em></p>

    <p class="text-gray-300"><span class="math">$G \\in \\mathbb{A}_1(P_z \\to \\mathbb{A}_2) \\iff \\begin{cases} (G \\cap \\mathcal{P}_1 \\in \\mathbb{A}_1), &amp; or \\\\ ((G \\cap \\mathcal{P}_1) \\cup \\{P_z\\} \\in \\mathbb{A}_1 \\text{ and } G \\cap \\mathcal{P}_2 \\in \\mathbb{A}_2). \\end{cases}</span>$</p>

    <p class="text-gray-300"><em>In other words,</em> A1(P<sup>z</sup> &rarr; A2) <em>is the monotone access structure</em> A<sup>1</sup> <em>with participant</em> P<sup>z</sup> <em>&quot;replaced&quot; by the sets of</em> A2<em>.</em></p>

    <p class="text-gray-300">Fig. 7 shows an example of A1(P<sup>1</sup> &rarr; A2), where A<sup>1</sup> is a (2, 3)-threshold policy on {P1, P2, P3} and A<sup>2</sup> is a (3, 4)-threshold policy on {A, B, C, D}. To obtain a Threshold-gate access tree for A1(P<sup>z</sup> &rarr; A2), we simply need to replace the leaf node corresponding to P<sup>z</sup> in the access tree for A<sup>1</sup> with the access tree for A2. In the example illustrated in Fig. 7, such as a hierarchical organization, to satisfy A1, at least two of  <span class="math">\\{P_1, P_2, P_3\\}</span>  have to be present, and the privilege of  <span class="math">P_1</span>  may be distributed to a lower level so that only if at least three out of  <span class="math">\\{A, B, C, D\\}</span>  are present, can they achieve the privilege of  <span class="math">P_1</span> .</p>

    <p class="text-gray-300"><strong>Theorem 1.</strong> [32] Let  <span class="math">\\mathbb{A}_1</span>  and  <span class="math">\\mathbb{A}_2</span>  be monotone access structures defined on participant sets  <span class="math">\\mathcal{P}_1</span>  and  <span class="math">\\mathcal{P}_2</span> , realized by LSSS  <span class="math">(M^{(1)}, \\rho^{(1)})</span>  of size  <span class="math">m_1</span>  and  <span class="math">(M^{(2)}, \\rho^{(2)})</span>  of size  <span class="math">m_2</span> , respectively. Let  <span class="math">P_z \\in \\mathcal{P}_1</span> . There exists an LSSS  <span class="math">(M, \\rho)</span>  of size  <span class="math">m_1 + (m_2 - 1)q</span>  realizing the access structure  <span class="math">\\mathbb{A}_1(P_z \\to \\mathbb{A}_2)</span> , where q is the number of rows labeled by  <span class="math">P_z</span>  in  <span class="math">(M^{(1)}, \\rho^{(1)})</span> .</p>

    <p class="text-gray-300">The construction of LSSS  <span class="math">(M,\\rho)</span>  is given as follows [32]: Let  <span class="math">M^{(1)}=\\begin{pmatrix} M_{P_z}^{(1)} \\\\ \\overline{M}^{(1)} \\end{pmatrix}</span>  and  <span class="math">M^{(2)}=\\begin{pmatrix} \\overrightarrow{u}^{(2)} &amp; \\widetilde{M}^{(2)} \\end{pmatrix}</span>  be  <span class="math">m_1 \\times d_1</span>  and  <span class="math">m_2 \\times d_2</span>  matrices, respectively, where  <span class="math">M_{P_z}^{(1)}</span>  are the q rows labeled by  <span class="math">P_z</span></p>

    <p class="text-gray-300">and  <span class="math">\\vec{u}^{(2)}</span>  is the first column, assuming that the rows of  <span class="math">P_z</span>  are the first rows in  <span class="math">M^{(1)}</span> . Let  <span class="math">M_{P_z}^{(1)} = \\begin{pmatrix} v_1 \\\\ \\vec{v}_2 \\\\ \\vdots \\\\ \\vec{v}_q \\end{pmatrix}</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\vec{u}^{(2)} = \\begin{pmatrix} u_1 \\\\ u_2 \\\\ \\vdots \\\\ u_{m_2} \\end{pmatrix}, \\text{ and define } \\vec{v}_i \\otimes \\vec{u}^{(2)} = \\begin{pmatrix} u_1 \\vec{v}_i \\\\ u_2 \\vec{v}_i \\\\ \\vdots \\\\ u_{m_2} \\vec{v}_i \\end{pmatrix}, \\text{ where } \\vec{v}_i \\ (i=1,\\ldots,q) \\text{ are row vectors in } \\mathbb{Z}_p^{d_1}</span>$</p>

    <p class="text-gray-300">and  <span class="math">u_j \\in \\mathbb{Z}_p</span>   <span class="math">(j = 1, \\dots, m_2)</span> . Note that  <span class="math">\\vec{v_i} \\otimes \\vec{u}^{(2)}</span>  is an  <span class="math">m_2 \\times d_1</span>  matrix. Using  <span class="math">\\mathbf{0}</span>  to denote all-zero</p>

    <p class="text-gray-300"><span class="math">$\\text{matrices, let } M = \\begin{pmatrix} \\vec{v}_1 \\otimes \\vec{u}^{(2)} &amp; \\widetilde{M}^{(2)} &amp; \\mathbf{0} &amp; \\cdots &amp; \\mathbf{0} \\\\ \\vec{v}_2 \\otimes \\vec{u}^{(2)} &amp; \\mathbf{0} &amp; \\widetilde{M}^{(2)} &amp; \\ddots &amp; \\vdots \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\ddots &amp; \\mathbf{0} \\\\ \\vec{v}_q \\otimes \\vec{u}^{(2)} &amp; \\mathbf{0} &amp; \\cdots &amp; \\mathbf{0} &amp; \\widetilde{M}^{(2)} \\\\ \\overline{M}^{(1)} &amp; \\mathbf{0} &amp; \\cdots &amp; \\mathbf{0} &amp; \\mathbf{0} \\end{pmatrix}, \\text{ the rows of } \\begin{pmatrix} \\overline{M}^{(1)} &amp; \\mathbf{0} \\end{pmatrix} \\text{ are labeled as }</span>$</p>

    <p class="text-gray-300">the corresponding rows of  <span class="math">\\overline{M}^{(1)}</span>  in  <span class="math">(M^{(1)}, \\rho^{(1)})</span> . For i=1 to q, the rows of  <span class="math">(v_i \\otimes \\vec{u}^{(2)} \\setminus \\mathbf{0})</span>  are labeled as the corresponding rows of  <span class="math">\\widetilde{M}^{(2)}</span>  in  <span class="math">(M^{(2)}, \\rho^{(2)})</span> . Then M computes the access structure  <span class="math">\\mathbb{A}_1(P_z \\to \\mathbb{A}_2)</span> , and it is an  <span class="math">(m_1 + (m_2 - 1)q) \\times (d_1 + (d_2 - 1)q)</span>  matrix. We refer readers to [32] for the proof.</p>

    <h4 id="sec-misc-4" class="text-lg font-semibold mt-6">III. OUR APPROACH - FROM THRESHOLD-GATE ACCESS TREES TO LSSS MATRICES</h4>

    <p class="text-gray-300">We now describe our method to construct an LSSS matrix from a Threshold-gate access tree. Inspired by Theorem 1, we repeatedly carry out the &quot;insertion&quot; operation on two Threshold access structures,</p>

    <p class="text-gray-300">and our ideas can be outlined as follows: (1) for a single (t, n)-threshold gate, find its LSSS matrix; (2) repeatedly perform the &quot;insertion&quot; of Threshold-gate access trees according to the structure of the input Threshold-gate access tree; and (3) use a formatted string to describe the input Threshold-gate access tree and design an algorithm which can output (M, &rho;) based on the formatted string alone.</p>

    <p class="text-gray-300">Recall that in a Threshold-gate access tree, each leaf node corresponds to an attribute, and each nonleaf node is a threshold gate, described by its children and a threshold value. A Threshold-gate access tree can naturally be described using a recursive-form string as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Without loss of generality, we assume the symbols &quot;(&quot;, &quot;,&quot; and &quot;)&quot; are not in the attribute universe, where &quot;()&quot; will be used to define non-leaf nodes and &quot;,&quot; will work as separator to separate the child nodes of each non-leaf node.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A Threshold-gate access tree A is described by a string that describes its root node. In particular, suppose that the root node is a (t, n)-threshold gate, the access tree can then be described by a string (F1, F2, . . . , Fn, t) where t is the threshold value and F<sup>i</sup> (1 &le; i &le; n) represents the children of the root node.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>F<sup>i</sup> is an attribute corresponding to a leaf node, or a non-leaf node described by its children and a threshold value, i.e. F<sup>i</sup> = (Fi,1, Fi,2, . . . , Fi,n<sup>i</sup> , ti), where Fi,1, Fi,2, . . . , Fi,n<sup>i</sup> represent the n<sup>i</sup> children of F<sup>i</sup> and t<sup>i</sup> is a threshold value with 1 &le; t<sup>i</sup> &le; n<sup>i</sup> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">For example, the access tree in Fig. 5 can be described using a recursive-form string, namely, ((A, B, C, 2), (D, E, F, 2),(G, H,(I, J, K, L, 3), 2), 2), where (A, B, C, 2), (D, E, F, 2) and (G, H,(I, J, K, L, 3), 2) are the three children of the root node. For the node (G, H,(I, J, K, L, 3), 2), the first two children are the leaf nodes corresponding to attributes G and H, respectively, and the third child is a (3, 4)-threshold gate described by (I, J, K, L, 3).</p>

    <p class="text-gray-300">We refer to such a recursive-form string as a <em>threshold-tree-string</em>. Furthermore, given a thresholdtree-string FA, when we say &quot;i th attribute of FA&quot; we mean the i th attribute, indexed from left to right, ignoring the symbols &quot;(&quot;, &quot;)&quot; and &quot;,&quot;. Suppose F<sup>A</sup> = ((A, B, C, 2),(A, D, 1), E, 3), the 1 st , 2 nd , 3 rd , 4 th , 5 th, and 6 th attributes of F<sup>A</sup> are A, B, C, A, D, and E, respectively.</p>

    <h4 id="sec-misc-5" class="text-lg font-semibold mt-6">B. LSSS for Threshold Access Structures</h4>

    <p class="text-gray-300">For a (t, n)-threshold access structure  <span class="math">(P_1, P_2, \\ldots, P_n, t)</span> , we can construct the corresponding LSSS over  <span class="math">\\mathbb{Z}_p</span> , p &gt; n + 1, as</p>

    <p class="text-gray-300"><span class="math">$M = \\begin{pmatrix} 1 &amp; 1 &amp; 1 &amp; \\dots &amp; 1 \\\\ 1 &amp; 2 &amp; 2^2 &amp; \\dots &amp; 2^{t-1} \\\\ 1 &amp; 3 &amp; 3^2 &amp; \\dots &amp; 3^{t-1} \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots \\\\ 1 &amp; n &amp; n^2 &amp; \\dots &amp; n^{t-1} \\end{pmatrix}, \\quad \\rho(i) = P_i \\text{ (for } i = 1, \\dots, n). \\tag{1}</span>$</p>

    <p class="text-gray-300">We can verify that  <span class="math">(M, \\rho)</span>  realizes  <span class="math">(P_1, P_2, \\dots, P_n, t)</span>  as follows. To share a secret  <span class="math">s \\in \\mathbb{Z}_p</span>  in a (t, n)-threshold style, we choose a random vector  <span class="math">\\vec{v} = (s, a_1, \\dots, a_{t-1}) \\in \\mathbb{Z}_p^t</span>  and give the inner product  <span class="math">\\lambda_i = (M_i \\cdot \\vec{v})</span>  to participant  <span class="math">P_i</span> . Consider the polynomial  <span class="math">f(x) = s + a_1x + a_2x^2 + \\dots + a_{t-1}x^{t-1}</span> , we have that  <span class="math">\\lambda_i = f(i)</span> , that is, participant  <span class="math">P_i</span>  has the value f(i). In other words, we are implementing Shamir's secret sharing scheme [33] for a (t, n)-threshold function. According to the security of Shamir's secret sharing scheme, we know that if and only if at least t of  <span class="math">\\{\\lambda_i\\}_{i=1}^n</span>  are known, the secret s can be reconstructed. Note that s is completely determined by the values of s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s are completely</p>

    <h4 id="sec-misc-6" class="text-lg font-semibold mt-6">C. Our Modified Construction for Theorem 1</h4>

    <p class="text-gray-300">In the construction for Theorem 1 (Section II-D), it is assumed that (1) the construction handles all the q rows owned by  <span class="math">P_z</span>  in one &quot;insertion&quot;, and (2) all the q rows of  <span class="math">P_z</span>  are the <em>first</em> rows in  <span class="math">M^{(1)}</span> . As directly using the original construction [32] for Theorem 1 will incur complex codes and additional overhead, for example, which are entailed to finding all the rows owned by  <span class="math">P_z</span>  and arranging them in the first rows of  <span class="math">M^{(1)}</span> , we propose to view and describe the construction in a different way:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let  <span class="math">(M, \\rho)</span>  be an LSSS realizing access structure  <span class="math">\\mathbb{A}</span> , and its size be m. For any  <span class="math">1 \\leq i, j \\leq m</span> , define  <span class="math">(M&#x27;, \\rho&#x27;)</span>  as follows:</li>
    </ol>

    <p class="text-gray-300"><span class="math">$M&#x27;_{i} = M_{j},</span>$
<span class="math">M&#x27;_{j} = M_{i},</span>   <span class="math">M&#x27;_{k} = M_{k} (\\forall k \\neq i, j);</span>   <span class="math">\\rho&#x27;(i) = \\rho(j),</span>   <span class="math">\\rho&#x27;(j) = \\rho(i),</span>   <span class="math">\\rho&#x27;(k) = \\rho(k) (\\forall k \\neq i, j).</span></p>

    <p class="text-gray-300">Obviously  <span class="math">(M&#x27;, \\rho&#x27;)</span>  is also an LSSS realizing  <span class="math">\\mathbb{A}</span> . This implies that when we use the construction for Theorem 1 we do not need to arrange the rows of  <span class="math">P_z</span>  to the first rows of the matrix.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>To design an efficient and easily comprehensible algorithm, it is desirable to handle one row in each &quot;insertion&quot; operation and by repeating the one-row-insertion operation to handle the cases</li>
    </ol>

    <p class="text-gray-300">that  <span class="math">P_z</span>  owns multiple, say q rows. The following example shows that we do not need to handle all the q rows in one &quot;insertion&quot;, instead, we can attain the same construction as the original one for Theorem 1 by repeating the one-row-insertion operation for q times. Without loss of generality, suppose q=2, and  <span class="math">\\vec{v}_1</span>  and  <span class="math">\\vec{v}_2</span>  are labeled by  <span class="math">P_z</span> :</p>

    <p class="text-gray-300"><span class="math">$M^{(1)} = \\begin{pmatrix} \\overline{M}^{(11)} \\\\ \\overrightarrow{v}_1 \\\\ \\overline{M}^{(12)} \\\\ \\overrightarrow{v}_2 \\\\ \\overline{M}^{(13)} \\end{pmatrix} \\xrightarrow{\\substack{row \\ \\overrightarrow{v}_1 \\\\ insertion}} M^{(1)} = \\begin{pmatrix} \\overline{M}^{(11)} &amp; \\mathbf{0} \\\\ \\overrightarrow{v}_1 \\otimes \\overrightarrow{u}^{(2)} &amp; \\widetilde{M}^{(2)} \\\\ \\overline{M}^{(12)} &amp; \\mathbf{0} \\\\ \\overrightarrow{v}_2 &amp; \\overrightarrow{0} \\\\ \\overline{M}^{(13)} &amp; \\mathbf{0} \\end{pmatrix} \\xrightarrow{\\substack{row \\ (\\overrightarrow{v}_2 \\ \\overrightarrow{0}) \\\\ insertion}} \\xrightarrow{insertion}</span>$</p>

    <p class="text-gray-300"><span class="math">$M^{(1)} = \\left( \\begin{array}{cccc} \\overline{M}^{(11)} &amp; \\mathbf{0} &amp; \\mathbf{0} \\\\ \\vec{v}_1 \\otimes \\vec{u}^{(2)} &amp; \\widetilde{M}^{(2)} &amp; \\mathbf{0} \\\\ \\overline{M}^{(12)} &amp; \\mathbf{0} &amp; \\mathbf{0} \\\\ \\vec{v}_2 \\otimes \\vec{u}^{(2)} &amp; \\vec{0} \\otimes \\vec{u}^{(2)} &amp; \\widetilde{M}^{(2)} \\\\ \\overline{M}^{(13)} &amp; \\mathbf{0} &amp; \\mathbf{0} \\end{array} \\right) = \\left( \\begin{array}{cccc} \\overline{M}^{(11)} &amp; \\mathbf{0} &amp; \\mathbf{0} \\\\ \\vec{v}_1 \\otimes \\vec{u}^{(2)} &amp; \\widetilde{M}^{(2)} &amp; \\mathbf{0} \\\\ \\overline{M}^{(12)} &amp; \\mathbf{0} &amp; \\mathbf{0} \\\\ \\vec{v}_2 \\otimes \\vec{u}^{(2)} &amp; \\mathbf{0} &amp; \\widetilde{M}^{(2)} \\\\ \\overline{M}^{(13)} &amp; \\mathbf{0} &amp; \\mathbf{0} \\end{array} \\right).</span>$</p>

    <p class="text-gray-300">Note that handling insertion of multiple rows through repeating one-row-insertion as above is based on the fact that in the expanded columns in each insertion, all elements but those in  <span class="math">\\widetilde{M}^{(2)}</span>  are zero, so that in the next insertion we have  <span class="math">\\vec{0} \\otimes \\vec{u}^{(2)} = \\mathbf{0}</span> .</p>

    <h4 id="sec-misc-7" class="text-lg font-semibold mt-6">IV. THE NEW LSSS GENERATION ALGORITHM</h4>

    <h4 id="sec-misc-8" class="text-lg font-semibold mt-6">A. The Algorithm</h4>

    <p class="text-gray-300">For a Threshold-gate access tree  <span class="math">\\mathbb{A}</span> , taking the corresponding threshold-tree-string  <span class="math">F_{\\mathbb{A}}</span>  as input, using an LSSS as in Equation (1) for each Threshold-gate, we can follow the threshold-tree-string's structure to repeatedly execute the one-row-insertion, and eventually output an LSSS  <span class="math">(M, \\rho)</span>  for  <span class="math">\\mathbb{A}</span> , where  <span class="math">\\rho</span>  is determined by  <span class="math">F_{\\mathbb{A}}</span>  as the i-th row of M is labeled by the i-th attribute of  <span class="math">F_{\\mathbb{A}}</span> . In particular, each node of the access tree is regarded as a participant of a threshold access structure specified by its parent node. Then we start with a (1,1)-threshold LSSS and consider the root node of the tree as its participant. We repeatedly execute the one-row-insertion on the non-leaf nodes of the tree, and will eventually obtain the desirable LSSS. Below is the LSSS generation algorithm with pseudo code given in Algorithm 1.</p>

    <h4 id="sec-misc-9" class="text-lg font-semibold mt-6">Algorithm Description.</h4>

    <p class="text-gray-300">&bull; Input: A threshold-tree-string  <span class="math">F_{\\mathbb{A}}</span>  for a Threshold-gate access tree  <span class="math">\\mathbb{A}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output: A matrix M and a function &rho;, which maps the i th row of M to the i th attribute in FA, (M, &rho;) is the LSSS realizing A.</li>
      <li>Convert(FA): In the following, M is an m &times; d matrix over Zp, and L = (L1, L2, . . . , Lm) a vector with m coordinates, where each coordinate is an attribute or a threshold-tree-string. The i th coordinate of L labels the i th row of M.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let matrix M = (1)1&times;1, vector L = (FA), and m = 1, d = 1.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Repeat the following until all coordinates of L are attributes:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>a) Consider M to be an m &times; d matrix over Zp, and L = (L1, L2, . . . , Lm).</li>
      <li>b) Scan the coordinates of L to find the first coordinate that is a threshold-tree-string rather than an attribute. Suppose the index of this coordinate is z. We have a threshold-tree-string L<sup>z</sup> = F<sup>z</sup> = (Fz,1, Fz,2, . . . , Fz,m<sup>2</sup> , d2). <em>Remark</em>: If such a coordinate does not exist, it means that all the coordinates have been attributes and the algorithm should stop and output the matrix M.</li>
      <li>c) Resolve F<sup>z</sup> to obtain its m<sup>2</sup> children Fz,1, Fz,2, . . . , Fz,m<sup>2</sup> and threshold value d2.</li>
      <li>d) For this (d2, m2)-threshold access structure, construct the corresponding LSSS matrix according to Equation (1), then execute &quot;insertion&quot; of this (d2, m2)-LSSS matrix on the z th row of M to obtain a new M with m &minus; 1 + m<sup>2</sup> rows and d + d<sup>2</sup> &minus; 1 columns. Set L = (L1, L2, . . . , Lz&minus;1, Fz,1, Fz,2, . . . , Fz,m<sup>2</sup> , Lz+1, . . . , Lm), and then set m = m&minus;1+m2, and d = d &minus; 1 + d2.</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Return the matrix M.</li>
    </ol></li>
    </ul></li>
    </ul>

    <p class="text-gray-300">Note that <em>&quot;2.(c) Resolve</em> F<sup>z</sup> <em>to obtain its</em> m<sup>2</sup> <em>children</em> Fz,1, Fz,2, . . . , Fz,m<sup>2</sup> <em>and its threshold value</em> d2<em>&quot;</em> is easy and we do not discuss the detail here.</p>

    <p class="text-gray-300">The algorithm above is simple and efficient with rationale based on the following: (1) each time only <em>one</em> row labeled by a threshold-tree-string is handled; (2) using the construction of (d2, m2)-LSSS from Equation (1) to ensure that the LSSS matrix for A is completely determined by F<sup>A</sup> as the i th row of the resulting M is labeled by the i th attribute in FA; (3) the first column of M2, i.e., ~u(2), is an all-one vector, so that ~v<sup>z</sup> &otimes; ~u(2) can easily be obtained by repeating the row ~v<sup>z</sup> d<sup>2</sup> times; and (4) the elements of <sup>M</sup>f(2) can easily be obtained (the pseudo code, Algorithm 1, Line 29 to 33).</p>

    <h2 id="sec-misc-10" class="text-2xl font-bold"><em>B. Complexity</em></h2>

    <p class="text-gray-300">Regarding the computational complexity of the algorithm, the major cost is on &quot;x &larr; x &lowast; a mod p&quot;, that is, computing a <sup>j</sup> mod p (a = 1, . . . , n; j = 1, . . . , t &minus; 1) for each (t, n)-threshold gate. While most</p>

    <pre><code class="language-text">1: (M[1, 1], L[1], m, d) &larr; (1, FA, 1, 1), z &larr; 1
2: while z 6= 0 do
3: z &larr; 0, i &larr; 1
4: while i &le; m AND z = 0 do
5: if L[i] is a threshold-tree-string then
6: z &larr; i
7: end if
8: i &larr; i + 1
9: end while
10: if z 6= 0 then
11: Fz &larr; L[z]
12: m2 &larr; the number of children of Fz, d2 &larr; the threshold value of Fz
13: L2[i] &larr; the i
                 th children of Fz (i = 1, 2, . . . , m2)
14: (M1, L1, m1, d1) &larr; (M, L, m, d)
15: for i = 1 to z &minus; 1 step 1 do
16: L[i] &larr; L1[i]
17: for j = 1 to d1 step 1 do
18: M[i, j] &larr; M1[i, j]
19: end for
20: for j = d1 + 1 to d1 + d2 &minus; 1 step 1 do
21: M[i, j] &larr; 0
22: end for
23: end for
24: for i = z to z + m2 &minus; 1 step 1 do
25: L[i] &larr; L2[i &minus; z + 1]
26: for j = 1 to d1 step 1 do
27: M[i, j] &larr; M1[z, j]
28: end for
29: a &larr; i &minus; (z &minus; 1), x &larr; i &minus; (z &minus; 1)
30: for j = d1 + 1 to d1 + d2 &minus; 1 step 1 do
31: M[i, j] &larr; x
32: x &larr; x &lowast; a mod p
33: end for
34: end for
35: for i = z + m2 to m1 + m2 &minus; 1 step 1 do
36: L[i] &larr; L1[i &minus; m2 + 1]
37: for j = 1 to d1 step 1 do
38: M[i, j] &larr; M1[i &minus; m2 + 1, j]
39: end for
40: for j = d1 + 1 to d1 + d2 &minus; 1 step 1 do
41: M[i, j] &larr; 0
42: end for
43: end for
44: (m, d) &larr; (m1 + m2 &minus; 1, d1 + d2 &minus; 1)
45: end if
46: end while
</code></pre>

    <p class="text-gray-300">values will be used multiple times, the computation cost can be further reduced by storing the values of  <span class="math">a^j \\mod p</span> .</p>

    <p class="text-gray-300">Taking as input the number of leaf nodes in the Threshold-gate access tree, say n, suppose there are I non-leaf nodes, we can analyze the time complexity of the algorithm (Algorithm 1) as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Line 3 to 45 are executed I times, one time for each non-leaf node. We use k = 1, ..., I to index these executions.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Line 3 to 9 are to find the first threshold-tree-string (if there exists one). Suppose the  <span class="math">z_k</span> -th coordinate of L[] is the first threshold-tree-string.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Line 10 to 45 are to resolve  <span class="math">L[z_k]</span>  to its children and threshold value, and execute the &quot;Insertion&quot; operation. We use  <span class="math">m_{1,k} \\times d_{1,k}</span>  and  <span class="math">m_{2,k} \\times d_{2,k}</span>  to denote the size of corresponding matrices.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">The time complexity for the k-th non-leaf node is</p>

    <p class="text-gray-300"><span class="math">$z_k \\quad \\text{for Line 3 to Line 9} \\\\ + m_{2,k} \\quad \\text{for Line 13} \\\\ + (z_k - 1) \\times (d_{1,k} + d_{2,k} - 1) \\quad \\text{for Line 15 to Line 23} \\\\ + m_{2,k} \\times (d_{1,k} + d_{2,k} - 1) \\quad \\text{for Line 24 to Line 34} \\\\ + (m_{1,k} - z_k) \\times (d_{1,k} + d_{2,k} - 1) \\quad \\text{for Line 35 to Line 43},</span>$</p>

    <p class="text-gray-300">and hence the total complexity of the algorithm is</p>

    <p class="text-gray-300"><span class="math">$T(n) = \\sum_{k=1}^{I} z_k + m_{2,k} + (z_k - 1 + m_{2,k} + m_{1,k} - z_k) \\times (d_{1,k} + d_{2,k} - 1)</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\sum_{k=1}^{I} z_k + \\sum_{k=1}^{I} m_{2,k} + \\sum_{k=1}^{I} (m_{1,k} + m_{2,k} - 1) \\times (d_{1,k} + d_{2,k} - 1)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq \\sum_{k=1}^{I} z_k + \\sum_{k=1}^{I} m_{2,k} + \\sum_{k=1}^{I} (m_{1,k} + m_{2,k}) \\times (d_{1,k} + d_{2,k})</span>$</p>

    <p class="text-gray-300"><span class="math">$(\\text{since } I \\leq n, \\ z_k \\leq n, \\ d_{1,k} \\leq m_{1,k} \\leq n, \\ d_{2,k} \\leq m_{2,k} \\leq n)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq n^2 + n^2 + 2n \\cdot \\sum_{k=1}^{I} (m_{1,k} + m_{2,k})</span>$</p>

    <p class="text-gray-300"><span class="math">$= 2n^2 + 2n \\cdot \\sum_{k=1}^{I} m_{1,k} + 2n \\cdot \\sum_{k=1}^{I} m_{2,k}.</span>$</p>

    <p class="text-gray-300">Note that the value of  <span class="math">\\sum_{k=1}^{I} m_{1,k}</span>  (resp. the value of  <span class="math">\\sum_{k=1}^{I} m_{2,k}</span> ) is the sum of the number of children of all the non-leaf nodes, this is, one less than the number of nodes in the Threshold-gate access tree</p>

    <p class="text-gray-300">(since the root node is not included). In a Threshold-gate access tree, if a non-leaf node has only one child node, the node and its child node can be combined to one node (without changing other parts), that is, any non-leaf node has no less than two children. Thus, a Threshold-gate access tree with n leaf nodes will have at most 2n nodes (since the number of the parent nodes of the leaf nodes is at most  <span class="math">\\frac{n}{2}</span> , the number of the parent nodes of these parent nodes is at most  <span class="math">\\frac{n}{2}</span> , ...). This is also why we have  <span class="math">I \\leq n</span> . Then</p>

    <p class="text-gray-300"><span class="math">$T(n) \\le 2n^2 + 2n \\cdot \\sum_{k=1}^{I} m_{1,k} + 2n \\cdot \\sum_{k=1}^{I} m_{2,k}</span>$
<span class="math">$\\le 2n^2 + 2n \\cdot 2n + 2n \\cdot 2n</span>$
<span class="math">$= 10n^2.</span>$</p>

    <p class="text-gray-300">Hence, the time complexity of Algorithm 1 is  <span class="math">O(n^2)</span> .</p>

    <h4 id="sec-misc-11" class="text-lg font-semibold mt-6">C. An Example</h4>

    <p class="text-gray-300">We now use the access tree shown in Fig. 5 as an example. As there are five Threshold-gates in the access tree, the algorithm will execute &quot;one-row-insertion&quot; for five times. The algorithm takes in the threshold-tree-strings  <span class="math">((A,B,C,2),\\,(D,E,F,2),(G,H,(I,J,K,L,3),2),2)</span>  and works out the LSSS as follows:</p>

    <p class="text-gray-300">follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300"><span class="math">$M = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}, L = \\begin{pmatrix} ((A, B, C, 2), (D, E, F, 2), (G, H, (I, J, K, L, 3), 2), 2) \\end{pmatrix}.</span>$</p></li>
      <li><p class="text-gray-300"><span class="math">M = \\begin{pmatrix} 1 &amp; 1 \\\\ 1 &amp; 2 \\\\ 1 &amp; 3 \\end{pmatrix}, L = \\begin{pmatrix} (A, B, C, 2) \\\\ (D, E, F, 2) \\\\ (G, H, (I, J, K, L, 3), 2) \\end{pmatrix}.</span></p></li>
      <li><p class="text-gray-300"><span class="math">M = \\begin{pmatrix} 1 &amp; 1 &amp; 1 \\\\ 1 &amp; 1 &amp; 2 \\\\ 1 &amp; 1 &amp; 3 \\\\ 1 &amp; 2 &amp; 0 \\\\ 1 &amp; 3 &amp; 0 \\end{pmatrix}, L = \\begin{pmatrix} A \\\\ B \\\\ C \\\\ (D, E, F, 2) \\\\ (G, H, (I, J, K, L, 3), 2) \\end{pmatrix}.</span></p></li>
      <li><p class="text-gray-300"><span class="math">M = \\begin{pmatrix} 1 &amp; 1 &amp; 0 \\\\ 1 &amp; 1 &amp; 0 \\\\ 1 &amp; 2 &amp; 0 &amp; 1 \\\\ 1 &amp; 2 &amp; 0 &amp; 2 \\\\ 1 &amp; 2 &amp; 0 &amp; 3 \\\\ 1 &amp; 3 &amp; 0 &amp; 0 \\end{pmatrix}, L = \\begin{pmatrix} A \\\\ B \\\\ C \\\\ F \\\\ (G, H, (I, J, K, L, 3), 2) \\end{pmatrix}.</span></p></li>
    </ol>

    <p class="text-gray-300"><span class="math">$6) \\ M = \\left( \\begin{array}{c} 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\\\ 1 &amp; 1 &amp; 2 &amp; 0 &amp; 0 \\\\ 1 &amp; 1 &amp; 3 &amp; 0 &amp; 0 \\\\ 1 &amp; 2 &amp; 0 &amp; 1 &amp; 0 \\\\ 1 &amp; 2 &amp; 0 &amp; 2 &amp; 0 \\\\ 1 &amp; 2 &amp; 0 &amp; 3 &amp; 0 \\\\ 1 &amp; 3 &amp; 0 &amp; 0 &amp; 1 \\\\ 1 &amp; 3 &amp; 0 &amp; 0 &amp; 2 \\\\ 1 &amp; 3 &amp; 0 &amp; 0 &amp; 3 \\end{array} \\right), \\ L = \\left( \\begin{array}{c} A \\\\ B \\\\ C \\\\ D \\\\ E \\\\ F \\\\ G \\\\ H \\\\ (I,J,K,L,3) \\end{array} \\right)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\left( \\begin{array}{c} A \\\\ B \\\\ C \\\\ H \\\\ (I,J,K,L,3) \\end{array} \\right)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\left( \\begin{array}{c} A \\\\ B \\\\ C \\\\ D \\\\ D \\\\ E \\\\ C \\\\ D \\\\ D \\\\ E \\\\ F \\\\ G \\\\ H \\\\ I \\\\ J \\\\ K \\\\ L \\\\ I \\end{array} \\right)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\left( \\begin{array}{c} A \\\\ B \\\\ C \\\\ D \\\\ D \\\\ E \\\\ F \\\\ G \\\\ H \\\\ I \\\\ J \\\\ K \\\\ L \\\\ L \\\\ I \\end{array} \\right)</span>$</p>

    <h2 id="sec-misc-12" class="text-2xl font-bold"><em>D. The Application of the New Algorithm in CP-ABE Systems</em></h2>

    <p class="text-gray-300">Algorithm 1 can be used in all the aforementioned provably secure and highly expressive CP-ABE schemes [12]&ndash;[20]. The algorithm can be embedded in the Encrypt and Decrypt algorithms, and the small-size threshold-tree-string can be included in the ciphertext as its policy. In this way, at the cost of running this new converting algorithm in the Decrypt process<sup>4</sup> , we should use the small-size thresholdtree-string (whose size is approximately equal to that of &rho;) to specify ciphertext policies, rather than employing the large LSSS (M, &rho;) directly. Besides, this new algorithm also results in achieving smaller (or the same in the worst case where all the non-leaf nodes of an access tree are AND or OR gates only) ciphertext size when compared with using the Lewko-Waters algorithm.</p>

    <p class="text-gray-300">.</p>

    <p class="text-gray-300"><sup>4</sup>Note that such an algorithm must be run in the Encrypt process of a CP-ABE system in order to generate LSSS matrices, i.e., the <em>additional</em> cost is to run the algorithm in the Decrypt process.</p>

    <p class="text-gray-300">More Efficient Converting Algorithm for the CP-ABE Decryption Process. In the Encrypt process of a CP-ABE system, the LSSS is completely generated using Algorithm 1. While in the Decrypt process, we observe that the LSSS does not need to be completely generated and hence can enhance the efficiency of this new converting algorithm specifically for the Decrypt process. In particular, only the rows labeled by the attributes that the user possesses need to be converted. We modify the algorithm so that it takes an attribute set S as an additional input, and if L<sup>z</sup> does not contain any attribute in S, we remove the z th row of M and the z th coordinate of L. As a result, the algorithm avoids executing unnecessary insertions. The following is the description of the modified algorithm, where the bold parts are different from the original Algorithm 1.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Input: A threshold-tree-string F<sup>A</sup> and an attribute set S.</li>
      <li>Output: A matrix M and a vector L whose coordinates are the attributes in S. The i th row of M is labeled by the i th coordinate of L.</li>
      <li>Convert(FA): In the following, M is an m&times;d matrix over Zp, and L is a vector with m coordinates, where each coordinate is an attribute or a threshold-tree-string. The i th coordinate of L labels the i th row of M.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let matrix M = (1)1&times;1, vector L = (FA), and m = 1, d = 1.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Repeat the following until all coordinates of L are attributes:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>a) Consider M to be an m &times; d matrix over Zp, and L = (L1, L2, . . . , Lm).</li>
      <li>b) Scan the coordinates of L to find the first coordinate that is a threshold-tree-string rather than an attribute. Suppose the index is z. We have a threshold-tree-string L<sup>z</sup> = F<sup>z</sup> = (Fz,1, Fz,2, . . . , Fz,m<sup>2</sup> , d2). If L<sup>z</sup> does not contain any attribute in S, remove the z th row of M and the z th coordinate of L, set m = m &minus; 1, and go to (a).</li>
      <li>c) Resolve F<sup>z</sup> to obtain its m<sup>2</sup> children Fz,1, Fz,2, . . . , Fz,m<sup>2</sup> and its threshold value d2.</li>
      <li>d) For this (d2, m2)-threshold access structures, construct the corresponding LSSS matrix according to Equation (1), then execute &quot;insertion&quot; of this (d2, m2)-LSSS matrix on the z th row of M to obtain a new M with m &minus; 1 + m<sup>2</sup> rows and d &minus; 1 + d<sup>2</sup> columns. Set L = (L1, L2, . . . , Lz&minus;1, Fz,1, Fz,2, . . . , Fz,m<sup>2</sup> , Lz+1, . . . , Lm), and then set m = m&minus;1+m2, and d = d + d<sup>2</sup> &minus; 1.</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Remove the coordinates (i.e. attributes) of L that do not appear in S, and remove the corresponding rows of M, then return the matrix M and vector L.</li>
    </ol></li>
    </ul></li>
    </ul>

    <p class="text-gray-300">This modified algorithm will work well for the Decrypt process because in the one-row-insertion</p>

    <p class="text-gray-300">operation, all elements of the expanded columns, except those in <sup>M</sup>f(2), are zero. For any <sup>F</sup><sup>A</sup> and <sup>S</sup>, suppose that M<sup>0</sup> S is the output of this modified algorithm, and M<sup>S</sup> is the sub-matrix labeled by S from M output by the original converting algorithm, i.e., Algorithm 1, we have that M<sup>0</sup> S can be obtained from M<sup>S</sup> by removing some all-zero columns, so that for any row vector ~&omega; = (&omega;1, . . . , &omega;|S<sup>|</sup> ), ~&omega;M<sup>S</sup> = (1, 0, . . . , 0) if and only if ~&omega;M<sup>0</sup> <sup>S</sup> = (1, 0, . . . , 0).</p>

    <p class="text-gray-300">As an example (use the one in Fig. 5 again), given</p>

    <p class="text-gray-300"><span class="math">$F_{\\mathbb{A}} = ((A, B, C, 2), (D, E, F, 2), (G, H, (I, J, K, L, 3), 2), 2)</span>$</p>

    <p class="text-gray-300">and S = {A, B, G, H}, the modified algorithm works as follows:</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{lll} 1) &amp; M_S&#x27; = \\left(\\begin{array}{c} 1 \\end{array}\\right), \\, L = \\left(\\begin{array}{c} ((A,B,C,2),(D,E,F,2),(G,H,(I,J,K,L,3),2),2) \\end{array}\\right). \\\\ 2) &amp; M_S&#x27; = \\left(\\begin{array}{c} 1 &amp; 1 \\\\ 1 &amp; 2 \\\\ 1 &amp; 3 \\end{array}\\right), \\, L = \\left(\\begin{array}{c} (A,B,C,2) \\\\ (D,E,F,2) \\\\ (G,H,(I,J,K,L,3),2) \\end{array}\\right). \\\\ 3) &amp; M_S&#x27; = \\left(\\begin{array}{c} 1 &amp; 1 &amp; 1 \\\\ 1 &amp; 1 &amp; 2 \\\\ 1 &amp; 1 &amp; 3 \\\\ 1 &amp; 2 &amp; 0 \\\\ 1 &amp; 3 &amp; 0 \\end{array}\\right), \\, L = \\left(\\begin{array}{c} A \\\\ B \\\\ C \\\\ (D,E,F,2) \\\\ (G,H,(I,J,K,L,3),2) \\end{array}\\right). \\\\ 4) &amp; M_S&#x27; = \\left(\\begin{array}{c} 1 &amp; 1 &amp; 1 \\\\ 1 &amp; 1 &amp; 2 \\\\ 1 &amp; 1 &amp; 3 \\\\ 1 &amp; 3 &amp; 0 \\end{array}\\right), \\, L = \\left(\\begin{array}{c} A \\\\ B \\\\ C \\\\ (G,H,(I,J,K,L,3),2) \\end{array}\\right). \\\\ 5) &amp; M_S&#x27; = \\left(\\begin{array}{c} 1 &amp; 1 &amp; 0 \\\\ 1 &amp; 1 &amp; 0 \\\\ 1 &amp; 3 &amp; 0 &amp; 1 \\\\ 1 &amp; 3 &amp; 0 &amp; 2 \\\\ 1 &amp; 3 &amp; 0 &amp; 3 \\\\ 1 &amp; 1 &amp; 1 &amp; 0 \\\\ 1 &amp; 1 &amp; 2 &amp; 0 \\\\ 1 &amp; 1 &amp; 3 &amp; 0 \\\\ 1 &amp; 1 &amp; 1 &amp; 0 \\\\ 1 &amp; 1 &amp; 2 &amp; 0 \\\\ 1 &amp; 1 &amp; 3 &amp; 0 \\\\ 1 &amp; 3 &amp; 0 &amp; 1 \\\\ 1 &amp; 3 &amp; 0 &amp; 2 \\\\ 1 &amp; 3 &amp; 0 &amp; 1 \\\\ 1 &amp; 1 &amp; 0 \\\\ 1 &amp; 3 &amp; 0 &amp; 2 \\\\ 1 &amp; 3 &amp; 0 &amp; 1 \\\\ 1 &amp; 3 &amp; 0 &amp; 2 \\\\ \\end{array}\\right), \\, L = \\left(\\begin{array}{c} A \\\\ B \\\\ C \\\\ G \\\\ H \\\\ (I,J,K,L,3) \\end{array}\\right). \\\\ 6) &amp; M_S&#x27; = \\left(\\begin{array}{c} 1 &amp; 1 &amp; 1 &amp; 0 \\\\ 1 &amp; 1 &amp; 2 &amp; 0 \\\\ 1 &amp; 1 &amp; 3 &amp; 0 \\\\ 1 &amp; 3 &amp; 0 &amp; 1 \\\\ 1 &amp; 3 &amp; 0 &amp; 2 \\\\ \\end{array}\\right), \\, L = \\left(\\begin{array}{c} A \\\\ B \\\\ C \\\\ G \\\\ H \\end{array}\\right). \\\\ 6) &amp; M_S&#x27; = \\left(\\begin{array}{c} 1 &amp; 1 &amp; 3 &amp; 0 \\\\ 1 &amp; 1 &amp; 3 &amp; 0 \\\\ 1 &amp; 1 &amp; 3 &amp; 0 \\\\ 1 &amp; 3 &amp; 0 &amp; 1 \\\\ 1 &amp; 3 &amp; 0 &amp; 2 \\\\ \\end{array}\\right), \\, L = \\left(\\begin{array}{c} C \\\\ G \\\\ H \\\\ C \\\\ G \\\\ H \\end{array}\\right). \\\\ 6) &amp; M_S&#x27; = \\left(\\begin{array}{c} 1 &amp; 1 &amp; 3 &amp; 0 \\\\ 1 &amp; 1 &amp; 3 &amp; 0 \\\\ 1 &amp; 1 &amp; 3 &amp; 0 \\\\ 1 &amp; 3 &amp; 0 &amp; 1 \\\\ 1 &amp; 3 &amp; 0 &amp; 2 \\\\ \\end{array}\\right), \\, L = \\left(\\begin{array}{c} C \\\\ G \\\\ H \\\\ C \\\\ G \\\\ H \\end{array}\\right). \\\\ 6) &amp; M_S&#x27; = \\left(\\begin{array}{c} 1 &amp; 1 &amp; 3 &amp; 0 \\\\ 1 &amp; 1 &amp; 3 &amp; 0 \\\\ 1 &amp; 3 &amp; 0 &amp; 1 \\\\ 1 &amp; 3 &amp; 0 &amp; 2 \\\\ \\end{array}\\right), \\, L = \\left(\\begin{array}{c} C \\\\ G \\\\ G \\\\ H \\end{array}\\right). \\\\ 6) &amp; M_S&#x27; = \\left(\\begin{array}{c} 1 &amp; 1 &amp; 3 &amp; 0 \\\\ 1 &amp; 1 &amp; 3 &amp; 0 \\\\ 1 &amp; 3 &amp; 0 &amp; 1 \\\\ 1 &amp; 3 &amp; 0 &amp; 2 \\\\ \\end{array}\\right), \\, L = \\left(\\begin{array}{c} C \\\\ G \\\\ G \\\\ H \\end{array}\\right). \\\\ \\\\ C \\\\ C \\\\ C \\\\ C \\\\ C \\\\ C \\\\ C \\\\ C \\\\ C</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">$M_S&#x27; = \\begin{pmatrix} 1 &amp; 1 &amp; 1 &amp; 0 \\\\ 1 &amp; 1 &amp; 2 &amp; 0 \\\\ 1 &amp; 3 &amp; 0 &amp; 1 \\\\ 1 &amp; 3 &amp; 0 &amp; 2 \\end{pmatrix}, L = \\begin{pmatrix} A \\\\ B \\\\ G \\\\ H \\end{pmatrix}</span>$</li>
    </ol>

    <p class="text-gray-300">Note that M<sup>S</sup> obtained from the example in Section. IV-C is</p>

    <p class="text-gray-300"><span class="math">$M_S = \\left( \\begin{array}{cccccccc} 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 1 &amp; 1 &amp; 2 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 1 &amp; 3 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\ 1 &amp; 3 &amp; 0 &amp; 0 &amp; 2 &amp; 0 &amp; 0 \\end{array} \\right),</span>$</p>

    <p class="text-gray-300">and M<sup>0</sup> S can be obtained from M<sup>S</sup> by removing the all-zero columns (4 th , 6 th, and 7 th columns).</p>

    <p class="text-gray-300">.</p>

    <p class="text-gray-300">As mentioned in Sec. II-A, fully secure and highly expressive KP-ABE schemes such as [14], [29] use LSSS to specify access policies of private keys, and the private key size is linear in the size of the associated LSSS. Applying this new converting algorithm in the key generation process of these KP-ABE schemes will result in private keys with smaller size than (or at most the same as) applying the Lewko-Waters algorithm.</p>

    <h2 id="sec-misc-13" class="text-2xl font-bold">V. CONCLUSION</h2>

    <p class="text-gray-300">In this paper, we proposed a new algorithm that converts any monotone access structures, in the most general and efficient form (i.e., Threshold-gate access trees, expressed by threshold-tree-strings), to the corresponding LSSS matrices. As Threshold-gate access tree is the most general and efficient form to describe a monotone access structure, for any given monotone access structures, this new algorithm can be applied directly, without requiring any preprocessing, and the size of the resulting LSSS matrix can achieve the best level among currently available work, and can also achieve much better efficiency when compared with the existing work especially for the cases where we have the general (t, n)-threshold gates other than being limited to the special cases of AND and OR gates. For the highly expressive CP-ABE and KP-ABE systems that use LSSS as access policies, using this new converting algorithm can attain smaller ciphertext size for CP-ABE and smaller private key size for KP-ABE. In addition, as the resulting LSSS matrix is completely determined by the threshold-tree-string, for the CP-ABE schemes, we can associate threshold-tree-strings as access policies rather than the LSSS matrices to the ciphertexts, so that we can significantly reduce the overhead incurred by expressing the access policies, from an LSSS</p>

    <p class="text-gray-300">matrix (M, &rho;) over Z<sup>p</sup> to a simple and intuitive threshold-tree-string, whose size is approximately equal to that of &rho;.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">[1] V. Goyal, O. Pandey, A. Sahai, and B. Waters, &quot;Attribute-based encryption for fine-grained access control of encrypted data,&quot; in <em>ACM Conference on Computer and Communications Security</em>. ACM, 2006, pp. 89&ndash;98.</p></li>
      <li><p class="text-gray-300">[2] R. L. Rivest, A. Shamir, and L. M. Adleman, &quot;A method for obtaining digital signatures and public-key cryptosystems,&quot; <em>Commun. ACM</em>, vol. 21, no. 2, pp. 120&ndash;126, 1978.</p></li>
      <li><p class="text-gray-300">[3] T. E. Gamal, &quot;A public key cryptosystem and a signature scheme based on discrete logarithms,&quot; <em>IEEE Transactions on Information Theory</em>, vol. 31, no. 4, pp. 469&ndash;472, 1985.</p></li>
      <li><p class="text-gray-300">[4] R. Cramer and V. Shoup, &quot;A practical public key cryptosystem provably secure against adaptive chosen ciphertext attack,&quot; in <em>CRYPTO</em>, ser. Lecture Notes in Computer Science, vol. 1462. Springer, 1998, pp. 13&ndash;25.</p></li>
      <li><p class="text-gray-300">[5] A. Shamir, &quot;Identity-based cryptosystems and signature schemes,&quot; in <em>CRYPTO</em>, ser. Lecture Notes in Computer Science, vol. 196. Springer, 1984, pp. 47&ndash;53.</p></li>
      <li><p class="text-gray-300">[6] D. Boneh and M. K. Franklin, &quot;Identity-based encryption from the weil pairing,&quot; in <em>CRYPTO</em>, ser. Lecture Notes in Computer Science, vol. 2139. Springer, 2001, pp. 213&ndash;229.</p></li>
      <li><p class="text-gray-300">[7] A. Fiat and M. Naor, &quot;Broadcast encryption,&quot; in <em>CRYPTO</em>, ser. Lecture Notes in Computer Science, vol. 773. Springer, 1993, pp. 480&ndash;491.</p></li>
      <li><p class="text-gray-300">[8] D. Boneh, C. Gentry, and B. Waters, &quot;Collusion resistant broadcast encryption with short ciphertexts and private keys,&quot; in <em>CRYPTO</em>, ser. Lecture Notes in Computer Science, vol. 3621. Springer, 2005, pp. 258&ndash;275.</p></li>
      <li><p class="text-gray-300">[9] J. Bethencourt, A. Sahai, and B. Waters, &quot;Ciphertext-policy attribute-based encryption,&quot; in <em>IEEE Symposium on Security and Privacy</em>. IEEE Computer Society, 2007, pp. 321&ndash;334.</p></li>
      <li><p class="text-gray-300">[10] L. Cheung and C. C. Newport, &quot;Provably secure ciphertext policy ABE,&quot; in <em>ACM Conference on Computer and Communications Security</em>. ACM, 2007, pp. 456&ndash;465.</p></li>
      <li><p class="text-gray-300">[11] V. Goyal, A. Jain, O. Pandey, and A. Sahai, &quot;Bounded ciphertext policy attribute based encryption,&quot; in <em>ICALP (2)</em>, ser. Lecture Notes in Computer Science, vol. 5126. Springer, 2008, pp. 579&ndash;591.</p></li>
      <li><p class="text-gray-300">[12] B. Waters, &quot;Ciphertext-policy attribute-based encryption: An expressive, efficient, and provably secure realization,&quot; in <em>Public Key Cryptography</em>, ser. Lecture Notes in Computer Science, vol. 6571. Springer, 2011, pp. 53&ndash;70.</p></li>
      <li><p class="text-gray-300">[13] A. B. Lewko, T. Okamoto, A. Sahai, K. Takashima, and B. Waters, &quot;Fully secure functional encryption: Attribute-based encryption and (hierarchical) inner product encryption,&quot; in <em>EUROCRYPT</em>, ser. Lecture Notes in Computer Science, vol. 6110. Springer, 2010, pp. 62&ndash;91.</p></li>
      <li><p class="text-gray-300">[14] T. Okamoto and K. Takashima, &quot;Fully secure functional encryption with general relations from the decisional linear assumption,&quot; in <em>CRYPTO</em>, ser. Lecture Notes in Computer Science, vol. 6223. Springer, 2010, pp. 191&ndash;208.</p></li>
      <li><p class="text-gray-300">[15] A. B. Lewko and B. Waters, &quot;Decentralizing attribute-based encryption,&quot; in <em>EUROCRYPT</em>, ser. Lecture Notes in Computer Science, vol. 6632. Springer, 2011, pp. 568&ndash;588.</p></li>
      <li><p class="text-gray-300">[16] Z. Liu, Z. Cao, Q. Huang, D. S. Wong, and T. H. Yuen, &quot;Fully secure multi-authority ciphertext-policy attribute-based encryption without random oracles,&quot; in <em>ESORICS</em>, ser. Lecture Notes in Computer Science, vol. 6879. Springer, 2011, pp. 278&ndash;297.</p></li>
      <li><p class="text-gray-300">[17] A. B. Lewko and B. Waters, &quot;New proof methods for attribute-based encryption: Achieving full security through selective techniques,&quot; in <em>CRYPTO</em>, ser. Lecture Notes in Computer Science, vol. 7417. Springer, 2012, pp. 180&ndash;198.</p></li>
      <li><p class="text-gray-300">[18] Z. Liu, Z. Cao, and D. S. Wong, &quot;White-box traceable ciphertext-policy attribute-based encryption supporting any monotone access structures,&quot; <em>IEEE Transactions on Information Forensics and Security</em>, vol. 8, no. 1, pp. 76&ndash;88, 2013.</p></li>
      <li><p class="text-gray-300">[19] Y. Rouselakis and B. Waters, &quot;Practical constructions and new proof methods for large universe attribute-based encryption,&quot; in <em>ACM Conference on Computer and Communications Security</em>. ACM, 2013, pp. 463&ndash;474.</p></li>
      <li><p class="text-gray-300">[20] Z. Liu, Z. Cao, and D. S. Wong, &quot;Blackbox traceable CP-ABE: how to catch people leaking their keys by selling decryption devices on ebay,&quot; in <em>ACM Conference on Computer and Communications Security</em>. ACM, 2013, pp. 475&ndash;486.</p></li>
      <li><p class="text-gray-300">[21] A. Beimel, &quot;Secure schemes for secret sharing and key distribution,&quot; Ph.D. dissertation, Israel Institute of Technology, Technion, Haifa, Israel, 1996.</p></li>
      <li><p class="text-gray-300">[22] J. C. Benaloh and J. Leichter, &quot;Generalized secret sharing and monotone functions,&quot; in <em>CRYPTO</em>, ser. Lecture Notes in Computer Science, vol. 403. Springer, 1988, pp. 27&ndash;35.</p></li>
      <li><p class="text-gray-300">[23] A. B. Lewko and B. Waters, &quot;Decentralizing attribute-based encryption,&quot; IACR Cryptology ePrint Archive, Tech. Rep. 351, 2010.</p></li>
      <li><p class="text-gray-300">[24] I. Wegener, <em>The complexity of Boolean functions</em>. Wiley-Teubner, 1987.</p></li>
      <li><p class="text-gray-300">[25] M. Karchmer and A. Wigderson, &quot;On span programs,&quot; in <em>Structure in Complexity Theory Conference</em>, 1993, pp. 102&ndash;111.</p></li>
      <li><p class="text-gray-300">[26] C. Zhang, K.-Y. Lam, and S. Jajodia, &quot;Scalable threshold closure,&quot; <em>Theor. Comput. Sci.</em>, vol. 226, no. 1-2, pp. 185&ndash;206, 1999.</p></li>
      <li><p class="text-gray-300">[27] A. Sahai and B. Waters, &quot;Fuzzy identity-based encryption,&quot; in <em>EUROCRYPT</em>, ser. Lecture Notes in Computer Science, vol. 3494. Springer, 2005, pp. 457&ndash;473.</p></li>
      <li><p class="text-gray-300">[28] R. Ostrovsky, A. Sahai, and B. Waters, &quot;Attribute-based encryption with non-monotonic access structures,&quot; in <em>ACM Conference on Computer and Communications Security</em>. ACM, 2007, pp. 195&ndash;203.</p></li>
      <li><p class="text-gray-300">[29] A. B. Lewko, T. Okamoto, A. Sahai, K. Takashima, and B. Waters, &quot;Fully secure functional encryption: Attribute-based encryption and (hierarchical) inner product encryption,&quot; IACR Cryptology ePrint Archive, Tech. Rep. 110, 2010.</p></li>
      <li><p class="text-gray-300">[30] N. Attrapadung, B. Libert, and E. de Panafieu, &quot;Expressive key-policy attribute-based encryption with constant-size ciphertexts,&quot; in <em>Public Key Cryptography</em>, ser. Lecture Notes in Computer Science, vol. 6571. Springer, 2011, pp. 90&ndash;108.</p></li>
      <li><p class="text-gray-300">[31] R. Longo, C. Marcolla, and M. Sala, &quot;Key-policy multi-authority attribute-based encryption,&quot; in <em>Algebraic Informatics</em>, ser. Lecture Notes in Computer Science, vol. 9270. Springer, 2015, pp. 152&ndash;164.</p></li>
      <li><p class="text-gray-300">[32] V. Nikov and S. Nikova, &quot;New monotone span programs from old,&quot; IACR Cryptology ePrint Archive, Tech. Rep. 282, 2004.</p></li>
      <li><p class="text-gray-300">[33] A. Shamir, &quot;How to share a secret,&quot; <em>Commun. ACM</em>, vol. 22, no. 11, pp. 612&ndash;613, 1979.</p></li>
    </ul>

`;
---

<BaseLayout title="Efficient Generation of Linear Secret Sharing Scheme Matrice... (2010/374)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2010 &middot; eprint 2010/374
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="efficient-generation-of-linear-secret-sharing-scheme-2010" />
  </article>
</BaseLayout>
