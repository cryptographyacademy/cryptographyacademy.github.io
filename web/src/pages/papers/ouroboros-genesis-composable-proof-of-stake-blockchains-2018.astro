---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2018/378';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Ouroboros Genesis: Composable Proof-of-Stake Blockchains with Dynamic Availability';
const AUTHORS_HTML = 'Christian Badertscher, Peter Gazi, Aggelos Kiayias, Alexander Russell, Vassilis Zikas';

const CONTENT = `    <p class="text-gray-300">February 22, 2019</p>

    <p class="text-gray-300">Christian Badertscher<em>, Peter Gaži<strong>, Aggelos Kiayias</strong></em>, Alexander Russell†, and Vassilis Zikas‡</p>

    <p class="text-gray-300">Abstract. Proof-of-stake-based (in short, PoS-based) blockchains aim to overcome scalability, efficiency, and composability limitations of the proof-of-work paradigm, which underlies the security of several mainstream cryptocurrencies including Bitcoin.</p>

    <p class="text-gray-300">Our work puts forth the first (global universally) composable (GUC) treatment of PoS-based blockchains in a setting that captures—for the first time in GUC—arbitrary numbers of parties that may not be fully operational, e.g., due to network problems, reboots, or updates of their OS that affect all or just some of their local resources including their network interface and clock. This setting, which we refer to as dynamic availability, naturally captures decentralized environments within which real-world deployed blockchain protocols are assumed to operate.</p>

    <p class="text-gray-300">We observe that none of the existing PoS-based blockchain protocols can realize the ledger functionality under dynamic availability in the same way that Bitcoin does (using only the information available in the genesis block). To address this we propose a new PoS-based protocol, “Ouroboros Genesis”, that adapts one of the latest cryptographically-secure PoS-based blockchain protocols with a novel chain selection rule. The rule enables new or offline parties to safely (re-)join and bootstrap their blockchain only from a trusted copy of the genesis block without any additional advice—such as checkpoints—or assumptions regarding past availability. We say that such a blockchain protocol can “bootstrap from genesis.”</p>

    <p class="text-gray-300">We prove the GUC security of Ouroboros Genesis against a fully adaptive adversary controlling less than half of the total stake. Our model allows adversarial scheduling of messages in a network with delays and captures the dynamic availability of participants in the worst case. Importantly, our protocol is effectively independent of both the maximum network delay and the minimum level of availability—both of which are run-time parameters. Proving the security of our construction against an adaptive adversary requires a novel martingale technique that may be of independent interest in the analysis of blockchain protocols.</p>

    <p class="text-gray-300">The primary real-world use of blockchains, thus far, has been to offer a platform for decentralized cryptocurrencies with various capabilities [26, 5]. A unique feature of blockchain protocols (in contrast to standard multiparty computation) from which the setting draws much of its appeal is the fact that the parties that run the protocol may engage only in passing with the protocol and need not identify themselves to other protocol participants. In fact, the Bitcoin blockchain protocol remains robust in the presence of a Byzantine adversary even if parties arbitrarily desynchronize, join at any moment of the execution, or go offline for arbitrary periods of time (a set of execution features that we will refer to as dynamic availability), as long as a majority of hashing power is always following the protocol.</p>

    <p class="text-gray-300">Motivated by this novel setting, several applications have recently emerged that use blockchains (or the cryptocurrencies that build on top of them) as enablers for other cryptographic protocols. For example, a</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>University of Edinburgh and IOHK, christian.badertscher@ed.ac.uk. Work done while at ETH Zurich.</li>

    </ul>

    <p class="text-gray-300"><strong> IOHK, peter.gazi@iohk.io. </strong> University of Edinburgh and IOHK. akiayias@inf.ed.ac.uk. Research partly supported by EU Project No. 780477, PRIVILEDGE. † University of Connecticut and IOHK. acr@cse.uconn.edu. This material is based upon work supported by the National Science Foundation under Grant No. 1717432. ‡ University of Edinburgh and IOHK. vassilis.zikas@ed.ac.uk.</p>

    <p class="text-gray-300">number of recent work <em>[2, 4, 24, 23, 1]</em> describe how blockchain-based cryptocurrencies can be used to obtain a natural notion of fairness in multi-party computation against dishonest majorities; or to allow parties to play games of chance—e.g., card games like poker, lottery-based games, etc.—without the need of a trusted third party; or how to use blockchains as bulletin boards in electronic voting. Such developments—in conjunction with the direct applicability to cryptocurrencies—have led to a pressing need for a general, formal security analysis of the functionality that blockchain protocols provide.</p>

    <p class="text-gray-300">Recently, Badertscher et al. <em>[3]</em> put forth the first composable analysis of Bitcoin, by proving that it implements, in a universally composable (UC) manner, an immutable transaction ledger. This improved on previous works <em>[17, 27]</em> that provided a game-based security analyses and rigorously described an ideal ledger that provides an answer to the question: What is the goal that Bitcoin aims to achieve? The advantage of such a UC treatment of blockchains is that it allows for a modular design and security analysis of the above cryptographic applications of blockchains.</p>

    <p class="text-gray-300">Notwithstanding, the wide adoption of Bitcoin has revealed some serious efficiency and (in)composability issues. The efficiency issues stem from the fact that it relies on <em>proof-of-work</em> (in short, <em>PoW</em>), a cryptographic puzzle-solving procedure with increasing difficulty as more parties join the system. Composability issues are due to the fact that the puzzle-solving procedure can, in principle, be useful also for other protocols—independent from the Bitcoin mining process. This means that one cannot exclude the possibility that an adversarial miner, participating in such an independent protocol <span class="math">\\pi</span> and in Bitcoin in parallel, can potentially double the value of his effort, by using the same hash query both for <span class="math">\\pi</span> and for Bitcoin.</p>

    <p class="text-gray-300">The demand for blockchain solutions that do not suffer from the above issues gave rise to an exciting recent line of work that propose to use alternative resources to achieve consensus and maintain a robust ledger. The most popular such resource is <em>stake</em> in the system. Informally, instead of requiring a party to invest computing power in order to be allowed to extend the blockchain, parties are given the chance to do so according to their <em>stake</em> in the system, e.g., the number of coins they own. This paradigm, often referred to as <em>proof-of-stake</em> (in short <em>PoS</em>), has yielded a number of proposals for PoS-based blockchains.</p>

    <p class="text-gray-300">Several of these PoS-based proposals originated from the cryptographic community, e.g., Algorand <em>[19]</em>, Snow White <em>[13]</em>, and Ouroboros/Ouroboros Praos <em>[22, 14]</em>. As such they are accompanied by a formal security proof that they achieve a well defined set of desirable properties. Alas, these protocols severely restrict the dynamic availability of participants: Snow White <em>[13]</em> and Ouroboros/Ouroboros Praos <em>[22, 14]</em> require an honest blockchain to be delivered as trusted “advice” to any joining party—a form of “checkpointing”, while Algorand <em>[19]</em> requires the explicit knowledge of a good estimate of the number of offline parties. Furthermore, all these works focus on a property-based specification of the provided security guarantees, i.e., they prove that they achieve a desirable set of properties. Such property-based definitions are known not to ensure, in general, the composability of the proposed schemes <em>[8, 10, 20]</em>.</p>

    <p class="text-gray-300">This leaves the following questions open:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Can PoS offer the same level of dynamic availability guarantees as PoW? In particular, joining without checkpointing advice or the knowledge of other parties’ online/offline status?</li>

      <li>What is the ideal functionality implemented by PoS-based blockchains? How does it compare to the one implemented by PoW?</li>

      <li>Does PoS suffer from the same incomposability issues as PoW?</li>

    </ul>

    <p class="text-gray-300">Our work addresses all the above questions. We put forth the first UC treatment of PoS-based blockchains. Our model captures for the first time dynamic availability and provides a fine-grained classification of failures that determine all different settings that an honest protocol participant may find itself in during the protocol</p>

    <p class="text-gray-300">execution. Given that none of the existing PoS protocols provide such strong guarantees, we describe and analyze a new protocol based on Ouroboros Praos <em>[14]</em>. The major structural change towards our new protocol, which we call Ouroboros Genesis, is a novel chain selection rule that enables joining parties to “bootstrap” only from a trusted copy of the genesis block. We prove that the protocol UC-securely implements the natural ledger functionality proposed in <em>[3]</em>—the very same functionality shown to be possessed by Bitcoin. We prove security in the setting of dynamic availability under the assumption of standard cryptographic primitives, an initialization functionality that is akin to public-key registration and a global random oracle which is a natural abstraction of deterministic hash functions. Our contributions are discussed in more detail below.</p>

    <p class="text-gray-300">Our Contributions. Our work provides a Universally Composable (UC) <em>[8]</em> treatment of proof-of-stake-based blockchains. To obtain a tight abstraction of the real-world setting and stronger composability guarantees, our treatment is in the UC model with <em>global setups</em>, a.k.a. GUC <em>[9]</em>; note that all our statements trivially apply also to the standard UC model by considering global setups as ideal UC functionalities.</p>

    <p class="text-gray-300">Dynamic Availability. Our first contribution is capturing in an accurate manner the guarantees that any such protocol can give to freshly joining parties and/or parties with temporary connectivity/availability issues, a setting that we call dynamic availability. More concretely, our model distinguishes several classes of honest parties, based on:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>whether the party has access to all three resources it needs (i.e., is registered with the respective functionalities): the random oracle, the clock, and the network (see Fig. 1 for the detailed enumeration of these classes);</li>

      <li>whether the party has been able to follow the protocol in such a state for sufficiently long to be guaranteed to hold a synchronized view of the ledger (we call such parties <em>synchronized</em>). More specifically, we will describe a parameter called Delay (a function of the network delay <span class="math">\\Delta</span>) that determines the time sufficient for a party with access to all resources to become fully synchronized with the state of the protocol. We stress that Delay is a parameter that is unknown to the protocol participants, thus it is impossible for a party to determine whether it is already synchronized.</li>

    </ul>

    <p class="text-gray-300">This detailed classification allows us to precisely capture the following derived party classes that will be essential for describing the security guarantees provided by our protocol:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Alert parties</em> are parties that have access to all the required resources, and are also synchronized. These parties enjoy full security guarantees and we will require a lower bound on their number (see below) to ensure security.</li>

      <li><em>Potentially active parties</em> (or <em>active</em> for short) are all parties that, broadly speaking, might potentially act in the current time slot of the protocol execution. This includes honest parties that have access to all the required resources as well as adversarial parties. Note that honest parties who lose access to clock are also potentially active, as they are not able to reliably evolve their private state, and hence it cannot be excluded that if they later get corrupted, they might act retroactively.</li>

      <li><em>Inactive Parties</em> are all other parties, such as honest parties that cannot access some of the necessary resources to engage with the protocol, e.g., their network connection. Per protocol rules, such parties abstain from active participation until that access is regained.</li>

    </ul>

    <p class="text-gray-300">Our objective is to realize the ledger functionality given the following two conditions:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>The ratio <span class="math">\\alpha</span> of the number of alert over the active parties is above <span class="math">1/2</span>; the difference is by a constant that is sufficiently large to absorb the partial synchrony delay parameter <span class="math">\\Delta</span>.</em></li>

    </ol>

    <p class="text-gray-300">In particular (and similar to the Bitcoin blockchain, see <em>[17, 27]</em>) the protocol will use a parameter <span class="math">f</span> and will permit a meaningful security guarantee provided that a suitable relation between <span class="math">f</span> and <span class="math">\\Delta</span> is satisfied. For a fixed choice of <span class="math">f</span>, the larger the delay <span class="math">\\Delta</span> is, the larger the difference between <span class="math">1/2</span> and the alert over active ratio should be. Note that this condition is simply a translation of the standard honest-majority assumption into our dynamic-availability setting.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The ratio <span class="math">\\beta</span> of the number of active over all parties is bounded from <span class="math">0</span> by some arbitrary constant that is unknown to the protocol participants.</li>

    </ul>

    <p class="text-gray-300">This necessary assumption provides an upper bound on the probability that no party will be able to act in the protocol at a given time (if it fails the protocol may halt).</p>

    <p class="text-gray-300">It is instructive to consider what role various party classes play in the above assumptions. In particular, let us stress that the stake of inactive parties, such as those that have lost (or given up) their network connection or their access to the random oracle, does not count as adversarial; in other words, they do not affect the ratio considered in Assumption (A) above.</p>

    <p class="text-gray-300">The above guarantees (and the corresponding assumptions) are arguably natural. However, none of the existing PoS protocols provides them without additional assumptions and/or restrictions to the adversary’s capabilities. Concretely, existing solutions and proposals <em>[22, 13, 14, 6]</em> either forfeit dynamic availability and assume honest parties are regularly online or rely on an assumption that joining (or resuming) parties are implicitly given access to a checkpointing functionality, which serves them a trusted recent honest chain and is supposed to be implemented either “for-free” by the environment or by some fortuitous network connection to existing honest parties. This solves the problem of joining parties getting up to speed with the correct chain—which is the main challenge here–but is arguably a strong assumption. To see this, note that given such a functionality parties only need to deregister and register in order to obtain eventual consensus, which completely trivializes the main goal of a blockchain protocol. One can attempt to avoid such trivialization by restricting the interval between deregistration and reregistration, or even forbidding it, but this makes the assumption somewhat artificial and excludes natural scenarios from the analysis, such as short-term unavailability (e.g. due to a system crash, network outage, maintenance, or update restart). We also note that even with the assumption of such an additional checkpointing functionality, there is no existing PoS solution which can tolerate both the optimal threshold of adversarial stake ratio approaching <span class="math">1/2</span>, and full adaptivity in corruptions and in the (re-)joining schedule, i.e., (re-)registration/deregistration.</p>

    <p class="text-gray-300">Note that the PoS protocol Algorand <em>[19]</em> does not require such checkpointing or parties being regularly online, however it requires a good estimate on participation to be fixed in the protocol, thus forfeiting dynamic availability as well. This requirement stems from the fact that the core of the protocol runs a Byzantine agreement sub-protocol that requires to be able to know (bounds on) the level of expected participation and hence estimate in advance the number of messages that are required to proceed with key protocol decisions.</p>

    <p class="text-gray-300">A PoS Blockchain with Bootstrapping from Genesis. Given the deficiencies of existing protocols to handle dynamic availability we present a new protocol, Ouroboros Genesis, that is based on a recent PoS protocol, Ouroboros Praos <em>[14]</em>. The novelty of our protocol lies in its chain selection rule that instantiates the so-called maxvalid procedure in <em>[17, 22, 3, 14]</em> in a way that allows the parties to identify a chain whose prefix has been part of the prefix of a recent honest chain, using only knowledge of the genesis block. For this reason we refer to this process as bootstrapping from genesis.</p>

    <p class="text-gray-300">Concretely, we prove that Ouroboros Genesis (G)UC-securely realizes the ledger functionality in the dynamic-availability setting, as long as the two essential conditions (A) and (B) introduced above are satisfied. Towards this goal, we develop a new technique which non-trivially extends the martingale argument from <em>[29]</em> so that we can use it to analyze an adaptive adversary in the presence of a worst-case (adversarial) joining-schedule. This technique is of independent interest, as it might prove useful for analyzing other PoS-based blockchains. Overall our security proof maintains the same cryptographic assumptions as <em>[14]</em>.</p>

    <p class="text-gray-300">Global UC formalisation. As a technical contribution, along the way we also provide a full specification of the real-world resources needed for PoS as ideal functionalities and global setups in GUC. Concretely, following the paradigm of <em>[3]</em>, we capture protocols in the (semi-) synchronous model as (G)UC protocols with access to a global clock functionality, and to a network with eventual (bounded) delivery. A delicate deviation from <em>[3]</em>, which also formally demonstrates the stronger composability guarantees that PoS offers, is with respect to how we abstract the calls to the hash function. Concretely, we assume the protocol participants have access to a global random oracle setup (in short, GRO). This captures the abstraction of hash functions as publicly available random functions. This should be contrasted to their abstraction as a UC functionality proposed in <em>[3]</em>, which is less composable. Intuitively, a (deterministic) hash function can be queried by any party, whereas a UC random-oracle functionality is available only to its calling protocol <span class="math">\\pi</span>; this implicitly</p>

    <p class="text-gray-300">restricts access to this functionality (and therefore the hash function it is supposed to abstract) on the specific protocol <span class="math">\\pi</span>.</p>

    <p class="text-gray-300">In fact, a closer consideration of the idiosyncrasies of PoWs reveals that abstracting hash-queries as calls to a GRO is not an option for PoW-based blockchains. This is true because of two issues: (1) at an intuitive level this would imply that the environment (i.e., other protocols) could make queries to the GRO and then share them with the adversary, which, as discussed above, gives “free” out-of-band computing resources to the adversary; (2) at the more technical level, the non-programmability of the GRO allows the environment to check that the simulator creates blocks that indeed carry sufficient work; but since the simulator needs to also simulate the hash queries of honest parties, this would only be feasible if he had a much larger query-budget than the adversary, which is not possible as the GRO needs to behave identically in the real and ideal world. We note in passing that in <em>[11]</em> a version of the GRO was proposed that reduces the power of the environment to check on the simulator; this GRO—which is arguably not the most realistic abstraction of hash functions—would still not work for PoWs because of the first issue. Demonstrating that PoS-based schemes can be proved in a model where hash functions are abstracted as GROs (which is not the case for the PoW setting) sheds light on the comparison between PoW and PoS.</p>

    <p class="text-gray-300">Our results and analysis thus categorically address the three questions posed above: Ouroboros Genesis can realise the same ledger functionality as Bitcoin, <span class="math">\\mathcal{G}_{\\textsc{ledger}}</span> <em>[3]</em>, in a setting with dynamic availability using standard cryptographic assumptions. In particular, the realization proof is carried out in a model where hash-functions are abstracted as global random oracles which shows that the consensus step does not suffer from the composability issues of PoW protocols. We note that providing explicit realizations of all the hybrid functionalities in the GRO model is beyond the scope of the current paper. Nevertheless, we observe that PoS protocols can effectively drop-in replace PoW based ones with the only added requirement being the initialization functionality that should provide a key registration service as opposed to merely a common random string.</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">Related Work.</h4>

    <p class="text-gray-300">A number of recent works have studied—in a rigorous cryptographic manner—the security of existing and newly proposed blockchain protocols both PoW-based, e.g, <em>[17, 27, 3]</em> and PoS-based, e.g., <em>[22, 14, 28, 13, 19]</em>. In the PoW-based setting, <em>[3]</em> describes and proves the composable security guarantees of the most representative protocol, namely Bitcoin; furthermore, the security proof tolerates an adaptive adversary and achieves optimal resilience—the adversary can control any percentage less than 50% of the network’s total computing power. In contrast, in the PoS-based setting, no simulation-based (UC) proof existed, and different proposed schemes tolerate different types of adversaries in terms of adaptivity. For example, Ouroboros <em>[22]</em> achieves only “semi-adaptive” security (corruptions with delay), whereas among the adaptively secure ones, Algorand <em>[19]</em> needs less than 1/3 of the stake of the system to be held by malicious parties, whereas Show White <em>[13]</em> and Ouroboros Praos <em>[14]</em> achieve the optimal 1/2 bound, at the cost of needing a checkpointing functionality to accommodate joining parties.</p>

    <p class="text-gray-300">The idea of parties that are muted for some time but do receive their messages was first proposed in <em>[28]</em> where those parties were referred to as sleepers. Our modeling of such parties differs from (and in fact strictly generalizes) that of <em>[28]</em> in various ways: first, instead of describing them by means of whether they are paused or not, we characterize them by means of the availability of their resources, making clear how those parties enter this state. Furthermore, our notion is only affecting the PoS session that is being executed and thus, in our composable setting, such parties are not restricted as to how they should behave within other protocols that they concurrently participate in. To emphasize this distinction and the fact that they may be continuing to operate in other protocol sessions we use the term ”stalled” for these parties (cf. Fig. 1). In addition to the modeling distinctions, our model allows us to obtain more general statements regarding the adaptivity of the adversary. Concretely, we can tolerate fully adaptive adversaries and worst-case registration/deregistration scheduling. In contrast, <em>[13]</em> tolerates semi-adaptive adversaries, whose corruption only takes effect after a certain number of rounds. Interestingly, there is no need for distinguishing a class of parties called deep</p>

    <p class="text-gray-300">sleepers in <em>[13]</em> (i.e., those that are in sleepy mode for a prolonged time) that required checkpointing via a safe initialisation string and thus the related impossibility result in <em>[13]</em> can be circumvented. Taking advantage our bootstrapping from genesis chain selection rule, all parties that are stalling, even for prolonged periods of time, can safely resynchronize without the assistance of a trusted initialisation exactly as in the case of PoW-based protocols.</p>

    <p class="text-gray-300">Outline of the remainder of the paper. In Section 2 we provide a formal description of our model of computation, including our real and ideal world functionalities and setups. In Section 3 we describe Ouroboros Genesis as a (G)UC protocol called Ouroboros-Genesis. The security analysis of the protocol, i.e., the proof that it UC-securely realizes the ledger functionality is given in Section 4. The proof starts by considering the interaction of the old chain selection procedure from <em>[14]</em> (called maxvalid-mc here, the protocol using it is dubbed Ouroboros-Praos) with honest parties assumed to be connected to the network and synchronized (Section 4.2), gradually incorporates the new maxvalid-bg procedure which allows the protocol to bootstrap from the genesis block (Section 4.3), along with proofs that this procedure is sufficient to provide all the guarantees offered to newly joining and temporarily offline parties (Section 4.4). Finally, there results are transformed into the full UC statement in Section 4.5.</p>

    <h2 id="sec-4" class="text-2xl font-bold">2 The Model</h2>

    <p class="text-gray-300">This section includes the main components of the computation model including the real and ideal functionalities used in this work. We assume the reader has some familiarity with the universal composition (UC) framework <em>[8]</em>. In addition to the new functionalities, we make use of the number of already existing functionalities from the literature. For completeness we nonetheless include these functionalities in Section A of the supplementary material.</p>

    <p class="text-gray-300">UC defines security via the simulation paradigm: the protocol execution in the real world is compared to an ideal execution, where the parties have access to an ideal functionality <span class="math">\\mathcal{F}</span> which abstracts the goals of the protocol. In the ideal world honest parties act as simply relayers between their environment <span class="math">\\mathcal{Z}</span> and the functionality <span class="math">\\mathcal{F}</span> (i.e., they run the so called dummy protocol <em>[8]</em>). Informally, security requires that the attack of any adversary against the (real-world) protocol can be simulated in the ideal world. More concretely, for any real-world adversary <span class="math">\\mathcal{A}</span> there should exists an ideal-world simulator <span class="math">\\mathcal{S}</span> that corrupts the same parties as <span class="math">\\mathcal{A}</span> and makes the ideal-world execution indistinguishable from the real-world in the eyes of any environment <span class="math">\\mathcal{Z}</span>.</p>

    <p class="text-gray-300">Importantly, the (real-world) protocol might be given access to some functionalities (often called hybrids), which capture the resources that the parties have available, e.g., their communication network. In standard UC, these resources appear only in the real-world—in fact they are formally treated as part of the protocol—whereas GUC <em>[9]</em> allows such resources to be preserved in the ideal world and as such be accessible directly by the environment (instead of their interface being filtered by the protocol.) To avoid confusion with standard UC functionalities, the GUC resources of the above type as often referred to as (global) setups. They capture, among others, settings where different protocols might share a common state, and allow to address deniability issues that the original UC framework has <em>[9]</em>. Furthermore, the fact that they do not disappear in the ideal world makes global setups more suitable for capturing universally accessible resources such as deterministic hash functions as discussed in the introduction.</p>

    <p class="text-gray-300">In the following, we describe the real-world resources that are needed in Ouroboros Genesis, along with the ideal world functionality that the protocol implements. Before doing so, we discuss some common conventions that we will use in the descriptions.</p>

    <p class="text-gray-300">Dynamically available party sets. A significant extension in the model of computation in our work, is the high granularity in the treatment of the protocol participant’s availability. Concretely, already in <em>[3]</em> all functionalities, protocols, and global setups have a dynamic party set. I.e., they all include special instructions allowing parties to register, deregister, and allowing the adversary to learn the current set of registered parties. Additionally, global setups allow any other setup (or functionality) to register and deregister with them, and they also allow other setups to learn their set of registered parties. These registration commands, as outlined</p>

    <p class="text-gray-300">in Section A.1 will be part of the code of all (hybrid and ideal) functionalities and setups considered in this work. For simplicity, we will not write them explicitly in the pseudo-code of the functionalities.</p>

    <p class="text-gray-300">Having such a flexible and dynamic registration/deregistration schedule, requires special care in the blockchain setting. E.g., in <em>[3]</em> it is observed that parties that have very recently joined the Bitcoin network cannot receive all guarantees of honest parties. Intuitively, the reason is that, due to network delays, these parties, called <em>desynchronized</em>, might be temporarily tricked into working on a fake (adversarial) chain. In this work we go one step further towards capturing all availability scenarios, and the corresponding guarantees that can be offered to parties with different availability patterns. We refer to Section 2.2 for more details.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">The adversary.</h4>

    <p class="text-gray-300">We assume a central adversary <span class="math">\\mathcal{A}</span> who corrupts miners and uses them to attack the protocol. The adversary is <em>adaptive</em> meaning that he can add miners to his corrupted set at any point in the protocol execution and can do so depending on his current view of it.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Assumptions on the environment/adversary as setup-functionality wrappers.</h4>

    <p class="text-gray-300">In order to prove statements about cryptographic protocols, one often makes assumptions about what the environment (or the adversary) can or cannot do. For example, to prove resistance against sleepy parties <em>[28]</em>, one needs to assume that awake (non-sleepy) honest parties are always in the majority. Such assumptions can be captured by a restricted environment and/or adversary. However, this is against the spirit of a general composition theorem and technically prevents us from applying it in a further construction step (where for example the ledger is used as a hybrid). To circumvent this undesirable property, we follow the paradigm of <em>[3]</em> to capture such assumption by means of a functionality wrapper that wraps the (local setup) functionalities that the protocol accesses and forces the required assumptions on the adversary/environment. In some sense, we shift such assumption or restrictions from the environment into the setup resources. We refer to <em>[3]</em> for a more detailed discussion. Looking ahead, the wrapper used in our security statements is sketched in Section D (This wrapper will only become relevant to interpret Theorem 3 without the need of a restricted environment or adversary).</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.1 The Real World Execution</h3>

    <p class="text-gray-300">Protocol participants are represented as parties—formally Interactive Turing Machine instances (ITIs)—in a multi-party computation. The main aspects of this computation are as follows:</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">Communication.</h4>

    <p class="text-gray-300">The parties interact which each other by means of a network of eventual delivery unicast channels <em>[3]</em>—informally, every party <span class="math">U_{p}</span> has an open incoming-connections interface where he might receive messages on from arbitrary other parties. This captures the natural joining procedure of real-worlds blockchains where new parties find a point of contact and use it to communicate with other parties by means of a gossiping (flooding) protocol. As argued in <em>[3]</em> assuming the honest parties are strongly connected, this network can be used to build the (UC version of the) standard multicast network with eventual delivery assumed in <em>[17, 27, 22]</em>. The abstraction of this network as a (local) UC functionality and its implementation from unicast channels was described in <em>[3]</em>. For completeness, we include this functionality in Section A.2.</p>

    <p class="text-gray-300">For the remainder of this work we will assume parties have access to such a multicast network. This network, denoted as <span class="math">\\mathcal{F}_{\\text{\\tiny N.MC}}^{\\Delta}</span>, has an upper bound <span class="math">\\Delta</span> in the delay that the adversary can incur on the delivery of any message; we stress, however, that the protocol is oblivious of <span class="math">\\Delta</span> and this bound in only used in the security statement. Hence from the protocol’s point of view the network is no better that an eventual delivery network (without a concrete bound).</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">Synchrony.</h4>

    <p class="text-gray-300">All known PoS-based blockchains, including Ouroboros Genesis, are (partially) synchronous, i.e., they proceed in synchronized rounds with either a known (or an unknown, in the case of partial synchrony) message delay. We model synchronous computation using the synchronous-UC paradigm introduced in <em>[21]</em> and adapted to GUC in <em>[3]</em>. Concretely, the parties are assumed access to a global clock setup, denoted</p>

    <p class="text-gray-300"><span class="math">\\mathcal{G}_{\\textsc{clock}}</span> (see Section A.3.) Each registered party can signal the clock that it is done with the current round, and once all honest registered parties (and functionalities) have done so, the clock advances by one tick. In addition, every party can query the clock to read the (logical) time.</p>

    <p class="text-gray-300">As observed in <em>[3]</em>, to obtain UC realization in such a globally synchronized setting, the target ideal functionality needs to keep track of the number of activations that an honest party gets—so that it can enforce in the ideal world the same pace of the clock as in the real world. This can be achieved by describing the protocol so that it has a predictable behavior when it comes to the pattern of activations that it needs before it sends the clock an update command. To capture this, <em>[3]</em> defines a function <span class="math">\\textsf{predict-time}_{\\Pi}(\\vec{\\mathcal{I}}_{H}^{T})</span> that predicts the time in which the clock is supposed to be according to the given protocol, given as input the timed honest-input sequence. For self-containment, we restate this property formalized in <em>[3]</em> in Definition 7 in Section A.3, where we also prove that Ouroboros Genesis indeed satisfies it.</p>

    <p class="text-gray-300">Hash functions as global random oracles. Ouroboros Genesis assumes that parties can query a hash function. As typically in cryptographic proofs the queries to hash function are modeled by assuming access to a random oracle (functionality): Upon receiving a query <span class="math">(\\textsc{eval},\\textsc{sid},x)</span> from a registered party, if <span class="math">x</span> has not been queried before, a value <span class="math">y</span> is chosen uniformly at random from <span class="math">\\{0,1\\}^{\\kappa}</span> (for security parameter <span class="math">\\kappa</span>) and returned to the party (and the mapping <span class="math">(x,y)</span> is internally stored). If <span class="math">x</span> has been queried before, the corresponding <span class="math">y</span> is returned.</p>

    <p class="text-gray-300">The random oracle is typically captured as a local UC functionality. As discussed in the introduction, this raises a number of issues, both with respect to how natural this abstraction of a hash function is, and with respect to the induced programmability that comes from this choice. Instead in this work we choose to capture it as a global setup, referred to as GRO and denoted as <span class="math">\\mathcal{G}_{\\textsc{ro}}</span> (see Section A.4 for a detailed description.) The fact that our security proof can be carried out in this model serves as an indication of the augmented composability that PoSs bring to the blockchain ecosystem. As mentioned before, Bitcoin cannot be proved secure in the GRO model.</p>

    <p class="text-gray-300">The genesis block generation and distribution. Agreement on the first, so-called genesis block, is a necessary condition in all common blockchains for the parties to achieve eventual consensus. In Ouroboros Genesis, this block includes the keys, signatures, and original stake distribution of the parties that are around at the beginning of the protocol. This assumption— i.e., that the genesis block is properly created and distributed to the initial parties, and that it is properly distributed to anyone who joins even later—is captured in <em>[14]</em> by assuming access to a (local) functionality <span class="math">\\mathcal{F}_{\\textsf{init}}</span>. For each stakeholder registered at the beginning of the protocol, <span class="math">\\mathcal{F}_{\\textsf{init}}</span> records his key in the genesis block; this block is distributed to anyone who requests it in any future round. To simplify the protocol description, we will assume throughout the paper that the first round—i.e., the genesis round—of the protocol occurs when the global time is <span class="math">\\tau=0</span>. This is wlog as the actual genesis-round index is written on the genesis block and we assume that all parties are synchronized with the global clock. For completeness we include a description of <span class="math">\\mathcal{F}_{\\textsf{init}}</span> in Section A.5.</p>

    <p class="text-gray-300">Hybrids used in the security proof. Ouroboros Genesis requires only access to the above functionalities and global setups, i.e., <span class="math">\\mathcal{F}_{\\textsc{hmc}}^{\\Delta}</span>, <span class="math">\\mathcal{F}_{\\textsf{init}}</span>, <span class="math">\\mathcal{G}_{\\textsc{clock}}</span>, and <span class="math">\\mathcal{G}_{\\textsc{ro}}</span>. However, for a clearer protocol description it is convenient to assume hybrid access to two more functionalities, one that abstracts verifiable random functions (VRF), denoted as <span class="math">\\mathcal{F}_{\\textsf{VRF}}</span>, and another one that abstracts key-evolving signature schemes (KES), denoted as <span class="math">\\mathcal{F}_{\\textsf{KES}}</span>. They first appeared in <em>[14]</em> and naturally allow for a cleaner and more modular protocol description and proof. For completeness we include their description in Section A.6 and refer to <em>[14]</em> for concrete realizations.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">2.2 The Ideal World Execution</h3>

    <p class="text-gray-300">We next turn to the functionalities available in the ideal-world. Recall that in this world, the parties execute the so-called dummy protocol. Since the clock and the random oracle are modeled as global setups, i.e.,</p>

    <p class="text-gray-300"><span class="math">\\mathcal{G}_{\\textsc{clock}}</span> and <span class="math">\\mathcal{G}_{\\textsc{ro}}</span>, they are available also in the ideal world. However, the big change in the ideal world, is that the Ouroboros Genesis protocol (and the corresponding network and initialization functionality) are replaced by the ideal functionality that abstracts the protocol’s goals. We call this functionality the <em>(ideal) ledger</em> and formally specify it in the following.</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">The Ledger Functionality.</h4>

    <p class="text-gray-300">The ledger that Ouroboros Genesis realizes is almost identical to the abstract ledger that was proved in <em>[3]</em> to be implemented by (the UC adaptation of) Bitcoin. In fact, the abstract ledger proposed in <em>[3]</em> is parameterizable by a collection of four algorithms. The ledger implemented by Ouroboros Genesis is effectively derived by appropriately instantiating these algorithms. This similarity can be seen as a confirmation of the ledger abstraction, and as an affirmation that Ouroboros Genesis meets strong composable security.</p>

    <p class="text-gray-300">Given their common core, in order to describe the Ouroboros Genesis ledger its is helpful to start with a briefly recap of the abstract ledger from <em>[3]</em>.</p>

    <p class="text-gray-300">The ledger from <em>[3]</em> maintains a central and unique ledger state denoted by state. Each registered party can request to see the state, but is guaranteed to receive a only a sufficiently long prefix of it; the size of each party’s view of the state is captured by (monotonically) increasing pointers that define which part of the state each party can read; the adversary has a limited control on these pointers. The dynamics of this can be seen as a sliding window over the sequence of state blocks, with width windowSize and starting at the head of the state, and each party’s pointer points to a location withing this window. (The adversary can choose the position of the pointers within this sliding window.) As is common in UC, parties advance the ledger when they are instructed to (activated with specific maintain-ledger input by their environment <span class="math">\\mathcal{Z}</span>.) The ledger uses these queries along with the function predict-time(<span class="math">\\cdot</span>) to ensure that the ideal world execution advances with the same pace (relatively to the clock) as the protocol does.</p>

    <p class="text-gray-300">Any party can input a transaction to the ledger (upon instructed by <span class="math">\\mathcal{Z}</span>); upon reception, transactions are validated using a predicate Validate and, if found valid, are added to a buffer. Each new block of the state consists of transactions which were previously accepted to the buffer. (Note that transaction are treated as abstract objects/input-values.) To give protocols syntactic freedom of how a state block looks like, a vector of transactions, say <span class="math">\\vec{N}_{i}</span> is mapped to the <span class="math">i</span>th state block via function <span class="math">\\textsf{Blockify}(\\vec{N}_{i})</span>. Validate and Blockify are two of the ledger’s parametrization algorithms.</p>

    <p class="text-gray-300">A defining part of the behavior of the ledger is the (parameterizable) procedure which defines when/how to extend state. One needs to allow the adversary enough influence, since this is the case in the real protocol, but the ledger should impose certain policies/restrictions regarding such extensions. For example it should require a minimum chain growth rate, a certain chain quality, and liveness of transactions, which are properties studied in <em>[14]</em> for Ouroboros Praos. The procedure ExtendPolicy is responsible for enforcing such a policy. In nutshell, to enable adversarial influence, ExtendPolicy takes as an input a proposal from the adversary for extending the state, and can decide to follow this proposal if it satisfies its policy; if it does not, ExtendPolicy can ignore the proposal (and enforce a default extension). This mechanism is flexible enough to model different kind of scenarios; in particular, as we show in this work, it enables to capture the composable guarantees of proof-of-stake as well.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">Setting the ledger functionality parameters.</h4>

    <p class="text-gray-300">To specify the ledger achieved by Ouroboros Genesis, we need to instantiate the relevant parameters/procedures from above. Blockify, Validate, and predict-time are chosen to mimic the input/output format restrictions of the protocol; concretely, <span class="math">\\textsf{Blockify}:=\\textsf{blockify}_{\\textsf{OG}}</span>, predict-time <span class="math">:=\\textsf{predict-time}_{\\textsf{OG}}</span> (defined in Lemma 3), and</p>

    <p class="text-gray-300"><span class="math">\\textsf{Validate}(\\textsf{BTX},\\textsf{state},\\textsf{buffer}):=\\textsf{ValidTx}_{\\textsf{OG}}(\\textsf{tx},\\textsf{state}),</span></p>

    <p class="text-gray-300">where <span class="math">\\textsf{blockify}_{\\textsf{OG}}</span>, predict-time<span class="math">{}_{\\textsf{OG}}</span>, and <span class="math">\\textsf{ValidTx}_{\\textsf{OG}}</span> are identical to what the real protocol uses, whose description appears in Section 3. As in <em>[3]</em>, <span class="math">\\textsf{blockify}_{\\textsf{OG}}</span> and <span class="math">\\textsf{ValidTx}_{\\textsf{OG}}</span> must not disqualify each other (see <em>[3, Definition 2]</em>). This is easily ensured and also the case for Ouroboros Genesis.</p>

    <p class="text-gray-300">The procedure ExtendPolicy policy is trickier, but it again follows the same principles as in <em>[3]</em>. It enforces the following properties: First, all blocks of state are semantically valid. Furthermore, it ensures the following properties:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The state grows at a minimal rate of blocks over a time interval. This is formalized by specifying a value maxTime_{window} in which at least windowSize blocks have to be inserted into the ledger state.</li>

      <li>A substantial fraction of blocks added to the state are declared as being what we call “honestly generated” and formally have to fulfill higher standards than other blocks. This fraction of good blocks is enforced by requiring a limit advBlocks_{window} of adversarial blocks (i.e., contributed blocks that do not need to employ higher standards) in each window of windowSize state blocks.</li>

    </ol>

    <p class="text-gray-300">Note that honestly generated blocks are crucial to ensure a liveness guarantee for transactions. The liveness guarantee captures that if a transaction is old enough and still valid, then it is guaranteed to be inserted into the state. This guarantee can be enhanced by using digital signatures in a modular next step, i.e., within a ledger-hybrid protocol. We refer to <em>[3]</em> for details. A detailed specification of the Ouroboros Genesis ExtendPolicy can be found in Section A.8.</p>

    <p class="text-gray-300">Party sets maintained by the ledger. The analysis (and ledger) of <em>[3]</em>, and also in this work, separates the honest parties into two different basic categories called synchronized and desynchronized. A party is considered synchronized if it has been continuously connected to all its resources for a sufficiently long interval and has maintained connectivity to these resources, except maybe the GRO, until the current time. Formally, here, “sufficiently long” refers to Delay-many rounds, where Delay is a parameter of the ledger that depends on the network delay (we defer a formal definition of (de)synchronized parties to Section 4.4); as a consequence, the chains held by synchronized parties satisfy common prefix property as defined in <em>[17]</em>. Honest parties that are registered to the ledger but are not synchronized are called desynchronized. Because we cannot guarantee that these parties’ view is consistent with the rest of the honest network, the ledger assigns them less guarantees. As soon as the interval of Delay rounds from registration passes (during which the party needs to have continuous access to the GRO and the clock), these parties become synchronized and obtain the best guarantees the ledger can assign. This party set corresponds to what we call alert parties in this work (and will be outlined in more detail in the next section). We give a detailed overview of all relevant party sets, and how they are reflected in the ideal-world, in the next section.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">2.3 On Modeling Dynamic Availability</h3>

    <p class="text-gray-300">As already discussed in the introduction, in this work we aim (and achieve) the highest granularity in the guarantees that honest parties receive, with respect to their availability status. To define the important classes, we first assign the following attributes to define an honest party’s status at a given point in the execution: a party is considered offline if it is not registered with the network and otherwise it is considered online. A party is time-aware if it is registered with the clock. And finally, we say that a party is operational if it is registered with the second global setup, namely the random oracle (and otherwise considered as stalled). While this gives us a clean technical definition of being operational or stalled, it assigns a rather negative meaning to the term stalled. One could alternatively introduce an explicit protocol feature to allow a higher-level application to choose to stall the operation for a while (but still being connected to the blockchain network for example); we plan to consider such a change in a future revision. For a concise overview, we refer to Figure 1. Based on the four basic attributes mentioned, we can define the types or categories of parties discussed in the introduction. The basic types, such as online/offline parties or operational/stalled parties, simply refer to the subset of honest parties possessing a certain attribute at a given point in the execution.</p>

    <p class="text-gray-300">We further define two more complex party types. First, we have the alert parties that can be considered the core set of honest parties establishing the desired properties of the blockchain and are those honest parties that have a synchronized state and are connected to all resources needed to execute the protocol.</p>

    <p class="text-gray-300">Fig. 1. Classification of honest parties. Based on access to resources (random oracle  <span class="math">\\mathcal{G}_{\\mathrm{RO}}</span> , clock  <span class="math">\\mathcal{G}_{\\mathrm{clock}}</span> , network  <span class="math">\\mathcal{F}_{\\mathrm{N-MC}}</span> ) and presence in their current non-offline status for more than Delay rounds (synchronized or desynchronized).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Resource</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Basic types of honest parties</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Resource unavailable</td>

            <td class="px-3 py-2 border-b border-gray-700">Resource available</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">random oracle GRO</td>

            <td class="px-3 py-2 border-b border-gray-700">stalled</td>

            <td class="px-3 py-2 border-b border-gray-700">operational</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">clock Gclock</td>

            <td class="px-3 py-2 border-b border-gray-700">time-unaware</td>

            <td class="px-3 py-2 border-b border-gray-700">time-aware</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">network FN-MC</td>

            <td class="px-3 py-2 border-b border-gray-700">offline</td>

            <td class="px-3 py-2 border-b border-gray-700">online</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">synchronized state</td>

            <td class="px-3 py-2 border-b border-gray-700">desynchronized</td>

            <td class="px-3 py-2 border-b border-gray-700">synchronized</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">alert:  <span class="math">\\Leftrightarrow</span>  operational  <span class="math">\\wedge</span>  time-aware  <span class="math">\\wedge</span>  online  <span class="math">\\wedge</span>  synchronized</p>

    <p class="text-gray-300">active:  <span class="math">\\Leftrightarrow</span>  (operational  <span class="math">\\wedge</span>  time-aware  <span class="math">\\wedge</span>  online)  <span class="math">\\vee</span>  adversarial  <span class="math">\\vee</span>  time-unaware</p>

    <p class="text-gray-300">Note that while alert parties are honest, the set of active parties also contains all adversarial parties.</p>

    <p class="text-gray-300">Next, in view of the security statements of later sections, we also define in Figure 1 the derived type of potentially active parties (or active for short). This class contains any (honest or corrupted) party that can potentially propose a block in its current status. Formally, it includes all honest parties with access to all resources (be they synchronized or not), all corrupted (i.e., adversarial) parties, and moreover any party that is time-unaware (independently of the other attributes). In the case of time-unaware parties, note that those parties are in particular not capable of evolving their signing keys reliably and hence it cannot be excluded that if they later get corrupted, they might retroactively perform protocol operations in a malicious way.</p>

    <p class="text-gray-300">The definition of a party type is extended from a single point in an execution to a single round in an execution, where a round, say  <span class="math">t</span> , consists of all system configurations where the value of the clock is  <span class="math">t</span> . We say a party is alert in round  <span class="math">t</span> , if it is alert at any point in the execution when the clock's time is  <span class="math">t</span> . We say a party is potentially active in round  <span class="math">t</span>  if it is considered active at some point in the execution when the clock's time is  <span class="math">t</span> . We will recall the above classes and their respective role in our security arguments in Section 4 and Appendix E.</p>

    <p class="text-gray-300">IDEAL-WORLD CORRESPONDENCE. As described in the previous section, as in [3], the ledger keeps an updated track of registered parties with all global setups so it can know which category each party belongs in. As described above, the ledger can thereby distinguish between desynchronized parties (with reduced security guarantees), stalled parties (that obtain no output), alert parties (full security guarantees), and offline parties (which are ignored). We note in passing that, although not included in [3], an analogous level of granularity is an interesting extension to the Bitcoin analysis too. In fact, as an exercise the reader can be convinced that Bitcoin does also implement the ledger with respect to such a fine-grained, dynamic-availability model.[12]</p>

    <p class="text-gray-300">A MINOR DEVIATION: FITTING THE FUNCTIONALITY TO THE POS SETTING. There is one minor point where the PoS ledger needs to deviate from the Bitcoin one. Concretely, in Bitcoin the contents of the genesis block are irrelevant (i.e., the ledger can simply have this block hardwired.) However, in PoS it is inherent that the initial stake (or tokens) is distributed in a trustworthy manner. This is reflected in the need for initialization, where the parties associated to this setup need to register in the very first round. To make sure that the ledger execution is indistinguishable from Ouroboros Genesis, we equip the ledger with an additional parameter, the initial stakeholders set and corresponding stake distribution  <span class="math">S_{\\mathrm{initStake}} \\coloneqq \\{(U_1, s_1), \\ldots, (U_n, s_1)\\}</span> . If some honest stakeholder abstains from registering in the first round, the ledger stops execution. In this work, this parameter is defined to be identical to the stake-distribution parameter of  <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span> .</p>

    <p class="text-gray-300">Given its strong similarities with the abstract ledger from <em>[3]</em>, the complete and formal specification of the concrete ledger that Ouroboros Genesis realizes can be found in Section A.7.</p>

    <h2 id="sec-15" class="text-2xl font-bold">3 Ouroboros Genesis as a UC-Protocol</h2>

    <p class="text-gray-300">In this section we provide a detailed description of our protocol Ouroboros-Genesis as a synchronous (G)UC protocol. The protocol has a similar structure as Ouroboros Praos <em>[14]</em>, but differs considerably in the novel chain selection rule, which allows parties to join at any point without the need of external checkpointing. As already discussed, the protocol only assumes access to the network functionalities and global setups, i.e., <span class="math">\\mathcal{F}_{\\text{N-MC}}^{A},\\mathcal{F}_{\\textsf{INIT}},\\mathcal{G}_{\\textsc{clock}}</span>, and <span class="math">\\mathcal{G}_{\\text{RO}}</span>. However, for clarity we describe the protocols as having access to two additional functionalities <span class="math">\\mathcal{F}_{\\textsf{VRF}}</span> and <span class="math">\\mathcal{F}_{\\textsf{KES}}</span>; as mentioned in the Section 2.1, these latter two functionalities can be implemented using the former.</p>

    <p class="text-gray-300">The section is organized as follows: First we discuss how the hybrids are used and provide a high level description of the protocol. Then we proceed to the detailed protocol specification.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">Protocol overview.</h4>

    <p class="text-gray-300">The protocol Ouroboros-Genesis assumes as hybrids a network <span class="math">\\mathcal{F}_{\\text{N-MC}}^{A}</span>, a verifiable random function <span class="math">\\mathcal{F}_{\\textsf{VRF}}</span>, a key-evolving signature scheme <span class="math">\\mathcal{F}_{\\textsf{KES}}</span>, a global random oracle <span class="math">\\mathcal{G}_{\\text{RO}}</span>, and a global clock <span class="math">\\mathcal{G}_{\\textsc{clock}}</span>.</p>

    <p class="text-gray-300">The protocol execution proceeds in disjoint, consecutive time intervals called slots. Importantly, time is divided in such a way that all parties know when a new slot starts—in our specification, every slot is one round, hence the parties can compute the current slot by comparing the round, i.e., clock value, recorded on the genesis block with the current round. Without loss of generality we will assume that the protocols starts when the global time is <span class="math">\\tau=0</span>; in this case the current slot index will always be <span class="math">\\tau</span>.</p>

    <p class="text-gray-300">In each slot sl, the parties execute a so-called <em>staking procedure</em> to extend the blockchain. At a high level, the staking procedure consists of the following steps: First, the parties execute an implicit lottery to elect a slot leader from a distribution which, roughly, is biased by the stake distribution—the more stake a party has in the system, the more likely he is to be elected slot leader.</p>

    <p class="text-gray-300">In any given slot, the elected slot leaders are in charge of extending the blockchain. Concretely, slot leaders are allowed to propose an updated blockchain. To this direction, the slot leader creates and signs a block for the current slot. Each such block contains transactions that may move stake among stakeholders. The slot leader then broadcasts the new chain extended by its block to its peers via <span class="math">\\mathcal{F}_{\\text{N-MC}}^{\\text{bc}}</span>. We remark that as in <em>[14]</em>, in order to achieve adaptive security the blocks are signed using a key-evolving signature scheme <span class="math">\\mathcal{F}_{\\textsf{KES}}</span> instead of a standard signature, and honest parties are mandated to update their private key in each slot.</p>

    <p class="text-gray-300">A chain proposed by any party might be adopted only if it satisfies the following two conditions: (1) it is valid according to a well defined validation procedure, and (2) the block corresponding to each slot is signed by a corresponding certified slot leader.</p>

    <p class="text-gray-300">To ensure the second property we need the implicit slot-leader lottery to provide its winners (slot leaders) with a certificate/proof of slot-leadership. For this reason, we implement the slot-leader election as follows: Each party <span class="math">U_{p}</span> checks whether or not it is a slot leader, by locally evaluating a verifiable random function (VRF, <em>[15]</em>, modeled by <span class="math">\\mathcal{F}_{\\textsf{VRF}}</span>) using the secret key associated with its stake, and providing as inputs to the VRF both the slot index sl and the so-called epoch randomness <span class="math">\\eta</span> (we will discuss shortly where this randomness comes from). If the VRF output <span class="math">y</span> is below a certain threshold <span class="math">T_{p}</span>—which depends on <span class="math">U_{p}</span>’s stake—then <span class="math">U_{p}</span> is an eligible slot leader; furthermore, he can use the verifiability of the VRF to generate a proof <span class="math">\\pi</span> of the function’s output, thereby certifying his own eligibility to act as a slot leader. In particular, in addition to transactions, each new block broadcast by a slot leader also contains the VRF output <span class="math">y</span> and a proof <span class="math">\\pi</span> of its validity to certify the party’s eligibility to act as a slot leader.</p>

    <p class="text-gray-300">Using the output of a VRF to identify the slot leaders as above not only allows for certifying the winner, but it also ensures that slot leaders are chosen from the appropriate distribution. In a nutshell, this is achieved as follows: Multiple slots are collected into epochs, each of which contains <span class="math">R\\in\\mathbb{N}</span> slots. The idea</p>

    <p class="text-gray-300">of having epochs is that it allows to use stake reference points that are old enough to be stable—with high probability—and are therefore appropriate to be used in a universally verifiable proof. Concretely, during an epoch ep, the stake distribution <span class="math">\\mathbb{S}_{\\textsf{ep}}</span> that is used for deriving the threshold <span class="math">T_{p}^{\\textsf{ep}}</span> used for the slot-leader election corresponds to the distribution recorded in the ledger up to the last block of epoch <span class="math">\\textsf{ep}-2</span>. Additionally, the epoch randomness <span class="math">\\eta_{\\textsf{ep}}</span> for sampling slot leaders in epoch ep is derived as a hash of additional VRF-values <span class="math">y_{\\rho}</span> that were included (together with their respective VRF-proofs <span class="math">\\pi_{\\rho}</span>) into blocks from the first two thirds of epoch <span class="math">\\textsf{ep}-1</span> for this purpose by the respective slot leaders. (To unify block structure, our protocol includes these values into all blocks, but this would not be necessary in practice.) The values <span class="math">\\mathbb{S}_{\\textsf{ep}}</span> and <span class="math">\\eta_{\\textsf{ep}}</span> are updated at the beginning of each epoch.</p>

    <p class="text-gray-300">A delicate point of the above staking procedure is that there will inevitably be some slots with zero or several slot leaders. This means that the parties might receive valid chains from several certified slot leaders. To determine which of these chains to adopt as the new state of the blockchain, each party collects all valid broadcast chains and applies a chain selection rule maxvalid-bg. In fact, the power of the protocol Ouroboros-Genesis and its superiority over all existing PoS-based blockchains stems from this new chain-selection rule which we discuss in detail below.</p>

    <p class="text-gray-300">We next turn to the formal specification of the protocol Ouroboros-Genesis. The protocol describes the code that each party <span class="math">U_{p}</span> executes. Recall that in UC parties can be dynamically created by the environment; upon its creation a party is assigned a session ID, sid, and connects to all global setups, to the adversary, and to all functionalities with which it shares the same session ID sid. Then the party becomes idle (releases the activation) and waits for the environment’s input or for a message by a party with which it has been connected. (Using a standard UC convention, we assume that newly created parties do not register to any functionality or setup unless they are explicitly instructed to, by receiving a special input from their environment. Thus the party generation process is decoupled from the protocol itself.)</p>

    <p class="text-gray-300">To make the protocol description modular, we describe different components as subprotocols and include in their header the parameters they need to be aware of. All protocols described here are <span class="math">\\{\\mathcal{G}_{\\textsc{clock}},\\mathcal{G}_{\\textsc{RO}},\\mathcal{F}_{\\textsc{N}\\text{-}\\textsc{MC}}^{\\Delta},\\mathcal{F}_{\\textsf{INIT}},\\mathcal{F}_{\\textsf{VRF}},\\mathcal{F}_{\\textsf{KES}}\\}</span>-hybrid protocols, i.e., have access to all these functionalities (and protocol participants share the same session ID with all local functionalities in this set.)</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">3.1 The Formal Protocol Description</h3>

    <p class="text-gray-300">We start with some notation. We use <span class="math">x\\prec y</span> to indicate that the string <span class="math">x</span> is a prefix of the string <span class="math">y</span>. Consider an arbitrary partitioning of the time axis into subsequent, non-overlapping, equally long intervals called slots. For the purpose of this section, a block is an arbitrary piece of data that contains an identification of a time slot to which it belongs. A blockchain (or chain, for short) is a sequence of blocks with increasing time slots, starting with a special genesis block and with each subsequent block containing a hash of the previous one. A more concrete description of blocks and chains created by the Ouroboros Genesis protocol will be given in Section 3.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We denote the length of a chain <span class="math">\\mathcal{C}</span> (i.e., the number of its blocks) by <span class="math">\\textsf{len}(\\mathcal{C})</span>. For a chain <span class="math">\\mathcal{C}</span> and an interval of slots <span class="math">I\\triangleq[\\textsf{sl}_{i},\\textsf{sl}_{j}]</span>, we denote by <span class="math">\\mathcal{C}[I]=\\mathcal{C}[\\textsf{sl}_{i}:\\textsf{sl}_{j}]</span> the sequence of blocks in <span class="math">\\mathcal{C}</span> such that their slot numbers fall into the interval <span class="math">I</span>. We replace the brackets in this notation with parentheses to denote intervals that do not include endpoints; e.g., <span class="math">(\\textsf{sl}_{i},\\textsf{sl}_{j}]=\\{\\textsf{sl}_{i}+1,\\ldots,\\textsf{sl}_{j}\\}</span>. Finally, we denote by $\\#_{i:j}(\\mathcal{C})\\triangleq\\#_{I}(\\mathcal{C})\\triangleq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}[I]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> the number of blocks in </span>\\mathcal{C}[I]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Before giving the formal specification we introduce some necessary terminology and notation. Each party U stores a local blockchain <span class="math">\\mathcal{C}_{\\textsf{loc}}^{U_{p}}</span>—<span class="math">U_{p}</span>’s local view of the blockchain. Such a local blockchain is a sequence of blocks <span class="math">B_{i}</span> (<span class="math">i&gt;0</span>) where each <span class="math">B\\in\\mathcal{C}_{\\textsf{loc}}</span> has the following format: <span class="math">B=(h,\\textsf{st},\\textsf{sl},crt,\\rho,\\sigma)</span>. The first block <span class="math">B_{0}</span> is special and is referred to as the genesis block G. In each following block <span class="math">B_{i},i&gt;0</span>, <span class="math">h</span> is a hash of the previous block, st is the encoded data of this block, and sl is the slot number this block belongs to. The value <span class="math">crt=(U_{p},y,\\pi)</span> certifies that the block was indeed proposed by an eligible slot leader <span class="math">U_{p}</span> for slot sl by providing the output <span class="math">y</span> of <span class="math">U_{p}</span>’s VRF evaluation for this slot, along with the corresponding VRF proof <span class="math">\\pi</span>.</p>

    <p class="text-gray-300">Additionally, <span class="math">\\rho=(y_{\\rho},\\pi_{\\rho})</span> is an independent VRF output—along with its proof—that is also inserted into the block by <span class="math">U_{p}</span> and is later used to derive the future epoch randomness. Finally, <span class="math">\\sigma</span> is the signature by <span class="math">U_{p}</span> on the entire block (using a key-evolving signature scheme).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If $\\mathcal{C}_{\\texttt{loc}}=B_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B_{\\ell}<span class="math"> is a (local) chain, we define its associated <em>encoded state</em> </span>\\vec{\\texttt{st}}<span class="math"> as the sequence </span>\\texttt{st}_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\texttt{st}_{\\ell}<span class="math">, where each </span>\\texttt{st}_{i}<span class="math">—referred to as the </span>i<span class="math">th <em>state block</em> of the state—is the encoded data stored in block </span>B_{i}<span class="math">. (The genesis data is defined to be </span>\\texttt{st}_{0}:=\\varepsilon<span class="math">.) The <em>exported state</em> is then a specific prefix </span>\\vec{\\texttt{st}}^{\\lceil k\\rceil}<span class="math"> of this state (we define this expression to be </span>\\varepsilon<span class="math"> if </span>k<span class="math"> is larger than the size of the chain). The exact format of the state blocks depends on the actual implementation and is enforced by use of the function </span>\\texttt{blockify}_{\\texttt{OG}}<span class="math">. Concretely, each state block </span>\\texttt{st}<span class="math"> is formed by applying this predicate on a vector </span>N$ of transactions to derive an appropriately formatted version of the block. This parameterization allows flexibility in the way the exported state is formatted.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To enable dynamic availability every party stores in a variable <span class="math">t_{\\text{on}}</span> (initially set to 1) the time/slot it was last online (and not stalled). It also store in a variable <span class="math">t_{\\text{work}}</span> (initially set to 0) the last time when the staking procedure run to completion. Every protocol machine also stores the current (local) state <span class="math">\\vec{\\texttt{st}}</span> encoded in the chain <span class="math">\\mathcal{C}_{\\texttt{loc}}</span> and the local buffer buffer (corresponding to the transactions seen so far on the network and not added on the blockchain); <span class="math">\\vec{\\texttt{st}},\\mathcal{C}_{\\texttt{loc}}</span> and buffer are all initially empty.</p>

    <p class="text-gray-300">For brevity, whenever in the protocol we say that a party <em>uses the clock to update, <span class="math">\\tau</span>, <span class="math">\\texttt{ep}</span>, and <span class="math">\\texttt{sl}</span></em> we mean the following step:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Send (clock-read, <span class="math">\\text{sid}_{C}</span>) to <span class="math">\\mathcal{G}_{\\text{clock}}</span>; receive the current time <span class="math">\\tau</span> and update <span class="math">\\texttt{ep}:=\\lceil\\tau/R\\rceil</span> and slot index <span class="math">\\texttt{sl}=\\tau</span>, accordingly.</li>

    </ul>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">Handling interrupts in a UC protocol.</h4>

    <p class="text-gray-300">A protocol command might consists of a sequence of operations. In UC, certain operations, such as sending a message to another party, outputting a message to the environment, or the inability to conclude a task because a resource is unavailable, result into the protocol machine having to loose its activation. Thus, one needs a mechanism for ensuring that a party that looses the activation in the middle of such a multi-step command is able to resume and complete this command. Such a mechanism is implicitly described in <em>[21]</em>. This mechanism can be made explicit by introducing an anchor <span class="math">a</span> that stores a pointer to the current operation; the protocol associates each anchor with such a multiple command and an input <span class="math">I</span>, so that when such an input is received it directly jumps to the stored anchor, executes the next operation(s) and updates (increases) the anchor before releasing the activation. We refer to execution in such a manner as <em>I-interruptible</em>.</p>

    <p class="text-gray-300">For clarity we include an example of an interruptible execution. Assume that the protocol mandates that upon receiving input <span class="math">I</span>, the party should run a command that consists of <span class="math">m</span> steps Step 1, Step 2, …, Step <span class="math">m</span>, but some of these steps might result in the executing party releasing its activation. Running this command in an <em>I-interruptible</em> manner means executing the following code: Upon receiving input <span class="math">I</span> if <span class="math">a&lt;m</span> go to Step <span class="math">a</span> and increase <span class="math">a=a+1</span> before executing the first operation that releases the activation; otherwise go to Step 1 and set <span class="math">a=2</span> before executing any operation that releases the activation.</p>

    <p class="text-gray-300">The Ouroboros Genesis protocol is described in detail in Figure 2. Aside of the core operation of the protocol, the description already includes a block of commands (in the bottom of the description) which specify what parties do when they receive external queries to their global setups, such as queries to the global random oracle. Note that since the ideal-world (dummy) parties would forward such queries to their setups, the protocol needs to do basically this, except possibly for some book-keeping actions in case they are not fully operational (such as making sure that at least the signing key evolves before moving to the next round).</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">3.2 Registration and Deregistration</h3>

    <p class="text-gray-300">The first thing a party needs to do in order to have any role in the protocol is register with its resources. Registration (and deregistration) is dictated to the (honest) parties by the environment. This captures the</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 2. The Ouroboros Genesis Protocol</p>

    <p class="text-gray-300">fact that resource availability is not something controlled by the protocol itself. For example, a crash of the timing or hashing process of the party's computer is captured by the environment instructing the party to deregister from the clock or the GRO, respectively. To capture our high-resolution (dynamic) availability, the environment is allowed to register and deregister parties from any of the resources at will.</p>

    <p class="text-gray-300">In the following we describe the protocol that the parties execute upon receiving a registration/deregistration request. For clarity, we assume that every party keeps a local registry, denoted by Reg, that includes a registration-flag for each of the functionalities (local and global) the party is connected to; whenever the party registers or deregisters with some functionality/setup the corresponding flag is updated accordingly. The protocols for registration and deregistration are described in the following. Since such commands are addressed to setups or to the ledger, they are only effecting in the real-world protocol if they are addressed to one of the functionalities/setups that are present, i.e., to some  <span class="math">\\mathcal{G} \\in \\{\\mathcal{G}_{\\mathrm{CLOCK}}, \\mathcal{G}_{\\mathrm{RO}}, \\mathcal{G}_{\\mathrm{LEDGER}}\\}</span> . Any registration input with session ID different than that of those three functionalities will be ignored by the protocol. Without loss of generality, we do not write the session IDs of global setups and refer to them simply with their name.</p>

    <p class="text-gray-300">The registration with any of the global setups  <span class="math">\\mathcal{G}_{\\mathrm{RO}}</span>  and  <span class="math">\\mathcal{G}_{\\mathrm{CLOCK}}</span>  is straightforward. However, registering with the ledger is a little more complicated. Upon receiving a ledger-registration query from the environment, the party first checks that it is registered with the global functionalities  <span class="math">\\mathcal{G}_{\\mathrm{RO}}</span>  and  <span class="math">\\mathcal{G}_{\\mathrm{CLOCK}}</span> . If not, then it ignores the input (and is still considered offline). Otherwise, it registers with each functionality—excluding the already registered-to global setup functionalities  <span class="math">\\mathcal{G}_{\\mathrm{RO}}</span>  and  <span class="math">\\mathcal{G}_{\\mathrm{CLOCK}}</span> . Moreover, once a party registers with its network it also stores the current time in variable  <span class="math">t_{\\mathrm{on}}</span> . (Recall that  <span class="math">t_{\\mathrm{on}}</span>  stores the last time the party was online, i.e., connected to all its resources.)</p>

    <p class="text-gray-300">Note that the registration to and from the global functionalities has to stay under the control of the environment. Only once this procedure is completed, the party becomes operational and otherwise is considered de-registered and does not answer any ledger-specific queries (i.e., it is offline). The activation after any (de)registration goes back to the environment. The registration process is detailed in Figure 3.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 3. The registration process.</p>

    <p class="text-gray-300">The deregistration process is described in Figure 4. De-registering from global setups is analogous to above, while for simplicity, we model de-registering from the "ledger" as disconnecting from the network and hence becoming an offline party.</p>

    <p class="text-gray-300">At the core of the Ouroboros Genesis protocol is the process that allows parties to maintain the ledger. There are three types of processes that are triggered by three different commands provided that the party is already registered to all its local and global functionalities—if this in not the case, the corresponding command is ignored.[16]</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 4. The deregistration process.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The command (SUBMIT, sid, tx) is used for sending a new transaction to the ledger (to be included in one of the upcoming blocks). It results in the party storing the submitted transaction in its local transaction buffer and multicasting it to the network so that other parties also add it to their buffers.</li>

      <li>The command (READ, sid) is used for the environment to ask for a read of the current ledger state. It results in the party outputting a prefix  <span class="math">\\vec{\\mathsf{st}}^{\\uparrow k}</span>  of the state  <span class="math">\\vec{\\mathsf{st}}</span>  extracted from its most recently updated (local) blockchain. As we argue any such output will be a prefix of any output given by any other party (this will follow from the common-prefix property).</li>

      <li>The command (MAINTAIN-LEDGER, sid, minerID) triggers the main ledger update and maintenance procedure which is the most involved part. A party receiving this command first fetches from its network all information relevant for the current round, then it uses the received information to update its local info—i.e., asks the clock for the current time  <span class="math">\\tau</span> , updates its epoch counter ep, its slot counter s1, and its (local view of) stake distribution parameters, accordingly; and finally it invokes the staking procedure unless it has already done so in the current round. If this is the first time that the party processes a (MAINTAIN-LEDGER, sid, minerID) message then before doing anything else, the party invokes an initialization protocol to receive the initial information it needs to start executing the protocol—in particular the genesis block. Furthermore, in order accommodate stalled parties, if the party is registered with the network but not with all other setups, this stalled party remembers the time it was stalled and returns the activation back to the environment. Also, since a stalled party remembers the last time it was online—thereby also the time it became stalled—in variable  <span class="math">t_{\\mathrm{on}}</span> , once such a party gets reconnected—i.e., re-registers with the ledger in the ideal world (resp. with the network, the VRF and the KES in the real world)—then upon its next activation to maintain the ledger, the party fetches all messages it has missed by comparing the current time  <span class="math">\\tau</span>  to  <span class="math">t_{\\mathrm{on}}</span>  and querying the network the corresponding number of times. Details of this procedure are given in Section 3.3.2.</li>

    </ul>

    <p class="text-gray-300">The relevant sub-processes involved in the handling of a MAINTAIN-LEDGER query are detailed in the following Sections 3.3.1 to 3.3.4. After introducing each of these basic ingredients, we conclude with a technical overview of the main ledger maintenance protocol LedgerMaintenance in Figure 12 and a detail specification of the protocol ReadState for answering requests to read the ledger's state (see Figure 13.)</p>

    <p class="text-gray-300">A party that has been registered with all its resources and setups becomes operational by invoking the initialization protocol Initialization-Genesis upon processing its first MAINTAIN-LEDGER command (see Figure 5 for detailed description). As a first step the party receives its keys from  <span class="math">\\mathcal{F}_{\\mathrm{VRF}}</span>  and  <span class="math">\\mathcal{F}_{\\mathrm{KES}}</span> . Subsequently, protocol Initialization-Genesis proceeds in one of the following two modes depending on whether or not the current round is the genesis round. Concretely:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In the genesis mode, which is only executed during the genesis round  <span class="math">\\tau = 0</span> , the party interacts with the initialization functionality  <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span>  to claim its stake.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In the non-genesis mode, i.e., when  <span class="math">\\tau &amp;gt; 1</span> , the protocol Initialization-Genesis queries  <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span>  to receive the genesis block and uses the received stake distribution to determine the initial threshold  <span class="math">T_{p}^{\\mathrm{ep}}</span>  for each stakeholder  <span class="math">U_{p}</span> . Additionally, in order for the party to receive transactions and chains that were circulated over the network prior to this current round, the party multicasts a special message HELLO upon its first maintain-ledger activation (in addition to its normal round messages). Looking ahead, any  <span class="math">U_{p}</span>  receiving this message will set a special WELCOME flag to 1 will trigger (at first chance)  <span class="math">U_{p}</span>  to multicast his local buffer and chain; receiving these messages will enable the newly joining party to get up to speed. Recall that in order to ensure that the genesis round has been completed (and all initial stakeholders have claimed their stake) before the protocol starts advancing, the functionality  <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span>  throws an exception (halts with an error) if the environment does not allow all stakeholder to claim their stake in the genesis round. If this occurs, the calling protocol (i.e., Ouroboros Genesis) also halts (cf. Figure 2).</li>

    </ul>

    <p class="text-gray-300">Independent of the round, the protocol concludes with the party setting isInit  <span class="math">\\leftarrow</span>  true (to make sure that it is never re-initialized) and  <span class="math">t_{\\mathrm{on}} \\gets \\tau</span>  to remember the last time it became online—which in this case is also the first one.</p>

    <p class="text-gray-300">Protocol Initialization-Genesis  <span class="math">(U_{p},\\mathrm{sid},R)</span> The following steps are executed in an (MAINTAIN-LEDGER, sid, minerID)-interruptible manner: 1: Send (KeyGen, sid,  <span class="math">U_{p}</span> ) to  <span class="math">\\mathcal{F}_{\\mathrm{VRF}}</span>  and  <span class="math">\\mathcal{F}_{\\mathrm{KES}}</span> ; receiving (VerificationKey, sid,  <span class="math">v_{p}^{\\mathrm{vrf}}</span> ) and (VerificationKey, sid,  <span class="math">v_{p}^{\\mathrm{kes}}</span> ), respectively. // The following branch is executed on the first maintenance query after registration of this instance at time 0. 2: if  <span class="math">\\tau = 0</span>  then 3: Send (ver_keys, sid,  <span class="math">U_{p}, v_{p}^{\\mathrm{vrf}}, v_{p}^{\\mathrm{kes}}</span> ) to  <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span>  to claim stake from the genesis block. 4: Invoke FinishRound( <span class="math">U_{p}</span> ) // Resume below on next maintain-ledger activation. 5: Invoke UpdateTime( <span class="math">U_{p}</span> ) to update  <span class="math">\\tau</span> , ep, and s1. 6: while  <span class="math">\\tau = 0</span>  do 7: Call UpdateTime( <span class="math">U_{p}</span> ) to update  <span class="math">\\tau</span> , ep, and s1. and give up the activation (set anchor here) end while 8: end if // The following executed if this is a non-genesis round 9: if  <span class="math">\\tau &amp;gt; 0</span>  then 10: if  <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span>  signals an error then 11: Halt the execution. 12: end if 13: Send (genblock_req, sid,  <span class="math">U_{p}</span> ) to  <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span> . 14: Receive from  <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span>  the response (genblock, sid,  <span class="math">\\mathbf{G} = (\\mathbb{S}_1, \\eta_1)</span> ), where <span class="math">\\mathbb{S}_1 = \\left((U_1, v_1^{\\mathrm{vrf}}, v_1^{\\mathrm{kes}}, s_1), \\ldots, (U_n, v_n^{\\mathrm{vrf}}, v_n^{\\mathrm{kes}}, s_n)\\right)</span> . 15: Set  <span class="math">\\mathcal{C}_{\\mathrm{loc}} \\gets (\\mathbf{G})</span> . 16: Set  <span class="math">T_{p}^{\\mathrm{ep}} \\gets 2^{\\ell_{\\mathrm{VRF}}} \\phi_f(\\alpha_p^{\\mathrm{ep}})</span>  as the threshold for stakeholder  <span class="math">U_{p}</span>  for epoch ep, where  <span class="math">\\alpha_p^{\\mathrm{ep}}</span>  is the relative stake of stakeholder  <span class="math">U_{p}</span>  in  <span class="math">\\mathbb{S}_{\\mathrm{ep}}</span>  and  <span class="math">\\ell_{\\mathrm{VRF}}</span>  denotes the output length of  <span class="math">\\mathcal{F}_{\\mathrm{VRF}}</span> . 17: Send (HELLO, sid,  <span class="math">U_{p}, v_{p}^{\\mathrm{vrf}}, v_{p}^{\\mathrm{kes}}</span> ) to  <span class="math">\\mathcal{F}_{\\mathrm{N-MC}}^{\\mathrm{new}}</span> . end if 18: Set isInit  <span class="math">\\leftarrow</span>  true,  <span class="math">t_{\\mathrm{on}} \\gets \\tau</span> , and  <span class="math">t_{\\mathrm{work}} \\gets 0</span> . GLOBAL VARIABLES: The protocol stores the list of variables  <span class="math">v_{p}^{\\mathrm{vrf}}, v_{p}^{\\mathrm{kes}}, \\tau, \\mathbf{ep}, \\mathbf{s1}, \\mathcal{C}_{\\mathrm{loc}}, T_{p}^{\\mathrm{ep}}, \\mathbf{isInit}</span> ,  <span class="math">t_{\\mathrm{on}}</span>  to make each of them accessible by all protocol parts.</p>

    <p class="text-gray-300">Fig. 5. The initialization protocol of Ouroboros Genesis (run only the first time a party joins).</p>

    <p class="text-gray-300">The first thing that an already initialized (and fully online) party does is to attempt to read its incoming messages. Recall that in our network setting, a party accesses its network interface by sending a FETCH command to its network. A network latency of, say,  <span class="math">\\Delta</span>  rounds, in the delivery of any given messages is then captured by the network withholding this message until  <span class="math">\\Delta</span>  FETCH commands are issued (cf. [21]). In order to ensure that parties which have been stalled (but were not taken offline) can catch up with the messages sent to them while they where stalled, we use the following mechanism. The party first gets the current time  <span class="math">\\tau</span>  from the clock, and then sets a counter fetchcount to  <span class="math">\\tau - t_{\\mathrm{on}}</span> . (Since  <span class="math">t_{\\mathrm{on}}</span>  stores the last round that the party was online, fetchcount will be the number of rounds this party was stalled.) Subsequently the party issues fetchcount FETCH-queries to its network. Recall that a party that was offline and becomes online is considered de-synchronized for (at least) as many rounds as it needs for that party to receive all the relevant information and for the chain-selection rule to bootstrap it <span class="math">^{17}</span>  —by detecting a chain that is guaranteed to originate from an honest and synchronized party. This party does not get to retrospectively receive messages sent to it while it was offline, which is reflected in our protocol by the fact that this party will execute the network-registration procedure from scratch and will therefore set  <span class="math">t_{\\mathrm{on}} = \\tau</span> .</p>

    <p class="text-gray-300">There are three types of messages that are exchanged through the network, namely: blockchains—e.g., when a slot leader creates a new block; regular messages, also referred to as transactions—which are broadcasted to the network when received by the environment; and HELLO-messages, as described above, sent by newly joining parties. To simplify the exposition, in our description we make the convention that each of these three types of messages is multicasted by its own network. Concretely, we will assume a network used for disseminating transactions, denoted as  <span class="math">\\mathcal{F}_{\\mathrm{N - MC}}^{\\mathrm{bs}}</span> , a network used for circulating HELLO message, denoted as  <span class="math">\\mathcal{F}_{\\mathrm{N - MC}}^{\\mathrm{new}}</span> , and a network used for disseminating other information (in particular new blockchains) as  <span class="math">\\mathcal{F}_{\\mathrm{N - MC}}^{\\mathrm{be}}</span> . We stress that this distinction of networks is only for sake of clarity, as these three networks can be simulated over the original multicast network  <span class="math">\\mathcal{F}_{\\mathrm{N - MC}}</span>  by appending a special identifier indicating the type of the exchanged message.</p>

    <p class="text-gray-300">The protocol FetchInformation performing the above operations can be found in Figure 6.</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Fig. 6. Fetching new information circulated through the multicast network.</p>

    <p class="text-gray-300">3.3.3 The Staking Procedure</p>

    <p class="text-gray-300">The next part of the ledger-maintenance protocol is the staking procedure which is used for the slot leader to compute and send the next block.</p>

    <p class="text-gray-300">Recall that a party <span class="math">U_{p}</span> is an eligible slot leader for a particular slot sl in an epoch ep if its VRF-output (for an input dependent on sl) is smaller than a threshold value <span class="math">T_{p}^{\\sf ep}</span>. We next discuss how this threshold is computed for the party’s current (local) blockchain, where we use the following notation: <span class="math">\\ell_{\\sf VRF}</span> denotes the VRF output length in bits. The (local) stake distribution <span class="math">\\mathbb{S}_{\\sf ep}</span> at epoch ep corresponding to the (local) blockchain <span class="math">\\mathcal{C}_{\\sf loc}</span> is a mapping from a party (identified by its public keys) to its stake and can be derived solely based on encoded transactions in <span class="math">\\mathcal{C}_{\\sf loc}</span> (and the genesis block). The relative stake of <span class="math">U_{p}</span> in the stake distribution <span class="math">\\mathbb{S}_{\\sf ep}</span>, denoted as <span class="math">\\alpha_{p}^{\\sf ep}\\in[0,1]</span>, is the fraction of stake that is associated with this party (more precisely, its public key) in <span class="math">\\mathbb{S}_{\\sf ep}</span> out of all stake. The mapping <span class="math">\\phi_{f}(\\cdot)</span> is defined as</p>

    <p class="text-gray-300"><span class="math">\\phi_{f}(\\alpha)\\triangleq 1-(1-f)^{\\alpha}</span> (1)</p>

    <p class="text-gray-300">and is parametrized by a quantity <span class="math">f\\in(0,1]</span> called the <em>active slots coefficient</em> <em>[14]</em>, which is an important parameter of the protocol Ouroboros-Genesis (cf. Section 3.3.3).</p>

    <p class="text-gray-300">Given the above, the threshold <span class="math">T_{p}^{\\sf ep}</span> is determined as</p>

    <p class="text-gray-300"><span class="math">T_{p}^{\\sf ep}=2^{\\ell_{\\sf VRF}}\\phi_{f}(\\alpha_{p}^{\\sf ep})\\;.</span> (2)</p>

    <p class="text-gray-300">Note that by (2), a party with relative stake <span class="math">\\alpha\\in(0,1]</span> becomes a slot leader in a particular slot with probability <span class="math">\\phi_{f}(\\alpha)</span>, independently of all other parties. We clearly have <span class="math">\\phi_{f}(1)=f</span>, hence <span class="math">f</span> is the probability that a hypothetical party controlling all 100% of the stake would be elected leader for a particular slot. Furthermore, the function <span class="math">\\phi</span> has an important property called “independent aggregation” <em>[14]</em>:</p>

    <p class="text-gray-300"><span class="math">1-\\phi\\left(\\sum_{i}\\alpha_{i}\\right)=\\prod_{i}(1-\\phi(\\alpha_{i}))\\;.</span> (3)</p>

    <p class="text-gray-300">In particular, when leadership is determined according to <span class="math">\\phi_{f}</span>, the probability of a stakeholder becoming a slot leader in a particular slot is independent of whether this stakeholder acts as a single party in the protocol, or splits its stake among several “virtual” parties. Therefore, we can conclude that under arbitrary stake distribution, a particular slot has <em>some</em> slot leader with probability <span class="math">f</span>, giving the active slots coefficient its intuitive meaning.</p>

    <p class="text-gray-300">The technical description of the staking procedure appears in Figure 7. It starts by two calls evaluating the VRF in two different points, using constants NONCE and TEST to provide domain separation, and receiving <span class="math">(y_{\\rho},\\pi_{\\rho})</span> and <span class="math">(y,\\pi)</span>, respectively. The value <span class="math">y</span> is used to evaluate slot leadership: if <span class="math">y&lt;T_{p}^{\\sf ep}</span> then the party is a slot leader and continues by processing its current transaction buffer to form a new block <span class="math">B</span>. Aside of this application data, each block contains control information as described in Section 3.1. The information includes the proof of leadership <span class="math">(y,\\pi)</span>, additional VRF-output <span class="math">(y_{\\rho},\\pi_{\\rho})</span> that influences the epoch-randomness for the next epoch, and the block signature <span class="math">\\sigma</span> produced using <span class="math">\\mathcal{F}_{\\sf KES}</span>. Finally, an updated blockchain <span class="math">\\mathcal{C}_{\\sf loc}</span> containing the new block <span class="math">B</span> is multicast over the network (note that in practice, the protocol would only diffuse the new block <span class="math">B</span>).</p>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">Transaction Validity.</h4>

    <p class="text-gray-300">Blockchain ledgers typically put restrictions on transactions that can be added to a block. For example, Bitcoin only allows transactions that are properly signed and are spending an unspent coin. Although this is not directly related to the consistency guarantees, similarly to <em>[3]</em>, our ledger also has such a transaction filter in place (this makes it suitable for applications like cryptocurrencies). This filter is</p>

    <p class="text-gray-300">implemented by means of a predicate ValidTxOG. To decide which transactions can be included in the state of a new block, the party checks for each transaction contained in its buffer whether it is valid, according to ValidTxOG, with respect to the current state of the chain. Note that to allow for full generality we leave ValidTxOG as a protocol/ledger parameter (the same for both); this will allow to use the same protocol and ledger for different definitions of transaction validity.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The transaction validity predicate ValidTxOG induces a natural transaction validity on blockchain-states. This is captured by the predicate isvalidstate(<span class="math">\\vec{\\mathsf{st}}</span>) that decides whether a state consists of valid transactions according to ValidTxOG. The predicate simply checks that each transaction tx of any state-block <span class="math">\\mathsf{st}_{i}</span> included in the state $\\vec{\\mathsf{st}}=\\mathsf{st}_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{st}_{\\ell}<span class="math"> includes transactions that are valid with respect to the state </span>\\mathsf{st}_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{st}_{i-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{st}_{i}^{-\\mathsf{tx}}<span class="math">, where </span>\\mathsf{st}_{i}^{-\\mathsf{tx}}<span class="math"> is the </span>i<span class="math">-th state block </span>\\mathsf{st}_{i}$ with tx removed.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-26" class="text-base font-medium mt-4">Remark 1 (Building a Cryptocurrency Ledger)</h6>

    <p class="text-gray-300">Consistently with the cryptographic literature on blockchains, we use the term transaction to refer to input values tx given to the ledger protocol (and the ledger functionality). It is important to recall that in order to achieve the standard ledger functionality of this work, where weak transaction liveness is enforced, transactions need not be signed (cf. <em>[17, 3]</em>). Using composition, a protection to amplify the liveness of transactions can be applied as a next modular step, on top of our ledger functionality. We note in passing that such an amplification has been achieved assuming a signature scheme combined with an explicit encoding of transactions to contain the source and destination addresses of the involved parties that relate to their public keys and/or identities; an honest protocol participant would consequently only sign its transactions but no others, and signature verification would be part of the validity check ValidTxOG. We refer to <em>[3]</em> for details on how to build a UC cryptocurrency ledger on top of a generic transaction ledger using the composability guarantees of the UC framework.</p>

    <h4 id="sec-27" class="text-lg font-semibold mt-6">3.3.4 Chain Selection</h4>

    <p class="text-gray-300">The most novel component of our protocol is the way in which a party decides which chain to adopt given a set of alternatives it (repeatedly) receives over the network. The chain selection protocol is invoked once a party has collected all chains he can in the current round—denote the set of all these chains by <span class="math">\\mathcal{N}=\\{\\mathcal{C}_{1},\\ldots,\\mathcal{C}_{M}\\}</span>—and is trying to decide whether to keep his current local chain <span class="math">\\mathcal{C}_{\\mathsf{loc}}</span>, or adopt one of the newly received chains in <span class="math">\\mathcal{N}</span>. As we prove, the power of the new rule lies in the fact that it allows a desynchronized or even a newly joining party—whose <span class="math">\\mathcal{C}_{\\mathsf{loc}}</span> is empty—to eventually converge to a good chain. We refer to this process as bootstrapping from genesis, and denote the new chain selection algorithm as maxvalid-bg.</p>

    <p class="text-gray-300">The chain selection process proceeds in three steps: First the party <span class="math">U_{p}</span> uses the clock to make sure the time-relevant parameters, i.e., <span class="math">\\tau,\\mathsf{ep}</span>, and <span class="math">\\mathsf{sl}</span>, are up-to-date, and updates its local state accordingly (see below). Second, <span class="math">U_{p}</span> filters all the received chains, one-by-one, to keep only the ones that satisfy a syntactic validity property. Informally, those are chains whose signatures are consistent with the genesis block, and their block-contents are consistent with the keys recorded in KES, the VRF, and the global random oracle. The filtering of any given chain <span class="math">\\mathcal{C}</span> is done by an invocation of protocol IsValidChain described below. Finally, the party applies our new chain selection rule maxvalid-bg on the filtered list of chains to (possibly) update its local chain. The above three steps are detailed in the following.</p>

    <h5 id="sec-28" class="text-base font-semibold mt-4">Step 1: Updating the local state and time variables.</h5>

    <p class="text-gray-300">Every time a party fetches new information from the network, it needs to refresh its local view, and in particular to update the current epoch counter <span class="math">\\mathsf{ep}</span> using the current clock time, as well as its view of the state parameters: the current epoch stake distribution <span class="math">\\mathbb{S}_{\\mathsf{ep}}</span>, the relative stake <span class="math">\\alpha_{p}^{\\mathsf{ep}}</span>, and epoch randomness <span class="math">\\eta_{\\mathsf{ep}}</span>, and the staking threshold <span class="math">T_{p}^{\\mathsf{ep}}</span>. This is achieved by the protocols UpdateStakeDist (see Figure 8) and (the very simple) UpdateTime in Figure 9. The algorithm used to update the stake parameters, in particular the threshold <span class="math">T_{p}^{\\mathsf{ep}}</span> was discussed in Section 3.3.3.</p>

    <p class="text-gray-300">Protocol StakingProcedure  <span class="math">(U_{p},\\mathrm{sid},k,\\mathrm{ep},\\mathrm{sl},</span>  buffer,  <span class="math">\\mathcal{C}_{\\mathrm{loc}})</span> The following steps are executed in an (MAINTAIN-LEDGER, sid, minerID)-interruptible manner: // Determine leader status 1: Send (EvalProve, sid,  <span class="math">\\eta_{j}\\parallel \\mathsf{sl}\\parallel</span>  NONCE) to  <span class="math">\\mathcal{F}_{\\mathrm{VRF}}</span>  , denote the response from  <span class="math">\\mathcal{F}_{\\mathrm{VRF}}</span>  by (Evaluated, sid,  <span class="math">y_{\\rho},\\pi_{\\rho})</span> 2: Send (EvalProve, sid,  <span class="math">\\eta_{j}\\parallel \\mathsf{sl}\\parallel</span>  TEST) to  <span class="math">\\mathcal{F}_{\\mathrm{VRF}}</span>  , denote the response from  <span class="math">\\mathcal{F}_{\\mathrm{VRF}}</span>  by (Evaluated, sid,  <span class="math">y,\\pi)</span> 3: if  <span class="math">y &amp;lt;   T_p^{\\mathrm{ep}}</span>  then // Generate a new block 4: Set buffer'  <span class="math">\\leftarrow</span>  buffer,  <span class="math">\\vec{N}\\gets \\mathrm{tx}_{U_p}^{\\mathrm{base - tx}}</span>  , and st  <span class="math">\\leftarrow</span>  blockifyOG(N) 5: repeat 6: Parse buffer' as sequence  <span class="math">(\\mathrm{tx}_1,\\dots ,\\mathrm{tx}_n)</span> 7: for  <span class="math">i = 1</span>  to n do</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">8: if ValidTxOG(txi, st</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">st) = 1 then</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">10: Remove tx from buffer' 11: Set st  <span class="math">\\leftarrow</span>  blockifyOG(N) end if end for until  <span class="math">\\vec{N}</span>  does not increase anymore 12: Set crt  <span class="math">= (U_p,y,\\pi)</span> <span class="math">\\rho = (y_{\\rho},\\pi_{\\rho})</span>  and  <span class="math">h\\gets H(\\mathrm{head}(\\mathcal{C}_{\\mathrm{loc}}))</span> 13: Send (USign, sid,  <span class="math">U_{p},(h,\\mathrm{st},\\mathrm{sl},crt,\\rho),\\mathrm{sl})</span>  to  <span class="math">\\mathcal{F}_{\\mathrm{KES}}</span>  ; denote the response from  <span class="math">\\mathcal{F}_{\\mathrm{KES}}</span>  by (Signature, sid,  <span class="math">(h,\\mathrm{st},\\mathrm{sl},crt,\\rho),\\mathrm{sl},\\sigma)</span> 14: Set  <span class="math">B\\gets (h,\\mathrm{st},\\mathrm{sl},crt,\\rho ,\\sigma)</span>  and update  <span class="math">\\mathcal{C}_{\\mathrm{loc}}\\gets \\mathcal{C}_{\\mathrm{loc}}\\parallel B.</span>  // Multicast the extended chain and wait. 15: Send (MULTICAST, sid,  <span class="math">\\mathcal{C}_{\\mathrm{loc}})</span>  to  <span class="math">\\mathcal{F}_{\\mathrm{N - MC}}^{\\mathrm{bc}}</span>  and proceed from here upon next activation of this procedure. 16: else 17: Evolve the KES signing key by sending (USign, sid,  <span class="math">U_{p},0,\\mathrm{sl})</span>  to  <span class="math">\\mathcal{F}_{\\mathrm{KES}}</span>  and set the anchor at end of procedure to resume on next maintenance activation. end if</p>

    <p class="text-gray-300">Fig. 7. The Ouroboros Genesis staking procedure.</p>

    <p class="text-gray-300">Protocol UpdateStakeDist  <span class="math">(k,U_{p},R,f)</span> 1: Set  <span class="math">\\mathbb{S}_{\\mathrm{ep}}</span>  to be the stakeholder distribution at the end of epoch  <span class="math">\\mathbf{ep} - 2</span>  in  <span class="math">\\mathcal{C}_{\\mathrm{loc}}</span>  in case  <span class="math">\\mathbf{ep}\\geq 2</span>  (and keep the initial stake distribution in case  <span class="math">\\mathbf{ep} &amp;lt; 2</span> ). 2: Set  <span class="math">\\alpha_{p}^{\\mathrm{ep}}</span>  to be the relative stake of  <span class="math">U_{p}</span>  in  <span class="math">\\mathbb{S}_{\\mathrm{ep}}</span>  and  <span class="math">T_{p}^{\\mathrm{ep}}\\gets 2^{\\ell_{\\mathrm{VRF}}}\\phi_{f}(\\alpha_{p}^{\\mathrm{ep}})</span> 3: Set  <span class="math">\\eta_{\\mathrm{ep}}\\gets H(\\eta_{\\mathrm{ep - 1}}\\parallel \\mathrm{ep}\\parallel v)</span>  where  <span class="math">v</span>  is the concatenation of the VRF outputs  <span class="math">y_{\\rho}</span>  from all blocks in  <span class="math">\\mathcal{C}_{\\mathrm{loc}}</span>  from the first  <span class="math">2R / 3</span>  slots of epoch  <span class="math">\\mathbf{ep} - 1</span> OUTPUT: The protocol outputs  <span class="math">\\tau, \\mathbf{ep}, \\mathbf{sl}, \\mathbb{S}_{\\mathrm{ep}}, \\alpha_p^{\\mathrm{ep}}, T_p^{\\mathrm{ep}}</span> , and  <span class="math">\\eta_{\\mathrm{ep}}</span>  to its caller (but not to  <span class="math">\\mathcal{Z}</span> ).</p>

    <p class="text-gray-300">Fig. 8. The protocol for updating the local stake distribution parameters.</p>

    <p class="text-gray-300">Step 2: Filtering out invalid chains. The protocol IsValidChain which filters out invalid chains is the same as the corresponding protocol from [14]. For completeness we include it in Appendix B (see Figure 15).</p>

    <p class="text-gray-300">Step 3: The new chain selection rule. The chain selection rule maxvalid from [14] (which, to avoid confusion, we hereafter refer to as maxvalid-mc for "moving checkpoint", cf. Section 4) prefers longer chains, unless the new chain  <span class="math">\\mathcal{C}_i</span>  forks more than  <span class="math">k</span>  blocks relative to the currently held chain  <span class="math">\\mathcal{C}_{\\mathrm{max}}</span>  (in which case the new chain would be discarded). This so-called moving checkpointing is crucial for the security proof in [14]; indeed, maxvalid-mc only guarantees satisfactory blockchain properties when coupled with a checkpointing functionality that provides newly joining, or re-joining, parties with a recent trusted chain. In particular, such checkpointing provides resilience against so-called "long-range attacks" (see [18] for a detailed discussion).</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Fig. 9. The protocol for updating the time variables.</p>

    <p class="text-gray-300">Our new chain selection rule, formally specified as algorithm maxvalid-bg( <span class="math">\\cdot</span> ) (see Figure 10), surgically adapts maxvalid-mc by adding an additional condition (Condition B). When satisfied, the new condition can lead to a party adopting a new chain  <span class="math">\\mathcal{C}_i</span>  even if this chain did fork more than  <span class="math">k</span>  blocks relative to the currently held chain  <span class="math">\\mathcal{C}_{\\mathrm{max}}</span> . Specifically, the new chain would be preferred if it grows more quickly in the  <span class="math">s</span>  slots following the slot associated with the last block common to both  <span class="math">\\mathcal{C}_i</span>  and  <span class="math">\\mathcal{C}_{\\mathrm{max}}</span>  (here  <span class="math">s</span>  is a parameter of the rule that we discuss in full detail in the proof). Roughly, this "local chain growth"—appearing just after the chains diverge—serves as an indication of the amount of participation in that interval. The intuition behind this criterion is that in a time interval shortly after the two chains diverge, they still agree on the leadership attribution for the upcoming slots, and out of the eligible slot leaders, the (honest) majority has been mostly working on the chain that ended up stabilizing.</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Fig. 10. The new chain selection rule.</p>

    <p class="text-gray-300">Thus the new rule substitutes a "global" longest chain rule with a "local" longest chain rule that prefers chains that demonstrate more participation after forking from the currently held chain  <span class="math">\\mathcal{C}_{\\mathrm{max}}</span> . As proven in Section 4, this additional condition allows an honest party that joins the network at an arbitrary point in time to bootstrap based only on the genesis block (obtained from  <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span> ) and the chains it observes by listening to the network for a sufficiently long period of time. In prior work, a newly spawned party had to be assumed to be bootstrapped by obtaining an honest chain from an external, and fully trusted, mechanism (or, alternatively, be given a list of trustworthy nodes from which to request an honest chain); our solution does not rely on any such assumption. We refer to this process/assumption as checkpointing; provably avoiding this process by means of an updated chain selection rule is one of the major contributions of our work.</p>

    <p class="text-gray-300">The protocol executed by the parties to select a new chain, denoted as SelectChain, can be found in Figure 11.</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> Fig. 11. The protocol for parties to adopt a (new) chain.</p>

    <p class="text-gray-300">We conclude this section by referring to Figure 12 for the technical overview of the main ledger maintenance protocol LedgerMaintenance which makes use of the previously introduced sub-processes.</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> Fig. 12. The main ledger maintenance protocol.</p>

    <p class="text-gray-300">The last command related to the interaction with the ledger is the read command (READ, sid) that is used to read the current contents of the state. Note that in the ideal world, the result of issuing such a command</p>

    <p class="text-gray-300">is for the ledger to output a (long enough prefix) of the current state of the ledger. Analogously, in the real world, the result is for the party receiving it to execute protocol ReadState which works as follows: the party, first, gets up to speed with time, and updates its local blockchain using the blockchains that have been sent to it,[21] and then it computes and outputs the prefix of its local chain (chopping of  <span class="math">k</span>  blocks.) The protocol ReadState is detailed in Figure 13.</p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a> Fig. 13. The protocol for parties to adopt a (new) chain.</p>

    <p class="text-gray-300">We first define the standard security properties of blockchain protocols: common prefix, chain growth and chain quality. While the security guarantees we prove in this paper are formulated in the UC setting, these standalone properties will turn out to be useful tools for our analysis.</p>

    <p class="text-gray-300">Common Prefix (CP); with parameters  <span class="math">k \\in \\mathbb{N}</span> . The chains  <span class="math">\\mathcal{C}_1, \\mathcal{C}_2</span>  possessed by two alert parties at the onset of the slots  <span class="math">\\mathsf{s1}_1 \\leq \\mathsf{s1}_2</span>  are such that  <span class="math">\\mathcal{C}_1^{\\lceil k \\rceil} \\preceq \\mathcal{C}_2</span> , where  <span class="math">\\mathcal{C}_1^{\\lceil k \\rceil}</span>  denotes the chain obtained by removing the last  <span class="math">k</span>  blocks from  <span class="math">\\mathcal{C}_1</span> , and  <span class="math">\\preceq</span>  denotes the prefix relation.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Chain Growth (CG); with parameters  <span class="math">\\tau \\in (0,1]</span>  and  <span class="math">s\\in \\mathbb{N}</span> . Consider a chain  <span class="math">\\mathcal{C}</span>  possessed by an alert party at the onset of a slot  <span class="math">\\mathsf{s1}</span> . Let  <span class="math">\\mathsf{s1}_1</span>  and  <span class="math">\\mathsf{s1}_2</span>  be two previous slots for which  <span class="math">\\mathsf{s1}_1 + s\\leq \\mathsf{s1}_2\\leq \\mathsf{s1}</span> , so  <span class="math">\\mathsf{s1}_1</span>  is at least  <span class="math">s</span>  slots prior to  <span class="math">\\mathsf{s1}_2</span> . Then  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}[\\mathsf{s1}_1:\\mathsf{s1}_2]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\tau \\cdot s<span class="math"> . We call  </span>\\tau$  the speed coefficient.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Chain Quality (CQ); with parameters  <span class="math">\\mu \\in (0,1]</span>  and  <span class="math">k\\in \\mathbb{N}</span> . Consider any portion of length at least  <span class="math">k</span>  of the chain possessed by an alert party at the onset of a slot; the ratio of blocks originating from alert parties in this portion is at least  <span class="math">\\mu</span> . We call  <span class="math">\\mu</span>  the chain quality coefficient.</p>

    <p class="text-gray-300">Note that previous work identified and studied a stronger version of chain growth (denoted below as CG2), which controls the relative growth of chains held by potentially distinct honest parties.</p>

    <p class="text-gray-300">(Strong) Chain Growth (CG2); with parameters  <span class="math">\\tau \\in (0,1]</span>  and  <span class="math">s\\in \\mathbb{N}</span> . Consider the chains  <span class="math">\\mathcal{C}_1,\\mathcal{C}_2</span>  possessed by two alert parties at the onset of two slots  <span class="math">\\mathsf{s1}_1,\\mathsf{s1}_2</span>  with  <span class="math">\\mathsf{s1}_1</span>  at least  <span class="math">s</span>  slots prior to  <span class="math">\\mathsf{s1}_2</span> . Then it holds that  <span class="math">\\mathsf{len}(\\mathcal{C}_2) - \\mathsf{len}(\\mathcal{C}_1)\\geq \\tau \\cdot s</span> . We call  <span class="math">\\tau</span>  the speed coefficient.</p>

    <p class="text-gray-300">We remark that the notion of chain growth CG2 follows from CP and CG (with some appropriate decay in parameters). However, it appears that CG is a preferable formulation in our setting, as it can be established with stronger parameters than CG2 and more naturally dovetails with several aspects of the security proofs.</p>

    <p class="text-gray-300">Finally, we will also consider a slight variant of chain quality called existential chain quality:</p>

    <p class="text-gray-300">xistential Chain Quality (<span class="math">\\exists</span>CQ); with parameter <span class="math">s\\in\\mathbb{N}</span>. Consider a chain <span class="math">\\mathcal{C}</span> possessed by an alert party at the onset of a slot <span class="math">\\mathtt{sl}</span>. Let <span class="math">\\mathtt{sl}_{1}</span> and <span class="math">\\mathtt{sl}_{2}</span> be two previous slots for which <span class="math">\\mathtt{sl}_{1}+s\\leq\\mathtt{sl}_{2}\\leq\\mathtt{sl}</span>. Then <span class="math">\\mathcal{C}[\\mathtt{sl}_{1}:\\mathtt{sl}_{2}]</span> contains at least one alertly generated block.</p>

    <p class="text-gray-300">As a side remark, the CG (resp. CQ) property follows from <span class="math">\\exists</span>CQ and an additional property called <em>honest-bounded chain growth</em> HCG (resp. <em>honest-bounded chain quality</em>, HCQ). We define HCG and HCQ and establish these relationships in Appendix E.5.</p>

    <p class="text-gray-300">Note that typically these security properties for blockchain protocols are formulated so that they grant the above-described guarantees to all <em>honest</em> parties. However, in our more fine-grained modeling of parties’ availability, a natural choice is to analyze these properties for the <em>alert</em> parties only. In particular, the properties CQ and <span class="math">\\exists</span>CQ guarantee sufficient presence of blocks generated by alert parties in the chain, i.e., generated by parties that were fully up-to-date with the state of the protocol and capable of contributing to it. In the following treatment, we often talk about <em>honestly-generated blocks</em>, but this always refers to blocks generated by such alert parties. Similarly, <em>adversarial blocks</em> don’t necessarily have to come from corrupted parties, rather from any parties that are not fully alert.</p>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">4.2 Security of Ouroboros Genesis with maxvalid-mc</h3>

    <p class="text-gray-300">The original Ouroboros Praos protocol given in <em>[14]</em> differs from Ouroboros Genesis in a single point: it employs a different chain selection rule, which we call maxvalid-mc here and outline below. The difference in maxvalid-mc compared to maxvalid-bg is that if the considered chain <span class="math">\\mathcal{C}_{i}</span> forks from the current chain <span class="math">\\mathcal{C}_{\\mathsf{loc}}</span> more than <span class="math">k</span> blocks in the past, it is immediately discarded, without evaluating Condition B as in maxvalid-bg. This can be seen as a “moving checkpoint” <span class="math">k</span> blocks behind the current tip of the chain, which is what the suffix “-mc” stands for. To preserve clarity, we will use Ouroboros-Praos to refer to the protocol that is identical to the one given in Section 3 except that is uses maxvalid-mc instead of maxvalid-bg as its chain-selection rule.</p>

    <p class="text-gray-300">⬇ Protocol maxvalid-mc(<span class="math">\\mathcal{C}_{\\mathsf{loc}},\\mathcal{C}_{1},\\ldots,\\mathcal{C}_{t}</span>) 1: Set <span class="math">\\mathcal{C}_{\\mathsf{max}}\\leftarrow\\mathcal{C}_{\\mathsf{loc}}</span>. 2: for <em><span class="math">i=1</span> to <span class="math">\\ell</span></em> do 3: if lsValidChain(<span class="math">\\mathcal{C}_{i}</span>) then // Compare <span class="math">\\mathcal{C}_{\\mathsf{max}}</span> to <span class="math">\\mathcal{C}_{i}</span> 4: if (<span class="math">\\mathcal{C}_{i}</span> forks from <span class="math">\\mathcal{C}_{\\mathsf{max}}</span> at most <span class="math">k</span> blocks) then</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5: if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathsf{max}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ then // Condition A</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Set <span class="math">\\mathcal{C}_{\\mathsf{max}}\\leftarrow\\mathcal{C}_{i}</span>. end if end if end if end for 6: return <span class="math">\\mathcal{C}_{\\mathsf{max}}</span>.</p>

    <p class="text-gray-300">Our first goal is to establish that the useful properties of common prefix, chain growth, and chain quality are achieved by Ouroboros-Praos, when executed in a slightly restricted environment. Namely, we start by assuming that all parties participate in the protocol run from the beginning and never get deregistered from the network <span class="math">\\mathcal{F}_{\\text{N-MC}}</span> (i.e., honest parties are always <em>online</em>); we refer to this setting as the <em>setting with static <span class="math">\\mathcal{F}_{\\text{N-MC}}</span>-registration</em>. We will drop this assumption later.</p>

    <p class="text-gray-300">The desired statement for this limited environment is given in Theorem 1, the rest of Section 4.2 will be dedicated to sketching its proof, which is fully spelled out in Appendix E. First, we need to define some relevant quantities.</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Definition 1 (Classes of parties and their relative stake)</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{P}[t]</span> denote the set of all parties in slot <span class="math">t</span>, and let <span class="math">\\mathcal{P}_{\\text{type}}[t]</span> for any type of party described in Figure 1 (e.g. alert, active) denote the set of all parties</p>

    <p class="text-gray-300">of the respective type in slot <span class="math">t</span>. For a set of parties <span class="math">\\mathcal{P}_{\\textsf{type}}[t]</span>, let <span class="math">\\mathcal{S}^{-}(\\mathcal{P}_{\\textsf{type}}[t])\\in[0,1]</span> (resp. <span class="math">\\mathcal{S}^{+}(\\mathcal{P}_{\\textsf{type}}[t])\\in[0,1]</span>) denote the minimum (resp., maximum), taken over the views of all alert parties, of the total relative stake of all the parties in <span class="math">\\mathcal{P}_{\\textsf{type}}[t]</span> in the stake distribution used for sampling the slot leaders in slot <span class="math">t</span>.</p>

    <p class="text-gray-300">Looking ahead, we remark that even though we give the general definition above, our protocol will have the property that for all party types and all time slots, <span class="math">\\mathcal{S}^{-}(\\mathcal{P}_{\\textsf{type}}[t])=\\mathcal{S}^{+}(\\mathcal{P}_{\\textsf{type}}[t])</span> with overwhelming probability, as all the alert parties will agree on the distribution used for sampling slot leaders with overwhelming probability.</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Definition 2 (Alert ratio, participating ratio).</h6>

    <p class="text-gray-300">At any time slot <span class="math">t</span> during the execution, we let:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the alert stake ratio be the fraction <span class="math">\\mathcal{S}^{-}(\\mathcal{P}_{\\text{alert}}[t])/\\mathcal{S}^{+}(\\mathcal{P}_{\\text{active}}[t])</span>; and</li>

      <li>the (potentially) participating stake ratio be the fraction <span class="math">\\mathcal{S}^{-}(\\mathcal{P}_{\\text{active}}[t])</span>.</li>

    </ul>

    <p class="text-gray-300">It is instructive to see that the potentially active stake ratio allows to conclude the ratio of stake belonging to parties that cannot participate in slot <span class="math">t</span>.</p>

    <p class="text-gray-300">Note that in the setting with static <span class="math">\\mathcal{F}_{\\text{N-MC}}</span>-registration, all honest parties are online from the beginning, and therefore also synchronized. The set of active parties hence consists only of alert, adversarial and time-unaware parties. In the general case it also contains honest parties that are online but desynchronized, we will discuss these in detail in Section 4.4.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">Consider the execution of Ouroboros-Praos with adversary <span class="math">\\mathcal{A}</span> and environment <span class="math">\\mathcal{Z}</span> in the setting with static <span class="math">\\mathcal{F}_{\\text{\\tiny N-MC}}</span>-registration. Let <span class="math">f</span> be the active-slot coefficient, let <span class="math">\\Delta</span> be the upper bound on the network delay and let <span class="math">Q</span> be an upper bound on the total number of queries issued to <span class="math">\\mathcal{G}_{\\text{\\tiny RO}}</span>. Let <span class="math">\\alpha,\\beta\\in[0,1]</span> denote a lower bound on the alert ratio and participating ratio throughout the whole execution, respectively. Let <span class="math">R</span> and <span class="math">L</span> denote the epoch length and the total lifetime of the system (in slots). If for some <span class="math">\\epsilon\\in(0,1)</span> we have</p>

    <p class="text-gray-300"><span class="math">\\alpha\\cdot(1-f)^{\\Delta+1}\\geq(1+\\epsilon)/2\\,,</span> (4)</p>

    <p class="text-gray-300">and <span class="math">R\\geq 144\\Delta/\\epsilon\\beta f</span> then Ouroboros-Praos achieves the following guarantees:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Common prefix. The probability that Ouroboros-Praos violates the common prefix property with parameter <span class="math">k</span> is no more than</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\epsilon_{\\textsf{CP}}(k)\\triangleq\\frac{19L}{\\epsilon^{4}}\\exp(\\Delta-\\epsilon^{4}k/18)+\\epsilon_{\\textsf{lift}}\\;;</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Chain growth. The probability that Ouroboros-Praos violates the chain growth property with parameters <span class="math">s\\geq 48\\Delta/(\\epsilon\\beta f)</span> and <span class="math">\\tau_{\\textsf{CG}}=\\beta f/16</span> is no more than</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\epsilon_{\\textsf{CG}}(\\tau_{\\textsf{CG}},s)\\triangleq\\frac{sL^{2}}{2}\\exp\\left(-(\\epsilon\\beta f)^{2}s/256\\right)+\\epsilon_{\\textsf{lift}}\\;;</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Existential chain quality. The probability that Ouroboros-Praos violates the existential chain quality property with parameter <span class="math">s\\geq 12\\Delta/(\\epsilon\\beta f)</span> is no more than</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\epsilon_{\\text{\\ref{3CQ}}}(s)\\triangleq(s+1)L^{2}\\exp\\left(-(\\epsilon\\beta f)^{2}s/64\\right)+\\epsilon_{\\textsf{lift}}\\;;</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Chain quality. The probability that Ouroboros-Praos violates the chain quality property with parameters <span class="math">k\\geq 48\\Delta/(\\epsilon\\beta f)</span> and <span class="math">\\mu=\\epsilon\\beta f/16</span> is no more than</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\epsilon_{\\textsf{CQ}}(\\mu,k)\\triangleq\\frac{kL^{2}}{2}\\exp\\left(-(\\epsilon\\beta f)^{2}k/256\\right)+\\epsilon_{\\textsf{lift}}\\;;</span></p>

    <p class="text-gray-300">where <span class="math">\\epsilon_{\\textsf{lift}}</span> is a shorthand for the quantity</p>

    <p class="text-gray-300"><span class="math">\\epsilon_{\\textsf{lift}}\\triangleq QL\\cdot\\left[R^{3}\\cdot\\exp\\left(-\\frac{(\\epsilon\\beta f)^{2}R}{768}\\right)+\\frac{38R}{\\epsilon^{4}}\\cdot\\exp\\left(\\Delta-\\frac{\\epsilon^{4}\\beta fR}{864}\\right)\\right]\\;.</span></p>

    <p class="text-gray-300">roof (sketch). The proof is inspired by the proof of property-based security of Ouroboros Praos given in <em>[14]</em>; however, a major extension of the techniques is necessary. To appreciate the need for this extension, let us first recall in very broad terms how the proof in <em>[14]</em> proceeds:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First, the above security properties (or slight variations of them, cf. Section 4.1) are proven for a single epoch. For this, the dynamics of the protocol execution is abstracted into combinatorial objects called forks, while the slot leader selection (assuming static corruption) is captured by sampling a so-called characteristic string.</li>

      <li>A recursive rule is given that identifies whether a characteristic string allows for “dangerous” forks, and a probabilistic analysis shows that under static corruption, leader schedules corresponding to such characteristic strings are extremely rare.</li>

      <li>Given the rarity of such undesirable characteristic strings, the CP, CG, and CQ properties are established for a single epoch and a static-corruption adversary.</li>

      <li>The analysis is generalized to fully adaptive corruption by showing a static-corruption adversary that dominates any adaptive one.</li>

      <li>The analysis is extended to an arbitrary number of epochs by analyzing the subprotocol for generating new randomness to be used in the following epoch to sample the leader schedule.</li>

    </ol>

    <p class="text-gray-300">The main improvement of Theorem 1 over the analysis in <em>[14]</em> is that it captures stalled and time-unaware parties (and making honest parties stalled or time-unaware is a fully adaptive decision of the environment). This is done in two different ways: broadly speaking, while stalled parties don’t pose a threat as long as the majority of active parties is honest, time-unaware parties are problematic (as they cannot evolve their keys) and have to be counted as adversarial until they regain their time-awareness.</p>

    <p class="text-gray-300">Unfortunately, the adaptive nature of the above environment’s control makes it impossible to start with a static analysis of the slot-leader selection as done above in steps 1–3. Moreover, the argument in step 4 completely breaks down as the static adversary given in <em>[14]</em> no longer dominates any possible adaptive combination of corruption and stalling. Therefore, our proof needs to revisit the steps 1–4 and replace the analysis of a sequence of binomially distributed random variables (representing the characteristic string) by considering inter-slot dependence right from the beginning. This is done via a martingale framework that is an important contribution of this paper and might prove useful also outside of the analysis of the Ouroboros protocols. We give all the details of our approach in Appendix E, where we also describe the parts of the framework from <em>[14]</em> that are necessary to follow our proof. ∎</p>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">4.3 Adopting the New maxvalid-bg Rule</h3>

    <h6 id="sec-37" class="text-base font-medium mt-4">Theorem 2.</h6>

    <p class="text-gray-300">Consider the protocol Ouroboros-Genesis using maxvalid-bg as described in Section 3, executed in the setting with static <span class="math">\\mathcal{F}_{\\text{\\tiny{N-MC}}}</span>-registration, under the same assumptions as in Theorem 1. If the maxvalid-bg parameters, <span class="math">k</span> and <span class="math">s</span>, satisfy</p>

    <p class="text-gray-300"><span class="math">k&gt;192\\Delta/(\\epsilon\\beta)\\qquad\\text{and}\\qquad R/6\\geq s=k/(4f)\\geq 48\\Delta/(\\epsilon\\beta f)</span></p>

    <p class="text-gray-300">then the guarantees given in Theorem 1 for common prefix, chain growth, chain quality, and existential chain quality are still valid except for an additional error probability</p>

    <p class="text-gray-300"><span class="math">\\exp\\left(\\ln L-\\Omega(k)\\right)+\\epsilon_{\\text{\\tiny{CG}}}(\\beta f/16,k/(4f))+\\epsilon_{\\text{\\tiny{3CQ}}}(k/(4f))+\\epsilon_{\\text{\\tiny{CP}}}(k\\beta/64)\\;.</span> (5)</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We show that when replacing maxvalid-mc with maxvalid-bg, the overall execution of the protocol remains the same except with negligible probability. To see this, consider a run of the protocol with maxvalid-mc, and let <span class="math">\\texttt{s1}_{b}</span> denote the first slot when any honest party discards a received candidate chain <span class="math">\\mathcal{C}_{\\text{\\tiny{cand}}}</span> (longer than <span class="math">\\mathcal{C}_{\\text{\\tiny{loc}}}</span>) because it forks from its <span class="math">\\mathcal{C}_{\\text{\\tiny{loc}}}</span> by more than <span class="math">k</span> blocks, as described by maxvalid-mc. Until <span class="math">\\texttt{s1}_{b}</span>, the whole execution would proceed identically if parties were using maxvalid-bg instead, as in both cases they would always prefer the longer of the compared chains using Condition A.</p>

    <p class="text-gray-300">Consider now the decision that a party running maxvalid-bg would make regarding this chain <span class="math">\\mathcal{C}_{\\text{\\tiny{cand}}}</span> in the slot <span class="math">\\texttt{s1}_{b}</span>. We will argue that it will also favor <span class="math">\\mathcal{C}_{\\text{\\tiny{loc}}}</span> with overwhelming probability. This will then imply the</p>

    <p class="text-gray-300">full statement, as the reasoning can be applied inductively to each of the slots where maxvalid-mc discards a longer chain, throughout the whole execution.</p>

    <p class="text-gray-300">Let <span class="math">\\mathtt{sl}_{a}</span> be the slot associated with the last common block of <span class="math">\\mathcal{C}_{\\mathtt{loc}}</span> and <span class="math">\\mathcal{C}_{\\mathtt{cand}}</span>. Recall that by the design of the protocol (independently of the underlying maxvalid rule), for every slot <span class="math">\\mathtt{sl}_{i}</span> there is an event <span class="math">E_{i}</span> such that: (i.) <span class="math">\\Pr[E_{i}]=1-f</span>; (ii.) the events <span class="math">E_{1},E_{2},\\ldots</span> are independent; (iii.) if <span class="math">E_{i}</span> occurs, then no valid block can be created for the slot <span class="math">\\mathtt{sl}_{i}</span>. Therefore, using a Chernoff bound (cf. Appendix F) and a union bound over the running time <span class="math">L</span> of the system, we can also lower-bound the number of slots between <span class="math">\\mathtt{sl}_{a}</span> and <span class="math">\\mathtt{sl}_{b}</span> as <span class="math">a-b\\geq k/(2f)</span>, except with error probability <span class="math">\\exp\\left(\\ln L-\\Omega(k)\\right)</span>. For the remainder of the proof, we will assume that the execution satisfies this property (that is, <span class="math">\\mathtt{sl}_{b}-\\mathtt{sl}_{a}&gt;k/(2f)</span> for all pairs of slots bounding <span class="math">k</span> blocks on an honestly held chain) and, further, that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>there is no <span class="math">k\\beta/64</span>-CP violation;</li>

      <li>there is no <span class="math">s</span>-<span class="math">\\exists</span>CQ violation; and</li>

      <li>there is no <span class="math">(\\beta f/16,s)</span>-CG violation.</li>

    </ul>

    <p class="text-gray-300">As indicated in the statement of the theorem, <span class="math">s</span> is fixed to be <span class="math">k/(4f)</span>. Observe that the error probabilities associated with these events are then precisely those appearing in (5).</p>

    <p class="text-gray-300">By the definition of maxvalid-bg, the chain <span class="math">\\mathcal{C}_{\\mathtt{cand}}</span> can only be adopted in favor of <span class="math">\\mathcal{C}_{\\mathtt{loc}}</span> if</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathtt{cand}}[0:\\mathtt{sl}_{a}+s]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathtt{loc}}[0:\\mathtt{sl}_{a}+s]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$ (6)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We will show that under the assumptions described above, this is not possible. For convenience, we consider two disjoint, consecutive subintervals of <span class="math">(\\mathtt{sl}_{a},\\mathtt{sl}_{b}]</span>:</p>

    <p class="text-gray-300"><span class="math">I_{\\text{growth}}=(\\mathtt{sl}_{a},\\mathtt{sl}_{a}+s]\\qquad\\text{and}\\qquad I_{\\text{stabilize}}=(\\mathtt{sl}_{a}+s,\\mathtt{sl}_{a}+2s]\\,.</span> (7)</p>

    <p class="text-gray-300">Note that by the choice of <span class="math">s</span>, both <span class="math">I_{\\text{growth}}</span> and <span class="math">I_{\\text{stabilize}}</span> are indeed subintervals of <span class="math">(\\mathtt{sl}_{a},\\mathtt{sl}_{b}]</span>. Moreover, since <span class="math">2s\\leq R/3</span>, the chains <span class="math">\\mathcal{C}_{\\mathtt{loc}}</span> and <span class="math">\\mathcal{C}_{\\mathtt{cand}}</span> use the same stake distribution and randomness to determine slot leaders for the interval <span class="math">I_{\\text{growth}}\\cup I_{\\text{stabilize}}</span>.</p>

    <p class="text-gray-300">First, we observe that <span class="math">\\mathcal{C}_{\\mathtt{loc}}</span> exhibits significant growth over the interval <span class="math">I_{\\text{growth}}</span>: specifically, by the chain growth property established in Theorem 1 and the assumption <span class="math">s=k/(4f)\\geq 48\\varDelta/(\\epsilon\\beta f)</span>, we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathtt{loc}}[I_{\\text{growth}}]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq s\\beta f/16=k\\beta/64\\,.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Similarly, observe that <span class="math">\\mathcal{C}_{\\mathtt{loc}}</span> possesses at least one honestly-generated block over the interval <span class="math">I_{\\text{stabilize}}</span>: specifically, by the existential chain quality property established in Theorem 1 and the assumption <span class="math">s=k/(4f)\\geq 24\\varDelta/(\\epsilon\\beta f)</span>, there must exists a slot <span class="math">\\mathtt{sl}^{<em>}\\in I_{\\text{stabilize}}</span> for which <span class="math">\\mathcal{C}_{\\mathtt{loc}}[\\mathtt{sl}^{</em>}]</span> was honestly generated.</p>

    <p class="text-gray-300">To complete the argument, we observe that the assertion (6) would yield a violation of common prefix. To argue this, we take advantage of the notions of characteristic strings, forks, (viable) tines and divergence, defined in Appendix E.1.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Specifically, consider the characteristic string <span class="math">W</span> and the fork <span class="math">F\\vdash_{\\varDelta}W</span> associated with this execution of the protocol. (The fork <span class="math">F</span> reflects all valid chains adopted by honest players during the execution—the local chains that result from application of the maxvalid rule.) Let <span class="math">t_{\\text{loc}}</span> denote the tine associated with the chain <span class="math">\\mathcal{C}_{\\mathtt{loc}}[0:\\mathtt{sl}^{<em>}-1]</span> and <span class="math">t_{\\text{cand}}</span> denote the tine associated with the chain <span class="math">\\mathcal{C}_{\\mathtt{cand}}[0:\\mathtt{sl}_{a}+s]</span>. The tine <span class="math">t_{\\text{loc}}</span> is viable, as the honest leader associated with <span class="math">\\mathtt{sl}^{</em>}</span> chose <span class="math">\\mathcal{C}_{\\mathtt{loc}}</span> to extend. To construct a viable tine from <span class="math">t_{\\text{cand}}</span>, we extend it using the adversarial slots associated with the portion of <span class="math">t_{\\text{loc}}</span> in <span class="math">I_{\\text{stabilize}}</span>. Specifically, recalling that <span class="math">\\mathtt{sl}^{<em>}</span> is associated with the first honestly generated block of <span class="math">\\mathcal{C}_{\\mathtt{loc}}</span> in <span class="math">I_{\\text{stabilize}}</span>, any blocks of <span class="math">\\mathcal{C}_{\\mathtt{loc}}</span> associated with slots in the interval <span class="math">(\\mathtt{sl}_{a}+s,\\mathtt{sl}^{</em>})</span> are associated with adversarial slots of <span class="math">W</span>, and we may use these adversarial slots to extend <span class="math">t_{\\text{cand}}</span>: Let <span class="math">\\widehat{t}_{\\text{cand}}</span> denote the extension of the tine <span class="math">t_{\\text{cand}}</span> formed by adding an adversarial node for each slot in <span class="math">(\\mathtt{sl}_{a}+s,\\mathtt{sl}^{*})</span> associated with a block of <span class="math">t_{\\text{loc}}</span>. Note, also, that <span class="math">\\widehat{t}_{\\text{cand}}</span> is viable, as <span class="math">\\mathtt{length}(\\widehat{t}_{\\text{cand}})&gt;\\mathtt{length}(t_{\\text{loc}})</span>. (Note that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathtt{loc}}[0:\\mathtt{sl}_{a}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathtt{cand}}[0:\\mathtt{sl}_{a}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> by assumption, and the tines </span>t_{\\text{loc}}<span class="math"> and </span>t_{\\text{cand}}<span class="math"> have the same number of blocks in the region </span>(\\mathtt{sl}_{a}+s,\\mathtt{sl}^{*})<span class="math">.) Thus these two tines form a divergence-violation (that is, a CP-violation) with parameter </span>\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathtt{loc}}[\\mathtt{sl}_{a}+1,\\mathtt{sl}_{a}+s]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq s\\beta f/16=k\\beta/64$ (by the chain growth guarantee above).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">4.4 Newly Joining Parties</p>

    <p class="text-gray-300">In this section we prove that the guarantees on common prefix, chain growth and (existential) chain quality obtained for Ouroboros-Genesis in Section 4.3 remain valid also when new parties join the protocol later during its execution.</p>

    <p class="text-gray-300">To capture this, we proceed as follows. For any new party <span class="math">U</span> that joins the protocol later during its execution (say at slot <span class="math">\\mathfrak{sl}_{\\text{join}}</span>), we consider a “virtual” party <span class="math">\\tilde{U}</span> that holds no stake, but was participating in the protocol since the beginning and was alert all the time. Moreover, we assume that starting from <span class="math">\\mathfrak{sl}_{\\text{join}}</span>, <span class="math">\\tilde{U}</span> is receiving the same messages (in the same slots) as <span class="math">U</span>. Clearly, the run of the protocol up to <span class="math">\\mathfrak{sl}_{\\text{join}}</span> would look the same with and without <span class="math">\\tilde{U}</span>, as <span class="math">\\tilde{U}</span> would never be elected a slot leader, and would not affect <span class="math">\\alpha</span> or <span class="math">\\beta</span>. Therefore, the execution of the protocol up to the point when the first party <span class="math">U</span> tries to join is covered by the statements proven in Section 4.3 (even when also considering the participation of <span class="math">\\tilde{U}</span>).</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Definition 3 (Adopting and discarding chains).</h6>

    <p class="text-gray-300">We say that an honest party <em>adopts</em> a chain <span class="math">\\mathcal{C}</span> when an execution of the procedure maxvalid-bg by this party returns <span class="math">\\mathcal{C}</span>. An honest party <em>discards</em> a chain <span class="math">\\mathcal{C}</span> when an execution of the procedure maxvalid-bg by this party takes <span class="math">\\mathcal{C}</span> as one of its inputs, but does not output <span class="math">\\mathcal{C}</span>.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Definition 4 (Virtual executions and virtual parties).</h6>

    <p class="text-gray-300">We say that an honest party <span class="math">U</span> is <em>joining the protocol execution</em> at slot <span class="math">\\mathfrak{sl}_{\\text{join}}</span> if <span class="math">\\mathfrak{sl}_{\\text{join}}</span> is the slot in which <span class="math">U</span> becomes operational, time-aware and online for the first time. For a party <span class="math">U</span> joining the execution <span class="math">\\mathcal{E}</span> of the protocol Ouroboros-Genesis at slot <span class="math">\\mathfrak{sl}_{\\text{join}}</span>, consider an execution <span class="math">\\mathcal{E}^{\\prime}</span> that only differs from <span class="math">\\mathcal{E}</span> by one additional party <span class="math">\\tilde{U}</span> being present from the beginning, registering <span class="math">0</span> stake, remaining alert throughout the execution, and receiving the same messages as <span class="math">U</span> from <span class="math">\\mathfrak{sl}_{\\text{join}}</span> on. We call <span class="math">\\mathcal{E}^{\\prime}</span> (resp. <span class="math">\\tilde{U}</span>) the <em>virtual execution</em> (resp. the <em>virtual party</em>) for <span class="math">U</span>.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Definition 5 (Synchronizing chains).</h6>

    <p class="text-gray-300">We call (a message containing) a chain <span class="math">\\mathcal{C}_{\\text{sync}}</span> <em>synchronizing for</em> <span class="math">U</span>, if this is the first chain that its virtual party <span class="math">\\tilde{U}</span> adopts after slot <span class="math">\\mathfrak{sl}_{\\text{join}}</span>.</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Definition 6 (Synchronized parties).</h6>

    <p class="text-gray-300">A party <span class="math">U</span> is called <em>synchronized</em> at time <span class="math">t</span> (cf. Fig. 1) with respect to synchronization parameter <span class="math">t_{\\text{sync}}\\geq 0</span>, if either <span class="math">U</span> has been online and time-aware since the beginning; or the last time it registered to the network <span class="math">\\mathcal{F}_{\\text{N-MC}}</span> was at time <span class="math">t_{0}</span> and there is a slot <span class="math">t_{1}\\in\\{t_{0},\\ldots,t-t_{\\text{sync}}\\}</span> such that the following conditions are satisfied:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">U</span> has been online and time-aware since <span class="math">t_{1}</span>;</li>

      <li><span class="math">U</span> was operational in slots <span class="math">t_{1},\\ldots,t_{1}+t_{\\text{sync}}-1</span>.</li>

    </ol>

    <p class="text-gray-300">Otherwise, the party is called <em>desynchronized</em>.</p>

    <p class="text-gray-300">The above definition leaves flexibility when a party is considered synchronized, or more importantly, for how long after joining it is considered de-synchronized. Note that during the time a party is de-synchronized, the bad impact on the protocol run is that it could potentially extend chains that are purely adversarial. Thus, a lower value of <span class="math">t_{\\text{sync}}</span> is generally preferable to get a stronger statement, but could come at the cost of higher network traffic. Before we instantiate the parameter <span class="math">t_{\\text{sync}}</span> of Definition 6 for the specific case of Ouroboros Genesis, which is done in Lemma 2, we first need to examine the joining process in general.</p>

    <p class="text-gray-300">In the following, whenever we refer to the set of synchronized/desynchronized parties, we implicitly refer to a generic synchronization parameter <span class="math">t_{\\text{sync}}</span>.</p>

    <p class="text-gray-300">The heart of our argument for newly joining parties is captured in the following lemma.</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Lemma 1.</h6>

    <p class="text-gray-300">In the same setting as Theorem 2 but with dynamic <span class="math">\\mathcal{F}_{\\text{\\tiny N-MC}}</span>-registrations, any newly joining party that remains operational, time-aware and online until it receives its synchronizing chain, will adopt it except with probability (5).</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We assume that none of the bad events considered in the proof of Theorem 2 occurs. Let <span class="math">U</span> be a new party joining the protocol at slot <span class="math">\\mathfrak{sl}_{\\text{join}}</span>. Moreover, let <span class="math">U</span> be the first such party in this execution, the argument can then inductively be applied to other parties joining later.</p>

    <p class="text-gray-300">Consider the virtual execution <span class="math">\\mathcal{E}^{\\prime}</span> for <span class="math">U</span>, let <span class="math">\\tilde{U}</span> be its corresponding virtual party, let <span class="math">\\mathcal{C}_{\\text{sync}}</span> be its synchronizing chain, and let <span class="math">\\mathfrak{sl}_{\\text{sync}}</span> be the slot in which <span class="math">U</span> and <span class="math">\\tilde{U}</span> receive <span class="math">\\mathcal{C}_{\\text{sync}}</span>. For the sake of contradiction, assume that <span class="math">U</span> does not adopt <span class="math">\\mathcal{C}_{\\text{sync}}</span>, and let <span class="math">\\mathcal{C}_{1}</span> denote the chain that <span class="math">U</span> is holding as its local chain <span class="math">\\mathcal{C}_{\\text{loc}}</span> when running maxvalid-bg in slot <span class="math">\\mathfrak{sl}_{\\text{sync}}</span>. Additionally, let <span class="math">\\mathfrak{sl}_{j_{1}}</span> denote the slot that contains the last common block of <span class="math">\\mathcal{C}_{1}</span> and <span class="math">\\mathcal{C}_{\\text{sync}}</span>. Finally, let <span class="math">\\mathcal{C}_{2}</span> denote the chain that <span class="math">\\tilde{U}</span> is holding as its local chain <span class="math">\\mathcal{C}_{\\text{loc}}</span> when running maxvalid-bg in slot <span class="math">\\mathfrak{sl}_{\\text{sync}}</span>. As <span class="math">\\mathcal{C}_{\\text{sync}}</span> is the first chain <span class="math">\\tilde{U}</span> adopts after <span class="math">\\mathfrak{sl}_{\\text{join}}</span>, we know that <span class="math">\\mathcal{C}_{2}</span> was adopted by <span class="math">\\tilde{U}</span> before <span class="math">\\mathfrak{sl}_{\\text{join}}</span>. Let <span class="math">\\mathfrak{sl}_{j_{2}}</span> denote the slot that contains the last common block of <span class="math">\\mathcal{C}_{2}</span> and <span class="math">\\mathcal{C}_{\\text{sync}}</span>.</p>

    <p class="text-gray-300">We have to analyze two possible cases here, depending on which condition in the procedure maxvalid-bg was used by <span class="math">U</span> to discard <span class="math">\\mathcal{C}_{\\text{sync}}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">U</span> discards <span class="math">\\mathcal{C}_{\\text{sync}}</span> using Condition A. Since Condition A was invoked, this means that <span class="math">\\#_{j_{1}:\\text{sync}}(\\mathcal{C}_{1})\\leq k</span>, and since <span class="math">\\mathcal{C}_{\\text{sync}}</span> was discarded, we have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\text{sync}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">However, since <span class="math">\\tilde{U}</span> adopted <span class="math">\\mathcal{C}_{\\text{sync}}</span>, we argue that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\text{sync}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. This holds because </span>\\tilde{U}<span class="math"> always adopts a new chain using Condition A, which is a direct consequence of the arguments given in the proof of Theorem 2. Hence, we can derive </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. To obtain a contradiction with the fact that </span>\\tilde{U}<span class="math"> did not adopt </span>\\mathcal{C}_{1}<span class="math"> to replace </span>\\mathcal{C}_{2}<span class="math">, we only need to show that when it received </span>\\mathcal{C}_{1}<span class="math"> it used Condition A to make its adoption decision, i.e., that </span>\\mathcal{C}_{1}<span class="math"> does not fork more than </span>k<span class="math"> blocks back from </span>\\mathcal{C}_{2}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This can be shown by case analysis. We need to consider two subcases:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Case <span class="math">j_{1}\\leq j_{2}</span>: This means that <span class="math">\\mathcal{C}_{2}</span> forks from <span class="math">\\mathcal{C}_{\\text{sync}}</span> not earlier than <span class="math">\\mathcal{C}_{1}</span> does and hence <span class="math">\\mathcal{C}_{1}</span> forks from <span class="math">\\mathcal{C}_{2}</span> in slot <span class="math">\\mathfrak{sl}_{j_{1}}</span>. Since we know that <span class="math">\\#_{j_{1}:\\text{sync}}(\\mathcal{C}_{1})\\leq k</span> and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\text{sync}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, we can easily conclude </span>\\#_{j_{1}:\\text{sync}}(\\mathcal{C}_{2})\\leq k$ in this case.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Case <span class="math">j_{1}&gt;j_{2}</span>: Here <span class="math">\\mathcal{C}_{2}</span> forks from <span class="math">\\mathcal{C}_{\\text{sync}}</span> earlier than <span class="math">\\mathcal{C}_{1}</span>, and hence <span class="math">\\mathcal{C}_{1}</span> forks from <span class="math">\\mathcal{C}_{2}</span> in slot <span class="math">\\mathfrak{sl}_{j_{2}}</span>. The desired inequality <span class="math">\\#_{j_{2}:\\text{sync}}(\\mathcal{C}_{2})\\leq k</span> in this case follows from the common prefix property.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">U</span> discards <span class="math">\\mathcal{C}_{\\text{sync}}</span> using Condition B. The contradiction in this case is obtained by using exactly the same argument as in the proof of Theorem 2 to show that if <span class="math">U</span> invokes Condition B on <span class="math">\\mathcal{C}_{\\text{sync}}</span>, it must actually adopt it.</li>

    </ul>

    <p class="text-gray-300">Namely, observe that we have <span class="math">\\#_{j_{1}:\\text{sync}}(\\mathcal{C}_{1})&gt;k</span> and hence with overwhelming probability <span class="math">\\text{sync}-j_{1}&gt;k/(2f)</span>. For intervals <span class="math">I_{\\text{growth}},I_{\\text{stabilize}}</span> defined as in (7) for <span class="math">a:=j_{1}</span> and <span class="math">b:=\\text{sync}</span>, on <span class="math">\\mathcal{C}_{\\text{sync}}</span> we again have a guarantee of sufficient chain growth in <span class="math">I_{\\text{growth}}</span> and at least one honest block in <span class="math">I_{\\text{stabilize}}</span>. Hence, by the same argument, Condition B in maxvalid-bg will favor <span class="math">\\mathcal{C}_{\\text{sync}}</span>, otherwise a violation of common prefix would occur. <span class="math">\\Box</span></p>

    <p class="text-gray-300">Based on Lemma 1, what remains is to upper-bound the time interval that a newly joining party has to be considered desynchronized, i.e., the time it takes until it obtains its synchronizing chain (which it will adopt). We present some alternatives beyond the default mechanism.</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Lemma 2.</h6>

    <p class="text-gray-300">Consider the same setting as Lemma 1 and let <span class="math">\\Delta</span> be the network delay. Consider an honest party <span class="math">U_{p}</span> in slot <span class="math">\\mathfrak{sl}</span>, which newly joined the protocol execution (and hence being registered to the network) at some slot <span class="math">\\mathfrak{sl}_{\\text{join}}\\leq\\mathfrak{sl}</span>. If party <span class="math">U_{p}</span> is considered synchronized in slot <span class="math">\\mathfrak{sl}</span> according to Definition 6 with parameter <span class="math">t_{\\text{sync}}\\geq 2\\Delta</span>, then it has also received its synchronizing chain.</p>

    <p class="text-gray-300">Furthermore, if alert parties multicast their local state every (constant) <span class="math">T</span> rounds, we obtain the statement for <span class="math">t_{\\text{sync}}\\geq T+\\Delta</span> even without any active request by the newly joining party.</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Both cases follow from observing when the alert party <span class="math">\\tilde{U}</span> would receive a synchronizing chain in the respective case. Clearly, for the first (and default) case this is no more than the round-trip time <span class="math">2\\Delta</span> after the actual new party joins the network, as any other alert party multicasts its local state by <span class="math">\\mathfrak{sl}_{\\text{join}}+\\Delta</span> (and in case of any later state update, it will multicast such a newer state by definition of the protocol). The second part follows similarly by observing that the above argument still holds, but where other alert parties multicast their local state by <span class="math">\\mathfrak{sl}_{\\text{join}}+T</span>. <span class="math">\\Box</span></p>

    <p class="text-gray-300">Hence, a party is considered synchronized in an execution of the protocol Ouroboros Genesis, if it satisfies Definition 6 with respect to parameter <span class="math">t_{\\text{sync}}=2\\Delta</span>.</p>

    <p class="text-gray-300">Remark 2 (Self-synchronization).</p>

    <p class="text-gray-300">Note that the protocol Ouroboros-Genesis is self-synchronizing in the sense that even without any active request, the newly joining party will receive its synchronizing chain by slot <span class="math">\\mathtt{sl_{join}}+t_{\\mathtt{sync}}</span> except with error probability <span class="math">\\epsilon_{\\mathtt{CG2}}(t_{\\mathtt{sync}})</span> of the event that <span class="math">\\tilde{U}</span> does not adopt a new chain during a period of <span class="math">t_{\\mathtt{sync}}</span>, which directly contradicts the <span class="math">\\mathtt{CG2}</span> security property for the respective parameters. A bound on <span class="math">\\mathtt{CG2}</span>-violation (and hence also <span class="math">\\epsilon_{\\mathtt{CG2}}(t_{\\mathtt{sync}})</span>) could be established as described in Section 4.1, however it would lead to longer synchronization times. We therefore do not pursue this option further, and instead choose to consider the default synchronization process as presented in Section 3.</p>

    <p class="text-gray-300">The analysis of the synchronization process that was outlined above applies also to resynchronization of parties that have already participated in the protocol, acquired some stake, and then got deregistered from <span class="math">\\mathcal{F}_{\\mathrm{N-MC}}</span> and hence became offline. The only difference is that, since the joining party does not know which of the messages it receives is actually its synchronizing message containing <span class="math">\\mathcal{C}_{\\mathtt{sync}}</span>, it starts participating in the protocol immediately after rejoining. Hence, before it receives <span class="math">\\mathcal{C}_{\\mathtt{sync}}</span> its participation is to some extent controlled by the adversary and hence its stake has to be counted towards the adversarial stake even though the party is not formally corrupted. This is already captured in the general form of Definition 2, and hence we have established the following corollary.</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Corollary 1.</h6>

    <p class="text-gray-300">Consider the protocol Ouroboros-Genesis as described in Section 3, executed in an environment with dynamic <span class="math">\\mathcal{F}_{\\mathrm{N-MC}}</span>-registrations and deregistrations. Then, under the assumptions of Theorem 2, the guarantees it gives for common prefix, chain growth, and chain quality are valid also in this general setting.</p>

    <h3 id="sec-48" class="text-xl font-semibold mt-8">4.5 Composable Guarantees</h3>

    <p class="text-gray-300">In this section, we conclude the analysis by showing how the property-focused statement of Corollary 1 can be turned into a universally composable security statement. This concludes the UC-analysis of Ouroboros-Genesis. The statement is conditioned again on the honest majority assumption introduced above. As explained in <em>[3]</em> for fully composable statements, it is desirable not to restrict the environment, but rather model these restrictions as part of the setup. In <em>[3]</em>, they put forth a general methodology to model such restrictions as wrapper functionalities that control the interaction between an adversary and the assumed setup functionality to enforce the restrictions. For completeness, we provide the corresponding wrapper in Section A.</p>

    <p class="text-gray-300">To prove composable security, the properties proven above for the real-world UC-execution play a crucial role in realizing the ledger <span class="math">\\mathcal{G}_{\\textsc{ledger}}</span> functionality (implementing a certain policy): first, the common-prefix property ensures that the ledger can maintain a unique ledger-state (a chain of state-blocks). Second, the chain quality ensures that the ledger can enforce a fraction of honestly generated blocks. Third, chain growth ensures that the ledger functionality can enforce its state to grow. The remaining arguments are given in the proof below. We now state the composable version of Corollary 1 (again for the default <span class="math">t_{\\mathtt{sync}}=2\\Delta</span> case) as a theorem:</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Theorem 3.</h6>

    <p class="text-gray-300">Let <span class="math">k</span> be the common-prefix parameter and let <span class="math">R</span> be the epoch-length parameter (restricted as in Theorem 2), let <span class="math">\\Delta</span> be the network delay, let <span class="math">\\tau_{\\mathtt{CG}}</span> and <span class="math">\\mu</span> be the speed and chain-quality coefficients, respectively (both defined as in Theorem 1), and let <span class="math">\\alpha</span> and <span class="math">\\beta</span> refer to the respective bounds on the participation ratios (as in Theorem 1). Let <span class="math">\\mathcal{G}_{\\textsc{ledger}}</span> be the ledger functionality defined in Section 2.2 and instantiate its parameters by</p>

    <p class="text-gray-300"><span class="math">\\mathtt{windowSize}=k</span> and <span class="math">\\mathtt{Delay}=2\\Delta</span> <span class="math">\\mathtt{maxTime}_{\\mathtt{window}}\\geq\\frac{\\mathtt{windowSize}}{\\tau_{\\mathtt{CG}}}</span> and <span class="math">\\mathtt{advBlcks}_{\\mathtt{window}}\\geq(1-\\mu)\\mathtt{windowSize}.</span></p>

    <p class="text-gray-300">The protocol Ouroboros-Genesis (with access to its specified hybrids) securely UC-realizes <span class="math">\\mathcal{G}_{\\textsc{ledger}}</span> under the assumptions required by Theorem 1 (which are formally enforceable by a real-world wrapper functionality <span class="math">\\mathcal{W}_{\\mathrm{OG}}^{P_{nN}}(\\cdot)</span> as given in Section D). In addition, the corresponding simulation is perfect except with negligible probability in the parameter <span class="math">k</span> when setting <span class="math">R\\geq\\omega(\\log k)</span>.</p>

    <p class="text-gray-300">##</p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We prove the theorem by proving the security with respect to the EUC version of UC (which stands for externalized UC) and we treat the clock and the random oracle as the only two shared functionalities. Our proof then implies naturally standard UC security (where all hybrids are local, i.e., not shared) and, by the equivalence shown in <em>[9]</em>, full GUC security. Secure realization is proven by providing a simulator <span class="math">\\mathcal{S}_{\\text{ledg}}</span> in the ideal world (with access to the ledger, global clock and random oracle) such that the protocol execution is indistinguishable from the ideal-world execution with the ledger functionality and the simulator. The simulator <span class="math">\\mathcal{S}_{\\text{ledg}}</span> is given in detail in Section C. The simulator basically runs internally an entire protocol execution and emulates this real-world view in a black-box way towards the real world adversary <span class="math">\\mathcal{A}</span>. This simulation can be done perfectly, as nothing restricts the simulator in evaluating, in each round what the corresponding party does in the protocol upon a maintain command (including aborts of protocols due to key collisions in <span class="math">\\mathcal{F}_{\\textsf{INIT}}</span> for example). Also, the simulator can extract the ledger state from the emulated blockchains (procedure ExtendLedgerState), and the views of honest parties on this state (procedure AdjustView). The only events that prevent a successful simulation are therefore when the ledger functionality does not allow the simulator to specify the state and the view appropriately. Simulating a ledger state fails, if the simulator encounters a violation of the common prefix property (in this case the simulation aborts as seen in the code of <span class="math">\\mathcal{S}_{\\text{ledg}}</span> when flag BAD-CP is triggered). Similarly, if the state grows too slowly, the simulator aborts (flag BAD-CG), or the state contains too few honestly generated blocks (flag BAD-CQ). This events, however, hold except with negligible probability in the parameter <span class="math">k</span> which follows exactly as proven in the previous sections (under the given assumptions). Considering that the analysis conditions no collisions among random oracle outputs, the corresponding total error probability of Theorem 2 can be invoked here and yields an upper bound of <span class="math">\\exp(-\\Omega(\\kappa))+\\exp(\\ln\\mathsf{poly}(\\kappa)-\\Omega(k))+\\exp(\\ln\\mathsf{poly}(\\kappa)-\\Omega(R))</span>, where <span class="math">\\mathsf{poly}(\\kappa)</span> denotes the polynomial upper bound on the runtime of <span class="math">\\mathcal{Z}</span> measured with respect to the security parameter <span class="math">\\kappa</span>. Note that in particular, the parameters <span class="math">L</span> and <span class="math">Q</span> of the security bound can simply be upper bounded by this polynomial.</p>

    <p class="text-gray-300">The remaining technical properties are straightforward to verify: first, pointers of alert parties are monotonically increasing, since the chains adopted by alert parties are monotonically increasing in size (recall from 6.2 that the new maxvalid-bg applied by alert parties essentially implements the longest-chain-rule but does not need checkpointing). The pointers of alert parties can also not be too far apart, i.e., the slackness is upper bounded by windowSize <span class="math">=k</span> (meaning they fall within a window of size windowSize), as otherwise the common-prefix property is violated in that execution (if the prefix of the chain known to any honest party was further away than <span class="math">k</span> blocks from the prefix of the actual longest chain, this would yield a fork and violate common-prefix). Second, the synchronization time does not take more than Delay time as given in the theorem statements, as this is exactly the time until the a newly joining party will have received a synchronizing chain and all honest transactions that were sent out (and still are valid) before this party joined the network (note that the round-trip time is just <span class="math">2\\mathbin{\\Delta}</span>). Hence, the overall bound is exactly the time it takes to receive a synchronizing chain as by Lemma 2.</p>

    <p class="text-gray-300">Overall, this means that except with negligible probability, the simulator will not abort and does never violate the ledger’s policy (as specified by (ExtendPolicy) or the additional restrictions on pointers into the unique ledger state. ∎</p>

    <h2 id="sec-51" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Marcin Andrychowicz and Stefan Dziembowski. PoW-based distributed cryptography with no trusted setup. In Rosario Gennaro and Matthew J. B. Robshaw, editors, CRYPTO 2015, Part II, volume 9216 of LNCS, pages 379–399. Springer, Heidelberg, August 2015.</li>

      <li>[2] Marcin Andrychowicz, Stefan Dziembowski, Daniel Malinowski, and Lukasz Mazurek. Secure multiparty computations on bitcoin. In 2014 IEEE Symposium on Security and Privacy, pages 443–458. IEEE Computer Society Press, May 2014.</li>

      <li>[3] Christian Badertscher, Ueli Maurer, Daniel Tschudi, and Vassilis Zikas. Bitcoin as a transaction ledger: A composable treatment. In Jonathan Katz and Hovav Shacham, editors, CRYPTO 2017, Part I, volume 10401 of LNCS, pages 324–356. Springer, Heidelberg, August 2017.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[4] Iddo Bentov and Ranjit Kumaresan. How to use bitcoin to design fair protocols. In Juan A. Garay and Rosario Gennaro, editors, CRYPTO 2014, Part II, volume 8617 of LNCS, pages 421–439. Springer, Heidelberg, August 2014.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[5] Vitalik Buterin. A next-generation smart contract and decentralized application platform, 2013. https://github.com/ethereum/wiki/wiki/White-Paper.</li>

      <li>[6] Vitalik Buterin and Virgil Griffith. Casper the friendly finality gadget. CoRR, abs/1710.09437, 2017.</li>

      <li>[7] Jan Camenisch, Robert R. Enderlein, Stephan Krenn, Ralf Küsters, and Daniel Rausch. Universal composition with responsive environments. In Jung Hee Cheon and Tsuyoshi Takagi, editors, ASIACRYPT 2016, Part II, volume 10032 of LNCS, pages 807–840. Springer, Heidelberg, December 2016.</li>

      <li>[8] Ran Canetti. Universally composable security: A new paradigm for cryptographic protocols. In 42nd FOCS, pages 136–145. IEEE Computer Society Press, October 2001.</li>

      <li>[9] Ran Canetti, Yevgeniy Dodis, Rafael Pass, and Shabsi Walfish. Universally composable security with global setup. In Salil P. Vadhan, editor, TCC 2007, volume 4392 of LNCS, pages 61–85. Springer, Heidelberg, February 2007.</li>

      <li>[10] Ran Canetti and Marc Fischlin. Universally composable commitments. In Joe Kilian, editor, CRYPTO 2001, volume 2139 of LNCS, pages 19–40. Springer, Heidelberg, August 2001.</li>

      <li>[11] Ran Canetti, Abhishek Jain, and Alessandra Scafuro. Practical UC security with a global random oracle. In Gail-Joon Ahn, Moti Yung, and Ninghui Li, editors, ACM CCS 14, pages 597–608. ACM Press, November 2014.</li>

      <li>[12] Ran Canetti, Daniel Shahaf, and Margarita Vald. Universally composable authentication and key-exchange with global PKI. In Chen-Mou Cheng, Kai-Min Chung, Giuseppe Persiano, and Bo-Yin Yang, editors, PKC 2016, Part II, volume 9615 of LNCS, pages 265–296. Springer, Heidelberg, March 2016.</li>

      <li>[13] Phil Daian, Rafael Pass, and Elaine Shi. Snow white: Provably secure proofs of stake. Cryptology ePrint Archive, Report 2016/919, 2016. https://eprint.iacr.org/2016/919.</li>

      <li>[14] Bernardo David, Peter Gazi, Aggelos Kiayias, and Alexander Russell. Ouroboros praos: An adaptively-secure, semi-synchronous proof-of-stake blockchain. In Jesper Buus Nielsen and Vincent Rijmen, editors, EUROCRYPT 2018, Part II, volume 10821 of LNCS, pages 66–98. Springer, Heidelberg, April / May 2018.</li>

      <li>[15] Yevgeniy Dodis and Aleksandr Yampolskiy. A verifiable random function with short proofs and keys. In Serge Vaudenay, editor, PKC 2005, volume 3386 of LNCS, pages 416–431. Springer, Heidelberg, January 2005.</li>

      <li>[16] Marc Fischlin, Anja Lehmann, Thomas Ristenpart, Thomas Shrimpton, Martijn Stam, and Stefano Tessaro. Random oracles with(out) programmability. In Masayuki Abe, editor, ASIACRYPT 2010, volume 6477 of LNCS, pages 303–320. Springer, Heidelberg, December 2010.</li>

      <li>[17] Juan A. Garay, Aggelos Kiayias, and Nikos Leonardos. The bitcoin backbone protocol: Analysis and applications. In Elisabeth Oswald and Marc Fischlin, editors, EUROCRYPT 2015, Part II, volume 9057 of LNCS, pages 281–310. Springer, Heidelberg, April 2015.</li>

      <li>[18] Peter Gaži, Aggelos Kiayias, and Alexander Russell. Stake-bleeding attacks on proof-of-stake blockchains. Cryptology ePrint Archive, Report 2018/248, 2018. https://eprint.iacr.org/2018/248.</li>

      <li>[19] Yossi Gilad, Rotem Hemo, Silvio Micali, Georgios Vlachos, and Nickolai Zeldovich. Algorand: Scaling byzantine agreements for cryptocurrencies. Cryptology ePrint Archive, Report 2017/454, 2017. http://eprint.iacr.org/2017/454.</li>

      <li>[20] Martin Hirt and Vassilis Zikas. Adaptively secure broadcast. In Henri Gilbert, editor, EUROCRYPT 2010, volume 6110 of LNCS, pages 466–485. Springer, Heidelberg, May / June 2010.</li>

      <li>[21] Jonathan Katz, Ueli Maurer, Björn Tackmann, and Vassilis Zikas. Universally composable synchronous computation. In Amit Sahai, editor, TCC 2013, volume 7785 of LNCS, pages 477–498. Springer, Heidelberg, March 2013.</li>

      <li>[22] Aggelos Kiayias, Alexander Russell, Bernardo David, and Roman Oliynykov. Ouroboros: A provably secure proof-of-stake blockchain protocol. In Jonathan Katz and Hovav Shacham, editors, CRYPTO 2017, Part I, volume 10401 of LNCS, pages 357–388. Springer, Heidelberg, August 2017.</li>

      <li>[23] Ranjit Kumaresan and Iddo Bentov. How to use bitcoin to incentivize correct computations. In Gail-Joon Ahn, Moti Yung, and Ninghui Li, editors, ACM CCS 14, pages 30–41. ACM Press, November 2014.</li>

      <li>[24] Ranjit Kumaresan and Iddo Bentov. Amortizing secure computation with penalties. In Edgar R. Weippl, Stefan Katzenbeisser, Christopher Kruegel, Andrew C. Myers, and Shai Halevi, editors, ACM CCS 16, pages 418–429. ACM Press, October 2016.</li>

      <li>[25] Rajeev Motwani and Prabhakar Raghavan. Randomized Algorithms. Cambridge University Press, New York, NY, USA, 1995.</li>

      <li>[26] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system, 2008. http://bitcoin.org/bitcoin.pdf.</li>

      <li>[27] Rafael Pass, Lior Seeman, and abhi shelat. Analysis of the blockchain protocol in asynchronous networks. In Jean-Sébastien Coron and Jesper Buus Nielsen, editors, EUROCRYPT 2017, Part II, volume 10211 of LNCS, pages 643–673. Springer, Heidelberg, April / May 2017.</li>

    </ul>

    <p class="text-gray-300">[28] Rafael Pass and Elaine Shi. The sleepy model of consensus. In Tsuyoshi Takagi and Thomas Peyrin, editors, ASIACRYPT 2017, Part II, volume 10625 of LNCS, pages 380–409. Springer, Heidelberg, December 2017.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[29] Alexander Russell, Cristopher Moore, Aggelos Kiayias, and Saad Quader. Forkable strings are rare. Cryptology ePrint Archive, Report 2017/241, 2017. https://eprint.iacr.org/2017/241.</li>

    </ul>

    <p class="text-gray-300">A The Model (Cont’d)</p>

    <p class="text-gray-300">This appendix includes complementary material to Section 2.</p>

    <h3 id="sec-52" class="text-xl font-semibold mt-8">A.1 Functionalities With Dynamic Party Sets</h3>

    <p class="text-gray-300">All our functionalities and global setups handle a dynamic party set. The employed mechanism works as follows: such functionalities include the instructions that allow honest parties to join or leave the set <span class="math">\\mathcal{P}</span> of players that the functionality interacts with, and inform the adversary about the current set of registered parties: Unless otherwise specified, the term party refers to an active protocol machine and, as usual in UC, includes the session information. The standard mechanism is as follows (and applies to all functionalities unless otherwise indicated by the functionality specification).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Upon receiving (register, sid) from some party <span class="math">U_{p}</span> (or from <span class="math">\\mathcal{A}</span> on behalf of a corrupted <span class="math">U_{p}</span>), set <span class="math">\\mathcal{P}=\\mathcal{P}\\cup\\{U_{p}\\}</span>. Return (register, sid, <span class="math">U_{p}</span>) to the caller.</li>

      <li>Upon receiving (de-register, sid) from some party <span class="math">U_{p}\\in\\mathcal{P}</span>, the functionality sets <span class="math">\\mathcal{P}:=\\mathcal{P}\\setminus\\{U_{p}\\}</span> and returns (de-register, sid, <span class="math">U_{p}</span>) to the caller.</li>

      <li>Upon receiving (is-registered, sid) from some party <span class="math">U_{p}</span>, return (register, sid, <span class="math">b</span>) to the caller, where the bit <span class="math">b</span> is 1 if and only if <span class="math">U_{p}\\in\\mathcal{P}</span>.</li>

      <li>Upon receiving (get-registered, sid) from <span class="math">\\mathcal{A}</span>, the functionality returns (get-registered, sid, <span class="math">\\mathcal{P}</span>) to <span class="math">\\mathcal{A}</span>.</li>

    </ul>

    <p class="text-gray-300">For simplicity in the description of the functionalities, for a party <span class="math">U_{p}\\in\\mathcal{P}</span> we will use <span class="math">U_{p}</span> to refer to this party’s ID. In addition to the above registration instructions, global setups, i.e., shared functionalities that are available both in the real and in the ideal world and allow parties connected to them to share state <em>[9]</em>, allow also UC functionalities to register with them. We note in passing that although we allow no communication between functionalities, we will allow functionalities to communicate with global setups along the lines of <em>[12, Section 2]</em>.</p>

    <p class="text-gray-300">Concretely, global setups include, in addition to the above party registration instructions, two registration/de-registration instructions for functionalities:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Upon receiving (register, sid_{C}) from a functionality <span class="math">\\mathcal{F}</span> (in session sid), set <span class="math">F:=F\\cup\\{(\\mathcal{F},\\text{sid})\\}</span>.</li>

      <li>Upon receiving (de-register, sid_{C}) from a functionality <span class="math">\\mathcal{F}</span> (in session sid, set <span class="math">F\\ :=\\ F\\setminus\\ \\{(\\mathcal{F},\\text{sid})\\}</span>.</li>

      <li>Upon receiving (get-registered-f, sid_{C}) from <span class="math">\\mathcal{A}</span>, return (get-registered-f, sid_{C}, <span class="math">F</span>) to <span class="math">\\mathcal{A}</span>.</li>

    </ul>

    <h3 id="sec-53" class="text-xl font-semibold mt-8">A.2 The Communication Network</h3>

    <p class="text-gray-300">We specify the multicast network with bounded delay in the following. The network is modeled as a local functionality. However, we conjecture that it is straightforward to make it global since the simulator has to simulate all the messages on the network. Since we do not consider properties such as network congestion, we choose not to model it as a global functionality for simplicity. As it is sometimes useful to distinguish (the same kind of network) according to the values sent over the network, we use the notation <span class="math">\\mathcal{F}_{\\text{N-MC}}^{\\text{bc},\\Delta}</span> and <span class="math">\\mathcal{F}_{\\text{N-MC}}^{\\text{ts},\\Delta}</span> to distinguish chain and transaction multicast in the protocol. However, since both networks can be realized from a single network we often just refer to <span class="math">\\mathcal{F}_{\\text{N-MC}}^{\\Delta}</span> for simplicity.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">The functionality is parameterized with a set possible senders and receivers  <span class="math">\\mathcal{P}</span> . Any newly registered (resp. deregistered) party is added to (resp. deleted from)  <span class="math">\\mathcal{P}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Honest sender multicast. Upon receiving (MULTICAST, sid, m) from some  <span class="math">U_p \\in \\mathcal{P}</span> , where  <span class="math">\\mathcal{P} = \\{U_1, \\ldots, U_n\\}</span>  denotes the current party set, choose  <span class="math">n</span>  new unique message-IDs  <span class="math">\\mathrm{mid}_1, \\ldots, \\mathrm{mid}_n</span> , initialize  <span class="math">2n</span>  new variables  <span class="math">D_{\\mathrm{mid}_1} := D_{\\mathrm{mid}_1}^{MAX} \\ldots := D_{\\mathrm{mid}_n} := D_{\\mathrm{mid}_n}^{MAX} := 1</span> , set  $\\vec{M} := \\vec{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(m, \\mathrm{mid}_1, D_{\\mathrm{mid}_1}, U_1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(m, \\mathrm{mid}_n, D_{\\mathrm{mid}_n}, U_n)<span class="math"> , and send (MULTICAST, sid, m,  </span>U_p<span class="math"> ,  </span>(U_1, \\mathrm{mid}_1), \\ldots, (U_n, \\mathrm{mid}_n)$ ) to the adversary.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Honest party fetching. Upon receiving (FETCH, sid) from  <span class="math">U_p \\in \\mathcal{P}</span>  (or from  <span class="math">\\mathcal{A}</span>  on behalf of  <span class="math">U_p</span>  if  <span class="math">U_p</span>  is corrupted):</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For all tuples  <span class="math">(m,\\mathrm{mid},D_{\\mathrm{mid}},U_p)\\in \\vec{M}</span> , set  <span class="math">D_{\\mathrm{mid}}\\coloneqq D_{\\mathrm{mid}} - 1</span></li>

      <li>Let  <span class="math">\\vec{M}_0^{U_p}</span>  denote the subvector  <span class="math">\\vec{M}</span>  including all tuples of the form  <span class="math">(m,\\mathrm{mid},D_{\\mathrm{mid}},U_p)</span>  with  <span class="math">D_{\\mathrm{mid}} = 0</span>  (in the same order as they appear in  <span class="math">\\vec{M}</span> ). Delete all entries in  <span class="math">\\vec{M}_0^{U_p}</span>  from  <span class="math">\\vec{M}</span> , and send  <span class="math">\\vec{M}_0^{U_p}</span>  to  <span class="math">U_p</span> .</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Adding adversarial delays. Upon receiving (DELAYS, sid,  <span class="math">(T_{\\mathrm{mid}_{i_1}}, \\mathrm{mid}_{i_1}), \\ldots, (T_{\\mathrm{mid}_{i_\\ell}}, \\mathrm{mid}_{i_\\ell}))</span>  from the adversary do the following for each pair  <span class="math">(T_{\\mathrm{mid}_{i_j}}, \\mathrm{mid}_{i_j})</span> :</li>

    </ul>

    <p class="text-gray-300">If  <span class="math">D_{\\mathrm{mid}_{i_j}}^{MAX} + T_{\\mathrm{mid}_{i_j}} \\leq \\Delta</span>  and mid is a message-ID registered in the current  <span class="math">\\vec{M}</span> , set  <span class="math">D_{\\mathrm{mid}_{i_j}} := D_{\\mathrm{mid}_{i_j}} + T_{\\mathrm{mid}_{i_j}}</span>  and set  <span class="math">D_{\\mathrm{mid}_{i_j}}^{MAX} := D_{\\mathrm{mid}_{i_j}}^{MAX} + T_{\\mathrm{mid}_{i_j}}</span> ; otherwise, ignore this pair.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Adversarily reordering messages. Upon receiving (SWAP, sid, mid, mid') from the adversary, if mid and mid' are message-IDs registered in the current  <span class="math">\\vec{M}</span> , then swap the triples  <span class="math">(m, \\mathrm{mid}, D_{\\mathrm{mid}}, \\cdot)</span>  and  <span class="math">(m, \\mathrm{mid}&#x27;, D_{\\mathrm{mid}}, \\cdot)</span>  in  <span class="math">\\vec{M}</span> . Return (SWAP, sid) to the adversary.</li>

    </ul>

    <p class="text-gray-300">As in [3], the basic functionality to capture a round-based protocol is the clock-functionality described below. In this functionality, each registered party can update the clock and once all honest parties have done so, the clock advances by one tick. In addition, every party can query the clock to read the (logical) time. A shared (global) clock allows each party to synchronize each session it participates in.</p>

    <p class="text-gray-300">An important property thereby is that for an ideal-world functionality to be UC implementable by a synchronous protocol, it needs to keep track of the number of activations that an honest party gets—such that the advancement of the ideal process is identical to advancement of the real world process. This requires that the protocol itself, when described as a UC interactive Turing-machine instance, has a predictable behavior (per session) when it comes to the pattern of activations that it needs before it sends the clock an update command. This is captured by defining a predictor predict-time <span class="math">_{\\Pi}(\\vec{\\mathcal{I}}_H^T)</span>  of the time, given as input the timed honest-input sequence.[23] We restate this property formalized in [3] here for completeness in Definition 7.</p>

    <p class="text-gray-300">Definition 7. A  <span class="math">\\mathcal{G}_{\\mathrm{CLOCK}}</span> -hybrid protocol  <span class="math">\\Pi</span>  has a predictable synchronization pattern iff there exist an algorithm predict-time <span class="math">_{\\Pi}(\\cdot)</span>  such that for any possible execution of  <span class="math">\\Pi</span>  in a session sid (i.e., for any adversary and environment, and any choice of random coins) the following holds: If  <span class="math">\\vec{\\mathcal{I}}_H^T = ((x_1, id_1, \\tau_1), \\ldots, (x_m, id_m, \\tau_m))</span>  is the corresponding timed honest-input sequence for this execution, then for any  <span class="math">i \\in [m-1]</span> :</p>

    <p class="text-gray-300">predict-time  <span class="math">\\Pi ((x_{1},id_{1},\\tau_{1}),\\ldots ,(x_{i},id_{i},\\tau_{i})) = \\tau_{i + 1},</span></p>

    <p class="text-gray-300">where  <span class="math">\\tau_{i + 1}</span>  refers to the clock time of this session.</p>

    <p class="text-gray-300">Having such a predictor is beneficial in modeling synchronous protocols in UC, as the theorems and the proofs only depend on this function but not on the exact number of activations of a party in each round. For example, if an additional computation step requires one activation more, then the only thing that changes is the concrete specification of the function <span class="math">\\textsf{predict-time}_{\\Pi}</span> but the theorems stay the same.</p>

    <p class="text-gray-300">Functionality Functionality <span class="math">\\mathcal{G}_{\\textsc{clock}}</span></p>

    <p class="text-gray-300">The functionality manages the set <span class="math">\\mathcal{P}</span> of registered identities, i.e., parties <span class="math">U_{p}=(\\text{pid},\\text{sid})</span>. It also manages the set <span class="math">F</span> of functionalities (together with their session identifier). Initially, <span class="math">\\mathcal{P}:=\\emptyset</span> and <span class="math">F:=\\emptyset</span>.</p>

    <p class="text-gray-300">For each session sid the clock maintains a variable <span class="math">\\tau_{\\text{sid}}</span>. For each identity <span class="math">U_{p}:=(\\text{pid},\\text{sid})\\in\\mathcal{P}</span> it manages variable <span class="math">d_{U_{p}}</span>. For each pair <span class="math">(\\mathcal{F},\\text{sid})\\in F</span> it manages variable <span class="math">d_{(\\mathcal{F},\\text{sid})}</span> (all integer variables are initially 0).</p>

    <p class="text-gray-300"><em>Synchronization:</em></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Upon receiving <span class="math">(\\textsc{clock-update},\\text{sid}_{C})</span> from some party <span class="math">U_{p}\\in\\mathcal{P}</span> set <span class="math">d_{U_{p}}:=1</span>; execute <em>Round-Update</em> and forward <span class="math">(\\textsc{clock-update},\\text{sid}_{C},U_{p})</span> to <span class="math">\\mathcal{A}</span>.</li>

      <li>Upon receiving <span class="math">(\\textsc{clock-update},\\text{sid}_{C})</span> from some functionality <span class="math">\\mathcal{F}</span> in a session sid such that <span class="math">(\\mathcal{F},\\text{sid})\\in F</span> set <span class="math">d_{(\\mathcal{F},\\text{sid})}:=1</span>, execute <em>Round-Update</em> and return <span class="math">(\\textsc{clock-update},\\text{sid}_{C},\\mathcal{F})</span> to this instance of <span class="math">\\mathcal{F}</span>.</li>

      <li>Upon receiving <span class="math">(\\textsc{clock-read},\\text{sid}_{C})</span> from any participant (including the environment on behalf of a party, the adversary, or any ideal—shared or local—functionality) return <span class="math">(\\textsc{clock-read},\\text{sid},\\tau_{\\text{sid}})</span> to the requestor (where sid is the sid of the calling instance).</li>

    </ul>

    <p class="text-gray-300"><em>Procedure Round-Update:</em> For each session sid do: If <span class="math">d_{(\\mathcal{F},\\text{sid})}:=1</span> for all <span class="math">\\mathcal{F}\\in F</span> and <span class="math">d_{U_{p}}=1</span> for all honest parties <span class="math">U_{p}=(\\cdot,\\text{sid})\\in\\mathcal{P}</span>, then set <span class="math">\\tau_{\\text{sid}}:=\\tau_{\\text{sid}}+1</span> and reset <span class="math">d_{(\\mathcal{F},\\text{sid})}:=0</span> and <span class="math">d_{U_{p}}:=0</span> for all parties <span class="math">U_{p}=(\\cdot,\\text{sid})\\in\\mathcal{P}</span>.</p>

    <p class="text-gray-300">We next show that the protocol has a predictable synchronization pattern according to Definition 7.</p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Lemma 3.</h6>

    <p class="text-gray-300">The protocol Ouroboros-Genesis satisfies Definition 7.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We will show that there is an easy and efficient algorithm <span class="math">\\textsf{predict-time}_{\\textsc{OG}}(\\cdot)</span> that, given any possible execution of the protocol in some session sid (for any adversary, environment, and choice of random coins), we have that if <span class="math">\\vec{\\mathcal{I}}_{H}^{T}=((x_{1},id_{1},\\tau_{1}),\\ldots,(x_{m},id_{m},\\tau_{m}))</span> is the corresponding timed honest-inputs sequence for this execution, then for any <span class="math">i\\in[m-1]</span> :</p>

    <p class="text-gray-300"><span class="math">\\textsf{predict-time}_{\\Pi}((x_{1},id_{1},\\tau_{1}),\\ldots,(x_{i},id_{i},\\tau_{i}))=\\tau_{i+1}.</span></p>

    <p class="text-gray-300">The basic mechanism to predict the clock time is an inductive process. The first advancement of the clock from <span class="math">\\tau=0</span> to <span class="math">\\tau=1</span> is after all parties <span class="math">U_{p}\\in\\mathcal{S}_{\\text{initStake}}</span> have received a registration query from the environment and if all additionally registered, uncorrupted parties have sent a clock-update message to the clock. The advancement from <span class="math">\\tau</span> to <span class="math">\\tau+1</span> follows by observing that each honest miner that is registered with all global functionalities needs one activation query MAINTAIN-LEDGER followed by an clock-update request from the environment to send his clock-update message (other honest miners do not send such a request). Once every honest party registered with the clock has sent its clock-update message, the clock advances. ∎</p>

    <h3 id="sec-58" class="text-xl font-semibold mt-8">A.4 The Global Random Oracle Setup</h3>

    <p class="text-gray-300">Functionality <span class="math">\\mathcal{G}_{\\textsc{ro}}</span></p>

    <p class="text-gray-300">The functionality is parameterized by a security parameter <span class="math">\\kappa</span>. It maintains a set of registered parties <span class="math">\\mathcal{P}</span> (initially set to <span class="math">\\emptyset</span>) and a (dynamically updatable) function table <span class="math">\\mathcal{T}</span> (initially <span class="math">\\mathcal{T}=\\emptyset</span>). For simplicity we write <span class="math">T[x]=\\bot</span> to denote the fact that no pair of the form <span class="math">(x,\\cdot)</span> is in <span class="math">\\mathcal{T}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Upon receiving <span class="math">(\\textsc{eval},\\text{sid}_{RO},x)</span> from some party <span class="math">U_{p}\\in\\mathcal{P}</span> (or from <span class="math">\\mathcal{A}</span> on behalf of a corrupted <span class="math">U_{p}</span>), do the following:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If  <span class="math">H[x] = \\bot</span>  sample a value  <span class="math">y</span>  uniformly at random from  <span class="math">\\{0, 1\\}^{\\kappa}</span> , set  <span class="math">H[x] \\gets y</span>  and add  <span class="math">(x, T[x])</span>  to  <span class="math">\\mathcal{T}</span> .</li>

      <li>Return (EVAL,  <span class="math">\\mathrm{sid}_{RO},x,H[x])</span>  to the requester.</li>

    </ol>

    <p class="text-gray-300">The functionality  <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span>  describe below was introduced in [14] to formalize the procedure of genesis block creation and distribution.</p>

    <p class="text-gray-300">The functionality  <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span>  is parameterized by the set  <span class="math">U_{1},\\ldots ,U_{n}</span>  of initial stakeholders  <span class="math">n</span>  and their respective stakes  <span class="math">s_1,\\dots ,s_n</span> . It maintains the set of registered parties  <span class="math">\\mathcal{P}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Upon receiving any message from a party, the functionality first sends (CLOCK-READ,  <span class="math">\\mathrm{sid}_C,\\tau</span> ) to the clock to receive the current round. Subsequently:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If this is the first (genesis) round and the message is request from some initial stakeholder  <span class="math">U_{i}</span>  of the form (ver_keys, sid,  <span class="math">U_{i}, v_{i}^{\\mathrm{vrf}}, v_{i}^{\\mathrm{kes}}</span> ), then  <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span>  stores the verification keys tuple  <span class="math">(U_{i}, v_{i}^{\\mathrm{vrf}}, v_{i}^{\\mathrm{kes}})</span>  and acknowledges its receipt. If some of the registered public keys are equal, it outputs an error and halts. Otherwise, it samples and stores a random value  <span class="math">\\eta_{1} \\stackrel{\\</span>}{\\leftarrow} \\{0, 1\\}^{\\lambda}<span class="math">  and constructs a genesis block  </span>(\\mathbb{S}_1, \\eta_1)<span class="math"> , where  </span>\\mathbb{S}_1 = \\big((U_1, v_1^{\\mathrm{vrf}}, v_1^{\\mathrm{kes}}, s_1), \\ldots, (U_n, v_n^{\\mathrm{vrf}}, v_n^{\\mathrm{kes}}, s_n)\\big)$ .</li>

      <li>If this is not the first round, then do the following</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If any of the  <span class="math">n</span>  initial stakeholders has not send a request of the above form, i.e., a (ver_keys, sid,  <span class="math">U_i</span> ,  <span class="math">v_i^{\\mathrm{vrf}}</span> ,  <span class="math">v_i^{\\mathrm{kes}}</span> )-message, to  <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span>  in the genesis round then  <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span>  outputs an error and halts.</li>

      <li>Otherwise, if the currently received input is a request of the form (genblock_req, sid,  <span class="math">U_{i}</span> ) from any (initial or not) stakeholder  <span class="math">U</span> ,  <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span>  sends (genblock, sid,  <span class="math">(\\mathbb{S}_1, \\eta_1)</span> ) to the requester.</li>

    </ul>

    <p class="text-gray-300">The security of Ouroboros Praos and Genesis is proven in a hybrid world with access to a multicast-network with upper bound on the message delay (unknown to the protocol), a global random oracle, a functionality that idealizes verifiable random functions (VRF), a functionality that idealizes key-evolving signature schemes (KES), and a setup functionality that distributes the initial tokens for proof-of-stake blockchains. The network, clock, RO, and initialization (genesis block), are assumed resources (see Section 2). On the other hand the VRF and KES functionalities are only hybrids used in the proof and are shown to be UC-realizable in [14] by concrete constructions. Therefore, hence they are only employed for simplicity in the proof (the overall security once instantiated by the constructions follows from the UC composition theorem). For completeness we include their definition below.</p>

    <p class="text-gray-300">Verifiable Random Functions. The following functionality  <span class="math">\\mathcal{F}_{\\mathrm{VRF}}</span>  capturing a verifiable random function was introduced in [14].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathcal{F}_{\\mathrm{VRF}}</span>  interacts with its set of registered parties  <span class="math">\\mathcal{P}</span>  (denoted by  $U_{1},\\ldots ,U_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ ) as follows:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Key Generation. Upon receiving a message (KeyGen, sid) from a stakeholder  <span class="math">U_{i}</span> , hand (KeyGen, sid,  <span class="math">U_{i}</span> ) to the adversary. Upon receiving (VerificationKey, sid,  <span class="math">U_{i}, v</span> ) from the adversary, if  <span class="math">U_{i}</span>  is honest, verify that  <span class="math">v</span>  is unique, record the pair  <span class="math">(U_{i}, v)</span>  and return (VerificationKey, sid,  <span class="math">v</span> ) to  <span class="math">U_{i}</span> . Initialize the table  <span class="math">T(v, \\cdot)</span>  to empty.</li>

      <li>Malicious Key Generation. Upon receiving a message (KeyGen, sid, v) from  <span class="math">S</span> , verify that  <span class="math">v</span>  has not been recorded before; in this case initialize table  <span class="math">T(v, \\cdot)</span>  to empty and record the pair  <span class="math">(S, v)</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>VRF Evaluation. Upon receiving a message (Eval, <span class="math">sid, m</span>) from <span class="math">U_i</span>, verify that some pair <span class="math">(U_i, v)</span> is recorded. If not, then ignore the request. Then, if the value <span class="math">T(v, m)</span> is undefined, pick a random value <span class="math">y</span> from <span class="math">\\{0, 1\\}^{F_{\\text{VRF}}}</span> and set <span class="math">T(v, m) = (y, \\emptyset)</span>. Then output (Evaluated, <span class="math">sid, y</span>) to <span class="math">U_i</span>, where <span class="math">y</span> is such that <span class="math">T(v, m) = (y, S)</span> for some <span class="math">S</span>.</li>

      <li>VRF Evaluation and Proof. Upon receiving a message (EvalProve, <span class="math">sid, m</span>) from <span class="math">U_i</span>, verify that some pair <span class="math">(U_i, v)</span> is recorded. If not, then ignore the request. Else, send (EvalProve, <span class="math">sid, U_i, m</span>) to the adversary. Upon receiving (EvalProve, <span class="math">sid, m, \\pi</span>) from the adversary, if value <span class="math">T(v, m)</span> is undefined, verify that <span class="math">\\pi</span> is unique, pick a random value <span class="math">y</span> from <span class="math">\\{0, 1\\}^{F_{\\text{VRF}}}</span> and set <span class="math">T(v, m) = (y, \\{\\pi\\})</span>. Else, if <span class="math">T(v, m) = (y, S)</span>, set <span class="math">T(v, m) = (y, S \\cup \\{\\pi\\})</span>. In any case, output (Evaluated, <span class="math">sid, y, \\pi</span>) to <span class="math">U_i</span>.</li>

      <li>Malicious VRF Evaluation. Upon receiving a message (Eval, <span class="math">sid, v, m, \\pi</span>) from <span class="math">S</span> for some <span class="math">v</span>, do the following. First, if <span class="math">(S, v)</span> is recorded and <span class="math">T(v, m)</span> is undefined, then choose a random value <span class="math">y</span> from <span class="math">\\{0, 1\\}^{F_{\\text{VRF}}}</span> and set <span class="math">T(v, m) = (y, S)</span> and output (Evaluated, <span class="math">sid, y</span>) to <span class="math">S</span>. The same is performed in case <span class="math">(U_i, v)</span> is recorded and <span class="math">U_i</span> corrupted. Else, if <span class="math">T(v, m) = (y, S&#x27;)</span> for some <span class="math">S&#x27; \\neq \\emptyset</span>, union <span class="math">S</span> to <span class="math">S&#x27;</span> and output (Evaluated, <span class="math">sid, y</span>) to <span class="math">S</span>, else ignore the request.</li>

      <li>Verification. Upon receiving a message (Verify, <span class="math">sid, m, y, \\pi, v&#x27;</span>) from some party <span class="math">P</span>, send (Verify, <span class="math">sid, m, y, \\pi, v&#x27;</span>) to the adversary. Upon receiving (Verified, <span class="math">sid, m, y, \\pi, v&#x27;</span>) from the adversary do:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">v&#x27; = v</span> for some <span class="math">(\\cdot, v)</span> and the entry <span class="math">T(v, m)</span> equals <span class="math">(y, S)</span> with <span class="math">\\pi \\in S</span>, then set <span class="math">f = 1</span>.</li>

      <li>Else, if <span class="math">v&#x27; = v</span> for some recorded pair of the form <span class="math">(\\cdot, v)</span>, but no entry <span class="math">T(v, m)</span> of the form <span class="math">(y, \\{\\ldots, \\pi, \\ldots\\})</span> is recorded, then set <span class="math">f = 0</span>.</li>

      <li>Else, initialize the table <span class="math">T(v&#x27;, \\cdot)</span> to empty, and set <span class="math">f = 0</span>.</li>

    </ol>

    <p class="text-gray-300">Output (Verified, <span class="math">sid, m, y, \\pi, f</span>) to <span class="math">P</span>.</p>

    <p class="text-gray-300">Key-Evolving Signatures. Ouroboros Praos and Genesis also make use of a key-evolving signature scheme for signing blocks. In our treatment, we reflect the fact that signing a message is a local operation performed by a slot-leader and invoke the proposed formalism of Camenisch et al. [7] and declare signing request as restricting. This means that although activated to provide a signature, the adversary has to provide the answer, i.e. the signature string, to this request immediately (no other output to another protocol machine is allowed) and return the activation token back to the functionality <span class="math">\\mathcal{F}_{\\mathrm{KES}}</span>. In this sense, the adversary and the environment are called responsive on signing queries.</p>

    <p class="text-gray-300">The following formalization of key-evolving signatures was given in [14] and we adopt it slightly using the notation from [7, Section 6] to indicate that signing request have to be answered immediately: we indicate the request by prefixing the query with the keyword Respond (and hence this query is considered to be restricting).</p>

    <h2 id="sec-63" class="text-2xl font-bold">Functionality <span class="math">\\mathcal{F}_{\\mathrm{KES}}</span></h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathcal{F}_{\\mathrm{KES}}</span> is parameterized by the total number of signature updates <span class="math">T</span>, interacting with a signer <span class="math">U_S</span> and registered parties in <span class="math">\\mathcal{P}</span> (denoted by $U_1, \\ldots, U_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$) as follows:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Key Generation. Upon receiving a message (KeyGen, <span class="math">sid, U_S</span>) from a stakeholder <span class="math">U_S</span>, send (KeyGen, <span class="math">sid, U_S</span>) to the adversary. Upon receiving (VerificationKey, <span class="math">sid, U_S, v</span>) from the adversary, send (VerificationKey, <span class="math">sid, v</span>) to <span class="math">U_S</span>, record the triple <span class="math">(sid, U_S, v)</span> and set counter <span class="math">k_{\\mathrm{ctr}} = 1</span>.</li>

      <li>Sign and Update. Upon receiving a message (USign, <span class="math">sid, U_S, m, j</span>) from <span class="math">U_S</span>, verify that <span class="math">(sid, U_S, v)</span> is recorded for some <span class="math">sid</span> and that <span class="math">k_{\\mathrm{ctr}} \\leq j \\leq T</span>. If not, then ignore the request. Else, set <span class="math">k_{\\mathrm{ctr}} = j + 1</span> and send (Respond, (Sign, <span class="math">sid, U_S, m, j</span>)) to the adversary. Upon receiving (Signature, <span class="math">sid, U_S, m, j, \\sigma</span>) from the adversary, verify that no entry <span class="math">(m, j, \\sigma, v, 0)</span> is recorded. If it is, then output an error message to <span class="math">U_S</span> and halt. Else, send (Signature, <span class="math">sid, m, j, \\sigma</span>) to <span class="math">U_S</span>, and record the entry <span class="math">(m, j, \\sigma, v, 1)</span>.</li>

      <li>Signature Verification. Upon receiving a message (Verify, <span class="math">sid, m, j, \\sigma, v&#x27;</span>) from some stakeholder <span class="math">U_i</span> do:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">v&#x27; = v</span> and the entry <span class="math">(m, j, \\sigma, v, 1)</span> is recorded, then set <span class="math">f = 1</span>. (This condition guarantees completeness: If the verification key <span class="math">v&#x27;</span> is the registered one and <span class="math">\\sigma</span> is a legitimately generated signature for <span class="math">m</span>, then the verification succeeds.)</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Else, if  <span class="math">v&#x27; = v</span> , the signer is not corrupted, and no entry  <span class="math">(m,j,\\sigma&#x27;,v,1)</span>  for any  <span class="math">\\sigma&#x27;</span>  is recorded, then set  <span class="math">f = 0</span>  and record the entry  <span class="math">(m,j,\\sigma,v,0)</span> . (This condition guarantees unforgeability: If  <span class="math">v&#x27;</span>  is the registered one, the signer is not corrupted, and never signed  <span class="math">m</span> , then the verification fails.)</li>

      <li>Else, if there is an entry  <span class="math">(m,j,\\sigma,v&#x27;,f&#x27;)</span>  recorded, then let  <span class="math">f = f&#x27;</span> . (This condition guarantees consistency: All verification requests with identical parameters will result in the same answer.)</li>

      <li>Else, if  <span class="math">j &amp;lt; \\mathbf{k}_{\\mathrm{ctr}}</span> , let  <span class="math">f = 0</span>  and record the entry  <span class="math">(m,j,\\sigma,v,0)</span> . Otherwise, if  <span class="math">j = \\mathbf{k}_{\\mathrm{ctr}}</span> , hand (Verify, sid, m, j,  <span class="math">\\sigma, v&#x27;</span> ) to the adversary. Upon receiving (Verified, sid, m, j,  <span class="math">\\phi</span> ) from the adversary let  <span class="math">f = \\phi</span>  and record the entry  <span class="math">(m,j,\\sigma,v&#x27;,\\phi)</span> . (This condition guarantees that the adversary is only able to forge signatures under keys belonging to corrupted parties for time periods corresponding to the current or future slots.)</li>

    </ol>

    <p class="text-gray-300">Output (Verified, sid, m, j, f) to  <span class="math">U_{i}</span> .</p>

    <p class="text-gray-300">Following the treatment of [7], the above functionality is realized by the same construction as in [14] because the simulator in that proof is responsive upon signing requests. We refer to [7] for more details.</p>

    <p class="text-gray-300">We next provide the complete description of the ledger functionality that, as we prove, is implemented by Ouroboros Genesis.</p>

    <p class="text-gray-300">General: The functionality is parameterized by four algorithms, Validate, ExtendPolicy, Blockify, and predict-time, along with three parameters: windowSize, Delay  <span class="math">\\in \\mathbb{N}</span> , and  <span class="math">S_{\\mathrm{initStake}} \\coloneqq \\{(U_1, s_1), \\ldots, (U_n, s_n)\\}</span> . The functionality manages variables state, NxtBC, buffer,  <span class="math">\\tau_L</span> , and  <span class="math">\\vec{\\tau}_{\\mathrm{state}}</span> , as described above. The variables are initialized as follows: state :=  <span class="math">\\vec{\\tau}_{\\mathrm{state}} \\coloneqq \\mathrm{NxtBC} \\coloneqq \\varepsilon</span> , buffer :=  <span class="math">\\emptyset</span> ,  <span class="math">\\tau_L = 0</span> . For each party  <span class="math">U_p \\in \\mathcal{P}</span>  the functionality maintains a pointer  <span class="math">\\mathfrak{pt}_i</span>  (initially set to 1) and a current-state view  <span class="math">\\mathrm{state}_p \\coloneqq \\varepsilon</span>  (initially set to empty). The functionality also keeps track of the timed honest-input sequence in a vector  <span class="math">\\vec{\\mathcal{I}}_H^T</span>  (initially  <span class="math">\\vec{\\mathcal{I}}_H^T \\coloneqq \\varepsilon</span> ).</p>

    <p class="text-gray-300">Party Management: The functionality maintains the set of registered parties  <span class="math">\\mathcal{P}</span> , the (sub-)set of honest parties  <span class="math">\\mathcal{H} \\subseteq \\mathcal{P}</span> , and the (sub-set) of de-synchronized honest parties  <span class="math">\\mathcal{P}_{DS} \\subset \\mathcal{H}</span>  (as discussed below). The sets  <span class="math">\\mathcal{P}, \\mathcal{H}, \\mathcal{P}_{DS}</span>  are all initially set to  <span class="math">\\emptyset</span> . When a (currently unregistered) honest party is registered at the ledger, if it is registered with the clock and the global RO already, then it is added to the party sets  <span class="math">\\mathcal{H}</span>  and  <span class="math">\\mathcal{P}</span>  and the current time of registration is also recorded; if the current time is  <span class="math">\\tau_{L} &amp;gt; 0</span> , it is also added to  <span class="math">\\mathcal{P}_{DS}</span> . Similarly, when a party is deregistered, it is removed from both  <span class="math">\\mathcal{P}</span>  (and therefore also from  <span class="math">\\mathcal{P}_{DS}</span>  or  <span class="math">\\mathcal{H}</span> ). The ledger maintains the invariant that it is registered (as a functionality) to the clock whenever  <span class="math">\\mathcal{H} \\neq \\emptyset</span> .</p>

    <p class="text-gray-300">Handling initial stakeholders: If during round  <span class="math">\\tau = 0</span> , the ledger did not receive a registration from each initial stakeholder, i.e.,  <span class="math">U_{p} \\in S_{\\mathrm{initStake}}</span> , the functionality halts.</p>

    <p class="text-gray-300">Upon receiving any input  <span class="math">I</span>  from any party or from the adversary, send (CLOCK-READ,  <span class="math">\\mathrm{sid}_C</span> ) to  <span class="math">\\mathcal{G}_{\\mathrm{CLOCK}}</span>  and upon receiving response (CLOCK-READ,  <span class="math">\\mathrm{sid}_C, \\tau</span> ) set  <span class="math">\\tau_L \\coloneqq \\tau</span>  and do the following if  <span class="math">\\tau &amp;gt; 0</span>  (otherwise, ignore input):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Updating synchronized/desynchronized party set:</li>

    </ol>

    <p class="text-gray-300">(a) Let  <span class="math">\\widehat{\\mathcal{P}}\\subseteq \\mathcal{P}_{DS}</span>  denote the set of desynchronized honest parties that have been registered (continuously) to the ledger, the clock, and the GRO since time  <span class="math">\\tau^{\\prime} &amp;lt; \\tau_{L} - \\text{Delay}</span> . Set  <span class="math">\\mathcal{P}_{DS} := \\mathcal{P}_{DS} \\setminus \\widehat{\\mathcal{P}}</span> . (b) For any synchronized party  <span class="math">U_{p} \\in \\mathcal{H} \\setminus \\mathcal{P}_{DS}</span> , if  <span class="math">U_{p}</span>  is not registered to the clock, then consider it desynchronized, i.e., set  <span class="math">\\mathcal{P}_{DS} \\cup \\{U_{p}\\}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If  <span class="math">I</span>  was received from an honest party  <span class="math">U_{p}\\in \\mathcal{P}</span></li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(a) Set  $\\vec{\\mathcal{I}}_H^T\\coloneqq \\vec{\\mathcal{I}}_H^T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(I,U_p,\\tau_L)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(b) Compute  <span class="math">\\vec{N} = (\\vec{N}_1,\\dots ,\\vec{N}_\\ell)\\coloneqq</span>  ExtendPolicy(  <span class="math">\\vec{\\mathcal{I}}_H^T</span>  ,state,NxtBC,buffer,  <span class="math">\\vec{\\tau}_{\\mathrm{state}}</span>  ) and if  <span class="math">\\vec{N}\\neq \\varepsilon</span>  set state  <span class="math">\\coloneqq</span>  state</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Blockify  $(\\vec{N}_1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  ...</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Blockify  <span class="math">(\\vec{N}_{\\ell})</span>  and  $\\vec{\\tau}_{\\mathrm{state}}\\coloneqq \\vec{\\tau}_{\\mathrm{state}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tau_L^\\ell<span class="math">  , where  </span>\\tau_L^\\ell = \\tau_L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots ,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tau_L$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(c) For each  <span class="math">\\mathsf{BTX} \\in \\mathsf{buffer}</span> : if Validate(BTX, state, buffer) = 0 then delete BTX from buffer. Also, reset NxtBC :=  <span class="math">\\varepsilon</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(d) If there exists  <span class="math">U_{j} \\in \\mathcal{H} \\setminus \\mathcal{P}_{DS}</span>  such that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{state}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\mathrm{pt}_j &gt; \\mathrm{windowSize}<span class="math">  or  </span>\\mathrm{pt}_j &lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{state}_j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , then set  </span>\\mathrm{pt}_k :=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{state}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  for all  </span>U_{k} \\in \\mathcal{H} \\setminus \\mathcal{P}_{DS}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If the calling party  <span class="math">U_{p}</span>  is stalled or time-unaware (according to the defined party classification), then no further actions are taken. Otherwise, depending on the above input  <span class="math">I</span>  and its sender's ID,  <span class="math">\\mathcal{G}_{\\text{LEDGER}}</span>  executes the corresponding code from the following list:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Submitting a transaction:</li>

    </ul>

    <p class="text-gray-300">If  <span class="math">I = (\\mathrm{SUBMIT}, \\mathrm{sid}, \\mathrm{tx})</span>  and is received from a party  <span class="math">U_p \\in \\mathcal{P}</span>  or from  <span class="math">\\mathcal{A}</span>  (on behalf of a corrupted party  <span class="math">U_p</span> ) do the following</p>

    <p class="text-gray-300">(a) Choose a unique transaction ID txid and set BTX := (tx, txid,  <span class="math">\\tau_L</span> ,  <span class="math">U_p</span> ) (b) If Validate(BTX, state, buffer) = 1, then buffer := buffer  <span class="math">\\cup</span>  {BTX}. (c) Send (SUBMIT, BTX) to  <span class="math">\\mathcal{A}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Reading the state:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If  <span class="math">I = (\\mathrm{READ}, \\mathrm{sid})</span>  is received from a party  <span class="math">U_p \\in \\mathcal{P}</span>  then set  $\\mathbf{state}_p := \\mathbf{state}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\min\\{\\mathbf{pt}_p,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{state}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}}<span class="math">  and return (READ, sid,  </span>\\mathbf{state}_p<span class="math"> ) to the requester. If the requester is  </span>\\mathcal{A}<span class="math">  then send (state, buffer,  </span>\\vec{\\mathcal{I}}_H^T<span class="math"> ) to  </span>\\mathcal{A}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Maintaining the ledger state:</li>

    </ul>

    <p class="text-gray-300">If  <span class="math">I = (\\mathrm{MAINTAIN - LEDGER}, \\mathrm{sid}, \\mathrm{minerID})</span>  is received by an honest party  <span class="math">U_p \\in \\mathcal{P}</span>  and (after updating  <span class="math">\\vec{\\mathcal{I}}_H^T</span>  as above) predict-time  <span class="math">(\\vec{\\mathcal{I}}_H^T) = \\widehat{\\tau} &amp;gt; \\tau_L</span>  then send (CLOCK-UPDATE,  <span class="math">\\mathrm{sid}_C</span> ) to  <span class="math">\\mathcal{G}_{\\mathrm{CLOCK}}</span> . Else send  <span class="math">I</span>  to  <span class="math">\\mathcal{A}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The adversary proposing the next block:</li>

    </ul>

    <p class="text-gray-300">If  <span class="math">I = (\\mathrm{NEXT - BLOCK},\\mathrm{hFlag},(\\mathrm{txid}_1,\\dots ,\\mathrm{txid}_\\ell))</span>  is sent from the adversary, update NxtBC as follows:</p>

    <p class="text-gray-300">(a) Set listOfTxid  <span class="math">\\leftarrow \\epsilon</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(b) For  <span class="math">i = 1,\\dots ,\\ell</span>  do: if there exists BTX  <span class="math">\\coloneqq (x,\\mathrm{txid},\\mathrm{minerID},\\tau_L,U_j)\\in \\mathsf{buffer}</span>  with ID txid  <span class="math">=</span>  txidi then set listOfTxid  <span class="math">\\coloneqq</span>  listOfTxid</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">txidi.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The adversary setting state-slackness:</li>

    </ul>

    <p class="text-gray-300">If  <span class="math">I = (\\mathrm{SET - SLACK},(U_{i_1},\\widehat{\\mathsf{pt}}_{i_1}),\\ldots ,(U_{i_\\ell},\\widehat{\\mathsf{pt}}_{i_\\ell}))</span>  with  <span class="math">\\{U_{p_{i_1}},\\dots ,U_{p_{i_\\ell}}\\} \\subseteq \\mathcal{H}\\setminus \\mathcal{P}_{DS}</span>  is received from the adversary  <span class="math">\\mathcal{A}</span>  do the following:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(a) If for all  $j \\in [\\ell] :</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{state}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\widehat{\\text{pt}}_{i_j} \\leq \\text{windowSize}<span class="math">  and  </span>\\widehat{\\text{pt}}_{i_j} \\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{state}_{i_j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , set  </span>\\text{pt}_{i_1} := \\widehat{\\text{pt}}_{i_1}<span class="math">  for every  </span>j \\in [\\ell]<span class="math">  and return (SET-SLACK, ok) to  </span>\\mathcal{A}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The adversary setting the state for desynchronized parties:</li>

    </ul>

    <p class="text-gray-300">If  <span class="math">I = (\\mathrm{DESYNC - STATE},(U_{i_1},\\mathrm{state}_{i_j}^{\\prime}),\\ldots ,(U_{i_\\ell},\\mathrm{state}_{i_\\ell}^{\\prime}))</span>  with  <span class="math">\\{U_{i_1},\\dots ,U_{i_\\ell}\\} \\subseteq \\mathcal{P}_{DS}</span>  is received from the adversary  <span class="math">\\mathcal{A}</span> , set  <span class="math">\\mathrm{state}_{i_j}\\coloneqq \\mathrm{state}_{i_j}^{\\prime}</span>  for each  <span class="math">j\\in [\\ell ]</span>  and return (DESYNC-STATE,ok) to  <span class="math">\\mathcal{A}</span> .</p>

    <p class="text-gray-300">The detailed ExtendPolicy for Ouroboros is given below.</p>

    <p class="text-gray-300">Algorithm ExtendPolicy for  <span class="math">\\mathcal{G}_{\\mathrm{LEDGER}}</span></p>

    <p class="text-gray-300">function EXTENDPOLICY  <span class="math">(\\vec{\\mathcal{I}}_H^T,\\mathrm{state},\\mathrm{NxtBC},\\mathrm{buffer},\\vec{\\tau}_{\\mathrm{state}})</span></p>

    <p class="text-gray-300">// First, create a default honest client block as alternative:</p>

    <p class="text-gray-300"><span class="math">\\vec{N}_{\\mathrm{df}} \\gets \\text{DEFAULTEXTENSION}(\\vec{\\mathcal{I}}_H^T, \\text{state}, \\text{NxtBC}, \\text{buffer}, \\vec{\\tau}_{\\text{state}})</span>  // Extension if adversary violates policy.</p>

    <p class="text-gray-300">Let  <span class="math">\\tau_{L}</span>  be current ledger time (computed from  <span class="math">\\vec{\\mathcal{I}}_H^T</span></p>

    <p class="text-gray-300">// The function must not have side-effects: Only modify copies of relevant values. Create local copies of the values buffer, state, and <span class="math">\\vec{\\tau}_{\\text{state}}</span>. // Now, parse the proposed block by the adversary Parse NxtBC as a vector <span class="math">((\\mathrm{hFlag}_1,\\mathrm{NxtBC}_1),\\cdots,(\\mathrm{hFlag}_n,\\mathrm{NxtBC}_n))</span> <span class="math">\\vec{N} \\leftarrow \\varepsilon</span> // Initialize Result // Determine the time of the state block which is windowSize blocks behind the head of the state</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{state}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\text{windowSize}$ then</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">else Set <span class="math">\\tau_{\\text{low}} \\leftarrow 1</span> end if oldValidTxMissing <span class="math">\\leftarrow</span> false // Flag to keep track whether old enough, valid transactions are inserted. for each list NxtBC<span class="math">_i</span> of transaction IDs do // Compute the next state block // Verify validity of NxtBC<span class="math">_i</span> and compute content Use the txid contained in NxtBC<span class="math">_i</span> to determine the list of transactions</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let $\\vec{\\text{tx}} = (\\text{tx}_1,\\dots,\\text{tx}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{NxtBC}_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math"> denote the transactions of NxtBC</span>_i$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">if <span class="math">\\text{tx}_1</span> is not a coin-base transaction then return <span class="math">\\vec{N}_{\\text{df}}</span> else <span class="math">\\vec{N}_i \\leftarrow \\text{tx}_1</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">for <span class="math">j = 2</span> to $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{NxtBC}_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ do</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Set <span class="math">\\text{st}_i \\leftarrow \\text{blockify}_{\\hat{\\mathcal{G}}}(\\vec{N}_i)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">if $\\text{ValidTx}_{\\hat{\\mathcal{G}}}(\\text{tx}_j,\\text{state}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{st}_i) = 0$ then</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">return <span class="math">\\vec{N}_{\\text{df}}</span> end if</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\vec{N}_i \\leftarrow \\vec{N}_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{tx}_j$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">end for Set <span class="math">\\text{st}_i \\leftarrow \\text{blockify}_{\\hat{\\mathcal{G}}}(\\vec{N}_i)</span> end if // Test that all old valid transaction are included if the proposal is declared to be an honest block, i.e., <span class="math">\\mathrm{hFlag}_i = 1</span> then for each <span class="math">\\text{BTX} = (\\text{tx},\\text{txid},\\tau&#x27;,U_p) \\in \\text{buffer}</span> of an honest party <span class="math">U_p</span> with time <span class="math">\\tau&#x27; &amp;lt; \\tau_{\\text{low}} - \\frac{\\text{Delay}}{2}</span> do</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">if $\\text{ValidTx}_{\\hat{\\mathcal{G}}}(\\text{tx},\\text{state}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{st}_i) = 1<span class="math"> but </span>\\text{tx} \\notin \\vec{N}_i$ then</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">oldValidTxMissing <span class="math">\\leftarrow</span> true end if end for end if</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\vec{N} \\leftarrow \\vec{N}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{N}_i$</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">$\\vec{\\tau}_{\\text{state}} \\leftarrow \\vec{\\tau}_{\\text{state}}</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">\\tau_L$</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">// Must not proceed with too many adversarial blocks <span class="math">i \\leftarrow \\max\\{\\{\\text{windowSize}\\} \\cup \\{k \\mid \\text{st}_k \\in \\text{state} \\land \\text{proposal of st}_k \\text{ had hFlag} = 1\\}\\}</span> // Determine most // recent honestly-generated block in the interval behind the head.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{state}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- i \\geq \\text{advBlocks}_{\\text{window}}$ then</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">return <span class="math">\\vec{N}_{\\text{df}}</span> end if // Update <span class="math">\\tau_{\\text{low}}</span>: the time of the state block which is windowSize blocks behind the head of the // current, potentially already extended state</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{state}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\text{windowSize}$ then</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">else Set <span class="math">\\tau_{\\text{low}} \\leftarrow 1</span> end if</p>

    <p class="text-gray-300">end for // Final checks (if policy is violated, it is enforced by the ledger); // Must not proceed too slow or with missing transaction. if <span class="math">\\tau_{\\texttt{low}}&gt;0</span> and <span class="math">\\tau_{L}-\\tau_{\\texttt{low}}&gt;\\texttt{maxTime}_{\\texttt{window}}</span> then // A sequence of blocks cannot take too much time. return <span class="math">\\tilde{N}_{\\texttt{df}}</span> else if <span class="math">\\tau_{\\texttt{low}}=0</span> and <span class="math">\\tau_{L}-\\tau_{\\texttt{low}}&gt;2\\cdot\\texttt{maxTime}_{\\texttt{window}}</span> then // Bootstrapping cannot take too much time. return <span class="math">\\tilde{N}_{\\texttt{df}}</span> else if oldValidTxMissing then // If not all old enough, valid transactions have been included. return <span class="math">\\tilde{N}_{\\texttt{df}}</span> end if return <span class="math">\\tilde{N}</span> end function</p>

    <p class="text-gray-300">!<a href="img-9.jpeg">img-9.jpeg</a> Fig. 14. Function to compute a policy-compliant default ledger-state extension.</p>

    <p class="text-gray-300">This appendix includes protocols that have been excluded from the body.</p>

    <p class="text-gray-300">Chain validation. The chain validation procedure is given in Figure 15.</p>

    <p class="text-gray-300">Protocol IsValidChain  <span class="math">(U_{p},\\mathrm{sid},k,\\mathcal{C},f,R)</span></p>

    <pre><code class="language-txt">if  $\\mathcal{C}$  contains future blocks, empty epochs, starts with a block other than  $\\mathbf{G}$ , or encodes an invalid state with
isvalidstate  $(\\widehat{\\mathbf{st}}) = 0$  then
return false
end if
for each epoch ep do
// Derive stake distribution and randomness for this epoch from  $\\mathcal{C}$
Set  $\\mathbb{S}_{\\mathrm{ep}}^{\\mathcal{C}}$  to be the stakeholder distribution at the end of epoch  $\\mathbf{ep} - 2$  in  $\\mathcal{C}$ .
Set  $\\alpha_{p&#x27;}^{\\mathrm{ep},\\mathcal{C}}$  to be the relative stake of any party  $U_{p&#x27;}$  in  $\\mathbb{S}_{\\mathrm{ep}}^{\\mathcal{C}}$  and  $T_{p&#x27;}^{\\mathrm{ep},\\mathcal{C}} \\gets 2^{t_{\\mathrm{VRF}}}\\phi_f(\\alpha_{p&#x27;}^{\\mathrm{ep},\\mathcal{C}})$ .
Set  $\\eta_{\\mathrm{ep}}^{\\mathcal{C}} \\gets H(\\eta_{\\mathrm{ep}-1}^{\\mathcal{C}} \\| \\mathbf{ep} \\| v)$  where  $v$  is the concatenation of the VRF outputs  $y_{\\rho}$  from all blocks in  $\\mathcal{C}$  from
the first two-thirds of slots of epoch  $\\mathbf{ep} - 1$ , and  $\\eta_1^{\\mathcal{C}} \\triangleq \\eta_1$  from  $\\mathbf{G}$ .
for each block  $B$  in  $\\mathcal{C}$  from epoch  $\\mathbf{ep}$  do
Parse  $B$  as  $(h, \\mathrm{st}, \\mathrm{sl}, crt, \\rho, \\sigma)$ .
// Check hash. H(.) is shorthand for a RO-evaluation.
Set badhash  $\\leftarrow (h \\neq H(B^{-1}))$ , where  $B^{-1}$  is the last block in  $\\mathcal{C}$  before  $B$  (possibly the genesis block).
// Check VRF values
Parse crt as  $(U_{p&#x27;}, y, \\pi)$  for some  $p&#x27;$ .
Send (Verify, sid,  $\\eta_{\\mathrm{ep}} \\| \\mathrm{sl} \\| \\mathrm{TEST}, y, \\pi, v_{p&#x27;}^{\\mathrm{vrf}}$ ) to  $\\mathcal{F}_{\\mathrm{VRF}}$ ,
denote its response by (Verified, sid,  $\\eta_{\\mathrm{ep}} \\| \\mathrm{sl} \\| \\mathrm{TEST}, y, \\pi, b_1$ ).
Send (Verify, sid,  $\\eta_{\\mathrm{ep}} \\| \\mathrm{sl} \\| \\mathrm{NONCE}, y_{\\rho}, \\pi_{\\rho}, v_{p&#x27;}^{\\mathrm{vrf}}$ ) to  $\\mathcal{F}_{\\mathrm{VRF}}$ ,
denote its response by (Verified, sid,  $\\eta_{\\mathrm{ep}} \\| \\mathrm{sl} \\| \\mathrm{NONCE}, y_{\\rho}, \\pi_{\\rho}, b_2$ ),
Set badvrf  $\\leftarrow (b_1 = 0 \\lor b_2 = 0 \\lor y \\geq T_{U_{p&#x27;}}^{\\mathrm{ep},\\mathcal{C}})$ .
// Check signature
Send (Verify, sid,  $(h, \\mathrm{st}, \\mathrm{sl}, crt, \\rho), \\mathrm{sl}, \\sigma, v_{p&#x27;}^{\\mathrm{kes}})$  to  $\\mathcal{F}_{\\mathrm{KES}}$ ,
denote its response by (Verified, sid,  $(h, \\mathrm{st}, \\mathrm{sl}, crt, \\rho), \\mathrm{sl}, b_3$ ).
Set badsig  $\\leftarrow (b_3 = 0)$ .
if (badhash  $\\vee$  badvrf  $\\vee$  badsig) then
return false
end if
end for
end for
return true</code></pre>

    <p class="text-gray-300">Fig. 15. The chain validation (filtering) protocol.</p>

    <p class="text-gray-300">The round finish procedure. Once a party is done its actions in a round it has to advance the synchronous computation by sending the indication to  <span class="math">\\mathcal{G}_{\\mathrm{CLOCK}}</span> . Since the functionality is shared and and an update-request by the environment might not be well aligned with the round actions, the protocol simply remembers that such an update has been received. The procedure FinishRound enforces that the protocol only sends the clock-update once (1) the round operations are concluded and (2) the environment has given the command to advance the round.[24]</p>

    <p class="text-gray-300">!<a href="img-10.jpeg">img-10.jpeg</a> Fig. 16. The UC-specific round conclusion of a synchronous protocol.</p>

    <p class="text-gray-300">Below we present the simulator used in the proof that the UC implementation of Ouroboros Genesis securely realizes the ledger functionality  <span class="math">\\mathcal{G}_{\\mathrm{LEDGER}}</span> . The simulator shares the basic structure with the simulator provided in [3] and differs in several low-level details.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The simulator internally emulates all local UC functionalities by running the code (and keeping the state) of  <span class="math">\\mathcal{F}_{\\mathrm{WHF}}</span> ,  <span class="math">\\mathcal{F}_{\\mathrm{KES}}</span> ,  <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span> ,  <span class="math">\\mathcal{F}_{\\mathrm{N-MC}}^{\\mathrm{be}}</span> , and  <span class="math">\\mathcal{F}_{\\mathrm{N-MC}}^{\\mathrm{ts}}</span> .</li>

      <li>The simulator mimics the execution of Ouroboros-Genesis for each honest party  <span class="math">U_{p}</span>  (including their state and the interaction with the hybrids).</li>

      <li>The simulator emulates a view towards the adversary  <span class="math">\\mathcal{A}</span>  in a black-box way, i.e., by internally running adversary  <span class="math">\\mathcal{A}</span>  and simulating his interaction with the protocol (and hybrids) as detailed below for each hybrid. To simplify the description, we assume  <span class="math">\\mathcal{A}</span>  does not violate the requirements by the wrapper  <span class="math">\\mathcal{W}_{\\mathrm{OG}}^{P_{\\mathrm{DS}}}(\\cdot)</span>  as this would imply no interaction between  <span class="math">S_{\\mathrm{ledg}}</span>  (i.e., the emulated hybrids) and  <span class="math">\\mathcal{A}</span> .</li>

      <li>For global functionalities, the simulator simply relays the messages sent from  <span class="math">\\mathcal{A}</span>  to the global functionalities (and returns the generated replies). Recall that the ideal world consists of the dummy parties, the ledger functionality, the clock, and the global random oracle.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>As defined in the main body of this paper, honest parties are categorized. We denote  <span class="math">S_{\\text{alert}}</span>  the alert parties (synchronized and executing the protocol) and use  <span class="math">S_{\\text{syncStalled}}</span>  shorthand for parties that are synchronized (and hence time aware and online) but stalled. Finally, we denote by  <span class="math">\\mathcal{P}_{DS}</span>  all honest but de-synchronized parties (both operational or stalled).</li>

      <li>For each registered honest party, the simulator maintains the local state containing in particular the local chain  <span class="math">\\mathcal{C}_{\\mathrm{inc}}^{(U_p)}</span> , the time  <span class="math">t_{\\mathrm{on}}</span>  it remembers when last being online. For each party  <span class="math">U_{p}</span>  and clock time  <span class="math">\\tau</span> , the simulator stores a flag update  <span class="math">U_{p,\\tau}</span>  (initially false) to remember whether this party has updated its state already in this round. Note that an registered party is registered with all its local hybrids.</li>

      <li>Upon any activation, the simulator will query the current party set from the ledger, the clock, and the random oracle to evaluate in which category an honest party belongs to. If a new honest party is registered to the ledger, it internally runs the initialization procedure of Ouroboros-Genesis.</li>

      <li>We assume that the simulator queries upon any activation for the sequence  <span class="math">\\vec{\\mathcal{I}}_H^T</span> , and the current time  <span class="math">\\tau</span>  from the clock. We note that the simulator is capable of determining predict-time( <span class="math">\\cdot</span> ) of  <span class="math">\\mathcal{G}_{\\mathrm{LEDGER}}</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Upon receiving (CLOCK-UPDATE,  <span class="math">\\mathrm{sid}_C, U_p</span> ) from  <span class="math">\\mathcal{G}_{\\mathrm{CLOCK}}</span> , if  <span class="math">U_p</span>  is an honest registered party, then remember that this party has received such a clock update (and the environment gets an activation). Otherwise, send (CLOCK-UPDATE,  <span class="math">\\mathrm{sid}_C, U_p</span> ) to  <span class="math">\\mathcal{A}</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Upon receiving (SUBMIT, BTX) from  <span class="math">\\mathcal{G}_{\\text{LEDGER}}</span>  where BTX := (tx, txid,  <span class="math">\\tau, U_p</span> ) forward (MULTICAST, sid, tx) to the simulated network  <span class="math">\\mathcal{F}_{\\text{N-MC}}</span>  in the name of  <span class="math">U_p</span> . Output the answer of  <span class="math">\\mathcal{F}_{\\text{N-MC}}</span>  to the adversary.</li>

      <li>Upon receiving (MAINTAIN-LEDGER, sid, minerID) from  <span class="math">\\mathcal{G}_{\\text{LEDGER}}</span> , extract from  <span class="math">\\bar{\\mathcal{I}}_H^T</span>  the party  <span class="math">U_p</span>  that issued this query. If  <span class="math">U_p</span>  has already completed its round-task, then ignore this request. Otherwise, execute SIMULATESTAKING  <span class="math">(U_p, \\tau)</span> .</li>

    </ul>

    <p class="text-gray-300">Simulation of Functionality  <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span>  towards  <span class="math">\\mathcal{A}</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The simulator relays back and forth the communication between the (internally emulated)  <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span>  functionality and the adversary  <span class="math">\\mathcal{A}</span>  acting on behalf of a corrupted party.</li>

      <li>If at time  <span class="math">\\tau = 0</span> , a corrupted party  <span class="math">U_{p} \\in S_{\\mathrm{initStake}}</span>  registers via (ver_keys, sid,  <span class="math">U_{p}, v_{U_{p}}^{\\mathrm{vrf}}, v_{U_{p}}^{\\mathrm{kes}}</span> ) to  <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span> , then input (REGISTER, sid) to  <span class="math">\\mathcal{G}_{\\mathrm{LEDGER}}</span>  on behalf of  <span class="math">U_{p}</span> .</li>

    </ul>

    <p class="text-gray-300">Simulation of the Functionalities  <span class="math">\\mathcal{F}_{\\mathrm{KES}}</span>  and  <span class="math">\\mathcal{F}_{\\mathrm{VRF}}</span>  towards  <span class="math">\\mathcal{A}</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The simulator relays back and forth the communication between the (internally emulated) hybrids and the adversary  <span class="math">\\mathcal{A}</span>  (either direct communication, communication to  <span class="math">\\mathcal{A}</span>  caused by emulating the actions of honest parties, or communication of  <span class="math">\\mathcal{A}</span>  on behalf of a corrupted party).</li>

    </ul>

    <p class="text-gray-300">Simulation of the Network  <span class="math">\\mathcal{F}_{\\mathrm{N - MC}}^{\\mathrm{bc}}</span>  (over which chains are sent) towards  <span class="math">\\mathcal{A}</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Upon receiving (MULTICAST, sid,  <span class="math">(\\mathcal{C}_{i_1}, U_{i_1}), \\ldots, (\\mathcal{C}_{i_\\ell}, U_{i_\\ell})</span>  with a list of chains and corresponding parties from  <span class="math">\\mathcal{A}</span>  (or on behalf some corrupted  <span class="math">P \\in \\mathcal{P}_{net}</span> ), then do the following:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Relay this input to the simulate network functionality and record its response to  <span class="math">\\mathcal{A}</span> .</li>

      <li>Execute EXTENDLEDGERSTATE(τ)</li>

      <li>Provide  <span class="math">\\mathcal{A}</span>  with the recorded output of the simulated network.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Upon receiving (MULTICAST, sid,  <span class="math">\\mathcal{C}</span> ) from  <span class="math">\\mathcal{A}</span>  on behalf of some corrupted party  <span class="math">P</span> , then do the following:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Relay this input to the simulate network functionality and record its response to  <span class="math">\\mathcal{A}</span> .</li>

      <li>Execute EXTENDLEDGERSTATE(τ)</li>

      <li>Provide  <span class="math">\\mathcal{A}</span>  with the recorded output of the simulated network.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Upon receiving (FETCH, sid) from  <span class="math">\\mathcal{A}</span>  on behalf some corrupted  <span class="math">P \\in \\mathcal{P}_{net}</span>  forward the request to the simulated  <span class="math">\\mathcal{F}_{\\mathrm{N - MC}}^{\\mathrm{bc}}</span>  and return whatever is returned to  <span class="math">\\mathcal{A}</span> .</li>

      <li>Upon receiving (DELAYS, sid,  <span class="math">(T_{\\mathrm{mid}_{i_1}}, \\mathrm{mid}_{i_1}), \\ldots, (T_{\\mathrm{mid}_{i_\\ell}}, \\mathrm{mid}_{i_\\ell}))</span>  from  <span class="math">\\mathcal{A}</span> : Forward the request to the simulated  <span class="math">\\mathcal{F}_{\\mathrm{N - MC}}^{\\mathrm{bc}}</span>  and record the answer to  <span class="math">\\mathcal{A}</span> . Before giving this answer to  <span class="math">\\mathcal{A}</span> , query the ledger state state and execute ADJUSTVIEW(state).</li>

      <li>Upon receiving (SWAP, sid, mid, mid') from  <span class="math">\\mathcal{A}</span> : Forward the request to the simulated  <span class="math">\\mathcal{F}_{\\mathrm{N - MC}}^{\\mathrm{bc}}</span>  and record the answer to  <span class="math">\\mathcal{A}</span> . Before giving this answer to  <span class="math">\\mathcal{A}</span> , query the ledger state state and execute ADJUSTVIEW(state).</li>

    </ul>

    <p class="text-gray-300">Simulation of the Network  <span class="math">\\mathcal{F}_{\\mathrm{N - MC}}^{\\mathrm{ts}}</span>  (over which transactions are sent) towards  <span class="math">\\mathcal{A}</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Upon receiving (MULTICAST, sid,  <span class="math">(m_{i_1}, U_{i_1}), \\ldots, (m_{i_\\ell}, U_{i_\\ell})</span>  with list of transactions from  <span class="math">\\mathcal{A}</span>  on behalf some corrupted  <span class="math">P \\in \\mathcal{P}_{net}</span> , then do the following:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Submit the transaction(s) to the ledger on behalf of this corrupted party, and receive for each transaction the transaction id txid</li>

      <li>Forward the request to the internally simulated  <span class="math">\\mathcal{F}_{\\mathrm{N - MC}}^{\\mathrm{ts}}</span>  , which replies for each message with a message-ID mid</li>

      <li>Remember the association between each mid and the corresponding txid</li>

      <li>Provide  <span class="math">\\mathcal{A}</span>  with whatever the network outputs.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Upon receiving (MULTICAST, sid,  <span class="math">m</span> ) from  <span class="math">\\mathcal{A}</span>  on behalf of some corrupted party  <span class="math">P</span> , then execute the corresponding steps 1. to 4. as above.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Upon receiving (FETCH, sid) from  <span class="math">\\mathcal{A}</span>  on behalf some corrupted  <span class="math">P \\in \\mathcal{P}_{\\text{net}}</span>  forward the request to the simulated  <span class="math">\\mathcal{F}_{\\mathrm{N-MC}}^{\\mathrm{ts}}</span>  and return whatever is returned to  <span class="math">\\mathcal{A}</span> .</li>

      <li>Upon receiving (DELAYS, sid,  <span class="math">(T_{\\mathrm{mid}_{i_1}}, \\mathrm{mid}_{i_1}), \\ldots, (T_{\\mathrm{mid}_{i_\\ell}}, \\mathrm{mid}_{i_\\ell}))</span>  from  <span class="math">\\mathcal{A}</span>  forward the request to the simulated  <span class="math">\\mathcal{F}_{\\mathrm{N-MC}}^{\\mathrm{ts}}</span>  and return whatever is returned to  <span class="math">\\mathcal{A}</span> .</li>

      <li>Upon receiving (SWAP, sid, mid, mid') from  <span class="math">\\mathcal{A}</span>  forward the request to the simulated  <span class="math">\\mathcal{F}_{\\mathrm{N-MC}}^{\\mathrm{ts}}</span>  and return whatever is returned to  <span class="math">\\mathcal{A}</span> .</li>

    </ul>

    <p class="text-gray-300">Simulate the core staking procedure of party  <span class="math">U_{p}</span>  as in the protocol in round  <span class="math">\\tau</span> . This includes running procedures FetchInformation and UpdateStakeDist of party  <span class="math">U_{p}</span>  (using the emulated network).</p>

    <p class="text-gray-300">if update  <span class="math">U_{p,\\tau}</span>  then</p>

    <p class="text-gray-300">Send (CLOCK-UPDATE, sidC,  <span class="math">U_{p}</span> ) to  <span class="math">\\mathcal{A}</span>  if  <span class="math">\\mathcal{S}_{\\mathrm{ledg}}</span>  has received such an input in round  <span class="math">\\tau</span></p>

    <p class="text-gray-300">else</p>

    <p class="text-gray-300">Execute the StakingProcedure and set update  <span class="math">U_{p,\\tau} \\gets</span>  true</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Includes sending messages to the emulated network  <span class="math">\\mathcal{F}_{\\mathrm{N - MC}}^{\\mathrm{bs}}</span></li>

    </ul>

    <p class="text-gray-300">Before the activation goes to  <span class="math">\\mathcal{A}</span> , execute EXTENDEDGERSTATE( <span class="math">\\tau</span> ).</p>

    <p class="text-gray-300">end if</p>

    <p class="text-gray-300">Remember that party  <span class="math">U_{p}</span>  has completed for this round  <span class="math">\\tau</span> .</p>

    <p class="text-gray-300">for each synchronized party  <span class="math">U_{p}\\in S_{\\mathrm{alert}}\\cup S_{\\mathrm{syncStalled}}</span>  of round  <span class="math">\\tau</span>  do</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{C}_{\\mathrm{loc}}^{(U_p)}</span>  be the party's currently stored local chain.</p>

    <p class="text-gray-300">Determine the number of rounds  <span class="math">\\rho^{(U_p)}</span>  this party legs behind  <span class="math">\\tau</span> , i.e.,  <span class="math">\\rho^{(U_p)} = \\tau - t_{\\mathrm{on}}^{(U_p)}</span> .</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{C}_1^{(U_p)},\\ldots ,\\mathcal{C}_k^{(U_p)}</span>  be the chains contained in the receiver buffer  <span class="math">\\vec{M}^{(U_p)}</span>  of  <span class="math">\\mathcal{F}_{\\mathrm{N - MC}}^{\\mathrm{bs}}</span>  with delay at most  <span class="math">\\rho^{(U_p)}</span> .</p>

    <p class="text-gray-300">Evaluate  <span class="math">\\mathcal{C}_{U_p} \\gets \\text{maxvalid-bg}(\\mathcal{C}_{\\text{loc}}^{(U_p)}, \\mathcal{C}_1^{(U_p)}, \\ldots, \\mathcal{C}_k^{(U_p)})</span>  and let this chain's encoded state be  <span class="math">\\vec{\\mathbf{st}}_{U_p}</span> .</p>

    <p class="text-gray-300">end for</p>

    <p class="text-gray-300">Let  <span class="math">\\vec{\\mathbf{st}}</span>  be the longest state among all such states  <span class="math">\\vec{\\mathbf{st}}_{U_p}</span> ,  <span class="math">U_p \\in S_{\\mathrm{alert}} \\cup S_{\\mathrm{syncStalled}}</span>  from above.</p>

    <p class="text-gray-300">Compare  <span class="math">\\vec{\\mathbf{st}}^{\\uparrow k}</span>  with the current state state of the ledger</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">if  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{state}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathrm{st}}^{\\uparrow k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  then // Only pointers need adjustments</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Execute ADJUSTVIEW(state)</p>

    <p class="text-gray-300">end if</p>

    <p class="text-gray-300">if state is not a prefix of  <span class="math">\\vec{\\mathbf{st}}^{\\uparrow k}</span>  then // Simulation fails</p>

    <p class="text-gray-300">Abort simulation: consistency violation among synchronized parties. // Event BAD-CP  <span class="math">k</span></p>

    <p class="text-gray-300">end if</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Define the difference diff to be the block sequence s.t. state</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">diff =  <span class="math">\\vec{\\mathbf{st}}^{\\uparrow k}</span> .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Parse diff := diff1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">...</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">diffn.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">for  <span class="math">j = 1</span>  to  <span class="math">n</span>  do</p>

    <p class="text-gray-300">Map each transaction tx in this block to its unique transaction ID txid. If a transaction does not yet have a txid, then submit it to the ledger first and receive the corresponding txid from  <span class="math">\\mathcal{G}_{\\mathrm{LEDGER}}</span></p>

    <p class="text-gray-300">Let  <span class="math">\\mathrm{list}_j = (\\mathrm{txid}_{j,1},\\dots ,\\mathrm{txid}_{j,t_j})</span>  be the corresponding list for this block diff  <span class="math">j</span></p>

    <p class="text-gray-300">if coinbase  <span class="math">\\mathrm{txid}_{j,1}</span>  specifies a party honest at block creation time then</p>

    <p class="text-gray-300"><span class="math">\\mathrm{hFlag}_j \\gets 1</span></p>

    <p class="text-gray-300">else</p>

    <p class="text-gray-300"><span class="math">\\mathrm{hFlag}_j \\gets 0</span></p>

    <p class="text-gray-300">end if</p>

    <p class="text-gray-300">Output (NEXT-BLOCK, hFlagj, listj) to  <span class="math">\\mathcal{G}_{\\mathrm{LEDGER}}</span>  (receiving (NEXT-BLOCK, ok) as an immediate answer)</p>

    <p class="text-gray-300">end for</p>

    <p class="text-gray-300">if Fraction of blocks with hFlag = 0 in the recent <span class="math">k</span> blocks <span class="math">&amp;gt;1-\\mu</span> then Abort simulation: chain quality violation. // Event BAD-CQ_{μ,k} else if State increases less than <span class="math">k</span> blocks during the last <span class="math">\\frac{k}{\\tau_{\\text{CG}}}</span> rounds then Abort simulation: chain growth violation. // Event BAD-CG_{v_{CG},k/τ_{CG}} end if // If no bad event occurs, we can adjust pointers into this new state.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Execute AdjustView(state</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">diff)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">end procedure</p>

    <p class="text-gray-300">procedure AdjustView(state, <span class="math">\\tau</span>) // Adjust the view of synchronized parties. pointers <span class="math">\\leftarrow\\varepsilon</span> for <span class="math">U_{p}\\in\\mathcal{P}</span> of round <span class="math">\\tau</span> do Let <span class="math">\\mathcal{C}_{\\text{loc}}^{(U_{p})}</span> be the party’s currently stored local chain. Determine the number of rounds <span class="math">\\rho^{(U_{p})}</span> this party legs behind <span class="math">\\tau</span>, i.e., <span class="math">\\rho^{(U_{p})}=\\tau-\\iota_{\\text{on}}^{(U_{p})}</span>. Let <span class="math">\\mathcal{C}_{1}^{(U_{p})},\\ldots,\\mathcal{C}_{k}^{(U_{p})}</span> be the chains contained in the receiver buffer <span class="math">\\vec{M}^{(U_{p})}</span> of <span class="math">\\mathcal{F}_{\\text{N-MC}}^{\\text{he}}</span> with delay at most <span class="math">\\rho^{(U_{p})}</span>. Evaluate <span class="math">\\mathcal{C}_{U_{p}}\\leftarrow\\text{maxvalid-bg}(\\mathcal{C}_{\\text{loc}}^{(U_{p})},\\mathcal{C}_{1}^{(U_{p})},\\ldots,\\mathcal{C}_{k}^{(U_{p})})</span> and let this chain’s encoded state be <span class="math">\\vec{\\text{st}}_{U_{p}}</span>. end for for each synchronized party <span class="math">U_{p}\\in\\mathcal{S}_{\\text{alert}}\\cup\\mathcal{S}_{\\text{syncStalled}}</span> of round <span class="math">\\tau</span> do</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Determine the pointer <span class="math">\\text{pt}_{U_{p}}</span> s.t. $\\vec{\\text{st}}_{U_{p}}^{\\left[k\\right.}=\\text{state}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\text{pt}_{U_{p}}}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">if such a pointer value does not exist then return // Call on invalid input or event BAD-CP_{k} occurred end if if update<span class="math">{}_{U_{p},\\tau}=</span> false then // Party did not start StakingProcedure in <span class="math">\\tau</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pointers $\\leftarrow\\text{pointers}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(U_{p},\\text{pt}_{U_{p}})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">end if // As otherwise, the new state is only fetched in the next round end for Output (set-slack, pointers) to <span class="math">\\mathcal{G}_{\\text{ledger}}</span> // Now, adjust the view of de-synchronized parties. pointers <span class="math">\\leftarrow\\varepsilon</span> desyncStates <span class="math">\\leftarrow\\varepsilon</span> for each de-synchronized party <span class="math">U_{p}\\in\\mathcal{P}_{DS}</span> do if update<span class="math">{}_{U_{p},\\tau}=</span> false then</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Set the pointer <span class="math">\\text{pt}_{U_{p}}</span> to be $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\text{st}}_{U_{p}}^{\\left[k\\right.}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">desyncStates $\\leftarrow\\text{desyncState}</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(U_{p},\\vec{\\text{st}}_{U_{p}}^{\\left[k\\right.})$</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">end if // As otherwise, the new state is only fetched in the next round Output (set-slack, pointers) to <span class="math">\\mathcal{G}_{\\text{ledger}}</span> Output (desync-state, desyncStates) to <span class="math">\\mathcal{G}_{\\text{ledger}}</span> end for end procedure</p>

    <h2 id="sec-79" class="text-2xl font-bold">Appendix D Proof-of-Stake Assumptions as a UC Wrapper</h2>

    <p class="text-gray-300">This section includes complementary material for the main body. We sketch below the wrapper functionality that is applied to the hybrid functionalities used by Ouroboros-Genesis. For details on more background of functionality wrappers we refer to <em>[3]</em>. In a nutshell, the wrapper observes the advancement of the entire system and checks whether the proportional stake of alert parties, of corrupted or de-synchronized parties, and of stalled parties are withing the allowed range specified as required by our main theorems.</p>

    <p class="text-gray-300">Functionality <span class="math">\\mathcal{W}_{\\mathrm{OG}}^{P_{\\mathrm{OS}}}(\\cdot)</span></p>

    <p class="text-gray-300">The wrapper functionality is parameterized by the bounds <span class="math">\\alpha</span>,<span class="math">\\beta</span> on the alert and participating stake ratio (see Definition 2), respectively, the network delay and a value <span class="math">\\varepsilon&gt;0</span> (the parameter that describes the gap between the honest and adversarial stake). The wrapper is assumed to be registered with the global clock <span class="math">\\mathcal{G}_{\\textsc{clock}}</span> and is aware of sets of registered parties, and the set of corrupted parties.</p>

    <p class="text-gray-300">General:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Upon receiving any request <span class="math">I</span> from any party <span class="math">U_{p}</span> or from <span class="math">\\mathcal{A}</span> (possibly on behalf of a party <span class="math">U_{p}</span> which is corrupted) to a wrapped hybrid functionality, record the request <span class="math">I</span> together with its source and the current time.</li>

      <li>The wrapper keeps track of the active parties and their relative share to the stake distribution.</li>

    </ul>

    <p class="text-gray-300">Restrictions on obtaining VRF proofs:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Upon receiving (EvalProve, sid, <span class="math">\\cdot</span>) to <span class="math">\\mathcal{F}_{\\textsf{VRF}}</span> from <span class="math">\\mathcal{A}</span> on behalf of a party <span class="math">U_{p}</span> which is corrupted or registered but de-synchronized do the following:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If the fraction of alert stake relative to all active stake in this round <span class="math">\\tau</span> so far does not satisfy the honest majority condition 4 (of Theorems 1 and 2) then ignore the request.</li>

      <li>Otherwise, forward the request to <span class="math">\\mathcal{F}_{\\textsf{VRF}}</span> and return to <span class="math">\\mathcal{A}</span> whatever <span class="math">\\mathcal{G}_{\\textsc{RO}}</span> returns.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Upon receiving (EvalProve, sid, <span class="math">\\cdot</span>) to <span class="math">\\mathcal{F}_{\\textsf{VRF}}</span> from an alert party <span class="math">U_{p}</span> do the following:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Forward the request to <span class="math">\\mathcal{F}_{\\textsf{VRF}}</span> and return to <span class="math">\\mathcal{A}</span> whatever <span class="math">\\mathcal{G}_{\\textsc{RO}}</span> returns.</li>

      <li>If the minimal fraction (in stake) of participation (of alert parties and in total) as demanded by Theorem 1 (and Theorem 2) is reached in round <span class="math">\\tau</span>, send (clock-update, sid_{C}) to <span class="math">\\mathcal{G}_{\\textsc{clock}}</span> to release the clock for this round.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Any other request is relayed to the underlying functionality (and recorded by the wrapper) and the corresponding output is given to the destination specified by the underlying functionality.</li>

    </ul>

    <h2 id="sec-80" class="text-2xl font-bold">Appendix E Proof of Theorem 1</h2>

    <p class="text-gray-300">In this appendix we prove Theorem 1. We begin with a detailed treatment of the relevant machinery from <em>[14]</em> for reasoning about blockchain “forks” and the common prefix property in the semi-synchronous setting. Our setting—which provides the adversary adaptive control over availability of the participating parties—appears to require significant further considerations. In particular, the techniques of <em>[14]</em> assume that slot leaders are elected by an <em>independent</em> process, so that various relevant events (such as whether a unique party has been assigned to a particular slot) are independent across distinct slots. The stronger adversary in the dynamic availability setting can conspire to correlate such events. Our analysis handles such correlations by modeling the underlying process of leader assignment as a martingale, and constructs a parallel theory to that of <em>[14]</em> that supports these richer distributions. Our exposition is self-contained; however, in some cases where the particular arguments are similar in spirit to the treatment in <em>[14]</em>, we only sketch them.</p>

    <p class="text-gray-300">In Sections E.1 and E.2 we briefly lay out the framework of forks, divergence, and <span class="math">\\Delta</span>-reduction developed by Kiayias et al. <em>[22]</em> and David et al. <em>[14]</em>. With these definitions set down, we proceed in Section E.3 to the new proofs of divergence for the richer distributions induced by an adversary in the setting with dynamic availability. We then describe the exact distribution of the characteristic strings that arises in the real experiment in Section E.4 and combine these results in E.5 to establish common prefix, chain growth, and chain quality for a single epoch. Finally, we lift these results into the multi-epoch setting in Section E.6.</p>

    <p class="text-gray-300">Note that Theorem 1, and hence also this whole section, works in the so-called setting with static <span class="math">\\mathcal{F}_{\\textsc{N-MC}}</span>-registration as defined in Section 4.2, postulating that all honest parties are registered with the network functionality <span class="math">\\mathcal{F}_{\\textsc{N-MC}}</span> from the beginning and never deregister. Therefore, all honest parties are guaranteed to be <em>online</em> and <em>synchronized</em>. However, not all honest parties are guaranteed to be <em>alert</em>, as some of them might still be <em>time-unaware</em> or <em>stalled</em> (cf. Fig. 1).</p>

    <p class="text-gray-300">We approach these two classes of parties in different ways in the formal treatment below: for <em>stalled</em> honest parties that are <em>time-aware</em>, we treat the slots where they would be the only slot leaders as empty</p>

    <p class="text-gray-300">slots. Looking ahead, this leads to the adaptive control of the environment over the emptiness of slots (via stalling alert parties), which warrants our martingale-based treatment. On the other hand, the honest parties that are <em>time-unaware</em> pose a risk for all slots for which they are eligible slot leaders, as even though they are not corrupted at the moment, they are not able to properly evolve their key and hence their later corruption would have detrimental effects for such slots. Therefore, we account for these parties by treating them identically to adversarial parties (namely, including them in the set of <em>active</em> parties), even though formally they are not adversarial.</p>

    <h3 id="sec-81" class="text-xl font-semibold mt-8">E.1 Forks and Divergence in the Semi-synchronous Setting</h3>

    <p class="text-gray-300">We recall the notion of a <em>characteristic string</em>, which we use to record, for each slot in a sequence of slots, whether any leader is elected for the slot and, if that is the case, whether this leader is unique and alert.</p>

    <h6 id="sec-82" class="text-base font-medium mt-4">Definition 8 (Characteristic string).</h6>

    <p class="text-gray-300">Let <span class="math">S=\\{\\texttt{sl}_{1},\\ldots,\\texttt{sl}_{R}\\}</span> be a sequence of slots of length <span class="math">R</span>; consider an execution (with adversary <span class="math">\\mathcal{A}</span> and environment <span class="math">\\mathcal{Z}</span>) of the protocol. For a slot <span class="math">\\texttt{sl}_{j}</span>, let <span class="math">\\mathrm{P}(j)</span> denote the set of active parties assigned to be slot leaders for slot <span class="math">j</span> by the protocol. We define the <em>characteristic string</em> <span class="math">w\\in\\{0,1,\\bot\\}^{R}</span> of <span class="math">S</span> to be the random variable so that</p>

    <p class="text-gray-300">\\[ w_{j}=\\begin{cases}\\bot&\\text{if }\\mathrm{P}(j)=\\emptyset,\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0&\\text{if }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{P}(j)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1\\text{ and the assigned party is alert,}\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">1&\\text{otherwise.}\\end{cases} \\] (8)</p>

    <p class="text-gray-300">For such a characteristic string <span class="math">w\\in\\{0,1,\\bot\\}^{<em>}</span> we say that the index <span class="math">j</span> is </em>uniquely alert<em> if <span class="math">w_{j}=0</span>, </em>empty<em> if <span class="math">w_{j}=\\bot</span>, and </em>potentially active* if <span class="math">w_{j}\\in\\{0,1\\}</span>.</p>

    <p class="text-gray-300">We emphasize that the characteristic string resulting from an execution is determined by both the nonce (and the effective leader selection process), the adaptive adversary <span class="math">\\mathcal{A}</span>, and the environment <span class="math">\\mathcal{Z}</span> (which, in particular, determines the stake distribution).</p>

    <h6 id="sec-83" class="text-base font-medium mt-4">Remark 3.</h6>

    <p class="text-gray-300">A reader familiar with the treatment in <em>[14]</em> will notice that Definition 8 syntactically differs from the definition of a characteristic string in <em>[14]</em>, by only considering <em>active</em> parties, and by assigning the symbol <span class="math">0</span> only to slots that have a unique <em>alert</em> slot leader, as opposed to a unique <em>honest</em> one. This is because the analysis in <em>[14]</em> does not consider stalled parties, and hence there an honest party is always alert and all parties are active. The semantics of the definition is maintained: a slot labeled by <span class="math">0</span> in both cases guarantees that there is will be exactly one block created for this slot, and it will be created according to the protocol. Additionally, a slot labeled by <span class="math">\\bot</span> guarantees that no party (either honest or adversarial) is in the position to create a block for this slot. This syntactic difference propagates also to some of the following definitions and statements, we will refrain from pointing it out repeatedly.</p>

    <p class="text-gray-300">The notion of a <span class="math">\\Delta</span>-fork is the analytic tool developed by David et al. <em>[14]</em> to reason about the various blockchains that can be induced by an adversary in the <span class="math">\\Delta</span>-synchronous setting with a particular characteristic string.</p>

    <h6 id="sec-84" class="text-base font-medium mt-4">Definition 9 (<span class="math">\\Delta</span>-fork).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">w\\in\\{0,1,\\bot\\}^{k}</span> and <span class="math">\\Delta</span> be a non-negative integer. Let $A=\\{i\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,w_{i}\\neq\\bot\\}<span class="math"> denote the set of potentially active indices, and let </span>H=\\{i\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,w_{i}=0\\}<span class="math"> denote the set of uniquely alert indices. A </span>\\Delta<span class="math">-fork for the string </span>w<span class="math"> is a rooted tree </span>F=(V,E)<span class="math"> with a labeling </span>\\ell:V\\to\\{0\\}\\cup A$ so that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the root <span class="math">r\\in V</span> is given the label <span class="math">\\ell(r)=0</span>;</li>

      <li>the labels along any (simple) path beginning at the root are strictly increasing;</li>

      <li>each uniquely alert index <span class="math">i\\in H</span> is the label of exactly one vertex of <span class="math">F</span>;</li>

      <li>the function <span class="math">\\mathbf{d}:H\\to\\{1,\\ldots,k\\}</span>, defined so that <span class="math">\\mathbf{d}(i)</span> is the depth in <span class="math">F</span> of the unique vertex <span class="math">v</span> for which <span class="math">\\ell(v)=i</span>, satisfies the following <span class="math">\\Delta</span>-monotonicity property: if <span class="math">i,j\\in H</span> and <span class="math">i+\\Delta&lt;j</span>, then <span class="math">\\mathbf{d}(i)&lt;\\mathbf{d}(j)</span>.</li>

    </ol>

    <p class="text-gray-300">For convenience, we direct the edges of forks so that depth increases along each edge; then there is a unique directed path from the root to each vertex and, in light of (ii), labels along such a path are strictly increasing. As a matter of notation, we write <span class="math">F\\vdash_{\\Delta}w</span> to indicate that <span class="math">F</span> is a <span class="math">\\Delta</span>-fork for the string <span class="math">w</span>. We typically refer to a <span class="math">\\Delta</span>-fork as simply a “fork”.</p>

    <p class="text-gray-300">The relationship between executions and <span class="math">\\Delta</span>-forks is formally described in <em>[14]</em>. Here we only recall the basic intuition: With an execution of Ouroboros Genesis we may associate the collection of all valid blockchains that were adopted by honest players as a result of their application of the maxvalid rule. Observe that any two blockchains held by honest players agree on some common prefix (including, at the very least, the genesis block); on the other hand, aside from this common prefix, the blockchains are entirely disjoint. Thus the union of these blockchains forms a natural “tree of blocks”, which is reflected by the notion of fork above. Indeed, the axiom (ii) reflects the fact that blocks in a valid blockchain must be associated with strictly increasing time slots, while axiom (iii) reflects the fact that an honest, alert slot leader emits exactly one block (associated with that slot). The axiom (iv) reflects the fact that an honest party <span class="math">p</span> at time <span class="math">t</span> must have received any blocks produced by honest parties at times prior to <span class="math">t-\\Delta</span>; thus the depth of any block produced by <span class="math">p</span> must exceed the depths of those blocks produced by these earlier honest parties. Thus, while a fork is clearly an abstraction that neglects some aspects of the execution, it does capture its salient features with respect to common prefix violations; see Remark 4 below.</p>

    <h6 id="sec-85" class="text-base font-medium mt-4">Definition 10 (Tines, length, and viability).</h6>

    <p class="text-gray-300">A path in a fork <span class="math">F</span> originating at the root is called a <em>tine</em>. For a tine <span class="math">t</span> we let <span class="math">\\texttt{length}(t)</span> denote its <em>length</em>, equal to the number of edges on the path. For a vertex <span class="math">v</span>, we call the length of the tine terminating at <span class="math">v</span> the <em>depth of <span class="math">v</span></em>. For convenience, we overload the notation <span class="math">\\ell(\\cdot)</span> so that it applies to tines by defining <span class="math">\\ell(t)\\triangleq\\ell(v)</span>, where <span class="math">v</span> is the terminal vertex on the tine <span class="math">t</span>. We say that a tine <span class="math">t</span> is <span class="math">\\Delta</span>-viable if <span class="math">\\texttt{length}(t)\\geq\\max_{h+\\Delta\\leq\\ell(t)}\\mathbf{d}(h)</span>, this maximum extended over all uniquely alert indices <span class="math">h</span> (appearing <span class="math">\\Delta</span> or more slots before <span class="math">\\ell(t)</span>). Note that any tine terminating in a uniquely alert vertex is necessarily viable by the <span class="math">\\Delta</span>-monotonicity property.</p>

    <p class="text-gray-300">A remark on the intuition behind viability: A viable tine is one which—at least in principle—could have been accepted as the longest chain by an alert party. In particular, if the last block of the chain is associated with slot <span class="math">t</span>, the chain must have length at least that of all honest chains produced no later than <span class="math">t-\\Delta</span>, as these would necessarily be observed by any alert player at time <span class="math">t+1</span>.</p>

    <h6 id="sec-86" class="text-base font-medium mt-4">Definition 11 (Divergence).</h6>

    <p class="text-gray-300">Let <span class="math">F</span> be a <span class="math">\\Delta</span>-fork for a string <span class="math">w\\in\\{0,1,\\bot\\}^{*}</span>. For two <span class="math">\\Delta</span>-viable tines <span class="math">t</span> and <span class="math">t^{\\prime}</span> of <span class="math">F</span>, we define the notation <span class="math">t/t^{\\prime}</span> by the rule</p>

    <p class="text-gray-300"><span class="math">t/t^{\\prime}=\\texttt{length}(t)-\\texttt{length}(t\\cap t^{\\prime})\\,,</span></p>

    <p class="text-gray-300">where <span class="math">t\\cap t^{\\prime}</span> denotes the common prefix of <span class="math">t</span> and <span class="math">t^{\\prime}</span>. Then define the <em>divergence</em> of two viable tines <span class="math">t_{1}</span> and <span class="math">t_{2}</span> to be the quantity</p>

    <p class="text-gray-300">\\[ \\operatorname{div}(t_{1},t_{2})=\\begin{cases}t_{1}/t_{2}&\\text{if }\\ell(t_{1})<\\ell(t_{2}),\\\\ t_{2}/t_{1}&\\text{if }\\ell(t_{2})<\\ell(t_{1}),\\\\ \\max(t_{1}/t_{2},t_{2}/t_{1})&\\text{if }\\ell(t_{1})=\\ell(t_{2}).\\end{cases} \\]</p>

    <p class="text-gray-300">We extend this notation to the fork <span class="math">F</span> by maximizing over viable tines: <span class="math">\\operatorname{div}_{\\Delta}(F)\\triangleq\\max_{t_{1},t_{2}}\\operatorname{div}(t_{1},t_{2})</span>, taken over all pairs of <span class="math">\\Delta</span>-viable tines of <span class="math">F</span>. Finally, we define the <span class="math">\\Delta</span>-divergence of a characteristic string <span class="math">w</span> to be the maximum over all <span class="math">\\Delta</span>-forks: <span class="math">\\operatorname{div}_{\\Delta}(w)\\triangleq\\max_{F\\vdash_{\\Delta}w}\\operatorname{div}_{\\Delta}(F)</span>.</p>

    <h6 id="sec-87" class="text-base font-medium mt-4">Remark 4.</h6>

    <p class="text-gray-300">Divergence provides an immediate bound on common prefix violations. In particular, any execution of the protocol inducing a characteristic string <span class="math">w</span> produces honest blockchains satisfying the <span class="math">\\operatorname{div}_{\\Delta}(w)</span>-common prefix property.</p>

    <p class="text-gray-300">Given the above, we will now focus on bounding the <span class="math">\\Delta</span>-divergence of characteristic strings arising from protocol executions.</p>

    <p class="text-gray-300">E.2 The Reduction Mapping</p>

    <p class="text-gray-300">David et al. <em>[14]</em> provided a method for bounding <span class="math">\\Delta</span>-divergence by establishing a direct connection between <span class="math">\\Delta</span>-divergence and divergence in the synchronous setting (when <span class="math">\\Delta=0</span>). We will rely on this machinery and here record its basic tools.</p>

    <h6 id="sec-88" class="text-base font-medium mt-4">Definition 12 (Synchronous characteristic strings and forks).</h6>

    <p class="text-gray-300">A synchronous characteristic string is an element of <span class="math">\\{0,1\\}^{*}</span>. A synchronous fork <span class="math">F</span> for a (synchronous) characteristic string <span class="math">w</span> is a <span class="math">0</span>-fork <span class="math">F\\vdash_{0}w</span>.</p>

    <h6 id="sec-89" class="text-base font-medium mt-4">Definition 13 (Reduction mapping <em>[14]</em>).</h6>

    <p class="text-gray-300">For <span class="math">\\Delta\\in\\mathbb{N}</span>, we define the function <span class="math">\\rho_{\\Delta}\\colon\\{0,1,\\bot\\}^{<em>}\\to\\{0,1\\}^{</em>}</span> inductively as follows:</p>

    <p class="text-gray-300">\\[ \\begin{split}\\rho_{\\Delta}(\\epsilon)&=\\epsilon,\\\\ \\rho_{\\Delta}(\\bot\\parallel w^{\\prime})&=\\rho_{\\Delta}(w^{\\prime}),\\\\ \\rho_{\\Delta}(1\\parallel w^{\\prime})&=1\\parallel\\rho_{\\Delta}(w^{\\prime}),\\\\ \\rho_{\\Delta}(0\\parallel w^{\\prime})&=\\begin{cases}0\\parallel\\rho_{\\Delta}(w^{\\prime})&\\text{if }w^{\\prime}\\in\\bot^{\\Delta-1}\\parallel\\{0,1,\\bot\\}^{*},\\\\ 1\\parallel\\rho_{\\Delta}(w^{\\prime})&\\text{otherwise.}\\end{cases}\\end{split} \\] (9)</p>

    <p class="text-gray-300">We call <span class="math">\\rho_{\\Delta}</span> the <em>reduction mapping for delay</em> <span class="math">\\Delta</span>. It will be convenient for us to naturally extend the definition of <span class="math">\\rho_{\\Delta}</span> to infinite strings over the alphabet <span class="math">\\{0,1,\\bot\\}</span>.</p>

    <p class="text-gray-300">The reduction map provides the basic connection between <span class="math">\\Delta</span>-divergence and (synchronous) divergence. This is reflected by the lemma below, established by David et al. <em>[14]</em>.</p>

    <h6 id="sec-90" class="text-base font-medium mt-4">Lemma 4 (<em>[14]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">w\\in\\{0,1,\\bot\\}^{*}</span>. Then <span class="math">\\operatorname{div}_{\\Delta}(w)\\leq\\operatorname{div}_{0}(\\rho_{\\Delta}(w))</span>.</p>

    <p class="text-gray-300">We will require also a lemma controlling the behavior of reduction for prefixes of a given string. Here we use the notation <span class="math">x\\prec y</span> to indicate the the string <span class="math">x</span> is a prefix of the string <span class="math">y</span>.</p>

    <h6 id="sec-91" class="text-base font-medium mt-4">Lemma 5 (Implicit in <em>[14]</em>).</h6>

    <p class="text-gray-300">If <span class="math">w,w^{\\prime}\\in\\{0,1,\\bot\\}^{*}</span> and <span class="math">w\\prec w^{\\prime}</span>, then <span class="math">\\rho_{\\Delta}(w)^{\\lceil\\Delta}\\prec\\rho_{\\Delta}(w^{\\prime})</span>.</p>

    <h6 id="sec-92" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The proof proceeds by induction on the length of <span class="math">w</span>. When $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\Delta<span class="math">, observe that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho_{\\Delta}(w)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\Delta<span class="math"> and hence </span>\\rho_{\\Delta}(w)^{\\lceil\\Delta}=\\epsilon<span class="math">. Otherwise </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>\\Delta<span class="math"> and we may write </span>w=ax<span class="math"> for a single symbol </span>a<span class="math"> (and a substring </span>x<span class="math">). According to the definition, </span>\\rho_{\\Delta}(ax)=\\alpha\\rho_{\\Delta}(x)<span class="math"> for some </span>\\alpha\\in\\{\\epsilon,0,1\\}<span class="math"> that is determined solely by the first </span>\\Delta<span class="math"> symbols of </span>w<span class="math">; these agree with </span>w^{\\prime}<span class="math">. By induction </span>\\rho(x)=\\rho(x^{\\prime})<span class="math">, where </span>w^{\\prime}=ax^{\\prime}$, which concludes the proof. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-93" class="text-xl font-semibold mt-8">E.3 Reduction and Divergence with Stalled Parties</h3>

    <p class="text-gray-300">With these definitions and lemmas behind us, we are prepared to bound divergence (and common prefix) in our setting with stalled parties.</p>

    <h6 id="sec-94" class="text-base font-medium mt-4">Definition 14 (The characteristic conditions).</h6>

    <p class="text-gray-300">Consider a family of random variables <span class="math">W_{1},\\ldots,W_{n}</span> taking values in <span class="math">\\{0,1,\\bot\\}</span>. We say that they satisfy the <span class="math">(f;\\gamma)</span>-characteristic conditions if, for each <span class="math">k\\geq 1</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr[W_{k}=\\bot\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,W_{1},\\ldots,W_{k-1}]\\geq(1-f)\\,,$</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">$\\Pr[W_{k}=1\\,</td>

            <td class="px-3 py-2 border-b border-gray-700">\\,W_{1},\\ldots,W_{k-1},W_{k}\\neq\\bot]\\leq 1-\\gamma\\,.$</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In the expressions above, conditioning on a collection of random variables indicates that the statement is true for any conditioning on the values taken by variables. We may naturally apply the same terminology to infinite sequences of variables taking values in <span class="math">\\{0,1,\\bot\\}</span>.</p>

    <p class="text-gray-300">Specifically, for an adversary constrained to <span class="math">(1-\\epsilon)/2</span> stake ratio, the characteristic string <span class="math">w_{1},\\ldots,w_{R}</span> induced for an epoch of length <span class="math">R</span> roughly satisfies the <span class="math">(f;(1+\\epsilon)/2)</span>-characteristic conditions. (We lay out the exact details in the next section.) Our strategy for bounding <span class="math">\\operatorname{div}_{\\Delta}(w)</span> will be to analyze the structure of the induced distribution <span class="math">\\rho_{\\Delta}(w)</span> (assuming that <span class="math">w</span> satisfies the characteristic conditions) and then directly bound the (synchronous) divergence of the resulting (synchronous) characteristic string.</p>

    <p class="text-gray-300">.</p>

    <p class="text-gray-300">The structure of the reduced distribution <span class="math">\\rho_{\\Delta}(w)</span>. As mentioned above, we begin by analyzing the structure of the distribution given by <span class="math">\\rho_{\\Delta}(w)</span>. Specifically, we will show that these random variables are almost super-binomial, in the sense that after trimming a short suffix, they satisfy a family of martingale conditions which guarantee that each random variable, conditioned on all prior values, takes the value <span class="math">0</span> with probability at least <span class="math">\\gamma(1-f)^{\\Delta-1}</span>. Finally, we appeal to a theorem of Kiayias et al. <em>[22]</em> and Russell et al. <em>[29]</em> to establish that <span class="math">\\rho_{\\Delta}(w)</span> is unlikely to have large divergence.</p>

    <h6 id="sec-95" class="text-base font-medium mt-4">Definition 15 (The super-binomial martingale conditions).</h6>

    <p class="text-gray-300">Consider a family of random variables <span class="math">X_{1},\\ldots,X_{n}</span> taking values in <span class="math">\\{0,1\\}^{n}</span>. We say that they satisfy the <span class="math">\\gamma</span>-super-binomial martingale conditions (or, simply, the <span class="math">\\gamma</span>-martingale conditions) if</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\Pr[X_{k}</span> $=0\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,X_{1},\\ldots,X_{k-1}]\\geq\\gamma\\,,\\text{and hence}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We may naturally apply the same terminology to infinite sequences of variables taking values in <span class="math">\\{0,1\\}</span>.</p>

    <p class="text-gray-300">It is convenient to explore first the structure of an infinite sequence of these variables, as these do not require any “trimming” in order to provide the martingale conditions.</p>

    <h6 id="sec-96" class="text-base font-medium mt-4">Lemma 6 (Structure of the induced distribution without boundary conditions).</h6>

    <p class="text-gray-300">Let <span class="math">W=W_{1},W_{2},\\ldots</span> be an infinite sequence of random variables, each taking values in <span class="math">\\{\\bot,0,1\\}</span>, which satisfy the <span class="math">(f;\\gamma)</span>-characteristic conditions and let</p>

    <p class="text-gray-300"><span class="math">X=\\rho_{\\Delta}(W)</span></p>

    <p class="text-gray-300">be the random variables obtained by applying the reduction mapping (for delay <span class="math">\\Delta</span>) to <span class="math">W</span>. Then <span class="math">X=X_{1},\\ldots,</span> satisfy the <span class="math">\\gamma(1-f)^{(\\Delta-1)}</span>-martingale conditions.</p>

    <h6 id="sec-97" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">For each <span class="math">k\\geq 1</span> we wish to establish that the random variables <span class="math">X_{1},\\ldots,X_{k}</span> satisfy the <span class="math">\\gamma(1-f)^{(\\Delta-1)}</span>-super-binomial martingale conditions. We prove these conditions under further conditioning. Specifically, we say that a finite sequence <span class="math">w_{1},\\ldots,w_{\\ell}</span>, where each <span class="math">w_{i}\\in\\{0,1,\\bot\\}</span>, is a <span class="math">t</span>-sequence if exactly <span class="math">t</span> of the <span class="math">w_{i}</span> are elements of <span class="math">\\{0,1\\}</span>. For a <span class="math">(k-1)</span>-sequence <span class="math">w</span>, let <span class="math">E_{w}</span> denote the event that <span class="math">W_{i}=w_{i}</span> (for each <span class="math">1\\leq i\\leq\\ell</span>) and that <span class="math">W_{\\ell+1}\\neq\\bot</span>. Observe that these events <span class="math">E_{w}</span>, taken over all <span class="math">(k-1)</span>-sequences <span class="math">w</span> of all possible lengths <span class="math">\\ell</span>, partition the probability space over which <span class="math">W_{1},W_{2},\\ldots</span> is defined. Furthermore, for any <span class="math">(k-1)</span>-sequence <span class="math">w</span>, conditioning on <span class="math">E_{w}</span> determines the random variables <span class="math">X_{1},\\ldots,X_{k-1}</span>; we write <span class="math">\\rho_{\\Delta}(w)</span> to denote the unique assignment to <span class="math">X_{1},\\ldots,X_{k-1}</span> resulting from this <span class="math">(k-1)</span>-sequence <span class="math">w</span>. It follows that, for any fixed <span class="math">x_{1},\\ldots,x_{k-1}</span>, the events <span class="math">E_{w}</span> for which <span class="math">\\rho_{\\Delta}(w)=x_{1},\\ldots,x_{k-1}</span> partition the event that the random variables <span class="math">X_{1},\\ldots,X_{k-1}</span> take the values <span class="math">x_{1},\\ldots,x_{k-1}</span>. Finally, observe that—conditioned on any specific <span class="math">E_{w}</span>—the <span class="math">(f,\\gamma)</span>-characteristic conditions guarantee that <span class="math">(W_{\\ell},W_{\\ell+1},\\ldots,W_{\\ell+(\\Delta-1)})=(0,\\bot,\\ldots,\\bot)</span> with probability at least <span class="math">\\gamma(1-f)^{\\Delta-1}</span>. In this case, <span class="math">X_{k}=0</span>, and we conclude that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr[X_{k}=0\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,E_{w}]\\geq\\gamma(1-f)^{\\Delta-1}\\,.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It follows that for any fixed values <span class="math">x_{1},\\ldots,x_{k-1}</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr[X_{k}=0\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,X_{i}=x_{i}]\\geq\\gamma(1-f)^{\\Delta-1}\\,,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">as desired. ∎</p>

    <p class="text-gray-300">We record two immediate applications of Azuma’s inequality for random variables satisfying the <span class="math">\\gamma</span>-super-binomial martingale conditions.</p>

    <h6 id="sec-98" class="text-base font-medium mt-4">Lemma 7.</h6>

    <p class="text-gray-300">Let <span class="math">X_{1},\\ldots,X_{n}</span> satisfy the <span class="math">\\gamma</span>-super-binomial martingale conditions with <span class="math">\\gamma\\geq 1/2</span>. Then, for any <span class="math">\\delta&gt;0</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\#_{0}(X)\\leq(1-\\delta)\\gamma n]\\leq\\exp\\left(-\\delta^{2}n/2\\right)</span> (10)</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\#_{0}(X)-\\#_{1}(X)\\leq(1-\\delta)(2\\gamma-1)n]</span> <span class="math">\\leq\\exp\\left(-\\frac{\\delta^{2}(2\\gamma-1)^{2}n}{8\\gamma^{2}}\\right)</span> (11) <span class="math">\\leq\\exp\\left(-\\delta^{2}(2\\gamma-1)^{2}n/8\\right)\\,,</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where $\\#_{0}(X)=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{i\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,X_{i}=0\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>\\#_{1}(X)=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{i\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,X_{i}=1\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-99" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For (10), consider the random variables <span class="math">H_{k}=\\sum_{i=1}^{k}((1-X_{i})-\\gamma)=\\#_{0}(X_{1},\\ldots,X_{k})-k\\gamma</span>. Observe that $\\mathbb{E}[H_{k}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,H_{1},\\ldots H_{k-1}]\\geq H_{k-1}<span class="math"> and that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{k}-H_{k-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\max(\\gamma,1-\\gamma)=\\gamma<span class="math">, as </span>\\gamma\\geq 1/2<span class="math">. Applying Azuma’s inequality (Theorem 9 in Appendix F) to the variables </span>H_{k}$ yields</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\Pr[H_{n}\\leq-\\delta\\gamma n]\\leq\\exp(-\\delta^{2}n/2)\\,,</span></p>

    <p class="text-gray-300">equivalent to (10). As for (11), consider the random variables</p>

    <p class="text-gray-300"><span class="math">B_{k}=2\\sum_{i=1}^{k}(1-X_{i}-\\gamma)=\\left(\\#_{0}(X_{1}\\ldots X_{k})-\\#_{1}(X_{1}\\ldots X_{k})\\right)-k(2\\gamma-1)\\,.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Then $\\mathbb{E}[B_{k}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,B_{1},\\ldots,B_{k-1}]\\geq B_{k-1}<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B_{t}-B_{t-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2\\gamma<span class="math"> as </span>\\gamma\\geq 1/2<span class="math">; applying Azuma’s inequality to the random variables </span>B_{k}$ yields (11). ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-100" class="text-base font-medium mt-4">Lemma 8 (Structure of the induced distribution).</h6>

    <p class="text-gray-300">Let <span class="math">W=W_{1}\\cdots W_{n}</span> be a sequence of random variables, each taking values in <span class="math">\\{\\bot,0,1\\}</span>, which satisfy the <span class="math">(f;\\gamma)</span>-characteristic conditions and let</p>

    <p class="text-gray-300"><span class="math">X=X_{1}\\cdots X_{\\ell}=\\rho_{\\Delta}(W_{1}\\cdots W_{n})</span></p>

    <p class="text-gray-300">be the random variables obtained by applying the reduction mapping (for delay <span class="math">\\Delta</span>) to <span class="math">W</span>. Then there is a sequence of random variables <span class="math">Z_{1},Z_{2},\\ldots</span>, each taking values in <span class="math">\\{0,1\\}</span>, so that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the random variables <span class="math">Z_{1},\\ldots,</span> satisfy the <span class="math">\\gamma(1-f)^{\\Delta-1}</span>-martingale conditions;</li>

      <li><span class="math">X_{1},\\ldots,X_{\\ell-\\Delta}=\\rho_{\\Delta}(W)^{\\lceil\\Delta\\hskip 1.0pt}\\text{is a prefix of }Z_{1}Z_{2}\\cdots</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Under the further condition that $\\Pr[W_{i}=\\bot\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,W_{1},\\ldots,W_{i-1}]\\leq(1-a)\\,,$ we also have:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the random variable <span class="math">\\ell</span> satisfies, for any <span class="math">\\delta&gt;0</span>,</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\Pr[\\ell&lt;(1-\\delta)an]\\leq\\exp\\left(-\\frac{\\delta^{2}a^{2}n}{2(1-a)^{2}}\\right)\\leq\\exp\\left(-\\delta^{2}a^{2}n/2\\right)\\,;</span> (12)</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>finally, if <span class="math">\\gamma(1-f)^{\\Delta-1}\\geq(1+\\epsilon)/2</span> for some <span class="math">\\epsilon\\geq 0</span> then</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\#_{0}(X)&lt;\\frac{(1+\\epsilon)an}{4}-\\Delta\\right]\\leq\\exp\\left(-\\frac{a^{2}n}{32}\\right)+\\exp\\left(-\\frac{an}{64}\\right)\\leq 2\\exp\\left(-\\frac{a^{2}n}{64}\\right)</span> (13)</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\#_{0}(X)-\\#_{1}(X)&lt;\\frac{\\epsilon an}{4}-2\\Delta\\right]\\leq\\exp\\left(-\\frac{a^{2}n}{8}\\right)+n\\exp\\left(-\\frac{\\epsilon^{2}an}{64}\\right)\\leq(n+1)\\exp\\left(-\\frac{\\epsilon^{2}a^{2}n}{64}\\right)\\,.</span> (14)</p>

    <h6 id="sec-101" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Treat the random variables <span class="math">W=W_{1}\\cdots W_{n}</span> as the first <span class="math">n</span> symbols of an infinite sequence <span class="math">W_{1}W_{2}\\cdots</span> of random variables satisfying the <span class="math">(f,\\epsilon)</span>-characteristic conditions. It is clear that such an infinite sequence of variables exists, as the random variables appearing in the extension <span class="math">W_{n+1},\\ldots</span> can be taken to be i.i.d. with a coordinatewise distribution that satisfies the <span class="math">(f;\\gamma)</span>-characteristic conditions with equality. Then define</p>

    <p class="text-gray-300"><span class="math">Z_{1}Z_{2}\\cdots\\triangleq\\rho_{\\Delta}(W_{1}W_{2}\\cdots)\\,,</span></p>

    <p class="text-gray-300">we wish to show that these variables satisfy the statement of the theorem.</p>

    <p class="text-gray-300">In light of Lemma 6, the random variables <span class="math">Z_{1},Z_{2},\\ldots</span> satisfy the <span class="math">\\gamma(1-f)^{\\Delta-1}</span>-martingale conditions as needed for (i). By Lemma 5,</p>

    <p class="text-gray-300"><span class="math">\\rho_{\\Delta}(W_{1}\\ldots W_{n})^{\\lceil\\Delta}\\prec\\rho_{\\Delta}(W_{1}W_{2}\\ldots)=Z_{1}Z_{2}\\ldots\\,,</span></p>

    <p class="text-gray-300">proving (ii).</p>

    <p class="text-gray-300">The bound (12) on <span class="math">\\ell</span> follows by considering the random variables</p>

    <p class="text-gray-300">\\[ A_{i}\\triangleq\\begin{cases}0&\\text{if }W_{i}=\\bot,\\\\ 1&\\text{if }W_{i}\\neq\\bot,\\end{cases} \\]</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">so that <span class="math">\\ell=\\sum_{i=1}^{n}A_{i}</span>. Then $\\Pr[A_{i}=1\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,A_{1},\\ldots,A_{i-1}]\\geq a<span class="math"> and applying Azuma’s inequality (Theorem 9) to the random variables </span>B_{t}\\triangleq\\sum_{i=1}^{t}(A_{i}-a)$ yields the result.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">With this length bound established, we note that <span class="math">\\ell\\leq(3/4)an</span> with probability no more than <span class="math">\\exp(-a^{2}n/32)</span> and, in light of (ii), when <span class="math">\\ell\\geq(3/4)an</span> we must have <span class="math">\\#_{0}(X)\\geq\\#_{0}(Z_{1},\\ldots,Z_{3an/4})-\\Delta</span>. Applying the bound of (10) to the <span class="math">Z_{i}</span> with <span class="math">\\delta=1/4</span>, we conclude that the probability that</p>

    <p class="text-gray-300"><span class="math">\\#_{0}(Z_{1},\\ldots,Z_{3an/4})\\leq\\frac{(1+\\epsilon)an}{4}\\leq\\frac{1+\\epsilon}{2}\\cdot\\frac{3an}{4}\\cdot\\frac{3}{4}</span></p>

    <p class="text-gray-300">is no more than <span class="math">\\exp(-(3/4)an/32)\\leq\\exp(-an/64)</span>; taking the union bound over these two bad events yields (13).</p>

    <p class="text-gray-300">Finally, consider (14). As above, we note that <span class="math">\\ell\\leq an/2</span> with probability no more than <span class="math">\\exp(-a^{2}n/8)</span>. Note that</p>

    <p class="text-gray-300"><span class="math">\\#_{0}(X)-\\#_{1}(X)\\geq\\#_{0}(\\widehat{Z})-\\#_{1}(\\widehat{Z})-2\\Delta\\,,</span></p>

    <p class="text-gray-300">where <span class="math">\\widehat{Z}\\triangleq Z_{1}\\ldots Z_{\\ell}</span>. Observe, however, that the probability that <em>any</em> prefix <span class="math">Z^{(t)}=Z_{1}\\ldots Z_{t}</span>, where <span class="math">an/2\\leq t\\leq n</span>, has <span class="math">\\#_{0}(Z^{(t)})-\\#_{1}(Z^{(t)})\\leq(2[(1+\\epsilon)/2]-1)an/4=\\epsilon an/4</span> is no more than</p>

    <p class="text-gray-300"><span class="math">n\\cdot\\exp(-\\epsilon^{2}an/64)</span></p>

    <p class="text-gray-300">by (11). (This follows by taking the union bound over each of the individual <span class="math">n-an/2\\leq n</span> bad events.) Finally, taking the union bound over these two bad events yields (14). ∎</p>

    <h6 id="sec-102" class="text-base font-medium mt-4">Divergence and forkability of <span class="math">\\rho_{\\Delta}(w)</span>.</h6>

    <p class="text-gray-300">We record a theorem of Russell et al. <em>[29]</em> which bounds the probability that random variables satisfying the <span class="math">(1+\\epsilon)/2</span>-martingale conditions are forkable.</p>

    <h6 id="sec-103" class="text-base font-medium mt-4">Theorem 4 (implicit in <em>[29]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">X_{1},\\ldots,X_{n}</span> be random variables taking values in <span class="math">\\{0,1\\}</span> that satisfy the <span class="math">(1+\\epsilon)/2</span>-martingale conditions. Then</p>

    <p class="text-gray-300"><span class="math">\\Pr[X_{1}\\cdots X_{n}\\text{ is forkable}]\\leq\\exp\\left(-\\frac{2\\epsilon^{4}n}{1+35\\epsilon}\\right)\\leq\\exp\\left(-\\frac{\\epsilon^{4}n}{18}\\right)\\,.</span></p>

    <p class="text-gray-300">Note that the constant <span class="math">1/18</span> is quite loose when <span class="math">\\epsilon</span> is small; in particular, the bound is <span class="math">\\exp(-2\\epsilon^{4}(1-O(\\epsilon))n)</span>.</p>

    <p class="text-gray-300">In fact, the original presentation <em>[29]</em> stated the result for binomially distributed variables, but the proof appearing there proceeds via a martingale analysis which can be immediately adapted to our setting where the <span class="math">X_{i}</span> are themselves a super-binomial martingale (e.g., satisfy the <span class="math">(1+\\epsilon)/2</span>-martingale conditions).</p>

    <p class="text-gray-300">We record, also, the fundamental relationship between forkable strings and divergence, established by Kiayias et al. <em>[22]</em>.</p>

    <h6 id="sec-104" class="text-base font-medium mt-4">Theorem 5 (<em>[22]</em>).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">w\\in\\{0,1\\}^{*}</span>. Then there is forkable substring <span class="math">\\tilde{w}</span> of <span class="math">w</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\operatorname{div}_{0}(w)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, we combine these results to control <span class="math">\\operatorname{div}_{\\Delta}(W)</span> for a string <span class="math">W</span> satisfying the <span class="math">(f;\\gamma)</span>-characteristic conditions.</p>

    <h6 id="sec-105" class="text-base font-medium mt-4">Theorem 6.</h6>

    <p class="text-gray-300">Let <span class="math">W=W_{1},\\ldots,W_{R}</span> be a family of random variables, taking values in <span class="math">\\{0,1,\\bot\\}</span> and satisfying the <span class="math">(f,\\gamma)</span>-characteristic conditions. If <span class="math">\\Delta&gt;0</span> and <span class="math">\\epsilon&gt;0</span> satisfy <span class="math">\\gamma(1-f)^{\\Delta-1}\\geq(1+\\epsilon)/2</span> then</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\operatorname{div}_{\\Delta}(W)\\geq k+\\Delta]\\leq\\frac{19R}{\\epsilon^{4}}\\exp(-\\epsilon^{4}k/18)\\,.</span></p>

    <h6 id="sec-106" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Defining <span class="math">X=\\rho_{\\Delta}(W)</span>, we have</p>

    <p class="text-gray-300"><span class="math">\\operatorname{div}_{\\Delta}(W)\\stackrel{{\\scriptstyle(a)}}{{\\leq}}\\operatorname{div}_{0}(X)\\stackrel{{\\scriptstyle(b)}}{{\\leq}}\\operatorname{div}_{0}(X^{\\lceil\\Delta})+\\Delta\\stackrel{{\\scriptstyle(c)}}{{\\leq}}\\operatorname{div}(Z_{1}\\ldots Z_{R})+\\Delta\\,,</span> (15)</p>

    <p class="text-gray-300">where <span class="math">Z_{1},Z_{2},\\ldots</span> are the random variables satisfying the <span class="math">\\gamma(1-f)^{\\Delta-1}</span>-martingale conditions promised by Lemma 8. Above, inequality <span class="math">(a)</span> follows from Lemma 4, inequality <span class="math">(b)</span> from the fact that divergence satisfies the growth bound</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\operatorname{div}_{0}(xy)\\leq\\operatorname{div}_{0}(x)+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,,$ (16)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and inequality <span class="math">(c)</span> follows from Lemma 8(ii) and (16). By Theorem 5, when <span class="math">\\operatorname{div}_{0}(Z)\\geq k</span> there is a forkable substring of <span class="math">Z</span> of length at least <span class="math">k</span>; then summing the bounds provided by Theorem 4 over all lengths at least <span class="math">k</span> we find that the probability of such a substring beginning at a particular fixed index is no more than</p>

    <p class="text-gray-300"><span class="math">\\sum_{t=k}^{\\infty}\\exp\\left(-\\frac{\\epsilon^{4}t}{18}\\right)</span> <span class="math">=\\exp\\left(-\\frac{\\epsilon^{4}k}{18}\\right)\\sum_{t=0}^{\\infty}\\exp\\left(-\\frac{\\epsilon^{4}t}{18}\\right)=\\exp\\left(-\\frac{\\epsilon^{4}k}{18}\\right)\\left(\\frac{1}{1-\\exp(-\\epsilon^{4}/18)}\\right)</span> <span class="math">\\leq\\exp\\left(-\\frac{\\epsilon^{4}k}{18}\\right)\\left(\\frac{1}{1-(1-\\epsilon^{4}/18+(\\epsilon^{4}/18)^{2}/2)}\\right)</span> <span class="math">\\leq\\exp\\left(-\\frac{\\epsilon^{4}k}{18}\\right)\\left(\\frac{18}{\\epsilon^{4}}\\right)\\left(\\frac{1}{1-(\\epsilon^{4}/36))}\\right)</span> <span class="math">\\leq\\exp\\left(-\\frac{\\epsilon^{4}k}{18}\\right)\\left(\\frac{18}{\\epsilon^{4}}\\right)\\left(\\frac{36}{35}\\right)</span> <span class="math">\\leq\\frac{19}{\\epsilon^{4}}\\exp\\left(-\\frac{\\epsilon^{4}k}{18}\\right)\\,.</span></p>

    <p class="text-gray-300">As there are no more than <span class="math">R</span> indices where such a forkable string could begin, we conclude that</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\operatorname{div}_{0}(Z_{1}\\ldots Z_{R})\\geq k]\\leq\\frac{19R}{\\epsilon^{4}}\\exp\\left(-\\frac{\\epsilon^{4}k}{18}\\right)\\,.</span></p>

    <p class="text-gray-300">Combining this with (15), the statement of the theorem follows immediately. ∎</p>

    <h3 id="sec-107" class="text-xl font-semibold mt-8">E.4 Distribution of Characteristic Strings in a Single Epoch</h3>

    <p class="text-gray-300">We now consider an execution of Ouroboros-Praos over a single epoch consisting of <span class="math">R</span> slots in the setting with static <span class="math">\\mathcal{F}_{\\text{N-MC}}</span>-registration (as in Theorem 1). We assume that the randomness used for slot leader selection throughout this epoch is perfect (i.e., unbiased by the adversary) and known to all participating stakeholders (just as in the first epoch, where it is a part of the genesis block <span class="math">\\mathbf{G}</span> provided by <span class="math">\\mathcal{F}_{\\textsf{INIT}}</span>). In what follows, we refer to this as the <em>single-epoch</em> setting.</p>

    <p class="text-gray-300">Recall that within a single epoch, the stake distribution used for electing slot leaders is fixed. Nonetheless, there are still several adaptive aspects of the experiment: the adversary is allowed to adaptively corrupt stakeholders (so the amount of corrupted stake may adaptively increase during an epoch); and the environment can adaptively make parties stalled or time-unaware by deregistering them either from <span class="math">\\mathcal{G}_{\\textsc{RO}}</span> or <span class="math">\\mathcal{G}_{\\textsc{clock}}</span> (and of course, register them back).</p>

    <p class="text-gray-300">As determined by the Ouroboros-Praos protocol, a party with relative stake <span class="math">\\alpha\\in[0,1]</span> becomes a slot leader for a given slot with probability</p>

    <p class="text-gray-300"><span class="math">\\phi_{f}(\\alpha)=1-(1-f)^{\\alpha}\\,.</span></p>

    <p class="text-gray-300">We recall the motivation (from <em>[14]</em>) for this non-linear stake scaling convention for leader selection: the function <span class="math">\\phi_{f}</span> satisfies the “independent aggregation” property:</p>

    <p class="text-gray-300"><span class="math">1-\\phi\\left(\\sum_{i}\\alpha_{i}\\right)=\\prod_{i}(1-\\phi(\\alpha_{i}))\\&gt;.</span> (17)</p>

    <p class="text-gray-300">In particular, when leadership is determined according to <span class="math">\\phi_{f}</span>, the probability of a stakeholder becoming a slot leader in a particular slot is independent of whether this stakeholder acts as a single party in the protocol, or splits its stake among several “virtual” parties. In particular, consider a party <span class="math">U</span> with relative stake <span class="math">\\alpha</span> who contrives to split its stake among two virtual subordinate parties with stakes <span class="math">\\alpha_{1}</span> and <span class="math">\\alpha_{2}</span> (so that <span class="math">\\alpha_{1}+\\alpha_{2}=\\alpha</span>). Then the probability that one of these virtual parties is elected for a particular slot is <span class="math">1-(1-\\phi(\\alpha_{1}))(1-\\phi(\\alpha_{2}))</span>, as these events are independent. Property (17) guarantees that this is identical to <span class="math">\\phi(\\alpha)</span>. Thus this selection rule is invariant under arbitrary reapportionment of a party’s stake among virtual parties. We record some further elementary properties of this convention.</p>

    <h6 id="sec-108" class="text-base font-medium mt-4">Proposition 1.</h6>

    <p class="text-gray-300">The function <span class="math">\\phi_{f}(\\alpha)</span> satisfies the following properties.</p>

    <p class="text-gray-300"><span class="math">\\phi_{f}\\left(\\sum_{i}\\alpha_{i}\\right)</span> <span class="math">=1-\\prod_{i}(1-\\phi_{f}(\\alpha_{i}))\\leq\\sum_{i}\\phi_{f}(\\alpha_{i})\\,,</span> <span class="math">\\text{for any }\\alpha_{i}\\geq 0\\,,</span> (18) <span class="math">\\alpha f\\leq\\phi_{f}(\\alpha)</span> <span class="math">\\leq\\alpha(-\\ln(1-f))=\\alpha\\left(f+\\frac{f^{2}}{2}+\\frac{f^{3}}{3}+\\ldots\\right)\\,,</span> <span class="math">\\text{for any }\\alpha\\in[0,1]\\,.</span> (19)</p>

    <h6 id="sec-109" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">These inequalities are discussed and proven in <em>[14]</em> with the exception of the bound</p>

    <p class="text-gray-300"><span class="math">\\phi_{f}(\\alpha)\\leq\\alpha(-\\ln(1-f))\\,.</span></p>

    <p class="text-gray-300">This follows because</p>

    <p class="text-gray-300"><span class="math">\\frac{d\\phi_{f}}{d\\alpha}(0)=-\\ln(1-f)\\quad\\text{and}\\quad\\frac{d^{2}\\phi_{f}}{d\\alpha^{2}}(\\alpha)=-(1-f)^{\\alpha}\\big{(}\\ln(1-f)\\big{)}^{2}\\,.</span></p>

    <p class="text-gray-300">As the second derivative is everywhere negative, the linear approximation via the first derivative at zero is an upper bound. ∎</p>

    <p class="text-gray-300">Our adversarial stake assumptions yield a characteristic string distribution <span class="math">W_{1},\\ldots,W_{R}</span> governed by the (evolving) stake of the alert and active participants during each slot. In preparation for a detailed description, recall the definitions of quantities <span class="math">\\mathcal{S}^{+}(\\cdot)</span> and <span class="math">\\mathcal{S}^{-}(\\cdot)</span> given in Definition 1 (which we apply below to individual parties as well as party classes) and the notions of alert and participating stake ratios as per Definition 2.</p>

    <h6 id="sec-110" class="text-base font-medium mt-4">Lemma 9.</h6>

    <p class="text-gray-300">The protocol Ouroboros-Praos, when executed in the single-epoch setting, induces characteristic strings <span class="math">W_{1},\\ldots,W_{R}</span> (with each <span class="math">W_{t}\\in\\{0,1,\\bot\\}</span>) satisfying</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$(1-f)\\leq\\Pr[W_{t}=\\bot\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,W_{1},\\ldots,W_{t-1}]\\leq\\prod_{U\\in\\mathcal{P}_{active}[t]}(1-f)^{\\mathcal{S}^{-}}(U)=1-\\phi_{f}(\\mathcal{S}^{-}(\\mathcal{P}_{active}[t]))\\,,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">\\mathcal{P}_{active}[t]</span> denotes the set of active participants at time <span class="math">t</span>. Furthermore,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr[W_{t}=0\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,W_{1},\\ldots,W_{t-1}]\\geq\\phi_{f}(\\mathcal{S}^{-}(\\mathcal{P}_{alert}[t]))(1-f)^{\\mathcal{S}^{-}(\\mathcal{P}_{active}[t])}\\geq\\mathcal{S}^{-}(\\mathcal{P}_{alert}[t])f(1-f)\\,,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">\\mathcal{P}_{alert}[t]</span> denotes the set of alert participants at time <span class="math">t</span>.</p>

    <h6 id="sec-111" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">This follows from the definition of characteristic string, <span class="math">\\phi_{f}(\\cdot)</span> and the properties (18) and (19). ∎</p>

    <p class="text-gray-300">Then it follows immediately that these random variables satisfy the characteristic conditions.</p>

    <h6 id="sec-112" class="text-base font-medium mt-4">Corollary 2.</h6>

    <p class="text-gray-300">The protocol Ouroboros-Praos, when executed in the single-epoch setting, induces characteristic strings <span class="math">W_{1},\\ldots,W_{R}</span> (with each <span class="math">W_{t}\\in\\{0,1,\\bot\\}</span>) satisfying the <span class="math">(f;c_{f}\\cdot(1-f)\\alpha)</span>-characteristic conditions, where <span class="math">\\alpha</span> is a lower-bound on the alert stake ratio over the execution and</p>

    <p class="text-gray-300"><span class="math">c_{f}=\\frac{f}{-\\ln(1-f)}\\,.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Furthermore, as noted above, $\\Pr[W_{t}=\\bot\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,W_{1},\\ldots,W_{t-1}]\\leq 1-\\phi_{f}(\\mathcal{S}^{-}(\\mathcal{P}_{active}[t]))$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For convenience, we note a weaker, but simpler, conclusion: the <span class="math">W_{1},\\ldots,W_{R}</span> satisfy the <span class="math">(f;(1-f)^{2}\\alpha)</span>-characteristic conditions and, additionally,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr[W_{t}=\\bot\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,W_{1},\\ldots,W_{t-1}]\\leq 1-f\\cdot\\mathcal{S}^{-}(\\mathcal{P}_{active}[t])\\,.$ (20)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-113" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The first statement follows directly from Lemma 9 and Definition 14. The weaker conclusion follows from the first one, as we have</p>

    <p class="text-gray-300"><span class="math">c_{f}=\\frac{f}{-\\ln(1-f)}=\\frac{f}{f+f^{2}/2+f^{3}/3+\\cdots}\\geq\\frac{1}{1+f+f^{2}+\\cdots}=1-f\\,,</span></p>

    <p class="text-gray-300">and <span class="math">\\phi_{f}(a)\\geq fa</span>. (We remark that the inequality <span class="math">c_{f}\\geq(1-f)(2+f)/2</span> is an alternative polynomial approximation, somewhat more cumbersome than the bound above, which is tight to first order at <span class="math">f\\approx 0</span>.) ∎</p>

    <h3 id="sec-114" class="text-xl font-semibold mt-8">E.5 Common Prefix, Chain Growth, and Chain Quality for a Single Epoch</h3>

    <h6 id="sec-115" class="text-base font-medium mt-4">Corollary 3 (Common prefix).</h6>

    <p class="text-gray-300">Let <span class="math">W=W_{1},\\ldots,W_{r}</span> denote the characteristic string induced by the Ouroboros-Praos protocol in the single-epoch setting over a sequence of <span class="math">r</span> slots. Assume that <span class="math">\\epsilon&gt;0</span> satisfies</p>

    <p class="text-gray-300"><span class="math">\\alpha(1-f)^{\\Delta+1}\\geq(1+\\epsilon)/2\\,,</span></p>

    <p class="text-gray-300">where <span class="math">\\alpha</span> is a lower-bound on the alert stake ratio over the execution. Then</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\operatorname{div}_{\\Delta}(W)\\geq k+\\Delta]\\leq\\frac{19r}{\\epsilon^{4}}\\exp(-\\epsilon^{4}k/18)\\,,</span></p>

    <p class="text-gray-300">and hence a <span class="math">k</span>-common-prefix violation occurs with probability at most</p>

    <p class="text-gray-300"><span class="math">\\bar{\\epsilon}_{\\mathsf{CP}}(k;r,\\Delta,\\epsilon)\\triangleq\\frac{19r}{\\epsilon^{4}}\\exp(\\Delta-\\epsilon^{4}k/18)\\,.</span></p>

    <h6 id="sec-116" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The statement is a direct consequence of combining Theorem 6 with Corollary 2. ∎</p>

    <p class="text-gray-300">Following <em>[17, 14]</em>, for a fixed characteristic string <span class="math">w=w_{1},\\ldots,w_{r}</span> we say that an index (or slot) <span class="math">i\\in[1,r-\\Delta+1]</span> is <span class="math">\\Delta</span>-right-isolated if <span class="math">w_{i}=0</span> and <span class="math">w_{i+1}=w_{i+2}=\\cdots=w_{i+\\Delta-1}=\\bot</span>.</p>

    <p class="text-gray-300">In preparation for establishing chain growth and chain quality, we describe two further chain properties that will be instrumental in the arguments.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Honest-Bounded Chain Growth (HCG); with parameters <span class="math">\\tau\\in(0,1],s\\in\\mathbb{N}</span>. Consider a chain <span class="math">\\mathcal{C}</span> possessed by an alert party at the onset of a slot <span class="math">\\mathtt{sl}</span>. Let <span class="math">\\mathtt{sl}_{1}</span> and <span class="math">\\mathtt{sl}_{2}</span> be two previous slots for which <span class="math">\\mathtt{sl}_{1}+s\\leq\\mathtt{sl}_{2}\\leq\\mathtt{sl}</span> and both <span class="math">\\mathcal{C}[\\mathtt{sl}_{1}]</span> and <span class="math">\\mathcal{C}[\\mathtt{sl}_{2}]</span> are honest blocks. Then $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}[\\mathtt{sl}_{1}+1:\\mathtt{sl}_{2}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\tau\\cdot s$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Honest-Bounded Chain Quality (HCQ); with parameters <span class="math">\\tau\\in(0,1],s\\in\\mathbb{N}</span>. Consider a chain <span class="math">\\mathcal{C}</span> possessed by an alert party at the onset of a slot <span class="math">\\mathtt{sl}</span>. Let <span class="math">\\mathtt{sl}_{1}</span> and <span class="math">\\mathtt{sl}_{2}</span> be two previous slots for which <span class="math">\\mathtt{sl}_{1}+s\\leq\\mathtt{sl}_{2}\\leq\\mathtt{sl}</span> and both <span class="math">\\mathcal{C}[\\mathtt{sl}_{1}]</span> and <span class="math">\\mathcal{C}[\\mathtt{sl}_{2}]</span> are honest blocks. Then <span class="math">\\mathcal{C}[\\mathtt{sl}_{1}+1:\\mathtt{sl}_{2}]</span> must contain at least <span class="math">\\tau\\cdot s</span> honestly generated blocks.</p>

    <p class="text-gray-300">Note that <span class="math">\\mathsf{HCQ}</span> clearly implies <span class="math">\\mathsf{HCG}</span> with the same parameters; however, looking ahead, we will establish stronger bounds for <span class="math">\\mathsf{HCG}</span>. These properties can be combined with existential chain quality (<span class="math">\\exists\\mathsf{CQ}</span>, defined in Section 4.1) to establish chain growth (<span class="math">\\mathsf{CG}</span>) and chain quality (<span class="math">\\mathsf{CQ}</span>), as described in the lemma below.</p>

    <h6 id="sec-117" class="text-base font-medium mt-4">Lemma 10.</h6>

    <p class="text-gray-300">Consider an execution of Ouroboros-Praos that satisfies <span class="math">\\exists\\mathsf{CQ}</span> with parameter <span class="math">s_{\\exists\\mathsf{CQ}}</span>. Then the following hold:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If the execution satisfies <span class="math">\\mathsf{HCG}</span> with parameters <span class="math">\\tau_{\\mathsf{HCG}}</span> and <span class="math">s_{\\mathsf{HCG}}</span>, then it satisfies <span class="math">\\mathsf{CG}</span> with parameters</li>

    </ol>

    <p class="text-gray-300"><span class="math">s=2s_{\\exists\\mathsf{CQ}}+s_{\\mathsf{HCG}}\\qquad\\text{and}\\qquad\\tau=\\tau_{\\mathsf{HCG}}\\cdot\\left(\\frac{s_{\\mathsf{HCG}}}{s_{\\mathsf{HCG}}+2s_{\\exists\\mathsf{CQ}}}\\right)\\,.</span></p>

    <p class="text-gray-300">In particular, assuming <span class="math">s_{\\mathsf{HCG}}\\geq 2s_{\\exists\\mathsf{CQ}}</span>, the execution satisfies <span class="math">\\mathsf{CG}</span> with parameter <span class="math">\\tau\\geq\\tau_{\\mathsf{HCG}}/2</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If the execution satisfies <span class="math">\\mathsf{HCQ}</span> with parameters <span class="math">\\tau_{\\mathsf{HCQ}}</span> and <span class="math">s_{\\mathsf{HCQ}}</span>, then it satisfies <span class="math">\\mathsf{CQ}</span> with parameters</li>

    </ol>

    <p class="text-gray-300"><span class="math">k=2s_{\\exists\\mathsf{CQ}}+s_{\\mathsf{HCQ}}\\qquad\\text{and}\\qquad\\mu=\\tau_{\\mathsf{HCQ}}\\cdot\\left(\\frac{s_{\\mathsf{HCQ}}}{s_{\\mathsf{HCQ}}+2s_{\\exists\\mathsf{CQ}}}\\right)\\,.</span></p>

    <p class="text-gray-300">In particular, assuming <span class="math">s_{\\mathsf{HCQ}}\\geq 2s_{\\exists\\mathsf{CQ}}</span>, the execution satisfies <span class="math">\\mathsf{CQ}</span> with parameter <span class="math">\\mu=\\tau_{\\mathsf{HCQ}}/2</span>.</p>

    <h6 id="sec-118" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Regarding the first statement of the lemma, consider a portion of a chain <span class="math">\\mathcal{C}</span> held by an alert party spanning <span class="math">\\widehat{s}\\geq s=2s_{\\exists\\mathsf{CQ}}+s_{\\mathsf{HCG}}</span> slots. By <span class="math">\\exists\\mathsf{CQ}</span>, there must be an honest block associated with the first <span class="math">s_{\\exists\\mathsf{CQ}}</span> and last <span class="math">s_{\\exists\\mathsf{CQ}}</span> slots. Between these two honest blocks, which are separated by at least <span class="math">s_{\\mathsf{HCG}}</span> slots, <span class="math">\\mathsf{HCG}</span> guarantees that at least</p>

    <p class="text-gray-300"><span class="math">\\tau_{\\mathsf{HCG}}\\cdot(\\widehat{s}-2s_{\\exists\\mathsf{CQ}})=\\tau_{\\mathsf{HCG}}\\cdot\\underbrace{\\left(\\frac{\\widehat{s}-2s_{\\exists\\mathsf{CQ}}}{\\widehat{s}}\\right)}_{(\\dagger)}\\widehat{s}\\geq\\tau_{\\mathsf{HCG}}\\cdot\\left(\\frac{s_{\\mathsf{HCG}}}{s_{\\mathsf{HCG}}+2s_{\\exists\\mathsf{CQ}}}\\right)\\widehat{s}</span></p>

    <p class="text-gray-300">blocks appear. (The last inequality follows because the function <span class="math">f_{\\lambda}(x)=(x-\\lambda)/x</span>, for any <span class="math">\\lambda&gt;0</span>, is strictly increasing for <span class="math">x&gt;0</span>—thus <span class="math">(\\dagger)</span> is minimized when <span class="math">\\widehat{s}=s_{\\mathsf{HCG}}+2s_{\\exists\\mathsf{CQ}}</span>.) The statement of the lemma follows.</p>

    <p class="text-gray-300">Likewise, for the second statement of the lemma, consider a portion of a chain <span class="math">\\mathcal{C}</span> containing <span class="math">\\widehat{k}\\geq k=2s_{\\exists\\mathsf{CQ}}+s_{\\mathsf{HCQ}}</span> blocks; of course, this portion must span at least <span class="math">\\widehat{k}</span> slots. Applying <span class="math">\\exists\\mathsf{CQ}</span> to the <span class="math">s_{\\exists\\mathsf{CQ}}</span> slots on either side of the interval (as above) and <span class="math">\\mathsf{HCQ}</span> to the remaining <span class="math">\\widehat{k}-2s_{\\exists\\mathsf{CQ}}</span> slots, the chain <span class="math">\\mathcal{C}</span> must contain at least</p>

    <p class="text-gray-300"><span class="math">\\tau_{\\mathsf{HCQ}}\\cdot(\\widehat{k}-2s_{\\exists\\mathsf{CQ}})=\\tau_{\\mathsf{HCQ}}\\cdot\\left(\\frac{\\widehat{k}-2s_{\\exists\\mathsf{CQ}}}{\\widehat{k}}\\right)\\widehat{k}\\geq\\tau_{\\mathsf{HCQ}}\\cdot\\left(\\frac{s_{\\mathsf{HCQ}}}{s_{\\mathsf{HCG}}+2s_{\\exists\\mathsf{CQ}}}\\right)\\widehat{k}</span></p>

    <p class="text-gray-300">honestly-generated blocks. ∎</p>

    <p class="text-gray-300">We now establish concrete bounds on <span class="math">\\mathsf{HCG}</span>, <span class="math">\\mathsf{HCQ}</span>, and <span class="math">\\exists\\mathsf{CQ}</span> for Ouroboros-Praos in the single-epoch setting.</p>

    <h6 id="sec-119" class="text-base font-medium mt-4">Lemma 11.</h6>

    <p class="text-gray-300">Let <span class="math">W=W_{1},\\ldots,W_{r}</span> denote the characteristic string induced by the protocol Ouroboros-Praos in the single-epoch setting over a sequence of <span class="math">r</span> slots. Let <span class="math">\\alpha,\\beta\\in[0,1]</span> denote lower bounds on the alert stake ratio and the participating stake ratio over the execution as per Definition 2, and assume that for some <span class="math">\\varepsilon\\in(0,1)</span> the parameter <span class="math">\\alpha</span> satisfies</p>

    <p class="text-gray-300"><span class="math">\\alpha(1-f)^{\\Delta+1}\\geq(1+\\epsilon)/2\\;.</span></p>

    <p class="text-gray-300">Then <span class="math">\\mathsf{HCG}</span>, <span class="math">\\mathsf{HCQ}</span>, and <span class="math">\\exists\\mathsf{CQ}</span> are guaranteed with the following parameters:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{HCG}</span>: For <span class="math">s\\geq 8\\Delta/(\\beta f)</span> and <span class="math">\\tau=\\beta f/8</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr[W\\text{ admits a }(\\tau,s)\\text{-}\\mathsf{HCG}\\text{ violation}]\\leq\\bar{\\epsilon}_{\\mathsf{HCG}}(\\tau,s;r)\\triangleq 2r^{2}\\exp\\left(-(f\\beta)^{2}s/64\\right)\\,.</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{HCQ}</span>: For <span class="math">s\\geq 16\\Delta/(\\epsilon\\beta f)</span> and <span class="math">\\tau=\\epsilon\\beta f/8</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr[W\\text{ admits a }(\\tau,s)\\text{-}\\mathsf{HCQ}\\text{ violation}]\\leq\\bar{\\epsilon}_{\\mathsf{HCQ}}(\\tau,s;r,\\epsilon)\\triangleq r^{2}(s+1)\\exp\\left(-(\\epsilon f\\beta)^{2}s/64\\right)\\,.</span></p>

    <p class="text-gray-300"><span class="math">\\exists\\mathsf{CQ}</span>: For <span class="math">s\\geq 12\\Delta/(\\epsilon\\beta f)</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr[W\\text{ admits a </span>s<span class="math">-}\\exists\\mathsf{CQ}</span> violation<span class="math">]\\leq\\bar{\\epsilon}_{\\exists\\mathsf{CQ}}(s;r,\\epsilon)=r^{2}(s+1)\\exp\\left(-(\\epsilon\\beta f)^{2}s/64\\right)\\,.</span></p>

    <h6 id="sec-120" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">For convenience, let us call a slot good if it is <span class="math">\\Delta</span>-right-isolated uniquely alert, and bad if it is neither empty nor good. We extend this terminology to blocks by calling a block good (resp. bad) if it is associated with a good (resp. bad) slot. For the discussion of honest-bounded properties below, consider a chain <span class="math">\\mathcal{C}</span> held by an alert party at slot <span class="math">\\mathsf{sl}</span> and two prior slots <span class="math">\\mathsf{sl}_{1}</span> and <span class="math">\\mathsf{sl}_{2}</span> for which (i.) <span class="math">\\mathsf{sl}</span>, <span class="math">\\mathsf{sl}_{1}</span> and <span class="math">\\mathsf{sl}_{2}</span> belong to the sequence of <span class="math">r</span> slots inducing <span class="math">W</span>; (ii.) both <span class="math">\\mathcal{C}[\\mathsf{sl}_{1}]</span> and <span class="math">\\mathcal{C}[\\mathsf{sl}_{2}]</span> are honestly generated blocks, and (iii.) <span class="math">\\mathsf{sl}_{1}+s\\leq\\mathsf{sl}_{2}\\leq\\mathsf{sl}</span>. Let <span class="math">T</span> denote the interval</p>

    <p class="text-gray-300"><span class="math">T\\triangleq\\{\\mathsf{sl}_{1}+1,\\ldots,\\mathsf{sl}_{2}\\}</span></p>

    <p class="text-gray-300">and let <span class="math">\\widehat{\\mathsf{sl}}_{1},\\ldots,\\widehat{\\mathsf{sl}}_{g}</span> be the increasing sequence of all good slots in <span class="math">T</span> (here the notion of isolation refers to this block of slots: in particular, a good slot must be at least <span class="math">\\Delta</span> slots from the right end of <span class="math">T</span>). Let <span class="math">V</span> denote the portion of <span class="math">W</span> associated with the slots in <span class="math">T</span> and let <span class="math">X=\\rho_{\\Delta}(V)</span>. Note that the good (resp., bad) slots appear as <span class="math">0</span> (resp., <span class="math">1</span>) symbols in <span class="math">X</span>, and hence <span class="math">g=\\#_{0}(X)</span>. Let also <span class="math">b\\triangleq\\#_{1}(X)</span> denote the number of bad slots of <span class="math">T</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">HCG: Recall that honest-bounded chain growth demands that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}[\\mathsf{sl}_{1}+1:\\mathsf{sl}_{2}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\tau s<span class="math">. To argue this, first observe that the uniquely alert slot leader associated with </span>\\widehat{\\mathsf{sl}}_{2}<span class="math"> will consider the chain </span>\\mathcal{C}[0:\\mathsf{sl}_{1}]<span class="math"> in the chain selection rule, as </span>\\mathcal{C}[0:\\mathsf{sl}_{1}]<span class="math"> was diffused by a slot leader in </span>\\mathsf{sl}_{1}<span class="math"> and </span>\\widehat{\\mathsf{sl}}_{2}\\geq\\widehat{\\mathsf{sl}}_{1}+\\Delta\\geq\\mathsf{sl}_{1}+\\Delta<span class="math">. In particular, the chain diffused by the unique slot leader in </span>\\widehat{\\mathsf{sl}}_{2}<span class="math"> (after block addition) must have length at least </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}[0:\\mathsf{sl}_{1}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+1<span class="math">. By the same argument, the chains diffused by the uniquely alert players associated with </span>\\widehat{\\mathsf{sl}}_{2},\\ldots,\\widehat{\\mathsf{sl}}_{g}<span class="math"> must grow monotonically: specifically, the chain diffused by the leader at slot </span>\\widehat{\\mathsf{sl}}_{g}<span class="math"> must have length at least </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}[0:\\mathsf{sl}_{1}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+(g-1)<span class="math">. Finally, note that the player generating the (honest) block </span>\\mathcal{C}[\\mathsf{sl}_{2}]<span class="math"> will have received the chain diffused by the leader of </span>\\widehat{\\mathsf{sl}}_{g}$. We conclude that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}[0:\\mathsf{sl}_{2}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}[0:\\mathsf{sl}_{1}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+g=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}[0:\\mathsf{sl}_{1}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\#_{0}(X)\\;.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Observe now that for <span class="math">\\tau=(1+\\epsilon)\\beta f/4-\\Delta/s</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr[W\\text{ admits }(\\tau,s)\\text{-}\\mathsf{HCG}\\text{ violation for }(\\mathsf{sl}_{1},\\mathsf{sl}_{2})]</span> <span class="math">\\leq\\Pr[\\#_{0}(X)\\leq\\tau s]</span> <span class="math">=\\Pr[\\#_{0}(X)\\leq\\beta f(1+\\epsilon)s/4-\\Delta]</span> <span class="math">\\leq 2\\exp\\left(-(f\\beta)^{2}s/64\\right)\\,,</span></p>

    <p class="text-gray-300">where the last inequality follows from (13) by using <span class="math">n:=s</span> and <span class="math">a:=\\beta f</span>, the latter being justified by (20). By the union bound, applied over all pairs of slots, we conclude that</p>

    <p class="text-gray-300"><span class="math">\\Pr[W\\text{ admits a }(\\tau,s)\\text{-}\\mathsf{HCG}\\text{ violation}]\\leq 2r^{2}\\exp(-(f\\beta)^{2}s/64)\\,.</span></p>

    <p class="text-gray-300">The simpler bound appearing in the theorem statement can be obtained by assuming that <span class="math">s\\geq 8\\Delta/(\\beta f)</span> and taking <span class="math">\\tau^{\\prime}=\\beta f/8</span>. Then any <span class="math">(s,\\tau^{\\prime})\\text{-}\\mathsf{HCG}</span> violation is a <span class="math">(s,\\tau)\\text{-}\\mathsf{HCG}</span> violation, as <span class="math">\\tau^{\\prime}&lt;\\tau</span> for such <span class="math">s</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">HCQ. Recall that honest-bounded chain quality demands that <span class="math">\\mathcal{C}[\\mathsf{sl}_{1}+1:\\mathsf{sl}_{2}]</span> contains at least <span class="math">\\tau s</span> honestly generated blocks. Note that, as argued above, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}[\\mathsf{sl}_{1}+1:\\mathsf{sl}_{2}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq g<span class="math">. On the other hand, the total number of adversarially-generated blocks in </span>\\mathcal{C}[\\mathsf{sl}_{1}+1:\\mathsf{sl}_{2}]<span class="math"> can be no more than </span>b<span class="math">. It follows that at least </span>g-b<span class="math"> blocks in </span>\\mathcal{C}[\\mathsf{sl}_{1}+1:\\mathsf{sl}_{2}]<span class="math"> are honest. Observe then that for </span>\\tau=\\epsilon\\beta f/4-2\\Delta/s$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\Pr[W\\text{ admits a }(\\tau,s)\\text{-}\\mathsf{HCQ}\\text{ violation for }(\\mathsf{sl}_{1},\\mathsf{sl}_{2})]</span> <span class="math">\\leq\\Pr[\\#_{0}(X)-\\#_{1}(X)\\leq\\tau s]</span> <span class="math">=\\Pr[\\#_{0}(X)-\\#_{1}(X)\\leq\\epsilon\\beta fs/4-2\\Delta]</span> <span class="math">\\leq(s+1)\\exp\\left(-(\\epsilon f\\beta)^{2}s/64\\right)\\,,</span></p>

    <p class="text-gray-300">where the last inequality follows from (14). Applying the union bound over all pairs of slots yields</p>

    <p class="text-gray-300"><span class="math">\\Pr[W\\text{ admits a }(\\tau,s)\\text{-}\\mathsf{HCQ}\\text{ violation}]\\leq r^{2}(s+1)\\exp\\left(-(\\epsilon f\\beta)^{2}s/64\\right)\\,.</span></p>

    <p class="text-gray-300">The simpler bound appearing in the theorem statement can be obtained by assuming <span class="math">s\\geq 16\\Delta/(\\epsilon\\beta f)</span> and taking <span class="math">\\tau^{\\prime}=\\epsilon\\beta f/8</span>. Then any <span class="math">(s,\\tau^{\\prime})</span>-HCQ violation is a <span class="math">(s,\\tau)</span>-violation, as <span class="math">\\tau&lt;\\tau^{\\prime}</span> for such <span class="math">s</span>.</p>

    <p class="text-gray-300"><span class="math">\\exists</span>CQ. We now consider the probability of an <span class="math">s</span>-<span class="math">\\exists</span>CQ-violation. Recall that an <span class="math">s</span>-<span class="math">\\exists</span>CQ violation is described by a chain <span class="math">\\mathcal{C}</span>, eventually held by an alert party, and a pair of slots <span class="math">\\texttt{sl}_{1}&lt;\\texttt{sl}_{2}</span> for which <span class="math">\\texttt{sl}_{1}+s\\leq\\texttt{sl}_{2}</span> and <span class="math">\\mathcal{C}[\\texttt{sl}_{1}:\\texttt{sl}_{2}]</span> contains no honestly generated blocks. Note that in this setting we no longer assume that <span class="math">\\mathcal{C}[\\texttt{sl}_{1}]</span> and <span class="math">\\mathcal{C}[\\texttt{sl}_{2}]</span> are honest.</p>

    <p class="text-gray-300">First, observe that all blocks in <span class="math">\\mathcal{C}[\\texttt{sl}_{1}:\\texttt{sl}_{2}]</span> are bad (as they are not even honestly generated). Let <span class="math">G_{1}</span> denote the latest honestly-generated block in <span class="math">\\mathcal{C}[0:\\texttt{sl}_{1}-1]</span> (note that at least <span class="math">\\mathcal{C}[0]</span> is considered honest) and let <span class="math">\\overline{\\texttt{sl}}_{1}</span> denote the slot associated with <span class="math">G_{1}</span>; likewise, let <span class="math">G_{2}</span> denote the earliest honestly-generated block appearing in <span class="math">\\mathcal{C}[\\texttt{sl}_{2}+1:\\texttt{sl}]</span> (or the last block of <span class="math">\\mathcal{C}</span>, if there is no honest one) and let <span class="math">\\overline{\\texttt{sl}}_{2}</span> denote the slot associated with <span class="math">G_{2}</span>. Note that all blocks between <span class="math">G_{1}</span> and <span class="math">G_{2}</span> are bad.</p>

    <p class="text-gray-300">Denote by <span class="math">S</span> the continuous sequence of slots</p>

    <p class="text-gray-300"><span class="math">S=\\{\\overline{\\texttt{sl}}_{1}+1,\\ldots,\\overline{\\texttt{sl}}_{2}\\}\\,.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">G_{2}=\\mathcal{C}[\\overline{\\texttt{sl}}_{2}]</span> is honest, note that by the same argument as above $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}[0:\\overline{\\texttt{sl}}_{2}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}[0:\\overline{\\texttt{sl}}_{1}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+g^{\\prime}<span class="math">, where </span>g^{\\prime}<span class="math"> is the number of good slots in </span>S<span class="math">. However, in chain </span>\\mathcal{C}<span class="math"> we have </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}[0:\\overline{\\texttt{sl}}_{2}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}[0:\\overline{\\texttt{sl}}_{1}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+b^{\\prime}+1<span class="math">, where </span>b^{\\prime}<span class="math"> is the number of bad slots in the same sequence </span>S<span class="math">, since by assumption </span>\\mathcal{C}[\\overline{\\texttt{sl}}_{1}+1:\\overline{\\texttt{sl}}_{2}-1]<span class="math"> contains no honestly generated blocks. These two conditions can only be satisfied at the same time if </span>g^{\\prime}\\leq b^{\\prime}+1<span class="math">. On the other hand, if </span>G_{2}<span class="math"> was not honestly-generated, we can only conclude that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}[0:\\overline{\\texttt{sl}}_{2}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}[0:\\overline{\\texttt{sl}}_{1}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+g^{\\prime}-1<span class="math">; specifically, note that </span>\\mathcal{C}<span class="math"> has been adopted by an alert player at slot sl, and so must have length at least that of the chain diffused during the last good slot of </span>S<span class="math">. However, in this case we have </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}[0:\\overline{\\texttt{sl}}_{2}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}[0:\\overline{\\texttt{sl}}_{1}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+b^{\\prime}<span class="math">, where </span>b^{\\prime}<span class="math"> is the number of bad slots in </span>S<span class="math">, since </span>\\mathcal{C}[\\overline{\\texttt{sl}}_{1}+1:\\overline{\\texttt{sl}}_{2}]<span class="math"> contains no honestly generated blocks. Again we find that </span>g^{\\prime}\\leq b^{\\prime}+1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Observe that good slots are associated with <span class="math">0</span>s in the string <span class="math">X^{\\prime}=\\rho_{\\Delta}(V^{\\prime})</span>, where <span class="math">V^{\\prime}</span> is the portion of <span class="math">W</span> associated with the interval <span class="math">S</span>; likewise, bad slots are associated with <span class="math">1</span>s in this sequence. Specifically,</p>

    <p class="text-gray-300"><span class="math">\\Pr[W\\text{ admits an }s\\text{-}\\exists\\texttt{CQ violation for }(\\texttt{sl}_{1},\\texttt{sl}_{2})]\\leq\\Pr[\\#_{0}(X^{\\prime})-\\#_{1}(X^{\\prime})\\leq 1]\\,.</span></p>

    <p class="text-gray-300">For <span class="math">s\\geq 12\\Delta/(\\epsilon\\beta f)</span>, <span class="math">\\epsilon s(\\beta f)/4\\geq 2\\Delta+1</span> and hence, by (14),</p>

    <p class="text-gray-300"><span class="math">\\Pr[W\\text{ admits an }s\\text{-}\\exists\\texttt{CQ violation for }(\\texttt{sl}_{1},\\texttt{sl}_{2})]</span> <span class="math">\\leq\\Pr[\\#_{0}(X^{\\prime})-\\#_{1}(X^{\\prime})\\leq 1]</span> <span class="math">\\leq\\Pr[\\#_{0}(X^{\\prime})-\\#_{1}(X^{\\prime})\\leq\\epsilon s(\\beta f)/4-2\\Delta]</span> <span class="math">\\leq(s+1)\\exp\\left(-(\\epsilon\\beta f)^{2}s/64\\right)\\,.</span></p>

    <p class="text-gray-300">The union bound, applied over all pairs of slots, then yields</p>

    <p class="text-gray-300"><span class="math">\\Pr[W\\text{ admits an }s\\text{-}\\exists\\texttt{CQ violation}]\\leq r^{2}(s+1)\\exp\\left(-(\\epsilon\\beta f)^{2}s/64\\right)\\,.</span></p>

    <p class="text-gray-300">∎</p>

    <h6 id="sec-121" class="text-base font-medium mt-4">Corollary 4 (Chain Growth).</h6>

    <p class="text-gray-300">Let <span class="math">W=W_{1},\\ldots,W_{r}</span> denote the characteristic string induced by the protocol Ouroboros-Praos in the single-epoch setting over a sequence of <span class="math">r</span> slots. Let <span class="math">\\alpha,\\beta\\in[0,1]</span> denote lower bounds on the alert stake ratio and the participating stake ratio over the execution as per Definition 2, and assume that for some some <span class="math">\\varepsilon\\in(0,1)</span> the parameter <span class="math">\\alpha</span> satisfies</p>

    <p class="text-gray-300"><span class="math">\\alpha(1-f)^{\\Delta+1}\\geq(1+\\epsilon)/2\\,.</span></p>

    <p class="text-gray-300">Then for</p>

    <p class="text-gray-300"><span class="math">s=48\\Delta/(\\epsilon\\beta f)\\qquad\\text{and}\\qquad\\tau=\\beta f/16</span> (21)</p>

    <p class="text-gray-300">we have</p>

    <p class="text-gray-300"><span class="math">\\Pr[W\\text{ admits a }(s,\\tau)\\text{-CG violation}]\\leq\\bar{\\epsilon}_{\\texttt{CG}}(\\tau,s;r,\\epsilon)\\triangleq\\frac{1}{2}sr^{2}\\exp\\left(-(\\epsilon\\beta f)^{2}s/256\\right)\\;.</span></p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">roof.</p>

    <p class="text-gray-300">The corollary follows directly by combining Lemmas 10 and 11, using <span class="math">s_{\\exists\\mathsf{CQ}}=12\\Delta/(\\epsilon\\beta f)</span>, <span class="math">s_{\\mathsf{HCG}}=2s_{\\mathsf{ECQ}}</span>, and <span class="math">\\tau_{\\mathsf{HCG}}=\\beta f/8</span>. ∎</p>

    <h6 id="sec-122" class="text-base font-medium mt-4">Corollary 5 (Chain Quality).</h6>

    <p class="text-gray-300">Let <span class="math">W=W_{1},\\ldots,W_{r}</span> denote the characteristic string induced by the protocol Ouroboros-Praos in the single-epoch setting over a sequence of <span class="math">r</span> slots. Let <span class="math">\\alpha,\\beta\\in[0,1]</span> denote lower bounds on the alert stake ratio and the participating stake ratio as per Definition 2, and assume that for some some <span class="math">\\varepsilon\\in(0,1)</span> the parameter <span class="math">\\alpha</span> satisfies</p>

    <p class="text-gray-300"><span class="math">\\alpha(1-f)^{\\Delta+1}\\geq(1+\\epsilon)/2\\,.</span></p>

    <p class="text-gray-300">Then for</p>

    <p class="text-gray-300"><span class="math">k=48\\Delta/(\\epsilon\\beta f)\\qquad\\text{and}\\qquad\\mu=\\epsilon\\beta f/16</span></p>

    <p class="text-gray-300">we have</p>

    <p class="text-gray-300"><span class="math">\\Pr[W\\text{ admits a }(\\mu,k)\\text{-CQ violation}]\\leq\\bar{\\epsilon}_{\\mathsf{CQ}}(\\mu,k;r,\\epsilon)\\triangleq\\frac{1}{2}kr^{2}\\exp\\left(-(\\epsilon\\beta f)^{2}k/256\\right)\\;.</span></p>

    <h6 id="sec-123" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The corollary follows directly by combining Lemmas 10 and 11, using <span class="math">s_{\\exists\\mathsf{CQ}}=12\\Delta/(\\epsilon\\beta f)</span>, <span class="math">s_{\\mathsf{HCQ}}=2s_{\\exists\\mathsf{CQ}}</span>, and <span class="math">\\tau_{\\mathsf{HCQ}}=\\epsilon\\beta f/8</span>. ∎</p>

    <h3 id="sec-124" class="text-xl font-semibold mt-8">E.6 Lifting to Multiple Epochs</h3>

    <p class="text-gray-300">The above analysis gives bounds for common prefix, chain growth, and variants of chain quality (denoted <span class="math">\\bar{\\epsilon}_{\\mathsf{CP}}</span>, <span class="math">\\bar{\\epsilon}_{\\mathsf{CG}}</span>, <span class="math">\\bar{\\epsilon}_{\\mathsf{CQ}}</span>, and <span class="math">\\bar{\\epsilon}_{\\exists\\mathsf{CQ}}</span>, respectively) for a single-epoch run of the protocol with static stake distribution and perfect randomness. We now conclude our proof of Theorem 1 by showing conditions under which these blockchain properties hold throughout the whole lifetime of the system consisting of many epochs.</p>

    <h6 id="sec-125" class="text-base font-medium mt-4">Theorem 7.</h6>

    <p class="text-gray-300">Consider the execution of Ouroboros-Praos with adversary <span class="math">\\mathcal{A}</span> and environment <span class="math">\\mathcal{Z}</span> in the setting with static <span class="math">\\mathcal{F}_{\\text{\\tiny N-MC}}</span>-registration. Let <span class="math">f</span> be the active-slot coefficient, let <span class="math">\\Delta</span> be the upper bound on the network delay. Let <span class="math">\\alpha,\\beta\\in[0,1]</span> denote a lower bound on the alert and participating stake ratios throughout the whole execution, respectively. Let <span class="math">R</span> and <span class="math">L</span> denote the epoch length and the total lifetime of the system (in slots), and let <span class="math">Q</span> be the total number of queries issued to <span class="math">\\mathcal{G}_{\\text{\\tiny RO}}</span>. If for some <span class="math">\\varepsilon\\in(0,1)</span> we have</p>

    <p class="text-gray-300"><span class="math">\\alpha\\cdot(1-f)^{\\Delta+1}\\geq(1+\\epsilon)/2\\,,</span></p>

    <p class="text-gray-300">then Ouroboros-Praos achieves the same guarantees for common prefix (resp. chain growth, chain quality, existential chain quality) as given in Corollary 3 (resp. Corollary 4, Corollary 5, Lemma 11) except with an additional error probability of</p>

    <p class="text-gray-300"><span class="math">QL\\cdot\\left(2\\bar{\\epsilon}_{\\mathsf{CG}}\\left(\\tau,R/3;R,\\epsilon\\right)+2\\bar{\\epsilon}_{\\mathsf{CP}}\\left(\\tau R/3;R,\\Delta,\\epsilon\\right)+\\bar{\\epsilon}_{\\exists\\mathsf{CQ}}\\left(R/3;R,\\epsilon\\right)\\right)\\;,</span> (22)</p>

    <p class="text-gray-300">where <span class="math">\\tau=\\beta f/16</span>. If <span class="math">R\\geq 144\\Delta/\\epsilon\\beta f</span> then this term can be upper-bounded by</p>

    <p class="text-gray-300"><span class="math">\\epsilon_{\\mathsf{lift}}\\triangleq QL\\cdot\\left[R^{3}\\cdot\\exp\\left(-\\frac{(\\epsilon\\beta f)^{2}R}{768}\\right)+\\frac{38R}{\\epsilon^{4}}\\cdot\\exp\\left(\\Delta-\\frac{\\epsilon^{4}\\tau R}{54}\\right)\\right]\\;.</span> (23)</p>

    <h6 id="sec-126" class="text-base font-medium mt-4">Proof (sketch).</h6>

    <p class="text-gray-300">This part of the analysis proceeds similarly as in Section 5 of <em>[14]</em> and hence we only sketch it. When moving from the single-epoch setting to a setting with several epochs, two new aspects need to be considered:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Stake distribution updates. The stake distribution used for sampling slot leaders changes in every epoch (this is why we consider epochs in the first place). In Ouroboros-Praos (and Ouroboros-Genesis), the distribution used for sampling in epoch <span class="math">\\mathsf{ep}</span> is set to be the stake distribution recorded on the blockchain up to the last block of the epoch <span class="math">\\mathsf{ep}-2</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Randomness updates. Every epoch needs new public randomness to be used for sampling slot leaders from the above distribution. For epoch <span class="math">\\mathtt{ep}</span>, this randomness is obtained by hashing together VRF-outputs put into blocks in epoch <span class="math">\\mathtt{ep}-1</span> by their creators. More precisely, the protocol hashes together these values from the blocks in the first <span class="math">2R/3</span> slots of epoch <span class="math">\\mathtt{ep}-1</span> (out of its <span class="math">R</span> slots).</li>

    </ul>

    <p class="text-gray-300">To argue that the above process of updating stake distribution and public randomness does not noticeably deviate the execution from the single-epoch analysis, we rely on the single-epoch setting bounds proven above. In particular, we make the following three observations:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Chain growth and common prefix imply that during the first <span class="math">R/3</span> slots of each epoch, each alert player’s chain grows by at least <span class="math">\\tau R/3</span> blocks (for <span class="math">\\tau</span> as in (21)) and therefore after these slots, all alert players agree on the stake distribution at the end of the previous epoch except with probability</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\bar{\\epsilon}_{\\mathtt{CG}}(\\tau,R/3;R,\\epsilon)+\\bar{\\epsilon}_{\\mathtt{CP}}(\\tau R/3;R,\\Delta,\\epsilon)\\;.</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Existential chain quality implies that during the second <span class="math">R/3</span> slots of each epoch, each alert player’s chain contains at least one honest block except with probability</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\bar{\\epsilon}_{\\exists\\mathtt{CQ}}(R/3;R,\\epsilon)\\;.</span></p>

    <p class="text-gray-300">That implies that the randomness that will be derived for the next epoch will be influenced by at least one honest VRF-output determined <em>after</em> the stake distribution is fixed.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Chain growth and common prefix imply that during the last <span class="math">R/3</span> slots of each epoch, each alert player’s chain grows by at least <span class="math">\\tau R/3</span> blocks and therefore after these slots, all alert players agree on the randomness for the next epoch except with probability</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\bar{\\epsilon}_{\\mathtt{CG}}(\\tau,R/3;R,\\epsilon)+\\bar{\\epsilon}_{\\mathtt{CP}}(\\tau R/3;R,\\Delta,\\epsilon)\\;.</span></p>

    <p class="text-gray-300">Hence, if we assumed perfect randomness in each epoch, all the above desired properties would be satisfied throughout the lifetime of the system <span class="math">L</span> except with probability</p>

    <p class="text-gray-300"><span class="math">L\\cdot(2\\bar{\\epsilon}_{\\mathtt{CG}}\\left(\\tau,R/3;R,\\epsilon\\right)+2\\bar{\\epsilon}_{\\mathtt{CP}}\\left(\\tau R/3;R,\\Delta,\\epsilon\\right)+\\bar{\\epsilon}_{\\exists\\mathtt{CQ}}\\left(R/3;R,\\epsilon\\right))</span></p>

    <p class="text-gray-300">by union bound.</p>

    <p class="text-gray-300">However, the above properties are not sufficient to infer that the public randomness used for leader election in the next epoch will be perfect. Instead, the process of deriving it described above still allows a limited amount of grinding by the adversary, who can decide whether to include blocks (with VRF outputs) in slots where he is a slot leader. In <em>[14]</em>, it is shown that this grinding effect can be crudely upper-bounded by limiting the number of queries to the random oracle that the adversary makes (of course, more fine-grained bounds are possible). The same argument applies here, and hence we need to introduce the quantity <span class="math">Q</span> into our bound (22). Since we model the random oracle as a global functionality <span class="math">\\mathcal{G}_{\\mathrm{RO}}</span>, the quantity <span class="math">Q</span> is an upper bound on the <em>total</em> number of queries to <span class="math">\\mathcal{G}_{\\mathrm{RO}}</span> that were asked during the execution, including queries from the environment.</p>

    <p class="text-gray-300">Finally, the bound (23 is obtained by instantiating (22) with the concrete bounds of Corollaries 3 and 4, and Lemma 11 (where Lemma 11 requires the assumption <span class="math">R\\geq 36\\Delta/\\epsilon\\beta f</span>, while 4 requires a stricter bound <span class="math">R\\geq 144\\Delta/\\epsilon\\beta f</span>). ∎</p>

    <h2 id="sec-127" class="text-2xl font-bold">Appendix F Large Deviation Bounds</h2>

    <p class="text-gray-300">We apply a variety of large deviation bounds in our probabilistic arguments, which we record here for concreteness. See, e.g., <em>[25]</em> for proofs and further discussion.</p>

    <p class="text-gray-300">Theorem 8 (Chernoff bound). Let <span class="math">X_{1},\\ldots ,X_{T}</span> be independent random variables with <span class="math">\\mathbb{E}[X_i] = p_i</span> and <span class="math">X_{i}\\in [0,1]</span>. Let <span class="math">X = \\sum_{i = 1}^{T}X_{i}</span> and <span class="math">\\mu = \\sum_{i = 1}^{T}p_{i} = \\mathbb{E}[X]</span>. Then, for all <span class="math">\\varLambda\\geq 0</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr [ X \\geq (1 + \\Lambda) \\mu ] \\leq e ^ {- \\frac {\\Lambda^ {2}}{2 + \\Lambda} \\mu};</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Pr [ X \\leq (1 - \\Lambda) \\mu ] \\leq e ^ {- \\frac {\\Lambda^ {2}}{2 + \\Lambda} \\mu}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 9 (Azuma's inequality (Azuma; Hoeffding). See [25, 4.16] for discussion). Let <span class="math">X_0, \\ldots, X_n</span> be a sequence of real-valued random variables so that, for all <span class="math">t</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X_{t+1} - X_t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq c<span class="math"> for some constant </span>c<span class="math">. If </span>\\mathbb{E}[X_{t+1} \\mid X_0, \\ldots, X_t] \\leq X_t<span class="math"> for all </span>t<span class="math"> then for every </span>\\Lambda \\geq 0$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ X _ {n} - X _ {0} \\geq \\Lambda \\right] \\leq \\exp \\left(- \\frac {\\Lambda^ {2}}{2 n c ^ {2}}\\right).</span></div>

    <p class="text-gray-300">Alternatively, if <span class="math">\\mathbb{E}[X_{t + 1} \\mid X_0, \\ldots, X_t] \\geq X_t</span> for all <span class="math">t</span> then for every <span class="math">\\Lambda \\geq 0</span></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ X _ {n} - X _ {0} \\leq - \\Lambda \\right] \\leq \\exp \\left(- \\frac {\\Lambda^ {2}}{2 n c ^ {2}}\\right).</span></div>

    <h2 id="sec-128" class="text-2xl font-bold">G List of Symbols</h2>

    <p class="text-gray-300">The communication model:</p>

    <p class="text-gray-300"><span class="math">\\Delta</span> maximum message delay in slots</p>

    <p class="text-gray-300">Functionalities:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{G}_{\\mathrm{CLOCK}}</span> global clock</p>

    <p class="text-gray-300"><span class="math">\\mathcal{G}_{\\mathrm{RO}}</span> global random oracle</p>

    <p class="text-gray-300"><span class="math">\\mathcal{F}_{\\mathrm{N - MC}}^{\\mathrm{hc},\\Delta}</span> <span class="math">\\Delta</span>-delayed network for diffusing blockchains</p>

    <p class="text-gray-300"><span class="math">\\mathcal{F}_{\\mathrm{N - MC}}^{\\mathrm{ts},\\Delta}</span> <span class="math">\\Delta</span>-delayed network for diffusing transactions</p>

    <p class="text-gray-300"><span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span> init functionality providing the genesis block</p>

    <p class="text-gray-300"><span class="math">\\mathcal{F}_{\\mathrm{VRF}}</span> verifiable random function</p>

    <p class="text-gray-300"><span class="math">\\mathcal{F}_{\\mathrm{KES}}</span> key-evolving signature scheme</p>

    <p class="text-gray-300"><span class="math">\\mathcal{G}_{\\mathrm{LEDGER}}</span> the ledger functionality</p>

    <p class="text-gray-300">Functionality <span class="math">\\mathcal{G}_{\\mathrm{LEDGER}}</span>:</p>

    <p class="text-gray-300"><span class="math">\\tau_{L}</span> current time</p>

    <p class="text-gray-300"><span class="math">\\vec{\\tau}_{\\mathrm{state}}</span> sequence of time stamps of state blocks</p>

    <p class="text-gray-300"><span class="math">\\vec{\\mathcal{I}}_H^T</span> timed honest-input sequence</p>

    <p class="text-gray-300"><span class="math">\\mathcal{S}_{\\mathrm{initStake}}</span> initial stakeholder set</p>

    <p class="text-gray-300">Protocol Ouroboros-Genesis:</p>

    <p class="text-gray-300"><span class="math">f</span> active slots coefficient</p>

    <p class="text-gray-300"><span class="math">\\phi (\\cdot)</span> slot-leader probability function (Eq. (1))</p>

    <p class="text-gray-300"><span class="math">R</span> epoch length in slots</p>

    <p class="text-gray-300"><span class="math">\\mathbb{S}_{\\mathrm{ep}}</span> stake distribution used to sample slot leaders in epoch ep</p>

    <p class="text-gray-300"><span class="math">\\alpha_{p}^{\\mathrm{ep}}</span> relative stake of party <span class="math">U_{p}</span> in <span class="math">\\mathbb{S}_{\\mathrm{ep}}</span></p>

    <p class="text-gray-300"><span class="math">\\eta_{\\mathrm{ep}}</span> randomness used to sample slot leaders in epoch ep</p>

    <p class="text-gray-300">Analysis:</p>

    <p class="text-gray-300"><span class="math">\\alpha</span> alert stake ratio (Def. 2)</p>

    <p class="text-gray-300"><span class="math">\\beta</span> participating stake ratio (Def. 2)</p>

    <p class="text-gray-300"><span class="math">L</span> total length of the execution (in slots)</p>

    <p class="text-gray-300"><span class="math">Q</span> total number of queries to the random oracle</p>`;
---

<BaseLayout title="Ouroboros Genesis: Composable Proof-of-Stake Blockchains wit... (2018/378)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2018 &middot; eprint 2018/378
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
