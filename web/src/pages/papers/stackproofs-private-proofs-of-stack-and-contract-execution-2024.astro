---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2024/1281';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Stackproofs: Private proofs of stack and contract execution using Protogalaxy';
const AUTHORS_HTML = 'Liam Eagen, Ariel Gabizon, Marek Sefranek, Patrick Towa, Zachary J. Williamson';

const CONTENT = `    <p class="text-gray-300">Liam Eagen [11] Ariel Gabizon [22] Marek Sefranek [33] Patrick Towa [22] Zachary J. Williamson [22]</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">The goal of this note is to describe and analyze a simplified variant of the zk-SNARK construction used in the Aztec protocol. Taking inspiration from the popular notion of Incrementally Verifiable Computation<em>[1]</em> (IVC) we define a related notion of <em>Repeated Computation with Global state</em> (RCG). As opposed to IVC, in RCG we assume the computation terminates before proving starts, and in addition to the local transitions some global consistency checks of the whole computation are allowed. However, we require the space efficiency of the prover to be close to that of an IVC prover not required to prove this global consistency. We show how RCG is useful for designing a proof system for a private smart contract system like Aztec.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Incrementally Verifiable Computation (IVC) <em>[1]</em> and its generalization to Proof Carrying Data (PCD) <em>[10]</em> are useful tools for constructing space-efficient SNARK provers<em>[11]</em>. In IVC and PCD we always have an acyclic computation. However code written in almost any programming language <em>is</em> cyclic in the sense of often relying on internal calls – we start from a function <span class="math">A</span>, execute some commands, go into a function <span class="math">B</span>, execute its commands, and go back to <span class="math">A</span>. When making a SNARK proof of such an execution, we typically linearize or “flatten” the cycle stemming from the internal call, in one of the following two ways.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The monolithic circuit approach: We “inline” all internal calls (as well as loops) into one long program without jumps.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The VM approach: Assume the code of <span class="math">A,B</span> is written in some prespecified instruction set. The program is executed by initially writing the code of <span class="math">A,B</span> into memory, and loading from memory and executing at each step the appropriate instruction according to a program counter. For example, the call to <span class="math">B</span> is made by changing the counter to that of the first instruction of <span class="math">B</span>. To prove correctness of the execution, all we need is a SNARK for proving correctness of a certain number of steps of a machine with this instruction set, and some initial memory state.</li>

    </ol>

    <p class="text-gray-300">The second approach is more generic, while the first offers more room for optimization, so we’d want to use it in resource-constrained settings, e.g. client-side proving.</p>

    <p class="text-gray-300">However, what if we’re in a situation where <span class="math">A</span> and <span class="math">B</span> have already been “SNARKified” separately? Namely, there is a verification key attached to each one, and we are expected to use these keys specifically. This is what happens in the Aztec system.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">The Aztec private contract system</h4>

    <p class="text-gray-300">Similar to Ethereum we have contracts, and the contracts have functions. A function in a contract can internally call a different function in the same or a different contract. Moreover, while writing the code for the different functions and compiling them to circuits, we can’t predict what function will be internally called by a given contract function. For example, a “send token” function could have an internal call to an “authorize” function. But the call to “authorize” need not be tied to a specific implementation and consequently, to a specific verification key – as different token holders are allowed to set their own “authorize” function.</p>

    <p class="text-gray-300">The goal of the Aztec system is to enable constructing zero-knowledge proofs of such contract function executions. For this purpose, a contract is deployed by</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Computing a verification key for each function of the contract.</li>

      <li>Adding a commitment to the verification keys of the contract in a global “function tree”. More accurately, a leaf of this tree is a hash of the contract address with a Merkle root of a tree whose leaves are the verification keys of that contract’s functions.</li>

    </ol>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Dealing with global state</h4>

    <p class="text-gray-300">The global state of the Aztec system is described by a set of notes, which are simply values in a field <span class="math">\\mathbb{F}</span>. Each note belongs to a certain contract. While running, a function can read, add or delete notes belonging to its contract. We can thus think of the notes as global variables shared between the different functions.</p>

    <p class="text-gray-300">Assume all functions in this system return accept or reject. (We can always move the output into the arguments if a function is not of this form.) Here’s a natural way to prove the mentioned execution: Put the arguments to <span class="math">B</span> in the public inputs of both the circuits of <span class="math">A</span> and <span class="math">B</span>. Verify the proofs <span class="math">\\pi_{A},\\pi_{B}</span> for <span class="math">A,B</span>; and check via the public inputs the same value was used in both proofs for the arguments of <span class="math">B</span>.</p>

    <p class="text-gray-300">This however, doesn’t yet deal with the notes. During execution, note operations happened in a certain order. We can thus assign a counter equal to one for the first</p>

    <p class="text-gray-300">operation and increment the counter with each operation. We then need to check, for example, that if a note was read with a certain counter, it was indeed added with a smaller counter. We can include a description of the note operations performed by a function in the inputs of its circuit. This description will contain the operation type (add, del, read), the note value, and the counter. The issue is, what if <span class="math">A</span> is reading a note that was added in the internal call to <span class="math">B</span>? Checking the existence of an add operation with smaller counter requires a constraint <em>between</em> the inputs of both circuits. And for an execution consisting of more calls, this constraint can involve any two circuits in the call tree.</p>

    <p class="text-gray-300">This brings us to the notion of <em>Repeated Computation with Global state</em> (RCG). In RCG we have a transition predicate taking us from one state to the next. We wish to prove we know a sequence of witnesses taking us from a legal initial state to a certain publicly known final state. This might remind the reader of the popular notion of <em>incrementally verifiable computation</em> (IVC). There are two differences.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In RCG we are not interested in “incremental” proofs of one step, only in proofs for a whole sequence of transitions ending in a desired final state.</li>

      <li>In RCG we also have a <em>final predicate</em> checking a joint consistency condition between witnesses from all iterations.</li>

    </ul>

    <p class="text-gray-300">One could ask, why not <em>only</em> have a final predicate that includes the transition checks? In other words, a monolithic circuit for the whole computation. The point is that in our use case the final predicate is applied to small parts of each iteration’s witness – namely the note operations. As a result, the decomposition into a transition and final predicate can facilitate obtaining better prover efficiency, especially in terms of prover space. Roughly, we’ll require space sufficient for storing the inputs to the final predicate, in addition to the space required to prove a single transition.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.1 Related work</h3>

    <p class="text-gray-300">Recent work <em>[x21, NDC^{+}24]</em> as well as ongoing work <em>[x10]</em> uses folding schemes <em>[BCL^{+}21, x14]</em> to break up proving statements about large computation into smaller statements. The objective being reducing prover memory and/or improving prover parallelism. These works have not formally defined a notion like RCG, and rather use the IVC terminology. We believe the RCG framework may be better suited for capturing the properties of these constructions. In terms of the concrete constructions, there are overlaps with this work, notably a two-pass over part of the witness to generate a random challenge. As alluded to earlier, one distinction is that these works start with a computation that is already linear, while here we start with cyclic computation and must “compile” it into a “linear” statement.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">1.2 Overview of the paper</h3>

    <p class="text-gray-300">In Section 2, we go over terminology and preliminaries. Notably, in Section 2.2 we introduce the <em>Zero-Testing Assumption</em> from <em>[x15]</em> that enables us to avoid heuris</p>

    <p class="text-gray-300">tic assumptions as commonly happens in IVC papers due to the need of instantiating the random oracle. In Section 3, we introduce our execution model involving record operations and execution trees. In Section 4, we introduce the notion of Repeated Computation with Global state, and show how to reduce computations in the model of Section 3 to RCG. In Section 5, we show how “log-derivative methods” <em>[x10, x23]</em> can capture global consistency of operations as defined in previous sections. In Section 6, we show how the Protogalaxy folding scheme <em>[x11]</em> can be proven secure under the ZTA (without the need of a random oracle). In Section 8, we present our main zk-SNARK construction. The main ingredient is a “folding to IVC” reduction similar to the ones in <em>[BCL^{+}21, x22]</em>. In Section 9, we outline how RCG can be implemented for a more general set of functions.</p>

    <p class="text-gray-300">A reader wanting to get a feeling of the main construction ideas might want to focus first on Sections 3–5.</p>

    <h2 id="sec-8" class="text-2xl font-bold">2 Preliminaries</h2>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">2.1 Terminology and Conventions</h3>

    <p class="text-gray-300">We assume all algorithms described receive as an implicit parameter the security parameter <span class="math">\\lambda</span>. Similarly, all integer parameters in the paper are implicitly functions of <span class="math">\\lambda</span>, and of size at most <span class="math">\\mathsf{poly}(\\lambda)</span> unless explicitly stated otherwise.</p>

    <p class="text-gray-300">Whenever we use the term <em>efficient</em>, we mean an algorithm running in time <span class="math">\\mathsf{poly}(\\lambda)</span>. Furthermore, we assume an <em>object generator</em> <span class="math">\\mathcal{O}</span> that is run with input <span class="math">\\lambda</span> before all protocols, and returns all fields and groups used. Specifically, in our protocol <span class="math">\\mathcal{O}(\\lambda)=(\\mathbb{F},\\mathbb{G},g,r_{\\mathsf{cm}})</span> where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbb{F}</span> is a field of prime size <span class="math">r=\\lambda^{\\omega(1)}</span> .</li>

      <li><span class="math">\\mathbb{G}</span> is a group of size <span class="math">r</span>.</li>

      <li><span class="math">g</span> is a uniformly chosen generator of <span class="math">\\mathbb{G}</span>.</li>

      <li><span class="math">r_{\\mathsf{cm}}</span> is a uniformly chosen key for a collision-resistant homomorphic commitment scheme <span class="math">\\mathsf{cm}:\\mathbb{F}^{M}\\to\\mathbb{G}</span>.</li>

    </ul>

    <p class="text-gray-300">We usually let the <span class="math">\\lambda</span> parameter be implicit, e.g. write <span class="math">\\mathbb{F}</span> instead of <span class="math">\\mathbb{F}(\\lambda)</span>. We denote by <span class="math">\\mathbb{F}_{&lt;d}[X]</span> the set of univariate polynomials over <span class="math">\\mathbb{F}</span> of degree smaller than <span class="math">d</span>. We write <span class="math">\\mathbb{G}</span> additively. <em>All probabilistic statements in the paper are additionally over the randomness of <span class="math">\\mathcal{O}</span>.</em></p>

    <p class="text-gray-300">We often denote by <span class="math">[n]</span> the integers <span class="math">\\{1,\\ldots,n\\}</span>. We use the acronym e.w.p. for “except with probability”; i.e. e.w.p. <span class="math">\\gamma</span> means with probability <em>at least</em> <span class="math">1-\\gamma</span>.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">2.2 Zero-Testing Assumption</h3>

    <p class="text-gray-300">Throughout this paper, we’ll make use of a variant of the <em>Zero-Testing Assumption (ZTA)</em> from <em>[x24]</em> given in Definition 2.1 as well as its generalization, the <em><span class="math">t</span>-variate Zero-Testing Assumption</em>, we introduce in Definition 2.3.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Definition 2.1.</h6>

    <p class="text-gray-300">Fix <span class="math">\\mathsf{cm}:\\mathbb{F}^{M}\\to K</span>, hash function <span class="math">\\mathcal{H}:\\{0,1\\}^{<em>}\\to\\mathbb{F}</span>, and integer <span class="math">d</span>. Fix the family of functions <span class="math">\\mathcal{D}</span>. We say the tuple <span class="math">(D,x,\\tau)</span> is a </em>degree <span class="math">d</span>-relation for <span class="math">(\\mathcal{D},\\mathcal{H},\\mathsf{cm})</span>* if</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">D\\in\\mathcal{D}</span>.</li>

      <li><span class="math">f(X):=D(x,\\tau)</span> is a non-zero element of <span class="math">\\mathbb{F}_{\\leq d}[X]</span>.</li>

      <li>Setting <span class="math">z:=\\mathcal{H}(\\mathsf{cm}(x),\\tau)</span>, we have <span class="math">f(z)=0</span>.</li>

    </ol>

    <p class="text-gray-300">The Zero-Testing Assumption (ZTA) for <span class="math">(\\mathcal{D},\\mathcal{H},\\mathsf{cm},d)</span> states that for any efficient <span class="math">\\mathcal{A}</span>, the probability that <span class="math">\\mathcal{A}</span> outputs a degree <span class="math">d</span>-relation for <span class="math">(\\mathcal{D},\\mathcal{H},\\mathsf{cm})</span> is <span class="math">\\mathsf{negl}(\\lambda)</span>.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Remark 2.2.</h6>

    <p class="text-gray-300">The validity of ZTA is very sensitive to the choice of <span class="math">D</span>. At first thought, one would want to prohibit <span class="math">D</span> from <em>any</em> invocation of <span class="math">\\mathcal{H}</span> or <span class="math">\\mathsf{cm}</span>. However, as will be seen later, this will be over-restrictive for capturing what is needed in multi-round protocols. We make sure not to use <span class="math">D</span> where <span class="math">\\mathcal{H}</span> is invoked on <span class="math">(\\mathsf{cm}(x),\\tau)</span>, and conjecture this suffices for avoiding couter-examples. In any case, analyzing a hash-based protocol under ZTA with a specific choice of <span class="math">D</span> allows for falsifiability - as opposed to an analysis in the ROM followed by applying Fiat-Shamir .</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Definition 2.3 (<span class="math">t</span>-variate ZTA).</h6>

    <p class="text-gray-300">Fix <span class="math">\\mathsf{cm}:\\mathbb{F}^{M}\\to K</span>, hash function <span class="math">\\mathcal{H}:\\{0,1\\}^{*}\\to\\mathbb{F}</span>, and integer <span class="math">d</span>. Fix the family of functions <span class="math">\\mathcal{D}</span>. We say the tuple <span class="math">(D,x,\\tau)</span> is a <span class="math">(t,d)</span>-relation for <span class="math">(\\mathcal{D},\\mathcal{H},\\mathsf{cm})</span> if</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">D\\in\\mathcal{D}</span>.</li>

      <li><span class="math">f(X_{1},\\ldots,X_{t}):=D(x,\\tau)</span> is a non-zero element of <span class="math">\\mathbb{F}_{\\leq d}[X_{1},\\ldots,X_{t}]</span>.</li>

      <li>Setting <span class="math">z_{i}:=\\mathcal{H}(\\mathsf{cm}(x),\\tau,i)</span> for <span class="math">i\\in[t]</span>, we have <span class="math">f(z_{1},\\ldots,z_{t})=0</span>.</li>

    </ol>

    <p class="text-gray-300">The <span class="math">t</span>-variate Zero-Testing Assumption (ZTA) for <span class="math">(\\mathcal{D},\\mathcal{H},\\mathsf{cm},d)</span> states that for any efficient <span class="math">\\mathcal{A}</span>, the probability that <span class="math">\\mathcal{A}</span> outputs a <span class="math">(t,d)</span>-relation for <span class="math">(\\mathcal{D},\\mathcal{H},\\mathsf{cm})</span> is <span class="math">\\mathsf{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">We prove that the univariate ZTA implies the <span class="math">t</span>-variate ZTA.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Lemma 2.4.</h6>

    <p class="text-gray-300">Fix a family of functions <span class="math">\\mathcal{D}</span> whose outputs are polynomials in <span class="math">\\mathbb{F}_{\\leq d}[X_{1},\\ldots,X_{t}]</span>. Let <span class="math">\\mathcal{D}_{t}</span> be a family of functions to be defined in the proof. Then the univariate ZTA for <span class="math">(\\mathcal{D}_{t},\\mathcal{H},\\mathsf{cm},d)</span> implies the <span class="math">t</span>-variate ZTA for <span class="math">(\\mathcal{D},\\mathcal{H},\\mathsf{cm},d)</span> and <span class="math">t=\\mathsf{poly}(\\lambda)</span>.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{A}</span> be an adversary against the <span class="math">t</span>-variate ZTA that outputs the <span class="math">(t,d)</span>-relation <span class="math">(D,x,\\tau)</span> for <span class="math">(\\mathcal{D},\\mathcal{H},\\mathsf{cm})</span>. We construct the adversary <span class="math">\\mathcal{A}^{\\prime}</span> against the univariate ZTA that outputs a degree-<span class="math">d</span> relation for <span class="math">(\\mathcal{D}_{t},\\mathcal{H},\\mathsf{cm})</span>, where <span class="math">\\mathcal{D}_{t}</span> will be the union of all the functions <span class="math">D_{i}</span> defined in the following.</p>

    <p class="text-gray-300">Write <span class="math">f(X_{1},\\ldots,X_{t}):=D(x,\\tau)</span> as a polynomial in <span class="math">X_{t}</span> over <span class="math">\\mathbb{F}[X_{1},\\ldots,X_{t-1}]</span>:</p>

    <p class="text-gray-300"><span class="math">f(X_{t})=\\sum_{i=0}^{d}C_{i}(X_{1},\\ldots,X_{t-1})X_{t}^{i}.</span></p>

    <p class="text-gray-300"><span class="math">i\\in[t]</span>, denote <span class="math">z_{i}:=\\mathcal{H}(\\mathsf{cm}(x),\\tau,i)</span>. Suppose first that <span class="math">f(z_{1},\\ldots,z_{t-1},X_{t})\\not\\equiv 0</span>. Then <span class="math">\\mathcal{A}^{\\prime}</span> can output the degree-<span class="math">d</span> relation <span class="math">(D_{t},x,\\tau_{t})</span>, where <span class="math">D_{t}</span> is the function that computes <span class="math">f_{t}(X):=f(z_{1},\\ldots,z_{t-1},X)</span> given <span class="math">x</span> and <span class="math">\\tau_{t}:=(\\tau,t)</span>, deriving <span class="math">z_{1},\\ldots,z_{t-1}</span> via <span class="math">\\mathcal{H}</span> as part of its operation. Note that <span class="math">f_{t}(z_{t})=0</span> with <span class="math">z_{t}=\\mathcal{H}(\\mathsf{cm}(x),\\tau_{t})</span>.</p>

    <p class="text-gray-300">Otherwise, there is a non-zero polynomial <span class="math">C_{i}\\in\\mathbb{F}_{\\leq d}[X_{1},\\ldots,X_{t-1}]</span> which satisfies <span class="math">C_{i}(z_{1},\\ldots,z_{t-1})=0</span>. If <span class="math">C_{i}(z_{1},\\ldots,z_{t-2},X_{t-1})\\not\\equiv 0</span>, <span class="math">\\mathcal{A}^{\\prime}</span> can output the degree-<span class="math">d</span> relation <span class="math">(D_{t-1},x,\\tau_{t-1})</span>, where <span class="math">D_{t-1}</span> is the function that computes <span class="math">f_{t-1}(X):=C_{i}(z_{1},\\ldots,z_{t-2},X)</span> given <span class="math">x</span> and <span class="math">\\tau_{t-1}:=(\\tau,t-1)</span>.</p>

    <p class="text-gray-300">Recursively define degree-<span class="math">d</span> relations <span class="math">(D_{i},x,\\tau_{i})</span> until <span class="math">i=1</span> and we have a univariate non-zero polynomial <span class="math">C_{j}^{\\prime}\\in\\mathbb{F}_{\\leq d}[X_{1}]</span> with <span class="math">C_{j}^{\\prime}(z_{1})=0</span>. In this base case, <span class="math">\\mathcal{A}^{\\prime}</span> can output the degree-<span class="math">d</span> relation <span class="math">(D_{1},x,\\tau_{1})</span>, where <span class="math">D_{1}</span> is the function that computes <span class="math">f_{1}(X):=C_{j}^{\\prime}(X)</span> given <span class="math">x</span> and <span class="math">\\tau_{1}:=(\\tau,1)</span>, finishing the proof. ∎</p>

    <h2 id="sec-16" class="text-2xl font-bold">3 The execution model</h2>

    <p class="text-gray-300">We present a formal framework for describing function executions enabling both internal function calls and global state.</p>

    <p class="text-gray-300">We begin in Section 3.1 by introducing <em>record operations</em> which is our specific notion of operating on a global state. Record operations keep track of the computation steps at which records (roughly corresponding to notes in the introduction) were added, read and deleted. We then define what it means for a set of such operations to be <em>consistent</em>. For example, we want to enforce that a record can be deleted only if it was first added.</p>

    <p class="text-gray-300">The eventual goal is to prove that a certain set of records is the output of a function execution (where that execution includes the function’s internal calls). The proof should not reveal any information about which function was executed, as long as it belongs to a pre-defined set of legal functions, or about its arguments. To do so, it is sufficient to prove knowledge of an execution tree with the initial function at the root, the functions it calls at its children nodes and so forth. Section 3.2 defines a relation which formally captures what it means for an individual function to accept on its arguments, and Section 3.3 formally defines such execution trees.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Remark 3.1.</h6>

    <p class="text-gray-300">For simplicity, and in contrast to the introduction, we don’t explicitly discuss contracts. We only model functions operating on a shared global state. As in Aztec each function can only operate on notes of its contract, this corresponds to a system with one contract. Capturing the general system mainly requires modelling the restriction that a function is only operating on the subset of notes belonging to its contract.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">3.1 Record operations</h3>

    <p class="text-gray-300">Records are pairs <span class="math">(\\mathsf{v},\\mathsf{c})</span>, where <span class="math">\\mathsf{v}\\in\\mathbb{F}</span> is the <em>value</em>, and <span class="math">\\mathsf{c}\\in[M]</span> is a <em>counter</em>. A <em>record operation</em> has one of the following forms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{add},\\mathsf{v},\\mathsf{c})</span>,</li>

      <li><span class="math">(\\mathsf{del},\\mathsf{v},\\mathsf{c}_{\\mathsf{v}},\\mathsf{c})</span>,</li>

    </ul>

    <p class="text-gray-300">-</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{read},\\mathsf{v},\\mathsf{c}_{\\mathsf{v}},\\mathsf{c})</span>.</li>

    </ul>

    <p class="text-gray-300">Here <span class="math">\\mathsf{v}\\in\\mathbb{F}</span> is a value and <span class="math">\\mathsf{c},\\mathsf{c}_{\\mathsf{v}}\\in[M]</span> are counters. <span class="math">\\mathsf{c}</span> is interpreted as the counter of the current operation. <span class="math">\\mathsf{c}_{\\mathsf{v}}</span> is interpreted as the counter of the operation where the value was added in the case of a <span class="math">\\mathsf{read}</span> or <span class="math">\\mathsf{del}</span> operation.</p>

    <p class="text-gray-300">We say a sequence <span class="math">\\mathcal{O}</span> of record operations of size <span class="math">M</span> is <em>consistent</em> if</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The counter values <span class="math">\\mathsf{c}</span> are distinct in all elements of <span class="math">\\mathcal{O}</span>, and as a set equal to <span class="math">[M]</span>.</li>

      <li>The <span class="math">\\mathsf{c}_{\\mathsf{v}}</span> fields in all <span class="math">\\mathsf{del}</span> operations <span class="math">(\\mathsf{del},\\mathsf{v},\\mathsf{c}_{\\mathsf{v}},\\mathsf{c})\\in\\mathcal{O}</span> are distinct.</li>

      <li>If <span class="math">(\\mathsf{del},\\mathsf{v},\\mathsf{c}_{\\mathsf{v}},\\mathsf{c})\\in\\mathcal{O}</span>, then <span class="math">\\mathsf{c}_{\\mathsf{v}}&lt;\\mathsf{c}</span> and <span class="math">(\\mathsf{add},\\mathsf{v},\\mathsf{c}_{\\mathsf{v}})\\in\\mathcal{O}</span>.</li>

      <li>If <span class="math">(\\mathsf{read},\\mathsf{v},\\mathsf{c}_{\\mathsf{v}},\\mathsf{c})\\in\\mathcal{O}</span>, then <span class="math">\\mathsf{c}_{\\mathsf{v}}&lt;\\mathsf{c}</span> and <span class="math">(\\mathsf{add},\\mathsf{v},\\mathsf{c}_{\\mathsf{v}})\\in\\mathcal{O}</span>.</li>

    </ol>

    <p class="text-gray-300">Let <span class="math">\\mathsf{V}</span> be a set of records. We say <span class="math">\\mathcal{O}</span> <em>has output <span class="math">\\mathsf{V}</span></em> if:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{O}</span> is consistent.</li>

      <li><span class="math">\\mathsf{V}=\\{(\\mathsf{v},\\mathsf{c})\\mid(\\mathsf{add},\\mathsf{v},\\mathsf{c})\\in\\mathcal{O}\\land\\forall\\mathsf{c}^{\\prime}\\in[M],(\\mathsf{del},\\mathsf{v},\\mathsf{c},\\mathsf{c}^{\\prime})\\notin\\mathcal{O}\\}</span>. In words, <span class="math">\\mathsf{V}</span> is the set of values that were added and not deleted.</li>

    </ul>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">3.2 The Plonkish relation</h3>

    <p class="text-gray-300">Now we introduce a relation <span class="math">\\mathcal{R}_{app}</span> describing the individual function executions tailored to make it convenient to later discuss an execution of a <em>sequence</em> of functions calling each other. The executed function is represented in the instance by a single group element <span class="math">\\mathsf{f}</span>. In the terminology of <em>[x10]</em>, <span class="math">\\mathsf{f}</span> is a commitment to the permutation and selector values of a specific <span class="math">\\mathcal{P}\\mathsf{l}\\mathsf{o}\\mathsf{n}\\mathcal{K}</span> circuit. In particular, <span class="math">\\mathcal{R}_{app}</span> is a “universal” Plonkish relation where the circuit is not fixed but chosen in the instance.</p>

    <p class="text-gray-300">Additionally, the instance adheres to a form containing both the record operations and the details of the inner calls of the individual function execution. We stress however, that the <em>interpretation</em> of these values as record operations and inner calls, only happens in the next section when we discuss valid executions trees; and doesn’t manifest in the definition of <span class="math">\\mathcal{R}_{app}</span>. Some choices of constants – like <span class="math">\\mathsf{args}</span> being of size four – are arbitrary.</p>

    <p class="text-gray-300">We fix a polynomial <span class="math">G:\\mathbb{F}^{8}\\to\\mathbb{F}</span>, and integers <span class="math">N,\\varkappa</span> that are implicit parameters in the following definition of relation <span class="math">\\mathcal{R}_{app}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{R}_{app}</span> consists of all pairs <span class="math">(\\mathfrak{x},\\mathfrak{w})</span> having the form</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathfrak{x}=(\\mathsf{f},\\mathsf{args},\\mathsf{c},\\mathsf{f}_{1},\\mathsf{args}_{1},\\mathsf{f}_{2},\\mathsf{args}_{2},\\mathcal{O})</span> where <span class="math">\\mathsf{f},\\mathsf{f}_{1},\\mathsf{f}_{2}\\in\\mathbb{G},\\mathsf{args}\\in\\mathbb{F}^{4},\\mathsf{c}\\in\\{0,1,2\\}</span>;</li>

      <li><span class="math">\\mathfrak{w}=(\\mathsf{w}_{\\mathsf{f}},\\omega)</span> where</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\mathsf{w}_{\\mathsf{f}}=(\\mathsf{S}_{1},\\ldots,\\mathsf{S}_{4},\\mathsf{q}_{1},\\ldots,\\mathsf{q}_{4})</span>,where $\\mathsf{S}_{j}\\in[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+N]^{\\varkappa},\\mathsf{q}_{j}\\in\\mathbb{F}^{\\varkappa}<span class="math"> for each </span>j\\in[4]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\omega\\in\\mathbb{F}^{N}</span></li>

    </ul>

    <p class="text-gray-300">such that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setting <span class="math">x = (\\mathfrak{x}, \\omega)</span>, for all <span class="math">i \\in [\\mathfrak{m}]</span></li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">G(\\mathsf{q}_{1,i}, \\ldots, \\mathsf{q}_{4,i}, x_{\\mathsf{S}_{1,i}}, \\ldots, x_{\\mathsf{S}_{4,i}}) = 0.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{f} = \\mathsf{cm}(\\mathsf{w}_{\\mathsf{f}})</span>.</li>

    </ol>

    <h2 id="sec-20" class="text-2xl font-bold">3.3 Valid execution trees</h2>

    <p class="text-gray-300">By an execution tree of length <span class="math">n</span> we mean a binary tree <span class="math">\\mathsf{T}</span> with <span class="math">n</span> vertices, whose nodes are labeled by pairs <span class="math">(\\mathfrak{x}, \\mathfrak{w})</span>. Let <span class="math">\\mathsf{F}</span> be a set of elements of <span class="math">\\mathbb{G}</span>. Given such <span class="math">\\mathsf{T}</span> we say it is a valid execution of length <span class="math">n</span> with function set <span class="math">\\mathsf{F}</span> and output <span class="math">\\mathsf{V}</span> if</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">\\mathsf{n} \\in \\mathsf{T}</span>, its label <span class="math">(\\mathfrak{x}, \\mathfrak{w})</span> is in <span class="math">\\mathcal{R}_{app}</span>.</li>

      <li>For each <span class="math">\\mathsf{n} \\in \\mathsf{T}</span>, let <span class="math">(\\mathfrak{x}, \\mathfrak{w})</span> be its label. Let <span class="math">\\mathfrak{x} = (\\mathsf{f}, \\mathsf{args}, \\mathsf{c}, \\mathsf{f}_1, \\mathsf{args}_1, \\mathsf{f}_2, \\mathsf{args}_2, \\mathcal{O})</span>. Then</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{f} \\in \\mathsf{F}</span>.</li>

      <li>The number of its children is <span class="math">\\mathsf{c}</span>.</li>

      <li>For <span class="math">i \\in [\\mathsf{c}]</span>, let <span class="math">(\\mathsf{f}^i, \\mathsf{args}^i, \\mathsf{c}^i, \\mathsf{f}_1^i, \\mathsf{args}_1^i, \\mathsf{f}_2^i, \\mathsf{args}_2^i, \\mathcal{O}^i)</span> denote the first component of the label of <span class="math">\\mathsf{n}</span>'s <span class="math">i</span>-th child. Then <span class="math">\\mathsf{f}_i = \\mathsf{f}^i</span> and <span class="math">\\mathsf{args}_i = \\mathsf{args}^i</span>.</li>

      <li>Let <span class="math">\\mathcal{O}</span> be the multi-set union of <span class="math">\\mathfrak{x}.\\mathcal{O}</span> over all nodes' labels <span class="math">(\\mathfrak{x},\\mathfrak{w})</span>. Then <span class="math">\\mathcal{O}</span> has output <span class="math">\\mathsf{V}</span>.</li>

    </ul>

    <p class="text-gray-300">Given a set of group elements <span class="math">\\mathsf{F}</span>, say it has Merkle root <span class="math">\\mathbf{r}</span> if <span class="math">\\mathbf{r}</span> is the root of a Merkle tree with the elements of <span class="math">\\mathsf{F}</span> at the leaves using some pre-determined encoding.</p>

    <p class="text-gray-300">We define a relation <span class="math">\\mathcal{R}_{\\mathrm{exec}}</span> capturing knowledge of an execution of bounded length with a certain output set of records. <span class="math">\\mathcal{R}_{\\mathrm{exec}}</span> consists of the pairs <span class="math">(\\mathbf{x}_{\\mathrm{exec}}, \\mathbf{w}_{\\mathrm{exec}})</span> of the form</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{x}_{\\mathrm{exec}} = (\\mathbf{r}, C, \\mathbf{V})</span>,</li>

      <li><span class="math">\\mathbf{w}_{\\mathrm{exec}} = (n, \\mathsf{T})</span>,</li>

    </ul>

    <p class="text-gray-300">such that <span class="math">n \\leq C</span>, and <span class="math">\\mathsf{T}</span> is a valid execution tree of length <span class="math">n</span> with function set <span class="math">\\mathsf{F}</span> having Merkle root <span class="math">\\mathbf{r}</span>, and output set <span class="math">\\mathsf{V}</span>.</p>

    <h2 id="sec-21" class="text-2xl font-bold">4 Repeated Computation with Global state</h2>

    <p class="text-gray-300">Motivated by space-efficient proofs for <span class="math">\\mathcal{R}_{\\mathrm{exec}}</span>, we introduce the notion of Repeated Computation with Global state (RCG). RCGs enable us to deal separately with the local consistency of iterative steps of a transition function, and over-all consistency of a global state consisting of a part of each iteration's witness. We first define the general notion, and then in Section 4.1 show how to capture valid execution trees with it.</p>

    <p class="text-gray-300">Defining RCG relations</p>

    <p class="text-gray-300">An RCG relation is defined by a pair of functions <span class="math">(F,\\not{\\ell})</span>. We call <span class="math">F(Z,W,Z^{<em>},S)\\to\\{\\texttt{accept},\\texttt{reject}\\}</span> the </em>transition predicate<em>, and <span class="math">\\not{\\ell}(Z,S_{1},\\ldots,S_{n},\\mathsf{V})\\to\\{\\texttt{accept},\\texttt{reject}\\}</span> the </em>final predicate*. We informally think of</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">Z</span> as the public input and <span class="math">W</span> as the private input of <span class="math">F</span>.</li>

      <li><span class="math">Z^{*}</span> as the output of <span class="math">F</span> (although the actual output is <span class="math">\\{\\texttt{accept},\\texttt{reject}\\}</span>).</li>

      <li><span class="math">S</span> as the part of the private input that will be used in the final predicate.</li>

    </ul>

    <p class="text-gray-300"><em>The relation <span class="math">\\mathcal{R}_{F,\\not{\\ell}}</span></em> is the set of pairs <span class="math">(x,w)</span> with</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">x=(z_{final},C,\\mathsf{V})</span>,</li>

      <li><span class="math">w=(n,z=(z_{0},\\ldots,z_{n}),w=(w_{1},\\ldots,w_{n}),s=(s_{1},\\ldots,s_{n}))</span></li>

    </ul>

    <p class="text-gray-300">such that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">z_{0}.\\texttt{init}=\\texttt{true}</span>.</li>

      <li><span class="math">z_{n}=z_{final}</span>.</li>

      <li><span class="math">n\\leq C</span>.</li>

      <li>For each <span class="math">i\\in[n]</span>, <span class="math">F(z_{i-1},w_{i},z_{i},s_{i})=\\texttt{accept}</span>.</li>

      <li><span class="math">\\not{\\ell}(z_{final},s_{1},\\ldots,s_{n},\\mathsf{V})=\\texttt{accept}</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We say a zk-SNARK for <span class="math">\\mathcal{R}_{F,\\not{\\ell}}</span> is <em>space-efficient</em> if, given <span class="math">s</span> and streaming access to <span class="math">z</span> and <span class="math">w</span>, <span class="math">\\mathbf{P}</span> requires space $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\lambda\\log n)<span class="math">. Here </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is defined as </span>\\mathscr{M}+n^{\\prime}<span class="math"> where </span>f:\\mathbb{F}^{\\mathscr{M}}\\to\\mathbb{F}^{n^{\\prime}}<span class="math"> is the Protogalaxy constraint function representing </span>F$ (see Section 6).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">4.1 Valid executions as RCGs</h3>

    <p class="text-gray-300">We define a specific RCG relation <span class="math">\\mathcal{R}_{F,\\not{\\ell}}</span> capturing valid execution trees as defined in Section 3.3. Loosely speaking, the transition function <span class="math">F</span> will update a call stack of functions yet to be executed, and execute the function that is at the top of the stack. The final predicate <span class="math">\\not{\\ell}</span> will check the union of record operations from all iterations is consistent.</p>

    <p class="text-gray-300">More precisely, define the function <span class="math">F(Z,W,Z^{*},S)\\to\\{\\texttt{accept},\\texttt{reject}\\}</span> as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">Z=(g,\\mathbf{r},\\texttt{init})</span> where <span class="math">g</span> is a stack of elements of the form <span class="math">(\\mathsf{f},\\texttt{args})</span>, <span class="math">\\mathbf{r}</span> is a root of a Merkle tree, and <span class="math">\\texttt{init}</span> is a boolean.</li>

      <li><span class="math">Z^{<em>}=(g^{</em>},\\mathbf{r}^{<em>},\\texttt{init}^{</em>})</span> has the same form.</li>

      <li><span class="math">W=(\\mathbf{p},\\mathbf{x},\\mathfrak{w})</span>.</li>

      <li><span class="math">S</span> is a set of record operations.</li>

    </ul>

    <p class="text-gray-300">Under this notation, <span class="math">F(Z,W,Z^{*},S)=\\mathsf{accept}</span> if and only if</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\mathsf{init}=\\mathsf{true}</span>, <span class="math">g</span> contains exactly one element.</li>

      <li>Setting <span class="math">\\mathfrak{x}=(\\mathbf{x},S)</span>, we have <span class="math">(\\mathfrak{x},\\mathfrak{w})\\in\\mathcal{R}_{app}</span>.</li>

      <li>Denoting <span class="math">g[0]=(\\mathsf{f},\\mathsf{args})</span>, we have <span class="math">\\mathsf{f}=\\mathbf{x}.\\mathsf{f}</span> and <span class="math">\\mathsf{args}=\\mathbf{x}.\\mathsf{args}</span>.</li>

      <li><span class="math">\\mathbf{p}</span> is a Merkle path from <span class="math">\\mathsf{f}</span> to <span class="math">\\mathbf{r}</span>.</li>

      <li><span class="math">\\mathbf{r}=\\mathbf{r}^{*}</span>.</li>

      <li><span class="math">g^{*}</span> is the result of popping <span class="math">(\\mathsf{f},\\mathsf{args})</span> from <span class="math">g</span> and then pushing the <span class="math">\\mathfrak{x}.\\mathsf{c}</span> elements <span class="math">(\\mathfrak{x}.\\mathsf{f}_{i},\\mathfrak{x}.\\mathsf{args}_{i})</span> for <span class="math">i\\in[\\mathfrak{x}.\\mathsf{c}]</span>.</li>

    </ol>

    <p class="text-gray-300">Denote by <span class="math">g_{empty}</span> the empty stack. We define <span class="math">\\mathpzc{f}(z_{n},s_{1},\\ldots,s_{n},\\mathsf{V})</span> to output <span class="math">\\mathsf{accept}</span> if and only if</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">z_{n}.g=g_{empty}</span>,</li>

      <li>Defining <span class="math">\\mathcal{O}</span> as the multi-set union of <span class="math">s_{1},\\ldots,s_{n}</span>, it is a well-formed set of record operations with output <span class="math">\\mathsf{V}</span>.</li>

    </ol>

    <p class="text-gray-300">We show that proving knowledge of a witness for an instance of <span class="math">\\mathcal{R}_{\\mathrm{exec}}</span> can be reduced to proving knowledge of a witness for an instance of <span class="math">\\mathcal{R}_{F,\\mathpzc{f}}</span>.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Lemma 4.1.</h6>

    <p class="text-gray-300">There is an efficiently computable and efficiently invertible map <span class="math">\\varphi</span> such that the following holds. Let <span class="math">\\mathsf{F}</span> be a set of function commitments with Merkle root <span class="math">\\mathbf{r}</span>. Fix positive integers <span class="math">n,C</span> with <span class="math">n\\leq C</span>. Define <span class="math">z_{final}\\mathbf{\\sigma}=\\mathbf{\\sigma}(g_{empty},\\mathbf{r},\\mathsf{false})</span>. Let <span class="math">\\mathsf{T}</span> be an execution tree of length <span class="math">n</span>.</p>

    <p class="text-gray-300">Then <span class="math">((\\mathbf{r},C,\\mathsf{V}),(n,\\mathsf{T}))\\in\\mathcal{R}_{\\mathrm{exec}}</span> if and only if <span class="math">((z_{final}\\mathbf{\\sigma},C,\\mathsf{V}),\\varphi(n,\\mathsf{T}))\\in\\mathcal{R}_{F,\\mathpzc{f}}</span>.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We describe the operation of <span class="math">\\varphi</span>. Given <span class="math">\\mathsf{T}</span> of length <span class="math">n</span>, let <span class="math">(\\mathfrak{x}_{1},\\mathfrak{w}_{1}),\\ldots,(\\mathfrak{x}_{n},\\mathfrak{w}_{n})</span> be the labels of its nodes according to DFS order. Define a sequence of stacks <span class="math">g_{0},\\ldots,g_{n}</span> according to the sequence of labels.</p>

    <p class="text-gray-300">Namely, <span class="math">g_{0}</span> is the stack containing only <span class="math">(\\mathfrak{x}_{1}.\\mathsf{f},\\mathfrak{x}_{1}.\\mathsf{args})</span>. And for each <span class="math">i\\in[n]</span>, <span class="math">g_{i}</span> is the stack obtained by popping <span class="math">g_{i-1}[0]</span> and pushing <span class="math">(\\mathfrak{x}_{i}.\\mathsf{f}_{j},\\mathfrak{x}_{i}.\\mathsf{args}_{j})</span> for <span class="math">j\\in[\\mathfrak{x}_{i}.\\mathsf{c}]</span>. Now, define <span class="math">z_{0}=(g_{0},\\mathbf{r},\\mathsf{true})</span> and for each <span class="math">i\\in[n]</span>, <span class="math">z_{i}=(g_{i},\\mathbf{r},\\mathsf{false})</span>.</p>

    <p class="text-gray-300">To proceed we need to refer to the record operations in each instance separately. For this purpose, for each <span class="math">i\\in[n]</span> denote <span class="math">\\mathfrak{x}_{i}=(\\mathbf{x}_{i},\\mathcal{O}_{i})</span>. For each <span class="math">i\\in[n]</span>, let <span class="math">\\mathbf{p}_{i}</span> be the path from <span class="math">\\mathfrak{x}_{i}.\\mathsf{f}</span> to <span class="math">\\mathbf{r}</span>. Define for each <span class="math">i\\in[n]</span>, <span class="math">w_{i}=(\\mathbf{p}_{i},\\mathbf{x}_{i},\\mathfrak{w}_{i})</span>, <span class="math">s_{i}=\\mathcal{O}_{i}</span>. Finally set <span class="math">z=(z_{0},\\ldots,z_{n}),w=(w_{1},\\ldots,w_{n}),s=(s_{1},\\ldots,s_{n})</span> and <span class="math">\\varphi(n,\\mathsf{T})=(n,z,w,s)</span>. Given this definition of <span class="math">\\varphi</span>, the statement of the lemma is straightforward to check. ∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">5 Removing the global state via rational identities</p>

    <p class="text-gray-300">We give rational identities which are equivalent to the consistency of record operations as formally defined in Section 3.1. They arise from ideas similar to those used in “log-derivative lookups” <em>[x1, x11]</em>. Using these identities, we then define a new RCG relation <span class="math">\\mathcal{R}_{F^{<em>},\\not{\\ell}^{</em>}}</span> capturing valid execution trees, i.e., <span class="math">\\mathcal{R}_{\\text{exec}}</span>. The advantage of <span class="math">\\mathcal{R}_{F^{<em>},\\not{\\ell}^{</em>}}</span> over <span class="math">\\mathcal{R}_{F,\\not{\\ell}}</span> from Section 4.1 is that the final predicate is “trivial” in the sense of only depending on the output of the final iteration. As we’ll see in Section 8, this makes constructing a zk-SNARK for it more convenient.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Claim 5.1.</h6>

    <p class="text-gray-300">Assume <span class="math">\\mathbb{F}</span> has characteristic larger than <span class="math">M+1</span>. Let <span class="math">\\mathsf{V}</span> be a set of records and <span class="math">\\mathcal{O}=\\left\\{\\left(\\partial p_{i},\\mathsf{v}_{i},\\mathsf{c}_{\\mathsf{v}i},\\mathsf{c}_{i}\\right)\\right\\}_{i\\in[M]}</span> be a set of record operations (defining <span class="math">\\mathsf{c}_{\\mathsf{v}i}=0</span> when <span class="math">\\partial p_{i}=\\mathsf{add}</span>) with <span class="math">\\mathsf{c}_{\\mathsf{v}i}&lt;\\mathsf{c}_{i}</span> for all <span class="math">i\\in[M]</span>. Then <span class="math">\\mathcal{O}</span> has output <span class="math">\\mathsf{V}</span> if and only if the following rational function identities hold:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\sum_{(\\mathsf{v},\\mathsf{c})\\in\\mathsf{V}}\\frac{1}{X+\\mathsf{v}Y+\\mathsf{c}}=\\sum_{i\\in[M],\\partial p_{i}=\\mathsf{add}}\\frac{1}{X+\\mathsf{v}_{i}Y+\\mathsf{c}_{i}}-\\sum_{i\\in[M],\\partial p_{i}=\\mathsf{del}}\\frac{1}{X+\\mathsf{v}_{i}Y+\\mathsf{c}_{\\mathsf{v}i}}.</span></li>

      <li>For some <span class="math">m\\in\\mathbb{F}^{M}</span>, we have</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\sum_{i\\in[M],\\partial p_{i}=\\mathsf{add}}\\frac{m_{i}}{X+\\mathsf{v}_{i}Y+\\mathsf{c}_{i}}=\\sum_{i\\in[M],\\partial p_{i}=\\mathsf{read}}\\frac{1}{X+\\mathsf{v}_{i}Y+\\mathsf{c}_{\\mathsf{v}i}}.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\sum_{i\\in[M]}\\frac{1}{X+\\mathsf{c}_{i}}=\\sum_{i\\in[M]}\\frac{1}{X+i}.</span></li>

    </ol>

    <h6 id="sec-26" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We focus on the only if direction. That is, if <span class="math">\\mathcal{O}</span> doesn’t have output <span class="math">\\mathsf{V}</span> one of the three identities should not hold. Let <span class="math">R_{v,c}(X,Y):=\\frac{1}{X+vY+c}</span>. The main fact we use is that the rational functions <span class="math">\\left\\{R_{v,c}\\right\\}_{(v,c)\\in\\mathbb{F}^{2}}</span> are linearly independent. Thus, <span class="math">\\sum_{v,c}a_{v,c}R_{v,c}=\\sum b_{v,c}R_{v,c}</span> implies <span class="math">a_{v,c}=b_{v,c}</span> for each <span class="math">(v,c)\\in\\mathbb{F}^{2}</span>. The event of <span class="math">\\mathcal{O}</span> not having output <span class="math">\\mathsf{V}</span> means one of the following occurs.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The multi-set of counters <span class="math">\\left\\{\\mathsf{c}_{i}\\right\\}_{i\\in[M]}</span> doesn’t equal <span class="math">\\{1,\\ldots,M\\}</span>. In this case, the LHS of the third identity will not have all one coefficients for the elements <span class="math">\\left\\{R_{0,i}\\right\\}_{i\\in[M]}</span> and so cannot equal the RHS.</li>

    </ol>

    <p class="text-gray-300">Note that when we are not in this case the counters in <span class="math">\\mathcal{O}</span> are all distinct, which we assume for the next cases.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For some <span class="math">\\mathsf{v},\\mathsf{c}_{\\mathsf{v}},\\mathsf{c}</span>, <span class="math">(\\mathsf{del},\\mathsf{v},\\mathsf{c}_{\\mathsf{v}},\\mathsf{c})\\in\\mathcal{O}</span> but <span class="math">(\\mathsf{add},\\mathsf{v},0,\\mathsf{c}_{\\mathsf{v}})\\notin\\mathcal{O}</span>; or for some <span class="math">\\mathsf{v},\\mathsf{c}_{\\mathsf{v}},\\mathsf{c}_{1}\\neq\\mathsf{c}_{2}</span>, <span class="math">(\\mathsf{del},\\mathsf{v},\\mathsf{c}_{\\mathsf{v}},\\mathsf{c}_{1}),(\\mathsf{del},\\mathsf{v},\\mathsf{c}_{\\mathsf{v}},\\mathsf{c}_{2})\\in\\mathcal{O}</span>: In the first identity RHS, we will have <span class="math">R_{\\mathsf{v},\\mathsf{c}_{\\mathsf{v}}}</span> with coefficient in the range <span class="math">\\{-1,\\ldots,-M\\}</span>, while in the LHS it has coefficient one or zero.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For some <span class="math">\\mathsf{v},\\mathsf{c}_{\\mathsf{v}},\\mathsf{c}</span>, <span class="math">(\\mathsf{read},\\mathsf{v},\\mathsf{c}_{\\mathsf{v}},\\mathsf{c})\\in \\mathcal{O}</span> but <span class="math">(\\mathsf{add},\\mathsf{v},0,\\mathsf{c}_{\\mathsf{v}})\\notin \\mathcal{O}</span>: In the second identity RHS <span class="math">R_{\\mathsf{v},\\mathsf{c}_{\\mathsf{v}}}</span> will have a coefficient in the range <span class="math">\\{1,\\ldots ,M\\}</span> while in the LHS it has coefficient zero.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{V}</span> is not equal to the set <span class="math">\\mathsf{V}&#x27;</span> of <span class="math">(\\mathsf{v}, \\mathsf{c})</span> for which <span class="math">(\\mathsf{add}, \\mathsf{v}, 0, \\mathsf{c}) \\in \\mathcal{O}</span> but <span class="math">(\\mathsf{del}, \\mathsf{v}, \\mathsf{c}, \\mathsf{c}&#x27;) \\notin \\mathcal{O}</span>. We look at the first identity. <span class="math">\\mathsf{V}&#x27;</span> is precisely the set of <span class="math">(\\mathsf{v}, \\mathsf{c})</span> with coefficient one on the RHS, while <span class="math">\\mathsf{V}</span> is the set of <span class="math">(\\mathsf{v}, \\mathsf{c})</span> with coefficient one on the LHS. Hence the first identity cannot hold in this case.</li>

    </ol>

    <p class="text-gray-300">Defining <span class="math">\\mathcal{R}_{F^{<em>},\\ell^{</em>}}</span> We now define the RCG relation <span class="math">\\mathcal{R}_{F^{<em>},\\ell^{</em>}}</span> which will permit efficient proofs that record operations are consistent. The idea is to evaluate the above rational identities at a random point, and have the transition predicate incrementally check the evaluation is correct by a running sum. For the random evaluation point to be generated in a manner that is sound but also allow for an incremental computation of the rational identity summand by summand, we compute it via a hash chain. This chain includes at each step the new set of record operations and the last hash output, which is in essence a commitment to all the record operations in previous steps. This idea also appears in [Sou23, NDC+24, Gro24]. We proceed with the formal definition.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">F</span> denote the function <span class="math">F(Z_{F},W_{F},Z_{F}^{*},S_{F})\\to \\{\\mathsf{accept},\\mathsf{reject}\\}</span> from Section 4.1. Let $k\\coloneqq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, </span>\\mathsf{cm}:\\mathbb{F}^{5k}\\to \\mathbb{G}<span class="math">, and set </span>M\\coloneqq kn$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Define the function <span class="math">F^{<em>}:(Z,W,Z^{</em>})\\to \\{\\mathsf{accept},\\mathsf{reject}\\}</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">Z = (Z_{F},\\hbar ,\\mathfrak{s},\\alpha ,\\beta ,\\varepsilon).</span></li>

      <li><span class="math">Z^{<em>} = (Z_{F}^{</em>}, \\hbar^{<em>}, \\mathfrak{s}^{</em>}, \\alpha^{<em>}, \\beta^{</em>}, \\varepsilon^{*})</span>.</li>

      <li><span class="math">W = (W_{F}, S_{F}, m)</span>.</li>

    </ul>

    <p class="text-gray-300">Under this notation <span class="math">F^{<em>}(Z,W,Z^{</em>}) = \\mathsf{accept}</span> if and only if</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">F(Z_{F},W_{F},Z_{F}^{*},S_{F}) = \\mathsf{accept}</span></li>

      <li>If <span class="math">Z_{F}.\\mathrm{init} = \\mathrm{true}</span>, <span class="math">\\hbar = \\emptyset</span> and <span class="math">\\mathfrak{s} = 0</span></li>

      <li>Let <span class="math">S_F = \\{(op_i, \\mathsf{v}_i, \\mathsf{c}_{\\mathsf{v}i}, \\mathsf{c}_i)\\}_{i \\in [k]}</span>. We have <span class="math">\\mathsf{c}_{\\mathsf{v}i} &amp;lt; \\mathsf{c}_i</span> for all <span class="math">i \\in [k]</span>, and <span class="math">\\mathfrak{s}^* = \\mathfrak{s} +</span></li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {i \\in [ k ] \\succ p _ {i} = \\mathsf {a d d}} \\frac {1 + \\varepsilon m _ {i}}{\\alpha + \\beta \\mathsf {v} _ {i} + \\mathsf {c} _ {i}} - \\sum_ {i \\in [ k ] \\succ p _ {i} = \\mathsf {r e a d}} \\frac {\\varepsilon}{\\alpha + \\beta \\mathsf {v} _ {i} + \\mathsf {c} _ {\\mathsf {v} i}} - \\sum_ {i \\in [ k ] \\succ p _ {i} = \\mathsf {d e l}} \\frac {1}{\\alpha + \\beta \\mathsf {v} _ {i} + \\mathsf {c} _ {\\mathsf {v} i}} + \\sum_ {i \\in [ k ]} \\frac {\\varepsilon^ {2}}{\\alpha + \\mathsf {c} _ {i}}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\alpha^{<em>} = \\alpha, \\beta^{</em>} = \\beta, \\varepsilon^{*} = \\varepsilon</span></li>

      <li><span class="math">\\hbar^{*} = \\mathcal{H}(\\hbar ,\\mathsf{cm}(S_F,m))</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">\\ell^{*}(Z,\\mathsf{V}) = \\mathsf{accept}</span>  if and only if</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">Z.g = g_{empty}</span></li>

      <li><span class="math">\\mathfrak{s} = \\sum_{(\\mathsf{v},\\mathsf{c})\\in \\mathsf{V}}\\frac{1}{\\alpha + \\beta\\mathsf{v} + \\mathsf{c}} +\\sum_{i\\in [M]}\\frac{\\varepsilon^2}{\\alpha + i},</span></li>

      <li><span class="math">\\mathcal{H}(\\hbar, \\mathsf{V}, 1) = \\alpha</span> ,  <span class="math">\\mathcal{H}(\\hbar, \\mathsf{V}, 2) = \\beta</span> ,  <span class="math">\\mathcal{H}(\\hbar, \\mathsf{V}, 3) = \\varepsilon</span> .</li>

    </ol>

    <p class="text-gray-300">We show that  <span class="math">\\mathcal{R}_{F^{<em>},\\ell^{</em>}}</span>  captures  <span class="math">\\mathcal{R}_{F,\\ell}</span>  and consequently valid executions.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 5.2.</strong> There is an efficiently computable map  <span class="math">\\varphi^{<em>}</span>  such that the following holds. Suppose an efficient adversary  <span class="math">\\mathcal{A}</span>  outputs  <span class="math">(\\phi, \\omega) \\in \\mathcal{R}_{F^{</em>},\\ell^{*}}</span> . Set  $d := 3M +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{V}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1<span class="math"> . Define  </span>\\mathsf{cm}^{<em>}(s_{1}, \\ldots, s_{n}, m_{1}, \\ldots, m_{n}) := h_{n}<span class="math"> , where  </span>h_{0} := \\emptyset<span class="math">  and  </span>h_{i} := \\mathcal{H}(h_{i-1}, \\mathsf{cm}(s_{i}, m_{i}))<span class="math">  for  </span>i \\in [n]<span class="math"> . Let  </span>\\mathcal{D}<span class="math">  be a function family to be defined in the proof. Assume the 3-variate ZTA holds for  </span>(\\mathcal{D}, \\mathcal{H}, \\mathsf{cm}^{</em>}, d)<span class="math"> . Then e.w.p.  </span>\\mathsf{negl}(\\lambda)<span class="math"> ,  </span>\\varphi^{*}(\\phi, \\omega) \\in \\mathcal{R}_{F,\\ell}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Proof.</strong> Given an instance  <span class="math">\\phi = (z_{final}^{<em>}, C, \\mathsf{V})</span>  with  <span class="math">z_{final}^{</em>} = (z_{final}, \\hbar, \\mathfrak{s}, \\alpha, \\beta, \\varepsilon)</span>  and witness  <span class="math">\\omega = (n, z&#x27;, w&#x27;)</span>  with  <span class="math">z&#x27; = (z_0&#x27;, \\ldots, z_n&#x27;)</span> ,  <span class="math">w&#x27; = (w_1&#x27;, \\ldots, w_n&#x27;)</span>  output by  <span class="math">\\mathcal{A}</span> , denote  <span class="math">z_i&#x27; = (z_i, \\hbar_i, \\mathfrak{s}_i, \\alpha_i, \\beta_i, \\varepsilon_i)</span> ,  <span class="math">w_i&#x27; = (w_i, s_i, m_i)</span> . Define  <span class="math">\\varphi^*(\\phi, \\omega) := (x, w)</span>  as</p>

    <div class="my-4 text-center"><span class="math-block">x := (z _ {f i n a \\ell}, C, \\mathsf {V}), w := (n, (z _ {0}, \\ldots , z _ {n}), (w _ {1}, \\ldots , w _ {n}), (s _ {1}, \\ldots , s _ {n})).</span></div>

    <p class="text-gray-300">From  <span class="math">(\\phi, \\omega) \\in \\mathcal{R}_{F^{<em>},\\ell^{</em>}}</span> , we know  <span class="math">w</span>  satisfies the transition constraints, namely for  <span class="math">i \\in [n]</span> ,  <span class="math">F(z_{i-1}, w_i, z_i, s_i) = \\text{accept}</span> . We also know that  <span class="math">z_0.\\text{init} = \\text{true}</span> ,  <span class="math">z_n = z_{final}</span> , and  <span class="math">n \\leq C</span> . It is left to show that e.w.p.  <span class="math">\\text{negl}(\\lambda) \\notin (z_n, s_1, \\ldots, s_n, \\mathsf{V}) = \\text{accept}</span> . Since  <span class="math">z_n.g = g_{empty}</span> , this is equivalent to showing that the rational identities from Claim 5.1 hold e.w.p.  <span class="math">\\text{negl}(\\lambda)</span> .</p>

    <p class="text-gray-300">From  <span class="math">F^{<em>}(z_{i - 1}^{\\prime},w_{i}^{\\prime},z_{i}^{\\prime}) = \\mathsf{accept}</span>  for all  <span class="math">i\\in [n]</span>  and  <span class="math">\\ell^{</em>}(z_{n}^{\\prime},\\mathsf{V}) = \\mathsf{accept}</span> , we know the equations from Claim 5.1 hold at  <span class="math">\\alpha ,\\beta ,\\varepsilon</span> . That is, defining the rational function</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} r (X, Y, Z) := \\sum_ {(\\mathsf {v}, \\mathsf {c}) \\in \\mathsf {V}} \\frac {1}{X + \\mathsf {v} Y + \\mathsf {c}} - \\sum_ {i \\in [ M ], \\sigma p _ {i} = \\mathsf {a d d}} \\frac {1}{X + \\mathsf {v} _ {i} Y + \\mathsf {c} _ {i}} + \\sum_ {i \\in [ M ], \\sigma p _ {i} = \\mathsf {d e l}} \\frac {1}{X + \\mathsf {v} _ {i} Y + \\mathsf {c} _ {\\mathsf {v} i}} \\\\ + Z \\left(\\sum_ {i \\in [ M ], \\sigma p _ {i} = \\mathsf {a d d}} \\frac {(m _ {1} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m _ {n}) _ {i}}{X + \\mathsf {v} _ {i} Y + \\mathsf {c} _ {i}} - \\sum_ {i \\in [ M ], \\sigma p _ {i} = \\mathsf {r e a d}} \\frac {1}{X + \\mathsf {v} _ {i} Y + \\mathsf {c} _ {\\mathsf {v} i}}\\right) \\\\ + Z ^ {2} \\left(\\sum_ {i \\in [ M ]} \\frac {1}{X + \\mathsf {c} _ {i}} - \\sum_ {i \\in [ M ]} \\frac {1}{X + i}\\right), \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">we have  <span class="math">r(\\alpha, \\beta, \\varepsilon) = 0</span> . If any of the three rational identities from Claim 5.1 does not hold, we have  <span class="math">r(X, Y, Z) \\neq 0</span> . Let  <span class="math">f \\in \\mathbb{F}_{\\leq d}[X, Y, Z]</span>  denote the resulting non-zero degree-  <span class="math">d</span>  polynomial when multiplying  <span class="math">r(X, Y, Z)</span>  with all of its denominators. Note that  <span class="math">f(\\alpha, \\beta, \\varepsilon) = 0</span> . Define  <span class="math">D</span>  as the function that computes  <span class="math">f(X, Y, Z)</span>  given  <span class="math">x := (s_1, \\ldots, s_n, m_1, \\ldots, m_n)</span>  and  <span class="math">\\tau := \\mathsf{V}</span> . Set  <span class="math">\\mathcal{D} := \\{D\\}</span> . Then we can define an efficient adversary  <span class="math">\\mathcal{A}&#x27;</span>  against the 3-variate ZTA for  <span class="math">(\\mathcal{D}, \\mathcal{H}, \\mathsf{cm}^*, d)</span>  that outputs the  <span class="math">(3, d)</span> -relation  <span class="math">(D, x, \\tau)</span> , which has probability  <span class="math">\\mathsf{negl}(\\lambda)</span> .</p>

    <p class="text-gray-300">6 Non-interactive folding schemes</p>

    <p class="text-gray-300">We fix a vector space <span class="math">K</span> over <span class="math">\\mathbb{F}</span>, and an <span class="math">\\mathbb{F}</span>-linear function <span class="math">\\mathsf{cm}:\\mathbb{F}^{M}\\to K</span> that will be an implicit parameter in Definition 6.1. We say a relation <span class="math">\\mathcal{R}</span> is <span class="math">\\mathsf{cm}</span>-compatible if every element of <span class="math">\\mathcal{R}</span> has the form <span class="math">(\\mathsf{cm}(\\omega),\\omega)</span>. We say <span class="math">\\mathcal{R}</span> is <span class="math">\\mathsf{cm}</span>-extendable if every element of <span class="math">\\mathcal{R}</span> has the form <span class="math">((\\mathsf{cm}(\\omega),\\tau),\\omega)</span> for some <span class="math">\\omega,\\tau</span>.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Definition 6.1.</h6>

    <p class="text-gray-300">Fix relations <span class="math">\\mathcal{R}</span> and <span class="math">\\mathcal{R}_{\\mathfrak{a}\\mathfrak{e}\\mathfrak{e}}</span> that are <span class="math">\\mathsf{cm}</span>-compatible and <span class="math">\\mathsf{cm}</span>-extendable, respectively. An <span class="math">(\\mathcal{R}\\mapsto\\mathcal{R}_{\\mathfrak{a}\\mathfrak{e}\\mathfrak{e}})</span>-folding scheme is a pair of algorithms <span class="math">(\\mathbf{P},\\mathbf{V})</span> such that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{P}</span> on input <span class="math">(\\Phi,\\phi^{\\prime};\\omega,\\omega^{\\prime})</span> produces a pair <span class="math">(\\Phi^{<em>},\\omega^{</em>})</span> and proof <span class="math">\\pi</span>.</li>

      <li><span class="math">\\mathbf{V}</span> on input <span class="math">(\\Phi,\\phi^{\\prime},\\Phi^{*},\\pi)</span> outputs <span class="math">\\mathsf{accept}</span> or <span class="math">\\mathsf{reject}</span> such that</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[label=()]</li>

      <li><span class="math">\\mathbf{Completeness}</span>: If <span class="math">(\\Phi,\\omega)\\in\\mathcal{R}_{\\mathfrak{a}\\mathfrak{e}\\mathfrak{e}},(\\phi^{\\prime},\\omega^{\\prime})\\in\\mathcal{R}</span> and <span class="math">\\mathbf{P}(\\Phi,\\phi^{\\prime};\\omega,\\omega^{\\prime})=(\\Phi^{<em>},\\omega^{</em>},\\pi)</span>, then with probability <span class="math">1-\\mathsf{negl}(\\lambda)</span>, <span class="math">(\\Phi^{<em>},\\omega^{</em>})\\in\\mathcal{R}_{\\mathfrak{a}\\mathfrak{e}\\mathfrak{e}}</span> and <span class="math">\\mathbf{V}(\\Phi,\\phi^{\\prime},\\Phi^{*},\\pi)=\\mathsf{accept}</span>.</li>

      <li>Knowledge soundness given extractable commitments:</li>

    </ol>

    <p class="text-gray-300">For any efficient <span class="math">\\mathcal{A}</span> the probability of the following event is <span class="math">\\mathsf{negl}(\\lambda)</span>: <span class="math">\\mathcal{A}</span> outputs <span class="math">(\\phi,\\tau),\\phi^{\\prime},(\\phi^{<em>},\\tau^{</em>}),\\omega,\\omega^{\\prime},\\omega^{*},\\pi</span> such that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{cm}(\\omega)=\\phi,\\mathsf{cm}(\\omega^{\\prime})=\\phi^{\\prime},\\mathsf{cm}(\\omega^{<em>})=\\phi^{</em>}</span>,</li>

      <li><span class="math">\\mathbf{V}((\\phi,\\tau),\\phi^{\\prime},(\\phi^{<em>},\\tau^{</em>}),\\pi)=\\mathsf{accept}</span>,</li>

      <li><span class="math">((\\phi^{<em>},\\tau^{</em>}),\\omega^{*})\\in\\mathcal{R}_{\\mathfrak{a}\\mathfrak{e}\\mathfrak{e}}</span>,</li>

      <li><span class="math">((\\phi,\\tau),\\omega)\\notin\\mathcal{R}_{\\mathfrak{a}\\mathfrak{e}\\mathfrak{e}}</span> or <span class="math">(\\phi^{\\prime},\\omega^{\\prime})\\notin\\mathcal{R}</span>.</li>

    </ol>

    <h6 id="sec-28" class="text-base font-medium mt-4">Remark 6.2.</h6>

    <p class="text-gray-300">The justification for requiring only knowledge soundness given extractable commitments is as follows. We assume the Algebraic Group Model <em>[x10]</em> and use a commitment scheme based on linear combination of group elements like <em>[x16]</em>. In this model with such a commitment scheme an adversary <span class="math">\\mathcal{A}</span> must output <span class="math">\\omega</span>, with <span class="math">\\mathsf{cm}(\\omega)=\\phi</span> whenever it outputs some <span class="math">\\phi\\in K</span>. For more details see <em>[x10]</em> or Section 2.2 of <em>[x13]</em>, as well as Section 7 of this paper.</p>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">6.1 Relations for folding schemes</h3>

    <p class="text-gray-300">We define a more general satisfiability relation than in <em>[x3, x11]</em>. We have as parameters, integers <span class="math">n,\\mathscr{M},d</span> and an <span class="math">\\mathbb{F}</span>-vector space <span class="math">K</span>. We have a</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[label=]</li>

      <li>Constraint function <span class="math">f:\\mathbb{F}^{\\mathscr{M}}\\to\\mathbb{F}^{n}</span> which is a vector of <span class="math">n</span> <span class="math">\\mathscr{M}</span>variate polynomials of degree <span class="math">\\leq d</span>,</li>

      <li>Instance predicate <span class="math">\\mathsf{f}:K\\to\\{\\mathsf{accept},\\mathsf{reject}\\}</span>,</li>

      <li>Commitment function <span class="math">\\mathsf{cm}:\\mathbb{F}^{\\mathscr{M}}\\to K</span> which is <span class="math">\\mathbb{F}</span>-linear and assumed to be collision resistant.</li>

    </ul>

    <p class="text-gray-300">Given <span class="math">(f,\\mathsf{f},\\mathsf{cm})</span> we define a relation <span class="math">\\mathcal{R}_{f,\\mathsf{f},\\mathsf{cm}}</span> consisting of all pairs <span class="math">(\\phi,\\omega)</span> such that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">f(\\omega)=0^{n}</span>.</li>

      <li><span class="math">\\mathbf{f}(\\phi)=\\mathsf{accept}</span>.</li>

      <li><span class="math">\\phi=\\mathsf{cm}(\\omega)</span>.</li>

    </ol>

    <p class="text-gray-300">We refer to a relation of this form as a <em>protostar relation</em> as the definition is based on relations appearing in <em>[x1]</em>.</p>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">The relation <span class="math">\\mathcal{R}^{\\mathsf{rand}}</span></h4>

    <p class="text-gray-300">For brevity, let <span class="math">\\mathcal{R}=\\mathcal{R}_{f,\\mathbf{f},\\mathsf{cm}}</span>. As in <em>[x4]</em>, we define the “randomized relaxed” version of <span class="math">\\mathcal{R}</span>, <span class="math">\\mathcal{R}^{\\mathsf{rand}}</span>. First, some required notation. Let <span class="math">t:=\\log n</span>. For <span class="math">i\\in[n]</span>, let <span class="math">S_{i}\\subseteq\\{0,\\ldots,t-1\\}</span> be the set such that <span class="math">i-1=\\sum_{j\\in[S_{i}]}2^{j}</span>. We define the <span class="math">t</span>-variate polynomial <span class="math">\\mathsf{pow}_{i}</span> as</p>

    <p class="text-gray-300"><span class="math">\\mathsf{pow}_{i}(X_{0},\\ldots,X_{t-1}):=\\prod_{\\ell\\in S_{i}}X_{\\ell}.</span></p>

    <p class="text-gray-300">Note that if <span class="math">\\bm{\\beta}=(\\beta,\\beta^{2},\\beta^{4},\\ldots,\\beta^{2^{t-1}})</span>, <span class="math">\\mathsf{pow}_{i}(\\bm{\\beta})=\\beta^{i-1}</span>.</p>

    <p class="text-gray-300">Given the above notation, <span class="math">\\mathcal{R}^{\\mathsf{rand}}</span> consists of the pairs <span class="math">(\\Phi,\\omega)</span> with <span class="math">\\Phi=(\\phi,\\bm{\\beta},e)</span> such that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\phi=\\mathsf{cm}(\\omega)</span>.</li>

      <li><span class="math">\\bm{\\beta}\\in\\mathbb{F}^{t},e\\in\\mathbb{F}</span> and we have</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\sum_{i\\in[n]}\\mathsf{pow}_{i}(\\bm{\\beta})f_{i}(\\omega)=e.</span></p>

    <p class="text-gray-300">(Here, <span class="math">f_{i}</span> denotes the <span class="math">i</span>-th output coordinate of <span class="math">f</span>.)</p>

    <h3 id="sec-31" class="text-xl font-semibold mt-8">6.2 The Protogalaxy scheme</h3>

    <p class="text-gray-300">Deviating from <em>[x4]</em>, we explicitly present Protogalaxy as a <em>non-interactive</em> folding scheme, and for the special case of folding <span class="math">k=1</span> instances. We define <span class="math">Z(X):=X\\cdot(1-X)</span>. We assume below <span class="math">\\mathcal{H}</span> is a function mapping arbitrary strings to elements of <span class="math">\\mathbb{F}^{*}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{P}_{PG}(\\Phi=(\\phi,\\bm{\\beta},e),\\phi_{1};\\omega,\\omega_{1})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">\\delta=\\mathcal{H}(\\Phi,\\phi_{1})</span>. Define <span class="math">\\bm{\\delta}:=(\\delta,\\delta^{2},\\ldots,\\delta^{2^{t-1}})\\in\\mathbb{F}^{t}</span>.</li>

      <li>Compute the polynomial</li>

    </ol>

    <p class="text-gray-300"><span class="math">F(X):=\\sum_{i\\in[n]}\\mathsf{pow}_{i}(\\bm{\\beta}+X\\bm{\\delta})f_{i}(\\omega).</span></p>

    <p class="text-gray-300">(Note that <span class="math">F(0)=\\sum_{i\\in[n]}\\mathsf{pow}_{i}(\\bm{\\beta})f_{i}(\\omega)=e.</span>)</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Denote the non-constant coefficients of <span class="math">F</span> by <span class="math">a := (F_1, \\ldots, F_t)</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">\\alpha = \\mathcal{H}(\\Phi, \\phi_1, a)</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">\\beta^<em> \\in \\mathbb{F}^t</span> where <span class="math">\\beta_i^</em> := \\beta_i + \\alpha \\cdot \\delta_i</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define the polynomial <span class="math">G(X)</span> as</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">G(X) := \\sum_{i \\in [n]} \\operatorname{pow}_i(\\beta^*) f_i(X \\cdot \\omega + (1 - X) \\omega_1).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the polynomial <span class="math">K(X)</span> such that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">G(X) = F(\\alpha) X + Z(X) K(X).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">b := (K_0, \\ldots, K_{d-2})</span> be the coefficients of <span class="math">K(X)</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">\\gamma = \\mathcal{H}(\\Phi, \\phi_1, a, b)</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">e^* := F(\\alpha) \\gamma + Z(\\gamma) K(\\gamma).</span></div>

    <p class="text-gray-300">Finally, output</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the instance <span class="math">\\Phi^<em> = (\\phi^</em>, \\beta^<em>, e^</em>)</span>, where</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\phi^* := \\gamma \\cdot \\phi + (1 - \\gamma) \\phi_1,</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the witness <span class="math">\\omega^* := \\gamma \\cdot \\omega + (1 - \\gamma) \\cdot \\omega_1</span>,</li>

    </ul>

    <p class="text-gray-300">and the proof <span class="math">\\pi := (a, b)</span>.</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{V}_{PG}^{\\mathbf{f}, \\mathbf{cm}}(\\Phi, \\phi_1, \\Phi^*, \\pi = (a, b)):</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check that <span class="math">\\mathbf{f}(\\phi_1) = \\mathrm{accept}</span>. Output reject otherwise.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">\\delta, \\alpha, \\gamma</span> as in the prover algorithm given <span class="math">\\Phi, \\phi_1, a, b</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check that <span class="math">\\Phi^*</span> is as computed as in the prover algorithm. Specifically, that</li>

    </ol>

    <p class="text-gray-300">(a) For each <span class="math">i \\in [t]</span>, <span class="math">\\beta_i^* = \\beta_i + \\alpha \\cdot \\delta_i</span>.</p>

    <p class="text-gray-300">(b) <span class="math">e^* = F(\\alpha)\\gamma + Z(\\gamma)K(\\gamma)</span>, where the coefficients of <span class="math">F, K</span> are defined by <span class="math">a, b</span> respectively.</p>

    <p class="text-gray-300">(c) <span class="math">\\phi^* = \\gamma \\cdot \\phi + (1 - \\gamma)\\phi_1</span>.</p>

    <p class="text-gray-300">Output accept iff this is the case.</p>

    <p class="text-gray-300">16</p>

    <p class="text-gray-300">Remark 6.3.</p>

    <p class="text-gray-300">We stress that the verifier’s description depends on <span class="math">\\mathbf{f},\\mathsf{cm}</span> (and <span class="math">t=\\log n</span> which is implicitly defined by the former), but not <span class="math">f</span>; hence the notation <span class="math">\\mathbf{V}_{PG}^{\\mathbf{f},\\mathsf{cm}}</span>. The independence of the verifier definition from <span class="math">f</span> will be crucial in Section 8 to avoid a circular definition of <span class="math">F^{\\prime}</span>.</p>

    <p class="text-gray-300">For the knowledge soundness analysis we’ll use a variant of the Zero-Testing Assumption from <em>[x10]</em>, see Definition 2.1.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Theorem 6.4.</h6>

    <p class="text-gray-300">Set <span class="math">d^{\\prime}:=\\max\\left\\{n,d\\right\\}</span>. Denote <span class="math">\\mathsf{cm}^{\\prime}((\\omega,\\bm{\\beta},e),\\omega_{1}):=((\\mathsf{cm}(\\omega),\\bm{\\beta},e),\\mathsf{cm}(\\omega_{1}))</span>. Let <span class="math">\\mathcal{D}</span> be a family of four functions to be defined in the proof. Assume that <span class="math">\\mathsf{cm}</span> is collision resistant and the ZTA holds for <span class="math">(\\mathcal{D},\\mathcal{H},\\mathsf{cm}^{\\prime},d^{\\prime})</span>. Then Protogalaxy is a <span class="math">(\\mathcal{R}\\mapsto\\mathcal{R}^{\\mathsf{rand}})</span>-folding scheme.</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The main thing to prove is knowledge soundness given extractable commitments. Fix any efficient <span class="math">\\mathcal{A}</span>. Let <span class="math">E</span> be the event that <span class="math">\\mathcal{A}</span> outputs <span class="math">\\Phi=(\\phi,\\bm{\\beta},e),\\phi_{1},\\Phi^{<em>}=(\\phi^{</em>},\\bm{\\beta}^{<em>},e^{</em>})</span>, <span class="math">\\omega,\\omega_{1},\\omega^{*},\\pi</span> such that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{cm}(\\omega)=\\phi,\\mathsf{cm}(\\omega_{1})=\\phi_{1},\\mathsf{cm}(\\omega^{<em>})=\\phi^{</em>}</span>,</li>

      <li><span class="math">\\mathbf{V}_{PG}^{\\mathbf{f},\\mathsf{cm}}(\\Phi,\\phi_{1},\\Phi^{*},\\pi)=\\mathsf{accept}</span>,</li>

      <li><span class="math">(\\Phi^{<em>},\\omega^{</em>})\\in\\mathcal{R}^{\\mathsf{rand}}</span>,</li>

      <li><span class="math">(\\Phi,\\omega)\\notin\\mathcal{R}^{\\mathsf{rand}}</span> or <span class="math">(\\phi_{1},\\omega_{1})\\notin\\mathcal{R}</span>.</li>

    </ol>

    <p class="text-gray-300">According to Definition 6.1, knowledge soundness is equivalent to <span class="math">E</span> having probability <span class="math">\\mathsf{negl}(\\lambda)</span> for any such <span class="math">\\mathcal{A}</span>. We construct an efficient <span class="math">\\mathcal{A}^{\\prime}</span> that runs <span class="math">\\mathcal{A}</span>, and when <span class="math">E</span> occurs outputs either a collision of <span class="math">\\mathsf{cm}</span> or a degree <span class="math">d^{\\prime}</span>-relation for <span class="math">(\\mathcal{H},\\mathsf{cm})</span>. By the theorem assumption this implies <span class="math">E</span> is contained in two events of probability <span class="math">\\mathsf{negl}(\\lambda)</span>, and must have probability <span class="math">\\mathsf{negl}(\\lambda)</span> itself.</p>

    <p class="text-gray-300">Assume we are in event <span class="math">E</span>. Using linearity of <span class="math">\\mathsf{cm}</span>, when <span class="math">E</span> occurs we have</p>

    <p class="text-gray-300"><span class="math">\\mathsf{cm}(\\gamma\\omega+(1-\\gamma)\\omega_{1})=\\gamma\\phi+(1-\\gamma)\\phi_{1}=\\phi^{<em>}=\\mathsf{cm}(\\omega^{</em>}).</span></p>

    <p class="text-gray-300">Thus, if <span class="math">\\omega^{<em>}\\neq\\gamma\\omega+(1-\\gamma)\\omega_{1}</span>, <span class="math">\\mathcal{A}^{\\prime}</span> can output <span class="math">(\\omega^{</em>},\\gamma\\omega+(1-\\gamma)\\omega_{1})</span> as a collision of <span class="math">\\mathsf{cm}</span>. Now assume that <span class="math">\\omega^{<em>}=\\gamma\\omega+(1-\\gamma)\\omega_{1}</span>. Suppose <span class="math">\\pi=(a,b)</span>, with <span class="math">a=(a_{1},\\ldots,a_{t}),b=(b_{0},\\ldots,b_{d-2})</span>. Define <span class="math">F_{0}(X):=e+\\sum_{i\\in[t]}a_{i}X^{i},K^{\\prime}(X):=\\sum_{i=0}^{d-2}b_{i}X^{i}</span>. Let <span class="math">\\delta,\\bm{\\delta},\\alpha,\\bm{\\beta}^{</em>},\\gamma</span> be computed as in the prover description given <span class="math">a,b</span>. Define the polynomials</p>

    <p class="text-gray-300"><span class="math">F^{\\prime}(X)</span> <span class="math">:=F_{0}(X)-\\sum_{i\\in[n]}\\mathsf{pow}_{i}(\\bm{\\beta}+X\\bm{\\delta})f_{i}(\\omega),</span> <span class="math">G^{\\prime}(X)</span> <span class="math">:=F_{0}(\\alpha)X+Z(X)K^{\\prime}(X)-\\sum_{i\\in[n]}\\mathsf{pow}_{i}(\\bm{\\beta}^{*})f_{i}(X\\omega+(1-X)\\omega_{1}).</span></p>

    <p class="text-gray-300">Since <span class="math">((\\phi^{<em>},\\bm{\\beta}^{</em>},e^{<em>}),\\omega^{</em>})\\in\\mathcal{R}^{\\mathsf{rand}}</span> and <span class="math">\\mathbf{V}_{PG}^{\\mathbf{f},\\mathsf{cm}}(\\Phi,\\phi^{\\prime},\\Phi^{*},\\pi)=\\mathsf{accept}</span>,</p>

    <p class="text-gray-300"><span class="math">G^{\\prime}(\\gamma)</span> <span class="math">=F_{0}(\\alpha)\\gamma+Z(\\gamma)K^{\\prime}(\\gamma)-\\sum_{i\\in[n]}\\mathsf{pow}_{i}(\\bm{\\beta}^{<em>})f_{i}(\\gamma\\omega+(1-\\gamma)\\omega_{1})</span> <span class="math">=e^{</em>}-\\sum_{i\\in[n]}\\mathsf{pow}_{i}(\\bm{\\beta}^{<em>})f_{i}(\\omega^{</em>})=e^{<em>}-e^{</em>}=0.</span></p>

    <p class="text-gray-300"><span class="math">x:=((\\omega,\\boldsymbol{\\beta},e),\\omega_{1})</span> and <span class="math">\\tau_{1}:=(a,b)</span>. If <span class="math">G^{\\prime}\\not\\equiv 0</span>, <span class="math">\\mathcal{A}^{\\prime}</span> outputs the degree <span class="math">d^{\\prime}</span>-relation <span class="math">(D_{1},x,\\tau_{1})</span>, where <span class="math">D_{1}</span> is the function that computes <span class="math">G^{\\prime}(X)</span> given <span class="math">x,\\tau_{1}</span>.</p>

    <p class="text-gray-300">Assume now that <span class="math">G^{\\prime}\\equiv 0</span>.</p>

    <p class="text-gray-300">If <span class="math">(\\phi_{1},\\omega_{1})\\notin\\mathcal{R}</span>, using <span class="math">Z(0)=0</span> we have</p>

    <p class="text-gray-300"><span class="math">G^{\\prime}(0)=-\\sum_{i\\in[n]}\\mathsf{pow}_{i}(\\boldsymbol{\\beta}^{*})f_{i}(\\omega_{1})=0.</span></p>

    <p class="text-gray-300">Define the polynomial <span class="math">A(X):=\\sum_{i\\in[n]}f_{i}(\\omega_{1})\\mathsf{pow}_{i}(\\boldsymbol{\\beta}_{1}+X\\delta,\\boldsymbol{\\beta}_{2}+X\\delta^{2},\\ldots,\\boldsymbol{\\beta}_{t}+X\\delta^{2^{t-1}})</span>. We have <span class="math">A(\\alpha)=0</span>. Suppose first that <span class="math">A(X)\\not\\equiv 0</span>. Then setting <span class="math">D_{2}</span> to be the function that computes <span class="math">A(X)</span> given <span class="math">x</span> and <span class="math">\\tau_{2}:=a</span>, <span class="math">\\mathcal{A}^{\\prime}</span> can output the degree <span class="math">n</span> relation <span class="math">(D_{2},x,\\tau_{2})</span>. Now assume <span class="math">A(X)\\equiv 0</span>. Define the polynomial</p>

    <p class="text-gray-300"><span class="math">B(X,Y):=\\sum_{i\\in[n]}f_{i}(\\omega_{1})\\mathsf{pow}_{i}(\\boldsymbol{\\beta}_{1}+XY,\\boldsymbol{\\beta}_{2}+XY^{2},\\ldots,\\boldsymbol{\\beta}_{t}+XY^{2^{t-1}}).</span></p>

    <p class="text-gray-300">We have that <span class="math">B(X,\\delta)\\equiv 0</span>. Write <span class="math">B(X,Y)</span> as a polynomial in <span class="math">X</span> over <span class="math">\\mathbb{F}[Y]</span>:</p>

    <p class="text-gray-300"><span class="math">B(X)=\\sum_{i=0}^{t}C_{i}(Y)X^{i}.</span></p>

    <p class="text-gray-300">Because we’re in the case <span class="math">(\\phi_{1},\\omega_{1})\\notin\\mathcal{R}</span>, <span class="math">B</span> is a combination of the <span class="math">n</span> linearly independent polynomials <span class="math">\\left\\{\\mathsf{pow}_{i}(\\boldsymbol{\\beta}_{1}+XY,\\boldsymbol{\\beta}_{2}+XY^{2},\\ldots,\\boldsymbol{\\beta}_{t}+XY^{2^{t-1}})\\right\\}_{i\\in[n]}</span> with at least one non-zero coefficient, and so <span class="math">B(X,Y)\\not\\equiv 0</span>. This means one of the polynomials <span class="math">C_{i}</span> is non-zero, while <span class="math">C_{i}(\\delta)=0</span>. We can use this to let <span class="math">\\mathcal{A}^{\\prime}</span> output the degree <span class="math">n</span> relation <span class="math">(D_{3},x,\\tau_{3})</span>, where <span class="math">D_{3}</span> is the function that computes <span class="math">C_{i}</span> given <span class="math">x</span> and <span class="math">\\tau_{3}:=\\emptyset</span>.</p>

    <p class="text-gray-300">Now, assume that <span class="math">(\\Phi,\\omega)\\notin\\mathcal{R}^{\\mathsf{rand}}</span>. As we’re still assuming <span class="math">G^{\\prime}\\equiv 0</span>, we have</p>

    <p class="text-gray-300"><span class="math">G^{\\prime}(1)=F_{0}(\\alpha)-\\sum_{i\\in[n]}\\mathsf{pow}_{i}(\\boldsymbol{\\beta}^{*})f_{i}(\\omega)=0.</span></p>

    <p class="text-gray-300">But we also have <span class="math">F^{\\prime}(\\alpha)=G^{\\prime}(1)</span> and so <span class="math">F^{\\prime}(\\alpha)=0</span>. On the other hand,</p>

    <p class="text-gray-300"><span class="math">F^{\\prime}(0)=e-\\sum_{i\\in[n]}\\mathsf{pow}_{i}(\\boldsymbol{\\beta})f_{i}(\\omega)\\neq 0.</span></p>

    <p class="text-gray-300">Setting <span class="math">\\tau_{4}:=a</span> and <span class="math">D_{4}</span> to be the function that computes <span class="math">F^{\\prime}</span> given <span class="math">x,\\tau_{4}</span>, we have that <span class="math">(D_{4},x,\\tau_{4})</span> is a degree <span class="math">\\log n</span> relation that <span class="math">\\mathcal{A}^{\\prime}</span> can output in this case. Setting <span class="math">\\mathcal{D}=\\{D_{1},D_{2},D_{3},D_{4}\\}</span> we have proven knowledge soundness under the theorem assumptions. ∎</p>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">6.3 Representative protostar-relations</h3>

    <h6 id="sec-35" class="text-base font-medium mt-4">Definition 6.5.</h6>

    <p class="text-gray-300">Given a relation <span class="math">\\mathcal{R}_{0}</span> we say a protostar-relation <span class="math">\\mathcal{R}=\\mathcal{R}_{f,\\boldsymbol{\\mathbf{f}},\\mathsf{cm}}</span> represents <span class="math">\\mathcal{R}_{0}</span> if there are efficiently computable and invertible maps <span class="math">\\varphi_{0},\\varphi_{1}</span> such that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\varphi_0(\\phi)</span> is always of the form <span class="math">(\\phi, X)</span> for some <span class="math">X</span>.</li>

      <li>Any efficient <span class="math">\\mathcal{A}</span> has a <span class="math">\\mathrm{negl}(\\lambda)</span> probability of outputting a pair <span class="math">(\\phi, \\omega)</span> such that either:</li>

    </ol>

    <p class="text-gray-300">(a) <span class="math">(\\phi, \\omega) \\in \\mathcal{R}_0</span> but <span class="math">(\\varphi_0(\\phi), \\varphi_1(\\omega)) \\notin \\mathcal{R}</span>. (b) <span class="math">(\\phi, \\omega) \\in \\mathcal{R}</span> but <span class="math">(\\varphi_0^{-1}(\\phi), \\varphi_1^{-1}(\\omega)) \\notin \\mathcal{R}_0</span>.</p>

    <p class="text-gray-300">We define the size of the protostar relation <span class="math">R_{f,\\mathbf{f},\\mathrm{cm}}</span> as <span class="math">\\mathcal{M} + n</span>.</p>

    <p class="text-gray-300"><strong>Claim 6.6.</strong> Assuming ZTA for a constant size family there is a protostar-relation <span class="math">\\mathcal{R}_{f,\\mathbf{f},\\mathrm{cm}}</span> representing <span class="math">\\mathcal{R}_{app}</span> of size <span class="math">O(N + n)</span>.</p>

    <h2 id="sec-36" class="text-2xl font-bold">7 Adversaries supporting recursive extraction</h2>

    <p class="text-gray-300">Following [LS24], we define a model of "recursive extraction" for our analysis in Section 8. We assume our commitment function <span class="math">\\mathsf{cm}:\\mathbb{F}^{\\mathcal{M}}\\to K</span> is surjective. We assume the existence of an efficiently computable injective representation function <span class="math">R:K\\to \\mathbb{F}^{\\mathcal{L}}</span>. Whenever an adversary <span class="math">\\mathcal{A}</span> outputs <span class="math">a\\in K</span> we assume it is represented as <span class="math">R(a)</span>. When analyzing knowledge soundness of our zk-SNARK in the next section, we put the following limitation on <span class="math">\\mathcal{A}</span>. Say <span class="math">\\mathcal{A}</span> outputs a vector <span class="math">v</span> over <span class="math">\\mathbb{F}</span>. If there is an index <span class="math">i</span> such that <span class="math">(v_{i},\\ldots ,v_{i + \\neq -1}) = R(a)</span> for some <span class="math">a\\in K</span>, then <span class="math">\\mathcal{A}</span> must also output <span class="math">\\omega \\in \\mathbb{F}^{\\mathcal{M}}</span> such that <span class="math">\\mathsf{cm}(\\omega) = a</span>. The same requirement of outputting a cm preimage for substrings in <span class="math">K</span> then holds for <span class="math">\\omega</span> and all other outputs of <span class="math">\\mathcal{A}</span>. In other words, <span class="math">\\mathcal{A}</span> must continue outputting more vectors "explaining" elements of <span class="math">K</span>, until the explanation vectors do not contain any elements of <span class="math">K</span> as substrings. We call such <span class="math">\\mathcal{A}</span> a recursive algebraic adversary with respect to cm. We always work with cm and <span class="math">R</span> such that only a <span class="math">\\mathrm{negl}(\\lambda)</span> fraction of elements of <span class="math">F^{\\mathcal{L}}</span> are in <span class="math">R(K)</span>. This is to get a <span class="math">\\mathrm{negl}(\\lambda)</span> probability that a random vector of <span class="math">\\mathrm{poly}(\\lambda)</span> size has a substring that is an element of <span class="math">K</span> - and thus avoid situations where <span class="math">\\mathcal{A}</span> is forced to "explain" elements of <span class="math">K</span> that he didn't purposefully write.</p>

    <p class="text-gray-300">This assumption is motivated by a "recursive" interpretation of the Algebraic Group Model[FKL18] as done in [LS24]. For illustration, consider first the case where <span class="math">\\mathsf{cm}:\\mathbb{F}^n\\to \\mathbb{G}</span> is defined as <span class="math">\\mathsf{cm}(\\omega) = \\langle \\omega ,V\\rangle</span> for a fixed vector <span class="math">V\\in \\mathbb{G}^n</span> derived in a setup procedure. I.e. <span class="math">\\mathsf{cm}</span> is a Pedersen commitment in this case. In this case, the AGM forces <span class="math">\\mathcal{A}</span> when outputting <span class="math">a\\in \\mathbb{G}</span> to also output <span class="math">\\omega</span> such that <span class="math">\\langle \\omega ,V\\rangle = \\mathsf{cm}(\\omega) = a</span>. [LS24] now raise the idea that if a prespecified subset of indices of <span class="math">\\omega</span> is a valid representation of <span class="math">b\\in \\mathbb{G}</span>, it is reasonable to demand of an algebraic <span class="math">\\mathcal{A}</span> to also output <span class="math">\\omega_{2}</span> with <span class="math">\\langle \\omega_2,V\\rangle = b</span>.</p>

    <p class="text-gray-300">Our concrete choice for cm when using PROTOGALAXY, is of the following form.² We have a setup procedure outputting a vector of group elements <span class="math">V \\in \\mathbb{G}^n</span> as output. We have some fixed partition of our input <span class="math">\\omega \\in \\mathbb{F}^{\\mathcal{M}}</span> into continuous segments of size either one or <span class="math">n</span>. To get <span class="math">\\mathsf{cm}(\\omega)</span> we operate segment-wise. If the segment <span class="math">\\omega_i</span> is of size one we</p>

    <p class="text-gray-300">²cm is of this form because it is derived from an interactive protocol where the prover messages are in committed form, but verifier challenges are in the clear. See [BC23, EG23] for more details.</p>

    <p class="text-gray-300">simply append <span class="math">\\omega_{i}</span> to the output. If a segment <span class="math">s = (\\omega_{i},\\ldots ,\\omega_{i + n - 1})</span> is of size <span class="math">n</span> we append <span class="math">\\langle s,V\\rangle</span> to the output. In particular the output <span class="math">\\mathsf{cm}(\\omega)</span> is a mixture of <span class="math">\\mathbb{F}</span> and <span class="math">\\mathbb{G}</span> elements, and accordingly the space <span class="math">K</span> is a direct sum of spaces <span class="math">\\mathbb{V}_i\\in \\{\\mathbb{F},\\mathbb{G}\\}</span>. It follows that an algebraic adversary outputting <span class="math">c\\in K</span> must output <span class="math">\\omega</span> with <span class="math">\\mathsf{cm}(\\omega) = c</span> as the AGM forces it to send an opening <span class="math">s\\in \\mathbb{F}^n</span> to each <span class="math">a\\in \\mathbb{G}</span>.</p>

    <h2 id="sec-37" class="text-2xl font-bold">8 The main construction</h2>

    <p class="text-gray-300">We say an RCG relation <span class="math">\\mathcal{R}_{F,\\ell}</span> is trivial if the <span class="math">S</span> variable is not used in <span class="math">F</span>, and accordingly <span class="math">\\ell</span> depends only on <span class="math">(z_{final},\\mathsf{V})</span>. We assume in this section <span class="math">\\mathcal{R}_{F,\\ell}</span> is trivial, thinking of it as <span class="math">\\mathcal{R}_{F^{<em>},\\ell^{</em>}}</span> from Section 5.</p>

    <h2 id="sec-38" class="text-2xl font-bold">8.1 The extended function <span class="math">F&#x27;</span></h2>

    <p class="text-gray-300">As in [KST21, BCL+21], we first describe an extended function <span class="math">F&#x27;</span> that executes the folding verifier in addition to an iteration of <span class="math">F</span>. Loosely speaking, extending <span class="math">F</span> into <span class="math">F&#x27;</span> is what enables bootstrapping a folding scheme into an IVC or RCG. We describe the function arguments first.</p>

    <pre><code class="language-text">inst = (z, count, fi)</code></pre>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">z</span> – output for <span class="math">F</span></li>

      <li>count – counter of IVC step</li>

      <li><span class="math">fi</span> – hash of accumulator</li>

    </ul>

    <pre><code class="language-text">w-inst = (acc, acc0, inst0, w, π)</code></pre>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>acc – current accumulator instance</li>

      <li>acc0 – previous accumulator instance</li>

      <li>inst0 – instance (of <span class="math">F&#x27;</span>) to be accumulated</li>

      <li><span class="math">w</span> – private input for <span class="math">F</span></li>

      <li><span class="math">\\pi</span> – proof for PROTOGALAXY verifier</li>

    </ul>

    <p class="text-gray-300">We fix <span class="math">\\mathbf{f}, \\mathbf{cm}, \\varphi_0, \\varphi_1</span> to be the values appearing in the statement of Claim 6.6. <span class="math">F&#x27;(\\mathrm{inst}, \\mathbf{w} - \\mathrm{inst}) = \\mathrm{accept}</span> if and only if:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">F(\\mathrm{inst}_0.z,w,z) = \\mathrm{accept}</span>.</li>

      <li>If count = 1:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{inst}_0.z.\\mathrm{init} = \\mathrm{true}</span>.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If count &gt; 1:</li>

    </ol>

    <p class="text-gray-300">20</p>

    <p class="text-gray-300">(a) <span class="math">\\mathcal{H}(\\mathrm{acc}) = \\hbar</span>. (b) <span class="math">\\mathcal{H}(\\mathrm{acc}_0) = \\mathrm{inst}_0.\\hbar</span>. (c) <span class="math">\\mathrm{inst}_0.\\mathrm{count} = \\mathrm{count} - 1</span>. (d) <span class="math">\\mathbf{V}_{PG}^{\\ell,\\mathrm{cm}}(\\mathrm{acc}_0, \\varphi_0(\\mathrm{inst}_0), \\mathrm{acc}, \\pi) = \\mathrm{accept}</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{R}_0</span> be the set of pairs <span class="math">(\\mathrm{inst}, \\mathbf{w} - \\mathrm{inst})</span> with <span class="math">F&#x27;(\\mathrm{inst}, \\mathbf{w} - \\mathrm{inst}) = \\mathrm{accept}</span>. Let <span class="math">\\mathcal{R}</span> be a protostar-relation representing <span class="math">\\mathcal{R}_0</span> as defined in Section 6.3.</p>

    <h2 id="sec-39" class="text-2xl font-bold">8.2 Commitment-consistent SNARKs</h2>

    <p class="text-gray-300">It will be convenient to assume a zk-SNARK where the proof contains a commitment to the witness. All SNARK construction we are aware of (e.g. [GWC19]) have this property.</p>

    <p class="text-gray-300"><strong>Definition 8.1.</strong> Fix a relation <span class="math">\\mathcal{R}</span>. Fix a linear function <span class="math">\\mathrm{cm} : \\mathbb{F} \\to K</span>. A cm-consistent zk-SNARK for <span class="math">\\mathcal{R}</span> is a tuple of efficient algorithms <span class="math">(\\mathbf{P}, \\mathbf{V}, \\mathbf{S})</span> such that <span class="math">\\mathbf{V}(\\mathrm{inst}, \\pi) = \\mathrm{accept}</span> implies <span class="math">\\pi = (\\pi_1, \\pi_2)</span> with <span class="math">\\pi_1 \\in K</span>. And additionally,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Completeness:</strong> Suppose <span class="math">(\\mathrm{inst}, \\omega) \\in \\mathcal{R}</span>. Let <span class="math">\\pi = \\mathbf{P}(\\mathrm{inst}, \\omega)</span>. Then with probability <span class="math">1 - \\mathrm{negl}(\\lambda)</span>, <span class="math">\\mathbf{V}(\\mathrm{inst}, \\pi) = \\mathrm{accept}</span>.</li>

      <li><strong>Knowledge Soundness given extractable commitments:</strong> The probability of any efficient <span class="math">\\mathcal{A}</span> outputting <span class="math">\\mathrm{inst}, \\pi = (\\pi_1, \\pi_2), \\omega</span> such that</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{V}(\\mathrm{inst}, \\pi) = \\mathrm{accept}</span>,</li>

      <li><span class="math">\\mathrm{cm}(\\omega) = \\pi_1</span>,</li>

      <li><span class="math">(\\mathrm{inst}, \\omega) \\notin \\mathcal{R}</span>,</li>

    </ol>

    <p class="text-gray-300">is <span class="math">\\mathrm{negl}(\\lambda)</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Zero-Knowledge:</strong> Fix any <span class="math">(\\mathrm{inst}, \\omega) \\in \\mathcal{R}</span>. <span class="math">\\mathrm{S}(\\mathrm{inst}, r_{\\mathrm{cm}})</span> outputs a distribution <span class="math">\\mathrm{negl}(\\lambda)</span>-close to <span class="math">\\mathbf{P}(\\mathrm{inst}, \\omega)</span>.</li>

    </ul>

    <p class="text-gray-300">For readability, from now on we denote an accumulator by <span class="math">\\mathrm{acc}</span>, accumulator witness by <span class="math">\\mathbf{w}</span>-<span class="math">\\mathrm{acc}</span>, instance by <span class="math">\\mathrm{inst}</span>, and instance witness by <span class="math">\\mathbf{w}</span>-<span class="math">\\mathrm{inst}</span>.</p>

    <h2 id="sec-40" class="text-2xl font-bold">8.3 The relation <span class="math">\\mathcal{R}_{\\mathrm{fin}}</span></h2>

    <p class="text-gray-300">We define the relation <span class="math">\\mathcal{R}_{\\mathrm{fin}}</span> of pairs <span class="math">(x, \\omega)</span> with</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">x = (\\mathrm{acc}, z_{\\mathrm{final}}, C, \\mathrm{V})</span></li>

      <li><span class="math">\\omega = (\\mathrm{w - acc}, \\mathrm{acc}_0, \\mathrm{inst}, \\pi)</span></li>

    </ul>

    <p class="text-gray-300">such that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathrm{acc}, \\mathrm{w - acc}) \\in \\mathcal{R}^{\\mathrm{rand}}</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{V}_{PG}^{\\ell, \\mathrm{cm}}(\\mathrm{acc}_0, \\mathrm{inst}, \\mathrm{acc}, \\pi) = \\mathrm{accept}</span>.</li>

      <li><span class="math">\\mathrm{inst}.z = z_{final}</span>.</li>

      <li><span class="math">\\mathrm{inst.count} \\leq C</span>.</li>

      <li><span class="math">\\mathrm{inst.}\\hbar = \\mathcal{H}(\\mathrm{acc}_0)</span>.</li>

    </ol>

    <p class="text-gray-300">Let <span class="math">(\\mathbf{P}_{\\mathrm{fin}},\\mathbf{V}_{\\mathrm{fin}})</span> be a cm-consistent zk-SNARK for <span class="math">\\mathcal{R}_{\\mathrm{fin}}</span>.</p>

    <h2 id="sec-41" class="text-2xl font-bold">8.4 Main construction</h2>

    <p class="text-gray-300">We now describe the full prover and verifier for a given trivial RCG relation <span class="math">\\mathcal{R}_{F,\\ell}</span>. Later we review how to use this to get a zk-SNARK for the relation <span class="math">\\mathcal{R}_{\\mathrm{exec}}</span> of valid executions, given the reductions of the previous sections.</p>

    <h2 id="sec-42" class="text-2xl font-bold"><span class="math">\\mathbf{P}(x,w)</span>:</h2>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">x = (z_{final}, C, \\mathsf{V}), w = (n, (z_0, \\ldots, z_n), (w_1, \\ldots, w_n))</span>. Recall that <span class="math">(x, w) \\in \\mathcal{R}_{F,\\ell}</span> implies <span class="math">F(z_{i-1}, w_i, z_i) = \\text{accept}</span> for each <span class="math">i \\in [n]</span>, <span class="math">z_0.\\mathrm{init} = \\text{true}</span>, <span class="math">z_n = z_{final}</span>, <span class="math">n \\leq C</span> and <span class="math">\\ell(z_{final}, \\mathsf{V}) = \\text{accept}</span>.</li>

      <li>Choose instance <span class="math">\\mathrm{inst}_0 = (z_0, \\mathrm{count}_0, \\hbar_0)</span> for arbitrary values <span class="math">\\mathrm{count}_0, \\hbar_0</span>. Choose <span class="math">\\mathrm{acc}_0</span> arbitrarily. Let <span class="math">\\mathrm{inst}_1 = (z_1, 1, \\hbar_1)</span>, <span class="math">\\mathbf{w}</span>-<span class="math">\\mathrm{inst}_1 = (\\mathrm{acc}_0, \\mathrm{acc}_0, \\mathrm{inst}_0, w_1, \\pi_0)</span> for arbitrary values <span class="math">\\hbar_1, \\mathrm{acc}_0, \\pi_0</span>. (We can choose some values arbitrarily as they aren't constrained in <span class="math">F&#x27;</span> when <span class="math">\\mathrm{count} = 1</span>.)</li>

      <li>Let <span class="math">\\mathrm{acc}_1</span> be a randomly chosen satisfiable accumulator. Namely, <span class="math">\\mathrm{acc}_1 = (\\mathrm{cm}(\\mathbf{w} - \\mathrm{acc}_1), \\beta, e)</span> where <span class="math">\\mathbf{w} - \\mathrm{acc}_1</span> and <span class="math">\\beta</span> are chosen randomly<span class="math">^3</span>, and <span class="math">e</span> is set to <span class="math">e = \\sum_{i \\in [n]} \\mathsf{pow}_i(\\beta) f_i(\\mathbf{w} - \\mathrm{acc}_1)</span>.</li>

      <li>For each <span class="math">2 \\leq i \\leq n</span>, compute</li>

    </ol>

    <p class="text-gray-300">(a) <span class="math">(\\mathrm{acc}_i, \\mathbf{w} - \\mathrm{acc}_i, \\pi_i) = \\mathbf{P}_{\\mathrm{cm}, n, f}^{\\mathrm{PG}}(\\mathrm{acc}_{i-1}, \\mathbf{w} - \\mathrm{acc}_{i-1}, \\varphi_0(\\mathrm{inst}_{i-1}), \\varphi_1(\\mathbf{w} - \\mathrm{inst}_{i-1}))</span> (b) <span class="math">\\mathrm{inst}_i = (z_i, i, \\mathcal{H}(\\mathrm{acc}_i))</span>, (c) <span class="math">\\mathbf{w} - \\mathrm{inst}_i = (\\mathrm{acc}_i, \\mathrm{acc}_{i-1}, \\mathrm{inst}_{i-1}, w_i, \\pi_i)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathrm{acc}, \\mathbf{w} - \\mathrm{acc}, \\pi^*) = \\mathbf{P}_{\\mathrm{cm}, n, f}^{\\mathrm{PG}}(\\mathrm{acc}_n, \\mathbf{w} - \\mathrm{acc}_n, \\varphi_0(\\mathrm{inst}_n), \\varphi_1(\\mathbf{w} - \\mathrm{inst}_n))</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\pi_{\\mathrm{fin}} = \\mathbf{P}_{\\mathrm{fin}}(x, \\omega)</span> where</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">x = (\\mathrm{acc}, z_{final}, C, \\mathsf{V})</span></li>

      <li><span class="math">\\omega = (\\mathbf{w} - \\mathrm{acc}, \\mathrm{acc}_n, \\varphi_0(\\mathrm{inst}_n), \\pi^*)</span></li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output <span class="math">\\pi = (\\mathrm{acc}, \\pi_{\\mathrm{fin}})</span>.</li>

    </ol>

    <p class="text-gray-300"><span class="math">^3</span>We only need <span class="math">\\mathsf{cm}(\\mathbf{w} - \\mathsf{acc}_1)</span> to be uniformly distributed over the image of <span class="math">\\mathsf{cm}</span>. According to <span class="math">\\mathsf{cm}</span>'s structure, it may suffice to choose only a small subset of <span class="math">\\mathbf{w} - \\mathsf{acc}_1</span>'s coordinates randomly, and set the rest to zero.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{V}(x,\\pi)</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse <span class="math">x</span> as <span class="math">(z_{final},C,\\mathsf{V})</span>, <span class="math">\\pi</span> as <span class="math">(\\mathsf{acc},\\pi_{\\mathsf{fin}})</span>.</li>

      <li>If <span class="math">\\ell(z_{final},\\mathsf{V})=\\mathsf{reject}</span> output <span class="math">\\mathsf{reject}</span>.</li>

      <li>Let <span class="math">x:=(\\mathsf{acc},z_{final},C,\\mathsf{V})</span>.</li>

      <li>Return <span class="math">\\mathbf{V}_{\\mathsf{fin}}(x,\\pi_{\\mathsf{fin}})</span>.</li>

    </ol>

    <h6 id="sec-43" class="text-base font-medium mt-4">Theorem 8.2.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{R}_{F,\\ell}</span> be a trivial RCG relation. Assume that <span class="math">\\mathcal{H}</span> is collision resistant, and that the assumptions in Theorem 6.4 hold. Then <span class="math">(\\mathbf{P},\\mathbf{V})</span> is a space-efficient zk-SNARK for <span class="math">\\mathcal{R}_{F,\\ell}</span>.</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The main thing to prove is knowledge soundness. Let <span class="math">\\mathcal{A}</span> be a recursive algebraic adversary.</p>

    <p class="text-gray-300">We define the following extractor algorithm <span class="math">\\mathbf{E}</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Given <span class="math">(x,\\pi_{\\mathsf{fin}})</span>, if <span class="math">\\pi_{\\mathsf{fin}}</span> is not of the form <span class="math">(\\pi_{1},\\pi_{2})</span> with <span class="math">\\pi_{1}\\in K</span> output <span class="math">\\mathsf{empty}</span> and abort. Otherwise let <span class="math">\\omega</span> be the element output by <span class="math">\\mathcal{A}</span> such that <span class="math">\\mathsf{cm}(\\omega)=\\pi_{1}</span>.</li>

      <li>Parse <span class="math">\\omega</span> as <span class="math">\\omega=(\\mathsf{w-acc},\\mathsf{acc}^{<em>},\\mathsf{inst}^{</em>},\\pi^{*})</span> where the different elements have the appropriate length in a witness for <span class="math">\\mathcal{R}_{\\mathsf{fin}}</span>. If such parsing fails output <span class="math">\\mathsf{empty}</span> and abort.</li>

      <li>Let <span class="math">n:=\\mathsf{inst}^{<em>}.\\mathsf{count}</span>. Denote <span class="math">\\mathsf{acc}_{n}:=\\mathsf{acc}^{</em>},\\mathsf{inst}_{n}:=\\mathsf{inst}^{*}</span>.</li>

      <li>If <span class="math">(x,\\omega)\\notin\\mathcal{R}_{\\mathsf{fin}}</span>, output <span class="math">\\mathsf{empty}</span> and abort. Otherwise, <span class="math">\\mathbf{V}_{PG}^{\\ell,\\mathsf{cm}}(\\mathsf{acc}_{n},\\mathsf{inst}_{n},\\mathsf{acc},\\pi^{*})=\\mathsf{accept}</span>, and thus <span class="math">\\mathsf{acc}_{n},\\mathsf{inst}_{n}\\in K</span>. Let <span class="math">\\mathsf{w-acc}_{n},\\mathsf{w-inst}_{n}</span> be the elements output by <span class="math">\\mathcal{A}</span> such that <span class="math">\\mathsf{cm}(\\mathsf{w-acc}_{n})=\\mathsf{acc}_{n}</span> and <span class="math">\\mathsf{cm}(\\mathsf{w-inst}_{n})=\\mathsf{inst}_{n}</span>.</li>

      <li>For <span class="math">i=n-1,\\ldots,1</span>:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">(\\mathsf{inst}_{i+1},\\mathsf{w-inst}_{i+1})\\notin\\mathcal{R}</span>, output <span class="math">\\mathsf{empty}</span> and abort. Otherwise, as <span class="math">(\\mathsf{inst}_{i+1},\\mathsf{w-inst}_{i+1})\\in\\mathcal{R}</span> implies <span class="math">\\mathsf{acc}_{i},\\mathsf{inst}_{i}\\in K</span>, let <span class="math">\\mathsf{w-acc}_{i},\\mathsf{w-inst}_{i}</span> be the elements output by <span class="math">\\mathcal{A}</span> such that <span class="math">\\mathsf{acc}_{i}=\\mathsf{cm}(\\mathsf{w-acc}_{i}),\\mathsf{inst}_{i}=\\mathsf{cm}(\\mathsf{w-inst}_{i})</span>.</li>

      <li>Parse <span class="math">\\varphi_{0}^{-1}(\\mathsf{inst}_{i})</span> as <span class="math">(z_{i},\\mathsf{count}_{i},\\hbar_{i})</span>. Parse <span class="math">\\varphi_{1}^{-1}(\\mathsf{w-inst}_{i})</span> as <span class="math">(\\mathsf{acc}_{i}^{\\prime},\\mathsf{acc}_{i-1},\\mathsf{inst}_{i-1},w_{i},\\pi_{i})</span>. Note that through this parsing we have in particular defined <span class="math">z_{i},w_{i}</span> and <span class="math">\\mathsf{inst}_{i-1}</span>.</li>

      <li>Define <span class="math">z_{0}:=\\mathsf{inst}_{0}.z</span>.</li>

      <li>Output <span class="math">w:=(n,(z_{0},\\ldots,z_{n}),(w_{1},\\ldots,w_{n}))</span>.</li>

    </ol>

    <p class="text-gray-300">Let <span class="math">D</span> be the event that <span class="math">\\mathcal{A}</span> outputs <span class="math">(x,\\pi)</span> such that <span class="math">\\mathbf{V}(x,\\pi)=\\mathsf{accept}</span>. If <span class="math">D</span> has probability <span class="math">\\mathsf{negl}(\\lambda)</span> we are done. Otherwise, in order to prove knowledge soundness, we need to show that</p>

    <p class="text-gray-300"><span class="math">\\Pr[(x,w)\\notin\\mathcal{R}_{F,\\ell}\\mid D]=\\mathsf{negl}(\\lambda).</span></p>

    <p class="text-gray-300">Assume from now we are in the space conditioned on <span class="math">D</span>. Let <span class="math">E_{0}</span> be the event <span class="math">(x,\\omega)\\notin\\mathcal{R}_{\\mathsf{fin}}</span>. For <span class="math">i\\in[n]</span>, let <span class="math">E_{i}</span> be the union of the following events:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{inst}_i,\\pmb {w}\\text{-}\\mathsf{inst}_i)\\notin \\mathcal{R}</span></li>

      <li><span class="math">(\\mathsf{acc}_i,\\mathbf{w}\\text{-}\\mathsf{acc}_i)\\notin \\mathcal{R}^{\\mathrm{rand}}</span></li>

      <li><span class="math">\\mathcal{H}(\\mathsf{acc}_i)\\neq \\mathsf{inst}_i.\\hbar</span></li>

    </ol>

    <p class="text-gray-300">We first argue that if <span class="math">E_0, \\ldots, E_n</span> don't occur, <span class="math">(x, w) \\in \\mathcal{R}_{F,\\ell}</span>. Denote <span class="math">x = (z_{final}, C, \\mathsf{V})</span> and <span class="math">x = (\\mathsf{acc}, x)</span>. Examining the definition of <span class="math">\\mathcal{R}_{F,\\ell}</span>, the statement <span class="math">(x, w) \\in \\mathcal{R}_{F,\\ell}</span> is equivalent to the following conditions.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\ell(z_{final}, \\mathsf{V}) = \\mathsf{accept}</span>: <span class="math">\\mathbf{V}</span> checks this directly so we know it holds.</li>

      <li><span class="math">\\mathsf{inst}_n.z = z_{final}</span> and <span class="math">n\\leq C</span>: Follows from <span class="math">(x,w)\\in \\mathcal{R}_{\\mathrm{fin}}</span></li>

      <li>For all <span class="math">i\\in [n]</span>, <span class="math">F(z_{i - 1},w_i,z_i) = \\mathsf{accept}</span>: Follows directly from <span class="math">(\\mathsf{inst}_i,\\pmb {w}\\text{-}\\mathsf{inst}_i)\\in \\mathcal{R}</span> for each <span class="math">i\\in [n]</span></li>

      <li><span class="math">z_0.\\mathrm{init} = \\mathrm{true}</span>: For this we first prove by backwards induction on <span class="math">i = n, n - 1, \\ldots, 1</span> that <span class="math">\\mathsf{inst}_i.\\mathrm{count} = i</span>. By our definition of <span class="math">\\mathsf{inst}_n</span> this holds for <span class="math">i = n</span>. For the induction step, assume it holds for <span class="math">i</span>. Since <span class="math">(\\mathsf{inst}_i, \\mathbf{w} - \\mathsf{inst}_i) \\in \\mathcal{R}</span> we have <span class="math">\\mathsf{inst}_{i-1}.\\mathrm{count} = \\mathbf{w} - \\mathsf{inst}_{i-1}.\\mathrm{inst}.\\mathrm{count} = \\mathsf{inst}_i.\\mathrm{count} - 1 = i - 1</span>.</li>

    </ol>

    <p class="text-gray-300">In particular, <span class="math">\\mathsf{inst}_1.\\mathsf{count} = 1</span> which implies when <span class="math">(\\mathsf{inst}_1,\\pmb {w}\\text{-}\\mathsf{inst}_1)\\in \\mathcal{R}</span> that <span class="math">z_0.\\mathrm{init} = \\mathsf{inst}_0.z.\\mathrm{init} = \\mathsf{true}</span>.</p>

    <p class="text-gray-300">It is left to show that the probability of <span class="math">E_0 \\cup E_1 \\cup \\ldots \\cup E_n</span> is <span class="math">\\mathsf{negl}(\\lambda)</span>. From the knowledge soundness of the zk-SNARK for <span class="math">\\mathcal{R}_{\\mathrm{fin}}</span> we have <span class="math">\\operatorname*{Pr}[E_0] = \\mathsf{negl}(\\lambda)</span>. (Recall we are in the event <span class="math">D</span> and assuming its probability is non-negligible.)</p>

    <p class="text-gray-300">For this purpose, we prove by backwards induction on <span class="math">i</span>, for each <span class="math">i \\in [n]</span>, that the probability that <span class="math">E_i</span> occurs given <span class="math">E_0, E_{i+1}, \\ldots, E_n</span> didn't is <span class="math">\\mathsf{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">For <span class="math">i = n</span>, assume <span class="math">E_0</span> didn't occur, hence <span class="math">(x, w) \\in \\mathcal{R}_{\\mathrm{fin}}</span>. In this case <span class="math">(\\mathsf{acc}, \\mathbf{w} - \\mathsf{acc}) \\in \\mathcal{R}^{\\mathrm{rand}}</span>, <span class="math">\\mathcal{H}(\\mathsf{acc}_n) = \\mathsf{inst}_n.\\hbar</span> and <span class="math">\\mathbf{V}_{PG}^{\\ell,\\mathsf{cm}}(\\mathsf{acc}_n, \\mathsf{inst}_n, \\mathsf{acc}, \\pi^<em>) = \\mathsf{accept}</span>. Define <span class="math">\\mathcal{A}_n</span> to be the algorithm that executes <span class="math">\\mathbf{E}</span> and outputs <span class="math">\\mathsf{acc}_n, \\mathsf{inst}_n, \\mathsf{acc}, \\mathbf{w} - \\mathsf{acc}_n, \\mathbf{w} - \\mathsf{inst}_n, \\mathbf{w} - \\mathsf{acc}, \\pi^</em></span>. From the knowledge soundness of PROTOGALAXY applied to <span class="math">\\mathcal{A}_n</span> we have that the probability conditioned on <span class="math">\\neg E_0</span> that <span class="math">E_n</span> occurred is <span class="math">\\mathsf{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">Now assume the induction hypothesis for some <span class="math">i &amp;gt; 1</span>. We have by the hypothesis that the event <span class="math">D_{i} \\coloneqq \\neg (E_{0} \\cup E_{i} \\cup \\ldots \\cup E_{n})</span> has probability <span class="math">1 - \\mathsf{negl}(\\lambda)</span>. Assume that we are in <span class="math">D_{i}</span>. From <span class="math">\\neg E_{i}</span> we have <span class="math">\\mathsf{inst}_{i}.\\hbar = \\mathcal{H}(\\mathsf{acc}_{i})</span>. From <span class="math">(\\mathsf{inst}_{i}, \\mathbf{w} - \\mathsf{inst}_{i}) \\in \\mathcal{R}</span> we have that <span class="math">\\mathsf{inst}_{i}.\\hbar = \\mathcal{H}(\\mathsf{acc}_{i}&#x27;)</span>. Thus <span class="math">\\mathcal{H}(\\mathsf{acc}_{i}) = \\mathcal{H}(\\mathsf{acc}_{i}&#x27;)</span>. From the collision resistance of <span class="math">\\mathcal{H}</span>, we thus have that the probability that <span class="math">\\mathsf{acc}_{i} \\neq \\mathsf{acc}_{i}&#x27;</span> is <span class="math">\\mathsf{negl}(\\lambda)</span>. If <span class="math">\\mathsf{acc}_{i} = \\mathsf{acc}_{i}&#x27;</span> we have from <span class="math">(\\mathsf{inst}_{i}, \\mathbf{w} - \\mathsf{inst}_{i}) \\in \\mathcal{R}</span> that <span class="math">\\mathbf{V}(\\mathsf{acc}_{i-1}, \\mathsf{inst}_{i-1}, \\mathsf{acc}_{i}, \\pi_{i}) = \\mathsf{accept}</span>. Define <span class="math">\\mathcal{A}_{i}</span> to be the algorithm that executes <span class="math">\\mathbf{E}</span> and outputs <span class="math">\\mathsf{acc}_{i-1}, \\mathsf{inst}_{i-1}, \\mathsf{acc}_{i}, \\mathbf{w} - \\mathsf{acc}_{i-1}, \\mathbf{w} - \\mathsf{inst}_{i-1}, \\mathbf{w} - \\mathsf{acc}_{i}, \\pi_{i}</span>. From the knowledge soundness of PROTOGALAXY applied to <span class="math">\\mathcal{A}_{i}</span>, we have that the probability that <span class="math">(\\mathsf{inst}_{i-1}, \\mathbf{w} - \\mathsf{inst}_{i-1}) \\notin \\mathcal{R}</span> or <span class="math">(\\mathsf{acc}_{i-1}, \\mathbf{w} - \\mathsf{acc}_{i-1}) \\notin \\mathcal{R}^{\\mathrm{rand}}</span> given <span class="math">D_{i}</span> is <span class="math">\\mathsf{negl}(\\lambda)</span>. Noting that <span class="math">(\\mathsf{inst}_{i}, \\mathbf{w} - \\mathsf{inst}_{i}) \\in \\mathcal{R}</span> also implies <span class="math">\\mathcal{H}(\\mathsf{acc}_{i-1}) = \\mathsf{inst}_{i-1}.\\hbar</span>, <span class="math">\\operatorname*{Pr}[E_{i-1} \\mid D_{i}] = \\mathsf{negl}(\\lambda)</span>; which is the desired inductive statement.</p>

    <p class="text-gray-300">24</p>

    <p class="text-gray-300">8.5 Constructing proofs for <span class="math">\\mathcal{R}_{\\mathrm{exec}}</span></p>

    <p class="text-gray-300">Going through the reductions of the previous sections, we get the following zk-SNARK for the relation <span class="math">\\mathcal{R}_{\\mathrm{exec}}</span> from Section 3.3 describing valid executions.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{P}_{\\mathrm{exec}}(\\mathbf{x}_{\\mathrm{exec}},\\mathbf{w}_{\\mathrm{exec}}):</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathbf{x}_{\\mathrm{exec}} = (\\mathbf{r},C,\\mathsf{V}),z_{fina\\ell} = (g_{empty},\\mathbf{r},\\mathsf{false})</span> and <span class="math">x = (z_{fina\\ell},C,\\mathsf{V})</span>. Let <span class="math">\\varphi</span> be the map in Lemma 4.1, and compute <span class="math">w = \\varphi (\\mathbf{w}_{\\mathrm{exec}})</span>.</li>

      <li>Let <span class="math">w = (n, (z_0, \\ldots, z_n), (w_1, \\ldots, w_n), (s_1, \\ldots, s_n))</span>.</li>

    </ol>

    <p class="text-gray-300">(a) For each <span class="math">i \\in [n]</span>, define <span class="math">m_i \\in \\mathbb{F}^k</span> such that <span class="math">m_{i,j}</span> is the number of times a record is read when <span class="math">s_{i,j}</span> is an add operation, and 0 otherwise.</p>

    <p class="text-gray-300">(b) Set <span class="math">\\hbar_0 = \\emptyset</span> and compute <span class="math">\\hbar_{i} = \\mathcal{H}(\\hbar_{i - 1},\\mathsf{cm}(s_{i},m_{i}))</span> for <span class="math">i\\in [n]</span>.</p>

    <p class="text-gray-300">(c) Compute <span class="math">(\\alpha, \\beta, \\varepsilon) = (\\mathcal{H}(\\hbar_n, \\mathsf{V}, 1), \\mathcal{H}(\\hbar_n, \\mathsf{V}, 2), \\mathcal{H}(\\hbar_n, \\mathsf{V}, 3))</span>.</p>

    <p class="text-gray-300">(d) Set <span class="math">\\mathfrak{s}_0 = 0</span> and compute <span class="math">\\mathfrak{s}_i</span> for <span class="math">i\\in [n]</span> as in the definition of <span class="math">F^{*}</span> in Section 5.</p>

    <p class="text-gray-300">(e) Let <span class="math">z_{fina\\ell}^{<em>} = (z_{fina\\ell}, \\hbar_{n}, \\mathfrak{s}_{n}, \\alpha, \\beta, \\varepsilon)</span>, for <span class="math">0 \\leq i \\leq n</span>, let <span class="math">z_{i}^{</em>} = (z_{i}, \\hbar_{i}, \\mathfrak{s}_{i}, \\alpha, \\beta, \\varepsilon)</span> and for <span class="math">i \\in [n]</span>, let <span class="math">w_{i}^{*} = (w_{i}, s_{i}, m_{i})</span>.</p>

    <p class="text-gray-300">(f) Set <span class="math">x^{<em>} = (z_{fina\\ell}^{</em>},C,\\mathsf{V})</span> and <span class="math">w^{<em>} = (n,(z_0^</em>,\\ldots ,z_n^<em>),(w_1^</em>,\\ldots ,w_n^*))</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the proof <span class="math">\\pi^{<em>}</span> for <span class="math">(x^{</em>},w^{<em>})\\in \\mathcal{R}_{F^{</em>},\\ell^{*}}</span> according to <span class="math">\\mathbf{P}</span> in Section 8.4.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output <span class="math">\\pi = (\\hbar_{n},\\mathfrak{s}_{n},\\alpha ,\\beta ,\\varepsilon ,\\pi^{*})</span>.</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathbf{V}_{\\mathrm{exec}}(\\mathbf{x}_{\\mathrm{exec}},\\pi)</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse <span class="math">\\mathbf{x}_{\\mathrm{exec}}</span> as <span class="math">(\\mathbf{r}, C, \\mathsf{V})</span> and <span class="math">\\pi</span> as <span class="math">(\\hbar, \\mathfrak{s}, \\alpha, \\beta, \\varepsilon, \\pi^{<em>})</span>. Let <span class="math">z_{fina\\ell} = (g_{empty}, \\mathbf{r}, \\text{false})</span>, <span class="math">z_{fina\\ell}^{</em>} = (z_{fina\\ell}, \\hbar, \\mathfrak{s}, \\alpha, \\beta, \\varepsilon)</span> and <span class="math">x^{<em>} = (z_{fina\\ell}^{</em>}, C, \\mathsf{V})</span>.</li>

      <li>Return <span class="math">\\mathbf{V}(x^{<em>},\\pi^{</em>})</span> according to <span class="math">\\mathbf{V}</span> in Section 8.4.</li>

    </ol>

    <p class="text-gray-300">Theorem 8.3. If <span class="math">(\\mathbf{P},\\mathbf{V})</span> from Section 8.4 is knowledge-sound for <span class="math">\\mathcal{R}_{F^{<em>},\\ell^{</em>}}</span> and the necessary assumptions from Lemma 5.2 hold, <span class="math">(\\mathbf{P}_{\\mathrm{exec}},\\mathbf{V}_{\\mathrm{exec}})</span> is knowledge-sound for <span class="math">\\mathcal{R}_{\\mathrm{exec}}</span>.</p>

    <p class="text-gray-300">Proof. Let <span class="math">\\mathcal{A}</span> be a recursive algebraic adversary that outputs <span class="math">\\mathrm{x_{exec}} = (\\mathbf{r},C,\\mathsf{V})</span> and <span class="math">\\pi = (\\hbar ,\\mathfrak{s},\\alpha ,\\beta ,\\varepsilon ,\\pi^{<em>})</span>. Let <span class="math">z_{fina\\ell} = (g_{empty},\\mathbf{r},\\mathsf{false})</span>, <span class="math">z_{fina\\ell}^{</em>} = (z_{fina\\ell},\\hbar ,\\mathfrak{s},\\alpha ,\\beta ,\\varepsilon)</span>, and <span class="math">x^{<em>} = (z_{fina\\ell}^{</em>},C,\\mathsf{V})</span>. Define <span class="math">\\mathcal{A}^<em></span> as the adversary that runs <span class="math">\\mathcal{A}</span> but outputs <span class="math">(x^{</em>},\\pi^{*})</span>. Define the following extractor <span class="math">\\mathbf{E}_{\\mathrm{exec}}</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Given <span class="math">(\\mathrm{x_{exec}},\\pi)</span>, use <span class="math">\\mathbf{E}</span> from Section 8.4 to extract <span class="math">w^{<em>}</span> from the adversary <span class="math">\\mathcal{A}^</em></span>.</li>

      <li>Compute <span class="math">(x, w) = \\varphi^{<em>}(x^{</em>}, w^{<em>})</span>, where <span class="math">\\varphi^{</em>}</span> is the map from Lemma 5.2.</li>

      <li>Output <span class="math">\\mathbf{w}_{\\mathrm{exec}} = \\varphi^{-1}(w)</span>, where <span class="math">\\varphi</span> is the map from Lemma 4.1.</li>

    </ol>

    <p class="text-gray-300">25</p>

    <p class="text-gray-300">We need to show that</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\mathbf{V}_{\\mathrm{exec}}(\\mathrm{x}_{\\mathrm{exec}},\\pi)=\\mathsf{accept}\\wedge(\\mathrm{x}_{\\mathrm{exec}},\\mathrm{w}_{\\mathrm{exec}})\\notin\\mathcal{R}_{\\mathrm{exec}}]=\\mathsf{negl}(\\lambda).</span></p>

    <p class="text-gray-300">If the first event in the above expression has negligible probability, we are done.</p>

    <p class="text-gray-300">Otherwise, assuming we are in the first event, i.e., <span class="math">\\mathbf{V}_{\\mathrm{exec}}</span> accepts, we show the second event has negligible probability. In particular, this means <span class="math">\\mathbf{V}(x^{<em>},\\pi^{</em>})=\\mathsf{accept}</span>.</p>

    <p class="text-gray-300">From the knowledge soundness of <span class="math">(\\mathbf{P},\\mathbf{V})</span> for <span class="math">\\mathcal{R}_{F^{<em>},\\not{\\ell}^{</em>}}</span>, we get that the witness <span class="math">\\omega^{<em>}</span> output by <span class="math">\\mathbf{E}</span> satisfies <span class="math">(x^{</em>},\\omega^{<em>})\\in\\mathcal{R}_{F^{</em>},\\not{\\ell}^{*}}</span> e.w.p. <span class="math">\\mathsf{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">From Lemma 5.2, we get <span class="math">(x,\\omega)\\in\\mathcal{R}_{F,\\not{\\ell}}</span> e.w.p. <span class="math">\\mathsf{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">From Lemma 4.1, we get <span class="math">(\\mathrm{x}_{\\mathrm{exec}},\\mathrm{w}_{\\mathrm{exec}})\\in\\mathcal{R}_{\\mathrm{exec}}</span> e.w.p. <span class="math">\\mathsf{negl}(\\lambda)</span>, finishing the proof. ∎</p>

    <h2 id="sec-45" class="text-2xl font-bold">9 General Final predicate</h2>

    <p class="text-gray-300">We sketch how to deal with a <em>general</em> final predicate <span class="math">\\not{\\ell}</span>, rather than the one described so far for checking record operations. A more detailed explanation will appear in an updated version of the paper.</p>

    <p class="text-gray-300">The basic idea is that a general final predicate reduces to the concatenation predicate. Namely, suppose we can prove an element <span class="math">s</span> is the commitment to the concatenation of the <span class="math">\\{s_{i}\\}</span> from all <span class="math">n</span> iterations. Then we can modify the final zk-SNARK in Section 8 to also check that <span class="math">\\not{\\ell}(z_{final},s_{1},\\ldots,s_{n},\\mathsf{V})=\\mathsf{accept}</span>.</p>

    <p class="text-gray-300">For this purpose, instead of the function <span class="math">F^{*}</span> in Section 5 we add Protogalaxy constraints to the transition function <span class="math">F</span> to obtain at iteration <span class="math">i</span> a vector <span class="math">S_{i}</span> that is the concatenation of <span class="math">S_{i-1}</span> with <span class="math">s_{i}</span>.</p>

    <h3 id="sec-46" class="text-xl font-semibold mt-8">9.1 Efficient Proofs of Concatenation with Protogalaxy</h3>

    <p class="text-gray-300">Given a sequence consisting of vectors <span class="math">\\{s_{i}\\}_{i\\in[n]}</span> of field elements of length <span class="math">k</span> and a bound <span class="math">C</span> on <span class="math">n</span>, we can define a system of linear protogalaxy constraints that a concatenation was correctly carried out. We highlight that it is important the constraint system does not depend on the current iteration <span class="math">i</span>, or actual sequence length <span class="math">n</span>, only on the bound <span class="math">C</span>. The idea is that if we append the new elements <em>at the beginning</em> of the vector, the concatenation constraints can be written as linear constraints that indeed only depend on <span class="math">k,C</span> but not <span class="math">i</span> or <span class="math">n</span>.</p>

    <p class="text-gray-300">Fix vector <span class="math">b\\in\\mathbb{F}^{k}</span> and vectors <span class="math">a,a^{\\prime}\\in\\mathbb{F}^{kC}</span>. For each <span class="math">j\\in[kC]</span> we define the constraint <span class="math">f_{j}(a,b,a^{\\prime})</span> as follows.</p>

    <p class="text-gray-300">\\[ f_{j}(a,b,a^{\\prime}):=\\begin{cases}a^{\\prime}_{j}-b_{j}&i\\leq k\\\\ a^{\\prime}_{j}-a_{j-k}&j>k\\end{cases}. \\]</p>

    <p class="text-gray-300">In words, the constraints <span class="math">\\{f_{j}\\}</span> enforce that <span class="math">a^{\\prime}</span> consists of the <span class="math">k</span> elements of <span class="math">b</span> followed by the first <span class="math">(C-1)k</span> elements of <span class="math">a</span>. Additionally, we will constrain (using the init variable) that <span class="math">S_{0}</span> is the zero vector of length <span class="math">kC</span>. In the <span class="math">i</span>-th iteration, our transition function <span class="math">F</span> will check for each <span class="math">j\\in[kC]</span> the constraint <span class="math">f_{j}(S_{i},s_{i},S_{i+1})=0</span>.</p>

    <p class="text-gray-300">###</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">One can now show inductively that when starting from the zero vector, under the assumptions that <span class="math">n\\leq C</span> and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq k<span class="math"> for each </span>i\\in[n]<span class="math">, we end up with </span>S_{n}=(s_{1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{n})$ possibly padded with zeroes.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h5 id="sec-47" class="text-base font-semibold mt-4">Prover efficiency</h5>

    <p class="text-gray-300">If the stack is folded in order, then even in the new randomized instance, the zero padding is preserved. That is, higher order elements above <span class="math">ki</span> are still zero after folding. So the prover only needs to perform one field multiplication per stack element to compute the folded witness. These constraints are also linear so they do not contribute to any of the error terms in the <span class="math">G(X)</span> polynomial.</p>

    <p class="text-gray-300">For all <span class="math">j&gt;k(i+1)</span> notice that <span class="math">f_{j}(S_{i},s_{i},S_{i+1})=0</span> identically, so they do not even contribute to the cost of computing the <span class="math">F(X)</span> polynomial. Assuming all of these constraints are organized adjacently in the highest order indices of the overall protogalaxy constraint system, there is a straightforward modification of the <span class="math">F(X)</span> computation which incurs no cost for constraints that are identically zero. In brief, if an entire subtree consists of leaves that are zero, then the prover can avoid any computation for that subtree. Therefore, the total prover computation depends only on the size of the vector <span class="math">S_{i+1}</span>.</p>

    <h2 id="sec-48" class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">The third author was funded by the Vienna Science and Technology Fund (WWTF) [10.47379/VRG18002] and by the Austrian Science Fund (FWF) [10.55776/F8515-N].</p>

    <h2 id="sec-49" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BC23] B. Bünz and B. Chen. Protostar: Generic efficient accumulation/folding for special sound protocols. IACR Cryptol. ePrint Arch., page 620, 2023.</li>

      <li>[BCCT12] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer. Recursive composition and bootstrapping for SNARKs and proof-carrying data. Cryptology ePrint Archive, Paper 2012/095, 2012. https://eprint.iacr.org/2012/095.</li>

      <li>[BCL^{+}21] B. Bünz, A. Chiesa, W. Lin, P. Mishra, and N. Spooner. Proof-carrying data without succinct arguments. In Tal Malkin and Chris Peikert, editors, Advances in Cryptology - CRYPTO 2021 - 41st Annual International Cryptology Conference, CRYPTO 2021, Virtual Event, August 16-20, 2021, Proceedings, Part I, volume 12825 of Lecture Notes in Computer Science, pages 681–710. Springer, 2021.</li>

      <li>[CT10] A. Chiesa and E. Tromer. Proof-carrying data and hearsay arguments from signature cards. In Innovations in Computer Science - ICS 2010, Tsinghua University, Beijing, China, January 5-7, 2010. Proceedings, pages 310–331. Tsinghua University Press, 2010.</li>

      <li>[Eag22] Liam Eagen. Bulletproofs++. IACR Cryptol. ePrint Arch., page 510, 2022.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[EG23] Liam Eagen and Ariel Gabizon. ProtoGalaxy: Efficient ProtoStar-style folding of multiple instances. Cryptology ePrint Archive, Paper 2023/1106, 2023. https://eprint.iacr.org/2023/1106.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[FKL18] G. Fuchsbauer, E. Kiltz, and J. Loss. The algebraic group model and its applications. In Advances in Cryptology - CRYPTO 2018 - 38th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 19-23, 2018, Proceedings, Part II, pages 33–62, 2018.</li>

      <li>[Gro24] J. Groth. Memory checking in folding-based zkvms - jens groth (nexus), 2024. https://www.youtube.com/watch?v=xnzjC_9vUzs.</li>

      <li>[GWC19] A. Gabizon, Z. J. Williamson, and O. Ciobotaru. PLONK: permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge. IACR Cryptology ePrint Archive, 2019:953, 2019.</li>

      <li>[Hab22] U. Haböck. Multivariate lookups based on logarithmic derivatives. IACR Cryptol. ePrint Arch., page 1530, 2022.</li>

      <li>[KST21] A. Kothapalli, S. T. V. Setty, and I. Tzialla. Nova: Recursive zero-knowledge arguments from folding schemes. IACR Cryptol. ePrint Arch., page 370, 2021.</li>

      <li>[KZG10] A. Kate, G. M. Zaverucha, and I. Goldberg. Constant-size commitments to polynomials and their applications. pages 177–194, 2010.</li>

      <li>[LS24] H. Lee and J. H. Seo. On the security of nova recursive proof system. Cryptology ePrint Archive, Paper 2024/232, 2024. https://eprint.iacr.org/2024/232.</li>

      <li>[NDC^{+}24] W. Nguyen, T. Datta, B. Chen, N. Tyagi, and D. Boneh. Mangrove: A scalable framework for folding-based SNARKs. Cryptology ePrint Archive, Paper 2024/416, 2024. https://eprint.iacr.org/2024/416.</li>

      <li>[Sou23] L. Soukhanov. Folding endgame, 2023. https://zkresear.ch/t/folding-endgame/106.</li>

      <li>[Val08] P. Valiant. Incrementally verifiable computation or proofs of knowledge imply time/space efficiency. In Theory of Cryptography, Fifth Theory of Cryptography Conference, TCC 2008, New York, USA, March 19-21, 2008, volume 4948 of Lecture Notes in Computer Science, pages 1–18. Springer, 2008.</li>

      <li>[Wil23] Z. J. Williamson. Goblin plonk: lazy recursive proof composition, 2023. https://hackmd.io/@aztec-network/B19AA8812.</li>

    </ul>`;
---

<BaseLayout title="Stackproofs: Private proofs of stack and contract execution ... (2024/1281)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2024 &middot; eprint 2024/1281
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
