---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2017/1066';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Bulletproofs: Short Proofs for Confidential Transactions and More';
const AUTHORS_HTML = 'Benedikt Bünz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, Greg Maxwell';

const CONTENT = `    <p class="text-gray-300">Bulletproofs: Short Proofs for Confidential Transactions and More</p>

    <p class="text-gray-300">Benedikt Bünz\\*, Jonathan Bootle†, Dan Boneh‡, Andrew Poelstra§, Pieter Wuille¶, and Greg Maxwell‡</p>

    <p class="text-gray-300"><span class="math">^{1}</span>Stanford University <span class="math">^{2}</span>University College London <span class="math">^{3}</span>Blockstream</p>

    <p class="text-gray-300">Full Version\\<em>\\</em></p>

    <p class="text-gray-300">We propose Bulletproofs, a new non-interactive zero-knowledge proof protocol with very short proofs and without a trusted setup; the proof size is only logarithmic in the witness size. Bulletproofs are especially well suited for efficient range proofs on committed values: they enable proving that a committed value is in a range using only <span class="math">2\\log_2(n) + 9</span> group and field elements, where <span class="math">n</span> is the bit length of the range. Proof generation and verification times are linear in <span class="math">n</span>.</p>

    <p class="text-gray-300">Bulletproofs greatly improve on the linear (in <span class="math">n</span>) sized range proofs in existing proposals for confidential transactions in Bitcoin and other cryptocurrencies. Moreover, Bulletproofs supports aggregation of range proofs, so that a party can prove that <span class="math">m</span> commitments lie in a given range by providing only an additive <span class="math">O(\\log(m))</span> group elements over the length of a single proof. To aggregate proofs from multiple parties, we enable the parties to generate a single proof without revealing their inputs to each other via a simple multi-party computation (MPC) protocol for constructing Bulletproofs. This MPC protocol uses either a constant number of rounds and linear communication, or a logarithmic number of rounds and logarithmic communication. We show that verification time, while asymptotically linear, is very efficient in practice. Moreover, the verification of multiple Bulletproofs can be batched for further speed-up. Concretely, the marginal time to verify an aggregation of 16 range proofs is about the same as the time to verify 16 ECDSA signatures.</p>

    <p class="text-gray-300">Bulletproofs build on the techniques of Bootle et al. (EUROCRYPT 2016). Beyond range proofs, Bulletproofs provide short zero-knowledge proofs for general arithmetic circuits while only relying on the discrete logarithm assumption and without requiring a trusted setup. We discuss many applications that would benefit from Bulletproofs, primarily in the area of cryptocurrencies. The efficiency of Bulletproofs is particularly well suited for the distributed and trustless nature of blockchains.</p>

    <p class="text-gray-300">\\<em>benedikt@cs.stanford.edu †jonathan.bootle.14@ucl.ac.uk ‡dabo@cs.stanford.edu §apoelstra@blockstream.io ¶pieter@blockstream.com †greg@xiph.org \\</em>\\*An extended abstract of this work appeared at IEEE S&amp;P 2018 [BBB⁺¹⁸]</p>

    <p class="text-gray-300">1</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Blockchain-based cryptocurrencies enable peer-to-peer electronic transfer of value by maintaining a global distributed but synchronized ledger, the blockchain. Any independent observer can verify both the current state of the blockchain as well as the validity of all transactions on the ledger. In Bitcoin, this innovation requires that all details of a transaction are public: the sender, the receiver, and the amount transferred. In general, we separate privacy for payments into two properties: (1) anonymity, hiding the identities of sender and receiver in a transaction and (2) confidentiality, hiding the amount transferred. While Bitcoin provides some weak anonymity through the unlinkability of Bitcoin addresses to real world identities, it lacks any confidentiality. This is a serious limitation for Bitcoin and could be prohibitive for many use cases. Would employees want to receive their salaries in bitcoin if it meant that their salaries were published on the public blockchain?</p>

    <p class="text-gray-300">To address the confidentiality of transaction amounts, Maxwell <em>[x14]</em> introduced confidential transactions (CT), in which every transaction amount involved is hidden from public view using a commitment to the amount. This approach seems to prevent public validation of the blockchain; an observer can no longer check that the sum of transaction inputs is greater than the sum of transaction outputs, and that all transaction values are positive. This can be addressed by including in every transaction a zero-knowledge proof of validity of the confidential transaction.</p>

    <p class="text-gray-300">Current proposals for CT zero-knowledge proofs <em>[x11]</em> have either been prohibitively large or required a trusted setup. Neither is desirable. While one could use succinct zero-knowledge proofs (SNARKs) <em>[BSCG^{+}13, x10]</em>, they require a trusted setup, which means that everyone needs to trust that the setup was performed correctly. One could avoid trusted setup by using a STARK <em>[x3]</em>, but the resulting range proofs while asymptotically efficient are practically larger than even the currently proposed solutions.</p>

    <p class="text-gray-300">Short non-interactive zero-knowledge proofs without a trusted setup, as described in this paper, have many applications in the realm of cryptocurrencies. In any distributed system where proofs are transmitted over a network or stored for a long time, short proofs reduce overall cost.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">1.1 Our Contributions</h3>

    <p class="text-gray-300">We present Bulletproofs, a new zero-knowledge argument of knowledge system, to prove that a secret committed value lies in a given interval. Bulletproofs do not require a trusted setup. They rely only on the discrete logarithm assumption, and are made non-interactive using the Fiat-Shamir heuristic.</p>

    <p class="text-gray-300">Bulletproofs builds on the techniques of Bootle et al. <em>[BCC^{+}16]</em>, which yield communication-efficient zero-knowledge proofs. We present a replacement for their inner-product argument that reduces overall communication by a factor of 3. We make Bulletproofs suitable for proving statements on committed values. Examples include a range proof, a verifiable shuffle, and other applications discussed below. We note that a range proof using the protocol of <em>[BCC^{+}16]</em> would have required implementing the commitment opening algorithm as part of the verification circuit, which we are able to eliminate.</p>

    <p class="text-gray-300">Distributed Bulletproofs generation. We show that Bulletproofs support a simple and efficient multi-party computation (MPC) protocol that allows multiple parties with secret committed values</p>

    <p class="text-gray-300">to jointly generate a single small range proof for all their values, without revealing their secret values to each other. One version of our MPC protocol is constant-round but with linear communication. Another variant requires only logarithmic communication, but uses a logarithmic number of rounds. When a confidential transaction has inputs from multiple parties (as in the case of CoinJoin), this MPC protocol can be used to aggregate all the proofs needed to construct the transaction into a single short proof.</p>

    <p class="text-gray-300">Proofs for arithmetic circuits. While we focus on confidential transactions (CT), where our work translates to significant practical savings, we stress that the improvements are not limited to CT. We present Bulletproofs for general NP languages. The proof size is logarithmic in the number of multiplication gates in the arithmetic circuit for verifying a witness. The proofs are much shorter than <span class="math">\\left[\\text{BCC}^{+}16\\right]</span> and allow inputs to be Pedersen commitments to elements of the witness.</p>

    <p class="text-gray-300">Optimizations and evaluation. We provide a complete implementation of Bulletproofs that includes many further optimizations described in Section 6. For example, we show how to batch the verification of multiple Bulletproofs so that the cost of verifying every additional proof is significantly reduced. We also provide efficiency comparisons with the range proofs currently used for confidential transactions <span class="math">\\left[\\text{Max16},\\text{Poe}\\right]</span> and with other proof systems. Our implementation includes a general tool for constructing Bulletproofs for any NP language. The tool reads in arithmetic circuits in the Pinocchio <em>[x20]</em> format which lets users use their toolchain. This toolchain includes a compiler from C to the circuit format. We expect this to be of great use to implementers who want to use Bulletproofs.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.2 Applications</h3>

    <p class="text-gray-300">We first discuss several applications for Bulletproofs along with related work specific to these applications. Additional related work is discussed in Section 1.3.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">1.2.1 Confidential Transactions and Mimblewimble</h4>

    <p class="text-gray-300">Bitcoin and other similar cryptocurrencies use a transaction-output-based system where each transaction fully spends the outputs of previously unspent transactions. These unspent transaction outputs are called UTXOs. Bitcoin allows a single UTXO to be spent to many distinct outputs, each associated with a different address. To spend a UTXO a user must provide a signature, or more precisely a scriptSig, that enables the transaction SCRIPT to evaluate to true <span class="math">\\left[\\text{BMC}^{+}15\\right]</span>. Apart from the validity of the scriptSig, miners verify that the transaction spends previously unspent outputs, and that the sum of the inputs is greater than the sum of the outputs.</p>

    <p class="text-gray-300">Maxwell <em>[x17]</em> introduced the notion of a confidential transaction, where the input and output amounts in a transaction are hidden in Pedersen commitments <span class="math">\\left[\\text{P}^{+}91\\right]</span>. To enable public validation, the transaction contains a zero-knowledge proof that the sum of the committed inputs is greater than the sum of the committed outputs, and that all the outputs are positive, namely they lie in the interval <span class="math">\\left[0,2^{n}\\right]</span>, where <span class="math">2^{n}</span> is much smaller than the group size. All current implementations of confidential transactions <span class="math">\\left[\\text{Max16},\\text{MP15},\\text{PBF}^{+},\\text{NM}^{+}16\\right]</span> use range proofs over committed values, where the proof size is linear in <span class="math">n</span>. These range proofs are the main contributor to the size of a confidential transaction. In current implementations <em>[x17]</em>, a confidential transaction with only two outputs and 32 bits of precision is 5.4 KB bytes, of which 5 KB are allocated to the range proof. Even with recent optimizations the range proofs would still take up 3.8 KB.</p>

    <p class="text-gray-300">We show in Section 6 that Bulletproofs greatly improve on this, even for a single range proof while simultaneously doubling the range proof precision at marginal additional cost (64 bytes). The logarithmic proof size additionally enables the prover to aggregate multiple range proofs, e.g. for transactions with multiple outputs, into a single short proof. With Bulletproofs, <span class="math">m</span> range proofs are merely <span class="math">O(\\log(m))</span> additional group elements over a single range proof. This is already useful for confidential transactions in their current form as most Bitcoin transactions have two or more outputs. It also presents an intriguing opportunity to aggregate multiple range proofs from different parties into one proof, as would be needed, for example, in a CoinJoin transaction <em>[x13]</em>. In Section 4.5, we present a simple and efficient MPC protocol that allows multiple users to generate a single transaction with a single aggregate range proof. The users do not have to reveal their secret transaction values to any of the other participants.</p>

    <p class="text-gray-300">Confidential transaction implementations are available in side-chains <em>[x11]</em>, private blockchains <em>[x1]</em>, and in the popular privacy-focused cryptocurrency Monero <em>[NM^{+}16]</em>. All these implementations would benefit from Bulletproofs.</p>

    <p class="text-gray-300">At the time of writing, Bitcoin has roughly 50 million UTXOs from 22 million transactions (see <code>statoshi.info</code>). Using a 52-bit representation of bitcoin that can cover all values from 1 satoshi up to 21 million bitcoins, this results in roughly 160GB of range proof data using the current systems. Using aggregated Bulletproofs, the range proofs for all UTXOs would take less than 17GB, about a factor 10 reduction in size.</p>

    <p class="text-gray-300">Mimblewimble. Recently an improvement was proposed to confidential transactions, called Mimblewimble <em>[x10, x12]</em>, which provides further savings.</p>

    <p class="text-gray-300">Jedusor <em>[x10]</em> realized that a Pedersen commitment to 0 can be viewed as an ECDSA public key, and that for a valid confidential transaction the difference between outputs, inputs, and transaction fees must be 0. A prover constructing a confidential transaction can therefore sign the transaction with the difference of the outputs and inputs as the public key. This small change removes the need for a scriptSig which greatly simplifies the structure of confidential transactions. Poelstra <em>[x12]</em> further refined and improved Mimblewimble and showed that these improvements enable a greatly simplified blockchain in which all spent transactions can be pruned and new nodes can efficiently validate the entire blockchain without downloading any old and spent transactions. Along with further optimizations, this results in a highly compressed blockchain. It consists only of a small subset of the block-headers as well as the remaining unspent transaction outputs and the accompanying range proofs plus an un-prunable 32 bytes per transaction. Mimblewimble also allows transactions to be aggregated before sending them to the blockchain.</p>

    <p class="text-gray-300">A Mimblewimble blockchain grows with the size of the UTXO set. Using Bulletproofs, it would only grow with the number of transactions that have unspent outputs, which is much smaller than the size of the UTXO set. Overall, Bulletproofs can not only act as a drop-in replacement for the range proofs in confidential transactions, but it can also help make Mimblewimble a practical scheme with a blockchain that is significantly smaller than the current Bitcoin blockchain.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">1.2.2 Provisions</h4>

    <p class="text-gray-300">Dagher et al. <em>[DBB^{+}15]</em> introduced the Provisions protocol which allows Bitcoin exchanges to prove that they are solvent without revealing any additional information. The protocol crucially relies on range proofs to prevent an exchange from inserting fake accounts with negative balances. These range proofs, which take up over 13GB, are the main contributors to the proof sizes of almost 18GB</p>

    <p class="text-gray-300">for a large exchange with 2 million customers. The proof size is in fact linear in the number of customers. Since in this protocol, one party (the exchange) has to construct many range proofs at once, the general Bulletproofs protocol from Section 4.3 is a natural replacement for the NIZK proof used in Provisions. With the proof size listed in Section 6, we obtain that the range proofs would take up less than 2 KB with our protocol. Additionally, the other parts of the proof could be similarly compressed using the protocol from Section 5. The proof would then be dominated by one commitment per customer, with size 62 MB. This is roughly 300 times smaller then the current implementation of Provisions.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">1.2.3 Verifiable shuffles</h4>

    <p class="text-gray-300">Consider two lists of committed values <span class="math">x_{1},\\ldots,x_{n}</span> and <span class="math">y_{1},\\ldots,y_{n}</span>. The goal is to prove that the second list is a permutation of the first. This problem is called a <em>verifiable shuffle</em>. It has many applications in voting <em>[x10, x25]</em>, mix-nets <em>[x13]</em>, and solvency proofs <em>[DBB^{+}15]</em>. Neff <em>[x25]</em> gave a practical implementation of a verifiable shuffle and later work improved on it <em>[x16, x20]</em>. Currently the most efficient shuffle <em>[x3]</em> has size <span class="math">O(\\sqrt{n})</span>.</p>

    <p class="text-gray-300">Bulletproofs can be used to create a verifiable shuffle of size <span class="math">O(\\log n)</span>. The two lists of commitments are given as inputs to the circuit protocol from Section 5. The circuit can implement a shuffle by sorting the two lists and then checking that they are equal. A sorting circuit can be implemented using <span class="math">O(n\\cdot\\log(n))</span> multiplications which means that the proof size will be only <span class="math">O(\\log(n))</span>. This is much smaller than previously proposed protocols. Given the concrete efficiency of Bulletproofs, a verifiable shuffle using Bulletproofs would be very efficient in practice. Constructing the proof and verifying it takes linear time in <span class="math">n</span>.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">1.2.4 NIZK Proofs for Smart Contracts</h4>

    <p class="text-gray-300">The Ethereum <em>[x31]</em> system uses highly expressive smart contracts to enable complex transactions. Smart contracts, like any other blockchain transaction, are public and provide no inherent privacy. To bring privacy to smart contracts, non-interactive zero-knowledge (NIZK) proofs have been proposed as a tool to enable complex smart contracts that do not leak the user inputs <em>[KMS^{+}16, x27, x14]</em>. However, these protocols are limited as the NIZK proof itself is not suitable for verification by a smart contract. The reason is that communication over the blockchain with a smart contract is expensive, and the smart contract’s own computational power is highly limited. SNARKs, which have succinct proofs and efficient verifiers, seem like a natural choice, but current practical SNARKs <em>[BSCG^{+}13]</em> require a complex trusted setup. The resulting common reference strings (CRS) are long, specific to each application, and possess trapdoors. In Hawk <em>[KMS^{+}16]</em>, for instance, a different CRS is needed for each smart contract, and either a trusted party is needed to generate it, or an expensive multi-party computation is needed to distribute the trust among a few parties. On the other hand, for small applications like boardroom voting, one can use classical sigma protocols <em>[x27]</em>, but the proof-sizes and expensive verification costs are prohibitive for more complicated applications. Recently, Campanelli et al. <em>[x14]</em> showed how to securely perform zero-knowledge contingent payments (ZKCPs) in Bitcoin, while attacking and fixing a previously proposed protocol <em>[x28]</em>. ZKCPs enable the trustless, atomic and efficient exchange of a cryptocurrency vs. some digital good. While ZKCPs support a wide area of applications they fundamentally work for only a single designated verifier and do not allow for public verification. For some smart contracts that have more than two users, public verification is</p>

    <p class="text-gray-300">often crucial. In an auction, for example, all bidders need to be convinced that all bids are well formed.</p>

    <p class="text-gray-300">Bulletproofs improves on this by enabling small proofs that do not require a trusted setup. The Bulletproofs verifier is not cheap, but there are multiple ways to work around this. First, a smart contract may act optimistically and only verify a proof if some party challenges its validity. Incentives can be used to ensure that rational parties never create an incorrect proof nor challenge a correct proof. This can be further improved by using an interactive referee delegation model <em>[x10]</em>, previously proposed for other blockchain applications <em>[x1, x22]</em>. In this model, the prover provides a proof along with a succinct commitment to the verifier’s execution trace. A challenger that disagrees with the computation also commits to his computation trace and the two parties engage in an interactive binary search to find the first point of divergence in the computation. The smart contract can then execute this single computation step and punish the party which provided a faulty execution trace. The intriguing property of this protocol is that even when a proof is challenged, the smart contract only needs to verify a single computation step, i.e. a single gate of the verification circuit. In combination with small Bulletproofs, this can enable more complex but privacy preserving smart contracts. Like in other applications, these NIZK proofs would benefit from the MPC protocol that we present in Section 4.5 to generate Bulletproofs distributively. Consider an auction smart contract where bidders in the first round submit commitments to bids and in the second round open them. A NIZK can be used to prove properties about the bids, e.g. they are in some range, without revealing them. Using Bulletproofs’ MPC multiple bidders can combine their Bulletproofs into a single proof. Furthermore, the proof will hide which bidder submitted which bid.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">1.2.5 Short Non-Interactive Proofs for Arithmetic Circuits without a Trusted Setup</h4>

    <p class="text-gray-300">Non-interactive zero-knowledge protocols for general statements are not possible without using a common reference string, which should be known by both the prover and the verifier. Many efficient non-interactive zero-knowledge proofs and arguments for arithmetic circuit satisfiability have been developed <em>[x20, x14, x15, x16, x17, x1, x18]</em>, and highly efficient protocols are known. However, aside from their performance, these protocols differ in the complexity of their common reference strings. Some, such as those in <em>[BSCG^{+}13]</em>, are highly structured, and sometimes feature a trapdoor, while some are simply chosen uniformly at random. Security proofs assume that the common reference string was honestly generated. In practice, the common reference string can be generated by a trusted third party, or using a secure multi-party computation protocol. The latter helps to alleviate concerns about embedded trapdoors, as with the trusted setup ceremony used to generate the public parameters for <em>[BSCG^{+}14]</em>.</p>

    <p class="text-gray-300">Zero-knowledge SNARKs have been the subject of extensive research <em>[x12, x3, x14, x15, x16, BSCG^{+}13, x17]</em>. They generate constant-sized proofs for any statement, and have extremely fast verification time. However, they have highly complex common reference strings which require lengthy and computationally intensive protocols <em>[x1]</em> to generate distributively. They also rely on strong unfalsifiable assumptions such as the knowledge-of-exponent assumption.</p>

    <p class="text-gray-300">A uniformly-random common reference string, on the other hand, can be derived from common random strings, like the digits of <span class="math">\\pi</span> or by assuming that hash functions behave like a random oracle. Examples of non-interactive protocols that do not require a trusted setup include <em>[x20, BCC^{+}16, BCG^{+}17b, BSBC^{+}17, x1]</em>.</p>

    <p class="text-gray-300">Ben-Sasson et al. present a proof system <em>[BCG^{+}17a]</em> and implementation <em>[BSBC^{+}17]</em> called</p>

    <p class="text-gray-300">Scalable Computational Integrity (SCI). While SCI has a simple setup, and relies only on collision-resistant hash functions, the system is not zero-knowledge and still experiences worse performance than <em>[BSCG^{+}13, BCC^{+}16]</em>. The proof sizes are roughly 42 MB large in practice for a reasonable circuit. In subsequent work Ben-Sasson et al. presented STARKs <em>[x11]</em>, which are zero-knowledge and more efficient than SCI. However even with these improvements the proof size is still over 200 KB (and grows logarithmically) at only 60-bit security for a circuit of size <span class="math">2^{17}</span>. A Bulletproof for such a circuit at twice the security would be only about 1 KB. Constructing STARKs is also costly in terms of memory requirements because of the large FFT that is required to make proving efficient.</p>

    <p class="text-gray-300">Ames et al. <em>[x1]</em> presented a proof system with linear verification time but only square root proof size building on the MPC in the head technique. Wahby <em>[WTs^{+}]</em> recently present a cryptographic zero-knowledge proof system which achieves square root verifier complexity and proof size based on the proofs for muggles <em>[x24]</em> techniques in combination with a sub-linear polynomial commitment scheme.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">1.3 Additional Related Work</h3>

    <p class="text-gray-300">Much of the research related to electronic payments that predates Bitcoin <em>[x39]</em> focused on efficient anonymous and confidential payments <em>[x10, x12]</em> . With the advent of blockchain-based cryptocurrencies, the question of privacy and confidentiality in transactions has gained a new relevance. While the original Bitcoin paper <em>[x39]</em> claimed that Bitcoin would provide anonymity through pseudonymous addresses early work on Bitcoin showed that the anonymity is limited <em>[MPJ^{+}13, AKR^{+}13]</em>. Given these limitations, various methods have been proposed to help improve the privacy of Bitcoin transactions. CoinJoin <em>[x38]</em>, proposed by Maxwell, allows users to hide information about the amounts of transactions by merging two or more transactions. This ensures that among the participants who join their transactions, it is impossible to tell which transaction inputs correspond to which transaction outputs. However, users do require some way of searching for other users, and furthermore, should be able to do so without relying on a trusted third party. CoinShuffle <em>[x40]</em> tried to fulfill this requirement by taking developing the ideas of CoinJoin and proposing a new Bitcoin mixing protocol which is completely decentralized. Monero <em>[x37]</em> is a cryptocurrency which employs cryptographic techniques to achieve strong privacy guarantees. These include stealth addresses, ring-signatures <em>[x43]</em>, and ring confidential transactions <em>[NM^{+}16]</em>. ZeroCash <em>[BSCG^{+}14]</em> offers optimal privacy guarantees but comes at the cost of expensive transaction generation and the requirement of a trusted setup.</p>

    <p class="text-gray-300">Range proofs. Range proofs are proofs that a secret value, which has been encrypted or committed to, lies in a certain interval. Range proofs do not leak any information about the secret value, other than the fact that they lie in the interval. Lipmaa <em>[x32]</em> presents a range proof which uses integer commitments, and Lagrange’s four-square theorem which states that every positive integer <span class="math">y</span> can be expressed as a sum of four squares. Groth <em>[x29]</em> notes that the argument can be optimized by considering <span class="math">4y+1</span>, since integers of this form only require three squares. The arguments require only a constant number of commitments. However, each commitment is large, as the security of the argument relies on the Strong RSA assumption. Additionally, a trusted setup is required to generate the RSA modulus or a prohibitively large modulus needs to be used <em>[x41]</em>. Camenisch et al. <em>[x13]</em> use a different approach. The verifier provides signatures on a small set of digits. The prover commits to the digits of the secret value, and then proves in zero-knowledge that the</p>

    <p class="text-gray-300">value matches the digits, and that each commitment corresponds to one of the signatures. They show that their scheme can be instantiated securely using both RSA accumulators <em>[x1]</em> and the Boneh-Boyen signature scheme <em>[x2]</em>. However, these range proofs require a trusted setup. Approaches based on the <span class="math">n</span>-ary digits of the secret value are limited to proving that the secret value is in an interval of the form <span class="math">\\left[0,n^{k}-1\\right]</span>. One can produce range proofs for more general intervals by using homomorphic commitments to translate intervals, and by using a combination of two different range proofs to conduct range proofs for intervals of different widths. However, <em>[x10]</em> presented an alternative digital decomposition which enables an interval of general width to be handled using a single range proof.</p>

    <h2 id="sec-10" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">Before we present Bulletproofs, we first review some of the underlying tools. In what follows, a PPT adversary <span class="math">\\mathcal{A}</span> is a probabilistic interactive Turing Machine that runs in polynomial time in the security parameter <span class="math">\\lambda</span>. We will drop the security parameter <span class="math">\\lambda</span> from the notation when it is implicit.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">2.1 Assumptions</h3>

    <h6 id="sec-12" class="text-base font-medium mt-4">Definition 1 (Discrete Log Relation).</h6>

    <p class="text-gray-300">For all PPT adversaries <span class="math">\\mathcal{A}</span> and for all <span class="math">n\\geqslant 2</span> there exists a negligible function <span class="math">\\mu(\\lambda)</span> such that</p>

    <p class="text-gray-300">\\[ P\\left[\\begin{array}[]{l}\\mathbb{G}=\\text{Setup}(1^{\\lambda}),\\ g_{1},\\ldots,g_{n}\\stackrel{{\\scriptstyle\\$}}{{\\leftarrow}}\\mathbb{G};\\\\ a_{1},\\ldots,a_{n}\\in\\mathbb{Z}_{p}\\leftarrow\\mathcal{A}(G,g_{1},\\ldots,g_{n})\\end{array}:\\exists a_{i}\\neq 0\\wedge\\prod_{i=1}^{n}g_{i}^{a_{i}}=1\\right]\\leqslant\\mu(\\lambda) \\]</p>

    <p class="text-gray-300">We say <span class="math">\\prod_{i=1}^{n}g_{i}^{a_{i}}=1</span> is a non trivial discrete log relation between <span class="math">g_{1},\\ldots,g_{n}</span>. The Discrete Log Relation assumption states that an adversary can’t find a non-trivial relation between randomly chosen group elements. For <span class="math">n\\geqslant 1</span> this assumption is equivalent to the discrete-log assumption.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">2.2 Commitments</h3>

    <h6 id="sec-14" class="text-base font-medium mt-4">Definition 2 (Commitment).</h6>

    <p class="text-gray-300">A non-interactive commitment scheme consists of a pair of probabilistic polynomial time algorithms <span class="math">(\\text{Setup},\\text{Com})</span>. The setup algorithm <span class="math">\\text{pp}\\leftarrow\\text{Setup}(1^{\\lambda})</span> generates public parameters <span class="math">\\text{pp}</span> for the scheme, for security parameter <span class="math">\\lambda</span>. The commitment algorithm <span class="math">\\text{Com}_{\\text{pp}}</span> defines a function <span class="math">\\textsf{M}_{\\text{pp}}\\times\\textsf{R}_{\\text{pp}}\\rightarrow\\textsf{C}_{\\text{pp}}</span> for message space <span class="math">\\textsf{M}_{\\text{pp}}</span>, randomness space <span class="math">\\textsf{R}_{\\text{pp}}</span> and commitment space <span class="math">\\textsf{C}_{\\text{pp}}</span> determined by <span class="math">\\text{pp}</span>. For a message <span class="math">x\\in\\textsf{M}_{\\text{pp}}</span>, the algorithm draws <span class="math">r\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\textsf{R}_{\\text{pp}}<span class="math"> uniformly at random, and computes commitment </span>\\mathbf{com}=\\text{Com}_{\\text{pp}}(x;r)$.</p>

    <p class="text-gray-300">For ease of notation we write <span class="math">\\text{Com}=\\text{Com}_{\\text{pp}}</span>.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Definition 3 (Homomorphic Commitments).</h6>

    <p class="text-gray-300">A homomorphic commitment scheme is a non-interactive commitment scheme such that <span class="math">\\textsf{M}_{\\text{pp}},\\textsf{R}_{\\text{pp}}</span> and <span class="math">\\textsf{C}_{\\text{pp}}</span> are all abelian groups, and for all <span class="math">x_{1},x_{2}\\in\\textsf{M}_{\\text{pp}}</span>, <span class="math">r_{1},r_{2}\\in\\textsf{R}_{\\text{pp}}</span>, we have</p>

    <p class="text-gray-300"><span class="math">\\text{Com}(x_{1};r_{1})+\\text{Com}(x_{2};r_{2})=\\text{Com}(x_{1}+x_{2};r_{1}+r_{2})</span></p>

    <p class="text-gray-300">Definition 4 (Hiding Commitment). A commitment scheme is said to be hiding if for all PPT adversaries <span class="math">\\mathcal{A}</span> there exists a negligible function <span class="math">\\mu(\\lambda)</span> such that.</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm {P} \\left[ b = b ^ {\\prime} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathrm {p p} \\leftarrow \\operatorname {S e t u p} (1 ^ {\\lambda}); \\\\ (x _ {0}, x _ {1}) \\in \\mathsf {M} _ {\\mathrm {p p}} ^ {2} \\leftarrow \\mathcal {A} (\\mathrm {p p}), b \\stackrel {\\S} {\\leftarrow} \\{0, 1 \\}, r \\stackrel {\\S} {\\leftarrow} \\mathsf {R} _ {\\mathrm {p p}}, \\\\ \\mathbf {c o m} = \\operatorname {C o m} (x _ {b}; r), b ^ {\\prime} \\leftarrow \\mathcal {A} (\\mathrm {p p}, \\mathbf {c o m}) \\end{array} \\right. \\right] - \\frac {1}{2} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leqslant \\mu (\\lambda)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where the probability is over <span class="math">b, r</span>, Setup and <span class="math">\\mathcal{A}</span>. If <span class="math">\\mu(\\lambda) = 0</span> then we say the scheme is perfectly hiding.</p>

    <p class="text-gray-300">Definition 5 (Binding Commitment). A commitment scheme is said to be binding if for all PPT adversaries <span class="math">\\mathcal{A}</span> there exists a negligible function <span class="math">\\mu</span> such that.</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm {P} \\left[ \\operatorname {C o m} (x _ {0}; r _ {0}) = \\operatorname {C o m} (x _ {1}; r _ {1}) \\wedge x _ {0} \\neq x _ {1} \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathrm {p p} \\leftarrow \\operatorname {S e t u p} (1 ^ {\\lambda}), \\\\ x _ {0}, x _ {1}, r _ {0}, r _ {1} \\leftarrow \\mathcal {A} (\\mathrm {p p}) \\end{array} \\right] \\leqslant \\mu (\\lambda)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where the probability is over Setup and <span class="math">\\mathcal{A}</span>. If <span class="math">\\mu(\\lambda) = 0</span> then we say the scheme is perfectly binding.</p>

    <p class="text-gray-300">In what follows, the order <span class="math">p</span> of the groups used is implicitly dependent on the security parameter <span class="math">\\lambda</span> to ensure that discrete log in these groups is intractable for PPT adversaries.</p>

    <p class="text-gray-300">Definition 6 (Pedersen Commitment). <span class="math">\\mathsf{M}_{\\mathrm{pp}},\\mathsf{R}_{\\mathrm{pp}} = \\mathbb{Z}_p,\\mathsf{C}_{\\mathrm{pp}} = \\mathbb{G}</span> of order <span class="math">p</span></p>

    <p class="text-gray-300">Setup: <span class="math">g,h\\stackrel {\\S}{\\leftarrow}\\mathbb{G}</span></p>

    <p class="text-gray-300"><span class="math">\\operatorname {Com}(x;r) = (g^x h^r)</span></p>

    <p class="text-gray-300">Definition 7 (Pedersen Vector Commitment). <span class="math">\\mathsf{M}_{\\mathrm{pp}} = \\mathbb{Z}_p^n</span>, <span class="math">\\mathsf{R}_{\\mathrm{pp}} = \\mathbb{Z}_p</span>, <span class="math">\\mathsf{C}_{\\mathrm{pp}} = \\mathbb{G}</span> with <span class="math">\\mathbb{G}</span> of order <span class="math">p</span></p>

    <p class="text-gray-300">Setup: <span class="math">\\mathbf{g} = (g_1, \\ldots, g_n), h \\stackrel{\\S}{\\leftarrow} \\mathbb{G}</span></p>

    <p class="text-gray-300"><span class="math">\\operatorname {Com}(\\mathbf{x} = (x_1,\\ldots ,x_n);r) = h^r\\mathbf{g}^{\\mathbf{x}} = h^r\\prod_i g_i^{x_i}\\in \\mathbb{G}</span></p>

    <p class="text-gray-300">The Pedersen vector commitment is perfectly hiding and computationally binding under the discrete logarithm assumption. We will often set <span class="math">r = 0</span>, in which case the commitment is binding but not hiding.</p>

    <h2 id="sec-16" class="text-2xl font-bold">2.3 Zero-Knowledge Arguments of Knowledge</h2>

    <p class="text-gray-300">Bulletproofs are zero-knowledge arguments of knowledge. A zero-knowledge proof of knowledge is a protocol in which a prover can convince a verifier that some statement holds without revealing any information about why it holds. A prover can for example convince a verifier that a confidential transaction is valid without revealing why that is the case, i.e. without leaking the transacted values. An argument is a proof which holds only if the prover is computationally bounded and certain computational hardness assumptions hold. We now give formal definitions.</p>

    <p class="text-gray-300">We will consider arguments consisting of three interactive algorithms (Setup, <span class="math">\\mathcal{P},\\mathcal{V}</span>), all running in probabilistic polynomial time. These are the common reference string generator Setup, the prover <span class="math">\\mathcal{P}</span>, and the verifier <span class="math">\\mathcal{V}</span>. On input <span class="math">1^{\\lambda}</span>, algorithm Setup produces a common reference string <span class="math">\\sigma</span>. The transcript produced by <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> when interacting on inputs <span class="math">s</span> and <span class="math">t</span> is denoted by <span class="math">tr\\gets \\langle \\mathcal{P}(s),\\mathcal{V}(t)\\rangle</span>. We write <span class="math">\\langle \\mathcal{P}(s),\\mathcal{V}(t)\\rangle = b</span> depending on whether the verifier rejects, <span class="math">b = 0</span>, or accepts, <span class="math">b = 1</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{R} \\subset \\{0,1\\}^<em> \\times \\{0,1\\}^</em> \\times \\{0,1\\}^*</span> be a polynomial-time-decidable ternary relation. Given <span class="math">\\sigma</span>, we call <span class="math">w</span> a witness for a statement <span class="math">u</span> if <span class="math">(\\sigma, u, w) \\in \\mathcal{R}</span>, and define the CRS-dependent language</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {L} _ {\\sigma} = \\{x \\mid \\exists w: (\\sigma , x, w) \\in \\mathcal {R} \\}</span></div>

    <p class="text-gray-300">as the set of statements <span class="math">x</span> that have a witness <span class="math">w</span> in the relation <span class="math">\\mathcal{R}</span>.</p>

    <p class="text-gray-300">9</p>

    <p class="text-gray-300">Definition 8 (Argument of Knowledge). The triple <span class="math">(\\mathrm{Setup},\\mathcal{P},\\mathcal{V})</span> is called an argument of knowledge for relation <span class="math">\\mathcal{R}</span> if it satisfies the following two definitions.</p>

    <p class="text-gray-300">Definition 9 (Perfect completeness). (Setup, <span class="math">\\mathcal{P}, \\mathcal{V}</span>) has perfect completeness if for all non-uniform polynomial time adversaries <span class="math">\\mathcal{A}</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{P} \\left[ (\\sigma , u, w) \\notin \\mathcal{R} \\text{ or } \\langle \\mathcal{P} (\\sigma , u, w), \\mathcal{V} (\\sigma , u) \\rangle = 1 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\sigma \\leftarrow \\mathrm{Setup}(1^{\\lambda}) \\\\ (u, w) \\leftarrow \\mathcal{A}(\\sigma) \\end{array} \\right. \\right] = 1</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Definition 10 (Computational Witness-Extended Emulation). (Setup, <span class="math">\\mathcal{P}, \\mathcal{V}</span>) has witness-extended emulation if for all deterministic polynomial time <span class="math">\\mathcal{P}^*</span> there exists an expected polynomial time emulator <span class="math">\\mathcal{E}</span> such that for all pairs of interactive adversaries <span class="math">\\mathcal{A}_1, \\mathcal{A}_2</span> there exists a negligible function <span class="math">\\mu(\\lambda)</span> such that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{P} \\left[ \\mathcal{A}_1(tr) = 1 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\sigma \\leftarrow \\mathrm{Setup}(1^{\\lambda}), (u, s) \\leftarrow \\mathcal{A}_2(\\sigma), \\\\ tr \\leftarrow \\langle \\mathcal{P}^*(\\sigma, u, s), \\mathcal{V}(\\sigma, u) \\rangle \\end{array} \\right. \\right] - \\right. \\right. \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where the oracle is given by <span class="math">\\mathcal{O} = \\langle \\mathcal{P}^*(\\sigma, u, s), \\mathcal{V}(\\sigma, u) \\rangle</span>, and permits rewinding to a specific point and resuming with fresh randomness for the verifier from this point onwards. We can also define computational witness-extended emulation by restricting to non-uniform polynomial time adversaries <span class="math">\\mathcal{A}_1</span> and <span class="math">\\mathcal{A}_2</span>.</p>

    <p class="text-gray-300">We use witness-extended emulation to define knowledge-soundness as used for example in [BCC+16] and defined in [GI08b, Lin03]. Informally, whenever an adversary produces an argument which satisfies the verifier with some probability, then there exists an emulator producing an identically distributed argument with the same probability, but also a witness. The value <span class="math">s</span> can be considered to be the internal state of <span class="math">\\mathcal{P}^<em></span>, including randomness. The emulator is permitted to rewind the interaction between the prover and verifier to any move, and resume with the same internal state for the prover, but with fresh randomness for the verifier. Whenever <span class="math">\\mathcal{P}^</em></span> makes a convincing argument when in state <span class="math">s</span>, <span class="math">\\mathcal{E}</span> can extract a witness, and therefore, we have an argument of knowledge of <span class="math">w</span> such that <span class="math">(\\sigma, u, w) \\in \\mathcal{R}</span>.</p>

    <p class="text-gray-300">Definition 11 (Public Coin). An argument of knowledge <span class="math">(\\mathrm{Setup},\\mathcal{P},\\mathcal{V})</span> is called public coin if all messages sent from the verifier to the prover are chosen uniformly at random and independently of the prover's messages, i.e., the challenges correspond to the verifier's randomness <span class="math">\\rho</span>.</p>

    <p class="text-gray-300">An argument of knowledge is zero knowledge if it does not leak information about <span class="math">w</span> apart from what can be deduced from the fact that <span class="math">(\\sigma, x, w) \\in \\mathcal{R}</span>. We will present arguments of knowledge that have special honest-verifier zero-knowledge. This means that given the verifier's challenge values, it is possible to efficiently simulate the entire argument without knowing the witness.</p>

    <p class="text-gray-300">Definition 12 (Perfect Special Honest-Verifier Zero-Knowledge). A public coin argument of knowledge <span class="math">(\\mathrm{Setup},\\mathcal{P},\\mathcal{V})</span> is a perfect special honest verifier zero knowledge (SHVZK) argument of knowledge for <span class="math">\\mathcal{R}</span> if there exists a probabilistic polynomial time simulator <span class="math">\\mathcal{S}</span> such that for all pairs of</p>

    <p class="text-gray-300">10</p>

    <p class="text-gray-300">interactive adversaries <span class="math">\\mathcal{A}_1, \\mathcal{A}_2</span></p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Pr} \\left[ (\\sigma, u, w) \\in \\mathcal{R} \\text{ and } \\mathcal{A}_1(tr) = 1 \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\sigma \\leftarrow \\operatorname{Setup}(1^\\lambda), (u, w, \\rho) \\leftarrow \\mathcal{A}_2(\\sigma), \\\\ tr \\leftarrow \\langle \\mathcal{P}(\\sigma, u, w), \\mathcal{V}(\\sigma, u; \\rho) \\rangle \\end{array} \\right] \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\operatorname{Pr} \\left[ (\\sigma, u, w) \\in \\mathcal{R} \\text{ and } \\mathcal{A}_1(tr) = 1 \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\sigma \\leftarrow \\operatorname{Setup}(1^\\lambda), (u, w, \\rho) \\leftarrow \\mathcal{A}_2(\\sigma), \\\\ tr \\leftarrow \\mathcal{S}(u, \\rho) \\end{array} \\right] \\end{array} $$</p>

    <p class="text-gray-300">where <span class="math">\\rho</span> is the public coin randomness used by the verifier.</p>

    <p class="text-gray-300">In this definition the adversary chooses a distribution over statements and witnesses but is still not able to distinguish between the simulated and the honestly generated transcripts for valid statements and witnesses.</p>

    <p class="text-gray-300">We now define range proofs, which are proofs that the prover knows an opening to a commitment, such that the committed value is in a certain range. Range proofs can be used to show that an integer commitment is to a positive number or that two homomorphic commitments to elements in a field of prime order will not overflow modulo the prime when they are added together.</p>

    <p class="text-gray-300"><strong>Definition 13 (Zero-Knowledge Range Proof).</strong> Given a commitment scheme <span class="math">(\\mathrm{Setup}, \\mathrm{Com})</span> over a message space <span class="math">\\mathsf{M}_{\\mathrm{pp}}</span> which is a set with a total ordering, a Zero-Knowledge Range Proof is a SHVZK argument of knowledge for the relation <span class="math">\\mathcal{R}_{\\mathrm{Range}}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R}_{\\text{Range}}: (\\mathrm{pp}, (\\mathbf{com}, l, r), (x, \\rho)) \\in \\mathcal{R}_{\\text{Range}} \\leftrightarrow \\mathbf{com} = \\mathrm{Com}(x; \\rho) \\wedge l \\leqslant x &amp;lt; r</span></div>

    <h2 id="sec-17" class="text-2xl font-bold">2.4 Notation</h2>

    <p class="text-gray-300">Let <span class="math">\\mathbb{G}</span> denote a cyclic group of prime order <span class="math">p</span>, and let <span class="math">\\mathbb{Z}_p</span> denote the ring of integers modulo <span class="math">p</span>. Let <span class="math">\\mathbb{G}^n</span> and <span class="math">\\mathbb{Z}_p^n</span> be vector spaces of dimension <span class="math">n</span> over <span class="math">\\mathbb{G}</span> and <span class="math">\\mathbb{Z}_p</span> respectively. Let <span class="math">\\mathbb{Z}_p^\\star</span> denote <span class="math">\\mathbb{Z}_p \\setminus \\{0\\}</span>. Generators of <span class="math">\\mathbb{G}</span> are denoted by <span class="math">g, h, v, u \\in \\mathbb{G}</span>. Group elements which represent commitments are capitalized and blinding factors are denoted by Greek letters, i.e. <span class="math">C = g^a h^\\alpha \\in \\mathbb{G}</span> is a Pedersen commitment to <span class="math">a</span>. If not otherwise clear from context <span class="math">x, y, z \\in \\mathbb{Z}_p^\\star</span> are uniformly distributed challenges. <span class="math">x \\stackrel{\\</span>}{\\leftarrow} \\mathbb{Z}_p^\\star<span class="math"> denotes the uniform sampling of an element from </span>\\mathbb{Z}_p^\\star<span class="math">. Throughout the paper, we will also be using vector notations defined as follows. Bold font denotes vectors, i.e. </span>\\mathbf{a} \\in \\mathbb{F}^n<span class="math"> is a vector with elements </span>a_1, \\ldots, a_n \\in \\mathbb{F}<span class="math">. Capitalized bold font denotes matrices, i.e. </span>\\mathbf{A} \\in \\mathbb{F}^{n \\times m}<span class="math"> is a matrix with </span>n<span class="math"> rows and </span>m<span class="math"> columns such that </span>a_{i,j}<span class="math"> is the element of </span>\\mathbf{A}<span class="math"> in the </span>i<span class="math">th row and </span>j<span class="math">th column. For a scalar </span>c \\in \\mathbb{Z}_p<span class="math"> and a vector </span>\\mathbf{a} \\in \\mathbb{Z}_p^n<span class="math">, we denote by </span>\\mathbf{b} = c \\cdot \\mathbf{a} \\in \\mathbb{Z}_p^n<span class="math"> the vector where </span>b_i = c \\cdot a_i<span class="math">. Furthermore, let </span>\\langle \\mathbf{a}, \\mathbf{b} \\rangle = \\sum_{i=1}^n a_i \\cdot b_i<span class="math"> denotes the inner product between two vectors </span>\\mathbf{a}, \\mathbf{b} \\in \\mathbb{F}^n<span class="math"> and </span>\\mathbf{a} \\circ \\mathbf{b} = (a_1 \\cdot b_1, \\ldots, a_n \\cdot b_n) \\in \\mathbb{F}^n$ the Hadamard product or entry wise multiplication of two vectors.</p>

    <p class="text-gray-300">We also define vector polynomials <span class="math">p(X) = \\sum_{i=0}^{d} \\mathbf{p_i} \\cdot X^i \\in \\mathbb{Z}_p^n[X]</span> where each coefficient <span class="math">\\mathbf{p_i}</span> is a vector in <span class="math">\\mathbb{Z}_p^n</span>. The inner product between two vector polynomials <span class="math">l(X), r(X)</span> is defined as</p>

    <div class="my-4 text-center"><span class="math-block">\\langle l(X), r(X) \\rangle = \\sum_{i=0}^{d} \\sum_{j=0}^{i} \\langle \\mathbf{l_i}, \\mathbf{r_j} \\rangle \\cdot X^{i+j} \\in \\mathbb{Z}_p[X] \\tag{1}</span></div>

    <p class="text-gray-300">Let <span class="math">t(X) = \\langle \\mathbf{l}(X), \\mathbf{r}(X) \\rangle</span>, then the inner product is defined such that <span class="math">t(x) = \\langle l(x), r(x) \\rangle</span> holds for all <span class="math">x \\in \\mathbb{Z}_p</span>, i.e. evaluating the polynomials at <span class="math">x</span> and then taking the inner product is the same as evaluating the inner product polynomial at <span class="math">x</span>.</p>

    <p class="text-gray-300">11</p>

    <p class="text-gray-300">For a vector <span class="math">\\mathbf{g}=(g_{1},\\ldots,g_{n})\\in\\mathbb{G}^{n}</span> and <span class="math">\\mathbf{a}\\in\\mathbb{Z}_{p}^{n}</span> we write <span class="math">C=\\mathbf{g}^{\\mathbf{a}}=\\prod_{i=1}^{n}g_{i}^{a_{i}}\\in\\mathbb{G}</span>. This quantity is a binding (but not hiding) commitment to the vector <span class="math">\\mathbf{a}\\in\\mathbb{Z}_{p}^{n}</span>. Given such a commitment <span class="math">C</span> and a vector <span class="math">\\mathbf{b}\\in\\mathbb{Z}_{p}^{n}</span> with non-zero entries, we can treat <span class="math">C</span> as a new commitment to <span class="math">\\mathbf{a}\\circ\\mathbf{b}</span>. To so do, define <span class="math">g_{i}^{\\prime}=g_{i}^{(b_{i}^{-1})}</span> such that <span class="math">C=\\prod_{i=1}^{n}(g_{i}^{\\prime})^{a_{i}\\cdot b_{i}}</span>. The binding property of this new commitment is inherited from the old commitment.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let $\\mathbf{a}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\mathbf{b}<span class="math"> denote the concatenation of two vectors: if </span>\\mathbf{a}\\in\\mathbb{Z}_{p}^{n}<span class="math"> and </span>\\mathbf{b}\\in\\mathbb{Z}_{p}^{m}<span class="math"> then </span>\\mathbf{a}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\mathbf{b}\\in\\mathbb{Z}_{p}^{n+m}<span class="math">. For </span>0\\leqslant\\ell\\leqslant n$, we use Python notation to denote slices of vectors:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathbf{a}_{[:\\ell]}=(a_{1},\\ldots,a_{\\ell})\\in\\mathbb{F}^{\\ell},\\qquad\\mathbf{a}_{[\\ell:]}=(a_{\\ell+1},\\ldots,a_{n})\\in\\mathbb{F}^{n-\\ell}.</span></p>

    <p class="text-gray-300">For <span class="math">k\\in\\mathbb{Z}_{p}^{\\star}</span> we use <span class="math">\\mathbf{k}^{n}</span> to denote the vector containing the first <span class="math">n</span> powers of <span class="math">k</span>, i.e.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{k}^{n}=(1,k,k^{2},\\ldots,k^{n-1})\\in(\\mathbb{Z}_{p}^{\\star})^{n}.</span></p>

    <p class="text-gray-300">For example, <span class="math">\\mathbf{2}^{n}=(1,2,4,\\ldots,2^{n-1})</span>. Equivalently <span class="math">\\mathbf{k}^{-n}=\\left(\\mathbf{k}^{-\\mathbf{1}}\\right)^{n}=(1,k^{-1},\\ldots,k^{-n+1})</span>.</p>

    <p class="text-gray-300">Finally, we write <span class="math">\\big{\\{}(\\text{Public Input};\\text{Witness}):\\text{Relation}\\big{\\}}</span> to denote the relation Relation using the specified Public Input and Witness.</p>

    <h2 id="sec-18" class="text-2xl font-bold">3 Improved Inner-Product Argument</h2>

    <p class="text-gray-300">Bootle et al. <em>[BCC^{+}16]</em> introduced a communication efficient inner-product argument and show how it can be leveraged to construct zero-knowledge proofs for arithmetic circuit satisfiability with low communication complexity. The argument is an argument of knowledge that the prover knows the openings of two binding Pedersen vector commitments that satisfy a given inner product relation.</p>

    <p class="text-gray-300">We reduce the communication complexity of the argument from <span class="math">6\\log_{2}(n)</span> in <em>[BCC^{+}16]</em> to only <span class="math">2\\log_{2}(n)</span>, where <span class="math">n</span> is the dimension of the two vectors. We achieve this improvement by modifying the relation being proved. Our argument is sound, but is not zero-knowledge. We then show that this protocol gives a public-coin, communication efficient, zero-knowledge range proof on a set of committed values, and a zero-knowledge proof system for arbitrary arithmetic circuits (Sections 4 and 5). By applying the Fiat-Shamir heuristic we obtain short non-interactive proofs (Section 4.4).</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">Overview.</h4>

    <p class="text-gray-300">The inputs to the inner-product argument are independent generators <span class="math">\\mathbf{g},\\mathbf{h}\\in\\mathbb{G}^{n}</span>, a scalar <span class="math">c\\in\\mathbb{Z}_{p}</span>, and <span class="math">P\\in\\mathbb{G}</span>. The argument lets the prover convince a verifier that the prover knows two vectors <span class="math">\\mathbf{a},\\mathbf{b}\\in\\mathbb{Z}_{p}^{n}</span> such that</p>

    <p class="text-gray-300"><span class="math">P=\\mathbf{g}^{\\mathbf{a}}\\mathbf{h}^{\\mathbf{b}}\\qquad\\text{and}\\qquad c=\\langle\\mathbf{a},\\mathbf{b}\\rangle.</span></p>

    <p class="text-gray-300">We refer to <span class="math">P</span> as a binding vector commitment to <span class="math">\\mathbf{a},\\mathbf{b}</span>. Throughout the section we assume that the dimension <span class="math">n</span> is a power of <span class="math">2</span>. If need be, one can easily pad the inputs to ensure that this holds.</p>

    <p class="text-gray-300">More precisely, the inner product argument is an efficient proof system for the following relation:</p>

    <p class="text-gray-300"><span class="math">\\big{\\{}(\\mathbf{g},\\mathbf{h}\\in\\mathbb{G}^{n},\\ P\\in\\mathbb{G},\\ c\\in\\mathbb{Z}_{p}\\ ;\\ \\mathbf{a},\\mathbf{b}\\in\\mathbb{Z}_{p}^{n}):\\ \\ P=\\mathbf{g}^{\\mathbf{a}}\\mathbf{h}^{\\mathbf{b}}\\wedge c=\\langle\\mathbf{a},\\mathbf{b}\\rangle\\big{\\}}.</span> (2)</p>

    <p class="text-gray-300">The simplest proof system for (2) is one where the prover sends the vectors <span class="math">\\mathbf{a},\\mathbf{b}\\in\\mathbb{Z}_{p}^{n}</span> to the verifier. The verifier accepts if these vectors are a valid witness for (2). This is clearly sound, however, it requires sending <span class="math">2n</span> elements to the verifier. Our goal is to send only <span class="math">2\\log_{2}(n)</span> elements.</p>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">We show how to do this when the inner product <span class="math">c = \\langle \\mathbf{a}, \\mathbf{b} \\rangle</span> is given as part of the vector commitment <span class="math">P</span>. That is, for a given <span class="math">P \\in \\mathbb{G}</span>, the prover proves that it has vectors <span class="math">\\mathbf{a}, \\mathbf{b} \\in \\mathbb{Z}_p^n</span> for which <span class="math">P = \\mathbf{g}^{\\mathbf{a}} \\mathbf{h}^{\\mathbf{b}} \\cdot u^{\\langle \\mathbf{a}, \\mathbf{b} \\rangle}</span>. More precisely, we design a proof system for the relation:</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\left( \\mathbf{g}, \\mathbf{h} \\in \\mathbb{G}^n, u, P \\in \\mathbb{G}; \\mathbf{a}, \\mathbf{b} \\in \\mathbb{Z}_p^n \\right) : P = \\mathbf{g}^{\\mathbf{a}} \\mathbf{h}^{\\mathbf{b}} \\cdot u^{\\langle \\mathbf{a}, \\mathbf{b} \\rangle} \\right\\}. \\tag{3}</span></div>

    <p class="text-gray-300">We show in Protocol 1 below that a proof system for (3) gives a proof system for (2) with the same complexity. Hence, it suffices to give a proof system for (3).</p>

    <p class="text-gray-300">To give some intuition for how the proof system for the relation (3) works let us define a hash function <span class="math">H: \\mathbb{Z}_p^{2n+1} \\to \\mathbb{G}</span> as follows. First, set <span class="math">n&#x27; = n/2</span> and fix generators <span class="math">\\mathbf{g}, \\mathbf{h} \\in \\mathbb{G}^n, u \\in \\mathbb{G}</span>. Then the hash function <span class="math">H</span> takes as input <span class="math">\\mathbf{a}, \\mathbf{a}&#x27;, \\mathbf{b}, \\mathbf{b}&#x27; \\in \\mathbb{Z}_p^{n&#x27;}</span> and <span class="math">c \\in \\mathbb{Z}_p</span>, and outputs</p>

    <div class="my-4 text-center"><span class="math-block">H(\\mathbf{a}, \\mathbf{a}&#x27;, \\mathbf{b}, \\mathbf{b}&#x27;, c) = \\mathbf{g}_{[:n&#x27;]}^{\\mathbf{a}} \\cdot \\mathbf{g}_{[n&#x27;:]}^{\\mathbf{a}&#x27;} \\cdot \\mathbf{h}_{[:n&#x27;]}^{\\mathbf{b}} \\cdot \\mathbf{h}_{[n&#x27;:]}^{\\mathbf{b}&#x27;} \\cdot u^c \\quad \\in \\mathbb{G}.</span></div>

    <p class="text-gray-300">Now, using the setup in (3), we can write <span class="math">P</span> as <span class="math">P = H\\left(\\mathbf{a}_{[:n&#x27;]}, \\mathbf{a}_{[n&#x27;:]}, \\mathbf{b}_{[:n&#x27;]}, \\mathbf{b}_{[n&#x27;:]}, \\langle \\mathbf{a}, \\mathbf{b} \\rangle\\right)</span>. Note that <span class="math">H</span> is additively homomorphic in its inputs, i.e.</p>

    <div class="my-4 text-center"><span class="math-block">H(\\mathbf{a}_1, \\mathbf{a}_1&#x27;, \\mathbf{b}_1, \\mathbf{b}_1&#x27;, c_1) \\cdot H(\\mathbf{a}_2, \\mathbf{a}_2&#x27;, \\mathbf{b}_2, \\mathbf{b}_2&#x27;, c_2) = H(\\mathbf{a}_1 + \\mathbf{a}_2, \\mathbf{a}_1&#x27; + \\mathbf{a}_2&#x27;, \\mathbf{b}_1 + \\mathbf{b}_2, \\mathbf{b}_1&#x27; + \\mathbf{b}_2&#x27;, c_1 + c_2).</span></div>

    <p class="text-gray-300">Consider the following protocol for the relation (3), where <span class="math">P \\in \\mathbb{G}</span> is given as input:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover computes <span class="math">L, R \\in \\mathbb{G}</span> as follows:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">L = H \\left( \\begin{array}{cccc} \\mathbf{0}^{n&#x27;}, &amp;amp; \\mathbf{a}_{[:n&#x27;]}, &amp;amp; \\mathbf{b}_{[n&#x27;:]}, &amp;amp; \\mathbf{0}^{n&#x27;}, &amp;amp; \\langle \\mathbf{a}_{[:n&#x27;]}, \\mathbf{b}_{[n&#x27;:]} \\rangle \\\\ R &amp;amp; = H \\left( \\begin{array}{cccc} \\mathbf{a}_{[n&#x27;:]}, &amp;amp; \\mathbf{0}^{n&#x27;}, &amp;amp; \\mathbf{0}^{n&#x27;}, &amp;amp; \\mathbf{b}_{[:n&#x27;]}, &amp;amp; \\langle \\mathbf{a}_{[n&#x27;:]}, \\mathbf{b}_{[:n&#x27;]} \\rangle \\\\ \\end{array} \\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\text{and recall that} \\quad P = H \\left( \\begin{array}{cccc} \\mathbf{a}_{[:n&#x27;]}, &amp;amp; \\mathbf{a}_{[n&#x27;:]}, &amp;amp; \\mathbf{b}_{[:n&#x27;]}, &amp;amp; \\mathbf{b}_{[n&#x27;:]}, \\\\ &amp;amp; &amp;amp; &amp;amp; \\langle \\mathbf{a}, \\mathbf{b} \\rangle \\\\ \\end{array} \\right).</span></div>

    <p class="text-gray-300">It sends <span class="math">L, R \\in \\mathbb{G}</span> to the verifier.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier chooses a random <span class="math">x \\stackrel{\\S}{\\leftarrow} \\mathbb{Z}_p</span> and sends <span class="math">x</span> to the prover.</li>

      <li>The prover computes <span class="math">\\mathbf{a}&#x27; = x \\mathbf{a}_{[:n&#x27;]} + x^{-1} \\mathbf{a}_{[n&#x27;:]} \\in \\mathbb{Z}_p^{n&#x27;} \\quad</span> and <span class="math">\\mathbf{b}&#x27; = x^{-1} \\mathbf{b}_{[:n&#x27;]} + x \\mathbf{b}_{[n&#x27;:]} \\in \\mathbb{Z}_p^{n&#x27;}</span> and sends <span class="math">\\mathbf{a}&#x27;, \\mathbf{b}&#x27; \\in \\mathbb{Z}_p^{n&#x27;}</span> to the verifier.</li>

      <li>Given <span class="math">(L, R, \\mathbf{a}&#x27;, \\mathbf{b}&#x27;)</span>, the verifier computes <span class="math">P&#x27; = L^{(x^2)} \\cdot P \\cdot R^{(x^{-2})}</span> and outputs "accept" if</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">P&#x27; = H\\left( x^{-1} \\mathbf{a}&#x27;, x \\mathbf{a}&#x27;, x \\mathbf{b}&#x27;, x^{-1} \\mathbf{b}&#x27;, \\langle \\mathbf{a}&#x27;, \\mathbf{b}&#x27; \\rangle \\right). \\tag{4}</span></div>

    <p class="text-gray-300">It is easy to verify that a proof from an honest prover will always be accepted. Indeed, the left hand side of (4) is</p>

    <div class="my-4 text-center"><span class="math-block">L^{x^2} \\cdot P \\cdot R^{x^{-2}} = H\\left( \\mathbf{a}_{[:n&#x27;]} + x^{-2} \\mathbf{a}_{[n&#x27;:]}, x^2 \\mathbf{a}_{[:n&#x27;]} + \\mathbf{a}_{[n&#x27;:]}, x^2 \\mathbf{b}_{[n&#x27;:]} + \\mathbf{b}_{[:n&#x27;]}, \\mathbf{b}_{[n&#x27;:]} + x^{-2} \\mathbf{b}_{[:n&#x27;]}, \\langle \\mathbf{a}&#x27;, \\mathbf{b}&#x27; \\rangle \\right)</span></div>

    <p class="text-gray-300">which is the same as the right hand side of (4).</p>

    <p class="text-gray-300">In this proof system, the proof sent from the prover is the four tuple <span class="math">(L, R, \\mathbf{a}&#x27;, \\mathbf{b}&#x27;)</span> and contains only <span class="math">n + 2</span> elements. This is about half the length of the trivial proof where the prover sends the complete <span class="math">\\mathbf{a}, \\mathbf{b} \\in \\mathbb{Z}_p^n</span> to the verifier.</p>

    <p class="text-gray-300">13</p>

    <p class="text-gray-300">To see why this protocol is a proof system for (3) we show how to extract a valid witness <span class="math">\\mathbf{a},\\mathbf{b}\\in\\mathbb{Z}_{p}^{n}</span> from a successful prover. After the prover sends <span class="math">L,R</span> we rewind the prover three times to obtain three tuples <span class="math">(x_{i},\\mathbf{a^{\\prime}}_{i},\\mathbf{b^{\\prime}}_{i})</span> for <span class="math">i=1,\\ldots,3</span>, where each tuple satisfies (4), namely</p>

    <p class="text-gray-300"><span class="math">L^{(x_{i}^{2})}\\cdot P\\cdot R^{(x_{i}^{-2})}=H(x_{i}^{-1}\\mathbf{a^{\\prime}}_{i},\\ x_{i}\\mathbf{a^{\\prime}}_{i},\\ x_{i}\\mathbf{b^{\\prime}}_{i},\\ x_{i}^{-1}\\mathbf{b^{\\prime}}_{i},\\ \\langle\\mathbf{a^{\\prime}}_{i},\\mathbf{b^{\\prime}}_{i}\\rangle).</span> (5)</p>

    <p class="text-gray-300">Assuming <span class="math">x_{i}\\neq\\pm x_{j}</span> for <span class="math">1\\leqslant i&lt;j\\leqslant 3</span>, we can find <span class="math">\\nu_{1},\\nu_{2},\\nu_{3}\\in\\mathbb{Z}_{p}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\sum_{i=1}^{3}x_{i}^{2}\\nu_{i}=0\\quad\\text{and}\\quad\\sum_{i=1}^{3}\\nu_{i}=1\\quad\\text{and}\\quad\\sum_{i=1}^{3}x_{i}^{-2}\\nu_{i}=0.</span></p>

    <p class="text-gray-300">Then setting</p>

    <p class="text-gray-300"><span class="math">\\mathbf{a}=\\sum_{i=1}^{3}(\\nu_{i}\\cdot x_{i}^{-1}\\mathbf{a^{\\prime}}_{i},\\ \\ \\nu_{i}\\cdot x_{i}\\mathbf{a^{\\prime}}_{i})\\in\\mathbb{Z}_{p}^{n}\\quad\\text{and}\\quad\\mathbf{b}=\\sum_{i=1}^{3}(\\nu_{i}\\cdot x_{i}\\mathbf{b^{\\prime}}_{i},\\ \\ \\nu_{i}\\cdot x_{i}^{-1}\\mathbf{b^{\\prime}}_{i})\\in\\mathbb{Z}_{p}^{n}</span></p>

    <p class="text-gray-300">we obtain that <span class="math">P=H\\left(\\mathbf{a}_{[:n^{\\prime}]},\\mathbf{a}_{[n^{\\prime}:]},\\mathbf{b}_{[:n^{\\prime}]},\\mathbf{b}_{[n^{\\prime}:]},c\\right)</span> where <span class="math">c=\\sum_{i=1}^{3}\\nu_{i}\\cdot\\langle\\mathbf{a^{\\prime}}_{i},\\mathbf{b^{\\prime}}_{i}\\rangle</span>. We will show in the proof of Theorem 1 below that with one additional rewinding, to obtain a fourth relation satisfying (5), we must have <span class="math">c=\\langle\\mathbf{a},\\mathbf{b}\\rangle</span> with high probability. Hence, the extracted <span class="math">\\mathbf{a},\\mathbf{b}</span> are a valid witness for the relation (3), as required.</p>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">Shrinking the proof by recursion.</h4>

    <p class="text-gray-300">Observe that the test in (4) is equivalent to testing that</p>

    <p class="text-gray-300"><span class="math">P^{\\prime}=\\left(\\mathbf{g}_{[:n^{\\prime}]}^{x^{-1}}\\circ\\mathbf{g}_{[n^{\\prime}:]}^{x}\\right)^{\\mathbf{a^{\\prime}}}\\cdot\\left(\\mathbf{h}_{[:n^{\\prime}]}^{x}\\circ\\mathbf{h}_{[n^{\\prime}:]}^{x^{-1}}\\right)^{\\mathbf{b^{\\prime}}}\\cdot u^{\\langle\\mathbf{a^{\\prime}},\\mathbf{b^{\\prime}}\\rangle}.</span></p>

    <p class="text-gray-300">Hence, instead of the prover sending the vectors <span class="math">\\mathbf{a^{\\prime}},\\mathbf{b^{\\prime}}</span> to the verifier, they can recursively engage in an inner-product argument for <span class="math">P^{\\prime}</span> with respect to generators <span class="math">(\\mathbf{g}_{[:n^{\\prime}]}^{x^{-1}}\\circ\\mathbf{g}_{[n^{\\prime}:]}^{x},\\ \\mathbf{h}_{[:n^{\\prime}]}^{x}\\circ\\mathbf{h}_{[n^{\\prime}:]}^{x^{-1}},\\ u)</span>. The dimension of this problem is only <span class="math">n^{\\prime}=n/2</span>.</p>

    <p class="text-gray-300">The resulting <span class="math">\\log_{2}n</span> depth recursive protocol is shown in Protocol 2. This <span class="math">\\log_{2}n</span> round protocol is public coin and can be made non-interactive using the Fiat-Shamir heuristic. The total communication of Protocol 2 is only <span class="math">2\\lceil\\log_{2}(n)\\rceil</span> elements in <span class="math">\\mathbb{G}</span> plus <span class="math">2</span> elements in <span class="math">\\mathbb{Z}_{p}</span>. Specifically, the prover sends the following terms:</p>

    <p class="text-gray-300"><span class="math">(L_{1},R_{1}),\\ \\ldots,\\ (L_{\\log_{2}n},R_{\\log_{2}n}),\\ \\ a,b</span></p>

    <p class="text-gray-300">where <span class="math">a,b\\in\\mathbb{Z}_{p}</span> are sent at the tail of the recursion. The prover’s work is dominated by <span class="math">8n</span> group exponentiations and the verifier’s work by <span class="math">4n</span> exponentiations. In Section 3.1 we present a more efficient verifier that performs only <span class="math">1</span> multi-exponentiation of size <span class="math">2n+2\\log(n)</span>. In Section 6 we present further optimizations.</p>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">Proving security.</h4>

    <p class="text-gray-300">The inner product protocol for the relation (2) is presented in Protocol 1. This protocol uses internally a fixed group element <span class="math">u\\in\\mathbb{G}</span> for which there is no known discrete-log relation among <span class="math">\\mathbf{g},\\mathbf{h},u</span>. The heart of Protocol 1 is Protocol 2 which is a proof system for the relation (3). In Protocol 1 the element <span class="math">u</span> is raised to a verifier chosen power <span class="math">x</span> to ensure that the extracted vectors <span class="math">\\mathbf{a},\\mathbf{b}</span> from Protocol 2 satisfy <span class="math">\\langle\\mathbf{a},\\mathbf{b}\\rangle=c</span>.</p>

    <p class="text-gray-300">The following theorem shows that Protocol 1 is a proof system for (2).</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}_{\\mathsf{IP}}</span> ’s input: <span class="math">(\\mathbf{g},\\mathbf{h},P,c,\\mathbf{a},\\mathbf{b})</span> <span class="math">\\mathcal{V}_{\\mathsf{IP}}</span> ’s input: <span class="math">(\\mathbf{g},\\mathbf{h},P,c)</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}_{\\mathsf{IP}}:x\\stackrel{\\S}{\\leftarrow}\\mathbb{Z}_{p}^{\\star}</span> (6) <span class="math">\\mathcal{V}_{\\mathsf{IP}}\\rightarrow\\mathcal{P}_{\\mathsf{IP}}:x</span> (7) <span class="math">P^{\\prime}=P\\cdot u^{x\\cdot c}</span> (8) <span class="math">\\text{Run Protocol 2 on Input }(\\mathbf{g},\\mathbf{h},u^{x},P^{\\prime}~{};~{}\\mathbf{a},\\mathbf{b})</span> (9)</p>

    <p class="text-gray-300">Protocol 1: Proof system for Relation (2) using Protocol 2. Here <span class="math">u\\in\\mathbb{G}</span> is a fixed group element with an unknown discrete-log relative to <span class="math">\\mathbf{g},\\mathbf{h}\\in\\mathbb{G}^{n}</span>.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Theorem 1 (Inner-Product Argument).</h6>

    <p class="text-gray-300">The argument presented in Protocol 1 for the relation (2) has perfect completeness and statistical witness-extended-emulation for either extracting a non-trivial discrete logarithm relation between <span class="math">\\mathbf{g},\\mathbf{h},u</span> or extracting a valid witness <span class="math">\\mathbf{a},\\mathbf{b}</span>.</p>

    <p class="text-gray-300">The proof for Theorem 1 is given in Appendix B.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">3.1 Inner-Product Verification through Multi-Exponentiation</h3>

    <p class="text-gray-300">Protocol 2 has a logarithmic number of rounds and in each round the prover and verifier compute a new set of generators <span class="math">\\mathbf{g}^{\\prime},\\mathbf{h}^{\\prime}</span>. This requires a total of <span class="math">4n</span> exponentiations: <span class="math">2n</span> in the first round, <span class="math">n</span> in the second and <span class="math">\\frac{n}{2^{j-3}}</span> in the <span class="math">j</span>th. We can reduce the number of exponentiations to a single multi-exponentiation of size <span class="math">2n</span> by delaying all the exponentiations until the last round. This technique provides a significant speed-up if the proof is compiled to a non interactive proof using the Fiat-Shamir heuristic (as in Section 4.4).</p>

    <p class="text-gray-300">Let <span class="math">g</span> and <span class="math">h</span> be the generators used in the final round of the protocol and <span class="math">x_{j}</span> be the challenge from the <span class="math">j</span>th round. In the last round the verifier checks that <span class="math">g^{a}h^{b}u^{a\\cdot b}=P</span>, where <span class="math">a,b\\in\\mathbb{Z}_{p}</span> are given by the prover. By unrolling the recursion we can express these final <span class="math">g</span> and <span class="math">h</span> in terms of the input generators <span class="math">\\mathbf{g},\\mathbf{h}\\in\\mathbb{G}^{n}</span> as:</p>

    <p class="text-gray-300"><span class="math">g=\\prod_{i=1}^{n}g_{i}^{s_{i}}\\in\\mathbb{G},\\qquad h=\\prod_{i=1}^{n}h_{i}^{1/s_{i}}\\in\\mathbb{G}</span></p>

    <p class="text-gray-300">where <span class="math">\\mathbf{s}=(s_{1},\\ldots,s_{n})\\in\\mathbb{Z}_{p}^{n}</span> only depends on the challenges <span class="math">(x_{1},\\ldots,x_{\\log_{2}(n)})</span>. The scalars <span class="math">s_{1},\\ldots,s_{n}\\in\\mathbb{Z}_{p}</span> are calculated as follows:</p>

    <p class="text-gray-300">\\[ \\text{for }i=1,\\ldots,n:\\quad s_{i}=\\prod_{j=1}^{\\log_{2}(n)}x_{j}^{b(i,j)}\\qquad\\text{where}\\qquad b(i,j)=\\begin{cases}1&\\text{ the <span class="math">j</span>th bit of <span class="math">i-1</span> is <span class="math">1</span>}\\\\ -1&\\text{otherwise}\\end{cases} \\]</p>

    <p class="text-gray-300">Now the entire verification check in the protocol reduces to the following single multi-exponentiation</p>

    <p class="text-gray-300">input: <span class="math">(\\mathbf{g},\\mathbf{h}\\in \\mathbb{G}^n,u,P\\in \\mathbb{G};\\mathbf{a},\\mathbf{b}\\in \\mathbb{Z}_p^n)</span>  (10)</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}_{\\mathrm{IP}}</span>  's input:  <span class="math">(\\mathbf{g},\\mathbf{h},u,P,\\mathbf{a},\\mathbf{b})</span>  (11)</p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}_{\\mathrm{IP}}</span>  's input:  <span class="math">(\\mathbf{g},\\mathbf{h},u,P)</span>  (12)</p>

    <p class="text-gray-300">output: <span class="math">\\{\\mathcal{V}_{\\mathrm{IP}}</span>  accepts or  <span class="math">\\mathcal{V}_{\\mathrm{IP}}</span>  rejects} (13)</p>

    <p class="text-gray-300">if  <span class="math">n = 1</span>  : (14)</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}_{\\mathrm{IP}}\\to \\mathcal{V}_{\\mathrm{IP}}:a,b\\in \\mathbb{Z}_p</span>  (15)</p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}_{\\mathrm{IP}}</span>  computes  <span class="math">c = a \\cdot b</span>  and checks if  <span class="math">P = g^{a}h^{b}u^{c}</span> : (16)</p>

    <p class="text-gray-300">if yes,  <span class="math">\\mathcal{V}_{\\mathrm{IP}}</span>  accepts; otherwise it rejects (17)</p>

    <p class="text-gray-300">else:  <span class="math">(n &amp;gt; 1)</span>  (18)</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}_{\\mathrm{IP}}</span>  computes: (19)</p>

    <div class="my-4 text-center"><span class="math-block">n ^ {\\prime} = \\frac {n}{2} \\tag {20}</span></div>

    <div class="my-4 text-center"><span class="math-block">c _ {L} = \\left\\langle \\mathbf {a} _ {[ : n ^ {\\prime} ]}, \\mathbf {b} _ {[ n ^ {\\prime}: ]} \\right\\rangle \\in \\mathbb {Z} _ {p} \\tag {21}</span></div>

    <div class="my-4 text-center"><span class="math-block">c _ {R} = \\left\\langle \\mathbf {a} _ {[ n ^ {\\prime}: ]}, \\mathbf {b} _ {[ : n ^ {\\prime} ]} \\right\\rangle \\in \\mathbb {Z} _ {p} \\tag {22}</span></div>

    <div class="my-4 text-center"><span class="math-block">L = \\mathbf {g} _ {[ n ^ {\\prime}: ]} ^ {\\mathbf {a} _ {[ : n ^ {\\prime} ]}} \\mathbf {h} _ {[ : n ^ {\\prime} ]} ^ {\\mathbf {b} _ {[ : n ^ {\\prime} ]}} u ^ {c _ {L}} \\in \\mathbb {G} \\tag {23}</span></div>

    <div class="my-4 text-center"><span class="math-block">R = \\mathbf {g} _ {[ : n ^ {\\prime} ]} ^ {\\mathbf {a} _ {[ n ^ {\\prime} : ]}} \\mathbf {h} _ {[ n ^ {\\prime} : ]} ^ {\\mathbf {b} _ {[ : n ^ {\\prime} ]}} u ^ {c _ {R}} \\in \\mathbb {G} \\tag {24}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {P} _ {\\mathrm {I P}} \\rightarrow \\mathcal {V} _ {\\mathrm {I P}}: L, R \\tag {25}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {V} _ {\\mathrm {I P}}: x \\stackrel {\\$} {\\leftarrow} \\mathbb {Z} _ {p} ^ {\\star} \\tag {26}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {V} _ {\\mathrm {I P}} \\rightarrow \\mathcal {P} _ {\\mathrm {I P}}: x \\tag {27}</span></div>

    <p class="text-gray-300"><span class="math">\\mathcal{P}_{\\mathrm{IP}}</span>  and  <span class="math">\\mathcal{V}_{\\mathrm{IP}}</span>  compute: (28)</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {g} ^ {\\prime} = \\mathbf {g} _ {[ : n ^ {\\prime} ]} ^ {x ^ {- 1}} \\circ \\mathbf {g} _ {[ n ^ {\\prime}: ]} ^ {x} \\in \\mathbb {G} ^ {n ^ {\\prime}} \\tag {29}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {h} ^ {\\prime} = \\mathbf {h} _ {[ : n ^ {\\prime} ]} ^ {x} \\circ \\mathbf {h} _ {[ n ^ {\\prime}: ]} ^ {x ^ {- 1}} \\in \\mathbb {G} ^ {n ^ {\\prime}} \\tag {30}</span></div>

    <div class="my-4 text-center"><span class="math-block">P ^ {\\prime} = L ^ {x ^ {2}} P R ^ {x ^ {- 2}} \\in \\mathbb {G} \\tag {31}</span></div>

    <p class="text-gray-300"><span class="math">\\mathcal{P}_{\\mathrm{IP}}</span>  computes: (32)</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {a} ^ {\\prime} = \\mathbf {a} _ {[ : n ^ {\\prime} ]} \\cdot x + \\mathbf {a} _ {[ n ^ {\\prime}: ]} \\cdot x ^ {- 1} \\in \\mathbb {Z} _ {p} ^ {n ^ {\\prime}} \\tag {33}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {b} ^ {\\prime} = \\mathbf {b} _ {[ : n ^ {\\prime} ]} \\cdot x ^ {- 1} + \\mathbf {b} _ {[ n ^ {\\prime}: ]} \\cdot x \\in \\mathbb {Z} _ {p} ^ {n ^ {\\prime}} \\tag {34}</span></div>

    <p class="text-gray-300">recursively run Protocol 2 on input  <span class="math">(\\mathbf{g}&#x27;,\\mathbf{h}&#x27;,u,P&#x27;;\\mathbf{a}&#x27;,\\mathbf{b}&#x27;)</span>  (35)</p>

    <p class="text-gray-300">Protocol 2: Improved Inner-Product Argument</p>

    <p class="text-gray-300">of size <span class="math">2n+2\\log_{2}(n)+1</span>:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{g}^{a\\cdot\\mathbf{s}}\\cdot\\mathbf{h}^{b\\cdot\\mathbf{s}^{-1}}\\cdot u^{a\\cdot b}\\stackrel{{\\scriptstyle?}}{{=}}P\\cdot\\prod_{j=1}^{\\log_{2}(n)}L_{j}^{(x_{j}^{2})}\\cdot R_{j}^{(x_{j}^{-2})}.</span></p>

    <p class="text-gray-300">Because a multi-exponentiation can be done much faster than <span class="math">n</span> separate exponentiations, as we discuss in Section 6, this leads to a significant savings.</p>

    <h2 id="sec-24" class="text-2xl font-bold">4 Range Proof Protocol with Logarithmic Size</h2>

    <p class="text-gray-300">We now present a novel protocol for conducting short and aggregatable range proofs. The protocol uses the improved inner product argument from Protocol 1. First, in Section 4.1, we describe how to construct a range proof that requires the verifier to check an inner product between two vectors. Then, in Section 4.2, we show that this check can be replaced with an efficient inner-product argument. In Section 4.3, we show how to efficiently aggregate <span class="math">m</span> range proofs into one short proof. In Section 4.4, we discuss how interactive public coin protocols can be made non-interactive by using the Fiat-Shamir heuristic, in the random oracle model. In Section 4.5 we present an efficient MPC protocol that allows multiple parties to construct a single aggregate range proof. Finally, in Section 4.6, we discuss an extension that enables a switch to quantum-secure range proofs in the future.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">4.1 Inner-Product Range Proof</h3>

    <p class="text-gray-300">We present a protocol which uses the improved inner-product argument to construct a range proof. The proof convinces the verifier that a commitment <span class="math">V</span> contains a number <span class="math">v</span> that is in a certain range, without revealing <span class="math">v</span>. Bootle et al. <em>[BCC^{+}16]</em> give a proof system for arbitrary arithmetic circuits, and in Section 5 we show that our improvements to the inner product argument also transfer to this general proof system. It is of course possible to prove that a commitment is in a given range using an arithmetic circuit, and the work of <em>[BCC^{+}16]</em> could be used to construct an asymptotically logarithmic sized range proof (in the length of <span class="math">v</span>). However, the circuit would need to implement the commitment function, namely a multi-exponentiation for Pedersen commitments, leading to a large complex circuit.</p>

    <p class="text-gray-300">We construct a range proof more directly by exploiting the fact that a Pedersen commitment <span class="math">V</span> is an element in the same group <span class="math">\\mathbb{G}</span> that is used to perform the inner product argument. We extend this idea in Section 5 to construct a proof system for circuits that operate on committed inputs.</p>

    <p class="text-gray-300">Formally, let <span class="math">v\\in\\mathbb{Z}_{p}</span> and let <span class="math">V\\in\\mathbb{G}</span> be a Pedersen commitment to <span class="math">v</span> using randomness <span class="math">\\gamma</span>. The proof system will convince the verifier that <span class="math">v\\in[0,2^{n}-1]</span>. In other words, the proof system proves the following relation which is equivalent to the range proof relation in Definition 13:</p>

    <p class="text-gray-300"><span class="math">\\big{\\{}(g,h\\in\\mathbb{G},V,n\\ ;\\ v,\\gamma\\in\\mathbb{Z}_{p}):V=h^{\\gamma}g^{v}\\wedge v\\in[0,2^{n}-1]\\big{\\}}.</span> (36)</p>

    <p class="text-gray-300">Let <span class="math">\\mathbf{a}_{L}=(a_{1},\\ldots,a_{n})\\in\\{0,1\\}^{n}</span> be the vector containing the bits of <span class="math">v</span>, so that <span class="math">\\langle\\mathbf{a}_{L},\\mathbf{2}^{n}\\rangle=v</span>. The prover <span class="math">\\mathcal{P}</span> commits to <span class="math">\\mathbf{a}_{L}</span> using a constant size vector commitment <span class="math">A\\in\\mathbb{G}</span>. It will convince the verifier that <span class="math">v</span> is in <span class="math">[0,2^{n}-1]</span> by proving that it knows an opening <span class="math">\\mathbf{a}_{L}\\in\\mathbb{Z}_{p}^{n}</span> of <span class="math">A</span> and <span class="math">v,\\gamma\\in\\mathbb{Z}_{p}</span> such that <span class="math">V=h^{\\gamma}g^{v}</span> and</p>

    <p class="text-gray-300"><span class="math">\\langle\\mathbf{a}_{L},\\mathbf{2}^{n}\\rangle=v\\quad\\text{and}\\quad\\mathbf{a}_{L}\\circ\\mathbf{a}_{R}=\\mathbf{0}^{n}\\quad\\text{and}\\quad\\mathbf{a}_{R}=\\mathbf{a}_{L}-\\mathbf{1}^{n}</span> (37)</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300">is proves that <span class="math">a_{1},\\ldots,a_{n}</span> are all in <span class="math">\\{0,1\\}</span>, as required and that <span class="math">\\mathbf{a}_{L}</span> is composed of the bits of <span class="math">v</span>. The high level goal of the following protocol is to convert these <span class="math">2n+1</span> constraints as a single inner-product constraint. This will allow us to use Protocol 1 to efficiently argue that an inner-product relation holds. To do this we take a random linear combination (chosen by the verifier) of the constraints. If the original constraints were not satisfied then it is inversely proportional in the challenge space unlikely that the combined constraint holds.</p>

    <p class="text-gray-300">Concretley, we use the following observation: to prove that a committed vector <span class="math">\\mathbf{b}\\in\\mathbb{Z}_{p}^{n}</span> satisfies <span class="math">\\mathbf{b}=\\mathbf{0}^{n}</span> it suffices for the verifier to send a random <span class="math">y\\in\\mathbb{Z}_{p}</span> to the prover and for the prover to prove that <span class="math">\\langle\\mathbf{b},\\mathbf{y}^{n}\\rangle=0</span>. If <span class="math">\\mathbf{b}\\neq\\mathbf{0}^{n}</span> then the equality will hold with at most negligible probability <span class="math">n/p</span>. Hence, if <span class="math">\\langle\\mathbf{b},\\mathbf{y}^{n}\\rangle=0</span> the verifier is convinced that <span class="math">\\mathbf{b}=\\mathbf{0}^{n}</span>.</p>

    <p class="text-gray-300">Using this observation, and using a random <span class="math">y\\in\\mathbb{Z}_{p}</span> from the verifier, the prover can prove that (37) holds by proving that</p>

    <p class="text-gray-300"><span class="math">\\langle\\mathbf{a}_{L},\\mathbf{2}^{n}\\rangle=v\\quad\\text{and}\\quad\\langle\\mathbf{a}_{L}\\ ,\\ \\mathbf{a}_{R}\\circ\\mathbf{y}^{n}\\rangle=0\\quad\\text{and}\\quad\\langle\\mathbf{a}_{L}-\\mathbf{1}^{n}-\\mathbf{a}_{R}\\ ,\\ \\mathbf{y}^{n}\\rangle=0.</span> (38)</p>

    <p class="text-gray-300">We can combine these three equalities into one using the same technique: the verifier chooses a random <span class="math">z\\in\\mathbb{Z}_{p}</span> and then the prover proves that</p>

    <p class="text-gray-300"><span class="math">z^{2}\\cdot\\langle\\mathbf{a}_{L},\\mathbf{2}^{n}\\rangle+z\\cdot\\langle\\mathbf{a}_{L}-\\mathbf{1}^{n}-\\mathbf{a}_{R}\\ ,\\ \\mathbf{y}^{n}\\rangle+\\langle\\mathbf{a}_{L}\\ ,\\ \\mathbf{a}_{R}\\circ\\mathbf{y}^{n}\\rangle=z^{2}\\cdot v.</span></p>

    <p class="text-gray-300">This equality can be re-written as:</p>

    <p class="text-gray-300"><span class="math">\\left\\langle\\mathbf{a}_{L}-z\\cdot\\mathbf{1}^{n}\\ ,\\ \\mathbf{y}^{n}\\circ(\\mathbf{a}_{R}+z\\cdot\\mathbf{1}^{n})+z^{2}\\cdot\\mathbf{2}^{n}\\right\\rangle=z^{2}\\cdot v+\\delta(y,z)</span> (39)</p>

    <p class="text-gray-300">where <span class="math">\\delta(y,z)=(z-z^{2})\\cdot\\langle\\mathbf{1}^{n},\\mathbf{y}^{n}\\rangle-z^{3}\\langle\\mathbf{1}^{n},\\mathbf{2}^{n}\\rangle\\in\\mathbb{Z}_{p}</span> is a quantity that the verifier can easily calculate. We thus reduced the problem of proving that (37) holds to proving a single inner-product identity.</p>

    <p class="text-gray-300">If the prover could send to the verifier the two vectors in the inner product in (39) then the verifier could check (39) itself, using the commitment <span class="math">V</span> to <span class="math">v</span>, and be convinced that (37) holds. However, these two vectors reveal information about <span class="math">\\mathbf{a}_{L}</span> and therefore the prover cannot send them to the verifier. We solve this problem by introducing two additional blinding terms <span class="math">\\mathbf{s}_{L},\\mathbf{s}_{R}\\in\\mathbb{Z}_{p}^{n}</span> to blind these vectors.</p>

    <p class="text-gray-300">Specifically, to prove the statement (36), <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> engage in the following zero knowledge protocol:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}_{\\mathrm{IP}}</span> on input <span class="math">v,\\gamma</span> computes: (40)</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{a}_L \\in \\{0, 1\\}^n \\text{ s.t. } \\langle \\mathbf{a}_L, \\mathbf{2}^n \\rangle = v \\tag{41}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{a}_R = \\mathbf{a}_L - \\mathbf{1}^n \\in \\mathbb{Z}_p^n \\tag{42}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\alpha \\stackrel{\\$}{\\leftarrow} \\mathbb{Z}_p \\tag{43}</span></div>

    <div class="my-4 text-center"><span class="math-block">A = h^\\alpha \\mathbf{g}^{\\mathbf{a}_L} \\mathbf{h}^{\\mathbf{a}_R} \\in \\mathbb{G} \\quad // \\quad \\text{commitment to } \\mathbf{a}_L \\text{ and } \\mathbf{a}_R \\tag{44}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{s}_L, \\mathbf{s}_R \\stackrel{\\$}{\\leftarrow} \\mathbb{Z}_p^n \\quad // \\quad \\text{choose blinding vectors } \\mathbf{s}_L, \\mathbf{s}_R \\tag{45}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\rho \\stackrel{\\$}{\\leftarrow} \\mathbb{Z}_p \\tag{46}</span></div>

    <div class="my-4 text-center"><span class="math-block">S = h^\\rho \\mathbf{g}^{\\mathbf{s}_L} \\mathbf{h}^{\\mathbf{s}_R} \\in \\mathbb{G} \\quad // \\quad \\text{commitment to } \\mathbf{s}_L \\text{ and } \\mathbf{s}_R \\tag{47}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{P} \\rightarrow \\mathcal{V}: A, S \\tag{48}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{V}: y, z \\stackrel{\\$}{\\leftarrow} \\mathbb{Z}_p^{\\star} \\quad // \\quad \\text{challenge points} \\tag{49}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{V} \\rightarrow \\mathcal{P}: y, z \\tag{50}</span></div>

    <p class="text-gray-300">With this setup, let us define two linear vector polynomials <span class="math">l(X), r(X)</span> in <span class="math">\\mathbb{Z}_p^n[X]</span>, and a quadratic polynomial <span class="math">t(X) \\in \\mathbb{Z}_p[X]</span> as follows:</p>

    <div class="my-4 text-center"><span class="math-block">l(X) = (\\mathbf{a}_L - z \\cdot \\mathbf{1}^n) + \\mathbf{s}_L \\cdot X \\quad \\in \\mathbb{Z}_p^n[X]</span></div>

    <div class="my-4 text-center"><span class="math-block">r(X) = \\mathbf{y}^n \\circ (\\mathbf{a}_R + z \\cdot \\mathbf{1}^n + \\mathbf{s}_R \\cdot X) + z^2 \\cdot \\mathbf{2}^n \\quad \\in \\mathbb{Z}_p^n[X]</span></div>

    <div class="my-4 text-center"><span class="math-block">t(X) = \\langle l(X), r(X) \\rangle = t_0 + t_1 \\cdot X + t_2 \\cdot X^2 \\quad \\in \\mathbb{Z}_p[X]</span></div>

    <p class="text-gray-300">where the inner product in the definition of <span class="math">t(X)</span> is as in (1). The constant terms of <span class="math">l(X)</span> and <span class="math">r(X)</span> are the inner product vectors in (39). The blinding vectors <span class="math">\\mathbf{s}_L</span> and <span class="math">\\mathbf{s}_R</span> ensure that the prover can publish <span class="math">l(x)</span> and <span class="math">r(x)</span> for one <span class="math">x \\in \\mathbb{Z}_p^\\star</span> without revealing any information about <span class="math">\\mathbf{a}_L</span> and <span class="math">\\mathbf{a}_R</span>.</p>

    <p class="text-gray-300">The constant term of <span class="math">t(x)</span>, denoted <span class="math">t_0</span>, is the result of the inner product in (39). The prover needs to convince the verifier that this <span class="math">t_0</span> satisfies (39), namely</p>

    <div class="my-4 text-center"><span class="math-block">t_0 = v \\cdot z^2 + \\delta(y, z).</span></div>

    <p class="text-gray-300">To so do, the prover commits to the remaining coefficients of <span class="math">t(X)</span>, namely <span class="math">t_1, t_2 \\in \\mathbb{Z}_p</span>. It then convinces the verifier that it has a commitment to the coefficients of <span class="math">t(X)</span> by checking the value of <span class="math">t(X)</span> at a random point <span class="math">x \\in \\mathbb{Z}_p^\\star</span>. Specifically, they do:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}_{\\mathrm{IP}}</span>  computes: (51)</p>

    <p class="text-gray-300"><span class="math">\\tau_{1},\\tau_{2}\\stackrel {\\S}{\\leftarrow}\\mathbb{Z}_{p}</span>  (52) <span class="math">T_{i} = g^{t_{i}}h^{\\tau_{i}}\\in \\mathbb{G},\\quad i = \\{1,2\\}</span>  // commit to  <span class="math">t_1,t_2</span>  (53)</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}\\to \\mathcal{V}:T_1,T_2</span>  (54)</p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}:x\\stackrel {\\S}{\\leftarrow}\\mathbb{Z}_p^\\star</span>  (55) <span class="math">\\mathcal{V}\\to \\mathcal{P}:x</span>  // a random challenge (56)</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}_{\\mathrm{IP}}</span>  computes: (57)</p>

    <p class="text-gray-300"><span class="math">\\mathbf{l} = l(x) = \\mathbf{a}_L - z\\cdot \\mathbf{1}^n +\\mathbf{s}_L\\cdot x\\in \\mathbb{Z}_p^n</span>  (58) <span class="math">\\mathbf{r} = r(x) = \\mathbf{y}^n\\circ (\\mathbf{a}_R + z\\cdot \\mathbf{1}^n +\\mathbf{s}_R\\cdot x) + z^2\\cdot \\mathbf{2}^n\\in \\mathbb{Z}_p^n</span>  (59) <span class="math">\\hat{t} = \\langle \\mathbf{l},\\mathbf{r}\\rangle \\in \\mathbb{Z}_p</span>  //  <span class="math">\\hat{t} = t(x)</span>  (60) <span class="math">\\tau_{x} = \\tau_{2}\\cdot x^{2} + \\tau_{1}\\cdot x + z^{2}\\cdot \\gamma \\in \\mathbb{Z}_{p}</span>  // blinding value for  <span class="math">\\hat{t}</span>  (61) <span class="math">\\mu = \\alpha +\\rho \\cdot x\\in \\mathbb{Z}_p</span>  //  <span class="math">\\alpha ,\\rho</span>  blind  <span class="math">A,S</span>  (62)</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}\\to \\mathcal{V}:\\tau_x,\\mu ,\\hat{t},\\mathbf{l},\\mathbf{r}</span>  (63)</p>

    <p class="text-gray-300">The verifier checks that  <span class="math">\\mathbf{l}</span>  and  <span class="math">\\mathbf{r}</span>  are in fact  <span class="math">l(x)</span>  and  <span class="math">r(x)</span>  and checks that  <span class="math">t(x) = \\langle \\mathbf{l},\\mathbf{r}\\rangle</span> . In order to construct a commitment to  <span class="math">\\mathbf{a}_R\\circ \\mathbf{y}^n</span>  the verifier switches the generators of the commitment from  <span class="math">\\mathbf{h}\\in \\mathbb{G}^n</span>  to  <span class="math">\\mathbf{h}&#x27; = \\mathbf{h}^{(\\mathbf{y}^{-n})}</span> . This has the effect that  <span class="math">A</span>  is now a vector commitment to  <span class="math">(\\mathbf{a}_L,\\mathbf{a}_R\\circ \\mathbf{y}^n)</span>  with respect to the new generators  <span class="math">(\\mathbf{g},\\mathbf{h}&#x27;,h)</span> . Similarly  <span class="math">S</span>  is now a vector commitment to  <span class="math">(\\mathbf{s}_L,\\mathbf{s}_R\\circ \\mathbf{y}^n)</span> . The remaining steps of the protocol are:</p>

    <p class="text-gray-300"><span class="math">h_i^\\prime = h_i^{(y^{-i + 1})}\\in \\mathbb{G},\\quad \\forall i\\in [1,n]</span>  //  <span class="math">\\mathbf{h}^{\\prime} = \\left(h_{1},h_{2}^{(y^{-1})},h_{3}^{(y^{-2})},\\ldots ,h_{n}^{(y^{-n + 1})}\\right)</span>  (64) <span class="math">g^{\\hat{t}}h^{\\tau_x}\\stackrel {?}{=}V^{z^2}\\cdot g^{\\delta (y,z)}\\cdot T_1^x\\cdot T_2^{x^2}</span>  // check that  <span class="math">\\hat{t} = t(x) = t_0 + t_1x + t_2x^2</span>  (65) <span class="math">P = A\\cdot S^x\\cdot \\mathbf{g}^{-z}\\cdot (\\mathbf{h}&#x27;)^{z\\cdot \\mathbf{y}^n +z^2\\cdot \\mathbf{2}^n}\\in \\mathbb{G}</span>  // compute a commitment to  <span class="math">l(x),r(x)</span>  (66) <span class="math">P\\stackrel {?}{=}h^{\\mu}\\cdot \\mathbf{g}^{\\mathbf{l}}\\cdot (\\mathbf{h}^{\\prime})^{\\mathbf{r}}</span>  // check that  <span class="math">\\mathbf{l},\\mathbf{r}</span>  are correct (67) <span class="math">\\hat{t}\\stackrel {?}{=}\\langle \\mathbf{l},\\mathbf{r}\\rangle \\in \\mathbb{Z}_p</span>  // check that  <span class="math">\\hat{t}</span>  is correct (68)</p>

    <p class="text-gray-300">Equation (65) is the only place where the verifier uses the given Pedersen commitment  <span class="math">V</span>  to  <span class="math">v</span> .</p>

    <p class="text-gray-300">Corollary 2 (Range Proof). The range proof presented in Section 4.1 has perfect completeness, perfect special honest verifier zero-knowledge, and computational witness extended emulation.</p>

    <p class="text-gray-300">Proof. The range proof is a special case of the aggregated range proof from section 4.3 with  <span class="math">m = 1</span> . This is therefore a direct corollary of Theorem 3.</p>

    <p class="text-gray-300">Finally, we can describe the efficient range proof that uses the improved inner product argument.</p>

    <p class="text-gray-300">In the range proof protocol from Section 4.1,  <span class="math">\\mathcal{P}</span>  transmits  <span class="math">\\mathbf{l}</span>  and  <span class="math">\\mathbf{r}</span> , whose size is linear in  <span class="math">n</span> . Our goal is a proof whose size is logarithmic in  <span class="math">n</span> .</p>

    <p class="text-gray-300">We can eliminate the transfer of <span class="math">\\mathbf{l}</span> and <span class="math">\\mathbf{r}</span> using the inner-product argument from Section 3. These vectors are not secret and hence a protocol the only provides soundness is sufficient.</p>

    <p class="text-gray-300">To use the inner-product argument observe that verifying (67) and (68) is the same as verifying that the witness <span class="math">\\mathbf{l},\\mathbf{r}</span> satisfies the inner product relation (2) on public input <span class="math">\\left(\\mathbf{g},\\ \\mathbf{h}^{\\prime},Ph^{-\\mu},\\ \\hat{t}\\ \\right)</span>. That is, <span class="math">P\\in\\mathbb{G}</span> is a commitment to two vectors <span class="math">\\mathbf{l},\\mathbf{r}\\in\\mathbb{Z}_{p}^{n}</span> whose inner product is <span class="math">\\hat{t}</span>. We can therefore replace (63) with a transfer of <span class="math">(\\tau_{x},\\mu,\\hat{t})</span>, as before, and an execution of an inner product argument. Then instead of transmitting <span class="math">\\mathbf{l}</span> and <span class="math">\\mathbf{r}</span>, which has a communication cost of <span class="math">2\\cdot n</span> elements, the inner-product argument transmits only <span class="math">2\\cdot\\left[\\log_{2}(n)\\right]+2</span> elements. In total, the prover sends only <span class="math">2\\cdot\\left[\\log_{2}(n)\\right]+4</span> group elements and <span class="math">5</span> elements in <span class="math">\\mathbb{Z}_{p}</span>.</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">4.3 Aggregating Logarithmic Proofs</h3>

    <p class="text-gray-300">In many of the range proof applications described in Section 1.2, a single prover needs to perform multiple range proofs at the same time. For example, a confidential transaction often contains multiple outputs, and in fact, most transactions require a so-called <em>change output</em> to send any unspent funds back to the sender. In Provisions <em>[DBB^{+}15]</em> the proof of solvency requires the exchange to conduct a range proof for every single account. Given the logarithmic size of the range proof presented in Section 4.2, there is some hope that we can perform a proof for <span class="math">m</span> values which is more efficient than conducting <span class="math">m</span> individual range proofs. In this section, we show that this can be achieved with a slight modification to the proof system from Section 4.1.</p>

    <p class="text-gray-300">Concretely, we present a proof system for the following relation:</p>

    <p class="text-gray-300"><span class="math">\\left\\{(g,h\\in\\mathbb{G},\\quad\\mathbf{V}\\in\\mathbb{G}^{m}\\quad;\\quad\\mathbf{v},\\bm{\\gamma}\\in\\mathbb{Z}_{p}^{m})\\ :\\ V_{j}=h^{\\gamma_{j}}g^{v_{j}}\\wedge v_{j}\\in\\left[0,2^{n}-1\\right]\\quad\\forall j\\in\\left[1,m\\right]\\right\\}</span> (69)</p>

    <p class="text-gray-300">The prover is very similar to the prover for a simple range proof with <span class="math">n\\cdot m</span> bits, with the following slight modifications. In line (41), the prover should compute <span class="math">\\mathbf{a}_{L}\\in\\mathbb{Z}_{p}^{n\\cdot m}</span> such that <span class="math">\\langle\\mathbf{2}^{n},\\mathbf{a}_{L}\\left[(j-1)\\cdot n:j\\cdot n-1\\right]\\rangle=v_{j}</span> for all <span class="math">j</span> in <span class="math">\\left[1,m\\right]</span>, i.e. <span class="math">\\mathbf{a}_{L}</span> is the concatenation of all of the bits for every <span class="math">v_{j}</span>. We adjust <span class="math">l(X)</span> and <span class="math">r(X)</span> accordingly so that</p>

    <p class="text-gray-300"><span class="math">l(X)</span> <span class="math">=(\\mathbf{a}_{L}-z\\cdot\\mathbf{1}^{n\\cdot m})+\\mathbf{s}_{L}\\cdot X\\in\\mathbb{Z}_{p}^{n\\cdot m}[X]</span> (70) <span class="math">r(X)</span> <span class="math">=\\mathbf{y}^{n\\cdot m}\\circ(\\mathbf{a}_{R}+z\\cdot\\mathbf{1}^{n\\cdot m}+\\mathbf{s}_{R}\\cdot X)+\\sum_{j=1}^{m}z^{1+j}\\cdot\\left(\\mathbf{0}^{(j-1)\\cdot n}\\parallel\\mathbf{2}^{n}\\parallel\\mathbf{0}^{(m-j)\\cdot n}\\right)\\in\\mathbb{Z}_{p}^{n\\cdot m}</span> (71)</p>

    <p class="text-gray-300">In the computation of <span class="math">\\tau_{x}</span>, we need to adjust for the randomness of each commitment <span class="math">V_{j}</span>, so that <span class="math">\\tau_{x}=\\tau_{1}\\cdot x+\\tau_{2}\\cdot x^{2}+\\sum_{j=1}^{m}z^{1+j}\\cdot\\gamma_{j}</span>. Further, <span class="math">\\delta(y,z)</span> is updated to incorporate more cross terms.</p>

    <p class="text-gray-300"><span class="math">\\delta(y,z)=(z-z^{2})\\cdot\\langle\\mathbf{1}^{n\\cdot m},\\mathbf{y}^{n\\cdot m}\\rangle-\\sum_{j=1}^{m}z^{j+2}\\cdot\\langle\\mathbf{1}^{n},\\mathbf{2}^{n}\\rangle</span></p>

    <p class="text-gray-300">The verification check (65) needs to be updated to include all the <span class="math">V_{j}</span> commitments.</p>

    <p class="text-gray-300"><span class="math">g^{\\hat{t}}h^{\\tau_{x}}\\stackrel{{\\scriptstyle?}}{{=}}g^{\\delta(y,z)}\\cdot\\mathbf{V}^{z^{2}\\cdot\\mathbf{z}^{m}}\\cdot T_{1}^{x}\\cdot T_{2}^{x^{2}}</span> (72)</p>

    <p class="text-gray-300">Finally, we change the definition of <span class="math">P</span> (66) such that it is a commitment to the new <span class="math">\\mathbf{r}</span>.</p>

    <p class="text-gray-300"><span class="math">P=AS^{x}\\cdot\\mathbf{g}^{-z}\\cdot\\mathbf{h}^{\\prime^{x}\\cdot\\mathbf{y}^{n\\cdot m}}\\prod_{j=1}^{m}\\mathbf{h}^{\\prime^{j+1}_{[(j-1)\\cdot n:j\\cdot n-1]}}^{z^{j+1}\\cdot\\mathbf{2}^{n}}</span></p>

    <p class="text-gray-300">The aggregated range proof which makes use of the inner product argument uses <span class="math">2 \\cdot [\\log_2(n \\cdot m)] + 4</span> group elements and 5 elements in <span class="math">\\mathbb{Z}_p</span>. Note that the proof size only grows by an additive term of <span class="math">2 \\cdot \\log_2(m)</span> when conducting multiple range proofs as opposed to a multiplicative factor of <span class="math">m</span> when creating <span class="math">m</span> independent range proofs.</p>

    <p class="text-gray-300"><strong>Theorem 3.</strong> The aggregate range proof presented in Section 4.3 has perfect completeness, perfect honest verifier zero-knowledge and computational witness extended emulation.</p>

    <p class="text-gray-300">The proof for Theorem 3 is presented in Appendix C. It is analogous to the proof of Theorem 4 which is described in greater detail in Appendix D.</p>

    <h2 id="sec-28" class="text-2xl font-bold">4.4 Non-Interactive Proof through Fiat-Shamir</h2>

    <p class="text-gray-300">So far we presented the proof as an interactive protocol with a logarithmic number of rounds. The verifier is a public coin verifier, as all the honest verifier's messages are random elements from <span class="math">\\mathbb{Z}_p^*</span>. We can therefore convert the protocol into a non-interactive protocol that is secure and full zero-knowledge in the random oracle model using the Fiat-Shamir transform [BR93]. All random challenges are replaced by hashes of the transcript up to that point, including the statement itself. Subsequent works have shown that this approach is secure, even for multi-round protocols [Wik21, AFK21].</p>

    <p class="text-gray-300">For example, one could set <span class="math">y = \\mathsf{H}(\\mathsf{st}, A, S)</span> and <span class="math">z = \\mathsf{H}(A, S, y)</span>, where <span class="math">\\mathsf{st}</span> is the statement. For a range proof <span class="math">\\mathsf{st}</span> would be <span class="math">\\{V, n\\}</span>, and for a circuit proof it would be the description of the circuit. It is very important to include the statement <span class="math">\\mathsf{st}</span> in the hash as otherwise an adversary can prove invalid statements, as pointed out in a blog post². Since implementing Fiat-Shamir can be error-prone, we recommend using an established library to do so, such as Merlin³, which was developed as part of an implementation of Bulletproofs in Rust⁴.</p>

    <p class="text-gray-300">To avoid a trusted setup we can use a hash function to generate the public parameters <span class="math">\\mathbf{g}, \\mathbf{h}, g, h</span> from a small seed. The hash function needs to map <span class="math">\\{0,1\\}^*</span> to <span class="math">\\mathbb{G}</span>, which can be built as in [BLS01]. This also makes it possible to provide random access to the public parameters. Alternatively, a common random string can be used.</p>

    <h2 id="sec-29" class="text-2xl font-bold">4.5 A Simple MPC Protocol for Bulletproofs</h2>

    <p class="text-gray-300">In several of the applications described in Section 1.2, the prover could potentially consist of multiple parties who each want to generate a single range proof. For instance, multiple parties may want to create a single joined confidential transaction, where each party knows some of the inputs and outputs and needs to create range proofs for their known outputs. The joint transaction would not only be smaller than the sum of multiple transactions, it would also hide which inputs correspond to which outputs and provide some level of anonymity. These kinds of transactions are called CoinJoin transactions [Max13]. In Provisions, an exchange may distribute the private keys to multiple servers and split the customer database into separate chunks, but it still needs to produce a single short proof of solvency. Can these parties generate one Bulletproof without sharing the entire witness with each other? The parties could certainly use generic multi-party computation techniques to generate a single proof, but this might be too expensive and incur significant communication costs.</p>

    <p class="text-gray-300">²https://blog.trailofbits.com/2022/04/13/part-1-coordinated-disclosure-of-vulnerabilities-affecting-girault-bulletproofs ³https://github.com/zkcrypto/merlin ⁴https://github.com/zkcrypto/bulletproofs</p>

    <p class="text-gray-300">This motivates the need for a simple MPC protocol specifically designed for Bulletproofs which requires little modification to the prover and is still efficient.</p>

    <p class="text-gray-300">Note that for aggregate range proofs, the inputs of one range proof do not affect the output of another range proof. Given the composable structure of Bulletproofs, it turns out that <span class="math">m</span> parties each having a Pedersen commitment <span class="math">(V_{k})_{k=1}^{m}</span> can generate a single Bulletproof that each <span class="math">V_{k}</span> commits to a number in some fixed range. The protocol either uses a constant number of rounds but communication that is linear in both <span class="math">m</span> and the binary encoding of the range, or it uses a logarithmic number of rounds and communication that is only linear in <span class="math">m</span>. We assume for simplicity that <span class="math">m</span> is a power of 2, but the protocol could be easily adapted for other <span class="math">m</span>. We use the same notation as in the aggregate range proof protocol, but use <span class="math">k</span> as an index to denote the <span class="math">k</span>th party’s message. That is <span class="math">A^{(k)}</span> is generated just like <span class="math">A</span> but using only the inputs of party <span class="math">k</span>.</p>

    <p class="text-gray-300">The MPC protocol works as follows, we assign a set of distinct generators <span class="math">(\\mathbf{g}^{(k)},\\mathbf{h}^{(k)})_{k=1}^{m}</span> to each party and define <span class="math">\\mathbf{g}</span> as the interleaved concatenation of all <span class="math">\\mathbf{g}^{(k)}</span> such that <span class="math">g_{i}=g_{[\\frac{i}{m}]}^{((i-1)\\mod m+1)}</span>. Define <span class="math">\\mathbf{h}</span> and <span class="math">\\mathbf{h}^{(k)}</span> in an analogous way.</p>

    <p class="text-gray-300">We first describe the protocol with linear communication. In each of the 3 rounds of the protocol, the ones that correspond to the rounds of the range proof in Section 4.1, each party simply generates its part of the proof, i.e. the <span class="math">A^{(k)},S^{(k)};T_{1}^{(k)},T_{2}^{(k)};\\tau_{x}^{(k)},\\mu^{(k)},\\hat{t}^{(k)},\\mathbf{l}^{(k)},\\mathbf{r}^{(k)}</span> using its inputs and generators. These shares are then sent to a dealer (which could be one of the parties), who simply adds them homomorphically to generate the respective proof component, e.g. <span class="math">A=\\prod_{k=1}^{l}A^{(k)}</span> and <span class="math">\\tau_{x}=\\sum_{k=1}^{l}\\tau_{x}^{(k)}</span>. In each round, the dealer generates the challenges using the Fiat-Shamir heuristic and the combined proof components and sends them to each party. Finally, each party sends <span class="math">\\mathbf{l}^{(k)},\\mathbf{r}^{(k)}</span> to the dealer who computes <span class="math">\\mathbf{l},\\mathbf{r}</span> as the interleaved concatenation of the shares. The dealer runs the inner product argument and generates the final proof. The protocol is complete as each proof component is simply the (homomorphic) sum of each parties’ proof components, and the challenges are generated as in the original protocol. It is also secure against honest but curious adversaries as each share constitutes part of a separate zero-knowledge proof.</p>

    <p class="text-gray-300">The communication can be reduced by running a second MPC protocol for the inner product argument. The generators were selected in such a way that up to the last <span class="math">\\log_{2}(l)</span> rounds each parties’ witnesses are independent and the overall witness is simply the interleaved concatenation of the parties’ witnesses. Therefore, parties simply compute <span class="math">L^{(k)},R^{(k)}</span> in each round and a dealer computes <span class="math">L,R</span> as the homomorphic sum of the shares. The dealer then again generates the challenge and sends it to each party. In the final round the parties send their witness to the dealer who completes Protocol 2. A similar protocol can be used for arithmetic circuits if the circuit is decomposable into separate independent circuits. Constructing an efficient MPC protocol for more complicated circuits remains an open problem.</p>

    <h3 id="sec-30" class="text-xl font-semibold mt-8">4.6 Perfectly Binding Commitments and Proofs</h3>

    <p class="text-gray-300">Bulletproofs, like the range proofs currently used in confidential transactions, are computationally binding. An adversary that could break the discrete logarithm assumption could generate acceptable range proofs for a value outside the correct range. On the other hand, the commitments are perfectly hiding and Bulletproofs are perfect zero-knowledge, so that even an all powerful adversary cannot learn which value was committed to. Commitment schemes which are simultaneously perfectly-binding and perfectly-hiding commitments are impossible, so when designing commitment schemes and proof systems, we need to decide which properties are more important. For cryptocur</p>

    <p class="text-gray-300">rencies, the binding property is more important than the hiding property <em>[x10]</em>. An adversary that can break the binding property of the commitment scheme or the soundness of the proof system can generate coins out of thin air and thus create uncontrolled but undetectable inflation rendering the currency useless. Giving up the privacy of a transaction is much less harmful as the sender of the transaction or the owner of an account is harmed at worst. Unfortunately, it seems difficult to create Bulletproofs from binding commitments. The efficiency of the system relies on vector commitments which allow the commitment to a long vector in a single group element. By definition, for perfectly binding commitment schemes, the size of the commitment must be at least the size of the message and compression is thus impossible. The works <em>[x4, x5]</em> show that in general, interactive proofs cannot have communication costs smaller than the witness size, unless some very surprising results in complexity theory hold.</p>

    <p class="text-gray-300">While the discrete logarithm assumption is believed to hold for classical computers, it does not hold against a quantum adversary. It is especially problematic that an adversary can create a perfectly hiding UTXO at any time, planning to open to an arbitrary value later when quantum computers are available. To defend against this, we can use the technique from Ruffing and Malavolta <em>[x10]</em> to ensure that even though the proof is only computationally binding, it is later possible to switch to a proof system that is perfectly binding and secure against quantum adversaries. In order to do this, the prover simply publishes <span class="math">g^{\\gamma}</span>, which turns the Pedersen commitment to <span class="math">v</span> into an ElGamal commitment. Ruffing and Malavolta also show that given a small message space, e.g. numbers in the range <span class="math">[0,2^{n}]</span>, it is impossible for a computationally bounded prover to construct a commitment that an unbounded adversary could open to a different message in the small message space.</p>

    <p class="text-gray-300">Note that the commitment is now only computationally hiding, but that switching to quantum-secure range proofs is possible. Succinct quantum-secure range proofs remain an open problem, but with a slight modification, the scheme from Poelstra et al. <em>[PBF^{+}]</em> can achieve statistical soundness. Instead of using Pedersen commitments, we propose using ElGamal commitments in every step of the protocol. An ElGamal commitment is a Pedersen commitment with an additional commitment <span class="math">g^{r}</span> to the randomness used. The scheme can be improved slightly if the same <span class="math">g^{r}</span> is used in multiple range proofs. In order to retain the hiding property, a different <span class="math">h</span> must be used for every proof.</p>

    <h2 id="sec-31" class="text-2xl font-bold">5 Zero-Knowledge Proof for Arithmetic Circuits</h2>

    <p class="text-gray-300">Bootle et al. <em>[BCC^{+}16]</em> present an efficient zero-knowledge argument for arbitrary arithmetic circuits using <span class="math">6\\log_{2}(n)+13</span> elements, where <span class="math">n</span> is the multiplicative complexity of the circuit. We can use our improved inner product argument to get a proof of size <span class="math">2\\log_{2}(n)+13</span> elements, while simultaneously generalizing to include committed values as inputs to the arithmetic circuit. Including committed input wires is important for many applications (notably range proofs) as otherwise the circuit would need to implement a commitment algorithm. Concretely a statement about Pedersen commitments would need to implement the group exponentiation for the group that the commitment is an element of.</p>

    <p class="text-gray-300">Following <em>[BCC^{+}16]</em>, we present a proof for a Hadamard-product relation. A multiplication gate of fan-in 2 has three wires; ‘left’ and ‘right’ for the input wires, and ‘output’ for the output wire. In the relation, <span class="math">\\mathbf{a}_{L}</span> is the vector of left inputs for each multiplication gate. Similarly, <span class="math">\\mathbf{a}_{R}</span> is the vector of right inputs, and <span class="math">\\mathbf{a}_{O}=\\mathbf{a}_{L}\\circ\\mathbf{a}_{R}</span> is the vector of outputs. <em>[BCC^{+}16]</em> shows how to convert an arbitrary arithmetic circuit with <span class="math">n</span> multiplication gates into a relation containing a</p>

    <p class="text-gray-300">Hadamard-product as above, with an additional <span class="math">Q\\leqslant 2\\cdot n</span> linear constraints of the form</p>

    <p class="text-gray-300"><span class="math">\\langle\\mathbf{w}_{L,q},\\mathbf{a}_{L}\\rangle+\\langle\\mathbf{w}_{R,q},\\mathbf{a}_{R}\\rangle+\\langle\\mathbf{w}_{O,q},\\mathbf{a}_{O}\\rangle=c_{q}</span></p>

    <p class="text-gray-300">for <span class="math">1\\leqslant q\\leqslant Q</span>, with <span class="math">\\mathbf{w}_{L,q},\\mathbf{w}_{R,q},\\mathbf{w}_{O,q}\\in\\mathbb{Z}_{p}^{n}</span> and <span class="math">c_{q}\\in\\mathbb{Z}_{p}</span>.</p>

    <p class="text-gray-300">We include additional commitments <span class="math">V_{i}</span> as part of our statement, and give a protocol for a more general relation, where the linear consistency constraints include the openings <span class="math">v_{j}</span> of the commitments <span class="math">V_{j}</span>. For simplicity and efficiency we present the scheme with <span class="math">V_{i}</span> being Pedersen commitments. The scheme can be trivially adapted to work with other additively homomorphic schemes by changing the commitments to <span class="math">t(X)</span> and adapting the verification in line (90).</p>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">5.1 Inner-Product Proof for Arithmetic Circuits</h3>

    <p class="text-gray-300">The high level idea of the protocol is to convert the Hadamard-product relation along with the linear constraints into a single inner product relation. Similar to the range proof protocol the prover verifiably produces a random linear combination of the Hadamard and the linear constraints to form a single inner product constraint. If the combination is chosen randomly by the verifier, as in our protocol, then with overwhelming probability the inner-product constraint implies the other constraints.</p>

    <p class="text-gray-300">In Section 5.2 we show that the inner product relation can be replaced with an efficient inner product argument which yields short proofs for arbitrary circuits where input wires can come from Pedersen commitments. Formally we present a proof system for the following relation.</p>

    <p class="text-gray-300"><span class="math">\\{(g,h\\in\\mathbb{G},\\mathbf{g},\\mathbf{h}\\in\\mathbb{G}^{n},\\mathbf{V}\\in\\mathbb{G}^{m},\\mathbf{W}_{L},\\mathbf{W}_{R},\\mathbf{W}_{O}\\in\\mathbb{Z}_{p}^{Q\\times n},\\mathbf{W}_{V}\\in\\mathbb{Z}_{p}^{Q\\times m},\\mathbf{c}\\in\\mathbb{Z}_{p}^{Q};\\mathbf{a}_{L},\\mathbf{a}_{R},\\mathbf{a}_{O}\\in\\mathbb{Z}_{p}^{n},\\mathbf{v},\\boldsymbol{\\gamma}\\in\\mathbb{Z}_{p}^{m}):</span> (73) <span class="math">V_{j}=g^{v_{j}}h^{\\gamma_{j}}\\ \\forall j\\in[1,m]\\wedge\\mathbf{a}_{L}\\circ\\mathbf{a}_{R}=\\mathbf{a}_{O}\\wedge\\mathbf{W}_{L}\\cdot\\mathbf{a}_{L}+\\mathbf{W}_{R}\\cdot\\mathbf{a}_{R}+\\mathbf{W}_{O}\\cdot\\mathbf{a}_{O}=\\mathbf{W}_{V}\\cdot\\mathbf{v}+\\mathbf{c}\\}</span></p>

    <p class="text-gray-300">Let <span class="math">\\mathbf{W}_{V}\\in\\mathbb{Z}_{p}^{Q\\times m}</span> be the weights for a commitment <span class="math">V_{j}</span>. The presented proof system only works for relations where <span class="math">\\mathbf{W}_{V}</span> is of rank <span class="math">m</span>, i.e. the columns of the matrix are all linearly independent. This restriction is minor as we can construct commitments that fulfill these linearly dependent constraints as a homomorphic combination of other commitments. Consider a vector <span class="math">\\mathbf{w}_{V}^{\\prime}=\\mathbf{a}\\cdot\\mathbf{W}_{V}\\in\\mathbb{Z}_{p}^{m}</span> for a vector of scalars <span class="math">\\mathbf{a}\\in\\mathbb{Z}_{p}^{Q}</span> then we can construct commitment <span class="math">V^{\\prime}=\\mathbf{v}^{\\mathbf{a}\\cdot\\mathbf{W}_{V}}</span>. Note that if the relation holds then we can conclude that <span class="math">\\langle\\mathbf{w}_{L,j},\\mathbf{a}_{L}\\rangle+\\langle\\mathbf{w}_{R,j},\\mathbf{a}_{R}\\rangle+\\langle\\mathbf{w}_{O,j},\\mathbf{a}_{O}\\rangle=\\langle\\mathbf{w}_{V}^{\\prime},\\mathbf{v}\\rangle+\\mathbf{c}</span>. The protocol is presented in Protocol 3. It is split into two parts. In the first part <span class="math">\\mathcal{P}</span> commits to <span class="math">l(X),r(X),t(X)</span> in the second part <span class="math">\\mathcal{P}</span> convinces <span class="math">\\mathcal{V}</span> that the polynomials are well formed and that <span class="math">\\langle l(X),r(X)\\rangle=t(X)</span>.</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Theorem 4.</h6>

    <p class="text-gray-300">The proof system presented in Protocol 3 has perfect completeness, perfect honest verifier zero-knowledge and computational witness extended emulation.</p>

    <p class="text-gray-300">The proof of Theorem 4 is presented in Appendix D.</p>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">5.2 Logarithmic-Sized Protocol</h3>

    <p class="text-gray-300">As for the range proof, we can reduce the communication cost of the protocol by using the inner product argument. Concretely transfer (82) is altered to simply <span class="math">\\tau_{x},\\mu,\\hat{t}</span> and additionally <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> engage in an inner product argument on public input <span class="math">(\\mathbf{g},\\mathbf{h}^{\\prime},P\\cdot h^{-\\mu},\\hat{t})</span>. Note that the statement proven is equivalent to the verification equations (92) and (88). The inner product argument has only logarithmic communication complexity and is thus highly efficient. Note that instead</p>

    <p class="text-gray-300">|  Input: (g,h∈G,g,h∈Gn,WL,WR,WO∈ZpQ×n, WV∈ZpQ×m, c∈ZpQ; aL, aR, aO∈Zp, γ∈Zp)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  P's input: (g,h,g,h,WL,WR,WO,WV,c; aL, aR, aO,γ)  |   |</p>

    <p class="text-gray-300">|  V's input: (g,h,g,h,WL,WR,WO,WV,c)  |   |</p>

    <p class="text-gray-300">|  Output: {V accepts,V rejects}  |   |</p>

    <p class="text-gray-300">|  P computes:  |   |</p>

    <p class="text-gray-300">|  α,β,ρ←$Zp  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">AI=hαgALhAR∈G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">// commit to aL, aR</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sL,sR←$Zp</td>

            <td class="px-3 py-2 border-b border-gray-700">// choose blinding vectors sL,sR</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">S=hρgSLhSR∈G</td>

            <td class="px-3 py-2 border-b border-gray-700">// commitment to sL,sR</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  P→V: AI,A0,S  |   |</p>

    <p class="text-gray-300">|  V: y,z←$Zp*  |   |</p>

    <p class="text-gray-300">|  V→P: y,z  |   |</p>

    <p class="text-gray-300">|  P and V compute:  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">yn=(1,y,y2,...,yn-1)∈Zp</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">// challenge per witness</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">δ(y,z)=<y-n○(zQ+1</td>

            <td class="px-3 py-2 border-b border-gray-700">W_R),zQ+1</td>

            <td class="px-3 py-2 border-b border-gray-700">W_L></td>

            <td class="px-3 py-2 border-b border-gray-700">// independent of the witness</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  P computes:  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">l(X)=aL·X+aO·X2+y-n○(zQ+1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">W_R)·X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  +sL·X3∈Zp[X]  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r(X)=yn○aR·X-yn+zQ+1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">W_L·X+WO)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  +yn○sR·X3∈Zp[X]  |   |</p>

    <p class="text-gray-300">|  t(X)=<l(X),r(X)> = ∑i=16ti·Xi∈Zp[X]  |   |</p>

    <p class="text-gray-300">|  w=WL·aL+WR·aR+WO·aO  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t2=<aL,aR∘yn>-<aO,yn>+<zQ+1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">W>+δ(y,z)∈Zp // t2=d(y,z)+<zQ+1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C+WV·v></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  τi←$Zp ∀i∈[1,3,4,5,6]  |   |</p>

    <p class="text-gray-300">|  Ti=gti hτi ∀i∈[1,3,4,5,6]  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P→V: T1,T3,T4,T5,T6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">// commitments to t1,t3,t4,t5,t6</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Protocol 3: Part 1: Computing commitments to  <span class="math">l(X), r(X)</span>  and  <span class="math">t(X)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V: x←2Zp</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">// Random challenge</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(74)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">V→P: x</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(75)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">P computes:</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(76)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">l = l(x) ∈ Zn</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(77)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">r = r(x) ∈ Zn</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(78)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">t = ⟨l, r⟩ ∈ Zp</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(79)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">τx = ∑i=1,i≠26τi·xi + x2·⟨zQ+1[1:], WV·γ⟩ ∈ Zp</td>

            <td class="px-3 py-2 border-b border-gray-700">// blinding value for t</td>

            <td class="px-3 py-2 border-b border-gray-700">(80)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">μ = α·x + β·x2 + ρ·x3 ∈ Zp</td>

            <td class="px-3 py-2 border-b border-gray-700">// Blinding value for P</td>

            <td class="px-3 py-2 border-b border-gray-700">(81)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">P → V: τx, μ, t, l, r</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(82)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">V computes and checks:</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(83)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">h′i = h′y−i+1 ∀i ∈ [1,n]</td>

            <td class="px-3 py-2 border-b border-gray-700">// h′ = (h1, h2y−1, ..., hn−n+1)</td>

            <td class="px-3 py-2 border-b border-gray-700">(84)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">WL = h′zQ+1[1:], WL</td>

            <td class="px-3 py-2 border-b border-gray-700">// Weights for aL</td>

            <td class="px-3 py-2 border-b border-gray-700">(85)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">WR = gγ−n⊙(zQ+1[1:], WR)</td>

            <td class="px-3 py-2 border-b border-gray-700">// Weights for aR</td>

            <td class="px-3 py-2 border-b border-gray-700">(86)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">WO = h′zQ+1[1:], WO</td>

            <td class="px-3 py-2 border-b border-gray-700">// Weights for aO</td>

            <td class="px-3 py-2 border-b border-gray-700">(87)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">t ≠ ⟨l, r⟩</td>

            <td class="px-3 py-2 border-b border-gray-700">// Check that t is correct</td>

            <td class="px-3 py-2 border-b border-gray-700">(88)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">g′t hτx ≠ gx2·(δ(y,z) + ⟨zQ+1[1:], e⟩) · Vx2·(zQ+1[1:], WV) · T1x</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(89)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">· ∏i=36Ti(xi)</td>

            <td class="px-3 py-2 border-b border-gray-700">// t = t(x) = ∑i=16ti·xi</td>

            <td class="px-3 py-2 border-b border-gray-700">(90)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">P = A′I · AO(x2) · h′-γn · WLx · WRx · WO · S(x3)</td>

            <td class="px-3 py-2 border-b border-gray-700">// commitment to l(x), r(x)</td>

            <td class="px-3 py-2 border-b border-gray-700">(91)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">P ≠ hμ · g1 · h′r</td>

            <td class="px-3 py-2 border-b border-gray-700">// Check that l = l(x) and r = r(x)</td>

            <td class="px-3 py-2 border-b border-gray-700">(92)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">if all checks succeed: V accepts</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(93)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">else: V rejects</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(94)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Protocol 3: Part 2: Polynomial identity check for  <span class="math">\\langle l(x), r(x) \\rangle = t(x)</span></p>

    <p class="text-gray-300">of transmitting  <span class="math">\\mathbf{l},\\mathbf{r}</span>  the inner product argument only requires communication of  <span class="math">2\\cdot [\\log_2(n)] + 2</span>  elements instead of  <span class="math">2\\cdot n</span> . In total the prover sends  <span class="math">2\\cdot [\\log_2(n)] + 8</span>  group elements and 5 elements in  <span class="math">\\mathbb{Z}_p</span> . Using the Fiat-Shamir heuristic as in 4.4 the protocol can be turned into an efficient non interactive proof. We report implementation details and evaluations in Section 6.</p>

    <p class="text-gray-300">Theorem 5. The arithmetic circuit protocol using the improved inner product argument (Protocol 2) has perfect completeness, statistical zero-knowledge and computational soundness under the discrete logarithm assumption.</p>

    <p class="text-gray-300">Proof. Completeness follows from the completeness of the underlying protocols. Zero-knowledge follows from the fact that  <span class="math">\\mathbf{l}</span>  and  <span class="math">\\mathbf{r}</span>  can be efficiently simulated, and because the simulator can simply run Protocol 2 given the simulated witness  <span class="math">(\\mathbf{l},\\mathbf{r})</span> . The protocol also has a knowledge-extractor, as the extractor of the range proof can be extended to extract  <span class="math">\\mathbf{l}</span>  and  <span class="math">\\mathbf{r}</span>  by calling the extractor of Protocol 2. The extractor uses  <span class="math">O(n^{3})</span>  valid transcripts in total, which is polynomial in  <span class="math">\\lambda</span>  if  <span class="math">n = O(\\lambda)</span> . The extractor is thus efficient and either extracts a discrete logarithm relation or a valid witness. However, if the generators  <span class="math">\\mathbf{g},\\mathbf{h},g,h</span>  are independently generated, then finding a discrete logarithm relation between them is as hard as breaking the discrete log problem. If the discrete log assumption holds in  <span class="math">\\mathbb{G}</span>  then a computationally bounded  <span class="math">\\mathcal{P}</span>  cannot produce discrete-logarithm relations between independent generators. The proof system is therefore computationally sound.</p>

    <p class="text-gray-300">In Table 1 we give analytical measurements for the proof size of different range proof protocols. We compare both the proof sizes for a single proof and for  <span class="math">m</span>  proofs for the range  <span class="math">[0,2^n - 1]</span> . We compare Bulletproofs against  <span class="math">\\left[\\mathrm{PBF}^{+}\\right]</span>  and a  <span class="math">\\Sigma</span> -protocol range proof where the proof commits to each bit and then shows that the commitment is to 0 or 1. The table shows that Bulletproofs</p>

    <p class="text-gray-300">Table 1: Range proof size for  <span class="math">m</span>  proofs.  <span class="math">m = 1</span>  is the special case of a single range proof <span class="math">m</span>  range proofs for range  <span class="math">[0,2^n -1]</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"># G elements</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"># Zp elements</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Σ Protocol [CD98]</td>

            <td class="px-3 py-2 border-b border-gray-700">mn</td>

            <td class="px-3 py-2 border-b border-gray-700">3mn + 1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Poelstra et al. [PBF+]</td>

            <td class="px-3 py-2 border-b border-gray-700">0.63 · mn</td>

            <td class="px-3 py-2 border-b border-gray-700">1.26 · mn + 1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Bulletproofs</td>

            <td class="px-3 py-2 border-b border-gray-700">2(log2(n) + log2(m)) + 4</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">have a significant advantage when providing multiple range proofs at once. The proof size for the protocol presented in Section 4.3 only grows by an additive logarithmic factor when conducting  <span class="math">m</span>  range proofs, while all other solutions grow multiplicatively in  <span class="math">m</span> .</p>

    <p class="text-gray-300">In many of the applications discussed in Section 1.2 the verifier's runtime is of particular interest. For example, with confidential transactions every full node needs to check all confidential transac</p>

    <p class="text-gray-300">tions and all associated range proofs. We therefore now present a number of optimizations for the non-interactive verifier. We present the optimizations for a single range proof but they all carry over to aggregate range proofs and the arithmetic circuit protocol.</p>

    <p class="text-gray-300">Single multi-exponentiation. In Section 3.1 we showed that the verification of the inner product can be reduce to a single multi-exponentiation. We can further extend this idea to verify the whole range proof using a single multi-exponentiation of size <span class="math">2n + 2\\log_2(n) + 7</span>. Notice that the Bulletproofs verifier only performs two checks (68) and (16). The idea is to delay exponentiation until those checks are actually performed and then to combine them into a single check. We, therefore, unroll the inner product argument as described in Section 3.1 using the input from the range proof. The resulting protocol is presented below with <span class="math">x_{u}</span> being the challenge from Protocol 1, and <span class="math">x_{j}</span> being the challenge from round <span class="math">j</span> of Protocol 2. <span class="math">L_{j}</span> and <span class="math">R_{j}</span> are the <span class="math">L,R</span> values from round <span class="math">j</span> of Protocol 2. The verifier runs the following verification procedure:</p>

    <p class="text-gray-300">input: proof <span class="math">\\pi = \\left\\{A,S,T_1,T_2,(L_j,R_j)_{\\mathrm{j = 1}}^{\\log (n)}\\in \\mathbb{G},\\tau ,\\hat{t},\\mu ,a,b\\in \\mathbb{Z}_p\\right\\}</span> (95)</p>

    <p class="text-gray-300">compute challenges from <span class="math">\\pi :\\{y,z,x,x_u,(x_j)_{\\mathrm{j = 1}}^{\\log_2(n)}\\}</span> (96)</p>

    <p class="text-gray-300"><span class="math">\\delta (y,z) = (z - z^{2})\\cdot \\langle \\mathbf{1}^{n},\\mathbf{y}^{n}\\rangle -z^{3}\\langle \\mathbf{1}^{n},\\mathbf{2}^{n}\\rangle</span> (97)</p>

    <p class="text-gray-300"><span class="math">g^{\\hat{t} -\\delta (y,z)}h^{\\tau_x}\\cdot V^{-z^2}\\cdot T_1^{-x}\\cdot T_2^{-x^2}\\stackrel {\\mathrm{?}}{=}1</span> (98)</p>

    <p class="text-gray-300"><span class="math">b(i,j) = \\left\\{ \\begin{array}{ll}1 &amp;amp; \\text{if the } j\\text{th bit of } i - 1\\text{ is } 1\\\\ -1 &amp;amp; \\text{otherwise} \\end{array} \\right.</span> (99)</p>

    <p class="text-gray-300">for <span class="math">i = 1,\\ldots ,n</span> : (100)</p>

    <div class="my-4 text-center"><span class="math-block">l _ {i} = \\prod_ {j = 1} ^ {\\log_ {2} n} x _ {j} ^ {b (i, j)} \\cdot a + z \\in \\mathbb {Z} _ {p} \\tag {101}</span></div>

    <div class="my-4 text-center"><span class="math-block">r _ {i} = y ^ {1 - i} \\cdot \\left(\\prod_ {j = 1} ^ {\\log_ {2} n} x _ {j} ^ {- b (i, j)} \\cdot b - z ^ {2} \\cdot 2 ^ {i - 1}\\right) - z \\in \\mathbb {Z} _ {p} \\tag {102}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {l} = \\left(l _ {1}, \\dots , l _ {n}\\right) \\in \\mathbb {Z} _ {p} ^ {n} \\tag {103}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {r} = \\left(r _ {1}, \\dots , r _ {n}\\right) \\in \\mathbb {Z} _ {p} ^ {n} \\tag {104}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {g} ^ {\\mathbf {l}} \\mathbf {h} ^ {\\mathbf {r}} g ^ {x _ {u} \\cdot (a \\cdot b - \\hat {t})} h ^ {\\mu} \\cdot A ^ {- 1} S ^ {- x} \\prod_ {j = 1} ^ {\\log_ {2} (n)} L _ {j} ^ {- x _ {j} ^ {2}} R _ {j} ^ {- x _ {j} ^ {- 2}} \\stackrel {?} {=} 1 \\tag {105}</span></div>

    <p class="text-gray-300">We can combine the two multi-exponentiations in line (98) and (105) by using a random value <span class="math">c \\stackrel{\\</span>}{\\leftarrow} \\mathbb{Z}_p<span class="math">. This is because if </span>A^c B = 1<span class="math"> for a random </span>c<span class="math"> then with high probability </span>A = 1 \\wedge B = 1$.</p>

    <p class="text-gray-300">Various algorithms are known to compute the multi-exponentiations (105) and (98) efficiently. As explained in [BDLO12], algorithms like Pippenger's [Pip80] perform a number of group operations that scales with <span class="math">O_{\\frac{n}{\\log(n)}}</span>, i.e. sub-linearly. For realistic problem sizes these dominate verification time.</p>

    <p class="text-gray-300">Computing scalars. A further optimization concerns the computation of the <span class="math">l_{i}</span> and <span class="math">r_{i}</span> values. Instead of computing <span class="math">x^{(i)} = \\prod_{j=1}^{\\log_2 n} x_j^{b(i,j)}</span> for each <span class="math">i</span>, we can compute each challenge product using only one multiplication in <span class="math">\\mathbb{Z}_p</span> by applying batch division. First we compute <span class="math">x^{(1)} = (\\prod_{j=1}^{\\log_2 n} x_j)^{-1}</span> to</p>

    <p class="text-gray-300">29</p>

    <p class="text-gray-300">get the first challenge value using a single inversion. Then computing <span class="math">x^{(2)}=x^{(1)}x_{1}^{2},\\ \\ x^{3}=x^{(1)}x_{2}^{2}</span>, and for example <span class="math">x^{(7)}=x^{(3)}x_{5}^{2}</span>. In general in order to compute <span class="math">x^{(i)}</span> we let <span class="math">k</span> be the next lower power of 2 of <span class="math">i-1</span> and compute <span class="math">x^{(i)}=x^{(i-k)}\\cdot x_{k+1}^{2}</span> which takes only one additional multiplication in <span class="math">\\mathbb{Z}_{p}</span> and no inversion. Further, note that the squares of the challenges are computed anyway in order to check equation (105).</p>

    <p class="text-gray-300">Batch verification. A further important optimization concerns the verification of multiple proofs. In many applications described in Section 1.2 the verifier needs to verify multiple (separate) range proofs at once. For example a Bitcoin node receiving a block of transactions needs to verify all transactions and thus range proofs in parallel. As noted above, verification boils down to a large multi-exponentiation. In fact, <span class="math">2n+2</span> of the generators only depend on the public parameters, and only <span class="math">2\\log(n)+5</span> are proof-dependent. We can therefore apply batch verification <em>[x1]</em> in order to reduce the number of expensive exponentiations. Batch verification is based on the observation that checking <span class="math">g^{x}=1\\wedge g^{y}=1</span> can be checked by drawing a random scalar <span class="math">\\alpha</span> from a large enough domain and checking <span class="math">g^{\\alpha\\cdot x+y}=1</span>. With high probability, the latter equation implies that <span class="math">g^{x}=1\\wedge g^{y}=1</span>, but the latter is more efficient to check. The same trick applies to multi-exponentiations and can save <span class="math">2n</span> exponentiations per additional proof. This is equivalent to the trick that is used for combining multiple exponentiations into one with the difference that the bases are equivalent. Verifying <span class="math">m</span> distinct range proofs of size <span class="math">n</span> now only requires a single multi-exponentiation of size <span class="math">2n+2+m\\cdot(2\\cdot\\log(n)+5)</span> along with <span class="math">O(m\\cdot n)</span> scalar operations.</p>

    <p class="text-gray-300">Note that this optimization can even be applied for circuits and proofs for different circuits if the same public parameter are used.</p>

    <p class="text-gray-300">Even for a single verification we can take advantage of the fact that most generators are fixed in the public parameters. Both the verifier and the prover can used fast fixed-base exponentiation with precomputation <em>[x10]</em> to speed-up all the multi-exponentiations.</p>

    <h3 id="sec-38" class="text-xl font-semibold mt-8">6.3 Implementation and Performance</h3>

    <p class="text-gray-300">To evaluate the performance of Bulletproofs in practice we give a reference implementation in C and integrate it into the popular library libsecp256k1 which is used in many cryptocurrency clients. libsecp256k1 uses the elliptic curve secp256k1 which has 128 bit security.</p>

    <p class="text-gray-300">In their compressed form, secp256k1 points can be stored as 32 bytes plus one bit. We use all of the optimizations described above, except the pre-computation of generators. The prover uses constant time operations until the computation of l and r. By Theorem 2, the inner product argument does not need to hide l and r and can therefore use variable time operations. The verifier has no secrets and can therefore safely use variable time operations like the multi-exponentiations.</p>

    <p class="text-gray-300">All experiments were performed on an Intel i7-6820HQ system throttled to 2.00 GHz and using a single thread. Less than 100 MB of memory was used in all experiments. For reference, verifying an ECDSA signature takes 86 <span class="math">\\mu s</span> on the same system. Table 2 shows that in terms of proof size Bulletproofs bring a significant improvement over the 3.8 KB proof size in <em>[x22]</em>. A single 64-bit range proof is 688 bytes. An aggregated proof for 32 ranges is still just 1 KB whereas 32 proofs from <em>[x22]</em> would have taken up 121 KB. The cost to verify a single 64-bit range proof is 3.9 ms but using batch verification of many proofs the amortized cost can be brought down to 450 <span class="math">\\mu s</span> or 5.2 ECDSA verifications. Verifying an aggregated proof for 64 ranges takes 61 ms or 1.9 ms per</p>

    <p class="text-gray-300">range. The marginal cost of verifying an additional proof is  <span class="math">2.67\\mathrm{ms}</span>  or  <span class="math">83~\\mu \\mathrm{s}</span>  per range. This is less than verifying an ECDSA signature, which cannot take advantage of the same batch validation.</p>

    <p class="text-gray-300">To aid future use of Bulletproofs we also implemented Protocol 3 for arithmetic circuits and provide a parser for circuits in the Pinocchio [PHGR13] format to the Bulletproofs format. This hooks Bulletproofs up to the Pinocchio toolchain which contains a compiler from a subset of C to the circuit format. To evaluate the implementation we analyze several circuits for hash preimages in Table 3 and Figure 3.</p>

    <p class="text-gray-300">Specifically, a SHA256 circuit generated by jsnark <span class="math">^{6}</span>  and a Pedersen hash function over an embedded elliptic curve similar to  <span class="math">\\mathrm{Jubjub}^{7}</span>  are benchmarked. A Bulletproof for knowing a 384-bit Pedersen hash preimage is about 1 KB and takes  <span class="math">61~\\mathrm{ms}</span>  to verify. The marginal cost of verifying an additional proof is  <span class="math">2.1~\\mathrm{ms}</span> . The SHA256 preimage proof is  <span class="math">1.4~\\mathrm{KB}</span>  and takes  <span class="math">750~\\mathrm{ms}</span>  to verify. The marginal cost of verifying additional proofs is  <span class="math">41.5~\\mathrm{ms}</span> . Figure 3 shows that the proving and verification time grow linearly. The batch verification first grows logarithmically and then linearly. For small circuits the logarithmic number of exponentiations dominate the cost while for larger circuits the linear scalar operations do.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: Sizes for range proofs</p>

    <p class="text-gray-300">Table 2: Range proofs: performance and proof size</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Problem size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Gates</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">π Size (bytes)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Timing (ms)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">prove</td>

            <td class="px-3 py-2 border-b border-gray-700">verify</td>

            <td class="px-3 py-2 border-b border-gray-700">batch</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Range proofs (range × aggregation size)  |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">8 bit</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">8</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">482</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3.7</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.9</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.28</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">32 bit</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">610</td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">2.4</td>

            <td class="px-3 py-2 border-b border-gray-700">0.38</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">64 bit</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">675</td>

            <td class="px-3 py-2 border-b border-gray-700">29</td>

            <td class="px-3 py-2 border-b border-gray-700">3.9</td>

            <td class="px-3 py-2 border-b border-gray-700">0.45</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">64 bit × 2</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">739</td>

            <td class="px-3 py-2 border-b border-gray-700">57</td>

            <td class="px-3 py-2 border-b border-gray-700">6.2</td>

            <td class="px-3 py-2 border-b border-gray-700">0.55</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">per range</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">370</td>

            <td class="px-3 py-2 border-b border-gray-700">29</td>

            <td class="px-3 py-2 border-b border-gray-700">3.1</td>

            <td class="px-3 py-2 border-b border-gray-700">0.28</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">64 bit × 4</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">803</td>

            <td class="px-3 py-2 border-b border-gray-700">111</td>

            <td class="px-3 py-2 border-b border-gray-700">10.4</td>

            <td class="px-3 py-2 border-b border-gray-700">0.71</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">per range</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">201</td>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700">2.6</td>

            <td class="px-3 py-2 border-b border-gray-700">0.18</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">64 bit × 8</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">932</td>

            <td class="px-3 py-2 border-b border-gray-700">213</td>

            <td class="px-3 py-2 border-b border-gray-700">18.8</td>

            <td class="px-3 py-2 border-b border-gray-700">1.08</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">per range</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">117</td>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700">2.4</td>

            <td class="px-3 py-2 border-b border-gray-700">0.13</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">64 bit × 16</td>

            <td class="px-3 py-2 border-b border-gray-700">1024</td>

            <td class="px-3 py-2 border-b border-gray-700">932</td>

            <td class="px-3 py-2 border-b border-gray-700">416</td>

            <td class="px-3 py-2 border-b border-gray-700">33.2</td>

            <td class="px-3 py-2 border-b border-gray-700">1.58</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">per range</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">59</td>

            <td class="px-3 py-2 border-b border-gray-700">26</td>

            <td class="px-3 py-2 border-b border-gray-700">2.1</td>

            <td class="px-3 py-2 border-b border-gray-700">0.10</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">64 bit × 32</td>

            <td class="px-3 py-2 border-b border-gray-700">2048</td>

            <td class="px-3 py-2 border-b border-gray-700">996</td>

            <td class="px-3 py-2 border-b border-gray-700">812</td>

            <td class="px-3 py-2 border-b border-gray-700">61.0</td>

            <td class="px-3 py-2 border-b border-gray-700">2.67</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">per range</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">1.9</td>

            <td class="px-3 py-2 border-b border-gray-700">0.083</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">64 bit × 64</td>

            <td class="px-3 py-2 border-b border-gray-700">4096</td>

            <td class="px-3 py-2 border-b border-gray-700">1060</td>

            <td class="px-3 py-2 border-b border-gray-700">1594</td>

            <td class="px-3 py-2 border-b border-gray-700">114</td>

            <td class="px-3 py-2 border-b border-gray-700">4.91</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">per range</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">1.8</td>

            <td class="px-3 py-2 border-b border-gray-700">0.077</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">64 bit × 128</td>

            <td class="px-3 py-2 border-b border-gray-700">8192</td>

            <td class="px-3 py-2 border-b border-gray-700">1124</td>

            <td class="px-3 py-2 border-b border-gray-700">3128</td>

            <td class="px-3 py-2 border-b border-gray-700">210</td>

            <td class="px-3 py-2 border-b border-gray-700">9.75</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">per range</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">8.8</td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">1.6</td>

            <td class="px-3 py-2 border-b border-gray-700">0.076</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">64 bit × 256</td>

            <td class="px-3 py-2 border-b border-gray-700">16384</td>

            <td class="px-3 py-2 border-b border-gray-700">1189</td>

            <td class="px-3 py-2 border-b border-gray-700">6171</td>

            <td class="px-3 py-2 border-b border-gray-700">392</td>

            <td class="px-3 py-2 border-b border-gray-700">21.03</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">per range</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">4.6</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">1.5</td>

            <td class="px-3 py-2 border-b border-gray-700">0.082</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">64 bit × 512</td>

            <td class="px-3 py-2 border-b border-gray-700">32768</td>

            <td class="px-3 py-2 border-b border-gray-700">1253</td>

            <td class="px-3 py-2 border-b border-gray-700">12205</td>

            <td class="px-3 py-2 border-b border-gray-700">764</td>

            <td class="px-3 py-2 border-b border-gray-700">50.7</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">per range</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">2.5</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">1.5</td>

            <td class="px-3 py-2 border-b border-gray-700">0.10</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The first 4 instances are  <span class="math">n</span> -bit range proofs and the later ones are  <span class="math">m</span>  aggregated 64-bit proofs and the normalized costs per range. "Batch" is the marginal cost of verifying an additional proof, computed by batch-verifying 100 proofs, subtracting the cost to verify one, and dividing by 99.</p>

    <p class="text-gray-300">Table 3: Protocol 3: Performance numbers and proof sizes</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Input size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Gates</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">π Size (bytes)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Timing (ms)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">prove</td>

            <td class="px-3 py-2 border-b border-gray-700">verify</td>

            <td class="px-3 py-2 border-b border-gray-700">batch</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Pedersen hash preimage (input size)  |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">48 bit</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">128</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">864</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">88</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6.4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.72</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">192 bit</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">992</td>

            <td class="px-3 py-2 border-b border-gray-700">335</td>

            <td class="px-3 py-2 border-b border-gray-700">19.1</td>

            <td class="px-3 py-2 border-b border-gray-700">1.33</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">384 bit</td>

            <td class="px-3 py-2 border-b border-gray-700">1024</td>

            <td class="px-3 py-2 border-b border-gray-700">1056</td>

            <td class="px-3 py-2 border-b border-gray-700">659</td>

            <td class="px-3 py-2 border-b border-gray-700">33.6</td>

            <td class="px-3 py-2 border-b border-gray-700">2.12</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">768 bit</td>

            <td class="px-3 py-2 border-b border-gray-700">2048</td>

            <td class="px-3 py-2 border-b border-gray-700">1120</td>

            <td class="px-3 py-2 border-b border-gray-700">1292</td>

            <td class="px-3 py-2 border-b border-gray-700">61.6</td>

            <td class="px-3 py-2 border-b border-gray-700">3.66</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1536 bit</td>

            <td class="px-3 py-2 border-b border-gray-700">4096</td>

            <td class="px-3 py-2 border-b border-gray-700">1184</td>

            <td class="px-3 py-2 border-b border-gray-700">2551</td>

            <td class="px-3 py-2 border-b border-gray-700">114.9</td>

            <td class="px-3 py-2 border-b border-gray-700">6.93</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3072 bit</td>

            <td class="px-3 py-2 border-b border-gray-700">8192</td>

            <td class="px-3 py-2 border-b border-gray-700">1248</td>

            <td class="px-3 py-2 border-b border-gray-700">5052</td>

            <td class="px-3 py-2 border-b border-gray-700">213.4</td>

            <td class="px-3 py-2 border-b border-gray-700">13.20</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Unpadded SHA256 preimage  |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">512 bit</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">25400</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1376</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">19478</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">749.9</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">41.52</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Bulletproofs for proving knowledge of  <span class="math">x</span>  s.t.  <span class="math">H(x) = y</span>  for different sized  <span class="math">x</span> 's. The first 7 rows are for the Pedersen hash function and the final row is for SHA256. "Batch" is the marginal cost of verifying an additional proof, computed by batch-verifying 100 proofs, subtracting the cost to verify one, and dividing by 99.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 2: Timings for range proofs</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 3: Timings for arithmetic circuits (Pedersen Hash)</p>

    <p class="text-gray-300">Acknowledgments</p>

    <p class="text-gray-300">We thank Shashank Agrawal for coming up with the Bulletproof name (short like a bullet with bulletproof security assumptions). We thank Peter Dettman for pointing out the batch inversion trick. We thank Sean Bowe and Daira Hopwood for various optimizations applicable to arithmetic circuits for Pedersen hash functions. Further, we thank Philip Hayes, Cathie Yun, and the anonymous reviewers for helpful corrections. We also thank Jim Miller for pointing out a critical vulnerability in the Fiat-Shamir description of a prior version of the paper. This work was supported by NSF, DARPA, a grant from ONR, and the Simons Foundation.</p>

    <h2 id="sec-39" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AFK21] Thomas Attema, Serge Fehr, and Michael Klooß. Fiat-shamir transformation of multi-round interactive proofs. IACR Cryptol. ePrint Arch., page 1377, 2021.</li>

      <li>[AHIV17] Scott Ames, Carmit Hazay, Yuval Ishai, and Muthuramakrishnan Venkitasubramaniam. Ligero: Lightweight sublinear arguments without a trusted setup. In Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security, pages 2087–2104. ACM, 2017.</li>

      <li>[AKR^{+}13] Elli Androulaki, Ghassan O Karame, Marc Roeschlin, Tobias Scherer, and Srdjan Capkun. Evaluating User Privacy in Bitcoin. In Financial Cryptography, 2013.</li>

      <li>[And17] Oleg Andreev. Hidden in Plain Sight: Transacting Privately on a Blockchain. blog. chain.com, 2017.</li>

      <li>[BB04] Dan Boneh and Xavier Boyen. Short signatures without random oracles. In Advances in Cryptology - EUROCRYPT 2004, pages 56–73, 2004.</li>

      <li>[BBB^{+}18] Benedikt Bünz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Greg Maxwell. Bulletproofs: Short proofs for confidential transactions and more (conference version). In Security and Privacy (SP), 2018 IEEE Symposium on, pages 319–338. IEEE, 2018.</li>

      <li>[BCC^{+}16] Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe Petit. Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In Annual International Conference on the Theory and Applications of Cryptographic Techniques, pages 327–357. Springer, 2016.</li>

      <li>[BCCT12] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In Innovations in Theoretical Computer Science 2012, pages 326–349, 2012.</li>

      <li>[BCCT13] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. Recursive composition and bootstrapping for SNARKS and proof-carrying data. In Symposium on Theory of Computing Conference, STOC’13, Palo Alto, CA, USA, June 1-4, 2013, pages 111–120, 2013.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BCG^{+}17a] Eli Ben-Sasson, Alessandro Chiesa, Ariel Gabizon, Michael Riabzev, and Nicholas Spooner. Interactive oracle proofs with constant rate and query complexity. In 44th International Colloquium on Automata, Languages, and Programming, ICALP 2017, July 10-14, 2017, Warsaw, Poland, pages 40:1–40:15, 2017.</li>

      <li>[BCG^{+}17b] Jonathan Bootle, Andrea Cerulli, Essam Ghadafi, Jens Groth, Mohammad Hajiabadi, and Sune K. Jakobsen. Linear-time zero-knowledge proofs for arithmetic circuit satisfiability. Cryptology ePrint Archive, Report 2017/872, 2017. http://eprint.iacr.org/2017/872.</li>

      <li>[BDLO12] Daniel J Bernstein, Jeroen Doumen, Tanja Lange, and Jan-Jaap Oosterwijk. Faster batch forgery identification. In International Conference on Cryptology in India, pages 454–473. Springer, 2012.</li>

      <li>[BdM93] Josh Cohen Benaloh and Michael de Mare. One-way accumulators: A decentralized alternative to digital sinatures (extended abstract). In Advances in Cryptology - EUROCRYPT ’93, pages 274–285, 1993.</li>

      <li>[BG12] Stephanie Bayer and Jens Groth. Efficient zero-knowledge argument for correctness of a shuffle. In Annual International Conference on the Theory and Applications of Cryptographic Techniques, pages 263–280. Springer, 2012.</li>

      <li>[BGB17] Benedikt Bünz, Steven Goldfeder, and Joseph Bonneau. Proofs-of-delay and randomness beacons in ethereum. IEEE SECURITY and PRIVACY ON THE BLOCKCHAIN (IEEE S&amp;B), 2017.</li>

      <li>[BGG17] Sean Bowe, Ariel Gabizon, and Matthew D. Green. A multi-party protocol for constructing the public parameters of the pinocchio zk-snark. IACR Cryptology ePrint Archive, 2017:602, 2017.</li>

      <li>[BGR98] Mihir Bellare, Juan A. Garay, and Tal Rabin. Fast batch verification for modular exponentiation and digital signatures. In Kaisa Nyberg, editor, Advances in Cryptology — EUROCRYPT’98, pages 236–250, Berlin, Heidelberg, 1998. Springer Berlin Heidelberg.</li>

      <li>[BLS01] Dan Boneh, Ben Lynn, and Hovav Shacham. Short signatures from the weil pairing. In International Conference on the Theory and Application of Cryptology and Information Security, pages 514–532. Springer, 2001.</li>

      <li>[BMC^{+}15] Joseph Bonneau, Andrew Miller, Jeremy Clark, Arvind Narayanan, Joshua A. Kroll, and Edward W. Felten. Research Perspectives and Challenges for Bitcoin and Cryptocurrencies. IEEE Symposium on Security and Privacy, 2015.</li>

      <li>[BR93] Mihir Bellare and Phillip Rogaway. Random oracles are practical: A paradigm for designing efficient protocols. In CCS ’93, pages 62–73, 1993.</li>

      <li>[BSBC^{+}17] Eli Ben-Sasson, Iddo Bentov, Alessandro Chiesa, Ariel Gabizon, Daniel Genkin, Matan Hamilis, Evgenya Pergament, Michael Riabzev, Mark Silberstein, Eran</li>

    </ul>

    <p class="text-gray-300">Tromer, et al. Computational integrity with a public random string from quasilinear pcps. In Annual International Conference on the Theory and Applications of Cryptographic Techniques, pages 551–579. Springer, 2017.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BSBTHR18] Eli Ben-Sasson, Iddo Ben-Tov, Yinon Horesh, and Michael Riabzev. Scalable, transparent, and post-quantum secure computational integrity. https://eprint.iacr.org/2018/046.pdf, 2018.</li>

      <li>[BSCG^{+}13] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza. SNARKs for C: Verifying program executions succinctly and in zero knowledge. In CRYPTO, 2013.</li>

      <li>[BSCG^{+}14] Eli Ben-Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers, Eran Tromer, and Madars Virza. Zerocash: Decentralized anonymous payments from Bitcoin. In IEEE Symposium on Security and Privacy. IEEE, 2014.</li>

      <li>[CCs08] Jan Camenisch, Rafik Chaabouni, and abhi shelat. Efficient protocols for set membership and range proofs. Advances in Cryptology-ASIACRYPT 2008, pages 234–252, 2008.</li>

      <li>[CD98] Ronald Cramer and Ivan Damgård. Zero-knowledge proofs for finite field arithmetic, or: Can zero-knowledge be for free? In CRYPTO 98, pages 424–441. Springer, 1998.</li>

      <li>[CGGN17] Matteo Campanelli, Rosario Gennaro, Steven Goldfeder, and Luca Nizzardo. Zero-knowledge contingent payments revisited: Attacks and payments for services. Commun. ACM, 2017.</li>

      <li>[Cha82] David Chaum. Blind signatures for untraceable payments. In CRYPTO, 1982.</li>

      <li>[CHL05] Jan Camenisch, Susan Hohenberger, and Anna Lysyanskaya. Compact e-cash. In EUROCRYPT, 2005.</li>

      <li>[CLas10] Rafik Chaabouni, Helger Lipmaa, and abhi shelat. Additive combinatorics and discrete logarithm based range protocols. In Information Security and Privacy - 15th Australasian Conference, ACISP 2010, Sydney, Australia, July 5-7, 2010. Proceedings, pages 336–351, 2010.</li>

      <li>[CRR11] Ran Canetti, Ben Riva, and Guy N Rothblum. Practical delegation of computation using multiple servers. In Proceedings of the 18th ACM conference on Computer and communications security, pages 445–454. ACM, 2011.</li>

      <li>[DBB^{+}15] G Dagher, B Bünz, Joseph Bonneau, Jeremy Clark, and D Boneh. Provisions: Privacy-preserving proofs of solvency for bitcoin exchanges (full version). Technical report, IACR Cryptology ePrint Archive, 2015.</li>

      <li>[FS01] Jun Furukawa and Kazue Sako. An efficient scheme for proving a shuffle. In Crypto, volume 1, pages 368–387. Springer, 2001.</li>

      <li>[GGPR13] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct nizks without pcps. In Advances in Cryptology - EUROCRYPT 2013, pages 626–645, 2013.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[GH98] Oded Goldreich and Johan Håstad. On the complexity of interactive proofs with bounded communication. Inf. Process. Lett., 67(4):205–214, 1998.</li>

      <li>[GI08a] Jens Groth and Yuval Ishai. Sub-linear zero-knowledge argument for correctness of a shuffle. Advances in Cryptology–EUROCRYPT 2008, pages 379–396, 2008.</li>

      <li>[GI08b] Jens Groth and Yuval Ishai. Sub-linear zero-knowledge argument for correctness of a shuffle. In Advances in Cryptology - EUROCRYPT 2008, pages 379–396, 2008.</li>

      <li>[GKR08] Shafi Goldwasser, Yael Tauman Kalai, and Guy N Rothblum. Delegating computation: interactive proofs for muggles. In Proceedings of the fortieth annual ACM symposium on Theory of computing, pages 113–122. ACM, 2008.</li>

      <li>[Gor98] Daniel M Gordon. A survey of fast exponentiation methods. Journal of algorithms, 27(1):129–146, 1998.</li>

      <li>[Gro03] Jens Groth. A verifiable secret shuffle of homomorphic encryptions. In Public Key Cryptography, volume 2567, pages 145–160. Springer, 2003.</li>

      <li>[Gro05] Jens Groth. Non-interactive zero-knowledge arguments for voting. In International Conference on Applied Cryptography and Network Security, pages 467–482. Springer, 2005.</li>

      <li>[Gro10] Jens Groth. Short pairing-based non-interactive zero-knowledge arguments. In Advances in Cryptology - ASIACRYPT 2010, pages 321–340, 2010.</li>

      <li>[Gro16] Jens Groth. On the size of pairing-based non-interactive arguments. In Advances in Cryptology - EUROCRYPT 2016, pages 305–326, 2016.</li>

      <li>[GS08] Jens Groth and Amit Sahai. Efficient non-interactive proof systems for bilinear groups. In Advances in Cryptology - EUROCRYPT 2008, pages 415–432, 2008.</li>

      <li>[GVW02] Oded Goldreich, Salil P. Vadhan, and Avi Wigderson. On interactive proofs with a laconic prover. Computational Complexity, 11(1-2):1–53, 2002.</li>

      <li>[Jed16] TE Jedusor. Mimblewimble, 2016.</li>

      <li>[KMS^{+}16] Ahmed Kosba, Andrew Miller, Elaine Shi, Zikai Wen, and Charalampos Papamanthou. Hawk: The blockchain model of cryptography and privacy-preserving smart contracts. In Security and Privacy (SP), 2016 IEEE Symposium on, pages 839–858. IEEE, 2016.</li>

      <li>[KP95] Joe Kilian and Erez Petrank. An efficient non-interactive zero-knowledge proof system for NP with general assumptions. Electronic Colloquium on Computational Complexity (ECCC), 2(38), 1995.</li>

      <li>[Lin03] Yehuda Lindell. Parallel coin-tossing and constant-round secure two-party computation. J. Cryptology, 16(3):143–184, 2003.</li>

      <li>[Lip03] Helger Lipmaa. On diophantine complexity and statistical zero-knowledge arguments. In International Conference on the Theory and Application of Cryptology and Information Security, pages 398–415. Springer, 2003.</li>

    </ul>

    <p class="text-gray-300">[Max] G Maxwell. Zero knowledge contingent payment. 2011. URl: https://en. bitcoin. it/wiki/Zero_Knowledge_Contingent_Payment (visited on 05/01/2016).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Max13] Gregory Maxwell. CoinJoin: Bitcoin privacy for the real world. bitcointalk.org, August 2013.</li>

      <li>[Max16] Greg Maxwell. Confidential transactions. https://people.xiph.org/~greg/ confidential_values.txt, 2016.</li>

      <li>[Mic94] Silvio Micali. Cs proofs. In Foundations of Computer Science, 1994 Proceedings., 35th Annual Symposium on, pages 436–453. IEEE, 1994.</li>

      <li>[Mon] Monero - Private Digital Currency . https://getmonero.org/.</li>

      <li>[MP15] Gregory Maxwell and Andrew Poelstra. Borromean ring signatures. http://diyhpl. us/~bryan/papers2/bitcoin/Borromean%20ring%20signatures.pdf, 2015.</li>

      <li>[MPJ^{+}13] Sarah Meiklejohn, Marjori Pomarole, Grant Jordan, Kirill Levchenko, Damon McCoy, Geoffrey M Voelker, and Stefan Savage. A fistful of bitcoins: characterizing payments among men with no names. In IMC, 2013.</li>

      <li>[MSH17] Patrick McCorry, Siamak F Shahandashti, and Feng Hao. A smart contract for boardroom voting with maximum voter privacy. IACR Cryptology ePrint Archive, 2017:110, 2017.</li>

      <li>[Nak08] S Nakamoto. Bitcoin: A peer-to-peer electronic cash system. Unpublished, 2008.</li>

      <li>[Nef01] C Andrew Neff. A verifiable secret shuffle and its application to e-voting. In Proceedings of the 8th ACM conference on Computer and Communications Security, pages 116–125. ACM, 2001.</li>

      <li>[NM^{+}16] Shen Noether, Adam Mackenzie, et al. Ring confidential transactions. Ledger, 1:1–18, 2016.</li>

      <li>[P^{+}91] Torben P Pedersen et al. Non-interactive and information-theoretic secure verifiable secret sharing. In Crypto, volume 91, pages 129–140. Springer, 1991.</li>

      <li>[PBF^{+}] Andrew Poelstra, Adam Back, Mark Friedenbach, Gregory Maxwell, and Pieter Wuille. Confidential assets.</li>

      <li>[PHGR13] Bryan Parno, Jon Howell, Craig Gentry, and Mariana Raykova. Pinocchio: Nearly practical verifiable computation. In Security and Privacy (SP), 2013 IEEE Symposium on, pages 238–252. IEEE, 2013.</li>

      <li>[PHGR16] Bryan Parno, Jon Howell, Craig Gentry, and Mariana Raykova. Pinocchio: nearly practical verifiable computation. Commun. ACM, 59(2):103–112, 2016.</li>

      <li>[Pip80] Nicholas Pippenger. On the evaluation of powers and monomials. SIAM Journal on Computing, 9:230–250, 1980.</li>

      <li>[Poe] Andrew Poelstra. Mimblewimble.</li>

    </ul>

    <p class="text-gray-300">[RM] Tim Ruffing and Giulio Malavolta. Switch commitments: A safety switch for confidential transactions.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[RMSK14] Tim Ruffing, Pedro Moreno-Sanchez, and Aniket Kate. CoinShuffle: Practical decentralized coin mixing for Bitcoin. In ESORICS, 2014.</li>

      <li>[San99] Tomas Sander. Efficient accumulators without trapdoor extended abstract. Information and Communication Security, pages 252–262, 1999.</li>

      <li>[TR] Jason Teutsch and Christian Reitwießner. A scalable verification solution for blockchains.</li>

      <li>[vS13] Nicolas van Saberhagen. Cryptonote v 2. 0, 2013.</li>

      <li>[Wik21] Douglas Wikstöm. Special soundness in the random oracle model. IACR Cryptol. ePrint Arch., page 1265, 2021.</li>

      <li>[Woo14] Gavin Wood. Ethereum: A secure decentralized transaction ledger. http://gavwood.com/paper.pdf, 2014.</li>

      <li>[WTs^{+}] Riad S Wahby, Ioanna Tzialla, abhi shelat, Justin Thaler, and Michael Walfish. Doubly-efficient zksnarks without trusted setup.</li>

    </ul>

    <h2 id="sec-40" class="text-2xl font-bold">Appendix A A General Forking Lemma</h2>

    <p class="text-gray-300">We briefly describe the forking lemma of <em>[BCC^{+}16]</em> that will be needed in the proofs.</p>

    <p class="text-gray-300">Suppose that we have a <span class="math">(2\\mu+1)</span>-move public-coin argument with <span class="math">\\mu</span> challenges, <span class="math">x_{1},\\ldots,x_{\\mu}</span> in sequence. Let <span class="math">n_{i}\\geqslant 1</span> for <span class="math">1\\leqslant i\\leqslant\\mu</span>. Consider <span class="math">\\prod_{i=1}^{\\mu}n_{i}</span> accepting transcripts with challenges in the following tree format. The tree has depth <span class="math">\\mu</span> and <span class="math">\\prod_{i=1}^{\\mu}n_{i}</span> leaves. The root of the tree is labeled with the statement. Each node of depth <span class="math">i&lt;\\mu</span> has exactly <span class="math">n_{i}</span> children, each labeled with a distinct value of the <span class="math">i</span>th challenge <span class="math">x_{i}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This can be referred to as an <span class="math">(n_{1},\\ldots,n_{\\mu})</span>-tree of accepting transcripts. Given a suitable tree of accepting transcripts, one can compute a valid witness for our inner-product argument, range proof, and argument for arithmetic circuit satisfiability. This is a natural generalization of special-soundness for Sigma-protocols, where <span class="math">\\mu=1</span> and <span class="math">n=2</span>. Combined with Theorem 6, this shows that the protocols have witness-extended emulation, and hence, the prover cannot produce an accepting transcript unless they know a witness. For simplicity in the following lemma, we assume that the challenges are chosen uniformly from <span class="math">\\mathbb{Z}_{p}</span> where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\lambda<span class="math">, but any sufficiently large challenge space would suffice. The success probability of a cheating prover scales inversely with the size of the challenge space and linearly with the number of accepting transcripts that an extractor needs. Therefore if </span>\\prod_{i=1}^{\\mu}n_{i}<span class="math"> is negligible in </span>2^{\\lambda}$, then a cheating prover can create a proof that the verifier accepts with only negligible probability.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-41" class="text-base font-medium mt-4">Theorem 6 (Forking Lemma, <em>[BCC^{+}16]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">(\\text{Setup},\\mathcal{P},\\mathcal{V})</span> be a <span class="math">(2k+1)</span>-move, public coin interactive protocol. Let <span class="math">\\chi</span> be a witness extraction algorithm that succeeds with probability <span class="math">1-\\mu(\\lambda)</span> for some negligible function <span class="math">\\mu(\\lambda)</span> in extracting a witness from an <span class="math">(n_{1},\\ldots,n_{k})</span>-tree of accepting transcripts in probabilistic polynomial time. Assume that <span class="math">\\prod_{i=1}^{k}n_{i}</span> is bounded above by a polynomial in the security parameter <span class="math">\\lambda</span>. Then <span class="math">(\\text{Setup},\\mathcal{P},\\mathcal{V})</span> has witness-extended emulation.</p>

    <p class="text-gray-300">The theorem is slightly different than the one from <em>[BCC^{+}16]</em>. We allow the extractor <span class="math">\\chi</span> to fail with negligible probability. Whenever this happens the Emulator <span class="math">\\mathcal{E}</span> as defined by Definition 10 also simply fails. Even with this slight modification this slightly stronger lemma still holds as <span class="math">\\mathcal{E}</span> overall still only fails with negligible probability.</p>

    <h2 id="sec-42" class="text-2xl font-bold">Appendix B Proof of Theorem 1</h2>

    <h6 id="sec-43" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Perfect completeness follows directly because Protocol 1 converts an instance for relation (2) into an instance for relation (3). Protocol 2 is trivially complete. For witness extended emulation we show that there exists an efficient extractor <span class="math">\\chi</span> that uses <span class="math">n^{2}</span> transcripts, as needed by Theorem 6.</p>

    <p class="text-gray-300">First we show how to construct an extractor <span class="math">\\chi_{1}</span> for Protocol 2 which on input <span class="math">(\\mathbf{g},\\mathbf{h},u,P)</span>, either extracts a witness <span class="math">\\mathbf{a},\\mathbf{b}</span> such that relation (3) holds, or discovers a non-trivial discrete logarithm relation between <span class="math">\\mathbf{g},\\mathbf{h},u</span>. Note that the hardness of computing a discrete log relation between <span class="math">\\mathbf{g}^{\\prime},\\mathbf{h}^{\\prime},u</span> implies the hardness of computing one between <span class="math">\\mathbf{g},\\mathbf{h},u</span> as defined in Protocol 2. We will, therefore, use an inductive argument showing that in each step we either extract a witness or a discrete log relation.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If $n=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{g}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1<span class="math">, then the prover reveals the witness </span>(a,b)<span class="math"> in the protocol and the relation </span>P=g^{a}h^{b}u^{a\\cdot b}$ can simply be checked directly.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Next, we show that for each recursive step that on input <span class="math">(\\mathbf{g},\\mathbf{h},u,P)</span>, we can efficiently extract from the prover a witness <span class="math">\\mathbf{a},\\mathbf{b}</span> or a non-trivial discrete logarithm relation between <span class="math">\\mathbf{g},\\mathbf{h},u</span>. The extractor runs the prover to get <span class="math">L</span> and <span class="math">R</span>. Then, by rewinding the prover four times and giving it four challenges <span class="math">x_{1},x_{2},x_{3},x_{4}</span>, such that <span class="math">x_{i}\\neq\\pm x_{j}</span> for <span class="math">1\\leqslant i&lt;j\\leqslant 4</span>, the extractor obtains four pairs <span class="math">\\mathbf{a}^{\\prime}{}_{i},\\mathbf{b}^{\\prime}{}_{i}\\in\\mathbb{Z}_{p}^{n^{\\prime}}</span> such that</p>

    <p class="text-gray-300"><span class="math">L^{x_{i}^{2}}PR^{x_{i}^{-2}}=\\left(\\mathbf{g}^{x_{i}^{-1}}_{[:n^{\\prime}]}\\circ\\mathbf{g}^{x_{i}}_{[n^{\\prime}:]}\\right)^{\\mathbf{a}^{\\prime}{}_{i}}\\cdot\\left(\\mathbf{h}^{x_{i}}_{[:n^{\\prime}]}\\circ\\mathbf{h}^{x_{i}^{-1}}_{[n^{\\prime}:]}\\right)^{\\mathbf{b}^{\\prime}{}_{i}}\\cdot u^{\\langle\\mathbf{a}^{\\prime}{}_{i},\\mathbf{b}^{\\prime}{}_{i}\\rangle}\\qquad\\text{for }i=1,\\ldots,4.</span> (106)</p>

    <p class="text-gray-300">We can use the first three challenges <span class="math">x_{1},x_{2},x_{3}</span>, to compute <span class="math">\\nu_{1},\\nu_{2},\\nu_{3}\\in\\mathbb{Z}_{p}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\sum_{i=1}^{3}\\nu_{i}\\cdot x_{i}^{2}=1,\\quad\\sum_{i=1}^{3}\\nu_{i}=0,\\quad\\sum_{i=1}^{3}\\nu_{i}\\cdot x_{i}^{-2}=0.</span></p>

    <p class="text-gray-300">Then taking a linear combination of the first three equalities in (106), with <span class="math">\\nu_{1},\\nu_{2},\\nu_{3}</span> as the coefficients, we can compute <span class="math">\\mathbf{a}_{L},\\mathbf{b}_{L}\\in\\mathbb{Z}_{p}^{n}</span> and <span class="math">c_{L}\\in\\mathbb{Z}_{p}</span> such that <span class="math">L=\\mathbf{g}^{\\mathbf{a}_{L}}\\mathbf{h}^{\\mathbf{b}_{L}}u^{c_{L}}</span>. Repeating this process with different combinations, we can also compute <span class="math">\\mathbf{a}_{P},\\mathbf{a}_{R},\\mathbf{b}_{P},\\mathbf{b}_{R}\\in\\mathbb{Z}_{p}^{n}</span> and <span class="math">c_{P},c_{R}\\in\\mathbb{Z}_{p}</span> such that</p>

    <p class="text-gray-300"><span class="math">R=\\mathbf{g}^{\\mathbf{a}_{R}}\\mathbf{h}^{\\mathbf{b}_{R}}u^{c_{R}},\\qquad P=\\mathbf{g}^{\\mathbf{a}_{P}}\\mathbf{h}^{\\mathbf{b}_{P}}u^{c_{P}}.</span></p>

    <p class="text-gray-300">Now, for each <span class="math">x\\in\\{x_{1},x_{2},x_{3},x_{4}\\}</span> and the corresponding <span class="math">\\mathbf{a}^{\\prime},\\mathbf{b}^{\\prime}\\in\\mathbb{Z}_{p}^{n^{\\prime}}</span> we can rewrite (106) as:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{g}^{\\mathbf{a}_{L}\\cdot x^{2}+\\mathbf{a}_{P}+\\mathbf{a}_{R}\\cdot x^{-2}}\\cdot\\mathbf{h}^{\\mathbf{b}_{L}\\cdot x^{2}+\\mathbf{b}_{P}+\\mathbf{b}_{R}\\cdot x^{-2}}\\cdot u^{c_{L}\\cdot x^{2}+c_{P}+c_{R}\\cdot x^{-2}}=L^{x^{2}}PR^{x^{-2}}=\\mathbf{g}^{\\mathbf{a}^{\\prime}\\cdot x^{-1}}_{[:n^{\\prime}]}\\mathbf{g}^{\\mathbf{a}^{\\prime}\\cdot x}_{[n^{\\prime}:]}\\mathbf{h}^{\\mathbf{b}^{\\prime}\\cdot x}_{[:n^{\\prime}]}\\mathbf{h}^{\\mathbf{b}^{\\prime}\\cdot x^{-1}}_{[n^{\\prime}:]}u^{\\langle\\mathbf{a}^{\\prime},\\mathbf{b}^{\\prime}\\rangle}.</span></p>

    <p class="text-gray-300">This implies that</p>

    <p class="text-gray-300"><span class="math">\\mathbf{a}^{\\prime}\\cdot x^{-1}</span> <span class="math">=\\mathbf{a}_{L,[:n^{\\prime}]}\\cdot x^{2}+\\mathbf{a}_{P,[:n^{\\prime}]}+\\mathbf{a}_{R,[:n^{\\prime}]}\\cdot x^{-2}</span> <span class="math">\\mathbf{a}^{\\prime}\\cdot x</span> <span class="math">=\\mathbf{a}_{L,[n^{\\prime}:]}\\cdot x^{2}+\\mathbf{a}_{P,[n^{\\prime}:]}+\\mathbf{a}_{R,[n^{\\prime}:]}\\cdot x^{-2}</span> <span class="math">\\mathbf{b}^{\\prime}\\cdot x</span> <span class="math">=\\mathbf{b}_{L,[:n^{\\prime}]}\\cdot x^{2}+\\mathbf{b}_{P,[:n^{\\prime}]}+\\mathbf{b}_{R,[:n^{\\prime}]}\\cdot x^{-2}</span> (107) <span class="math">\\mathbf{b}^{\\prime}\\cdot x^{-1}</span> <span class="math">=\\mathbf{b}_{L,[n^{\\prime}:]}\\cdot x^{2}+\\mathbf{b}_{P,[n^{\\prime}:]}+\\mathbf{b}_{R,[n^{\\prime}:]}\\cdot x^{-2}</span> <span class="math">\\langle\\mathbf{a}^{\\prime},\\mathbf{b}^{\\prime}\\rangle</span> <span class="math">=c_{L}\\cdot x^{2}+c_{P}+c_{R}\\cdot x^{-2}</span></p>

    <p class="text-gray-300">If any of these equalities do not hold, we directly obtain a non-trivial discrete logarithm relation between the generators <span class="math">(g_{1},\\ldots,g_{n},h_{1},\\ldots,h_{n},u)</span>.</p>

    <p class="text-gray-300">If the equalities hold, we can deduce that for each challenge <span class="math">x\\in\\{x_{1},x_{2},x_{3},x_{4}\\}</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{a}_{L,[:n^{\\prime}]}\\cdot x^{3}+(\\mathbf{a}_{P,[:n^{\\prime}]}-\\mathbf{a}_{L,[n^{\\prime}:]})\\cdot x+(\\mathbf{a}_{R,[:n^{\\prime}]}-\\mathbf{a}_{P,[n^{\\prime}:]})\\cdot x^{-1}-\\mathbf{a}_{R,[n^{\\prime}:]}\\cdot x^{-3}=0</span> (108) <span class="math">\\mathbf{b}_{L,[n^{\\prime}:]}\\cdot x^{3}+(\\mathbf{b}_{P,[n^{\\prime}:]}-\\mathbf{b}_{L,[:n^{\\prime}]})\\cdot x+(\\mathbf{b}_{R,[n^{\\prime}:]}-\\mathbf{b}_{P,[:n^{\\prime}]})\\cdot x^{-1}-\\mathbf{b}_{R,[:n^{\\prime}]}\\cdot x^{-3}=0</span> (109)</p>

    <p class="text-gray-300">The equality (108) follows from the first two equations in (107). Similarly, (109) follows from the third and fourth equations in (107).</p>

    <p class="text-gray-300">The only way (108) and (109) hold for all 4 challenges <span class="math">x_{1},x_{2},x_{3},x_{4}\\in\\mathbb{Z}_{p}</span> is if</p>

    <p class="text-gray-300"><span class="math">\\mathbf{a}_{L,[:n^{\\prime}]}</span> <span class="math">=\\mathbf{a}_{R,[n^{\\prime}:]}=\\mathbf{b}_{R,[:n^{\\prime}]}=\\mathbf{b}_{L,[n^{\\prime}:]}=0,</span> <span class="math">\\mathbf{a}_{L,[n^{\\prime}:]}</span> <span class="math">=\\mathbf{a}_{P,[:n^{\\prime}]},\\qquad\\mathbf{a}_{R,[:n^{\\prime}]}=\\mathbf{a}_{P,[n^{\\prime}:]}</span> (110) <span class="math">\\mathbf{b}_{L,[:n^{\\prime}]}</span> <span class="math">=\\mathbf{b}_{P,[n^{\\prime}:]},\\qquad\\mathbf{b}_{R,[n^{\\prime}:]}=\\mathbf{b}_{P,[:n^{\\prime}]}.</span></p>

    <p class="text-gray-300">Plugging these relations into (107) we obtain that for every <span class="math">x\\in\\{x_{1},x_{2},x_{3},x_{4}\\}</span> we have that</p>

    <p class="text-gray-300"><span class="math">\\mathbf{a}^{\\prime}=\\mathbf{a}_{P,[:n^{\\prime}]}\\cdot x+\\mathbf{a}_{P,[n^{\\prime}:]}\\cdot x^{-1}\\qquad\\text{and}\\qquad\\mathbf{b}^{\\prime}=\\mathbf{b}_{P,[:n^{\\prime}]}\\cdot x^{-1}+\\mathbf{b}_{P,[n^{\\prime}:]}\\cdot x.</span></p>

    <p class="text-gray-300">Now, using these values we can see that the extracted <span class="math">c_{L},c_{P}</span> and <span class="math">c_{R}</span> have the expected form:</p>

    <p class="text-gray-300"><span class="math">c_{L}\\cdot x^{2}</span> <span class="math">+c_{P}+c_{R}\\cdot x^{-2}=\\langle\\mathbf{a}^{\\prime},\\mathbf{b}^{\\prime}\\rangle</span> <span class="math">=\\langle\\mathbf{a}_{P,[:n^{\\prime}]}\\cdot x+\\mathbf{a}_{P,[n^{\\prime}:]}\\cdot x^{-1}\\ ,\\ \\mathbf{b}_{P,[:n^{\\prime}]}\\cdot x^{-1}+\\mathbf{b}_{P,[n^{\\prime}:]}\\cdot x\\rangle</span> <span class="math">=\\langle\\mathbf{a}_{P,[:n^{\\prime}]},\\mathbf{b}_{P,[n^{\\prime}:]}\\rangle\\cdot x^{2}+\\langle\\mathbf{a}_{P,[:n^{\\prime}]},\\mathbf{b}_{P,[:n^{\\prime}]}\\rangle+\\langle\\mathbf{a}_{P,[n^{\\prime}:]},\\mathbf{b}_{P,[n^{\\prime}:]}\\rangle+\\langle\\mathbf{a}_{P,[n^{\\prime}:]},\\mathbf{b}_{P,[:n^{\\prime}]}\\rangle\\cdot x^{-2}</span> <span class="math">=\\langle\\mathbf{a}_{P,[:n^{\\prime}]},\\mathbf{b}_{P,[n^{\\prime}:]}\\rangle\\cdot x^{2}+\\langle\\mathbf{a}_{P},\\mathbf{b}_{P}\\rangle+\\langle\\mathbf{a}_{P,[n^{\\prime}:]},\\mathbf{b}_{P,[:n^{\\prime}]}\\rangle\\cdot x^{-2}.</span></p>

    <p class="text-gray-300">Since this relation holds for all <span class="math">x\\in\\{x_{1},x_{2},x_{3},x_{4}\\}</span> it must be that</p>

    <p class="text-gray-300"><span class="math">\\langle\\mathbf{a}_{P},\\mathbf{b}_{P}\\rangle=c_{P}.</span></p>

    <p class="text-gray-300">The extractor, thus, either extracts a discrete logarithm relation between the generators, or the witness <span class="math">(\\mathbf{a}_{P},\\mathbf{b}_{P})</span> for the relation (3).</p>

    <p class="text-gray-300">Using Theorem 6 we can see that the extractor uses <span class="math">4^{\\log_{2}(n)}=n^{2}</span> transcripts in total and thus runs in expected polynomial time in <span class="math">n</span> and <span class="math">\\lambda</span>.</p>

    <p class="text-gray-300">We now show that using Protocol 1 we can construct an extractor <span class="math">\\chi</span> that extracts a valid witness for relation (3). The extractor uses the extractor <span class="math">\\chi_{1}</span> of Protocol 2. On input <span class="math">(\\mathbf{g},\\mathbf{h},u,P,c)</span> <span class="math">\\chi</span> runs the prover with on a challenge <span class="math">x</span> and uses the extractor <span class="math">\\chi_{1}</span> to obtain a witness <span class="math">\\mathbf{a},\\mathbf{b}</span> such that:</p>

    <p class="text-gray-300"><span class="math">P\\cdot u^{x\\cdot c}=\\mathbf{g^{a}h^{b}}u^{x\\cdot\\langle\\mathbf{a},\\mathbf{b}\\rangle}</span>. Rewinding <span class="math">\\mathcal{P}</span>, supplying him with a different challenge <span class="math">x^{\\prime}</span> and rerunning the extractor <span class="math">\\chi_{1}</span> yields a second witness <span class="math">(\\mathbf{a}^{\\prime},\\mathbf{b}^{\\prime})</span>. Again the soundness of Protocol 2 implies that <span class="math">P\\cdot u^{x^{\\prime}\\cdot c}=\\mathbf{g^{a^{\\prime}}h^{b^{\\prime}}}u^{x^{\\prime}\\cdot\\langle\\mathbf{a}^{\\prime},\\mathbf{b}^{\\prime}\\rangle}</span>. From the two witnesses, we can compute:</p>

    <p class="text-gray-300"><span class="math">u^{(x-x^{\\prime})\\cdot c}=\\mathbf{g^{a-a^{\\prime}}h^{b-b^{\\prime}}}u^{x\\cdot\\langle\\mathbf{a},\\mathbf{b}\\rangle-x^{\\prime}\\cdot\\langle\\mathbf{a}^{\\prime},\\mathbf{b}^{\\prime}\\rangle}</span></p>

    <p class="text-gray-300">Unless <span class="math">\\mathbf{a}=\\mathbf{a}^{\\prime}</span> and <span class="math">\\mathbf{b}=\\mathbf{b}^{\\prime}</span> we get a not trivial discrete log relation between <span class="math">\\mathbf{g},\\mathbf{h}</span> and <span class="math">u</span>. Otherwise we get <span class="math">u^{(x-x^{\\prime})\\cdot c}=u^{(x-x^{\\prime})\\cdot\\langle\\mathbf{a},\\mathbf{b}\\rangle}\\implies c=\\langle\\mathbf{a},\\mathbf{b}\\rangle</span>. Thus, <span class="math">(\\mathbf{a},\\mathbf{b})</span> is a valid witness for relation (3). Since <span class="math">\\chi</span> forks the prover once, and uses the efficient extractor <span class="math">\\chi_{1}</span> twice, it is also efficient. Using the forking lemma (Theorem 6) we conclude that the protocol has witness extended emulation. ∎</p>

    <h2 id="sec-44" class="text-2xl font-bold">Appendix C Proof of Theorem 3</h2>

    <h6 id="sec-45" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Perfect completeness follows from the fact that <span class="math">t_{0}=\\delta(y,z)+z^{2}\\cdot\\langle\\mathbf{z}^{m},\\mathbf{v}\\rangle</span> for all valid witnesses. To prove perfect honest-verifier zero-knowledge we construct a simulator that produces a distribution of proofs for a given statement <span class="math">(g,h\\in\\mathbb{G},\\mathbf{g},\\mathbf{h}\\in\\mathbb{G}^{n\\cdot m},\\mathbf{V}\\in\\mathbb{G}^{m})</span> that is indistinguishable from valid proofs produced by an honest prover interacting with an honest verifier. The simulator chooses all proof elements and challenges according to the randomness supplied by the adversary from their respective domains or computes them directly as described in the protocol. <span class="math">S</span> and <span class="math">T_{1}</span> are computed according to the verification equations, i.e.:</p>

    <p class="text-gray-300"><span class="math">S</span> <span class="math">=(h^{-\\mu}\\cdot A\\cdot\\mathbf{g}^{-z\\cdot\\mathbf{1}^{n\\cdot m}-\\mathbf{l}}\\cdot\\mathbf{h}^{\\prime}{}^{z\\cdot\\mathbf{y}^{n\\cdot m}}-\\mathbf{r}\\prod_{j=1}^{m}\\mathbf{h}^{\\prime}{}_{[(j-1)\\cdot m:j\\cdot m]}^{z^{j+1}\\cdot\\mathbf{2}^{n}})^{-x^{-1}}</span> <span class="math">T_{1}</span> <span class="math">=(h^{-\\tau_{x}}g^{\\delta(y,z)-\\hat{t}}\\cdot\\mathbf{V}^{z^{2}\\cdot\\mathbf{z}^{m}}\\cdot T_{2}^{x^{2}})^{-x^{-1}}</span></p>

    <p class="text-gray-300">Finally, the simulator runs the inner-product argument with the simulated witness <span class="math">(\\mathbf{l},\\mathbf{r})</span> and the verifier’s randomness. All elements in the proof are either independently randomly distributed or their relationship is fully defined by the verification equations. The inner product argument remains zero knowledge as we can successfully simulate the witness, thus revealing the witness or leaking information about it does not change the zero-knowledge property of the overall protocol. The simulator runs in time <span class="math">O(\\mathcal{V}+\\mathcal{P}_{\\textsf{InnerProduct}})</span> and is thus efficient.</p>

    <p class="text-gray-300">In order to prove computational witness extended emulation, we construct an extractor <span class="math">\\chi</span> as follows. The extractor <span class="math">\\chi</span> runs the prover with <span class="math">n\\cdot m</span> different values of <span class="math">y</span>, <span class="math">(m+2)</span> different values of <span class="math">z</span>, and <span class="math">3</span> different values of the challenge <span class="math">x</span>. Additionally it invokes the extractor for the inner product argument on each of the transcripts. This results in <span class="math">3\\cdot(m+2)\\cdot n\\cdot m\\cdot O(n^{2})</span> valid proof transcripts.</p>

    <p class="text-gray-300">For each transcript the extractor <span class="math">\\chi</span> first runs the extractor <span class="math">\\chi_{\\textsf{InnerProduct}}</span> for the inner-product argument to extract a witness <span class="math">\\mathbf{l},\\mathbf{r}</span> to the inner product argument such that <span class="math">h^{\\mu}\\mathbf{g^{l}h^{r}}=P\\wedge\\langle\\mathbf{l},\\mathbf{r}\\rangle=\\hat{t}</span>. Using 2 valid transcripts and extracted inner product argument witnesses for different <span class="math">x</span> challenges, we can compute linear combinations of (67) such that in order to compute <span class="math">\\alpha,\\rho,\\mathbf{a}_{L},\\mathbf{a}_{R},\\mathbf{s}_{L},\\mathbf{s}_{R}</span> such that <span class="math">A=h^{\\alpha}\\mathbf{g^{a}}_{L}\\mathbf{h^{a}}_{R}</span>, as well as <span class="math">S=h^{\\rho}\\mathbf{g^{s}}_{L}\\mathbf{h^{s}}_{R}</span>.</p>

    <p class="text-gray-300">If for any other set of challenges <span class="math">(x,y,z)</span> the extractor can compute a different representation of <span class="math">A</span> or <span class="math">S</span>, then this yields a non-trivial discrete logarithm relation between independent generators <span class="math">h,\\mathbf{g},\\mathbf{h}</span> which contradicts the discrete logarithm assumption.</p>

    <p class="text-gray-300">Using these representations of <span class="math">A</span> and <span class="math">S</span>, as well as <span class="math">\\mathbf{l}</span> and <span class="math">\\mathbf{r}</span>, we then find that for all challenges <span class="math">x, y</span> and <span class="math">z</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{l}</span> <span class="math">=\\mathbf{a}_{L}-z\\cdot\\mathbf{1}^{n\\cdot m}+\\mathbf{s}_{L}\\cdot x</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathbf{r}</span> $=\\mathbf{y}^{n\\cdot m}\\circ(\\mathbf{a}_{R}+z\\cdot\\mathbf{1}^{n\\cdot m}+\\mathbf{s}_{R}\\cdot x)+\\sum_{j=1}^{m}z^{1+j}\\cdot\\left(0^{(j-1)\\cdot n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{2}^{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{(m-j)\\cdot n}\\right)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If these equalities do not hold for all challenges and <span class="math">\\mathbf{l},\\mathbf{r}</span> from the transcript, then we have two distinct representations of the same group element using a set of independent generators. This would be a non-trivial discrete logarithm relation.</p>

    <p class="text-gray-300">For given values of <span class="math">y</span> and <span class="math">z</span>, we now takes 3 transcripts with different <span class="math">x</span>’s and uses linear combinations of equation (72) to compute <span class="math">\\tau_{1},\\tau_{2},t_{1},t_{2}</span> such that</p>

    <p class="text-gray-300"><span class="math">T_{1}=g^{t_{1}}h^{\\tau_{1}}\\wedge T_{2}=g^{t_{1}}h^{\\tau_{2}}</span></p>

    <p class="text-gray-300">Additionally we can compute a <span class="math">v,\\gamma</span> such that <span class="math">g^{v}h^{\\gamma}=\\prod_{j=1}^{m}V_{j}^{z^{j+1}}</span> Repeating this for <span class="math">m</span> different <span class="math">z</span> challenges, we can compute <span class="math">(v_{j},\\gamma_{j})_{j=1}^{m}</span> such that <span class="math">g^{v_{j}}h^{\\gamma_{j}}=V_{j}\\ \\forall j\\in[1,m]</span>. If for any transcript <span class="math">\\delta(y,z)+\\sum_{j=1}^{m}z^{j+2}\\cdot v_{j}+t_{1}\\cdot x+t_{2}\\cdot x^{2}\\neq\\hat{t}</span> then this directly yields a discrete log relation between <span class="math">g</span> and <span class="math">h</span>, i.e. a violation of the binding property of the Pedersen commitment. If not, then for all <span class="math">y,z</span> challenges and 3 distinct challenges <span class="math">X=x_{j},j\\in[1,3]</span>:</p>

    <p class="text-gray-300"><span class="math">\\sum_{i=0}^{2}t_{i}\\cdot X^{i}-p(X)=0</span></p>

    <p class="text-gray-300">with <span class="math">t_{0}=\\delta(y,z)+\\sum_{j=1}^{m}z^{j+2}\\cdot\\langle\\mathbf{v}_{j},\\mathbf{2}^{n}\\rangle</span> and <span class="math">p(X)=\\sum_{i=0}^{2}p_{i}\\cdot X^{i}=\\langle l(X),r(X)\\rangle</span>. Since the polynomial <span class="math">t(X)-p(X)</span> is of degree 2, but has at least 3 roots (each challenge <span class="math">x_{j}</span>), it is necessarily the zero polynomial, i.e. <span class="math">t(X)=\\langle l(X),r(X)\\rangle</span>.</p>

    <p class="text-gray-300">Since this implies that <span class="math">t_{0}=p_{0}</span>, the following holds for all <span class="math">y,z</span> challenges:</p>

    <p class="text-gray-300"><span class="math">\\sum_{j=1}^{m}z^{j+2}\\cdot\\langle\\mathbf{v}_{j},\\mathbf{2}^{n}\\rangle+\\delta(y,z)</span> <span class="math">=</span> <span class="math">\\langle\\mathbf{a}_{L},\\mathbf{y}^{n\\cdot m}\\circ\\mathbf{a}_{R}\\rangle+z\\cdot\\langle\\mathbf{a}_{L}-\\mathbf{a}_{R},\\mathbf{y}^{n\\cdot m}\\rangle+\\sum_{j=1}^{m}z^{j+1}\\langle\\mathbf{a}_{L,[(j-1)\\cdot n:j\\cdot n]},\\mathbf{2}^{n}\\rangle</span> <span class="math">-z^{2}\\cdot\\langle\\mathbf{1}^{n\\cdot m},\\mathbf{y}^{n\\cdot m}\\rangle-\\sum_{j=1}^{m}z^{j+2}\\cdot\\langle\\mathbf{1}^{n},\\mathbf{2}^{n}\\rangle\\in\\mathbb{Z}_{p}</span></p>

    <p class="text-gray-300">If this equality holds for <span class="math">n\\cdot m</span> distinct <span class="math">y</span> challenges and <span class="math">m+2</span> distinct <span class="math">z</span> challenges, then we can infer the following.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{a}_{L}\\circ\\mathbf{a}_{R}</span> <span class="math">=\\mathbf{0}^{n\\cdot m}</span> <span class="math">\\in\\mathbb{Z}_{p}^{n\\cdot m}</span> <span class="math">\\mathbf{a}_{R}</span> <span class="math">=\\mathbf{a}_{L}-\\mathbf{1}^{n\\cdot m}</span> <span class="math">\\in\\mathbb{Z}_{p}^{n\\cdot m}</span> <span class="math">v_{j}</span> <span class="math">=\\langle\\mathbf{a}_{L,[(j-1)\\cdot n:j\\cdot n]},\\mathbf{2}^{n}\\rangle</span> <span class="math">\\in\\mathbb{Z}_{p}\\forall j\\in[1,m]</span></p>

    <p class="text-gray-300">The first two equations imply that <span class="math">\\mathbf{a}_{L}\\in\\{0,1\\}^{n\\cdot m}</span>. The last equation imply that <span class="math">v_{j}\\in[0,2^{n-1}]</span> for all <span class="math">j\\in[1,m]</span>. Since <span class="math">g^{v_{i}}h^{\\gamma_{i}}=V_{i}\\quad\\forall j\\in[1,m]</span> we have that <span class="math">(\\mathbf{v},\\boldsymbol{\\gamma})</span> is valid witness for relation (69). The extractor rewinds the prover <span class="math">3\\cdot(m+2)\\cdot n\\cdot m\\cdot O(n^{2})</span> times. Extraction is efficient and the number of transcripts is polynomial in <span class="math">\\lambda</span> because <span class="math">n,m=O(\\lambda)</span>. Note that extraction either returns a valid witness or a discrete logarithm relation between independently chosen generators. We define <span class="math">\\chi^{\\prime}</span> being equal to <span class="math">\\chi</span> but failing whenever <span class="math">\\chi</span> extracts a discrete log relation. By the Discrete Log Relation assumption this happens with at most negligible probability. We can, therefore, apply the forking lemma and see that computational witness emulation holds.</p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">D Proof of Theorem 4</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Perfect completeness follows from the fact that</p>

    <p class="text-gray-300"><span class="math">t_{2}\\,=\\,\\delta(y,z)+\\langle\\mathbf{z}_{[1:]}^{Q+1},\\mathbf{W}_{L}\\cdot\\mathbf{a}_{L}+\\mathbf{W}_{R}\\cdot\\mathbf{a}_{R}+\\mathbf{W}_{O}\\cdot\\mathbf{a}_{O}\\rangle\\,=\\,\\delta(y,z)+\\langle\\mathbf{z}_{[1:]}^{Q+1},\\mathbf{W}_{V}\\cdot\\mathbf{v}+\\mathbf{c}\\rangle</span> (111)</p>

    <p class="text-gray-300">whenever the prover knows a witness to the relation and is honest.</p>

    <p class="text-gray-300">To prove perfect honest-verifier zero-knowledge we construct an efficient simulator that produces a distribution of proofs for a given statement</p>

    <p class="text-gray-300"><span class="math">\\left(\\begin{array}[]{c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c\\end{array}\\right)</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">\\left(\\begin{array}[]{c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c}\\end{array}\\right)</span></p>

    <p class="text-gray-300">and the verifier’s randomness that is indistinguishable from valid proofs produced by an honest prover interacting with an honest verifier. The simulator acts as follows:</p>

    <p class="text-gray-300">Compute <span class="math">x,y,z</span> using <span class="math">\\mathcal{V}</span>’s randomness (112)</p>

    <p class="text-gray-300"><span class="math">\\mu,\\tau_{x}\\xleftarrow{\\</span>}\\mathbb{Z}_{p}$ (113)</p>

    <p class="text-gray-300"><span class="math">\\mathbf{l},\\mathbf{r}\\xleftarrow{\\</span>}\\mathbb{Z}_{p}^{n}$ (114)</p>

    <p class="text-gray-300"><span class="math">\\hat{t}=\\langle\\mathbf{l},\\mathbf{r}\\rangle</span> (115)</p>

    <p class="text-gray-300"><span class="math">A_{I},A_{O}\\xleftarrow{\\</span>}\\mathbb{G}$ (116)</p>

    <p class="text-gray-300"><span class="math">S=\\left(\\begin{array}[]{c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c}\\end{array}\\right)</span> (117)</p>

    <p class="text-gray-300"><span class="math">T_{3},T_{4},T_{5},T_{6}\\xleftarrow{\\</span>}\\mathbb{G}$ (118)</p>

    <p class="text-gray-300"><span class="math">T_{1}=\\left(\\begin{array}[]{c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c}\\end{array}\\right)</span> (119)</p>

    <p class="text-gray-300">Output: <span class="math">(A_{I},A_{O},S;y,z;T_{1},(T_{i})_{3}^{6};x;\\tau_{x},\\mu,\\hat{t},\\mathbf{l},\\mathbf{r})</span> (120)</p>

    <p class="text-gray-300">The values <span class="math">A_{I},A_{O},\\mathbf{l},\\mathbf{r},\\mu,\\tau_{x}</span> produced by an honest prover interacting with an honest verifier are random independent elements, i.e. if <span class="math">\\mathbf{s},\\rho,\\alpha,\\tau_{1},(\\tau_{i})_{3}^{6},\\rho</span> as well as <span class="math">x,y,z</span> are chosen independently and randomly. <span class="math">\\hat{t}</span> is the inner product of <span class="math">\\mathbf{l},\\mathbf{r}</span> as in any verifying transcript. The simulated <span class="math">S</span> is fully defined by equations (92). The honestly produced <span class="math">T</span> are perfectly hiding commitments and as such random group elements. Their internal relation given <span class="math">\\hat{t}</span> and <span class="math">\\tau_{x}</span> is fully defined by equation (90), which is ensured by computing <span class="math">T_{1}</span> accordingly. Therefore, the transcript of the proof is identically distributed to an honestly computed proof with uniformly selected challenges. The simulator runs in time <span class="math">O(\\mathcal{V})</span> and is thus efficient.</p>

    <p class="text-gray-300">In order to prove computational witness extended emulation we construct an extractor <span class="math">\\chi</span> as follows. The <span class="math">\\chi</span> runs the prover with <span class="math">n</span> different <span class="math">y</span>, <span class="math">(Q+1)</span> different <span class="math">z</span> and <span class="math">7</span> different <span class="math">x</span> challenges. This results in <span class="math">7\\cdot(Q+1)\\cdot n</span> valid proof transcripts. We takes <span class="math">3</span> valid transcripts for <span class="math">x\\in\\{x_{1},x_{2},x_{3}\\}</span> and fixed <span class="math">y</span> and <span class="math">z</span>. From the transmitted <span class="math">\\mathbf{l},\\mathbf{r},\\hat{t}</span> for each combination of challenges, we compute <span class="math">\\nu_{1},\\nu_{2},\\nu_{3}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\sum_{i=1}^{3}\\nu_{i}\\cdot x_{i}=1\\wedge\\sum_{i=1}^{3}\\nu_{i}\\cdot x^{2}=\\sum_{i=1}^{3}\\nu_{i}\\cdot x_{i}^{3}=0</span></p>

    <p class="text-gray-300">Taking the linear combinations of equation (92) with <span class="math">(\\nu_{1},\\nu_{2},\\nu_{3})</span> as coefficients, we compute <span class="math">\\alpha\\in\\mathbb{Z}_{p},\\mathbf{a}_{L},\\mathbf{a}_{R}\\in\\mathbb{Z}_{p}^{n}</span> such that <span class="math">h^{\\alpha}\\mathbf{g}^{\\mathbf{a}_{L}}\\mathbf{h}^{\\mathbf{a}_{R}}=A_{I}</span>. If for any other set of challenges we can compute</p>

    <p class="text-gray-300">different <span class="math">\\alpha&#x27;, \\mathbf{a}_L&#x27;, \\mathbf{a}_R&#x27;</span> such that <span class="math">h^{\\alpha&#x27;} \\mathbf{g}^{\\mathbf{a}_L&#x27;} \\mathbf{h}^{\\mathbf{a}_R&#x27;} = A_I = h^\\alpha \\mathbf{g}^{\\mathbf{a}_L} \\mathbf{h}^{\\mathbf{a}_R}</span>, then this yields a non-trivial discrete log relation between independent generators <span class="math">h, \\mathbf{g}, \\mathbf{h}</span> which contradicts the discrete log relation assumption. Similarly, we can use the same challenges and equation (92) to compute unique <span class="math">\\beta, \\rho \\in \\mathbb{Z}_p, \\mathbf{a}_{O,L}, \\mathbf{a}_{O,R}, \\mathbf{s}_L, \\mathbf{s}_R \\in \\mathbb{Z}_p^n</span> such that <span class="math">h^\\beta \\mathbf{g}^{\\mathbf{a}_{O,L}} \\mathbf{h}^{\\mathbf{a}_{O,R}} = A_O</span> and <span class="math">h^\\rho \\mathbf{g}^{\\mathbf{a}_L} \\mathbf{h}^{\\mathbf{s}_R} = S</span>.</p>

    <p class="text-gray-300">Using Equation (92), we can replace <span class="math">A_I, A_O, S</span> with the computed representations and read <span class="math">\\mathbf{l}, \\mathbf{r}, \\hat{t}</span> from the transcripts. We then find that for all challenges <span class="math">x, y, z</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf{l} = \\mathbf{a}_L \\cdot x + \\mathbf{a}_{O,L} \\cdot x^2 + \\mathbf{y}^{-n} \\circ (\\mathbf{z}_{[1:]}^{Q+1} \\cdot \\mathbf{W}_R) \\cdot X + \\mathbf{s}_L \\cdot x^3 \\\\ \\mathbf{r} = \\mathbf{y}^n \\circ \\mathbf{a}_R \\cdot x - \\mathbf{y}^n + \\mathbf{z}_{[1:]}^{Q+1} \\cdot (\\mathbf{W}_L \\cdot x + \\mathbf{W}_O) + \\mathbf{y}^n \\circ \\mathbf{a}_{O,R} \\cdot x^2 + \\mathbf{y}^n \\circ \\mathbf{s}_R \\cdot x^3 \\\\ \\hat{t} = \\langle \\mathbf{l}, \\mathbf{r} \\rangle \\\\ \\end{array}</span></div>

    <p class="text-gray-300">If these equalities do not hold for all challenges and <span class="math">\\mathbf{l},\\mathbf{r}</span> from the transcript, then we necessarily have a non-trivial discrete log relation between the generators <span class="math">\\mathbf{g},\\mathbf{h}</span> and <span class="math">h</span>.</p>

    <p class="text-gray-300">We now show that <span class="math">t_2</span> indeed has the form described in (111). For a given <span class="math">y, z</span> the extractor takes 6 transcripts with different <span class="math">x</span>'s and uses linear combinations of equation (90) to compute <span class="math">(\\tau_i, t_i), i \\in [1,3,\\ldots,6]</span> such that <span class="math">T_i = g^{t_i} h^{\\tau_i}</span>. Note that the linear combinations have to cancel out the other <span class="math">T_i^{x^i}</span> terms as well as <span class="math">(\\mathbf{v}^{\\mathbf{z}_{[1:]}^{Q+1}} \\cdot \\mathbf{W}_V)^{x^2}</span>. Using these <span class="math">(\\tau_i, t_i)</span> we can compute <span class="math">v, \\gamma</span> such that <span class="math">g^v h^\\gamma = \\mathbf{V}^{\\mathbf{z}_{[1:]}^{Q+1}} \\cdot \\mathbf{W}_V</span>. Repeating this for <span class="math">m</span> different <span class="math">z</span> challenges, we can compute <span class="math">(v_j, \\gamma_j)_{j=1}^m</span> using linear combinations of <span class="math">g^v h^\\gamma = \\mathbf{V}^{\\mathbf{z}_{[1:]}^{Q+1}} \\cdot \\mathbf{W}_V</span> such that <span class="math">g^{v_j} h^{\\gamma_j} = V_j \\forall j \\in [1,m]</span>. This will however only succeed if the weight vectors <span class="math">\\mathbf{w}_{V,j}</span> are linearly independent, i.e. if the matrix <span class="math">\\mathbf{W}_V</span> has rank <span class="math">m</span>. This necessarily implies that <span class="math">Q \\geqslant m</span>. If for any transcript <span class="math">t_1 \\cdot x + \\sum_{i=3}^6 t_i \\cdot x^i + x^2 \\cdot (\\langle \\mathbf{z}_{[1:]}^{Q+1}, \\mathbf{W}_V \\cdot \\mathbf{v} + \\mathbf{c} \\rangle + \\delta(y,z)) \\neq \\hat{t}</span> then this directly yields a discrete log relation between <span class="math">g</span> and <span class="math">h</span>.</p>

    <p class="text-gray-300">If not, then for all <span class="math">y,z</span> challenges and 7 distinct challenges <span class="math">x = x_{j}, j \\in [1,7]</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=1}^6 t_i \\cdot x - p(x) = 0 \\tag{121}</span></div>

    <p class="text-gray-300">with <span class="math">t_2 = \\langle \\mathbf{z}_{[1:]}^{Q+1}, \\mathbf{W}_V \\cdot \\mathbf{v} + \\mathbf{c} \\rangle + \\delta(y,z)</span> and <span class="math">p(x) = \\sum_{i=1}^6 p_i \\cdot x^i = \\langle \\mathbf{l}(x), \\mathbf{r}(x) \\rangle</span>. Since the polynomial <span class="math">t(x) - p(x)</span> is of degree 6, but has at least 7 roots (each challenge <span class="math">x_j</span>), it is necessarily the zero polynomial, i.e. <span class="math">t(x) = \\langle \\mathbf{l}(x), \\mathbf{r}(x) \\rangle</span>. Finally, we show that this equality implies that we can extract a witness <span class="math">(\\mathbf{a}_L, \\mathbf{a}_R, \\mathbf{a}_O \\in \\mathbb{Z}_p^n, \\mathbf{v}, \\boldsymbol{\\gamma} \\in \\mathbb{Z}_p^m)</span> which satisfies the relation.</p>

    <p class="text-gray-300">The quadratic coefficient of <span class="math">p</span> is:</p>

    <div class="my-4 text-center"><span class="math-block">p_2 = \\langle \\mathbf{a}_L, \\mathbf{y}^n \\circ \\mathbf{a}_R \\rangle - \\langle \\mathbf{a}_{O,L}, \\mathbf{y}^n \\rangle + \\langle \\mathbf{z}_{[1:]}^{Q+1}, \\mathbf{W}_L \\cdot \\mathbf{a}_L + \\mathbf{W}_{R,q} \\cdot \\mathbf{a}_R + \\mathbf{W}_O \\cdot \\mathbf{a}_{O,L} \\rangle + \\delta(y,z) \\in \\mathbb{Z}_p</span></div>

    <p class="text-gray-300">The polynomial equality implies that any challenge <span class="math">y, z</span>, <span class="math">p_2 = t_2</span>. Using a fixed <span class="math">y</span> and <span class="math">(Q + 1)</span> different <span class="math">z</span> challenges we can infer that all coefficients of <span class="math">p_2(z) - t_2(z)</span> have to be zero. Using <span class="math">n</span> different <span class="math">y</span> challenges, i.e. <span class="math">n \\cdot (Q + 1)</span> total transcripts we can infer the following equalities:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{a}_L \\circ \\mathbf{a}_R - \\mathbf{a}_{O,L} = \\mathbf{0}^n \\in \\mathbb{Z}_p^n \\tag{122}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{W}_L \\cdot \\mathbf{a}_L + \\mathbf{W}_R \\cdot \\mathbf{a}_R + \\mathbf{W}_O \\cdot \\mathbf{a}_{O,L} = \\mathbf{W}_V \\cdot \\mathbf{v} + \\mathbf{c} \\in \\mathbb{Z}_p^Q \\tag{123}</span></div>

    <p class="text-gray-300">From equation (122) we can directly infer that <span class="math">\\mathbf{a}_L \\circ \\mathbf{a}_R = \\mathbf{a}_{O,L}</span>. Equations (123) are exactly the linear constraints on the circuit gates.</p>

    <p class="text-gray-300">Defining <span class="math">\\mathbf{a}_O = \\mathbf{a}_{O,L}</span>, we can conclude that <span class="math">(\\mathbf{a}_L, \\mathbf{a}_R, \\mathbf{a}_O, \\mathbf{v}, \\boldsymbol{\\gamma})</span> is indeed a valid witness. Extraction is efficient and the number of transcripts is polynomial in <span class="math">\\lambda</span> because <span class="math">n, m = O(\\lambda)</span>. Note</p>

    <p class="text-gray-300">45</p>

    <p class="text-gray-300">that extraction either returns a valid witness or a non-trivial discrete logarithm relation between independently chosen generators. We define <span class="math">\\chi^{\\prime}</span> being equal to <span class="math">\\chi</span> but failing whenever <span class="math">\\chi</span> extracts a discrete log relation. By the discrete log relation assumption this happens with at most negligible probability. We can, therefore, apply the forking lemma and see that computational witness emulation holds. ∎</p>`;
---

<BaseLayout title="Bulletproofs: Short Proofs for Confidential Transactions and... (2017/1066)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2017 &middot; eprint 2017/1066
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
