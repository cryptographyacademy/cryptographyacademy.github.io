---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2001/108';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Design and Analysis of Practical Public-Key Encryption Schemes Secure against Adaptive Chosen Ciphertext Attack';
const AUTHORS_HTML = 'Ronald Cramer, Victor Shoup';

const CONTENT = `    <p class="text-gray-300">Ronald Cramer Dept. of Computer Science, Aarhus University cramer@brics.dk</p>

    <p class="text-gray-300">Victor Shoup IBM Zurich Research Laboratory sho@zurich.ibm.com</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">A new public key encryption scheme, along with several variants, is proposed and analyzed. The scheme and its variants are quite practical, and are proved secure against adaptive chosen ciphertext attack under standard intractability assumptions. These appear to be the first public-key encryption schemes in the literature that are simultaneously practical and provably secure.</p>

    <p class="text-gray-300">This paper is a significantly revised and extended version of the extended abstract “A practical public key cryptosystem provably secure against adaptive chosen ciphertext attack” [R. Cramer and V. Shoup, in <em>Advances in Cryptology – Crypto ’98</em>], and also includes results originally presented in the extended abstract “Using hash functions as a hedge against chosen ciphertext attack” [V. Shoup, in <em>Advances in Cryptology – Eurocrypt 2000</em>].</p>

    <p class="text-gray-300">#</p>

    <p class="text-gray-300">1 Introduction 1 1.1 Chosen ciphertext security 1 1.2 Previous work 2 1.3 Further progress 3 1.4 Outline of paper 3</p>

    <p class="text-gray-300">2 Some Preliminaries 5 2.1 Basic mathematical notation 5 2.2 Algorithms and probability spaces 5 2.3 Statistical distance and negligible functions 6</p>

    <p class="text-gray-300">3 Secure Public Key Encryption 6 3.1 Public Key Encryption Schemes 6 3.2 Security against adaptive chosen ciphertext attack 8 3.3 Application of the definition of security 9 3.4 Further discussion 10</p>

    <p class="text-gray-300">4 Intractability Assumptions Related to the Discrete Logarithm Problem 11 4.1 Computational group schemes 11 4.2 Examples of appropriate computational group schemes 12 4.3 Intractability assumptions 14 4.4 Further discussion 17</p>

    <p class="text-gray-300">5 Target Collision Resistant Hash Functions 17 5.1 Further discussion 18</p>

    <p class="text-gray-300">6 The New Encryption Scheme: Basic Version 19 6.1 Description of the scheme 19 6.2 Security analysis of the scheme 21 6.3 Two variations 28 6.4 A hash-free variant 31</p>

    <p class="text-gray-300">7 Hybrid Encryption 35 7.1 Key encapsulation 36 7.2 One-time symmetric-key encryption 37 7.3 A hybrid construction 41</p>

    <p class="text-gray-300">8 Key Derivation Functions 42 8.1 Constructions 43</p>

    <p class="text-gray-300">9 The New Encryption Scheme: Hybrid Version 44 9.1 Description of the Scheme 44 9.2 Security analysis of the scheme 46 9.3 Two variations 50</p>

    <p class="text-gray-300">10 Further Security Considerations of Scheme CS3b 50</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>10.1 Hashed ElGamal key encapsulation 51</li>

      <li>10.2 The random oracle model 51</li>

      <li>10.3 CS3b is at least as secure as HEG 51</li>

      <li>10.4 The security of HEG in the random oracle model 53</li>

      <li>10.5 The security of CS3b in the random oracle model 56</li>

      <li>10.6 Random oracles and pair-wise independent key derivation functions: getting the best of both 57</li>

      <li>10.7 Further discussion 57</li>

    </ul>

    <p class="text-gray-300">In this paper, we present and analyze a new public-key encryption scheme, and several variants, proving that they are secure against adaptive chosen ciphertext attack (as defined by Rackoff and Simon <em>[x20]</em>) under standard intractability assumptions. The schemes are quite practical, requiring just a few exponentiations in a group for both encryption and decryption. Moreover, the proofs of security of these schemes rely only on standard intractability assumptions: one variant relies only on the hardness of the Decisional Diffie-Hellman problem, while other, somewhat more practical, variants rely on a couple of other standard intractability assumptions.</p>

    <p class="text-gray-300">The hardness of the Decisional Diffie-Hellman problem is essentially equivalent to the semantic security of the basic ElGamal encryption scheme <em>[x5]</em>. Thus, with just a bit more computation, we get security against adaptive chosen ciphertext attack, whereas the basic ElGamal scheme is completely insecure against this type of attack.</p>

    <p class="text-gray-300">While there are several provably secure public-key encryption schemes in the literature, they are all quite impractical. Also, there are several practical encryption schemes that have been proposed, but none of them has been proven secure under standard intractability assumptions. The significance of our results is that they provide several schemes that are provably secure and practical at the same time. There appear to be no other public-key encryption schemes in the literature that enjoy both of these properties simultaneously.</p>

    <p class="text-gray-300">This paper is a significantly revised and extended version of the extended abstract <em>[x10]</em>, and also includes results originally presented in the extended abstract <em>[x22]</em>.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.1 Chosen ciphertext security</h3>

    <p class="text-gray-300">Semantic security, defined by Goldwasser and Micali <em>[x13]</em>, captures the intuition that an adversary should not be able to obtain any partial information about a message given its encryption. However, this guarantee of secrecy is only valid when the adversary is completely passive, i.e., can only eavesdrop. Indeed, semantic security offers no guarantee of secrecy at all if an adversary can mount an active attack, i.e., inject messages into a network or otherwise influence the behavior of parties in the network.</p>

    <p class="text-gray-300">To deal with active attacks, Rackoff and Simon <em>[x20]</em> defined the notion of security against an adaptive chosen ciphertext attack. If an adversary can inject messages into a network, these messages may be ciphertexts, and the adversary may be able to extract partial information about the corresponding cleartexts through its interactions with the parties in the network. Rackoff and Simon’s definition models this type of attack by simply allowing an adversary to obtain decryptions of its choice, i.e., the adversary has access to a “decryption oracle.” Now, given an encryption of a message — the “target” ciphertext — we want to guarantee that the adversary cannot obtain any partial information about the message. To achieve this, we have to restrict the adversary’s behavior in some way, otherwise the adversary could simply submit the target ciphertext itself to the decryption oracle. The restriction proposed by Rackoff and Simon is the weakest possible: the adversary is not allowed to submit the target ciphertext itself to the oracle; however, it may submit any other ciphertext, including ciphertexts that are related to the target ciphertext.</p>

    <p class="text-gray-300">A different notion of security against active attacks, called non-malleability, was proposed by Dolev, Dwork, and Naor <em>[x8, x9]</em>. Here, the adversary also has access to a decryption oracle, but his goal is not to obtain partial information about the target ciphertext, but rather, to create another encryption of a different message that is related in some interesting way to the original, encrypted message. For example, for a non-malleable encryption scheme, given an encryption</p>

    <p class="text-gray-300">of <span class="math">n</span>, it should be infeasible to create an encryption of <span class="math">n+1</span>. It turns out that non-malleability and security against adaptive chosen ciphertext attack are equivalent <em>[x1, x10]</em>.</p>

    <p class="text-gray-300">An encryption scheme secure against adaptive chosen ciphertext attack is a very powerful cryptographic primitive. It is essential in designing protocols that are secure against active adversaries. For example, this primitive is used in protocols for authentication and key exchange <em>[x11, x10, x34]</em> and in protocols for escrow, certified e-mail, and more general fair exchange <em>[x2]</em>. It is by now generally recognized in the cryptographic research community that security against adaptive chosen ciphertext attack is the “right” notion of security for a general-purpose public-key encryption scheme. This is exemplified by the adoption of Bellare and Rogaway’s OAEP scheme <em>[x5]</em> (a practical but only heuristically secure scheme) as the internet encryption standard PKCS<span class="math">\\#1</span> version 2, and for use in the SET protocol for electronic commerce.</p>

    <p class="text-gray-300">There are also intermediate notions of security, between semantic security and adaptive chosen ciphertext security. Naor and Yung <em>[x32]</em> propose an attack model where the adversary has access to the decryption oracle only prior to obtaining the target ciphertext, and the goal of the adversary is to obtain partial information about the encrypted message. Naor and Yung called this type of attack a chosen ciphertext attack; it has also been called a “lunch-time” or “midnight” attack, and also an indifferent chosen ciphertext attack. In this paper, we will use the phrase adaptive chosen ciphertext attack for Rackoff and Simon’s definition, to distinguish it from Naor and Yung’s definition. Also, throughout this paper, unless otherwise specified, by “security” we will always mean “security against adaptive chosen ciphertext attack.”</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.2 Previous work</h3>

    <p class="text-gray-300"><em>Provably Secure Schemes.</em> Naor and Yung <em>[x32]</em> presented the first scheme provably secure against lunch-time attacks. Subsequently, Dolev, Dwork, and Naor <em>[x10]</em> presented a scheme that is provably secure against adaptive chosen ciphertext attack.</p>

    <p class="text-gray-300">Rackoff and Simon <em>[x31]</em> present and prove the security of an encryption scheme, but their scheme is actually not a public-key scheme in the traditional sense: in their scheme, all users — both senders and receivers — require public keys, and moreover, a trusted center is required to perform certain functions. In contrast, all other schemes mentioned in this paper, including our own, are traditional public-key systems: encryption is a probabilistic function of the message and the receiver’s public key, decryption is a function of the ciphertext and the receiver’s secret key, and no trusted center is required. This distinction can be important: adding extra system requirements as in the Rackoff and Simon scheme can greatly restrict the range of application of the scheme.</p>

    <p class="text-gray-300">All of the previously known schemes provably secure under standard intractability assumptions are completely impractical (albeit polynomial time), as they rely on general and expensive constructions for non-interactive zero-knowledge proofs. This includes non-standard schemes like Rackoff and Simon’s as well.</p>

    <p class="text-gray-300"><em>Practical Schemes.</em> Damgård <em>[x12]</em> proposed a practical scheme that he conjectured to be secure against lunch-time attacks; however, this scheme is not known to be provably secure in this sense, and is in fact demonstrably insecure against adaptive chosen ciphertext attack.</p>

    <p class="text-gray-300">Zheng and Seberry <em>[x39]</em> proposed practical schemes that are conjectured to be secure against chosen ciphertext attack, but again, no proof based on standard intractability assumptions is known. Lim and Lee <em>[x24]</em> also proposed practical schemes that were later broken by Frankel and Yung <em>[x16]</em>.</p>

    <p class="text-gray-300">Bellare and Rogaway <em>[x4, x5]</em> have presented practical schemes for which they give heuristic proofs of adaptive chosen ciphertext security; namely, they prove security based on the assump</p>

    <p class="text-gray-300">tion of a one-way trapdoor permutation in an idealized model of computation, the so-called random oracle model, wherein a hash function is represented by a random oracle. Actually, it turns out that the proof of security of the OAEP scheme in <em>[x1]</em> is flawed: as demonstrated in <em>[x21]</em>, there can be no standard “black box” security proof based on an arbitrary one-way trapdoor permutation. However, the negative result in <em>[x21]</em> does not rule out the possibility that OAEP in conjunction with a specific one-way trapdoor permutation scheme is secure. Indeed, it is shown in <em>[x21]</em> that OAEP with exponent-3 RSA is secure, and this result is generalized in <em>[x10]</em> to arbitrary-exponent RSA. A new scheme, OAEP+, is also presented in <em>[x21]</em>, which can be proven secure in the random oracle model, using an arbitrary one-way trapdoor permutation. Further variations of OAEP and OAEP+ are discussed in <em>[x3]</em>.</p>

    <p class="text-gray-300">Shoup and Gennaro <em>[x24]</em> also give ElGamal-like schemes that are secure against adaptive chosen ciphertext attack in the random oracle model, and that are also amenable to efficient threshold decryption.</p>

    <p class="text-gray-300">We stress that although a security proof in the random oracle model is of some value, it is still only a heuristic proof. In particular, these types of proofs do not rule out the possibility of breaking the scheme without breaking the underlying intractability assumption. Nor do they even rule out the possibility of breaking the scheme without finding some kind of weakness in the hash function, as shown by Canetti, Goldreich, and Halevi <em>[x7]</em>.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">1.3 Further progress</h3>

    <p class="text-gray-300">Subsequent to the publication of the extended abstract <em>[x6]</em> on which the present paper is based, some further progress in this area has been made. Canetti and Goldwasser <em>[x8]</em> presented a threshold-decryption variant of our scheme. Also, the authors of the present paper <em>[x5]</em> have generalized and extended the basic ideas underlying our encryption scheme, obtaining new and quite practical encryption schemes that are secure against adaptive chosen ciphertext attack under different assumptions — one scheme relies on Paillier’s Decision Composite Residuosity assumption <em>[x22]</em>, while the other (somewhat less practical) scheme relies on the classical Quadratic Residuosity assumption.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">1.4 Outline of paper</h3>

    <p class="text-gray-300">Our paper consists of two parts.</p>

    <p class="text-gray-300">Part 1. In the first part, we take care of a number of preliminaries, after which we present a basic version of our new scheme, along with a few variants. This first part is organized as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We introduce some basic notation that will be used throughout the paper.</li>

      <li>We state the formal definition of a public-key encryption scheme and the notion of security against adaptive chosen ciphertext attack. We also discuss some implications of the definition of security that illustrate its utility.</li>

      <li>We state the formal definitions of several intractability assumption related to the Discrete Logarithm problem: the Discrete Logarithm assumption, the Computational Diffie-Hellman assumption, and the Decisional Diffie-Hellman assumption. In doing this, we introduce the notion of a computational group scheme, which is a general framework that allows us to discuss in an abstract, yet sufficiently concrete way, the different families of groups that may be used in cryptographic applications.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We define the notion of a target collision resistant hash function, which is a special type of a universal one-way hash function. We will use this primitive in the most efficient variants of our encryption scheme.</li>

      <li>We present and analyze the basic version of our encryption scheme, which we call CS1, along with two variants, called CS1a and CS1b. We prove the security of these schemes based on the Decisional Diffie-Hellman assumption, and the assumption that a given family of hash functions is target collision resistant. We also present and analyze a somewhat less efficient scheme, called CS2, which does not require a target collision resistant hash function.</li>

    </ul>

    <h5 id="sec-9" class="text-base font-semibold mt-4">Part 2</h5>

    <p class="text-gray-300">The schemes presented in §6 suffer from two drawbacks. First, the schemes require that plaintexts are, or can be encoded as, group elements, which may significantly restrict the range of application of the encryption scheme and/or the choice of computational group scheme; it would be nice to relax this restriction, allowing plaintexts to be, say, bit strings of arbitrary length. Second, if the Decisional Diffie-Hellman assumption is false, these schemes can be trivially broken; it would be nice if we could provide a second level of defense, so that if Decisional Diffie-Hellman assumption turns out to be false, we have a scheme that still offers some security — even if only heuristically.</p>

    <p class="text-gray-300">It turns out that both of these drawbacks can be dealt with by using a technique called hybrid encryption. Basically, a hybrid encryption scheme uses public-key encryption techniques to derive a shared key that is then used to encrypt the actual message using standard symmetric-key techniques. The second part of the paper is devoted to developing the formal theory behind this technique, and to designing and analyzing variations on our basic scheme that utilize this technique. This part is organized as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We lay the theoretical foundations for hybrid encryption. Although most of the ideas in this section appear to be “folklore,” they have not been treated rigorously in the literature. In §7.1, we introduce the notion of a key encapsulation mechanism, and an appropriate notion of security against adaptive chosen ciphertext attack. A key encapsulation mechanism is like a public-key encryption scheme, except that the encryption algorithm can only be used to generate and encrypt a random bit string of fixed length, which we shall use as a key for a symmetric-key encryption scheme. In §7.2, we state the formal properties of a symmetric-key encryption scheme that we need for use in a hybrid encryption scheme, and discuss some simple constructions based on pseudo-random bit generators and message authentication codes. In §7.3, we prove that an appropriately secure key encapsulation mechanism, combined with an appropriately secure symmetric-key encryption scheme, yields a public-key encryption scheme that is secure against adaptive chosen ciphertext attack.</li>

    </ul>

    <p class="text-gray-300">In what follows, we concentrate exclusively on the problem of constructing secure key encapsulation mechanisms, since the problem of constructing symmetric-key encryption schemes is essentially solved.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We discuss the notion of a secure key derivation function, which is a function that should map random group elements to pseudo-random bit strings of given length. A key derivation function is an essential ingredient in our constructions of key encapsulation mechanisms.</li>

      <li>We present and analyze a key encapsulation mechanism, CS3, along with two variants, CS3a and CS3b, and prove their security under the Decisional Diffie-Hellman assumption, and also assuming a target collision resistant hash function and a secure key derivation function.</li>

    </ul>

    <p class="text-gray-300">.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The hybrid encryption scheme obtained from CS3b is by far the most practical of the encryption schemes presented in this paper; moreover, it has other interesting security properties. We show that CS3b is no less secure than a more traditional key encapsulation mechanism that is a hashed variant of ElGamal encryption, which we call HEG. Second, we also show that CS3b is secure in the random oracle model (viewing the key derivation function as a random function), under the weaker Computational Diffie-Hellman assumption, and also assuming a target collision resistant hash function. The results in this section show that there is virtually no risk in using scheme CS3b relative to more traditional encryption schemes, while at the same time, CS3b provides a security guarantee that more traditional schemes do not.</li>

    </ul>

    <h2 id="sec-10" class="text-2xl font-bold">2 Some Preliminaries</h2>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">2.1 Basic mathematical notation</h3>

    <p class="text-gray-300"><span class="math">\\mathbf{Z}</span> denotes the ring of integers, <span class="math">\\mathbf{Z}_{\\geq 0}</span> denotes the set of non-negative integers, and for positive integer <span class="math">k</span>, <span class="math">\\mathbf{Z}_{k}</span> denotes the ring of integers modulo <span class="math">k</span>, and <span class="math">\\mathbf{Z}_{k}^{*}</span> denotes the corresponding multiplicative group of units.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">2.2 Algorithms and probability spaces</h3>

    <p class="text-gray-300">We write <span class="math">\\nu\\leftarrow\\alpha</span> to denote the algorithmic action of assigning the value of <span class="math">\\alpha</span> to the variable <span class="math">\\nu</span>.</p>

    <p class="text-gray-300">Let <span class="math">X</span> be a finite probability space, i.e., a probability space on a finite set <span class="math">S</span>. For <span class="math">\\alpha\\in S</span>, we let <span class="math">\\Pr_{X}[\\alpha]</span> denote the probability that <span class="math">X</span> assigns to <span class="math">\\alpha</span>, and for <span class="math">S^{\\prime}\\subset S</span>, we let <span class="math">\\Pr_{X}[S^{\\prime}]</span> denote the probability that <span class="math">X</span> assigns to <span class="math">S^{\\prime}</span>.</p>

    <p class="text-gray-300">We write <span class="math">\\nu\\stackrel{{\\scriptstyle R}}{{\\leftarrow}}X</span> to denote the algorithmic action of sampling an element of <span class="math">S</span> according to the distribution <span class="math">X</span>, and assigning the result of this sampling experiment to the variable <span class="math">\\nu</span>. We sometimes write <span class="math">\\nu_{1},\\ldots,\\nu_{k}\\stackrel{{\\scriptstyle R}}{{\\leftarrow}}X</span> as a shorthand for <span class="math">\\nu_{1}\\stackrel{{\\scriptstyle R}}{{\\leftarrow}}X;\\ldots;\\nu_{k}\\stackrel{{\\scriptstyle R}}{{\\leftarrow}}X</span>.</p>

    <p class="text-gray-300">For any finite set <span class="math">S</span>, <span class="math">\\mathbf{U}(S)</span> denotes the uniform distribution on <span class="math">S</span>. We write <span class="math">\\nu\\stackrel{{\\scriptstyle R}}{{\\leftarrow}}S</span> as a shorthand for <span class="math">\\nu\\stackrel{{\\scriptstyle R}}{{\\leftarrow}}\\mathbf{U}(S)</span>.</p>

    <p class="text-gray-300">For any probability space <span class="math">X</span> on a finite set <span class="math">S</span>, we denote by <span class="math">[X]</span> the subset of elements of <span class="math">S</span> that are assigned non-zero probability by <span class="math">X</span>, i.e., the “support” of <span class="math">X</span>.</p>

    <p class="text-gray-300">If <span class="math">X_{1},X_{2},\\ldots,X_{k}</span> are finite probability spaces, and <span class="math">\\phi</span> is a <span class="math">k</span>-ary predicate, then we write</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\phi(\\nu_{1},\\ldots,\\nu_{k}):\\nu_{1}\\stackrel{{\\scriptstyle R}}{{\\leftarrow}}X_{1};\\ldots;\\nu_{k}\\stackrel{{\\scriptstyle R}}{{\\leftarrow}}X_{k}]</span></p>

    <p class="text-gray-300">to denote the probability that <span class="math">\\phi(\\nu_{1},\\ldots,\\nu_{k})</span> holds when <span class="math">\\nu_{1}</span> is sampled from <span class="math">X_{1}</span>, <span class="math">\\nu_{2}</span> is sampled from <span class="math">X_{2}</span>, etc. More generally, for <span class="math">1\\leq i\\leq k</span>, <span class="math">X_{i}</span> may be family of finite probability spaces parameterized by <span class="math">(\\nu_{1},\\ldots,\\nu_{i-1})</span>, and we write</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\phi(\\nu_{1},\\ldots,\\nu_{k}):\\nu_{1}\\stackrel{{\\scriptstyle R}}{{\\leftarrow}}X_{1};\\nu_{2}\\stackrel{{\\scriptstyle R}}{{\\leftarrow}}X_{2}(\\nu_{1});\\ldots;\\nu_{k}\\stackrel{{\\scriptstyle R}}{{\\leftarrow}}X_{k}(\\nu_{1},\\ldots,\\nu_{k-1})]</span></p>

    <p class="text-gray-300">to denote the probability that <span class="math">\\phi(\\nu_{1},\\ldots,\\nu_{k})</span> holds when <span class="math">\\nu_{1}</span> is sampled from <span class="math">X_{1}</span>, after which <span class="math">\\nu_{2}</span> is sampled from <span class="math">X_{2}(\\nu_{1})</span>, and so on. In this case, it is important that <span class="math">\\nu_{1},\\ldots,\\nu_{k}</span> are sampled in the order given.</p>

    <p class="text-gray-300">Similarly, if <span class="math">F</span> is a <span class="math">k</span>-ary function function, then</p>

    <p class="text-gray-300"><span class="math">\\{F(\\nu_{1},\\ldots,\\nu_{k}):\\nu_{1}\\stackrel{{\\scriptstyle R}}{{\\leftarrow}}X_{1};\\nu_{2}\\stackrel{{\\scriptstyle R}}{{\\leftarrow}}X_{2}(\\nu_{1});\\ldots;\\nu_{k}\\stackrel{{\\scriptstyle R}}{{\\leftarrow}}X_{k}(\\nu_{1},\\ldots,\\nu_{k-1})\\}</span></p>

    <p class="text-gray-300">denotes the probability space defined by sampling <span class="math">\\nu_{1}</span> from <span class="math">X_{1}</span>, <span class="math">\\nu_{2}</span> from <span class="math">X_{2}(\\nu_{1})</span>, and so on, and then evaluating the function <span class="math">F(\\nu_{1},\\ldots,\\nu_{k})</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">We shall consider polynomial-time probabilistic algorithms <span class="math">\\mathsf{A}</span>. We shall insist that for all <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span> and all inputs of length <span class="math">\\lambda</span>, algorithm <span class="math">\\mathsf{A}</span> <em>always</em> halts in time bounded by a polynomial in <span class="math">\\lambda</span>, regardless of the random choices that <span class="math">\\mathsf{A}</span> may make. In particular, for any input tuple <span class="math">(\\alpha_{1},\\ldots,\\alpha_{k})</span>, the random choices made by <span class="math">\\mathsf{A}</span> as well as the output of <span class="math">\\mathsf{A}</span> on this input are finite probability spaces. We denote this output probability space of <span class="math">\\mathsf{A}</span> for a given input <span class="math">(\\alpha_{1},\\ldots,\\alpha_{k})</span> by <span class="math">\\mathsf{A}(\\alpha_{1},\\ldots,\\alpha_{k})</span>. We stress that <span class="math">\\mathsf{A}(\\alpha_{1},\\ldots,\\alpha_{k})</span> is a <em>probability space</em>, and not a <em>value</em>. As such, we may write <span class="math">\\nu\\xleftarrow{R}\\mathsf{A}(\\alpha_{1},\\ldots,\\alpha_{k})</span> to denote the algorithmic action of running <span class="math">\\mathsf{A}</span> on input <span class="math">(\\alpha_{1},\\ldots,\\alpha_{k})</span>, and assigning the output to the variable <span class="math">\\nu</span>. When we speak of the “running time” of <span class="math">\\mathsf{A}</span>, we mean the worst-case running time of <span class="math">\\mathsf{A}</span> for inputs of a given length.</p>

    <p class="text-gray-300">To exercise the above notation a bit, note that <span class="math">[\\mathsf{A}(\\alpha_{1},\\ldots,\\alpha_{k})]</span> denotes the set of possible outputs of <span class="math">\\mathsf{A}</span> on input <span class="math">(\\alpha_{1},\\ldots,\\alpha_{k})</span>. For a tertiary predicate <span class="math">\\phi</span>, and polynomial-time probabilistic algorithms <span class="math">\\mathsf{A}_{1}</span> and <span class="math">\\mathsf{A}_{2}</span>, and a value <span class="math">\\alpha_{0}</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\phi(\\alpha_{0},\\alpha_{1},\\alpha_{2}):\\alpha_{1}\\xleftarrow{R}\\mathsf{A}_{1}(\\alpha_{0});\\alpha_{2}\\xleftarrow{R}\\mathsf{A}_{2}(\\alpha_{0},\\alpha_{1})]</span></p>

    <p class="text-gray-300">denotes the probability that <span class="math">\\phi(\\alpha_{0},\\alpha_{1},\\alpha_{2})</span> holds when <span class="math">\\mathsf{A}_{1}</span> is run on input <span class="math">\\alpha_{0}</span>, yielding an output <span class="math">\\alpha_{1}</span>, and then <span class="math">\\mathsf{A}_{2}</span> is run on input <span class="math">(\\alpha_{0},\\alpha_{1})</span>, yielding an output <span class="math">\\alpha_{2}</span>.</p>

    <p class="text-gray-300">For <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span>, <span class="math">\\mathfrak{1}^{\\lambda}</span> denotes the bit string consisting of <span class="math">\\lambda</span> copies of the bit <span class="math">\\mathfrak{1}</span>. The string <span class="math">\\mathfrak{1}^{\\lambda}</span> will often be an input to an algorithm: this is a technical device that allows a polynomial-time algorithm to run in time bounded by a polynomial in <span class="math">\\lambda</span>, even if there are no other inputs to the algorithm, or those inputs happen to be very short.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">2.3 Statistical distance and negligible functions</h3>

    <p class="text-gray-300">Let <span class="math">X</span> and <span class="math">Y</span> be probability spaces on a finite set <span class="math">S</span>. Define the <em>statistical distance</em> <span class="math">\\Delta(X,Y)</span> <em>between</em> <span class="math">X</span> <em>and</em> <span class="math">Y</span> as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Delta(X,Y)\\mathop{:}={1\\over 2}\\sum_{\\alpha\\in S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr_{X}[\\alpha]-\\Pr_{Y}[\\alpha]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">One can easily verify that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Delta(X,Y)=\\max_{S^{\\prime}\\subset S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr_{X}[S^{\\prime}]-\\Pr_{Y}[S^{\\prime}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">A function <span class="math">F</span> mapping non-negative integers to non-negative reals is called <em>negligible</em> if for all positive numbers <span class="math">c</span>, there exists an integer <span class="math">\\lambda_{0}(c)\\geq 0</span> such that for all <span class="math">\\lambda&gt;\\lambda_{0}(c)</span>, we have <span class="math">F(\\lambda)&lt;1/\\lambda^{c}</span>.</p>

    <h2 id="sec-14" class="text-2xl font-bold">3 Secure Public Key Encryption</h2>

    <p class="text-gray-300">In this section, we state the basic properties of a public-key encryption scheme, along with the definition of security against adaptive chosen ciphertext attack. Although the notions here are relatively standard, we treat a number of details here that are not often dealt with in the literature. We also discuss some implications of the definition of security that illustrate its utility.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">3.1 Public Key Encryption Schemes</h3>

    <p class="text-gray-300">A <em>public-key encryption scheme</em> <span class="math">\\mathsf{PKE}</span> consists of the following algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A probabilistic, polynomial-time <em>key generation algorithm</em> <span class="math">\\mathsf{PKE.KeyGen}</span> that on input <span class="math">\\mathfrak{1}^{\\lambda}</span> for <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span>, outputs a public key/secret key pair <span class="math">(\\mathsf{PK},\\mathsf{SK})</span>. The structure of <span class="math">\\mathsf{PK}</span> and <span class="math">\\mathsf{SK}</span> depends on the particular scheme.</li>

    </ul>

    <p class="text-gray-300">For <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>, we define the probability spaces</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{PKE.PKSpace}_{\\lambda} := \\{\\mathsf{PK}: (\\mathsf{PK}, \\mathsf{SK}) \\stackrel {R}{\\leftarrow} \\mathsf{PKE.KeyGen}(1^{\\lambda})\\},</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{PKE.SKSpace}_{\\lambda} := \\{\\mathsf{SK}: (\\mathsf{PK}, \\mathsf{SK}) \\stackrel {R}{\\leftarrow} \\mathsf{PKE.KeyGen}(1^{\\lambda})\\}.</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A probabilistic, polynomial-time encryption algorithm <span class="math">\\mathsf{PKE.Encrypt}</span> that takes as input <span class="math">1^{\\lambda}</span> for <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>, a public key <span class="math">\\mathsf{PK} \\in [\\mathsf{PKE.PKSpace}_{\\lambda}]</span>, a message <span class="math">m</span>, and outputs a ciphertext <span class="math">\\psi</span>.</li>

    </ul>

    <p class="text-gray-300">A ciphertext is a bit string. The structure of a message may depend on the particular scheme; see below (§3.1.1) for a discussion.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A deterministic, polynomial-time decryption algorithm <span class="math">\\mathsf{PKE.Decrypt}</span> that takes as input <span class="math">1^{\\lambda}</span> for <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>, a secret key <span class="math">\\mathsf{SK} \\in [\\mathsf{PKE.SKSpace}_{\\lambda}]</span>, a ciphertext <span class="math">\\psi</span>, and outputs either a message <span class="math">m</span> or the special symbol reject.</li>

    </ul>

    <h2 id="sec-16" class="text-2xl font-bold">3.1.1 Message spaces</h2>

    <p class="text-gray-300">Different public-key encryption schemes might specify different message spaces, and these message spaces might in fact vary with the choice of public key. Let us denote by <span class="math">\\mathsf{PKE.MSpace}_{\\lambda,\\mathsf{PK}}</span> the message space associated with <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> and <span class="math">\\mathsf{PK} \\in [\\mathsf{PKE.PKSpace}_{\\lambda}]</span>. Although there may be other ways of categorizing message spaces, we shall work with schemes that specify message spaces in one of two ways:</p>

    <p class="text-gray-300"><strong>unrestricted message space</strong>: <span class="math">\\mathsf{PKE.MSpace}_{\\lambda,\\mathsf{PK}} = \\{0,1\\}^{*}</span> for all <span class="math">\\lambda</span> and <span class="math">\\mathsf{PK}</span>.</p>

    <p class="text-gray-300"><strong>restricted message space</strong>: <span class="math">\\mathsf{PKE.MSpace}_{\\lambda,\\mathsf{PK}}</span> is a finite set that may depend on <span class="math">\\lambda</span> and <span class="math">\\mathsf{PK}</span>.</p>

    <p class="text-gray-300">There should be a deterministic, polynomial-time algorithm that on input <span class="math">1^{\\lambda}</span>, <span class="math">\\mathsf{PK}</span>, and <span class="math">\\alpha</span>, determines if <span class="math">\\alpha \\in \\mathsf{PKE.MSpace}_{\\lambda,\\mathsf{PK}}</span>.</p>

    <p class="text-gray-300">Clearly, a public-key encryption scheme with an unrestricted message space will be most suitable in a setting where a very general-purpose encryption scheme is required. However, encryption schemes with restricted message spaces can be useful in some settings as well.</p>

    <h2 id="sec-17" class="text-2xl font-bold">3.1.2 Soundness</h2>

    <p class="text-gray-300">A public-key encryption scheme should be sound in the sense that decrypting an encryption of a message should yield the original message.</p>

    <p class="text-gray-300">Requiring that this always holds is a very strong condition which will not be satisfied by many otherwise quite acceptable encryption schemes.</p>

    <p class="text-gray-300">A definition of soundness that is adequate for our purposes runs as follows. Let us say a public key/secret key pair <span class="math">(\\mathsf{PK},\\mathsf{SK}) \\in [\\mathsf{PKE.KeyGen}(1^{\\lambda})]</span> is bad if for some <span class="math">m \\in \\mathsf{PKE.MSpace}_{\\lambda,\\mathsf{PK}}</span> and some <span class="math">\\psi \\in [\\mathsf{PKE.Encrypt}(1^{\\lambda},\\mathsf{PK},m)]</span>, we have <span class="math">\\mathsf{PKE.Decrypt}(1^{\\lambda},\\mathsf{SK},\\psi) \\neq m</span>. Then our requirement is that the probability that the key generation algorithm outputs a bad key pair grows negligibly in <span class="math">\\lambda</span>.</p>

    <p class="text-gray-300">One could formulate even weaker notions of soundness that would still be adequate for many applications, but we shall not pursue this here.</p>

    <p class="text-gray-300">3.2 Security against adaptive chosen ciphertext attack</p>

    <p class="text-gray-300">An adversary A in an adaptive chosen ciphertext attack (CCA) is a probabilistic, polynomial-time oracle query machine.</p>

    <p class="text-gray-300">The attack game is defined in terms of an interactive computation between the adversary and its environment. The adversary’s environment responds to the oracle queries made by the adversary: each oracle query response is sampled from a probability space that is a function of the adversary’s input and all the previous oracle queries made by the adversary. We require that A runs in time strictly bounded by a polynomial in the length of its input, regardless of its probabilistic choices, and regardless of the responses to its oracle queries from its environment.</p>

    <p class="text-gray-300">We now describe the attack game used to define security against adaptive chosen ciphertext attack; that is, we define (operationally) the environment in which A runs. We assume that the input to A is <span class="math">1^{\\lambda}</span> for some <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span>.</p>

    <p class="text-gray-300">The adversary queries a key generation oracle. The key generation oracle computes <span class="math">(\\mathsf{PK},\\mathsf{SK})\\stackrel{{\\scriptstyle n}}{{\\leftarrow}}\\mathsf{PKE}.\\mathsf{KeyGen}(1^{\\lambda})</span> and responds with <span class="math">\\mathsf{PK}</span>. The adversary makes a sequence of calls to a decryption oracle.</p>

    <p class="text-gray-300">For each decryption oracle query, the adversary submits a ciphertext <span class="math">\\psi</span>, and the decryption oracle responds with <span class="math">\\mathsf{PKE}.\\mathsf{Decrypt}(1^{\\lambda},\\mathsf{SK},\\psi)</span>.</p>

    <p class="text-gray-300">We emphasize that <span class="math">\\psi</span> may be an arbitrary bit string, concocted by A in an arbitrary fashion — it certainly need not be an output of the encryption algorithm.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The adversary submits two messages <span class="math">m_{0},m_{1}\\in\\mathsf{PKE}.\\mathsf{MSpace}_{\\lambda,\\mathsf{PK}}</span> to an encryption oracle. In the case of an unrestricted message space, we require that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">On input <span class="math">m_{0},m_{1}</span>, the encryption oracle computes:</p>

    <p class="text-gray-300"><span class="math">\\sigma\\stackrel{{\\scriptstyle n}}{{\\leftarrow}}\\{0,1\\};\\ \\psi^{*}\\stackrel{{\\scriptstyle n}}{{\\leftarrow}}\\mathsf{PKE}.\\mathsf{Encrypt}(1^{\\lambda},\\mathsf{PK},m_{\\sigma});</span></p>

    <p class="text-gray-300">and responds with the “target” ciphertext <span class="math">\\psi^{<em>}</span>. The adversary continues to make calls to the decryption oracle, subject only to the restriction that a submitted ciphertext <span class="math">\\psi</span> is not identical to <span class="math">\\psi^{</em>}</span>.</p>

    <p class="text-gray-300">Again, we emphasize that <span class="math">\\psi</span> is arbitrary, and may even be computed by A as a function of <span class="math">\\psi^{*}</span>. The adversary outputs <span class="math">\\hat{\\sigma}\\in\\{0,1\\}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We define the CCA advantage of A against <span class="math">\\mathsf{PKE}</span> at <span class="math">\\lambda</span>, denoted <span class="math">\\mathsf{AdvCCA}_{\\mathsf{PKE},\\mathsf{A}}(\\lambda)</span>, to be $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[\\sigma=\\hat{\\sigma}]-1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ in the above attack game.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We say that <span class="math">\\mathsf{PKE}</span> is secure against adaptive chosen ciphertext attack if</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>for all probabilistic, polynomial-time oracle query machines A, the function <span class="math">\\mathsf{AdvCCA}_{\\mathsf{PKE},\\mathsf{A}}(\\lambda)</span> grows negligibly in <span class="math">\\lambda</span>.</p>
    </blockquote>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">3.3 Application of the definition of security</p>

    <p class="text-gray-300">In applying the above definition of security, one typically works directly with the quantity</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{AdvCCA}^{\\prime}_{\\mathsf{PKE,A}}(\\lambda)\\mathrel{\\mathop{:}}=\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[\\hat{\\sigma}=1\\mid\\sigma=0]-\\Pr[\\hat{\\sigma}=1\\mid\\sigma=1]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If we view <span class="math">\\mathsf{A}</span> as a statistical test, then the quantity <span class="math">\\mathsf{AdvCCA}^{\\prime}_{\\mathsf{PKE,A}}(\\lambda)</span> measures <span class="math">\\mathsf{A}</span>’s advantage in distinguishing a game in which <span class="math">m_{0}</span> is always encrypted from a game in which <span class="math">m_{1}</span> is always encrypted. It is easy to verify that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{AdvCCA}^{\\prime}_{\\mathsf{PKE,A}}(\\lambda)=2\\cdot\\mathsf{AdvCCA}_{\\mathsf{PKE,A}}(\\lambda).</span></p>

    <p class="text-gray-300">We present here a sketch of another characterization of this notion of security that illustrates more fully its utility in reasoning about the security of higher-level protocols. This alternative characterization is a natural, high level, simulation-based definition that in some ways provides a justification for the rather low level, technical definition given above. Our treatment here will be somewhat less formal than elsewhere in this paper.</p>

    <p class="text-gray-300">We start by defining the notion of a channel, which is an object that implements the following operations:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>KeyGen — outputs a public key <span class="math">\\mathsf{PK}</span>.</li>

      <li>Encrypt — takes as input a message <span class="math">m</span>, and outputs a ciphertext <span class="math">\\psi</span>.</li>

      <li>Decrypt — takes as input a ciphertext <span class="math">\\psi</span>, and outputs a message <span class="math">m</span> (possibly a special reject symbol).</li>

    </ul>

    <p class="text-gray-300">Additionally, a channel is parameterized by a security parameter <span class="math">\\lambda</span>.</p>

    <p class="text-gray-300">To initialize a channel, the KeyGen operation is invoked, after which, an arbitrary number of Encrypt and Decrypt operations may be invoked. We shall assume that messages are arbitrary bit strings.</p>

    <p class="text-gray-300">A channel may be implemented in several ways. One way, of course, is to simply “plug in” a public-key encryption scheme. We call such an implementation of a channel a real channel. We wish to describe another implementation, which we call an ideal channel.</p>

    <p class="text-gray-300">Loosely speaking, an ideal channel acts essentially like a private storage and retrieval service: when an Encrypt operation is invoked with a message <span class="math">m</span>, the ideal channel generates a corresponding ciphertext <span class="math">\\psi</span> without even “looking” at <span class="math">m</span>, and stores the pair <span class="math">(m,\\psi)</span> in a table; when a Decrypt operation is invoked with a ciphertext <span class="math">\\psi</span> such that <span class="math">(m,\\psi)</span> is in the table for some <span class="math">m</span>, the ideal channel returns the message <span class="math">m</span>. Thus, the “encryption” <span class="math">\\psi</span> of a message <span class="math">m</span> is completely independent of <span class="math">m</span>, and essentially plays the role of a “receipt,” presentation of which to the Decrypt operation yields the message <span class="math">m</span>. As such, the Encrypt operation might be better named Store, and the Decrypt operation Retrieve.</p>

    <p class="text-gray-300">We now describe the operation of an ideal channel in a bit more detail.</p>

    <p class="text-gray-300">An ideal channel is built using a channel simulator. A channel simulator is an object that implements an interface that is identical to that of a channel, except that the Encrypt operation does not take as input a message, but rather just the length of a message.</p>

    <p class="text-gray-300">An ideal channel uses a channel simulator as follows. The KeyGen operation of the ideal channel is implemented directly in terms of the KeyGen operation of the channel simulator. The ideal channel maintains a set <span class="math">S</span> of message/ciphertext pairs <span class="math">(m,\\psi)</span> and a set <span class="math">T</span> of ciphertexts, both initially empty.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">When the Encrypt operation of the ideal channel is invoked with input <span class="math">m</span>, the ideal channel invokes the channel simulator with input $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, obtaining a ciphertext </span>\\psi<span class="math">. If </span>\\psi\\in T<span class="math"> or </span>(m^{\\prime},\\psi)\\in S$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">for some <span class="math">m^{\\prime}</span>, the ideal channel becomes “broken,” and this and all subsequent invocations of either Encrypt or Decrypt return a special symbol indicating this; otherwise, the ideal channel adds the pair <span class="math">(m,\\psi)</span> to <span class="math">S</span> and returns <span class="math">\\psi</span> as the result of the Encrypt operation.</p>

    <p class="text-gray-300">When the Decrypt operation of the ideal channel is invoked with input <span class="math">\\psi</span>, the ideal channel first checks if <span class="math">(m,\\psi)\\in S</span> for some <span class="math">m</span>; if so, it simply returns the message <span class="math">m</span>; otherwise, it adds <span class="math">\\psi</span> to <span class="math">T</span>, invokes the Decrypt operation of the channel simulator to obtain <span class="math">m</span>, and returns <span class="math">m</span>.</p>

    <p class="text-gray-300">That completes the description of how an ideal channel is implemented using a channel simulator.</p>

    <p class="text-gray-300">Now we define a notion of security based on the indistinguishability of real and ideal channels for a public-key encryption scheme <span class="math">\\mathsf{PKE}</span> with an unrestricted message space. Consider a game in which a polynomial-time probabilistic adversary <span class="math">\\mathsf{A}</span> interacts with an arbitrary number of channels, and at the end of the game, outputs a 0 or 1. We say that <span class="math">\\mathsf{PKE}</span> is secure in the sense of channel indistinguishability if there exists an efficient channel simulator such that for the resulting ideal channel, <span class="math">\\mathsf{A}</span> cannot effectively distinguish between a game played with all real channels and a game played with all ideal channels; i.e., the absolute difference between the probabilities that <span class="math">\\mathsf{A}</span> outputs a 1 in the two games grows negligibly in the security parameter.</p>

    <p class="text-gray-300">Note that since real channels never become broken, this definition of security implies that ideal channels become broken with only negligible probability.</p>

    <p class="text-gray-300">It straightforward to show that if <span class="math">\\mathsf{PKE}</span> is secure against adaptive chosen ciphertext attack, then it is also secure in the sense of channel indistinguishability. To prove this, the channel simulator is implemented using the KeyGen and Decrypt algorithms of <span class="math">\\mathsf{PKE}</span>, and the Encrypt operation of the channel simulator on input <span class="math">\\ell</span> simply runs the Encrypt algorithm of <span class="math">\\mathsf{PKE}</span> on input <span class="math">\\mathsf{1}^{\\ell}</span>. We leave it to the reader to verify that the resulting ideal channel is indistinguishable from the real channel. This is essentially just a standard “hybrid” argument.</p>

    <p class="text-gray-300">In analyzing a higher-level protocol, one may substitute all real channels by ideal channels. Presumably, it is much more straightforward to then analyze the resulting idealized protocol, since in the idealized protocol, ciphertexts are just “receipts” that are completely independent of the corresponding messages. Security implies that any (polynomial-time recognizable) event in the original protocol occurs with essentially the same probability in the idealized protocol.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">3.4 Further discussion</h3>

    <p class="text-gray-300">The definition of security we have presented here is from <em>[x20]</em>. It is called IND-CCA2 in <em>[x1]</em>. It is known to be equivalent to other notions, such as non-malleability <em>[x10, x11, x12]</em>, which is called NM-CCA2 in <em>[x1]</em>.</p>

    <p class="text-gray-300">There are other, weaker notions of security for a public-key encryption scheme. For example, <em>[x22]</em> define a notion that is sometimes called security against indifferent chosen ciphertext attack, or security against lunchtime attack. This definition of security is exactly the same as the one above in §3.2, except that Stage 4 of the attack is omitted — that is, the adversary does not have access to the decryption oracle after it obtains the target ciphertext. While this notion of security may seem natural, it is actually not sufficient in many applications. This notion is called IND-CCA1 in <em>[x1]</em>.</p>

    <p class="text-gray-300">An even weaker notion of security for a public-key encryption scheme is that of security against a passive attack, also known as semantic security. This definition of security is exactly the same as the one above in §3.2, except that both Stages 2 and 4 of the attack are omitted — that is, the adversary does not have access to the decryption oracle at all. This notion was introduced in <em>[x13]</em> and is called IND-CPA in <em>[x1]</em>. This notion of security is quite limited: it is only</p>

    <p class="text-gray-300">adequate in situations where the adversary only has the power to eavesdrop network traffic, but cannot modify network traffic or otherwise actively participate in a protocol using the encryption scheme.</p>

    <p class="text-gray-300">For a similar, but slightly different, approach to modeling encryption as an “idealized” process, see <em>[x1]</em>. See also <em>[x2]</em> for another generalization of the definition of adaptive chosen ciphertext attack to a setting involving many users and messages.</p>

    <h2 id="sec-19" class="text-2xl font-bold">4 Intractability Assumptions Related to the Discrete Logarithm Problem</h2>

    <p class="text-gray-300">In this section, we recall the Discrete Logarithm (DL) assumption, the Computational Diffie-Hellman (CDH) assumption, and the Decisional Diffie-Hellman (DDH) assumption. All of these assumptions are formulated with respect to a suitable group <span class="math">G</span> of large prime order <span class="math">q</span> generated by a given element <span class="math">g</span>.</p>

    <p class="text-gray-300">Informally, the DL assumption is this:</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>given <span class="math">g^{x}</span> and <span class="math">g^{y}</span> for random <span class="math">x,y\\in\\mathbf{Z}_{q}</span>, it is hard to compute <span class="math">g^{xy}</span>.</p>
    </blockquote>

    <p class="text-gray-300">Informally, the CDH assumption is this:</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>given <span class="math">g^{x}</span> and <span class="math">g^{y}</span> for random <span class="math">x,y\\in\\mathbf{Z}_{q}</span>, it is hard to compute <span class="math">g^{xy}</span>.</p>
    </blockquote>

    <p class="text-gray-300">Informally, the DDH assumption is this:</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>it is hard to distinguish triples of the form <span class="math">(g^{x},g^{y},g^{z})</span> for random <span class="math">x,y,z\\in\\mathbf{Z}_{q}</span> from triples of the form <span class="math">(g^{x},g^{y},g^{xy})</span> for random <span class="math">x,y\\in\\mathbf{Z}_{q}</span>.</p>
    </blockquote>

    <p class="text-gray-300">The rest of this section is devoted to describing these assumptions more formally, discussing appropriate groups, and discussing some variations and consequences of these assumptions.</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">4.1 Computational group schemes</h3>

    <p class="text-gray-300">To state these intractability assumptions in a general but precise way, and in an appropriate asymptotic setting, we introduce the notion of a computational group scheme.</p>

    <p class="text-gray-300">A computational group scheme <span class="math">\\mathcal{G}</span> specifies a sequence <span class="math">(\\mathbf{S}_{\\lambda})_{\\lambda\\in\\mathbf{Z}_{\\geq 0}}</span> of group distributions. For every value of a security parameter <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span>, <span class="math">\\mathbf{S}_{\\lambda}</span> is a probability distribution of group descriptions. A group description <span class="math">\\Gamma</span> specifies a finite abelian group <span class="math">\\hat{G}</span>, along with a prime-order subgroup <span class="math">G</span>, a generator <span class="math">g</span> of <span class="math">G</span>, and the order <span class="math">q</span> of <span class="math">G</span>. We use multiplicative notation for the group operation in <span class="math">\\hat{G}</span>, and we denote the identity element of <span class="math">\\hat{G}</span> by <span class="math">1_{G}</span>.</p>

    <p class="text-gray-300">We will write <span class="math">\\Gamma[\\hat{G},G,g,q]</span> to indicate that <span class="math">\\Gamma</span> specifies <span class="math">\\hat{G}</span>, <span class="math">G</span>, <span class="math">g</span>, and <span class="math">q</span> as above. As a simple example of this notation: “for all <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span>, for all <span class="math">\\Gamma[\\hat{G},G,g,q]\\in[\\mathbf{S}_{\\lambda}]</span>, we have <span class="math">g^{q}=1_{G}</span>.”</p>

    <p class="text-gray-300">As usual, mathematical objects like a group description <span class="math">\\Gamma</span> and elements of a group <span class="math">\\hat{G}</span> are represented for computational purposes as bit strings bounded in length by a polynomial in <span class="math">\\lambda</span>. The interpretation of these bit strings is up to the algorithms comprising the group scheme (see below). However, we require that the encoding scheme used to represent group elements as bit strings be canonical; that is, every element of a group <span class="math">\\hat{G}</span> has a unique binary encoding.</p>

    <p class="text-gray-300">The group scheme should also provide several algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a deterministic, polynomial-time algorithm for computing the group operation that takes as input <span class="math">1^{\\lambda}</span> for <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span>, <span class="math">\\Gamma[\\hat{G},G,g,q]\\in[\\mathbf{S}_{\\lambda}]</span>, along with <span class="math">h_{1},h_{2}\\in\\hat{G}</span>, and outputs the group element <span class="math">h_{1}\\cdot h_{2}\\in\\hat{G}</span>;</li>

    </ul>

    <p class="text-gray-300">-</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a deterministic, polynomial-time algorithm for computing the group inversion operation that takes as input <span class="math">1^{\\lambda}</span> for <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>, <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span>, and <span class="math">h \\in \\hat{G}</span>, and outputs <span class="math">h^{-1} \\in \\hat{G}</span>;</li>

      <li>a deterministic, polynomial-time algorithm that takes as input <span class="math">1^{\\lambda}</span> for <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>, <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span>, and <span class="math">\\alpha \\in \\{0,1\\}^{*}</span>, and determines if <span class="math">\\alpha</span> is a valid binary encoding of an element of <span class="math">\\hat{G}</span>;</li>

      <li>a deterministic, polynomial-time algorithm that takes as input <span class="math">1^{\\lambda}</span> for <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>, <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span>, and <span class="math">h \\in \\hat{G}</span>, and determines if <span class="math">h \\in G</span>;</li>

      <li>a deterministic, polynomial-time algorithm that takes as input <span class="math">1^{\\lambda}</span> for <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>, <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span>, and outputs <span class="math">g</span> and <span class="math">q</span>.</li>

      <li>a probabilistic, polynomial-time approximate sampling algorithm <span class="math">\\hat{S}</span> that on input <span class="math">1^{\\lambda}</span> approximately samples <span class="math">\\mathbf{S}_{\\lambda}</span>. The distributions <span class="math">\\mathbf{S}_{\\lambda}</span> and <span class="math">\\hat{S}(1^{\\lambda})</span> should be statistically close; that is, the statistical distance <span class="math">\\Delta(\\mathbf{S}_{\\lambda}, \\hat{S}(1^{\\lambda}))</span> should be a negligible function in <span class="math">\\lambda</span>.</li>

    </ul>

    <p class="text-gray-300">Notice that we do not require that the output distribution <span class="math">\\hat{S}(1^{\\lambda})</span> of the sampling algorithm is identical to <span class="math">\\mathbf{S}_{\\lambda}</span>, but only that the distributions have a negligible statistical distance. In particular, not all elements of <span class="math">[\\hat{S}(1^{\\lambda})]</span> are necessarily valid group descriptions. It would be impractical to require that these two distributions are identical.</p>

    <p class="text-gray-300">Note that the requirement that the group order be easily computable from the group description is not a trivial requirement: it is easy to exhibit groups whose orders are not easy to compute, e.g., subgroups of <span class="math">\\mathbf{Z}_n^*</span> for composite <span class="math">n</span>.</p>

    <p class="text-gray-300">The requirement that group elements have unique encodings is also an important, non-trivial requirement. It is easy to exhibit quotient groups in which the problem of computing canonical representatives of residue classes is non-trivial. An example of this is the group underlying Paillier's encryption scheme [Pai99].</p>

    <p class="text-gray-300">Let <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span>. The value <span class="math">1_G</span> may be directly encoded in <span class="math">\\Gamma</span>, but if not, we can always compute it as <span class="math">g \\cdot g^{-1}</span>.</p>

    <p class="text-gray-300">Although we will not require it, typical group schemes will have the property that for all <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span>, the only elements of <span class="math">\\hat{G}</span> of order <span class="math">q</span> lie in <span class="math">G</span>. When this is the case, testing whether a given <span class="math">h \\in \\hat{G}</span> lies in the subgroup <span class="math">G</span> can be implemented by testing if <span class="math">h^q = 1_G</span>. However, a group scheme may provide a more efficient subgroup test.</p>

    <p class="text-gray-300">Let <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span>. For <span class="math">a \\in G \\setminus \\{1_G\\}</span> and <span class="math">b \\in G</span>, we denote by <span class="math">\\log_a b</span> the discrete logarithm of <span class="math">b</span> to the base <span class="math">a</span>; that is, <span class="math">\\log_a b</span> is the unique element <span class="math">x \\in \\mathbf{Z}_q</span> such that <span class="math">b = a^x</span>.</p>

    <p class="text-gray-300">As a notational convention, throughout this paper, the letters <span class="math">a - h</span> (and decorated versions thereof) will denote elements of <span class="math">\\hat{G}</span>, and the letters <span class="math">r - z</span> (and decorated versions thereof) will denote elements of <span class="math">\\mathbf{Z}_q</span>.</p>

    <h2 id="sec-21" class="text-2xl font-bold">4.2 Examples of appropriate computational group schemes</h2>

    <p class="text-gray-300">There are several examples of computational group schemes that are appropriate for cryptographic applications.</p>

    <p class="text-gray-300">Example 1. Let <span class="math">\\ell_1(\\lambda)</span> and <span class="math">\\ell_2(\\lambda)</span> be polynomially bounded integer-valued functions in <span class="math">\\lambda</span>, such that <span class="math">1 &amp;lt; \\ell_1(\\lambda) &amp;lt; \\ell_2(\\lambda)</span> for all <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>. It should be the case that the function <span class="math">2^{-\\ell_1(\\lambda)}</span> is negligible. For a given <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>, the distribution <span class="math">\\mathbf{S}_{\\lambda}</span> is defined as the distribution of triples <span class="math">(q, p, g)</span>, where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">q</span> is a random <span class="math">\\ell_1(\\lambda)</span>-bit prime,</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">q</span> is a random <span class="math">q</span>-bit prime,</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">p</span> is a random <span class="math">\\ell_{2}(\\lambda)</span>-bit prime with <span class="math">p\\equiv 1\\pmod{q}</span>, and</li>

      <li><span class="math">g</span> is a random generator of <span class="math">G</span>, the unique subgroup of order <span class="math">q</span> of the cyclic group <span class="math">\\hat{G}=\\mathbf{Z}_{p}^{*}</span>.</li>

    </ul>

    <p class="text-gray-300">Elements in <span class="math">\\mathbf{Z}_{p}^{<em>}</span> can be encoded canonically as bit strings of length <span class="math">\\ell_{2}(\\lambda)</span>. Group operations in <span class="math">\\mathbf{Z}_{p}^{</em>}</span> are efficiently implemented using arithmetic modulo <span class="math">p</span>, and group inversion is implemented using the extended Euclidean algorithm. To test if an element <span class="math">(\\alpha\\bmod\\ p)\\in\\mathbf{Z}_{p}^{*}</span> lies in <span class="math">G</span>, we can test if <span class="math">\\alpha^{q}\\equiv 1\\pmod{p}</span>.</p>

    <p class="text-gray-300">A random generator <span class="math">g</span> of <span class="math">G</span> may be obtained by generating a random element in <span class="math">\\mathbf{Z}_{p}^{*}</span> and raising it to the power <span class="math">(p-1)/q</span> (repeating if necessary if this yields <span class="math">(1\\bmod p)</span>).</p>

    <p class="text-gray-300">The sampling algorithm <span class="math">\\hat{S}</span> may use standard, practical algorithms for primality testing that may err with a small probability that grows negligibly in <span class="math">\\lambda</span>. See, e.g., <em>[x1]</em> for more information on primality testing. Not all elements of <span class="math">[\\hat{S}(\\mathfrak{1}^{\\lambda})]</span> are valid group descriptions. Moreover, depending on other aspects of the implementation, the distribution on the valid group descriptions may also be slightly skewed away from <span class="math">\\mathbf{S}_{\\lambda}</span>. In our formulation of various intractability assumptions, it is much more convenient to work with the natural distribution <span class="math">\\mathbf{S}_{\\lambda}</span> than the more awkward distribution <span class="math">\\hat{S}(\\mathfrak{1}^{\\lambda})</span>.</p>

    <p class="text-gray-300">We should comment the density of primes <span class="math">p</span> such that <span class="math">p\\equiv 1\\pmod{q}</span> has never been proven to be sufficiently large to ensure fast termination of the group generation algorithm. Dirichlet’s Theorem on primes in arithmetic progressions only applies to the case where <span class="math">q</span> is fixed relative to <span class="math">p</span>. However, provided <span class="math">\\ell_{2}(\\lambda)\\geq(2+\\delta)\\ell_{1}(\\lambda)</span> for some fixed <span class="math">\\delta&gt;0</span>, for any <span class="math">\\ell_{1}(\\lambda)</span>-bit prime <span class="math">q</span>, the probability that a random <span class="math">\\ell_{2}(\\lambda)</span>-bit number of the form <span class="math">qk+1</span> is prime is <span class="math">\\Omega(1/\\ell_{2}(\\lambda))</span>, assuming the Extended Riemann Hypothesis (ERH). This follows from Theorem 8.8.18 in <em>[x1]</em>.</p>

    <p class="text-gray-300">If the density of primes <span class="math">p</span> such that <span class="math">p\\equiv 1\\pmod{q}</span> cannot be proven to be sufficiently large to ensure fast termination of the group generation algorithm, even assuming the ERH, it may not be unreasonable to anyway conjecture that this is the case.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Example 2.</h6>

    <p class="text-gray-300">This is the same as Example 1, except that <span class="math">p=2q+1</span>, where <span class="math">q</span> is a random <span class="math">\\ell_{1}(\\lambda)</span>-bit prime. Such a prime <span class="math">q</span> is known as a Sophie Germain prime. It is unknown if there exist infinitely many Sophie Germain primes. However, it is conjectured that there are, and specific conjectures on their density have been made <em>[x2, x3]</em> that empirically seem to be valid. In particular, it is conjectured that the probability that a random <span class="math">\\ell_{1}(\\lambda)</span>-bit number is a Sophie Germain prime is <span class="math">\\Omega(1/\\ell_{1}(\\lambda)^{2})</span>. If such a density estimate were true, then a simple trial and error method for finding Sophie Germain primes would terminate quickly. See <em>[x4]</em> for more information on efficiently generating such primes.</p>

    <p class="text-gray-300">Since the subgroup <span class="math">G</span> of <span class="math">\\mathbf{Z}_{p}^{<em>}</span> of order <span class="math">q</span> is just the subgroup of quadratic residues, testing if a given element <span class="math">(\\alpha\\bmod p)\\in\\mathbf{Z}_{p}^{</em>}</span> lies in <span class="math">G</span> can be performed by computing the Legendre symbol <span class="math">(\\alpha\\mid p)</span>, which is generally much more efficient than computing <span class="math">\\alpha^{q}\\bmod p</span>.</p>

    <p class="text-gray-300">A nice property of this construction is that the numbers <span class="math">\\{1,\\ldots,q\\}</span> are easily encoded as elements of <span class="math">G</span>. Given <span class="math">\\alpha\\in\\{1,\\ldots,q\\}</span>, we test if <span class="math">(\\alpha\\mid p)=1</span>, if so, then we encode <span class="math">\\alpha</span> as <span class="math">(\\alpha\\bmod p)\\in G</span>, and otherwise, we encode <span class="math">\\alpha</span> as <span class="math">(-\\alpha\\bmod p)</span>. Given a group element <span class="math">h=(\\alpha\\bmod p)\\in G</span> with <span class="math">1\\leq\\alpha\\leq p-1</span>, we decode <span class="math">h</span> as <span class="math">\\alpha</span> if <span class="math">\\alpha\\leq q</span>, and otherwise, we decode <span class="math">h</span> as <span class="math">p-\\alpha</span>.</p>

    <p class="text-gray-300">This encoding scheme clearly allows us to also easily encode arbitrary bit strings of length <span class="math">\\ell_{1}(\\lambda)-1</span> as elements of <span class="math">G</span>.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Example 3.</h6>

    <p class="text-gray-300">One can also construct <span class="math">G</span> as a prime order subgroup of an elliptic curve over a finite field. Elliptic curves and their application to cryptography is a very rich field, and we refer the reader to <em>[x2]</em> for an introduction and further references. We only note here that some of the same minor technical problems that arose above in Example 1 also arise here; namely, that (1) the</p>

    <p class="text-gray-300">known procedures for generating elliptic curves whose orders have a suitably large prime factor are somewhat heuristic, simply because not enough has been proven about how the order of a randomly generated elliptic curve factors into primes, and (2) it is in general not easy to encode arbitrary bit strings of a given length as points on an elliptic curve. We also note that it is fairly easy to generate elliptic curves of prime order so that we do not have to work in a sub-group, i.e., we can take <span class="math">G = \\hat{G}</span>. This is useful, as then the sub-group test becomes trivial.</p>

    <h2 id="sec-24" class="text-2xl font-bold">4.3 Intractability assumptions</h2>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">4.3.1 The DL assumption</h3>

    <p class="text-gray-300">Let <span class="math">\\mathcal{G}</span> be a computational group scheme, specifying a sequence <span class="math">(\\mathbf{S}_{\\lambda})_{\\lambda \\in \\mathbf{Z}_{\\geq 0}}</span> of group distributions.</p>

    <p class="text-gray-300">For all probabilistic, polynomial-time algorithms <span class="math">\\mathsf{A}</span>, and for all <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>, we define the <span class="math">DL</span> advantage of <span class="math">\\mathsf{A}</span> against <span class="math">\\mathcal{G}</span> at <span class="math">\\lambda</span> as</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{AdvDL}_{\\mathcal{G},\\mathsf{A}}(\\lambda) := \\Pr[ y = x : \\Gamma[\\hat{G}, G, g, q] \\stackrel{R}{\\leftarrow} \\mathbf{S}_{\\lambda}; x \\stackrel{R}{\\leftarrow} \\mathbf{Z}_{q}; y \\stackrel{R}{\\leftarrow} \\mathsf{A}(1^{\\lambda}, \\Gamma, g^{x}) ].</span></div>

    <p class="text-gray-300">The DL assumption for <span class="math">\\mathcal{G}</span> is this:</p>

    <p class="text-gray-300">For every probabilistic, polynomial-time algorithm <span class="math">\\mathsf{A}</span>, the function <span class="math">\\mathsf{AdvDL}_{\\mathcal{G},\\mathsf{A}}(\\lambda)</span> is negligible in <span class="math">\\lambda</span>.</p>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">4.3.2 The CDH assumption</h3>

    <p class="text-gray-300">Let <span class="math">\\mathcal{G}</span> be a computational group scheme, specifying a sequence <span class="math">(\\mathbf{S}_{\\lambda})_{\\lambda \\in \\mathbf{Z}_{\\geq 0}}</span> of group distributions.</p>

    <p class="text-gray-300">For all probabilistic, polynomial-time algorithms <span class="math">\\mathsf{A}</span>, and for all <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>, we define the CDH advantage of <span class="math">\\mathsf{A}</span> against <span class="math">\\mathcal{G}</span> at <span class="math">\\lambda</span> as</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{AdvCDH}_{\\mathcal{G},\\mathsf{A}}(\\lambda) := \\Pr[ c = g^{xy} : \\Gamma[\\hat{G}, G, g, q] \\stackrel{R}{\\leftarrow} \\mathbf{S}_{\\lambda}; x, y \\stackrel{R}{\\leftarrow} \\mathbf{Z}_{q}; c \\stackrel{R}{\\leftarrow} \\mathsf{A}(1^{\\lambda}, \\Gamma, g^{x}, g^{y}) ].</span></div>

    <p class="text-gray-300">The CDH assumption for <span class="math">\\mathcal{G}</span> is this:</p>

    <p class="text-gray-300">For every probabilistic, polynomial-time algorithm <span class="math">\\mathsf{A}</span>, the function <span class="math">\\mathsf{AdvCDH}_{\\mathcal{G},\\mathsf{A}}(\\lambda)</span> is negligible in <span class="math">\\lambda</span>.</p>

    <p class="text-gray-300">For all probabilistic, polynomial-time algorithms <span class="math">\\mathsf{A}</span>, for all <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>, and for all <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span>, we define the CDH advantage of <span class="math">\\mathsf{A}</span> against <span class="math">\\mathcal{G}</span> at <span class="math">\\lambda</span> given <span class="math">\\Gamma</span> as</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{AdvCDH}_{\\mathcal{G},\\mathsf{A}}(\\lambda \\mid \\Gamma) := \\Pr[ c = g^{xy} : x \\stackrel{R}{\\leftarrow} \\mathbf{Z}_{q}; y \\stackrel{R}{\\leftarrow} \\mathbf{Z}_{q}; c \\stackrel{R}{\\leftarrow} \\mathsf{A}(1^{\\lambda}, \\Gamma, g^{x}, g^{y}) ].</span></div>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">4.3.3 The DDH assumption</h3>

    <p class="text-gray-300">Let <span class="math">\\mathcal{G}</span> be a computational group scheme, specifying a sequence <span class="math">(\\mathbf{S}_{\\lambda})_{\\lambda \\in \\mathbf{Z}_{\\geq 0}}</span> of group distributions.</p>

    <p class="text-gray-300">For all <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>, and for all <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span>, we define the sets <span class="math">\\mathcal{D}_{\\lambda,\\Gamma}</span> and <span class="math">\\mathcal{T}_{\\lambda,\\Gamma}</span> as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{D}_{\\lambda,\\Gamma} := \\{(g^{x}, g^{y}, g^{xy}) \\in G^{3} : x, y \\in \\mathbf{Z}_{q}\\};</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{T}_{\\lambda,\\Gamma} := G^{3}.</span></div>

    <p class="text-gray-300">The set <span class="math">\\mathcal{D}_{\\lambda,\\Gamma}</span> is the set of "Diffie-Hellman triples." Also, for <span class="math">\\rho \\in G^3</span>, define <span class="math">\\mathsf{DHP}_{\\lambda,\\Gamma}(\\rho) = 1</span> if <span class="math">\\rho \\in \\mathcal{D}_{\\lambda,\\Gamma}</span>, and otherwise, define <span class="math">\\mathsf{DHP}_{\\lambda,\\Gamma}(\\rho) = 0</span>.</p>

    <p class="text-gray-300">14</p>

    <p class="text-gray-300">For all <span class="math">0/1</span>-valued, probabilistic, polynomial-time algorithms <span class="math">\\mathsf{A}</span>, and for all <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>, we define the DDH advantage of <span class="math">\\mathsf{A}</span> against <span class="math">\\mathcal{G}</span> at <span class="math">\\lambda</span> as</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\operatorname{AdvDDH}_{\\mathcal{G}, \\mathsf{A}}(\\lambda) := \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\tau = 1: \\Gamma \\stackrel{R}{\\leftarrow} \\mathbf{S}_{\\lambda}; \\rho \\stackrel{R}{\\leftarrow} \\mathcal{D}_{\\lambda, \\Gamma}; \\tau \\stackrel{R}{\\leftarrow} \\mathsf{A}(1^{\\lambda}, \\Gamma, \\rho) \\right] - \\right. \\right. \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">The DDH assumption for <span class="math">\\mathcal{G}</span> is this:</p>

    <p class="text-gray-300">For every probabilistic, polynomial-time, 0/1-valued algorithm <span class="math">\\mathsf{A}</span>, the function <span class="math">\\mathsf{AdvDDH}_{\\mathcal{G},\\mathsf{A}}(\\lambda)</span> is negligible in <span class="math">\\lambda</span>.</p>

    <p class="text-gray-300">For all <span class="math">0/1</span>-valued, probabilistic, polynomial-time algorithms <span class="math">\\mathsf{A}</span>, for all <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>, and all <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span>, we define the DDH advantage of <span class="math">\\mathsf{A}</span> against <span class="math">\\mathcal{G}</span> at <span class="math">\\lambda</span> given <span class="math">\\Gamma</span> as</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\operatorname{AdvDDH}_{\\mathcal{G}, \\mathsf{A}}(\\lambda \\mid \\Gamma) := \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\tau = 1: \\rho \\stackrel{R}{\\leftarrow} \\mathcal{D}_{\\lambda, \\Gamma}; \\tau \\stackrel{R}{\\leftarrow} \\mathsf{A}(1^{\\lambda}, \\Gamma, \\rho) \\right] - \\right. \\right. \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <h2 id="sec-28" class="text-2xl font-bold">A minor variation</h2>

    <p class="text-gray-300">We will need the following variation on the DDH assumption.</p>

    <p class="text-gray-300">For all <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>, for all <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span>, and we define the sets <span class="math">\\mathcal{D}_{\\lambda, \\Gamma}&#x27;</span> and <span class="math">\\mathcal{T}_{\\lambda, \\Gamma}&#x27;</span> as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathcal{D}_{\\lambda, \\Gamma}&#x27; := \\{g^{x}, g^{y}, g^{xy}: x, y \\in \\mathbf{Z}_{q}, x \\neq 0\\}; \\\\ \\mathcal{T}_{\\lambda, \\Gamma}&#x27; := \\{g^{x}, g^{y}, g^{z}: x, y, z \\in \\mathbf{Z}_{q}, x \\neq 0, z \\neq xy\\}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">That is, <span class="math">\\mathcal{D}_{\\lambda,\\Gamma}&#x27;</span> is the set of triples <span class="math">(\\hat{g}, a, \\hat{a}) \\in G^3</span>, such that <span class="math">\\hat{g} \\neq 1_G</span> and <span class="math">\\log_g a = \\log_{\\hat{g}} \\hat{a}</span>, and <span class="math">\\mathcal{T}_{\\lambda,\\Gamma}&#x27;</span> is the set of triples <span class="math">(\\hat{g}, a, \\hat{a}) \\in G^3</span>, such that <span class="math">\\hat{g} \\neq 1_G</span> and <span class="math">\\log_g a \\neq \\log_{\\hat{g}} \\hat{a}</span>.</p>

    <p class="text-gray-300">It is easy to verify the following:</p>

    <div class="my-4 text-center"><span class="math-block">\\Delta \\left(\\mathbf{U} \\left(\\mathcal{D}_{\\lambda, \\Gamma}\\right), \\mathbf{U} \\left(\\mathcal{D}_{\\lambda, \\Gamma}^{\\prime}\\right)\\right) \\leq 1/q; \\tag{1}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Delta \\left(\\mathbf{U} \\left(\\mathcal{T}_{\\lambda, \\Gamma}\\right), \\mathbf{U} \\left(\\mathcal{T}_{\\lambda, \\Gamma}^{\\prime}\\right)\\right) \\leq 2/q. \\tag{2}</span></div>

    <p class="text-gray-300">For all <span class="math">0/1</span>-valued, probabilistic, polynomial-time algorithms <span class="math">\\mathsf{A}</span>, and for all <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>, we define</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\operatorname{AdvDDH}_{\\mathcal{G}, \\mathsf{A}}'(\\lambda) := \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\tau = 1: \\Gamma \\stackrel{R}{\\leftarrow} \\mathbf{S}_{\\lambda}; \\rho \\stackrel{R}{\\leftarrow} \\mathcal{D}_{\\lambda, \\Gamma}^{\\prime}; \\tau \\stackrel{R}{\\leftarrow} \\mathsf{A}(1^{\\lambda}, \\Gamma, \\rho) \\right] - \\right. \\right. \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">For all <span class="math">0/1</span>-valued, probabilistic, polynomial-time algorithms <span class="math">\\mathsf{A}</span>, for all <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>, and for all <span class="math">\\Gamma \\in [\\mathbf{S}_{\\lambda}]</span>, we define</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\operatorname{AdvDDH}_{\\mathcal{G}, \\mathsf{A}}'(\\lambda \\mid \\Gamma) := \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\tau = 1: \\rho \\stackrel{R}{\\leftarrow} \\mathcal{D}_{\\lambda, \\Gamma}^{\\prime}; \\tau \\stackrel{R}{\\leftarrow} \\mathsf{A}(1^{\\lambda}, \\Gamma, \\rho) \\right] - \\right. \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">The inequalities (1) and (2) imply the following:</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Lemma 1</h6>

    <p class="text-gray-300">For all 0/1-valued, probabilistic, polynomial-time algorithms <span class="math">\\mathsf{A}</span>, for all <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span>, and for all <span class="math">\\Gamma[\\hat{G},G,g,q]\\in[\\mathbf{S}_{\\lambda}]</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{AdvDDH}_{\\mathcal{G},\\mathsf{A}}(\\lambda\\mid\\Gamma)-\\mathsf{AdvDDH}^{\\prime}_{\\mathcal{G},\\mathsf{A}}(\\lambda\\mid\\Gamma)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 3/q.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In particular, the DDH assumption holds for <span class="math">\\mathcal{G}</span> if and only if for every probabilistic, polynomial-time 0/1-valued algorithm <span class="math">\\mathsf{A}</span>, the function <span class="math">\\mathsf{AdvDDH}^{\\prime}_{\\mathcal{G},\\mathsf{A}}(\\lambda)</span> is negligible in <span class="math">\\lambda</span>.</p>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">Random self-reducibility</h4>

    <p class="text-gray-300">In this section, we discuss the random self-reducibility property of the DDH problem, and its implications.</p>

    <p class="text-gray-300">The following lemma states the random self-reducibility property for the DDH problem.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Lemma 2</h6>

    <p class="text-gray-300">There exists a probabilistic, polynomial-time algorithm <span class="math">\\mathsf{RSR}</span> such that for all <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span>, for all <span class="math">\\Gamma\\in[\\mathbf{S}_{\\lambda}]</span>, and for all <span class="math">\\rho\\in\\mathcal{T}_{\\lambda,\\Gamma}</span>, the distribution <span class="math">\\mathsf{RSR}(1^{\\lambda},\\Gamma,\\rho)</span> is <span class="math">\\mathbf{U}(\\mathcal{D}_{\\lambda,\\Gamma})</span> if <span class="math">\\rho\\in\\mathcal{D}_{\\lambda,\\Gamma}</span>, and is <span class="math">\\mathbf{U}(\\mathcal{T}_{\\lambda,\\Gamma})</span> if <span class="math">\\rho\\notin\\mathcal{D}_{\\lambda,\\Gamma}</span>.</p>

    <p class="text-gray-300">This was first observed by Stadler <em>[x20]</em>, who needed the result to prove the security of a particular protocol, and later by Naor and Reingold <em>[x15]</em>, who also pointed out some of its broader implications.</p>

    <p class="text-gray-300">The algorithm <span class="math">\\mathsf{RSR}</span> is very simple. Given <span class="math">1^{\\lambda}</span>, the group description <span class="math">\\Gamma[\\hat{G},G,g,q]</span>, and <span class="math">\\rho=(a,b,c)\\in G^{3}</span>, the algorithm computes <span class="math">(a^{\\prime},b^{\\prime},c^{\\prime})\\in G^{3}</span> as follows:</p>

    <p class="text-gray-300"><span class="math">r\\stackrel{{\\scriptstyle R}}{{\\leftarrow}}\\mathbf{Z}_{q};\\ s\\stackrel{{\\scriptstyle R}}{{\\leftarrow}}\\mathbf{Z}_{q};\\ t\\stackrel{{\\scriptstyle R}}{{\\leftarrow}}\\mathbf{Z}_{q};\\ a^{\\prime}\\leftarrow a^{r}g^{s};\\ b^{\\prime}\\leftarrow bg^{t};\\ c^{\\prime}\\leftarrow c^{r}a^{rt}b^{s}g^{st}.</span></p>

    <p class="text-gray-300">The implication of this random self-reduction is that if Diffie-Hellman tuples can be efficiently distinguished from random tuples with a non-negligible advantage, then Diffie-Hellman tuples can be efficiently recognized with negligible error probability. More formally, we have the following:</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Lemma 3</h6>

    <p class="text-gray-300">For every be a 0/1-valued, probabilistic, polynomial-time algorithm <span class="math">\\mathsf{A}</span>, and every polynomial <span class="math">P</span> (with integer coefficients, taking positive values on <span class="math">\\mathbf{Z}_{\\geq 0}</span>), there exists a 0/1-valued, probabilistic, polynomial-time algorithm <span class="math">\\mathsf{A}_{1}</span> such that for all <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span>, for all <span class="math">\\Gamma\\in[\\mathbf{S}_{\\lambda}]</span>, for all <span class="math">\\rho\\in\\mathcal{T}_{\\lambda,\\Gamma}</span>, and for all <span class="math">\\kappa\\in\\mathbf{Z}_{\\geq 0}</span>,</p>

    <p class="text-gray-300"><span class="math">\\text{if }\\mathsf{AdvDDH}_{\\mathcal{G},\\mathsf{A}}(\\lambda\\mid\\Gamma)\\geq 1/P(\\lambda),\\text{ then }\\Pr[\\mathsf{A}_{1}(1^{\\lambda},\\Gamma,\\rho,1^{\\kappa})\\neq\\mathsf{DHP}_{\\lambda,\\Gamma}(\\rho)]\\leq 2^{-\\kappa}.</span></p>

    <p class="text-gray-300">Lemma 3 follows from Lemma 2 using standard “amplification” techniques, making use of standard results on tail inequalities for the binomial distribution. Given <span class="math">1^{\\lambda}</span>, <span class="math">\\Gamma</span>, <span class="math">\\rho</span>, and <span class="math">1^{\\kappa}</span>, algorithm <span class="math">\\mathsf{A}_{1}</span> invokes algorithm <span class="math">\\mathsf{A}</span> as a subroutine <span class="math">O(P(\\lambda)^{2}\\kappa)</span> times with inputs <span class="math">(1^{\\lambda},\\Gamma,\\rho^{\\prime})</span>, where each <span class="math">\\rho^{\\prime}\\in\\mathcal{T}_{\\lambda,\\Gamma}</span> is independently sampled from <span class="math">\\mathsf{RSR}(1^{\\lambda},\\Gamma,\\rho)</span>; additionally, algorithm <span class="math">\\mathsf{A}_{1}</span> has to run algorithm <span class="math">\\mathsf{A}</span> as a subroutine <span class="math">O(P(\\lambda)^{2}\\kappa)</span> times to “calibrate” <span class="math">\\mathsf{A}</span>, calculating an estimate of</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\ \\tau=1:\\rho^{\\prime}\\stackrel{{\\scriptstyle R}}{{\\leftarrow}}\\mathcal{T}_{\\lambda,\\Gamma};\\ \\tau\\stackrel{{\\scriptstyle R}}{{\\leftarrow}}\\mathsf{A}(1^{\\lambda},\\Gamma,\\rho^{\\prime})\\ ].</span></p>

    <p class="text-gray-300">4.4 Further discussion</p>

    <p class="text-gray-300">It is clear that the DDH assumption is at least as strong as the CDH assumption, which in turn is at least as strong as the DL assumption.</p>

    <p class="text-gray-300">The CDH assumption was introduced informally by <em>[x10]</em>. Since then, there have been many papers that deal with the DL and CDH assumptions, and cryptocraphic applications based on them. The DDH assumption appears to have first surfaced in the cryptographic literature in <em>[x5]</em>, although as that paper notes, the DDH assumption is actually needed to prove the security of a number of previously proposed protocols. Indeed, the famous Diffie-Hellman key exchange cannot be proved secure in any reasonable and standard way just based on the CDH assumption: the DDH assumption (or some variant thereof) is required.</p>

    <p class="text-gray-300">The DDH assumption underpins a number of cryptographic applications. See, for example, the work of Stadler <em>[x27]</em> on publicly verifiable secret sharing, and the construction by Naor and Reingold <em>[x24]</em> of pseudo-random functions. Also, the well-known encryption scheme of ElGamal <em>[x11]</em> relies on the DDH for its security against passive attacks (i.e., semantic security).</p>

    <p class="text-gray-300">One variant of the ElGamal scheme is as follows. Let <span class="math">G</span> be a group of prime order <span class="math">q</span> generated by an element <span class="math">g</span>. The public key consists of a group element <span class="math">h=g^{z}</span>, where <span class="math">z\\in{\\bf Z}_{q}</span> is chosen at random; the secret key is <span class="math">z</span>. To encrypt a message <span class="math">m</span>, where we assume that <span class="math">m\\in G</span>, we compute</p>

    <p class="text-gray-300"><span class="math">u\\stackrel{{\\scriptstyle n}}{{\\leftarrow}}{\\bf Z}_{q};\\ a\\leftarrow g^{u};\\ b\\leftarrow h^{u};\\ c\\leftarrow b\\cdot m;</span></p>

    <p class="text-gray-300">to form a ciphertext <span class="math">\\psi=(a,c)</span>. To decrypt such a ciphertext using the secret key, one computes</p>

    <p class="text-gray-300"><span class="math">b\\leftarrow a^{z};\\ m\\leftarrow c\\cdot b^{-1};</span></p>

    <p class="text-gray-300">to obtain the message <span class="math">m</span>.</p>

    <p class="text-gray-300">It is a trivial exercise to show that the security of this encryption scheme against passive attack is equivalent to the DDH assumption. It is also easy to see that this scheme is completely insecure against adaptive chosen ciphertext attack: if <span class="math">(a,c)</span> is an encryption of <span class="math">m\\in G</span>, then for any <span class="math">m^{\\prime}\\in G</span>, <span class="math">(a,c\\cdot m^{\\prime})</span> is an encryption of <span class="math">m\\cdot m^{\\prime}</span>; thus, one can submit <span class="math">(a,c\\cdot m^{\\prime})</span> to the decryption oracle, obtaining <span class="math">m\\cdot m^{\\prime}</span>, from which one then computes <span class="math">m</span>.</p>

    <p class="text-gray-300">There are some very special families of elliptic curves for which the DDH assumption does not hold, but for which the CDH assumption still appears to stand <em>[x16]</em>. How these results are to be interpreted is a bit unclear. One the one hand, perhaps they cast some doubt on the DDH assumption in general. On the other hand, perhaps they only illustrate that very specially crafted families of elliptic curves may exhibit some surprising security weaknesses, which would seem to counsel against using such special families of elliptic curves for cryptographic applications, and instead, to use generic, randomly generated elliptic curves; indeed, for another special class of elliptic curves, the DL assumption is false <em>[x28]</em>.</p>

    <p class="text-gray-300">We refer the reader to two excellent surveys <em>[x22]</em> and <em>[x3]</em>. The latter focuses exclusively on the DDH assumption, while the former discusses both the CDH and DDH assumptions.</p>

    <h2 id="sec-33" class="text-2xl font-bold">5 Target Collision Resistant Hash Functions</h2>

    <p class="text-gray-300">In this section, we define the notion of a target collision resistant hash function, which is a special kind of universal one-way hash function, tailored somewhat for our particular application.</p>

    <p class="text-gray-300">We informally summarize this section as follows. We shall be working with a group <span class="math">G</span> of order <span class="math">q</span>, and we want to hash tuples of group elements to elements of <span class="math">{\\bf Z}_{q}</span>. For this purpose, we will use</p>

    <p class="text-gray-300">a family of keyed hash functions, such that given a randomly chosen tuple of group elements and randomly chosen hash function key, it is computationally infeasible to find a different tuple of group elements that hashes to the same value using the given hash key.</p>

    <p class="text-gray-300">Now the details.</p>

    <p class="text-gray-300">Let <span class="math">k</span> be a fixed positive integer, and let <span class="math">\\mathcal{G}</span> be a computational group scheme, specifying a sequence <span class="math">(\\mathbf{S}_{\\lambda})_{\\lambda \\in \\mathbf{Z}_{\\geq 0}}</span> of group distributions.</p>

    <p class="text-gray-300">A <span class="math">k</span>-ary group hashing scheme HF associated with <span class="math">\\mathcal{G}</span> specifies two items:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A family of key spaces indexed by <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> and <span class="math">\\Gamma \\in [\\mathbf{S}_{\\lambda}]</span>. Each such key space is a probability space on bit strings denoted by <span class="math">\\mathsf{HF.KeySpace}_{\\lambda, \\Gamma}</span>.</li>

    </ul>

    <p class="text-gray-300">There must exist a probabilistic, polynomial-time algorithm whose output distribution on input <span class="math">1^{\\lambda}</span> and <span class="math">\\Gamma</span> is equal to <span class="math">\\mathsf{HF.KeySpace}_{\\lambda,\\Gamma}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A family of hash functions indexed by <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>, <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span>, and <span class="math">\\mathsf{hk} \\in [\\mathsf{HF.KeySpace}_{\\lambda, \\Gamma}]</span>, where each such function <span class="math">\\mathsf{HF}_{\\mathsf{hk}}^{\\lambda, \\Gamma}</span> maps a <span class="math">k</span>-tuple <span class="math">\\rho \\in G^{k}</span> of group elements to an element of <span class="math">\\mathbf{Z}_q</span>.</li>

    </ul>

    <p class="text-gray-300">There must exist a deterministic, polynomial-time algorithm that on input <span class="math">1^{\\lambda}</span>, <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span>, <span class="math">\\mathsf{hk} \\in [\\mathsf{HF.KeySpace}_{\\lambda, \\Gamma}]</span>, and <span class="math">\\rho \\in G^{k}</span>, outputs <span class="math">\\mathsf{HF}_{\\mathsf{hk}}^{\\lambda, \\Gamma}(\\rho)</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\mathsf{A}</span> be a probabilistic, polynomial-time algorithm. For <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>, we define</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\text{AdvTCR}_{\\mathsf{HF}, \\mathsf{A}}(\\lambda) := \\\\ \\text{Pr}[ \\rho \\in G^{k} \\wedge \\rho \\neq \\rho^{*} \\wedge \\mathsf{HF}_{\\mathsf{hk}}^{\\lambda, \\Gamma}(\\rho^{*}) = \\mathsf{HF}_{\\mathsf{hk}}^{\\lambda, \\Gamma}(\\rho): \\\\ \\Gamma[\\hat{G}, G, g, q] \\stackrel{R}{\\leftarrow} \\mathbf{S}_{\\lambda}; \\rho^{*} \\stackrel{R}{\\leftarrow} G^{k}; \\mathsf{hk} \\stackrel{R}{\\leftarrow} \\mathsf{HF.KeySpace}_{\\lambda, \\Gamma}; \\rho \\stackrel{R}{\\leftarrow} \\mathsf{A}(1^{\\lambda}, \\Gamma, \\rho^{*}, \\mathsf{hk})]. \\end{array}</span></div>

    <p class="text-gray-300">The target collision resistance (TCR) assumption for HF is this:</p>

    <p class="text-gray-300">For every probabilistic, polynomial-time algorithm <span class="math">\\mathsf{A}</span>, the function <span class="math">\\mathsf{AdvTCR}_{\\mathsf{HF}, \\mathsf{A}}(\\lambda)</span> is negligible in <span class="math">\\lambda</span>.</p>

    <p class="text-gray-300">It will also be convenient to define the following. Let <span class="math">\\mathsf{A}</span> be a probabilistic, polynomial-time algorithm. For <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> and <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span>, we define</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\text{AdvTCR}_{\\mathsf{HF}, \\mathsf{A}}(\\lambda \\mid \\Gamma) := \\\\ \\text{Pr}[ \\rho \\in G^{k} \\wedge \\rho \\neq \\rho^{*} \\wedge \\mathsf{HF}_{\\mathsf{hk}}^{\\lambda, \\Gamma}(\\rho^{*}) = \\mathsf{HF}_{\\mathsf{hk}}^{\\lambda, \\Gamma}(\\rho): \\\\ \\rho^{*} \\stackrel{R}{\\leftarrow} G; \\mathsf{hk} \\stackrel{R}{\\leftarrow} \\mathsf{HF.KeySpace}_{\\lambda, \\Gamma}; \\rho \\stackrel{R}{\\leftarrow} \\mathsf{A}(1^{\\lambda}, \\Gamma, \\rho^{*}, \\mathsf{hk})]. \\end{array}</span></div>

    <h2 id="sec-34" class="text-2xl font-bold">5.1 Further discussion</h2>

    <p class="text-gray-300">As already mentioned, our notion of a target collision resistant hash function is a special case of the more general notion of a universal one-way hash function, introduced by Naor and Yung [NY89]. In their presentation, the hash functions mapped bit strings to bit strings, but of course, using appropriate formatting, we can easily make such a function a map from tuples of elements of the group <span class="math">G</span> to elements of <span class="math">\\mathbf{Z}_q</span>. The notion of security presented in [NY89] was also slightly stronger than ours: in their paper, the first input to the hash function (i.e. the "target" input) is chosen adversarially, but independent of the key of the hash function, whereas in our application, the target input is a random tuple of group elements.</p>

    <p class="text-gray-300">As was shown in <em>[x20]</em>, universal one-way hash functions can be built from arbitrary one-way permutations. This result was extended by <em>[x17]</em>, who showed that universal one-way hash functions can be built (albeit less efficiently) from arbitrary one-way functions.</p>

    <p class="text-gray-300">In practice, to build a universal one-way hash function, one can use a dedicated cryptographic hash function, like SHA-1 <em>[x18]</em>. Constructions in <em>[x3]</em> and <em>[x19]</em> show how to build a general-purpose universal one-way hash function using the underlying compression function of SHA-1, assuming the latter is second pre-image collision resistant. Actually, in our application, since the target input is just a random tuple of group elements, it is not too unreasonable to simply use SHA-1 directly, without a key at all.</p>

    <p class="text-gray-300">Note that the notion of target collision resistance is both qualitatively and quantitatively weaker than the notion of (full) collision resistance, which is why we prefer to rely on the former rather than the latter. A collision resistant hash function is one where it is hard for an adversary to find two different inputs that hash to the same value; the difference between target collision resistance and collision resistance is that in the former, one of the two inputs is not under the control of the adversary, while in the latter, both inputs are under the control of the adversary.</p>

    <h2 id="sec-35" class="text-2xl font-bold">6 The New Encryption Scheme: Basic Version</h2>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">6.1 Description of the scheme</h3>

    <p class="text-gray-300">In this section, we present the basic version, <span class="math">\\mathsf{CS1}</span>, of our new scheme.</p>

    <p class="text-gray-300">The scheme makes use of a computational group scheme <span class="math">\\mathcal{G}</span> as described in §4.1, defining a sequence <span class="math">(\\mathbf{S}_{\\lambda})_{\\lambda\\in\\mathbf{Z}_{\\geq 0}}</span> of distributions of group descriptions, and providing a sampling algorithm <span class="math">\\hat{S}</span>, where the output distribution <span class="math">\\hat{S}(\\mathbf{1}^{\\lambda})</span> closely approximates <span class="math">\\mathbf{S}_{\\lambda}</span>.</p>

    <p class="text-gray-300">The scheme also makes use of a tertiary group hashing scheme <span class="math">\\mathsf{HF}</span> associated with <span class="math">\\mathcal{G}</span>, as described in §5.</p>

    <p class="text-gray-300">The scheme is described in detail in Figure 1.</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Remark 1</h6>

    <p class="text-gray-300">Note that this encryption scheme has a restricted message space: messages are elements of the group <span class="math">G</span>. This limits to some degree the applicability of the scheme and the choice of group scheme; indeed, if one wants to encrypt arbitrary bit strings of some bounded length, then among the examples of group schemes discussed in §4.2, only Example 2, based on Sophie Germain primes, is suitable.</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Remark 2</h6>

    <p class="text-gray-300">Note that in step D2 of the decryption algorithm, we test if <span class="math">a</span>, <span class="math">\\hat{a}</span>, and <span class="math">c</span> belong to the subgroup <span class="math">G</span>. This test is essential to the security of the scheme. Although some group schemes may provide a more efficient method for performing these tests, in a typical implementation, one may have to compute <span class="math">a^{q}</span>, <span class="math">\\hat{a}^{q}</span>, and <span class="math">c^{q}</span>, testing that each of these is <span class="math">1_{G}</span>.</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Remark 3</h6>

    <p class="text-gray-300">Note that the key generation algorithm samples a group description <span class="math">\\Gamma</span> from <span class="math">\\hat{S}(\\mathbf{1}^{\\lambda})</span>. However, in describing the encryption scheme, we assume that <span class="math">\\Gamma</span> is a valid group description. With negligible probability (in <span class="math">\\lambda</span>), <span class="math">\\Gamma</span> may not be a valid group description, in which case the behavior of the key generation, encryption, and decryption algorithms is implementation dependent.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Remark 4</h6>

    <p class="text-gray-300">It is straightforward to verify that this encryption scheme satisfies the basic requirements that any public key encryption scheme should satisfy, as described in §3.1. In particular, the soundness property will always hold when <span class="math">\\Gamma</span> is a valid group description.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Key Generation: On input  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , compute</p>

    <p class="text-gray-300"><span class="math">\\Gamma[\\hat{G}, G, g, q] \\stackrel{R}{\\leftarrow} \\hat{S}(1^{\\lambda})</span> ;  <span class="math">\\mathsf{hk} \\stackrel{R}{\\leftarrow} \\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda, \\Gamma}</span> ;</p>

    <p class="text-gray-300"><span class="math">w\\stackrel {R}{\\leftarrow}\\mathbf{Z}_q^e;x_1,x_2,y_1,y_2,z_1,z_2\\stackrel {R}{\\leftarrow}\\mathbf{Z}_q;</span></p>

    <p class="text-gray-300"><span class="math">\\hat{g}\\gets g^{w};e\\gets g^{x_1}\\hat{g}^{x_2};f\\gets g^{y_1}\\hat{g}^{y_2};h\\gets g^{z_1}\\hat{g}^{z_2};</span></p>

    <p class="text-gray-300">and output the public key  <span class="math">\\mathsf{PK} = (\\Gamma ,\\mathsf{hk},\\hat{g},e,f,h)</span>  and the secret key  <span class="math">\\mathsf{SK} = (\\Gamma ,\\mathsf{hk},x_1,x_2,y_1,y_2,z_1,z_2)</span> .</p>

    <p class="text-gray-300">Encryption: Given  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , a public key</p>

    <p class="text-gray-300"><span class="math">\\mathsf{PK} = (\\Gamma [\\hat{G},G,g,q],\\mathsf{hk},\\hat{g},e,f,h)\\in [\\mathbf{S}_{\\lambda}]\\times [\\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda ,\\Gamma}]\\times G^{4},</span></p>

    <p class="text-gray-300">along with a message  <span class="math">m \\in G</span> , compute</p>

    <p class="text-gray-300">E1:  <span class="math">u \\stackrel{R}{\\leftarrow} \\mathbf{Z}_q</span> ; E2:  <span class="math">a \\gets g^u</span> ; E3:  <span class="math">\\hat{a} \\gets \\hat{g}^u</span> ; E4:  <span class="math">b \\gets h^u</span> ; E5:  <span class="math">c\\gets b\\cdot m</span> E6:  <span class="math">v\\gets \\mathsf{HF}_{\\mathsf{hk}}^{\\lambda ,\\Gamma}(a,\\hat{a},c)</span> E7:  <span class="math">d\\gets e^{u}f^{uv}</span></p>

    <p class="text-gray-300">and output the ciphertext  <span class="math">\\psi = (a, \\hat{a}, c, d)</span> .</p>

    <p class="text-gray-300">Decryption: Given  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , a secret key</p>

    <p class="text-gray-300"><span class="math">\\mathsf{SK} = (\\Gamma [\\hat{G},G,g,q],\\mathsf{hk},x_1,x_2,y_1,y_2,z_1,z_2)\\in [\\mathbf{S}_\\lambda ]\\times [\\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda ,\\Gamma}]\\times \\mathbf{Z}_q^6,</span></p>

    <p class="text-gray-300">along with a ciphertext  <span class="math">\\psi</span> , do the following.</p>

    <p class="text-gray-300">D1: Parse  <span class="math">\\psi</span>  as a 4-tuple  <span class="math">(a, \\hat{a}, c, d) \\in \\hat{G}^4</span> ; output reject and halt if  <span class="math">\\psi</span>  is not of this form. D2: Test if  <span class="math">a</span> ,  <span class="math">\\hat{a}</span> , and  <span class="math">c</span>  belong to  <span class="math">G</span> ; output reject and halt if this is not the case. D3: Compute  <span class="math">v \\gets \\mathsf{HF}_{\\mathsf{hk}}^{\\lambda, \\Gamma}(a, \\hat{a}, c)</span> . D4: Test if  <span class="math">d = a^{x_1 + y_1v} \\cdot \\hat{a}^{x_2 + y_2v}</span> ; output reject and halt if this is not the case. D5: Compute  <span class="math">b \\gets a^{z_1} \\hat{a}^{z_2}</span> . D6: Compute  <span class="math">m \\gets c \\cdot b^{-1}</span> , and output  <span class="math">m</span> .</p>

    <p class="text-gray-300">Figure 1: The public-key encryption scheme CS1</p>

    <p class="text-gray-300">Remark 5</p>

    <p class="text-gray-300">Technically speaking, the output <span class="math">\\psi</span> of the encryption algorithm is actually a canonical binary encoding of the 4-tuple <span class="math">(a,\\hat{a},c,d)\\in G^{4}</span>. In particular, it is critical that for any two ciphertexts <span class="math">\\psi^{\\prime}\\neq\\psi</span>, the parsing algorithm in step D1 of the decryption algorithm should not output the same 4-tuple of group elements.</p>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">6.2 Security analysis of the scheme</h3>

    <p class="text-gray-300">We shall prove that CS1 is secure against adaptive chosen ciphertext attack if the DDH assumption holds for <span class="math">\\mathcal{G}</span> and the TCR assumption holds for HF. However, we wish to state and prove a concrete security reduction. To this end, we need some auxiliary definitions.</p>

    <p class="text-gray-300">Suppose <span class="math">\\mathsf{PKE}</span> is a public-key encryption scheme that uses a group scheme in the following natural way: on input <span class="math">1^{\\lambda}</span>, the key generation algorithm runs the sampling algorithm of the group scheme on input <span class="math">1^{\\lambda}</span>, yielding a group description <span class="math">\\Gamma</span>. For a given probabilistic, polynomial-time oracle query machine <span class="math">\\mathsf{A}</span>, <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span>, and group description <span class="math">\\Gamma</span>, let us define <span class="math">\\mathsf{AdvCCA}_{\\mathsf{PKE},\\mathsf{A}}(\\lambda\\mid\\Gamma)</span> to be <span class="math">\\mathsf{A}</span>’s advantage in an adaptive chosen ciphertext attack where the key generation algorithm uses the given value of <span class="math">\\Gamma</span>, instead of running the sampling algorithm of the group scheme.</p>

    <p class="text-gray-300">For all probabilistic, polynomial-time oracle query machines <span class="math">\\mathsf{A}</span>, for all <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span>, let <span class="math">Q_{\\mathsf{A}}(\\lambda)</span> be an upper bound on the number of decryption oracle queries made by <span class="math">\\mathsf{A}</span> on input <span class="math">1^{\\lambda}</span>. We assume that <span class="math">Q_{\\mathsf{A}}(\\lambda)</span> is a strict bound in the sense that it holds regardless of the probabilistic choices of <span class="math">\\mathsf{A}</span>, and regardless of the responses to its oracle queries from its environment.</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Theorem 1</h6>

    <p class="text-gray-300">If the DDH assumption holds for <span class="math">\\mathcal{G}</span> and the TCR assumption holds for HF, then CS1 is secure against adaptive chosen ciphertext attack.</p>

    <p class="text-gray-300">In particular, for all probabilistic, polynomial-time oracle query machines <span class="math">\\mathsf{A}</span>, there exist probabilistic algorithms <span class="math">\\mathsf{A}_{1}</span> and <span class="math">\\mathsf{A}_{2}</span>, whose running times are essentially the same as that of <span class="math">\\mathsf{A}</span>, such that the following holds. For all <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span>, and all <span class="math">\\Gamma[\\hat{G},G,g,q]\\in[\\mathbf{S}_{\\lambda}]</span>, we have</p>

    <p class="text-gray-300"><span class="math">\\mathsf{AdvCCA}_{\\mathsf{CS1},\\mathsf{A}}(\\lambda\\mid\\Gamma)\\leq\\mathsf{AdvDDH}_{\\mathcal{G},\\mathsf{A}_{1}}(\\lambda\\mid\\Gamma)+\\mathsf{AdvTCR}_{\\mathsf{HF},\\mathsf{A}_{2}}(\\lambda\\mid\\Gamma)+(Q_{\\mathsf{A}}(\\lambda)+4)/q.</span> (3)</p>

    <p class="text-gray-300">The precise running times of algorithms <span class="math">\\mathsf{A}_{1}</span> and <span class="math">\\mathsf{A}_{2}</span> depend a good deal on details of the model of computation and on implementation details, and so we make no attempt to be more precise on this matter.</p>

    <p class="text-gray-300">Before continuing, we state the following simple but useful lemma, which we leave to the reader to verify.</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Lemma 4</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">U_{1}</span>, <span class="math">U_{2}</span>, and <span class="math">F</span> be events defined on some probability space. Suppose that the event <span class="math">U_{1}\\wedge\\neg F</span> occurs if and only if <span class="math">U_{2}\\wedge\\neg F</span> occurs. Then $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[U_{1}]-\\Pr[U_{2}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\Pr[F]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To prove Theorem 1, let us fix a probabilistic, polynomial-time oracle query machine <span class="math">\\mathsf{A}</span>, the value of the security parameter <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span>, and the group description <span class="math">\\Gamma[\\hat{G},G,g,q]\\in[\\mathbf{S}_{\\lambda}]</span>.</p>

    <p class="text-gray-300">The attack game is as described in §3.2. We now describe the relevant random variables to be considered in analyzing the adversary’s attack.</p>

    <p class="text-gray-300">Suppose that the public key is <span class="math">(\\Gamma,\\mathsf{hk},\\hat{g},e,f,h)</span> and that the secret key is <span class="math">(\\Gamma,\\mathsf{hk},x_{1},x_{2},y_{1},y_{2},z_{1},z_{2})</span>. Let <span class="math">w\\!:=\\log_{g}\\hat{g}</span>, and define <span class="math">x,y,z\\in\\mathbf{Z}_{q}</span> as follows:</p>

    <p class="text-gray-300"><span class="math">x\\!:=x_{1}+x_{2}w,\\ y\\!:=y_{1}+y_{2}w,\\ z\\!:=z_{1}+z_{2}w.</span></p>

    <p class="text-gray-300">That is, <span class="math">x=\\log_{g}e</span>, <span class="math">y=\\log_{g}f</span>, and <span class="math">z=\\log_{g}h</span>.</p>

    <p class="text-gray-300">As a notational convention, whenever a particular ciphertext <span class="math">\\psi</span> is under consideration in some context, the following values are also implicitly defined in that context:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">a,\\hat{a},b,c,d\\in G</span>, where <span class="math">\\psi=(a,\\hat{a},c,d)</span> and <span class="math">b:=a^{z_{1}}\\hat{a}^{z_{2}}</span>;</li>

      <li><span class="math">u,\\hat{u},v,r,s,t\\in\\mathbf{Z}_{q}</span>, where</li>

    </ul>

    <p class="text-gray-300"><span class="math">u:=\\log_{g}a,\\ \\hat{u}:=\\log_{\\hat{g}}\\hat{a},\\ v:=H\\!F^{\\lambda,\\Gamma}_{\\mathsf{hk}}(a,\\hat{a},c),\\ r:=\\log_{g}c,\\ s:=\\log_{g}d,</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">t:=x_{1}u+y_{1}uv+x_{2}\\hat{u}w+y_{2}\\hat{u}vw.</span></p>

    <p class="text-gray-300">For the target ciphertext <span class="math">\\psi^{<em>}</span>, we also denote by <span class="math">a^{</em>},\\hat{a}^{<em>},b^{</em>},c^{<em>},d^{</em>}\\in G</span> and <span class="math">u^{<em>},\\hat{u}^{</em>},v^{<em>},r^{</em>},s^{<em>},t^{</em>}\\in\\mathbf{Z}_{q}</span> the corresponding values.</p>

    <p class="text-gray-300">The probability space defining the attack game is then determined by the following, mutually independent, random variables:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the coin tosses Coins of A;</li>

      <li>the values <span class="math">\\mathsf{hk},w,x_{1},x_{2},y_{1},y_{2},z_{1},z_{2}</span> generated by the key generation algorithm;</li>

      <li>the values <span class="math">\\sigma\\in\\{0,1\\}</span> and <span class="math">u^{*}\\in\\mathbf{Z}_{q}</span> generated by the encryption oracle.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbf{G}_{0}</span> be the original attack game, let <span class="math">\\hat{\\sigma}\\in\\{0,1\\}</span> denote the output of A, and let <span class="math">T_{0}</span> be the event that <span class="math">\\sigma=\\hat{\\sigma}</span> in <span class="math">\\mathbf{G}_{0}</span>, so that $\\mathsf{AdvCCA_{CS1,A}}(\\lambda\\mid\\Gamma)=\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[T_{0}]-1/2\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our overall strategy for the proof is as follows. We shall define a sequence <span class="math">\\mathbf{G}_{1},\\mathbf{G}_{2},\\ldots,\\mathbf{G}_{\\ell}</span> of modified attack games. Each of the games <span class="math">\\mathbf{G}_{0},\\mathbf{G}_{1},\\ldots,\\mathbf{G}_{\\ell}</span> operates on the same underlying probability space. In particular, the public key and secret key of the cryptosystem, the coin tosses Coins of A, and the hidden bit <span class="math">\\sigma</span> take on identical values across all games. Only some of the rules defining how the environment responds to oracle queries differ from game to game. For any <span class="math">1\\leq i\\leq\\ell</span>, we let <span class="math">T_{i}</span> be the event that <span class="math">\\sigma=\\hat{\\sigma}</span> in game <span class="math">\\mathbf{G}_{i}</span>. Our strategy is to show that for <span class="math">1\\leq i\\leq\\ell</span>, the quantity $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[T_{i-1}]-\\Pr[T_{i}]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is negligible. Also, it will be evident from the definition of game </span>\\mathbf{G}_{\\ell}<span class="math"> that </span>\\Pr[T_{\\ell}]=1/2<span class="math">, which will imply that </span>\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[T_{0}]-1/2\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ is negligible.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">So that the overall structure of the proof is more transparent, we shall defer the proofs of all lemmas to the end of the proof of the theorem.</p>

    <p class="text-gray-300">Game <span class="math">\\mathbf{G}_{1}</span>. We now modify game <span class="math">\\mathbf{G}_{0}</span> to obtain a new game <span class="math">\\mathbf{G}_{1}</span>. These two games are identical, except for a small modification to the encryption oracle. Instead of using the encryption algorithm as given to compute the target ciphertext <span class="math">\\psi^{*}</span>, we use a modified encryption algorithm, in which steps E4 and E7 are replaced by:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>E4^{′}: <span class="math">b\\leftarrow a^{z_{1}}\\hat{a}^{z_{2}}</span>;</li>

      <li>E7^{′}: <span class="math">d\\leftarrow a^{x_{1}+y_{1}v}\\cdot\\hat{a}^{x_{2}+y_{2}v}</span>.</li>

    </ul>

    <p class="text-gray-300">The change we have made is purely conceptual: the values of <span class="math">b^{<em>}</span> and <span class="math">d^{</em>}</span> are exactly the same in game <span class="math">\\mathbf{G}_{1}</span> as they were in <span class="math">\\mathbf{G}_{0}</span>. Therefore,</p>

    <p class="text-gray-300"><span class="math">\\Pr[T_{1}]=\\Pr[T_{0}].</span> (4)</p>

    <p class="text-gray-300">Note that the encryption oracle now makes use of some components of the secret key, which is something the original encryption oracle does not do.</p>

    <p class="text-gray-300">.</p>

    <h4 id="sec-44" class="text-lg font-semibold mt-6">Game G_{2}.</h4>

    <p class="text-gray-300">We now modify game <span class="math">\\mathbf{G}_{1}</span> to obtain a new game <span class="math">\\mathbf{G}_{2}</span>. We again modify the encryption oracle, replacing step E3 of the encryption algorithm by</p>

    <p class="text-gray-300"><span class="math">\\mathbf{E3^{\\prime}}:\\ \\hat{u}\\xleftarrow{\\mu}\\mathbf{Z}_{q}\\setminus\\{u\\};\\ \\hat{a}\\leftarrow\\hat{g}^{\\hat{u}}.</span></p>

    <p class="text-gray-300">Note that whereas in games <span class="math">\\mathbf{G}_{0}</span> and <span class="math">\\mathbf{G}_{1}</span> we had <span class="math">u^{<em>}=\\hat{u}^{</em>}</span>, in game <span class="math">\\mathbf{G}_{2}</span>, <span class="math">u^{<em>}</span> and <span class="math">\\hat{u}^{</em>}</span> are nearly independent, being subject only to <span class="math">u^{<em>}\\neq\\hat{u}^{</em>}</span>. However, observe that games <span class="math">\\mathbf{G}_{1}</span> and <span class="math">\\mathbf{G}_{2}</span> are the same, except that in game <span class="math">\\mathbf{G}_{1}</span>, the triple <span class="math">(\\hat{g},a^{<em>},\\hat{a}^{</em>})</span> is uniformly distributed in <span class="math">\\mathcal{D}^{\\prime}_{\\lambda,\\Gamma}</span>, and in game <span class="math">\\mathbf{G}_{2}</span>, the triple <span class="math">(\\hat{g},a^{<em>},\\hat{a}^{</em>})</span> is uniformly distributed in <span class="math">\\mathcal{T}^{\\prime}_{\\lambda,\\Gamma}</span>. Thus, any difference in behavior between these two games immediately yields a statistical test for the distinguishing Diffie-Hellman triple from non-Diffie-Hellman triples. More precisely, we have:</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Lemma 5</h6>

    <p class="text-gray-300">There exists a probabilistic algorithm <span class="math">\\mathsf{A}_{1}</span>, whose running time is essentially the same as that of <span class="math">\\mathsf{A}</span>, such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[T_{2}]-\\Pr[T_{1}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\mathsf{AdvDDH}_{\\mathcal{G},\\mathsf{A}_{1}}(\\lambda\\mid\\Gamma)+3/q.$ (5)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-46" class="text-lg font-semibold mt-6">Game G_{3}.</h4>

    <p class="text-gray-300">In this game, we modify the decryption oracle in game <span class="math">\\mathbf{G}_{2}</span> to obtain a new game <span class="math">\\mathbf{G}_{3}</span>. Instead of using the original decryption algorithm, we modify the decryption algorithm, replacing steps D4 and D5 with:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{D4^{\\prime}}</span>: Test if <span class="math">\\hat{a}=a^{w}</span> and <span class="math">d=a^{x+yv}</span>; output reject and halt if this is not the case.</li>

      <li><span class="math">\\mathbf{D5^{\\prime}}:\\ b\\leftarrow a^{z}</span>.</li>

    </ul>

    <p class="text-gray-300">Note that the decryption oracle now make use of <span class="math">w</span>, but does not make use of <span class="math">x_{1},y_{2},y_{1},y_{2},z_{1},z_{2}</span>, except indirectly through the values <span class="math">x,y,z</span>.</p>

    <p class="text-gray-300">Now, let <span class="math">R_{3}</span> be the event that in game <span class="math">\\mathbf{G}_{3}</span>, some ciphertext <span class="math">\\psi</span> is submitted to the decryption oracle that is rejected in step <span class="math">\\mathbf{D4^{\\prime}}</span> but that would have passed the test in step D4.</p>

    <p class="text-gray-300">Note that if a ciphertext passes the test in <span class="math">\\mathbf{D4^{\\prime}}</span>, it would also have passed the test in D4.</p>

    <p class="text-gray-300">It is clear that games <span class="math">\\mathbf{G}_{2}</span> and <span class="math">\\mathbf{G}_{3}</span> proceed identically until the event <span class="math">R_{3}</span> occurs. In particular, the event <span class="math">T_{2}\\wedge\\neg R_{3}</span> and <span class="math">T_{3}\\wedge\\neg R_{3}</span> are identical. So by Lemma 4, we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[T_{3}]-\\Pr[T_{2}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\Pr[R_{3}],$ (6)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and so it suffices to bound <span class="math">\\Pr[R_{3}]</span>. We introduce auxiliary games <span class="math">\\mathbf{G}_{4}</span> and <span class="math">\\mathbf{G}_{5}</span> below to do this.</p>

    <h4 id="sec-47" class="text-lg font-semibold mt-6">Game G_{4}.</h4>

    <p class="text-gray-300">This game is identical to game <span class="math">\\mathbf{G}_{3}</span>, except for a small modification to the encryption oracle. We again modify the algorithm used by the encryption oracle, replacing step E5 by</p>

    <p class="text-gray-300"><span class="math">\\mathbf{E5^{\\prime}}:\\ r\\xrightarrow{\\mu}\\mathbf{Z}_{q};\\ c\\leftarrow g^{r}.</span></p>

    <p class="text-gray-300">It is clear by construction that</p>

    <p class="text-gray-300"><span class="math">\\Pr[T_{4}]=1/2,</span> (7)</p>

    <p class="text-gray-300">since in game <span class="math">\\mathbf{G}_{4}</span>, the variable <span class="math">\\sigma</span> is never used at all, and so the adversary’s output is independent of <span class="math">\\sigma</span>.</p>

    <p class="text-gray-300">Define the event <span class="math">R_{4}</span> to be the event in game <span class="math">\\mathbf{G}_{4}</span> analogous to the event <span class="math">R_{3}</span> in game <span class="math">G_{3}</span>; that is, <span class="math">R_{4}</span> is the event that in game <span class="math">\\mathbf{G}_{4}</span>, some ciphertext <span class="math">\\psi</span> is submitted to the decryption oracle that is rejected in step <span class="math">\\mathbf{D4^{\\prime}}</span> but that would have passed the test in step D4.</p>

    <p class="text-gray-300">We show that this modification has no effect; more precisely:</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Lemma 6</h6>

    <p class="text-gray-300">We have</p>

    <p class="text-gray-300"><span class="math">\\Pr[T_{4}]</span> <span class="math">=</span> <span class="math">\\Pr[T_{3}],</span> (8) <span class="math">\\Pr[R_{4}]</span> <span class="math">=</span> <span class="math">\\Pr[R_{3}].</span> (9)</p>

    <p class="text-gray-300">Game <span class="math">\\mathbf{G}_{5}</span>. This game is the same as game <span class="math">\\mathbf{G}_{4}</span>, except for the following modification.</p>

    <p class="text-gray-300">We modify the decryption oracle so that it applies the following special rejection rule: if the adversary submits a ciphertext <span class="math">\\psi</span> for decryption at a point in time after the encryption oracle has been invoked, such that <span class="math">(a,\\hat{a},c)\\neq(a^{<em>},\\hat{a}^{</em>},c^{<em>})</span> but <span class="math">v=v^{</em>}</span>, then the decryption oracle immediately outputs reject and halts (before executing step <span class="math">\\mathbf{D4^{\\prime}}</span>).</p>

    <p class="text-gray-300">To analyze this game, we define two events.</p>

    <p class="text-gray-300">First, we define the event <span class="math">C_{5}</span> to be the event that the decryption oracle in game <span class="math">\\mathbf{G}_{5}</span> rejects a ciphertext using the special rejection rule.</p>

    <p class="text-gray-300">Second, we define the event <span class="math">R_{5}</span> to be the event in game <span class="math">\\mathbf{G}_{5}</span> that some ciphertext <span class="math">\\psi</span> is submitted to the decryption oracle that is rejected in step <span class="math">\\mathbf{D4^{\\prime}}</span> but that would have passed the test in step <span class="math">\\mathbf{D4}</span>. Note that such a ciphertext is not rejected by the special rejection rule, since that rule is applied before step <span class="math">\\mathbf{D4^{\\prime}}</span> is executed.</p>

    <p class="text-gray-300">Now, it is clear that games <span class="math">\\mathbf{G}_{4}</span> and <span class="math">\\mathbf{G}_{5}</span> proceed identically until event <span class="math">C_{5}</span> occurs. In particular, the events <span class="math">R_{4}\\wedge\\neg C_{5}</span> and <span class="math">R_{5}\\wedge\\neg C_{5}</span> are identical. So by Lemma 4, we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[R_{5}]-\\Pr[R_{4}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\Pr[C_{5}].$ (10)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Now, if event <span class="math">C_{5}</span> occurs with non-negligible probability, we immediately get an algorithm that contradicts the target collision resistance assumption; more precisely:</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Lemma 7</h6>

    <p class="text-gray-300">There exists a probabilistic algorithm <span class="math">\\mathsf{A}_{2}</span>, whose running time is essentially the same as that of <span class="math">\\mathsf{A}</span>, such that</p>

    <p class="text-gray-300"><span class="math">\\Pr[C_{5}]\\leq\\mathsf{AdvTCR}_{\\mathsf{HF,A_{2}}}(\\lambda\\mid\\Gamma)+1/q.</span> (11)</p>

    <p class="text-gray-300">Finally, we show that event <span class="math">R_{5}</span> occurs with negligible probability, based on purely information-theoretic considerations:</p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Lemma 8</h6>

    <p class="text-gray-300">We have</p>

    <p class="text-gray-300"><span class="math">\\Pr[R_{5}]\\leq Q_{\\mathsf{A}}(\\lambda)/q.</span> (12)</p>

    <p class="text-gray-300">The detailed proof of this lemma is presented below. However, the basic idea of the proof runs as follows. For a decryption query <span class="math">\\psi</span>, the only information the adversary has about <span class="math">(x_{1},x_{2},y_{1},y_{2})</span> are the values of <span class="math">x</span>, <span class="math">y</span>, and possibly <span class="math">s^{*}</span>, which are linear combinations of <span class="math">(x_{1},x_{2},y_{1},y_{2})</span>. As we will prove, the value of <span class="math">t</span>, which the adversary must successfully guess in order to make the event <span class="math">R_{5}</span> happen, is an independent linear combination of <span class="math">(x_{1},x_{2},y_{1},y_{2})</span>, and is therefore unpredictable.</p>

    <p class="text-gray-300">Inequality (3) now follows immediately from (4)-(12).</p>

    <h3 id="sec-51" class="text-xl font-semibold mt-8">Proofs of Lemmas</h3>

    <p class="text-gray-300">To complete the proof of Theorem 1, we now present the proofs of Lemmas 5, 6, 7, and 8.</p>

    <p class="text-gray-300">Proof of Lemma 5. We describe the algorithm <span class="math">\\mathsf{A}_1</span> in detail. For a given value of <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>, it takes as input <span class="math">\\mathbf{1}^{\\lambda}</span>, <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span>, and <span class="math">\\rho = (\\hat{g}, a^{<em>}, \\hat{a}^{</em>}) \\in G^{3}</span>.</p>

    <p class="text-gray-300">Algorithm <span class="math">\\mathsf{A}_1</span> provides an environment for <span class="math">\\mathsf{A}</span>, interacting with <span class="math">\\mathsf{A}</span> as follows.</p>

    <p class="text-gray-300">First, <span class="math">\\mathsf{A}_1</span> computes</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{hk} \\stackrel {R}{\\leftarrow} \\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda,\\Gamma}; \\; x_1, x_2, y_1, y_2, z_1, z_2 \\stackrel {R}{\\leftarrow} \\mathbf{Z}_q; \\; e \\leftarrow g^{x_1} \\hat{g}^{x_2}; \\; f \\leftarrow g^{y_1} \\hat{g}^{y_2}; \\; h \\leftarrow g^{z_1} \\hat{g}^{z_2};</span></div>

    <p class="text-gray-300">to generate a public key <span class="math">\\mathsf{PK} = (\\Gamma, \\mathsf{hk}, \\hat{g}, e, f, h)</span> and a secret key <span class="math">\\mathsf{SK} = (\\Gamma, \\mathsf{hk}, x_1, x_2, y_1, y_2, z_1, z_2)</span>. It then gives <span class="math">\\mathsf{PK}</span> to <span class="math">\\mathsf{A}</span>.</p>

    <p class="text-gray-300">Whenever <span class="math">\\mathsf{A}</span> submits a ciphertext <span class="math">\\psi = (a, \\hat{a}, c, d)</span> to the decryption oracle, <span class="math">\\mathsf{A}_1</span> simply runs the decryption algorithm, using the secret key <span class="math">\\mathsf{SK}</span>.</p>

    <p class="text-gray-300">When <span class="math">\\mathsf{A}</span> submits <span class="math">(m_0, m_1)</span> to the encryption oracle, <span class="math">\\mathsf{A}_1</span> computes</p>

    <div class="my-4 text-center"><span class="math-block">\\sigma \\stackrel {R} {\\leftarrow} \\{0, 1 \\}; \\; b^* \\leftarrow (a^*)^{z_1} (\\hat{a}^*)^{z_2}; \\; c^* \\leftarrow b^* \\cdot m_\\sigma; \\; v^* \\leftarrow \\mathsf{HF}_{\\mathsf{hk}}^{\\lambda,\\Gamma}(a^*, \\hat{a}^*, c*); \\; d^* \\leftarrow (a^*)^{x_1 + y_1 v^*} (\\hat{a}^*)^{x_2 + y_2 v^};</span></div>

    <p class="text-gray-300">and responds with the "ciphertext" <span class="math">\\psi^{<em>} = (a^{</em>}, \\hat{a}^{<em>}, c^{</em>}, d^{*})</span>.</p>

    <p class="text-gray-300">When <span class="math">\\mathsf{A}</span> outputs <span class="math">\\hat{\\sigma}</span> and halts, <span class="math">\\mathsf{A}_1</span> outputs 1 if <span class="math">\\sigma = \\hat{\\sigma}</span> and 0 if <span class="math">\\sigma \\neq \\hat{\\sigma}</span>.</p>

    <p class="text-gray-300">That completes the description of <span class="math">\\mathsf{A}_1</span>. By construction, it is clear that for fixed <span class="math">\\lambda</span> and <span class="math">\\Gamma \\in [\\mathbf{S}_{\\lambda}]</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr[T_1] = \\Pr[\\tau = 1: \\rho \\stackrel{R}{\\leftarrow} \\mathcal{D}_{\\lambda,\\Gamma}&#x27; ; \\tau \\stackrel{R}{\\leftarrow} \\mathsf{A}_1(\\mathbf{1}^{\\lambda}, \\Gamma, \\rho)];</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Pr[T_2] = \\Pr[\\tau = 1: \\rho \\stackrel{R}{\\leftarrow} \\mathcal{T}_{\\lambda,\\Gamma}&#x27; ; \\tau \\stackrel{R}{\\leftarrow} \\mathsf{A}_1(\\mathbf{1}^{\\lambda}, \\Gamma, \\rho)].</span></div>

    <p class="text-gray-300">Thus,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[T_2] - \\Pr[T_1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\mathsf{AdvDDH}_{\\mathcal{G},\\mathsf{A}_1}'(\\lambda \\mid \\Gamma),</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">and so (5) now follows directly from this and Lemma 1. <span class="math">\\square</span></p>

    <p class="text-gray-300">Before continuing, we state and prove a simple but useful lemma.</p>

    <p class="text-gray-300">Lemma 9 Let <span class="math">k, n</span> be integers with <span class="math">1 \\leq k \\leq n</span>, and let <span class="math">K</span> be a finite field. Consider a probability space with random variables <span class="math">\\vec{\\alpha} \\in K^{n \\times 1}</span>, <span class="math">\\vec{\\beta} = (\\beta_1, \\ldots, \\beta_k)^T \\in K^{k \\times 1}</span>, <span class="math">\\vec{\\gamma} \\in K^{k \\times 1}</span>, and <span class="math">M \\in K^{k \\times n}</span>, such that <span class="math">\\vec{\\alpha}</span> is uniformly distributed over <span class="math">K^{n \\times 1}</span>, <span class="math">\\vec{\\beta} = M\\vec{\\alpha} + \\vec{\\gamma}</span>, and for <span class="math">1 \\leq i \\leq k</span>, the <span class="math">i</span>th rows of <span class="math">M</span> and <span class="math">\\vec{\\gamma}</span> are determined by <span class="math">\\beta_1, \\ldots, \\beta_{i-1}</span>.</p>

    <p class="text-gray-300">Then conditioning on any fixed values of <span class="math">\\beta_1, \\ldots, \\beta_{k-1}</span> such that the resulting matrix <span class="math">M</span> has rank <span class="math">k</span>, the value of <span class="math">\\beta_k</span> is uniformly distributed over <span class="math">K</span> in the resulting conditional probability space.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Consider fixed values of <span class="math">\\beta_1, \\ldots, \\beta_{k-1} \\in K</span>, which determine <span class="math">M</span> and <span class="math">\\vec{\\gamma}</span>, and assume that the matrix <span class="math">M</span> has rank <span class="math">k</span>. For any <span class="math">\\beta_k \\in K</span>, consider the corresponding vector <span class="math">\\vec{\\beta} = (\\beta_1, \\ldots, \\beta_k)^T</span>; there are exactly $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{n-k}<span class="math"> vectors </span>\\vec{\\alpha}<span class="math"> such that </span>\\vec{\\beta} = M\\vec{\\alpha} + \\vec{\\gamma}<span class="math">. Therefore, each possible value </span>\\beta_k \\in K<span class="math"> is equally likely. </span>\\square$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof of Lemma 6. Consider the quantity</p>

    <div class="my-4 text-center"><span class="math-block">X := (\\mathsf{Coins}, \\mathsf{hk}, w, x_1, x_2, y_1, y_2, \\sigma, u^*, \\hat{u}^*)</span></div>

    <p class="text-gray-300">and the quantity <span class="math">z</span>. Note that <span class="math">X</span> and <span class="math">z</span> take on the same values in games <span class="math">\\mathbf{G}_3</span> and <span class="math">\\mathbf{G}_4</span>.</p>

    <p class="text-gray-300">Consider also the quantity <span class="math">r^<em></span>. This quantity takes on different values in games <span class="math">\\mathbf{G}_3</span> and <span class="math">\\mathbf{G}_4</span>. For clarity, let us denote these values as <span class="math">[r^</em>]_3</span> and <span class="math">[r^*]_4</span>, respectively.</p>

    <p class="text-gray-300">It is clear by inspection that the events <span class="math">R_3</span> and <span class="math">T_3</span> are determined as functions of <span class="math">X</span>, <span class="math">z</span>, and <span class="math">[r^<em>]_3</span>. Also, the events <span class="math">R_4</span> and <span class="math">T_4</span> have precisely the same functional dependence on <span class="math">X</span>, <span class="math">z</span>, and <span class="math">[r^</em>]_4</span>.</p>

    <p class="text-gray-300">So to prove the lemma, it suffices to show that the distributions of <span class="math">(X,z,[r^{<em>}]_{3})</span> and <span class="math">(X,z,[r^{</em>}]_{4})</span> are identical. Observe that by construction, conditioning on any fixed values of <span class="math">X</span> and <span class="math">z</span>, the distribution of <span class="math">[r^{<em>}]_{4}</span> is uniform over <span class="math">\\mathbf{Z}_{q}</span>. So it will suffice to show that conditioning on any fixed values of <span class="math">X</span> and <span class="math">z</span>, the distribution of <span class="math">[r^{</em>}]_{3}</span> is also uniform over <span class="math">\\mathbf{Z}_{q}</span>.</p>

    <p class="text-gray-300">We have</p>

    <div class="my-4 text-center"><span class="math-block">\\left( \\begin{array}{c} z \\\\ [ r ^ {*} ] _ {3} \\end{array} \\right) = \\underbrace {\\left( \\begin{array}{cc} 1 &amp;amp; w \\\\ u ^ {*} &amp;amp; w \\hat {u} ^ {*} \\end{array} \\right)} _ {=: M} \\cdot \\left( \\begin{array}{c} z _ {1} \\\\ z _ {2} \\end{array} \\right) + \\left( \\begin{array}{c} 0 \\\\ \\log_ {g} m _ {\\sigma} \\end{array} \\right).</span></div>

    <p class="text-gray-300">Conditioning only on a fixed value of <span class="math">X</span>, the matrix <span class="math">M</span> is fixed, but the values <span class="math">z_{1}</span> and <span class="math">z_{2}</span> are still uniformly and independently distributed over <span class="math">\\mathbf{Z}_q</span>. Observe that <span class="math">\\operatorname<em>{det}(M) = w(\\hat{u}^{</em>} - u^{<em>}) \\neq 0</span>. If we further condition on a fixed value of <span class="math">z</span>, the value of <span class="math">m_{\\sigma}</span> is fixed, and by Lemma 9, the distribution of <span class="math">[r^{</em>}]_{3}</span> is uniform over <span class="math">\\mathbf{Z}_q</span>.</p>

    <p class="text-gray-300">Proof of Lemma 7. Algorithm <span class="math">\\mathsf{A}_2</span> provides an environment for <span class="math">\\mathsf{A}</span>, interacting with <span class="math">\\mathsf{A}</span> as follows.</p>

    <p class="text-gray-300">Algorithm <span class="math">\\mathsf{A}_2</span> takes as input <span class="math">1^{\\lambda}</span>, <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span>, <span class="math">\\rho^{<em>} = (a^{</em>}, \\hat{a}^{<em>}, c^{</em>}) \\in G^{3}</span>, and <span class="math">\\mathsf{hk} \\in [\\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda, \\Gamma}]</span>. It first constructs a public key <span class="math">\\mathsf{PK}</span> and secret key <span class="math">\\mathsf{SK}</span> for the encryption scheme using the standard key generation algorithm, except that the given values of <span class="math">\\Gamma</span> and <span class="math">\\mathsf{hk}</span> are used. It also constructs the target ciphertext <span class="math">\\psi^{<em>} = (a^{</em>}, \\hat{a}^{<em>}, c^{</em>}, d^{<em>})</span>, where <span class="math">a^{</em>}, \\hat{a}^{<em>}, c^{</em>}</span> are the given inputs as above, and where <span class="math">d^{*}</span> is computed as</p>

    <div class="my-4 text-center"><span class="math-block">v ^ {*} \\leftarrow \\mathsf {H F} _ {\\mathsf {h k}} ^ {\\lambda , \\Gamma} (a ^ {*}, \\hat {a} ^ {*}, c ^ {*}); d ^ {*} \\leftarrow (a ^ {*}) ^ {x _ {1} + y _ {1} v ^ {*}} (\\hat {a} ^ {*}) ^ {x _ {2} + y _ {2} v ^ {*}}.</span></div>

    <p class="text-gray-300">Here, <span class="math">\\mathsf{hk}</span> is the given input as above, and <span class="math">x_{1},y_{1},x_{2},y_{2}</span> are the values taken from the secret key <span class="math">\\mathsf{SK}</span> as computed above.</p>

    <p class="text-gray-300">Now <span class="math">\\mathsf{A}_2</span> interacts with <span class="math">\\mathsf{A}</span> using the rules of game <span class="math">\\mathbf{G}_5</span> for the decryption oracle, and giving <span class="math">\\mathsf{A}</span> the target ciphertext <span class="math">\\psi^{*}</span> when <span class="math">\\mathsf{A}</span> invokes the encryption oracle. However, if the decryption oracle ever invokes the special rejection rule in game <span class="math">\\mathbf{G}_5</span> for a given ciphertext <span class="math">\\psi</span>, algorithm <span class="math">\\mathsf{A}_2</span> immediately outputs <span class="math">(a, \\hat{a}, c)</span> corresponding to <span class="math">\\psi</span> and halts. Also, if the attack terminates without the special rejection rule ever having been invoked, then <span class="math">\\mathsf{A}_2</span> also halts (without producing any output).</p>

    <p class="text-gray-300">That completes the description of <span class="math">\\mathsf{A}_2</span>. If the input <span class="math">(a^<em>, \\hat{a}^</em>, c^<em>)</span> to <span class="math">\\mathsf{A}_2</span> is sampled uniformly over all triples of group elements, subject to <span class="math">\\log_g a^</em> \\neq \\log_{\\tilde{g}} \\hat{a}^<em></span>, then algorithm <span class="math">\\mathsf{A}_2</span> succeeds in finding a collision with probability exactly <span class="math">\\operatorname</em>{Pr}[C_5]</span>. However, in the definition of AdvTCR, the input is sampled from the uniform distribution over all triples, not subject to the above restriction. The bound (11) follows from the fact that the statistical distance between these two input distributions is <span class="math">1/q</span>.</p>

    <p class="text-gray-300">Proof of Lemma 8. To prove (12), for <span class="math">1 \\leq i \\leq Q_{\\mathsf{A}}(\\lambda)</span>, let us define <span class="math">R_5^{(i)}</span> to be the event that there is an <span class="math">i</span>th ciphertext submitted to the decryption oracle in game <span class="math">\\mathbf{G}_5</span>, and that the submitted ciphertext is rejected in step D4' but would have passed the test in step D4. For <span class="math">1 \\leq i \\leq Q_{\\mathsf{A}}(\\lambda)</span>, let us define <span class="math">B_5^{(i)}</span> to be the event that the <span class="math">i</span>th decryption oracle query occurs before the encryption oracle query, and that the submitted ciphertext passes the test in steps D1 and D2 of the decryption oracle. For <span class="math">1 \\leq i \\leq Q_{\\mathsf{A}}(\\lambda)</span>, let us define <span class="math">\\hat{B}_5^{(i)}</span> to be the event that the <span class="math">i</span>th decryption oracle query occurs after the encryption oracle query, and that the submitted ciphertext passes the tests in steps D1 and D2 of the decryption oracle.</p>

    <p class="text-gray-300">The bound (12) will follow immediately from Lemmas 10 and 11 below.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma 10 Notation as in the proof of Lemma 8. For all <span class="math">1 \\leq i \\leq Q_{\\mathsf{A}}(\\lambda)</span>, we have $\\operatorname*{Pr}[R_5^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B_5^{(i)}] \\leq 1/q$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-52" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Fix <span class="math">1\\leq i\\leq Q_{\\mathsf{A}}(\\lambda)</span>. Consider the quantities</p>

    <p class="text-gray-300"><span class="math">X:=(\\mathsf{Coins},\\mathsf{hk},w,z)</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">X^{\\prime}:=(x,y).</span></p>

    <p class="text-gray-300">The values of <span class="math">X</span> and <span class="math">X^{\\prime}</span> completely determine the behavior of the adversary up until the point when the encryption oracle is invoked, and in particular, they completely determine the event <span class="math">B_{5}^{(i)}</span>. Let us call <span class="math">X</span> and <span class="math">X^{\\prime}</span> relevant if the event <span class="math">B_{5}^{(i)}</span> occurs.</p>

    <p class="text-gray-300">It will suffice prove that conditioned on any fixed, relevant values of <span class="math">X</span> and <span class="math">X^{\\prime}</span>, the probability that <span class="math">R_{5}^{(i)}</span> occurs is bounded by <span class="math">1/q</span>.</p>

    <p class="text-gray-300">Once relevant values of <span class="math">X</span> and <span class="math">X^{\\prime}</span> are fixed, the value <span class="math">\\psi</span> of the <span class="math">i</span>th decryption query is also fixed, along with the corresponding values <span class="math">a,\\hat{a},b,c,d,u,\\hat{u},v,r</span>, and <span class="math">s</span>.</p>

    <p class="text-gray-300">The test in <span class="math">\\mathbf{D4^{\\prime}}</span> fails if and only if one of the two mutually exclusive conditions (<span class="math">\\hat{a}\\neq a^{w}</span>) or (<span class="math">\\hat{a}=a^{w}</span> and <span class="math">d\\neq a^{x+yv}</span>) holds. It is easy to verify that if the second condition holds, then in fact the test in <span class="math">\\mathbf{D4}</span> fails. Thus, if the test in <span class="math">\\mathbf{D4^{\\prime}}</span> fails but that in <span class="math">\\mathbf{D4}</span> passes, it must be the case that <span class="math">\\hat{a}\\neq a^{w}</span> and <span class="math">d=a^{x_{1}+y_{1}v}\\hat{a}^{x_{2}+y_{2}v}</span>. So we only need to consider values of <span class="math">X</span> and <span class="math">X^{\\prime}</span> such that <span class="math">\\hat{a}\\neq a^{w}</span>. The condition <span class="math">\\hat{a}\\neq a^{w}</span> is equivalent to the condition <span class="math">u\\neq\\hat{u}</span>, and the condition <span class="math">d=a^{x_{1}+y_{1}v}\\hat{a}^{x_{2}+y_{2}v}</span> is equivalent to the condition <span class="math">s=t</span>.</p>

    <p class="text-gray-300">We have</p>

    <p class="text-gray-300">\\[ \\left(\\begin{array}[]{c}x\\\\ y\\\\ t\\end{array}\\right)=\\underbrace{\\left(\\begin{array}[]{cccc}1&w&0&0\\\\ 0&0&1&w\\\\ u&\\hat{u}w&uv&\\hat{u}vw\\end{array}\\right)}_{=:M}\\cdot\\left(\\begin{array}[]{c}x_{1}\\\\ x_{2}\\\\ y_{1}\\\\ y_{2}\\end{array}\\right). \\]</p>

    <p class="text-gray-300">Let us first condition only on a fixed value of <span class="math">X</span>, which fixes the first two rows of <span class="math">M</span>, but leaves the values <span class="math">x_{1}</span>, <span class="math">x_{2}</span>, <span class="math">y_{1}</span>, and <span class="math">y_{2}</span> still uniformly distributed over <span class="math">\\mathbf{Z}_{q}</span> and mutually independent. Let us further condition on a fixed value of <span class="math">X^{\\prime}</span> such that <span class="math">X</span> and <span class="math">X^{\\prime}</span> are relevant, and that <span class="math">u\\neq\\hat{u}</span>. The third row of <span class="math">M</span> is also fixed, along with the values <span class="math">x</span>, <span class="math">y</span>, and <span class="math">s</span>. It is easy to see by inspection that the rows of <span class="math">M</span> are linearly independent, since <span class="math">\\hat{u}\\neq u</span> and <span class="math">w\\neq 0</span>. From this, it follows by Lemma 9 that <span class="math">t</span> is still uniformly distributed over <span class="math">\\mathbf{Z}_{q}</span>, but since <span class="math">s</span> is fixed, we have <span class="math">\\Pr[s=t]=1/q</span>.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Lemma 11</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Notation as in the proof of Lemma 8. For all <span class="math">1\\leq i\\leq Q_{\\mathsf{A}}(\\lambda)</span>, we have $\\Pr[R_{5}^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{B}_{5}^{(i)}]\\leq 1/q$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-54" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Fix <span class="math">1\\leq i\\leq Q_{\\mathsf{A}}(\\lambda)</span>. Consider the quantities</p>

    <p class="text-gray-300"><span class="math">X:=(\\mathsf{Coins},\\mathsf{hk},w,z,u^{<em>},\\hat{u}^{</em>},r^{*})</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">X^{\\prime}:=(x,y,s^{*}).</span></p>

    <p class="text-gray-300">The values of <span class="math">X</span> and <span class="math">X^{\\prime}</span> completely determine the adversary’s entire behavior in game <span class="math">\\mathbf{G}_{5}</span>, and in particular, they completely determine the event <span class="math">\\hat{B}_{5}^{(i)}</span>. Let us call <span class="math">X</span> and <span class="math">X^{\\prime}</span> relevant if the event <span class="math">\\hat{B}_{5}^{(i)}</span> occurs.</p>

    <p class="text-gray-300">It will suffice prove that conditioned on any fixed, relevant values of <span class="math">X</span> and <span class="math">X^{\\prime}</span>, the probability that <span class="math">R_{5}^{(i)}</span> occurs is bounded by <span class="math">1/q</span></p>

    <p class="text-gray-300">Once <span class="math">X</span> and <span class="math">X^{\\prime}</span> are fixed, the value <span class="math">\\psi</span> of the <span class="math">i</span>th decryption query is also fixed, along with the corresponding values <span class="math">a,\\hat{a},b,c,d,u,\\hat{u},v,r,</span> and <span class="math">s</span>. As in the proof of Lemma 10, it suffices to consider values of <span class="math">X</span> and <span class="math">X^{\\prime}</span> for which <span class="math">u\\neq\\hat{u}</span>, and then to show that <span class="math">\\Pr[s=t]\\leq q</span>. Notice that the value of <span class="math">X</span> determines the value of <span class="math">v^{<em>}</span>, and we may also assume that <span class="math">v\\neq v^{</em>}</span>. To see why we may do so, if <span class="math">v=v^{<em>}</span>, then either <span class="math">(a,\\hat{a},c)=(a^{</em>},\\hat{a}^{<em>},c^{</em>})</span>, or <span class="math">\\psi</span> is rejected by the special rejection rule. In the first case, since <span class="math">\\psi\\neq\\psi^{<em>}</span>, we must have <span class="math">d\\neq d^{</em>}</span>, but this implies that <span class="math">\\psi</span> fails the test in D4. In the second case, step D4^{′} is not even executed.</p>

    <p class="text-gray-300">We have</p>

    <p class="text-gray-300">\\[ \\left(\\begin{array}[]{c}x\\\\ y\\\\ s^{<em>}\\\\ t\\end{array}\\right)=\\underbrace{\\left(\\begin{array}[]{cccc}1&w&0&0\\\\ 0&0&1&w\\\\ u^{</em>}&\\hat{u}^{<em>}w&u^{</em>}v^{<em>}&\\hat{u}^{</em>}v^{*}w\\\\ u&\\hat{u}w&uv&\\hat{u}vw\\end{array}\\right)}_{\\eqqcolon M}\\cdot\\left(\\begin{array}[]{c}x_{1}\\\\ x_{2}\\\\ y_{1}\\\\ y_{2}\\end{array}\\right). \\]</p>

    <p class="text-gray-300">Let us first condition only on a fixed value of <span class="math">X</span>, which fixes the first three rows of <span class="math">M</span>, but leaves the values <span class="math">x_{1}</span>, <span class="math">x_{2}</span>, <span class="math">y_{1}</span>, and <span class="math">y_{2}</span> still uniformly distributed over <span class="math">\\mathbf{Z}_{q}</span> and mutually independent. Let us further condition on a fixed value of <span class="math">X^{\\prime}</span> such that <span class="math">X</span> and <span class="math">X^{\\prime}</span> are relevant, and that <span class="math">u\\neq\\hat{u}</span> and <span class="math">v\\neq v^{<em>}</span>. The fourth row of <span class="math">M</span> is also fixed, along with the values <span class="math">x</span>, <span class="math">y</span>, <span class="math">s^{</em>}</span>, and <span class="math">s</span>. It is easy to see that the rows of <span class="math">M</span> are linearly independent, since</p>

    <p class="text-gray-300"><span class="math">\\det(M)=w^{2}(\\hat{u}-u)(\\hat{u}^{<em>}-u^{</em>})(v^{*}-v)\\neq 0.</span></p>

    <p class="text-gray-300">From this, it follows by Lemma 9 that <span class="math">t</span> is still uniformly distributed over <span class="math">\\mathbf{Z}_{q}</span>, but since <span class="math">s</span> is fixed, we have <span class="math">\\Pr[s=t]=1/q</span>.</p>

    <h3 id="sec-55" class="text-xl font-semibold mt-8">6.3 Two variations</h3>

    <p class="text-gray-300">Scheme CS1 was presented because it is in a form that is particularly easy to analyze. We now describe and analyze two variations of the scheme CS1, which we call CS1a and CS1b, that are a bit simpler than CS1, but that require a bit more work to analyze. For both of these schemes, the public key has the same format and indeed, the same probability distribution, as in CS1, and the encryption algorithm is the same as in CS1. The key generation and decryption algorithms are slightly different, however, and are described in detail in Figures 2 and 3.</p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Remark 6</h6>

    <p class="text-gray-300">Scheme CS1a is essentially the same scheme that was originally presented as the “main scheme” in <em>[x10]</em>. Scheme CS1b is a minor variation of a scheme originally presented in <em>[x27]</em>.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Remark 7</h6>

    <p class="text-gray-300">Note that in scheme CS1b, we do not have to separately test if <span class="math">\\hat{a}</span> belongs to the subgroup <span class="math">G</span> in step D2^{′}, since this is already implied by the test in step D4^{′}. The test that <span class="math">a</span> and <span class="math">c</span> belong to <span class="math">G</span> may in some cases be implemented by testing if <span class="math">a^{q}=1_{G}</span> and <span class="math">c^{q}=1_{G}</span>.</p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Remark 8</h6>

    <p class="text-gray-300">Note also in scheme CS1b, the decryption algorithm has to compute either three or four (if we test if <span class="math">a^{q}=1_{G}</span>) powers of <span class="math">a</span>, and possibly one power of <span class="math">c</span> (if we test if <span class="math">c^{q}=1_{G}</span>). Special algorithmic techniques <em>[x5, x22]</em> can be employed to compute these several powers of <span class="math">a</span> significantly faster than computing several powers of different group elements.</p>

    <h6 id="sec-59" class="text-base font-medium mt-4">Remark 9</h6>

    <p class="text-gray-300">In an actual implementation, it is strongly recommended to compute both exponentiations in step D4^{′} of CS1b before rejecting the ciphertext, even if the first exponentiation performed already implies that the ciphertext should be rejected. The reason is that if the ciphertext is rejected</p>

    <p class="text-gray-300">Key Generation: On input  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , compute</p>

    <p class="text-gray-300"><span class="math">\\Gamma[\\hat{G}, G, g, q] \\stackrel{\\mu}{\\leftarrow} \\hat{S}(1^{\\lambda})</span> ;  <span class="math">\\mathsf{hk} \\stackrel{\\mu}{\\leftarrow} \\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda, \\Gamma}</span> ;</p>

    <p class="text-gray-300"><span class="math">w\\stackrel {\\mu}{\\leftarrow}\\mathbf{Z}_q^*</span>  .  <span class="math">x_{1},x_{2},y_{1},y_{2},z\\stackrel {\\mu}{\\leftarrow}\\mathbf{Z}_{q};</span></p>

    <p class="text-gray-300"><span class="math">\\hat{g}\\gets g^{w};e\\gets g^{x_1}\\hat{g}^{x_2};f\\gets g^{y_1}\\hat{g}^{y_2};h\\gets g^z;</span></p>

    <p class="text-gray-300">and output the public key  <span class="math">\\mathsf{PK} = (\\Gamma ,\\mathsf{hk},\\hat{g},e,f,h)</span>  and the secret key  <span class="math">\\mathsf{SK} = (\\Gamma ,\\mathsf{hk},x_1,x_2,y_1,y_2,z)</span> .</p>

    <p class="text-gray-300">Decryption: Given  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , a secret key</p>

    <p class="text-gray-300"><span class="math">\\mathsf{SK} = (\\Gamma [\\hat{G},G,g,q],\\mathsf{hk},x_1,x_2,y_1,y_2,z)\\in [\\mathbf{S}_\\lambda ]\\times [\\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda ,\\Gamma}]\\times \\mathbf{Z}_q^5,</span></p>

    <p class="text-gray-300">along with a ciphertext  <span class="math">\\psi</span> , do the following.</p>

    <p class="text-gray-300">D1: Parse  <span class="math">\\psi</span>  as a 4-tuple  <span class="math">(a, \\hat{a}, c, d) \\in \\hat{G}^4</span> ; output reject and halt if  <span class="math">\\psi</span>  is not of this form. D2: Test if  <span class="math">a</span> ,  <span class="math">\\hat{a}</span> , and  <span class="math">c</span>  belong to  <span class="math">G</span> ; output reject and halt if this is not the case. D3: Compute  <span class="math">v \\gets \\mathsf{HF}_{\\mathsf{hk}}^{\\lambda, \\Gamma}(a, \\hat{a}, c)</span> . D4: Test if  <span class="math">d = a^{x_1 + y_1v}\\hat{a}^{x_2 + y_2v}</span> ; output reject and halt if this is not the case. D5': Compute  <span class="math">b \\gets a^z</span> . D6: Compute  <span class="math">m \\gets c \\cdot b^{-1}</span> , and output  <span class="math">m</span> .</p>

    <p class="text-gray-300">Figure 2: Key generation and decryption algorithms for CS1a</p>

    <p class="text-gray-300">Key Generation: On input  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , compute</p>

    <p class="text-gray-300"><span class="math">\\Gamma[\\hat{G}, G, g, q] \\stackrel{\\mu}{\\leftarrow} \\hat{S}(1^{\\lambda})</span> ;  <span class="math">\\mathsf{hk} \\stackrel{\\mu}{\\leftarrow} \\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda, \\Gamma}</span> ;</p>

    <p class="text-gray-300"><span class="math">w\\stackrel {\\mu}{\\leftarrow}\\mathbf{Z}_q^*</span>  .  <span class="math">x,y,z\\stackrel {\\mu}{\\leftarrow}\\mathbf{Z}_q;</span></p>

    <p class="text-gray-300"><span class="math">\\hat{g}\\gets g^{w};e\\gets g^{x};f\\gets g^{y};h\\gets g^{z};</span></p>

    <p class="text-gray-300">and output the public key  <span class="math">\\mathsf{PK} = (\\Gamma ,\\mathsf{hk},\\hat{g},e,f,h)</span>  and the secret key  <span class="math">\\mathsf{SK} = (\\Gamma ,\\mathsf{hk},w,x,y,z)</span> .</p>

    <p class="text-gray-300">Decryption: Given  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , a secret key</p>

    <p class="text-gray-300"><span class="math">\\mathsf{SK} = (\\Gamma [\\hat{G},G,g,q],\\mathsf{hk},x,y,z)\\in [\\mathbf{S}_{\\lambda}]\\times [\\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda ,\\Gamma}]\\times \\mathbf{Z}_q^3,</span></p>

    <p class="text-gray-300">along with a ciphertext  <span class="math">\\psi</span> , do the following.</p>

    <p class="text-gray-300">D1: Parse  <span class="math">\\psi</span>  as a 4-tuple  <span class="math">(a, \\hat{a}, c, d) \\in \\hat{G}^4</span> ; output reject and halt if  <span class="math">\\psi</span>  is not of this form. D2': Test if  <span class="math">a</span>  and  <span class="math">c</span>  belong to  <span class="math">G</span> ; output reject and halt if this is not the case. D3: Compute  <span class="math">v \\gets \\mathsf{HF}_{\\mathsf{hk}}^{\\lambda, \\Gamma}(a, \\hat{a}, c)</span> . D4': Test if  <span class="math">\\hat{a} = a^w</span>  and  <span class="math">d = a^{x + yv}</span> ; output reject and halt if this is not the case. D5': Compute  <span class="math">b \\gets a^z</span> . D6: Compute  <span class="math">m \\gets c \\cdot b^{-1}</span> , and output  <span class="math">m</span> .</p>

    <p class="text-gray-300">Figure 3: Key generation and decryption algorithms for CS1b</p>

    <p class="text-gray-300">after just one exponentiation, this may reveal some timing information that could be exploited by an attacker. Indeed, if we reject immediately upon detecting that <span class="math">\\hat{a}\\neq a^{w}</span>, then based upon timing information, an attacker could use the decryption box as a kind Diffie-Hellman decision oracle. Our formal model of security does not model any notion of time at all, so such attacks fall outside of the model. We should also point out that we know of no actual attack on the scheme even if such timing information is available.</p>

    <h6 id="sec-60" class="text-base font-medium mt-4">Remark 10</h6>

    <p class="text-gray-300">For the same reasons as discussed in the previous remark, it is important that any “error code” returned by the decryption algorithm in scheme CS1b not reveal the precise reason why a ciphertext was rejected.</p>

    <h6 id="sec-61" class="text-base font-medium mt-4">Theorem 2</h6>

    <p class="text-gray-300">If the DDH assumption holds for <span class="math">\\mathcal{G}</span> and the TCR assumption holds for HF, then CS1a and CS1b are secure against adaptive chosen ciphertext attack.</p>

    <p class="text-gray-300">In particular, for all probabilistic, polynomial-time oracle query machines A, for all <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span>, and all <span class="math">\\Gamma[\\hat{G},G,g,q]\\in[\\mathbf{S}_{\\lambda}]</span>, we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textsf{AdvCCA}_{\\textsf{CS1a,A}}(\\lambda\\mid\\Gamma)-\\textsf{AdvCCA}_{\\textsf{CS1,A}}(\\lambda\\mid\\Gamma)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq Q_{\\textsf{A}}(\\lambda)/q$ (13)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textsf{AdvCCA}_{\\textsf{CS1b,A}}(\\lambda\\mid\\Gamma)-\\textsf{AdvCCA}_{\\textsf{CS1,A}}(\\lambda\\mid\\Gamma)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq Q_{\\textsf{A}}(\\lambda)/q.$ (14)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To prove this theorem, let us fix A, <span class="math">\\lambda</span>, and <span class="math">\\Gamma[\\hat{G},G,g,q]</span>. Consider the attack game <span class="math">\\mathbf{G}_{0}</span> as defined in §6.2: this is game that A plays against the scheme CS1 for the given values of <span class="math">\\lambda</span> and <span class="math">\\Gamma</span>. We adopt all the notational conventions established at the beginning of §6.2 (i.e., prior to the description of game <span class="math">\\mathbf{G}_{1}</span>).</p>

    <p class="text-gray-300">We begin by defining two modifications of game <span class="math">\\mathbf{G}_{0}</span>.</p>

    <p class="text-gray-300">Game <span class="math">\\mathbf{G}_{-1a}</span>. In this game, we modify the decryption oracle so that in place of step D5, we execute step D5^{′} as in the scheme CS1a. We emphasize that in game <span class="math">\\mathbf{G}_{-1a}</span>, we have <span class="math">z=z_{1}+z_{2}w</span>, where <span class="math">w</span>, <span class="math">z_{1}</span>, and <span class="math">z_{2}</span> are generated by the key generation algorithm of CS1.</p>

    <p class="text-gray-300">Game <span class="math">\\mathbf{G}_{-1b}</span>. In this game, we modify the decryption oracle so that in place of steps D4 and D5, we execute steps D4^{′} and D5^{′} as in the scheme CS1b. We emphasize that in game <span class="math">\\mathbf{G}_{-1b}</span>, we have <span class="math">x=x_{1}+x_{2}w</span>, <span class="math">y=x_{1}+x_{2}w</span>, and <span class="math">z=z_{1}+z_{2}w</span>, where <span class="math">w</span>, <span class="math">x_{1}</span>, <span class="math">x_{2}</span>, <span class="math">y_{1}</span>, <span class="math">y_{2}</span>, <span class="math">z_{1}</span>, and <span class="math">z_{2}</span> are generated by the key generation algorithm of CS1.</p>

    <p class="text-gray-300">Let <span class="math">T_{-1a}</span> be the event that <span class="math">\\sigma=\\hat{\\sigma}</span> in game <span class="math">\\mathbf{G}_{-1a}</span> and <span class="math">T_{-1b}</span> be the event that <span class="math">\\sigma=\\hat{\\sigma}</span> in game <span class="math">\\mathbf{G}_{-1b}</span>.</p>

    <p class="text-gray-300">We remind the reader that games <span class="math">\\mathbf{G}_{0}</span>, <span class="math">\\mathbf{G}_{-1a}</span>, and <span class="math">\\mathbf{G}_{-1b}</span> all operate on the same underlying probability space: all of the variables</p>

    <p class="text-gray-300"><span class="math">\\textsf{Coins},\\textsf{hk},w,x_{1},x_{2},y_{1},y_{2},z_{1},z_{2},\\sigma,u^{*}</span></p>

    <p class="text-gray-300">that ultimately determine the events <span class="math">T_{0}</span>, <span class="math">T_{-1a}</span>, and <span class="math">T_{-1b}</span> have the same values in games <span class="math">\\mathbf{G}_{0}</span>, <span class="math">\\mathbf{G}_{-1a}</span>, and <span class="math">\\mathbf{G}_{-1b}</span>; all that changes is the functional behavior of the decryption oracle.</p>

    <p class="text-gray-300">It is straightforward to verify that and that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\textsf{AdvCCA}_{\\textsf{CS1a,A}}(\\lambda\\mid\\Gamma)=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[T_{-1a}-1/2]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\textsf{AdvCCA}_{\\textsf{CS1b,A}}(\\lambda\\mid\\Gamma)=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[T_{-1b}-1/2]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Let us define the event <span class="math">R_{-1b}</span> to be the event that some ciphertext is rejected in game <span class="math">\\mathbf{G}_{-1b}</span> in step <span class="math">\\mathbf{D4^{\\prime}}</span> that would have passed the test in <span class="math">\\mathbf{D4}</span>. It is clear that games <span class="math">\\mathbf{G}_{0}</span>, <span class="math">\\mathbf{G}_{-1a}</span>, and <span class="math">\\mathbf{G}_{-1b}</span> all proceed identically until event <span class="math">R_{-1b}</span> occurs. In particular, we the events <span class="math">T_{0}\\wedge\\neg R_{-1b}</span>, <span class="math">T_{-1a}\\wedge\\neg R_{-1b}</span>, and <span class="math">T_{-1b}\\wedge\\neg R_{-1b}</span> are identical. So by Lemma 4, we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[T_{0}]-\\Pr[T_{-1a}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\Pr[R_{-1b}]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[T_{0}]-\\Pr[T_{-1b}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\Pr[R_{-1b}].$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">So it suffices to show that</p>

    <p class="text-gray-300"><span class="math">\\Pr[R_{-1b}]\\leq Q_{\\mathsf{A}}(\\lambda)/q.</span> (15)</p>

    <p class="text-gray-300">To do this, for <span class="math">1\\leq i\\leq Q_{\\mathsf{A}}(\\lambda)</span>, let <span class="math">R^{(i)}_{-1b}</span> be the event that there is an <span class="math">i</span>th ciphertext submitted to the decryption oracle in game <span class="math">\\mathbf{G}_{-1b}</span>, and that this ciphertext is rejected in step <span class="math">\\mathbf{D4^{\\prime}}</span>, but would have passed the test in step <span class="math">\\mathbf{D4}</span>.</p>

    <p class="text-gray-300">The bound (15) will follow immediately from the following lemma.</p>

    <h6 id="sec-62" class="text-base font-medium mt-4">Lemma 12</h6>

    <p class="text-gray-300">For all <span class="math">1\\leq i\\leq Q_{\\mathsf{A}}(\\lambda)</span>, we have <span class="math">\\Pr[R^{(i)}_{-1b}]\\leq 1/q</span>.</p>

    <p class="text-gray-300">Proof. The proof of this is lemma is almost identical to that of Lemma 10. Note that in game <span class="math">\\mathbf{G}_{-1b}</span>, the encryption oracle uses the “real” encryption algorithm, and so itself does not leak any additional information about <span class="math">(x_{1},x_{2},y_{1},y_{2})</span>. This is in contrast to game <span class="math">\\mathbf{G}_{5}</span>, where the encryption oracle does leak additional information.</p>

    <p class="text-gray-300">Fix <span class="math">1\\leq i\\leq Q_{\\mathsf{A}}(\\lambda)</span>. Consider the quantities</p>

    <p class="text-gray-300"><span class="math">X:=(\\mathsf{Coins},\\mathsf{hk},w,z,\\sigma,u^{*}).</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">X^{\\prime}:=(x,y).</span></p>

    <p class="text-gray-300">The values of <span class="math">X</span> and <span class="math">X^{\\prime}</span> completely determine the adversary’s entire behavior in game <span class="math">\\mathbf{G}_{5}</span>, and hence determine if there is an <span class="math">i</span>th decryption oracle query, and if so, the value of the corresponding ciphertext. Let us call <span class="math">X</span> and <span class="math">X^{\\prime}</span> relevant if for these values of <span class="math">X</span> and <span class="math">X^{\\prime}</span>, there is an <span class="math">i</span>th decryption oracle query, and the corresponding ciphertext passes steps <span class="math">\\mathbf{D1}</span> and <span class="math">\\mathbf{D2}</span>.</p>

    <p class="text-gray-300">It will suffice prove that conditioned on any fixed, relevant values of <span class="math">X</span> and <span class="math">X^{\\prime}</span>, the probability that <span class="math">R^{(i)}_{-1b}</span> occurs is bounded by <span class="math">1/q</span>.</p>

    <p class="text-gray-300">The remainder of the argument is exactly as in Lemma 10, except using <span class="math">X</span>, <span class="math">X^{\\prime}</span>, and the notion of relevant as defined here. <span class="math">\\Box</span></p>

    <h3 id="sec-63" class="text-xl font-semibold mt-8">6.4 A hash-free variant</h3>

    <p class="text-gray-300">Our basic scheme CS1 requires a target collision resistant hash function. Qualitatively, the TCR assumption is much weaker than the DDH assumption, since one can build a target collision resistant hash function based on an arbitrary one-way function. Indeed, one can build a collision resistant hash function under the DL assumption; however, the hash functions arising from such a construction produce an output that is in <span class="math">G</span>, whereas we need a hash function that maps into <span class="math">\\mathbf{Z}_{q}</span>. We cannot in general expect to find an easy-to-compute, injective map from <span class="math">G</span> onto <span class="math">\\mathbf{Z}_{q}</span>; in Example 2 in §4.2, we in fact do have such a map, but that is an exceptional case.</p>

    <p class="text-gray-300">For these reasons, we present a variation <span class="math">\\mathsf{CS2}</span> of our basic scheme that does not require a hash function.</p>

    <p class="text-gray-300">This scheme requires a family <span class="math">\\{\\mathsf{Chop}_{\\lambda,\\Gamma}\\}</span> of "chopping" functions associated with the group scheme <span class="math">\\mathcal{G}</span> with the following properties. For <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> and <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span>, the function <span class="math">\\mathsf{Chop}_{\\lambda,\\Gamma}</span> injectively maps triples <span class="math">\\rho \\in G^3</span> of group elements to <span class="math">N</span>-tuples <span class="math">(v_1, \\ldots, v_N) \\in \\mathbf{Z}_q^N</span>. Here, <span class="math">N = N(\\lambda, \\Gamma)</span> is bounded by a polynomial in <span class="math">\\lambda</span>, and the function <span class="math">\\mathsf{Chop}_{\\lambda,\\Gamma}</span> should be computable by a deterministic, polynomial-time function that takes inputs <span class="math">\\mathbf{1}^{\\lambda}</span>, <span class="math">\\Gamma</span>, and <span class="math">\\rho</span>.</p>

    <p class="text-gray-300">In principle, such chopping functions always exist, since we can write down the binary representation of <span class="math">\\rho</span>, and chop it into bit strings of length <span class="math">\\lfloor \\log_2 q \\rfloor</span>.</p>

    <p class="text-gray-300">We present the details of scheme CS2 in Figure 4.</p>

    <p class="text-gray-300"><strong>Theorem 3</strong> If the DDH assumption holds for <span class="math">\\mathcal{G}</span>, then CS2 is secure against adaptive chosen ciphertext attack.</p>

    <p class="text-gray-300">In particular, for all probabilistic, polynomial-time oracle query machines <span class="math">\\mathsf{A}</span>, there exists a probabilistic algorithm <span class="math">\\mathsf{A}_1</span>, whose running time is essentially the same as that of <span class="math">\\mathsf{A}</span>, such that the following holds. For all <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>, and all <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span>, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{AdvCCA}_{\\mathsf{CS2},\\mathsf{A}}(\\lambda \\mid \\Gamma) \\leq \\operatorname{AdvDDH}_{\\mathcal{G},\\mathsf{A}_1}(\\lambda \\mid \\Gamma) + (Q_{\\mathsf{A}}(\\lambda) + 3)/q.</span></div>

    <p class="text-gray-300">The proof of this theorem follows the same lines as the proof of Theorem 1. We present here a sketch of the proof, appealing in several places to arguments found in the proof of Theorem 1 so as to avoid repeating arguments that are identical or nearly identical.</p>

    <p class="text-gray-300">Let us fix a probabilistic, polynomial-time oracle query machine <span class="math">\\mathsf{A}</span>, the value of the security parameter <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>, and the group description <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span>.</p>

    <p class="text-gray-300">We define <span class="math">x, z \\in \\mathbf{Z}_q</span> as follows:</p>

    <div class="my-4 text-center"><span class="math-block">x := x_1 + x_2 w, \\quad z := z_1 + z_2 w.</span></div>

    <p class="text-gray-300">We also define <span class="math">y^{(i)} \\in \\mathbf{Z}_q</span>, for <span class="math">1 \\leq i \\leq N</span>, as</p>

    <div class="my-4 text-center"><span class="math-block">y^{(i)} := y_1^{(i)} + y_2^{(i)} w.</span></div>

    <p class="text-gray-300">As a notational convention, whenever a particular ciphertext <span class="math">\\psi</span> is under consideration in some context, the following values are also implicitly defined in that context:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">a, \\hat{a}, c, d \\in G</span>, where <span class="math">\\psi = (a, \\hat{a}, c, d)</span>;</li>

      <li><span class="math">u, \\hat{u}, v_1, \\ldots, v_N, r, s \\in \\mathbf{Z}_q</span>, where</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">u := \\log_g a, \\quad \\hat{u} := \\log_{\\hat{g}} \\hat{a}, \\quad (v_1, \\ldots, v_N) := \\mathsf{Chop}_{\\lambda,\\Gamma}(a, \\hat{a}, c), \\quad r := \\log_g c, \\quad s := \\log_g d.</span></div>

    <p class="text-gray-300">For the target ciphertext <span class="math">\\psi^{<em>}</span>, we also denote by <span class="math">a^{</em>}, \\hat{a}^{<em>}, c^{</em>}, d^{<em>} \\in G</span> and <span class="math">u^{</em>}, \\hat{u}^{<em>}, v_{1}^{</em>}, \\ldots, v_{N}^{<em>}, r^{</em>}, s^{*} \\in \\mathbf{Z}_{q}</span> the corresponding values.</p>

    <p class="text-gray-300">The probability space defining the attack game is then determined by the following, mutually independent, random variables:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the coin tosses of <span class="math">\\mathsf{A}</span>;</li>

      <li>the values <span class="math">w, x_1, x_2, y_1^{(1)}, \\ldots, y^{(N)}, y_2^{(1)}, \\ldots, y_2^{(N)}, z_1, z_2</span> generated by the key generation algorithm;</li>

    </ul>

    <p class="text-gray-300">32</p>

    <p class="text-gray-300">Key Generation: On input  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , compute</p>

    <p class="text-gray-300"><span class="math">\\Gamma[\\hat{G}, G, g, q] \\stackrel{R}{\\leftarrow} \\hat{S}(1^{\\lambda})</span> ;</p>

    <p class="text-gray-300"><span class="math">w\\stackrel {R}{\\leftarrow}\\mathbf{Z}_q^s</span>  .  <span class="math">x_{1},x_{2},z_{1},z_{2}\\stackrel {R}{\\leftarrow}\\mathbf{Z}_{q};</span></p>

    <p class="text-gray-300">for  <span class="math">i = 1,\\ldots ,n</span>  ..  <span class="math">y_{1}^{(i)},y_{2}^{(i)}\\stackrel {n}{\\leftarrow}\\mathbf{Z}_{q};</span></p>

    <p class="text-gray-300"><span class="math">\\hat{g}\\gets g^w</span>  .  <span class="math">e\\gets g^{x_1}\\hat{g}^{x_2}</span>  .  <span class="math">h\\gets g^{x_1}\\hat{g}^{x_2}</span></p>

    <p class="text-gray-300">for  <span class="math">i = 1,\\ldots ,n</span>  ..  <span class="math">f_{i}\\gets g^{y_{i}^{(i)}}\\hat{g}^{y_{2}^{(i)}}</span></p>

    <p class="text-gray-300">and output the public key  <span class="math">\\mathsf{PK} = (\\Gamma, \\hat{g}, e, (f_i)_{i=1}^N, h)</span>  and the secret key</p>

    <p class="text-gray-300"><span class="math">\\mathsf{SK} = (\\Gamma ,x_1,x_2,(y_1^{(i)},y_2^{(i)})_{i = 1}^N,z_1,z_2)</span></p>

    <p class="text-gray-300">Encryption: Given  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , a public key</p>

    <p class="text-gray-300"><span class="math">\\mathsf{PK} = (\\Gamma [\\hat{G},G,g,q],\\hat{g},e,(f_i)_{i = 1}^N,h)\\in [\\mathbf{S}_\\lambda ]\\times G^{N + 3},</span></p>

    <p class="text-gray-300">along with a message  <span class="math">m \\in G</span> , compute</p>

    <p class="text-gray-300">E1:  <span class="math">u \\stackrel{R}{\\leftarrow} \\mathbf{Z}_q</span> ; E2:  <span class="math">a \\gets g^u</span> ; E3:  <span class="math">\\hat{a} \\gets \\hat{g}^u</span> ; E4:  <span class="math">b \\gets h^u</span> ; E5:  <span class="math">c\\gets b\\cdot m</span> E6:  <span class="math">(v_{1},\\ldots ,v_{N})\\gets \\mathsf{Chop}_{\\lambda ,\\Gamma}(a,\\hat{a},c)</span> E7:  <span class="math">d\\gets e^{u}\\prod_{i = 1}^{N}f_{i}^{uv_{i}}</span></p>

    <p class="text-gray-300">and output the ciphertext  <span class="math">\\psi = (a, \\hat{a}, c, d)</span> .</p>

    <p class="text-gray-300">Decryption: Given  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , a secret key</p>

    <p class="text-gray-300"><span class="math">\\mathsf{SK} = (\\Gamma [\\hat{G},G,g,q],x_1,x_2,(y_1^{(i)},y_2^{(i)})_{i = 1}^N,z_1,z_2)\\in [\\mathbf{S}_\\lambda ]\\times \\mathbf{Z}_q^{N + 4},</span></p>

    <p class="text-gray-300">along with a ciphertext  <span class="math">\\psi</span> , do the following.</p>

    <p class="text-gray-300">D1: Parse  <span class="math">\\psi</span>  as a 4-tuple  <span class="math">(a, \\hat{a}, c, d) \\in \\hat{G}^4</span> ; output reject and halt if  <span class="math">\\psi</span>  is not of this form. D2: Test if  <span class="math">a</span> ,  <span class="math">\\hat{a}</span> , and  <span class="math">c</span>  belong to  <span class="math">G</span> ; output reject and halt if this is not the case. D3: Compute  <span class="math">(v_{1},\\ldots ,v_{N})\\gets \\mathsf{Chop}_{\\lambda ,\\Gamma}(a,\\hat{a},c)</span> D4: Test if  <span class="math">d = a^{x_1 + \\sum_{i=1}^N y_1^{(i)} v_i} \\cdot \\hat{a}^{x_2 + \\sum_{i=1}^N y_2^{(i)} v_i}</span> ; output reject and halt if this is not the case. D5: Compute  <span class="math">b \\gets a^{z_1} \\hat{a}^{z_2}</span> . D6: Compute  <span class="math">m \\gets c \\cdot b^{-1}</span> , and output  <span class="math">m</span> .</p>

    <p class="text-gray-300">Figure 4: The public-key encryption scheme CS2, where  <span class="math">N = N(\\lambda, \\Gamma)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the values  <span class="math">\\sigma \\in \\{0,1\\}</span>  and  <span class="math">u^{*} \\in \\mathbf{Z}_{q}</span>  generated by the encryption oracle.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  <span class="math">\\mathbf{G}_0</span>  be the original attack game, let  <span class="math">\\hat{\\sigma} \\in \\{0,1\\}</span>  denote the output of  <span class="math">\\mathsf{A}</span> , and let  <span class="math">T_0</span>  be the event that  <span class="math">\\sigma = \\hat{\\sigma}</span>  in  <span class="math">\\mathbf{G}_0</span> , so that  $\\mathsf{AdvCCA}_{\\mathsf{CS2},\\mathsf{A}}(\\lambda \\mid \\Gamma) =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname*{Pr}[T_0] - 1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As in the proof of Theorem 1, we shall define a sequence of modified games  <span class="math">\\mathbf{G}_i</span> , for  <span class="math">i = 1,2,\\ldots</span> , and in game  <span class="math">\\mathbf{G}_i</span> , the event  <span class="math">T_i</span>  will be the event corresponding to event  <span class="math">T_0</span> , but in game  <span class="math">\\mathbf{G}_i</span> . We remind the reader that all of these games operate on the same underlying probability space, and except as otherwise specified, random variables have identical values between games.</p>

    <p class="text-gray-300">Game  <span class="math">\\mathbf{G}_1</span> . In game  <span class="math">\\mathbf{G}_1</span> , we modify the algorithm used by the encryption oracle as follows. Steps E4 and E7 are replaced by:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{E4^{\\prime}}</span>  ..  <span class="math">b\\gets a^{z_1}\\hat{a}^{z_2};</span> <span class="math">\\mathbf{E7^{\\prime}}</span>  ..  <span class="math">d\\gets a^{x_1 + \\sum_{i = 1}^N y_1^{(i)}v_i}\\cdot \\hat{a}^{x_2 + \\sum_{i = 1}^N y_2^{(i)}v_i}.</span></p>

    <p class="text-gray-300">By the same reasoning as in the proof of Theorem 1, we have  <span class="math">\\operatorname<em>{Pr}[T_1] = \\operatorname</em>{Pr}[T_0]</span> .</p>

    <p class="text-gray-300">Game  <span class="math">\\mathbf{G}_2</span> . We again modify the encryption oracle, replacing step E3 by</p>

    <p class="text-gray-300"><span class="math">\\mathbf{E3^{\\prime}}</span>  ..  <span class="math">\\hat{u}\\stackrel {B}{\\leftarrow}\\mathbf{Z}_q\\setminus \\{u\\} ;\\hat{a}\\gets \\hat{g}^{\\hat{u}}.</span></p>

    <p class="text-gray-300">By the same reasoning as in the proof of Theorem 1, one sees that there exists a probabilistic algorithm  <span class="math">\\mathsf{A}_1</span> , whose running time is essentially the same as that of  <span class="math">\\mathsf{A}</span> , such that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr [ T _ {2} ] - \\Pr [ T _ {1} ]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\operatorname {A d v D D H} _ {\\mathcal {G}, \\mathrm {A} _ {1}} (\\lambda \\mid \\Gamma) + 3 / q.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Game  <span class="math">\\mathbf{G}_3</span> . In this game, we modify the decryption oracle in game  <span class="math">\\mathbf{G}_2</span> , replacing steps D4 and D5 with:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{D4^{\\prime}}</span>  : Test if  <span class="math">\\hat{a} = a^{w}</span>  and  <span class="math">d = a^{x + \\sum_{i = 1}^{N}y^{(i)}v_i}</span> ; output reject and halt if this is not the case.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{D5^{\\prime}}</span>  ..  <span class="math">b\\gets a^z</span></p>

    <p class="text-gray-300">Let  <span class="math">R_{3}</span>  be the event that in game  <span class="math">\\mathbf{G}_3</span> , some ciphertext  <span class="math">\\psi</span>  is submitted to the decryption oracle that is rejected in step  <span class="math">\\mathbf{D4}&#x27;</span>  but that would have passed the test in step  <span class="math">\\mathbf{D4}</span> .</p>

    <p class="text-gray-300">As in the proof of Theorem 1, we have</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr [ T _ {3} ] - \\Pr [ T _ {2} ]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\Pr [ R _ {3} ].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We claim that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ R _ {3} \\right] \\leq Q _ {\\mathrm {A}} (\\lambda) / q.</span></div>

    <p class="text-gray-300">We can prove the analog of Lemma 8 (in game  <span class="math">\\mathbf{G}_5</span>  in the proof of Theorem 1) by considering an  <span class="math">(N + 3)\\times (2N + 2)</span>  matrix  <span class="math">M</span>  over  <span class="math">\\mathbf{Z}_q</span>  defined as</p>

    <div class="my-4 text-center"><span class="math-block">M := \\left( \\begin{array}{c c c c c c c} 1 &amp;amp; w &amp;amp; &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\\\ &amp;amp; &amp;amp; 1 &amp;amp; w &amp;amp; &amp;amp; &amp;amp; \\\\ &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\ddots &amp;amp; &amp;amp; \\\\ &amp;amp; &amp;amp; &amp;amp; &amp;amp; &amp;amp; 1 &amp;amp; w \\\\ u ^ {*} &amp;amp; \\hat {u} ^ {*} w &amp;amp; u ^ {*} v _ {1} ^ {*} &amp;amp; \\hat {u} ^ {*} v _ {1} ^ {*} w &amp;amp; \\dots &amp;amp; u ^ {*} v _ {N} ^ {*} &amp;amp; \\hat {u} ^ {*} v _ {N} ^ {*} w \\\\ u &amp;amp; \\hat {u} w &amp;amp; u v _ {1} &amp;amp; \\hat {u} v _ {1} w &amp;amp; \\dots &amp;amp; u v _ {N} &amp;amp; \\hat {u} v _ {N} w \\end{array} \\right),</span></div>

    <p class="text-gray-300">where  <span class="math">w \\neq 0</span> ,  <span class="math">\\hat{u} \\neq u</span> ,  <span class="math">\\hat{u}^<em> \\neq u^</em></span> , and  <span class="math">v_i \\neq v_i^*</span>  for some  <span class="math">i \\in \\{1, \\dots, N\\}</span> . It will suffice to show that the rows of  <span class="math">M</span>  are linearly independent.</p>

    <p class="text-gray-300">If we choose <span class="math">i</span> such that <span class="math">v_{i}\\neq v_{i}^{*}</span>, and consider the <span class="math">4\\times 4</span> sub-matrix <span class="math">M^{\\prime}</span> of <span class="math">M</span> consisting of the intersection of columns 1, 2, <span class="math">2i+1</span>, <span class="math">2i+2</span> of <span class="math">M</span>, and rows 1, <span class="math">i+1</span>, <span class="math">N+2</span>, <span class="math">N+3</span> of <span class="math">M</span>, we see that matrix <span class="math">M^{\\prime}</span> has the same form as the matrix considered in Lemma 11, and hence is non-singular. It follows that the rows of <span class="math">M</span> are linearly independent, since any non-trivial linear relation among the rows of <span class="math">M</span> implies a non-trivial linear relation among the rows of <span class="math">M^{\\prime}</span>.</p>

    <p class="text-gray-300">Game G_{4}. We again modify the algorithm used by the encryption oracle, replacing step E5 by</p>

    <p class="text-gray-300"><span class="math">\\textbf{E5}^{\\prime}\\text{: }r\\stackrel{{\\scriptstyle B}}{{\\longleftarrow}}\\textbf{Z}_{q}\\text{: }c\\leftarrow g^{r}.</span></p>

    <p class="text-gray-300">By reasoning analogous to that in game G_{4} in the proof of Theorem 1, one can show that</p>

    <p class="text-gray-300"><span class="math">\\Pr[T_{4}]=\\Pr[T_{3}].</span></p>

    <p class="text-gray-300">Moreover, by construction it is evident that</p>

    <p class="text-gray-300"><span class="math">\\Pr[T_{4}]=1/2.</span></p>

    <p class="text-gray-300">That completes the proof sketch of Theorem 3. We leave it to the reader to work out the details of the design and analysis of variants CS2a and CS2b of scheme CS2, corresponding to the variants CS1a and CS1b of scheme CS1, which were discussed in §6.3.</p>

    <h6 id="sec-64" class="text-base font-medium mt-4">Remark 11</h6>

    <p class="text-gray-300">Note that the high-level structure of the proof of Theorem 3 is significantly simpler than that of Theorem 1. In particular, in the analysis of game G_{3} in the proof of Theorem 3, we were able to bound the quantity <span class="math">\\Pr[R_{3}]</span> directly, without deferring the analysis to a later game, as in the proof of Theorem 1. This simplification comes from the fact that we do not have to deal with a target collision resistant hash function in Theorem 3, as we did in Theorem 1. Indeed, if in the scheme CS1 we use a collision resistant hash function, we could prove the security of CS1 using a proof with essentially the same line of reasoning as that of the proof of Theorem 3, with one extra game between G_{0} and G_{1} to effectively ban hash function collisions.</p>

    <h2 id="sec-65" class="text-2xl font-bold">7 Hybrid Encryption</h2>

    <p class="text-gray-300">The encryption schemes presented in the previous section all had restricted message spaces. In some settings, an encryption scheme with an unrestricted message space is more desirable. A simple and efficient way to build an encryption scheme that has an unrestricted message is to build a hybrid encryption scheme. Loosely speaking, such a scheme uses public-key encryption techniques to encrypt a key <span class="math">K</span> that is then used to encrypt the actual message using symmetric-key encryption techniques. In this section, we develop the necessary tools for building a hybrid public-key encryption scheme.</p>

    <p class="text-gray-300">One key ingredient in any hybrid scheme is a key encapsulation mechanism. This is like a public-key encryption scheme, except that the job of the encryption algorithm is to generate the encryption of a random key <span class="math">K</span>. Of course, one can always use a general-purpose public-key encryption scheme to do this, by simply generating <span class="math">K</span> at random, and then encrypting it. However, there are typically more efficient ways to this.</p>

    <p class="text-gray-300">As a quick example of a key encapsulation mechanism, consider the following variation of the ElGamal encryption scheme. Let <span class="math">G</span> be a group of prime order <span class="math">q</span> generated by an element <span class="math">g</span>. Let <span class="math">H</span> be a cryptographic hash function, such as SHA-1. The public key consists of a group element</p>

    <p class="text-gray-300"><span class="math">h=g^{z}</span>, where <span class="math">z\\in\\mathbf{Z}_{q}</span> is chosen at random; the secret key is <span class="math">z</span>. To generate an encryption of a symmetric key <span class="math">K</span>, we compute</p>

    <p class="text-gray-300"><span class="math">u\\stackrel{{\\scriptstyle R}}{{\\leftarrow}}\\mathbf{Z}_{q};\\ a\\gets g^{u};\\ b\\gets h^{u};\\ K\\gets H(b);</span></p>

    <p class="text-gray-300">to form a ciphertext <span class="math">\\psi=a</span>. To decrypt a ciphertext <span class="math">\\psi=a</span> using the secret key, one computes</p>

    <p class="text-gray-300"><span class="math">b\\gets a^{z};\\ K\\gets H(b);</span></p>

    <p class="text-gray-300">obtaing a symmetric key <span class="math">K</span>.</p>

    <p class="text-gray-300">To build a complete hybrid encryption scheme, we combine a key encapsulation mechanism with a symmetric-key encryption scheme.</p>

    <h3 id="sec-66" class="text-xl font-semibold mt-8">7.1 Key encapsulation</h3>

    <p class="text-gray-300">A key encapsulation mechanism KEM consists of the following algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A probabilistic, polynomial-time key generation algorithm KEM.KeyGen that on input <span class="math">1^{\\lambda}</span> for <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span>, outputs a public key/secret key pair <span class="math">(\\mathsf{PK},\\mathsf{SK})</span>. The structure of <span class="math">\\mathsf{PK}</span> and <span class="math">\\mathsf{SK}</span> depends on the particular scheme.</li>

    </ul>

    <p class="text-gray-300">For <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span>, we define the probability spaces</p>

    <p class="text-gray-300"><span class="math">\\mathsf{KEM.PKSpace}_{\\lambda}:=\\{\\mathsf{PK}:(\\mathsf{PK},\\mathsf{SK})\\stackrel{{\\scriptstyle R}}{{\\leftarrow}}\\mathsf{KEM.KeyGen}(1^{\\lambda})\\},</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">\\mathsf{KEM.SKSpace}_{\\lambda}:=\\{\\mathsf{SK}:(\\mathsf{PK},\\mathsf{SK})\\stackrel{{\\scriptstyle R}}{{\\leftarrow}}\\mathsf{KEM.KeyGen}(1^{\\lambda})\\}.</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A probabilistic, polynomial-time encryption algorithm KEM.Encrypt that takes as input <span class="math">1^{\\lambda}</span> for <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span>, and a public key <span class="math">\\mathsf{PK}\\in[\\mathsf{KEM.PKSpace}_{\\lambda}]</span>, and outputs a pair <span class="math">(K,\\psi)</span>, where <span class="math">K</span> is a key and <span class="math">\\psi</span> is a ciphertext.</li>

    </ul>

    <p class="text-gray-300">A key <span class="math">K</span> is a bit string of length <span class="math">\\mathsf{KEM.KeyLen}(\\lambda)</span>, where <span class="math">\\mathsf{KEM.KeyLen}(\\lambda)</span> is another parameter of the key encapsulation mechanism.</p>

    <p class="text-gray-300">A ciphertext is a bit string.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A deterministic, polynomial-time decryption algorithm KEM.Decrypt that takes as input <span class="math">1^{\\lambda}</span> for <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span>, a secret key <span class="math">\\mathsf{SK}\\in[\\mathsf{KEM.SKSpace}_{\\lambda}]</span>, a ciphertext <span class="math">\\psi</span>, and outputs either a key <span class="math">K</span> or the special symbol reject.</li>

    </ul>

    <h4 id="sec-67" class="text-lg font-semibold mt-6">7.1.1 Soundness</h4>

    <p class="text-gray-300">As for public key encryption, we need an appropriate notion of soundness. A definition of soundness that is adequate for our purposes runs as follows. Let us say a public key/secret key pair <span class="math">(\\mathsf{PK},\\mathsf{SK})\\in[\\mathsf{KEM.KeyGen}(1^{\\lambda})]</span> is bad if for some <span class="math">(K,\\psi)\\in[\\mathsf{KEM.Encrypt}(1^{\\lambda},\\mathsf{PK})]</span>, we have <span class="math">\\mathsf{KEM.Decrypt}(1^{\\lambda},\\mathsf{SK},\\psi)\\neq K</span>. Let <span class="math">\\mathsf{BadKeyPair}_{\\mathsf{KEM}}(\\lambda)</span> denote the probability that the key generation algorithm generates a bad key pair for a given value of <span class="math">\\lambda</span>. Then our requirement is that <span class="math">\\mathsf{BadKeyPair}_{\\mathsf{KEM}}(\\lambda)</span> grows negligibly in <span class="math">\\lambda</span>.</p>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">7.1.2 Security against adaptive chosen ciphertext attack</p>

    <p class="text-gray-300">As for a public key encryption scheme, an adversary <span class="math">\\mathsf{A}</span> in an adaptive chosen ciphertext attack is a probabilistic, polynomial-time oracle query machine that takes as input <span class="math">1^{\\lambda}</span>, where <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span> is the security parameter. We now describe the attack game used to define security against adaptive chosen ciphertext security.</p>

    <p class="text-gray-300">The adversary queries a <em>key generation oracle</em>. The key generation oracle computes <span class="math">(\\mathsf{PK},\\mathsf{SK})\\stackrel{{\\scriptstyle n}}{{\\leftarrow}}\\mathsf{KEM.KeyGen}(1^{\\lambda})</span> and responds with <span class="math">\\mathsf{PK}</span>. The adversary makes a sequence of calls to a <em>decryption oracle</em>.</p>

    <p class="text-gray-300">For each decryption oracle query, the adversary submits a ciphertext <span class="math">\\psi</span>, and the decryption oracle responds with <span class="math">\\mathsf{KEM.Decrypt}(1^{\\lambda},\\mathsf{SK},\\psi)</span>. The adversary queries an <em>encryption oracle</em>.</p>

    <p class="text-gray-300">The encryption oracle computes:</p>

    <p class="text-gray-300"><span class="math">(K^{<em>},\\psi^{</em>})\\stackrel{{\\scriptstyle n}}{{\\leftarrow}}\\mathsf{KEM.Encrypt}(1^{\\lambda},\\mathsf{PK});\\ K^{+}\\stackrel{{\\scriptstyle n}}{{\\leftarrow}}\\{0,1\\}^{\\ell};\\ \\tau\\stackrel{{\\scriptstyle n}}{{\\leftarrow}}\\{0,1\\};</span> if <span class="math">\\tau=0</span> then <span class="math">K^{\\dagger}\\leftarrow K^{*}</span> else <span class="math">K^{\\dagger}\\leftarrow K^{+}</span>;</p>

    <p class="text-gray-300">where <span class="math">\\ell\\mathop{:=}\\mathsf{KEM.KeyLen}(\\lambda)</span>, and responds with the pair <span class="math">(K^{\\dagger},\\psi^{<em>})</span>. The adversary continues to make calls to the decryption oracle, subject only to the restriction that a submitted ciphertext <span class="math">\\psi</span> is not </em>identical<em> to <span class="math">\\psi^{</em>}</span>. The adversary outputs <span class="math">\\hat{\\tau}\\in\\{0,1\\}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We define <span class="math">\\mathsf{AdvCCA}_{\\mathsf{KEM,A}}(\\lambda)</span> to be $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[\\tau=\\hat{\\tau}]-1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ in the above attack game.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We say that <span class="math">\\mathsf{KEM}</span> is <em>secure against adaptive chosen ciphertext attack</em> if</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p><em>for all probabilistic, polynomial-time oracle query machines <span class="math">\\mathsf{A}</span>, the function <span class="math">\\mathsf{AdvCCA}_{\\mathsf{KEM,A}}(\\lambda)</span> grows negligibly in <span class="math">\\lambda</span>.</em></p>
    </blockquote>

    <p class="text-gray-300">In applying the above definition of security, one typically works directly with the quantity</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{AdvCCA}^{\\prime}_{\\mathsf{KEM,A}}(\\lambda)\\mathop{:=}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[\\hat{\\tau}=1\\mid\\tau=0]-\\Pr[\\hat{\\tau}=1\\mid\\tau=1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathop{.}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It is easy to verify that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{AdvCCA}^{\\prime}_{\\mathsf{KEM,A}}(\\lambda)=2\\cdot\\mathsf{AdvCCA}_{\\mathsf{KEM,A}}(\\lambda).</span></p>

    <h3 id="sec-68" class="text-xl font-semibold mt-8">7.2 One-time symmetric-key encryption</h3>

    <p class="text-gray-300">A <em>one-time symmetric-key encryption scheme <span class="math">\\mathsf{SKE}</span></em> consists of two algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A deterministic, polynomial-time encryption algorithm <span class="math">\\mathsf{SKE.Encrypt}</span> that takes as input <span class="math">1^{\\lambda}</span> for <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span>, a key <span class="math">K</span>, and a message <span class="math">m</span>, and outputs a ciphertext <span class="math">\\chi</span>.</li>

    </ul>

    <p class="text-gray-300">The key <span class="math">K</span> is a bit string of length <span class="math">\\mathsf{SKE.KeyLen}(\\lambda)</span>.</p>

    <p class="text-gray-300">Here, <span class="math">\\mathsf{SKE.KeyLen}(\\lambda)</span> is a parameter of the encryption scheme, which we assume can be computed in deterministic polynomial time given <span class="math">1^{\\lambda}</span>.</p>

    <p class="text-gray-300">The message <span class="math">m</span> is a bit string of arbitrary, unbounded length.</p>

    <p class="text-gray-300">The ciphertext <span class="math">\\chi</span> is a bit string.</p>

    <p class="text-gray-300">We denote by <span class="math">\\mathsf{SKE.CTLen}(\\lambda,\\ell)</span> the maximum length of any encryption of a message of length at most <span class="math">\\ell</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A deterministic, polynomial-time decryption algorithm <span class="math">\\mathsf{SKE.Decrypt}</span> that takes as input <span class="math">1^{\\lambda}</span> for <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span>, a key <span class="math">K</span>, and a ciphertext <span class="math">\\chi</span> and outputs a message <span class="math">m</span> or the special symbol <span class="math">\\mathsf{reject}</span>.</li>

    </ul>

    <p class="text-gray-300">The key <span class="math">K</span> is a bit string of length <span class="math">\\mathsf{SKE.KeyLen}(\\lambda)</span>.</p>

    <p class="text-gray-300">The ciphertext <span class="math">\\chi</span> is a bit string of arbitrary length.</p>

    <p class="text-gray-300">We require that <span class="math">\\mathsf{SKE}</span> satisfy the following <em>soundness</em> condition: for all <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span>, for all <span class="math">K\\in\\{0,1\\}^{\\mathsf{SKE.KeyLen}(\\lambda)}</span>, for all <span class="math">m\\in\\{0,1\\}^{*}</span>, we have:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{SKE.Decrypt}(1^{\\lambda},K,\\mathsf{SKE.Encrypt}(1^{\\lambda},K,m))=m.</span></p>

    <h4 id="sec-69" class="text-lg font-semibold mt-6">7.2.1 Two definitions of security</h4>

    <p class="text-gray-300">We define two notions of security for a one-time symmetric-key encryption scheme: security against passive attacks, and security against adaptive chosen ciphertext attacks.</p>

    <p class="text-gray-300">As usual, an adversary <span class="math">\\mathsf{A}</span> is a probabilistic, polynomial-time oracle query machine that takes as input <span class="math">1^{\\lambda}</span>, where <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span> is the security parameter.</p>

    <p class="text-gray-300">A passive attack runs as follows. The adversary <span class="math">\\mathsf{A}</span> chooses two messages, <span class="math">m_{0}</span> and <span class="math">m_{1}</span>, of equal length, and gives these to an encryption oracle. The encryption oracle generates a random key <span class="math">K</span> of length <span class="math">\\mathsf{SKE.KeyLen}(\\lambda)</span>, along with random <span class="math">\\sigma\\in\\{0,1\\}</span>, and encrypts the message <span class="math">m_{\\sigma}</span> using the key <span class="math">K</span>. The adversary <span class="math">\\mathsf{A}</span> is then given the resulting ciphertext <span class="math">\\chi^{*}</span>. Finally, the adversary outputs <span class="math">\\hat{\\sigma}\\in\\{0,1\\}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We define <span class="math">\\mathsf{AdvPA}_{\\mathsf{SKE,A}}(\\lambda)</span> to be $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[\\sigma=\\hat{\\sigma}]-1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ in the above attack game.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We say that <span class="math">\\mathsf{SKE}</span> is secure against passive attacks if</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>for all probabilistic, polynomial-time oracle query machines <span class="math">\\mathsf{A}</span>, the function <span class="math">\\mathsf{AdvPA}_{\\mathsf{SKE,A}}(\\lambda)</span> grows negligibly in <span class="math">\\lambda</span>.</p>
    </blockquote>

    <p class="text-gray-300">An adaptive chosen ciphertext attack is exactly the same as a passive attack, except that after the adversary <span class="math">\\mathsf{A}</span> obtains the target ciphertext <span class="math">\\chi^{<em>}</span> from the encryption oracle, the adversary may then query a decryption oracle any number of times. In each decryption oracle query, <span class="math">\\mathsf{A}</span> submits a ciphertext <span class="math">\\chi\\neq\\chi^{</em>}</span>, and obtains the decryption of <span class="math">\\chi</span> under the key <span class="math">K</span>. As in the passive attack, <span class="math">\\mathsf{A}</span> outputs <span class="math">\\hat{\\sigma}\\in\\{0,1\\}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We define <span class="math">\\mathsf{AdvCCA}_{\\mathsf{SKE,A}}(\\lambda)</span> to be $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[\\sigma=\\hat{\\sigma}]-1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ in the above attack game.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We say that <span class="math">\\mathsf{SKE}</span> is secure against adaptive chosen ciphertext attacks if</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>for all probabilistic, polynomial-time oracle query machines <span class="math">\\mathsf{A}</span>, the function <span class="math">\\mathsf{AdvCCA}_{\\mathsf{SKE,A}}(\\lambda)</span> grows negligibly in <span class="math">\\lambda</span>.</p>
    </blockquote>

    <h4 id="sec-70" class="text-lg font-semibold mt-6">7.2.2 Constructions</h4>

    <p class="text-gray-300">Our definition of a symmetric-key encryption scheme and the corresponding notions of security are tailored to the application of building a hybrid public-key encryption scheme. These definitions may not be appropriate for other settings. In particular, our definitions of security do not imply protection against chosen plaintext attack; however, this protection is not needed for hybrid public-key encryption schemes, since a symmetric key is only used to encrypt a single message.</p>

    <p class="text-gray-300">It is easy to build a symmetric key encryption scheme that achieves security against passive attacks using standard symmetric-key techniques. For example, to encrypt a message <span class="math">m</span>, one can</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">xpand the key <span class="math">K</span> using a pseudo-random bit generator to obtain a “one time pad” <span class="math">\\alpha</span> of length $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and then compute </span>\\chi\\leftarrow m\\oplus\\alpha$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">A pseudo-random bit generator can be built from an arbitrary one-way permutation <em>[x10]</em>, or even from an arbitrary one-way function <em>[x16, x11]</em>. These constructions, however, are not very practical. In a practical implementation, it is perfectly reasonable to stretch the key <span class="math">K</span> by using it as the key to a dedicated block cipher, and then evaluate the block cipher at successive points (so-called “counter mode”) to obtain a sequence of pseudo-random bits (c.f. <em>[x22, Chapter 7]</em>).</p>

    <p class="text-gray-300">Note that the above construction yields a scheme that is completely insecure against adaptive chosen ciphertext attack. However, it is also easy to build a symmetric key encryption scheme SKE2 that achieves security against adaptive chosen ciphertext attack, given an arbitrary scheme SKE1 that is only secure against passive attacks.</p>

    <p class="text-gray-300">One technique is to simply build an SKE2 ciphertext by attaching a message authentication code to the SKE1 ciphertext. Although this technique seems to be “folklore,” for completeness, we develop the details here.</p>

    <p class="text-gray-300">A one-time message authentication code MAC specifies the following items:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span>, a key length parameter MAC.KeyLen(<span class="math">\\lambda</span>) and an output length parameter MAC.OutLen(<span class="math">\\lambda</span>).</li>

    </ul>

    <p class="text-gray-300">We assume that MAC.KeyLen(<span class="math">\\lambda</span>) can be computed in deterministic polynomial time given <span class="math">\\mathfrak{1}^{\\lambda}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A family of functions indexed by <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span> and <span class="math">\\mathsf{mk}\\in\\{0,1\\}^{\\mathsf{MAC.KeyLen}(\\lambda)}</span>, where each function <span class="math">\\mathsf{MAC}^{\\lambda}_{\\mathsf{mk}}</span> maps arbitrary bit strings to bit strings of length exactly MAC.OutLen(<span class="math">\\lambda</span>).</li>

    </ul>

    <p class="text-gray-300">There must be a deterministic, polynomial-time algorithm that on input <span class="math">\\mathfrak{1}^{\\lambda}</span>, <span class="math">\\mathsf{mk}\\in\\{0,1\\}^{\\mathsf{MAC.KeyLen}(\\lambda)}</span>, and <span class="math">\\alpha\\in\\{0,1\\}^{*}</span>, outputs <span class="math">\\mathsf{MAC}^{\\lambda}_{\\mathsf{mk}}(\\alpha)</span>.</p>

    <p class="text-gray-300">To define security for MAC, we define an attack game as follows. As usual, an adversary A is a probabilistic, polynomial-time oracle query machine that takes as input <span class="math">\\mathfrak{1}^{\\lambda}</span>, where <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span> is the security parameter. The adversary A first chooses a bit string <span class="math">\\alpha</span>, and submits this to an oracle. The oracle generates a random key <span class="math">\\mathsf{mk}</span> of length MAC.KeyLen(<span class="math">\\lambda</span>), computes <span class="math">\\beta\\leftarrow\\mathsf{MAC}^{\\lambda}_{\\mathsf{mk}}(\\alpha)</span>, and returns <span class="math">\\beta</span> to the adversary. The adversary A then outputs a list</p>

    <p class="text-gray-300"><span class="math">((\\alpha_{1},\\beta_{1}),\\ldots,(\\alpha_{k},\\beta_{k}))</span></p>

    <p class="text-gray-300">of pairs of bit strings. We say that A has produced a forgery if for some <span class="math">1\\leq i\\leq k</span>, we have <span class="math">\\alpha_{i}\\neq\\alpha</span> and <span class="math">\\mathsf{MAC}^{\\lambda}_{\\mathsf{mk}}(\\alpha_{i})=\\beta_{i}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We say that A is a <span class="math">(L_{1}(\\lambda),L_{2}(\\lambda),N(\\lambda))</span> forging adversary if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq L_{1}(\\lambda)<span class="math">, </span>k\\leq N(\\lambda)<span class="math">, and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq L_{2}(\\lambda)<span class="math"> for all </span>1\\leq i\\leq k$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Define <span class="math">\\mathsf{AdvForge}_{\\mathsf{MAC,A}}(\\lambda)</span> to be the probability that A produces a forgery in the above game. We say that MAC is secure if</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>for all probabilistic, polynomial-time oracle query machines A, the function <span class="math">\\mathsf{AdvForge}_{\\mathsf{MAC,A}}(\\lambda)</span> grows negligibly in <span class="math">\\lambda</span>.</p>
    </blockquote>

    <p class="text-gray-300">Message authentication codes have been extensively studied (c.f. <em>[x22, Chapter 9]</em>). Once can easily build secure one-time message authentication codes using an appropriate family of universal hash functions, without relying on any intractability assumptions. There are also other ways to build message authentication codes which may be preferable in practice, even though the security of these schemes is not fully proven.</p>

    <p class="text-gray-300">Now we show how to use <span class="math">\\mathsf{SKE1}</span> and <span class="math">\\mathsf{MAC}</span> to build <span class="math">\\mathsf{SKE2}</span>. The key length <span class="math">\\mathsf{SKE2.KeyLen}(\\lambda)</span> of <span class="math">\\mathsf{SKE2}</span> will be equal to</p>

    <p class="text-gray-300"><span class="math">\\mathsf{SKE1.KeyLen}(\\lambda)+\\mathsf{MAC.KeyLen}(\\lambda).</span></p>

    <p class="text-gray-300">We will write such a key as <span class="math">(K,\\mathsf{mk})</span>, where <span class="math">K</span> is a bit string of length <span class="math">\\mathsf{SKE1.KeyLen}(\\lambda)</span>, and <span class="math">\\mathsf{mk}</span> is a bit string of length <span class="math">\\mathsf{MAC.KeyLen}(\\lambda)</span>.</p>

    <p class="text-gray-300">To encrypt a message <span class="math">m</span> under a key <span class="math">(K,\\mathsf{mk})</span> as above, algorithm <span class="math">\\mathsf{SKE2.Encrypt}</span> computes</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\chi\\leftarrow\\mathsf{SKE1.Encrypt}(1^{\\lambda},K,m);\\ \\mathsf{tag}\\leftarrow\\mathsf{MAC}^{\\lambda}_{\\mathsf{mk}}(\\chi);\\ \\chi^{\\prime}\\leftarrow\\chi\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\mathsf{tag};$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and outputs the ciphertext <span class="math">\\chi^{\\prime}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To decrypt a ciphertext <span class="math">\\chi^{\\prime}</span> under a key <span class="math">(K,\\mathsf{mk})</span> as above, algorithm <span class="math">\\mathsf{SKE2.Decrypt}</span> first parses <span class="math">\\chi^{\\prime}</span> as $\\chi^{\\prime}=\\chi\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\mathsf{tag}<span class="math">, where </span>\\mathsf{tag}<span class="math"> is a bit string of length </span>\\mathsf{MAC.OutLen}(\\lambda)<span class="math">. If this parsing step fails (because </span>\\chi^{\\prime}<span class="math"> is too short), then the algorithm outputs </span>\\mathsf{reject}$; otherwise, it computes</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathsf{tag}^{\\prime}\\leftarrow\\mathsf{MAC}^{\\lambda}_{\\mathsf{mk}}(\\chi).</span></p>

    <p class="text-gray-300">If <span class="math">\\mathsf{tag}\\neq\\mathsf{tag}^{\\prime}</span>, the algorithm outputs <span class="math">\\mathsf{reject}</span>; otherwise, it computes</p>

    <p class="text-gray-300"><span class="math">m\\leftarrow\\mathsf{SKE1.Decrypt}(1^{\\lambda},K,\\chi);</span></p>

    <p class="text-gray-300">and outputs <span class="math">m</span>.</p>

    <p class="text-gray-300">To analyze the security of <span class="math">\\mathsf{SKE2}</span>, we recall that for all probabilistic, polynomial-time oracle query machines <span class="math">\\mathsf{A}</span>, for all <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span>, we denote by <span class="math">Q_{\\mathsf{A}}(\\lambda)</span> an upper bound on the number of decryption oracle queries made by <span class="math">\\mathsf{A}</span> on input <span class="math">1^{\\lambda}</span>. Although we introduced this notation in the context of public-key encryption, we can adopt it here in the context of symmetric-key encryption as well. We remind the reader that <span class="math">Q_{\\mathsf{A}}(\\lambda)</span> should be a strict bound that holds for any environment.</p>

    <p class="text-gray-300">For all probabilistic, polynomial-time oracle query machines <span class="math">\\mathsf{A}</span>, for all <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span>, we define <span class="math">B_{\\mathsf{A}}(\\lambda)</span> to be an upper bound on the length of the messages submitted by <span class="math">\\mathsf{A}</span> to the encryption oracle, and <span class="math">B^{\\prime}_{\\mathsf{A}}(\\lambda)</span> to be an upper bound on the ciphertexts submitted by <span class="math">\\mathsf{A}</span> to the decryption oracle. As usual, these upper bounds should hold regardless of the environment of <span class="math">\\mathsf{A}</span>.</p>

    <h6 id="sec-71" class="text-base font-medium mt-4">Theorem 4</h6>

    <p class="text-gray-300">If <span class="math">\\mathsf{SKE1}</span> is secure against passive attacks, and <span class="math">\\mathsf{MAC}</span> is a secure one-time message authentication code, then <span class="math">\\mathsf{SKE2}</span> is secure against adaptive chosen ciphertext attacks.</p>

    <p class="text-gray-300">In particular, for every probabilistic, polynomial-time oracle query machine <span class="math">\\mathsf{A}</span>, there exist probabilistic oracle query machine <span class="math">\\mathsf{A}_{1}</span> and <span class="math">\\mathsf{A}_{2}</span>, whose running times are essentially the same as that of <span class="math">\\mathsf{A}</span>, such that for all <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span>,</p>

    <p class="text-gray-300"><span class="math">\\mathsf{AdvCCA}_{\\mathsf{SKE2,A}}(\\lambda)\\leq\\mathsf{AdvPA}_{\\mathsf{SKE1,A}_{1}}(\\lambda)+\\mathsf{AdvForge}_{\\mathsf{MAC,A}_{2}}(\\lambda).</span></p>

    <p class="text-gray-300">Moreover, <span class="math">\\mathsf{A}_{2}</span> is a</p>

    <p class="text-gray-300"><span class="math">(\\mathsf{SKE1.CTLen}(\\lambda,B(\\lambda)),\\ B^{\\prime}(\\lambda)-\\mathsf{MAC.OutLen}(\\lambda),\\ Q_{\\mathsf{A}}(\\lambda))</span></p>

    <p class="text-gray-300">forging adversary.</p>

    <h6 id="sec-72" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Fix <span class="math">\\mathsf{A}</span> and <span class="math">\\lambda</span>, and let <span class="math">\\mathbf{G}_{0}</span> denote the original chosen ciphertext attack game. Let <span class="math">T_{0}</span> be the event that <span class="math">\\sigma=\\hat{\\sigma}</span> in game <span class="math">\\mathbf{G}_{0}</span>.</p>

    <p class="text-gray-300">We next define a modified attack game <span class="math">\\mathbf{G}_{1}</span>, in which all ciphertexts submitted to the decryption oracle by <span class="math">\\mathsf{A}</span> in game <span class="math">\\mathbf{G}_{1}</span> are simply rejected.</p>

    <p class="text-gray-300"><span class="math">T_{1}</span> be the event that <span class="math">\\sigma=\\hat{\\sigma}</span> is game <span class="math">\\mathbf{G}_{1}</span>. Let <span class="math">R_{1}</span> be the event in game <span class="math">\\mathbf{G}_{1}</span> that some ciphertext is rejected in game <span class="math">\\mathbf{G}_{1}</span> that would not have been rejected under the rules of game <span class="math">\\mathbf{G}_{0}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since games <span class="math">\\mathbf{G}_{0}</span> and <span class="math">\\mathbf{G}_{1}</span> proceed identically until event <span class="math">R_{1}</span> occurs, the events <span class="math">T_{0}\\wedge\\neg R_{1}</span> and <span class="math">T_{1}\\wedge\\neg R_{1}</span> are identical, and so by Lemma 4, we have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[T_{0}]-\\Pr[T_{1}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\Pr[R_{1}]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It is straightforward to verify that</p>

    <p class="text-gray-300"><span class="math">\\Pr[R_{1}]\\leq\\mathsf{AdvForge}_{\\mathsf{MAC,A_{2}}}(\\lambda)</span> (16)</p>

    <p class="text-gray-300">for an adversary <span class="math">\\mathsf{A}_{2}</span> as described above.</p>

    <p class="text-gray-300">The theorem now follows by observing that the attack by <span class="math">\\mathsf{A}</span> in game <span class="math">\\mathbf{G}_{1}</span> is now a passive attack. That is, the adversary <span class="math">\\mathsf{A}_{1}</span> in the theorem simply runs the adversary <span class="math">\\mathsf{A}</span>, and whenever <span class="math">\\mathsf{A}</span> makes a decryption oracle query, adversary <span class="math">\\mathsf{A}_{1}</span> simply lets <span class="math">\\mathsf{A}</span> continue as if the decryption oracle rejected the ciphertext. ∎</p>

    <h6 id="sec-73" class="text-base font-medium mt-4">Remark 12</h6>

    <p class="text-gray-300">Although the keys for <span class="math">\\mathsf{SKE2}</span> are longer than those for <span class="math">\\mathsf{SKE1}</span>, this need not be the case if we use a pseudo-random bit generator to stretch a short key into a suitably long key. Indeed, the key length of any symmetric key encryption scheme need be no longer than the key length of a secure a pseudo-random bit generator.</p>

    <h3 id="sec-74" class="text-xl font-semibold mt-8">7.3 A hybrid construction</h3>

    <p class="text-gray-300">Let <span class="math">\\mathsf{KEM}</span> be a key encapsulation mechanism (as defined in §7.1) and let <span class="math">\\mathsf{SKE}</span> be a one-time symmetric key encryption scheme (as defined in §7.2). Further, let us assume that the two schemes are compatible in the sense that for all <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span>, we have <span class="math">\\mathsf{KEM.KeyLen}(\\lambda)=\\mathsf{SKE.KeyLen}(\\lambda)</span>. We now describe a hybrid public-key encryption scheme <span class="math">\\mathsf{HPKE}</span>.</p>

    <p class="text-gray-300">The key generation algorithm for <span class="math">\\mathsf{HPKE}</span> is the same as that of <span class="math">\\mathsf{KEM}</span>, and the public and secret keys are the same as those of <span class="math">\\mathsf{KEM}</span>.</p>

    <p class="text-gray-300">To encrypt a message <span class="math">m</span> in the hybrid scheme, we run <span class="math">\\mathsf{KEM.Encrypt}</span> to generate a symmetric key <span class="math">K</span> and a ciphertext <span class="math">\\psi</span> encrypting <span class="math">K</span>. We then encrypt <span class="math">m</span> under the key <span class="math">K</span> using <span class="math">\\mathsf{SKE.Encrypt}</span>, obtaining a ciphertext <span class="math">\\chi</span>. The output of the encryption algorithm is <span class="math">\\hat{\\psi}=(\\psi,\\chi)</span>, encoded in a canonical fashion as a bit string.</p>

    <p class="text-gray-300">The decryption algorithm for the hybrid scheme runs as follows. Given a ciphertext <span class="math">\\hat{\\psi}</span>, we first verify that <span class="math">\\hat{\\psi}</span> properly encodes a pair <span class="math">(\\psi,\\chi)</span>. If not, we output <span class="math">\\mathsf{reject}</span> and halt. Next, we decrypt <span class="math">\\psi</span> using <span class="math">\\mathsf{KEM.Decrypt}</span>; if this yields <span class="math">\\mathsf{reject}</span>, then we output <span class="math">\\mathsf{reject}</span> and halt. Otherwise, we obtain a symmetric key <span class="math">K</span> and decrypt <span class="math">\\chi</span> under <span class="math">K</span> using <span class="math">\\mathsf{SKE.Decrypt}</span>, and output the resulting decryption (which may be <span class="math">\\mathsf{reject}</span>).</p>

    <h6 id="sec-75" class="text-base font-medium mt-4">Theorem 5</h6>

    <p class="text-gray-300">If <span class="math">\\mathsf{KEM}</span> and <span class="math">\\mathsf{SKE}</span> are secure against adaptive chosen ciphertext attacks, then so is <span class="math">\\mathsf{HPKE}</span>.</p>

    <p class="text-gray-300">In particular, if <span class="math">\\mathsf{A}</span> is a probabilistic, polynomial-time oracle query machine, then there exist probabilistic oracle query machines <span class="math">\\mathsf{A}_{1}</span> and <span class="math">\\mathsf{A}_{2}</span>, whose running times are essentially the same as that of <span class="math">\\mathsf{A}</span>, such that for all <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span>, we have</p>

    <p class="text-gray-300"><span class="math">\\mathsf{AdvCCA}_{\\mathsf{HPKE,A}}(\\lambda)\\leq\\mathsf{BadKeyPair}_{\\mathsf{KEM}}(\\lambda)+\\mathsf{AdvCCA}^{\\prime}_{\\mathsf{KEM,A_{1}}}(\\lambda)+\\mathsf{AdvCCA}_{\\mathsf{SKE,A_{2}}}(\\lambda).</span></p>

    <h6 id="sec-76" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Fix <span class="math">\\mathsf{A}</span> and <span class="math">\\lambda</span>, and let <span class="math">\\mathbf{G}_{0}</span> be the original chosen ciphertext attack game played by <span class="math">\\mathsf{A}</span> against <span class="math">\\mathsf{HPKE}</span>. We let <span class="math">\\hat{\\psi}^{<em>}=(\\psi^{</em>},\\chi^{<em>})</span> denote the target ciphertext; <span class="math">\\sigma</span> is the hidden bit generated by the encryption oracle and <span class="math">\\hat{\\sigma}</span> is the bit output by <span class="math">\\mathsf{A}</span>. Let <span class="math">T_{0}</span> be the event that <span class="math">\\sigma=\\hat{\\sigma}</span>. Also, let <span class="math">K^{</em>}</span> denote the symmetric key output by the algorithm <span class="math">\\mathsf{KEM.Encrypt}</span> during the encryption process within the encryption oracle.</p>

    <p class="text-gray-300">We now define a modified game <span class="math">\\mathbf{G}_{1}</span>. In this game, whenever a ciphertext <span class="math">(\\psi,\\chi)</span> is submitted to the decryption oracle after the invocation of the encryption oracle, if <span class="math">\\psi=\\psi^{<em>}</span> (but <span class="math">\\chi\\neq\\chi^{</em>}</span> of course), then the decryption oracle does not apply algorithm KEM.Decrypt to obtain the symmetric key, but instead just uses the key <span class="math">K^{*}</span> produced by the encryption oracle. Let <span class="math">T_{1}</span> be the event that <span class="math">\\sigma=\\hat{\\sigma}</span> in game <span class="math">\\mathbf{G}_{1}</span>.</p>

    <p class="text-gray-300">This change is slightly more than just conceptual, since KEM.KeyGen may generate a bad key pair with probability <span class="math">\\mathsf{BadKeyPair}_{\\mathsf{KEM}}(\\lambda)</span>. However, unless this occurs, games <span class="math">\\mathbf{G}_{0}</span> and <span class="math">\\mathbf{G}_{1}</span> proceed identically, and so by Lemma 4, we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[T_{1}]-\\Pr[T_{0}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\mathsf{BadKeyPair}_{\\mathsf{KEM}}(\\lambda).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Now we define a modified game <span class="math">\\mathbf{G}_{2}</span>. This game behaves just like game <span class="math">\\mathbf{G}_{1}</span>, except that we use a completely random symmetric key <span class="math">K^{+}</span> in place of the key <span class="math">K^{*}</span> in both the encryption and decryption oracles. Let <span class="math">T_{2}</span> be the event that <span class="math">\\sigma=\\hat{\\sigma}</span> in game <span class="math">\\mathbf{G}_{2}</span>.</p>

    <p class="text-gray-300">It is straightforward to see that there is an oracle query machine <span class="math">\\mathsf{A}_{1}</span>, whose running time is essentially the same as that of <span class="math">\\mathsf{A}</span>, such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[T_{2}]-\\Pr[T_{1}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathsf{AdvCCA}_{\\mathsf{KEM,A}_{1}}^{\\epsilon}(\\lambda).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The adversary <span class="math">\\mathsf{A}_{1}</span> basically just runs the adversary <span class="math">\\mathsf{A}</span>. In the attack game that <span class="math">\\mathsf{A}_{1}</span> is playing against <span class="math">\\mathsf{KEM}</span>, the value <span class="math">K^{\\dagger}</span> is equal to <span class="math">K^{<em>}</span> in game <span class="math">\\mathbf{G}_{1}</span>, and is equal to <span class="math">K^{+}</span> in game <span class="math">\\mathbf{G}_{2}</span>. Note that in games <span class="math">\\mathbf{G}_{1}</span> and <span class="math">\\mathbf{G}_{2}</span>, the ciphertext <span class="math">\\psi^{</em>}</span> is never explicitly decrypted, and so <span class="math">\\mathsf{A}_{1}</span> need not submit this for decryption either.</p>

    <p class="text-gray-300">Lastly, we observe that there is an oracle query machine <span class="math">\\mathsf{A}_{2}</span>, whose running time is essentially the same as that of <span class="math">\\mathsf{A}</span>, such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[T_{2}]-1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathsf{AdvCCA}_{\\mathsf{SKE,A}_{2}}(\\lambda).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To see this, note that in game <span class="math">\\mathbf{G}_{2}</span>, the ciphertext <span class="math">\\chi^{<em>}</span> is produced using the random symmetric encryption key <span class="math">K^{+}</span>, and also that some other ciphertexts <span class="math">\\chi\\neq\\chi^{</em>}</span> are decrypted using <span class="math">K^{+}</span>, but that the key <span class="math">K^{+}</span> plays no other role in game <span class="math">\\mathbf{G}_{2}</span>. Thus, in game <span class="math">\\mathbf{G}_{2}</span>, the adversary <span class="math">\\mathsf{A}</span> is essentially just carrying out an adaptive chosen ciphertext attack against <span class="math">\\mathsf{SKE}</span>. <span class="math">\\Box</span></p>

    <h6 id="sec-77" class="text-base font-medium mt-4">Remark 13</h6>

    <p class="text-gray-300">We stress that it is essential for both <span class="math">\\mathsf{KEM}</span> and <span class="math">\\mathsf{SKE}</span> to be secure against adaptive chosen ciphertext attack in order to prove that <span class="math">\\mathsf{HPKE}</span> is as well. One cannot start with a “weak” <span class="math">\\mathsf{KEM}</span> and hope to “repair” it with a hybrid construction: doing this may indeed foil some specific attacks, but we know of no way to formally reason about the security of such a scheme. It is also important not to waste the chosen ciphertext security of <span class="math">\\mathsf{KEM}</span> by using a “weak” <span class="math">\\mathsf{SKE}</span>. Indeed, some popular methods of constructing a “digital envelope” use a <span class="math">\\mathsf{SKE}</span> that may only be secure against passive attacks; even if the resulting composite ciphertext is digitally signed, this does not necessarily provide security against chosen ciphertext attack.</p>

    <h2 id="sec-78" class="text-2xl font-bold">8 Key Derivation Functions</h2>

    <p class="text-gray-300">In the next section, we will present and analyze a key encapsulation mechanism. The key will be derived by hashing a pair of group elements. In order not to clutter that section, we develop here the notion of such a key derivation function.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{G}</span> be a computational group scheme, specifying a sequence <span class="math">(\\mathbf{S}_{\\lambda})_{\\lambda\\in\\mathbf{Z}_{\\geq 0}}</span> of group distributions.</p>

    <p class="text-gray-300">A key derivation scheme <span class="math">\\mathsf{KDF}</span> associated with <span class="math">\\mathcal{G}</span> specifies two items:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A family of key spaces indexed by <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> and <span class="math">\\Gamma \\in [\\mathbf{S}_{\\lambda}]</span>. Each such key space is a probability space on bit strings denoted by KDF.KeySpace<span class="math">_{\\lambda, \\Gamma}</span>.</li>

    </ul>

    <p class="text-gray-300">There must exist a probabilistic, polynomial-time algorithm whose output distribution on input <span class="math">1^{\\lambda}</span> and <span class="math">\\Gamma</span> is equal to KDF.KeySpace<span class="math">_{\\lambda, \\Gamma}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A family of key derivation functions indexed by <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>, <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span>, and <span class="math">\\mathrm{dk} \\in [\\mathrm{KDF.KeySpace}_{\\lambda, \\Gamma}]</span>, where each such function <span class="math">\\mathrm{KDF}_{\\mathrm{dk}}^{\\lambda, \\Gamma}</span> maps a pair <span class="math">(a, b) \\in G^2</span> of group elements to a key <span class="math">K</span>.</li>

    </ul>

    <p class="text-gray-300">A key <span class="math">K</span> is a bit string of length KDF.OutLen<span class="math">(\\lambda)</span>. The parameter KDF.OutLen<span class="math">(\\lambda)</span> should be computable in deterministic polynomial time given <span class="math">1^{\\lambda}</span>.</p>

    <p class="text-gray-300">There must exist a deterministic, polynomial-time algorithm that on input <span class="math">1^{\\lambda}</span>, <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span>, <span class="math">\\mathrm{dk} \\in [\\mathrm{KDF.KeySpace}_{\\lambda, \\Gamma}]</span>, and <span class="math">(a, b) \\in G^2</span>, outputs <span class="math">\\mathrm{KDF}_{\\mathrm{dk}}^{\\lambda, \\Gamma}(a, b)</span>.</p>

    <p class="text-gray-300">We now define the security property that we shall require of KDF.</p>

    <p class="text-gray-300">For all <span class="math">0/1</span>-valued, probabilistic, polynomial-time algorithms <span class="math">\\mathsf{A}</span>, and for all <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>, define</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\text{AdvDist}_{\\mathsf{KDF}, \\mathsf{A}}(\\lambda) := \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[ \\tau = 1: \\Gamma \\stackrel{R}{\\leftarrow} \\mathbf{S}_{\\lambda}; \\mathrm{dk} \\stackrel{R}{\\leftarrow} \\mathrm{KDF.KeySpace}_{\\lambda, \\Gamma}; a, b \\stackrel{R}{\\leftarrow} G; \\right. \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\left. \\tau \\stackrel{R}{\\leftarrow} \\mathsf{A}(1^{\\lambda}, \\Gamma, \\mathrm{dk}, a, \\mathrm{KDF}_{\\mathrm{dk}}^{\\lambda, \\Gamma}(a, b)) \\right] - \\\\ \\Pr[ \\tau = 1: \\Gamma \\stackrel{R}{\\leftarrow} \\mathbf{S}_{\\lambda}; \\mathrm{dk} \\stackrel{R}{\\leftarrow} \\mathrm{KDF.KeySpace}_{\\lambda, \\Gamma}; a \\stackrel{R}{\\leftarrow} G; K \\stackrel{R}{\\leftarrow} \\{0, 1\\}^{\\mathrm{KDF.OutLen}(\\lambda)}; \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left. \\tau \\stackrel{R}{\\leftarrow} \\mathsf{A}(1^{\\lambda}, \\Gamma, \\mathrm{dk}, a, K) \\right] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">That is, <span class="math">\\text{AdvDist}_{\\mathsf{KDF}, \\mathsf{A}}(\\lambda)</span> measures the advantage that <span class="math">\\mathsf{A}</span> has in distinguishing two distributions: in the first it is given <span class="math">\\mathrm{KDF}_{\\mathrm{dk}}^{\\lambda, \\Gamma}(a, b)</span> and in the second it is given a random key <span class="math">K</span>; in both distributions it is given the derivation key <span class="math">\\mathrm{dk}</span> as well as the auxiliary group element <span class="math">a</span>.</p>

    <p class="text-gray-300">We shall say that KDF is secure if this distinguishing advantage is negligible, i.e.,</p>

    <p class="text-gray-300">for all 0/1-valued, probabilistic, polynomial-time algorithms <span class="math">\\mathsf{A}</span>, the function <span class="math">\\text{AdvDist}_{\\mathsf{KDF}, \\mathsf{A}}(\\lambda)</span> grows negligibly in <span class="math">\\lambda</span>.</p>

    <p class="text-gray-300">It is also convenient to define a quantity analogous to <span class="math">\\text{AdvDist}_{\\mathsf{KDF}, \\mathsf{A}}(\\lambda)</span>, but conditioned on a fixed group description. For all <span class="math">0/1</span>-valued, probabilistic, polynomial-time algorithms <span class="math">\\mathsf{A}</span>, for all <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>, and all <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span>,</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\text{AdvDist}_{\\mathsf{KDF}, \\mathsf{A}}(\\lambda \\mid \\Gamma) := \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[ \\tau = 1: \\mathrm{dk} \\stackrel{R}{\\leftarrow} \\mathrm{KDF.KeySpace}_{\\lambda, \\Gamma}; a, b \\stackrel{R}{\\leftarrow} G; \\right. \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\left. \\tau \\stackrel{R}{\\leftarrow} \\mathsf{A}(1^{\\lambda}, \\Gamma, \\mathrm{dk}, a, \\mathrm{KDF}_{\\mathrm{dk}}^{\\lambda, \\Gamma}(a, b)) \\right] - \\\\ \\Pr[ \\tau = 1: \\mathrm{dk} \\stackrel{R}{\\leftarrow} \\mathrm{KDF.KeySpace}_{\\lambda, \\Gamma}; a \\stackrel{R}{\\leftarrow} G; K \\stackrel{R}{\\leftarrow} \\{0, 1\\}^{\\mathrm{KDF.OutLen}(\\lambda)}; \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left. \\tau \\stackrel{R}{\\leftarrow} \\mathsf{A}(1^{\\lambda}, \\Gamma, \\mathrm{dk}, a, K) \\right] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <h2 id="sec-79" class="text-2xl font-bold">8.1 Constructions</h2>

    <h3 id="sec-80" class="text-xl font-semibold mt-8">8.1.1 Unconditionally secure constructions</h3>

    <p class="text-gray-300">One can build a secure KDF for <span class="math">\\mathcal{G}</span> without any assumptions, provided the groups defined by <span class="math">\\mathcal{G}</span> are sufficiently large, which they certainly will be in our applications. Indeed, all we need is that KDF is pair-wise independent.</p>

    <p class="text-gray-300">In our context, we shall say that a KDF is pair-wise independent if for all <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span>, for all <span class="math">\\Gamma[\\hat{G},G,g,q]\\in[\\mathbf{S}_{\\lambda}]</span>, for all <span class="math">a,b,b^{\\prime}\\in G</span> with <span class="math">b\\neq b^{\\prime}</span>, the distribution</p>

    <p class="text-gray-300"><span class="math">\\{(\\mathsf{KDF}^{\\lambda,\\Gamma}_{\\mathsf{dk}}(a,b),\\mathsf{KDF}^{\\lambda,\\Gamma}_{\\mathsf{dk}}(a,b^{\\prime})):\\mathsf{dk}\\stackrel{{\\scriptstyle\\mu}}{{\\leftarrow}}\\mathsf{KDF.KeySpace}_{\\lambda,\\Gamma}\\}</span></p>

    <p class="text-gray-300">is the uniform distribution over all pairs of bits strings of length <span class="math">\\mathsf{KDF.OutLen}(\\lambda)</span>.</p>

    <p class="text-gray-300">By the Leftover Hash Lemma <em>[x10, x14]</em>, it follows that if KDF is pair-wise independent, then for all <span class="math">0/1</span>-valued, probabilistic, polynomial-time algorithms A, for all <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span>, and all <span class="math">\\Gamma[\\hat{G},G,g,q]\\in[\\mathbf{S}_{\\lambda}]</span>,</p>

    <p class="text-gray-300"><span class="math">\\mathsf{AdvDist}_{\\mathsf{KDF,A}}(\\lambda\\mid\\Gamma)\\leq 2^{-k},</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">k=\\lfloor\\frac{\\lfloor\\log_{2}q\\rfloor-\\mathsf{KDF.OutLen}(\\lambda)}{2}\\rfloor.</span></p>

    <p class="text-gray-300">We also point out that fairly efficient pair-wise independent functions can be constructed without relying on any intractability assumptions.</p>

    <h4 id="sec-81" class="text-lg font-semibold mt-6">8.1.2 Conditionally secure constructions</h4>

    <p class="text-gray-300">In practice, to build a key derivation function, one might simply use a dedicated cryptographic hash function, like SHA-1.</p>

    <p class="text-gray-300">In this situation, we will simply be forced to assume that such a KDF is secure. However, such an intractability assumption is not entirely unreasonable. Moreover, a dedicated cryptographic hash function has several potential advantages over a pair-wise independent hash function:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>it may not use a key, or it may use a very short key, which may lead to a significant space savings;</li>

      <li>it can usually be evaluated more quickly than a typical pair-wise independent hash function can;</li>

      <li>it can be safely used to derive output keys that are significantly longer than would be safe to derive with a typical pair-wise independent hash function;</li>

      <li>it may, at least heuristically, provide even more security in applications than a typical pair-wise independent hash function.</li>

    </ul>

    <h2 id="sec-82" class="text-2xl font-bold">9 The New Encryption Scheme: Hybrid Version</h2>

    <h3 id="sec-83" class="text-xl font-semibold mt-8">9.1 Description of the Scheme</h3>

    <p class="text-gray-300">In this section, we present a hybrid version of our new encryption scheme. Specifically, we present a key encapsulation mechanism CS3, out of which one can easily construct a hybrid encryption scheme, as described in §7.</p>

    <p class="text-gray-300">The scheme makes use of a computational group scheme <span class="math">\\mathcal{G}</span> as described in §4.1, defining a sequence <span class="math">(\\mathbf{S}_{\\lambda})_{\\lambda\\in\\mathbf{Z}_{\\geq 0}}</span> of distributions of group descriptions, and providing a sampling algorithm <span class="math">\\hat{S}</span>, where the output distribution <span class="math">\\hat{S}(1^{\\lambda})</span> closely approximates <span class="math">\\mathbf{S}_{\\lambda}</span>.</p>

    <p class="text-gray-300">The scheme also makes use of a binary group hashing scheme HF associated with <span class="math">\\mathcal{G}</span>, as described in §5.</p>

    <p class="text-gray-300">Finally, the scheme makes use of a key derivation scheme KDF, associated with <span class="math">\\mathcal{G}</span>, as described in §8. Note that output key length CS3.KeyLen<span class="math">(\\lambda)</span> of the scheme is equal to KDF.OutLen<span class="math">(\\lambda)</span>.</p>

    <p class="text-gray-300">The scheme is described in detail in Figure 5.</p>

    <p class="text-gray-300">Key Generation: On input  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , compute</p>

    <p class="text-gray-300"><span class="math">\\Gamma[\\hat{G}, G, g, q] \\stackrel{\\kappa}{\\leftarrow} \\hat{S}(1^{\\lambda})</span> ;  <span class="math">\\mathsf{hk} \\stackrel{\\kappa}{\\leftarrow} \\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda, \\Gamma}</span> ;  <span class="math">\\mathsf{dk} \\stackrel{\\kappa}{\\leftarrow} \\mathsf{KDF}.\\mathsf{KeySpace}_{\\lambda, \\Gamma}</span> ;</p>

    <p class="text-gray-300"><span class="math">w\\stackrel {\\kappa}{\\leftarrow}\\mathbf{Z}_q^x;x_1,x_2,y_1,y_2,z_1,z_2\\stackrel {\\kappa}{\\leftarrow}\\mathbf{Z}_q;</span></p>

    <p class="text-gray-300"><span class="math">\\hat{g}\\gets g^{w};e\\gets g^{x_1}\\hat{g}^{x_2};f\\gets g^{y_1}\\hat{g}^{y_2};h\\gets g^{z_1}\\hat{g}^{z_2};</span></p>

    <p class="text-gray-300">and output the public key  <span class="math">\\mathsf{PK} = (\\Gamma ,\\mathsf{hk},\\mathsf{dk},\\hat{g},e,f,h)</span>  and the secret key</p>

    <p class="text-gray-300"><span class="math">\\mathsf{SK} = (\\Gamma ,\\mathsf{hk},\\mathsf{dk},x_1,x_2,y_1,y_2,z_1,z_2)</span></p>

    <p class="text-gray-300">Encryption: Given  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , a public key</p>

    <p class="text-gray-300"><span class="math">\\mathsf{PK} = (\\Gamma [\\hat{G},G,g,q],\\mathsf{hk},\\mathsf{dk},\\hat{g},e,f,h)\\in [\\mathbf{S}_{\\lambda}]\\times [\\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda ,\\Gamma}]\\times [\\mathsf{KDF}.\\mathsf{KeySpace}_{\\lambda ,\\Gamma}]\\times G^{4},</span></p>

    <p class="text-gray-300">compute</p>

    <p class="text-gray-300">E1:  <span class="math">u \\stackrel{\\kappa}{\\leftarrow} \\mathbf{Z}_q</span> ; E2:  <span class="math">a \\gets g^u</span> ; E3:  <span class="math">\\hat{a} \\gets \\hat{g}^u</span> ; E4:  <span class="math">b\\gets h^u</span> E5:  <span class="math">K\\gets \\mathsf{KDF}_{\\mathsf{dk}}^{\\lambda ,\\Gamma}(a,b)</span> E6:  <span class="math">v\\gets \\mathsf{HF}_{\\mathsf{hk}}^{\\lambda ,\\Gamma}(a,\\hat{a})</span> E7:  <span class="math">d\\gets e^{u}f^{av}</span></p>

    <p class="text-gray-300">and output the symmetric key  <span class="math">K</span>  and the ciphertext  <span class="math">\\psi = (a,\\hat{a},d)</span></p>

    <p class="text-gray-300">Decryption: Given  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , a secret key</p>

    <p class="text-gray-300"><span class="math">\\mathsf{SK} = (\\Gamma [\\hat{G},G,g,q],\\mathsf{hk},\\mathsf{dk},x_1,x_2,y_1,y_2,z_1,z_2)\\in [\\mathbf{S}_\\lambda ]\\times [\\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda ,\\Gamma}]\\times [\\mathsf{KDF}.\\mathsf{KeySpace}_{\\lambda ,\\Gamma}]\\times \\mathbf{Z}_q^6,</span></p>

    <p class="text-gray-300">along with a ciphertext  <span class="math">\\psi</span> , do the following.</p>

    <p class="text-gray-300">D1: Parse  <span class="math">\\psi</span>  as a 3-tuple  <span class="math">(a, \\hat{a}, d) \\in \\hat{G}^3</span> ; output reject and halt if  <span class="math">\\psi</span>  is not of this form. D2: Test if  <span class="math">a</span>  and  <span class="math">\\hat{a}</span>  belong to  <span class="math">G</span> ; output reject and halt if this is not the case. D3: Compute  <span class="math">v \\gets \\mathsf{HF}_{\\mathsf{hk}}^{\\lambda, \\Gamma}(a, \\hat{a})</span> . D4: Test if  <span class="math">d = a^{x_1 + y_1v}\\hat{a}^{x_2 + y_2v}</span> ; output reject and halt if this is not the case. D5: Compute  <span class="math">b \\gets a^{z_1} \\hat{a}^{z_2}</span> . D6: Compute  <span class="math">K \\gets \\mathsf{KDF}_{\\mathsf{dk}}^{\\lambda, \\Gamma}(a, b)</span> , and output the symmetric key  <span class="math">K</span> .</p>

    <p class="text-gray-300">Figure 5: The key encapsulation mechanism CS3</p>

    <p class="text-gray-300">9.2 Security analysis of the scheme</p>

    <p class="text-gray-300">We shall prove that <span class="math">\\mathsf{CS3}</span> is secure against adaptive chosen ciphertext attack if the DDH assumption holds for <span class="math">\\mathcal{G}</span>, and the TCR assumption holds for <span class="math">\\mathsf{HF}</span>, and assuming that <span class="math">\\mathsf{KDF}</span> is a secure key derivation scheme.</p>

    <p class="text-gray-300">As we have done before, for all probabilistic, polynomial-time oracle query machines <span class="math">\\mathsf{A}</span>, and for all <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>, we let <span class="math">Q_{\\mathsf{A}}(\\lambda)</span> be an upper bound on the number of decryption oracle queries made by <span class="math">\\mathsf{A}</span> on input <span class="math">1^{\\lambda}</span>. We assume that <span class="math">Q_{\\mathsf{A}}(\\lambda)</span> is a strict bound in the sense that it holds regardless of the probabilistic choices of <span class="math">\\mathsf{A}</span>, and regardless of the responses to its oracle queries from its environment.</p>

    <p class="text-gray-300"><strong>Theorem 6</strong> If the DDH assumption holds for <span class="math">\\mathcal{G}</span> and the TCR assumption holds for <span class="math">\\mathsf{HF}</span>, and assuming that <span class="math">\\mathsf{KDF}</span> is a secure key derivation scheme, then <span class="math">\\mathsf{CS3}</span> is secure against adaptive chosen ciphertext attack</p>

    <p class="text-gray-300">In particular, for all probabilistic, polynomial-time oracle query machines <span class="math">\\mathsf{A}</span>, there exist probabilistic algorithms <span class="math">\\mathsf{A}_1</span>, <span class="math">\\mathsf{A}_2</span>, and <span class="math">\\mathsf{A}_3</span> whose running times are essentially the same as that of <span class="math">\\mathsf{A}</span>, such that the following holds. For all <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>, and all <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span>, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{AdvCCA}_{\\mathsf{CS3},\\mathsf{A}}(\\lambda \\mid \\Gamma) \\leq \\operatorname{AdvDDH}_{\\mathcal{G},\\mathsf{A}_1}(\\lambda \\mid \\Gamma) + \\operatorname{AdvTCR}_{\\mathsf{HF},\\mathsf{A}_2}(\\lambda \\mid \\Gamma) + \\operatorname{AdvDist}_{\\mathsf{KDF},\\mathsf{A}_3}(\\lambda \\mid \\Gamma) + (Q_{\\mathsf{A}}(\\lambda) + 3)/q. \\tag{17}</span></div>

    <p class="text-gray-300">To prove Theorem 6, let us fix a probabilistic, polynomial-time oracle query machine <span class="math">\\mathsf{A}</span>, the value of the security parameter <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>, and the group description <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span>.</p>

    <p class="text-gray-300">The proof follows the same line of argument as the proof of Theorem 1, and we will at several places appeal to argument in that proof, so as to avoid unnecessary repetition.</p>

    <p class="text-gray-300">The attack game is as described in §7.1.2. We now discuss the relevant random variables in this game.</p>

    <p class="text-gray-300">Suppose that the public key is <span class="math">(\\Gamma, \\mathsf{hk}, \\mathsf{dk}, \\hat{g}, e, f, h)</span> and that the secret key is <span class="math">(\\Gamma, \\mathsf{hk}, \\mathsf{dk}, x_1, x_2, y_1, y_2, z_1, z_2)</span>. Let <span class="math">w := \\log_g \\hat{g}</span>, and define <span class="math">x, y, z \\in \\mathbf{Z}_q</span> as follows:</p>

    <div class="my-4 text-center"><span class="math-block">x := x_1 + x_2 w, \\quad y := y_1 + y_2 w, \\quad z := z_1 + z_2 w.</span></div>

    <p class="text-gray-300">As a notational convention, whenever a particular ciphertext <span class="math">\\psi</span> is under consideration in some context, the following values are also implicitly defined in that context:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">a, \\hat{a}, d \\in G</span>, where <span class="math">\\psi = (a, \\hat{a}, d)</span>;</li>

      <li><span class="math">u, \\hat{u}, v, s \\in \\mathbf{Z}_q</span>, where</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">u := \\log_g a, \\quad \\hat{u} := \\log_{\\hat{g}} \\hat{a}, \\quad v := \\mathsf{HF}_{\\mathsf{hk}}^{\\lambda, \\Gamma}(a, \\hat{a}), \\quad s := \\log_g d.</span></div>

    <p class="text-gray-300">For the target ciphertext <span class="math">\\psi^{<em>}</span>, we also denote by <span class="math">a^{</em>}, \\hat{a}^{<em>}, d^{</em>} \\in G</span>, and <span class="math">u^{<em>}, \\hat{u}^{</em>}, v^{<em>}, s^{</em>} \\in \\mathbf{Z}_{q}</span> the corresponding values.</p>

    <p class="text-gray-300">The probability space defining the attack game is then determined by the following, mutually independent, random variables:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the coin tosses of <span class="math">\\mathsf{A}</span>;</li>

      <li>the values <span class="math">\\mathsf{hk}, \\mathsf{dk}, w, x_1, x_2, y_1, y_2, z_1, z_2</span> generated by the key generation algorithm;</li>

      <li>the values <span class="math">\\tau \\in \\{0,1\\}</span>, <span class="math">K^{+} \\in \\{0,1\\}^{\\mathsf{KDF.OutLen}(\\lambda)}</span>, and <span class="math">u^{*} \\in \\mathbf{Z}_{q}</span> generated by the encryption oracle in the attack game.</li>

    </ul>

    <p class="text-gray-300">46</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbf{G}_{0}</span> be the original attack game, let <span class="math">\\hat{\\tau}\\in\\{0,1\\}</span> denote the output of <span class="math">\\mathsf{A}</span>, and let <span class="math">T_{0}</span> be the event that <span class="math">\\tau=\\hat{\\tau}</span> in <span class="math">\\mathbf{G}_{0}</span>, so that $\\mathsf{AdvCCA}_{\\mathsf{CS3},\\mathsf{A}}(\\lambda\\mid\\Gamma)=\\mid{\\rm Pr}[T_{0}]-1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As in the proof of Theorem 1, we shall define a sequence of modified games <span class="math">\\mathbf{G}_{i}</span>, for <span class="math">i=1,2,\\ldots</span>, where in game <span class="math">\\mathbf{G}_{i}</span>, the event <span class="math">T_{i}</span> will be the event corresponding to event <span class="math">T_{0}</span>, but in game <span class="math">\\mathbf{G}_{i}</span>. The overall structure of the proof will differ a bit from that of Theorem 1, even though many of the low level details will be very similar. Indeed, the proof of this theorem is conceptually a bit simpler (even though there are more steps) than that of Theorem 1, since the inputs to <span class="math">\\mathsf{HF}_{\\mathsf{hk}}^{\\lambda,\\Gamma}</span> in the encryption oracle are independent of any quantities computed by the adversary; we also save a term of <span class="math">1/q</span> in (17) because of this.</p>

    <p class="text-gray-300">Game <span class="math">\\mathbf{G}_{1}</span>. We now modify game <span class="math">\\mathbf{G}_{0}</span> to obtain a new game <span class="math">\\mathbf{G}_{1}</span>. These two games are identical, except that instead of using the encryption algorithm as given to compute the target ciphertext <span class="math">\\psi^{*}</span>, we use a modified encryption algorithm, in which steps E4 and E7 are replaced by:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{E4^{\\prime}}</span>: <span class="math">b\\leftarrow a^{z_{1}}\\hat{a}^{z_{2}}</span>;</li>

      <li><span class="math">\\mathbf{E7^{\\prime}}</span>: <span class="math">d\\leftarrow a^{x_{1}+y_{1}v}\\hat{a}^{x_{2}+y_{2}v}</span>.</li>

    </ul>

    <p class="text-gray-300">By the same reasoning as in the proof of Theorem 1, we have</p>

    <p class="text-gray-300"><span class="math">{\\rm Pr}[T_{1}]={\\rm Pr}[T_{0}].</span></p>

    <p class="text-gray-300">Game <span class="math">\\mathbf{G}_{2}</span>. We again modify the encryption oracle, replacing step E3 by</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{E3^{\\prime}}</span>: <span class="math">\\hat{u}\\xleftarrow{\\mu}\\mathbf{Z}_{q}</span>; <span class="math">\\hat{a}\\leftarrow\\hat{g}^{\\hat{u}}</span>.</li>

    </ul>

    <p class="text-gray-300">By the same reasoning as in the proof of Theorem 1, one sees that there exists a probabilistic algorithm <span class="math">\\mathsf{A}_{1}</span>, whose running time is essentially the same as that of <span class="math">\\mathsf{A}</span>, such that</p>

    <p class="text-gray-300"><span class="math">\\mid{\\rm Pr}[T_{2}]-{\\rm Pr}[T_{1}]\\mid\\leq\\mathsf{AdvDDH}_{\\mathcal{G},\\mathsf{A}_{1}}(\\lambda\\mid\\Gamma)+2/q.</span></p>

    <p class="text-gray-300">Note that unlike game <span class="math">\\mathbf{G}_{2}</span> in the proof of Theorem 1, we do not impose the restriction <span class="math">u^{<em>}\\neq\\hat{u}^{</em>}</span> just yet; it is technically convenient to defer this until later. This is why the term <span class="math">2/q</span> appears in the above bound, rather than <span class="math">3/q</span>.</p>

    <p class="text-gray-300">Game <span class="math">\\mathbf{G}_{3}</span>. This game is the same as game <span class="math">\\mathbf{G}_{2}</span>, except for the following modification.</p>

    <p class="text-gray-300">We modify the decryption oracle so that it applies the following <em>special rejection rule</em>: if the adversary submits a ciphertext <span class="math">\\psi</span> for decryption at a point in time after the encryption oracle has been invoked, such that <span class="math">(a,\\hat{a})\\neq(a^{<em>},\\hat{a}^{</em>})</span> but <span class="math">v=v^{*}</span>, then the decryption oracle immediately outputs reject and halts (before executing step <span class="math">\\mathbf{D4^{\\prime}}</span>).</p>

    <p class="text-gray-300">We claim that there exists a probabilistic algorithm <span class="math">\\mathsf{A}_{2}</span>, whose running time is essentially the same as that of <span class="math">\\mathsf{A}</span>, such that</p>

    <p class="text-gray-300"><span class="math">\\mid{\\rm Pr}[T_{3}]-{\\rm Pr}[T_{2}]\\mid\\leq\\mathsf{AdvTCR}_{\\mathsf{HF},\\mathsf{A}_{2}}(\\lambda\\mid\\Gamma).</span></p>

    <p class="text-gray-300">This follows from reasoning very similar to the proof of Lemma 7 in the analysis of game <span class="math">\\mathbf{G}_{5}</span> in the proof of Theorem 1. Observe that we can impose the special rejection rule already in this game, rather than deferring to to a later game as in the proof of Theorem 1, because, as we mentioned above, the inputs to <span class="math">\\mathsf{HF}_{\\mathsf{hk}}^{\\lambda,\\Gamma}</span> in the encryption oracle are independent of any quantities computed by the adversary.</p>

    <p class="text-gray-300">.</p>

    <h4 id="sec-84" class="text-lg font-semibold mt-6">Game G_{4}.</h4>

    <p class="text-gray-300">We again modify the encryption oracle, replacing step E3^{′} by</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\hat{u}\\xleftarrow{\\text{\\tiny R}}\\mathbf{Z}_{q}\\setminus\\{u\\};~{}\\hat{a}\\xleftarrow{}\\hat{g}^{\\hat{u}}.</span></li>

    </ul>

    <p class="text-gray-300">It is easy to verify that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[T_{4}]-\\Pr[T_{3}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 1/q.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-85" class="text-lg font-semibold mt-6">Game G_{5}.</h4>

    <p class="text-gray-300">In this game, we modify the decryption oracle in game G_{4}, replacing steps D4 and D5 with:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Test if <span class="math">\\hat{a}=a^{w}</span> and <span class="math">d=a^{x+yv}</span>; output reject and halt if this is not the case.</li>

      <li><span class="math">b\\leftarrow a^{z}</span>.</li>

    </ul>

    <p class="text-gray-300">Let <span class="math">R_{5}</span> be the event that in game G_{5}, some ciphertext <span class="math">\\psi</span> is submitted to the decryption oracle that is rejected in step D4^{′} but that would have passed the test in step D4.</p>

    <p class="text-gray-300">It is clear that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[T_{5}]-\\Pr[T_{4}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\Pr[R_{5}].$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We also claim that</p>

    <p class="text-gray-300"><span class="math">\\Pr[R_{5}]\\leq Q_{\\mathsf{A}}(\\lambda)/q.</span></p>

    <p class="text-gray-300">This follows from reasoning analogous to that in Lemma 8 (in game G_{5} in the proof of Theorem 1).</p>

    <h4 id="sec-86" class="text-lg font-semibold mt-6">Game G_{6}.</h4>

    <p class="text-gray-300">We again modify the algorithm used by the encryption oracle, replacing step E4^{′} by</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">r\\xleftarrow{\\text{\\tiny R}}\\mathbf{Z}_{q};~{}b\\leftarrow g^{r}.</span></li>

    </ul>

    <p class="text-gray-300">By reasoning analogous to that in the analysis of game G_{4} in the proof of Theorem 1, one can easily show that</p>

    <p class="text-gray-300"><span class="math">\\Pr[T_{6}]=\\Pr[T_{5}].</span></p>

    <h4 id="sec-87" class="text-lg font-semibold mt-6">Game G_{7}.</h4>

    <p class="text-gray-300">In this game, we modify the encryption oracle, replacing step E5 of the encryption algorithm by</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">K\\xleftarrow{\\text{\\tiny R}}\\{0,1\\}^{\\mathsf{KDF},\\mathsf{OutLen}(\\lambda)}.</span></li>

    </ul>

    <p class="text-gray-300">It is straightforward to see that there exists a probabilistic algorithm <span class="math">\\mathsf{A}_{3}</span>, whose running time is essentially the same as that of <span class="math">\\mathsf{A}</span>, such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[T_{7}]-\\Pr[T_{6}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\mathsf{AdvDist}_{\\mathsf{KDF},\\mathsf{A}_{3}}(\\lambda\\mid\\Gamma).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Furthermore, it is clear that by construction that</p>

    <p class="text-gray-300"><span class="math">\\Pr[T_{7}]=1/2.</span></p>

    <p class="text-gray-300">That completes the proof of Theorem 6.</p>

    <p class="text-gray-300">Key Generation: On input  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , compute</p>

    <p class="text-gray-300"><span class="math">\\Gamma[\\hat{G}, G, g, q] \\stackrel{n}{\\leftarrow} \\hat{S}(1^{\\lambda})</span> ;  <span class="math">\\mathsf{hk} \\stackrel{n}{\\leftarrow} \\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda, \\Gamma}</span> ;  <span class="math">\\mathsf{dk} \\stackrel{n}{\\leftarrow} \\mathsf{KDF}.\\mathsf{KeySpace}_{\\lambda, \\Gamma}</span> ;</p>

    <p class="text-gray-300"><span class="math">w\\stackrel {n}{\\leftarrow}\\mathbf{Z}_q^z;x_1,x_2,y_1,y_2,z\\stackrel {n}{\\leftarrow}\\mathbf{Z}_q;</span></p>

    <p class="text-gray-300"><span class="math">\\hat{g}\\gets g^{w};e\\gets g^{x_1}\\hat{g}^{x_2};f\\gets g^{y_1}\\hat{g}^{y_2};h\\gets g^z;</span></p>

    <p class="text-gray-300">and output the public key  <span class="math">\\mathsf{PK} = (\\Gamma ,\\mathsf{hk},\\mathsf{dk},\\hat{g},e,f,h)</span>  and the secret key  <span class="math">\\mathsf{SK} = (\\Gamma ,\\mathsf{hk},\\mathsf{dk},x_1,x_2,y_1,y_2,z)</span> .</p>

    <p class="text-gray-300">Decryption: Given  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , a secret key</p>

    <p class="text-gray-300"><span class="math">\\mathsf{SK} = (\\Gamma [\\hat{G},G,g,q],\\mathsf{hk},\\mathsf{dk},x_1,x_2,y_1,y_2,z)\\in [\\mathbf{S}_\\lambda ]\\times [\\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda ,\\Gamma}]\\times [\\mathsf{KDF}.\\mathsf{KeySpace}_{\\lambda ,\\Gamma}]\\times \\mathbf{Z}_q^5,</span></p>

    <p class="text-gray-300">along with a ciphertext  <span class="math">\\psi</span> , do the following.</p>

    <p class="text-gray-300">D1: Parse  <span class="math">\\psi</span>  as a 3-tuple  <span class="math">(a, \\hat{a}, d) \\in \\hat{G}^3</span> ; output reject and halt if  <span class="math">\\psi</span>  is not of this form. D2: Test if  <span class="math">a</span>  and  <span class="math">\\hat{a}</span>  belong to  <span class="math">G</span> ; output reject and halt if this is not the case. D3: Compute  <span class="math">v \\gets \\mathsf{HF}_{\\mathsf{hk}}^{\\lambda, \\Gamma}(a, \\hat{a})</span> . D4: Test if  <span class="math">d = a^{x_1 + y_1v}\\hat{a}^{x_2 + y_2v}</span> ; output reject and halt if this is not the case. D5': Compute  <span class="math">b \\gets a^z</span> . D6: Compute  <span class="math">K \\gets \\mathsf{KDF}_{\\mathsf{dk}}^{\\lambda, \\Gamma}(a, b)</span> , and output the symmetric key  <span class="math">K</span> .</p>

    <p class="text-gray-300">Figure 6: Key generation and decryption algorithms for CS3a</p>

    <p class="text-gray-300">Key Generation: On input  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , compute</p>

    <p class="text-gray-300"><span class="math">\\Gamma[\\hat{G}, G, g, q] \\stackrel{n}{\\leftarrow} \\hat{S}(1^{\\lambda})</span> ;  <span class="math">\\mathsf{hk} \\stackrel{n}{\\leftarrow} \\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda, \\Gamma}</span> ;  <span class="math">\\mathsf{dk} \\stackrel{n}{\\leftarrow} \\mathsf{KDF}.\\mathsf{KeySpace}_{\\lambda, \\Gamma}</span> ;</p>

    <p class="text-gray-300"><span class="math">w\\stackrel {n}{\\leftarrow}\\mathbf{Z}_q^z;x,y,z\\stackrel {n}{\\leftarrow}\\mathbf{Z}_q;</span></p>

    <p class="text-gray-300"><span class="math">\\hat{g}\\gets g^{w};e\\gets g^{x};f\\gets g^{y};h\\gets g^{z};</span></p>

    <p class="text-gray-300">and output the public key  <span class="math">\\mathsf{PK} = (\\Gamma ,\\mathsf{hk},\\mathsf{dk},\\hat{g},e,f,h)</span>  and the secret key  <span class="math">\\mathsf{SK} = (\\Gamma ,\\mathsf{hk},\\mathsf{dk},x,y,z)</span> .</p>

    <p class="text-gray-300">Decryption: Given  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , a secret key</p>

    <p class="text-gray-300"><span class="math">\\mathsf{SK} = (\\Gamma [\\hat{G},G,g,q],\\mathsf{hk},\\mathsf{dk},x,y,z)\\in [\\mathbf{S}_{\\lambda}]\\times [\\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda ,\\Gamma}]\\times [\\mathsf{KDF}.\\mathsf{KeySpace}_{\\lambda ,\\Gamma}]\\times \\mathbf{Z}_q^3,</span></p>

    <p class="text-gray-300">along with a ciphertext  <span class="math">\\psi</span> , do the following.</p>

    <p class="text-gray-300">D1: Parse  <span class="math">\\psi</span>  as a 3-tuple  <span class="math">(a, \\hat{a}, d) \\in \\hat{G}^3</span> ; output reject and halt if  <span class="math">\\psi</span>  is not of this form. D2': Test if  <span class="math">a</span>  belongs to  <span class="math">G</span> ; output reject and halt if this is not the case. D3: Compute  <span class="math">v \\gets \\mathsf{HF}_{\\mathsf{hk}}^{\\lambda, \\Gamma}(a, \\hat{a})</span> . D4': Test if  <span class="math">\\hat{a} = a^w</span>  and  <span class="math">d = a^{x + yv}</span> ; output reject and halt if this is not the case. D5': Compute  <span class="math">b \\gets a^z</span> . D6: Compute  <span class="math">K \\gets \\mathsf{KDF}_{\\mathsf{dk}}^{\\lambda, \\Gamma}(a, b)</span> , and output the symmetric key  <span class="math">K</span> .</p>

    <p class="text-gray-300">Figure 7: Key generation and decryption algorithms for CS3b</p>

    <p class="text-gray-300">9.3 Two variations</p>

    <p class="text-gray-300">One can easily modify scheme CS3 to obtain two variants, which we call CS3a and CS3b, that are analogous to the variations CS1a and CS1b of CS1, discussed in §6.3. Only the key generation and decryption algorithms differ. The details are are presented in Figures 6 and 7.</p>

    <h6 id="sec-88" class="text-base font-medium mt-4">Remark 14</h6>

    <p class="text-gray-300">Scheme CS3b is essentially the same scheme that was originally presented in <em>[x20]</em>. This scheme is the most efficient scheme among all those presented in this paper. It is also attractive in that it yields a public-key encryption scheme with an unrestricted message space. Moreover, this scheme has some other attractive security properties that will be examined in §10.</p>

    <h6 id="sec-89" class="text-base font-medium mt-4">Remark 15</h6>

    <p class="text-gray-300">Analogous to Remark 7, we do not have to separately test if <span class="math">\\hat{a}</span> belongs to the subgroup <span class="math">G</span> in step D2^{′} of the decryption algorithm of CS3b, and we may test if <span class="math">a</span> belongs to <span class="math">G</span> in some cases by testing if <span class="math">a^{q}=1_{G}</span>.</p>

    <h6 id="sec-90" class="text-base font-medium mt-4">Remark 16</h6>

    <p class="text-gray-300">Analogous to Remark 8, in scheme CS3b, the decryption algorithm has to compute either three or four (if we test if <span class="math">a^{q}=1_{G}</span>) powers of <span class="math">a</span>, and special algorithmic techniques can be exploited to do this.</p>

    <h6 id="sec-91" class="text-base font-medium mt-4">Remark 17</h6>

    <p class="text-gray-300">Analogous to Remarks 9 and 10, it is strongly recommended to always compute both exponentiations in step D4^{′} of CS3b before rejecting the ciphertext, and to not reveal the precise reason why any ciphertext was rejected.</p>

    <p class="text-gray-300">The following theorem can proved using an argument almost identical to the argument that was used to prove Theorem 2. We leave it to the reader to verify this.</p>

    <h6 id="sec-92" class="text-base font-medium mt-4">Theorem 7</h6>

    <p class="text-gray-300">If the DDH assumption holds for <span class="math">\\mathcal{G}</span> and the TCR assumption holds for HF, and assuming that KDF is a secure key derivation scheme, then CS3a and CS3b are secure against adaptive chosen ciphertext attack.</p>

    <p class="text-gray-300">In particular, for all probabilistic, polynomial-time oracle query machines <span class="math">\\mathsf{A}</span>, for all <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span>, and all <span class="math">\\Gamma[\\hat{G},G,g,q]\\in[\\mathbf{S}_{\\lambda}]</span>, we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{AdvCCA}_{\\mathsf{CS3a,A}}(\\lambda\\mid\\Gamma)-\\mathsf{AdvCCA}_{\\mathsf{CS3,A}}(\\lambda\\mid\\Gamma)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq Q_{\\mathsf{A}}(\\lambda)/q$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{AdvCCA}_{\\mathsf{CS3b,A}}(\\lambda\\mid\\Gamma)-\\mathsf{AdvCCA}_{\\mathsf{CS3,A}}(\\lambda\\mid\\Gamma)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq Q_{\\mathsf{A}}(\\lambda)/q$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-93" class="text-2xl font-bold">10 Further Security Considerations of Scheme CS3b</h2>

    <p class="text-gray-300">The key encapsulation mechanism CS3b, which was described and analyzed in §9.3, has some other interesting security properties, which we discuss in this section.</p>

    <p class="text-gray-300">The main results we present here are the following. First, we show that CS3b is no less secure than a more traditional key encapsulation mechanism that is a hashed variant of ElGamal encryption, which we call HEG. Second, we also show that CS3b is secure in the random oracle model (viewing KDF as a random oracle) if the CDH and TCR assumptions hold. Along the way, we also give a security analysis of HEG in the random oracle model, based on a rather non-standard intractability assumption.</p>

    <p class="text-gray-300">10.1 Hashed ElGamal key encapsulation</p>

    <p class="text-gray-300">We begin by presenting a fairly traditional version of ElGamal key encapsulation, which we call HEG.</p>

    <p class="text-gray-300">The scheme makes use of a computational group scheme <span class="math">\\mathcal{G}</span> as described in §4.1, defining a sequence <span class="math">(\\mathbf{S}_{\\lambda})_{\\lambda\\in\\mathbf{Z}_{\\geq 0}}</span> of distributions of group descriptions, and providing a sampling algorithm <span class="math">\\hat{S}</span>, where the output distribution <span class="math">\\hat{S}(\\mathbf{1}^{\\lambda})</span> closely approximates <span class="math">\\mathbf{S}_{\\lambda}</span>.</p>

    <p class="text-gray-300">Also, the scheme makes use of a key derivation scheme KDF, associated with <span class="math">\\mathcal{G}</span>, as described in §8. Note that output key length <span class="math">\\mathsf{EG.KeyLen}(\\lambda)</span> of the scheme is equal to KDF.OutLen<span class="math">(\\lambda)</span>.</p>

    <p class="text-gray-300">The scheme is described in detail in Figure 8.</p>

    <h3 id="sec-94" class="text-xl font-semibold mt-8">10.2 The random oracle model</h3>

    <p class="text-gray-300">We will analyze the security of both schemes HEG and CS3b in the random oracle model. In this approach, a cryptographic hash function — in this case KDF — is modeled for the purposes of analysis as a “black box” containing a random function to which the adversary and the algorithms implementing the cryptosystem have “oracle access.” This approach has been used implicitly and informally for some time; however, it was formalized by Bellare and Rogaway <em>[x1]</em>, and has subsequently been used quite a bit in the cryptographic research community.</p>

    <p class="text-gray-300">More precisely, we shall analyze the security the scheme HEG and later CS3b in an idealized model of computation where for all <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span>, all <span class="math">\\Gamma[\\hat{G},G,g,q]\\in[\\mathbf{S}_{\\lambda}]</span>, all <span class="math">\\mathsf{dk}\\in[\\mathsf{KDF.KeySpace}_{\\lambda,\\Gamma}]</span>, and all <span class="math">a,b\\in G</span>, we treat the values <span class="math">\\mathsf{KDF}^{\\lambda,\\Gamma}_{\\mathsf{dk}}(a,b)</span> as mutually independent, random bit strings of length <span class="math">\\mathsf{KDF.OutLen}(\\lambda)</span>; moreover, the only way to obtain the value of <span class="math">\\mathsf{KDF}^{\\lambda,\\Gamma}_{\\mathsf{dk}}(a,b)</span> to to explicitly query an oracle with input <span class="math">(\\lambda,\\Gamma,\\mathsf{dk},a,b)</span>. Actually, to be complete, we allow <span class="math">\\Gamma</span>, <span class="math">\\mathsf{dk}</span>, <span class="math">a</span>, and <span class="math">b</span> to range over arbitrary bit strings, regardless of whether these are valid encodings of appropriate objects. Since in any of our applications, only a finite number of the values <span class="math">\\mathsf{KDF}^{\\lambda,\\Gamma}_{\\mathsf{dk}}(a,b)</span> will be relevant, experiments based on these values can be modeled using finite probability spaces.</p>

    <p class="text-gray-300">When considering an adversary <span class="math">\\mathsf{A}</span> that is carrying out an adaptive chosen ciphertext attack in the random oracle model, in addition to the usual types of oracle queries that <span class="math">\\mathsf{A}</span> makes, the adversary <span class="math">\\mathsf{A}</span> is also allowed to query the random oracle representing KDF. We shall denote by <span class="math">Q^{\\prime}_{\\mathsf{A}}(\\lambda)</span> a strict upper bound on the number of random oracle queries that <span class="math">\\mathsf{A}</span> makes for a given value of the security parameter <span class="math">\\lambda</span>; as usual, this bound should hold regardless of the environment in which <span class="math">\\mathsf{A}</span> actually runs.</p>

    <h3 id="sec-95" class="text-xl font-semibold mt-8">10.3 CS3b is at least as secure as HEG</h3>

    <p class="text-gray-300">We now show that the scheme CS3b is at least as secure as HEG.</p>

    <h6 id="sec-96" class="text-base font-medium mt-4">Theorem 8</h6>

    <p class="text-gray-300">If scheme HEG is secure against adaptive chosen ciphertext attack, then so is CS3b; moreover, this implication holds in either the standard or random oracle models.</p>

    <p class="text-gray-300">In particular, for all probabilistic, polynomial-time oracle query machines <span class="math">\\mathsf{A}</span>, there exists another oracle query machine <span class="math">\\mathsf{A}_{1}</span>, whose running time is essentially the same as that of <span class="math">\\mathsf{A}</span>, such that for all <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span>, and all <span class="math">\\Gamma[\\hat{G},G,g,q]\\in[\\mathbf{S}_{\\lambda}]</span>, we have</p>

    <p class="text-gray-300"><span class="math">\\mathsf{AdvCCA}_{\\mathsf{CS3b,A}}(\\lambda\\mid\\Gamma)\\leq\\mathsf{AdvCCA}_{\\mathsf{HEG,A}_{1}}(\\lambda\\mid\\Gamma);</span></p>

    <p class="text-gray-300">moreover, <span class="math">Q_{\\mathsf{A}_{1}}(\\lambda)\\leq Q_{\\mathsf{A}}(\\lambda)</span> and (in the random oracle model) <span class="math">Q^{\\prime}_{\\mathsf{A}_{1}}(\\lambda)\\leq Q^{\\prime}_{\\mathsf{A}}(\\lambda)</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Key Generation: On input  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , compute</p>

    <p class="text-gray-300"><span class="math">\\Gamma[\\hat{G}, G, g, q] \\stackrel{\\mu}{\\leftarrow} \\hat{S}(1^{\\lambda}); \\mathsf{dk} \\stackrel{\\mu}{\\leftarrow} \\mathsf{KDF}.\\mathsf{KeySpace}_{\\lambda, \\Gamma}; z \\stackrel{\\mu}{\\leftarrow} \\mathbf{Z}_q; h \\gets g^z;</span></p>

    <p class="text-gray-300">and output the public key  <span class="math">\\mathsf{PK} = (\\Gamma, \\mathsf{dk}, h)</span>  and the secret key  <span class="math">\\mathsf{SK} = (\\Gamma, \\mathsf{dk}, z)</span> .</p>

    <p class="text-gray-300">Encryption: Given  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , a public key</p>

    <p class="text-gray-300"><span class="math">\\mathsf{PK} = (\\Gamma [\\hat{G},G,g,q],\\mathsf{dk},h)\\in [\\mathbf{S}_{\\lambda}]\\times [\\mathsf{KDF}.\\mathsf{KeySpace}_{\\lambda ,\\Gamma}]\\times G,</span></p>

    <p class="text-gray-300">compute</p>

    <p class="text-gray-300">E1:  <span class="math">u \\stackrel{\\mu}{\\leftarrow} \\mathbf{Z}_q</span> ; E2:  <span class="math">a \\gets g^u</span> ; E3:  <span class="math">b \\gets h^u</span> ; E4:  <span class="math">K \\gets \\mathsf{KDF}_{\\mathsf{dk}}^{\\lambda, \\Gamma}(a, b)</span> ;</p>

    <p class="text-gray-300">and output the symmetric key  <span class="math">K</span>  and the ciphertext  <span class="math">\\psi = a</span> .</p>

    <p class="text-gray-300">Decryption: Given  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , a secret key</p>

    <p class="text-gray-300"><span class="math">\\mathsf{SK} = (\\Gamma [\\hat{G},G,g,q],\\mathsf{dk},z)\\in [\\mathbf{S}_{\\lambda}]\\times [\\mathsf{KDF}.\\mathsf{KeySpace}_{\\lambda ,\\Gamma}]\\times \\mathbf{Z}_q,</span></p>

    <p class="text-gray-300">along with a ciphertext  <span class="math">\\psi</span> , do the following.</p>

    <p class="text-gray-300">D1: Parse  <span class="math">\\psi</span>  as a group element  <span class="math">a\\in \\hat{G}</span> ; output reject and halt if  <span class="math">\\psi</span>  is not of this form. D2: Test if  <span class="math">a</span>  belongs to  <span class="math">G</span> ; output reject and halt if this is not the case. D3: Compute  <span class="math">b \\gets a^z</span> . D4: Compute  <span class="math">K \\gets \\mathsf{KDF}_{\\mathsf{dk}}^{\\lambda, \\Gamma}(a, b)</span> , and output the symmetric key  <span class="math">K</span> .</p>

    <p class="text-gray-300">Figure 8: The key encapsulation mechanism HEG</p>

    <h6 id="sec-97" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Fix <span class="math">\\mathsf{A}</span>, <span class="math">\\lambda</span>, and <span class="math">\\Gamma[\\hat{G},G,g,q]</span> as above. We construct an adversary <span class="math">\\mathsf{A}_{1}</span> that attacks <span class="math">\\mathsf{HEG}</span>. The adversary <span class="math">\\mathsf{A}_{1}</span> makes use of <span class="math">\\mathsf{A}</span> by providing an environment for <span class="math">\\mathsf{A}</span>, as follows.</p>

    <p class="text-gray-300">First, suppose that <span class="math">\\mathsf{A}_{1}</span> is given a public key <span class="math">(\\Gamma,\\mathsf{dk},h)</span> for scheme <span class="math">\\mathsf{HEG}</span>, where <span class="math">\\Gamma</span> is fixed as above. Adversary <span class="math">\\mathsf{A}_{1}</span> then “dresses up” the <span class="math">\\mathsf{HEG}</span> public key to look like a <span class="math">\\mathsf{CS3b}</span> public key; namely, <span class="math">\\mathsf{A}_{1}</span> computes</p>

    <p class="text-gray-300"><span class="math">\\mathsf{hk}\\xleftarrow{R}\\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda,\\Gamma};\\;w\\xleftarrow{R}\\mathbf{Z}_{q}^{*};\\;x,y\\xleftarrow{R}\\mathbf{Z}_{q};\\;\\hat{g}\\leftarrow g^{w};\\;e\\leftarrow g^{x};\\;f\\leftarrow g^{y};</span></p>

    <p class="text-gray-300">and presents <span class="math">\\mathsf{A}</span> with the <span class="math">\\mathsf{CS3b}</span> public key</p>

    <p class="text-gray-300"><span class="math">(\\Gamma,\\mathsf{hk},\\mathsf{dk},\\hat{g},e,f,h).</span></p>

    <p class="text-gray-300">Second, whenever <span class="math">\\mathsf{A}</span> submits a <span class="math">\\mathsf{CS3b}</span> ciphertext <span class="math">(a,\\hat{a},d)\\in\\hat{G}^{3}</span> to the decryption oracle, adversary <span class="math">\\mathsf{A}_{1}</span> first performs the validity tests of the decryption algorithm of <span class="math">\\mathsf{CS3b}</span>, making use of the values <span class="math">\\mathsf{hk},w,x,y</span> generated above; if these tests pass, then <span class="math">\\mathsf{A}_{1}</span> invokes the decryption oracle of <span class="math">\\mathsf{HEG}</span> with input <span class="math">a</span>.</p>

    <p class="text-gray-300">Third, when <span class="math">\\mathsf{A}</span> invokes the encryption oracle of <span class="math">\\mathsf{CS3b}</span>, adversary <span class="math">\\mathsf{A}_{1}</span> does the following. It invokes the encryption oracle of <span class="math">\\mathsf{HEG}</span>, obtaining a ciphertext <span class="math">a^{<em>}\\in G</span> and a key <span class="math">K^{\\dagger}</span>. It then “dresses up” <span class="math">a^{</em>}</span> to look like a <span class="math">\\mathsf{CS3b}</span> ciphertext; namely, it computes</p>

    <p class="text-gray-300"><span class="math">\\hat{a}^{<em>}\\leftarrow(a^{</em>})^{w};\\;v^{<em>}\\leftarrow\\mathsf{HF}_{\\mathsf{hk}}^{\\lambda,\\Gamma}(a^{</em>},\\hat{a}^{<em>});\\;d^{</em>}\\leftarrow(a^{<em>})^{x+yv^{</em>}};</span></p>

    <p class="text-gray-300">and presents <span class="math">\\mathsf{A}</span> with the <span class="math">\\mathsf{CS3b}</span> ciphertext <span class="math">(a^{<em>},\\hat{a}^{</em>},d^{*})</span> along with the key <span class="math">K^{\\dagger}</span>.</p>

    <p class="text-gray-300">Fourth, when <span class="math">\\mathsf{A}</span> terminates and outputs a value, <span class="math">\\mathsf{A}_{1}</span> also terminates and outputs the same value.</p>

    <p class="text-gray-300">That completes the description of the adversary <span class="math">\\mathsf{A}_{1}</span>.</p>

    <p class="text-gray-300">One has to check that <span class="math">\\mathsf{A}_{1}</span> carries out a legal adaptive chosen ciphertext attack, in the sense that it should not attempt to submit the target ciphertext itself to the decryption oracle, subsequent to the invocation of the encryption oracle. Consider a ciphertext <span class="math">a</span> submitted by <span class="math">\\mathsf{A}_{1}</span> to the decryption oracle. This was derived from a valid <span class="math">\\mathsf{CS3b}</span> ciphertext <span class="math">(a,\\hat{a},d)</span> submitted by <span class="math">\\mathsf{A}</span> to the decryption oracle. By the construction, it is easy to see that if <span class="math">a=a^{<em>}</span>, then in fact, <span class="math">(a,\\hat{a},d)=(a^{</em>},\\hat{a}^{<em>},d^{</em>})</span>, which cannot happen if <span class="math">\\mathsf{A}</span> itself carries out a legal attack.</p>

    <p class="text-gray-300">Since the simulation by <span class="math">\\mathsf{A}_{1}</span> above is perfect, it is clear that whatever advantage <span class="math">\\mathsf{A}</span> has in guessing the hidden bit, adversary <span class="math">\\mathsf{A}_{1}</span> has precisely the same advantage. It is also clear by construction that <span class="math">Q_{\\mathsf{A}_{1}}(\\lambda)\\leq Q_{\\mathsf{A}}(\\lambda)</span>, and in the random oracle model that <span class="math">Q^{\\prime}_{\\mathsf{A}_{1}}(\\lambda)\\leq Q^{\\prime}_{\\mathsf{A}}(\\lambda)</span>. ∎</p>

    <h3 id="sec-98" class="text-xl font-semibold mt-8">10.4 The security of <span class="math">\\mathsf{HEG}</span> in the random oracle model</h3>

    <p class="text-gray-300">As for the security of <span class="math">\\mathsf{HEG}</span>, even in the random oracle model, we do not know how to prove a very strong result. We content ourselves with a proof that the scheme <span class="math">\\mathsf{HEG}</span> is secure against adaptive chosen ciphertext attack in the random oracle model, provided the CDH assumption holds <em>relative to an oracle for the DDH problem</em>.</p>

    <p class="text-gray-300">More precisely, for all probabilistic, polynomial-time oracle query machines <span class="math">\\mathsf{A}</span>, and for all <span class="math">\\lambda\\in\\mathbf{Z}_{\\geq 0}</span>, we define</p>

    <p class="text-gray-300"><span class="math">\\mathsf{AdvCDH}^{*}_{\\mathcal{G},\\mathsf{A}}(\\lambda)\\mathop{:}=\\Pr[\\;c=g^{xy}:\\Gamma[\\hat{G},G,g,q]\\xleftarrow{R}\\mathbf{S}_{\\lambda};\\;x\\xleftarrow{R}\\mathbf{Z}_{q};\\;y\\xleftarrow{R}\\mathbf{Z}_{q};\\;c\\xleftarrow{R}\\mathsf{A}^{\\mathsf{DHP}_{\\lambda,\\Gamma}}(\\mathbf{1}^{\\lambda},\\Gamma,g^{x},g^{y})\\;],</span></p>

    <p class="text-gray-300">where the notation <span class="math">\\mathsf{A}^{\\mathsf{DHP}_{\\lambda,\\Gamma}}(\\cdots)</span> signifies that <span class="math">\\mathsf{A}</span> runs with access to an oracle for the Diffie-Hellman predicate <span class="math">\\mathsf{DHP}_{\\lambda,\\Gamma}</span> defined in §4.3.3.</p>

    <p class="text-gray-300">We say that the CDH assumption for <span class="math">\\mathcal{G}</span> holds relative to an oracle for the DDH problem if:</p>

    <p class="text-gray-300">for all probabilistic, polynomial-time oracle query machines <span class="math">\\mathsf{A}</span>, the function <span class="math">\\mathsf{AdvCDH}_{\\mathcal{G},\\mathsf{A}}^{*}(\\lambda)</span> is negligible in <span class="math">\\lambda</span>.</p>

    <p class="text-gray-300">For all probabilistic, polynomial-time oracle query machines <span class="math">\\mathsf{A}</span>, for all <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>, and for all <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span>, we also define</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{AdvCDH}_{\\mathcal{G},\\mathsf{A}}^{*}(\\lambda \\mid \\Gamma) := \\Pr[ c = g^{xy} : x \\stackrel{\\scriptscriptstyle B}{\\leftarrow} \\mathbf{Z}_{q}; y \\stackrel{\\scriptscriptstyle B}{\\leftarrow} \\mathbf{Z}_{q}; c \\stackrel{\\scriptscriptstyle B}{\\leftarrow} \\mathsf{A}^{\\mathsf{DHP}_{\\lambda,\\Gamma}} \\left(1^{\\lambda}, \\Gamma, g^{x}, g^{y}\\right) ].</span></div>

    <p class="text-gray-300"><strong>Theorem 9</strong> The scheme HEG is secure in the random oracle model if the CDH assumption for <span class="math">\\mathcal{G}</span> holds relative to an oracle for the DDH problem.</p>

    <p class="text-gray-300">In particular, for all probabilistic, polynomial-time oracle query machines <span class="math">\\mathsf{A}</span>, there exists an oracle query machine <span class="math">\\mathsf{A}_1</span>, whose running time is essentially the same as that of <span class="math">\\mathsf{A}</span>, such that for all <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>, and for all <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span>, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{AdvCCA}_{\\mathsf{HEG},\\mathsf{A}}(\\lambda \\mid \\Gamma) \\leq \\mathsf{AdvCDH}_{\\mathcal{G},\\mathsf{A}_{1}}^{*}(\\lambda \\mid \\Gamma) + Q_{\\mathsf{A}}(\\lambda)/q;</span></div>

    <p class="text-gray-300">moreover, the number or DDH-oracle queries made by <span class="math">\\mathsf{A}_1</span> is bounded by <span class="math">Q_{\\mathsf{A}}&#x27;(\\lambda)</span>.</p>

    <p class="text-gray-300">To prove Theorem 9, let us fix <span class="math">\\mathsf{A}</span>, <span class="math">\\lambda</span>, and <span class="math">\\Gamma[\\hat{G}, G, g, q]</span>. The attack game is as described in §7.1.2.</p>

    <p class="text-gray-300">We begin by describing the relevant random variables in the attack game. The public key is <span class="math">(\\Gamma, \\mathsf{dk}, h)</span> and the secret key is <span class="math">(\\Gamma, \\mathsf{dk}, z)</span>.</p>

    <p class="text-gray-300">For a given ciphertext <span class="math">\\psi</span>, we let <span class="math">a \\in G</span> denote the corresponding group element, we let <span class="math">b := a^z</span>, <span class="math">u := \\log_g a</span>, and <span class="math">K := \\mathsf{KDF}_{\\mathsf{dk}}^{\\lambda, \\Gamma}(a, b)</span>. Note also that <span class="math">b = a^u</span>. For the target ciphertext <span class="math">\\psi^<em></span>, we let <span class="math">a^</em></span>, <span class="math">b^<em></span>, <span class="math">u^</em></span>, and <span class="math">K^*</span> denote the corresponding values.</p>

    <p class="text-gray-300">The encryption oracle also generates values <span class="math">\\tau \\in \\{0,1\\}</span> and <span class="math">K^{+} \\in \\{0,1\\}^{\\mathsf{KDF.OutLen}(\\lambda)}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbf{G}_0</span> be the original attack game, let <span class="math">\\hat{\\tau}</span> denote the output of <span class="math">\\mathsf{A}</span>, and let <span class="math">T_0</span> be the event that <span class="math">\\tau = \\hat{\\tau}</span>, so that $\\mathsf{AdvCCA}_{\\mathsf{HEG},\\mathsf{A}}(\\lambda \\mid \\Gamma) =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[T_0] - 1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As usual, we define a sequence of game <span class="math">\\mathbf{G}_1</span>, <span class="math">\\mathbf{G}_2</span>, etc., and in game <span class="math">\\mathbf{G}_i</span> for <span class="math">i \\geq 1</span> we define <span class="math">T_i</span> to be the event in game <span class="math">\\mathbf{G}_i</span> corresponding to event <span class="math">T_0</span> in game <span class="math">\\mathbf{G}_0</span>.</p>

    <p class="text-gray-300"><strong>Game <span class="math">\\mathbf{G}_1</span></strong>. We modify game <span class="math">\\mathbf{G}_0</span> as follows. First, we run the encryption oracle at the beginning of the attack game, but we give the results of this to the adversary only when it actually invokes the encryption oracle. This is a purely conceptual change, since the adversary provides no input to the encryption oracle. Second, if the adversary ever submits a ciphertext <span class="math">\\psi = \\psi^*</span> to the decryption oracle before the encryption algorithm is invoked, we abort the game immediately, before responding to this decryption oracle invocation (the environment, say, goes silent at this point).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">F_1</span> be the event that game <span class="math">\\mathbf{G}_1</span> is aborted as above. It is clear that <span class="math">\\operatorname*{Pr}[F_1] \\leq Q_{\\mathsf{A}}(\\lambda)/q</span>. It is also clear that games <span class="math">\\mathbf{G}_0</span> and <span class="math">\\mathbf{G}_1</span> proceed identically until event <span class="math">F_1</span> occurs, and so by Lemma 4, we have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname<em>{Pr}[T_1] - \\operatorname</em>{Pr}[T_0]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\operatorname*{Pr}[F_1]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Game <span class="math">\\mathbf{G}_2</span></strong>. We next modify game <span class="math">\\mathbf{G}_1</span> as follows. If the adversary every queries the random oracle to obtain the value of <span class="math">\\mathsf{KDF}_{\\mathsf{dk}}^{\\lambda, \\Gamma}(a^<em>, b^</em>)</span>, we immediately abort the game, before responding to this random oracle invocation.</p>

    <p class="text-gray-300">It is easy to see that <span class="math">\\operatorname<em>{Pr}[T_2] = 1/2</span>. This follows directly from the fact that in game <span class="math">\\mathbf{G}_2</span>, the value of <span class="math">\\mathsf{KDF}_{\\mathsf{dk}}^{\\lambda, \\Gamma}(a^</em>, b^*)</span> is obtained from the random oracle only by the encryption oracle: the adversary never queries the random oracle directly at this point, nor does the decryption oracle.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">F_2</span> be the event that game <span class="math">\\mathbf{G}_2</span> is aborted as above. It is clear that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname<em>{Pr}[T_2] - \\operatorname</em>{Pr}[T_1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\operatorname<em>{Pr}[F_2]<span class="math">, so it suffices to bound </span>\\operatorname</em>{Pr}[F_2]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We claim that <span class="math">\\operatorname<em>{Pr}[F_2] = \\mathsf{AdvCDH}_{\\mathcal{G},\\mathsf{A}_1}^</em>(\\lambda \\mid \\Gamma)</span> for an oracle query machine <span class="math">\\mathsf{A}_1</span> whose running time and number of oracle queries are bounded as in the statement of the theorem.</p>

    <p class="text-gray-300">54</p>

    <p class="text-gray-300">We now describe <span class="math">\\mathsf{A}_1</span>. It takes as input <span class="math">\\mathbf{1}^{\\lambda}</span>, <span class="math">\\Gamma[\\hat{G}, G, g, q]</span>, along with group elements <span class="math">a^<em>, h \\in G</span>, and attempts to compute <span class="math">b^</em> \\in G</span> such that <span class="math">\\mathsf{DHP}_{\\lambda, \\Gamma}(h, a^<em>, b^</em>) = 1</span>. The machine <span class="math">\\mathsf{A}_1</span> has access to an oracle for the function <span class="math">\\mathsf{DHP}_{\\lambda, \\Gamma}</span>.</p>

    <p class="text-gray-300">Machine <span class="math">\\mathsf{A}_1</span> simulates the environment of game <span class="math">\\mathbf{G}_2</span> for <span class="math">\\mathsf{A}</span> as follows. It first computes <span class="math">\\mathsf{dk} \\stackrel{R}{\\leftarrow} \\mathsf{KDF.KeySpace}_{\\lambda, \\Gamma}</span> and gives <span class="math">\\mathsf{A}</span> the public key <span class="math">(\\Gamma, \\mathsf{dk}, h)</span>. For the target ciphertext, it of course sets <span class="math">\\psi^<em> := a^</em></span>. For the other output <span class="math">K^\\dagger</span> of the encryption oracle, <span class="math">\\mathsf{A}_1</span> simply generates this as a random bit string of length <span class="math">\\mathsf{KDF.OutLen}(\\lambda)</span>.</p>

    <p class="text-gray-300">Machine <span class="math">\\mathsf{A}_1</span> also needs to simulate the responses to the random oracle and decryption oracle queries. For the random oracle queries, the only values that are relevant are those corresponding to the given values of <span class="math">\\lambda</span>, <span class="math">\\Gamma</span>, and <span class="math">\\mathsf{dk}</span>.</p>

    <p class="text-gray-300">For the irrelevant random oracle queries, <span class="math">\\mathsf{A}_1</span> simply maintains a set of input/output pairs, generating outputs at random as necessary.</p>

    <p class="text-gray-300">Machine <span class="math">\\mathsf{A}_1</span> processes relevant random oracle queries using the following data structures:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a set <span class="math">\\mathcal{V}_1</span> of triples <span class="math">(a, b, K)</span>, with <span class="math">a, b \\in G</span> and <span class="math">K \\in \\{0, 1\\}^{\\mathsf{KDF.OutLen}(\\lambda)}</span>, initially empty; this will contain those triples <span class="math">(a, b, K)</span> for which <span class="math">\\mathsf{A}_1</span> has assigned the value <span class="math">K</span> to <span class="math">\\mathsf{KDF}_{\\mathsf{dk}}^{\\lambda, \\Gamma}(a, b)</span>;</li>

      <li>a set <span class="math">\\mathcal{V}_2</span> of pairs <span class="math">(a, b)</span>, with <span class="math">a, b \\in G</span>, initially empty; this will contain precisely those pairs <span class="math">(a, b)</span> such that <span class="math">(a, b, K) \\in \\mathcal{V}_1</span> for some <span class="math">K</span>, and <span class="math">\\mathsf{DHP}_{\\lambda, \\Gamma}(h, a, b) = 1</span>;</li>

      <li>a set <span class="math">\\mathcal{V}_3</span> of pairs <span class="math">(a, K)</span>, with <span class="math">a \\in G</span> and <span class="math">K \\in \\{0, 1\\}^{\\mathsf{KDF.OutLen}(\\lambda)}</span>, initially empty; this will contain pairs <span class="math">(a, K)</span> for which <span class="math">\\mathsf{A}_1</span> has assigned the value <span class="math">K</span> to <span class="math">\\mathsf{KDF}_{\\mathsf{dk}}^{\\lambda, \\Gamma}(a, b)</span> for <span class="math">b \\in G</span> with <span class="math">\\mathsf{DHP}_{\\lambda, \\Gamma}(h, a, b) = 1</span>, even though <span class="math">\\mathsf{A}_1</span> does not actually know the value of <span class="math">b</span>.</li>

    </ul>

    <p class="text-gray-300">Given a request for the value <span class="math">\\mathsf{KDF}_{\\mathsf{dk}}^{\\lambda, \\Gamma}(a, b)</span>, machine <span class="math">\\mathsf{A}_1</span> does the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>It tests if <span class="math">(a, b, K) \\in \\mathcal{V}_1</span> for some <span class="math">K</span>. If so (which means that <span class="math">\\mathsf{A}</span> has queried the value <span class="math">\\mathsf{KDF}_{\\mathsf{dk}}^{\\lambda, \\Gamma}(a, b)</span> before), it returns <span class="math">K</span> as the value of <span class="math">\\mathsf{KDF}_{\\mathsf{dk}}^{\\lambda, \\Gamma}(a, b)</span>; otherwise, it continues.</li>

      <li>It invokes its own DDH-oracle to determine if <span class="math">\\mathsf{DHP}_{\\lambda, \\Gamma}(h, a, b) = 1</span>.</li>

      <li>If <span class="math">\\mathsf{DHP}_{\\lambda, \\Gamma}(h, a, b) = 1</span>, then:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">a = a^<em></span>, it halts and outputs the solution <span class="math">b^</em> := b</span> to the given problem instance (this corresponds to the early-abort rule introduced in game <span class="math">\\mathbf{G}_2</span>); otherwise, it continues.</li>

      <li>It adds the pair <span class="math">(a, b)</span> to the set <span class="math">\\mathcal{V}_2</span>.</li>

      <li>If <span class="math">(a, K) \\in \\mathcal{V}_3</span> for some <span class="math">K</span>, then it adds the triple <span class="math">(a, b, K)</span> to <span class="math">\\mathcal{V}_1</span>, and returns <span class="math">K</span> as the value of <span class="math">\\mathsf{KDF}_{\\mathsf{dk}}^{\\lambda, \\Gamma}(a, b)</span>; otherwise, it continues.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>It generates <span class="math">K</span> as a random bit string of length <span class="math">\\mathsf{KDF.OutLen}(\\lambda)</span>, adds the triple <span class="math">(a, b, K)</span> to <span class="math">\\mathcal{V}_1</span>, and returns <span class="math">K</span> as the value of <span class="math">\\mathsf{KDF}_{\\mathsf{dk}}^{\\lambda, \\Gamma}(a, b)</span>.</li>

    </ul>

    <p class="text-gray-300">Machine <span class="math">\\mathsf{A}_1</span> processes decryption oracle queries as follows. Suppose it is given a ciphertext <span class="math">\\psi</span>, with <span class="math">a \\in G</span> the corresponding group element. Then it does the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\psi = \\psi^{*}</span> (which can only happen if the encryption oracle has not yet been invoked), then it simply halts (this corresponds to the early-abort rule introduced in game <span class="math">\\mathbf{G}_1</span>); otherwise, continues.</li>

      <li>It tests if <span class="math">(a, b) \\in \\mathcal{V}_2</span> for some <span class="math">b \\in G</span>.</li>

    </ul>

    <p class="text-gray-300">55</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If this is so, then it finds the (unique) triple in <span class="math">\\mathcal{V}_{1}</span> of the form <span class="math">(a,b,K)</span> for some <span class="math">K</span>, and returns this value of <span class="math">K</span> as the result of the decryption oracle invocation; otherwise, it continues.</li>

      <li>It tests if <span class="math">(a,K)\\in\\mathcal{V}_{3}</span> for some <span class="math">K</span>.</li>

      <li>If this is so, then it returns this value of <span class="math">K</span> as the result of the decryption oracle; otherwise, it generates a random bit string <span class="math">K</span> of length KDF.OutLen<span class="math">(\\lambda)</span>, adds the pair <span class="math">(a,K)</span> to <span class="math">\\mathcal{V}_{3}</span>, and returns this value of <span class="math">K</span> as the result of the decryption oracle invocation.</li>

    </ul>

    <p class="text-gray-300">It is straightforward to verify by inspection that <span class="math">\\mathsf{A}_{1}</span> as above does the job.</p>

    <p class="text-gray-300">That completes the proof of Theorem 9.</p>

    <h3 id="sec-99" class="text-xl font-semibold mt-8">10.5 The security of CS3b in the random oracle model</h3>

    <p class="text-gray-300">We can now prove the following security theorem for CS3b in the random oracle model.</p>

    <h6 id="sec-100" class="text-base font-medium mt-4">Theorem 10</h6>

    <p class="text-gray-300">The scheme CS3b is secure in the random oracle model if the CDH assumption holds for <span class="math">\\mathcal{G}</span>, and the TCR assumption holds for HF.</p>

    <h6 id="sec-101" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">To prove this, let us assume by way of contradiction that the CDH assumption holds for <span class="math">\\mathcal{G}</span> and the TCR assumption holds for HF, but CS3b is not secure in the random oracle model.</p>

    <p class="text-gray-300">Now, the CDH assumption implies that for any polynomials <span class="math">P_{1}</span> and <span class="math">P_{2}</span> (with integer coefficients, taking positive values on <span class="math">\\mathbf{Z}_{\\geq 0}</span>), there exists a <span class="math">\\lambda_{0}\\in\\mathbf{Z}_{\\geq 0}</span>, such that for all <span class="math">\\lambda\\geq\\lambda_{0}</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr[q\\leq P_{1}(\\lambda):\\Gamma[\\hat{G},G,g,q]\\stackrel{{\\scriptstyle n}}{{\\leftarrow}}\\mathbf{S}_{\\lambda}]\\leq 1/P_{2}(\\lambda),</span></p>

    <p class="text-gray-300">since otherwise, a trivial, brute-force algorithm would have a CDH advantage that was not negligible. This implies in particular that when we model KDF as a random oracle, it acts as a secure key derivation scheme. From this it follows from Theorems 6 and 7 that CS3b is secure in the random oracle model if the DDH assumption holds; actually, since these two theorems do not deal with the random oracle model, one must make a cursory inspection of the proofs of these theorems to draw this conclusion, but this is very straightforward.</p>

    <p class="text-gray-300">Let <span class="math">\\mathsf{A}</span> be a polynomial-time adversary that breaks the security of CS3b in the random oracle model. This means that there exist polynomials <span class="math">P_{1}</span>, <span class="math">P_{2}</span> (with integer coefficients, taking positive values on <span class="math">\\mathbf{Z}_{\\geq 0}</span>), an infinite set <span class="math">\\Lambda\\subset\\mathbf{Z}_{\\geq 0}</span>, and sets <span class="math">\\mathcal{Z}_{\\lambda}\\subset[\\mathbf{S}_{\\lambda}]</span> for each <span class="math">\\lambda\\in\\Lambda</span>, such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for all <span class="math">\\lambda\\in\\Lambda</span> and <span class="math">\\Gamma\\in\\mathcal{Z}_{\\lambda}</span>, <span class="math">\\mathsf{AdvCCA}_{\\mathsf{CS3b},\\mathsf{A}}(\\lambda\\mid\\Gamma)\\geq 1/P_{1}(\\lambda)</span>,</li>

      <li>for all <span class="math">\\lambda\\in\\Lambda</span>, <span class="math">\\Pr_{\\mathbf{S}_{\\lambda}}[\\mathcal{Z}_{\\lambda}]\\geq 1/P_{2}(\\lambda)</span>.</li>

    </ul>

    <p class="text-gray-300">Theorems 6 and 7 (adapted to the random oracle model), together with our TCR assumption, imply that there exists a polynomial-time algorithm <span class="math">\\mathsf{A}_{1}</span>, such that for all sufficiently large <span class="math">\\lambda\\in\\Lambda</span>, and for all but a negligible fraction of <span class="math">\\Gamma</span> in <span class="math">\\mathcal{Z}_{\\lambda}</span>, we have</p>

    <p class="text-gray-300"><span class="math">\\mathsf{AdvDDH}_{\\mathcal{G},\\mathsf{A}_{1}}(\\lambda\\mid\\Gamma)\\geq 1/(2P_{1}(\\lambda)).</span></p>

    <p class="text-gray-300">We now apply Lemma 3 using the above algorithm <span class="math">\\mathsf{A}_{1}</span>, and choosing the value of <span class="math">\\kappa</span> in that lemma so that <span class="math">2^{-\\kappa}\\cdot Q^{\\prime}_{\\mathsf{A}}(\\lambda)\\leq 1/2</span>, yielding a polynomial-time algorithm <span class="math">\\mathsf{A}_{2}</span>, such that for all sufficiently large <span class="math">\\lambda\\in\\Lambda</span>, and for all but a negligible fraction of <span class="math">\\Gamma\\in\\mathcal{Z}_{\\lambda}</span>, and for all <span class="math">\\rho\\in\\mathcal{T}_{\\lambda,\\Gamma}</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\mathsf{A}_{2}(1^{\\lambda},\\Gamma,\\rho)\\neq\\mathsf{DHP}_{\\lambda,\\Gamma}(\\rho)]\\leq 1/(2Q^{\\prime}_{\\mathsf{A}}(\\lambda)).</span></p>

    <p class="text-gray-300">Applying Theorem 8 with the adversary <span class="math">\\mathsf{A}</span> yields a polynomial-time adversary <span class="math">\\mathsf{A}_{3}</span> such that for all <span class="math">\\lambda\\in\\Lambda</span> and <span class="math">\\Gamma\\in\\mathcal{Z}_{\\lambda}</span>, <span class="math">\\mathsf{AdvCCA_{HEG,A_{3}}}(\\lambda\\mid\\Gamma)\\geq 1/P_{1}(\\lambda)</span>. Applying Theorem 9 with the adversary <span class="math">\\mathsf{A}_{3}</span> yields a polynomial-time oracle machine <span class="math">\\mathsf{A}_{4}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{AdvCDH^{*}_{\\mathcal{G},\\mathsf{A}_{4}}}(\\lambda\\mid\\Gamma)\\geq 1/(2P_{1}(\\lambda))</span></p>

    <p class="text-gray-300">for all sufficiently large <span class="math">\\lambda\\in\\Lambda</span>, and for all but a negligible fraction of <span class="math">\\Gamma\\in\\mathcal{Z}_{\\lambda}</span>. Since for a given value of <span class="math">\\lambda</span>, algorithm <span class="math">\\mathsf{A}_{4}</span> makes no more than <span class="math">Q^{\\prime}_{\\mathsf{A}}(\\lambda)</span> DDH-oracle queries, if we replace the DDH-oracle used by <span class="math">\\mathsf{A}_{4}</span> with algorithm <span class="math">\\mathsf{A}_{2}</span> above, we obtain a polynomial-time algorithm <span class="math">\\mathsf{A}_{5}</span> such that for all sufficiently large <span class="math">\\lambda\\in\\Lambda</span>, and for all but a negligible fraction of <span class="math">\\Gamma</span> in <span class="math">\\mathcal{Z}_{\\lambda}</span>, we have <span class="math">\\mathsf{AdvCDH_{\\mathcal{G},\\mathsf{A}_{5}}}(\\lambda\\mid\\Gamma)\\geq 1/(4P_{1}(\\lambda))</span>. But this contradicts the CDH assumption. ∎</p>

    <h3 id="sec-102" class="text-xl font-semibold mt-8">10.6 Random oracles and pair-wise independent key derivation functions: getting the best of both</h3>

    <p class="text-gray-300">If we want to prove the security of <span class="math">\\mathsf{CS3b}</span> in the standard model without making any intractability assumptions about <span class="math">\\mathsf{KDF}</span>, then we may choose <span class="math">\\mathsf{KDF}</span> to be pair-wise independent. On the one hand, standard constructions for pair-wise independent hash functions typically exhibit a lot of algebraic structure, and it is not very reasonable to assume that such a <span class="math">\\mathsf{KDF}</span> can be safely modeled as a random oracle. On the other hand, typical dedicated cryptographic hash functions, like SHA-1, may be modeled as random oracles, but they are certainly not pair-wise independent.</p>

    <p class="text-gray-300">We shall sketch here how to get the best of both worlds, i.e., how to implement the <span class="math">\\mathsf{KDF}</span> so that we get a proof of security of <span class="math">\\mathsf{CS3b}</span> in the standard model just under the DDH and TCR assumptions, and in the random oracle model under the CDH and TCR assumptions.</p>

    <p class="text-gray-300">The idea is this: compute <span class="math">\\mathsf{KDF}</span> as the XOR of a pair-wise independent hash <span class="math">\\mathsf{KDF1}</span> and a cryptographic hash <span class="math">\\mathsf{KDF2}</span>.</p>

    <p class="text-gray-300">It is clear that if <span class="math">\\mathsf{KDF1}</span> is pair-wise independent, then so is <span class="math">\\mathsf{KDF}</span>, and so the security of <span class="math">\\mathsf{CS3b}</span> in the standard model under the DDH and TCR assumptions now follows directly from Theorem 7.</p>

    <p class="text-gray-300">Now suppose we model the cryptographic hash <span class="math">\\mathsf{KDF2}</span> as a random oracle. It is easy to see that for any adversary <span class="math">\\mathsf{A}</span> attacking <span class="math">\\mathsf{CS3b}</span> given oracle access to <span class="math">\\mathsf{KDF2}</span>, there is an adversary <span class="math">\\mathsf{A}_{1}</span>, whose running time is roughly the same as that of <span class="math">\\mathsf{A}</span>, that attacks <span class="math">\\mathsf{CS3b}</span> given oracle access to <span class="math">\\mathsf{KDF}</span>: the adversary <span class="math">\\mathsf{A}_{1}</span> just does whatever <span class="math">\\mathsf{A}</span> does, except that whenever <span class="math">\\mathsf{A}</span> queries the oracle for <span class="math">\\mathsf{KDF2}</span>, adversary <span class="math">\\mathsf{A}_{1}</span> queries its oracle for <span class="math">\\mathsf{KDF}</span> and computes the value of <span class="math">\\mathsf{KDF2}</span> as the XOR of the value of <span class="math">\\mathsf{KDF}</span> and the value of <span class="math">\\mathsf{KDF1}</span>. Note, however, that the output distribution of the oracle <span class="math">\\mathsf{KDF}</span> is the same as that of a random oracle, and so the security of <span class="math">\\mathsf{CS3b}</span> in the random oracle model under the CDH and TCR assumptions now follows directly from Theorem 10.</p>

    <p class="text-gray-300">We do not necessarily advocate this approach to building a <span class="math">\\mathsf{KDF}</span> in practical implementations: simply assuming that a <span class="math">\\mathsf{KDF}</span> implemented directly using a dedicated cryptographic hash is secure is quite reasonable, and the resulting <span class="math">\\mathsf{KDF}</span> is much simpler and more efficient than any approach that makes use of a pair-wise independent hash function.</p>

    <h3 id="sec-103" class="text-xl font-semibold mt-8">10.7 Further discussion</h3>

    <p class="text-gray-300">The scheme <span class="math">\\mathsf{HEG}</span> is intended to represent a fairly traditional version of ElGamal key encapsulation. The only thing slightly non-traditional about it is the fact that the symmetric key <span class="math">K</span> is derived by hashing both <span class="math">a</span> (the ephemeral Diffie-Hellman public key) and <span class="math">b</span> (the shared Diffie-Hellman key), rather than just <span class="math">b</span> alone.</p>

    <p class="text-gray-300">Hashing both the ephemeral and shared keys together has some quantitative security advantages. Notice that in Theorem 9, the implied CDH algorithm makes no more than <span class="math">Q^{\\prime}_{\\mathsf{A}}(\\lambda)</span> queries to the DDH-oracle. If we were to hash only the shared Diffie-Hellman key, we could still prove the security of <span class="math">\\mathsf{HEG}</span>, but the reduction would be less efficient; in particular, the implied CDH algorithm might require up to <span class="math">Q^{\\prime}_{\\mathsf{A}}(\\lambda)\\cdot Q_{\\mathsf{A}}(\\lambda)</span> queries to the DDH-oracle. A similar quantitative security advantage arises in the multi-user/multi-message model (see <em>[x11]</em>). In this model, we can exploit the well-know random self-reducibility of the CDH problem to get a more efficient reduction if we hash both keys instead of just one. Of course, these improved security reductions for <span class="math">\\mathsf{HEG}</span> carry over to the security reduction for <span class="math">\\mathsf{CS3b}</span> in the random oracle model.</p>

    <p class="text-gray-300">The DHAES encryption scheme <em>[x1]</em>, which is a hybrid ElGamal encryption scheme that has been proposed for standardization, also hashes both the ephemeral and shared Diffie-Hellman keys to derive a symmetric key. Indeed, the DHAES scheme can be constructed from the key encapsulation mechanism <span class="math">\\mathsf{HEG}</span> using the hybrid constructions presented in §7, and it is straightforward to verify that analogues of Theorems 8 and 9 hold for the DHAES scheme as well. The DHAES scheme needs to hash both group elements because it allows the possibility of a group <span class="math">G</span> whose order is a composite number. In a revised version of DHAES, called DHIES <em>[x1]</em>, the group <span class="math">G</span> is required to have prime order, and only the shared Diffie-Hellman key is hashed. However, as we have seen, there are still some security benefits to be gained from hashing both group elements, even if the group is of prime order, as we are assuming in this paper.</p>

    <p class="text-gray-300">Theorem 10 originally appeared in the paper <em>[x37]</em>. The proof in that paper basically rolled all of the arguments used in the proofs of Theorems 8, 9, 10, along with the arguments in §10.6, into a single proof, which we have unraveled to some extent here. Our presentation here was somewhat influenced by the paper <em>[x38]</em>, which formally introduces the notion of the CDH assumption relative to an oracle for the DDH problem.</p>

    <p class="text-gray-300">The security reduction in Theorem 10 is quite inefficient: we have to perform many simulations using the given adversary <span class="math">\\mathsf{A}</span> just to solve one instance of the DDH problem, and then in a different simulation involving <span class="math">\\mathsf{A}</span>, we have to solve many instances of the DDH problem in order to solve one instance of the CDH problem. Of course, if the DDH problem for a given group scheme turns out not to be a hard problem, then it may very well be the case that there is a much more efficient DDH algorithm than the one built using our security reduction involving <span class="math">\\mathsf{A}</span>. In this case, the reduction in Theorem 10 becomes quite reasonable.</p>

    <h2 id="sec-104" class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">Some of this work was done while the first author was at the Institute for Theoretical Computer Science, ETH, Zurich, and while the second author was visiting the Computer Science Department at Stanford University. Thanks to Ilia Mironov for comments on an early draft of this paper.</p>

    <p class="text-gray-300">Thanks also to Moni Naor for his comments on an early draft of the <em>Crypto ’98</em> paper on which this paper is based, and in particular, for his suggestion of using a universal one-way hash function instead of a collision resistant hash function in the design of scheme <span class="math">\\mathsf{CS1}</span>, and for his suggestion of a hash-free variant, upon which scheme <span class="math">\\mathsf{CS2}</span> is loosely based.</p>

    <h2 id="sec-105" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[ABR99] M. Abdalla, M. Bellare, and P. Rogaway. DHAES: an encryption scheme based on the Diffie-Hellma problem. Cryptology ePrint Archive, Report 1999/007, 1999. http:</li>

    </ul>

    <p class="text-gray-300">//eprint.iacr.org.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[ABR01] M. Abdalla, M. Bellare, and P. Rogaway. The oracle Diffie-Hellman assumptions and an analysis of DHIES. In Topics in Cryptology – CT-RSA 2001, pages 143–158, 2001. Springer LNCS 2045.</li>

      <li>[ASW00] N. Asokan, V. Shoup, and M. Waidner. Optimistic fair exchange of digital signatures. IEEE Journal on Selected Areas in Communications, 18(4):593–610, 2000. Extended abstract in Advances in Cryptology–Eurocrypt ’98.</li>

      <li>[BBM00] M. Bellare, A. Boldyreva, and S. Micali. Public-key encryption in a multi-user setting: security proofs and improvements. In Advances in Cryptology–Eurocrypt 2000, 2000.</li>

      <li>[BDPR98] M. Bellare, A. Desai, D. Pointcheval, and P. Rogaway. Relations among notions of security for public-key encryption schemes. In Advances in Cryptology–Crypto ’98, pages 26–45, 1998.</li>

      <li>[BGMW92] E. F. Brickell, D. M. Gordon, K. S. McCurley, and D. B. Wilson. Fast exponentiation with precomputation. In Advances in Cryptology–Eurocrypt ’92, pages 200–207, 1992.</li>

      <li>[BH62] P. Bateman and R. Horn. A heuristic asymptotic formula concerning the distribution of prime numbers. Math. Comp., 16:363–367, 1962.</li>

      <li>[BH65] P. Bateman and R. Horn. Primes represented by irreducible polynomials in one variable. Proc. Sympos. Pure Math., 8:119–135, 1965.</li>

      <li>[Bon98] D. Boneh. The Decision Diffie-Hellman Problem. In Ants-III, pages 48–63, 1998. Springer LNCS 1423.</li>

      <li>[Bon01] D. Boneh. Simplified OAEP for the RSA and Rabin functions. In Advances in Cryptology–Crypto 2001, 2001.</li>

      <li>[BR93] M. Bellare and P. Rogaway. Random oracles are practical: a paradigm for designing efficient protocols. In First ACM Conference on Computer and Communications Security, pages 62–73, 1993.</li>

      <li>[BR94] M. Bellare and P. Rogaway. Optimal asymmetric encryption. In Advances in Cryptology—Eurocrypt ’94, pages 92–111, 1994.</li>

      <li>[BR97] M. Bellare and P. Rogaway. Collision-resistant hashing: towards making UOWHFs practical. In Advances in Cryptology–Crypto ’97, 1997.</li>

      <li>[Bra93] S. Brands. An efficient off-line electronic cash system based on the representation problem, 1993. CWI Technical Report, CS-R9323.</li>

      <li>[BS96] E. Bach and J. Shallit. Algorithmic Number Theory, volume 1. MIT Press, 1996.</li>

      <li>[BSS99] I. Blake, G. Seroussi, and N. Smart. Elliptic Curves in Cryptography. Cambridge University Press, 1999.</li>

      <li>[Can00] R. Canetti. Universally composable security: a new paradigm for cryptographic protocols. Cryptology ePrint Archive, Report 2000/067, 2000. http://eprint.iacr.org.</li>

    </ul>

    <p class="text-gray-300">[CG99] R. Canetti and S. Goldwasser. An efficient threshold public key cryptosystem secure against adaptive chosen ciphertext attack. In Advances in Cryptology–Eurocrypt ’99, pages 90–106, 1999.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[CGH98] R. Canetti, O. Goldreich, and S. Halevi. The random oracle model, revisited. In 30th Annual ACM Symposium on Theory of Computing, 1998.</li>

      <li>[CS98] R. Cramer and V. Shoup. A practical public key cryptosystem provably secure against adaptive chosen ciphertext attack. In Advances in Cryptology–Crypto ’98, pages 13–25, 1998.</li>

      <li>[CS00] R. Cramer and V. Shoup. Signature schemes based on the strong RSA assumption. ACM Transactions on Information and Systems Security, 3(3):161–185, 2000.</li>

      <li>[CS01] R. Cramer and V. Shoup. Universal hash proofs and a paradigm for adaptive chosen ciphertext secure public key encryption. Cryptology ePrint Archive, Report 2001/085, 2001. http://eprint.iacr.org.</li>

      <li>[Dam91] I. Damgård. Towards practical public key cryptosystems secure against chosen ciphertext attacks. In Advances in Cryptology–Crypto ’91, pages 445–456, 1991.</li>

      <li>[DDN91] D. Dolev, C. Dwork, and M. Naor. Non-malleable cryptography. In 23rd Annual ACM Symposium on Theory of Computing, pages 542–552, 1991.</li>

      <li>[DDN00] D. Dolev, C. Dwork, and M. Naor. Non-malleable cryptography. SIAM J. Comput., 30(2):391–437, 2000.</li>

      <li>[DH76] W. Diffie and M. E. Hellman. New directions in cryptography. IEEE Trans. Info. Theory, 22:644–654, 1976.</li>

      <li>[DN96] C. Dwork and M. Naor. Method for message authentication from non-malleable cryptosystems, 1996. U. S. Patent No. 05539826.</li>

      <li>[ElG85] T. ElGamal. A public key cryptosystem and signature scheme based on discrete logarithms. IEEE Trans. Inform. Theory, 31:469–472, 1985.</li>

      <li>[FOPS01] E. Fujisaki, T. Okamoto, D. Pointcheval, and J. Stern. RSA-OAEP is secure under the RSA assumption. In Advances in Cryptology–Crypto 2001, 2001.</li>

      <li>[FY95] Y. Frankel and M. Yung. Cryptanalysis of immunized LL public key systems. In Advances in Cryptology–Crypto ’95, pages 287–296, 1995.</li>

      <li>[GL89] O. Goldreich and L. A. Levin. A hard-core predicate for all one-way functions. In 21st Annual ACM Symposium on Theory of Computing, pages 25–32, 1989.</li>

      <li>[GM84] S. Goldwasser and S. Micali. Probabilistic encryption. Journal of Computer and System Sciences, 28:270–299, 1984.</li>

      <li>[HILL99] J. Håstad, R. Impagliazzo, L. Levin, and M. Luby. A pseudo-random generator from any one-way function. SIAM J. Comput., 28(4):1364–1396, 1999.</li>

      <li>[ILL89] R. Impagliazzo, L. Levin, and M. Luby. Pseudo-random number generation from any one-way function. In 21st Annual ACM Symposium on Theory of Computing, pages 12–24, 1989.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[IZ89] R. Impagliazzo and D. Zuckermann. How to recycle random bits. In 30th Annual Symposium on Foundations of Computer Science, pages 248–253, 1989.</li>

      <li>[JN01] A. Joux and K. Nguyen. Separating Decision Diffie-Hellman from Diffie-Hellman in cryptographic groups. Cryptology ePrint Archive, Report 2001/003, 2001. http://eprint.iacr.org.</li>

      <li>[LL93] C. H. Lim and P. J. Lee. Another method for attaining security against adaptively chosen ciphertext attacks. In Advances in Cryptology–Crypto ’93, pages 420–434, 1993.</li>

      <li>[LL94] C. H. Lim and P. J. Lee. More flexible exponentiation with precomputation. In Advances in Cryptology–Crypto ’94, pages 95–107, 1994.</li>

      <li>[MvOV97] A. Menesez, P. van Oorschot, and S. Vanstone. Handbook of Applied Cryptography. CRC Press, 1997.</li>

      <li>[MW00] U. Maurer and S. Wolf. The Diffie-Hellman protocol. Designs, Codes, and Cryptography, 19:147–171, 2000.</li>

      <li>[NR97] M. Naor and O. Reingold. Number-theoretic constructions of efficient pseudo-random functions. In 38th Annual Symposium on Foundations of Computer Science, 1997.</li>

      <li>[NY89] M. Naor and M. Yung. Universal one-way hash functions and their cryptographic applications. In 21st Annual ACM Symposium on Theory of Computing, 1989.</li>

      <li>[NY90] M. Naor and M. Yung. Public-key cryptosystems provably secure against chosen ciphertext attacks. In 22nd Annual ACM Symposium on Theory of Computing, pages 427–437, 1990.</li>

      <li>[OP01] T. Okamoto and D. Pointcheval. The gap-problems: a new class of problems for the security of cryptographic schemes. In Proc. 2001 International Workshop on Practice and Theory in Public Key Cryptography (PKC 2001), 2001.</li>

      <li>[Pai99] P. Paillier. Public-key cryptosystems based on composite degree residuosity classes. In Advances in Cryptology–Eurocrypt ’99, pages 223–238, 1999.</li>

      <li>[Rom90] J. Rompel. One-way functions are necessary and sufficient for digital signatures. In 21st Annual ACM Symposium on Theory of Computing, 1990.</li>

      <li>[RS91] C. Rackoff and D. Simon. Noninteractive zero-knowledge proof of knowledge and chosen ciphertext attack. In Advances in Cryptology–Crypto ’91, pages 433–444, 1991.</li>

      <li>[SG98] V. Shoup and R. Gennaro. Securing threshold cryptosystems against chosen ciphertext attack. In Advances in Cryptology–Eurocrypt ’98, 1998. To appear, J. Cryptology.</li>

      <li>[SHA95] Secure hash standard, National Institute of Standards and Technology (NIST), FIPS Publication 180-1, April 1995.</li>

      <li>[Sho99] V. Shoup. On formal models for secure key exchange. Cryptology ePrint Archive, Report 1999/012, 1999. http://eprint.iacr.org.</li>

      <li>[Sho00a] V. Shoup. A composition theorem for universal one-way hash functions. In Advances in Cryptology–Eurocrypt 2000, 2000.</li>

    </ul>

    <p class="text-gray-300">[Sho00b] V. Shoup. Using hash functions as a hedge against chosen ciphertext attack. In Advances in Cryptology–Eurocrypt 2000, 2000.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Sho01] V. Shoup. OAEP reconsidered. In Advances in Cryptology–Crypto 2001, 2001.</li>

      <li>[Sma99] N. Smart. The discrete logarithm problem on elliptic curves of trace one. J. Cryptology, 12(3):193–196, 1999.</li>

      <li>[Sta96] M. Stadler. Publicly verifiable secret sharing. In Advances in Cryptology–Eurocrypt ’96, pages 190–199, 1996.</li>

      <li>[ZS92] Y. Zheng and J. Seberry. Practical approaches to attaining security against adaptively chosen ciphertext attacks. In Advances in Cryptology–Crypto ’92, pages 292–304, 1992.</li>

    </ul>`;
---

<BaseLayout title="Design and Analysis of Practical Public-Key Encryption Schem... (2001/108)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2001 &middot; eprint 2001/108
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
