---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2001/108';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-17';
const TITLE_HTML = 'Design and Analysis of Practical Public-Key Encryption Schemes Secure against Adaptive Chosen Ciphertext Attack';
const AUTHORS_HTML = 'Ronald Cramer Dept. of Computer Science, Aarhus University cramer@brics.dk';

const CONTENT = `    <p class="text-gray-300">Ronald Cramer Dept. of Computer Science, Aarhus University cramer@brics.dk</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
    <p class="text-gray-300">Victor Shoup IBM Zurich Research Laboratory sho@zurich.ibm.com</p>

    </blockquote>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
    <p class="text-gray-300">December 17, 2001</p>

    </blockquote>

    </blockquote>

    <h4 id="sec-1" class="text-lg font-semibold mt-6">Abstract</h4>

    <p class="text-gray-300">A new public key encryption scheme, along with several variants, is proposed and analyzed. The scheme and its variants are quite practical, and are proved secure against adaptive chosen ciphertext attack under standard intractability assumptions. These appear to be the first publickey encryption schemes in the literature that are simultaneously practical and provably secure.</p>

    <p class="text-gray-300">This paper is a significantly revised and extended version of the extended abstract &quot;A practical public key cryptosystem provably secure against adaptive chosen ciphertext attack&quot; [R. Cramer and V. Shoup, in Advances in Cryptology – Crypto '98], and also includes results originally presented in the extended abstract &quot;Using hash functions as a hedge against chosen ciphertext attack&quot; [V. Shoup, in Advances in Cryptology – Eurocrypt 2000].</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">1</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Introduction</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">1</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.1&lt;br&gt;Chosen ciphertext security</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.2&lt;br&gt;Previous work</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.3&lt;br&gt;Further progress&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.4&lt;br&gt;Outline of paper&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Some Preliminaries</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.1&lt;br&gt;Basic mathematical notation&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.2&lt;br&gt;Algorithms and probability spaces&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.3&lt;br&gt;Statistical distance and negligible functions&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Secure Public Key Encryption</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.1&lt;br&gt;Public Key Encryption Schemes</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.2&lt;br&gt;Security against adaptive chosen ciphertext attack&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.3&lt;br&gt;Application of the definition of security&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.4&lt;br&gt;Further discussion&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Intractability Assumptions Related to the Discrete Logarithm Problem</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.1&lt;br&gt;Computational group schemes</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.2&lt;br&gt;Examples of appropriate computational group schemes</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.3&lt;br&gt;Intractability assumptions</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.4&lt;br&gt;Further discussion&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Target Collision Resistant Hash Functions</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.1&lt;br&gt;Further discussion&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">The New Encryption Scheme: Basic Version</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.1&lt;br&gt;Description of the scheme&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.2&lt;br&gt;Security analysis of the scheme&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.3&lt;br&gt;Two variations&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">28</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.4&lt;br&gt;A hash-free variant</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">31</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Hybrid Encryption</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">35</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7.1&lt;br&gt;Key encapsulation&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">36</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7.2&lt;br&gt;One-time symmetric-key encryption&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">37</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7.3&lt;br&gt;A hybrid construction&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">41</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Key Derivation Functions</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">42</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8.1&lt;br&gt;Constructions</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">43</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">The New Encryption Scheme: Hybrid Version</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">44</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9.1&lt;br&gt;Description of the Scheme&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">44</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9.2&lt;br&gt;Security analysis of the scheme&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">46</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9.3&lt;br&gt;Two variations&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">50</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">10 Further Security Considerations of Scheme&lt;br&gt;CS3b</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">50</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10.1 Hashed ElGamal key encapsulation</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">51</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10.2 The random oracle model&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">51</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10.3&lt;br&gt;CS3b&lt;br&gt;is at least as secure as&lt;br&gt;HEG&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">51</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10.4 The security of&lt;br&gt;HEG&lt;br&gt;in the random oracle model&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">53</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10.5 The security of&lt;br&gt;CS3b&lt;br&gt;in the random oracle model&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">56</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10.6 Random oracles and pair-wise independent key derivation functions: getting the best</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of both</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">57</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10.7 Further discussion&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">57</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">In this paper, we present and analyze a new public-key encryption scheme, and several variants, proving that they are secure against adaptive chosen ciphertext attack (as defined by Rackoff and Simon [RS91]) under standard intractability assumptions. The schemes are quite practical, requiring just a few exponentiations in a group for both encryption and decryption. Moreover, the proofs of security of these schemes rely only on standard intractability assumptions: one variant relies only on the hardness of the Decisional Diffie-Hellman problem, while other, somewhat more practical, variants rely on a couple of other standard intractability assumptions.</p>

    <p class="text-gray-300">The hardness of the Decisional Diffie-Hellman problem is essentially equivalent to the semantic security of the basic ElGamal encryption scheme [ElG85]. Thus, with just a bit more computation, we get security against adaptive chosen ciphertext attack, whereas the basic ElGamal scheme is completely insecure against this type of attack.</p>

    <p class="text-gray-300">While there are several provably secure public-key encryption schemes in the literature, they are all quite impractical. Also, there are several practical encryption schemes that have been proposed, but none of them has been proven secure under standard intractability assumptions. The significance of our results is that they provide several schemes that are provably secure and practical at the same time. There appear to be no other public-key encryption schemes in the literature that enjoy both of these properties simultaneously.</p>

    <p class="text-gray-300">This paper is a significantly revised and extended version of the extended abstract [CS98], and also includes results originally presented in the extended abstract [Sho00b].</p>

    <p class="text-gray-300">Semantic security, defined by Goldwasser and Micali [GM84], captures the intuition that an adversary should not be able to obtain any partial information about a message given its encryption. However, this guarantee of secrecy is only valid when the adversary is completely passive, i.e., can only eavesdrop. Indeed, semantic security offers no guarantee of secrecy at all if an adversary can mount an active attack, i.e., inject messages into a network or otherwise influence the behavior of parties in the network.</p>

    <p class="text-gray-300">To deal with active attacks, Rackoff and Simon [RS91] defined the notion of security against an adaptive chosen ciphertext attack. If an adversary can inject messages into a network, these messages may be ciphertexts, and the adversary may be able to extract partial information about the corresponding cleartexts through its interactions with the parties in the network. Rackoff and Simon's definition models this type of attack by simply allowing an adversary to obtain decryptions of its choice, i.e., the adversary has access to a &quot;decryption oracle.&quot; Now, given an encryption of a message — the &quot;target&quot; ciphertext — we want to guarantee that the adversary cannot obtain any partial information about the message. To achieve this, we have to restrict the adversary's behavior in some way, otherwise the adversary could simply submit the target ciphertext itself to the decryption oracle. The restriction proposed by Rackoff and Simon is the weakest possible: the adversary is not allowed to submit the target ciphertext itself to the oracle; however, it may submit any other ciphertext, including ciphertexts that are related to the target ciphertext.</p>

    <p class="text-gray-300">A different notion of security against active attacks, called non-malleability, was proposed by Dolev, Dwork, and Naor [DDN91, DDN00]. Here, the adversary also has access to a decryption oracle, but his goal is not to obtain partial information about the target ciphertext, but rather, to create another encryption of a different message that is related in some interesting way to the original, encrypted message. For example, for a non-malleable encryption scheme, given an encryption of n, it should be infeasible to create an encryption of n+ 1. It turns out that non-malleability and security against adaptive chosen ciphertext attack are equivalent [BDPR98, DDN00].</p>

    <p class="text-gray-300">An encryption scheme secure against adaptive chosen ciphertext attack is a very powerful cryptographic primitive. It is essential in designing protocols that are secure against active adversaries. For example, this primitive is used in protocols for authentication and key exchange [DN96, DDN00, Sho99] and in protocols for escrow, certified e-mail, and more general fair exchange [ASW00]. It is by now generally recognized in the cryptographic research community that security against adaptive chosen ciphertext attack is the &quot;right&quot; notion of security for a general-purpose public-key encryption scheme. This is exemplified by the adoption of Bellare and Rogaway's OAEP scheme [BR94] (a practical but only heuristically secure scheme) as the internet encryption standard PKCS#1 version 2, and for use in the SET protocol for electronic commerce.</p>

    <p class="text-gray-300">There are also intermediate notions of security, between semantic security and adaptive chosen ciphertext security. Naor and Yung [NY90] propose an attack model where the adversary has access to the decryption oracle only prior to obtaining the target ciphertext, and the goal of the adversary is to obtain partial information about the encrypted message. Naor and Yung called this type of attack a chosen ciphertext attack; it has also been called a &quot;lunch-time&quot; or &quot;midnight&quot; attack, and also an indifferent chosen ciphertext attack. In this paper, we will use the phrase adaptive chosen ciphertext attack for Rackoff and Simon's definition, to distinguish it from Naor and Yung's definition. Also, throughout this paper, unless otherwise specified, by &quot;security&quot; we will always mean &quot;security against adaptive chosen ciphertext attack.&quot;</p>

    <p class="text-gray-300">Provably Secure Schemes. Naor and Yung [NY90] presented the first scheme provably secure against lunch-time attacks. Subsequently, Dolev, Dwork, and Naor [DDN91] presented a scheme that is provably secure against adaptive chosen ciphertext attack.</p>

    <p class="text-gray-300">Rackoff and Simon [RS91] present and prove the security of an encryption scheme, but their scheme is actually not a public-key scheme in the traditional sense: in their scheme, all users both senders and receivers — require public keys, and moreover, a trusted center is required to perform certain functions. In contrast, all other schemes mentioned in this paper, including our own, are traditional public-key systems: encryption is a probabilistic function of the message and the receiver's public key, decryption is a function of the ciphertext and the receiver's secret key, and no trusted center is required. This distinction can be important: adding extra system requirements as in the Rackoff and Simon scheme can greatly restrict the range of application of the scheme.</p>

    <p class="text-gray-300">All of the previously known schemes provably secure under standard intractability assumptions are completely impractical (albeit polynomial time), as they rely on general and expensive constructions for non-interactive zero-knowledge proofs. This includes non-standard schemes like Rackoff and Simon's as well.</p>

    <p class="text-gray-300">Practical Schemes. Damg˚ard [Dam91] proposed a practical scheme that he conjectured to be secure against lunch-time attacks; however, this scheme is not known to be provably secure in this sense, and is in fact demonstrably insecure against adaptive chosen ciphertext attack.</p>

    <p class="text-gray-300">Zheng and Seberry [ZS92] proposed practical schemes that are conjectured to be secure against chosen ciphertext attack, but again, no proof based on standard intractability assumptions is known. Lim and Lee [LL93] also proposed practical schemes that were later broken by Frankel and Yung [FY95].</p>

    <p class="text-gray-300">Bellare and Rogaway [BR93, BR94] have presented practical schemes for which they give heuristic proofs of adaptive chosen ciphertext security; namely, they prove security based on the assumption of a one-way trapdoor permutation in an idealized model of computation, the so-called random oracle model, wherein a hash function is represented by a random oracle. Actually, it turns out that the proof of security of the OAEP scheme in [BR94] is flawed: as demonstrated in [Sho01], there can be no standard &quot;black box&quot; security proof based on an arbitrary one-way trapdoor permutation. However, the negative result in [Sho01] does not rule out the possibility that OAEP in conjunction with a specific one-way trapdoor permutation scheme is secure. Indeed, it is shown in [Sho01] that OAEP with exponent-3 RSA is secure, and this result is generalized in [FOPS01] to arbitraryexponent RSA. A new scheme, OAEP+, is also presented in [Sho01], which can be proven secure in the random oracle model, using an arbitrary one-way trapdoor permutation. Further variations of OAEP and OAEP+ are discussed in [Bon01].</p>

    <p class="text-gray-300">Shoup and Gennaro [SG98] also give ElGamal-like schemes that are secure against adaptive chosen ciphertext attack in the random oracle model, and that are also amenable to efficient threshold decryption.</p>

    <p class="text-gray-300">We stress that although a security proof in the random oracle model is of some value, it is still only a heuristic proof. In particular, these types of proofs do not rule out the possibility of breaking the scheme without breaking the underlying intractability assumption. Nor do they even rule out the possibility of breaking the scheme without finding some kind of weakness in the hash function, as shown by Canetti, Goldreich, and Halevi [CGH98].</p>

    <h2 id="sec-2" class="text-2xl font-bold">1.3 Further progress</h2>

    <p class="text-gray-300">Subsequent to the publication of the extended abstract [CS98] on which the present paper is based, some further progress in this area has been made. Canetti and Goldwasser [CG99] presented a threshold-decryption variant of our scheme. Also, the authors of the present paper [CS01] have generalized and extended the basic ideas underlying our encryption scheme, obtaining new and quite practical encryption schemes that are secure against adaptive chosen ciphertext attack under different assumptions — one scheme relies on Paillier's Decision Composite Residuosity assumption [Pai99], while the other (somewhat less practical) scheme relies on the classical Quadratic Residuosity assumption.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.4 Outline of paper</h3>

    <p class="text-gray-300">Our paper consists of two parts.</p>

    <p class="text-gray-300">Part 1. In the first part, we take care of a number of preliminaries, after which we present a basic version of our new scheme, along with a few variants. This first part is organized as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">§2: We introduce some basic notation that will be used throughout the paper.</p></li>
      <li><p class="text-gray-300">§3: We state the formal definition of a public-key encryption scheme and the notion of security against adaptive chosen ciphertext attack. We also discuss some implications of the definition of security that illustrate its utility.</p></li>
      <li><p class="text-gray-300">§4: We state the formal definitions of several intractability assumption related to the Discrete Logarithm problem: the Discrete Logarithm assumption, the Computational Diffie-Hellman assumption, and the Decisional Diffie-Hellman assumption. In doing this, we introduce the notion of a computational group scheme, which is a general framework that allows us to discuss in an abstract, yet sufficiently concrete way, the different families of groups that may be used in cryptographic applications.</p></li>
      <li><p class="text-gray-300">§5: We define the notion of a target collision resistant hash function, which is a special type of a universal one-way hash function. We will use this primitive in the most efficient variants of our encryption scheme.</p></li>
      <li><p class="text-gray-300">§6: We present and analyze the basic version of our encryption scheme, which we call CS1, along with two variants, called CS1a and CS1b. We prove the security of these schemes based on the Decisional Diffie-Hellman assumption, and the assumption that a given family of hash functions is target collision resistant. We also present and analyze a somewhat less efficient scheme, called CS2, which does not require a target collision resistant hash function.</p></li>
    </ul>

    <p class="text-gray-300">Part 2. The schemes presented in §6 suffer from two drawbacks. First, the schemes require that plaintexts are, or can be encoded as, group elements, which may significantly restrict the range of application of the encryption scheme and/or the choice of computational group scheme; it would be nice to relax this restriction, allowing plaintexts to be, say, bit strings of arbitrary length. Second, if the Decisional Diffie-Hellman assumption is false, these schemes can be trivially broken; it would be nice if we could provide a second level of defense, so that if Decisional Diffie-Hellman assumption turns out to be false, we have a scheme that still offers some security — even if only heuristically.</p>

    <p class="text-gray-300">It turns out that both of these drawbacks can be dealt with by using a technique called hybrid encryption. Basically, a hybrid encryption scheme uses public-key encryption techniques to derive a shared key that is then used to encrypt the actual message using standard symmetric-key techniques. The second part of the paper is devoted to developing the formal theory behind this technique, and to designing and analyzing variations on our basic scheme that utilize this technique. This part is organized as follows:</p>

    <p class="text-gray-300">§7: We lay the theoretical foundations for hybrid encryption. Although most of the ideas in this section appear to be &quot;folklore,&quot; they have not been treated rigorously in the literature. In §7.1, we introduce the notion of a key encapsulation mechanism, and an appropriate notion of security against adaptive chosen ciphertext attack. A key encapsulation mechanism is like a public-key encryption scheme, except that the encryption algorithm can only be used to generate and encrypt a random bit string of fixed length, which we shall use as a key for a symmetric-key encryption scheme. In §7.2, we state the formal properties of a symmetric-key encryption scheme that we need for use in a hybrid encryption scheme, and discuss some simple constructions based on pseudo-random bit generators and message authentication codes. In §7.3, we prove that an appropriately secure key encapsulation mechanism, combined with an appropriately secure symmetric-key encryption scheme, yields a public-key encryption scheme that is secure against adaptive chosen ciphertext attack.</p>

    <p class="text-gray-300">In what follows, we concentrate exclusively on the problem of constructing secure key encapsulation mechanisms, since the problem of constructing symmetric-key encryption schemes is essentially solved.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>§8: We discuss the notion of a secure key derivation function, which is a function that should map random group elements to pseudo-random bit strings of given length. A key derivation function is an essential ingredient in our constructions of key encapsulation mechanisms.</li>
      <li>§9: We present and analyze a key encapsulation mechanism, CS3, along with two variants, CS3a and CS3b, and prove their security under the Decisional Diffie-Hellman assumption, and also assuming a target collision resistant hash function and a secure key derivation function.</li>
    </ul>

    <p class="text-gray-300">§10: The hybrid encryption scheme obtained from CS3b is by far the most practical of the encryption schemes presented in this paper; moreover, it has other interesting security properties. We show that CS3b is no less secure than a more traditional key encapsulation mechanism that is a hashed variant of ElGamal encryption, which we call HEG. Second, we also show that CS3b is secure in the random oracle model (viewing the key derivation function as a random function), under the weaker Computational Diffie-Hellman assumption, and also assuming a target collision resistant hash function. The results in this section show that there is virtually no risk in using scheme CS3b relative to more traditional encryption schemes, while at the same time, CS3b provides a security guarantee that more traditional schemes do not.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">2.1 Basic mathematical notation</h4>

    <p class="text-gray-300"><span class="math">\\mathbf{Z}</span>  denotes the ring of integers,  <span class="math">\\mathbf{Z}_{\\geq 0}</span>  denotes the set of non-negative integers, and for positive integer k,  <span class="math">\\mathbf{Z}_k</span>  denotes the ring of integers modulo k, and  <span class="math">\\mathbf{Z}_k^*</span>  denotes the corresponding multiplicative group of units.</p>

    <p class="text-gray-300">We write  <span class="math">\\nu \\leftarrow \\alpha</span>  to denote the algorithmic action of assigning the value of  <span class="math">\\alpha</span>  to the variable  <span class="math">\\nu</span> .</p>

    <p class="text-gray-300">Let X be a finite probability space, i.e., a probability space on a finite set S. For  <span class="math">\\alpha \\in S</span> , we let  <span class="math">\\Pr_X[\\alpha]</span>  denote the probability that X assigns to  <span class="math">\\alpha</span> , and for  <span class="math">S&#x27; \\subset S</span> , we let  <span class="math">\\Pr_X[S&#x27;]</span>  denote the probability that X assigns to S'.</p>

    <p class="text-gray-300">We write  <span class="math">\\nu \\stackrel{R}{\\leftarrow} X</span>  to denote the algorithmic action of sampling an element of S according to the distribution X, and assigning the result of this sampling experiment to the variable  <span class="math">\\nu</span> . We sometimes write  <span class="math">\\nu_1, \\ldots, \\nu_k \\stackrel{R}{\\leftarrow} X</span>  as a shorthand for  <span class="math">\\nu_1 \\stackrel{R}{\\leftarrow} X; \\ldots; \\nu_k \\stackrel{R}{\\leftarrow} X</span> .</p>

    <p class="text-gray-300">For any finite set S,  <span class="math">\\mathbf{U}(S)</span>  denotes the uniform distribution on S. We write  <span class="math">\\nu \\stackrel{R}{\\leftarrow} S</span>  as a shorthand for  <span class="math">\\nu \\stackrel{R}{\\leftarrow} \\mathbf{U}(S)</span> .</p>

    <p class="text-gray-300">For any probability space X on a finite set S, we denote by [X] the subset of elements of S that are assigned non-zero probability by X, i.e., the &quot;support&quot; of X.</p>

    <p class="text-gray-300">If  <span class="math">X_1, X_2, \\ldots, X_k</span>  are finite probability spaces, and  <span class="math">\\phi</span>  is a k-ary predicate, then we write</p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\phi(\\nu_1,\\ldots,\\nu_k):\\nu_1\\stackrel{\\scriptscriptstyle R}{\\leftarrow} X_1;\\ldots;\\nu_k\\stackrel{\\scriptscriptstyle R}{\\leftarrow} X_k]</span>$</p>

    <p class="text-gray-300">to denote the probability that  <span class="math">\\phi(\\nu_1, \\ldots, \\nu_k)</span>  holds when  <span class="math">\\nu_1</span>  is sampled from  <span class="math">X_1, \\nu_2</span>  is sampled from  <span class="math">X_2</span> , etc. More generally, for  <span class="math">1 \\le i \\le k</span> ,  <span class="math">X_i</span>  may be family of finite probability spaces parameterized by  <span class="math">(\\nu_1, \\ldots, \\nu_{i-1})</span> , and we write</p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\phi(\\nu_1,\\ldots,\\nu_k):\\nu_1\\stackrel{R}{\\leftarrow} X_1;\\nu_2\\stackrel{R}{\\leftarrow} X_2(\\nu_1);\\ldots;\\nu_k\\stackrel{R}{\\leftarrow} X_k(\\nu_1,\\ldots,\\nu_{k-1})]</span>$</p>

    <p class="text-gray-300">to denote the probability that  <span class="math">\\phi(\\nu_1, \\ldots, \\nu_k)</span>  holds when  <span class="math">\\nu_1</span>  is sampled from  <span class="math">X_1</span> , after which  <span class="math">\\nu_2</span>  is sampled from  <span class="math">X_2(\\nu_1)</span> , and so on. In this case, it is important that  <span class="math">\\nu_1, \\ldots, \\nu_k</span>  are sampled in the order given.</p>

    <p class="text-gray-300">Similarly, if F is a k-ary function function, then</p>

    <p class="text-gray-300"><span class="math">$\\{F(\\nu_1,\\ldots,\\nu_k): \\nu_1 \\stackrel{R}{\\leftarrow} X_1; \\nu_2 \\stackrel{R}{\\leftarrow} X_2(\\nu_1); \\ldots; \\nu_k \\stackrel{R}{\\leftarrow} X_k(\\nu_1,\\ldots,\\nu_{k-1})\\}</span>$</p>

    <p class="text-gray-300">denotes the probability space defined by sampling  <span class="math">\\nu_1</span>  from  <span class="math">X_1</span> ,  <span class="math">\\nu_2</span>  from  <span class="math">X_2(\\nu_1)</span> , and so on, and then evaluating the function  <span class="math">F(\\nu_1, \\ldots, \\nu_k)</span> .</p>

    <p class="text-gray-300">We shall consider polynomial-time probabilistic algorithms A. We shall insist that for all  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>  and all inputs of length  <span class="math">\\lambda</span> , algorithm A always halts in time bounded by a polynomial in  <span class="math">\\lambda</span> , regardless of the random choices that A may make. In particular, for any input tuple  <span class="math">(\\alpha_1, \\ldots, \\alpha_k)</span> , the random choices made by A as well as the output of A on this input are finite probability spaces. We denote this output probability space of A for a given input  <span class="math">(\\alpha_1, \\ldots, \\alpha_k)</span>  by  <span class="math">A(\\alpha_1, \\ldots, \\alpha_k)</span> . We stress that  <span class="math">A(\\alpha_1, \\ldots, \\alpha_k)</span>  is a probability space, and not a value. As such, we may write  <span class="math">\\nu \\in A(\\alpha_1, \\ldots, \\alpha_k)</span>  to denote the algorithmic action of running A on input  <span class="math">(\\alpha_1, \\ldots, \\alpha_k)</span> , and assigning the output to the variable  <span class="math">\\nu</span> . When we speak of the &quot;running time&quot; of A, we mean the worst-case running time of A for inputs of a given length.</p>

    <p class="text-gray-300">To exercise the above notation a bit, note that  <span class="math">[A(\\alpha_1, \\ldots, \\alpha_k)]</span>  denotes the set of possible outputs of A on input  <span class="math">(\\alpha_1, \\ldots, \\alpha_k)</span> . For a tertiary predicate  <span class="math">\\phi</span> , and polynomial-time probabilistic algorithms  <span class="math">A_1</span>  and  <span class="math">A_2</span> , and a value  <span class="math">\\alpha_0</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\phi(\\alpha_0, \\alpha_1, \\alpha_2) : \\alpha_1 \\stackrel{R}{\\leftarrow} \\mathsf{A}_1(\\alpha_0); \\alpha_2 \\stackrel{R}{\\leftarrow} \\mathsf{A}_2(\\alpha_0, \\alpha_1)]</span>$</p>

    <p class="text-gray-300">denotes the probability that  <span class="math">\\phi(\\alpha_0, \\alpha_1, \\alpha_2)</span>  holds when  <span class="math">A_1</span>  is run on input  <span class="math">\\alpha_0</span> , yielding an output  <span class="math">\\alpha_1</span> , and then  <span class="math">A_2</span>  is run on input  <span class="math">(\\alpha_0, \\alpha_1)</span> , yielding an output  <span class="math">\\alpha_2</span> .</p>

    <p class="text-gray-300">For  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> ,  <span class="math">\\mathbf{1}^{\\lambda}</span>  denotes the bit string consisting of  <span class="math">\\lambda</span>  copies of the bit 1. The string  <span class="math">\\mathbf{1}^{\\lambda}</span>  will often be an input to an algorithm: this is a technical device that allows a polynomial-time algorithm to run in time bounded by a polynomial in  <span class="math">\\lambda</span> , even if there are no other inputs to the algorithm, or those inputs happen to be very short.</p>

    <p class="text-gray-300">Let X and Y be probability spaces on a finite set S. Define the statistical distance  <span class="math">\\Delta(X,Y)</span>  between X and Y as</p>

    <p class="text-gray-300"><span class="math">$\\Delta(X,Y) := \\frac{1}{2} \\sum_{\\alpha \\in S} |\\operatorname{Pr}_X[\\alpha] - \\operatorname{Pr}_Y[\\alpha]|.</span>$</p>

    <p class="text-gray-300">One can easily verify that</p>

    <p class="text-gray-300"><span class="math">$\\Delta(X,Y) = \\max_{S&#x27; \\subset S} |\\Pr_X[S&#x27;] - \\Pr_Y[S&#x27;]|.</span>$</p>

    <p class="text-gray-300">A function F mapping non-negative integers to non-negative reals is called <em>negligible</em> if for all positive numbers c, there exists an integer  <span class="math">\\lambda_0(c) \\geq 0</span>  such that for all  <span class="math">\\lambda &gt; \\lambda_0(c)</span> , we have  <span class="math">F(\\lambda) &lt; 1/\\lambda^c</span> .</p>

    <p class="text-gray-300">In this section, we state the basic properties of a public-key encryption scheme, along with the definition of security against adaptive chosen ciphertext attack. Although the notions here are relatively standard, we treat a number of details here that are not often dealt with in the literature. We also discuss some implications of the definition of security that illustrate its utility.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">3.1 Public Key Encryption Schemes</h4>

    <p class="text-gray-300">A public-key encryption scheme PKE consists of the following algorithms:</p>

    <p class="text-gray-300">• A probabilistic, polynomial-time key generation algorithm PKE.KeyGen that on input  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , outputs a public key/secret key pair (PK, SK). The structure of PK and SK depends on the particular scheme.</p>

    <p class="text-gray-300">For λ ∈ Z≥0, we define the probability spaces</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{PKE}.\\mathsf{PKSpace}_{\\lambda} := \\{\\mathsf{PK} : (\\mathsf{PK},\\mathsf{SK}) \\xleftarrow{\\scriptscriptstyle{R}} \\mathsf{PKE}.\\mathsf{KeyGen}(\\mathbf{1}^{\\lambda})\\},</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{PKE}.\\mathsf{SKSpace}_{\\lambda} := \\{\\mathsf{SK} : (\\mathsf{PK},\\mathsf{SK}) \\xleftarrow{\\scriptscriptstyle{R}} \\mathsf{PKE}.\\mathsf{KeyGen}(\\mathbf{1}^{\\lambda})\\}.</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A probabilistic, polynomial-time encryption algorithm PKE.Encrypt that takes as input 1 λ for λ ∈ Z≥0, a public key PK ∈ [PKE.PKSpace&lt;sup&gt;λ&lt;/sup&gt; ], a message m, and outputs a ciphertext ψ.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A ciphertext is a bit string. The structure of a message may depend on the particular scheme; see below (§3.1.1) for a discussion.</li>
    </ul></li>
      <li>A deterministic, polynomial-time decryption algorithm PKE.Decrypt that takes as input 1 λ for λ ∈ Z≥0, a secret key SK ∈ [PKE.SKSpace&lt;sup&gt;λ&lt;/sup&gt; ], a ciphertext ψ, and outputs either a message m or the special symbol reject.</li>
    </ul>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">3.1.1 Message spaces</h3>

    <p class="text-gray-300">Different public-key encryption schemes might specify different message spaces, and these message spaces might in fact vary with the choice of public key. Let us denote by PKE.MSpaceλ,PK the message space associated with λ ∈ Z≥&lt;sup&gt;0&lt;/sup&gt; and PK ∈ [PKE.PKSpace&lt;sup&gt;λ&lt;/sup&gt; ]. Although there may be other ways of categorizing message spaces, we shall work with schemes that specify message spaces in one of two ways:</p>

    <p class="text-gray-300">unrestricted message space: PKE.MSpaceλ,PK = {0, 1} ∗ for all λ and PK.</p>

    <p class="text-gray-300">restricted message space: PKE.MSpaceλ,PK is a finite set that may depend on λ and PK.</p>

    <p class="text-gray-300">There should be a deterministic, polynomial-time algorithm that on input 1 λ , PK, and α, determines if α ∈ PKE.MSpaceλ,PK.</p>

    <p class="text-gray-300">Clearly, a public-key encryption scheme with an unrestricted message space will be most suitable in a setting where a very general-purpose encryption scheme is required. However, encryption schemes with restricted message spaces can be useful in some settings as well.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">3.1.2 Soundness</h4>

    <p class="text-gray-300">A public-key encryption scheme should be sound in the sense that decrypting an encryption of a message should yield the original message.</p>

    <p class="text-gray-300">Requiring that this always holds is a very strong condition which will not be satisfied by many otherwise quite acceptable encryption schemes.</p>

    <p class="text-gray-300">A definition of soundness that is adequate for our purposes runs as follows. Let us say a public key/secret key pair (PK, SK) ∈ [PKE.KeyGen(1 λ )] is bad if for some m ∈ PKE.MSpaceλ,PK and some ψ ∈ [PKE.Encrypt(1 λ , PK, m)], we have PKE.Decrypt(1 λ , SK, ψ) 6= m. Then our requirement is that the probability that the key generation algorithm outputs a bad key pair grows negligibly in λ.</p>

    <p class="text-gray-300">One could formulate even weaker notions of soundness that would still be adequate for many applications, but we shall not pursue this here.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">3.2 Security against adaptive chosen ciphertext attack</h3>

    <p class="text-gray-300">An adversary A in an adaptive chosen ciphertext attack (CCA) is a probabilistic, polynomial-time oracle query machine.</p>

    <p class="text-gray-300">The attack game is defined in terms of an interactive computation between the adversary and its environment. The adversary's environment responds to the oracle queries made by the adversary: each oracle query response is sampled from a probability space that is a function of the adversary's input and all the previous oracle queries made by the adversary. We require that A runs in time strictly bounded by a polynomial in the length of its input, regardless of its probabilistic choices, and regardless of the responses to its oracle queries from its environment.</p>

    <p class="text-gray-300">We now describe the attack game used to define security against adaptive chosen ciphertext attack; that is, we define (operationally) the environment in which A runs. We assume that the input to A is 1 λ for some λ ∈ Z≥0.</p>

    <p class="text-gray-300">Stage 1: The adversary queries a key generation oracle. The key generation oracle computes (PK, SK) &lt;sup&gt;R&lt;/sup&gt;← PKE.KeyGen(1 λ ) and responds with PK.</p>

    <p class="text-gray-300">Stage 2: The adversary makes a sequence of calls to a decryption oracle.</p>

    <p class="text-gray-300">For each decryption oracle query, the adversary submits a ciphertext ψ, and the decryption oracle responds with PKE.Decrypt(1 λ , SK, ψ).</p>

    <p class="text-gray-300">We emphasize that ψ may be an arbitrary bit string, concocted by A in an arbitrary fashion — it certainly need not be an output of the encryption algorithm.</p>

    <p class="text-gray-300">Stage 3: The adversary submits two messages m0, m&lt;sup&gt;1&lt;/sup&gt; ∈ PKE.MSpaceλ,PK to an encryption oracle. In the case of an unrestricted message space, we require that |m0| = |m1|.</p>

    <p class="text-gray-300">On input m0, m1, the encryption oracle computes:</p>

    <p class="text-gray-300"><span class="math">$\\sigma \\overset{R}{\\leftarrow} \\{0,1\\}; \\ \\psi^* \\overset{R}{\\leftarrow} \\mathsf{PKE}.\\mathsf{Encrypt}(\\mathbf{1}^{\\lambda},\\mathsf{PK},m_{\\sigma});</span>$</p>

    <p class="text-gray-300">and responds with the &quot;target&quot; ciphertext ψ ∗ .</p>

    <p class="text-gray-300">Stage 4: The adversary continues to make calls to the decryption oracle, subject only to the restriction that a submitted ciphertext ψ is not identical to ψ ∗ .</p>

    <p class="text-gray-300">Again, we emphasize that ψ is arbitrary, and may even be computed by A as a function of ψ ∗ .</p>

    <p class="text-gray-300">Stage 5: The adversary outputs ˆσ ∈ {0, 1}.</p>

    <p class="text-gray-300">We define the CCA advantage of A against PKE at λ, denoted AdvCCAPKE,A(λ), to be |Pr[σ = ˆσ] − 1/2| in the above attack game.</p>

    <p class="text-gray-300">We say that PKE is secure against adaptive chosen ciphertext attack if</p>

    <p class="text-gray-300">for all probabilistic, polynomial-time oracle query machines A, the function AdvCCAPKE,A(λ) grows negligibly in λ.</p>

    <h2 id="sec-9" class="text-2xl font-bold">3.3 Application of the definition of security</h2>

    <p class="text-gray-300">In applying the above definition of security, one typically works directly with the quantity</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{AdvCCA&#x27;_{PKE,A}}(\\lambda) := \\left| \\Pr[\\hat{\\sigma} = 1 \\mid \\sigma = 0] - \\Pr[\\hat{\\sigma} = 1 \\mid \\sigma = 1] \\right|.</span>$</p>

    <p class="text-gray-300">If we view A as a statistical test, then the quantity AdvCCA&lt;sup&gt;0&lt;/sup&gt; PKE,A(λ) measures A's advantage in distinguishing a game in which m&lt;sup&gt;0&lt;/sup&gt; is always encrypted from a game in which m&lt;sup&gt;1&lt;/sup&gt; is always encrypted. It is easy to verify that</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{AdvCCA}&#x27;_{\\mathsf{PKE},\\mathsf{A}}(\\lambda) = 2 \\cdot \\mathsf{AdvCCA}_{\\mathsf{PKE},\\mathsf{A}}(\\lambda).</span>$</p>

    <p class="text-gray-300">We present here a sketch of another characterization of this notion of security that illustrates more fully its utility in reasoning about the security of higher-level protocols. This alternative characterization is a natural, high level, simulation-based definition that in some ways provides a justification for the rather low level, technical definition given above. Our treatment here will be somewhat less formal than elsewhere in this paper.</p>

    <p class="text-gray-300">We start by defining the notion of a channel, which is an object that implements the following operations:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>KeyGen outputs a public key PK.</li>
      <li>Encrypt takes as input a message m, and outputs a ciphertext ψ.</li>
      <li>Decrypt takes as input a ciphertext ψ, and outputs a message m (possibly a special reject symbol).</li>
    </ul>

    <p class="text-gray-300">Additionally, a channel is parameterized by a security parameter λ.</p>

    <p class="text-gray-300">To initialize a channel, the KeyGen operation is invoked, after which, an arbitrary number of Encrypt and Decrypt operations may be invoked. We shall assume that messages are arbitrary bit strings.</p>

    <p class="text-gray-300">A channel may be implemented in several ways. One way, of course, is to simply &quot;plug in&quot; a public-key encryption scheme. We call such an implementation of a channel a real channel. We wish to describe another implementation, which we call an ideal channel.</p>

    <p class="text-gray-300">Loosely speaking, an ideal channel acts essentially like a private storage and retrieval service: when an Encrypt operation is invoked with a message m, the ideal channel generates a corresponding ciphertext ψ without even &quot;looking&quot; at m, and stores the pair (m, ψ) in a table; when a Decrypt operation is invoked with a ciphertext ψ such that (m, ψ) is in the table for some m, the ideal channel returns the message m. Thus, the &quot;encryption&quot; ψ of a message m is completely independent of m, and essentially plays the role of a &quot;receipt,&quot; presentation of which to the Decrypt operation yields the message m. As such, the Encrypt operation might be better named Store, and the Decrypt operation Retrieve.</p>

    <p class="text-gray-300">We now describe the operation of an ideal channel in a bit more detail.</p>

    <p class="text-gray-300">An ideal channel is built using a channel simulator. A channel simulator is an object that implements an interface that is identical to that of a channel, except that the Encrypt operation does not take as input a message, but rather just the length of a message.</p>

    <p class="text-gray-300">An ideal channel uses a channel simulator as follows. The KeyGen operation of the ideal channel is implemented directly in terms of the KeyGen operation of the channel simulator. The ideal channel maintains a set S of message/ciphertext pairs (m, ψ) and a set T of ciphertexts, both initially empty.</p>

    <p class="text-gray-300">When the Encrypt operation of the ideal channel is invoked with input m, the ideal channel invokes the channel simulator with input |m|, obtaining a ciphertext ψ. If ψ ∈ T or (m&lt;sup&gt;0&lt;/sup&gt; , ψ) ∈ S</p>

    <p class="text-gray-300">for some m&lt;sup&gt;0&lt;/sup&gt; , the ideal channel becomes &quot;broken,&quot; and this and all subsequent invocations of either Encrypt or Decrypt return a special symbol indicating this; otherwise, the ideal channel adds the pair (m, ψ) to S and returns ψ as the result of the Encrypt operation.</p>

    <p class="text-gray-300">When the Decrypt operation of the ideal channel is invoked with input ψ, the ideal channel first checks if (m, ψ) ∈ S for some m; if so, it simply returns the message m; otherwise, it adds ψ to T, invokes the Decrypt operation of the channel simulator to obtain m, and returns m.</p>

    <p class="text-gray-300">That completes the description of how an ideal channel is implemented using a channel simulator.</p>

    <p class="text-gray-300">Now we define a notion of security based on the indistinguishability of real and ideal channels for a public-key encryption scheme PKE with an unrestricted message space. Consider a game in which a polynomial-time probabilistic adversary A interacts with an arbitrary number of channels, and at the end of the game, outputs a 0 or 1. We say that PKE is secure in the sense of channel indistinguishability if there exists an efficient channel simulator such that for the resulting ideal channel, A cannot effectively distinguish between a game played with all real channels and a game played with all ideal channels; i.e., the absolute difference between the probabilities that A outputs a 1 in the two games grows negligibly in the security parameter.</p>

    <p class="text-gray-300">Note that since real channels never become broken, this definition of security implies that ideal channels become broken with only negligible probability.</p>

    <p class="text-gray-300">It straightforward to show that if PKE is secure against adaptive chosen ciphertext attack, then it is also secure in the sense of channel indistinguishability. To prove this, the channel simulator is implemented using the KeyGen and Decrypt algorithms of PKE, and the Encrypt operation of the channel simulator on input <code>simply runs the Encrypt algorithm of PKE on input 1</code> . We leave it to the reader to verify that the resulting ideal channel is indistinguishable from the real channel. This is essentially just a standard &quot;hybrid&quot; argument.</p>

    <p class="text-gray-300">In analyzing a higher-level protocol, one may substitute all real channels by ideal channels. Presumably, it is much more straightforward to then analyze the resulting idealized protocol, since in the idealized protocol, ciphertexts are just &quot;receipts&quot; that are completely independent of the corresponding messages. Security implies that any (polynomial-time recognizable) event in the original protocol occurs with essentially the same probability in the idealized protocol.</p>

    <p class="text-gray-300">The definition of security we have presented here is from [RS91]. It is called IND-CCA2 in [BDPR98]. It is known to be equivalent to other notions, such as non-malleability [DDN91, BDPR98, DDN00], which is called NM-CCA2 in [BDPR98].</p>

    <p class="text-gray-300">There are other, weaker notions of security for a public-key encryption scheme. For example, [NY90] define a notion that is sometimes called security against indifferent chosen ciphertext attack, or security against lunchtime attack. This definition of security is exactly the same as the one above in §3.2, except that Stage 4 of the attack is omitted — that is, the adversary does not have access to the decryption oracle after it obtains the target ciphertext. While this notion of security may seem natural, it is actually not sufficient in many applications. This notion is called IND-CCA1 in [BDPR98].</p>

    <p class="text-gray-300">An even weaker notion of security for a public-key encryption scheme is that of security against a passive attack, also known as semantic security. This definition of security is exactly the same as the one above in §3.2, except that both Stages 2 and 4 of the attack are omitted — that is, the adversary does not have access to the decryption oracle at all. This notion was introduced in [GM84] and is called IND-CPA in [BDPR98]. This notion of security is quite limited: it is only adequate in situations where the adversary only has the power to eavesdrop network traffic, but cannot modify network traffic or otherwise actively participate in a protocol using the encryption scheme.</p>

    <p class="text-gray-300">For a similar, but slightly different, approach to modeling encryption as an &quot;idealized&quot; process, see [Can00]. See also [BBM00] for another generalization of the definition of adaptive chosen ciphertext attack to a setting involving many users and messages.</p>

    <p class="text-gray-300">In this section, we recall the Discrete Logarithm (DL) assumption, the Computational Diffie-Hellman (CDH) assumption, and the Decisional Diffie-Hellman (DDH) assumption. All of these assumptions are formulated with respect to a suitable group G of large prime order q generated by a given element g.</p>

    <pre><code class="language-text">Informally, the DL assumption is this:
</code></pre>

    <pre><code class="language-text">given g^x and g^y for random x, y \\in \\mathbf{Z}_q, it is hard to compute g^{xy}.
</code></pre>

    <p class="text-gray-300">Informally, the CDH assumption is this:</p>

    <pre><code class="language-text">given g^x and g^y for random x, y \\in \\mathbf{Z}_q, it is hard to compute g^{xy}.
</code></pre>

    <p class="text-gray-300">Informally, the DDH assumption is this:</p>

    <pre><code class="language-text">it is hard to distinguish triples of the form (g^x, g^y, g^z) for random x, y, z \\in \\mathbf{Z}_q from triples of the form (g^x, g^y, g^{xy}) for random x, y \\in \\mathbf{Z}_q.
</code></pre>

    <p class="text-gray-300">The rest of this section is devoted to describing these assumptions more formally, discussing appropriate groups, and discussing some variations and consequences of these assumptions.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">4.1 Computational group schemes</h4>

    <p class="text-gray-300">To state these intractability assumptions in a general but precise way, and in an appropriate asymptotic setting, we introduce the notion of a <em>computational group scheme</em>.</p>

    <p class="text-gray-300">A computational group scheme  <span class="math">\\mathcal{G}</span>  specifies a sequence  <span class="math">(\\mathbf{S}_{\\lambda})_{\\lambda \\in \\mathbf{Z}_{\\geq 0}}</span>  of group distributions. For every value of a security parameter  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> ,  <span class="math">\\mathbf{S}_{\\lambda}</span>  is a probability distribution of group descriptions. A group description  <span class="math">\\Gamma</span>  specifies a finite abelian group  <span class="math">\\hat{G}</span> , along with a prime-order subgroup G, a generator g of G, and the order g of G. We use multiplicative notation for the group operation in  <span class="math">\\hat{G}</span> , and we denote the identity element of  <span class="math">\\hat{G}</span>  by  <span class="math">1_G</span> .</p>

    <p class="text-gray-300">We will write  <span class="math">\\Gamma[\\hat{G}, G, g, q]</span>  to indicate that  <span class="math">\\Gamma</span>  specifies  <span class="math">\\hat{G}, G, g</span> , and q as above. As a simple example of this notation: &quot;for all  <span class="math">\\lambda \\in \\mathbf{Z}_{&gt;0}</span> , for all  <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span> , we have  <span class="math">g^q = 1_G</span> .&quot;</p>

    <p class="text-gray-300">As usual, mathematical objects like a group description  <span class="math">\\Gamma</span>  and elements of a group  <span class="math">\\hat{G}</span>  are represented for computational purposes as bit strings bounded in length by a polynomial in  <span class="math">\\lambda</span> . The interpretation of these bit strings is up to the algorithms comprising the group scheme (see below). However, we require that the encoding scheme used to represent group elements as bit strings be canonical; that is, every element of a group  <span class="math">\\hat{G}</span>  has a unique binary encoding.</p>

    <p class="text-gray-300">The group scheme should also provide several algorithms:</p>

    <p class="text-gray-300">• a deterministic, polynomial-time algorithm for computing the group operation that takes as input  <span class="math">\\mathbf{1}^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> ,  <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span> , along with  <span class="math">h_1, h_2 \\in \\hat{G}</span> , and outputs the group element  <span class="math">h_1 \\cdot h_2 \\in \\hat{G}</span> ;</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>a deterministic, polynomial-time algorithm for computing the group inversion operation that takes as input  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> ,  <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span> , and  <span class="math">h \\in \\hat{G}</span> , and outputs  <span class="math">h^{-1} \\in \\hat{G}</span> ;</li>
      <li>a deterministic, polynomial-time algorithm that takes as input  <span class="math">\\mathbf{1}^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> ,  <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span> , and  <span class="math">\\alpha \\in \\{0, 1\\}^*</span> , and determines if  <span class="math">\\alpha</span>  is a valid binary encoding of an element of  <span class="math">\\hat{G}</span> ;</li>
      <li>a deterministic, polynomial-time algorithm that takes as input  <span class="math">\\mathbf{1}^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> ,  <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span> , and  <span class="math">h \\in \\hat{G}</span> , and determines if  <span class="math">h \\in G</span> ;</li>
      <li>a deterministic, polynomial-time algorithm that takes as input  <span class="math">\\mathbf{1}^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> ,  <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span> , and outputs g and q.</li>
      <li>a probabilistic, polynomial-time approximate sampling algorithm  <span class="math">\\hat{S}</span>  that on input  <span class="math">\\mathbf{1}^{\\lambda}</span>  approximately samples  <span class="math">\\mathbf{S}_{\\lambda}</span> . The distributions  <span class="math">\\mathbf{S}_{\\lambda}</span>  and  <span class="math">\\hat{S}(\\mathbf{1}^{\\lambda})</span>  should be statistically close; that is, the statistical distance  <span class="math">\\Delta(\\mathbf{S}_{\\lambda}, \\hat{S}(\\mathbf{1}^{\\lambda}))</span>  should be a negligible function in  <span class="math">\\lambda</span> .</li>
    </ul>

    <p class="text-gray-300">Notice that we do not require that the output distribution  <span class="math">\\hat{S}(1^{\\lambda})</span>  of the sampling algorithm is identical to  <span class="math">\\mathbf{S}_{\\lambda}</span> , but only that the distributions have a negligible statistical distance. In particular, not all elements of  <span class="math">[\\hat{S}(1^{\\lambda})]</span>  are necessarily valid group descriptions. It would be impractical to require that these two distributions are identical.</p>

    <p class="text-gray-300">Note that the requirement that the group order be easily computable from the group description is not a trivial requirement: it is easy to exhibit groups whose orders are not easy to compute, e.g., subgroups of  <span class="math">\\mathbf{Z}_n^*</span>  for composite n.</p>

    <p class="text-gray-300">The requirement that group elements have unique encodings is also an important, non-trivial requirement. It is easy to exhibit quotient groups in which the problem of computing canonical representatives of residue classes is non-trivial. An example of this is the group underlying Paillier's encryption scheme [Pai99].</p>

    <p class="text-gray-300">Let  <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span> . The value  <span class="math">1_G</span>  may be directly encoded in  <span class="math">\\Gamma</span> , but if not, we can always compute it as  <span class="math">g \\cdot g^{-1}</span> .</p>

    <p class="text-gray-300">Although we will not require it, typical group schemes will have the property that for all  <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span> , the only elements of  <span class="math">\\hat{G}</span>  of order q lie in G. When this is the case, testing whether a given  <span class="math">h \\in \\hat{G}</span>  lies in the subgroup G can be implemented by testing if  <span class="math">h^q = 1_G</span> . However, a group scheme may provide a more efficient subgroup test.</p>

    <p class="text-gray-300">Let  <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span> . For  <span class="math">a \\in G \\setminus \\{1_G\\}</span>  and  <span class="math">b \\in G</span> , we denote by  <span class="math">\\log_a b</span>  the discrete logarithm of b to the base a; that is,  <span class="math">\\log_a b</span>  is the unique element  <span class="math">x \\in \\mathbf{Z}_q</span>  such that  <span class="math">b = a^x</span> .</p>

    <p class="text-gray-300">As a notational convention, throughout this paper, the letters a-h (and decorated versions thereof) will denote elements of  <span class="math">\\hat{G}</span> , and the letters r-z (and decorated versions thereof) will denote elements of  <span class="math">\\mathbf{Z}_q</span> .</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">4.2 Examples of appropriate computational group schemes</h4>

    <p class="text-gray-300">There are several examples of computational group schemes that are appropriate for cryptographic applications.</p>

    <p class="text-gray-300">Example 1. Let  <span class="math">\\ell_1(\\lambda)</span>  and  <span class="math">\\ell_2(\\lambda)</span>  be polynomially bounded integer-valued functions in  <span class="math">\\lambda</span> , such that  <span class="math">1 &lt; \\ell_1(\\lambda) &lt; \\ell_2(\\lambda)</span>  for all  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> . It should be the case that the function  <span class="math">2^{-\\ell_1(\\lambda)}</span>  is negligible. For a given  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , the distribution  <span class="math">\\mathbf{S}_{\\lambda}</span>  is defined as the distribution of triples (q, p, g), where</p>

    <p class="text-gray-300">• q is a random  <span class="math">\\ell_1(\\lambda)</span> -bit prime,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>p is a random  <span class="math">\\ell_2(\\lambda)</span> -bit prime with  <span class="math">p \\equiv 1 \\pmod{q}</span> , and</li>
      <li>g is a random generator of G, the unique subgroup of order q of the cyclic group  <span class="math">\\hat{G} = \\mathbf{Z}_{p}^{*}</span> .</li>
    </ul>

    <p class="text-gray-300">Elements in  <span class="math">\\mathbf{Z}_p^*</span>  can be encoded canonically as bit strings of length  <span class="math">\\ell_2(\\lambda)</span> . Group operations in  <span class="math">\\mathbf{Z}_p^*</span>  are efficiently implemented using arithmetic modulo p, and group inversion is implemented using the extended Euclidean algorithm. To test if an element  <span class="math">(\\alpha \\mod p) \\in \\mathbf{Z}_p^*</span>  lies in G, we can test if  <span class="math">\\alpha^q \\equiv 1 \\pmod{p}</span> .</p>

    <p class="text-gray-300">A random generator g of G may be obtained by generating a random element in  <span class="math">\\mathbb{Z}_p^*</span>  and raising it to the power (p-1)/q (repeating if necessary if this yields  <span class="math">(1 \\mod p)</span> ).</p>

    <p class="text-gray-300">The sampling algorithm  <span class="math">\\hat{S}</span>  may use standard, practical algorithms for primality testing that may err with a small probability that grows negligibly in  <span class="math">\\lambda</span> . See, e.g., [BS96] for more information on primality testing. Not all elements of  <span class="math">[\\hat{S}(1^{\\lambda})]</span>  are valid group descriptions. Moreover, depending on other aspects of the implementation, the distribution on the valid group descriptions may also be slightly skewed away from  <span class="math">\\mathbf{S}_{\\lambda}</span> . In our formulation of various intractability assumptions, it is much more convenient to work with the natural distribution  <span class="math">\\mathbf{S}_{\\lambda}</span>  than the more awkward distribution  <span class="math">\\hat{S}(1^{\\lambda})</span> .</p>

    <p class="text-gray-300">We should comment the density of primes p such that  <span class="math">p \\equiv 1 \\pmod{q}</span>  has never been proven to be sufficiently large to ensure fast termination of the group generation algorithm. Dirichlet's Theorem on primes in arithmetic progressions only applies to the case where q is fixed relative to p. However, provided  <span class="math">\\ell_2(\\lambda) \\geq (2+\\delta)\\ell_1(\\lambda)</span>  for some fixed  <span class="math">\\delta &gt; 0</span> , for any  <span class="math">\\ell_1(\\lambda)</span> -bit prime q, the probability that a random  <span class="math">\\ell_2(\\lambda)</span> -bit number of the form qk+1 is prime is  <span class="math">\\Omega(1/\\ell_2(\\lambda))</span> , assuming the Extended Riemann Hypothesis (ERH). This follows from Theorem 8.8.18 in [BS96].</p>

    <p class="text-gray-300">If the density of primes p such that  <span class="math">p \\equiv 1 \\pmod{q}</span>  cannot be proven to be sufficiently large to ensure fast termination of the group generation algorithm, even assuming the ERH, it may not be unreasonable to anyway conjecture that this is the case.</p>

    <p class="text-gray-300">Example 2. This is the same as Example 1, except that p = 2q + 1, where q is a random  <span class="math">\\ell_1(\\lambda)</span> -bit prime. Such a prime q is known as a Sophie Germain prime. It is unknown if there exist infinitely many Sophie Germain primes. However, it is conjectured that there are, and specific conjectures on their density have been made [BH62, BH65] that empirically seem to be valid. In particular, it is conjectured that the probability that a random  <span class="math">\\ell_1(\\lambda)</span> -bit number is a Sophie Germain prime is  <span class="math">\\Omega(1/\\ell_1(\\lambda)^2)</span> . If such a density estimate were true, then a simple trial and error method for finding Sophie Germain primes would terminate quickly. See [CS00] for more information on efficiently generating such primes.</p>

    <p class="text-gray-300">Since the subgroup G of  <span class="math">\\mathbf{Z}_p^*</span>  of order q is just the subgroup of quadratic residues, testing if a given element  <span class="math">(\\alpha \\bmod p) \\in \\mathbf{Z}_p^*</span>  lies in G can be performed by computing the Legendre symbol  <span class="math">(\\alpha \\mid p)</span> , which is generally much more efficient than computing  <span class="math">\\alpha^q \\bmod p</span> .</p>

    <p class="text-gray-300">A nice property of this construction is that the numbers  <span class="math">\\{1, \\ldots, q\\}</span>  are easily encoded as elements of G. Given  <span class="math">\\alpha \\in \\{1, \\ldots, q\\}</span> , we test if  <span class="math">(\\alpha \\mid p) = 1</span> , if so, then we encode  <span class="math">\\alpha</span>  as  <span class="math">(\\alpha \\mod p) \\in G</span> , and otherwise, we encode  <span class="math">\\alpha</span>  as  <span class="math">(-\\alpha \\mod p)</span> . Given a group element  <span class="math">h = (\\alpha \\mod p) \\in G</span>  with  <span class="math">1 \\le \\alpha \\le p - 1</span> , we decode h as  <span class="math">\\alpha</span>  if  <span class="math">\\alpha \\le q</span> , and otherwise, we decode h as  <span class="math">p - \\alpha</span> .</p>

    <p class="text-gray-300">This encoding scheme clearly allows us to also easily encode arbitrary bit strings of length  <span class="math">\\ell_1(\\lambda) - 1</span>  as elements of G.</p>

    <p class="text-gray-300">Example 3. One can also construct G as a prime order subgroup of an elliptic curve over a finite field. Elliptic curves and their application to cryptography is a very rich field, and we refer the reader to [BSS99] for an introduction and further references. We only note here that some of the same minor technical problems that arose above in Example 1 also arise here; namely, that (1) the</p>

    <p class="text-gray-300">known procedures for generating elliptic curves whose orders have a suitably large prime factor are somewhat heuristic, simply because not enough has been proven about how the order of a randomly generated elliptic curve factors into primes, and (2) it is in general not easy to encode arbitrary bit strings of a given length as points on an elliptic curve. We also note that it is fairly easy to generate elliptic curves of prime order so that we do not have to work in a sub-group, i.e., we can take  <span class="math">G = \\hat{G}</span> . This is useful, as then the sub-group test becomes trivial.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">4.3.1 The DL assumption</h3>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{G}</span>  be a computational group scheme, specifying a sequence  <span class="math">(\\mathbf{S}_{\\lambda})_{\\lambda \\in \\mathbf{Z}_{\\geq 0}}</span>  of group distributions. For all probabilistic, polynomial-time algorithms A, and for all  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , we define the DL advantage of A against  <span class="math">\\mathcal{G}</span>  at  <span class="math">\\lambda</span>  as</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{AdvDL}_{\\mathcal{G},\\mathsf{A}}(\\lambda) := \\Pr[\\ y = x : \\Gamma[\\hat{G}, G, g, q] \\overset{R}{\\leftarrow} \\mathbf{S}_{\\lambda}; \\ x \\overset{R}{\\leftarrow} \\mathbf{Z}_{q}; \\ y \\overset{R}{\\leftarrow} \\mathsf{A}(\\mathbf{1}^{\\lambda}, \\Gamma, g^{x}) \\ ].</span>$</p>

    <p class="text-gray-300">The DL assumption for  <span class="math">\\mathcal{G}</span>  is this:</p>

    <p class="text-gray-300">For every probabilistic, polynomial-time algorithm A, the function  <span class="math">AdvDL_{\\mathcal{G},A}(\\lambda)</span>  is negligible in  <span class="math">\\lambda</span> .</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">4.3.2 The CDH assumption</h3>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{G}</span>  be a computational group scheme, specifying a sequence  <span class="math">(\\mathbf{S}_{\\lambda})_{\\lambda \\in \\mathbf{Z}_{\\geq 0}}</span>  of group distributions. For all probabilistic, polynomial-time algorithms A, and for all  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , we define the <em>CDH</em> advantage of A against  <span class="math">\\mathcal{G}</span>  at  <span class="math">\\lambda</span>  as</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{AdvCDH}_{\\mathcal{G},\\mathsf{A}}(\\lambda) := \\Pr[\\ c = g^{xy} : \\Gamma[\\hat{G},G,g,q] \\xleftarrow{R} \\mathbf{S}_{\\lambda}; \\ x,y \\xleftarrow{R} \\mathbf{Z}_q; \\ c \\xleftarrow{R} \\mathsf{A}(\\mathbf{1}^{\\lambda},\\Gamma,g^x,g^y) \\ ].</span>$</p>

    <p class="text-gray-300">The CDH assumption for  <span class="math">\\mathcal{G}</span>  is this:</p>

    <p class="text-gray-300">For every probabilistic, polynomial-time algorithm A, the function  <span class="math">AdvCDH_{\\mathcal{G},A}(\\lambda)</span>  is negligible in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">For all probabilistic, polynomial-time algorithms A, for all  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , and for all  <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span> , we define the <em>CDH advantage of</em> A <em>against</em>  <span class="math">\\mathcal{G}</span>  <em>at</em>  <span class="math">\\lambda</span>  <em>given</em>  <span class="math">\\Gamma</span>  as</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{AdvCDH}_{\\mathcal{G},\\mathsf{A}}(\\lambda\\mid\\Gamma) := \\Pr[\\ c = g^{xy} : x \\overset{\\scriptscriptstyle R}{\\leftarrow} \\mathbf{Z}_q; \\ y \\overset{\\scriptscriptstyle R}{\\leftarrow} \\mathbf{Z}_q; \\ c \\overset{\\scriptscriptstyle R}{\\leftarrow} \\mathsf{A}(\\mathtt{1}^\\lambda,\\Gamma,g^x,g^y) \\ ].</span>$</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">4.3.3 The DDH assumption</h4>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{G}</span>  be a computational group scheme, specifying a sequence  <span class="math">(\\mathbf{S}_{\\lambda})_{\\lambda \\in \\mathbf{Z}_{\\geq 0}}</span>  of group distributions. For all  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , and for all  <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span> , we define the sets  <span class="math">\\mathcal{D}_{\\lambda, \\Gamma}</span>  and  <span class="math">\\mathcal{T}_{\\lambda, \\Gamma}</span>  as follows:</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{D}_{\\lambda,\\Gamma} := \\{(g^x, g^y, g^{xy}) \\in G^3 : x, y \\in \\mathbf{Z}_q\\};</span>$</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{T}_{\\lambda,\\Gamma} := G^3.</span>$</p>

    <p class="text-gray-300">The set  <span class="math">\\mathcal{D}_{\\lambda,\\Gamma}</span>  is the set of &quot;Diffie-Hellman triples.&quot; Also, for  <span class="math">\\rho \\in G^3</span> , define  <span class="math">\\mathsf{DHP}_{\\lambda,\\Gamma}(\\rho) = 1</span>  if  <span class="math">\\rho \\in \\mathcal{D}_{\\lambda,\\Gamma}</span> , and otherwise, define  <span class="math">\\mathsf{DHP}_{\\lambda,\\Gamma}(\\rho) = 0</span> .</p>

    <p class="text-gray-300">For all 0/1-valued, probabilistic, polynomial-time algorithms A, and for all  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , we define the <em>DDH advantage of</em> A <em>against</em>  <span class="math">\\mathcal{G}</span>  <em>at</em>  <span class="math">\\lambda</span>  as</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathsf{AdvDDH}_{\\mathcal{G},\\mathsf{A}}(\\lambda) := \\\\ \\Big| \\Pr[\\ \\tau = 1 : \\Gamma \\xleftarrow{R} \\mathbf{S}_{\\lambda}; \\ \\rho \\xleftarrow{R} \\mathcal{D}_{\\lambda,\\Gamma}; \\ \\tau \\xleftarrow{R} \\mathsf{A}(\\mathbf{1}^{\\lambda},\\Gamma,\\rho) \\ ] - \\\\ \\Pr[\\ \\tau = 1 : \\Gamma \\xleftarrow{R} \\mathbf{S}_{\\lambda}; \\ \\rho \\xleftarrow{R} \\mathcal{T}_{\\lambda,\\Gamma}; \\ \\tau \\xleftarrow{R} \\mathsf{A}(\\mathbf{1}^{\\lambda},\\Gamma,\\rho) \\ ] \\Big| \\end{split}</span>$</p>

    <p class="text-gray-300">The DDH assumption for  <span class="math">\\mathcal{G}</span>  is this:</p>

    <p class="text-gray-300">For every probabilistic, polynomial-time, 0/1-valued algorithm A, the function  <span class="math">AdvDDH_{\\mathcal{G},A}(\\lambda)</span>  is negligible in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">For all 0/1-valued, probabilistic, polynomial-time algorithms A, for all  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , and all  <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span> , we define the <em>DDH advantage of</em> A <em>against</em>  <span class="math">\\mathcal{G}</span>  <em>at</em>  <span class="math">\\lambda</span>  <em>given</em>  <span class="math">\\Gamma</span>  as</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathsf{AdvDDH}_{\\mathcal{G},\\mathsf{A}}(\\lambda \\mid \\Gamma) := \\\\ \\Big| \\Pr[\\ \\tau = 1 : \\rho \\xleftarrow{R} \\mathcal{D}_{\\lambda,\\Gamma}; \\ \\tau \\xleftarrow{R} \\mathsf{A}(\\mathbf{1}^{\\lambda},\\Gamma,\\rho) \\ ] - \\\\ \\Pr[\\ \\tau = 1 : \\rho \\xleftarrow{R} \\mathcal{T}_{\\lambda,\\Gamma}; \\ \\tau \\xleftarrow{R} \\mathsf{A}(\\mathbf{1}^{\\lambda},\\Gamma,\\rho) \\ ] \\Big| \\end{split}</span>$</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">A minor variation</h4>

    <p class="text-gray-300">We will need the following variation on the DDH assumption.</p>

    <p class="text-gray-300">For all  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , for all  <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span> , and we define the sets  <span class="math">\\mathcal{D}&#x27;_{\\lambda, \\Gamma}</span>  and  <span class="math">\\mathcal{T}&#x27;_{\\lambda, \\Gamma}</span>  as follows:</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{D}&#x27;_{\\lambda,\\Gamma} := \\{g^x, g^y, g^{xy} : x, y \\in \\mathbf{Z}_q, x \\neq 0\\};</span>$</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{T}&#x27;_{\\lambda,\\Gamma} := \\{g^x, g^y, g^z : x, y, z \\in \\mathbf{Z}_q, x \\neq 0, z \\neq xy\\}.</span>$</p>

    <p class="text-gray-300">That is,  <span class="math">\\mathcal{D}&#x27;_{\\lambda,\\Gamma}</span>  is the set of triples  <span class="math">(\\hat{g}, a, \\hat{a}) \\in G^3</span> , such that  <span class="math">\\hat{g} \\neq 1_G</span>  and  <span class="math">\\log_g a = \\log_{\\hat{g}} \\hat{a}</span> , and  <span class="math">\\mathcal{T}&#x27;_{\\lambda,\\Gamma}</span>  is the set of triples  <span class="math">(\\hat{g}, a, \\hat{a}) \\in G^3</span> , such that  <span class="math">\\hat{g} \\neq 1_G</span>  and  <span class="math">\\log_g a \\neq \\log_{\\hat{g}} \\hat{a}</span> .</p>

    <p class="text-gray-300">It is easy to verify the following:</p>

    <p class="text-gray-300"><span class="math">$\\Delta(\\mathbf{U}(\\mathcal{D}_{\\lambda\\,\\Gamma}), \\mathbf{U}(\\mathcal{D}&#x27;_{\\lambda\\,\\Gamma})) \\leq 1/q; \\tag{1}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\Delta(\\mathbf{U}(\\mathcal{T}_{\\lambda,\\Gamma}), \\mathbf{U}(\\mathcal{T}&#x27;_{\\lambda,\\Gamma})) \\leq 2/q.</span>$
(2)</p>

    <p class="text-gray-300">For all 0/1-valued, probabilistic, polynomial-time algorithms A, and for all  <span class="math">\\lambda \\in \\mathbb{Z}_{&gt;0}</span> , we define</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathsf{AdvDDH}&#x27;_{\\mathcal{G},\\mathsf{A}}(\\lambda) := \\\\ \\Big| \\Pr[\\ \\tau = 1 : \\Gamma \\xleftarrow{R} \\mathbf{S}_{\\lambda}; \\ \\rho \\xleftarrow{R} \\mathcal{D}&#x27;_{\\lambda,\\Gamma}; \\ \\tau \\xleftarrow{R} \\mathsf{A}(\\mathbf{1}^{\\lambda},\\Gamma,\\rho) \\ ] - \\\\ \\Pr[\\ \\tau = 1 : \\Gamma \\xleftarrow{R} \\mathbf{S}_{\\lambda}; \\ \\rho \\xleftarrow{R} \\mathcal{T}&#x27;_{\\lambda,\\Gamma}; \\ \\tau \\xleftarrow{R} \\mathsf{A}(\\mathbf{1}^{\\lambda},\\Gamma,\\rho) \\ ] \\Big| \\end{split}</span>$</p>

    <p class="text-gray-300">For all 0/1-valued, probabilistic, polynomial-time algorithms A, for all  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , and for all  <span class="math">\\Gamma \\in [\\mathbf{S}_{\\lambda}]</span> , we define</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathsf{AdvDDH}_{\\mathcal{G},\\mathsf{A}}&#x27;(\\lambda \\mid \\Gamma) := \\\\ \\Big| \\mathrm{Pr}[\\ \\tau = 1 : \\rho \\xleftarrow{R} \\mathcal{D}_{\\lambda,\\Gamma}&#x27;; \\ \\tau \\xleftarrow{R} \\mathsf{A}(\\mathbf{1}^{\\lambda}, \\Gamma, \\rho) \\ ] - \\\\ \\mathrm{Pr}[\\ \\tau = 1 : \\rho \\xleftarrow{R} \\mathcal{T}_{\\lambda,\\Gamma}&#x27;; \\ \\tau \\xleftarrow{R} \\mathsf{A}(\\mathbf{1}^{\\lambda}, \\Gamma, \\rho) \\ ] \\Big| \\end{split}</span>$</p>

    <p class="text-gray-300">The inequalities (1) and (2) imply the following:</p>

    <p class="text-gray-300"><strong>Lemma 1</strong> For all 0/1-valued, probabilistic, polynomial-time algorithms A, for all  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , and for all  <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\left|\\mathsf{AdvDDH}_{\\mathcal{G},\\mathsf{A}}(\\lambda\\mid\\Gamma) - \\mathsf{AdvDDH}_{\\mathcal{G},\\mathsf{A}}&#x27;(\\lambda\\mid\\Gamma)\\right| \\leq 3/q.</span>$</p>

    <p class="text-gray-300">In particular, the DDH assumption holds for  <span class="math">\\mathcal G</span>  if and only if for every probabilistic, polynomial-time 0/1-valued algorithm A, the function  <span class="math">\\mathsf{AdvDDH}_{\\mathcal G}&#x27;(\\lambda)</span>  is negligible in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">In this section, we discuss the random self-reducibility property of the DDH problem, and its implications.</p>

    <p class="text-gray-300">The following lemma states the random self-reducibility property for the DDH problem.</p>

    <p class="text-gray-300"><strong>Lemma 2</strong> There exists a probabilistic, polynomial-time algorithm RSR such that for all  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , for all  <span class="math">\\Gamma \\in [\\mathbf{S}_{\\lambda}]</span> , and for all  <span class="math">\\rho \\in \\mathcal{T}_{\\lambda,\\Gamma}</span> , the distribution  <span class="math">\\mathsf{RSR}(\\mathbf{1}^{\\lambda},\\Gamma,\\rho)</span>  is  <span class="math">\\mathbf{U}(\\mathcal{D}_{\\lambda,\\Gamma})</span>  if  <span class="math">\\rho \\in \\mathcal{D}_{\\lambda,\\Gamma}</span> , and is  <span class="math">\\mathbf{U}(\\mathcal{T}_{\\lambda,\\Gamma})</span>  if  <span class="math">\\rho \\notin \\mathcal{D}_{\\lambda,\\Gamma}</span> .</p>

    <p class="text-gray-300">This was first observed by Stadler [Sta96], who needed the result to prove the security of a particular protocol, and later by Naor and Reingold [NR97], who also pointed out some of its broader implications.</p>

    <p class="text-gray-300">The algorithm RSR is very simple. Given  <span class="math">\\mathbf{1}^{\\lambda}</span> , the group description  <span class="math">\\Gamma[\\hat{G}, G, g, q]</span> , and  <span class="math">\\rho = (a, b, c) \\in G^3</span> , the algorithm computes  <span class="math">(a&#x27;, b&#x27;, c&#x27;) \\in G^3</span>  as follows:</p>

    <p class="text-gray-300"><span class="math">$r \\stackrel{R}{\\leftarrow} \\mathbf{Z}_q; \\ s \\stackrel{R}{\\leftarrow} \\mathbf{Z}_q; \\ t \\stackrel{R}{\\leftarrow} \\mathbf{Z}_q; \\ a&#x27; \\leftarrow a^r g^s; \\ b&#x27; \\leftarrow b g^t; \\ c&#x27; \\leftarrow c^r a^{rt} b^s g^{st}.</span>$</p>

    <p class="text-gray-300">The implication of this random self-reduction is that if Diffie-Hellman tuples can be efficiently distinguished from random tuples with a non-negligible advantage, then Diffie-Hellman tuples can be efficiently <em>recognized</em> with negligible error probability. More formally, we have the following:</p>

    <p class="text-gray-300"><strong>Lemma 3</strong> For every be a 0/1-valued, probabilistic, polynomial-time algorithm A, and every polynomial P (with integer coefficients, taking positive values on  <span class="math">\\mathbf{Z}_{\\geq 0}</span> ), there exists a 0/1-valued, probabilistic, polynomial-time algorithm  <span class="math">A_1</span>  such that for all  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , for all  <span class="math">\\Gamma \\in [\\mathbf{S}_{\\lambda}]</span> , for all  <span class="math">\\rho \\in \\mathcal{T}_{\\lambda,\\Gamma}</span> , and for all  <span class="math">\\kappa \\in \\mathbf{Z}_{\\geq 0}</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\textit{if} \\ \\mathsf{AdvDDH}_{\\mathcal{G},\\mathsf{A}}(\\lambda \\mid \\Gamma) \\geq 1/P(\\lambda), \\ \\textit{then} \\ \\Pr[\\mathsf{A}_1(\\mathtt{1}^\\lambda,\\Gamma,\\rho,\\mathtt{1}^\\kappa) \\neq \\mathsf{DHP}_{\\lambda,\\Gamma}(\\rho)] \\leq 2^{-\\kappa}.</span>$</p>

    <p class="text-gray-300">Lemma 3 follows from Lemma 2 using standard &quot;amplification&quot; techniques, making use of standard results on tail inequalities for the binomial distribution. Given  <span class="math">\\mathbf{1}^{\\lambda}</span> ,  <span class="math">\\Gamma</span> ,  <span class="math">\\rho</span> , and  <span class="math">\\mathbf{1}^{\\kappa}</span> , algorithm  <span class="math">\\mathsf{A}_1</span>  invokes algorithm  <span class="math">\\mathsf{A}</span>  as a subroutine  <span class="math">O(P(\\lambda)^2\\kappa)</span>  times with inputs  <span class="math">(\\mathbf{1}^{\\lambda}, \\Gamma, \\rho&#x27;)</span> , where each  <span class="math">\\rho&#x27; \\in \\mathcal{T}_{\\lambda,\\Gamma}</span>  is independently sampled from  <span class="math">\\mathsf{RSR}(\\mathbf{1}^{\\lambda}, \\Gamma, \\rho)</span> ; additionally, algorithm  <span class="math">\\mathsf{A}_1</span>  has to run algorithm  <span class="math">\\mathsf{A}</span>  as a subroutine  <span class="math">O(P(\\lambda)^2\\kappa)</span>  times to &quot;calibrate&quot;  <span class="math">\\mathsf{A}</span> , calculating an estimate of</p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\ \\tau = 1 : \\rho&#x27; \\xleftarrow{R} \\mathcal{T}_{\\lambda,\\Gamma}; \\ \\tau \\xleftarrow{R} \\mathsf{A}(\\mathsf{1}^{\\lambda},\\Gamma,\\rho&#x27;)\\ ].</span>$</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">4.4 Further discussion</h4>

    <p class="text-gray-300">It is clear that the DDH assumption is at least as strong as the CDH assumption, which in turn is at least as strong as the DL assumption.</p>

    <p class="text-gray-300">The CDH assumption was introduced informally by [DH76]. Since then, there have been many papers that deal with the DL and CDH assumptions, and cryptocraphic applications based on them. The DDH assumption appears to have first surfaced in the cryptographic literature in [Bra93], although as that paper notes, the DDH assumption is actually needed to prove the security of a number of previously proposed protocols. Indeed, the famous Diffie-Hellman key exchange cannot be proved secure in any reasonable and standard way just based on the CDH assumption: the DDH assumption (or some variant thereof) is required.</p>

    <p class="text-gray-300">The DDH assumption underpins a number of cryptographic applications. See, for example, the work of Stadler [Sta96] on publicly verifiable secret sharing, and the construction by Naor and Reingold [NR97] of pseudo-random functions. Also, the well-known encryption scheme of ElGamal [ElG85] relies on the DDH for its security against passive attacks (i.e., semantic security).</p>

    <p class="text-gray-300">One variant of the ElGamal scheme is as follows. Let G be a group of prime order q generated by an element g. The public key consists of a group element  <span class="math">h = g^z</span> , where  <span class="math">z \\in \\mathbf{Z}_q</span>  is chosen at random; the secret key is z. To encrypt a message m, where we assume that  <span class="math">m \\in G</span> , we compute</p>

    <p class="text-gray-300"><span class="math">$u \\stackrel{R}{\\leftarrow} \\mathbf{Z}_q; \\ a \\leftarrow g^u; \\ b \\leftarrow h^u; \\ c \\leftarrow b \\cdot m;</span>$</p>

    <p class="text-gray-300">to form a ciphertext  <span class="math">\\psi = (a, c)</span> . To decrypt such a ciphertext using the secret key, one computes</p>

    <p class="text-gray-300"><span class="math">$b \\leftarrow a^z</span>$
;  <span class="math">m \\leftarrow c \\cdot b^{-1}</span> ;</p>

    <p class="text-gray-300">to obtain the message m.</p>

    <p class="text-gray-300">It is a trivial exercise to show that the security of this encryption scheme against passive attack is equivalent to the DDH assumption. It is also easy to see that this scheme is completely insecure against adaptive chosen ciphertext attack: if (a, c) is an encryption of  <span class="math">m \\in G</span> , then for any  <span class="math">m&#x27; \\in G</span> ,  <span class="math">(a, c \\cdot m&#x27;)</span>  is an encryption of  <span class="math">m \\cdot m&#x27;</span> ; thus, one can submit  <span class="math">(a, c \\cdot m&#x27;)</span>  to the decryption oracle, obtaining  <span class="math">m \\cdot m&#x27;</span> , from which one then computes m.</p>

    <p class="text-gray-300">There are some very special families of elliptic curves for which the DDH assumption does not hold, but for which the CDH assumption still appears to stand [JN01]. How these results are to be interpreted is a bit unclear. One the one hand, perhaps they cast some doubt on the DDH assumption in general. On the other hand, perhaps they only illustrate that very specially crafted families of elliptic curves may exhibit some surprising security weaknesses, which would seem to counsel against using such special families of elliptic curves for cryptographic applications, and instead, to use generic, randomly generated elliptic curves; indeed, for another special class of elliptic curves, the DL assumption is false [Sma99].</p>

    <p class="text-gray-300">We refer the reader to two excellent surveys [MW00] and [Bon98]. The latter focuses exclusively on the DDH assumption, while the former discusses both the CDH and DDH assumptions.</p>

    <p class="text-gray-300">In this section, we define the notion of a target collision resistant hash function, which is a special kind of universal one-way hash function, tailored somewhat for our particular application.</p>

    <p class="text-gray-300">We informally summarize this section as follows. We shall be working with a group G of order q, and we want to hash tuples of group elements to elements of  <span class="math">\\mathbf{Z}_q</span> . For this purpose, we will use</p>

    <p class="text-gray-300">a family of keyed hash functions, such that given a randomly chosen tuple of group elements and randomly chosen hash function key, it is computationally infeasible to find a different tuple of group elements that hashes to the same value using the given hash key.</p>

    <p class="text-gray-300">Now the details.</p>

    <p class="text-gray-300">Let k be a fixed positive integer, and let  <span class="math">\\mathcal{G}</span>  be a computational group scheme, specifying a sequence  <span class="math">(\\mathbf{S}_{\\lambda})_{\\lambda \\in \\mathbf{Z}_{\\geq 0}}</span>  of group distributions.</p>

    <p class="text-gray-300">A k-ary group hashing scheme HF associated with  <span class="math">\\mathcal{G}</span>  specifies two items:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A family of <em>key spaces</em> indexed by  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>  and  <span class="math">\\Gamma \\in [\\mathbf{S}_{\\lambda}]</span> . Each such key space is a probability space on bit strings denoted by  <span class="math">\\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda,\\Gamma}</span> .    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>There must exist a probabilistic, polynomial-time algorithm whose output distribution on input  <span class="math">1^{\\lambda}</span>  and  <span class="math">\\Gamma</span>  is equal to  <span class="math">\\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda,\\Gamma}</span> .</li>
    </ul></li>
      <li>A family of hash functions indexed by  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> ,  <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span> , and  <span class="math">\\mathsf{hk} \\in [\\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda,\\Gamma}]</span> , where each such function  <span class="math">\\mathsf{HF}^{\\lambda,\\Gamma}_{\\mathsf{hk}}</span>  maps a k-tuple  <span class="math">\\rho \\in G^k</span>  of group elements to an element of  <span class="math">\\mathbf{Z}_q</span> .</li>
    </ul>

    <p class="text-gray-300">There must exist a deterministic, polynomial-time algorithm that on input  <span class="math">\\mathbf{1}^{\\lambda}</span> ,  <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span> ,  <span class="math">\\mathsf{hk} \\in [\\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda,\\Gamma}]</span> , and  <span class="math">\\rho \\in G^k</span> , outputs  <span class="math">\\mathsf{HF}^{\\lambda,\\Gamma}_{\\mathsf{hk}}(\\rho)</span> .</p>

    <p class="text-gray-300">Let A be a probabilistic, polynomial-time algorithm. For  <span class="math">\\lambda \\in \\mathbb{Z}_{&gt;0}</span> , we define</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathsf{AdvTCR}_{\\mathsf{HF},\\mathsf{A}}(\\lambda) := \\\\ &amp; \\Pr[\\ \\rho \\in G^k \\ \\land \\ \\rho \\neq \\rho^* \\ \\land \\ \\mathsf{HF}^{\\lambda,\\Gamma}_{\\mathsf{hk}}(\\rho^*) = \\mathsf{HF}^{\\lambda,\\Gamma}_{\\mathsf{hk}}(\\rho) : \\\\ &amp; \\Gamma[\\hat{G},G,g,q] \\overset{\\scriptscriptstyle R}{\\leftarrow} \\mathbf{S}_{\\lambda}; \\ \\rho^* \\overset{\\scriptscriptstyle R}{\\leftarrow} G^k; \\ \\mathsf{hk} \\overset{\\scriptscriptstyle R}{\\leftarrow} \\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda \\ \\Gamma}; \\ \\rho \\overset{\\scriptscriptstyle R}{\\leftarrow} \\mathsf{A}(\\mathbf{1}^{\\lambda},\\Gamma,\\rho^*,\\mathsf{hk}) \\ ]. \\end{split}</span>$</p>

    <p class="text-gray-300">The target collision resistance (TCR) assumption for HF is this:</p>

    <p class="text-gray-300">For every probabilistic, polynomial-time algorithm A, the function  <span class="math">AdvTCR_{HF,A}(\\lambda)</span>  is negligible in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">It will also be convenient to define the following. Let A be a probabilistic, polynomial-time algorithm. For  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>  and  <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span> , we define</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathsf{AdvTCR}_{\\mathsf{HF},\\mathsf{A}}(\\lambda \\mid \\Gamma) := \\\\ &amp; \\Pr[ \\ \\rho \\in G^k \\ \\land \\ \\rho \\neq \\rho^* \\ \\land \\ \\mathsf{HF}^{\\lambda,\\Gamma}_{\\mathsf{hk}}(\\rho^*) = \\mathsf{HF}^{\\lambda,\\Gamma}_{\\mathsf{hk}}(\\rho) : \\\\ &amp; \\rho^* \\xleftarrow{\\scriptscriptstyle{R}} G; \\ \\mathsf{hk} \\xleftarrow{\\scriptscriptstyle{R}} \\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda,\\Gamma}; \\ \\rho \\xleftarrow{\\scriptscriptstyle{R}} \\mathsf{A}(\\mathbf{1}^\\lambda,\\Gamma,\\rho^*,\\mathsf{hk}) \\ ]. \\end{split}</span>$</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">5.1 Further discussion</h3>

    <p class="text-gray-300">As already mentioned, our notion of a target collision resistant hash function is a special case of the more general notion of a universal one-way hash function, introduced by Naor and Yung [NY89]. In their presentation, the hash functions mapped bit strings to bit strings, but of course, using appropriate formatting, we can easily make such a function a map from tuples of elements of the group G to elements of  <span class="math">\\mathbf{Z}_q</span> . The notion of security presented in [NY89] was also slightly stronger than ours: in their paper, the first input to the hash function (i.e. the &quot;target&quot; input) is chosen adversarially, but independent of the key of the hash function, whereas in our application, the target input is a random tuple of group elements.</p>

    <p class="text-gray-300">As was shown in [NY89], universal one-way hash functions can be built from arbitrary one-way permutations. This result was extended by [Rom90], who showed that universal one-way hash functions can be built (albeit less efficiently) from arbitrary one-way functions.</p>

    <p class="text-gray-300">In practice, to build a universal one-way hash function, one can use a dedicated cryptographic hash function, like SHA-1 [SHA95]. Constructions in [BR97] and [Sho00a] show how to build a general-purpose universal one-way hash function using the underlying compression function of SHA-1, assuming the latter is second pre-image collision resistant. Actually, in our application, since the target input is just a random tuple of group elements, it is not too unreasonable to simply use SHA-1 directly, without a key at all.</p>

    <p class="text-gray-300">Note that the notion of target collision resistance is both qualitatively and quantitatively weaker than the notion of (full) collision resistance, which is why we prefer to rely on the former rather than the latter. A <em>collision resistant</em> hash function is one where it is hard for an adversary to find two different inputs that hash to the same value; the difference between target collision resistance and collision resistance is that in the former, one of the two inputs is not under the control of the adversary, while in the latter, both inputs are under the control of the adversary.</p>

    <p class="text-gray-300">In this section, we present the basic version, CS1, of our new scheme.</p>

    <p class="text-gray-300">The scheme makes use of a computational group scheme  <span class="math">\\mathcal{G}</span>  as described in §4.1, defining a sequence  <span class="math">(\\mathbf{S}_{\\lambda})_{\\lambda \\in \\mathbf{Z}_{\\geq 0}}</span>  of distributions of group descriptions, and providing a sampling algorithm  <span class="math">\\hat{S}</span> , where the output distribution  <span class="math">\\hat{S}(\\mathbf{1}^{\\lambda})</span>  closely approximates  <span class="math">\\mathbf{S}_{\\lambda}</span> .</p>

    <p class="text-gray-300">The scheme also makes use of a tertiary group hashing scheme HF associated with  <span class="math">\\mathcal{G}</span> , as described in §5.</p>

    <p class="text-gray-300">The scheme is described in detail in Figure 1.</p>

    <p class="text-gray-300"><strong>Remark 1</strong> Note that this encryption scheme has a restricted message space: messages are elements of the group G. This limits to some degree the applicability of the scheme and the choice of group scheme; indeed, if one wants to encrypt arbitrary bit strings of some bounded length, then among the examples of group schemes discussed in  <span class="math">\\S4.2</span> , only Example 2, based on Sophie Germain primes, is suitable.</p>

    <p class="text-gray-300"><strong>Remark 2</strong> Note that in step <strong>D2</strong> of the decryption algorithm, we test if a,  <span class="math">\\hat{a}</span> , and c belong to the subgroup G. This test is essential to the security of the scheme. Although some group schemes may provide a more efficient method for performing these tests, in a typical implementation, one may have to compute  <span class="math">a^q</span> ,  <span class="math">\\hat{a}^q</span> , and  <span class="math">c^q</span> , testing that each of these is  <span class="math">1_G</span> .</p>

    <p class="text-gray-300"><strong>Remark 3</strong> Note that the key generation algorithm samples a group description  <span class="math">\\Gamma</span>  from  <span class="math">\\hat{S}(1^{\\lambda})</span> . However, in describing the encryption scheme, we assume that  <span class="math">\\Gamma</span>  is a valid group description. With negligible probability (in  <span class="math">\\lambda</span> ),  <span class="math">\\Gamma</span>  may not be a valid group description, in which case the behavior of the key generation, encryption, and decryption algorithms is implementation dependent.</p>

    <p class="text-gray-300"><strong>Remark 4</strong> It is straightforward to verify that this encryption scheme satisfies the basic requirements that any public key encryption scheme should satisfy, as described in §3.1. In particular, the <em>soundness</em> property will always hold when  <span class="math">\\Gamma</span>  is a valid group description.</p>

    <pre><code class="language-text">Key Generation: On input 1^{\\lambda} for \\lambda \\in \\mathbb{Z}_{\\geq 0}, compute
</code></pre>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp;\\Gamma[\\hat{G},G,g,q] \\overset{\\mathbb{R}}{\\leftarrow} \\hat{S}(\\mathbf{1}^{\\lambda}); \\text{ hk } \\overset{\\mathbb{R}}{\\leftarrow} \\text{HF.KeySpace}_{\\lambda,\\Gamma}; \\\\ &amp;w \\overset{\\mathbb{R}}{\\leftarrow} \\mathbf{Z}_q^*; \\ x_1,x_2,y_1,y_2,z_1,z_2 \\overset{\\mathbb{R}}{\\leftarrow} \\mathbf{Z}_q; \\\\ &amp;\\hat{g} \\leftarrow g^w; \\ e \\leftarrow g^{x_1}\\hat{g}^{x_2}; \\ f \\leftarrow g^{y_1}\\hat{g}^{y_2}; \\ h \\leftarrow g^{z_1}\\hat{g}^{z_2}; \\end{split}</span>$</p>

    <p class="text-gray-300">and output the public key  <span class="math">PK = (\\Gamma, hk, \\hat{g}, e, f, h)</span>  and the secret key  <span class="math">SK = (\\Gamma, hk, x_1, x_2, y_1, y_2, z_1, z_2)</span> .</p>

    <p class="text-gray-300"><strong>Encryption:</strong> Given  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbb{Z}_{&gt;0}</span> , a public key</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{PK} = (\\Gamma[\\hat{G}, G, g, q], \\mathsf{hk}, \\hat{g}, e, f, h) \\in [\\mathbf{S}_{\\lambda}] \\times [\\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda \\Gamma}] \\times G^4,</span>$</p>

    <p class="text-gray-300">along with a message  <span class="math">m \\in G</span> , compute</p>

    <p class="text-gray-300">E1:
<span class="math">$u \\stackrel{R}{\\leftarrow} \\mathbf{Z}_q</span>$
;
E2:  <span class="math">a \\leftarrow g^u</span> ;
E3:  <span class="math">\\hat{a} \\leftarrow \\hat{g}^u</span> ;
E4:  <span class="math">b \\leftarrow h^u</span> ;
E5:  <span class="math">c \\leftarrow b \\cdot m</span> ;
E6:  <span class="math">v \\leftarrow \\mathsf{HF}^{\\lambda,\\Gamma}_{\\mathsf{hk}}(a,\\hat{a},c)</span> ;
E7:  <span class="math">d \\leftarrow e^u f^{uv}</span> ;</p>

    <p class="text-gray-300">and output the ciphertext  <span class="math">\\psi = (a, \\hat{a}, c, d)</span> .</p>

    <p class="text-gray-300"><strong>Decryption:</strong> Given  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbb{Z}_{&gt;0}</span> , a secret key</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{SK} = (\\Gamma[\\hat{G}, G, g, q], \\mathsf{hk}, x_1, x_2, y_1, y_2, z_1, z_2) \\in [\\mathbf{S}_{\\lambda}] \\times [\\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda, \\Gamma}] \\times \\mathbf{Z}_q^6,</span>$</p>

    <p class="text-gray-300">along with a ciphertext  <span class="math">\\psi</span> , do the following.</p>

    <p class="text-gray-300"><strong>D1:</strong> Parse  <span class="math">\\psi</span>  as a 4-tuple  <span class="math">(a, \\hat{a}, c, d) \\in \\hat{G}^4</span> ; output reject and halt if  <span class="math">\\psi</span>  is not of this form.</p>

    <p class="text-gray-300"><strong>D2:</strong> Test if a,  <span class="math">\\hat{a}</span> , and c belong to G; output reject and halt if this is not the case.</p>

    <p class="text-gray-300"><strong>D3:</strong> Compute  <span class="math">v \\leftarrow \\mathsf{HF}^{\\lambda,\\Gamma}_{\\mathsf{hk}}(a,\\hat{a},c)</span> .</p>

    <p class="text-gray-300"><strong>D4:</strong> Test if  <span class="math">d = a^{x_1 + y_1 v} \\cdot \\hat{a}^{x_2 + y_2 v}</span> ; output reject and halt if this is not the case.</p>

    <p class="text-gray-300"><strong>D5:</strong> Compute  <span class="math">b \\leftarrow a^{z_1} \\hat{a}^{z_2}</span> .</p>

    <p class="text-gray-300"><strong>D6:</strong> Compute  <span class="math">m \\leftarrow c \\cdot b^{-1}</span> , and output m.</p>

    <p class="text-gray-300">Figure 1: The public-key encryption scheme CS1</p>

    <p class="text-gray-300"><strong>Remark 5</strong> Technically speaking, the output  <span class="math">\\psi</span>  of the encryption algorithm is actually a canonical binary encoding of the 4-tuple  <span class="math">(a, \\hat{a}, c, d) \\in G^4</span> . In particular, it is critical that for any two ciphertexts  <span class="math">\\psi&#x27; \\neq \\psi</span> , the parsing algorithm in step <strong>D1</strong> of the decryption algorithm should not output the same 4-tuple of group elements.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">6.2 Security analysis of the scheme</h3>

    <p class="text-gray-300">We shall prove that CS1 is secure against adaptive chosen ciphertext attack if the DDH assumption holds for  <span class="math">\\mathcal{G}</span>  and the TCR assumption holds for HF. However, we wish to state and prove a concrete security reduction. To this end, we need some auxiliary definitions.</p>

    <p class="text-gray-300">Suppose PKE is a public-key encryption scheme that uses a group scheme in the following natural way: on input  <span class="math">\\mathbf{1}^{\\lambda}</span> , the key generation algorithm runs the sampling algorithm of the group scheme on input  <span class="math">\\mathbf{1}^{\\lambda}</span> , yielding a group description  <span class="math">\\Gamma</span> . For a given probabilistic, polynomial-time oracle query machine A,  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , and group description  <span class="math">\\Gamma</span> , let us define  <span class="math">\\mathsf{AdvCCA}_{\\mathsf{PKE},\\mathsf{A}}(\\lambda \\mid \\Gamma)</span>  to be  <span class="math">\\mathsf{A}</span> 's advantage in an adaptive chosen ciphertext attack where the key generation algorithm uses the given value of  <span class="math">\\Gamma</span> , instead of running the sampling algorithm of the group scheme.</p>

    <p class="text-gray-300">For all probabilistic, polynomial-time oracle query machines A, for all  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , let  <span class="math">Q_{\\mathsf{A}}(\\lambda)</span>  be an upper bound on the number of decryption oracle queries made by A on input  <span class="math">1^{\\lambda}</span> . We assume that  <span class="math">Q_{\\mathsf{A}}(\\lambda)</span>  is a strict bound in the sense that it holds regardless of the probabilistic choices of A, and regardless of the responses to its oracle queries from its environment.</p>

    <p class="text-gray-300"><strong>Theorem 1</strong> If the DDH assumption holds for  <span class="math">\\mathcal{G}</span>  and the TCR assumption holds for HF, then CS1 is secure against adaptive chosen ciphertext attack.</p>

    <p class="text-gray-300">In particular, for all probabilistic, polynomial-time oracle query machines A, there exist probabilistic algorithms  <span class="math">A_1</span>  and  <span class="math">A_2</span> , whose running times are essentially the same as that of A, such that the following holds. For all  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , and all  <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span> , we have</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{AdvCCA}_{\\mathsf{CS1},\\mathsf{A}}(\\lambda \\mid \\Gamma) \\leq \\mathsf{AdvDDH}_{\\mathcal{G},\\mathsf{A}_1}(\\lambda \\mid \\Gamma) + \\mathsf{AdvTCR}_{\\mathsf{HF},\\mathsf{A}_2}(\\lambda \\mid \\Gamma) + (Q_{\\mathsf{A}}(\\lambda) + 4)/q. \\tag{3}</span>$</p>

    <p class="text-gray-300">The precise running times of algorithms  <span class="math">A_1</span>  and  <span class="math">A_2</span>  depend a good deal on details of the model of computation and on implementation details, and so we make no attempt to be more precise on this matter.</p>

    <p class="text-gray-300">Before continuing, we state the following simple but useful lemma, which we leave to the reader to verify.</p>

    <p class="text-gray-300"><strong>Lemma 4</strong> Let  <span class="math">U_1</span> ,  <span class="math">U_2</span> , and F be events defined on some probability space. Suppose that the event  <span class="math">U_1 \\wedge \\neg F</span>  occurs if and only if  <span class="math">U_2 \\wedge \\neg F</span>  occurs. Then  <span class="math">|\\Pr[U_1] - \\Pr[U_2]| \\leq \\Pr[F]</span> .</p>

    <p class="text-gray-300">To prove Theorem 1, let us fix a probabilistic, polynomial-time oracle query machine A, the value of the security parameter  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , and the group description  <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span> .</p>

    <p class="text-gray-300">The attack game is as described in §3.2. We now describe the relevant random variables to be considered in analyzing the adversary's attack.</p>

    <p class="text-gray-300">Suppose that the public key is  <span class="math">(\\Gamma, \\mathsf{hk}, \\hat{g}, e, f, h)</span>  and that the secret key is  <span class="math">(\\Gamma, \\mathsf{hk}, x_1, x_2, y_1, y_2, z_1, z_2)</span> . Let  <span class="math">w := \\log_q \\hat{g}</span> , and define  <span class="math">x, y, z \\in \\mathbf{Z}_q</span>  as follows:</p>

    <p class="text-gray-300"><span class="math">$x := x_1 + x_2 w</span>$
,  <span class="math">y := y_1 + y_2 w</span> ,  <span class="math">z := z_1 + z_2 w</span> .</p>

    <p class="text-gray-300">That is,  <span class="math">x = \\log_a e</span> ,  <span class="math">y = \\log_a f</span> , and  <span class="math">z = \\log_a h</span> .</p>

    <p class="text-gray-300">As a notational convention, whenever a particular ciphertext  <span class="math">\\psi</span>  is under consideration in some context, the following values are also implicitly defined in that context:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">a, \\hat{a}, b, c, d \\in G</span> , where  <span class="math">\\psi = (a, \\hat{a}, c, d)</span>  and  <span class="math">b := a^{z_1} \\hat{a}^{z_2}</span> ;</li>
      <li><span class="math">u, \\hat{u}, v, r, s, t \\in \\mathbf{Z}_q</span> , where</li>
    </ul>

    <p class="text-gray-300"><span class="math">$u := \\log_q a, \\ \\hat{u} := \\log_{\\hat{q}} \\hat{a}, \\ v := \\mathsf{HF}^{\\lambda,\\Gamma}_{\\mathsf{hk}}(a,\\hat{a},c), \\ r := \\log_q c, \\ s := \\log_q d</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$t := x_1 u + y_1 u v + x_2 \\hat{u} w + y_2 \\hat{u} v w.</span>$</p>

    <p class="text-gray-300">For the target ciphertext  <span class="math">\\psi^*</span> , we also denote by  <span class="math">a^*, \\hat{a}^*, b^*, c^*, d^* \\in G</span>  and  <span class="math">u^*, \\hat{u}^*, v^*, r^*, s^*, t^* \\in \\mathbf{Z}_q</span>  the corresponding values.</p>

    <p class="text-gray-300">The probability space defining the attack game is then determined by the following, mutually independent, random variables:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the coin tosses Coins of A;</li>
      <li>the values  <span class="math">hk, w, x_1, x_2, y_1, y_2, z_1, z_2</span>  generated by the key generation algorithm;</li>
      <li>the values  <span class="math">\\sigma \\in \\{0,1\\}</span>  and  <span class="math">u^* \\in \\mathbf{Z}_q</span>  generated by the encryption oracle.</li>
    </ul>

    <p class="text-gray-300">Let  <span class="math">G_0</span>  be the original attack game, let  <span class="math">\\hat{\\sigma} \\in \\{0,1\\}</span>  denote the output of A, and let  <span class="math">T_0</span>  be the event that  <span class="math">\\sigma = \\hat{\\sigma}</span>  in  <span class="math">G_0</span> , so that  <span class="math">AdvCCA_{CS1,A}(\\lambda \\mid \\Gamma) = |\\Pr[T_0] - 1/2|</span> .</p>

    <p class="text-gray-300">Our overall strategy for the proof is as follows. We shall define a sequence  <span class="math">\\mathbf{G}_1, \\mathbf{G}_2, \\ldots, \\mathbf{G}_\\ell</span>  of modified attack games. Each of the games  <span class="math">\\mathbf{G}_0, \\mathbf{G}_1, \\ldots, \\mathbf{G}_\\ell</span>  operates on the same underlying probability space. In particular, the public key and secret key of the cryptosystem, the coin tosses Coins of A, and the hidden bit  <span class="math">\\sigma</span>  take on <em>identical</em> values across all games. Only some of the rules defining how the environment responds to oracle queries differ from game to game. For any  <span class="math">1 \\leq i \\leq \\ell</span> , we let  <span class="math">T_i</span>  be the event that  <span class="math">\\sigma = \\hat{\\sigma}</span>  in game  <span class="math">\\mathbf{G}_i</span> . Our strategy is to show that for  <span class="math">1 \\leq i \\leq \\ell</span> , the quantity  <span class="math">|\\Pr[T_{i-1}] - \\Pr[T_i]|</span>  is negligible. Also, it will be evident from the definition of game  <span class="math">\\mathbf{G}_\\ell</span>  that  <span class="math">\\Pr[T_\\ell] = 1/2</span> , which will imply that  <span class="math">|\\Pr[T_0] - 1/2|</span>  is negligible.</p>

    <p class="text-gray-300">So that the overall structure of the proof is more transparent, we shall defer the proofs of all lemmas to the end of the proof of the theorem.</p>

    <p class="text-gray-300"><strong>Game G&lt;sub&gt;1&lt;/sub&gt;.</strong> We now modify game  <span class="math">G_0</span>  to obtain a new game  <span class="math">G_1</span> . These two games are identical, except for a small modification to the encryption oracle. Instead of using the encryption algorithm as given to compute the target ciphertext  <span class="math">\\psi^*</span> , we use a modified encryption algorithm, in which steps E4 and E7 are replaced by:</p>

    <p class="text-gray-300"><strong>E4':</strong>
<span class="math">$b \\leftarrow a^{z_1} \\hat{a}^{z_2}</span>$
;
<strong>E7':</strong>  <span class="math">d \\leftarrow a^{x_1+y_1v} \\cdot \\hat{a}^{x_2+y_2v}</span> .</p>

    <p class="text-gray-300">The change we have made is purely conceptual: the values of  <span class="math">b^*</span>  and  <span class="math">d^*</span>  are exactly the same in game  <span class="math">\\mathbf{G}_1</span>  as they were in  <span class="math">\\mathbf{G}_0</span> . Therefore,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[T_1] = \\Pr[T_0]. \\tag{4}</span>$</p>

    <p class="text-gray-300">Note that the encryption oracle now makes use of some components of the secret key, which is something the original encryption oracle does not do.</p>

    <p class="text-gray-300"><strong>Game G</strong>&lt;sub&gt;2&lt;/sub&gt;. We now modify game  <span class="math">G_1</span>  to obtain a new game  <span class="math">G_2</span> . We again modify the encryption oracle, replacing step <strong>E3</strong> of the encryption algorithm by</p>

    <p class="text-gray-300"><strong>E3':</strong>
<span class="math">$\\hat{u} \\stackrel{R}{\\leftarrow} \\mathbf{Z}_q \\setminus \\{u\\}; \\ \\hat{a} \\leftarrow \\hat{g}^{\\hat{u}}.</span>$</p>

    <p class="text-gray-300">Note that whereas in games  <span class="math">\\mathbf{G}_0</span>  and  <span class="math">\\mathbf{G}_1</span>  we had  <span class="math">u^* = \\hat{u}^*</span> , in game  <span class="math">\\mathbf{G}_2</span> ,  <span class="math">u^*</span>  and  <span class="math">\\hat{u}^*</span>  are nearly independent, being subject only to  <span class="math">u^* \\neq \\hat{u}^*</span> . However, observe that games  <span class="math">\\mathbf{G}_1</span>  and  <span class="math">\\mathbf{G}_2</span>  are the same, except that in game  <span class="math">\\mathbf{G}_1</span> , the triple  <span class="math">(\\hat{g}, a^*, \\hat{a}^*)</span>  is uniformly distributed in  <span class="math">\\mathcal{D}&#x27;_{\\lambda,\\Gamma}</span> , and in game  <span class="math">\\mathbf{G}_2</span> , the triple  <span class="math">(\\hat{g}, a^*, \\hat{a}^*)</span>  is uniformly distributed in  <span class="math">\\mathcal{T}&#x27;_{\\lambda,\\Gamma}</span> . Thus, any difference in behavior between these two games immediately yields a statistical test for the distinguishing Diffie-Hellman triple from non-Diffie-Hellman triples. More precisely, we have:</p>

    <p class="text-gray-300"><strong>Lemma 5</strong> There exists a probabilistic algorithm  <span class="math">A_1</span> , whose running time is essentially the same as that of A, such that</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[T_2] - \\Pr[T_1]| \\le \\mathsf{AdvDDH}_{\\mathcal{G},\\mathsf{A}_1}(\\lambda \\mid \\Gamma) + 3/q.</span>$
(5)</p>

    <p class="text-gray-300"><strong>Game G</strong>&lt;sub&gt;3&lt;/sub&gt;. In this game, we modify the <em>decryption</em> oracle in game  <span class="math">G_2</span>  to obtain a new game  <span class="math">G_3</span> . Instead of using the original decryption algorithm, we modify the decryption algorithm, replacing steps D4 and D5 with:</p>

    <p class="text-gray-300"><strong>D4':</strong> Test if  <span class="math">\\hat{a} = a^w</span>  and  <span class="math">d = a^{x+yv}</span> ; output reject and halt if this is not the case.</p>

    <p class="text-gray-300"><strong>D5':</strong>  <span class="math">b \\leftarrow a^z</span> .</p>

    <p class="text-gray-300">Note that the decryption oracle now make use of w, but does not make use of  <span class="math">x_1, y_2, y_1, y_2, z_1, z_2</span> , except indirectly through the values x, y, z.</p>

    <p class="text-gray-300">Now, let  <span class="math">R_3</span>  be the event that in game  <span class="math">G_3</span> , some ciphertext  <span class="math">\\psi</span>  is submitted to the decryption oracle that is rejected in step D4' but that would have passed the test in step D4.</p>

    <p class="text-gray-300">Note that if a ciphertext passes the test in <strong>D4</strong>′, it would also have passed the test in <strong>D4</strong>.</p>

    <p class="text-gray-300">It is clear that games  <span class="math">G_2</span>  and  <span class="math">G_3</span>  proceed identically until the event  <span class="math">R_3</span>  occurs. In particular, the event  <span class="math">T_2 \\wedge \\neg R_3</span>  and  <span class="math">T_3 \\wedge \\neg R_3</span>  are identical. So by Lemma 4, we have</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[T_3] - \\Pr[T_2]| \\le \\Pr[R_3],\\tag{6}</span>$</p>

    <p class="text-gray-300">and so it suffices to bound  <span class="math">Pr[R_3]</span> . We introduce auxiliary games  <span class="math">G_4</span>  and  <span class="math">G_5</span>  below to do this.</p>

    <p class="text-gray-300"><strong>Game G&lt;sub&gt;4&lt;/sub&gt;.</strong> This game is identical to game  <span class="math">G_3</span> , except for a small modification to the <em>encryption</em> oracle. We again modify the algorithm used by the encryption oracle, replacing step <strong>E5</strong> by</p>

    <p class="text-gray-300">E5':
<span class="math">$r \\stackrel{R}{\\leftarrow} \\mathbf{Z}_q</span>$
;  <span class="math">c \\leftarrow g^r</span> .</p>

    <p class="text-gray-300">It is clear by construction that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[T_4] = 1/2,\\tag{7}</span>$</p>

    <p class="text-gray-300">since in game  <span class="math">G_4</span> , the variable  <span class="math">\\sigma</span>  is never used at all, and so the adversary's output is independent of  <span class="math">\\sigma</span> .</p>

    <p class="text-gray-300">Define the event  <span class="math">R_4</span>  to be the event in game  <span class="math">\\mathbf{G}_4</span>  analogous to the event  <span class="math">R_3</span>  in game  <span class="math">G_3</span> ; that is,  <span class="math">R_4</span>  is the event that in game  <span class="math">\\mathbf{G}_4</span> , some ciphertext  <span class="math">\\psi</span>  is submitted to the decryption oracle that is rejected in step  <span class="math">\\mathbf{D}\\mathbf{4}&#x27;</span>  but that would have passed the test in step  <span class="math">\\mathbf{D}\\mathbf{4}</span> .</p>

    <p class="text-gray-300">We show that this modification has no effect; more precisely:</p>

    <p class="text-gray-300">Lemma 6 We have</p>

    <p class="text-gray-300"><span class="math">$\\Pr[T_4] = \\Pr[T_3], \\tag{8}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\Pr[R_4] = \\Pr[R_3]. \\tag{9}</span>$</p>

    <p class="text-gray-300"><strong>Game G&lt;sub&gt;5&lt;/sub&gt;.</strong> This game is the same as game  <span class="math">G_4</span> , except for the following modification.</p>

    <p class="text-gray-300">We modify the <em>decryption</em> oracle so that it applies the following <em>special rejection rule</em>: if the adversary submits a ciphertext  <span class="math">\\psi</span>  for decryption at a point in time after the encryption oracle has been invoked, such that  <span class="math">(a, \\hat{a}, c) \\neq (a^*, \\hat{a}^*, c^*)</span>  but  <span class="math">v = v^*</span> , then the decryption oracle immediately outputs reject and halts (before executing step  <span class="math">\\mathbf{D4}&#x27;</span> ).</p>

    <p class="text-gray-300">To analyze this game, we define two events.</p>

    <p class="text-gray-300">First, we define the event  <span class="math">C_5</span>  to be the event that the decryption oracle in game  <span class="math">\\mathbf{G}_5</span>  rejects a ciphertext using the special rejection rule.</p>

    <p class="text-gray-300">Second, we define the event  <span class="math">R_5</span>  to be the event in game  <span class="math">G_5</span>  that some ciphertext  <span class="math">\\psi</span>  is submitted to the decryption oracle that is rejected in step D4' but that would have passed the test in step D4. Note that such a ciphertext is not rejected by the special rejection rule, since that rule is applied before step D4' is executed.</p>

    <p class="text-gray-300">Now, it is clear that games  <span class="math">G_4</span>  and  <span class="math">G_5</span>  proceed identically until event  <span class="math">C_5</span>  occurs. In particular, the events  <span class="math">R_4 \\wedge \\neg C_5</span>  and  <span class="math">R_5 \\wedge \\neg C_5</span>  are identical. So by Lemma 4, we have</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[R_5] - \\Pr[R_4]| \\le \\Pr[C_5]. \\tag{10}</span>$</p>

    <p class="text-gray-300">Now, if event  <span class="math">C_5</span>  occurs with non-negligible probability, we immediately get an algorithm that contradicts the target collision resistance assumption; more precisely:</p>

    <p class="text-gray-300"><strong>Lemma 7</strong> There exists a probabilistic algorithm  <span class="math">A_2</span> , whose running time is essentially the same as that of A, such that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[C_5] \\le \\mathsf{AdvTCR}_{\\mathsf{HF},\\mathsf{A}_2}(\\lambda \\mid \\Gamma) + 1/q. \\tag{11}</span>$</p>

    <p class="text-gray-300">Finally, we show that event  <span class="math">R_5</span>  occurs with negligible probability, based on purely information-theoretic considerations:</p>

    <p class="text-gray-300">Lemma 8 We have</p>

    <p class="text-gray-300"><span class="math">$\\Pr[R_5] \\le Q_{\\mathsf{A}}(\\lambda)/q. \\tag{12}</span>$</p>

    <p class="text-gray-300">The detailed proof of this lemma is presented below. However, the basic idea of the proof runs as follows. For a decryption query  <span class="math">\\psi</span> , the only information the adversary has about  <span class="math">(x_1, x_2, y_1, y_2)</span>  are the values of x, y, and possibly  <span class="math">s^*</span> , which are linear combinations of  <span class="math">(x_1, x_2, y_1, y_2)</span> . As we will prove, the value of t, which the adversary must successfully guess in order to make the event  <span class="math">R_5</span>  happen, is an independent linear combination of  <span class="math">(x_1, x_2, y_1, y_2)</span> , and is therefore unpredictable.</p>

    <p class="text-gray-300">Inequality (3) now follows immediately from (4)-(12).</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6"><strong>Proofs of Lemmas</strong></h4>

    <p class="text-gray-300">To complete the proof of Theorem 1, we now present the proofs of Lemmas 5, 6, 7, and 8.</p>

    <p class="text-gray-300"><strong>Proof of Lemma 5.</strong> We describe the algorithm  <span class="math">A_1</span>  in detail. For a given value of  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , it takes as input  <span class="math">\\mathbf{1}^{\\lambda}</span> ,  <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span> , and  <span class="math">\\rho = (\\hat{g}, a^*, \\hat{a}^*) \\in G^3</span> .</p>

    <p class="text-gray-300">Algorithm  <span class="math">\\mathsf{A}_1</span>  provides an environment for  <span class="math">\\mathsf{A},</span>  interacting with  <span class="math">\\mathsf{A}</span>  as follows.</p>

    <p class="text-gray-300">First,  <span class="math">A_1</span>  computes</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{hk} \\xleftarrow{R} \\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda,\\Gamma}; \\ x_1, x_2, y_1, y_2, z_1, z_2 \\xleftarrow{R} \\mathbf{Z}_q; \\ e \\leftarrow g^{x_1} \\hat{g}^{x_2}; \\ f \\leftarrow g^{y_1} \\hat{g}^{y_2}; \\ h \\leftarrow g^{z_1} \\hat{g}^{z_2};</span>$</p>

    <p class="text-gray-300">to generate a public key  <span class="math">PK = (\\Gamma, hk, \\hat{g}, e, f, h)</span>  and a secret key  <span class="math">SK = (\\Gamma, hk, x_1, x_2, y_1, y_2, z_1, z_2)</span> . It then gives PK to A.</p>

    <p class="text-gray-300">Whenever A submits a ciphertext  <span class="math">\\psi = (a, \\hat{a}, c, d)</span>  to the decryption oracle,  <span class="math">A_1</span>  simply runs the decryption algorithm, using the secret key SK.</p>

    <p class="text-gray-300">When A submits  <span class="math">(m_0, m_1)</span>  to the encryption oracle,  <span class="math">A_1</span>  computes</p>

    <p class="text-gray-300"><span class="math">$\\sigma \\xleftarrow{R} \\{0,1\\}; \\ b^* \\leftarrow (a^*)^{z_1} (\\hat{a}^*)^{z_2}; \\ c^* \\leftarrow b^* \\cdot m_\\sigma; \\ v^* \\leftarrow \\mathsf{HF}^{\\lambda,\\Gamma}_{\\mathsf{hk}} (a^*,\\hat{a}^*,c^*); \\ d^* \\leftarrow (a^*)^{x_1 + y_1 v^*} (\\hat{a}^*)^{x_2 + y_2 v^*};</span>$</p>

    <p class="text-gray-300">and responds with the &quot;ciphertext&quot;  <span class="math">\\psi^* = (a^*, \\hat{a}^*, c^*, d^*)</span> .</p>

    <p class="text-gray-300">When A outputs  <span class="math">\\hat{\\sigma}</span>  and halts,  <span class="math">A_1</span>  outputs 1 if  <span class="math">\\sigma = \\hat{\\sigma}</span>  and 0 if  <span class="math">\\sigma \\neq \\hat{\\sigma}</span> .</p>

    <p class="text-gray-300">That completes the description of  <span class="math">A_1</span> . By construction, it is clear that for fixed  <span class="math">\\lambda</span>  and  <span class="math">\\Gamma \\in [\\mathbf{S}_{\\lambda}]</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[T_1] = \\Pr[\\tau = 1 : \\rho \\stackrel{R}{\\leftarrow} \\mathcal{D}&#x27;_{\\lambda,\\Gamma}; \\ \\tau \\stackrel{R}{\\leftarrow} \\mathsf{A}_1(\\mathsf{1}^{\\lambda}, \\Gamma, \\rho) \\ ];</span>$</p>

    <p class="text-gray-300"><span class="math">$\\Pr[T_2] = \\Pr[\\tau = 1 : \\rho \\stackrel{R}{\\leftarrow} \\mathcal{T}&#x27;_{\\lambda,\\Gamma}; \\ \\tau \\stackrel{R}{\\leftarrow} \\mathsf{A}_1(\\mathsf{1}^{\\lambda}, \\Gamma, \\rho) \\ ].</span>$</p>

    <p class="text-gray-300">Thus,</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[T_2] - \\Pr[T_1]| = \\mathsf{AdvDDH}_{\\mathcal{G},\\mathsf{A}_1}&#x27;(\\lambda \\mid \\Gamma),</span>$</p>

    <p class="text-gray-300">and so (5) now follows directly from this and Lemma 1.  <span class="math">\\ \\square</span></p>

    <p class="text-gray-300">Before continuing, we state and prove a simple but useful lemma.</p>

    <p class="text-gray-300"><strong>Lemma 9</strong> Let k, n be integers with  <span class="math">1 \\le k \\le n</span> , and let K be a finite field. Consider a probability space with random variables  <span class="math">\\vec{\\alpha} \\in K^{n \\times 1}</span> ,  <span class="math">\\vec{\\beta} = (\\beta_1, \\dots, \\beta_k)^T \\in K^{k \\times 1}</span> ,  <span class="math">\\vec{\\gamma} \\in K^{k \\times 1}</span> , and  <span class="math">M \\in K^{k \\times n}</span> , such that  <span class="math">\\vec{\\alpha}</span>  is uniformly distributed over  <span class="math">K^{n \\times 1}</span> ,  <span class="math">\\vec{\\beta} = M\\vec{\\alpha} + \\vec{\\gamma}</span> , and for  <span class="math">1 \\le i \\le k</span> , the ith rows of M and  <span class="math">\\vec{\\gamma}</span>  are determined by  <span class="math">\\beta_1, \\dots, \\beta_{i-1}</span> .</p>

    <p class="text-gray-300">Then conditioning on any fixed values of  <span class="math">\\beta_1, \\ldots, \\beta_{k-1}</span>  such that the resulting matrix M has rank k, the value of  <span class="math">\\beta_k</span>  is uniformly distributed over K in the resulting conditional probability space.</p>

    <p class="text-gray-300">Proof. Consider fixed values of  <span class="math">\\beta_1, \\ldots, \\beta_{k-1} \\in K</span> , which determine M and  <span class="math">\\vec{\\gamma}</span> , and assume that the matrix M has rank k. For any  <span class="math">\\beta_k \\in K</span> , consider the corresponding vector  <span class="math">\\vec{\\beta} = (\\beta_1, \\ldots, \\beta_k)^T</span> ; there are exactly  <span class="math">|K|^{n-k}</span>  vectors  <span class="math">\\vec{\\alpha}</span>  such that  <span class="math">\\vec{\\beta} = M\\vec{\\alpha} + \\vec{\\gamma}</span> . Therefore, each possible value  <span class="math">\\beta_k \\in K</span>  is equally likely.  <span class="math">\\square</span></p>

    <p class="text-gray-300">Proof of Lemma 6. Consider the quantity</p>

    <p class="text-gray-300"><span class="math">$X := (\\mathsf{Coins}, \\mathsf{hk}, w, x_1, x_2, y_1, y_2, \\sigma, u^*, \\hat{u}^*)</span>$</p>

    <p class="text-gray-300">and the quantity z. Note that X and z take on the same values in games  <span class="math">G_3</span>  and  <span class="math">G_4</span> .</p>

    <p class="text-gray-300">Consider also the quantity  <span class="math">r^*</span> . This quantity takes on different values in games  <span class="math">\\mathbf{G}_3</span>  and  <span class="math">\\mathbf{G}_4</span> . For clarity, let us denote these values as  <span class="math">[r^*]_3</span>  and  <span class="math">[r^*]_4</span> , respectively.</p>

    <p class="text-gray-300">It is clear by inspection that the events  <span class="math">R_3</span>  and  <span class="math">T_3</span>  are determined as functions of X, z, and  <span class="math">[r^*]_3</span> . Also, the events  <span class="math">R_4</span>  and  <span class="math">T_4</span>  have precisely the same functional dependence on X, z, and  <span class="math">[r^*]_4</span> . So to prove the lemma, it suffices to show that the distributions of  <span class="math">(X, z, [r^*]_3)</span>  and  <span class="math">(X, z, [r^*]_4)</span>  are identical. Observe that by construction, conditioning on any fixed values of X and z, the distribution of  <span class="math">[r^*]_4</span>  is uniform over  <span class="math">\\mathbf{Z}_q</span> . So it will suffice to show that conditioning on any fixed values of X and z, the distribution of  <span class="math">[r^*]_3</span>  is also uniform over  <span class="math">\\mathbf{Z}_q</span> .</p>

    <p class="text-gray-300">We have</p>

    <p class="text-gray-300"><span class="math">$\\begin{pmatrix} z \\\\ [r^*]_3 \\end{pmatrix} = \\underbrace{\\begin{pmatrix} 1 &amp; w \\\\ u^* &amp; w\\hat{u}^* \\end{pmatrix}}_{=: M} \\cdot \\begin{pmatrix} z_1 \\\\ z_2 \\end{pmatrix} + \\begin{pmatrix} 0 \\\\ \\log_g m_\\sigma \\end{pmatrix}.</span>$</p>

    <p class="text-gray-300">Conditioning only on a fixed value of X, the matrix M is fixed, but the values  <span class="math">z_1</span>  and  <span class="math">z_2</span>  are still uniformly and independently distributed over  <span class="math">\\mathbf{Z}_q</span> . Observe that  <span class="math">\\det(M) = w(\\hat{u}^* - u^*) \\neq 0</span> . If we further condition on a fixed value of z, the value of  <span class="math">m_{\\sigma}</span>  is fixed, and by Lemma 9, the distribution of  <span class="math">[r^*]_3</span>  is uniform over  <span class="math">\\mathbf{Z}_q</span> .  <span class="math">\\square</span></p>

    <p class="text-gray-300"><strong>Proof of Lemma 7.</strong> Algorithm  <span class="math">A_2</span>  provides an environment for A, interacting with A as follows. Algorithm  <span class="math">A_2</span>  takes as input  <span class="math">\\mathbf{1}^{\\lambda}</span> ,  <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span> ,  <span class="math">\\rho^* = (a^*, \\hat{a}^*, c^*) \\in G^3</span> , and  <span class="math">\\mathsf{hk} \\in [\\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda,\\Gamma}]</span> . It first constructs a public key PK and secret key SK for the encryption scheme using the standard key generation algorithm, except that the given values of  <span class="math">\\Gamma</span>  and  <span class="math">\\mathsf{hk}</span>  are used. It also constructs the target ciphertext  <span class="math">\\psi^* = (a^*, \\hat{a}^*, c^*, d^*)</span> , where  <span class="math">a^*, \\hat{a}^*, c^*</span>  are the given inputs as above, and where  <span class="math">d^*</span>  is computed as</p>

    <p class="text-gray-300"><span class="math">$v^* \\leftarrow \\mathsf{HF}^{\\lambda,\\Gamma}_{\\mathsf{hk}}(a^*, \\hat{a}^*, c^*); \\ d^* \\leftarrow (a^*)^{x_1 + y_1 v^*} (\\hat{a}^*)^{x_2 + y_2 v^*}.</span>$</p>

    <p class="text-gray-300">Here, hk is the given input as above, and  <span class="math">x_1, y_1, x_2, y_2</span>  are the values taken from the secret key SK as computed above.</p>

    <p class="text-gray-300">Now  <span class="math">A_2</span>  interacts with A using the rules of game  <span class="math">G_5</span>  for the decryption oracle, and giving A the target ciphertext  <span class="math">\\psi^*</span>  when A invokes the encryption oracle. However, if the decryption oracle ever invokes the special rejection rule in game  <span class="math">G_5</span>  for a given ciphertext  <span class="math">\\psi</span> , algorithm  <span class="math">A_2</span>  immediately outputs  <span class="math">(a, \\hat{a}, c)</span>  corresponding to  <span class="math">\\psi</span>  and halts. Also, if the attack terminates without the special rejection rule ever having been invoked, then  <span class="math">A_2</span>  also halts (without producing any output).</p>

    <p class="text-gray-300">That completes the description of  <span class="math">A_2</span> . If the input  <span class="math">(a^*, \\hat{a}^*, c^*)</span>  to  <span class="math">A_2</span>  is sampled uniformly over all triples of group elements, subject to  <span class="math">\\log_g a^* \\neq \\log_{\\hat{g}} \\hat{a}^*</span> , then algorithm  <span class="math">A_2</span>  succeeds in finding a collision with probability exactly  <span class="math">\\Pr[C_5]</span> . However, in the definition of  <span class="math">\\mathsf{AdvTCR}</span> , the input is sampled from the uniform distribution over all triples, not subject to the above restriction. The bound (11) follows from the fact that the statistical distance between these two input distributions is 1/q.  <span class="math">\\square</span></p>

    <p class="text-gray-300"><strong>Proof of Lemma 8.</strong> To prove (12), for  <span class="math">1 \\leq i \\leq Q_{\\mathsf{A}}(\\lambda)</span> , let us define  <span class="math">R_5^{(i)}</span>  to be the event that there is an <em>i</em>th ciphertext submitted to the decryption oracle in game  <span class="math">\\mathbf{G}_5</span> , and that the submitted ciphertext is rejected in step  <span class="math">\\mathbf{D4}&#x27;</span>  but would have passed the test in step  <span class="math">\\mathbf{D4}</span> . For  <span class="math">1 \\leq i \\leq Q_{\\mathsf{A}}(\\lambda)</span> , let us define  <span class="math">B_5^{(i)}</span>  to be the event that the <em>i</em>th decryption oracle query occurs before the encryption oracle query, and that the submitted ciphertext passes the test in steps  <span class="math">\\mathbf{D1}</span>  and  <span class="math">\\mathbf{D2}</span>  of the decryption oracle. For  <span class="math">1 \\leq i \\leq Q_{\\mathsf{A}}(\\lambda)</span> , let us define  <span class="math">\\hat{B}_5^{(i)}</span>  to be the event that the <em>i</em>th decryption oracle query occurs after the encryption oracle query, and that the submitted ciphertext passes the tests in steps  <span class="math">\\mathbf{D1}</span>  and  <span class="math">\\mathbf{D2}</span>  of the decryption oracle.</p>

    <p class="text-gray-300">The bound (12) will follow immediately from Lemmas 10 and 11 below.  <span class="math">\\Box</span></p>

    <p class="text-gray-300"><strong>Lemma 10</strong> Notation as in the proof of Lemma 8. For all  <span class="math">1 \\le i \\le Q_A(\\lambda)</span> , we have  <span class="math">\\Pr[R_5^{(i)}|B_5^{(i)}] \\le 1/q</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Fix  <span class="math">1 \\leq i \\leq Q_{\\mathsf{A}}(\\lambda)</span> . Consider the quantities</p>

    <p class="text-gray-300"><span class="math">$X := (\\mathsf{Coins}, \\mathsf{hk}, w, z)</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$X&#x27; := (x, y).</span>$</p>

    <p class="text-gray-300">The values of X and X' completely determine the behavior of the adversary up until the point when the encryption oracle is invoked, and in particular, they completely determine the event  <span class="math">B_5^{(i)}</span> . Let us call X and X' relevant if the event  <span class="math">B_5^{(i)}</span>  occurs.</p>

    <p class="text-gray-300">It will suffice prove that conditioned on any fixed, relevant values of X and X', the probability that  <span class="math">R_5^{(i)}</span>  occurs is bounded by 1/q.</p>

    <p class="text-gray-300">Once relevant values of X and X' are fixed, the value  <span class="math">\\psi</span>  of the ith decryption query is also fixed, along with the corresponding values  <span class="math">a, \\hat{a}, b, c, d, u, \\hat{u}, v, r</span> , and s.</p>

    <p class="text-gray-300">The test in  <span class="math">\\mathbf{D4}&#x27;</span>  fails if and only if one of the two mutually exclusive conditions  <span class="math">(\\hat{a} \\neq a^w)</span>  or  <span class="math">(\\hat{a} = a^w)</span>  and  <span class="math">d \\neq a^{x+yv}</span>  holds. It is easy to verify that if the second condition holds, then in fact the test in  <span class="math">\\mathbf{D4}</span>  fails. Thus, if the test in  <span class="math">\\mathbf{D4}&#x27;</span>  fails but that in  <span class="math">\\mathbf{D4}</span>  passes, it must be the case that  <span class="math">\\hat{a} \\neq a^w</span>  and  <span class="math">d = a^{x_1+y_1v}\\hat{a}^{x_2+y_2v}</span> . So we only need to consider values of X and X' such that  <span class="math">\\hat{a} \\neq a^w</span> . The condition  <span class="math">\\hat{a} \\neq a^w</span>  is equivalent to the condition  <span class="math">u \\neq \\hat{u}</span> , and the condition  <span class="math">d = a^{x_1+y_1v}\\hat{a}^{x_2+y_2v}</span>  is equivalent to the condition s = t.</p>

    <p class="text-gray-300">We have</p>

    <p class="text-gray-300"><span class="math">$\\begin{pmatrix} x \\\\ y \\\\ t \\end{pmatrix} = \\underbrace{\\begin{pmatrix} 1 &amp; w &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; w \\\\ u &amp; \\hat{u}w &amp; uv &amp; \\hat{u}vw \\end{pmatrix}}_{=:M} \\cdot \\begin{pmatrix} x_1 \\\\ x_2 \\\\ y_1 \\\\ y_2 \\end{pmatrix}.</span>$</p>

    <p class="text-gray-300">Let us first condition only on a fixed value of X, which fixes the first two rows of M, but leaves the values  <span class="math">x_1, x_2, y_1</span> , and  <span class="math">y_2</span>  still uniformly distributed over  <span class="math">\\mathbf{Z}_q</span>  and mutually independent. Let us further condition on a fixed value of X' such that X and X' are relevant, and that  <span class="math">u \\neq \\hat{u}</span> . The third row of M is also fixed, along with the values x, y, and s. It is easy to see by inspection that the rows of M are linearly independent, since  <span class="math">\\hat{u} \\neq u</span>  and  <span class="math">w \\neq 0</span> . From this, it follows by Lemma 9 that t is still uniformly distributed over  <span class="math">\\mathbf{Z}_q</span> , but since s is fixed, we have  <span class="math">\\Pr[s=t]=1/q</span> .  <span class="math">\\square</span></p>

    <p class="text-gray-300"><strong>Lemma 11</strong> Notation as in the proof of Lemma 8. For all  <span class="math">1 \\le i \\le Q_A(\\lambda)</span> , we have  <span class="math">\\Pr[R_5^{(i)}|\\hat{B}_5^{(i)}] \\le 1/q</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Fix  <span class="math">1 \\leq i \\leq Q_{\\mathsf{A}}(\\lambda)</span> . Consider the quantities</p>

    <p class="text-gray-300"><span class="math">$X := (\\mathsf{Coins}, \\mathsf{hk}, w, z, u^*, \\hat{u}^*, r^*)</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$X&#x27; := (x, y, s^*).</span>$</p>

    <p class="text-gray-300">The values of X and X' completely determine the adversary's entire behavior in game  <span class="math">\\mathbf{G}_5</span> , and in particular, they completely determine the event  <span class="math">\\hat{B}_5^{(i)}</span> . Let us call X and X' relevant if the event  <span class="math">\\hat{B}_5^{(i)}</span>  occurs.</p>

    <p class="text-gray-300">It will suffice prove that conditioned on any fixed, relevant values of X and X', the probability that  <span class="math">R_5^{(i)}</span>  occurs is bounded by 1/q.</p>

    <p class="text-gray-300">Once X and X' are fixed, the value  <span class="math">\\psi</span>  of the ith decryption query is also fixed, along with the corresponding values  <span class="math">a, \\hat{a}, b, c, d, u, \\hat{u}, v, r</span> , and s. As in the proof of Lemma 10, it suffices to consider values of X and X' for which  <span class="math">u \\neq \\hat{u}</span> , and then to show that  <span class="math">\\Pr[s=t] \\leq q</span> . Notice that the value of X determines the value of  <span class="math">v^*</span> , and we may also assume that  <span class="math">v \\neq v^*</span> . To see why we may do so, if  <span class="math">v = v^*</span> , then either  <span class="math">(a, \\hat{a}, c) = (a^*, \\hat{a}^*, c^*)</span> , or  <span class="math">\\psi</span>  is rejected by the special rejection rule. In the first case, since  <span class="math">\\psi \\neq \\psi^*</span> , we must have  <span class="math">d \\neq d^*</span> , but this implies that  <span class="math">\\psi</span>  fails the test in  <span class="math">\\mathbf{D4}</span> . In the second case, step  <span class="math">\\mathbf{D4}&#x27;</span>  is not even executed.</p>

    <p class="text-gray-300">We have</p>

    <p class="text-gray-300"><span class="math">$\\begin{pmatrix} x \\\\ y \\\\ s^* \\\\ t \\end{pmatrix} = \\underbrace{\\begin{pmatrix} 1 &amp; w &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; w \\\\ u^* &amp; \\hat{u}^* w &amp; u^* v^* &amp; \\hat{u}^* v^* w \\\\ u &amp; \\hat{u} w &amp; u v &amp; \\hat{u} v w \\end{pmatrix}}_{=:M} \\cdot \\begin{pmatrix} x_1 \\\\ x_2 \\\\ y_1 \\\\ y_2 \\end{pmatrix}.</span>$</p>

    <p class="text-gray-300">Let us first condition only on a fixed value of X, which fixes the first three rows of M, but leaves the values  <span class="math">x_1, x_2, y_1</span> , and  <span class="math">y_2</span>  still uniformly distributed over  <span class="math">\\mathbf{Z}_q</span>  and mutually independent. Let us further condition on a fixed value of X' such that X and X' are relevant, and that  <span class="math">u \\neq \\hat{u}</span>  and  <span class="math">v \\neq v^*</span> . The fourth row of M is also fixed, along with the values  <span class="math">x, y, s^*</span> , and s. It is easy to see that the rows of M are linearly independent, since</p>

    <p class="text-gray-300"><span class="math">$\\det(M) = w^{2}(\\hat{u} - u)(\\hat{u}^{*} - u^{*})(v^{*} - v) \\neq 0.</span>$</p>

    <p class="text-gray-300">From this, it follows by Lemma 9 that t is still uniformly distributed over  <span class="math">\\mathbb{Z}_q</span> , but since s is fixed, we have  <span class="math">\\Pr[s=t]=1/q</span> .  <span class="math">\\square</span></p>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">6.3 Two variations</h4>

    <p class="text-gray-300">Scheme CS1 was presented because it is in a form that is particularly easy to analyze. We now describe and analyze two variations of the scheme CS1, which we call CS1a and CS1b, that are a bit simpler than CS1, but that require a bit more work to analyze. For both of these schemes, the public key has the same format and indeed, the same probability distribution, as in CS1, and the encryption algorithm is the same as in CS1. The key generation and decryption algorithms are slightly different, however, and are described in detail in Figures 2 and 3.</p>

    <p class="text-gray-300"><strong>Remark 6</strong> Scheme CS1a is essentially the same scheme that was originally presented as the &quot;main scheme&quot; in [CS98]. Scheme CS1b is a minor variation of a scheme originally presented in [Sho00b].</p>

    <p class="text-gray-300"><strong>Remark 7</strong> Note that in scheme CS1b, we do not have to separately test if  <span class="math">\\hat{a}</span>  belongs to the subgroup G in step  <span class="math">\\mathbf{D2}&#x27;</span> , since this is already implied by the test in step  <span class="math">\\mathbf{D4}&#x27;</span> . The test that a and c belong to G may in some cases be implemented by testing if  <span class="math">a^q = 1_G</span>  and  <span class="math">c^q = 1_G</span> .</p>

    <p class="text-gray-300"><strong>Remark 8</strong> Note also in scheme CS1b, the decryption algorithm has to compute either three or four (if we test if  <span class="math">a^q = 1_G</span> ) powers of a, and possibly one power of c (if we test if  <span class="math">c^q = 1_G</span> ). Special algorithmic techniques [BGMW92, LL94] can be employed to compute these several powers of a significantly faster than computing several powers of different group elements.</p>

    <p class="text-gray-300"><strong>Remark 9</strong> In an actual implementation, it is strongly recommended to compute both exponentiations in step  <span class="math">\\mathbf{D4}&#x27;</span>  of CS1b before rejecting the ciphertext, even if the first exponentiation performed already implies that the ciphertext should be rejected. The reason is that if the ciphertext is rejected</p>

    <p class="text-gray-300"><strong>Key Generation:</strong> On input  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbb{Z}_{&gt;0}</span> , compute</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp;\\Gamma[\\hat{G},G,g,q] \\overset{\\scriptscriptstyle R}{\\leftarrow} \\hat{S}(\\mathbf{1}^{\\lambda}); \\ \\ \\mathsf{hk} \\overset{\\scriptscriptstyle R}{\\leftarrow} \\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda,\\Gamma}; \\\\ &amp;w \\overset{\\scriptscriptstyle R}{\\leftarrow} \\mathbf{Z}_q^*; \\ x_1,x_2,y_1,y_2,z \\overset{\\scriptscriptstyle R}{\\leftarrow} \\mathbf{Z}_q; \\\\ &amp;\\hat{g} \\leftarrow g^w; \\ e \\leftarrow g^{x_1}\\hat{g}^{x_2}; \\ f \\leftarrow g^{y_1}\\hat{g}^{y_2}; \\ h \\leftarrow g^z; \\end{split}</span>$</p>

    <p class="text-gray-300">and output the public key  <span class="math">\\mathsf{PK} = (\\Gamma, \\mathsf{hk}, \\hat{g}, e, f, h)</span>  and the secret key  <span class="math">\\mathsf{SK} = (\\Gamma, \\mathsf{hk}, x_1, x_2, y_1, y_2, z)</span> .</p>

    <p class="text-gray-300"><strong>Decryption:</strong> Given  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , a secret key</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{SK} = (\\Gamma[\\hat{G}, G, g, q], \\mathsf{hk}, x_1, x_2, y_1, y_2, z) \\in [\\mathbf{S}_{\\lambda}] \\times [\\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda, \\Gamma}] \\times \\mathbf{Z}_q^5,</span>$</p>

    <p class="text-gray-300">along with a ciphertext  <span class="math">\\psi</span> , do the following.</p>

    <p class="text-gray-300"><strong>D1:</strong> Parse  <span class="math">\\psi</span>  as a 4-tuple  <span class="math">(a, \\hat{a}, c, d) \\in \\hat{G}^4</span> ; output reject and halt if  <span class="math">\\psi</span>  is not of this form.</p>

    <p class="text-gray-300"><strong>D2:</strong> Test if a,  <span class="math">\\hat{a}</span> , and c belong to G; output reject and halt if this is not the case.</p>

    <p class="text-gray-300"><strong>D3:</strong> Compute  <span class="math">v \\leftarrow \\mathsf{HF}^{\\lambda,\\Gamma}_{\\mathsf{hk}}(a,\\hat{a},c)</span> .</p>

    <p class="text-gray-300"><strong>D4:</strong> Test if  <span class="math">d = a^{x_1 + y_1 v} \\hat{a}^{x_2 + y_2 v}</span> ; output reject and halt if this is not the case.</p>

    <p class="text-gray-300"><strong>D5':</strong> Compute  <span class="math">b \\leftarrow a^z</span> .</p>

    <p class="text-gray-300"><strong>D6:</strong> Compute  <span class="math">m \\leftarrow c \\cdot b^{-1}</span> , and output m.</p>

    <p class="text-gray-300">Figure 2: Key generation and decryption algorithms for CS1a</p>

    <p class="text-gray-300"><strong>Key Generation:</strong> On input  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbb{Z}_{&gt;0}</span> , compute</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp;\\Gamma[\\hat{G},G,g,q] \\overset{\\scriptscriptstyle R}{\\leftarrow} \\hat{S}(\\mathbf{1}^{\\lambda}); \\ \\ \\mathsf{hk} \\overset{\\scriptscriptstyle R}{\\leftarrow} \\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda,\\Gamma}; \\\\ &amp;w \\overset{\\scriptscriptstyle R}{\\leftarrow} \\mathbf{Z}_q^*; \\ x,y,z \\overset{\\scriptscriptstyle R}{\\leftarrow} \\mathbf{Z}_q; \\\\ &amp;\\hat{g} \\leftarrow g^w; \\ e \\leftarrow g^x; \\ f \\leftarrow g^y; \\ h \\leftarrow g^z; \\end{split}</span>$</p>

    <p class="text-gray-300">and output the public key  <span class="math">\\mathsf{PK} = (\\Gamma, \\mathsf{hk}, \\hat{g}, e, f, h)</span>  and the secret key  <span class="math">\\mathsf{SK} = (\\Gamma, \\mathsf{hk}, w, x, y, z)</span> .</p>

    <p class="text-gray-300"><strong>Decryption:</strong> Given  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbb{Z}_{&gt;0}</span> , a secret key</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{SK} = (\\Gamma[\\hat{G}, G, g, q], \\mathsf{hk}, x, y, z) \\in [\\mathbf{S}_{\\lambda}] \\times [\\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda, \\Gamma}] \\times \\mathbf{Z}_q^3,</span>$</p>

    <p class="text-gray-300">along with a ciphertext  <span class="math">\\psi</span> , do the following.</p>

    <p class="text-gray-300"><strong>D1:</strong> Parse  <span class="math">\\psi</span>  as a 4-tuple  <span class="math">(a, \\hat{a}, c, d) \\in \\hat{G}^4</span> ; output reject and halt if  <span class="math">\\psi</span>  is not of this form.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{D2&#x27;}</span> : Test if a and c belong to G; output reject and halt if this is not the case.</p>

    <p class="text-gray-300"><strong>D3:</strong> Compute  <span class="math">v \\leftarrow \\mathsf{HF}^{\\lambda,\\Gamma}_{\\mathsf{hk}}(a,\\hat{a},c)</span> .</p>

    <p class="text-gray-300"><strong>D4':</strong> Test if  <span class="math">\\hat{a} = a^w</span>  and  <span class="math">d = a^{x+yv}</span> ; output reject and halt if this is not the case.</p>

    <p class="text-gray-300"><strong>D5':</strong> Compute  <span class="math">b \\leftarrow a^z</span> .</p>

    <p class="text-gray-300"><strong>D6:</strong> Compute  <span class="math">m \\leftarrow c \\cdot b^{-1}</span> , and output m.</p>

    <p class="text-gray-300">Figure 3: Key generation and decryption algorithms for CS1b</p>

    <p class="text-gray-300">after just one exponentiation, this may reveal some timing information that could be exploited by an attacker. Indeed, if we reject immediately upon detecting that ˆa 6= a &lt;sup&gt;w&lt;/sup&gt;, then based upon timing information, an attacker could use the decryption box as a kind Diffie-Hellman decision oracle. Our formal model of security does not model any notion of time at all, so such attacks fall outside of the model. We should also point out that we know of no actual attack on the scheme even if such timing information is available.</p>

    <p class="text-gray-300">Remark 10 For the same reasons as discussed in the previous remark, it is important that any &quot;error code&quot; returned by the decryption algorithm in scheme CS1b not reveal the precise reason why a ciphertext was rejected.</p>

    <p class="text-gray-300">Theorem 2 If the DDH assumption holds for G and the TCR assumption holds for HF, then CS1a and CS1b are secure against adaptive chosen ciphertext attack.</p>

    <p class="text-gray-300">In particular, for all probabilistic, polynomial-time oracle query machines A, for all λ ∈ Z≥0, and all Γ[G, G, g, q ˆ ] ∈ [Sλ], we have</p>

    <p class="text-gray-300"><span class="math">$|\\mathsf{AdvCCA}_{\\mathsf{CS1a},\\mathsf{A}}(\\lambda \\mid \\Gamma) - \\mathsf{AdvCCA}_{\\mathsf{CS1},\\mathsf{A}}(\\lambda \\mid \\Gamma)| \\le Q_{\\mathsf{A}}(\\lambda)/q \\tag{13}</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$|\\mathsf{AdvCCA}_{\\mathsf{CS1b},\\mathsf{A}}(\\lambda \\mid \\Gamma) - \\mathsf{AdvCCA}_{\\mathsf{CS1},\\mathsf{A}}(\\lambda \\mid \\Gamma)| \\le Q_{\\mathsf{A}}(\\lambda)/q. \\tag{14}</span>$</p>

    <p class="text-gray-300">To prove this theorem, let us fix A, λ, and Γ[G, G, g, q ˆ ]. Consider the attack game G&lt;sup&gt;0&lt;/sup&gt; as defined in §6.2: this is game that A plays against the scheme CS1 for the given values of λ and Γ. We adopt all the notational conventions established at the beginning of §6.2 (i.e., prior to the description of game G1).</p>

    <p class="text-gray-300">We begin by defining two modifications of game G0.</p>

    <p class="text-gray-300">Game G−1a. In this game, we modify the decryption oracle so that in place of step D5, we execute step D5&lt;sup&gt;0&lt;/sup&gt; as in the scheme CS1a. We emphasize that in game G−1a, we have z = z&lt;sup&gt;1&lt;/sup&gt; + z2w, where w, z1, and z&lt;sup&gt;2&lt;/sup&gt; are generated by the key generation algorithm of CS1.</p>

    <p class="text-gray-300">Game G−1b. In this game, we modify the decryption oracle so that in place of steps D4 and D5, we execute steps D4&lt;sup&gt;0&lt;/sup&gt; and D5&lt;sup&gt;0&lt;/sup&gt; as in the scheme CS1b. We emphasize that in game G−1b, we have x = x&lt;sup&gt;1&lt;/sup&gt; + x2w, y = x&lt;sup&gt;1&lt;/sup&gt; + x2w, and z = z&lt;sup&gt;1&lt;/sup&gt; + z2w, where w, x1, x2, y1, y2, z1, and z&lt;sup&gt;2&lt;/sup&gt; are generated by the key generation algorithm of CS1.</p>

    <p class="text-gray-300">Let T−1&lt;sup&gt;a&lt;/sup&gt; be the event that σ = ˆσ in game G−1&lt;sup&gt;a&lt;/sup&gt; and T−1&lt;sup&gt;b&lt;/sup&gt; be the event that σ = ˆσ in game G−1b.</p>

    <p class="text-gray-300">We remind the reader that games G0, G−1a, and G−1&lt;sup&gt;b&lt;/sup&gt; all operate on the same underlying probability space: all of the variables</p>

    <p class="text-gray-300">Coins, hk,
<span class="math">$w, x_1, x_2, y_1, y_2, z_1, z_2, \\sigma, u^*</span>$</p>

    <p class="text-gray-300">that ultimately determine the events T0, T−1a, and T−1&lt;sup&gt;b&lt;/sup&gt; have the same values in games G0, G−1a, and G−1b; all that changes is the functional behavior of the decryption oracle.</p>

    <p class="text-gray-300">It is straightforward to verify that and that</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{AdvCCA}_{\\mathsf{CS1a},\\mathsf{A}}(\\lambda \\mid \\Gamma) = |\\Pr[T_{-1a} - 1/2]|</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{AdvCCA}_{\\mathsf{CS1b},\\mathsf{A}}(\\lambda \\mid \\Gamma) = |\\Pr[T_{-1b} - 1/2]|.</span>$</p>

    <p class="text-gray-300">Let us define the event  <span class="math">R_{-1b}</span>  to be the event that some ciphertext is rejected in game  <span class="math">\\mathbf{G}_{-1b}</span>  in step  <span class="math">\\mathbf{D4}&#x27;</span>  that would have passed the test in  <span class="math">\\mathbf{D4}</span> . It is clear that games  <span class="math">\\mathbf{G}_0</span> ,  <span class="math">\\mathbf{G}_{-1a}</span> , and  <span class="math">\\mathbf{G}_{-1b}</span>  all proceed identically until event  <span class="math">R_{-1b}</span>  occurs. In particular, we the events  <span class="math">T_0 \\wedge \\neg R_{-1b}</span> ,  <span class="math">T_{-1a} \\wedge \\neg R_{-1b}</span> , and  <span class="math">T_{-1b} \\wedge \\neg R_{-1b}</span>  are identical. So by Lemma 4, we have</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[T_0] - \\Pr[T_{-1a}]| \\le \\Pr[R_{-1b}]</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[T_0] - \\Pr[T_{-1b}]| \\le \\Pr[R_{-1b}].</span>$</p>

    <p class="text-gray-300">So it suffices to show that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[R_{-1b}] \\le Q_{\\mathsf{A}}(\\lambda)/q. \\tag{15}</span>$</p>

    <p class="text-gray-300">To do this, for  <span class="math">1 \\leq i \\leq Q_{\\mathsf{A}}(\\lambda)</span> , let  <span class="math">R_{-1b}^{(i)}</span>  be the event that there is an <em>i</em>th ciphertext submitted to the decryption oracle in game  <span class="math">\\mathbf{G}_{-1b}</span> , and that this ciphertext is rejected in step  <span class="math">\\mathbf{D4}&#x27;</span> , but would have passed the test in step  <span class="math">\\mathbf{D4}</span> .</p>

    <p class="text-gray-300">The bound (15) will follow immediately from the following lemma.</p>

    <p class="text-gray-300"><strong>Lemma 12</strong> For all
<span class="math">$1 \\le i \\le Q_A(\\lambda)</span>$
, we have  <span class="math">\\Pr[R_{-1b}^{(i)}] \\le 1/q</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> The proof of this is lemma is almost identical to that of Lemma 10. Note that in game  <span class="math">\\mathbf{G}_{-1b}</span> , the encryption oracle uses the &quot;real&quot; encryption algorithm, and so itself does not leak any additional information about  <span class="math">(x_1, x_2, y_1, y_2)</span> . This is in contrast to game  <span class="math">\\mathbf{G}_5</span> , where the encryption oracle does leak additional information.</p>

    <p class="text-gray-300">Fix  <span class="math">1 \\le i \\le Q_A(\\lambda)</span> . Consider the quantities</p>

    <p class="text-gray-300"><span class="math">$X := (\\mathsf{Coins}, \\mathsf{hk}, w, z, \\sigma, u^*).</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$X&#x27; := (x, y).</span>$</p>

    <p class="text-gray-300">The values of X and X' completely determine the adversary's entire behavior in game  <span class="math">\\mathbf{G}_5</span> , and hence determine if there is an <em>i</em>th decryption oracle query, and if so, the value of the corresponding ciphertext. Let us call X and X' relevant if for these values of X and X', there is an <em>i</em>th decryption oracle query, and the corresponding ciphertext passes steps  <span class="math">\\mathbf{D1}</span>  and  <span class="math">\\mathbf{D2}</span> .</p>

    <p class="text-gray-300">It will suffice prove that conditioned on any fixed, relevant values of X and X', the probability that  <span class="math">R_{-1b}^{(i)}</span>  occurs is bounded by 1/q.</p>

    <p class="text-gray-300">The remainder of the argument is <em>exactly</em> as in Lemma 10, except using X, X', and the notion of <em>relevant</em> as defined here.  <span class="math">\\Box</span></p>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">6.4 A hash-free variant</h4>

    <p class="text-gray-300">Our basic scheme CS1 requires a target collision resistant hash function. Qualitatively, the TCR assumption is much weaker than the DDH assumption, since one can build a target collision resistant hash function based on an arbitrary one-way function. Indeed, one can build a collision resistant hash function under the DL assumption; however, the hash functions arising from such a construction produce an output that is in G, whereas we need a hash function that maps into  <span class="math">\\mathbf{Z}_q</span> . We cannot in general expect to find an easy-to-compute, injective map from G onto  <span class="math">\\mathbf{Z}_q</span> ; in Example 2 in §4.2, we in fact do have such a map, but that is an exceptional case.</p>

    <p class="text-gray-300">For these reasons, we present a variation CS2 of our basic scheme that does not require a hash function.</p>

    <p class="text-gray-300">This scheme requires a family  <span class="math">\\{\\mathsf{Chop}_{\\lambda,\\Gamma}\\}</span>  of &quot;chopping&quot; functions associated with the group scheme  <span class="math">\\mathcal{G}</span>  with the following properties. For  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>  and  <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span> , the function  <span class="math">\\mathsf{Chop}_{\\lambda,\\Gamma}</span>  is bounded by a polynomial in  <span class="math">\\lambda</span> , and the function  <span class="math">\\mathsf{Chop}_{\\lambda,\\Gamma}</span>  should be computable by a deterministic, polynomial-time function that takes inputs  <span class="math">\\mathbf{1}^{\\lambda}</span> ,  <span class="math">\\Gamma</span> , and  <span class="math">\\rho</span> .</p>

    <p class="text-gray-300">In principle, such chopping functions always exist, since we can write down the binary representation of  <span class="math">\\rho</span> , and chop it into bit strings of length  <span class="math">|\\log_2 q|</span> .</p>

    <p class="text-gray-300">We present the details of scheme CS2 in Figure 4.</p>

    <p class="text-gray-300"><strong>Theorem 3</strong> If the DDH assumption holds for  <span class="math">\\mathcal{G}</span> , then CS2 is secure against adaptive chosen ciphertext attack.</p>

    <p class="text-gray-300">In particular, for all probabilistic, polynomial-time oracle query machines A, there exists a probabilistic algorithm  <span class="math">A_1</span> , whose running time is essentially the same as that of A, such that the following holds. For all  <span class="math">\\lambda \\in \\mathbf{Z}_{&gt;0}</span> , and all  <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span> , we have</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{AdvCCA}_{\\mathsf{CS2},\\mathsf{A}}(\\lambda \\mid \\Gamma) \\leq \\mathsf{AdvDDH}_{\\mathcal{G},\\mathsf{A}_1}(\\lambda \\mid \\Gamma) + (Q_{\\mathsf{A}}(\\lambda) + 3)/q.</span>$</p>

    <p class="text-gray-300">The proof of this theorem follows the same lines as the proof of Theorem 1. We present here a sketch of the proof, appealing in several places to arguments found in the proof of Theorem 1 so as to avoid repeating arguments that are identical or nearly identical.</p>

    <p class="text-gray-300">Let us fix a probabilistic, polynomial-time oracle query machine A, the value of the security parameter  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , and the group description  <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span> .</p>

    <p class="text-gray-300">We define  <span class="math">x, z \\in \\mathbf{Z}_q</span>  as follows:</p>

    <p class="text-gray-300"><span class="math">$x := x_1 + x_2 w, \\ z := z_1 + z_2 w.</span>$</p>

    <p class="text-gray-300">We also define  <span class="math">y^{(i)} \\in \\mathbf{Z}_q</span> , for  <span class="math">1 \\le i \\le N</span> , as</p>

    <p class="text-gray-300"><span class="math">$y^{(i)} := y_1^{(i)} + y_2^{(i)} w.</span>$</p>

    <p class="text-gray-300">As a notational convention, whenever a particular ciphertext  <span class="math">\\psi</span>  is under consideration in some context, the following values are also implicitly defined in that context:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">a, \\hat{a}, c, d \\in G</span> , where  <span class="math">\\psi = (a, \\hat{a}, c, d)</span> ;</li>
      <li><span class="math">u, \\hat{u}, v_1, \\ldots, v_N, r, s \\in \\mathbf{Z}_q</span> , where</li>
    </ul>

    <p class="text-gray-300"><span class="math">$u := \\log_a a, \\ \\hat{u} := \\log_{\\hat{a}} \\hat{a}, \\ (v_1, \\dots, v_N) := \\mathsf{Chop}_{\\lambda, \\Gamma}(a, \\hat{a}, c), \\ r := \\log_a c, \\ s := \\log_a d.</span>$</p>

    <p class="text-gray-300">For the target ciphertext  <span class="math">\\psi^*</span> , we also denote by  <span class="math">a^*, \\hat{a}^*, c^*, d^* \\in G</span>  and  <span class="math">u^*, \\hat{u}^*, v_1^*, \\dots, v_N^*, r^*, s^* \\in \\mathbf{Z}_q</span>  the corresponding values.</p>

    <p class="text-gray-300">The probability space defining the attack game is then determined by the following, mutually independent, random variables:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the coin tosses of A;</li>
      <li>the values  <span class="math">w, x_1, x_2, y_1^{(1)}, \\dots, y_2^{(N)}, y_2^{(1)}, \\dots, y_2^{(N)}, z_1, z_2</span>  generated by the key generation algorithm;</li>
    </ul>

    <p class="text-gray-300"><strong>Key Generation:</strong> On input  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbb{Z}_{&gt;0}</span> , compute</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp;\\Gamma[\\hat{G},G,g,q] \\overset{R}{\\leftarrow} \\hat{S}(\\mathbf{1}^{\\lambda}); \\\\ &amp;w \\overset{R}{\\leftarrow} \\mathbf{Z}_{q}^{*}; \\ x_{1},x_{2},z_{1},z_{2} \\overset{R}{\\leftarrow} \\mathbf{Z}_{q}; \\\\ &amp;\\text{for } i=1,\\ldots,n \\colon y_{1}^{(i)},y_{2}^{(i)} \\overset{R}{\\leftarrow} \\mathbf{Z}_{q}; \\\\ &amp;\\hat{g} \\leftarrow g^{w}; \\ e \\leftarrow g^{x_{1}}\\hat{g}^{x_{2}}; \\ h \\leftarrow g^{z_{1}}\\hat{g}^{z_{2}}; \\\\ &amp;\\text{for } i=1,\\ldots,n \\colon f_{i} \\leftarrow g^{y_{1}^{(i)}}\\hat{g}^{y_{2}^{(i)}}; \\end{split}</span>$</p>

    <p class="text-gray-300">and output the public key  <span class="math">\\mathsf{PK} = (\\Gamma, \\hat{g}, e, (f_i)_{i=1}^N, h)</span>  and the secret key  <span class="math">\\mathsf{SK} = (\\Gamma, x_1, x_2, (y_1^{(i)}, y_2^{(i)})_{i=1}^N, z_1, z_2).</span></p>

    <p class="text-gray-300"><strong>Encryption:</strong> Given  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbb{Z}_{\\geq 0}</span> , a public key</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{PK} = (\\Gamma[\\hat{G}, G, g, q], \\hat{g}, e, (f_i)_{i=1}^N, h) \\in [\\mathbf{S}_{\\lambda}] \\times G^{N+3},</span>$</p>

    <p class="text-gray-300">along with a message  <span class="math">m \\in G</span> , compute</p>

    <p class="text-gray-300">E1:  <span class="math">u \\stackrel{R}{\\leftarrow} \\mathbf{Z}_a</span> ;</p>

    <p class="text-gray-300"><strong>E2:</strong>  <span class="math">a \\leftarrow q^u</span> :</p>

    <p class="text-gray-300">E3:  <span class="math">\\hat{a} \\leftarrow \\hat{g}^u</span> ;</p>

    <p class="text-gray-300"><strong>E4:</strong>  <span class="math">b \\leftarrow h^u</span> :</p>

    <p class="text-gray-300"><strong>E5:</strong>  <span class="math">c \\leftarrow b \\cdot m</span> ;</p>

    <p class="text-gray-300"><strong>E6:</strong>  <span class="math">(v_1, \\ldots, v_N) \\leftarrow \\mathsf{Chop}_{\\lambda, \\Gamma}(a, \\hat{a}, c);</span>  <strong>E7:</strong>  <span class="math">d \\leftarrow e^u \\prod_{i=1}^N f_i^{uv_i};</span></p>

    <p class="text-gray-300">and output the ciphertext  <span class="math">\\psi = (a, \\hat{a}, c, d)</span> .</p>

    <p class="text-gray-300"><strong>Decryption:</strong> Given  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbb{Z}_{&gt;0}</span> , a secret key</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{SK} = (\\Gamma[\\hat{G}, G, g, q], x_1, x_2, (y_1^{(i)}, y_2^{(i)})_{i=1}^N, z_1, z_2) \\in [\\mathbf{S}_{\\lambda}] \\times \\mathbf{Z}_q^{N+4},</span>$</p>

    <p class="text-gray-300">along with a ciphertext  <span class="math">\\psi</span> , do the following.</p>

    <p class="text-gray-300"><strong>D1:</strong> Parse  <span class="math">\\psi</span>  as a 4-tuple  <span class="math">(a, \\hat{a}, c, d) \\in \\hat{G}^4</span> ; output reject and halt if  <span class="math">\\psi</span>  is not of this form.</p>

    <p class="text-gray-300"><strong>D2:</strong> Test if a,  <span class="math">\\hat{a}</span> , and c belong to G; output reject and halt if this is not the case.</p>

    <p class="text-gray-300"><strong>D3:</strong> Compute  <span class="math">(v_1, \\ldots, v_N) \\leftarrow \\mathsf{Chop}_{\\lambda, \\Gamma}(a, \\hat{a}, c)</span> .</p>

    <p class="text-gray-300"><strong>D4:</strong> Test if  <span class="math">d = a^{x_1 + \\sum_{i=1}^{N} y_1^{(i)} v_i} \\cdot \\hat{a}^{x_2 + \\sum_{i=1}^{N} y_2^{(i)} v_i}</span> ; output reject and halt if this is not the case.</p>

    <p class="text-gray-300"><strong>D5:</strong> Compute  <span class="math">b \\leftarrow a^{z_1} \\hat{a}^{z_2}</span> .</p>

    <p class="text-gray-300"><strong>D6:</strong> Compute  <span class="math">m \\leftarrow c \\cdot b^{-1}</span> , and output m.</p>

    <p class="text-gray-300">Figure 4: The public-key encryption scheme CS2, where  <span class="math">N = N(\\lambda, \\Gamma)</span></p>

    <p class="text-gray-300">• the values  <span class="math">\\sigma \\in \\{0,1\\}</span>  and  <span class="math">u^* \\in \\mathbf{Z}_q</span>  generated by the encryption oracle.</p>

    <p class="text-gray-300">Let  <span class="math">G_0</span>  be the original attack game, let  <span class="math">\\hat{\\sigma} \\in \\{0,1\\}</span>  denote the output of A, and let  <span class="math">T_0</span>  be the event that  <span class="math">\\sigma = \\hat{\\sigma}</span>  in  <span class="math">G_0</span> , so that  <span class="math">AdvCCA_{CS2,A}(\\lambda \\mid \\Gamma) = |\\Pr[T_0] - 1/2|</span> .</p>

    <p class="text-gray-300">As in the proof of Theorem 1, we shall define a sequence of modified games  <span class="math">\\mathbf{G}_i</span> , for i = 1, 2, ..., and in game  <span class="math">\\mathbf{G}_i</span> , the event  <span class="math">T_i</span>  will be the event corresponding to event  <span class="math">T_0</span> , but in game  <span class="math">\\mathbf{G}_i</span> . We remind the reader that all of these games operate on the same underlying probability space, and except as otherwise specified, random variables have identical values between games.</p>

    <p class="text-gray-300"><strong>Game G</strong>&lt;sub&gt;1&lt;/sub&gt;. In game  <span class="math">\\mathbf{G}_1</span> , we modify the algorithm used by the encryption oracle as follows. Steps  <span class="math">\\mathbf{E}\\mathbf{4}</span>  and  <span class="math">\\mathbf{E}\\mathbf{7}</span>  are replaced by:</p>

    <p class="text-gray-300"><strong>E4':</strong>
<span class="math">$b \\leftarrow a^{z_1} \\hat{a}^{z_2}</span>$
;</p>

    <p class="text-gray-300"><strong>E7':</strong>
<span class="math">$d \\leftarrow a^{x_1 + \\sum_{i=1}^{N} y_1^{(i)} v_i} \\cdot \\hat{a}^{x_2 + \\sum_{i=1}^{N} y_2^{(i)} v_i}</span>$
.</p>

    <p class="text-gray-300">By the same reasoning as in the proof of Theorem 1, we have  <span class="math">Pr[T_1] = Pr[T_0]</span> .</p>

    <p class="text-gray-300"><strong>Game G&lt;sub&gt;2&lt;/sub&gt;.</strong> We again modify the encryption oracle, replacing step E3 by</p>

    <p class="text-gray-300"><strong>E3':</strong>
<span class="math">$\\hat{u} \\stackrel{R}{\\leftarrow} \\mathbf{Z}_q \\setminus \\{u\\}; \\ \\hat{a} \\leftarrow \\hat{g}^{\\hat{u}}.</span>$</p>

    <p class="text-gray-300">By the same reasoning as in the proof of Theorem 1, one sees that there exists a probabilistic algorithm  <span class="math">A_1</span> , whose running time is essentially the same as that of A, such that</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[T_2] - \\Pr[T_1]| \\le \\mathsf{AdvDDH}_{\\mathcal{G},\\mathsf{A}_1}(\\lambda \\mid \\Gamma) + 3/q.</span>$</p>

    <p class="text-gray-300"><strong>Game G</strong>&lt;sub&gt;3&lt;/sub&gt;. In this game, we modify the decryption oracle in game  <span class="math">G_2</span> , replacing steps D4 and D5 with:</p>

    <p class="text-gray-300"><strong>D4':</strong> Test if
<span class="math">$\\hat{a} = a^w</span>$
and  <span class="math">d = a^{x + \\sum_{i=1}^{N} y^{(i)} v_i}</span> ; output reject and halt if this is not the case. <strong>D5':</strong>  <span class="math">h \\leftarrow a^z</span></p>

    <p class="text-gray-300">Let  <span class="math">R_3</span>  be the event that in game  <span class="math">G_3</span> , some ciphertext  <span class="math">\\psi</span>  is submitted to the decryption oracle that is rejected in step D4' but that would have passed the test in step D4.</p>

    <p class="text-gray-300">As in the proof of Theorem 1, we have</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[T_3] - \\Pr[T_2]| \\le \\Pr[R_3].</span>$</p>

    <p class="text-gray-300">We claim that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[R_3] \\leq Q_{\\mathsf{A}}(\\lambda)/q.</span>$</p>

    <p class="text-gray-300">We can prove the analog of Lemma 8 (in game  <span class="math">G_5</span>  in the proof of Theorem 1) by considering an  <span class="math">(N+3) \\times (2N+2)</span>  matrix M over  <span class="math">\\mathbf{Z}_q</span>  defined as</p>

    <p class="text-gray-300"><span class="math">$M := \\begin{pmatrix} 1 &amp; w &amp; &amp; &amp; &amp; &amp; &amp; \\\\ &amp; &amp; 1 &amp; w &amp; &amp; &amp; &amp; \\\\ &amp; &amp; &amp; \\ddots &amp; &amp; &amp; \\\\ &amp; &amp; &amp; &amp; \\ddots &amp; &amp; \\\\ u^* &amp; \\hat{u}^*w &amp; u^*v_1^* &amp; \\hat{u}^*v_1^*w &amp; \\cdots &amp; u^*v_N^* &amp; \\hat{u}^*v_N^*w \\\\ u &amp; \\hat{u}w &amp; uv_1 &amp; \\hat{u}v_1w &amp; \\cdots &amp; uv_N &amp; \\hat{u}v_Nw \\end{pmatrix},</span>$</p>

    <p class="text-gray-300">where  <span class="math">w \\neq 0</span> ,  <span class="math">\\hat{u} \\neq u</span> ,  <span class="math">\\hat{u}^* \\neq u^*</span> , and  <span class="math">v_i \\neq v_i^*</span>  for some  <span class="math">i \\in \\{1, ..., N\\}</span> . It will suffice to show that the rows of M are linearly independent.</p>

    <p class="text-gray-300">If we choose i such that v&lt;sup&gt;i&lt;/sup&gt; 6= v ∗ i , and consider the 4 × 4 sub-matrix M&lt;sup&gt;0&lt;/sup&gt; of M consisting of the intersection of columns 1, 2, 2i + 1, 2i + 2 of M, and rows 1, i + 1, N + 2, N + 3 of M, we see that matrix M&lt;sup&gt;0&lt;/sup&gt; has the same form as the matrix considered in Lemma 11, and hence is non-singular. It follows that the rows of M are linearly independent, since any non-trivial linear relation among the rows of M implies a non-trivial linear relation among the rows of M&lt;sup&gt;0&lt;/sup&gt; .</p>

    <p class="text-gray-300">Game G4. We again modify the algorithm used by the encryption oracle, replacing step E5 by</p>

    <p class="text-gray-300"><strong>E5':</strong>
<span class="math">$r \\stackrel{R}{\\leftarrow} \\mathbf{Z}_q</span>$
;  <span class="math">c \\leftarrow g^r</span> .</p>

    <p class="text-gray-300">By reasoning analogous to that in game G&lt;sup&gt;4&lt;/sup&gt; in the proof of Theorem 1, one can show that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[T_4] = \\Pr[T_3].</span>$</p>

    <p class="text-gray-300">Moreover, by construction it is evident that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[T_4] = 1/2.</span>$</p>

    <p class="text-gray-300">That completes the proof sketch of Theorem 3. We leave it to the reader to work out the details of the design and analysis of variants CS2a and CS2b of scheme CS2, corresponding to the variants CS1a and CS1b of scheme CS1, which were discussed in §6.3.</p>

    <p class="text-gray-300">Remark 11 Note that the high-level structure of the proof of Theorem 3 is significantly simpler than that of Theorem 1. In particular, in the analysis of game G&lt;sup&gt;3&lt;/sup&gt; in the proof of Theorem 3, we were able to bound the quantity Pr[R3] directly, without deferring the analysis to a later game, as in the proof of Theorem 1. This simplification comes from the fact that we do not have to deal with a target collision resistant hash function in Theorem 3, as we did in Theorem 1. Indeed, if in the scheme CS1 we use a collision resistant hash function, we could prove the security of CS1 using a proof with essentially the same line of reasoning as that of the proof of Theorem 3, with one extra game between G&lt;sup&gt;0&lt;/sup&gt; and G&lt;sup&gt;1&lt;/sup&gt; to effectively ban hash function collisions.</p>

    <p class="text-gray-300">The encryption schemes presented in the previous section all had restricted message spaces. In some settings, an encryption scheme with an unrestricted message space is more desirable. A simple and efficient way to build an encryption scheme that has an unrestricted message is to build a hybrid encryption scheme. Loosely speaking, such a scheme uses public-key encryption techniques to encrypt a key K that is then used to encrypt the actual message using symmetrickey encryption techniques. In this section, we develop the necessary tools for building a hybrid public-key encryption scheme.</p>

    <p class="text-gray-300">One key ingredient in any hybrid scheme is a key encapsulation mechanism. This is like a publickey encryption scheme, except that the job of the encryption algorithm is to generate the encryption of a random key K. Of course, one can always use a general-purpose public-key encryption scheme to do this, by simply generating K at random, and then encrypting it. However, there are typically more efficient ways to this.</p>

    <p class="text-gray-300">As a quick example of a key encapsulation mechanism, consider the following variation of the ElGamal encryption scheme. Let G be a group of prime order q generated by an element g. Let H be a cryptographic hash function, such as SHA-1. The public key consists of a group element</p>

    <p class="text-gray-300"><span class="math">h = g^z</span> , where  <span class="math">z \\in \\mathbf{Z}_q</span>  is chosen at random; the secret key is z. To generate an encryption of a symmetric key K, we compute</p>

    <p class="text-gray-300"><span class="math">$u \\stackrel{\\mathbb{R}}{\\leftarrow} \\mathbf{Z}_q; \\ a \\leftarrow g^u; \\ b \\leftarrow h^u; \\ K \\leftarrow H(b);</span>$</p>

    <p class="text-gray-300">to form a ciphertext  <span class="math">\\psi = a</span> . To decrypt a ciphertext  <span class="math">\\psi = a</span>  using the secret key, one computes</p>

    <p class="text-gray-300"><span class="math">$b \\leftarrow a^z; \\ K \\leftarrow H(b);</span>$</p>

    <p class="text-gray-300">obtaing a symmetric key K.</p>

    <p class="text-gray-300">To build a complete hybrid encryption scheme, we combine a key encapsulation mechanism with a symmetric-key encryption scheme.</p>

    <p class="text-gray-300">A key encapsulation mechanism KEM consists of the following algorithms:</p>

    <p class="text-gray-300">• A probabilistic, polynomial-time key generation algorithm KEM.KeyGen that on input  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbb{Z}_{\\geq 0}</span> , outputs a public key/secret key pair (PK, SK). The structure of PK and SK depends on the particular scheme.</p>

    <p class="text-gray-300">For  <span class="math">\\lambda \\in \\mathbf{Z}_{&gt;0}</span> , we define the probability spaces</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{KEM}.\\mathsf{PKSpace}_{\\lambda} := \\{\\mathsf{PK} : (\\mathsf{PK},\\mathsf{SK}) \\xleftarrow{R} \\mathsf{KEM}.\\mathsf{KeyGen}(\\mathbf{1}^{\\lambda})\\},</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{KEM.SKSpace}_{\\lambda} := \\{\\mathsf{SK} : (\\mathsf{PK}, \\mathsf{SK}) \\xleftarrow{\\scriptscriptstyle{R}} \\mathsf{KEM.KeyGen}(\\mathbf{1}^{\\lambda})\\}.</span>$</p>

    <p class="text-gray-300">• A probabilistic, polynomial-time encryption algorithm KEM.Encrypt that takes as input  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbb{Z}_{\\geq 0}</span> , and a public key  <span class="math">\\mathsf{PK} \\in [\\mathsf{KEM}.\\mathsf{PKSpace}_{\\lambda}]</span> , and outputs a pair  <span class="math">(K, \\psi)</span> , where K is a key and  <span class="math">\\psi</span>  is a ciphertext.</p>

    <p class="text-gray-300">A key K is a bit string of length  <span class="math">\\mathsf{KEM}.\\mathsf{KeyLen}(\\lambda)</span> , where  <span class="math">\\mathsf{KEM}.\\mathsf{KeyLen}(\\lambda)</span>  is another parameter of the key encapsulation mechanism.</p>

    <p class="text-gray-300">A ciphertext is a bit string.</p>

    <p class="text-gray-300">• A deterministic, polynomial-time decryption algorithm KEM.Decrypt that takes as input  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbb{Z}_{\\geq 0}</span> , a secret key  <span class="math">\\mathsf{SK} \\in [\\mathsf{KEM.SKSpace}_{\\lambda}]</span> , a ciphertext  <span class="math">\\psi</span> , and outputs either a key K or the special symbol reject.</p>

    <h4 id="sec-22" class="text-lg font-semibold mt-6">7.1.1 Soundness</h4>

    <p class="text-gray-300">As for public key encryption, we need an appropriate notion of soundness. A definition of soundness that is adequate for our purposes runs as follows. Let us say a public key/secret key pair  <span class="math">(PK, SK) \\in [KEM.KeyGen(1^{\\lambda})]</span>  is bad if for some  <span class="math">(K, \\psi) \\in [KEM.Encrypt(1^{\\lambda}, PK)]</span> , we have  <span class="math">KEM.Decrypt(1^{\\lambda}, SK, \\psi) \\neq K</span> . Let  <span class="math">BadKeyPair_{KEM}(\\lambda)</span>  denote the probability that the key generation algorithm generates a bad key pair for a given value of  <span class="math">\\lambda</span> . Then our requirement is that  <span class="math">BadKeyPair_{KEM}(\\lambda)</span>  grows negligibly in  <span class="math">\\lambda</span> .</p>

    <h4 id="sec-23" class="text-lg font-semibold mt-6">7.1.2 Security against adaptive chosen ciphertext attack</h4>

    <p class="text-gray-300">As for a public key encryption scheme, an adversary A in an adaptive chosen ciphertext attack is a probabilistic, polynomial-time oracle query machine that takes as input  <span class="math">1^{\\lambda}</span> , where  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>  is the security parameter. We now describe the attack game used to define security against adaptive chosen ciphertext security.</p>

    <p class="text-gray-300"><strong>Stage 1:</strong> The adversary queries a <em>key generation oracle</em>. The key generation oracle computes  <span class="math">(PK, SK) \\stackrel{R}{\\leftarrow} KEM.KeyGen(1^{\\lambda})</span>  and responds with PK.</p>

    <p class="text-gray-300">Stage 2: The adversary makes a sequence of calls to a decryption oracle.</p>

    <p class="text-gray-300">For each decryption oracle query, the adversary submits a ciphertext  <span class="math">\\psi</span> , and the decryption oracle responds with KEM.Decrypt(1&lt;sup&gt; <span class="math">\\lambda</span> &lt;/sup&gt;, SK,  <span class="math">\\psi</span> ).</p>

    <p class="text-gray-300">Stage 3: The adversary queries an encryption oracle.</p>

    <p class="text-gray-300">The encryption oracle computes:</p>

    <p class="text-gray-300"><span class="math">$(K^*, \\psi^*) \\xleftarrow{R} \\mathsf{KEM}.\\mathsf{Encrypt}(\\mathbf{1}^{\\lambda}, \\mathsf{PK}); \\ K^+ \\xleftarrow{R} \\{0, 1\\}^{\\ell}; \\ \\tau \\xleftarrow{R} \\{0, 1\\}; \\\\ \\text{if } \\tau = 0 \\text{ then } K^{\\dagger} \\leftarrow K^* \\text{ else } K^{\\dagger} \\leftarrow K^+; \\\\</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\ell := \\mathsf{KEM}.\\mathsf{KeyLen}(\\lambda)</span> , and responds with the pair  <span class="math">(K^{\\dagger}, \\psi^*)</span> .</p>

    <p class="text-gray-300"><strong>Stage 4:</strong> The adversary continues to make calls to the decryption oracle, subject only to the restriction that a submitted ciphertext  <span class="math">\\psi</span>  is not <em>identical</em> to  <span class="math">\\psi^*</span> .</p>

    <p class="text-gray-300"><strong>Stage 5:</strong> The adversary outputs  <span class="math">\\hat{\\tau} \\in \\{0, 1\\}</span> .</p>

    <p class="text-gray-300">We define  <span class="math">AdvCCA_{KEM,A}(\\lambda)</span>  to be  <span class="math">|Pr[\\tau = \\hat{\\tau}] - 1/2|</span>  in the above attack game.</p>

    <p class="text-gray-300">We say that KEM is secure against adaptive chosen ciphertext attack if</p>

    <p class="text-gray-300">for all probabilistic, polynomial-time oracle query machines A, the function  <span class="math">AdvCCA_{KEM,A}(\\lambda)</span>  grows negligibly in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">In applying the above definition of security, one typically works directly with the quantity</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{AdvCCA}&#x27;_{\\mathsf{KFM},\\mathsf{A}}(\\lambda) := |\\Pr[\\hat{\\tau} = 1 \\mid \\tau = 0] - \\Pr[\\hat{\\tau} = 1 \\mid \\tau = 1]|.</span>$</p>

    <p class="text-gray-300">It is easy to verify that</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{AdvCCA}&#x27;_{\\mathsf{KEM},\\mathsf{A}}(\\lambda) = 2 \\cdot \\mathsf{AdvCCA}_{\\mathsf{KEM},\\mathsf{A}}(\\lambda).</span>$</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">7.2 One-time symmetric-key encryption</h4>

    <p class="text-gray-300">A one-time symmetric-key encryption scheme SKE consists of two algorithms:</p>

    <p class="text-gray-300">• A deterministic, polynomial-time encryption algorithm SKE.Encrypt that takes as input  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbb{Z}_{&gt;0}</span> , a key K, and a message m, and outputs a ciphertext  <span class="math">\\chi</span> .</p>

    <p class="text-gray-300">The key K is a bit string of length  <span class="math">SKE.KeyLen(\\lambda)</span> .</p>

    <p class="text-gray-300">Here,  <span class="math">\\mathsf{SKE}.\\mathsf{KeyLen}(\\lambda)</span>  is a parameter of the encryption scheme, which we assume can be computed in deterministic polynomial time given  <span class="math">1^{\\lambda}</span> .</p>

    <p class="text-gray-300">The message m is a bit string of arbitrary, unbounded length.</p>

    <p class="text-gray-300">The ciphertext  <span class="math">\\chi</span>  is a bit string.</p>

    <p class="text-gray-300">We denote by  <span class="math">\\mathsf{SKE}.\\mathsf{CTLen}(\\lambda,\\ell)</span>  the maximum length of any encryption of a message of length at most  <span class="math">\\ell</span> .</p>

    <p class="text-gray-300">• A deterministic, polynomial-time decryption algorithm SKE.Decrypt that takes as input  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , a key K, and a ciphertext  <span class="math">\\chi</span>  and outputs a message m or the special symbol reject.</p>

    <p class="text-gray-300">The key K is a bit string of length  <span class="math">SKE.KeyLen(\\lambda)</span> .</p>

    <p class="text-gray-300">The ciphertext  <span class="math">\\chi</span>  is a bit string of arbitrary length.</p>

    <p class="text-gray-300">We require that SKE satisfy the following soundness condition: for all  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , for all  <span class="math">K \\in \\{0,1\\}^{\\mathsf{SKE}.\\mathsf{KeyLen}(\\lambda)}</span> , for all  <span class="math">m \\in \\{0,1\\}^*</span> , we have:</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{SKE}.\\mathsf{Decrypt}(\\mathbf{1}^{\\lambda},K,\\mathsf{SKE}.\\mathsf{Encrypt}(\\mathbf{1}^{\\lambda},K,m)) = m.</span>$</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">7.2.1 Two definitions of security</h3>

    <p class="text-gray-300">We define two notions of security for a one-time symmetric-key encryption scheme: security against passive attacks, and security against adaptive chosen ciphertext attacks.</p>

    <p class="text-gray-300">As usual, an adversary A is a probabilistic, polynomial-time oracle query machine that takes as input  <span class="math">1^{\\lambda}</span> , where  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>  is the security parameter.</p>

    <p class="text-gray-300">A passive attack runs as follows. The adversary A chooses two messages,  <span class="math">m_0</span>  and  <span class="math">m_1</span> , of equal length, and gives these to an encryption oracle. The encryption oracle generates a random key K of length  <span class="math">\\mathsf{SKE}.\\mathsf{KeyLen}(\\lambda)</span> , along with random  <span class="math">\\sigma \\in \\{0,1\\}</span> , and encrypts the message  <span class="math">m_\\sigma</span>  using the key K. The adversary A is then given the resulting ciphertext  <span class="math">\\chi^*</span> . Finally, the adversary outputs  <span class="math">\\hat{\\sigma} \\in \\{0,1\\}</span> .</p>

    <p class="text-gray-300">We define  <span class="math">AdvPA_{SKE,A}(\\lambda)</span>  to be  <span class="math">|\\Pr[\\sigma = \\hat{\\sigma}] - 1/2|</span>  in the above attack game.</p>

    <p class="text-gray-300">We say that SKE is secure against passive attacks if</p>

    <p class="text-gray-300">for all probabilistic, polynomial-time oracle query machines A, the function  <span class="math">AdvPA_{SKE,A}(\\lambda)</span>  grows negligibly in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">An adaptive chosen ciphertext attack is exactly the same as a passive attack, except that after the adversary A obtains the target ciphertext  <span class="math">\\chi^*</span>  from the encryption oracle, the adversary may then query a decryption oracle any number of times. In each decryption oracle query, A submits a ciphertext  <span class="math">\\chi \\neq \\chi^*</span> , and obtains the decryption of  <span class="math">\\chi</span>  under the key K. As in the passive attack, A outputs  <span class="math">\\hat{\\sigma} \\in \\{0,1\\}</span> .</p>

    <p class="text-gray-300">We define  <span class="math">\\mathsf{AdvCCA}_{\\mathsf{SKE},\\mathsf{A}}(\\lambda)</span>  to be  <span class="math">|\\Pr[\\sigma = \\hat{\\sigma}] - 1/2|</span>  in the above attack game.</p>

    <p class="text-gray-300">We say that SKE is secure against adaptive chosen ciphertext attacks if</p>

    <p class="text-gray-300">for all probabilistic, polynomial-time oracle query machines A, the function  <span class="math">AdvCCA_{SKE,A}(\\lambda)</span>  grows negligibly in  <span class="math">\\lambda</span> .</p>

    <h4 id="sec-26" class="text-lg font-semibold mt-6">7.2.2 Constructions</h4>

    <p class="text-gray-300">Our definition of a symmetric-key encryption scheme and the corresponding notions of security are tailored to the application of building a hybrid public-key encryption scheme. These definitions may not be appropriate for other settings. In particular, our definitions of security do not imply protection against chosen plaintext attack; however, this protection is not needed for hybrid public-key encryption schemes, since a symmetric key is only used to encrypt a single message.</p>

    <p class="text-gray-300">It is easy to build a symmetric key encryption scheme that achieves security against passive attacks using standard symmetric-key techniques. For example, to encrypt a message m, one can</p>

    <p class="text-gray-300">expand the key K using a pseudo-random bit generator to obtain a &quot;one time pad&quot;  <span class="math">\\alpha</span>  of length |m|, and then compute  <span class="math">\\chi \\leftarrow m \\oplus \\alpha</span> .</p>

    <p class="text-gray-300">A pseudo-random bit generator can be built from an arbitrary one-way permutation [GL89], or even from an arbitrary one-way function [ILL89, HILL99]. These constructions, however, are not very practical. In a practical implementation, it is perfectly reasonable to stretch the key K by using it as the key to a dedicated block cipher, and then evaluate the block cipher at successive points (so-called &quot;counter mode&quot;) to obtain a sequence of pseudo-random bits (c.f. [MvOV97, Chapter 7]).</p>

    <p class="text-gray-300">Note that the above construction yields a scheme that is completely insecure against adaptive chosen ciphertext attack. However, it is also easy to build a symmetric key encryption scheme SKE2 that achieves security against adaptive chosen ciphertext attack, given an arbitrary scheme SKE1 that is only secure against passive attacks.</p>

    <p class="text-gray-300">One technique is to simply build an SKE2 ciphertext by attaching a <em>message authentication code</em> to the SKE1 ciphertext. Although this technique seems to be &quot;folklore,&quot; for completeness, we develop the details here.</p>

    <p class="text-gray-300">A one-time message authentication code MAC specifies the following items:</p>

    <p class="text-gray-300">• For  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , a key length parameter MAC.KeyLen( <span class="math">\\lambda</span> ) and an output length parameter MAC.OutLen( <span class="math">\\lambda</span> ).</p>

    <p class="text-gray-300">We assume that MAC.KeyLen( <span class="math">\\lambda</span> ) can be computed in deterministic polynomial time given  <span class="math">1^{\\lambda}</span> .</p>

    <p class="text-gray-300">• A family of functions indexed by  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>  and  <span class="math">\\mathsf{mk} \\in \\{0,1\\}^{\\mathsf{MAC.KeyLen}(\\lambda)}</span> , where each function  <span class="math">\\mathsf{MAC}^{\\lambda}_{\\mathsf{mk}}</span>  maps arbitrary bit strings to bit strings of length exactly  <span class="math">\\mathsf{MAC.OutLen}(\\lambda)</span> .</p>

    <p class="text-gray-300">There must be a deterministic, polynomial-time algorithm that on input  <span class="math">\\mathbf{1}^{\\lambda}</span> ,  <span class="math">\\mathsf{mk} \\in \\{0,1\\}^{\\mathsf{MAC.KeyLen}(\\lambda)}</span> , and  <span class="math">\\alpha \\in \\{0,1\\}^*</span> , outputs  <span class="math">\\mathsf{MAC}^{\\lambda}_{\\mathsf{mk}}(\\alpha)</span> .</p>

    <p class="text-gray-300">To define security for MAC, we define an attack game as follows. As usual, an adversary A is a probabilistic, polynomial-time oracle query machine that takes as input  <span class="math">1^{\\lambda}</span> , where  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>  is the security parameter. The adversary A first chooses a bit string  <span class="math">\\alpha</span> , and submits this to an oracle. The oracle generates a random key mk of length MAC.KeyLen( <span class="math">\\lambda</span> ), computes  <span class="math">\\beta \\leftarrow \\mathsf{MAC}^{\\lambda}_{\\mathsf{mk}}(\\alpha)</span> , and returns  <span class="math">\\beta</span>  to the adversary. The adversary A then outputs a list</p>

    <p class="text-gray-300"><span class="math">$((\\alpha_1,\\beta_1),\\ldots,(\\alpha_k,\\beta_k))</span>$</p>

    <p class="text-gray-300">of pairs of bit strings. We say that A has produced a forgery if for some  <span class="math">1 \\le i \\le k</span> , we have  <span class="math">\\alpha_i \\ne \\alpha</span>  and  <span class="math">\\mathsf{MAC}^{\\lambda}_{\\mathsf{mk}}(\\alpha_i) = \\beta_i</span> .</p>

    <p class="text-gray-300">We say that A is a  <span class="math">(L_1(\\lambda), L_2(\\lambda), N(\\lambda))</span>  forging adversary if  <span class="math">|\\alpha| \\leq L_1(\\lambda)</span> ,  <span class="math">k \\leq N(\\lambda)</span> , and  <span class="math">|\\alpha_i| \\leq L_2(\\lambda)</span>  for all  <span class="math">1 \\leq i \\leq k</span> .</p>

    <p class="text-gray-300">Define  <span class="math">\\mathsf{AdvForge}_{\\mathsf{MAC},\\mathsf{A}}(\\lambda)</span>  to be the probability that A produces a forgery in the above game. We say that  <span class="math">\\mathsf{MAC}</span>  is secure if</p>

    <p class="text-gray-300">for all probabilistic, polynomial-time oracle query machines A, the function  <span class="math">AdvForge_{MAC,A}(\\lambda)</span>  grows negligibly in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">Message authentication codes have been extensively studied (c.f. [MvOV97, Chapter 9]). Once can easily build secure one-time message authentication codes using an appropriate family of universal hash functions, without relying on any intractability assumptions. There are also other ways to build message authentication codes which may be preferable in practice, even though the security of these schemes is not fully proven.</p>

    <p class="text-gray-300">Now we show how to use SKE1 and MAC to build SKE2. The key length SKE2.KeyLen( <span class="math">\\lambda</span> ) of SKE2 will be equal to</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{SKE1}.\\mathsf{KeyLen}(\\lambda) + \\mathsf{MAC}.\\mathsf{KeyLen}(\\lambda).</span>$</p>

    <p class="text-gray-300">We will write such a key as (K, mk), where K is a bit string of length  <span class="math">\\mathsf{SKE1.KeyLen}(\\lambda)</span> , and  <span class="math">\\mathsf{mk}</span>  is a bit string of length  <span class="math">\\mathsf{MAC.KeyLen}(\\lambda)</span> .</p>

    <p class="text-gray-300">To encrypt a message m under a key  <span class="math">(K, \\mathsf{mk})</span>  as above, algorithm SKE2. Encrypt computes</p>

    <p class="text-gray-300"><span class="math">$\\chi \\leftarrow \\mathsf{SKE1}.\\mathsf{Encrypt}(\\mathbf{1}^{\\lambda},K,m); \\ \\mathsf{tag} \\leftarrow \\mathsf{MAC}^{\\lambda}_{\\mathsf{mk}}(\\chi); \\ \\chi&#x27; \\leftarrow \\chi \\, \\| \\, \\mathsf{tag};</span>$</p>

    <p class="text-gray-300">and outputs the ciphertext  <span class="math">\\chi&#x27;</span> .</p>

    <p class="text-gray-300">To decrypt a ciphertext  <span class="math">\\chi&#x27;</span>  under a key (K, mk) as above, algorithm SKE2.Decrypt first parses  <span class="math">\\chi&#x27;</span>  as  <span class="math">\\chi&#x27; = \\chi \\parallel tag</span> , where tag is a bit string of length MAC.OutLen( <span class="math">\\lambda</span> ). If this parsing step fails (because  <span class="math">\\chi&#x27;</span>  is too short), then the algorithm outputs reject; otherwise, it computes</p>

    <p class="text-gray-300"><span class="math">$tag&#x27; \\leftarrow MAC_{mk}^{\\lambda}(\\chi).</span>$</p>

    <p class="text-gray-300">If  <span class="math">tag \\neq tag&#x27;</span> , the algorithm outputs reject; otherwise, it computes</p>

    <p class="text-gray-300"><span class="math">$m \\leftarrow \\mathsf{SKE1.Decrypt}(1^{\\lambda}, K, \\chi);</span>$</p>

    <p class="text-gray-300">and outputs m.</p>

    <p class="text-gray-300">To analyze the security of SKE2, we recall that for all probabilistic, polynomial-time oracle query machines A, for all  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , we denote by  <span class="math">Q_{\\mathsf{A}}(\\lambda)</span>  an upper bound on the number of decryption oracle queries made by A on input  <span class="math">1^{\\lambda}</span> . Although we introduced this notation in the context of public-key encryption, we can adopt it here in the context of symmetric-key encryption as well. We remind the reader that  <span class="math">Q_{\\mathsf{A}}(\\lambda)</span>  should be a strict bound that holds for any environment.</p>

    <p class="text-gray-300">For all probabilistic, polynomial-time oracle query machines A, for all  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , we define  <span class="math">B_{\\mathsf{A}}(\\lambda)</span>  to be an upper bound on the length of the messages submitted by A to the encryption oracle, and  <span class="math">B&#x27;_{\\mathsf{A}}(\\lambda)</span>  to be an upper bound on the ciphertexts submitted by A to the decryption oracle. As usual, these upper bounds should hold regardless of the environment of A.</p>

    <p class="text-gray-300"><strong>Theorem 4</strong> If SKE1 is secure against passive attacks, and MAC is a secure one-time message authentication code, then SKE2 is secure against adaptive chosen ciphertext attacks.</p>

    <p class="text-gray-300">In particular, for every probabilistic, polynomial-time oracle query machine A, there exist probabilistic oracle query machine  <span class="math">A_1</span>  and  <span class="math">A_2</span> , whose running times are essentially the same as that of A, such that for all  <span class="math">\\lambda \\in \\mathbf{Z}_{&gt;0}</span> ,</p>

    <p class="text-gray-300"><span class="math">$AdvCCA_{SKE2,A}(\\lambda) \\leq AdvPA_{SKE1,A_1}(\\lambda) + AdvForge_{MAC,A_2}(\\lambda)</span>$
.</p>

    <p class="text-gray-300">Moreover, A2 is a</p>

    <p class="text-gray-300"><span class="math">$(\\mathsf{SKE1.CTLen}(\\lambda, B(\\lambda)), \\ B&#x27;(\\lambda) - \\mathsf{MAC.OutLen}(\\lambda), \\ Q_{\\mathsf{A}}(\\lambda))</span>$</p>

    <p class="text-gray-300">forging adversary.</p>

    <p class="text-gray-300"><em>Proof.</em> Fix A and  <span class="math">\\lambda</span> , and let  <span class="math">\\mathbf{G}_0</span>  denote the original chosen ciphertext attack game. Let  <span class="math">T_0</span>  be the event that  <span class="math">\\sigma = \\hat{\\sigma}</span>  in game  <span class="math">\\mathbf{G}_0</span> .</p>

    <p class="text-gray-300">We next define a modified attack game  <span class="math">G_1</span> , in which all ciphertexts submitted to the decryption oracle by A in game  <span class="math">G_1</span>  are simply rejected.</p>

    <p class="text-gray-300">Let  <span class="math">T_1</span>  be the event that  <span class="math">\\sigma = \\hat{\\sigma}</span>  is game  <span class="math">\\mathbf{G}_1</span> . Let  <span class="math">R_1</span>  be the event in game  <span class="math">\\mathbf{G}_1</span>  that some ciphertext is rejected in game  <span class="math">\\mathbf{G}_1</span>  that would not have been rejected under the rules of game  <span class="math">\\mathbf{G}_0</span> .</p>

    <p class="text-gray-300">Since games  <span class="math">G_0</span>  and  <span class="math">G_1</span>  proceed identically until event  <span class="math">R_1</span>  occurs, the events  <span class="math">T_0 \\wedge \\neg R_1</span>  and  <span class="math">T_1 \\wedge \\neg R_1</span>  are identical, and so by Lemma 4, we have  <span class="math">|\\Pr[T_0] - \\Pr[T_1]| \\leq \\Pr[R_1]</span> .</p>

    <p class="text-gray-300">It is straightforward to verify that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[R_1] \\le \\mathsf{AdvForge}_{\\mathsf{MAC},\\mathsf{A}_2}(\\lambda) \\tag{16}</span>$</p>

    <p class="text-gray-300">for an adversary  <span class="math">A_2</span>  as described above.</p>

    <p class="text-gray-300">The theorem now follows by observing that the attack by A in game  <span class="math">G_1</span>  is now a passive attack. That is, the adversary  <span class="math">A_1</span>  in the theorem simply runs the adversary A, and whenever A makes a decryption oracle query, adversary  <span class="math">A_1</span>  simply lets A continue as if the decryption oracle rejected the ciphertext.  <span class="math">\\square</span></p>

    <p class="text-gray-300">Remark 12 Although the keys for SKE2 are longer than those for SKE1, this need not be the case if we use a pseudo-random bit generator to stretch a short key into a suitably long key. Indeed, the key length of any symmetric key encryption scheme need be no longer than the key length of a secure a pseudo-random bit generator.</p>

    <p class="text-gray-300">Let KEM be a key encapsulation mechanism (as defined in §7.1) and let SKE be a one-time symmetric key encryption scheme (as defined in §7.2). Further, let us assume that the two schemes are <em>compatible</em> in the sense that for all  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , we have KEM.KeyLen( <span class="math">\\lambda</span> ) = SKE.KeyLen( <span class="math">\\lambda</span> ). We now describe a hybrid public-key encryption scheme HPKE.</p>

    <p class="text-gray-300">The key generation algorithm for HPKE is the same as that of KEM, and the public and secret keys are the same as those of KEM.</p>

    <p class="text-gray-300">To encrypt a message m in the hybrid scheme, we run KEM.Encrypt to generate a symmetric key K and a ciphertext  <span class="math">\\psi</span>  encrypting K. We then encrypt m under the key K using SKE.Encrypt, obtaining a ciphertext  <span class="math">\\chi</span> . The output of the encryption algorithm is  <span class="math">\\hat{\\psi} = (\\psi, \\chi)</span> , encoded in a canonical fashion as a bit string.</p>

    <p class="text-gray-300">The decryption algorithm for the hybrid scheme runs as follows. Given a ciphertext  <span class="math">\\hat{\\psi}</span> , we first verify that  <span class="math">\\hat{\\psi}</span>  properly encodes a pair  <span class="math">(\\psi, \\chi)</span> . If not, we output reject and halt. Next, we decrypt  <span class="math">\\psi</span>  using KEM.Decrypt; if this yields reject, then we output reject and halt. Otherwise, we obtain a symmetric key K and decrypt  <span class="math">\\chi</span>  under K using SKE.Decrypt, and output the resulting decryption (which may be reject).</p>

    <p class="text-gray-300"><strong>Theorem 5</strong> If KEM and SKE are secure against adaptive chosen ciphertext attacks, then so is HPKE.</p>

    <p class="text-gray-300">In particular, if A is a probabilistic, polynomial-time oracle query machine, then there exist probabilistic oracle query machines  <span class="math">A_1</span>  and  <span class="math">A_2</span> , whose running times are essentially the same as that of A, such that for all  <span class="math">\\lambda \\in \\mathbf{Z}_{&gt;0}</span> , we have</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{AdvCCA}_{\\mathsf{HPKE},\\mathsf{A}}(\\lambda) \\leq \\mathsf{BadKeyPair}_{\\mathsf{KEM}}(\\lambda) + \\mathsf{AdvCCA}&#x27;_{\\mathsf{KEM},\\mathsf{A}_1}(\\lambda) + \\mathsf{AdvCCA}_{\\mathsf{SKE},\\mathsf{A}_2}(\\lambda).</span>$</p>

    <p class="text-gray-300">Proof. Fix A and  <span class="math">\\lambda</span> , and let  <span class="math">\\mathbf{G}_0</span>  be the original chosen ciphertext attack game played by A against HPKE. We let  <span class="math">\\hat{\\psi}^* = (\\psi^*, \\chi^*)</span>  denote the target ciphertext;  <span class="math">\\sigma</span>  is the hidden bit generated by the encryption oracle and  <span class="math">\\hat{\\sigma}</span>  is the bit output by A. Let  <span class="math">T_0</span>  be the event that  <span class="math">\\sigma = \\hat{\\sigma}</span> . Also, let  <span class="math">K^*</span>  denote the symmetric key output by the algorithm KEM.Encrypt during the encryption process within the encryption oracle.</p>

    <p class="text-gray-300">We now define a modified game  <span class="math">\\mathbf{G}_1</span> . In this game, whenever a ciphertext  <span class="math">(\\psi, \\chi)</span>  is submitted to the decryption oracle after the invocation of the encryption oracle, if  <span class="math">\\psi = \\psi^*</span>  (but  <span class="math">\\chi \\neq \\chi^*</span>  of course), then the decryption oracle does not apply algorithm KEM.Decrypt to obtain the symmetric key, but instead just uses the key  <span class="math">K^*</span>  produced by the encryption oracle. Let  <span class="math">T_1</span>  be the event that  <span class="math">\\sigma = \\hat{\\sigma}</span>  in game  <span class="math">\\mathbf{G}_1</span> .</p>

    <p class="text-gray-300">This change is slightly more than just conceptual, since KEM.KeyGen may generate a bad key pair with probability  <span class="math">\\mathsf{BadKeyPair}_{\\mathsf{KEM}}(\\lambda)</span> . However, unless this occurs, games  <span class="math">\\mathbf{G}_0</span>  and  <span class="math">\\mathbf{G}_1</span>  proceed identically, and so by Lemma 4, we have</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[T_1] - \\Pr[T_0]| \\leq \\mathsf{BadKeyPair}_{\\mathsf{KEM}}(\\lambda).</span>$</p>

    <p class="text-gray-300">Now we define a modified game  <span class="math">\\mathbf{G}_2</span> . This game behaves just like game  <span class="math">\\mathbf{G}_1</span> , except that we use a completely random symmetric key  <span class="math">K^+</span>  in place of the key  <span class="math">K^*</span>  in both the encryption and decryption oracles. Let  <span class="math">T_2</span>  be the event that  <span class="math">\\sigma = \\hat{\\sigma}</span>  in game  <span class="math">\\mathbf{G}_2</span> .</p>

    <p class="text-gray-300">It is straightforward to see that there is an oracle query machine  <span class="math">A_1</span> , whose running time is essentially the same as that of A, such that</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[T_2] - \\Pr[T_1]| = \\mathsf{AdvCCA}&#x27;_{\\mathsf{KEM.A}_1}(\\lambda).</span>$</p>

    <p class="text-gray-300">The adversary  <span class="math">A_1</span>  basically just runs the adversary A. In the attack game that  <span class="math">A_1</span>  is playing against KEM, the value  <span class="math">K^{\\dagger}</span>  is equal to  <span class="math">K^*</span>  in game  <span class="math">G_1</span> , and is equal to  <span class="math">K^+</span>  in game  <span class="math">G_2</span> . Note that in games  <span class="math">G_1</span>  and  <span class="math">G_2</span> , the ciphertext  <span class="math">\\psi^*</span>  is never explicitly decrypted, and so  <span class="math">A_1</span>  need not submit this for decryption either.</p>

    <p class="text-gray-300">Lastly, we observe that there is an oracle query machine  <span class="math">A_2</span> , whose running time is essentially the same as that of A, such that</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[T_2] - 1/2| = \\mathsf{AdvCCA}_{\\mathsf{SKE},\\mathsf{A}_2}(\\lambda).</span>$</p>

    <p class="text-gray-300">To see this, note that in game  <span class="math">\\mathbf{G}_2</span> , the ciphertext  <span class="math">\\chi^*</span>  is produced using the random symmetric encryption key  <span class="math">K^+</span> , and also that some other ciphertexts  <span class="math">\\chi \\neq \\chi^*</span>  are decrypted using  <span class="math">K^+</span> , but that the key  <span class="math">K^+</span>  plays no other role in game  <span class="math">\\mathbf{G}_2</span> . Thus, in game  <span class="math">\\mathbf{G}_2</span> , the adversary A is essentially just carrying out an adaptive chosen ciphertext attack against SKE.  <span class="math">\\square</span></p>

    <p class="text-gray-300">Remark 13 We stress that it is essential for both KEM and SKE to be secure against adaptive chosen ciphertext attack in order to prove that HPKE is as well. One cannot start with a &quot;weak&quot; KEM and hope to &quot;repair&quot; it with a hybrid construction: doing this may indeed foil some specific attacks, but we know of no way to formally reason about the security of such a scheme. It is also important not to waste the chosen ciphertext security of KEM by using a &quot;weak&quot; SKE. Indeed, some popular methods of constructing a &quot;digital envelope&quot; use a SKE that may only be secure against passive attacks; even if the resulting composite ciphertext is digitally signed, this does not necessarily provide security against chosen ciphertext attack.</p>

    <p class="text-gray-300">In the next section, we will present and analyze a key encapsulation mechanism. The key will be derived by hashing a pair of group elements. In order not to clutter that section, we develop here the notion of such a key derivation function.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{G}</span>  be a computational group scheme, specifying a sequence  <span class="math">(\\mathbf{S}_{\\lambda})_{\\lambda \\in \\mathbf{Z}_{\\geq 0}}</span>  of group distributions. A key derivation scheme KDF associated with  <span class="math">\\mathcal{G}</span>  specifies two items:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A family of key spaces indexed by  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span>  and  <span class="math">\\Gamma \\in [\\mathbf{S}_{\\lambda}]</span> . Each such key space is a probability space on bit strings denoted by KDF.KeySpace&lt;sub&gt; <span class="math">\\lambda,\\Gamma</span> &lt;/sub&gt;.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>There must exist a probabilistic, polynomial-time algorithm whose output distribution on input  <span class="math">1^{\\lambda}</span>  and  <span class="math">\\Gamma</span>  is equal to KDF.KeySpace&lt;sub&gt; <span class="math">\\lambda</span> &lt;/sub&gt; <span class="math">\\Gamma</span> .</li>
    </ul></li>
      <li>A family of key derivation functions indexed by  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> ,  <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span> , and  <span class="math">\\mathsf{dk} \\in [\\mathsf{KDF}.\\mathsf{KeySpace}_{\\lambda,\\Gamma}]</span> , where each such function  <span class="math">\\mathsf{KDF}^{\\lambda,\\Gamma}_{\\mathsf{dk}}</span>  maps a pair  <span class="math">(a,b) \\in G^2</span>  of group elements to a key K.</li>
    </ul>

    <p class="text-gray-300">A key K is a bit string of length  <span class="math">\\mathsf{KDF}.\\mathsf{OutLen}(\\lambda)</span> . The parameter  <span class="math">\\mathsf{KDF}.\\mathsf{OutLen}(\\lambda)</span>  should be computable in deterministic polynomial time given  <span class="math">1^{\\lambda}</span> .</p>

    <p class="text-gray-300">There must exist a deterministic, polynomial-time algorithm that on input  <span class="math">\\mathbf{1}^{\\lambda}</span> ,  <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span> ,  <span class="math">\\mathsf{dk} \\in [\\mathsf{KDF}.\\mathsf{KeySpace}_{\\lambda,\\Gamma}]</span> , and  <span class="math">(a,b) \\in G^2</span> , outputs  <span class="math">\\mathsf{KDF}_{\\mathsf{dk}}^{\\lambda,\\Gamma}(a,b)</span> .</p>

    <p class="text-gray-300">We now define the security property that we shall require of KDF.</p>

    <p class="text-gray-300">For all 0/1-valued, probabilistic, polynomial-time algorithms A, and for all  <span class="math">\\lambda \\in \\mathbb{Z}_{&gt;0}</span> , define</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathsf{AdvDist}_{\\mathsf{KDF},\\mathsf{A}}(\\lambda) &amp;:= \\\\ \\Big| \\Pr[\\ \\tau = 1 : \\Gamma \\overset{R}{\\leftarrow} \\mathbf{S}_{\\lambda}; \\ \\mathsf{dk} \\overset{R}{\\leftarrow} \\mathsf{KDF}.\\mathsf{KeySpace}_{\\lambda,\\Gamma}; \\ a,b \\overset{R}{\\leftarrow} G; \\\\ \\tau \\overset{R}{\\leftarrow} \\mathsf{A}(\\mathbf{1}^{\\lambda},\\Gamma,\\mathsf{dk},a,\\mathsf{KDF}^{\\lambda,\\Gamma}_{\\mathsf{dk}}(a,b)) \\ \\big] - \\\\ \\Pr[\\ \\tau = 1 : \\Gamma \\overset{R}{\\leftarrow} \\mathbf{S}_{\\lambda}; \\ \\mathsf{dk} \\overset{R}{\\leftarrow} \\mathsf{KDF}.\\mathsf{KeySpace}_{\\lambda,\\Gamma}; \\ a \\overset{R}{\\leftarrow} G; \\ K \\overset{R}{\\leftarrow} \\{0,1\\}^{\\mathsf{KDF}.\\mathsf{OutLen}(\\lambda)}; \\\\ \\tau \\overset{R}{\\leftarrow} \\mathsf{A}(\\mathbf{1}^{\\lambda},\\Gamma,\\mathsf{dk},a,K) \\ \\big] \\Big| \\end{split}</span>$</p>

    <p class="text-gray-300">That is,  <span class="math">\\mathsf{AdvDist}_{\\mathsf{KDF},\\mathsf{A}}(\\lambda)</span>  measures the advantage that A has in distinguishing two distributions: in the first it is given  <span class="math">\\mathsf{KDF}_{\\mathsf{dk}}^{\\lambda,\\Gamma}(a,b)</span>  and in the second it is given a random key K; in both distributions it is given the derivation key  <span class="math">\\mathsf{dk}</span>  as well as the auxiliary group element a.</p>

    <p class="text-gray-300">We shall say that KDF is secure if this distinguishing advantage is negligible, i.e.,</p>

    <p class="text-gray-300">for all 0/1-valued, probabilistic, polynomial-time algorithms A, the function  <span class="math">AdvDist_{KDF,A}(\\lambda)</span>  grows negligibly in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">It is also convenient to define a quantity analogous to  <span class="math">\\mathsf{AdvDist}_{\\mathsf{KDF},\\mathsf{A}}(\\lambda)</span> , but conditioned on a fixed group description. For all 0/1-valued, probabilistic, polynomial-time algorithms  <span class="math">\\mathsf{A}</span> , for all  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , and all  <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathsf{AdvDist}_{\\mathsf{KDF},\\mathsf{A}}(\\lambda \\mid \\Gamma) := \\\\ \\Big| \\Pr[ \\ \\tau = 1 : \\mathsf{dk} \\xleftarrow{R} \\mathsf{KDF}.\\mathsf{KeySpace}_{\\lambda,\\Gamma}; \\ a, b \\xleftarrow{R} G; \\\\ \\tau \\xleftarrow{R} \\mathsf{A}(\\mathbf{1}^{\\lambda}, \\Gamma, \\mathsf{dk}, a, \\mathsf{KDF}^{\\lambda,\\Gamma}_{\\mathsf{dk}}(a, b)) \\ ] - \\\\ \\Pr[ \\ \\tau = 1 : \\mathsf{dk} \\xleftarrow{R} \\mathsf{KDF}.\\mathsf{KeySpace}_{\\lambda,\\Gamma}; \\ a \\xleftarrow{R} G; \\ K \\xleftarrow{R} \\{0, 1\\}^{\\mathsf{KDF}.\\mathsf{OutLen}(\\lambda)}; \\\\ \\tau \\xleftarrow{R} \\mathsf{A}(\\mathbf{1}^{\\lambda}, \\Gamma, \\mathsf{dk}, a, K) \\ ] \\Big| \\end{split}</span>$</p>

    <h4 id="sec-27" class="text-lg font-semibold mt-6">8.1 Constructions</h4>

    <h4 id="sec-28" class="text-lg font-semibold mt-6">8.1.1 Unconditionally secure constructions</h4>

    <p class="text-gray-300">One can build a secure KDF for  <span class="math">\\mathcal{G}</span>  without any assumptions, provided the groups defined by  <span class="math">\\mathcal{G}</span>  are sufficiently large, which they certainly will be in our applications. Indeed, all we need is that KDF is <em>pair-wise independent</em>.</p>

    <p class="text-gray-300">In our context, we shall say that a KDF is pair-wise independent if for all  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , for all  <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span> , for all  <span class="math">a, b, b&#x27; \\in G</span>  with  <span class="math">b \\neq b&#x27;</span> , the distribution</p>

    <p class="text-gray-300"><span class="math">$\\{(\\mathsf{KDF}^{\\lambda,\\Gamma}_\\mathsf{dk}(a,b),\\mathsf{KDF}^{\\lambda,\\Gamma}_\\mathsf{dk}(a,b&#x27;)):\\mathsf{dk} \\xleftarrow{\\scriptscriptstyle R} \\mathsf{KDF}.\\mathsf{KeySpace}_{\\lambda,\\Gamma}\\}</span>$</p>

    <p class="text-gray-300">is the uniform distribution over all pairs of bits strings of length  <span class="math">\\mathsf{KDF}.\\mathsf{OutLen}(\\lambda)</span> .</p>

    <p class="text-gray-300">By the Leftover Hash Lemma [ILL89, IZ89], it follows that if KDF is pair-wise independent, then for all 0/1-valued, probabilistic, polynomial-time algorithms A, for all  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , and all  <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{AdvDist}_{\\mathsf{KDF},\\mathsf{A}}(\\lambda \\mid \\Gamma) \\leq 2^{-k}</span>$</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">$k = \\lfloor \\frac{\\lfloor \\log_2 q \\rfloor - \\mathsf{KDF}.\\mathsf{OutLen}(\\lambda)}{2} \\rfloor.</span>$</p>

    <p class="text-gray-300">We also point out that fairly efficient pair-wise independent functions can be constructed without relying on any intractability assumptions.</p>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">8.1.2 Conditionally secure constructions</h4>

    <p class="text-gray-300">In practice, to build a key derivation function, one might simply use a dedicated cryptographic hash function, like SHA-1.</p>

    <p class="text-gray-300">In this situation, we will simply be forced to assume that such a KDF is secure. However, such an intractability assumption is not entirely unreasonable. Moreover, a dedicated cryptographic hash function has several potential advantages over a pair-wise independent hash function:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>it may not use a key, or it may use a very short key, which may lead to a significant space savings;</li>
      <li>it can usually be evaluated more quickly than a typical pair-wise independent hash function can;</li>
      <li>it can be safely used to derive output keys that are significantly longer than would be safe to derive with a typical pair-wise independent hash function;</li>
      <li>it may, at least heuristically, provide even more security in applications than a typical pairwise independent hash function.</li>
    </ul>

    <h3 id="sec-30" class="text-xl font-semibold mt-8">9.1 Description of the Scheme</h3>

    <p class="text-gray-300">In this section, we present a hybrid version of our new encryption scheme. Specifically, we present a key encapsulation mechanism CS3, out of which one can easily construct a hybrid encryption scheme, as described in  <span class="math">\\S 7</span> .</p>

    <p class="text-gray-300">The scheme makes use of a computational group scheme  <span class="math">\\mathcal{G}</span>  as described in §4.1, defining a sequence  <span class="math">(\\mathbf{S}_{\\lambda})_{\\lambda \\in \\mathbf{Z}_{\\geq 0}}</span>  of distributions of group descriptions, and providing a sampling algorithm  <span class="math">\\hat{S}</span> , where the output distribution  <span class="math">\\hat{S}(1^{\\lambda})</span>  closely approximates  <span class="math">\\mathbf{S}_{\\lambda}</span> .</p>

    <p class="text-gray-300">The scheme also makes use of a binary group hashing scheme HF associated with  <span class="math">\\mathcal{G}</span> , as described in §5.</p>

    <p class="text-gray-300">Finally, the scheme makes use of a key derivation scheme KDF, associated with  <span class="math">\\mathcal{G}</span> , as described in §8. Note that output key length CS3.KeyLen( <span class="math">\\lambda</span> ) of the scheme is equal to KDF.OutLen( <span class="math">\\lambda</span> ).</p>

    <p class="text-gray-300">The scheme is described in detail in Figure 5.</p>

    <pre><code class="language-text">\\Gamma[\\hat{G},G,g,q] \\xleftarrow{\\scriptscriptstyle R} \\hat{S}(\\mathbf{1}^{\\lambda}); \\ \\mathsf{hk} \\xleftarrow{\\scriptscriptstyle R} \\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda,\\Gamma}; \\ \\mathsf{dk} \\xleftarrow{\\scriptscriptstyle R} \\mathsf{KDF}.\\mathsf{KeySpace}_{\\lambda,\\Gamma};
                                           w \\stackrel{R}{\\leftarrow} \\mathbf{Z}_{q}^{*}; \\ x_{1}, x_{2}, y_{1}, y_{2}, z_{1}, z_{2} \\stackrel{R}{\\leftarrow} \\mathbf{Z}_{q}; \\\\ \\hat{g} \\leftarrow g^{w}; \\ e \\leftarrow g^{x_{1}} \\hat{g}^{x_{2}}; \\ f \\leftarrow g^{y_{1}} \\hat{g}^{y_{2}}; \\ h \\leftarrow g^{z_{1}} \\hat{g}^{z_{2}};
       and output the public key \\mathsf{PK} = (\\Gamma, \\mathsf{hk}, \\mathsf{dk}, \\hat{g}, e, f, h) and the secret key
       \\mathsf{SK} = (\\Gamma, \\mathsf{hk}, \\mathsf{dk}, x_1, x_2, y_1, y_2, z_1, z_2).
Encryption: Given 1^{\\lambda} for \\lambda \\in \\mathbb{Z}_{&gt;0}, a public key
                      \\mathsf{PK} = (\\Gamma[\\hat{G}, G, g, g], \\mathsf{hk}, \\mathsf{dk}, \\hat{g}, e, f, h) \\in [\\mathbf{S}_{\\lambda}] \\times [\\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda, \\Gamma}] \\times [\\mathsf{KDF}.\\mathsf{KeySpace}_{\\lambda, \\Gamma}] \\times G^4,
       compute
               E1: u \\stackrel{R}{\\leftarrow} \\mathbf{Z}_a;
               E2: a \\leftarrow q^u:
               E3: \\hat{a} \\leftarrow \\hat{g}^u;
               E4: b \\leftarrow h^u:
              \\begin{aligned} \\mathbf{E5:} \\ \\ K \\leftarrow \\mathsf{KDF}^{\\lambda,\\Gamma}_{\\mathsf{dk}}(a,b); \\\\ \\mathbf{E6:} \\ \\ v \\leftarrow \\mathsf{HF}^{\\lambda,\\Gamma}_{\\mathsf{hk}}(a,\\hat{a}); \\\\ \\mathbf{E7:} \\ \\ d \\leftarrow e^u f^{uv}; \\end{aligned}
       and output the symmetric key K and the ciphertext \\psi = (a, \\hat{a}, d).
Decryption: Given 1^{\\lambda} for \\lambda \\in \\mathbb{Z}_{\\geq 0}, a secret key
           \\mathsf{SK} = (\\Gamma[\\hat{G}, G, g, q], \\mathsf{hk}, \\mathsf{dk}, x_1, x_2, y_1, y_2, z_1, z_2) \\in [\\mathbf{S}_{\\lambda}] \\times [\\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda, \\Gamma}] \\times [\\mathsf{KDF}.\\mathsf{KeySpace}_{\\lambda, \\Gamma}] \\times \\mathbf{Z}_{a}^6
       along with a ciphertext \\psi, do the following.
               D1: Parse \\psi as a 3-tuple (a, \\hat{a}, d) \\in \\hat{G}^3; output reject and halt if \\psi is not of this form.
               D2: Test if a and \\hat{a} belong to G; output reject and halt if this is not the case.
               D3: Compute v \\leftarrow \\mathsf{HF}^{\\lambda,\\Gamma}_{\\mathsf{hk}}(a,\\hat{a}).
               D4: Test if d = a^{x_1+y_1v} \\hat{a}^{x_2+y_2v}; output reject and halt if this is not the case.
               D5: Compute b \\leftarrow a^{z_1} \\hat{a}^{z_2}.
               D6: Compute K \\leftarrow \\mathsf{KDF}_{\\mathsf{dk}}^{\\lambda,\\Gamma}(a,b), and output the symmetric key K.
</code></pre>

    <p class="text-gray-300"><strong>Key Generation:</strong> On input  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbb{Z}_{&gt;0}</span> , compute</p>

    <p class="text-gray-300">Figure 5: The key encapsulation mechanism CS3</p>

    <h4 id="sec-31" class="text-lg font-semibold mt-6">9.2 Security analysis of the scheme</h4>

    <p class="text-gray-300">We shall prove that CS3 is secure against adaptive chosen ciphertext attack if the DDH assumption holds for  <span class="math">\\mathcal{G}</span> , and the TCR assumption holds for HF, and assuming that KDF is a secure key derivation scheme.</p>

    <p class="text-gray-300">As we have done before, for all probabilistic, polynomial-time oracle query machines A, and for all  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , we let  <span class="math">Q_{\\mathsf{A}}(\\lambda)</span>  be an upper bound on the number of decryption oracle queries made by A on input  <span class="math">\\mathbf{1}^{\\lambda}</span> . We assume that  <span class="math">Q_{\\mathsf{A}}(\\lambda)</span>  is a strict bound in the sense that it holds regardless of the probabilistic choices of A, and regardless of the responses to its oracle queries from its environment.</p>

    <p class="text-gray-300"><strong>Theorem 6</strong> If the DDH assumption holds for  <span class="math">\\mathcal G</span>  and the TCR assumption holds for HF, and assuming that KDF is a secure key derivation scheme, then CS3 is secure against adaptive chosen ciphertext attack</p>

    <p class="text-gray-300">In particular, for all probabilistic, polynomial-time oracle query machines A, there exist probabilistic algorithms  <span class="math">A_1</span> ,  <span class="math">A_2</span> , and  <span class="math">A_3</span>  whose running times are essentially the same as that of A, such that the following holds. For all  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , and all  <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span> , we have</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{AdvCCA}_{\\mathsf{CS3,A}}(\\lambda \\mid \\Gamma) \\leq \\mathsf{AdvDDH}_{\\mathcal{G},\\mathsf{A}_1}(\\lambda \\mid \\Gamma) + \\mathsf{AdvTCR}_{\\mathsf{HF},\\mathsf{A}_2}(\\lambda \\mid \\Gamma) + \\mathsf{AdvDist}_{\\mathsf{KDF},\\mathsf{A}_3}(\\lambda \\mid \\Gamma) + (Q_\\mathsf{A}(\\lambda) + 3)/q. \\tag{17}</span>$</p>

    <p class="text-gray-300">To prove Theorem 6, let us fix a probabilistic, polynomial-time oracle query machine A, the value of the security parameter  <span class="math">\\lambda \\in \\mathbf{Z}_{&gt;0}</span> , and the group description  <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span> .</p>

    <p class="text-gray-300">The proof follows the same line of argument as the proof of Theorem 1, and we will at several places appeal to argument in that proof, so as to avoid unnecessary repetition.</p>

    <p class="text-gray-300">The attack game is as described in §7.1.2. We now discuss the relevant random variables in this game.</p>

    <p class="text-gray-300">Suppose that the public key is  <span class="math">(\\Gamma, \\mathsf{hk}, \\mathsf{dk}, \\hat{g}, e, f, h)</span>  and that the secret key is  <span class="math">(\\Gamma, \\mathsf{hk}, \\mathsf{dk}, x_1, x_2, y_1, y_2, z_1, z_2)</span> . Let  <span class="math">w := \\log_q \\hat{g}</span> , and define  <span class="math">x, y, z \\in \\mathbf{Z}_q</span>  as follows:</p>

    <p class="text-gray-300"><span class="math">$x := x_1 + x_2 w</span>$
,  <span class="math">y := y_1 + y_2 w</span> ,  <span class="math">z := z_1 + z_2 w</span> .</p>

    <p class="text-gray-300">As a notational convention, whenever a particular ciphertext  <span class="math">\\psi</span>  is under consideration in some context, the following values are also implicitly defined in that context:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">a, \\hat{a}, d \\in G</span> , where  <span class="math">\\psi = (a, \\hat{a}, d)</span> ;</li>
      <li><span class="math">u, \\hat{u}, v, s \\in \\mathbf{Z}_q</span> , where</li>
    </ul>

    <p class="text-gray-300"><span class="math">$u := \\log_g a, \\ \\hat{u} := \\log_{\\hat{g}} \\hat{a}, \\ v := \\mathsf{HF}^{\\lambda, \\Gamma}_{\\mathsf{hk}}(a, \\hat{a}), \\quad s := \\log_g d.</span>$</p>

    <p class="text-gray-300">For the target ciphertext  <span class="math">\\psi^*</span> , we also denote by  <span class="math">a^*, \\hat{a}^*, d^* \\in G</span> , and  <span class="math">u^*, \\hat{u}^*, v^*, s^* \\in \\mathbf{Z}_q</span>  the corresponding values.</p>

    <p class="text-gray-300">The probability space defining the attack game is then determined by the following, mutually independent, random variables:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the coin tosses of A;</li>
      <li>the values hk, dk, w,  <span class="math">x_1</span> ,  <span class="math">x_2</span> ,  <span class="math">y_1</span> ,  <span class="math">y_2</span> ,  <span class="math">z_1</span> ,  <span class="math">z_2</span>  generated by the key generation algorithm;</li>
      <li>the values  <span class="math">\\tau \\in \\{0,1\\}</span> ,  <span class="math">K^+ \\in \\{0,1\\}^{\\mathsf{KDF}.\\mathsf{OutLen}(\\lambda)}</span> , and  <span class="math">u^* \\in \\mathbf{Z}_q</span>  generated by the encryption oracle in the attack game.</li>
    </ul>

    <p class="text-gray-300">Let  <span class="math">\\mathbf{G}_0</span>  be the original attack game, let  <span class="math">\\hat{\\tau} \\in \\{0,1\\}</span>  denote the output of A, and let  <span class="math">T_0</span>  be the event that  <span class="math">\\tau = \\hat{\\tau}</span>  in  <span class="math">\\mathbf{G}_0</span> , so that  <span class="math">\\mathsf{AdvCCA}_{\\mathsf{CS3,A}}(\\lambda \\mid \\Gamma) = |\\Pr[T_0] - 1/2|</span> .</p>

    <p class="text-gray-300">As in the proof of Theorem 1, we shall define a sequence of modified games  <span class="math">\\mathbf{G}_i</span> , for i = 1, 2, ..., where in game  <span class="math">\\mathbf{G}_i</span> , the event  <span class="math">T_i</span>  will be the event corresponding to event  <span class="math">T_0</span> , but in game  <span class="math">\\mathbf{G}_i</span> . The overall structure of the proof will differ a bit from that of Theorem 1, even though many of the low level details will be very similar. Indeed, the proof of this theorem is conceptually a bit simpler (even though there are more steps) than that of Theorem 1, since the inputs to  <span class="math">\\mathsf{HF}^{\\lambda,\\Gamma}_{\\mathsf{hk}}</span>  in the encryption oracle are independent of any quantities computed by the adversary; we also save a term of 1/q in (17) because of this.</p>

    <p class="text-gray-300"><strong>Game G</strong>&lt;sub&gt;1&lt;/sub&gt;. We now modify game  <span class="math">\\mathbf{G}_0</span>  to obtain a new game  <span class="math">\\mathbf{G}_1</span> . These two games are identical, except that instead of using the encryption algorithm as given to compute the target ciphertext  <span class="math">\\psi^*</span> , we use a modified encryption algorithm, in which steps  <span class="math">\\mathbf{E}\\mathbf{4}</span>  and  <span class="math">\\mathbf{E}\\mathbf{7}</span>  are replaced by:</p>

    <p class="text-gray-300"><strong>E4':</strong>
<span class="math">$b \\leftarrow a^{z_1} \\hat{a}^{z_2}</span>$
;</p>

    <p class="text-gray-300"><strong>E7':</strong>
<span class="math">$d \\leftarrow a^{x_1 + y_1 v} \\hat{a}^{x_2 + y_2 v}</span>$
.</p>

    <p class="text-gray-300">By the same reasoning as in the proof of Theorem 1, we have</p>

    <p class="text-gray-300"><span class="math">$\\Pr[T_1] = \\Pr[T_0].</span>$</p>

    <p class="text-gray-300"><strong>Game G_2.</strong> We again modify the encryption oracle, replacing step <strong>E3</strong> by</p>

    <p class="text-gray-300"><strong>E3':</strong>
<span class="math">$\\hat{u} \\stackrel{R}{\\leftarrow} \\mathbf{Z}_q</span>$
;  <span class="math">\\hat{a} \\leftarrow \\hat{g}^{\\hat{u}}</span> .</p>

    <p class="text-gray-300">By the same reasoning as in the proof of Theorem 1, one sees that there exists a probabilistic algorithm  <span class="math">A_1</span> , whose running time is essentially the same as that of A, such that</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[T_2] - \\Pr[T_1]| \\le \\mathsf{AdvDDH}_{\\mathcal{G},\\mathsf{A}_1}(\\lambda \\mid \\Gamma) + 2/q.</span>$</p>

    <p class="text-gray-300">Note that unlike game  <span class="math">G_2</span>  in the proof of Theorem 1, we do not impose the restriction  <span class="math">u^* \\neq \\hat{u}^*</span>  just yet; it is technically convenient to defer this until later. This is why the term 2/q appears in the above bound, rather than 3/q.</p>

    <p class="text-gray-300"><strong>Game G</strong>&lt;sub&gt;3&lt;/sub&gt;. This game is the same as game  <span class="math">G_2</span> , except for the following modification.</p>

    <p class="text-gray-300">We modify the decryption oracle so that it applies the following special rejection rule: if the adversary submits a ciphertext  <span class="math">\\psi</span>  for decryption at a point in time after the encryption oracle has been invoked, such that  <span class="math">(a, \\hat{a}) \\neq (a^*, \\hat{a}^*)</span>  but  <span class="math">v = v^*</span> , then the decryption oracle immediately outputs reject and halts (before executing step  <span class="math">\\mathbf{D4}&#x27;</span> ).</p>

    <p class="text-gray-300">We claim that there exists a probabilistic algorithm  <span class="math">A_2</span> , whose running time is essentially the same as that of A, such that</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[T_3] - \\Pr[T_2]| \\le \\mathsf{AdvTCR}_{\\mathsf{HF},\\mathsf{A}_2}(\\lambda \\mid \\Gamma).</span>$</p>

    <p class="text-gray-300">This follows from reasoning very similar to the proof of Lemma 7 in the analysis of game  <span class="math">G_5</span>  in the proof of Theorem 1. Observe that we can impose the special rejection rule already in this game, rather than deferring to to a later game as in the proof of Theorem 1, because, as we mentioned above, the inputs to  <span class="math">\\mathsf{HF}^{\\lambda,\\Gamma}_{\\mathsf{hk}}</span>  in the encryption oracle are independent of any quantities computed by the adversary.</p>

    <p class="text-gray-300">Game G4. We again modify the encryption oracle, replacing step E3&lt;sup&gt;0&lt;/sup&gt; by</p>

    <p class="text-gray-300">E3&quot;:
<span class="math">$\\hat{u} \\stackrel{R}{\\leftarrow} \\mathbf{Z}_q \\setminus \\{u\\}; \\ \\hat{a} \\leftarrow \\hat{g}^{\\hat{u}}.</span>$</p>

    <p class="text-gray-300">It is easy to verify that</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[T_4] - \\Pr[T_3]| \\le 1/q.</span>$</p>

    <p class="text-gray-300">Game G5. In this game, we modify the decryption oracle in game G4, replacing steps D4 and D5 with:</p>

    <p class="text-gray-300">D4&lt;sup&gt;0&lt;/sup&gt; : Test if ˆa = a &lt;sup&gt;w&lt;/sup&gt; and d = a &lt;sup&gt;x&lt;/sup&gt;+yv; output reject and halt if this is not the case.</p>

    <p class="text-gray-300">D5&lt;sup&gt;0&lt;/sup&gt; : b ← a z .</p>

    <p class="text-gray-300">Let R&lt;sup&gt;5&lt;/sup&gt; be the event that in game G5, some ciphertext ψ is submitted to the decryption oracle that is rejected in step D4&lt;sup&gt;0&lt;/sup&gt; but that would have passed the test in step D4.</p>

    <p class="text-gray-300">It is clear that</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[T_5] - \\Pr[T_4]| \\le \\Pr[R_5].</span>$</p>

    <p class="text-gray-300">We also claim that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[R_5] \\le Q_{\\mathsf{A}}(\\lambda)/q.</span>$</p>

    <p class="text-gray-300">This follows from reasoning analogous to that in Lemma 8 (in game G&lt;sup&gt;5&lt;/sup&gt; in the proof of Theorem 1).</p>

    <p class="text-gray-300">Game G6. We again modify the algorithm used by the encryption oracle, replacing step E4&lt;sup&gt;0&lt;/sup&gt; by</p>

    <p class="text-gray-300"><strong>E4&quot;:</strong>
<span class="math">$r \\stackrel{R}{\\leftarrow} \\mathbf{Z}_q</span>$
;  <span class="math">b \\leftarrow g^r</span> .</p>

    <p class="text-gray-300">By reasoning analogous to that in the analysis of game G&lt;sup&gt;4&lt;/sup&gt; in the proof of Theorem 1, one can easily show that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[T_6] = \\Pr[T_5].</span>$</p>

    <p class="text-gray-300">Game G7. In this game, we modify the encryption oracle, replacing step E5 of the encryption algorithm by</p>

    <p class="text-gray-300"><strong>E5':</strong>
<span class="math">$K \\stackrel{R}{\\leftarrow} \\{0,1\\}^{\\mathsf{KDF.OutLen}(\\lambda)}</span>$
.</p>

    <p class="text-gray-300">It is straightforward to see that there exists a probabilistic algorithm A3, whose running time is essentially the same as that of A, such that</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[T_7] - \\Pr[T_6]| \\le \\mathsf{AdvDist}_{\\mathsf{KDF},\\mathsf{A}_3}(\\lambda \\mid \\Gamma).</span>$</p>

    <p class="text-gray-300">Furthermore, it is clear that by construction that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[T_7] = 1/2.</span>$</p>

    <p class="text-gray-300">That completes the proof of Theorem 6.</p>

    <p class="text-gray-300"><strong>Key Generation:</strong> On input  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbb{Z}_{&gt;0}</span> , compute</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp;\\Gamma[\\hat{G},G,g,q] \\overset{\\scriptscriptstyle R}{\\leftarrow} \\hat{S}(1^{\\lambda}); \\ \\ \\mathsf{hk} \\overset{\\scriptscriptstyle R}{\\leftarrow} \\ \\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda,\\Gamma}; \\ \\ \\mathsf{dk} \\overset{\\scriptscriptstyle R}{\\leftarrow} \\ \\mathsf{KDF}.\\mathsf{KeySpace}_{\\lambda,\\Gamma}; \\\\ &amp;w \\overset{\\scriptscriptstyle R}{\\leftarrow} \\mathbf{Z}_q^*; \\ \\ x_1,x_2,y_1,y_2,z \\overset{\\scriptscriptstyle R}{\\leftarrow} \\mathbf{Z}_q; \\\\ &amp;\\hat{g} \\leftarrow g^w; \\ \\ e \\leftarrow g^{x_1}\\hat{g}^{x_2}; \\ \\ f \\leftarrow g^{y_1}\\hat{g}^{y_2}; \\ \\ h \\leftarrow g^z; \\end{split}</span>$</p>

    <p class="text-gray-300">and output the public key  <span class="math">PK = (\\Gamma, hk, dk, \\hat{g}, e, f, h)</span>  and the secret key  <span class="math">SK = (\\Gamma, hk, dk, x_1, x_2, y_1, y_2, z)</span></p>

    <p class="text-gray-300"><strong>Decryption:</strong> Given  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbb{Z}_{&gt;0}</span> , a secret key</p>

    <p class="text-gray-300"><span class="math">\\mathsf{SK} = (\\Gamma[\\hat{G}, G, g, q], \\mathsf{hk}, \\mathsf{dk}, x_1, x_2, y_1, y_2, z) \\in [\\mathbf{S}_{\\lambda}] \\times [\\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda, \\Gamma}] \\times [\\mathsf{KDF}.\\mathsf{KeySpace}_{\\lambda, \\Gamma}] \\times \\mathbf{Z}_q^5</span> along with a ciphertext  <span class="math">\\psi</span> , do the following.</p>

    <p class="text-gray-300"><strong>D1:</strong> Parse  <span class="math">\\psi</span>  as a 3-tuple  <span class="math">(a, \\hat{a}, d) \\in \\hat{G}^3</span> ; output reject and halt if  <span class="math">\\psi</span>  is not of this form.</p>

    <p class="text-gray-300"><strong>D2:</strong> Test if a and  <span class="math">\\hat{a}</span>  belong to G; output reject and halt if this is not the case.</p>

    <p class="text-gray-300"><strong>D3:</strong> Compute  <span class="math">v \\leftarrow \\mathsf{HF}^{\\lambda,\\Gamma}_{\\mathsf{hk}}(a,\\hat{a})</span> . <strong>D4:</strong> Test if  <span class="math">d = a^{x_1 + y_1 v} \\hat{a}^{x_2 + y_2 v}</span> ; output reject and halt if this is not the case.</p>

    <p class="text-gray-300"><strong>D5</strong>': Compute  <span class="math">b \\leftarrow a^z</span> .</p>

    <p class="text-gray-300"><strong>D6:</strong> Compute  <span class="math">K \\leftarrow \\mathsf{KDF}^{\\lambda,\\Gamma}_{\\mathsf{dk}}(a,b)</span> , and output the symmetric key K.</p>

    <p class="text-gray-300">Figure 6: Key generation and decryption algorithms for CS3a</p>

    <p class="text-gray-300"><strong>Key Generation:</strong> On input  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbb{Z}_{&gt;0}</span> , compute</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp;\\Gamma[\\hat{G},G,g,q] \\overset{\\scriptscriptstyle R}{\\leftarrow} \\hat{S}(\\mathbf{1}^{\\lambda}); \\text{ hk } \\overset{\\scriptscriptstyle R}{\\leftarrow} \\text{HF.KeySpace}_{\\lambda,\\Gamma}; \\text{ dk } \\overset{\\scriptscriptstyle R}{\\leftarrow} \\text{KDF.KeySpace}_{\\lambda,\\Gamma};\\\\ &amp;w \\overset{\\scriptscriptstyle R}{\\leftarrow} \\mathbf{Z}_q^*; \\ x,y,z \\overset{\\scriptscriptstyle R}{\\leftarrow} \\mathbf{Z}_q;\\\\ &amp;\\hat{g} \\leftarrow g^w; \\ e \\leftarrow g^x; \\ f \\leftarrow g^y; \\ h \\leftarrow g^z; \\end{split}</span>$</p>

    <p class="text-gray-300">and output the public key  <span class="math">PK = (\\Gamma, hk, dk, \\hat{g}, e, f, h)</span>  and the secret key  <span class="math">SK = (\\Gamma, hk, dk, x, y, z)</span> .</p>

    <p class="text-gray-300"><strong>Decryption:</strong> Given  <span class="math">1^{\\lambda}</span>  for  <span class="math">\\lambda \\in \\mathbb{Z}_{\\geq 0}</span> , a secret key</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{SK} = (\\Gamma[\\hat{G}, G, g, q], \\mathsf{hk}, \\mathsf{dk}, x, y, z) \\in [\\mathbf{S}_{\\lambda}] \\times [\\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda, \\Gamma}] \\times [\\mathsf{KDF}.\\mathsf{KeySpace}_{\\lambda, \\Gamma}] \\times \\mathbf{Z}_q^3,</span>$
along with a ciphertext  <span class="math">\\psi</span> , do the following.</p>

    <p class="text-gray-300"><strong>D1:</strong> Parse  <span class="math">\\psi</span>  as a 3-tuple  <span class="math">(a, \\hat{a}, d) \\in \\hat{G}^3</span> ; output reject and halt if  <span class="math">\\psi</span>  is not of this form.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{D2&#x27;}</span> : Test if a belongs to G; output reject and halt if this is not the case.</p>

    <p class="text-gray-300"><strong>D3:</strong> Compute  <span class="math">v \\leftarrow \\mathsf{HF}^{\\lambda,\\Gamma}_{\\mathsf{hk}}(a,\\hat{a})</span> .</p>

    <p class="text-gray-300"><strong>D4':</strong> Test if  <span class="math">\\hat{a} = a^w</span>  and  <span class="math">d = a^{x+yv}</span> ; output reject and halt if this is not the case.</p>

    <p class="text-gray-300"><strong>D5':</strong> Compute  <span class="math">b \\leftarrow a^z</span> .</p>

    <p class="text-gray-300"><strong>D6:</strong> Compute  <span class="math">K \\leftarrow \\mathsf{KDF}^{\\lambda,\\Gamma}_{\\mathsf{dk}}(a,b)</span> , and output the symmetric key K.</p>

    <p class="text-gray-300">Figure 7: Key generation and decryption algorithms for CS3b</p>

    <p class="text-gray-300">One can easily modify scheme CS3 to obtain two variants, which we call CS3a and CS3b, that are analogous to the variations CS1a and CS1b of CS1, discussed in §6.3. Only the key generation and decryption algorithms differ. The details are are presented in Figures 6 and 7.</p>

    <p class="text-gray-300">Remark 14 Scheme CS3b is essentially the same scheme that was originally presented in [Sho00b]. This scheme is the most efficient scheme among all those presented in this paper. It is also attractive in that it yields a public-key encryption scheme with an unrestricted message space. Moreover, this scheme has some other attractive security properties that will be examined in §10.</p>

    <p class="text-gray-300">Remark 15 Analogous to Remark 7, we do not have to separately test if ˆa belongs to the subgroup G in step D2&lt;sup&gt;0&lt;/sup&gt; of the decryption algorithm of CS3b, and we may test if a belongs to G in some cases by testing if a &lt;sup&gt;q&lt;/sup&gt; = 1G.</p>

    <p class="text-gray-300">Remark 16 Analogous to Remark 8, in scheme CS3b, the decryption algorithm has to compute either three or four (if we test if a &lt;sup&gt;q&lt;/sup&gt; = 1G) powers of a, and special algorithmic techniques can be exploited to do this.</p>

    <p class="text-gray-300">Remark 17 Analogous to Remarks 9 and 10, it is strongly recommended to always compute both exponentiations in step D4&lt;sup&gt;0&lt;/sup&gt; of CS3b before rejecting the ciphertext, and to not reveal the precise reason why any ciphertext was rejected.</p>

    <p class="text-gray-300">The following theorem can proved using an argument almost identical to the argument that was used to prove Theorem 2. We leave it to the reader to verify this.</p>

    <p class="text-gray-300">Theorem 7 If the DDH assumption holds for G and the TCR assumption holds for HF, and assuming that KDF is a secure key derivation scheme, then CS3a and CS3b are secure against adaptive chosen ciphertext attack.</p>

    <p class="text-gray-300">In particular, for all probabilistic, polynomial-time oracle query machines A, for all λ ∈ Z≥0, and all Γ[G, G, g, q ˆ ] ∈ [Sλ], we have</p>

    <p class="text-gray-300"><span class="math">$|\\mathsf{AdvCCA}_{\\mathsf{CS3a},\\mathsf{A}}(\\lambda \\mid \\Gamma) - \\mathsf{AdvCCA}_{\\mathsf{CS3},\\mathsf{A}}(\\lambda \\mid \\Gamma)| \\leq Q_{\\mathsf{A}}(\\lambda)/q_{\\mathsf{A}}(\\lambda \\mid \\Gamma)</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$|\\mathsf{AdvCCA}_{\\mathsf{CS3b},\\mathsf{A}}(\\lambda\\mid\\Gamma) - \\mathsf{AdvCCA}_{\\mathsf{CS3},\\mathsf{A}}(\\lambda\\mid\\Gamma)| \\leq Q_{\\mathsf{A}}(\\lambda)/q</span>$</p>

    <p class="text-gray-300">The key encapsulation mechanism CS3b, which was described and analyzed in §9.3, has some other interesting security properties, which we discuss in this section.</p>

    <p class="text-gray-300">The main results we present here are the following. First, we show that CS3b is no less secure than a more traditional key encapsulation mechanism that is a hashed variant of ElGamal encryption, which we call HEG. Second, we also show that CS3b is secure in the random oracle model (viewing KDF as a random oracle) if the CDH and TCR assumptions hold. Along the way, we also give a security analysis of HEG in the random oracle model, based on a rather non-standard intractability assumption.</p>

    <h4 id="sec-32" class="text-lg font-semibold mt-6">10.1 Hashed ElGamal key encapsulation</h4>

    <p class="text-gray-300">We begin by presenting a fairly traditional version of ElGamal key encapsulation, which we call HEG.</p>

    <p class="text-gray-300">The scheme makes use of a computational group scheme  <span class="math">\\mathcal{G}</span>  as described in §4.1, defining a sequence  <span class="math">(\\mathbf{S}_{\\lambda})_{\\lambda \\in \\mathbf{Z}_{\\geq 0}}</span>  of distributions of group descriptions, and providing a sampling algorithm  <span class="math">\\hat{S}</span> , where the output distribution  <span class="math">\\hat{S}(\\mathbf{1}^{\\lambda})</span>  closely approximates  <span class="math">\\mathbf{S}_{\\lambda}</span> .</p>

    <p class="text-gray-300">Also, the scheme makes use of a key derivation scheme KDF, associated with  <span class="math">\\mathcal{G}</span> , as described in §8. Note that output key length EG.KeyLen( <span class="math">\\lambda</span> ) of the scheme is equal to KDF.OutLen( <span class="math">\\lambda</span> ).</p>

    <p class="text-gray-300">The scheme is described in detail in Figure 8.</p>

    <h3 id="sec-33" class="text-xl font-semibold mt-8">10.2 The random oracle model</h3>

    <p class="text-gray-300">We will analyze the security of both schemes HEG and CS3b in the random oracle model. In this approach, a cryptographic hash function — in this case KDF — is modeled for the purposes of analysis as a &quot;black box&quot; containing a random function to which the adversary and the algorithms implementing the cryptosystem have &quot;oracle access.&quot; This approach has been used implicitly and informally for some time; however, it was formalized by Bellare and Rogaway [BR93], and has subsequently been used quite a bit in the cryptographic research community.</p>

    <p class="text-gray-300">More precisely, we shall analyze the security the scheme HEG and later CS3b in an idealized model of computation where for all  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , all  <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span> , all  <span class="math">\\mathsf{dk} \\in [\\mathsf{KDF}.\\mathsf{KeySpace}_{\\lambda,\\Gamma}]</span> , and all  <span class="math">a, b \\in G</span> , we treat the values  <span class="math">\\mathsf{KDF}^{\\lambda,\\Gamma}_{\\mathsf{dk}}(a,b)</span>  as mutually independent, random bit strings of length  <span class="math">\\mathsf{KDF}.\\mathsf{OutLen}(\\lambda)</span> ; moreover, the only way to obtain the value of  <span class="math">\\mathsf{KDF}^{\\lambda,\\Gamma}_{\\mathsf{dk}}(a,b)</span>  to to explicitly query an oracle with input  <span class="math">(\\lambda,\\Gamma,\\mathsf{dk},a,b)</span> . Actually, to be complete, we allow  <span class="math">\\Gamma</span> ,  <span class="math">\\mathsf{dk},a</span> , and b to range over arbitrary bit strings, regardless of whether these are valid encodings of appropriate objects. Since in any of our applications, only a finite number of the values  <span class="math">\\mathsf{KDF}^{\\lambda,\\Gamma}_{\\mathsf{dk}}(a,b)</span>  will be relevant, experiments based on these values can be modeled using finite probability spaces.</p>

    <p class="text-gray-300">When considering an adversary A that is carrying out an adaptive chosen ciphertext attack in the random oracle model, in addition to the usual types of oracle queries that A makes, the adversary A is also allowed to query the random oracle representing KDF. We shall denote by  <span class="math">Q&#x27;_{\\mathsf{A}}(\\lambda)</span>  a strict upper bound on the number of random oracle queries that A makes for a given value of the security parameter  <span class="math">\\lambda</span> ; as usual, this bound should hold regardless of the environment in which A actually runs.</p>

    <p class="text-gray-300">We now show that the scheme CS3b is at least as secure as HEG.</p>

    <p class="text-gray-300"><strong>Theorem 8</strong> If scheme HEG is secure against adaptive chosen ciphertext attack, then so is CS3b; moreover, this implication holds in either the standard or random oracle models.</p>

    <p class="text-gray-300">In particular, for all probabilistic, polynomial-time oracle query machines A, there exists another oracle query machine  <span class="math">A_1</span> , whose running time is essentially the same as that of A, such that for all  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , and all  <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span> , we have</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{AdvCCA}_{\\mathsf{CS3b},\\mathsf{A}}(\\lambda \\mid \\Gamma) \\leq \\mathsf{AdvCCA}_{\\mathsf{HEG},\\mathsf{A}_1}(\\lambda \\mid \\Gamma);</span>$</p>

    <p class="text-gray-300">moreover,  <span class="math">Q_{A_1}(\\lambda) \\leq Q_{A}(\\lambda)</span>  and (in the random oracle model)  <span class="math">Q&#x27;_{A_1}(\\lambda) \\leq Q&#x27;_{A}(\\lambda)</span> .</p>

    <p class="text-gray-300">Key Generation: On input 1 λ for λ ∈ Z&lt;sup&gt;≥&lt;/sup&gt;0, compute</p>

    <p class="text-gray-300"><span class="math">$\\Gamma[\\hat{G},G,g,q] \\overset{\\scriptscriptstyle R}{\\leftarrow} \\hat{S}(\\mathbf{1}^{\\lambda}); \\ \\mathsf{dk} \\overset{\\scriptscriptstyle R}{\\leftarrow} \\mathsf{KDF}.\\mathsf{KeySpace}_{\\lambda,\\Gamma}; \\ z \\overset{\\scriptscriptstyle R}{\\leftarrow} \\mathbf{Z}_q; \\ h \\leftarrow g^z;</span>$</p>

    <p class="text-gray-300">and output the public key PK = (Γ, dk, h) and the secret key SK = (Γ, dk, z).</p>

    <p class="text-gray-300">Encryption: Given 1 λ for λ ∈ Z&lt;sup&gt;≥&lt;/sup&gt;0, a public key</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{PK} = (\\Gamma[\\hat{G}, G, g, q], \\mathsf{dk}, h) \\in [\\mathbf{S}_{\\lambda}] \\times [\\mathsf{KDF}.\\mathsf{KeySpace}_{\\lambda, \\Gamma}] \\times G,</span>$</p>

    <p class="text-gray-300">compute</p>

    <p class="text-gray-300">E1: u &lt;sup&gt;R&lt;/sup&gt;← Zq;</p>

    <p class="text-gray-300">E2: a ← g u ;</p>

    <p class="text-gray-300">E3: b ← h u ;</p>

    <p class="text-gray-300">E4: K ← KDFλ,&lt;sup&gt;Γ&lt;/sup&gt; dk (a, b);</p>

    <p class="text-gray-300">and output the symmetric key K and the ciphertext ψ = a.</p>

    <p class="text-gray-300">Decryption: Given 1 λ for λ ∈ Z&lt;sup&gt;≥&lt;/sup&gt;0, a secret key</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{SK} = (\\Gamma[\\hat{G}, G, g, q], \\mathsf{dk}, z) \\in [\\mathbf{S}_{\\lambda}] \\times [\\mathsf{KDF}.\\mathsf{KeySpace}_{\\lambda, \\Gamma}] \\times \\mathbf{Z}_q,</span>$</p>

    <p class="text-gray-300">along with a ciphertext ψ, do the following.</p>

    <p class="text-gray-300">D1: Parse ψ as a group element a ∈ Gˆ; output reject and halt if ψ is not of this form.</p>

    <p class="text-gray-300">D2: Test if a belongs to G; output reject and halt if this is not the case.</p>

    <p class="text-gray-300">D3: Compute b ← a z .</p>

    <p class="text-gray-300">D4: Compute K ← KDFλ,&lt;sup&gt;Γ&lt;/sup&gt; dk (a, b), and output the symmetric key K.</p>

    <p class="text-gray-300">Figure 8: The key encapsulation mechanism HEG</p>

    <p class="text-gray-300"><em>Proof.</em> Fix A,  <span class="math">\\lambda</span> , and  <span class="math">\\Gamma[\\hat{G}, G, g, q]</span>  as above. We construct an adversary A&lt;sub&gt;1&lt;/sub&gt; that attacks HEG. The adversary A&lt;sub&gt;1&lt;/sub&gt; makes use of A by providing an environment for A, as follows.</p>

    <p class="text-gray-300">First, suppose that  <span class="math">A_1</span>  is given a public key  <span class="math">(\\Gamma, dk, h)</span>  for scheme HEG, where  <span class="math">\\Gamma</span>  is fixed as above. Adversary  <span class="math">A_1</span>  then &quot;dresses up&quot; the HEG public key to look like a CS3b public key; namely,  <span class="math">A_1</span>  computes</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{hk} \\overset{R}{\\leftarrow} \\mathsf{HF}.\\mathsf{KeySpace}_{\\lambda \\Gamma}; \\ w \\overset{R}{\\leftarrow} \\mathbf{Z}_{q}^{*}; \\ x, y \\overset{R}{\\leftarrow} \\mathbf{Z}_{q}; \\ \\hat{g} \\leftarrow g^{w}; \\ e \\leftarrow g^{x}; \\ f \\leftarrow g^{y};</span>$</p>

    <p class="text-gray-300">and presents A with the CS3b public key</p>

    <p class="text-gray-300"><span class="math">$(\\Gamma, \\mathsf{hk}, \\mathsf{dk}, \\hat{g}, e, f, h).</span>$</p>

    <p class="text-gray-300">Second, whenever A submits a CS3b ciphertext  <span class="math">(a, \\hat{a}, d) \\in \\hat{G}^3</span>  to the decryption oracle, adversary A&lt;sub&gt;1&lt;/sub&gt; first performs the validity tests of the decryption algorithm of CS3b, making use of the values hk, w, x, y generated above; if these tests pass, then A&lt;sub&gt;1&lt;/sub&gt; invokes the decryption oracle of HEG with input a.</p>

    <p class="text-gray-300">Third, when A invokes the encryption oracle of CS3b, adversary  <span class="math">A_1</span>  does the following. It invokes the encryption oracle of HEG, obtaining a ciphertext  <span class="math">a^* \\in G</span>  and a key  <span class="math">K^{\\dagger}</span> . It then &quot;dresses up&quot;  <span class="math">a^*</span>  to look like a CS3b ciphertext; namely, it computes</p>

    <p class="text-gray-300"><span class="math">$\\hat{a}^* \\leftarrow (a^*)^w; \\ v^* \\leftarrow \\mathsf{HF}^{\\lambda,\\Gamma}_{\\mathsf{hk}}(a^*, \\hat{a}^*); \\ d^* \\leftarrow (a^*)^{x+yv^*};</span>$</p>

    <p class="text-gray-300">and presents A with the CS3b ciphertext  <span class="math">(a^*, \\hat{a}^*, d^*)</span>  along with the key  <span class="math">K^{\\dagger}</span> .</p>

    <p class="text-gray-300">Fourth, when A terminates and outputs a value,  <span class="math">A_1</span>  also terminates and outputs the same value. That completes the description of the adversary  <span class="math">A_1</span> .</p>

    <p class="text-gray-300">One has to check that  <span class="math">A_1</span>  carries out a legal adaptive chosen ciphertext attack, in the sense that it should not attempt to submit the target ciphertext itself to the decryption oracle, subsequent to the invocation of the encryption oracle. Consider a ciphertext a submitted by  <span class="math">A_1</span>  to the decryption oracle. This was derived from a valid CS3b ciphertext  <span class="math">(a, \\hat{a}, d)</span>  submitted by A to the decryption oracle. By the construction, it is easy to see that if  <span class="math">a = a^*</span> , then in fact,  <span class="math">(a, \\hat{a}, d) = (a^*, \\hat{a}^*, d^*)</span> , which cannot happen if A itself carries out a legal attack.</p>

    <p class="text-gray-300">Since the simulation by  <span class="math">A_1</span>  above is perfect, it is clear that whatever advantage A has in guessing the hidden bit, adversary  <span class="math">A_1</span>  has precisely the same advantage. It is also clear by construction that  <span class="math">Q_{A_1}(\\lambda) \\leq Q_{A}(\\lambda)</span> , and in the random oracle model that  <span class="math">Q&#x27;_{A_1}(\\lambda) \\leq Q&#x27;_{A}(\\lambda)</span> .  <span class="math">\\square</span></p>

    <h4 id="sec-34" class="text-lg font-semibold mt-6">10.4 The security of HEG in the random oracle model</h4>

    <p class="text-gray-300">As for the security of HEG, even in the random oracle model, we do not know how to prove a very strong result. We content ourselves with a proof that the scheme HEG is secure against adaptive chosen ciphertext attack in the random oracle model, provided the CDH assumption holds relative to an oracle for the DDH problem.</p>

    <p class="text-gray-300">More precisely, for all probabilistic, polynomial-time oracle query machines A, and for all  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , we define</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{AdvCDH}^*_{\\mathcal{G},\\mathsf{A}}(\\lambda) := \\Pr[\\ c = g^{xy} : \\Gamma[\\hat{G},G,g,q] \\xleftarrow{R} \\mathbf{S}_{\\lambda}; \\ x \\xleftarrow{R} \\mathbf{Z}_q; \\ y \\xleftarrow{R} \\mathbf{Z}_q; \\ c \\xleftarrow{R} \\mathsf{A}^{\\mathsf{DHP}_{\\lambda,\\Gamma}}(\\mathbf{1}^{\\lambda},\\Gamma,g^x,g^y) \\ ],</span>$</p>

    <p class="text-gray-300">where the notation  <span class="math">A^{\\mathsf{DHP}_{\\lambda,\\Gamma}}(\\cdots)</span>  signifies that A runs with access to an oracle for the Diffie-Hellman predicate  <span class="math">\\mathsf{DHP}_{\\lambda,\\Gamma}</span>  defined in §4.3.3.</p>

    <p class="text-gray-300">We say that the CDH assumption for  <span class="math">\\mathcal{G}</span>  holds relative to an oracle for the DDH problem if:</p>

    <p class="text-gray-300">for all probabilistic, polynomial-time oracle query machines A, the function  <span class="math">\\mathsf{AdvCDH}^*_{\\mathcal{C},\\mathsf{A}}(\\lambda)</span>  is negligible in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">For all probabilistic, polynomial-time oracle query machines A, for all  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , and for all  <span class="math">\\Gamma[\\hat{G}, G, g, g] \\in [\\mathbf{S}_{\\lambda}]</span> , we also define</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{AdvCDH}^*_{\\mathcal{G},\\mathsf{A}}(\\lambda\\mid\\Gamma) := \\Pr[\\ c = g^{xy} : x \\xleftarrow{R} \\mathbf{Z}_q; \\ y \\xleftarrow{R} \\mathbf{Z}_q; \\ c \\xleftarrow{R} \\mathsf{A}^{\\mathsf{DHP}_{\\lambda,\\Gamma}}(\\mathbf{1}^{\\lambda},\\Gamma,g^x,g^y) \\ ].</span>$</p>

    <p class="text-gray-300"><strong>Theorem 9</strong> The scheme HEG is secure in the random oracle model if the CDH assumption for  <span class="math">\\mathcal{G}</span>  holds relative to an oracle for the DDH problem.</p>

    <p class="text-gray-300">In particular, for all probabilistic, polynomial-time oracle query machines A, there exists an oracle query machine  <span class="math">A_1</span> , whose running time is essentially the same as that of A, such that for all  <span class="math">\\lambda \\in \\mathbf{Z}_{\\geq 0}</span> , and for all  <span class="math">\\Gamma[\\hat{G}, G, g, q] \\in [\\mathbf{S}_{\\lambda}]</span> , we have</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{AdvCCA}_{\\mathsf{HEG},\\mathsf{A}}(\\lambda \\mid \\Gamma) \\leq \\mathsf{AdvCDH}^*_{\\mathcal{G},\\mathsf{A}_1}(\\lambda \\mid \\Gamma) + Q_{\\mathsf{A}}(\\lambda)/q;</span>$</p>

    <p class="text-gray-300">moreover, the number or DDH-oracle queries made by  <span class="math">A_1</span>  is bounded by  <span class="math">Q&#x27;_{\\Delta}(\\lambda)</span> .</p>

    <p class="text-gray-300">To prove Theorem 9, let us fix A,  <span class="math">\\lambda</span> , and  <span class="math">\\Gamma[\\hat{G}, G, g, q]</span> . The attack game is as described in §7.1.2. We begin by describing the relevant random variables in the attack game. The public key is  <span class="math">(\\Gamma, \\mathsf{dk}, h)</span>  and the secret key is  <span class="math">(\\Gamma, \\mathsf{dk}, z)</span> .</p>

    <p class="text-gray-300">For a given ciphertext  <span class="math">\\psi</span> , we let  <span class="math">a \\in G</span>  denote the corresponding group element, we let  <span class="math">b := a^z</span> ,  <span class="math">u := \\log_g a</span> , and  <span class="math">K := \\mathsf{KDF}^{\\lambda,\\Gamma}_\\mathsf{dk}(a,b)</span> . Note also that  <span class="math">b = a^u</span> . For the target ciphertext  <span class="math">\\psi^*</span> , we let  <span class="math">a^*</span> ,  <span class="math">b^*</span> ,  <span class="math">u^*</span> , and  <span class="math">K^*</span>  denote the corresponding values.</p>

    <p class="text-gray-300">The encryption oracle also generates values  <span class="math">\\tau \\in \\{0,1\\}</span>  and  <span class="math">K^+ \\in \\{0,1\\}^{\\mathsf{KDF}.\\mathsf{OutLen}(\\lambda)}</span> .</p>

    <p class="text-gray-300">Let  <span class="math">G_0</span>  be the original attack game, let  <span class="math">\\hat{\\tau}</span>  denote the output of A, and let  <span class="math">T_0</span>  be the event that  <span class="math">\\tau = \\hat{\\tau}</span> , so that  <span class="math">AdvCCA_{HEG,A}(\\lambda \\mid \\Gamma) = |\\Pr[T_0] - 1/2|</span> .</p>

    <p class="text-gray-300">As usual, we define a sequence of game  <span class="math">\\mathbf{G}_1</span> ,  <span class="math">\\mathbf{G}_2</span> , etc., and in game  <span class="math">\\mathbf{G}_i</span>  for  <span class="math">i \\geq 1</span>  we define  <span class="math">T_i</span>  to be the event in game  <span class="math">\\mathbf{G}_i</span>  corresponding to event  <span class="math">T_0</span>  in game  <span class="math">\\mathbf{G}_0</span> .</p>

    <p class="text-gray-300"><strong>Game G</strong>&lt;sub&gt;1&lt;/sub&gt;. We modify game  <span class="math">G_0</span>  as follows. First, we run the encryption oracle at the beginning of the attack game, but we give the results of this to the adversary only when it actually invokes the encryption oracle. This is a purely conceptual change, since the adversary provides no input to the encryption oracle. Second, if the adversary ever submits a ciphertext  <span class="math">\\psi = \\psi^*</span>  to the decryption oracle before the encryption algorithm is invoked, we about the game immediately, before responding to this decryption oracle invocation (the environment, say, goes silent at this point).</p>

    <p class="text-gray-300">Let  <span class="math">F_1</span>  be the event that game  <span class="math">\\mathbf{G}_1</span>  is aborted as above. It is clear that  <span class="math">\\Pr[F_1] \\leq Q_{\\mathsf{A}}(\\lambda)/q</span> . It is also clear that games  <span class="math">\\mathbf{G}_0</span>  and  <span class="math">\\mathbf{G}_1</span>  proceed identically until event  <span class="math">F_1</span>  occurs, and so by Lemma 4, we have  <span class="math">|\\Pr[T_1] - \\Pr[T_0]| \\leq \\Pr[F_1]</span> .</p>

    <p class="text-gray-300"><strong>Game G</strong>&lt;sub&gt;2&lt;/sub&gt;. We next modify game <strong>G</strong>&lt;sub&gt;1&lt;/sub&gt; as follows. If the adversary every queries the random oracle to obtain the value of  <span class="math">\\mathsf{KDF}_{\\mathsf{dk}}^{\\lambda,\\Gamma}(a^*,b^*)</span> , we immediately abort the game, before responding to this random oracle invocation.</p>

    <p class="text-gray-300">It is easy to see that  <span class="math">\\Pr[T_2] = 1/2</span> . This follows directly from the fact that in game  <span class="math">\\mathbf{G}_2</span> , the value of  <span class="math">\\mathsf{KDF}_{\\mathsf{dk}}^{\\lambda,\\Gamma}(a^*,b^*)</span>  is obtained from the random oracle only by the encryption oracle: the adversary never queries the random oracle directly at this point, nor does the decryption oracle.</p>

    <p class="text-gray-300">Let  <span class="math">F_2</span>  be the event that game  <span class="math">G_2</span>  is aborted as above. It is clear that  <span class="math">|\\Pr[T_2] - \\Pr[T_1]| \\le \\Pr[F_2]</span> , so it suffices to bound  <span class="math">\\Pr[F_2]</span> .</p>

    <p class="text-gray-300">We claim that  <span class="math">\\Pr[F_2] = \\mathsf{AdvCDH}^*_{\\mathcal{G},\\mathsf{A}_1}(\\lambda \\mid \\Gamma)</span>  for an oracle query machine  <span class="math">\\mathsf{A}_1</span>  whose running time and number of oracle queries are bounded as in the statement of the theorem.</p>

    <p class="text-gray-300">We now describe  <span class="math">A_1</span> . It takes as input  <span class="math">\\mathbf{1}^{\\lambda}</span> ,  <span class="math">\\Gamma[\\hat{G}, G, g, q]</span> , along with group elements  <span class="math">a^*, h \\in G</span> , and attempts to compute  <span class="math">b^* \\in G</span>  such that  <span class="math">\\mathsf{DHP}_{\\lambda,\\Gamma}(h, a^*, b^*) = 1</span> . The machine  <span class="math">\\mathsf{A}_1</span>  has access to an oracle for the function  <span class="math">\\mathsf{DHP}_{\\lambda,\\Gamma}</span> .</p>

    <p class="text-gray-300">Machine  <span class="math">A_1</span>  simulates the environment of game  <span class="math">G_2</span>  for A as follows. It first computes  <span class="math">dk \\stackrel{R}{\\leftarrow} \\mathsf{KDF}.\\mathsf{KeySpace}_{\\lambda,\\Gamma}</span>  and gives A the public key  <span class="math">(\\Gamma, \\mathsf{dk}, h)</span> . For the target ciphertext, it of course sets  <span class="math">\\psi^* := a^*</span> . For the other output  <span class="math">K^{\\dagger}</span>  of the encryption oracle,  <span class="math">A_1</span>  simply generates this as a random bit string of length  <span class="math">\\mathsf{KDF}.\\mathsf{OutLen}(\\lambda)</span> .</p>

    <p class="text-gray-300">Machine  <span class="math">A_1</span>  also needs to simulate the responses to the random oracle and decryption oracle queries. For the random oracle queries, the only values that are relevant are those corresponding to the given values of  <span class="math">\\lambda</span> ,  <span class="math">\\Gamma</span> , and dk.</p>

    <p class="text-gray-300">For the irrelevant random oracle queries,  <span class="math">A_1</span>  simply maintains a set of input/output pairs, generating outputs at random as necessary.</p>

    <p class="text-gray-300">Machine A&lt;sub&gt;1&lt;/sub&gt; processes relevant random oracle queries using the following data structures:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>a set  <span class="math">\\mathcal{V}_1</span>  of triples (a, b, K), with  <span class="math">a, b \\in G</span>  and  <span class="math">K \\in \\{0, 1\\}^{\\mathsf{KDF}.\\mathsf{OutLen}(\\lambda)}</span> , initially empty; this will contain those triples (a, b, K) for which  <span class="math">\\mathsf{A}_1</span>  has assigned the value K to  <span class="math">\\mathsf{KDF}^{\\lambda, \\Gamma}_{\\mathsf{dk}}(a, b)</span> ;</li>
      <li>a set  <span class="math">V_2</span>  of pairs (a, b), with  <span class="math">a, b \\in G</span> , initially empty; this will contain precisely those pairs (a, b) such that  <span class="math">(a, b, K) \\in V_1</span>  for some K, and  <span class="math">\\mathsf{DHP}_{\\lambda,\\Gamma}(h, a, b) = 1</span> ;</li>
      <li>a set  <span class="math">\\mathcal{V}_3</span>  of pairs (a, K), with  <span class="math">a \\in G</span>  and  <span class="math">K \\in \\{0, 1\\}^{\\mathsf{KDF.OutLen}(\\lambda)}</span> , initially empty; this will contain pairs (a, K) for which  <span class="math">\\mathsf{A}_1</span>  has assigned the value K to  <span class="math">\\mathsf{KDF}^{\\lambda,\\Gamma}_{\\mathsf{dk}}(a, b)</span>  for  <span class="math">b \\in G</span>  with  <span class="math">\\mathsf{DHP}_{\\lambda,\\Gamma}(h, a, b) = 1</span> , even though  <span class="math">\\mathsf{A}_1</span>  does not actually know the value of b.</li>
    </ul>

    <p class="text-gray-300">Given a request for the value  <span class="math">\\mathsf{KDF}_{\\mathsf{dk}}^{\\lambda,\\Gamma}(a,b)</span> , machine  <span class="math">\\mathsf{A}_1</span>  does the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>It tests if  <span class="math">(a, b, K) \\in \\mathcal{V}_1</span>  for some K. If so (which means that A has queried the value  <span class="math">\\mathsf{KDF}^{\\lambda, \\Gamma}_{\\mathsf{dk}}(a, b)</span>  before), it returns K as the value of  <span class="math">\\mathsf{KDF}^{\\lambda, \\Gamma}_{\\mathsf{dk}}(a, b)</span> ; otherwise, it continues.</li>
      <li>It invokes its own DDH-oracle to determine if  <span class="math">\\mathsf{DHP}_{\\lambda,\\Gamma}(h,a,b)=1</span> .</li>
      <li>If  <span class="math">\\mathsf{DHP}_{\\lambda,\\Gamma}(h,a,b)=1</span> , then:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">a = a^*</span> , it halts and outputs the solution  <span class="math">b^* := b</span>  to the given problem instance (this corresponds to the early-abort rule introduced in game  <span class="math">\\mathbf{G}_2</span> ); otherwise, it continues.</li>
      <li>It adds the pair (a, b) to the set  <span class="math">\\mathcal{V}_2</span> .</li>
      <li>If  <span class="math">(a, K) \\in \\mathcal{V}_3</span>  for some K, then it adds the triple (a, b, K) to  <span class="math">\\mathcal{V}_1</span> , and returns K as the value of  <span class="math">\\mathsf{KDF}^{\\lambda,\\Gamma}_{\\mathsf{dk}}(a,b)</span> ; otherwise, it continues.</li>
    </ul></li>
      <li>It generates K as a random bit string of length  <span class="math">\\mathsf{KDF}.\\mathsf{OutLen}(\\lambda)</span> , adds the triple (a,b,K) to  <span class="math">\\mathcal{V}_1</span> , and returns K as the value of  <span class="math">\\mathsf{KDF}^{\\lambda,\\Gamma}_\\mathsf{dk}(a,b)</span> .</li>
    </ul>

    <p class="text-gray-300">Machine  <span class="math">A_1</span>  processes decryption oracle queries as follows. Suppose it is given a ciphertext  <span class="math">\\psi</span> , with  <span class="math">a \\in G</span>  the corresponding group element. Then it does the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">If  <span class="math">\\psi = \\psi^*</span>  (which can only happen if the encryption oracle has not yet been invoked), then it simply halts (this corresponds to the early-abort rule introduced in game  <span class="math">\\mathbf{G}_1</span> ); otherwise, continues.</p></li>
      <li><p class="text-gray-300">It tests if  <span class="math">(a, b) \\in \\mathcal{V}_2</span>  for some  <span class="math">b \\in G</span> .</p></li>
      <li><p class="text-gray-300">If this is so, then it finds the (unique) triple in  <span class="math">\\mathcal{V}_1</span>  of the form (a, b, K) for some K, and returns this value of K as the result of the decryption oracle invocation; otherwise, it continues.</p></li>
      <li><p class="text-gray-300">It tests if  <span class="math">(a, K) \\in \\mathcal{V}_3</span>  for some K.</p></li>
      <li><p class="text-gray-300">If this is so, then it returns this value of K as the result of the decryption oracle; otherwise, it generates a random bit string K of length  <span class="math">\\mathsf{KDF}.\\mathsf{OutLen}(\\lambda)</span> , adds the pair (a,K) to  <span class="math">\\mathcal{V}_3</span> , and returns this value of K as the result of the decryption oracle invocation.</p></li>
    </ul>

    <p class="text-gray-300">It is straightforward to verify by inspection that  <span class="math">A_1</span>  as above does the job. That completes the proof of Theorem 9.</p>

    <p class="text-gray-300">We can now prove the following security theorem for CS3b in the random oracle model.</p>

    <p class="text-gray-300"><strong>Theorem 10</strong> The scheme CS3b is secure in the random oracle model if the CDH assumption holds for  <span class="math">\\mathcal{G}</span> , and the TCR assumption holds for HF.</p>

    <p class="text-gray-300"><em>Proof.</em> To prove this, let us assume by way of contradiction that the CDH assumption holds for  <span class="math">\\mathcal{G}</span>  and the TCR assumption holds for HF, but CS3b is not secure in the random oracle model.</p>

    <p class="text-gray-300">Now, the CDH assumption implies that for any polynomials  <span class="math">P_1</span>  and  <span class="math">P_2</span>  (with integer coefficients, taking positive values on  <span class="math">\\mathbf{Z}_{\\geq 0}</span> ), there exists a  <span class="math">\\lambda_0 \\in \\mathbf{Z}_{\\geq 0}</span> , such that for all  <span class="math">\\lambda \\geq \\lambda_0</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[q \\le P_1(\\lambda) : \\Gamma[\\hat{G}, G, g, q] \\stackrel{R}{\\leftarrow} \\mathbf{S}_{\\lambda}] \\le 1/P_2(\\lambda),</span>$</p>

    <p class="text-gray-300">since otherwise, a trivial, brute-force algorithm would have a CDH advantage that was not negligible. This implies in particular that when we model KDF as a random oracle, it acts as a secure key derivation scheme. From this it follows from Theorems 6 and 7 that CS3b is secure in the random oracle model if the DDH assumption holds; actually, since these two theorems do not deal with the random oracle model, one must make a cursory inspection of the proofs of these theorems to draw this conclusion, but this is very straightforward.</p>

    <p class="text-gray-300">Let A be a polynomial-time adversary that breaks the security of CS3b in the random oracle model. This means that there exist polynomials  <span class="math">P_1</span> ,  <span class="math">P_2</span>  (with integer coefficients, taking positive values on  <span class="math">\\mathbb{Z}_{\\geq 0}</span> ), an infinite set  <span class="math">\\Lambda \\subset \\mathbb{Z}_{\\geq 0}</span> , and sets  <span class="math">\\mathcal{Z}_{\\lambda} \\subset [\\mathbf{S}_{\\lambda}]</span>  for each  <span class="math">\\lambda \\in \\Lambda</span> , such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>for all  <span class="math">\\lambda \\in \\Lambda</span>  and  <span class="math">\\Gamma \\in \\mathcal{Z}_{\\lambda}</span> ,  <span class="math">\\mathsf{AdvCCA}_{\\mathsf{CS3b.A}}(\\lambda \\mid \\Gamma) \\geq 1/P_1(\\lambda)</span> ,</li>
      <li>for all  <span class="math">\\lambda \\in \\Lambda</span> ,  <span class="math">\\Pr_{\\mathbf{S}_{\\lambda}}[\\mathcal{Z}_{\\lambda}] \\geq 1/P_2(\\lambda)</span> .</li>
    </ul>

    <p class="text-gray-300">Theorems 6 and 7 (adapted to the random oracle model), together with our TCR assumption, imply that there exists a polynomial-time algorithm  <span class="math">A_1</span> , such that for all sufficiently large  <span class="math">\\lambda \\in \\Lambda</span> , and for all but a negligible fraction of  <span class="math">\\Gamma</span>  in  <span class="math">\\mathcal{Z}_{\\lambda}</span> , we have</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{AdvDDH}_{\\mathcal{G},\\mathsf{A}_1}(\\lambda \\mid \\Gamma) \\geq 1/(2P_1(\\lambda)).</span>$</p>

    <p class="text-gray-300">We now apply Lemma 3 using the above algorithm  <span class="math">A_1</span> , and choosing the value of  <span class="math">\\kappa</span>  in that lemma so that  <span class="math">2^{-\\kappa} \\cdot Q&#x27;_{\\mathsf{A}}(\\lambda) \\leq 1/2</span> , yielding a polynomial-time algorithm  <span class="math">A_2</span> , such that for all sufficiently large  <span class="math">\\lambda \\in \\Lambda</span> , and for all but a negligible fraction of  <span class="math">\\Gamma \\in \\mathcal{Z}_{\\lambda}</span> , and for all  <span class="math">\\rho \\in \\mathcal{T}_{\\lambda,\\Gamma}</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\mathsf{A}_2(\\mathsf{1}^\\lambda,\\Gamma,\\rho) \\neq \\mathsf{DHP}_{\\lambda,\\Gamma}(\\rho)] \\leq 1/(2Q_\\mathsf{A}&#x27;(\\lambda)).</span>$</p>

    <p class="text-gray-300">Applying Theorem 8 with the adversary A yields a polynomial-time adversary A&lt;sub&gt;3&lt;/sub&gt; such that for all  <span class="math">\\lambda \\in \\Lambda</span>  and  <span class="math">\\Gamma \\in \\mathcal{Z}_{\\lambda}</span> , AdvCCA&lt;sub&gt;HEG,A&lt;sub&gt;3&lt;/sub&gt;&lt;/sub&gt; <span class="math">(\\lambda \\mid \\Gamma) \\geq 1/P_1(\\lambda)</span> . Applying Theorem 9 with the adversary A&lt;sub&gt;3&lt;/sub&gt; yields a polynomial-time oracle machine A&lt;sub&gt;4&lt;/sub&gt; such that</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{AdvCDH}^*_{\\mathcal{G},\\mathsf{A}_4}(\\lambda \\mid \\Gamma) \\geq 1/(2P_1(\\lambda))</span>$</p>

    <p class="text-gray-300">for all sufficiently large  <span class="math">\\lambda \\in \\Lambda</span> , and for all but a negligible fraction of  <span class="math">\\Gamma \\in \\mathcal{Z}_{\\lambda}</span> . Since for a given value of  <span class="math">\\lambda</span> , algorithm  <span class="math">A_4</span>  makes no more than  <span class="math">Q&#x27;_{\\mathsf{A}}(\\lambda)</span>  DDH-oracle queries, if we replace the DDH-oracle used by  <span class="math">A_4</span>  with algorithm  <span class="math">A_2</span>  above, we obtain a polynomial-time algorithm  <span class="math">A_5</span>  such that for all sufficiently large  <span class="math">\\lambda \\in \\Lambda</span> , and for all but a negligible fraction of  <span class="math">\\Gamma</span>  in  <span class="math">\\mathcal{Z}_{\\lambda}</span> , we have  <span class="math">\\mathsf{AdvCDH}_{\\mathcal{G},\\mathsf{A}_5}(\\lambda \\mid \\Gamma) \\geq 1/(4P_1(\\lambda))</span> . But this contradicts the CDH assumption.  <span class="math">\\square</span></p>

    <p class="text-gray-300">If we want to prove the security of CS3b in the standard model without making any intractability assumptions about KDF, then we may choose KDF to be pair-wise independent. On the one hand, standard constructions for pair-wise independent hash functions typically exhibit a lot of algebraic structure, and it is not very reasonable to assume that such a KDF can be safely modeled as a random oracle. On the other hand, typical dedicated cryptographic hash functions, like SHA-1, may be modeled as random oracles, but they are certainly not pair-wise independent.</p>

    <p class="text-gray-300">We shall sketch here how to get the best of both worlds, i.e., how to implement the KDF so that we get a proof of security of CS3b in the standard model just under the DDH and TCR assumptions, and in the random oracle model under the CDH and TCR assumptions.</p>

    <p class="text-gray-300">The idea is this: compute KDF as the XOR of a pair-wise independent hash KDF1 and a cryptographic hash KDF2.</p>

    <p class="text-gray-300">It is clear that if KDF1 is pair-wise independent, then so is KDF, and so the security of CS3b in the standard model under the DDH and TCR assumptions now follows directly from Theorem 7.</p>

    <p class="text-gray-300">Now suppose we model the cryptographic hash KDF2 as a random oracle. It is easy to see that for any adversary A attacking CS3b given oracle access to KDF2, there is an adversary  <span class="math">A_1</span> , whose running time is roughly the same as that of A, that attacks CS3b given oracle access to KDF: the adversary  <span class="math">A_1</span>  just does whatever A does, except that whenever A queries the oracle for KDF2, adversary  <span class="math">A_1</span>  queries its oracle for KDF and computes the value of KDF2 as the XOR of the value of KDF and the value of KDF1. Note, however, that the output distribution of the oracle KDF is the same as that of a random oracle, and so the security of CS3b in the random oracle model under the CDH and TCR assumptions now follows directly from Theorem 10.</p>

    <p class="text-gray-300">We do not necessarily advocate this approach to building a KDF in practical implementations: simply assuming that a KDF implemented directly using a dedicated cryptographic hash is secure is quite reasonable, and the resulting KDF is much simpler and more efficient than any approach that makes use of a pair-wise independent hash function.</p>

    <h4 id="sec-35" class="text-lg font-semibold mt-6">10.7 Further discussion</h4>

    <p class="text-gray-300">The scheme  <span class="math">\\mathsf{HEG}</span>  is intended to represent a fairly traditional version of ElGamal key encapsulation. The only thing slightly non-traditional about it is the fact that the symmetric key K is derived by hashing both a (the ephemeral Diffie-Hellman public key) and b (the shared Diffie-Hellman key), rather than just b alone.</p>

    <p class="text-gray-300">Hashing both the ephemeral and shared keys together has some quantitative security advantages. Notice that in Theorem 9, the implied CDH algorithm makes no more than  <span class="math">Q&#x27;_{\\mathsf{A}}(\\lambda)</span>  queries to the DDH-oracle. If we were to hash only the shared Diffie-Hellman key, we could still prove the security of HEG, but the reduction would be less efficient; in particular, the implied CDH algorithm might require up to  <span class="math">Q&#x27;_{\\mathsf{A}}(\\lambda) \\cdot Q_{\\mathsf{A}}(\\lambda)</span>  queries to the DDH-oracle. A similar quantitative security advantage arises in the multi-user/multi-message model (see [BBM00]). In this model, we can exploit the well-know random self-reducibility of the CDH problem to get a more efficient reduction if we hash both keys instead of just one. Of course, these improved security reductions for HEG carry over to the security reduction for CS3b in the random oracle model.</p>

    <p class="text-gray-300">The DHAES encryption scheme [ABR99], which is a hybrid ElGamal encryption scheme that has been proposed for standardization, also hashes both the ephemeral and shared Diffie-Hellman keys to derive a symmetric key. Indeed, the DHAES scheme can be constructed from the key encapsulation mechanism HEG using the hybrid constructions presented in  <span class="math">\\S 7</span> , and it is straightforward to verify that analogues of Theorems 8 and 9 hold for the DHAES scheme as well. The DHAES scheme needs to hash both group elements because it allows the possibility of a group G whose order is a composite number. In a revised version of DHAES, called DHIES [ABR01], the group G is required to have prime order, and only the shared Diffie-Hellman key is hashed. However, as we have seen, there are still some security benefits to be gained from hashing both group elements, even if the group is of prime order, as we are assuming in this paper.</p>

    <p class="text-gray-300">Theorem 10 originally appeared in the paper [Sho00b]. The proof in that paper basically rolled all of the arguments used in the proofs of Theorems 8, 9, 10, along with the arguments in §10.6, into a single proof, which we have unraveled to some extent here. Our presentation here was somewhat influenced by the paper [OP01], which formally introduces the notion of the CDH assumption relative to an oracle for the DDH problem.</p>

    <p class="text-gray-300">The security reduction in Theorem 10 is quite inefficient: we have to perform many simulations using the given adversary A just to solve one instance of the DDH problem, and then in a different simulation involving A, we have to solve many instances of the DDH problem in order to solve one instance of the CDH problem. Of course, if the DDH problem for a given group scheme turns out not to be a hard problem, then it may very well be the case that there is a much more efficient DDH algorithm than the one built using our security reduction involving A. In this case, the reduction in Theorem 10 becomes quite reasonable.</p>

    <p class="text-gray-300">Some of this work was done while the first author was at the Institute for Theoretical Computer Science, ETH, Zurich, and while the second author was visiting the Computer Science Department at Stanford University. Thanks to Ilia Mironov for comments on an early draft of this paper.</p>

    <p class="text-gray-300">Thanks also to Moni Naor for his comments on an early draft of the <em>Crypto '98</em> paper on which this paper is based, and in particular, for his suggestion of using a universal one-way hash function instead of a collision resistant hash function in the design of scheme CS1, and for his suggestion of a hash-free variant, upon which scheme CS2 is loosely based.</p>

    <p class="text-gray-300">[ABR99] M. Abdalla, M. Bellare, and P. Rogaway. DHAES: an encryption scheme based on the Diffie-Hellma problem. Cryptology ePrint Archive, Report 1999/007, 1999. http:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">//eprint.iacr.org.</p></li>
      <li><p class="text-gray-300">[ABR01] M. Abdalla, M. Bellare, and P. Rogaway. The oracle Diffie-Hellman assumptions and an analysis of DHIES. In Topics in Cryptology – CT-RSA 2001, pages 143–158, 2001. Springer LNCS 2045.</p></li>
      <li><p class="text-gray-300">[ASW00] N. Asokan, V. Shoup, and M. Waidner. Optimistic fair exchange of digital signatures. IEEE Journal on Selected Areas in Communications, 18(4):593–610, 2000. Extended abstract in Advances in Cryptology–Eurocrypt '98.</p></li>
      <li><p class="text-gray-300">[BBM00] M. Bellare, A. Boldyreva, and S. Micali. Public-key encryption in a multi-user setting: security proofs and improvements. In Advances in Cryptology–Eurocrypt 2000, 2000.</p></li>
      <li><p class="text-gray-300">[BDPR98] M. Bellare, A. Desai, D. Pointcheval, and P. Rogaway. Relations among notions of security for public-key encryption schemes. In Advances in Cryptology–Crypto '98, pages 26–45, 1998.</p></li>
      <li><p class="text-gray-300">[BGMW92] E. F. Brickell, D. M. Gordon, K. S. McCurley, and D. B. Wilson. Fast exponentiation with precomputation. In Advances in Cryptology–Eurocrypt '92, pages 200–207, 1992.</p></li>
      <li><p class="text-gray-300">[BH62] P. Bateman and R. Horn. A heuristic asymptotic formula concerning the distribution of prime numbers. Math. Comp., 16:363–367, 1962.</p></li>
      <li><p class="text-gray-300">[BH65] P. Bateman and R. Horn. Primes represented by irreducible polynomials in one variable. Proc. Sympos. Pure Math., 8:119–135, 1965.</p></li>
      <li><p class="text-gray-300">[Bon98] D. Boneh. The Decision Diffie-Hellman Problem. In Ants-III, pages 48–63, 1998. Springer LNCS 1423.</p></li>
      <li><p class="text-gray-300">[Bon01] D. Boneh. Simplified OAEP for the RSA and Rabin functions. In Advances in Cryptology–Crypto 2001, 2001.</p></li>
      <li><p class="text-gray-300">[BR93] M. Bellare and P. Rogaway. Random oracles are practical: a paradigm for designing efficient protocols. In First ACM Conference on Computer and Communications Security, pages 62–73, 1993.</p></li>
      <li><p class="text-gray-300">[BR94] M. Bellare and P. Rogaway. Optimal asymmetric encryption. In Advances in Cryptology—Eurocrypt '94, pages 92–111, 1994.</p></li>
      <li><p class="text-gray-300">[BR97] M. Bellare and P. Rogaway. Collision-resistant hashing: towards making UOWHFs practical. In Advances in Cryptology–Crypto '97, 1997.</p></li>
      <li><p class="text-gray-300">[Bra93] S. Brands. An efficient off-line electronic cash system based on the representation problem, 1993. CWI Technical Report, CS-R9323.</p></li>
      <li><p class="text-gray-300">[BS96] E. Bach and J. Shallit. Algorithmic Number Theory, volume 1. MIT Press, 1996.</p></li>
      <li><p class="text-gray-300">[BSS99] I. Blake, G. Seroussi, and N. Smart. Elliptic Curves in Cryptography. Cambridge University Press, 1999.</p></li>
      <li><p class="text-gray-300">[Can00] R. Canetti. Universally composable security: a new paradigm for cryptographic protocols. Cryptology ePrint Archive, Report 2000/067, 2000. http://eprint.iacr.org.</p></li>
      <li><p class="text-gray-300">[CG99] R. Canetti and S. Goldwasser. An efficient threshold public key cryptosystem secure against adaptive chosen ciphertext attack. In Advances in Cryptology–Eurocrypt '99, pages 90–106, 1999.</p></li>
      <li><p class="text-gray-300">[CGH98] R. Canetti, O. Goldreich, and S. Halevi. The random oracle model, revisited. In 30th Annual ACM Symposium on Theory of Computing, 1998.</p></li>
      <li><p class="text-gray-300">[CS98] R. Cramer and V. Shoup. A practical public key cryptosystem provably secure against adaptive chosen ciphertext attack. In Advances in Cryptology–Crypto '98, pages 13–25, 1998.</p></li>
      <li><p class="text-gray-300">[CS00] R. Cramer and V. Shoup. Signature schemes based on the strong RSA assumption. ACM Transactions on Information and Systems Security, 3(3):161–185, 2000.</p></li>
      <li><p class="text-gray-300">[CS01] R. Cramer and V. Shoup. Universal hash proofs and a paradigm for adaptive chosen ciphertext secure public key encryption. Cryptology ePrint Archive, Report 2001/085, 2001. http://eprint.iacr.org.</p></li>
      <li><p class="text-gray-300">[Dam91] I. Damg˚ard. Towards practical public key cryptosystems secure against chosen ciphertext attacks. In Advances in Cryptology–Crypto '91, pages 445–456, 1991.</p></li>
      <li><p class="text-gray-300">[DDN91] D. Dolev, C. Dwork, and M. Naor. Non-malleable cryptography. In 23rd Annual ACM Symposium on Theory of Computing, pages 542–552, 1991.</p></li>
      <li><p class="text-gray-300">[DDN00] D. Dolev, C. Dwork, and M. Naor. Non-malleable cryptography. SIAM J. Comput., 30(2):391–437, 2000.</p></li>
      <li><p class="text-gray-300">[DH76] W. Diffie and M. E. Hellman. New directions in cryptography. IEEE Trans. Info. Theory, 22:644–654, 1976.</p></li>
      <li><p class="text-gray-300">[DN96] C. Dwork and M. Naor. Method for message authentication from non-malleable cryptosystems, 1996. U. S. Patent No. 05539826.</p></li>
      <li><p class="text-gray-300">[ElG85] T. ElGamal. A public key cryptosystem and signature scheme based on discrete logarithms. IEEE Trans. Inform. Theory, 31:469–472, 1985.</p></li>
      <li><p class="text-gray-300">[FOPS01] E. Fujisaki, T. Okamoto, D. Pointcheval, and J. Stern. RSA-OAEP is secure under the RSA assumption. In Advances in Cryptology–Crypto 2001, 2001.</p></li>
      <li><p class="text-gray-300">[FY95] Y. Frankel and M. Yung. Cryptanalysis of immunized LL public key systems. In Advances in Cryptology–Crypto '95, pages 287–296, 1995.</p></li>
      <li><p class="text-gray-300">[GL89] O. Goldreich and L. A. Levin. A hard-core predicate for all one-way functions. In 21st Annual ACM Symposium on Theory of Computing, pages 25–32, 1989.</p></li>
      <li><p class="text-gray-300">[GM84] S. Goldwasser and S. Micali. Probabilistic encryption. Journal of Computer and System Sciences, 28:270–299, 1984.</p></li>
      <li><p class="text-gray-300">[HILL99] J. H˚astad, R. Impagliazzo, L. Levin, and M. Luby. A pseudo-random generator from any one-way function. SIAM J. Comput., 28(4):1364–1396, 1999.</p></li>
      <li><p class="text-gray-300">[ILL89] R. Impagliazzo, L. Levin, and M. Luby. Pseudo-random number generation from any one-way function. In 21st Annual ACM Symposium on Theory of Computing, pages 12–24, 1989.</p></li>
      <li><p class="text-gray-300">[IZ89] R. Impagliazzo and D. Zuckermann. How to recycle random bits. In 30th Annual Symposium on Foundations of Computer Science, pages 248–253, 1989.</p></li>
      <li><p class="text-gray-300">[JN01] A. Joux and K. Nguyen. Separating Decision Diffie-Hellman from Diffie-Hellman in cryptographic groups. Cryptology ePrint Archive, Report 2001/003, 2001. http: //eprint.iacr.org.</p></li>
      <li><p class="text-gray-300">[LL93] C. H. Lim and P. J. Lee. Another method for attaining security against adaptively chosen ciphertext attacks. In Advances in Cryptology–Crypto '93, pages 420–434, 1993.</p></li>
      <li><p class="text-gray-300">[LL94] C. H. Lim and P. J. Lee. More flexible exponentiation with precomputation. In Advances in Cryptology–Crypto '94, pages 95–107, 1994.</p></li>
      <li><p class="text-gray-300">[MvOV97] A. Menesez, P. van Oorschot, and S. Vanstone. Handbook of Applied Cryptography. CRC Press, 1997.</p></li>
      <li><p class="text-gray-300">[MW00] U. Maurer and S. Wolf. The Diffie-Hellman protocol. Designs, Codes, and Cryptography, 19:147–171, 2000.</p></li>
      <li><p class="text-gray-300">[NR97] M. Naor and O. Reingold. Number-theoretic constructions of efficient pseudo-random functions. In 38th Annual Symposium on Foundations of Computer Science, 1997.</p></li>
      <li><p class="text-gray-300">[NY89] M. Naor and M. Yung. Universal one-way hash functions and their cryptographic applications. In 21st Annual ACM Symposium on Theory of Computing, 1989.</p></li>
      <li><p class="text-gray-300">[NY90] M. Naor and M. Yung. Public-key cryptosystems provably secure against chosen ciphertext attacks. In 22nd Annual ACM Symposium on Theory of Computing, pages 427–437, 1990.</p></li>
      <li><p class="text-gray-300">[OP01] T. Okamoto and D. Pointcheval. The gap-problems: a new class of problems for the security of cryptographic schemes. In Proc. 2001 International Workshop on Practice and Theory in Public Key Cryptography (PKC 2001), 2001.</p></li>
      <li><p class="text-gray-300">[Pai99] P. Paillier. Public-key cryptosystems based on composite degree residuosity classes. In Advances in Cryptology–Eurocrypt '99, pages 223–238, 1999.</p></li>
      <li><p class="text-gray-300">[Rom90] J. Rompel. One-way functions are necessary and sufficient for digital signatures. In 21st Annual ACM Symposium on Theory of Computing, 1990.</p></li>
      <li><p class="text-gray-300">[RS91] C. Rackoff and D. Simon. Noninteractive zero-knowledge proof of knowledge and chosen ciphertext attack. In Advances in Cryptology–Crypto '91, pages 433–444, 1991.</p></li>
      <li><p class="text-gray-300">[SG98] V. Shoup and R. Gennaro. Securing threshold cryptosystems against chosen ciphertext attack. In Advances in Cryptology–Eurocrypt '98, 1998. To appear, J. Cryptology.</p></li>
      <li><p class="text-gray-300">[SHA95] Secure hash standard, National Institute of Standards and Technology (NIST), FIPS Publication 180-1, April 1995.</p></li>
      <li><p class="text-gray-300">[Sho99] V. Shoup. On formal models for secure key exchange. Cryptology ePrint Archive, Report 1999/012, 1999. http://eprint.iacr.org.</p></li>
      <li><p class="text-gray-300">[Sho00a] V. Shoup. A composition theorem for universal one-way hash functions. In Advances in Cryptology–Eurocrypt 2000, 2000.</p></li>
      <li><p class="text-gray-300">[Sho00b] V. Shoup. Using hash functions as a hedge against chosen ciphertext attack. In Advances in Cryptology–Eurocrypt 2000, 2000.</p></li>
      <li><p class="text-gray-300">[Sho01] V. Shoup. OAEP reconsidered. In Advances in Cryptology–Crypto 2001, 2001.</p></li>
      <li><p class="text-gray-300">[Sma99] N. Smart. The discrete logarithm problem on elliptic curves of trace one. J. Cryptology, 12(3):193–196, 1999.</p></li>
      <li><p class="text-gray-300">[Sta96] M. Stadler. Publicly verifiable secret sharing. In Advances in Cryptology–Eurocrypt '96, pages 190–199, 1996.</p></li>
      <li><p class="text-gray-300">[ZS92] Y. Zheng and J. Seberry. Practical approaches to attaining security against adaptively chosen ciphertext attacks. In Advances in Cryptology–Crypto '92, pages 292–304, 1992.</p></li>
    </ul>

`;
---

<BaseLayout title="Design and Analysis of Practical Public-Key Encryption Schem... (2001/108)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2001 &middot; eprint 2001/108
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="design-and-analysis-of-practical-public-key-encryption-2001" />
  </article>
</BaseLayout>
