---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2022/1577';
const CRAWLER = 'marker';
---

<BaseLayout title="Rescue-Prime Optimized (2022/1577)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4">
        Rescue-Prime Optimized
      </h1>
      <p class="text-gray-400 mb-2">
        Tomer Ashur, Al Kindi, Willi Meier, Alan Szepieniec,
        Bobbin Threadbare
      </p>
      <p class="text-gray-500 text-sm mb-4">
        2022 &middot; Full Version &middot; eprint 2022/1577
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">Converted with: {CRAWLER}</p>
    </header>

    <!-- ============================================================ -->
    <!-- TABLE OF CONTENTS                                            -->
    <!-- ============================================================ -->

    <nav id="toc" class="mb-10 p-6 rounded-lg"
      style="background: rgba(255,255,255,0.03);
             border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li>
          <a href="#sec-1"
            class="hover:text-white">Introduction</a>
        </li>
        <li>
          <a href="#sec-2"
            class="hover:text-white">Specification</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-2.1"
                class="hover:text-white">Integer Parameters</a>
            </li>
            <li>
              <a href="#sec-2.2"
                class="hover:text-white">Round Constants</a>
            </li>
            <li>
              <a href="#sec-2.3"
                class="hover:text-white">MDS Matrix</a>
            </li>
            <li>
              <a href="#sec-2.4"
                class="hover:text-white">
                Order of Operations within a Round</a>
            </li>
            <li>
              <a href="#sec-2.5"
                class="hover:text-white">Padding Rule</a>
            </li>
            <li>
              <a href="#sec-2.6"
                class="hover:text-white">Overwrite Mode</a>
            </li>
            <li>
              <a href="#sec-2.7"
                class="hover:text-white">
                Indexation of State Elements</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-3"
            class="hover:text-white">Test Vectors</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-3.1"
                class="hover:text-white">128 Bits Instance</a>
            </li>
            <li>
              <a href="#sec-3.2"
                class="hover:text-white">160 Bits Instance</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-4"
            class="hover:text-white">Motivation</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-4.1"
                class="hover:text-white">Circulant MDS Matrix</a>
            </li>
            <li>
              <a href="#sec-4.2"
                class="hover:text-white">Reduced Round Number</a>
            </li>
            <li>
              <a href="#sec-4.3"
                class="hover:text-white">
                Order of Operations for Better Folding</a>
            </li>
            <li>
              <a href="#sec-4.4"
                class="hover:text-white">
                Usability in a Stack-Based Virtual Machine</a>
            </li>
            <li>
              <a href="#sec-4.5"
                class="hover:text-white">Padding Rule</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-ack"
            class="hover:text-white">Acknowledgments</a>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400 list-disc
        list-inside">
        <li>
          <a href="#references"
            class="hover:text-white">References</a>
        </li>
      </ul>
    </nav>

    <!-- ============================================================ -->
    <!-- 1  INTRODUCTION                                              -->
    <!-- ============================================================ -->

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1. Introduction</h2>
      <p class="text-gray-300">
        This note specifies two instances of a hash function obtained
        from applying the Marvellous design strategy [ABB+19] to a specific
        context. The context in question is native hashing in a STARK
        [BBHR18] Virtual Machine such as Miden [Thr].
      </p>
      <p class="text-gray-300">
        This context induces unique design constraints, which this
        specification addresses. The hash function must be defined
        over the same field that the VM is defined over, which is the
        prime field with
        <span class="math">p = 2^&#123;64&#125; - 2^&#123;32&#125; + 1</span>
        elements. One of the main use cases is Merkle tree hashing,
        and so the hash function must support an interface for
        efficient two-to-one hashing. There are two parameter sets,
        targeting security level 128 and 160, respectively.
      </p>
      <p class="text-gray-300">
        <strong>Keywords:</strong> Arithmetization-Oriented &middot;
        Hash function &middot; Rescue Prime &middot;
        Merkle tree hashing
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 2  SPECIFICATION                                             -->
    <!-- ============================================================ -->

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2. Specification</h2>
      <p class="text-gray-300">
        The starting point is Rescue-Prime [SAD20], and we assume the
        reader is familiar with this document. What is described here
        is the deviations from this standard. A complete reference
        implementation in SageMath serves as a companion to this
        specification. It is available at
        <a
          href="https://github.com/ASDiscreteMathematics/rpo"
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >https://github.com/ASDiscreteMathematics/rpo</a>.
      </p>

      <!-- 2.1 Integer Parameters -->
      <h3 id="sec-2.1" class="text-xl font-semibold mt-8 mb-3">
        2.1 Integer Parameters
      </h3>
      <p class="text-gray-300">
        Table 1 fixes some integer parameters. Additionally, this
        choice for <span class="math">p</span> fixes
        <span class="math">\alpha</span> and
        <span class="math">\alpha^&#123;-1&#125;</span>, which are
        the exponents of the power maps in the forward and backward
        S-box layer, respectively (see Figure 1). Specifically,
        <span class="math">\alpha = 7</span> and
      </p>
      <div class="math-block">
        \alpha^&#123;-1&#125; = 10540996611094048183
        = 1001001001001001001001001001000110110110110110110110110110110111_2.
      </div>

      <p class="text-gray-300 text-sm font-semibold mt-6 mb-2">
        Table 1: Integer parameters for the two instances of
        Rescue-Prime Optimized
      </p>
      <table class="w-full text-sm">
        <thead>
          <tr class="border-b border-gray-600">
            <th class="text-left py-2 text-gray-300">Parameter</th>
            <th class="text-center py-2 text-gray-300">
              128-bit instance
            </th>
            <th class="text-center py-2 text-gray-300">
              160-bit instance
            </th>
          </tr>
        </thead>
        <tbody class="text-gray-400">
          <tr class="border-b border-gray-700">
            <td class="py-2">
              Prime field modulus
              <span class="math">p</span>
            </td>
            <td class="text-center py-2">
              <span class="math">2^&#123;64&#125; - 2^&#123;32&#125; + 1</span>
            </td>
            <td class="text-center py-2">
              <span class="math">2^&#123;64&#125; - 2^&#123;32&#125; + 1</span>
            </td>
          </tr>
          <tr class="border-b border-gray-700">
            <td class="py-2">
              Security level
              <span class="math">\lambda</span>
            </td>
            <td class="text-center py-2">128</td>
            <td class="text-center py-2">160</td>
          </tr>
          <tr class="border-b border-gray-700">
            <td class="py-2">
              Round number
              <span class="math">N</span>
            </td>
            <td class="text-center py-2">7</td>
            <td class="text-center py-2">7</td>
          </tr>
          <tr class="border-b border-gray-700">
            <td class="py-2">
              State size
              <span class="math">m</span>
            </td>
            <td class="text-center py-2">12</td>
            <td class="text-center py-2">16</td>
          </tr>
          <tr class="border-b border-gray-700">
            <td class="py-2">
              Rate
              <span class="math">r</span>
            </td>
            <td class="text-center py-2">8</td>
            <td class="text-center py-2">10</td>
          </tr>
          <tr>
            <td class="py-2">
              Capacity
              <span class="math">c</span>
            </td>
            <td class="text-center py-2">4</td>
            <td class="text-center py-2">6</td>
          </tr>
        </tbody>
      </table>

      <!-- 2.2 Round Constants -->
      <h3 id="sec-2.2" class="text-xl font-semibold mt-8 mb-3">
        2.2 Round Constants
      </h3>
      <p class="text-gray-300">
        The round constants are defined as follows:
      </p>
      <ol class="list-decimal list-inside text-gray-300 space-y-2
        ml-4">
        <li>
          Start from the string
          <code>RPO(%i,%i,%i,%i)</code>.
        </li>
        <li>
          Populate the wildcards &ldquo;%i&rdquo; with the ASCII
          decimal expansion of the integer parameters
          <span class="math">p</span>,
          <span class="math">m</span>,
          <span class="math">c</span>,
          <span class="math">\lambda</span>, in that order.
        </li>
        <li>
          Use SHAKE256 to expand this ASCII string into
          <span class="math">9 \cdot 2 \cdot N \cdot m</span>
          pseudorandom bytes.
        </li>
        <li>
          For every chunk of 9 bytes, compute the matching integer
          by interpreting the byte array as the integer&rsquo;s
          base-256 expansion with least significant digit first.
        </li>
        <li>
          Reduce the obtained integer modulo
          <span class="math">p</span>.
        </li>
        <li>
          Collect all such integers. The list of obtained field
          elements constitutes the list of round constants.
        </li>
      </ol>
      <p class="text-gray-300">
        The function <code>get_round_constants</code> of the reference
        implementation accomplishes this task.
      </p>

      <!-- 2.3 MDS Matrix -->
      <h3 id="sec-2.3" class="text-xl font-semibold mt-8 mb-3">
        2.3 MDS Matrix
      </h3>
      <p class="text-gray-300">
        The MDS matrix is circulant. Its first row is
      </p>
      <div class="math-block">
        [7, 23, 8, 26, 13, 10, 9, 7, 6, 22, 21, 8]
      </div>
      <p class="text-gray-300">
        for 128 bits of security, and
      </p>
      <div class="math-block">
        [256, 2, 1073741824, 2048, 16777216, 128, 8, 16, 524288,
        4194304, 1, 268435456, 1, 1024, 2, 8192]
      </div>
      <p class="text-gray-300">
        for 160 bits of security.
      </p>

      <!-- 2.4 Order of Operations within a Round -->
      <h3 id="sec-2.4" class="text-xl font-semibold mt-8 mb-3">
        2.4 Order of Operations within a Round
      </h3>
      <p class="text-gray-300">
        The operations within every half-round are reordered. The
        correct order is now:
      </p>
      <ol class="list-decimal list-inside text-gray-300 space-y-1
        ml-4">
        <li>MDS matrix</li>
        <li>Injection of constants</li>
        <li>
          <span class="math">\alpha</span> or
          <span class="math">\alpha^&#123;-1&#125;</span>
          S-box layer
        </li>
      </ol>
      <p class="text-gray-300 text-sm italic mt-4">
        Figure 1: New versus old half-rounds. (See paper for diagram.)
      </p>

      <!-- 2.5 Padding Rule -->
      <h3 id="sec-2.5" class="text-xl font-semibold mt-8 mb-3">
        2.5 Padding Rule
      </h3>
      <p class="text-gray-300">
        The padding rule makes a distinction depending on whether the
        length of the input is a multiple of the rate
        <span class="math">r</span> or not.
      </p>
      <ul class="list-disc list-inside text-gray-300 space-y-2 ml-4">
        <li>The zero-length input is not allowed.</li>
        <li>
          If the input length is a multiple of the rate
          <span class="math">r</span>, then:
          <ul class="list-disc list-inside ml-6 mt-1 space-y-1">
            <li>
              Initialize all capacity elements to 0.
            </li>
            <li>
              No changes are made to the message.
            </li>
          </ul>
        </li>
        <li>
          If the input length is <em>not</em> a multiple of the rate
          <span class="math">r</span>, then:
          <ul class="list-disc list-inside ml-6 mt-1 space-y-1">
            <li>
              Initialize the first capacity element to 1 and all
              others to 0.
            </li>
            <li>
              Append to the input a single 1 element followed by as
              many zeros as are necessary to make the input length a
              multiple of the rate.
            </li>
          </ul>
        </li>
      </ul>
      <p class="text-gray-300">
        In either case the sponge methodology applies: absorb
        <span class="math">r</span> elements from the input in
        between applications of the permutation, until no input is
        left.
      </p>

      <!-- 2.6 Overwrite Mode -->
      <h3 id="sec-2.6" class="text-xl font-semibold mt-8 mb-3">
        2.6 Overwrite Mode
      </h3>
      <p class="text-gray-300">
        In the absorb phase of the sponge construction, the state
        elements associated with the rate are overwritten by the
        matching elements from the input chunk, rather than added
        into. Specifically, if the state elements are
        <span class="math">s[0]</span> through
        <span class="math">s[m-1]</span> and the input chunk is
        <span class="math">i[0]</span> through
        <span class="math">i[r-1]</span> then correct absorption is
        given by
      </p>
      <div class="math-block">
        s[j] \leftarrow i[j] \quad \text&#123;for all&#125;
        \; 0 \leq j &lt; r
      </div>
      <p class="text-gray-300">
        rather than
        <span class="math">
          s[j] \leftarrow s[j] + i[j]
        </span>
        for all
        <span class="math">0 \leq j &lt; r</span>.
      </p>

      <!-- 2.7 Indexation of State Elements -->
      <h3 id="sec-2.7" class="text-xl font-semibold mt-8 mb-3">
        2.7 Indexation of State Elements
      </h3>
      <p class="text-gray-300">
        The state is divided into the capacity part, with indices 0
        through <span class="math">c - 1</span>, and the rate part,
        with indices <span class="math">c</span> through
        <span class="math">m - 1</span>. After the last permutation
        is done, the digest is given by elements
        <span class="math">c</span> through
        <span class="math">c + r/2 - 1</span>.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 3  TEST VECTORS                                              -->
    <!-- ============================================================ -->

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3. Test Vectors</h2>
      <p class="text-gray-300">
        The test vectors are generated by the method
        <code>print_test_vectors</code> from the reference
        implementation. For the sake of completeness, they are
        repeated here.
      </p>

      <!-- 3.1 128 Bits Instance -->
      <h3 id="sec-3.1" class="text-xl font-semibold mt-8 mb-3">
        3.1 128 Bits Instance
      </h3>
      <div class="overflow-x-auto">
        <pre class="text-xs text-gray-400 bg-gray-900 p-4
          rounded-lg leading-relaxed"><code>[ 0 ] &ndash;&gt;
  [15502365082424960843 3880949717274681448
   16279046390222443165 6901340476773664264]
[ 0 1 ] &ndash;&gt;
  [7478710183745780580 3308077307559720969
   3383561985796182409 17205078494700259815]
[ 0 1 2 ] &ndash;&gt;
  [17439912364295172999 17979156346142712171
   8280795511427637894 9349844417834368814]
[ 0 1 2 3 ] &ndash;&gt;
  [5105868198472766874 13090564195691924742
   1058904296915798891 18379501748825152268]
[ 0 1 2 3 4 ] &ndash;&gt;
  [9133662113608941286 12096627591905525991
   14963426595993304047 13290205840019973377]
[ 0 1 2 3 4 5 ] &ndash;&gt;
  [3134262397541159485 10106105871979362399
   138768814855329459 15044809212457404677]
[ 0 1 2 3 4 5 6 ] &ndash;&gt;
  [162696376578462826 4991300494838863586
   660346084748120605 13179389528641752698]
[ 0 1 2 3 4 5 6 7 ] &ndash;&gt;
  [2242391899857912644 12689382052053305418
   235236990017815546 5046143039268215739]
[ 0 1 2 3 4 5 6 7 8 ] &ndash;&gt;
  [9585630502158073976 1310051013427303477
   7491921222636097758 9417501558995216762]
[ 0 1 2 3 4 5 6 7 8 9 ] &ndash;&gt;
  [1994394001720334744 10866209900885216467
   13836092831163031683 10814636682252756697]
[ 0 1 2 3 4 5 6 7 8 9 10 ] &ndash;&gt;
  [17486854790732826405 17376549265955727562
   2371059831956435003 17585704935858006533]
[ 0 1 2 3 4 5 6 7 8 9 10 11 ] &ndash;&gt;
  [11368277489137713825 3906270146963049287
   10236262408213059745 7855286700581400007]
[ 0 1 2 3 4 5 6 7 8 9 10 11 12 ] &ndash;&gt;
  [17899847381280262181 14717912805498651446
   10769146203951775298 2774289833490417856]
[ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 ] &ndash;&gt;
  [3794717687462954368 4386865643074822822
   8854162840275334305 7129983987107225269]
[ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ] &ndash;&gt;
  [7244773535611633983 19359923075859320
   10898655967774994333 9319339563065736480]
[ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ] &ndash;&gt;
  [4935426252518736883 12584230452580950419
   8762518969632303998 18159875708229758073]
[ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ] &ndash;&gt;
  [14871230873837295931 11225255908868362971
   18100987641405432308 15592443400896442233]
[ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ] &ndash;&gt;
  [8348203744950016968 4041411241960726733
   17584743399305468057 16836952610803537051]
[ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ] &ndash;&gt;
  [16139797453633030050 1090233424040889412
   10770255347785669036 16982398987290254028]</code></pre>
      </div>

      <!-- 3.2 160 Bits Instance -->
      <h3 id="sec-3.2" class="text-xl font-semibold mt-8 mb-3">
        3.2 160 Bits Instance
      </h3>
      <div class="overflow-x-auto">
        <pre class="text-xs text-gray-400 bg-gray-900 p-4
          rounded-lg leading-relaxed"><code>[ 0 ] &ndash;&gt;
  [4766737105427868572 7538777753317835226
   13644171984579649606 6748107971891460622
   3480072938342119934]
[ 0 1 ] &ndash;&gt;
  [6277287776173829375 5688033921803605355
   1104978478612014217 973672476085279574
   7883652116413977779]
[ 0 1 2 ] &ndash;&gt;
  [3071553803427093579 12239501990998925662
   14411295652479845526 5735407824213194294
   6714816738691504270]
[ 0 1 2 3 ] &ndash;&gt;
  [4455998568145007624 18218360213084301612
   8963555484142424669 13451196299356019287
   6609673207614347775]
[ 0 1 2 3 4 ] &ndash;&gt;
  [7894041400531553560 3138084719322472990
   15017675162298246509 12340633143623038238
   3710158928968726190]
[ 0 1 2 3 4 5 ] &ndash;&gt;
  [18345924309197503617 6448668044176965096
   5891298758878861437 18404292940273103487
   3997157420583608118]
[ 0 1 2 3 4 5 6 ] &ndash;&gt;
  [4293522863608749708 11352999694211746044
   15850245073570756600 1206950096837096206
   6945598368659615878]
[ 0 1 2 3 4 5 6 7 ] &ndash;&gt;
  [1339949574743034442 5967452101017112419
   824612579975542151 3327557828938393394
   14113149399665697150]
[ 0 1 2 3 4 5 6 7 8 ] &ndash;&gt;
  [3540904694808418824 5951416386790014715
   13859113410786779774 17205554479494520251
   7359323608260195110]
[ 0 1 2 3 4 5 6 7 8 9 ] &ndash;&gt;
  [7504301802792161339 12879743137663115497
   17245986604042562042 8175050867418132561
   10639659106647312680]
[ 0 1 2 3 4 5 6 7 8 9 10 ] &ndash;&gt;
  [18267475461736255602 4481864641736940956
   11260039501101148638 7529970948767692955
   4177810888704753150]
[ 0 1 2 3 4 5 6 7 8 9 10 11 ] &ndash;&gt;
  [16604116128892623566 1520851983040290492
   9361704524730297620 7447748879766268839
   10834422028571028806]
[ 0 1 2 3 4 5 6 7 8 9 10 11 12 ] &ndash;&gt;
  [243957224918814907 9966149007214472697
   18130816682404489504 3814760895598122151
   8625735006522337870]
[ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 ] &ndash;&gt;
  [13414343823130474877 1002887112060795246
   16685735965176892618 16172309857128312555
   5158081519803147178]
[ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ] &ndash;&gt;
  [14614132925482133961 7618082792229868740
   1881720834768448253 11508391877383996679
   5348386073072413261]
[ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ] &ndash;&gt;
  [6268111131988518030 17920308297240232909
   17719152474870950965 14857432101092580778
   5708937553833180778]
[ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ] &ndash;&gt;
  [11597726741964198121 1568026444559423552
   3233218961458461983 9700509409081014876
   7989061413164577390]
[ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ] &ndash;&gt;
  [11180580619692834182 16871004730930134181
   17810700669516829599 13679692060051982328
   10386085719330760064]
[ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ] &ndash;&gt;
  [6222872143719551583 3842704143974291265
   18311432727968603639 12278517700025439333
   7011953052853282225]</code></pre>
      </div>
    </section>

    <!-- ============================================================ -->
    <!-- 4  MOTIVATION                                                -->
    <!-- ============================================================ -->

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4. Motivation</h2>

      <!-- 4.1 Circulant MDS Matrix -->
      <h3 id="sec-4.1" class="text-xl font-semibold mt-8 mb-3">
        4.1 Circulant MDS Matrix
      </h3>
      <p class="text-gray-300">
        Rescue-Prime is secure when instantiated with any MDS matrix.
        Therefore, a circulant MDS matrix such as the one proposed by
        Polygon Zero may be chosen instead of the one defined by the
        specification. The obvious questions are:
      </p>
      <ol class="list-decimal list-inside text-gray-300 space-y-1
        ml-4">
        <li>Is the proposed matrix really MDS?</li>
        <li>
          Does the structure enable faster computation of
          matrix-vector products?
        </li>
      </ol>

      <!-- 4.1.1 MDS Test -->
      <h4 id="sec-4.1.1" class="text-lg font-semibold mt-6 mb-2">
        4.1.1 MDS Test
      </h4>
      <p class="text-gray-300">
        As for question (1), we were granted access to Polygon
        Zero&rsquo;s MDS test procedure and were able to verify the
        correctness of this function. As a result, we are confident
        that the circulant matrices specified above are in fact MDS.
      </p>
      <p class="text-gray-300">
        In the interest of disseminating science, we present a
        self-contained description of this algorithm here. Credit
        for this function goes to Hamish Ivey-Law from Polygon Zero
        [Lub+].
      </p>
      <p class="text-gray-300">
        The key insight is that the standard cofactor expansion
        method for computing determinants induces a dependency
        relation on intermediate computation results. The resulting
        graph is directed and acyclic. As a consequence, it allows
        for a dynamic programming approach.
      </p>
      <p class="text-gray-300">
        Specifically, the dependency relation is this: to compute the
        determinant of a
        <span class="math">(k+1) \times (k+1)</span> matrix, you
        need to select a row or column and combine it with the
        <span class="math">(k+1)</span>-many
        <span class="math">k \times k</span> determinants of minors
        that do not cover that row or column. Therefore, if you have
        the determinants of all
        <span class="math">k \times k</span> submatrices, computing
        the determinants of all
        <span class="math">(k+1) \times (k+1)</span> submatrices is
        straightforward.
      </p>
      <p class="text-gray-300">
        This observation suggests the following strategy: compute the
        determinants of all
        <span class="math">2 \times 2</span> submatrices. Use those
        values to compute the determinants of all
        <span class="math">3 \times 3</span> submatrices. And so on
        until the final dimension has been reached. For every computed
        determinant, verify that its value is nonzero.
      </p>
      <p class="text-gray-300">
        This method tests a matrix for hyperinvertibility, which is
        the property that every square submatrix is invertible.
        Hyperinvertibility is equivalent to MDS. The next lemma and
        proof are folklore knowledge.
      </p>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">
          Lemma 1
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            A matrix is hyperinvertible iff it is MDS.
          </p>
        </div>
      </div>

      <p class="text-gray-300 mt-4">
        <em>Proof.</em>
        <strong>Hyperinvertibility
        <span class="math">\Rightarrow</span> MDS.</strong>
        Let <span class="math">M</span> be an
        <span class="math">m \times m</span> hyperinvertible matrix.
        If there is a nonzero codeword
        <span class="math">(\mathbf&#123;x&#125; \mid \mathbf&#123;x&#125;M)</span>
        whose Hamming weight is less than
        <span class="math">m + 1</span>, then
        <span class="math">
          \mathrm&#123;HW&#125;(\mathbf&#123;x&#125;M) &lt;
          m + 1 - \mathrm&#123;HW&#125;(\mathbf&#123;x&#125;)
        </span>.
        Let <span class="math">\bar&#123;\mathbf&#123;x&#125;&#125;</span>
        denote <span class="math">\mathbf&#123;x&#125;</span> after
        dropping the zeros, and
        <span class="math">\bar&#123;M&#125;</span> the
        <span class="math">
          \mathrm&#123;HW&#125;(\bar&#123;\mathbf&#123;x&#125;&#125;)
          \times m
        </span>
        matrix whose corresponding rows are dropped. Clearly,
        <span class="math">
          \bar&#123;\mathbf&#123;x&#125;&#125;\bar&#123;M&#125;
          = \mathbf&#123;x&#125;M
        </span>
        and so
        <span class="math">
          \mathrm&#123;HW&#125;(\bar&#123;\mathbf&#123;x&#125;&#125;
          \bar&#123;M&#125;) &lt; m + 1
          - \mathrm&#123;HW&#125;(\mathbf&#123;x&#125;)
        </span>.
        Equivalently,
        <span class="math">
          \bar&#123;\mathbf&#123;x&#125;&#125;\bar&#123;M&#125;
        </span>
        has to contain at least
        <span class="math">\mathrm&#123;HW&#125;(\mathbf&#123;x&#125;)</span>
        zeros. Therefore, some
        <span class="math">
          \mathrm&#123;HW&#125;(\bar&#123;\mathbf&#123;x&#125;&#125;)
          \times
          \mathrm&#123;HW&#125;(\bar&#123;\mathbf&#123;x&#125;&#125;)
        </span>
        submatrix of
        <span class="math">\bar&#123;M&#125;</span> and of
        <span class="math">M</span> sends
        <span class="math">\bar&#123;\mathbf&#123;x&#125;&#125;</span>
        to <span class="math">\mathbf&#123;0&#125;</span>, which can
        only happen if it is singular, contradicting the assumption
        that <span class="math">M</span> is hyperinvertible.
      </p>
      <p class="text-gray-300">
        <strong>MDS <span class="math">\Rightarrow</span>
        hyperinvertibility.</strong>
        Let
        <span class="math">
          \mathcal&#123;C&#125; \subset \mathbb&#123;F&#125;^&#123;2m&#125;
        </span>
        be an MDS code of dimension <span class="math">m</span> and
        <span class="math">(I \mid M)</span> its systematic generator
        matrix. Then
        <span class="math">
          \mathcal&#123;C&#125; =
          \&#123;(\mathbf&#123;x&#125; \mid \mathbf&#123;x&#125;M)
          \mid \mathbf&#123;x&#125; \in
          \mathbb&#123;F&#125;^m\&#125;
        </span>.
        If <span class="math">M</span> is not hyperinvertible, then
        some square
        <span class="math">k \times k</span> submatrix
        <span class="math">\tilde&#123;M&#125;</span> is singular.
        Then build a codeword as follows. Set
        <span class="math">\mathbf&#123;x&#125;</span> to a
        (left-) kernel vector of
        <span class="math">\tilde&#123;M&#125;</span> in those
        coordinates that correspond to
        <span class="math">\tilde&#123;M&#125;</span>, and to 0 in
        other coordinates. The codeword
        <span class="math">
          (\mathbf&#123;x&#125; \mid \mathbf&#123;x&#125;M)
          \in \mathcal&#123;C&#125;
        </span>
        has at least <span class="math">m - k</span> zeros in the
        first half and at least <span class="math">k</span> zeros
        in the second half, so its Hamming weight is at most
        <span class="math">m</span>, contradicting the assumption
        of <span class="math">\mathcal&#123;C&#125;</span> being MDS.
        <span class="math">\square</span>
      </p>
      <p class="text-gray-300">
        To find a suitable circulant MDS matrix, it suffices to
        sample the first row from a suitable distribution, test the
        resulting circulant matrix for hyperinvertibility, and repeat
        if it does not pass the test.
      </p>

      <!-- 4.1.2 Fast Multiplication -->
      <h4 id="sec-4.1.2" class="text-lg font-semibold mt-6 mb-2">
        4.1.2 Fast Multiplication
      </h4>
      <p class="text-gray-300">
        As for question (2), the answer is in the affirmative. Let
        <span class="math">
          R_p =
          \frac&#123;\mathbb&#123;Z&#125;_p[X]&#125;&#123;\langle
          X^m - 1 \rangle&#125;
        </span>
        be the ring of polynomials with multiplication modulo
        <span class="math">X^m - 1</span>. There is an isomorphism
        between the elements of
        <span class="math">R_p</span> and circulant
        <span class="math">m \times m</span> matrices over
        <span class="math">\mathbb&#123;Z&#125;_p</span> given by
      </p>
      <div class="math-block">
        a_0 + a_1 X + a_2 X^2 + \dots + a_&#123;m-1&#125; X^&#123;m-1&#125;
        \;\leftrightarrow\;
        \begin&#123;pmatrix&#125;
        a_0 &amp; a_&#123;m-1&#125; &amp; \dots &amp; a_1 \\
        a_1 &amp; a_0 &amp; &amp; a_2 \\
        \vdots &amp; &amp; \ddots &amp; \vdots \\
        a_&#123;m-1&#125; &amp; a_&#123;m-2&#125; &amp; \dots &amp; a_0
        \end&#123;pmatrix&#125;.
        \tag&#123;1&#125;
      </div>
      <p class="text-gray-300">
        A fast way to multiply polynomials modulo
        <span class="math">X^m - 1</span> translates to a fast
        circulant matrix times vector multiplication procedure. We
        describe below two methods for fast polynomial multiplication
        modulo <span class="math">X^m - 1</span>.
      </p>
      <p class="text-gray-300">
        Note that the coefficient vector of the polynomial
        corresponds to the first column of the matrix, and not the
        first row. To translate between row and column, one needs to
        reverse the entire vector except for the element at the first
        position.
      </p>

      <!-- 4.1.3 Karatsuba-based -->
      <h4 id="sec-4.1.3" class="text-lg font-semibold mt-6 mb-2">
        4.1.3 Karatsuba-based
      </h4>
      <p class="text-gray-300">
        Karatsuba multiplication [KO62] splits the multiplication of two
        polynomials of degree at most
        <span class="math">n - 1</span> up into three
        multiplications of polynomials of degree
        <span class="math">n/2 - 1</span>, and applies that split
        recursively. In the limit the procedure requires only
        <span class="math">O(n^&#123;1.58&#125;)</span>
        multiplications, compared to the
        <span class="math">n^2</span> for the schoolbook algorithm.
        While the number of multiplications is reduced, the number of
        additions is increased. However, additions generally do not
        need to be followed up with modular reduction.
      </p>
      <p class="text-gray-300">
        Let
        <span class="math">
          a(X) = a_l(X) + X^&#123;n/2&#125; \cdot a_r(X)
        </span>
        and
        <span class="math">
          b(X) = b_l(X) + X^&#123;n/2&#125; \cdot b_r(X)
        </span>
        with all of
        <span class="math">a_l(X)</span>,
        <span class="math">a_r(X)</span>,
        <span class="math">b_l(X)</span>, and
        <span class="math">b_r(X)</span> having degree at most
        <span class="math">n/2 - 1</span>. Let
      </p>
      <ul class="list-disc list-inside text-gray-300 space-y-1 ml-4">
        <li>
          <span class="math">
            c_0(X) = a_l(X) \times a_l(X)
          </span>,
        </li>
        <li>
          <span class="math">
            c_2(X) = a_r(X) \times b_r(X)
          </span>,
        </li>
        <li>
          <span class="math">
            c_1(X) = (a_l(X) + a_r(X)) \times (b_l(X) + b_r(X))
            - c_0(X) - c_2(X)
          </span>;
        </li>
      </ul>
      <p class="text-gray-300">
        then
      </p>
      <div class="math-block">
        c(X) = a(X) \times b(X) = c_0(X)
        + X^&#123;n/2&#125; \cdot c_1(X)
        + X^n \cdot c_2(X).
      </div>
      <p class="text-gray-300">
        Note that <span class="math">c(X)</span> can be calculated
        with only 3 multiplications of polynomials of half the number
        of coefficients. Applying this reduction recursively is what
        generates Karatsuba&rsquo;s multiplication algorithm.
      </p>
      <p class="text-gray-300">
        After using Karatsuba to find the product of two polynomials
        <span class="math">t(X)</span> and
        <span class="math">s(X)</span> that represent the MDS matrix
        and state vector respectively, the next step is the reduction
        modulo <span class="math">X^m - 1</span>. This step is
        straightforward: just iterate over the coefficients of
        monomials <span class="math">X^&#123;m/2&#125;</span>
        through <span class="math">X^&#123;m-1&#125;</span> and add
        them to the coefficients of monomials
        <span class="math">X^0</span> through
        <span class="math">X^&#123;m/2 - 1&#125;</span>.
      </p>

      <!-- 4.1.4 NTT-based -->
      <h4 id="sec-4.1.4" class="text-lg font-semibold mt-6 mb-2">
        4.1.4 NTT-based
      </h4>
      <p class="text-gray-300">
        Using the same isomorphism as in the previous section and the
        fact that multiplication in the ring
        <span class="math">R_p</span> can be done efficiently using
        the Number Theory Transform (NTT) and its inverse, we can get
        a <span class="math">O(n \cdot \log(n))</span> algorithm for
        circulant matrix times vector multiplication. More precisely,
        let <span class="math">\omega</span> be a primitive
        <span class="math">n</span>-th root of unity and define the
        following
        <span class="math">
          \mathbb&#123;Z&#125;_p[X]
        </span>-linear map:
      </p>
      <div class="math-block">
        \mathrm&#123;NTT&#125;_&#123;\omega&#125;:
        \begin&#123;cases&#125;
        R_p \longrightarrow (\mathbb&#123;Z&#125;_p)^n \\
        a(X) \mapsto (a(\omega^0), a(\omega^1),
        \cdots, a(\omega^n))
        \end&#123;cases&#125;
        \tag&#123;2&#125;
      </div>
      <p class="text-gray-300">
        which is just the evaluation of the polynomial
        <span class="math">a</span> at the powers of
        <span class="math">\omega</span>, i.e. the
        <span class="math">n</span>-th roots of unity. This is
        called the Number Theory Transform (NTT), and is a special
        case of the Discrete Fourier Transform. Then, using the
        Chinese Remainder Theorem, one can show that
        <span class="math">
          \mathrm&#123;NTT&#125;_&#123;\omega&#125;
        </span>
        is an isomorphism of algebras. This means that, in
        particular, the following holds:
      </p>
      <div class="math-block">
        \mathrm&#123;NTT&#125;_&#123;\omega&#125;\!\left(
        a(X) \times b(X)\right)
        = \mathrm&#123;NTT&#125;_&#123;\omega&#125;(a(X))
        \odot \mathrm&#123;NTT&#125;_&#123;\omega&#125;(b(X))
      </div>
      <p class="text-gray-300">
        or equivalently
      </p>
      <div class="math-block">
        a(X) \times b(X) =
        \mathrm&#123;NTT&#125;_&#123;\omega&#125;^&#123;-1&#125;
        \!\left(
        \mathrm&#123;NTT&#125;_&#123;\omega&#125;(a(X))
        \odot \mathrm&#123;NTT&#125;_&#123;\omega&#125;(b(X))
        \right)
      </div>
      <p class="text-gray-300">
        where <span class="math">\odot</span> is the Hadamard
        product. This in particular yields the following algorithm:
      </p>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Algorithm 1: Circulant matrix times vector multiplication
          using NTT
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300 mb-2">
            <strong>Require:</strong>
            <span class="math">n \geq 1</span>,
            <span class="math">
              a(X), b(X) \in R_p
            </span>
            and <span class="math">\omega</span> is a primitive
            <span class="math">n</span>-th root of unity.
          </p>
          <p class="text-gray-300 mb-2">
            <strong>Ensure:</strong>
            <span class="math">C(X) = a(X) \times b(X)</span>
          </p>
          <ol class="list-decimal list-inside text-gray-300
            space-y-1 ml-4">
            <li>
              <span class="math">
                \alpha \leftarrow
                \mathrm&#123;NTT&#125;_&#123;\omega&#125;(a(X))
              </span>
            </li>
            <li>
              <span class="math">
                \beta \leftarrow
                \mathrm&#123;NTT&#125;_&#123;\omega&#125;(b(X))
              </span>
            </li>
            <li>
              <span class="math">
                \gamma \leftarrow \alpha \odot \beta
              </span>
            </li>
            <li>
              <span class="math">
                C(X) \leftarrow
                \mathrm&#123;NTT&#125;_&#123;\omega&#125;^&#123;-1&#125;(\gamma)
              </span>
            </li>
          </ol>
        </div>
      </div>

      <p class="text-gray-300 mt-4">
        Given that in our current context the matrix we are
        multiplying with is fixed once and for all, the previous
        algorithm can be optimized by pre-computing the NTT of the
        MDS matrix such that in the end it will be necessary to
        compute only one NTT and one inverse NTT per input vector
        <span class="math">b</span>. Since the NTT and the inverse
        NTT can be computed in
        <span class="math">O(n \cdot \log(n))</span> using the Fast
        Fourier Transform (FFT), the complexity of Algorithm 1 is
        also <span class="math">O(n \cdot \log(n))</span>.
      </p>

      <!-- 4.2 Reduced Round Number -->
      <h3 id="sec-4.2" class="text-xl font-semibold mt-8 mb-3">
        4.2 Reduced Round Number
      </h3>
      <p class="text-gray-300">
        According to the specification [SAD20], the Gr&ouml;bner basis
        attack dominates for the range in which the given parameters
        lie. Moreover, the number of rounds should be set to
        <span class="math">
          N = \lceil 1.5 \cdot \min(l_1, 5) \rceil
        </span>,
        where <span class="math">l_1</span> is the minimal number
        required to guarantee that the Gr&ouml;bner basis attack has
        complexity at least as large as the security parameter, and
        where the factor 1.5 is a security margin. For both the
        128-bit variant and the 160-bit variant, the estimate for the
        complexity of the Gr&ouml;bner basis attack exceeds the
        security level as soon as
        <span class="math">N \geq 3</span>. Plugging this data point
        into the formula gives rise to a recommended number of rounds
        of
        <span class="math">
          N = \lceil 1.5 \cdot 5 \rceil = 8
        </span>.
        Setting instead <span class="math">N = 7</span> constitutes
        a 12.5% reduction in the number of rounds.
      </p>
      <p class="text-gray-300">
        The reason why we feel confident recommending
        <span class="math">N = 7</span> is threefold:
      </p>
      <ul class="list-disc list-inside text-gray-300 space-y-2 ml-4">
        <li>
          The relative reduction is still less than the relative
          security margin induced by the factor 1.5.
        </li>
        <li>
          The estimate of the Gr&ouml;bner basis attack complexity
          according to the specification is still more than double the
          security level. The estimate according to experiments run in
          the course of this research project were lower, but still
          indicate that the security target is met with margin.
        </li>
        <li>
          Since the publication of the original Marvellous paper [ABB+19],
          the first version of which appeared online in 2019, there
          has been little progress in attacking either Rescue or
          Rescue-Prime.
        </li>
      </ul>

      <!-- 4.3 Order of Operations for Better Folding -->
      <h3 id="sec-4.3" class="text-xl font-semibold mt-8 mb-3">
        4.3 Order of Operations for Better Folding
      </h3>
      <p class="text-gray-300">
        One of the costly steps in both the prover and the verifier of
        a STARK is the computation of the vector of values of AIR
        transition constraint polynomials for two consecutive rows of
        the algebraic execution trace (AET). The AIR constraints are
        evaluated point by point on the codewords that represent the
        trace. The generated codewords are different from zero except
        in locations that correspond to a row in the AET and its
        successor.
      </p>
      <p class="text-gray-300">
        Rescue and Rescue-Prime have S-boxes that send
        <span class="math">x</span> to
        <span class="math">x^&#123;1/\alpha&#125;</span>, where
        <span class="math">\alpha</span> is the smallest invertible
        non-trivial power map degree. To avoid a very high degree
        AIR, the Marvellous paper [ABB+19] introduced <em>folding</em>.
        This technique involves arithmetizing the evolution of the
        state forwards in time for a part of the time step, and
        backwards in time for the remaining part. By traversing over
        the <span class="math">x \mapsto x^&#123;1/\alpha&#125;</span>
        map backwards, the degree of the resulting AIR drops to
        <span class="math">\alpha</span>. The equation is found by
        equating two distinct expressions for the value of the same
        wire in the middle. The corresponding polynomial is found by
        moving all terms to the left hand side.
      </p>
      <p class="text-gray-300 text-sm italic mt-4">
        Figure 2: New versus old folding strategy.
        (See paper for diagram.)
      </p>
      <p class="text-gray-300">
        The original folding strategy makes no distinction between the
        cost of multiplying a vector by a matrix or by its inverse.
        The AIR polynomials have the same number of terms. However,
        considerable effort was spent making the MDS matrix-vector
        multiplication fast, and it seems difficult to simultaneously
        make multiplication by the matrix&rsquo;s inverse fast. This
        problem motivates an alternative folding strategy, namely one
        that avoids using the inverse MDS matrix altogether.
      </p>
      <p class="text-gray-300">
        The new folding strategy in forwards direction: one MDS, one
        injection of constants, one
        <span class="math">x \mapsto x^&#123;\alpha&#125;</span>
        S-box layer, another MDS, and another injection of constants.
        Only the map
        <span class="math">x \mapsto x^&#123;1/\alpha&#125;</span>
        is computed in backwards direction.
      </p>
      <p class="text-gray-300">
        To argue why this rearrangement does not affect security,
        consider moving the MDS matrix and injection of constants of
        the very last step to the front. This move does not degrade
        security according to the following heuristic argument. An
        attack that meaningfully distinguishes the new permutation
        (that is, after the move) from a permutation selected
        uniformly at random, can be translated to an attack on the
        old permutation (that is, before rearrangement) with a linear
        overhead. Note that the round constants are sampled
        independently from those of Rescue-Prime.
      </p>

      <!-- 4.4 Usability in a Stack-Based Virtual Machine -->
      <h3 id="sec-4.4" class="text-xl font-semibold mt-8 mb-3">
        4.4 Usability in a Stack-Based Virtual Machine
      </h3>

      <h4 id="sec-4.4.1" class="text-lg font-semibold mt-6 mb-2">
        4.4.1 Indexation
      </h4>
      <p class="text-gray-300">
        As per &sect; 2.7, the capacity elements are indexed 0
        through <span class="math">c - 1</span> and the rate elements
        <span class="math">c</span> through
        <span class="math">m - 1</span>. This choice stands in
        contrast to traditional indexing choices, which puts the rate
        part first. While the choice of indexation is irrelevant from
        a security point of view (see below), this present choice
        benefits usability in the context of a stack machine.
      </p>
      <p class="text-gray-300">
        The unorthodox indexing scheme corresponds to putting the
        capacity part deep into the stack, and the rate part in the
        shallow end. As a result, squeezing and absorbing corresponds
        to operations that affect only the top of the stack. The
        capacity part of the sponge state does not need to be touched
        except when the hasher is initialized and after hashing is
        finished.
      </p>
      <p class="text-gray-300">
        To see why any choice of indexation is arbitrary from the
        point of view of security, observe that any permutation can be
        absorbed into one or even all MDS matrices without changing
        the fact that they are MDS. The end result is a permutation
        with an identical security argument.
      </p>

      <h4 id="sec-4.4.2" class="text-lg font-semibold mt-6 mb-2">
        4.4.2 Overwrite Mode
      </h4>
      <p class="text-gray-300">
        In many stack-based VMs, at most one element can be pushed
        onto the stack per clock cycle. Therefore, first pushing
        elements onto the stack and then adding them into the sponge
        state would require a large number of operations: in addition
        to push and add operations, stack manipulation operations are
        also necessary to arrange the stack correctly. In the
        overwrite mode, we can drop rate elements from the stack and
        then simply push the new rate elements onto the stack. This
        procedure is strictly more efficient than the procedure when
        elements are absorbed through addition as it requires no
        additional stack manipulation operations.
      </p>
      <p class="text-gray-300">
        The security of overwrite mode has been analyzed e.g. in
        &sect; 4.3 of the Sponge SoK [BDPVA11].
      </p>

      <!-- 4.5 Padding Rule -->
      <h3 id="sec-4.5" class="text-xl font-semibold mt-8 mb-3">
        4.5 Padding Rule
      </h3>
      <p class="text-gray-300">
        A sponge function is defined to absorb
        <span class="math">r</span> elements from the input in
        between applications of the permutation. When the message
        cannot be split into an integral number of
        <span class="math">r</span>-element blocks, a padding rule
        is used to determine how to handle the last block. To avoid
        trivial collisions, a padding rule must be
        <em>sponge compliant</em> (see [BDPVA11, Def. 1]). The Marvellous
        paper [ABB+19] extended &ldquo;the simplest padding rule&rdquo;
        (see [BDPVA11, Def. 2]) suggesting to append a single 1 element at
        the end of the message, followed by the necessary amount of
        zeros to make the length a multiple of
        <span class="math">r</span>. As a result, the padded message
        is always longer than the message before padding.
      </p>
      <p class="text-gray-300">
        We are interested in an efficient two-to-one hashing as a
        primary optimization goal. Therefore, we would like to avoid
        the costly overhead of an additional permutation call to
        accommodate the padding. Inspired by [Hir18] and similar to [BBP+22]
        we abuse the notion of domain separation.
      </p>
      <p class="text-gray-300">
        We consider messages with length a multiple of
        <span class="math">r</span> as belonging to the 0-domain,
        and all other messages as belonging to the 1-domain. As
        messages in the 0-domain have a predetermined length that is
        already a multiple of <span class="math">r</span> elements,
        no further padding is required. For messages in the 1-domain,
        we apply &ldquo;the simplest padding rule.&rdquo; The domain
        is encoded in the first capacity element which results in a
        1-bit security loss because now the attacker has two domains
        in which to search for &ldquo;valid&rdquo; preimages.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- ACKNOWLEDGMENTS                                              -->
    <!-- ============================================================ -->

    <section id="sec-ack" class="mb-10">
      <h2 class="text-2xl font-bold">Acknowledgments</h2>
      <p class="text-gray-300">
        This project was made possible through the financial support
        of
        <a
          href="https://polygon.technology/"
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >Polygon</a>, for which the authors would like to express
        gratitude.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- REFERENCES                                                   -->
    <!-- ============================================================ -->

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>
      <ul class="space-y-3 text-gray-400 text-sm list-none ml-2">
        <li>
          <span class="text-gray-500">[ABB+19]</span>
          Abdelrahaman Aly, Tomer Ashur, Eli Ben-Sasson,
          Siemen Dhooghe, and Alan Szepieniec.
          <em>Design of symmetric-key primitives for advanced
          cryptographic protocols.</em>
          Cryptology ePrint Archive, Paper 2019/426, 2019.
          <a
            href="https://eprint.iacr.org/2019/426"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2019/426</a>.
        </li>
        <li>
          <span class="text-gray-500">[BBHR18]</span>
          Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and
          Michael Riabzev.
          <em>Scalable, transparent, and post-quantum secure
          computational integrity.</em>
          Cryptology ePrint Archive, Paper 2018/046, 2018.
          <a
            href="https://eprint.iacr.org/2018/046"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2018/046</a>.
        </li>
        <li>
          <span class="text-gray-500">[BDPVA11]</span>
          Guido Bertoni, Joan Daemen, Micha&euml;l Peeters, and
          Gilles Van Assche.
          <em>Cryptographic sponge functions</em>, 2011.
        </li>
        <li>
          <span class="text-gray-500">[BBP+22]</span>
          Cl&eacute;mence Bouvier, Pierre Briaud, Pyrros Chaidos,
          L&eacute;o Perrin, and Vesselin Velichkov.
          <em>Anemoi: Exploiting the link between
          arithmetization-orientation and CCZ-equivalence.</em>
          IACR Cryptol. ePrint Arch., page 840, 2022.
          <a href="/papers/anemoi-2022"
            class="text-blue-400 hover:text-blue-300">
            [page on this site]</a>
        </li>
        <li>
          <span class="text-gray-500">[Hir18]</span>
          Shoichi Hirose.
          <em>Sequential hashing with minimum padding.</em>
          Cryptogr., 2(2):11, 2018.
        </li>
        <li>
          <span class="text-gray-500">[KO62]</span>
          Anatolii Karatsuba and Yuri Ofman.
          <em>Multiplication of many-digital numbers by automatic
          computers.</em>
          In Doklady Akademii Nauk, volume 145, pages 293&ndash;294.
          Russian Academy of Sciences, 1962.
        </li>
        <li>
          <span class="text-gray-500">[Lub+]</span>
          Daniel Lubarov, Brendan Farmer, William Borgeaud,
          Hamish Ivey-Law, Connor Southard, Brendan Gluth,
          Nick Ward, and Jacqueline Nabaglo.
          <em>Polygon Zero.</em>
          <a
            href="https://polygon.technology/solutions/polygon-zero"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >polygon.technology/solutions/polygon-zero</a>.
        </li>
        <li>
          <span class="text-gray-500">[SAD20]</span>
          Alan Szepieniec, Tomer Ashur, and Siemen Dhooghe.
          <em>Rescue-Prime: a standard specification (SoK).</em>
          Cryptology ePrint Archive, Paper 2020/1143, 2020.
          <a
            href="https://eprint.iacr.org/2020/1143"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2020/1143</a>.
          <a href="/papers/rescue-prime-2020"
            class="text-blue-400 hover:text-blue-300">
            [page on this site]</a>
        </li>
        <li>
          <span class="text-gray-500">[Thr]</span>
          Bobbin Threadbare.
          <em>Polygon Miden.</em>
          <a
            href="https://polygon.technology/solutions/polygon-miden"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >polygon.technology/solutions/polygon-miden</a>.
        </li>
      </ul>
    </section>
  </article>
</BaseLayout>
