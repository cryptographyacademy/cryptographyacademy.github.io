---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2022/1352';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'aPlonK : Aggregated PlonK from Multi-Polynomial Commitment Schemes';
const AUTHORS_HTML = 'Miguel Ambrona, Marc Beunardeau, Anne-Laure Schmitt, Raphaël R. Toledo';

const CONTENT = `    <p class="text-gray-300">Miguel Ambrona, Marc Beunardeau, Anne-Laure Schmitt, and Raphaël R. Toledo</p>

    <p class="text-gray-300">Nomadic Labs, Paris, France name.surname@nomadic-labs.com</p>

    <p class="text-gray-300">Abstract. <span class="math">\\mathcal{P}lon\\mathcal{K}</span> is a prominent universal and updatable zk-SNARK for general circuit satisfiability. We present <span class="math">a\\mathcal{P}lon\\mathcal{K}</span>, a variant of <span class="math">\\mathcal{P}lon\\mathcal{K}</span> that reduces the proof size and verification time when multiple statements are proven in a batch. Both the aggregated proof size and the verification complexity of <span class="math">a\\mathcal{P}lon\\mathcal{K}</span> are logarithmic in the number of aggregated statements. Our main building block, inspired by the techniques developed in SnarkPack (Gailly, Maller, Nitulescu, FC 2022), is a multi-polynomial commitment scheme, a new primitive that generalizes polynomial commitment schemes. Our techniques also include a mechanism for involving committed data into <span class="math">\\mathcal{P}lon\\mathcal{K}</span> statements very efficiently, which can be of independent interest.</p>

    <p class="text-gray-300">We also implement an open-source industrial-grade library for zero-knowledge <span class="math">\\mathcal{P}lon\\mathcal{K}</span> proofs with support for <span class="math">a\\mathcal{P}lon\\mathcal{K}</span>. Our experimental results show that our techniques are suitable for real-world applications (such as blockchain rollups), achieving significant performance improvements in proof size and verification time.</p>

    <p class="text-gray-300">In 1985 [GMR85], Goldwasser, Micali and Rackoff introduced the notion of zero-knowledge arguments. They allow a <em>prover</em> to convince a <em>verifier</em> of the validity of a certain statement without revealing any other information, e.g. why the statement is true. A few years later, Blum, Feldman and Micali [BFM88], extended this notion and considered <em>non-interactive</em> zero-knowledge arguments (NIZK), where the communication between the two parties is unilateral: the prover produces a “certificate” that can be verified by everyone.</p>

    <p class="text-gray-300">Existing generic protocols that implement zero-knowledge argument systems [BFM88, DMP90, FLS90] for any NP relation have been perceived as mainly theoretical results for many years: they used to involve expensive NP reductions and repetitions of the same routine in order to achieve reasonable soundness. Only special purpose protocols for specific NP languages [Sch91, Cra97, CDS94, GS08] were considered efficient enough for practical deployment, and they have been widely used for building digital signatures and anonymous credentials.</p>

    <p class="text-gray-300">Recently, the research community has witnessed significant improvements on the design of efficient general-purpose zero-knowledge proof systems which offer various degrees of practicality [Gro16, BCG+17, BBB+18, MBKM19, LMR19]. Such improvements have been driven by the increasing development of blockchain systems that make use of zero-knowledge arguments to achieve privacy and scalability [BCG+14, DFKP13]. In these systems, communication complexity is one of the most important performance factors, which has led to an increasing interest and remarkable progress in so-called <em>succinct non-interactive arguments of knowledge</em> (SNARKs) [GGPR13, BCG+13, PHGR13, Gro16], a class of non-interactive arguments of knowledge with sublinear (if not constant) communication and verification complexity. This comes at the cost of a significantly slower prover, compared to other zero-knowledge proof systems with higher communication complexity [JKO13, GMO16, CGM16].</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}lon\\mathcal{K}</span>, which stands for <em>Permutations over Lagrange-bases for Oecumenical Non-interactive arguments of Knowledge</em>, is a universal and updatable zero-knowledge SNARK for general circuit satisfiability. Given its significant improvements with respect to its predecessor Sonic [MBKM19], especially on prover efficiency, <span class="math">\\mathcal{P}lon\\mathcal{K}</span> has become very popular and has been adopted by several state-of-the-art blockchain projects such as Zcash [HBHW], Mina [BMRS20], the Dusk Network [MKF21] or Anoma [GYB21].</p>

    <p class="text-gray-300">In this work we present <span class="math">a\\mathcal{P}lon\\mathcal{K}</span>, a new affluent of the <span class="math">\\mathcal{P}lon\\mathcal{K}</span> family which focuses on reducing the proof size and verification time when multiple statements are proven in a batch. The aggregated proof size and the verification complexity of <span class="math">a\\mathcal{P}lon\\mathcal{K}</span> are logarithmic in the number of aggregated statements, making it an appealing building block for many blockchain applications, where having low verification complexity is paramount.</p>

    <h6 id="sec-3" class="text-base font-medium mt-4">Remark 1.</h6>

    <p class="text-gray-300"><span class="math">a\\mathcal{P}lon\\mathcal{K}</span> is the main proving system of the Epoxy library, developed by the Cryptography Team at Nomadic Labs <em>[x20]</em>. Epoxy is a validity rollup over the Tezos blockchain <em>[x13]</em>.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 Blockchain applications of SNARKs</h3>

    <p class="text-gray-300">Blockchain developers were among the first to deploy large-scale real-life applications of general purpose zero-knowledge proof systems, starting different lines of research in this area. We can cite Virgo <em>[x27]</em> and its successors, used for Overeality <em>[x22]</em>; STARK <em>[x3]</em>, used by Starkware <em>[x26]</em>; Halo <em>[x5]</em>, used by Zcash <em>[x11]</em>; or <span class="math">\\mathcal{P}lon\\mathcal{K}</span> <em>[x12]</em>, created by Aztec <em>[x28]</em>.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Privacy.</h4>

    <p class="text-gray-300">Blockchains revolve around the property of public verifiability, since anyone must be able to verify the transition between successive blockchain states. As such, all the information on a blockchain must be public, which makes it difficult to support privacy-friendly applications.</p>

    <p class="text-gray-300">Using zk-SNARKs is a natural approach to keep public verifiability while maintaining privacy. This was first illustrated theoretically <em>[x20, x10, BCG^{+}14]</em> but also in practice <em>[x11]</em>. These systems leverage zero-knowledge proofs to allow users to generate private transactions that hide the sender, the recipient, and (potentially) the transferred amount. Although zero-knowledge proofs are practical, they incur a considerable overhead on both the prover (the user) and the verifier (the blockchain). Note that a SNARK proof verification typically involves heavier computations than a simple signature verification.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Scalability and validity rollups.</h4>

    <p class="text-gray-300">Scalability is a an inherent issue in blockchain systems. The blockchain throughput cannot be simply increased with additional computing power, since every node should be able to validate state transitions. SNARKs can be of help here when they are used to certify expensive computations (e.g., the validity of multiple transactions), since the SNARK verification can become cheaper than the direct validation of the statement being proven. This idea has been explored in so-called validity rollups. (Note that in this context, zero-knowledge is not necessarily relevant.)</p>

    <p class="text-gray-300">A validity rollup is an alternative chain that runs in parallel to the main chain, but stores a small amount of data on the main chain, e.g., a commitment to the rollup state. Transactions can be sent to a rollup <em>operator</em>, who knows the exhaustive rollup state and can update it accordingly. Periodically, the rollup operator will communicate to the main chain a commitment to the most updated version of the rollup state together with a proof that ensures its validity (ergo the name). The commitment to the new rollup state and such proof are published on the main blockchain and the nodes only need to check this single proof (instead of validating all the operations performed between rollup states). The blockchain (layer 1) becomes more scalable at the cost of having to produce such proof, which is generated by an independent operator (in layer 2). Unlike in layer 1, the operator can make use of extra computing power and parallelization to speedup the process of creating proofs, thus reducing the rollup latency.</p>

    <p class="text-gray-300">Despite such promising properties and even if the rollup operator can use large computing power, producing proofs is a major bottleneck. A possible idea to reduce the proving cost (and thus the rollup latency) is to split the statement into smaller ones. For example, instead of proving the validity of 10,000 rollup transactions with one proof, one could produce 100 proofs of 100 transactions each. Dealing with smaller proofs can significantly simplify the prover cost, whose complexity is linearithmic in the circuit size. Unfortunately, this would require that the blockchain nodes receive and verify 100 proofs instead of 1.</p>

    <p class="text-gray-300">A proof that the new committed state has been achieved by applying legitimate operations to the previous committed state.</p>

    <p class="text-gray-300">2Remarkably, the blockchain nodes do not even need access to the rollup operations that were involved.</p>

    <p class="text-gray-300">Our techniques in this work are particularly suitable for the above scenario. They allow the prover to combine the batch proofs, producing an aggregated proof that can be verified very efficiently by the blockchain nodes. An alternative solution would be to use incrementally verifiable computation (IVC) <em>[x18]</em>. We discuss the differences between these two approaches in Section 1.3.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Privacy-preserving rollups</h4>

    <p class="text-gray-300">To make rollups privacy-friendly, we can leverage the zero-knowledge property of SNARKs. For example, by having users create zero-knowledge proofs which are then aggregated by the rollup operator, their private information could remain hidden. Our techniques are also applicable to this scenario but require some coordination between users. We need the users to synchronize a few times during the proving process to achieve correctness, as all parties must use the same Fiat-Shamir randomness (see Section 4.1). On the other hand, our distributed version of <span class="math">a\\mathcal{P}lon\\mathcal{K}</span> can be adapted to prevent DoS attacks: if a user aborts the execution of their proof, or misbehaves, the aggregation of the rest of proofs can still be completed. Again, recursion and IVC are an alternative for implementing privacy-preserving rollups (see Section 1.3).</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">1.2 Our contributions</h3>

    <p class="text-gray-300">We pursue the study of the <span class="math">\\mathcal{P}lon\\mathcal{K}</span> proving system and establish several general techniques that reduce the proof size and verification time when multiple statements are proven in a batch.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6"><span class="math">a\\mathcal{P}lon\\mathcal{K}</span></h4>

    <p class="text-gray-300">Our main contribution is a multi-statement proving system coined <em>aggregated <span class="math">\\mathcal{P}lon\\mathcal{K}</span></em> or <span class="math">a\\mathcal{P}lon\\mathcal{K}</span> for short, which allows one to combine <span class="math">k</span> proofs into a single aggregated proof of <span class="math">\\mathcal{O}(\\log k)</span> size that can be verified in <span class="math">\\mathcal{O}(\\log k)</span> time. The aggregated proofs must be created coordinately, but their computation is highly parallelizable. <span class="math">a\\mathcal{P}lon\\mathcal{K}</span> is the result of extending the techniques of Gailly, Maller and Nitulescu (SnarkPack) <em>[x10]</em>, designed over Groth16 <em>[x11]</em>, to the framework of <span class="math">\\mathcal{P}lon\\mathcal{K}</span>. This work and SnarkPack both use the generalized inner product argument presented in <em>[x3]</em>.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">Multi-polynomial commitments</h4>

    <p class="text-gray-300">We introduce the notion of multi-polynomial commitment schemes, a generalization of polynomial commitment schemes designed to commit to several polynomials at the same time, while achieving sublinear commitment and proof sizes and sublinear verification complexity in the number of committed polynomials.</p>

    <p class="text-gray-300">We then present a generic construction of a multi-polynomial commitment scheme from any homomorphic polynomial commitment scheme whose commitment space is one of the source groups of a set of bilinear groups. Our construction is inspired by the techniques of SnarkPack for building an inner-product argument with logarithmic verification time by combining a modified version of the inner-product argument <em>[BBB^{+}18, x2, x4, x7]</em> with a KZG-like <em>[x14]</em> commitment scheme whose commitment space is the target group of a set of bilinear groups.</p>

    <p class="text-gray-300">Our new notion of multi-polynomial commitments captures the essence of SnarkPack, hardcoded in their <em>ad hoc</em> construction for aggregating Groth16 proofs. We consider this an important contribution as it provides clarity, intuition and continues the modularity of <span class="math">\\mathcal{P}lon\\mathcal{K}</span>-based systems.</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">Improvements over SnarkPack</h4>

    <p class="text-gray-300">While the verification of SnarkPack is presented as sublinear, their verifier needs to perform a linear number of scalar operations for dealing with public inputs. (This is inherent for verifiable computations.) We observe that for many applications (e.g. a validity rollup) most public inputs can be hidden from the verifier as long as some relation on them is ensured (e.g., they form a chain). Our system can exploit this fact, to achieve actual sublinear verification time, when the use case allows for it.</p>

    <p class="text-gray-300">Furthermore, we double the efficiency of the main subroutine of SnarkPack by observing that their <em>pair group commitments</em> <em>[x10, Section 3.2]</em> do not need to be binding in order to achieve the desired security properties, if the underlying polynomial commitment scheme is <em>inner-product binding</em> and <em>inner-product extractable</em> (see Section 3). Note that <em>[BMM^{+}21, Section 5.3]</em> propose an alternative solution to achieve a</p>

    <p class="text-gray-300">binding committing function without doubling the commitment size. They use a different SRS without odd powers in one of the source groups. This requires a dedicated trusted setup, something which SnarkPack and this work want to avoid in order to reuse the SRS from existing ceremonies.</p>

    <h5 id="sec-12" class="text-base font-semibold mt-4">Commitments in <span class="math">\\mathcal{P}lon\\mathcal{K}</span> relations.</h5>

    <p class="text-gray-300">En route, we present a mechanism that allows a <span class="math">\\mathcal{P}lon\\mathcal{K}</span> statement to refer to the data inside a public commitment. Such link does not require a high number of constraints to model the commitment opening, as it is performed <em>outside of the <span class="math">\\mathcal{P}lon\\mathcal{K}</span> circuit</em>. This building block, necessary to instantiate <span class="math">a\\mathcal{P}lon\\mathcal{K}</span> efficiently, can be of independent interest, as it can be used for building hybrid proving systems or for proving statements modeled with non-deterministic circuits (see Section 4.2).</p>

    <h5 id="sec-13" class="text-base font-semibold mt-4">Implementation and evaluation.</h5>

    <p class="text-gray-300">We implement a general library for (zero-knowledge) <span class="math">\\mathcal{P}lon\\mathcal{K}</span> proofs with support for <span class="math">a\\mathcal{P}lon\\mathcal{K}</span>. Our library is implemented over the BLS12-381 elliptic curve <em>[x10]</em> and uses bindings to the <em>blst</em> library <em>[x28]</em>. Our experiments show that the techniques described in this work are suitable for real-world applications, providing significant performance improvements in proof size and verification time, while introducing a light overhead on prover complexity. Our code is publicly available as open-source <em>[x29]</em>.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">1.3 Related work</h3>

    <p class="text-gray-300">In this section, we compare our techniques with other approaches for combining zero-knowledge proofs and present the main advantages of <span class="math">a\\mathcal{P}lon\\mathcal{K}</span>.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">1.3.1 IVC and recursion.</h4>

    <p class="text-gray-300">Incrementally verifiable computation (IVC) <em>[x34]</em>, conceived by Valiant, is a framework that provides proof composability: with IVC one can conjunctively combine two proofs of size <span class="math">k</span> into a proof of size <span class="math">k</span> as well. This is a powerful technique that can be used to implement recursion. In the context of SNARKS, recursion allows one to prove statements like the following (parametrized by a state):</p>

    <p class="text-gray-300"><em>“I know a previous state from which the current state can be reached and I also have a proof of this very statement for such previous state.”</em></p>

    <p class="text-gray-300">This can be achieved by expressing a SNARK verifier in a SNARK circuit. One real-world application of this technique is the Mina blockchain <em>[x11]</em>, which provides its user with a constant-size proof of validity of its most updated state. In particular, the proof ensures that one transition of the blockchain has been performed correctly and that there exists another proof for the preceding state. This allows the blockchain state to be constant.</p>

    <p class="text-gray-300">Incidentally, recursion can also be used to aggregate proofs together by proving that one has seen valid proofs. This allows for natural parallelization by splitting a complex computation into smaller ones that are then aggregated.</p>

    <p class="text-gray-300">However, the strength of recursive SNARKs comes with high costs. Expressing a SNARK verifier in a SNARK circuit is very expensive. The current known techniques are (i) using cycles of pairing friendly elliptic curves <em>[x12]</em> which require very big group elements, (ii) or implementing non-native operations such as modular arithmetic over a modulus (e.g. the SNARK’s base field order) that does not coincide with the SNARK’s scalar field order. This typically leads to a decrease in performance of several orders of magnitude.</p>

    <p class="text-gray-300">This performance issue has led to new lines of research exploring alternatives techniques for achieving weaker versions of IVC. We can cite, Halo <em>[x6]</em>, and its successor Halo2 (which uses <span class="math">\\mathcal{P}lon\\mathcal{K}</span> instead of Sonic <em>[x22]</em>), Fractal <em>[x13]</em>, Bünz et al. work <em>[x7]</em>, or Nova <em>[x20]</em>, a novel construction based on folding schemes. These works explore the idea of performing a weaker version of recursion by not modeling some expesive parts of the SNARK verification in the circuit. These excluded verification steps can be accumulated and carried out for future verification. These techniques achieve IVC by using a cycle of (not necessarily pairing-friendly) elliptic curves, leading to better performance.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">1.3.2 Proof aggregation without recursion.</h4>

    <p class="text-gray-300">Proof aggregation can be achieved more efficiently without recursion and still be suitable for many applications such as validity rollups.</p>

    <h5 id="sec-17" class="text-base font-semibold mt-4">Aztec</h5>

    <p class="text-gray-300">The company Aztec <em>[x20]</em>, creator of <span class="math">\\mathcal{P}lon\\mathcal{K}</span>, achieves a form of proof aggregation which can be seen as a weak version of IVC. Thanks to this simplification, they do not require cycles of elliptic curves. However, they still need to model elliptic curves in a SNARK circuit, which involves simulating non-native field operations. The expensive pairing checks are accumulated as in Halo, by using standard batching techniques.</p>

    <h5 id="sec-18" class="text-base font-semibold mt-4">SnarkPack</h5>

    <p class="text-gray-300">Gailly, Maller and Nitulescu <em>[x10]</em> provide a framework for aggregating Groth16 proofs. As we explained in Section 1.2, their techniques (based on <em>[BMM^{+}21]</em>) are the starting point of this paper and combine a homomorphic pair group commitment schemes with an inner-product argument to achieve logarithmic-size proofs and logarithmic verification complexity (in the number of aggregated proofs).</p>

    <p class="text-gray-300">Our work achieves very efficient proof aggregation without cycles of elliptic curves and without simulating non-native operations. This is an improvement over Halo and Aztec, which brings us at the level of SnarkPack. However, unlike SnarkPack, <span class="math">a\\mathcal{P}lon\\mathcal{K}</span> is defined over a universal SNARK. An immediate consequence is that we can aggregate different circuits. Furthermore, we can perform proof aggregation that connects the proven statements in an arbitrary fashion (e.g. Section 4.3).</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">1.4 Technical overview</h3>

    <p class="text-gray-300">In a nutshell, a <span class="math">\\mathcal{P}lon\\mathcal{K}</span> proof consists of a set of commitments to secret polynomials together with evaluations of such polynomials at a random point (sampled after the polynomials have been committed). A <span class="math">\\mathcal{P}lon\\mathcal{K}</span> verifier simply checks that the evaluations are valid with respect to the corresponding polynomial commitments and that they satisfy a series of equations.</p>

    <p class="text-gray-300">In the multi-statement setting, in order to achieve sublinear verification time in the number of aggregated proofs, the verifier will need to delegate some computations to the prover and independently verify that they were performed honestly. As we will see, such verification can be performed significantly faster than the delegated computation. In our construction, such delegation occurs twice: (i) a multi-polynomial commitment scheme is used to achieve sublinear commitments size and sublinear verification complexity on checking the commitment evaluations; (ii) we use <em>meta-verification</em> (which we describe below in more detail) to achieve constant verification complexity on checking the evaluation equations.</p>

    <h5 id="sec-20" class="text-base font-semibold mt-4">Multi-polynomial commitments.</h5>

    <p class="text-gray-300">The main challenge of building a multi-polynomial commitment scheme is achieving sublinear commitment size (and sublinear verification) in the number of committed polynomials. We follow the techniques of Gailly, Maller and Nitulescu <em>[x10, BMM^{+}21]</em>, and start from the KZG polynomial commitment scheme <em>[x16]</em> defined over a set of bilinear groups <span class="math">(\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{t})</span> of prime order <span class="math">p</span> equipped with a pairing <span class="math">e</span>. We use the implicit notation <span class="math">[x]_{i}</span> to denote <span class="math">x\\,G_{i}\\in\\mathbb{G}_{i}</span> for every <span class="math">i\\in\\{1,2,t\\}</span>, where <span class="math">G_{i}</span> is the designated generator of <span class="math">\\mathbb{G}_{i}</span> and <span class="math">x\\in\\mathbb{Z}_{p}</span>. The KZG commitment scheme is defined as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The commitment key is <span class="math">\\mathsf{ck}\\coloneqq[s,\\ldots,s^{d-1}]_{1}</span> for a uniformly sampled <span class="math">s\\in\\mathbb{Z}_{p}</span>.</li>

      <li>The verification key is <span class="math">\\mathsf{vk}\\coloneqq[s]_{2}</span>.</li>

      <li>A polynomial <span class="math">f\\in\\mathbb{Z}_{p}^{&lt;d}[X]</span> is committed as <span class="math">\\mu\\coloneqq[f(s)]_{1}</span>, using <span class="math">\\mathsf{ck}</span>.</li>

      <li>A proof that <span class="math">f(z)=v</span> is <span class="math">\\pi\\coloneqq[h(s)]_{1}</span>, where <span class="math">h(X)\\coloneqq(f(X)-f(z))/(X-s)</span>.</li>

      <li>Verification that <span class="math">f(z)=v</span> is done by checking <span class="math">e(\\mu-[v]_{1},[1]_{2})=e(\\pi,\\mathsf{vk}-[z]_{2})</span>.</li>

    </ul>

    <p class="text-gray-300">Observe that such scheme is homomorphic in the sense that if <span class="math">\\mu_{1}</span> and <span class="math">\\mu_{2}</span> are commitments to polynomials <span class="math">f_{1}</span> and <span class="math">f_{2}</span> respectively, then <span class="math">\\mu_{1}+\\mu_{2}</span> is a commitment to polynomial <span class="math">f_{1}+f_{2}</span>.</p>

    <p class="text-gray-300">The homomorphic property allows for the following optimization when verifying that several commitments <span class="math">\\mu_{1},\\ldots,\\mu_{k}</span> evaluate to claimed evaluations <span class="math">v_{1},\\ldots,v_{k}</span> on a common point <span class="math">z\\in\\mathbb{Z}_{p}</span>. First, compute a random linear combination of the commitments, <span class="math">\\hat{\\mu}\\coloneqq\\sum_{i}r^{i}\\mu_{i}</span> for a uniformly sampled <span class="math">r\\in\\mathbb{Z}_{p}</span>. Then, verify that <span class="math">\\hat{\\mu}</span> opens to <span class="math">\\hat{v}\\coloneqq\\sum_{i}r^{i}v_{i}</span> on <span class="math">z</span>. This trick allows the verifier to only check one pairing equation instead of <span class="math">k</span>, at the cost of a negligible statistical error. Indeed, it could occur that the aggregated commitment opens to the aggregated evaluation, whereas some of the commitments <span class="math">\\mu_{i}</span> do not open to the claimed <span class="math">v_{i}</span> on <span class="math">z</span>, but the probability of this event can be upper-bounded by <span class="math">k/p</span> if <span class="math">r</span> is chosen uniformly and independently.</p>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">Delegating the computation of <span class="math">\\hat{\\mu}</span></h4>

    <p class="text-gray-300">In order to achieve sublinear commitment size, the prover will <em>commit to the commitments</em> <span class="math">\\mu_{1},\\dots,\\mu_{k}</span>. A value <span class="math">r</span> will be sampled after this meta-commitment, either by the verifier (in an interactive protocol) or through the Fiat-Shamir heuristic. The computation of the aggregated commitment <span class="math">\\hat{\\mu}</span> will be delegated to the prover, who will include a proof ensuring that such computation is correct with respect to the meta-commitment.</p>

    <p class="text-gray-300">What would be a suitable scheme for committing to the commitments? The computation that we need to assert on <span class="math">\\hat{\\mu}</span> can be seen as a polynomial evaluation on <span class="math">r</span> of a polynomial whose “coefficients” are <span class="math">\\mu_{i}</span>. Thus, a good candidate for our meta-commitment scheme is again a polynomial commitment scheme. This is precisely what Gailly et al. suggest in <em>[Gam20]</em>. We can use a variant of the KZG commitment scheme whose committing space is <span class="math">\\mathbb{G}_{\\mathrm{t}}</span>, by committing to <span class="math">\\mu_{1},\\dots,\\mu_{k}</span> as <span class="math">M\\coloneqq\\sum_{i}e(\\mu_{i},[\\tau^{i}]_{2})</span>, were <span class="math">\\tau</span> is a new SRS secret, independent of <span class="math">s</span>.</p>

    <p class="text-gray-300">A difficulty arises: how can we generalize the KZG proof of opening strategy in that case? If we define <span class="math">f(X)\\coloneqq\\sum_{i}\\mathrm{d}\\log(\\mu_{i})X^{i}</span>, we could provide the verifier with <span class="math">f(r)</span> and <span class="math">\\pi\\coloneqq[h(\\tau)]_{2}</span>, where <span class="math">h(X)</span> is defined as <span class="math">(f(X)-v)/(X-r)</span>. The verifier would then check that <span class="math">M-[f(r)]_{\\mathrm{t}}=e(\\pi,[\\tau]_{1}-[r]_{1})</span> and that <span class="math">\\hat{\\mu}=[f(r)]_{1}</span>, which equals <span class="math">\\sum_{i}r^{i}\\mu_{i}</span>, as desired. Unfortunately, this method requires explicitly knowing the coefficients of polynomial <span class="math">f</span>. Given that group elements <span class="math">\\mu_{i}</span> are the result of committing to certain non-constant polynomial, their discrete logarithm will not be known to the prover.</p>

    <p class="text-gray-300">A possible solution <em>[Gam20, BMM+21]</em> is to implement the opening of commitment <span class="math">M</span> at <span class="math">r</span> via an inner-product argument <em>[BBB+18]</em>. In particular, a modified version similar to those in <em>[BGH+19b, BCL+21]</em>, that we describe in detail in Figure 3, adjusted to support relation <span class="math">\\mathrm{PoK}\\{\\bm{\\mu}:\\,\\langle\\bm{\\mu},\\bm{\\tau}\\rangle=M\\,\\wedge\\,\\langle\\bm{r},\\bm{\\mu}\\rangle=\\hat{\\mu}\\}</span>. However, inner-product arguments are known to have linear verification. More concretely, the verification complexity is logarithmic in <span class="math">k</span> except for one final check that a certain <span class="math">M^{\\prime}\\in\\mathbb{G}_{\\mathrm{t}}</span> corresponds to the commitment of a polynomial <span class="math">g(x)\\coloneqq\\prod_{j=1}^{n}(u_{j}^{-1}+u_{j}\\,X^{2^{\\kappa-j}})</span>, for some known coefficients <span class="math">u_{j}</span>, where <span class="math">\\kappa=\\lceil\\log_{2}(k)\\rceil</span>. Polynomial <span class="math">g</span>, given its nice factored form, can be evaluated in logarithmic time. This opens the possibility of, instead of performing the (expensive) linear check that <span class="math">M^{\\prime}</span> is the commitment to <span class="math">g</span>, verifying a proof of opening of <span class="math">M^{\\prime}</span> at a random point <span class="math">\\rho\\in\\mathbb{Z}_{p}</span>, and checking that it opens to <span class="math">g(\\rho)</span>. This can be done precisely as we described in the previous paragraph. Intuitively, the inner-product argument has allowed us to replace the KZG-like proof of opening of unknown polynomial <span class="math">f</span>, by a KZG-like proof of opening of a <em>known</em> polynomial <span class="math">g</span> (at the cost of some other logarithmic complexity checks).</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Remark 2.</h6>

    <p class="text-gray-300">The meta-committing function <span class="math">\\bm{\\mu}\\mapsto\\sum_{i}e(\\mu_{i},[\\tau^{i}]_{2})</span> is not binding. This is because <span class="math">\\tau</span> is also available in <span class="math">\\mathbb{G}_{1}</span>, which is necessary for the KZG-like verification. The authors of <em>[Gam20]</em> suggest to make the commitment binding by computing it twice with respect to two independent structured reference string, namely: <span class="math">\\bm{\\mu}\\mapsto(\\sum_{i}e(\\mu_{i},[\\tau^{i}]_{2}),\\sum_{i}e(\\mu_{i},[\\hat{\\tau}^{i}]_{2}))</span>.</p>

    <p class="text-gray-300">Interestingly, we show that such duplication is not strictly necessary if the underlying polynomial commitment scheme satisfies two additional properties which we coin the <em>inner-product binding property</em> and <em>inner-product extractability</em> (see Section 3.1). We then show that the KZG polynomial commitment scheme satisfies both (Lemmas 2 and 3). This observation reduces the number of <span class="math">\\mathbb{G}_{\\mathrm{t}}</span> elements and <span class="math">\\mathbb{G}_{\\mathrm{t}}</span> operations involved in the aggregated proofs and the inner-product argument by a factor of 2 compared to the protocol from <em>[Gam20]</em>.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Remark 3.</h6>

    <p class="text-gray-300">The above committing function can be seen as an application of the bivariate polynomial commitment scheme from <em>[BMM+21, Section 6.1]</em> if the second variable <span class="math">Y</span> is evaluated at <span class="math">r</span>, the batching randomness. Our opening function is different, as we explain in the next paragraph.</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">Achieving sublinear verification complexity</h4>

    <p class="text-gray-300">The above techniques allowed us to delegate the computation of <span class="math">\\hat{\\mu}</span>. In order to get a complete multi-polynomial commitment scheme, we need to design a sublinear verification algorithm that takes as input a commitment to the evaluations instead of the evaluations themselves. This can be achieved generically through a proof for relation <span class="math">\\mathrm{PoK}\\big{\\{}\\bm{v}:\\mathsf{Commit\\text{-}Evals}(\\bm{v})=\\mathsf{com}_{\\bm{v}}\\,\\wedge\\,\\sum_{i}r^{i}v_{i}=\\hat{v}\\big{\\}}</span>. We refer to Section 3 for more details and we note that such relation will be proven with a <span class="math">\\mathcal{P}lon\\mathcal{K}</span> circuit in what we call <em>meta-verification</em> (Section 4.1).</p>

    <p class="text-gray-300">Meta-verification. Using a multi-polynomial commitment is not enough to achieve sublinear verification. There is a linear number of equations/identities in the number of aggregated proofs that need to be verified. We exploit the fact that these identities involve scalar operations over <span class="math">\\mathbb{Z}_p</span>, the native field of <span class="math">\\mathcal{P}lon\\mathcal{K}</span> circuits.</p>

    <p class="text-gray-300">This observation allows us to delegate the verification of the identities to the prover, who will compute a <span class="math">\\mathcal{P}lon\\mathcal{K}</span> proof of the fact that the identities are satisfied on the evaluations inside <span class="math">\\mathsf{com}_{\\pmb{v}}</span>, the commitment to the evaluations, whose validity has been ensured by the multi-polynomial commitment scheme (see Figure 5 for a precise description of the statement).</p>

    <p class="text-gray-300">We then show that if function Commit-Evals, used for committing to the evaluations, is chosen adequately, it can be linked very naturally to a <span class="math">\\mathcal{P}lon\\mathcal{K}</span> proof, without having to model the commitment opening with <span class="math">\\mathcal{P}lon\\mathcal{K}</span> constraints, but outside of the circuit. This technique, necessary to have a small meta-verification circuit and thus maximize the number of proofs <span class="math">k</span> that can be aggregated, can be of independent interest (see Section 4.2).</p>

    <h2 id="sec-25" class="text-2xl font-bold">2 Preliminaries</h2>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">2.1 Notation</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For a finite set <span class="math">S</span>, we write <span class="math">a \\gets S</span> to denote that <span class="math">a</span> is uniformly sampled from <span class="math">S</span>. We denote the security parameter by <span class="math">\\lambda \\in \\mathbb{N}</span>. Given two functions <span class="math">f, g: \\mathbb{N} \\to [0,1]</span>, we write <span class="math">f \\approx g</span> if the difference $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(\\lambda) - g(\\lambda)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is asymptotically smaller than the inverse of any polynomial. A function </span>f<span class="math"> is said to be negligible if </span>f \\approx 0<span class="math">, whereas it is said to be overwhelming when </span>f \\approx 1<span class="math">. For integers </span>m, n<span class="math">, such that </span>m \\leq n<span class="math">, we denote by </span>[m, n]<span class="math"> the range </span>\\{m, m+1, \\ldots, n\\}<span class="math">. We denote by </span>[n]<span class="math"> the range </span>[1, n]<span class="math">. Given </span>d \\in \\mathbb{N}<span class="math"> and a ring </span>R<span class="math">, we denote by </span>R^{&lt;d}[X]<span class="math"> the set of univariate polynomials over </span>X<span class="math"> with coefficients in </span>R<span class="math"> and degree strictly smaller than </span>d<span class="math">. For </span>n \\in \\mathbb{N}<span class="math">, we denote by </span>\\pmb{v} \\in R^n<span class="math"> a vector length </span>n<span class="math"> over </span>R<span class="math">, and for every </span>i \\in [n]<span class="math">, we denote by </span>v_i<span class="math"> its </span>i<span class="math">-th component. Furthermore, for any </span>k \\leq n<span class="math">, </span>\\pmb{v}[:k]<span class="math"> denotes the vector formed by the first </span>k<span class="math"> components of </span>\\pmb{v}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We consider a bilinear group generator <span class="math">\\mathcal{G}</span> that on input <span class="math">1^{\\lambda}</span>, produces a set of bilinear groups <span class="math">(\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_t)</span> of order <span class="math">p</span> (a <span class="math">\\lambda</span>-bits prime), equipped with a non-degenerate bilinear pairing <span class="math">e: \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_t</span>, satisfying <span class="math">e(aG, bH) = ab \\cdot e(G, H)</span> for all <span class="math">G \\in \\mathbb{G}_1</span>, <span class="math">H \\in \\mathbb{G}_2</span> and <span class="math">a, b \\in \\mathbb{Z}_p</span>. We use additive notation for all three groups. Unless specified otherwise, we implicitly assume that all algorithms share the same common set of bilinear groups, sampled from the appropriate security parameter. For <span class="math">n \\in \\mathbb{N}</span>, such that <span class="math">n \\mid p-1</span>, let <span class="math">\\mathcal{H}_n</span> be the subgroup generated by <span class="math">\\omega_n \\in \\mathbb{Z}_p</span>, a designated primitive <span class="math">n</span>-th root of unity over <span class="math">\\mathbb{Z}_p</span>, and let <span class="math">Z_{\\mathcal{H}_n}(X) := X^n - 1</span>, which vanishes over <span class="math">\\mathcal{H}_n</span>. For every <span class="math">i \\in [n]</span>, let <span class="math">\\mathsf{L}_{i,n}</span> be the Lagrange polynomial such that <span class="math">\\mathsf{L}_{i,n}(\\omega_n^i) = 1</span> and <span class="math">\\mathsf{L}_{i,n}(h) = 0</span> for all <span class="math">h \\in \\mathcal{H}_n \\setminus \\{\\omega_n^i\\}</span>. Throughout the paper, such <span class="math">n</span> will denote the number of constraints in the constraint system of interest. To speed up polynomial operations through the discrete (I)FFT algorithm, it is convenient that <span class="math">n</span> be a power of two.⁶</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">2.2 Succinct non-interactive arguments of knowledge</h3>

    <p class="text-gray-300">SNARKs are a class of arguments of knowledge that allow a prover to convince a verifier of the validity of a certain statement. They have the important property that proofs and verification time must be poly-logarithmic in the length of the statement and the witness.</p>

    <p class="text-gray-300"><strong>Definition 1 (SNARKs).</strong> A succinct non-interactive argument of knowledge (SNARK) for a binary relation <span class="math">\\mathcal{R}</span> is a triple of PPT algorithms</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{Setup}(1^{\\lambda}, \\mathcal{R}) \\to \\mathsf{pp}</span>, on input the security parameter <span class="math">\\lambda</span> and relation <span class="math">\\mathcal{R}</span>, outputs a set of public parameters <span class="math">\\mathsf{pp}</span>, also known as a common reference string.</li>

    </ul>

    <p class="text-gray-300">⁵It is more common to express <span class="math">\\mathbb{G}_t</span> in multiplicative notation, since its group operation is typically implemented through a polynomial multiplication.</p>

    <p class="text-gray-300">⁶Some elliptic-curves are designed so that a big power of 2 divides <span class="math">p-1</span>, e.g., <span class="math">2^{32}</span> divides the order of the multiplicative subgroup of BLS12-381 [Bow17] scalar field.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Prove}(pp,x,w)\\to\\pi</span>, on input <span class="math">pp</span>, statement <span class="math">x</span> and witness <span class="math">w</span>, outputs a proof.</li>

      <li><span class="math">\\mathsf{Verify}(pp,x,\\pi)\\to 1/0</span>, on input <span class="math">pp</span>, statement <span class="math">x</span> and proof <span class="math">\\pi</span>, outputs a bit.</li>

    </ul>

    <h6 id="sec-28" class="text-base font-medium mt-4">Completeness.</h6>

    <p class="text-gray-300">A SNARK is <em>complete</em> if for every <span class="math">\\lambda\\in\\mathbb{N}</span> and every <span class="math">(x,w)\\in\\mathcal{R}</span>:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[pp\\leftarrow\\mathsf{Setup}(1^{\\lambda},\\mathcal{R});\\,\\pi\\leftarrow\\mathsf{Prove}(pp,x,w)\\,:\\,\\mathsf{Verify}(pp,x,\\pi)=1\\right]=1\\,\\,\\,.</span></p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Knowledge Soundness.</h6>

    <p class="text-gray-300">A SNARK is <em>knowledge sound</em> if for every PPT algorithm <span class="math">\\mathcal{A}</span>, there exists an expected polynomial-time extractor <span class="math">\\mathcal{E}</span> (with access to <span class="math">\\mathcal{A}</span>’s random tape) such that the following probability is negligible in <span class="math">\\lambda</span>:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[pp\\leftarrow\\mathsf{Setup}(1^{\\lambda},\\mathcal{R});\\,\\left(\\pi,x\\right)\\leftarrow\\mathcal{A}(pp):\\,\\,w\\leftarrow\\mathcal{E}(pp);\\mathsf{Verify}(pp,x,\\pi)=1\\,\\wedge\\,\\left(x,w\\right)\\notin\\mathcal{R}\\right]\\,\\,\\,.</span></p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Succinctness.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A SNARK is <em>succinct</em> if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathsf{poly}(\\lambda,\\mathsf{log}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, for every </span>(x,w)\\in\\mathcal{R})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-31" class="text-base font-medium mt-4">Zero-knowledge.</h6>

    <p class="text-gray-300">A SNARK is <em>zero-knowledge</em> if there exists a PPT (stateful) simulator <span class="math">\\mathcal{S}</span> such that for every PPT (stateful) algorithm <span class="math">\\mathcal{A}</span>, the following probabilities are negligibly close (in <span class="math">\\lambda</span>):</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[pp\\leftarrow\\mathsf{Setup}(1^{\\lambda},\\mathcal{R});\\,\\left(x,w\\right)\\leftarrow\\mathcal{A}(pp);\\,\\pi\\leftarrow\\mathsf{Prove}(pp,x,w):\\,\\left(x,w\\right)\\in\\mathcal{R}\\,\\wedge\\,\\mathcal{A}(\\pi)=1\\right]\\,\\,\\,,</span> <span class="math">\\Pr\\left[pp\\leftarrow\\mathcal{S}(1^{\\lambda});\\,\\left(x,w\\right)\\leftarrow\\mathcal{A}(pp);\\,\\pi\\leftarrow\\mathcal{S}(pp,x):\\,\\left(x,w\\right)\\in\\mathcal{R}\\,\\wedge\\,\\mathcal{A}(\\pi)=1\\right]\\,\\,\\,.</span></p>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">2.3 Polynomial commitment schemes</h3>

    <p class="text-gray-300">A polynomial commitment scheme (PCS) <em>[x10]</em> is a commitment scheme where the objects being committed are univariate polynomials (of bounded degree). These systems are also equipped with a mechanism for proving (not necessarily in zero-knowledge) that the polynomial “inside” a certain commitment evaluates to a claimed value at a given evaluation point.</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Definition 2 (Polynomial Commitment).</h6>

    <p class="text-gray-300">A polynomial commitment scheme over a ring <span class="math">R</span> consists of four PPT algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}(1^{\\lambda},d)\\to(\\mathsf{ck},\\mathsf{vk})</span>, on input the security parameter <span class="math">\\lambda</span> and a degree bound <span class="math">d\\in\\mathbb{N}</span>, outputs a commitment key <span class="math">\\mathsf{ck}</span> and a verification key <span class="math">\\mathsf{vk}</span>.</li>

      <li><span class="math">\\mathsf{Commit}(\\mathsf{ck},f)\\to\\mathsf{com}</span>, given <span class="math">\\mathsf{ck}</span> and a polynomial <span class="math">f\\in R^{&lt;d}[X]</span>, outputs a commitment <span class="math">\\mathsf{com}</span>.</li>

      <li><span class="math">\\mathsf{Open}(\\mathsf{ck},\\mathsf{com},z,f)\\to\\pi</span>, given a commitment key, a commitment <span class="math">\\mathsf{com}</span>, an evaluation point <span class="math">z\\in R</span> a polynomial <span class="math">f</span> (that was committed in <span class="math">\\mathsf{com}</span>), outputs a proof <span class="math">\\pi</span>.</li>

      <li><span class="math">\\mathsf{Check}(\\mathsf{vk},\\mathsf{com},z,v,\\pi)\\to 1/0</span>, given a verification key <span class="math">\\mathsf{vk}</span>, a commitment <span class="math">\\mathsf{com}</span>, an evaluation point <span class="math">z</span>, a claimed evaluation <span class="math">v</span> and a proof <span class="math">\\pi</span>, outputs a bit (1 representing acceptance, 0 representing rejection).</li>

    </ul>

    <p class="text-gray-300">For the sake of simplicity in the next definitions, we require that all algorithms except <span class="math">\\mathsf{Setup}</span> be deterministic. Note that most instantiations from the literature are deterministic <em>[x10, x3, x2]</em>. We also require a polynomial commitment scheme to satisfy the following properties.</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Completeness.</h6>

    <p class="text-gray-300">A polynomial commitment scheme is <em>complete</em> if for every <span class="math">\\lambda,d</span> and every <span class="math">(\\mathsf{ck},\\mathsf{vk})\\leftarrow\\mathsf{Setup}(1^{\\lambda},d)</span>, any <span class="math">f\\in R^{&lt;d}[X]</span>, <span class="math">z\\in R</span>, it holds:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Check}(\\mathsf{vk},\\mathsf{com},z,f(z),\\mathsf{Open}(\\mathsf{ck},\\mathsf{com},z,f))=1\\,\\,\\,,</span></p>

    <p class="text-gray-300">where <span class="math">\\mathsf{com}\\coloneqq\\mathsf{Commit}(\\mathsf{ck},f)</span>.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Binding Property.</h6>

    <p class="text-gray-300">A polynomial commitment scheme is <em>binding</em> if for every polynomial <span class="math">d\\in\\mathbb{N}</span> and every PPT adversary <span class="math">\\mathcal{A}</span>, the following probability is negligible in <span class="math">\\lambda</span>:</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{c}(\\mathsf{ck},\\mathsf{vk})\\leftarrow\\mathsf{Setup}(1^{\\lambda},d)\\\\ (f,f^{\\prime})\\leftarrow\\mathcal{A}(\\mathsf{ck})\\end{array}:\\,\\,\\,\\mathsf{Commit}(\\mathsf{ck},f)=\\mathsf{Commit}(\\mathsf{ck},f^{\\prime})\\,\\,\\wedge\\,\\,f\\neq f^{\\prime}\\right]\\,\\,\\,. \\]</p>

    <p class="text-gray-300">Knowledge Soundness. A polynomial commitment scheme is <em>knowledge sound</em> if for every polynomial <span class="math">d\\in\\mathbb{N}</span> and every PPT adversary <span class="math">\\mathcal{A}</span>, there exists an (expected polynomial time) extractor <span class="math">\\mathcal{E}</span> such that the following probability is negligible in <span class="math">\\lambda</span>:</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{cc}(\\mathsf{ck},\\mathsf{vk})\\leftarrow\\mathsf{Setup}(1^{\\lambda},d)&\\mathsf{Check}(\\mathsf{vk},\\mathsf{com},z,v,\\pi)=1\\\\ (\\mathsf{com},z,v,\\pi)\\leftarrow\\mathcal{A}(\\mathsf{ck})&:\\quad\\mathsf{Check}(\\mathsf{vk},\\mathsf{com},z,v,\\pi)=1\\\\ f\\leftarrow\\mathcal{E}(\\mathsf{ck})&\\wedge\\left(\\mathsf{com}\\neq\\mathsf{Commit}(\\mathsf{ck},f)\\ \\vee\\ (f(z)\\neq v)\\right)\\end{array}\\right]\\ . \\]</p>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">2.4 Constraint systems</h3>

    <p class="text-gray-300">A constraint system is a list of polynomial equations over <span class="math">\\mathbb{Z}_{p}[X_{1},\\ldots,X_{m}]</span>, of restricted form. For simplicity in our exposition, in this work we consider polynomials of the form</p>

    <p class="text-gray-300"><span class="math">\\mathsf{q}_{\\mathsf{L}}X_{i}+\\mathsf{q}_{\\mathsf{R}}X_{j}+\\mathsf{q}_{\\mathsf{O}}X_{k}+\\mathsf{q}_{\\mathsf{M}}X_{i}X_{j}+\\mathsf{q}_{\\mathsf{C}}\\ ,</span></p>

    <p class="text-gray-300">for certain scalar coefficients <span class="math">\\mathsf{q}_{\\mathsf{L}},\\mathsf{q}_{\\mathsf{R}},\\mathsf{q}_{\\mathsf{O}},\\mathsf{q}_{\\mathsf{M}},\\mathsf{q}_{\\mathsf{C}}\\in\\mathbb{Z}_{p}</span>. This corresponds to the classical identity considered in the original <span class="math">\\mathcal{P}lon\\mathcal{K}</span> paper <em>[x10]</em>. All our results extend to other versions of <span class="math">\\mathcal{P}lon\\mathcal{K}</span>, that involve additional identities such as <em>[x10, PFM^{+}22]</em> and even to implementations that use a different number of wires per gate (instead of 3).</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Definition 3 (Constraint System).</h6>

    <p class="text-gray-300">A constraint system on <span class="math">m</span> variables is a list of tuples <span class="math">(a,b,c,\\mathsf{q}_{\\mathsf{L}},\\mathsf{q}_{\\mathsf{R}}</span>, <span class="math">\\mathsf{q}_{\\mathsf{O}},\\mathsf{q}_{\\mathsf{M}},\\mathsf{q}_{\\mathsf{C}})</span> with <span class="math">a,b,c\\in[m]</span>, <span class="math">\\mathsf{q}_{\\mathsf{L}},\\mathsf{q}_{\\mathsf{R}},\\mathsf{q}_{\\mathsf{O}},\\mathsf{q}_{\\mathsf{M}},\\mathsf{q}_{\\mathsf{C}}\\in\\mathbb{Z}_{p}</span>. We say a vector <span class="math">\\bm{x}\\in\\mathbb{Z}_{p}^{m}</span> satisfies constraint system <span class="math">\\mathcal{C}=\\{(a_{i},b_{i},c_{i},\\mathsf{q}_{\\mathsf{L}i},\\mathsf{q}_{\\mathsf{R}i},\\mathsf{q}_{\\mathsf{O}i},\\mathsf{q}_{\\mathsf{M}i},\\mathsf{q}_{\\mathsf{C}i})\\}_{i\\in[n]}</span> if for every <span class="math">i\\in[n]</span>:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{q}_{\\mathsf{L}i}x_{a_{i}}+\\mathsf{q}_{\\mathsf{R}i}x_{b_{i}}+\\mathsf{q}_{\\mathsf{O}i}x_{c_{i}}+\\mathsf{q}_{\\mathsf{M}i}x_{a_{i}}x_{b_{i}}+\\mathsf{q}_{\\mathsf{C}i}=0\\enspace.</span></p>

    <p class="text-gray-300">The <span class="math">\\mathcal{P}lon\\mathcal{K}</span> proving system is a zk-SNARK for the following relation, defined over so-called <em>public inputs</em> <span class="math">\\bm{x}\\in\\mathbb{Z}_{p}^{\\ell}</span> and <em>witness</em> <span class="math">\\bm{w}\\in\\mathbb{Z}_{p}^{m-\\ell}</span>:</p>

    <p class="text-gray-300"><span class="math">\\text{PoK}\\left\\{\\,\\bm{w}\\in\\mathbb{Z}_{p}^{m-\\ell}\\,:\\,\\left(\\bm{x},\\bm{w}\\right)\\in\\mathbb{Z}_{p}^{m}\\text{ satisfies }\\mathcal{C}\\;\\right\\}\\enspace.</span> (1)</p>

    <p class="text-gray-300">The statement being proved is thus parametrized by both <span class="math">\\mathcal{C}</span> and <span class="math">\\bm{x}</span>.</p>

    <h3 id="sec-38" class="text-xl font-semibold mt-8">2.5 The <span class="math">\\mathcal{P}lon\\mathcal{K}</span> proving system</h3>

    <p class="text-gray-300">Let <span class="math">\\mathcal{C}=\\{(a_{i},b_{i},c_{i},\\mathsf{q}_{\\mathsf{L}i},\\mathsf{q}_{\\mathsf{R}i},\\mathsf{q}_{\\mathsf{O}i},\\mathsf{q}_{\\mathsf{M}i},\\mathsf{q}_{\\mathsf{C}i})\\}_{i\\in[n]}</span> be a constraint system on <span class="math">m</span> variables. <span class="math">\\mathcal{P}lon\\mathcal{K}</span> requires that the system be preprocessed by defining univariate polynomials <span class="math">\\mathsf{q}_{\\mathsf{L}}(X),\\mathsf{q}_{\\mathsf{R}}(X),\\mathsf{q}_{\\mathsf{O}}(X),\\mathsf{q}_{\\mathsf{M}}(X),\\mathsf{q}_{\\mathsf{C}}(X)</span> in <span class="math">\\mathbb{Z}_{p}[X]</span> satisfying:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{q}_{\\mathsf{L}}(\\omega_{n}^{i})=\\mathsf{q}_{\\mathsf{L}i}\\quad\\mathsf{q}_{\\mathsf{R}}(\\omega_{n}^{i})=\\mathsf{q}_{\\mathsf{R}i}\\quad\\mathsf{q}_{\\mathsf{O}}(\\omega_{n}^{i})=\\mathsf{q}_{\\mathsf{O}i}\\quad\\mathsf{q}_{\\mathsf{M}}(\\omega_{n}^{i})=\\mathsf{q}_{\\mathsf{M}i}\\quad\\mathsf{q}_{\\mathsf{C}}(\\omega_{n}^{i})=\\mathsf{q}_{\\mathsf{C}i}\\enspace,</span></p>

    <p class="text-gray-300">for every <span class="math">i\\in[n]</span>. We recall that <span class="math">\\omega_{n}</span> is a designated <span class="math">n</span>-th primitive root of unity. Furthermore the relations between indices <span class="math">\\{a_{i},b_{i},c_{i}\\}_{i\\in[n]}</span> are captured through a permutation <span class="math">\\sigma:[3n]\\to[3n]</span>, which decomposes in exactly <span class="math">m</span> cycles: the <span class="math">j</span>-th cycle involving all positions where the <span class="math">j</span>-th variable is used. Such permutation is then transformed into a list of 3 polynomials <span class="math">\\mathsf{S}_{\\sigma 1}</span>, <span class="math">\\mathsf{S}_{\\sigma 2}</span>, <span class="math">\\mathsf{S}_{\\sigma 3}</span>, which are involved in the definition of the so-called <em>permutation identities</em>, parametrized by two scalars <span class="math">\\beta,\\gamma\\in\\mathbb{Z}_{p}</span>:</p>

    <p class="text-gray-300"><span class="math">\\text{{perm-ids}}_{\\beta,\\gamma}^{\\sigma}(\\mathsf{A}(X),\\mathsf{B}(X),\\mathsf{C}(X),\\mathsf{Z}(X))\\enspace,</span></p>

    <p class="text-gray-300">defining two polynomials which must vanish over the whole subgroup <span class="math">\\mathcal{H}_{n}</span>. We describe in detail this identity, how it depends on polynomials <span class="math">\\mathsf{S}_{\\sigma i}</span>, and how these polynomials are created in Appendix A.1. Here, we just assume there exists an efficient mechanism to compute a polynomial <span class="math">\\mathsf{Z}</span> (of degree at most <span class="math">n</span>) that satisfies the <em>perm-ids</em> , from <span class="math">\\beta,\\gamma</span>, if polynomials <span class="math">\\mathsf{A}</span>, <span class="math">\\mathsf{B}</span>, <span class="math">\\mathsf{C}</span> were honestly generated from a satisfying assignment to the constraint system <span class="math">\\mathcal{C}</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\Psi</span> be a polynomial commitment scheme, and let <span class="math">(\\mathsf{ck},\\mathsf{vk})\\leftarrow\\Psi.\\mathsf{Setup}(1^{\\lambda},n)</span>. <span class="math">\\mathcal{P}lon\\mathcal{K}</span>’s preprocessing phase concludes by committing to the above polynomials using <span class="math">\\Psi</span>. That is, <span class="math">\\mu_{\\mathsf{q}_{\\mathsf{L}}}\\leftarrow\\Psi.\\mathsf{Commit}(\\mathsf{ck},\\mathsf{q}_{\\mathsf{L}})</span>, and</p>

    <p class="text-gray-300">similarly for <span class="math">\\mu_{\\mathsf{q}_{\\mathsf{R}}}</span>, <span class="math">\\mu_{\\mathsf{q}_{\\mathsf{G}}}</span>, <span class="math">\\mu_{\\mathsf{q}_{\\mathsf{M}}}</span>, <span class="math">\\mu_{\\mathsf{q}_{\\mathsf{C}}}</span> and <span class="math">\\mu_{\\mathsf{S}_{\\sigma 1}},\\mu_{\\mathsf{S}_{\\sigma 2}},\\mu_{\\mathsf{S}_{\\sigma 3}}</span>. These polynomial commitments, together with <span class="math">(\\mathsf{ck},\\mathsf{vk})</span> form <span class="math">\\mathcal{P}lon\\mathcal{K}</span>’s public parameters <span class="math">\\mathsf{pp}</span>.</p>

    <p class="text-gray-300">We describe <span class="math">\\mathcal{P}lon\\mathcal{K}</span>’s prover and verifier in Figure 1. In a nutshell, the prover commits to certain polynomials <span class="math">\\mathsf{A}</span>, <span class="math">\\mathsf{B}</span>, <span class="math">\\mathsf{C}</span>, that represent a valid trace witness. The prover then argues that such polynomials satisfy the identities over the whole subgroup <span class="math">\\mathcal{H}_n</span> by showing that the identities, instantiated with the witness polynomials, lead to polynomials which are divisible by <span class="math">Z_{\\mathcal{H}_n}</span>. This is done by committing to the quotient <span class="math">\\mathsf{T}</span> of such division and evaluating all (committed) polynomials on a uniformly sampled point <span class="math">\\xi</span>. The verifier then checks that <span class="math">Z_{\\mathcal{H}_n}(\\xi)\\mathsf{T}(\\xi)</span> equals the evaluation of the identities on <span class="math">\\xi</span>, which ensures that the previous division (over polynomials) was exact thanks to the knowledge soundness of <span class="math">\\varPsi</span> and the Schwartz-Zippel Lemma.</p>

    <p class="text-gray-300">If instantiated with a secure polynomial commitment <span class="math">\\varPsi</span> which has logarithmic verification on the degree bound of polynomials<span class="math">^7</span>, the protocol from Figure 1 constitutes a SNARK for relation (1) by virtue of [GWC19, Theorem 7.1 &amp; Corollary 7.2].</p>

    <h2 id="sec-39" class="text-2xl font-bold">3 Multi-polynomial commitment schemes</h2>

    <p class="text-gray-300">We introduce the notion of <em>multi-polynomial commitment schemes</em>, a generalization of polynomial commitment schemes designed to commit to several polynomials at the same time. We require the commitment size be sublinear in the number of committed polynomials. Furthermore, we require that verification can be performed from a succinct (standard) commitment to the polynomial evaluations. That way, the verifier does not need to obtain the actual evaluations, which allows its running time to be sublinear in the number of polynomials involved.</p>

    <p class="text-gray-300"><strong>Definition 4 (Multi-polynomial commitment).</strong> A multi-polynomial commitment scheme over a ring <span class="math">R</span> consists of five polynomial-time algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}(1^{\\lambda},d,K)\\to (\\mathsf{ck},\\mathsf{vk})</span>, on input the security parameter <span class="math">\\lambda</span>, a degree bound <span class="math">d\\in \\mathbb{N}</span>, and a vector length bound <span class="math">K\\in \\mathbb{N}</span>, outputs a commitment key <span class="math">\\mathsf{ck}</span> and a verification key <span class="math">\\mathsf{vk}</span>.</li>

      <li><span class="math">\\mathsf{Commit-Polys}(\\mathsf{ck},\\pmb {f})\\to \\mathsf{com}_{\\pmb{f}}</span>, given a commitment key <span class="math">\\mathsf{ck}</span> and a vector of <span class="math">k</span> polynomials <span class="math">\\pmb {f}\\in R^{&amp;lt;d}[X]^k</span>, with <span class="math">k\\leq K</span>, outputs a commitment <span class="math">\\mathsf{com}_{\\pmb{f}}</span>. We require that the size of <span class="math">\\mathsf{com}_{\\pmb{f}}</span> be sublinear in <span class="math">k</span>.</li>

      <li><span class="math">\\mathsf{Commit-Evals}(\\pmb{v}) \\to \\mathsf{com}_{\\pmb{v}}</span>, given a vector <span class="math">\\pmb{v} \\in R^k</span>, with <span class="math">k \\leq K</span>, outputs a commitment <span class="math">\\mathsf{com}_{\\pmb{v}}</span>. We require that the size of <span class="math">\\mathsf{com}_{\\pmb{v}}</span> be sublinear in <span class="math">k</span>.</li>

      <li><span class="math">\\mathsf{Open}(\\mathsf{ck},\\mathsf{com}_{\\pmb{f}},z,\\pmb {f})\\to \\pi</span>, given a commitment key, a commitment <span class="math">\\mathsf{com}_{\\pmb{f}}</span>, an evaluation point <span class="math">z\\in R</span> and a vector of <span class="math">k</span> polynomials in <span class="math">R^{&amp;lt;d}[X]</span> (that were committed in <span class="math">\\mathsf{com}_{\\pmb{f}}</span>) with <span class="math">k\\leq K</span>, outputs a proof <span class="math">\\pi</span>.</li>

      <li><span class="math">\\mathsf{Check}(\\mathsf{vk},\\mathsf{com}_{\\pmb{f}},z,\\mathsf{com}_{\\pmb{v}},\\pi)\\to 1 / 0</span>, given a verification key <span class="math">\\mathsf{vk}</span>, a commitment to polynomials <span class="math">\\mathsf{com}_{\\pmb{f}}</span>, an evaluation point <span class="math">z</span>, a commitment to evaluations <span class="math">\\mathsf{com}_{\\pmb{v}}</span>, and a proof <span class="math">\\pi</span>, outputs a bit. We require that the verification complexity be sublinear in <span class="math">K</span>.</li>

    </ul>

    <p class="text-gray-300">For the sake of simplicity, we require that all algorithms except <span class="math">\\mathsf{Setup}</span> be deterministic. Our definitions could be adjusted to support non-determinism, but this is not necessary for our use case. (Commitments do not need to be hiding, as zero-knowledge can be enforced by other mechanisms.)</p>

    <p class="text-gray-300"><strong>Completeness.</strong> A multi-polynomial commitment scheme is <em>complete</em> if for every <span class="math">\\lambda, d, K</span> and all <span class="math">(\\mathsf{ck}, \\mathsf{vk}) \\gets \\mathsf{Setup}(1^{\\lambda}, d, K)</span>, for any <span class="math">k \\leq K</span>, any vector <span class="math">\\pmb{f} \\in R^{&amp;lt;d}[X]^k</span>, and any <span class="math">z \\in R</span>, it holds:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {C h e c k} (\\mathrm {v k}, \\operatorname {c o m} _ {\\boldsymbol {f}}, z, \\operatorname {c o m} _ {\\boldsymbol {v}}, \\operatorname {O p e n} (\\mathrm {c k}, \\operatorname {c o m} _ {\\boldsymbol {f}}, z, \\boldsymbol {f})) = 1,</span></div>

    <p class="text-gray-300">where <span class="math">\\mathsf{com}_{\\pmb{f}} \\coloneqq \\mathsf{Commit-Polys}(\\mathsf{ck}, \\pmb{f})</span> and <span class="math">\\mathsf{com}_{\\pmb{v}} \\coloneqq \\mathsf{Commit-Evals}(\\pmb{f}(z))</span>.</p>

    <p class="text-gray-300">7The authors propose to instantiate <span class="math">\\varPsi</span> with the KZG polynomial commitment scheme [KZG10], which leads to a SNARK whose knowledge soundness holds in the algebraic group model.</p>

    <p class="text-gray-300">8We assume both keys implicitly contain <span class="math">d,K</span> and that ck implicitly contains vk.</p>

    <p class="text-gray-300">PlonK.Prove(C, pp, x, w):</p>

    <p class="text-gray-300">Inputs: constraint system  <span class="math">\\mathcal{C}</span>  on  <span class="math">m</span>  variables, preprocessed parameters pp for  <span class="math">\\mathcal{C}</span> , instance  <span class="math">\\pmb{x}</span> , witness trace  <span class="math">\\pmb{w}</span></p>

    <p class="text-gray-300">Output: PoK  <span class="math">\\left\\{\\pmb {w}\\in \\mathbb{Z}_p^{m - \\ell}:(\\pmb {x},\\pmb {w})\\in \\mathbb{Z}_p^m\\text{satisfies}\\mathcal{C}\\right\\}</span></p>

    <p class="text-gray-300">1:  <span class="math">\\widetilde{w} := (\\pmb{x}, \\pmb{w})</span> ;  <span class="math">\\mathsf{A}(X) := \\sum_{i=1}^{n} \\widetilde{w}_{a_i} \\mathsf{L}_i(X)</span> ;  <span class="math">\\mathsf{B}(X) := \\sum_{i=1}^{n} \\widetilde{w}_{b_i} \\mathsf{L}_i(X)</span> ;  <span class="math">\\mathsf{C}(X) := \\sum_{i=1}^{n} \\widetilde{w}_{c_i} \\mathsf{L}_i(X)^a</span> 2:  <span class="math">[\\mathsf{A}]\\coloneqq \\varPsi .</span>  Commit(ck,A);  <span class="math">[\\mathsf{B}]\\coloneqq \\varPsi .</span>  Commit(ck,B);  <span class="math">[\\mathsf{C}]\\coloneqq \\varPsi .</span>  Commit(ck,C) 3:  <span class="math">\\beta \\gets \\mathsf{Hash}([\\mathsf{A}],[\\mathsf{B}],[\\mathsf{C}])</span> ;  <span class="math">\\gamma \\gets \\mathsf{Hash}(\\beta)</span> 4: compute polynomial  <span class="math">\\mathsf{Z}(X)</span> , satisfying perm-ids <span class="math">_{\\beta, \\gamma}^{\\pi}(\\mathsf{A}, \\mathsf{B}, \\mathsf{C}, \\mathsf{Z})</span>  on  <span class="math">\\mathcal{H}_n</span>  ▷ See Appendix A.1 5:  <span class="math">[Z] \\gets \\Psi</span> . Commit(ck, Z) 6:  <span class="math">F(X) = (\\mathsf{q}_{\\mathsf{L}}\\mathsf{A} + \\mathsf{q}_{\\mathsf{R}}\\mathsf{B} + \\mathsf{q}_{\\mathsf{O}}\\mathsf{C} + \\mathsf{q}_{\\mathsf{M}}\\mathsf{A}\\mathsf{B} + \\mathsf{q}_{\\mathsf{C}})(X)</span> 7:  <span class="math">ids(X) = \\{F(X)\\} \\cup perm-ids_{\\beta, \\gamma}^{\\pi}(A, B, C, Z); \\alpha \\gets \\mathsf{Hash}(\\gamma, [Z])</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">8:  $\\mathsf{T}(X)\\coloneqq \\big(\\sum_{i\\in [</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ids</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]}\\alpha^i ids_i(X)\\big) / Z_{\\mathcal{H}_n}(X)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">9:  <span class="math">[\\mathsf{T}]\\gets \\varPsi</span>  .Commit(ck,T) 10:  <span class="math">\\xi \\gets \\mathsf{Hash}(\\alpha, [\\mathsf{T}])</span> 11: return ([A], [B], [C], [Z], [T]) together with evaluations on  <span class="math">\\xi</span>  and proofs of their correctness, of these commitments as well as all polynomials commitments in pp; evaluate Z also on  <span class="math">\\xi \\omega</span>  Using  <span class="math">\\Psi</span> . Open</p>

    <p class="text-gray-300">PlonK.Verify(C, pp, x, π):</p>

    <p class="text-gray-300">Inputs: constraint system  <span class="math">\\mathcal{C}</span>  on  <span class="math">m</span>  variables, preprocessed parameters pp for  <span class="math">\\mathcal{C}</span> , instance  <span class="math">\\pmb{x}</span> , proof  <span class="math">\\pi</span></p>

    <p class="text-gray-300">Output: bool (true if the proof is accepted, false otherwise)</p>

    <p class="text-gray-300">1: parse  <span class="math">\\pi</span>  as ([A], [B], [C], [Z], [T],  <span class="math">\\pi_{\\mathrm{evals}}</span> ) 2: assert that the claimed evaluations in  <span class="math">\\pi_{\\mathrm{evals}}</span>  are correct 3:  <span class="math">\\beta \\gets \\mathsf{Hash}([\\mathsf{A}],[\\mathsf{B}],[\\mathsf{C}])</span> ;  <span class="math">\\gamma \\gets \\mathsf{Hash}(\\beta)</span> ;  <span class="math">\\alpha \\gets \\mathsf{Hash}(\\gamma, [\\mathsf{Z}])</span> ;  <span class="math">\\xi \\gets \\mathsf{Hash}(\\alpha, [\\mathsf{T}])</span> 4: evaluate  <span class="math">\\{ids\\}_{i}</span>  on  <span class="math">\\xi</span> , leveraging the claimed evaluations, obtaining  <span class="math">\\{\\overline{ids}\\}_{i}</span>  ▷  <span class="math">ids</span>  depend on  <span class="math">\\beta, \\gamma</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5: return  $\\sum_{i\\in [</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ids</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]}\\alpha^i\\overline{ids}_i = Z_{\\mathcal{H}_n}(\\xi)\\bar{t}<span class="math">  ▷  </span>\\bar{t}<span class="math">  is the claimed evaluation of  </span>T<span class="math">  on  </span>\\xi$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 1. The  <span class="math">\\mathcal{P}\\text{lon}\\mathcal{K}</span>  proving system for  <span class="math">\\mathcal{C} \\coloneqq \\{(a_i, b_i, c_i, q_{L_i}, q_{R_i}, q_{O_i}, q_{M_i}, q_{C_i})\\}_{i \\in [n]}</span> , with preprocessed parameters pp that include commitment keys (ck, vk) of a polynomial commitment scheme  <span class="math">\\Psi</span>  and polynomial commitments  <span class="math">[q_L], [q_R], [q_O], [q_M], [q_C]</span>  and  <span class="math">[S_{\\sigma,1}], [S_{\\sigma,2}], [S_{\\sigma,3}]</span> .</p>

    <p class="text-gray-300"><span class="math">{}^{a}</span>  Additional multiples of polynomial  <span class="math">{Z}_{{\\mathcal{H}}_{n}}</span>  may be optionally added to each  <span class="math">\\mathrm{A},\\mathrm{B},\\mathrm{C}</span>  ,to achieve zero-knowledge.</p>

    <p class="text-gray-300">Binding Property. A multi-polynomial commitment scheme is binding if for every polynomial  <span class="math">d, K \\in \\mathbb{N}</span>  and every PPT adversary  <span class="math">\\mathcal{A}</span> , the following probabilities are negligible in  <span class="math">\\lambda</span> :</p>

    <p class="text-gray-300"><span class="math">\\operatorname*{Pr}\\left[(\\mathsf{ck},\\mathsf{vk})\\gets \\mathsf{Setup}(1^{\\lambda},d,K);(\\pmb {f},\\pmb{f}^{\\prime})\\gets \\mathcal{A}(\\mathsf{ck}):\\begin{array}{l}\\pmb {f}\\neq \\pmb{f}^{\\prime}\\land \\pmb {f}\\in R^{&amp;lt;  d}[X]^{k},\\pmb{f}^{\\prime}\\in R^{&amp;lt;  d}[X]^{k^{\\prime}},k,k^{\\prime}\\leq K\\\\ \\mathrm{Commit - Polys}(\\mathsf{ck},\\pmb {f}) = \\mathrm{Commit - Polys}(\\mathsf{ck},\\pmb{f}^{\\prime})\\end{array}\\right],</span></p>

    <p class="text-gray-300"><span class="math">\\operatorname*{Pr}\\left[(\\mathsf{ck},\\mathsf{vk})\\gets \\mathsf{Setup}(1^{\\lambda},d,K);(\\pmb {v},\\pmb{v}^{\\prime})\\gets \\mathcal{A}(\\mathsf{ck}):\\begin{array}{l}\\pmb {v}\\neq \\pmb{v}^{\\prime}\\land \\pmb {v}\\in R^{k},\\pmb{v}^{\\prime}\\in R^{k^{\\prime}},k,k^{\\prime}\\leq K\\\\ \\mathrm{Commit - Evals}(\\pmb {v}) = \\mathrm{Commit - Evals}(\\pmb{v}^{\\prime})\\end{array}\\right].</span></p>

    <p class="text-gray-300">Knowledge Soundness. A multi-polynomial commitment scheme is knowledge sound if for every polynomial <span class="math">d, K \\in \\mathbb{N}</span> and every PPT adversary <span class="math">\\mathcal{A}</span>, there exists an (expected polynomial time) extractor <span class="math">\\mathcal{E}</span> such that the following probability is negligible in <span class="math">\\lambda</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr} \\left[ \\begin{array}{c c} (\\mathsf{ck}, \\mathsf{vk}) \\leftarrow \\operatorname{Setup}(1^{\\lambda}, d, K) &amp;amp; \\operatorname{Check}(\\mathsf{vk}, \\operatorname{com}_{\\boldsymbol{f}}, z, \\operatorname{com}_{\\boldsymbol{v}}, \\pi) = 1 \\\\ (\\operatorname{com}_{\\boldsymbol{f}}, z, \\operatorname{com}_{\\boldsymbol{v}}, \\pi) \\leftarrow \\mathcal{A}(\\mathsf{ck}) &amp;amp; \\bigwedge \\\\ \\boldsymbol{f} \\leftarrow \\mathcal{E}(\\mathsf{ck}) &amp;amp; \\bigwedge \\\\ &amp;amp; \\bigvee_{\\forall} \\operatorname{com}_{\\boldsymbol{v}} \\neq \\operatorname{Commit-Evals}(\\boldsymbol{f}(z)) \\end{array} \\right]</span></div>

    <h2 id="sec-40" class="text-2xl font-bold">3.1 A multi-polynomial commitment scheme from KZG and IPA</h2>

    <p class="text-gray-300">We present a generic construction of multi-polynomial commitments from:</p>

    <p class="text-gray-300">(i) a polynomial commitment scheme which is homomorphic over <span class="math">\\mathbb{G}_1</span>, inner-product binding and inner-product extractable (as defined below);</p>

    <p class="text-gray-300">(ii) a sublinear-verifier argument system for the following relation, parametrized by <span class="math">\\pmb{G} \\in \\mathbb{G}_2^k</span>, <span class="math">C \\in \\mathbb{G}_t</span>, <span class="math">P \\in \\mathbb{G}_1</span> and <span class="math">r \\in \\mathbb{Z}_p</span>, where <span class="math">\\pmb{r} = (1, r, \\dots, r^{k-1})</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{PoK}\\left\\{\\boldsymbol{\\mu} \\in \\mathbb{G}_1^k: \\langle \\boldsymbol{\\mu}, \\boldsymbol{G} \\rangle = C \\wedge \\langle \\boldsymbol{r}, \\boldsymbol{\\mu} \\rangle = P \\right\\}, \\tag{2}</span></div>

    <p class="text-gray-300">The first building block can be instantiated with the celebrated KZG commitment scheme [KZG10] (described in Appendix B). For the second building block, we propose a modified version of the inner-product argument [BBB+18], inspired by [GMN20] (see Figure 3).</p>

    <p class="text-gray-300"><strong>Homomorphic Property.</strong> A polynomial commitment scheme over group <span class="math">\\mathbb{G}</span> of prime order <span class="math">p</span> is homomorphic if for every <span class="math">\\lambda, d \\in \\mathbb{N}</span>, <span class="math">(\\mathsf{ck}, \\mathsf{vk}) \\gets \\mathsf{Setup}(1^{\\lambda}, d)</span> and all <span class="math">f, g \\in \\mathbb{Z}_p^{&amp;lt;d}[X]</span>, it holds:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Commit}(\\mathsf{ck}, f) +_{\\mathbb{G}} \\operatorname{Commit}(\\mathsf{ck}, g) = \\operatorname{Commit}(\\mathsf{ck}, f + g),</span></div>

    <p class="text-gray-300"><strong>Inner-Product Binding Property.</strong> A homomorphic polynomial commitment scheme (over <span class="math">\\mathbb{G}_1</span>) is inner-product binding if for every polynomial <span class="math">d, K \\in \\mathbb{N}</span> and every PPT (stateful) algorithm <span class="math">\\mathcal{A}</span>, the following probability is negligible in <span class="math">\\lambda</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr} \\left[ \\begin{array}{c c} (\\mathsf{ck}, \\mathsf{vk}) \\leftarrow \\operatorname{Setup}(1^{\\lambda}, d) &amp;amp; \\boldsymbol{f} \\neq \\boldsymbol{f}&#x27;, \\boldsymbol{f}, \\boldsymbol{f}&#x27; \\in \\mathbb{Z}_p^{&amp;lt;d}[X]^k, \\text{ with } k \\leq K \\\\ \\tau \\leftarrow \\mathbb{Z}_p &amp;amp; \\bigwedge_{(\\boldsymbol{f}, \\boldsymbol{f}&#x27;) \\in \\mathcal{A}(\\mathsf{ck}, [\\boldsymbol{\\tau}]_1, [\\boldsymbol{\\tau}]_2)}: \\langle \\operatorname{Commit}(\\mathsf{ck}, \\boldsymbol{f}), \\boldsymbol{\\tau}[:k] \\rangle = \\langle \\operatorname{Commit}(\\mathsf{ck}, \\boldsymbol{f}&#x27;), \\boldsymbol{\\tau}[:k] \\rangle \\end{array} \\right],</span></div>

    <p class="text-gray-300">where <span class="math">\\operatorname{Commit}(\\mathsf{ck}, \\boldsymbol{f})</span> is a shorthand for <span class="math">(\\operatorname{Commit}(\\mathsf{ck}, f_1), \\dots, \\operatorname{Commit}(\\mathsf{ck}, f_k))</span> and <span class="math">\\boldsymbol{\\tau} := (1, \\tau, \\dots, \\tau^{K-1})</span>.</p>

    <p class="text-gray-300"><strong>Proposition 1.</strong> The KZG PCS (Figure 7) is inner-product binding.</p>

    <p class="text-gray-300">We refer to Appendix B for a proof.</p>

    <p class="text-gray-300"><strong>Inner-Product Extractability.</strong> A homomorphic polynomial commitment scheme (over <span class="math">\\mathbb{G}_1</span>) is inner-product extractable if for every polynomial <span class="math">d, K \\in \\mathbb{N}</span> and every PPT (stateful) algorithm <span class="math">\\mathcal{A}</span>, there exists an (expected polynomial time) extractor <span class="math">\\mathcal{E}</span> such that the following probability is negligible in <span class="math">\\lambda</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr} \\left[ \\begin{array}{c c} (\\mathsf{ck}, \\mathsf{vk}) \\leftarrow \\operatorname{Setup}(1^{\\lambda}, d) &amp;amp; G \\in \\mathbb{G}_t, z \\in \\mathbb{Z}_p, \\boldsymbol{v} \\in \\mathbb{Z}_p^k, \\boldsymbol{\\mu} \\in \\mathbb{G}_1^k, \\text{ with } k \\leq K \\\\ \\tau, r \\leftarrow \\mathbb{Z}_p &amp;amp; \\langle \\boldsymbol{\\mu}, \\boldsymbol{\\tau}[:k] \\rangle = G \\\\ G, z, \\boldsymbol{v} \\leftarrow \\mathcal{A}(\\mathsf{ck}, [\\boldsymbol{\\tau}]_1, [\\boldsymbol{\\tau}]_2) &amp;amp; : \\operatorname{Check}(\\mathsf{vk}, \\langle \\boldsymbol{\\mu}, \\boldsymbol{r} \\rangle, z, \\langle \\boldsymbol{v}, \\boldsymbol{r} \\rangle, \\pi) = 1 \\\\ (\\boldsymbol{\\mu}, \\pi) \\leftarrow \\mathcal{A}(r) &amp;amp; \\big(\\boldsymbol{f}(z) \\neq \\boldsymbol{v} \\vee \\langle \\operatorname{Commit}(\\mathsf{ck}, \\boldsymbol{f}), \\boldsymbol{\\tau}[:k] \\rangle \\neq G \\big) \\end{array} \\right],</span></div>

    <p class="text-gray-300">where <span class="math">\\operatorname{Commit}(\\mathsf{ck}, \\boldsymbol{f})</span> is a shorthand for <span class="math">(\\operatorname{Commit}(\\mathsf{ck}, f_1), \\dots, \\operatorname{Commit}(\\mathsf{ck}, f_k))</span>, <span class="math">\\boldsymbol{\\tau} := (1, \\tau, \\dots, \\tau^{K-1})</span> and <span class="math">\\boldsymbol{r} := (1, r, \\dots, r^{k-1})</span>.</p>

    <p class="text-gray-300">Setup  <span class="math">(1^{\\lambda},d,K)</span></p>

    <p class="text-gray-300">1:  <span class="math">(\\mathsf{ck}_{\\Psi},\\mathsf{vk}_{\\Psi})\\gets \\varPsi .\\mathsf{Setup}(1^{\\lambda},d)</span> 2:  <span class="math">\\tau \\gets \\mathbb{Z}_p</span> ;  <span class="math">\\mathsf{ck}_{\\tau} := [1, \\tau, \\tau^2, \\dots, \\tau^{K-1}]_2</span> 3: return  <span class="math">(\\mathsf{ck} := (\\mathsf{ck}_{\\Psi}, \\mathsf{ck}_{\\tau}), \\mathsf{vk} := (\\mathsf{vk}_{\\Psi}, [\\tau]_1))</span></p>

    <p class="text-gray-300">Commit-Polys  <span class="math">(\\mathsf{ck}\\coloneqq (\\mathsf{ck}_{\\Psi},\\mathsf{ck}_{\\tau}),\\pmb {f})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1:  <span class="math">\\mu_{i}\\gets \\varPsi</span>  .Commit  $(\\mathsf{ck}_{\\Psi},f_i)\\forall i\\in [k](k\\coloneqq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pmb {f}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq K)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">2: return  <span class="math">\\mathsf{com}_{\\pmb{f}} := (k, \\sum_{i=1}^{k} e(\\mu_i, \\mathsf{ck}_{\\tau i}))</span></p>

    <p class="text-gray-300">Commit-Evals  <span class="math">(\\pmb{v})</span></p>

    <p class="text-gray-300">Any function that is (sublinearly) shrinking, binding and admits a succinct and efficient proof for relation:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {P o K} \\left\\{\\boldsymbol {v}: \\text {C o m m i t - E v a l s} (\\boldsymbol {v}) = \\operatorname {c o m} _ {\\boldsymbol {v}} \\wedge \\sum_ {i = 1} ^ {k} r ^ {i - 1} v _ {i} = \\hat {v} \\right\\} \\tag {3}</span></div>

    <p class="text-gray-300">Open  <span class="math">(\\mathsf{ck}\\coloneqq (\\mathsf{ck}_{\\Psi},\\mathsf{ck}_{\\tau}),\\mathsf{com}_{\\pmb{f}}\\coloneqq (k,G),z,\\pmb {f})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1:  <span class="math">\\pmb{v} = \\pmb{f}(z)</span> ;  <span class="math">\\mathsf{com}_{\\pmb{v}} := \\mathsf{Commit-Evals}(\\pmb{v})</span> ;  $k =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pmb{f}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> ;  </span>\\kappa := \\lceil \\log_2(k) \\rceil$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">2:  <span class="math">\\mu_{i}\\gets \\varPsi</span>  .Commit  <span class="math">(\\mathsf{ck}_{\\Psi},f_i)\\forall i\\in [k]</span>  ▷ Not necessary if  <span class="math">\\mu_{i}</span>  were stored on Commit-Polys 3:  <span class="math">r\\coloneqq \\mathsf{Hash}(\\mathsf{com}_{\\pmb{f}},z,\\mathsf{com}_{\\pmb{v}});</span> <span class="math">\\pmb {r}\\coloneqq (1,r,\\dots ,r^{n - 1});\\hat{f}\\coloneqq \\langle \\pmb {f},\\pmb {r}\\rangle ;\\hat{\\mu}\\coloneqq \\langle \\pmb {\\mu},\\pmb {r}\\rangle ;\\hat{v}\\coloneqq \\langle \\pmb {v},\\pmb {r}\\rangle</span> 4:  <span class="math">\\pi_{\\Psi} \\gets \\Psi</span> . Open  <span class="math">(\\mathsf{ck}_{\\Psi}, \\hat{\\mu}, z, \\hat{f}, \\hat{v})</span> 5: produce a proof  <span class="math">\\pi_v</span>  of relation (3) w.r.t  <span class="math">\\mathsf{com}_v</span> ,  <span class="math">\\hat{v}</span>  and  <span class="math">r</span> 6:  <span class="math">\\pi_{\\mathrm{IPA}} \\gets \\mathrm{IPA}.</span>  Prove  <span class="math">(k, \\mathsf{ck}_{\\tau}, (G, r, \\hat{\\mu}), \\mu)</span>  (let  <span class="math">\\{u_j\\}_{j=1}^{\\kappa}</span>  be the sampled random challenges) 7:  <span class="math">g(X) \\coloneqq \\prod_{j=1}^{\\kappa}(u_j^{-1} + u_jX^{2^{\\kappa - j}})</span> ;  <span class="math">\\rho \\coloneqq \\mathsf{Hash}(\\pi_{\\mathsf{IPA}})</span>  and  <span class="math">v_\\rho \\coloneqq g(\\rho)</span> 8:  <span class="math">h(X)\\coloneqq (g(X) - v_{\\rho}) / (X - \\rho);\\pi_{\\tau}\\coloneqq [h(\\tau)]_2</span> <span class="math">\\triangleright \\pi_{\\tau}</span>  is comptued using  <span class="math">\\mathsf{ck}_{\\tau}</span> 9: return  <span class="math">(\\hat{\\mu},\\hat{v},\\pi_{\\Psi},\\pi_{v},\\pi_{\\mathrm{IPA}},\\pi_{\\tau})</span></p>

    <p class="text-gray-300">Check(vk := (vk, [τ]), comf := (k, G), z, comv, π := (μ, v, π, π, π, πIPA, π)):</p>

    <p class="text-gray-300">1:  <span class="math">r\\coloneqq \\mathsf{Hash}(\\mathsf{com}_{\\pmb{f}},z,\\mathsf{com}_{\\pmb{v}})</span> 2:  <span class="math">b_{\\Psi} \\gets \\Psi</span> . Check  <span class="math">(\\mathsf{vk}_{\\Psi}, \\hat{\\mu}, z, \\hat{v}, \\pi_{\\Psi})</span> 3: let  <span class="math">b_v</span>  be the result of verifying that  <span class="math">\\pi_v</span>  is a valid proof of relation (3) w.r.t  <span class="math">\\mathsf{com}_v</span> ,  <span class="math">\\hat{v}</span>  and  <span class="math">r</span> 4:  <span class="math">b_{\\mathrm{IPA}} \\gets \\mathrm{IPA.Verify}&#x27;(k, [\\tau]_1, (G, r, \\hat{\\mu}), \\pi_{\\mathrm{IPA}})</span>  ▷ Skip steps 6-7 of Figure 3 5:  <span class="math">\\rho \\coloneqq \\mathsf{Hash}(\\pi_{\\mathsf{IPA}});v_{\\rho}\\coloneqq \\prod_{j = 1}^{\\kappa}(u_j^{-1} + u_j\\rho^{2^{\\kappa -j}})</span> <span class="math">\\triangleright u_{j}</span>  are the challenges computed during IPA.Verify' 6:  <span class="math">b_{\\tau} \\coloneqq e([\\tau]_{1} - [\\rho]_{1}, \\pi_{\\tau}) \\stackrel{?}{=} e([1]_{1}, G_{0} - [v_{\\rho}]_{2})</span> <span class="math">\\triangleright G_{0} \\in \\mathbb{G}_{2}</span>  is the last element of  <span class="math">\\pi_{\\mathrm{IPA}}</span> 7: return  <span class="math">b_{\\Psi} \\wedge b_v \\wedge b_{\\mathrm{IPA}} \\wedge b_\\tau</span></p>

    <p class="text-gray-300">Fig. 2. Multi-polynomial commitment scheme based on an inner-product binding and inner-product extractable polynomial commitment scheme  <span class="math">\\varPsi</span>  (over  <span class="math">\\mathbb{G}_1</span> ) and inner-product argument IPA from Figure 3.</p>

    <p class="text-gray-300">Proposition 2. The KZG PCS (Figure 7) is inner-product extractable.</p>

    <p class="text-gray-300">We refer to Appendix B for a proof.</p>

    <p class="text-gray-300">Theorem 1. If <span class="math">\\mathsf{Hash}:\\{0,1\\}^{*}\\to\\mathbb{Z}_{p}</span> is a random oracle, and polynomial commitment scheme <span class="math">\\Psi</span> is complete, binding, knowledge sound, homomorphic, inner-product binding and inner-product extractable, then the scheme from Figure 2 is a complete, binding and knowledge sound multi-polynomial commitment scheme.</p>

    <p class="text-gray-300">We refer to Appendix C.1 for a proof.</p>

    <p class="text-gray-300">Remark 4. Our scheme from Figure 2 could also be instantiated with a homomorphic commitment scheme <span class="math">\\Psi</span> that is not inner-product binding nor inner-product extractable. In that case, the multi-polynomial commitment scheme would need to be modified by adding a second <span class="math">\\mathbb{G}_{\\mathfrak{t}}</span> element <span class="math">\\sum_{i=1}^{k} e(\\mu_i, [\\tilde{\\tau}^i]_2)</span> to <span class="math">\\mathsf{com}_{\\boldsymbol{f}}</span> for a new <span class="math">\\tilde{\\tau}</span> independent of <span class="math">\\tau</span>. This modification would make the committing function binding, which would allow us to prove security without relying on the inner-product binding and inner-product extractability properties of <span class="math">\\Psi</span> (see Appendix C.1). Note that proofs of opening would need to include an extra element <span class="math">\\pi_{\\tilde{\\tau}}</span>, computed as <span class="math">[h(\\tilde{\\tau})]_2</span>, analogously to <span class="math">\\pi_{\\tau}</span> in step 8 of the Open algorithm, which would be verified with a second pairing equation in step 6 of the Check algorithm. Furthermore, the IPA protocol would need to be adapted, as described in Figure 3 through extra colored terms.</p>

    <h2 id="sec-41" class="text-2xl font-bold">4 <span class="math">\\mathcal{P}lon\\mathcal{K}</span> proof aggregation from multi-polynomial commitments</h2>

    <p class="text-gray-300">We study the problem of designing a multi-statement proving system, that can handle several <span class="math">\\mathcal{P}lon\\mathcal{K}</span> proofs more efficiently than the simple parallel execution on every statement of the traditional <span class="math">\\mathcal{P}lon\\mathcal{K}</span> system. For the sake of simplicity in our exposition, we assume that all statements are parametrized by the same <span class="math">\\mathcal{P}lon\\mathcal{K}</span> constraint system (although each statement has its own public inputs). However, most of our techniques apply to the case with different systems.</p>

    <h3 id="sec-42" class="text-xl font-semibold mt-8">4.1 <span class="math">a\\mathcal{P}lon\\mathcal{K}</span></h3>

    <p class="text-gray-300">A simple but effective first optimization is to share the random challenges sampled with Fiat-Shamir across all proofs. This can be beneficial for several reasons. For example, having a common evaluation point <span class="math">\\xi</span> for all proofs means that all polynomial commitments are opened at the same point, which can typically lead to significant optimizations by the underlying polynomial commitment scheme. Note that sharing such random challenges across proofs does not harm security as long as the challenges are computed from the partial transcripts of all proofs. In that case, from an extractor for the aggregated proving system one could build an extractor for any of the individual statements by fixing all other statements. On the other hand, this trick, which is the basis of many of our optimizations, requires that the provers of every different statement run coordinately or at least synchronize at every point where random challenges are sampled. This limitation prevents us from strictly achieving IVC <em>[x18]</em>, but does not limit the distribution of the prover computation. Thus, our system is perfectly applicable to creating a validity rollup (see Section 1.1).</p>

    <p class="text-gray-300">Another rather simple optimization is to have a common polynomial <span class="math">\\mathsf{T}</span> for all proofs, computed from a linear combination of all the identities. In the rest of this section, we describe our more sophisticated optimization techniques. The resulting proving system, that we call <span class="math">a\\mathcal{P}lon\\mathcal{K}</span>, is described in Figure 4.</p>

    <p class="text-gray-300">Theorem 2. If multi-polynomial commitment scheme <span class="math">\\Psi</span> is complete, binding and knowledge sound, and <span class="math">\\mathsf{Hash}:\\{0,1\\}^{*}\\to\\mathbb{Z}_{p}</span> is a random oracle, the protocol described in Figure 4 constitutes a SNARK for relation:</p>

    <p class="text-gray-300"><span class="math">\\mathrm{PoK}\\left\\{\\ \\{\\boldsymbol{w}_{i}\\in\\mathbb{Z}_{p}^{m-\\ell}\\}_{i\\in[k]}\\ :\\ (\\boldsymbol{x_{i}},\\boldsymbol{w_{i}})\\in\\mathbb{Z}_{p}^{m}\\ \\text{satisfies}\\ \\mathcal{C}\\ \\ \\forall i\\in[k]\\ \\right\\}\\enspace.</span></p>

    <p class="text-gray-300">We refer to Appendix C.2 for a proof.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">IPA.Prove  <span class="math">(k,\\pmb {G},\\pmb {H},(C_G,C_H,r,P),\\pmb {\\mu})</span></p>

    <p class="text-gray-300">Inputs:  <span class="math">k\\coloneqq 2^{\\kappa}</span>  , vectors  <span class="math">\\pmb {G},\\pmb {H}\\in \\mathbb{G}_2^k</span>  , instance  <span class="math">(C_G,C_H,r,P)\\in \\mathbb{G}_1^2\\times \\mathbb{Z}_p\\times \\mathbb{G}_1</span>  , witness  <span class="math">\\pmb {\\mu}\\in \\mathbb{G}_1^k</span></p>

    <p class="text-gray-300">Output:  <span class="math">\\mathrm{PoK}\\{\\pmb {\\mu}\\in \\mathbb{G}_1^k:\\langle \\pmb {\\mu},\\pmb {G}\\rangle = C_G\\wedge \\langle \\pmb {\\mu},\\pmb {H}\\rangle = C_H\\wedge \\langle \\pmb {r},\\pmb {\\mu}\\rangle = P\\}</span>  , where  <span class="math">\\pmb {r} = (1,r,r^2,r^3,\\dots ,r^{k - 1})</span></p>

    <p class="text-gray-300">1: set  <span class="math">\\pmb{\\mu}^{(\\kappa)}\\coloneqq \\pmb {\\mu}</span> <span class="math">r^{(\\kappa)}\\coloneqq (1,r,r^2,r^3,\\ldots ,r^{2^{\\kappa} - 1})</span> <span class="math">G^{(\\kappa)}\\coloneqq G</span> <span class="math">H^{(\\kappa)}\\coloneqq H</span>  , and ts  <span class="math">\\coloneqq (C_G,C_H,r,P)</span> 2: for every  <span class="math">j</span>  from  <span class="math">\\kappa</span>  down to 1 do 3: set  <span class="math">L_{G}^{(j)}\\coloneqq \\langle \\pmb{\\mu}_{\\mathsf{L}}^{(j)},\\pmb{G}_{\\mathsf{R}}^{(j)}\\rangle</span> <span class="math">L_{H}^{(j)}\\coloneqq \\langle \\pmb{\\mu}_{\\mathsf{L}}^{(j)},\\pmb{H}_{\\mathsf{R}}^{(j)}\\rangle</span>  and  <span class="math">L_{r}^{(j)}\\coloneqq \\langle \\pmb{\\mu}_{\\mathsf{L}}^{(j)},\\pmb{r}_{\\mathsf{R}}^{(j)}\\rangle</span> 4: set  <span class="math">R_{G}^{(j)}\\coloneqq \\langle \\pmb{\\mu}_{\\mathsf{R}}^{(j)},\\pmb{G}_{\\mathsf{L}}^{(j)}\\rangle</span> <span class="math">R_{H}^{(j)}\\coloneqq \\langle \\pmb{\\mu}_{\\mathsf{R}}^{(j)},\\pmb{H}_{\\mathsf{L}}^{(j)}\\rangle</span>  and  <span class="math">R_{r}^{(j)}\\coloneqq \\langle \\pmb{\\mu}_{\\mathsf{R}}^{(j)},\\pmb{r}_{\\mathsf{L}}^{(j)}\\rangle</span> 5: set  <span class="math">u_{j}\\gets \\mathsf{Hash}(L_{G}^{(j)},R_{G}^{(j)},L_{H}^{(j)},R_{H}^{(j)},L_{r}^{(j)},R_{r}^{(j)},\\mathsf{ts})\\in \\mathbb{Z}_{p}</span>  and  <span class="math">\\mathsf{ts}\\coloneqq u_j</span> 6: set  <span class="math">\\pmb{\\mu}^{(j - 1)}\\coloneqq u_j\\pmb{\\mu}_L^{(j)} + u_j^{-1}\\pmb{\\mu}_R^{(j)}</span> 7: set  <span class="math">\\pmb{G}^{(j - 1)}\\coloneqq u_j^{-1}\\pmb{G}_L^{(j)} + u_j\\pmb{G}_R^{(j)}\\triangleright u_j</span>  multiplies the left half of  <span class="math">\\pmb{\\mu}^{(j)}</span> , but the right half of  <span class="math">\\pmb{G}^{(j)}</span> ,  <span class="math">\\pmb{H}^{(j)}</span> ,  <span class="math">\\pmb{r}^{(j)}</span> 8: set  <span class="math">\\pmb{H}^{(j - 1)}\\coloneqq u_j^{-1}\\pmb {H}_L^{(j)} + u_j\\pmb {H}_R^{(j)}</span> 9: set  <span class="math">\\pmb{r}^{(j - 1)}\\coloneqq u_j^{-1}\\pmb {r}_L^{(j)} + u_j\\pmb {r}_R^{(j)}</span> 10: return  <span class="math">\\pi := (\\{L_G^{(j)}, R_G^{(j)}, L_H^{(j)}, R_H^{(j)}, L_r^{(j)}, R_r^{(j)}\\}_{j \\in [\\kappa]}, \\pmb{\\mu}^{(0)}, \\pmb{G}^{(0)}, \\pmb{H}^{(0)}) \\in (\\mathbb{G}_1^4 \\times \\mathbb{G}_1^2)^\\kappa \\times \\mathbb{G}_1 \\times \\mathbb{G}_2^2</span></p>

    <p class="text-gray-300">IPA.Verify  <span class="math">(k,\\pmb {G},\\pmb {H},(C_G,C_H,r,P),\\pi)</span></p>

    <p class="text-gray-300">Inputs:  <span class="math">k\\coloneqq 2^{\\kappa}</span>  , vectors  <span class="math">\\pmb {G},\\pmb {H}\\in \\mathbb{G}_2^k</span>  , instance  <span class="math">(C_G,C_H,r,P)\\in \\mathbb{G}_1^2\\times \\mathbb{Z}_p\\times \\mathbb{G}_1</span>  , proof  <span class="math">\\pi</span></p>

    <p class="text-gray-300">Output: bool (true if the proof is accepted, false otherwise)</p>

    <p class="text-gray-300">1: parse  <span class="math">\\pi</span>  as  <span class="math">(\\{L_G^{(j)},R_G^{(j)},L_H^{(j)},R_H^{(j)},L_r^{(j)},R_r^{(j)}\\}_{j\\in [\\kappa ]},\\mu_0,G_0,H_0)\\in (\\mathbb{G}_1^4\\times \\mathbb{G}_1^2)^\\kappa \\times \\mathbb{G}_1\\times \\mathbb{G}_2^2</span>  or fail 2: for every  <span class="math">j</span>  from  <span class="math">\\kappa</span>  down to 1 do 3: set  <span class="math">u_{j}\\gets \\mathsf{Hash}(L_{G}^{(j)},R_{G}^{(j)},L_{H}^{(j)},R_{H}^{(j)},L_{r}^{(j)},R_{r}^{(j)},\\mathsf{ts})\\in \\mathbb{Z}_{p}</span>  and set  <span class="math">\\mathfrak{ts}\\coloneqq u_j</span> 4: define  <span class="math">g(X) \\coloneqq \\prod_{j=1}^{\\kappa}(u_j^{-1} + u_j X^{2^{\\kappa - j}})</span> <span class="math">\\triangleright g</span>  is a polynomial of degree  <span class="math">2^{\\kappa} - 1</span> 5: set  <span class="math">r_0 \\coloneqq g(r)</span> <span class="math">\\triangleright \\mathcal{O}(\\kappa)</span>  if  <span class="math">g(r)</span>  is computed as  <span class="math">\\prod_{j=1}^{\\kappa}(u_j^{-1} + u_j r^{2^{\\kappa - j}})</span> 6: let  <span class="math">\\pmb{g} = (g_0, g_1, \\dots, g_{2^{\\kappa} - 1})</span>  be the coefficients of  <span class="math">g</span>  in increasing order of degree 7: assert  <span class="math">\\langle \\pmb{g},\\pmb{G}\\rangle = G_0</span>  , and  <span class="math">\\langle \\pmb {g},\\pmb {H}\\rangle = H_0</span> <span class="math">\\triangleright \\mathcal{O}(2^{\\kappa})</span> 8: return true iff  <span class="math">r_0 \\cdot \\mu_0 = P + \\sum_{j=1}^{\\kappa} (u_j^2 L_r^{(j)} + u_j^{-2} R_r^{(j)})</span>  and the following hold:</p>

    <div class="my-4 text-center"><span class="math-block">e \\left(\\mu_ {0}, G _ {0}\\right) = C _ {G} + \\sum_ {j = 1} ^ {\\kappa} \\left(u _ {j} ^ {2} L _ {G} ^ {(j)} + u _ {j} ^ {- 2} R _ {G} ^ {(j)}\\right) \\quad \\wedge \\quad e \\left(\\mu_ {0}, H _ {0}\\right) = C _ {H} + \\sum_ {j = 1} ^ {\\kappa} \\left(u _ {j} ^ {2} L _ {H} ^ {(j)} + u _ {j} ^ {- 2} R _ {H} ^ {(j)}\\right)</span></div>

    <p class="text-gray-300">Fig. 3. Inner-product argument (IPA) for relation  <span class="math">\\mathrm{PoK}\\{\\pmb {\\mu}\\in \\mathbb{G}_1^{2^\\kappa}:\\langle \\pmb {\\mu},\\pmb {G}\\rangle = C_G\\wedge \\langle \\pmb {\\mu},\\pmb {H}\\rangle = C_H\\wedge \\langle \\pmb {r},\\pmb {\\mu}\\rangle = P\\}</span> . The figure describes two schemes obtained by including or discarding the colored terms.</p>

    <p class="text-gray-300">Shared permutation argument. Permutation arguments [BG12, BCC+16, MBKM19] can be used for arguing correctness of a shuffle  <span class="math">\\sigma</span> .  <span class="math">\\mathcal{P}lon\\mathcal{K}</span> 's permutation argument [GWC19] is used for enforcing that the wires which are supposed to be equal have indeed been instantiated with the same value. This is done by committing to a polynomial  <span class="math">Z</span>  (see step 4 of the  <span class="math">\\mathcal{P}lon\\mathcal{K}</span> . Prove routine from Figure 1), which satisfies the permutation identities (see Appendix A.1) with respect to the wire polynomials  <span class="math">A, B, C</span> .</p>

    <p class="text-gray-300">We observe that it is possible to share the permutation argument across all proofs for the same circuit, since the permutation  <span class="math">\\sigma</span>  is common to all of them. To do so, we linearly batch the wire polynomials  <span class="math">\\mathsf{A}_j,\\mathsf{B}_j,\\mathsf{C}_j</span></p>

    <p class="text-gray-300">aPlonK.Setup(1 <span class="math">\\lambda</span> , C := {ai, bi, ci, qLi, qRi, qOi, qMi, qCi}i∈[n], k):</p>

    <p class="text-gray-300">1:  <span class="math">\\mathsf{q}_{\\mathsf{L}}(X) := \\sum_{i=1}^{n} \\mathsf{q}_{\\mathsf{L}_i} \\mathsf{L}_{i,n}(X)</span> ; define  <span class="math">\\mathsf{q}_{\\mathsf{R}}, \\mathsf{q}_{\\mathsf{O}}, \\mathsf{q}_{\\mathsf{M}}, \\mathsf{q}_{\\mathsf{C}}</span>  analogously 2:  <span class="math">\\sigma : [3n] \\to [3n]</span>  be  <span class="math">\\mathcal{C}_{\\sigma}</span> ; pp.polys :=  <span class="math">(q_{L}, q_{R}, q_{O}, q_{M}, q_{C}, S_{\\sigma 1}, S_{\\sigma 2}, S_{\\sigma 3})</span> 3:  <span class="math">(\\mathsf{ck},\\mathsf{vk})\\gets \\varPsi .\\mathsf{Setup}(1^{\\lambda},n,k);\\mu_{\\mathsf{pp}}\\gets \\varPsi .\\mathsf{Commit - Polys}(\\mathsf{ck},\\mathsf{pp}.</span>  polys) 4: return pp := (n, σ, ck, vk, μpp, pp.polys)</p>

    <p class="text-gray-300">aPlonK.Prove(pp := (n, σ, ck, _, μpp, pp.polys), {xj}j∈[k], {wj}j∈[k]):</p>

    <p class="text-gray-300">1:  <span class="math">\\widetilde{\\pmb{w}}_j\\coloneqq (\\pmb {x}_j,\\pmb {w}_j)</span>  for all  <span class="math">j\\in [k]</span> 2:  <span class="math">\\mathsf{A}_j(X) := \\sum_{i=1}^n \\widetilde{w}_{j a_i} \\mathsf{L}_{i,n}(X)</span> ;  <span class="math">\\mathsf{B}_j(X) := \\sum_{i=1}^n \\widetilde{w}_{j b_i} \\mathsf{L}_{i,n}(X)</span> ;  <span class="math">\\mathsf{C}_j(X) := \\sum_{i=1}^n \\widetilde{w}_{j c_i} \\mathsf{L}_{i,n}(X)</span>  for all  <span class="math">j \\in [k]</span> 3:  <span class="math">\\mathbf{W} := (\\mathsf{A}_1, \\mathsf{B}_1, \\mathsf{C}_1, \\ldots, \\mathsf{A}_k, \\mathsf{B}_k, \\mathsf{C}_k)</span> ;  <span class="math">\\mu_{\\mathbf{w}} := \\varPsi</span> . Commit-Polys(ck, W) 4:  <span class="math">\\beta \\gets \\mathrm{Hash}(\\mu_{\\mathbf{w}})</span> ;  <span class="math">\\gamma \\gets \\mathrm{Hash}(\\beta)</span> ;  <span class="math">\\delta \\gets \\mathrm{Hash}(\\gamma)</span> 5:  <span class="math">\\widetilde{\\mathsf{A}}(X) \\coloneqq \\sum_{j=1}^{k} \\delta^j \\mathsf{A}_j(X)</span> ;  <span class="math">\\widetilde{\\mathsf{B}}(X) \\coloneqq \\sum_{j=1}^{k} \\delta^j \\mathsf{B}_j(X)</span> ;  <span class="math">\\widetilde{\\mathsf{C}}(X) \\coloneqq \\sum_{j=1}^{k} \\delta^j \\mathsf{C}_j(X)</span> 6: compute polynomial  <span class="math">\\mathsf{Z}(X)</span> , satisfying perm-ids <span class="math">_{\\beta, \\gamma}^{\\sigma}(\\widetilde{\\mathsf{A}}, \\widetilde{\\mathsf{B}}, \\widetilde{\\mathsf{C}}, \\mathsf{Z})</span>  on  <span class="math">\\mathcal{H}_n</span> 7:  <span class="math">\\mu_{\\mathrm{z}}\\gets \\varPsi</span>  .Commit-Polys(ck,Z) 8:  <span class="math">F_{j}(X)\\coloneqq (\\mathsf{q}_{\\mathsf{L}}\\mathsf{A}_{j} + \\mathsf{q}_{\\mathsf{R}}\\mathsf{B}_{j} + \\mathsf{q}_{\\mathsf{O}}\\mathsf{C}_{j} + \\mathsf{q}_{\\mathsf{M}}\\mathsf{A}_{j}\\mathsf{B}_{j} + \\mathsf{q}_{\\mathsf{C}} + \\mathsf{PI}_{\\boldsymbol{x}_j})(X)</span>  for all  <span class="math">j\\in [k]</span> 9:  <span class="math">ids(X) \\coloneqq \\bigcup_{j \\in [k]} F_j(X) \\cup perm-ids_{\\beta, \\gamma}^{\\sigma}(\\widetilde{\\mathsf{A}}, \\widetilde{\\mathsf{B}}, \\widetilde{\\mathsf{C}}, \\mathsf{Z})</span> 10:  <span class="math">\\alpha \\gets \\mathrm{Hash}(\\delta, \\mu_{\\mathrm{z}})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">11:  $\\mathsf{T}(X)\\coloneqq \\big(\\sum_{i\\in [</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ids</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]}\\alpha^i ids_i(X)\\big) / Z_{\\mathcal{H}_n}(X)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">12:  <span class="math">\\mu_{\\mathrm{t}}\\gets \\varPsi</span>  .Commit-Polys(ck,T) 13:  <span class="math">\\xi \\gets \\mathrm{Hash}(\\alpha, \\mu_{\\mathrm{t}})</span> 14:  <span class="math">\\operatorname{ev}(\\operatorname{com}, \\mathbf{f}, x) \\coloneqq (\\Psi. \\operatorname{Open}(\\operatorname{ck}, \\operatorname{com}, x, \\mathbf{f}), \\Psi. \\operatorname{Commit-Evals}(\\operatorname{ck}, \\mathbf{f}(x)))</span> 15:  <span class="math">(\\pi_{\\mathbf{w}},\\nu_{\\mathbf{w}})\\gets \\mathrm{ev}(\\mu_{\\mathbf{w}},\\mathbf{W},\\xi)</span> <span class="math">(\\pi_{\\mathbf{z}},\\nu_{\\mathbf{z}})\\gets \\mathrm{ev}(\\mu_{\\mathbf{z}},\\mathbf{Z},\\xi)</span> <span class="math">(\\overline{\\pi}_{\\mathbf{z}},\\nu_{\\mathbf{z}})\\gets \\mathrm{ev}(\\mu_{\\mathbf{z}},\\mathbf{Z},\\omega \\xi)</span> <span class="math">(\\pi_{\\mathbf{t}},\\nu_{\\mathbf{t}})\\gets \\mathrm{ev}(\\mu_{\\mathbf{t}},\\mathbf{T},\\xi)</span> 16:  <span class="math">(\\pi_{\\mathrm{pp}},\\nu_{\\mathrm{pp}})\\gets \\mathrm{ev}(\\mu_{\\mathrm{pp}},\\mathrm{pp.polys},\\xi)</span> 17: compute  <span class="math">\\pi_{\\mathrm{meta}}</span> , a PoK  <span class="math">\\{\\pmb{w}_{\\mathrm{meta}}: \\mathcal{R}_{n,k}((\\alpha, \\beta, \\gamma, \\delta, \\xi, \\nu_{\\mathbf{w}}, \\nu_{\\mathbf{z}}, \\nu_{\\mathbf{z}}, \\nu_{\\mathbf{t}}, \\nu_{\\mathbf{pp}}, \\{\\pmb{x}_j\\}_{j \\in [k]}), \\pmb{w}_{\\mathrm{meta}}\\} = 1\\}</span>  See Section 4.1 18: return  <span class="math">\\pi \\coloneqq (\\mu_{\\mathbf{w}},\\mu_{\\mathbf{z}},\\mu_{\\mathbf{t}},\\nu_{\\mathbf{w}},\\nu_{\\mathbf{z}},\\nu_{\\mathbf{z}},\\nu_{\\mathbf{t}},\\nu_{\\mathbf{pp}},\\pi_{\\mathbf{w}},\\pi_{\\mathbf{z}},\\overline{\\pi}_{\\mathbf{z}},\\pi_{\\mathbf{t}},\\pi_{\\mathbf{pp}},\\pi_{\\mathbf{meta}})</span></p>

    <p class="text-gray-300">aPlonK.Verify(pp := (n, _, vk,  <span class="math">\\mu_{\\mathbf{pp}}, \\_</span> ),  <span class="math">\\{\\pmb{x}_j\\}_{j \\in [k]}, \\pi := (\\mu_{\\mathbf{w}}, \\mu_{\\mathbf{z}}, \\mu_{\\mathbf{t}}, \\nu_{\\mathbf{w}}, \\nu_{\\mathbf{z}}, \\nu_{\\mathbf{z}}, \\nu_{\\mathbf{t}}, \\nu_{\\mathbf{pp}}, \\pi_{\\mathbf{w}}, \\pi_{\\mathbf{z}}, \\overline{\\pi}_{\\mathbf{z}}, \\pi_{\\mathbf{t}}, \\pi_{\\mathbf{pp}}, \\pi_{\\mathbf{meta}})</span> ):</p>

    <p class="text-gray-300">1:  <span class="math">\\beta \\gets \\mathrm{Hash}(\\mu_{\\mathbf{w}})</span> ;  <span class="math">\\gamma \\gets \\mathrm{Hash}(\\beta)</span> ;  <span class="math">\\delta \\gets \\mathrm{Hash}(\\gamma)</span> ;  <span class="math">\\alpha \\gets \\mathrm{Hash}(\\delta, \\mu_{\\mathbf{z}})</span> ;  <span class="math">\\xi \\gets \\mathrm{Hash}(\\alpha, \\mu_{\\mathbf{t}})</span> 2:  <span class="math">\\mathsf{v}(\\mathsf{com},\\pmb {v},x,\\pi)\\coloneqq \\varPsi</span>  .Check(vk,com,x,v,π) 3:  <span class="math">b_{\\mu} \\coloneqq \\mathsf{v}(\\mu_{\\mathsf{w}}, \\nu_{\\mathsf{w}}, \\xi, \\pi_{\\mathsf{w}}) \\wedge \\mathsf{v}(\\mu_{\\mathsf{z}}, \\nu_{\\mathsf{z}}, \\xi, \\pi_{\\mathsf{z}}) \\wedge \\mathsf{v}(\\mu_{\\mathsf{z}}, \\overline{\\nu_{\\mathsf{z}}}, \\omega \\xi, \\overline{\\pi}_{\\mathsf{z}}) \\wedge \\mathsf{v}(\\mu_{\\mathsf{t}}, \\nu_{\\mathsf{t}}, \\xi, \\pi_{\\mathsf{t}}) \\wedge \\mathsf{v}(\\mu_{\\mathsf{pp}}, \\nu_{\\mathsf{pp}}, \\xi, \\pi_{\\mathsf{pp}})</span> 4: let  <span class="math">b_{\\mathrm{meta}}</span>  be the result of verifying  <span class="math">\\pi_{\\mathrm{meta}}</span>  w.r.t. relation  <span class="math">\\mathcal{R}_{n,k}((\\alpha, \\beta, \\gamma, \\delta, \\xi, \\nu_{\\mathrm{w}}, \\nu_{\\mathrm{z}}, \\nu_{\\mathrm{z}}, \\nu_{\\mathrm{t}}, \\nu_{\\mathrm{pp}}, \\{\\pmb{x}_j\\}_{j \\in [k]}), \\cdot)</span> 5: return  <span class="math">b_{\\mu} \\wedge b_{\\mathrm{meta}}</span></p>

    <p class="text-gray-300">Fig. 4. The  <span class="math">a</span>  PlonK proving system, based on multi-polynomial commitment scheme  <span class="math">\\varPsi</span> .</p>

    <p class="text-gray-300">for every proof  <span class="math">j \\in [k]</span> , with some uniformly sampled coefficient  <span class="math">\\delta \\in \\mathbb{Z}_p</span>  as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\widetilde {\\mathsf {A}} := \\sum_ {j = 1} ^ {k} \\delta^ {j} \\mathsf {A} _ {j} \\qquad \\qquad \\widetilde {\\mathsf {B}} := \\sum_ {j = 1} ^ {k} \\delta^ {j} \\mathsf {B} _ {j} \\qquad \\qquad \\widetilde {\\mathsf {C}} := \\sum_ {i = 1} ^ {k} \\delta^ {j} \\mathsf {C} _ {j}.</span></div>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 5. Meta-verification relation for aggregating  <span class="math">k</span>  proofs of  <span class="math">n</span> -constraints circuits.  <span class="math">\\eta_{2}</span>  and  <span class="math">\\eta_{3}</span>  are non-quadratic residues over  <span class="math">\\mathbb{Z}_p</span> , see Section A.1.</p>

    <p class="text-gray-300">If each of the polynomial triples  <span class="math">(\\mathsf{A}_j,\\mathsf{B}_j,\\mathsf{C}_j)</span>  satisfies the copy-constraints induced by permutation  <span class="math">\\sigma</span> , so will the batched triple  <span class="math">(\\widehat{\\mathsf{A}},\\widehat{\\mathsf{B}},\\widehat{\\mathsf{C}})</span> , which guarantees correctness. The converse is also true with overwhelming probability over the choice of  <span class="math">\\delta</span> , which assures soundness (this intuition can be formalized via a forking argument). Thus, the permutation argument for  <span class="math">k</span>  proofs can be achieved with just one  <span class="math">\\mathsf{Z}</span>  polynomial instead of  <span class="math">k</span>  of them (see steps 5 and 6 of the  <span class="math">a\\mathsf{Pl}on\\mathsf{K}</span> .Prove routine from Figure 4). The number of permutation identities is consequently reduced from  <span class="math">2k</span>  to just 2.</p>

    <p class="text-gray-300">Using a multi-polynomial commitment. Replacing the polynomial commitment scheme used by  <span class="math">\\mathcal{P}lon\\mathcal{K}</span>  by a multi-polynomial commitment scheme can lead to major improvements in proof size and verification time. It allows us to commit to all wire polynomials together in one single multi-polynomial commitment with sublinear size in the number of aggregated proofs  <span class="math">k</span> . With our multi-polynomial commitment scheme from Figure 2, the commitment size would be constant ( <span class="math">1\\mathbb{G}_{\\mathfrak{t}}</span>  element) instead of linear in  <span class="math">k</span> , and the commitment verification complexity would be  <span class="math">\\mathcal{O}(\\log k)</span>  instead of  <span class="math">\\mathcal{O}(k)</span> .</p>

    <p class="text-gray-300">This technique achieves sublinear complexity (in  <span class="math">k</span> ) on commitment verification operations. However, the verifier still needs to check all the identities, which involves a  <span class="math">\\mathcal{O}(k)</span>  number of scalar operations. For that, the verifier needs to receive all the evaluations of the committed polynomials (whose validity can be asserted through the already verified evaluation commitment) and use them to verify the identities. Our next technique addresses this issue.</p>

    <p class="text-gray-300">Meta-verification. The verification of identities only involves scalar operations over  <span class="math">\\mathbb{Z}_{\\mathfrak{p}}</span> , but this is the native field of  <span class="math">\\mathcal{P}lon\\mathcal{K}</span>  circuits. This opens the possibility of, instead of verifying the identities directly, verifying a  <span class="math">\\mathcal{P}lon\\mathcal{K}</span>  proof that the identities are correct. Such proof would need to ensure that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the prover knows evaluations satisfying all the identities,</li>

      <li>such evaluations coincide with the evaluations verified during the multi-polynomial commitment check.</li>

    </ul>

    <p class="text-gray-300">We formally describe the meta-verification equation in Figure 5. It is parametrized by the number of constraints in the circuit  <span class="math">n</span> , and the number of aggregated proofs  <span class="math">k</span> . The public inputs to the meta-verification circuit are  <span class="math">(\\alpha, \\beta, \\gamma, \\delta, \\xi, \\nu_{\\mathsf{w}}, \\nu_{\\mathsf{z}}, \\nu_{\\overline{\\mathsf{z}}}, \\nu_{\\mathsf{t}}, \\nu_{\\mathsf{pp}}, \\{\\pmb{x}_j\\}_{j \\in [k]})</span> , where  <span class="math">\\alpha, \\beta, \\gamma, \\delta, \\xi</span>  are Fiat-Shamir sampled scalars;  <span class="math">\\nu_{\\mathsf{w}}, \\nu_{\\mathsf{z}}, \\nu_{\\mathsf{t}}, \\nu_{\\mathsf{pp}}</span>  are evaluation commitments of (respectively) the wire polynomials,  <span class="math">Z</span>  polynomial,  <span class="math">T</span>  polynomial and setup polynomials at  <span class="math">\\xi</span> ;  <span class="math">\\nu_{\\overline{\\mathsf{z}}}</span>  is (a commitment to) the evaluation of polynomial  <span class="math">Z</span>  at  <span class="math">\\omega \\xi</span> ; and for every  <span class="math">j \\in [k]</span> ,  <span class="math">x_j</span>  is</p>

    <p class="text-gray-300">the vector of public inputs to the <span class="math">j</span>-th statement. On the other hand, the secret inputs to the meta-verification relation are the actual polynomial evaluations at <span class="math">\\xi</span> and <span class="math">\\omega\\xi</span> of the committed polynomials.</p>

    <p class="text-gray-300">By just verifying a single <span class="math">\\mathcal{P}lon\\mathcal{K}</span> proof, the verifier can assert the correctness of all identities without performing a <span class="math">\\mathcal{O}(k)</span> number of scalar operations. On the other hand, we make three observations that deserve attention:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The Commit-Evals algorithm needs to be modeled in a <span class="math">\\mathcal{P}lon\\mathcal{K}</span> circuit. There is flexibility for the choice of such algorithm, but modeling any commitment scheme that is binding will require a significant number of constraints.</li>

      <li>The verifier complexity is still <span class="math">\\mathcal{O}(k)</span> on scalar operations, given the public inputs <span class="math">\\{\\bm{x_{j}}\\}_{j\\in[k]}</span> to the meta-verification circuit.</li>

      <li>This technique imposes a bound on <span class="math">k</span>, the number of aggregated proofs, since the meta-verification circuit size is linear in <span class="math">k</span> and there is an inherent upper-bound on the size of <span class="math">\\mathcal{P}lon\\mathcal{K}</span> circuits.</li>

    </ol>

    <p class="text-gray-300">The first issue can be partially solved by instantiating Commit-Evals with a SNARK-friendly hash function like Poseidon <em>[GKR+21]</em> or Anemoi <em>[BBC+22]</em>, which can be implemented with a moderate number of constraints. Alternatively, in Section 4.2, we show how to build a commitment scheme that can be involved very efficiently in a <span class="math">\\mathcal{P}lon\\mathcal{K}</span> statement. This can be of independent interest.</p>

    <p class="text-gray-300">We refer to Section 4.3 for details on how the second issue can be addressed, depending on the circuit being proved.</p>

    <p class="text-gray-300">Finally, if the first issue is satisfactorily solved, the upper-bound on <span class="math">k</span> could be sufficient for most applications. Even if it is not, one could consider proving the meta-verification relation with several <span class="math">\\mathcal{P}lon\\mathcal{K}</span> proofs, what can lead to a second layer of aggregation and iterate this process if necessary.</p>

    <h3 id="sec-43" class="text-xl font-semibold mt-8">4.2 Commitments in <span class="math">\\mathcal{P}lon\\mathcal{K}</span> statements</h3>

    <p class="text-gray-300">We present a mechanism that allows the data committed in a public commitment to be involved in a <span class="math">\\mathcal{P}lon\\mathcal{K}</span> statement. More concretely, let <span class="math">\\mathsf{Com}</span> be a commitment scheme for vectors over <span class="math">\\mathbb{Z}_{p}</span>. We enhance the <span class="math">\\mathcal{P}lon\\mathcal{K}</span> proving system to support the following relation:</p>

    <p class="text-gray-300"><span class="math">\\text{PoK}\\left\\{\\;(\\bm{w},\\bm{w}^{\\prime})\\in\\mathbb{Z}_{p}^{m}\\times\\mathbb{Z}_{p}^{m^{\\prime}}\\;:\\;(\\bm{x},\\bm{w},\\bm{w}^{\\prime})\\in\\mathbb{Z}_{p}^{\\ell+m+m^{\\prime}}\\text{ satisfies }\\mathcal{C}\\;\\wedge\\;\\mathsf{Com}(\\bm{w})=\\mathsf{com}\\;\\right\\}\\enspace.</span> (4)</p>

    <p class="text-gray-300">The statement being proved is thus parametrized by <span class="math">\\mathcal{C}</span>, <span class="math">\\bm{x}</span> and <span class="math">\\mathsf{com}</span>.</p>

    <p class="text-gray-300">For that, we define <span class="math">\\mathsf{Com}</span> of a vector <span class="math">\\bm{w}\\in\\mathbb{Z}_{p}^{m}</span> as the Kate commitment <em>[x13]</em> to any polynomial <span class="math">f</span> that evaluates to <span class="math">w_{i}</span> on <span class="math">\\omega^{i-1}</span> for all <span class="math">i\\in[m]</span>. Similarly to how public inputs are treated in <span class="math">\\mathcal{P}lon\\mathcal{K}</span>, we will dedicate a section of <span class="math">m</span> constraints to the link between <span class="math">\\mathsf{Com}</span> and the circuit wires. Say, constraints <span class="math">i^{<em>}</span> to <span class="math">i^{</em>}+m-1</span> for some <span class="math">i^{<em>}</span>. For that, we define a selector <span class="math">\\mathsf{q}_{\\mathsf{com}}</span> such that <span class="math">\\mathsf{q}_{\\mathsf{com}}(\\omega^{i})=-1</span> if <span class="math">i\\in[i^{</em>},i^{<em>}+m-1]</span> or <span class="math">0</span> otherwise. Furthermore, we deactivate (set to zero) all other selectors in this range of constraints except <span class="math">\\mathsf{q}_{\\mathsf{L}}</span>, which evaluates to <span class="math">1</span> in it, allowing us to “fetch” the values inside <span class="math">\\mathsf{com}</span> into <span class="math">\\mathsf{a}</span>-wires, which will be then used across the circuit. The <span class="math">\\mathcal{P}lon\\mathcal{K}</span> identity will consequently get added the new term <span class="math">\\mathsf{q}_{\\mathsf{com}}(X)\\cdot\\mathsf{com}(\\omega^{-i^{</em>}}X)</span>. Observe that by setting <span class="math">i^{<em>}=0</span>, one can avoid having a new evaluation point <span class="math">\\omega^{-i^{</em>}}\\xi</span>. This can be achieved by shifting away the constraints dedicated to public inputs, which in the original <span class="math">\\mathcal{P}lon\\mathcal{K}</span> were defined to be the first <span class="math">\\ell</span>. Note that if we do not want to open the whole vector <span class="math">\\bm{w}</span>, we can activate <span class="math">\\mathsf{q}_{\\mathsf{com}}</span> on a smaller range; then the verifier can dynamically adapt by querying <span class="math">\\mathsf{com}(\\omega^{-j^{*}}X)</span> for a chosen <span class="math">j</span>. This can prove useful if we want to use this technique in the context of vector commitments.</p>

    <h4 id="sec-44" class="text-lg font-semibold mt-6">Hybrid statements.</h4>

    <p class="text-gray-300">Proving statements about committed data is a powerful tool that can be used for constructing hybrid proving systems <em>[x7, x1, x6]</em>. Such commitments can be the meeting point between a SNARK proof and other systems, e.g., a sigma protocol asserting the validity of the committed</p>

    <p class="text-gray-300">data with respect to some algebraic statement. The binding property of the commitment ensures that both proofs “talk about the same data”.</p>

    <p class="text-gray-300">In particular, we can choose the Commit-Evals algorithm from our multi-polynomial commitment scheme (Figure 2) to be the above Com. This provides a satisfying solution to issue (i) from the previous section. In that case, the meta-verification circuit (Figure 5) could be extended to also handle the PoK from relation (3), see Figure 2.</p>

    <h4 id="sec-45" class="text-lg font-semibold mt-6">Randomized circuits.</h4>

    <p class="text-gray-300">Another remarkable application of involving commitments in the statement is being able to express <em>randomized circuits</em>. Randomness can be used to simplify the verification of certain computations: given a Boolean circuit <span class="math">C</span>, it is often possible to find a (smaller) circuit <span class="math">\\widehat{C}</span>, taking an extra input <span class="math">r</span>, which is equivalent to <span class="math">C</span> in the sense that, for every <span class="math">x</span>:</p>

    <p class="text-gray-300"><span class="math">\\Pr_{r\\leftarrow\\Xi_{p}}\\Big{[}C(x)=1\\Rightarrow\\widehat{C}(x;r)=1\\Big{]}=1\\qquad\\text{and}\\qquad\\Pr_{r\\leftarrow\\Xi_{p}}\\Big{[}\\widehat{C}(x;r)=1\\Rightarrow C(x)=1\\Big{]}\\approx 1\\;\\;.</span></p>

    <p class="text-gray-300">Verifying the more efficient <span class="math">\\widehat{C}(x;r)=1</span> for a uniformly sampled <span class="math">r</span> is an overwhelming evidence that <span class="math">C(x)=1</span>. However, it is important to choose <span class="math">r</span> uniformly and independently of <span class="math">x</span>. When proving a randomized circuit in <span class="math">\\mathcal{P}lon\\mathcal{K}</span>, <span class="math">r</span> will be treated as an additional public input. We must guarantee that <span class="math">r</span> cannot be biased by the prover and that the prover cannot change its secret input based on <span class="math">r</span>. On the other hand, the circuit trace that the prover commits to depends on <span class="math">r</span>, this is natural, since <span class="math">r</span> is involved in the constraint system. The solution is to have the prover commit to the witness seed using Com, then derive <span class="math">r</span> from such commitment through the Fiat-Shamir heuristic and finally, completing the rest of the trace (which now depends on <span class="math">r</span>).</p>

    <h3 id="sec-46" class="text-xl font-semibold mt-8">4.3 Hiding public inputs</h3>

    <p class="text-gray-300">Our techniques allowed us to significantly reduce the verifier complexity, for the most part now being logarithmic in the number of aggregated proofs <span class="math">k</span>. However, as in SnarkPack <em>[x10]</em>, our verifier complexity is still linear in <span class="math">k</span>, due to the <span class="math">\\ell</span> public inputs per proof to process. This seems an inherent limitation.</p>

    <p class="text-gray-300">However, depending on the application, such limitation could be relaxed. For example, the verifier may have access to a commitment to the relevant public inputs and may be interested in simply checking that verification passes with respect to some opening of the commitment. In other scenarios, the circuit public inputs themselves could be irrelevant to the verifier, who only wants to assert some relation between them. For example, in some incremental computations like a transactional rollup of a blockchain: where each of the <span class="math">k</span> proofs takes 2 public inputs, an initial rollup state and a final (modified) state, and the verifier is simply interested in asserting that the final state of a given proof matches the initial state of the next proof, but not on the actual value of such intermediate states. This <em>rollup-like</em> configuration is used for our benchmarks (Section 5).</p>

    <p class="text-gray-300">In those cases, our techniques can be very naturally extended to achieve actual sublinear verification complexity by performing the relevant checks on public inputs in the meta-verification circuit. This can be seen as new mechanism to implement a weak form of IVC.</p>

    <h2 id="sec-47" class="text-2xl font-bold">5 Implementation and evaluation</h2>

    <p class="text-gray-300">We have implement the algorithms described in this work and evaluated their performance in a series of benchmarks presented in Section 5.2. Our source code is written in OCaml with bindings to C implementations of the heaviest cryptographic functions. We use the BLS12-381 elliptic curve <em>[x2]</em> for pairings through bindings to the <em>blst</em> library <em>[x23]</em>. Our implementation is publicly available as open-source <em>[x25]</em>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Table 1. Proof size comparison.  <span class="math">k</span>  is the number of aggregated proofs (formulas valid for  <span class="math">k \\geq  3</span>  ).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Zp</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Gt</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PlonK</td>

            <td class="px-3 py-2 border-b border-gray-700">3k+12</td>

            <td class="px-3 py-2 border-b border-gray-700">3k+4</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">aPlonK</td>

            <td class="px-3 py-2 border-b border-gray-700">19</td>

            <td class="px-3 py-2 border-b border-gray-700">2[log23k]+10</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2[log23k]+3</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Our comparisons are performed between  <span class="math">\\mathcal{P}lon\\mathcal{K}</span>  and  <span class="math">a\\mathcal{P}lon\\mathcal{K}</span>  for aggregating a batch of  <span class="math">k</span>  different proofs of a constraint system of  <span class="math">n</span>  constraints. In the case of  <span class="math">\\mathcal{P}lon\\mathcal{K}</span> , we use the KZG polynomial commitment and implement a simple proof aggregation, but which uses our shared permutation argument and the batch verification optimizations applicable to KZG [GWC19]. In the case of  <span class="math">a\\mathcal{P}lon\\mathcal{K}</span> , we implement the scheme described in Figure 4 instantiated with a multi-polynomial commitment scheme constructed from the KZG polynomial commitment scheme (Figure 7) and the IPA argument from Figure 3. Our experimental results from Section 5.2 show that the performance and proof size improvements of  <span class="math">a\\mathcal{P}lon\\mathcal{K}</span>  are significant even against the optimized version of  <span class="math">\\mathcal{P}lon\\mathcal{K}</span>  that we compare it with, which in turn is a lot more performant than the naive parallel execution of standard  <span class="math">\\mathcal{P}lon\\mathcal{K}</span> .</p>

    <p class="text-gray-300">Remark 5. We leverage the homomorphic properties of the IPA statement, see relation (2), to perform only one IPA instead of four: for the evaluation of the commitments to (i) public parameter polynomials, (ii) wire polynomials, (iii) the permutation polynomial and (iv) the  <span class="math">\\mathsf{T}</span>  polynomial. This is possible if all inner-product arguments use the same  <span class="math">r</span> , since in that case:</p>

    <div class="my-4 text-center"><span class="math-block">\\langle \\boldsymbol {\\mu}, \\boldsymbol {G} \\rangle = C \\quad \\wedge \\quad \\langle \\boldsymbol {r}, \\boldsymbol {\\mu} \\rangle = P \\quad \\wedge \\quad \\langle \\boldsymbol {\\mu} ^ {\\prime}, \\boldsymbol {G} \\rangle = C ^ {\\prime} \\quad \\wedge \\quad \\langle \\boldsymbol {r}, \\boldsymbol {\\mu} ^ {\\prime} \\rangle = P ^ {\\prime}</span></div>

    <p class="text-gray-300">if and only if, with overwhelming probability over the choice of  <span class="math">\\zeta</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\langle \\boldsymbol {\\mu} + \\zeta \\boldsymbol {\\mu} ^ {\\prime}, \\boldsymbol {G} \\rangle = C + \\zeta C ^ {\\prime} \\quad \\wedge \\quad \\langle \\boldsymbol {r}, \\boldsymbol {\\mu} + \\zeta \\boldsymbol {\\mu} ^ {\\prime} \\rangle = P + \\zeta P ^ {\\prime}.</span></div>

    <h2 id="sec-48" class="text-2xl font-bold">5.1 Theoretical results</h2>

    <p class="text-gray-300">We present a detailed comparison between  <span class="math">\\mathcal{P}lon\\mathcal{K}</span>  and  <span class="math">a\\mathcal{P}lon\\mathcal{K}</span>  on their proof size, verifier complexity and prover complexity in terms of scalar field and group elements/operations. In the rest of this section  <span class="math">k</span>  represents the number of aggregated statements,  <span class="math">n</span>  is the common circuit size measured in number of constraints and  <span class="math">\\ell</span>  is the number of public inputs for each atomic statement.</p>

    <p class="text-gray-300">Proof size (Table 1). Observe that the aggregated proof sizes of both  <span class="math">\\mathcal{P}lon\\mathcal{K}</span>  and  <span class="math">a\\mathcal{P}lon\\mathcal{K}</span>  are independent on the circuit size  <span class="math">n</span>  and only depend on the number of aggregated statements  <span class="math">k</span> . With  <span class="math">\\mathcal{P}lon\\mathcal{K}</span> , the proof size is linear in  <span class="math">k</span> , whereas with  <span class="math">a\\mathcal{P}lon\\mathcal{K}</span> , it is logarithmic.</p>

    <p class="text-gray-300">Verifier complexity (Table 2). The verifier complexity of  <span class="math">\\mathcal{P}lon\\mathcal{K}</span>  is  <span class="math">\\mathcal{O}(k\\log n + k\\ell)</span> , whereas the verifier complexity of  <span class="math">a\\mathcal{P}lon\\mathcal{K}</span>  is  <span class="math">\\mathcal{O}(\\log k + \\ell&#x27;)</span> , where  <span class="math">\\ell&#x27; = \\mathcal{O}(k\\ell)</span>  is the number of public inputs to the meta-verification circuit. Note that, when applicable (e.g. for a rollup), our technique for hiding public inputs can lead to a constant  <span class="math">\\ell&#x27;</span> . In that case, the verifier complexity of  <span class="math">a\\mathcal{P}lon\\mathcal{K}</span>  would be  <span class="math">\\mathcal{O}(\\log k)</span> . This is an important difference with respect to SnarkPack [GMN20], where the verification of aggregated proofs is linear in the number of public inputs.</p>

    <p class="text-gray-300">Prover complexity (Table 3). The prover complexity of  <span class="math">\\mathcal{P}lon\\mathcal{K}</span>  is  <span class="math">\\mathcal{O}(kn\\log n)</span> . The  <span class="math">a\\mathcal{P}lon\\mathcal{K}</span>  prover requires more operations but stays in the same order of complexity with respect to operations in  <span class="math">\\mathbb{Z}_p</span>  and  <span class="math">\\mathbb{G}_1</span> . It additional requires  <span class="math">\\mathcal{O}(\\log k)</span>  hashes, pairings, and operations in  <span class="math">\\mathbb{G}_2</span> ,  <span class="math">\\mathbb{G}_t</span> . However, as evidenced by our experimental results from Section 5.2, the overhead of these additional computations is not very significant compared to the complexity of the rest of computations.</p>

    <p class="text-gray-300">Table 2. Verifier complexity comparison.  <span class="math">k</span>  is the number of aggregated proofs,  <span class="math">n</span>  is the circuit size,  <span class="math">\\ell</span>  is the number of public inputs per proof,  <span class="math">n&#x27; = \\mathcal{O}(k + \\ell)</span>  is the meta-verification circuit size (see Table 4),  <span class="math">\\ell&#x27; (\\leq n&#x27;)</span>  is the number of public inputs to it (in our implementation, it is set to 15), and  <span class="math">\\kappa = \\lceil \\log_2(3k) \\rceil</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Operation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PlonK</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">aPlonK</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">inv</td>

            <td class="px-3 py-2 border-b border-gray-700">kℓ + 2k</td>

            <td class="px-3 py-2 border-b border-gray-700">κ + ℓ' + 2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Zp mul</td>

            <td class="px-3 py-2 border-b border-gray-700">k log2(n) + 2kℓ + 11k + 20</td>

            <td class="px-3 py-2 border-b border-gray-700">5κ + log2(n') + 2ℓ' + 35</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">add</td>

            <td class="px-3 py-2 border-b border-gray-700">2kℓ + 11k + 14</td>

            <td class="px-3 py-2 border-b border-gray-700">κ + 2ℓ' + 28</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">G1 mul</td>

            <td class="px-3 py-2 border-b border-gray-700">3k + 15</td>

            <td class="px-3 py-2 border-b border-gray-700">2κ + 13</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3k + 16</td>

            <td class="px-3 py-2 border-b border-gray-700">2κ + 17</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">G1 mul</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2κ</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2κ + 3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Pairing</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Hash</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">κ + 10</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3. Prover complexity comparison.  <span class="math">k</span>  is the number of aggregated proofs,  <span class="math">n</span>  is the circuit size,  <span class="math">n&#x27; = \\mathcal{O}(k + \\ell)</span>  is the meta-verification circuit size (see Table 4), and  <span class="math">K</span>  is the first power of two over  <span class="math">3k</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Operation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PlonK</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">aPlonK</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">inv</td>

            <td class="px-3 py-2 border-b border-gray-700">n + 3k + 3</td>

            <td class="px-3 py-2 border-b border-gray-700">PlonK + log2(K) + 2n' + 6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Zp mul</td>

            <td class="px-3 py-2 border-b border-gray-700">15/2kn log2(n) + 45kn + 7n log2(n) + 105n + 3k + 9</td>

            <td class="px-3 py-2 border-b border-gray-700">PlonK + 3K + 3 log2(K) + 29/2n' log2(n') + 155n' + 16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">add</td>

            <td class="px-3 py-2 border-b border-gray-700">15kn log2(n) + 42kn + 14n log2(n) + 95n + 3k + 11</td>

            <td class="px-3 py-2 border-b border-gray-700">PlonK + 2K + log2(K) + 29n' log2(n') + 140n' + 13</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">G1 mul</td>

            <td class="px-3 py-2 border-b border-gray-700">3kn + 6n + 3k + 12</td>

            <td class="px-3 py-2 border-b border-gray-700">PlonK + 9n' + 8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">add</td>

            <td class="px-3 py-2 border-b border-gray-700">3kn + 6n + 3k + 12</td>

            <td class="px-3 py-2 border-b border-gray-700">PlonK + 9n' + 9k + 27</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">G2 mul</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">3K - 2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">add</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2K - 1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">G1 add</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2K + k - 2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Pairing</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2K + 3k + 2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Hash</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">log2(K) + 10</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 4. Meta-verification circuit size (measured in number of constraints). For circuits that aggregate  <span class="math">k</span>  proofs and for two different alternatives implementations of Commit-Evals and two different schedules of public inputs.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Without public inputs</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Rollup-like public inputs</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Base cost (ignoring Commit-Evals)</td>

            <td class="px-3 py-2 border-b border-gray-700">25k + 344</td>

            <td class="px-3 py-2 border-b border-gray-700">28k + 339</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Extra cost if Commit-Evals = Poseidon</td>

            <td class="px-3 py-2 border-b border-gray-700">200k + 1061</td>

            <td class="px-3 py-2 border-b border-gray-700">210k + 1061</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Extra cost if Commit-Evals = (KZG.Commit ∘ IFFT)</td>

            <td class="px-3 py-2 border-b border-gray-700">3k + 12</td>

            <td class="px-3 py-2 border-b border-gray-700">3k + 12</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Meta-verification circuit size (Table 4). We present the size measured in number of constraints of the meta-verification circuit which models  <span class="math">\\mathcal{R}_{n,k}</span>  (described in Figure 5). Such numbers are helpful to interpret the verifier and prover complexities given in Tables 2 and 3 respectively. Table 4 describes the base cost of implementing relation  <span class="math">\\mathcal{R}_{n,k}</span>  when ignoring the logic related to Commit-Evals. We consider two different schedules of public inputs: (i) a circuit without public inputs, which serves as a lower-bound on the size of the meta-verification circuit; (ii) a rollup-like public input schedule, where each circuit being proved has two public inputs and the meta-verification circuit checks that they are linked in a chain (i.e., that the second public input of one circuit coincides with the first public input of the next). We also present the additional cost of modeling Commit-Evals through the Poseidon (implemented following the results of [ASTW22]) and the cost of modeling it with a Kate commitment as described in Section 4.2. Note how, even though Poseidon</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Fig. 6. Times and proof sizes for different numbers of proofs. The circuit has  <span class="math">2^{16}</span>  constraints with 2 public inputs per proof. In  <span class="math">a\\mathcal{P}lon\\mathcal{K}</span> , public inputs are hidden to the verifier (except the first of the first proof and the last of the last proof); the first public input of each proof is checked to be equal to the second public input of the previous proof.</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a></p>

    <p class="text-gray-300">is a SNARK-friendly hash function, implementing Commit-Evals with it would be very costly and the main factor on the meta-verification circuit size. This would introduce a relatively small limit on the number of proofs that can be aggregated with this technique. On the other hand, when modeling Commit-Evals as described in Section 4.2, the overhead is minimal compared to the rest of the verification circuit, improving by an order of magnitude the number of proofs that can be aggregated.</p>

    <p class="text-gray-300">We present our experimental results in Figure 6, which includes a comparison of the setup, proving and verification times, as well as proof sizes of  <span class="math">\\mathcal{P}lon\\mathcal{K}</span>  and  <span class="math">a\\mathcal{P}lon\\mathcal{K}</span> , for different aggregation sizes. All experiments were performed on a 2.9GHz Intel Xeon Platinum 8375C vCPU with 1 TB of RAM and 128 processors.</p>

    <p class="text-gray-300">We use a circuit of  <span class="math">n = 2^{16}</span>  constraints. Our circuit performs a computation which involves several additions and multiplications across various inputs, two of which are considered public. That way we guarantee that all selectors  <span class="math">\\mathfrak{q}_{\\mathrm{L}}, \\mathfrak{q}_{\\mathrm{R}}, \\mathfrak{q}_{\\mathrm{O}}, \\mathfrak{q}_{\\mathrm{M}}, \\mathfrak{q}_{\\mathrm{C}}</span>  are non-trivial. Nevertheless, note that the complexity of all algorithms is independent of the actual architecture of the circuit and their performance only depends on the number of constraints  <span class="math">n</span> . We choose a rollup-like schedule of public inputs, joined in a chain as described in the previous section.</p>

    <p class="text-gray-300">The logic associated to Commit-Evals in the meta-verification circuit should be implemented through our method for involving commitments outside of  <span class="math">\\mathcal{P}lon\\mathcal{K}</span>  (Section 4.2). While we counted these extra constraints in Table 4, such method has not been implemented for simplicity. We expect the overhead of having this logic into account to be negligible given that it only increases the meta-verification circuit by  <span class="math">3k + 12</span>  constraints.</p>

    <p class="text-gray-300">Setup. The setup of  <span class="math">\\mathcal{P}lon\\mathcal{K}</span>  is constant since the circuit of interest always has  <span class="math">n = 2^{16}</span>  constraints. However, in  <span class="math">a\\mathcal{P}lon\\mathcal{K}</span> , it is linear in  <span class="math">k</span> . This is because the size of the meta-verification circuit grows linearly with the number of aggregated proofs. Fortunately, the impact of  <span class="math">a\\mathcal{P}lon\\mathcal{K}</span> 's setup is in the order of seconds</p>

    <p class="text-gray-300">for aggregating thousands or proofs. Furthermore, note that the setup performance is not critical, as it is precomputed only once.</p>

    <p class="text-gray-300">Proving. All experiments have used parallelization over all the 128 available cores. When <span class="math">k\\leq 128</span> a core is assigned for each proof. After that threshold we can expect a linear growth since each core will need to produce more than one proof. One CPU was also in charge of orchestrating the distribution and computing the meta-verification proof, a step which was performed sequentially. The difference between <span class="math">\\mathcal{P}lon\\mathcal{K}</span> and <span class="math">a\\mathcal{P}lon\\mathcal{K}</span> proving times comes from the proving time of the meta-verification circuit. We can see a overhead of approximately 20% (45 seconds) for <span class="math">a\\mathcal{P}lon\\mathcal{K}</span> proving time for <span class="math">2^{12}</span> aggregated proofs. This represents 1% of the total machine time. Furthermore, such overhead would be even less important if circuits were larger, as the complexity of our aggregation routines is independent of <span class="math">n</span>.</p>

    <p class="text-gray-300">Verification and proof sizes. Our experimental results on verification corroborate the fact that <span class="math">\\mathcal{P}lon\\mathcal{K}</span> is linear while <span class="math">a\\mathcal{P}lon\\mathcal{K}</span> is logarithmic in the number of aggregated proofs. <span class="math">a\\mathcal{P}lon\\mathcal{K}</span> becomes more efficient after a threshold of about <span class="math">k=300</span> proofs. On the other hand, the proof size of <span class="math">a\\mathcal{P}lon\\mathcal{K}</span> becomes smaller starting from <span class="math">k=64</span> proofs.</p>

    <h2 id="sec-50" class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">We are very thankful to Antonio Locascio, Danny Willems, Julien Coolen, Marco Stronati, Marina Polubelova and Victor Dumitrescu, developers and co-authors of our implementation <em>[x18]</em>, for very fruitful discussions and all their help and feedback.</p>

    <p class="text-gray-300">We would also like to thank Mary Maller, for her feedback and clarifications about SnarkPack in the early stages of this project.</p>

    <h2 id="sec-51" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>AGM [18] Shashank Agrawal, Chaya Ganesh, and Payman Mohassel. Non-interactive zero-knowledge proofs for composite statements. In Hovav Shacham and Alexandra Boldyreva, editors, CRYPTO 2018, Part III, volume 10993 of LNCS, pages 643–673. Springer, Heidelberg, August 2018.</li>

      <li>ASTW [22] Miguel Ambrona, Anne-Laure Schmitt, Raphael R. Toledo, and Danny Willems. New optimization techniques for PlonK’s arithmetization. Cryptology ePrint Archive, Report 2022/462, 2022. https://eprint.iacr.org/2022/462.</li>

      <li>BBB^{+} [18] Benedikt Bünz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Greg Maxwell. Bulletproofs: Short proofs for confidential transactions and more. In 2018 IEEE Symposium on Security and Privacy, pages 315–334. IEEE Computer Society Press, May 2018.</li>

      <li>BBC^{+} [22] Clémence Bouvier, Pierre Briaud, Pyrros Chaidos, Léo Perrin, and Vesselin Velichkov. Anemoi: Exploiting the link between arithmetization-orientation and ccz-equivalence. Cryptology ePrint Archive, Paper 2022/840, 2022. https://eprint.iacr.org/2022/840.</li>

      <li>BBHR [19] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable zero knowledge with no trusted setup. In Alexandra Boldyreva and Daniele Micciancio, editors, Advances in Cryptology - CRYPTO 2019 - 39th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 18-22, 2019, Proceedings, Part III, volume 11694 of Lecture Notes in Computer Science, pages 701–732. Springer, 2019.</li>

      <li>BCC^{+} [16] Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe Petit. Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In Marc Fischlin and Jean-Sébastien Coron, editors, EUROCRYPT 2016, Part II, volume 9666 of LNCS, pages 327–357. Springer, Heidelberg, May 2016.</li>

      <li>BCG^{+} [13] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza. SNARKs for C: Verifying program executions succinctly and in zero knowledge. In Ran Canetti and Juan A. Garay, editors, CRYPTO 2013, Part II, volume 8043 of LNCS, pages 90–108. Springer, Heidelberg, August 2013.</li>

      <li>BCG^{+} [14] Eli Ben-Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers, Eran Tromer, and Madars Virza. Zerocash: Decentralized anonymous payments from bitcoin. In 2014 IEEE Symposium on Security and Privacy, pages 459–474. IEEE Computer Society Press, May 2014.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">24</p>

    <p class="text-gray-300">BCG⁺¹⁷. Jonathan Bootle, Andrea Cerulli, Essam Ghadafi, Jens Groth, Mohammad Hajiabadi, and Sune K. Jakobsen. Linear-time zero-knowledge proofs for arithmetic circuit satisfiability. In Tsuyoshi Takagi and Thomas Peyrin, editors, ASIACRYPT 2017, Part III, volume 10626 of LNCS, pages 336–365. Springer, Heidelberg, December 2017.</p>

    <p class="text-gray-300">BCL⁺²¹. Benedikt Bünz, Alessandro Chiesa, William Lin, Pratyush Mishra, and Nicholas Spooner. Proof-carrying data without succinct arguments. In Tal Malkin and Chris Peikert, editors, CRYPTO 2021, Part I, volume 12825 of LNCS, pages 681–710, Virtual Event, August 2021. Springer, Heidelberg.</p>

    <p class="text-gray-300">BCMS²⁰. Benedikt Bünz, Alessandro Chiesa, Pratyush Mishra, and Nicholas Spooner. Proof-carrying data from accumulation schemes. Cryptology ePrint Archive, Report 2020/499, 2020. https://eprint.iacr.org/2020/499.</p>

    <p class="text-gray-300">BDFG²⁰. Dan Boneh, Justin Drake, Ben Fisch, and Ariel Gabizon. Efficient polynomial commitment schemes for multiple points and polynomials. Cryptology ePrint Archive, Report 2020/081, 2020. https://eprint.iacr.org/2020/081.</p>

    <p class="text-gray-300">BFM⁸⁸. Manuel Blum, Paul Feldman, and Silvio Micali. Non-interactive zero-knowledge and its applications (extended abstract). In 20th ACM STOC, pages 103–112. ACM Press, May 1988.</p>

    <p class="text-gray-300">BG¹². Stephanie Bayer and Jens Groth. Efficient zero-knowledge argument for correctness of a shuffle. In David Pointcheval and Thomas Johansson, editors, EUROCRYPT 2012, volume 7237 of LNCS, pages 263–280. Springer, Heidelberg, April 2012.</p>

    <p class="text-gray-300">BGH¹⁹a. Sean Bowe, Jack Grigg, and Daira Hopwood. Halo: Recursive proof composition without a trusted setup. IACR Cryptol. ePrint Arch., page 1021, 2019.</p>

    <p class="text-gray-300">BGH¹⁹b. Sean Bowe, Jack Grigg, and Daira Hopwood. Halo: Recursive proof composition without a trusted setup. Cryptology ePrint Archive, Report 2019/1021, 2019. https://eprint.iacr.org/2019/1021.</p>

    <p class="text-gray-300">BMM⁺²¹. Benedikt Bünz, Mary Maller, Pratyush Mishra, Nirvan Tyagi, and Psi Vesely. Proofs for inner pairing products and applications. In Mehdi Tibouchi and Huaxiong Wang, editors, ASIACRYPT 2021, Part III, volume 13092 of LNCS, pages 65–97. Springer, Heidelberg, December 2021.</p>

    <p class="text-gray-300">BMRS²⁰. Joseph Bonneau, Izaak Meckler, Vanishree Rao, and Evan Shapiro. Mina: Decentralized cryptocurrency at scale, 2020. Whitepaper. https://docs.minaprotocol.com/static/pdf/technicalWhitepaper.pdf.</p>

    <p class="text-gray-300">BMV¹⁹. Benedikt Bünz, Mary Maller, and Noah Vesely. Efficient proofs for pairing-based languages. Cryptology ePrint Archive, Report 2019/1177, 2019. https://eprint.iacr.org/2019/1177.</p>

    <p class="text-gray-300">BN⁰⁶. Mihir Bellare and Gregory Neven. Multi-signatures in the plain public-key model and a general forking lemma. In Ari Juels, Rebecca N. Wright, and Sabrina De Capitani di Vimercati, editors, ACM CCS 2006, pages 390–399. ACM Press, October / November 2006.</p>

    <p class="text-gray-300">Bow¹⁷. Sean Bowe. Bls12-381: New zk-snark elliptic curve construction, 2017. ECC Posts. https://electriccoin.co/blog/new-snark-curve/.</p>

    <p class="text-gray-300">CCW¹⁹. Alessandro Chiesa, Lynn Chua, and Matthew Weidner. On cycles of pairing-friendly elliptic curves. SIAM J. Appl. Algebra Geom., 3(2):175–192, 2019.</p>

    <p class="text-gray-300">CDS⁹⁴. Ronald Cramer, Ivan Damgård, and Berry Schoenmakers. Proofs of partial knowledge and simplified design of witness hiding protocols. In Yvo Desmedt, editor, CRYPTO'94, volume 839 of LNCS, pages 174–187. Springer, Heidelberg, August 1994.</p>

    <p class="text-gray-300">CFtQ¹⁹. Matteo Campanelli, Dario Fiore, and Anaïs Querol. LegoSNARK: Modular design and composition of succinct zero-knowledge proofs. In Lorenzo Cavallaro, Johannes Kinder, XiaoFeng Wang, and Jonathan Katz, editors, ACM CCS 2019, pages 2075–2092. ACM Press, November 2019.</p>

    <p class="text-gray-300">CGM¹⁶. Melissa Chase, Chaya Ganesh, and Payman Mohassel. Efficient zero-knowledge proof of algebraic and non-algebraic statements with applications to privacy preserving credentials. In Matthew Robshaw and Jonathan Katz, editors, CRYPTO 2016, Part III, volume 9816 of LNCS, pages 499–530. Springer, Heidelberg, August 2016.</p>

    <p class="text-gray-300">COS¹⁹. Alessandro Chiesa, Dev Ojha, and Nicholas Spooner. Fractal: Post-quantum and transparent recursive proofs from holography. Cryptology ePrint Archive, Report 2019/1076, 2019. https://eprint.iacr.org/2019/1076.</p>

    <p class="text-gray-300">Cra⁹⁷. Ronald Cramer. Modular design of secure yet practical cryptographic protocols. 1997.</p>

    <p class="text-gray-300">DFKP¹³. George Danezis, Cedric Fournet, Markulf Kohlweiss, and Bryan Parno. Pinocchio coin: Building zerocoin from a succinct pairing-based proof system. In Proceedings of the First ACM Workshop on Language Support for Privacy-Enhancing Technologies, PETShop '13, page 27–30, New York, NY, USA, 2013. Association for Computing Machinery.</p>

    <p class="text-gray-300">DMP⁹⁰. Alfredo De Santis, Silvio Micali, and Giuseppe Persiano. Non-interactive zero-knowledge with preprocessing. In Shafi Goldwasser, editor, CRYPTO'88, volume 403 of LNCS, pages 269–282. Springer, Heidelberg, August 1990.</p>

    <p class="text-gray-300">25</p>

    <p class="text-gray-300">DRZ20. Vanesa Daza, Carla Råfols, and Alexandros Zacharakis. Updateable inner product argument with logarithmic verifier and applications. In Aggelos Kiayias, Markulf Kohlweiss, Petros Wallden, and Vassilis Zikas, editors, PKC 2020, Part I, volume 12110 of LNCS, pages 527–557. Springer, Heidelberg, May 2020.</p>

    <p class="text-gray-300">FLS90. Uriel Feige, Dror Lapidot, and Adi Shamir. Multiple non-interactive zero knowledge proofs based on a single random string (extended abstract). In 31st FOCS, pages 308–317. IEEE Computer Society Press, October 1990.</p>

    <p class="text-gray-300">GGPR13. Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct NIZKs without PCPs. In Thomas Johansson and Phong Q. Nguyen, editors, EUROCRYPT 2013, volume 7881 of LNCS, pages 626–645. Springer, Heidelberg, May 2013.</p>

    <p class="text-gray-300"><span class="math">\\mathrm{GKR}^{+}21</span>. Lorenzo Grassi, Dmitry Khovratovich, Christian Rechberger, Arnab Roy, and Markus Schofnegger. Poseidon: A new hash function for zero-knowledge proof systems. In Michael Bailey and Rachel Greenstadt, editors, USENIX Security 2021, pages 519–535. USENIX Association, August 2021.</p>

    <p class="text-gray-300">GMN20. Nicolas Gailly, Mary Maller, and Anca Nitulescu. Snarkpack: Practical snark aggregation. In Ittay Eyal and Juan Garay, editors, FC 2022: 26th International Conference on Financial Cryptography and Data Security, volume 13411 of LNCS, St George’s, Grenada, 2020. Springer, Heidelberg, Germany. https://ia.cr/2021/529.</p>

    <p class="text-gray-300">GMO16. Irene Giacomelli, Jesper Madsen, and Claudio Orlandi. ZKBoo: Faster zero-knowledge for Boolean circuits. In Thorsten Holz and Stefan Savage, editors, USENIX Security 2016, pages 1069–1083. USENIX Association, August 2016.</p>

    <p class="text-gray-300">GMR85. Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of interactive proof-systems (extended abstract). In 17th ACM STOC, pages 291–304. ACM Press, May 1985.</p>

    <p class="text-gray-300">Goo14. L.M. Goodman. Tezos: a self-amending crypto-ledger, 2014. https://tezos.com/whitepaper.pdf.</p>

    <p class="text-gray-300">Gro16. Jens Groth. On the size of pairing-based non-interactive arguments. In Marc Fischlin and Jean-Sébastien Coron, editors, EUROCRYPT 2016, Part II, volume 9666 of LNCS, pages 305–326. Springer, Heidelberg, May 2016.</p>

    <p class="text-gray-300">GS08. Jens Groth and Amit Sahai. Efficient non-interactive proof systems for bilinear groups. In Nigel P. Smart, editor, EUROCRYPT 2008, volume 4965 of LNCS, pages 415–432. Springer, Heidelberg, April 2008.</p>

    <p class="text-gray-300">GW19. Ariel Gabizon and Zachary J. Williamson. The turbo-plonk program syntax for specifying snark programs, 2019. Preprint. https://docs.zkproof.org/pages/standards/accepted-workshop3/proposal-turbo_plonk.pdf.</p>

    <p class="text-gray-300">GWC19. Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru. PLONK: Permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge. Cryptology ePrint Archive, Report 2019/953, 2019. https://eprint.iacr.org/2019/953.</p>

    <p class="text-gray-300">GYB21. Christopher Goes, Awa Sun Yin, and Adrian Brink. Anoma: Undefining money: A protocol for private, asset-agnostic digital cash and n-party bartering, 2021. https://anoma.network/papers/whitepaper.pdf.</p>

    <p class="text-gray-300">HBHW. Daira Hopwood, Sean Bowe, Taylor Hornby, and Nathan Wilcox. Zcash protocol specification. https://zips.z.cash/protocol/protocol.pdf.</p>

    <p class="text-gray-300">JKO13. Marek Jawurek, Florian Kerschbaum, and Claudio Orlandi. Zero-knowledge using garbled circuits: how to prove non-algebraic statements efficiently. In Ahmad-Reza Sadeghi, Virgil D. Gligor, and Moti Yung, editors, ACM CCS 2013, pages 955–966. ACM Press, November 2013.</p>

    <p class="text-gray-300">KST21. Abhiram Kothapalli, Srinath Setty, and Ioanna Tzialla. Nova: Recursive zero-knowledge arguments from folding schemes. Cryptology ePrint Archive, Report 2021/370, 2021. https://eprint.iacr.org/2021/370.</p>

    <p class="text-gray-300">KZG10. Aniket Kate, Gregory M. Zaverucha, and Ian Goldberg. Constant-size commitments to polynomials and their applications. In Masayuki Abe, editor, ASIACRYPT 2010, volume 6477 of LNCS, pages 177–194. Springer, Heidelberg, December 2010.</p>

    <p class="text-gray-300">LMR19. Russell W. F. Lai, Giulio Malavolta, and Viktoria Ronge. Succinct arguments for bilinear group arithmetic: Practical structure-preserving cryptography. In Lorenzo Cavallaro, Johannes Kinder, XiaoFeng Wang, and Jonathan Katz, editors, ACM CCS 2019, pages 2057–2074. ACM Press, November 2019.</p>

    <p class="text-gray-300">MBKM19. Mary Maller, Sean Bowe, Markulf Kohlweiss, and Sarah Meiklejohn. Sonic: Zero-knowledge SNARKs from linear-size universal and updatable structured reference strings. In Lorenzo Cavallaro, Johannes Kinder, XiaoFeng Wang, and Jonathan Katz, editors, ACM CCS 2019, pages 2111–2128. ACM Press, November 2019.</p>

    <p class="text-gray-300">MGGR13. Ian Miers, Christina Garman, Matthew Green, and Aviel D. Rubin. Zerocoin: Anonymous distributed E-cash from Bitcoin. In 2013 IEEE Symposium on Security and Privacy, pages 397–411. IEEE Computer Society Press, May 2013.</p>

    <p class="text-gray-300">MKF21. Toghrul Maharramov, Dmitry Khovratovich, and Emanuele Francioni. The dusk network whitepaper, 2021. Whitepaper. https://dusk.network/uploads/The_Dusk_Network_Whitepaper_v3_0_0.pdf.</p>

    <p class="text-gray-300">Nom22. Nomadic Labs’ Cryptography Team. <span class="math">\\alpha\\mathcal{P}lon\\mathcal{K}</span>, a library for zero-knowledge proofs and validity rollups, 2022. https://gitlab.com/nomadic-labs/privacy-team/.</p>

    <p class="text-gray-300">Ove22. Overeality Labs. Infrastructure for web3 interoperability, 2022. https://overeality.io/home.</p>

    <p class="text-gray-300">PFM^{+}22. Luke Pearson, Joshua Fitzgerald, Héctor Masip, Marta Bellés-Muñoz, and Jose Luis Muñoz-Tapia. Plonkup: Reconciling plonk with plookup. Cryptology ePrint Archive, Report 2022/086, 2022. https://ia.cr/2022/086.</p>

    <p class="text-gray-300">PHGR13. Bryan Parno, Jon Howell, Craig Gentry, and Mariana Raykova. Pinocchio: Nearly practical verifiable computation. In 2013 IEEE Symposium on Security and Privacy, pages 238–252. IEEE Computer Society Press, May 2013.</p>

    <p class="text-gray-300">PS00. David Pointcheval and Jacques Stern. Security arguments for digital signatures and blind signatures. Journal of Cryptology, 13(3):361–396, June 2000.</p>

    <p class="text-gray-300">Sch91. Claus-Peter Schnorr. Efficient signature generation by smart cards. Journal of Cryptology, 4(3):161–174, January 1991.</p>

    <p class="text-gray-300">Sta21. StarkWare. ethstark documentation. Cryptology ePrint Archive, Paper 2021/582, 2021. https://eprint.iacr.org/2021/582.</p>

    <p class="text-gray-300">Sup21. Supranational. blst, a bls12-381 signature library focused on performance and security., 2021. https://github.com/supranational/blst/tree/757aa00a90c03779f70d0ddab6bc84b40861bb4b.</p>

    <p class="text-gray-300">Val08. Paul Valiant. Incrementally verifiable computation or proofs of knowledge imply time/space efficiency. In Ran Canetti, editor, TCC 2008, volume 4948 of LNCS, pages 1–18. Springer, Heidelberg, March 2008.</p>

    <p class="text-gray-300">Wil18. Zachary J. Williamson. Aztec network (white paper), 2018. Whitepaper. https://github.com/AztecProtocol/AZTEC/blob/master/AZTEC.pdf.</p>

    <p class="text-gray-300">ZXZS20. Jiaheng Zhang, Tiancheng Xie, Yupeng Zhang, and Dawn Song. Transparent polynomial delegation and its applications to zero knowledge proof. In 2020 IEEE Symposium on Security and Privacy, SP 2020, San Francisco, CA, USA, May 18-21, 2020, pages 859–876. IEEE, 2020.</p>

    <p class="text-gray-300">A Additional definitions</p>

    <h3 id="sec-52" class="text-xl font-semibold mt-8">A.1 <span class="math">\\mathcal{P}lon\\mathcal{K}</span> permutation identities</h3>

    <p class="text-gray-300">Given a permutation <span class="math">\\sigma:[3n]\\to[3n]</span>, <span class="math">\\eta_{1}=1\\in\\mathbb{Z}_{p}</span>, <span class="math">\\eta_{2},\\eta_{3}\\in\\mathbb{Z}_{p}</span> two quadratic non-residues (declared during the preprocessing phase of <span class="math">\\mathcal{P}lon\\mathcal{K}</span>) such that <span class="math">\\eta_{3}\\notin\\eta_{2}\\mathcal{H}_{n}</span>, the permutation polynomials <span class="math">\\mathsf{S}_{\\sigma 1}</span>, <span class="math">\\mathsf{S}_{\\sigma 2}</span>, <span class="math">\\mathsf{S}_{\\sigma 3}</span> are defined as</p>

    <p class="text-gray-300"><span class="math">\\mathsf{S}_{\\sigma k}\\coloneqq\\sum_{i=1}^{n}\\eta_{q_{ki}}\\omega^{r_{ki}}\\mathsf{L}_{i}(X),\\qquad\\forall k\\in[3]\\enspace.</span></p>

    <p class="text-gray-300">with <span class="math">q_{ki}n+r_{ki}=\\sigma(kn+i)</span> such that <span class="math">0\\leq r_{ki}&lt;n</span>.</p>

    <p class="text-gray-300">The permutation identities are parametrized by two scalars <span class="math">\\beta,\\gamma\\in\\mathbb{Z}_{p}</span> and is formed by the following polynomials:</p>

    <p class="text-gray-300"><span class="math">perm\\mathchar 45\\relax\\mathchar 21\\relax\\mathchar 22\\relax_{\\sigma,\\beta,\\gamma}(\\mathsf{A}(X),\\mathsf{B}(X),\\mathsf{C}(X),\\mathsf{Z}(X))\\coloneqq</span> <span class="math">\\big{\\{}\\;\\mathsf{P}(X,\\eta_{2}X,\\eta_{3}X,X)-\\mathsf{P}(\\mathsf{S}_{\\sigma 1}(X),\\mathsf{S}_{\\sigma 2}(X),\\mathsf{S}_{\\sigma 3}(X),\\omega X),\\enspace(\\mathsf{Z}(X)-1)\\mathsf{L}_{1}(X)\\;\\big{\\}}\\enspace,</span></p>

    <p class="text-gray-300">where <span class="math">\\mathsf{P}(Y_{1},Y_{2},Y_{3},Y_{4})</span> is defined as <span class="math">(\\mathsf{A}(X)+\\beta Y_{1}+\\gamma)(\\mathsf{B}(X)+\\beta Y_{2}+\\gamma)(\\mathsf{C}(X)+\\beta Y_{3}+\\gamma)\\mathsf{Z}(Y_{4})</span></p>

    <p class="text-gray-300">An honest prover, who has built polynomials <span class="math">\\mathsf{A}</span>, <span class="math">\\mathsf{B}</span> and <span class="math">\\mathsf{C}</span> from a trace witness <span class="math">\\widetilde{\\bm{w}}</span> that respects the permutation constraints induced by <span class="math">\\sigma</span>, can construct a polynomial <span class="math">\\mathsf{Z}</span> that satisfies the permutation identities as follows (define <span class="math">W=(\\mathsf{A},\\mathsf{B},\\mathsf{C})</span>).</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Z}\\coloneqq\\mathsf{L}_{1}+\\sum_{i=2}^{n}\\mathsf{L}_{i}\\prod_{j=1}^{i-1}\\prod_{k=0}^{2}\\frac{(W_{k}(\\omega^{j})+\\beta\\eta_{k}\\omega^{j}+\\gamma)}{(W_{k}(\\omega^{j})+\\beta\\mathsf{S}_{\\sigma k}(\\omega^{j})+\\gamma)}\\enspace.</span></p>

    <h3 id="sec-53" class="text-xl font-semibold mt-8">A.2 Assumptions</h3>

    <h6 id="sec-54" class="text-base font-medium mt-4">Definition 5 (<span class="math">q</span>-DLOG Assumption).</h6>

    <p class="text-gray-300">For <span class="math">q\\in\\mathbb{N}</span>, the <span class="math">q</span>-discrete logarithm assumption (relative to bilinear group generator <span class="math">\\mathcal{G}</span>) states that for any PPT algorithm <span class="math">\\mathcal{A}</span>, the following probability is negligible in <span class="math">\\lambda</span>:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\big{[}(\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{\\mathsf{t}},e)\\leftarrow\\mathcal{G}(1^{\\lambda});\\;\\bm{x}\\coloneqq(1,\\ldots,x^{q});\\;y\\leftarrow\\mathcal{A}([\\bm{x}]_{1},[\\bm{x}]_{2}):\\;y=x\\big{]}\\enspace.</span></p>

    <h2 id="sec-55" class="text-2xl font-bold">Appendix B Building blocks for multi-polynomial commitments</h2>

    <p class="text-gray-300">The multi-polynomial commitment scheme from Figure 2 relies on two main building blocks: (i) a homomorphic polynomial commitment scheme whose commitment space is <span class="math">\\mathbb{G}_{1}</span>, and (ii) an argument system for relation <span class="math">\\mathrm{PoK}\\{\\,\\bm{\\mu}:\\,\\langle\\bm{\\mu},\\bm{G}\\rangle=C_{G}\\wedge\\langle\\bm{r},\\bm{\\mu}\\rangle=P\\,\\}</span>. In this section we provide a description of candidate instantiations for such building blocks. For the former, we choose the well-known KZG homomorphic polynomial commitment scheme <em>[x10]</em>. For the latter, we propose the protocol from Section B.2, a modified version of the inner-product argument <em>[BBB^{+}18]</em>. Similar modifications of the inner-product argument have been proposed in the literature <em>[x1, BCL^{+}21]</em>. Here we present our own version, specialized for our use case, and prove its security for completeness.</p>

    <h3 id="sec-56" class="text-xl font-semibold mt-8">B.1 KZG polynomial commitment</h3>

    <p class="text-gray-300">We describe in Figure 7 the well-known KZG homomorphic polynomial commitment scheme <em>[x10]</em>.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Lemma 1.</h6>

    <p class="text-gray-300">The polynomial commitment scheme from Figure 7 is <em>complete</em>, homomorphic, binding <em>and</em> knowledge sound <em>in the algebraic group model under the <span class="math">q</span>-DLOG assumption</em>.</p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300"><em>Completeness</em> and the <em>homomorphic property</em> can be checked by inspection. Breaking the <em>binding property</em> implies finding two different polynomials <span class="math">f</span>, <span class="math">f^{\\prime}</span> such that <span class="math">[f(s)]_{1}=[f^{\\prime}(s)]_{1}</span> which is equivalent to finding a non-trivial linear relation between the elements of <span class="math">\\mathsf{ck}</span>, which is hard under the q-DLOG assumption. We refer to <em>[x12, Section 3]</em> for a proof of <em>knowledge soundness</em> in the algebraic group model. ∎</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Fig. 7. KZG homomorphic polynomial commitment scheme over  <span class="math">\\mathbb{G}_1</span> .</p>

    <p class="text-gray-300">Lemma 2. The polynomial commitment scheme from Figure 7 is inner-product binding (in the standard model) under the  <span class="math">q</span> -DLOG assumption.</p>

    <p class="text-gray-300">Proof. Let  <span class="math">\\mathcal{A}</span>  be an adversary against the inner-product binding property of the scheme from Figure 7, for some  <span class="math">d, K \\in \\mathbb{N}</span> . We build an adversary  <span class="math">\\mathcal{B}</span>  against the  <span class="math">q</span> -DLOG problem (for  <span class="math">q = K - 1</span> ).  <span class="math">\\mathcal{B}</span>  is given  <span class="math">[\\pmb{x}]_1</span>  and  <span class="math">[\\pmb{x}]_2</span>  for some  <span class="math">x \\gets \\mathbb{Z}_p</span>  and  <span class="math">\\pmb{x} := (1, x, \\dots, x^{K - 1})</span> .  <span class="math">\\mathcal{B}</span>  will now flip a fair coin:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If the coin results in heads,  <span class="math">\\mathcal{B}</span>  will simulate  <span class="math">\\mathsf{ck} \\coloneqq ([\\pmb{s}]_1, [\\pmb{s}]_2)</span>  by sampling  <span class="math">s</span>  uniformly at random.  <span class="math">\\mathcal{B}</span>  will call  <span class="math">\\mathcal{A}</span>  on  <span class="math">(\\mathsf{ck}, [\\pmb{x}]_1, [\\pmb{x}]_2)</span> , receiving two distinct vectors of polynomials  <span class="math">\\pmb{f}, \\pmb{f}&#x27; \\in \\mathbb{Z}_p[X]^k</span>  for some  <span class="math">k \\leq K</span> , such that  <span class="math">\\sum_{i=1}^{k} x^{i-1}(f_i - f_i&#x27;)(s) = 0</span> . If  <span class="math">(f_i - f_i&#x27;)(s) \\neq 0</span>  for some  <span class="math">i</span> , then  <span class="math">\\mathcal{B}</span>  can extract  <span class="math">x</span>  by solving a non-trivial polynomial equation over  <span class="math">\\mathbb{Z}_p</span> .  <span class="math">\\mathcal{B}</span>  will win the  <span class="math">q</span> -DLOG game in this branch with non-negligible probability unless  <span class="math">(f_i - f_i&#x27;)(s) = 0</span>  with overwhelming probability for all  <span class="math">i \\in [k]</span> .</li>

      <li>If the coin results in tails,  <span class="math">\\mathcal{B}</span>  will simulate  <span class="math">\\tau</span>  by sampling it uniformly at random. It will then instantiate  <span class="math">\\mathsf{ck}</span>  with  <span class="math">([\\pmb{x}]_1, [\\pmb{x}]_2)</span>  and call  <span class="math">\\mathcal{A}</span>  on  <span class="math">(\\mathsf{ck}, [\\pmb{\\tau}]_1, [\\pmb{\\tau}]_2)</span> , receiving two distinct vectors of polynomials  <span class="math">\\pmb{f}, \\pmb{f}&#x27; \\in \\mathbb{Z}_p[X]^k</span>  for some  <span class="math">k \\leq K</span> , such that  <span class="math">\\sum_{i=1}^{k} \\tau^{i-1}(f_i - f_i&#x27;)(x) = 0</span> . Assume  <span class="math">\\mathcal{B}</span>  is almost never successful in the previous branch, then  <span class="math">(f_i - f_i&#x27;)(x) = 0</span>  with overwhelming probability for all  <span class="math">i \\in [k]</span> . Since  <span class="math">\\pmb{f} \\neq \\pmb{f}&#x27;</span>  there must exist an index  <span class="math">i</span>  such that  <span class="math">(f_i - f_i&#x27;)(X)</span>  is not the zero polynomial. However,  <span class="math">(f_i - f_i&#x27;)(x) = 0</span> , thus  <span class="math">\\mathcal{B}</span>  can extract  <span class="math">x</span>  by solving a non-trivial polynomial equation over  <span class="math">\\mathbb{Z}_p</span> .</li>

    </ul>

    <p class="text-gray-300">Algorithm  <span class="math">\\mathcal{B}</span>  must be successful in at least one of the branches with the same probability that  <span class="math">\\mathcal{A}</span>  is, so the total advantage of  <span class="math">\\mathcal{B}</span>  solving the  <span class="math">q</span> -DLOG problem is at least half the advantage of  <span class="math">\\mathcal{A}</span>  against the inner-product binding property.</p>

    <p class="text-gray-300">Lemma 3. The polynomial commitment scheme from Figure 7 is inner-product extractable in the algebraic group model under the  <span class="math">q</span> -DLOG assumption.</p>

    <p class="text-gray-300">Proof. We proceed in the symbolic model, which immediately implies generic security. As explained above, symbolic security can be turned into a proof in the algebraic group model under the  <span class="math">q</span> -DLOG assumption.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{A}</span>  be a symbolic adversary against the inner-product extractability of the scheme from Figure 7, for some  <span class="math">d, K \\in \\mathbb{N}</span> . On its first message,  <span class="math">\\mathcal{A}</span>  outputs polynomial  <span class="math">G \\in \\mathbb{Z}_p[S, T]</span>  and scalars  <span class="math">z \\in \\mathbb{Z}_p</span> ,  <span class="math">\\pmb{v} \\in \\mathbb{Z}_p^k</span> , for</p>

    <p class="text-gray-300">some <span class="math">k \\leq K</span>. After being given <span class="math">r \\in \\mathbb{Z}_p</span>, <span class="math">\\mathcal{A}</span> outputs polynomials <span class="math">\\boldsymbol{\\mu} \\in \\mathbb{Z}_p[S, T]^k</span> and <span class="math">\\pi \\in \\mathbb{Z}_p[S, T]</span>. We define an extractor <span class="math">\\mathcal{E}</span> that runs the first step of <span class="math">\\mathcal{A}</span>, parses the resulting polynomial <span class="math">G(S, T)</span> as <span class="math">\\sum_{j=1}^{2K-1} T^{j-1} f_j(S)</span> and outputs <span class="math">\\boldsymbol{f} \\coloneqq (f_1, \\ldots, f_k)</span>. We need to show that if the following equations hold with non-negligible probability over the choice of <span class="math">r</span>, and for <span class="math">\\boldsymbol{T} \\coloneqq (1, T, \\ldots, T^{k-1})</span>, <span class="math">\\boldsymbol{r} \\coloneqq (1, r, \\ldots, r^{k-1})</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\langle \\boldsymbol {\\mu} (S, T), \\boldsymbol {r} \\rangle - \\langle \\boldsymbol {v}, \\boldsymbol {r} \\rangle = \\pi (S, T) (S - z) \\tag {5}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\langle \\boldsymbol {\\mu} (S, T), \\boldsymbol {T} \\rangle = G (S, T), \\tag {6}</span></div>

    <p class="text-gray-300">then the above extractor produces <span class="math">k</span> polynomials <span class="math">\\boldsymbol{f}</span> satisfying <span class="math">\\boldsymbol{f}(z) = \\boldsymbol{v}</span> and <span class="math">\\langle \\boldsymbol{f}, \\boldsymbol{T} \\rangle = G(S, T)</span>.</p>

    <p class="text-gray-300">First, given the structural conditions of footnote 13, polynomial <span class="math">\\mu_{i}</span>, for every <span class="math">i\\in [k]</span>, must be expressible as <span class="math">\\mu_{i}\\coloneqq P_{i}(S) + Q_{i}(T)</span> for some univariate polynomials <span class="math">P_{i}</span> and <span class="math">Q_{i}</span>. We can thus express equation (6) as <span class="math">\\sum_{i = 1}^{k}P_{i}(S)T^{i - 1} + \\sum_{i = 1}^{k}Q_{i}(T)T^{i - 1} = G(S,T)</span>, which implies that <span class="math">f_{j}(S)</span> is constant for every <span class="math">j &amp;gt; k</span>. Now, by subtracting equations (6) and (5) and rearranging terms, we get:</p>

    <div class="my-4 text-center"><span class="math-block">G (S, T) = \\left\\langle \\boldsymbol {\\mu} (S, T), \\boldsymbol {T} - \\boldsymbol {r} \\right\\rangle + \\pi (S, T) (S - z) + \\left\\langle \\boldsymbol {v}, \\boldsymbol {r} \\right\\rangle . \\tag {7}</span></div>

    <p class="text-gray-300">Partially evaluating equation (7) on <span class="math">S = z</span> leads to <span class="math">G(z,T) = \\langle \\pmb{\\mu}(z,T),\\pmb{T} - \\pmb{r}\\rangle +\\langle \\pmb{v},\\pmb{r}\\rangle</span>, a polynomial equation on <span class="math">T</span>, which evaluated on <span class="math">T = r</span> gives <span class="math">G(z,r) = \\langle \\pmb{v},\\pmb{r}\\rangle</span>. Now, define <span class="math">h(X)\\coloneqq G(z,X) - \\langle \\pmb{v},\\pmb{X}\\rangle</span>, where <span class="math">\\pmb{X}\\coloneqq (1,X,\\dots ,X^{k - 1})</span> and observe that polynomial <span class="math">h</span> is determined by the first message of <span class="math">\\mathcal{A}</span>, before <span class="math">r</span> is chosen. Furthermore, if the last equality holds with non-negligible probability over the choice of <span class="math">r</span>, then <span class="math">h(r) = 0</span> for a non-negligible amount of values of <span class="math">r</span> over <span class="math">\\mathbb{Z}_p</span>. Since <span class="math">\\deg (h) &amp;lt; 2K</span>, which is negligible, <span class="math">h</span> must be the zero polynomial. Given that <span class="math">h</span> can be expressed as <span class="math">h(X) = \\left(\\sum_{j = 1}^{2K - 1}X^{j - 1}f_j(z)\\right) - \\sum_{j = 1}^{k}X^{j - 1}v_j</span>, we can deduce that <span class="math">f_{j}(z) = v_{j}</span> for every <span class="math">j\\in [k]</span> and <span class="math">f_{j}(z) = 0</span> for all <span class="math">j &amp;gt; k</span>. Furthermore, <span class="math">f_{j}</span> is a constant polynomial for every <span class="math">j &amp;gt; k</span>, so <span class="math">f_{j}(X)</span> must be the zero polynomial for every <span class="math">j &amp;gt; k</span>. Consequently, <span class="math">\\langle \\pmb {f},\\pmb {T}\\rangle = G(S,T)</span>, as desired.</p>

    <h2 id="sec-59" class="text-2xl font-bold">B.2 Modified inner-product argument</h2>

    <p class="text-gray-300"><strong>Lemma 4.</strong> The argument from Figure 3 has perfect completeness and computational witness-extended emulation for either extracting a non-trivial linear relation between group elements in <span class="math">\\mathbf{G}, \\mathbf{H}</span> or extracting a valid witness for relation:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {P o K} \\left\\{\\boldsymbol {\\mu} \\in \\mathbb {G} _ {1} ^ {2 ^ {\\kappa}}: \\langle \\boldsymbol {\\mu}, \\boldsymbol {G} \\rangle = C _ {G} \\wedge \\langle \\boldsymbol {\\mu}, \\boldsymbol {H} \\rangle = C _ {H} \\wedge \\langle \\boldsymbol {r}, \\boldsymbol {\\mu} \\rangle = P \\right\\}.</span></div>

    <p class="text-gray-300"><strong>Proof.</strong> We focus on the variant of Figure 3 which includes colored terms. A proof for the simpler version could be easily derived from this one. Correctness can be checked by inspection. For witness-extended emulation, we focus on the interactive version of the protocol from Figure 3 where every hash evaluation producing <span class="math">u_{j}</span> is replaced by a round of interaction where the verifier samples <span class="math">u_{j}</span> uniformly at random. We will see that there exists an efficient extractor <span class="math">\\mathcal{E}</span> that produces a witness from <span class="math">3^{\\kappa}</span> different valid transcripts. Since <span class="math">n = 2^{\\kappa}</span> is polynomial-size and <span class="math">3^{\\kappa}</span> equals <span class="math">n^{\\log_23}</span>, the result then follows from the General Forking Lemma from [BCC+16, BBB+18]. We proceed by induction on <span class="math">\\kappa</span>.</p>

    <p class="text-gray-300">If <span class="math">\\kappa = 0</span> the extractor from a transcript simply returns <span class="math">\\mu^{(0)}</span>, which is a valid witness if the transcript is valid (the transcript verification equations are those of the NP-relation when <span class="math">\\kappa = 0</span>).</p>

    <p class="text-gray-300">We now argue that if (for some <span class="math">\\kappa &amp;gt; 0</span>) we have an extractor <span class="math">\\mathcal{E}_{\\kappa - 1}</span> for the protocol of size <span class="math">\\kappa - 1</span>, we can build an extractor <span class="math">\\mathcal{E}_{\\kappa}</span> for the protocol of size <span class="math">\\kappa</span>. <span class="math">\\mathcal{E}_{\\kappa}</span> will run the prover until values <span class="math">(L_{G}^{(\\kappa)}, L_{H}^{(\\kappa)}, L_{r}^{(\\kappa)}, R_{G}^{(\\kappa)}, R_{H}^{(\\kappa)}, R_{r}^{(\\kappa)})</span> have been fixed and sent to the verifier. Observe that the protocol after this first step is equivalent to a</p>

    <p class="text-gray-300">29</p>

    <p class="text-gray-300">protocol of size <span class="math">\\kappa - 1</span> on a different public input:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{G}&#x27; := u_{\\kappa}^{-1} \\mathbf{G}_{\\mathrm{L}}^{(\\kappa)} + u_{\\kappa} \\mathbf{G}_{\\mathrm{R}}^{(\\kappa)} \\quad C_G&#x27; := C_G + u_{\\kappa}^2 L_G^{(\\kappa)} + u_{\\kappa}^{-2} R_G^{(\\kappa)} \\quad r&#x27; = r</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{H}&#x27; := u_{\\kappa}^{-1} \\mathbf{H}_{\\mathrm{L}}^{(\\kappa)} + u_{\\kappa} \\mathbf{H}_{\\mathrm{R}}^{(\\kappa)} \\quad C_H&#x27; := C_H + u_{\\kappa}^2 L_H^{(\\kappa)} + u_{\\kappa}^{-2} R_H^{(\\kappa)} \\quad P&#x27; = \\left(P + u_{\\kappa}^2 L_r^{(\\kappa)} + u_{\\kappa}^{-2} R_r^{(\\kappa)}\\right) / \\left(u_{\\kappa}^{-1} + u_{\\kappa} r^{2^{\\kappa - 1}}\\right). \\tag{8}</span></div>

    <p class="text-gray-300">This is possible because <span class="math">\\mathbf{r}^{(\\kappa - 1)} \\coloneqq u_{\\kappa}^{-1} \\mathbf{r}_{\\mathrm{L}}^{(\\kappa)} + u_{\\kappa} \\mathbf{r}_{\\mathrm{R}}^{(\\kappa)}</span> can be expressed as <span class="math">(u_{\\kappa}^{-1} + u_{\\kappa} r^{2^{\\kappa - 1}}) (1, r, r^2, \\ldots, r^{2^{\\kappa - 1} - 1})</span>. Thus, <span class="math">\\mathbf{r}^{(\\kappa - 1)}</span> is again a vector containing the powers of a single element (actually the same <span class="math">r</span>), modulo multiplication by a constant. We got rid of the constant by dividing by it on the definition of <span class="math">P&#x27;</span>.</p>

    <p class="text-gray-300">At this point, <span class="math">\\mathcal{E}_{\\kappa}</span> forks the execution of the prover three times, by providing three different challenges <span class="math">u_{\\kappa}</span>, say <span class="math">u_{\\kappa,1}</span>, <span class="math">u_{\\kappa,2}</span> and <span class="math">u_{\\kappa,3}</span>. From this step, the protocol can be seen as an execution of the protocol of size <span class="math">\\kappa - 1</span> on public inputs <span class="math">(2^{\\kappa - 1}, \\mathbf{G}_i&#x27;, \\mathbf{H}_i&#x27;), (C_{G,i}&#x27;, C_{H,i}&#x27;, r, P_i&#x27;))</span>, for <span class="math">i = 1, 2, 3</span>, defined as in equation (8) by using the corresponding challenge <span class="math">u_{\\kappa,i}</span>. We can leverage the extractor <span class="math">\\mathcal{E}_{\\kappa - 1}</span> to obtain, from <span class="math">3 \\cdot 3^{\\kappa - 1} = 3^{\\kappa}</span> valid transcripts, witnesses <span class="math">\\pmb{\\mu}_i \\in \\mathbb{G}_1^{2^{\\kappa - 1}}</span> such that for all <span class="math">i \\in \\{1, 2, 3\\}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\langle \\boldsymbol{\\mu}_i, \\mathbf{G}_i&#x27; \\rangle = C_{G,i}&#x27; \\quad \\wedge \\quad \\langle \\boldsymbol{\\mu}_i, \\mathbf{H}_i&#x27; \\rangle = C_{H,i}&#x27; \\quad \\wedge \\quad \\sum_{j=0}^{2^{\\kappa - 1}} \\mu_{i,j} r^j = P_i&#x27;.</span></div>

    <p class="text-gray-300">Now, if <span class="math">u_{\\kappa,i} \\neq u_{\\kappa,j}</span> for <span class="math">i \\neq j</span>, which will occur with overwhelming probability, extractor <span class="math">\\mathcal{E}_{\\kappa}</span> can solve a linear system of equations and find <span class="math">\\nu_1, \\nu_2, \\nu_3 \\in \\mathbb{Z}_p</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=1}^{3} u_{\\kappa,i}^{-2} \\nu_i = 0 \\quad \\sum_{i=1}^{3} \\nu_i = 1 \\quad \\sum_{i=1}^{3} u_{\\kappa,i}^2 \\nu_i = 0.</span></div>

    <p class="text-gray-300">Extractor <span class="math">\\mathcal{E}_{\\kappa}</span> concludes by defining <span class="math">\\pmb{\\mu} \\in \\mathbb{G}_1^{2^{\\kappa}}</span> as:</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol{\\mu} := \\sum_{i=1}^{3} \\left(\\nu_i u_{\\kappa,i}^{-1} \\boldsymbol{\\mu}_i, \\nu_i u_{\\kappa,i} \\boldsymbol{\\mu}_i\\right).</span></div>

    <p class="text-gray-300">Observe that this represents a valid witness for the relation of Lemma 4:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\langle \\boldsymbol{\\mu}, \\mathbf{G} \\rangle &amp;amp;= \\sum_{i=1}^{3} \\nu_i u_{\\kappa,i}^{-1} \\langle \\boldsymbol{\\mu}_i, \\mathbf{G}_L \\rangle + \\sum_{i=1}^{3} \\nu_i u_{\\kappa,i} \\langle \\boldsymbol{\\mu}_i, \\mathbf{G}_R \\rangle = \\sum_{i=1}^{3} \\nu_i \\langle \\boldsymbol{\\mu}_i, u_{\\kappa,i}^{-1} \\mathbf{G}_L + u_{\\kappa,i} \\mathbf{G}_R \\rangle \\\\ &amp;amp;= \\sum_{i=1}^{3} \\nu_i \\langle \\boldsymbol{\\mu}_i, \\mathbf{G}_i&#x27; \\rangle = \\sum_{i=1}^{3} \\nu_i C_{G,i}&#x27; = \\sum_{i=1}^{3} \\nu_i \\left(C_G + u_{\\kappa,i}^2 L_G^{(\\kappa)} + u_{\\kappa,i}^{-2} R_G^{(\\kappa)}\\right) \\\\ &amp;amp;= \\left(\\sum_{i=1}^{3} \\nu_i\\right) C_G + \\left(\\sum_{i=1}^{3} \\nu_i u_{\\kappa,i}^2\\right) L_G^{(\\kappa)} + \\left(\\sum_{i=1}^{3} \\nu_i u_{\\kappa,i}^{-2}\\right) R_G^{(\\kappa)} \\\\ &amp;amp;= C_G. \\end{aligned}</span></div>

    <p class="text-gray-300">Similarly, <span class="math">\\langle \\pmb{\\mu}, \\pmb{H} \\rangle = C_H</span>. Finally,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\langle \\boldsymbol{r}, \\boldsymbol{\\mu} \\rangle &amp;amp;= \\sum_{i=1}^{3} \\nu_i u_{\\kappa,i}^{-1} \\langle \\boldsymbol{r}_L, \\boldsymbol{\\mu}_i \\rangle + \\sum_{i=1}^{3} \\nu_i u_{\\kappa,i} \\langle \\boldsymbol{r}_R, \\boldsymbol{\\mu}_i \\rangle = \\sum_{i=1}^{3} \\nu_i \\langle u_{\\kappa,i}^{-1} \\boldsymbol{r}_L + u_{\\kappa,i} \\boldsymbol{r}_R, \\boldsymbol{\\mu}_i \\rangle \\\\ &amp;amp;= \\sum_{i=1}^{3} \\nu_i \\left(u_{\\kappa,i}^{-1} + r^{2^{\\kappa - 1}} u_{\\kappa,i}\\right) \\langle \\boldsymbol{r}_L, \\boldsymbol{\\mu}_i \\rangle = \\sum_{i=1}^{3} \\nu_i \\left(u_{\\kappa,i}^{-1} + r^{2^{\\kappa - 1}} u_{\\kappa,i}\\right) P_i&#x27; \\\\ &amp;amp;= \\sum_{i=1}^{3} \\nu_i \\left(P + u_{\\kappa,i}^2 L_r^{(\\kappa)} + u_{\\kappa,i}^{-2} R_r^{(\\kappa)}\\right) = \\left(\\sum_{i=1}^{3} \\nu_i\\right) P + \\left(\\sum_{i=1}^{3} \\nu_i u_{\\kappa,i}^2\\right) L_r^{(\\kappa)} + \\left(\\sum_{i=1}^{3} \\nu_i u_{\\kappa,i}^{-2}\\right) R_r^{(\\kappa)} \\\\ &amp;amp;= P. \\end{aligned}</span></div>

    <p class="text-gray-300">□</p>

    <h2 id="sec-61" class="text-2xl font-bold">C.1 Proof of Theorem 1</h2>

    <p class="text-gray-300">Theorem 1 establishes that the scheme from Figure 2 is a complete, binding and knowledge sound multipolynomial commitment scheme. We first establish the following helper lemma, which we prove after the proof of Theorem 1.</p>

    <p class="text-gray-300">Lemma 5. Let  <span class="math">\\mathcal{A}</span>  be an algebraic (stateful) algorithm. If the  <span class="math">q</span> -DLOG assumption holds, then the following probability is negligible in  <span class="math">\\lambda</span> , for any  <span class="math">K \\in \\mathbb{N}</span>  and any polynomial  <span class="math">g \\in \\mathbb{Z}_p[X]</span>  with  <span class="math">\\deg(g) \\leq K</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\begin{array}{c} \\tau , \\rho \\leftarrow \\mathbb {Z} _ {p} \\\\ G \\leftarrow \\mathcal {A} ([ \\boldsymbol {\\tau} ] _ {1}, [ \\boldsymbol {\\tau} ] _ {2}) : G \\neq [ g (\\tau) ] _ {\\mathrm {t}} \\wedge e ([ \\tau ] _ {1} - [ \\rho ] _ {1}, \\pi) = G - g (\\rho) \\\\ \\pi \\leftarrow \\mathcal {A} (\\rho) \\end{array} \\right],</span></div>

    <p class="text-gray-300">where  <span class="math">\\pmb{\\tau} \\coloneqq (1, \\tau, \\dots, \\tau^{K-1})</span> .</p>

    <p class="text-gray-300">Proof (of Theorem 1). Completeness can be checked by inspection.</p>

    <p class="text-gray-300">For the binding property, note that Commit-Evals is binding by definition. We will prove that that Commit-Polys is binding if  <span class="math">\\varPsi</span>  is inner-product binding. For that, let  <span class="math">\\mathcal{A}</span>  be an adversary against the binding property of the scheme from Figure 2 (for  <span class="math">d,K\\in \\mathbb{N}</span> ). We will build an adversary  <span class="math">\\mathcal{B}</span>  against the inner-product binding property of  <span class="math">\\varPsi</span>  (for the same  <span class="math">d,K</span> ), who succeeds with the same probability  <span class="math">\\mathcal{A}</span>  does. On input  <span class="math">(\\mathsf{ck}_{\\varPsi},[\\pmb {\\tau}]_1,[\\pmb {\\tau}]_2)</span> ,  <span class="math">\\mathcal{B}</span>  simulates the commitment key of the multi-polynomial commitment as  <span class="math">\\mathsf{ck}\\coloneqq (\\mathsf{ck}_{\\varPsi},[\\pmb {\\tau}]_2)</span>  and the verification key as  <span class="math">\\mathsf{vk}\\coloneqq (\\mathsf{vk}_{\\varPsi},[\\tau ]_{1})</span> . Adversary  <span class="math">\\mathcal{B}</span>  sends  <span class="math">\\mathsf{ck}</span>  to  <span class="math">\\mathcal{A}</span> , who will produce  <span class="math">\\pmb {f}\\in \\mathbb{Z}_p^{&amp;lt; d}[X]^k</span>  and  <span class="math">\\pmb {f}&#x27;\\in \\mathbb{Z}_p^{&amp;lt; d}[X]^{k&#x27;}</span> , with  <span class="math">k,k^{\\prime} &amp;lt; K</span> , such that  <span class="math">\\pmb {f}\\neq \\pmb{f}^{\\prime}</span>  and Commit-Polys(ck,  <span class="math">\\pmb {f}) =</span>  Commit-Polys(ck,  <span class="math">\\pmb {f}^{\\prime}</span> ). Adversary  <span class="math">\\mathcal{B}</span>  will simply output  <span class="math">(\\pmb {f},\\pmb {f}^{\\prime})</span> , which must be a valid forgery to its own inner-product binding game, since:</p>

    <div class="my-4 text-center"><span class="math-block">\\left(k, \\langle \\Psi . \\text {C o m m i t} (\\mathrm {c k} _ {\\Psi}, \\boldsymbol {f}), \\boldsymbol {\\tau} \\rangle\\right) = \\text {C o m m i t - P o l y s} (\\mathrm {c k}, \\boldsymbol {f}) = \\text {C o m m i t - P o l y s} (\\mathrm {c k}, \\boldsymbol {f} ^ {\\prime}) = \\left(k ^ {\\prime}, \\langle \\Psi . \\text {C o m m i t} (\\mathrm {c k} _ {\\Psi}, \\boldsymbol {f} ^ {\\prime}), \\boldsymbol {\\tau} \\rangle\\right),</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">which implies that  <span class="math">\\langle \\varPsi .\\mathsf{Commit}(\\mathsf{ck}_{\\varPsi},\\pmb {f}),\\pmb {\\tau}\\rangle = \\langle \\varPsi .\\mathsf{Commit}(\\mathsf{ck}_{\\varPsi},\\pmb {f}^{\\prime}),\\pmb {\\tau}\\rangle</span>  and that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pmb {f}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pmb {f}'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  , as desired.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, we show that the scheme is knowledge sound. Let  <span class="math">\\mathcal{A}</span>  be an algorithm that on input ck produces  <span class="math">(\\mathsf{com}_{\\pmb{f}},z,\\mathsf{com}_{\\pmb{v}},\\pi)</span>  s.t. Check(vk,comf,z,comv,π)=1 with non-negligible probability. We will define an extractor  <span class="math">\\mathcal{E}</span>  that runs in expected polynomial time and produces  <span class="math">\\pmb{f}</span>  such that  <span class="math">\\mathsf{com}_{\\pmb{f}} = \\mathsf{Commit - Polys}(\\mathsf{ck},\\pmb {f})</span>  and  <span class="math">\\mathsf{com}_{\\pmb{v}} = \\mathsf{Commit - Evals}(\\pmb {f}(z))</span>  with overwhelming probability conditioned on Check(vk,comf,z,comv,π)=1.</p>

    <p class="text-gray-300">For that, we will extend algorithm  <span class="math">\\mathcal{A}</span>  (against knowledge soundness for some  <span class="math">d,K\\in \\mathbb{N}</span> ) into an algorithm  <span class="math">\\mathcal{B}</span>  against the inner-product extractability of  <span class="math">\\varPsi</span>  (for the same  <span class="math">d,K\\in \\mathbb{N}</span> ). Given  <span class="math">(\\mathsf{ck}_{\\varPsi},[\\pmb {\\tau}]_1,[\\pmb {\\tau}]_2)</span> ,  <span class="math">\\mathcal{B}</span>  will prepare the multi-polynomial commitment key  <span class="math">\\mathsf{ck}</span>  as described above and run  <span class="math">\\mathcal{A}</span>  on it, producing  <span class="math">(\\mathsf{com}_{\\pmb{f}},z,\\mathsf{com}_{\\pmb{v}},\\pi)</span> . Parse  <span class="math">\\mathsf{com}_{\\pmb{f}}</span>  as  <span class="math">(k,G)</span> .  <span class="math">\\mathcal{B}</span>  will then run the knowledge extractor of the proof of relation (3) contained in  <span class="math">\\pi</span>  to obtain a vector  <span class="math">\\pmb{v}</span>  s.t. Commit-Evals  <span class="math">(\\pmb {v}) = \\mathsf{com}_{\\pmb{v}}</span> . After that,  <span class="math">\\mathcal{B}</span>  will output  <span class="math">(G,z,\\pmb {v})</span>  as its first message of the inner-product extractability game. On receiving  <span class="math">r</span> ,  <span class="math">\\mathcal{B}</span>  will rewind  <span class="math">\\mathcal{A}</span>  and provide  <span class="math">r</span>  as the output of Hash on  <span class="math">(\\mathsf{com}_{\\pmb{f}},z,\\mathsf{com}_{\\pmb{v}})</span> . By the Forking Lemma [PS00, BN06], this second execution of  <span class="math">\\mathcal{A}</span>  results in a tuple  <span class="math">(\\mathsf{com}_{\\pmb{f}},z,\\mathsf{com}_{\\pmb{v}},\\tilde{\\pi})</span>  which also satisfies Check(vk,comf,z,comv,  <span class="math">\\tilde{\\pi}) = 1</span>  with non-negligible probability. Parse  <span class="math">\\tilde{\\pi}</span>  as  <span class="math">(\\hat{\\mu},\\hat{v},\\pi_{\\Psi},\\pi_v,\\pi_{\\mathsf{IPA}},\\pi_\\tau)</span> . Now observe that by virtue of Lemma 5, steps 5-6 from the Check algorithm from Figure 2 serve as a replacement for the skipped steps 6-7 from the inner-product argument from Figure 3. Therefore,  <span class="math">\\mathcal{B}</span>  can leverage the extractor of the inner-product argument to obtain  <span class="math">\\pmb {\\mu}\\in \\mathbb{G}_1^k</span>  such that  <span class="math">\\langle \\pmb {\\mu},\\pmb {\\tau}[:k]\\rangle = G</span>  and  <span class="math">\\langle \\pmb {r},\\pmb {\\mu}\\rangle = \\hat{\\mu}</span> , where  <span class="math">\\pmb {r} = (1,r,\\dots,r^{k - 1})</span> . Algorithm  <span class="math">\\mathcal{B}</span>  will output  <span class="math">(\\pmb {\\mu},\\pi_{\\Psi})</span> .</p>

    <p class="text-gray-300">Observe that  <span class="math">\\mathcal{B}</span>  is a successful algorithm against the inner-product extractability of  <span class="math">\\varPsi</span>  in the sense that  <span class="math">G\\in \\mathbb{G}_{\\mathfrak{t}}</span> ,  <span class="math">z\\in \\mathbb{Z}_p</span> ,  <span class="math">\\pmb {v}\\in \\mathbb{Z}_p^k</span> ,  <span class="math">\\pmb {\\mu}\\in \\mathbb{G}_1^k</span>  for some  <span class="math">k\\leq K</span>  and with non-negligible probability  <span class="math">\\langle \\pmb {\\mu},\\pmb {\\tau}[:k]\\rangle = G</span>  and  <span class="math">\\varPsi</span> . Check  <span class="math">(\\mathsf{ck}_{\\varPsi},\\hat{\\mu},z,\\hat{v},\\pi_{\\varPsi}) = 1</span> , where  <span class="math">\\hat{\\mu} = \\langle \\pmb {\\mu},\\pmb {r}\\rangle</span>  and  <span class="math">\\hat{v} = \\langle \\pmb {v},\\pmb {r}\\rangle</span> , as ensured by the proof of relation (3) contained in  <span class="math">\\tilde{\\pi}</span>  (and given the binding property of Commit-Evals). Therefore, given the inner-product extractability of  <span class="math">\\varPsi</span> , there exists an extractor  <span class="math">\\mathcal{E}_{\\mathcal{B}}</span>  that produces  <span class="math">k</span>  polynomials  <span class="math">\\pmb{f}</span>  s.t.  <span class="math">\\pmb {f}(z) = \\pmb{v}</span>  and  <span class="math">\\mathsf{com}_{\\pmb{f}} = (k,G) = (k,\\langle \\varPsi .\\mathsf{Commit}(\\mathsf{ck}_{\\varPsi},\\pmb {f}),\\pmb {\\tau}[:k]\\rangle)</span>  which equals Commit-Polys  <span class="math">(\\mathsf{ck},\\pmb {f})</span> . Consequently, given  <span class="math">\\mathcal{A}</span> , we can define an extractor  <span class="math">\\mathcal{E}</span>  for the knowledge soundness game that builds  <span class="math">\\mathcal{B}</span>  from  <span class="math">\\mathcal{A}</span>  and replays  <span class="math">\\mathcal{E}_{\\mathcal{B}}</span> , as desired.</p>

    <h2 id="sec-62" class="text-2xl font-bold">Proof of Lemma 5</h2>

    <p class="text-gray-300">For simplicity, we describe a proof in the generic group model. As observed before, it can be lifted to a proof in the algebraic group model under the  <span class="math">q</span> -DLOG assumption.</p>

    <p class="text-gray-300">31</p>

    <h6 id="sec-63" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Algorithm <span class="math">\\mathcal{A}</span>, will output a polynomial <span class="math">G\\in\\mathbb{Z}_{p}[T]</span> of degree bounded by <span class="math">2K</span>. (Note that <span class="math">\\mathcal{A}</span> can obtain <span class="math">[\\tau^{i}]_{\\mathsf{t}}</span> for every <span class="math">i\\in[0,2K-2]</span> by using the pairing, and no more relevant elements.) Then, after receiving <span class="math">\\rho\\in\\mathbb{Z}_{p}</span>, <span class="math">\\mathcal{A}</span> will output a second polynomial <span class="math">\\pi\\in\\mathbb{Z}_{p}[T]</span> of degree bounded by <span class="math">K</span>. <span class="math">\\mathcal{A}</span> is successful iff <span class="math">G(T)\\neq g(T)</span> and <span class="math">(T-\\rho)\\pi(T)=G(T)-g(\\rho)</span>. Once <span class="math">G</span> is fixed, the probability that it evaluates to the same value as <span class="math">g</span> on a uniformly chosen <span class="math">\\rho</span> is negligible. (It can be upper-bounded by <span class="math">2K/p</span>, given that <span class="math">G</span> and <span class="math">g</span> are distinct polynomials with degree bounded by <span class="math">2K</span>.) This means that, with overwhelming probability over the choice of <span class="math">\\rho</span>, the right-hand side of the previous equality is a polynomial that does not evaluate to <span class="math">0</span> on <span class="math">\\rho</span>. On the other hand, the left-hand side is a polynomial that evaluates to <span class="math">0</span> on <span class="math">\\rho</span>, independently of <span class="math">\\pi(T)</span>. We conclude that both polynomials cannot be equal and thus, the adversary cannot succeed in the symbolic model, what implies that the adversary’s success probability in the generic group model is negligible. ∎</p>

    <h6 id="sec-64" class="text-base font-medium mt-4">Theorem 1.1.</h6>

    <p class="text-gray-300">without the inner-product binding property or inner-product extractability</p>

    <p class="text-gray-300">The scheme from Figure 2 could be instantiated with a polynomial commitment scheme <span class="math">\\Psi</span> that is not inner-product binding nor inner-product extractable if it is modified as described in Remark 4. This is because function <span class="math">\\mathsf{Com}:\\mathbb{G}_{1}^{k}\\to\\mathbb{G}_{1}^{2}</span> defined as <span class="math">\\mathsf{Com}(\\bm{\\mu})\\coloneqq(\\langle\\bm{\\mu},\\bm{\\tau}[:k]\\rangle,\\langle\\bm{\\mu},\\bm{\\tilde{\\tau}}[:k]\\rangle)</span> is binding, as long as <span class="math">\\tau</span> and <span class="math">\\tilde{\\tau}</span> are sampled independently and only given as powers in <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span>.</p>

    <p class="text-gray-300">The <em>binding</em> of the modified multi-polynomial commitment scheme follows directly from the previous fact and the (standard) binding property of <span class="math">\\Psi</span>, which together imply that <span class="math">\\mathsf{Commit\\text{-}Polys}</span> is binding. Also, note that <span class="math">\\mathsf{Commit\\text{-}Evals}</span> is binding by definition.</p>

    <p class="text-gray-300">The <em>knowledge soundness</em> of the multi-polynomial commitment scheme could be proven as follows. Let <span class="math">\\mathcal{A}</span> be an algorithm that on input <span class="math">\\mathsf{ck}</span> produces <span class="math">(\\mathsf{com}_{\\bm{f}},z,\\mathsf{com}_{\\bm{v}},\\pi)</span> satisfying <span class="math">\\mathsf{Check}(\\mathsf{vk},\\mathsf{com}_{\\bm{f}},z,\\mathsf{com}_{\\bm{v}},\\pi)=1</span> with non-negligible probability <span class="math">\\delta</span>. We define an extractor <span class="math">\\mathcal{E}</span> that runs in expected polynomial time and produces <span class="math">\\bm{f}</span> such that <span class="math">\\mathsf{com}_{\\bm{f}}=\\mathsf{Commit\\text{-}Polys}(\\mathsf{ck},\\bm{f})</span> and <span class="math">\\mathsf{com}_{\\bm{v}}=\\mathsf{Commit\\text{-}Evals}(\\bm{f}(z))</span> with overwhelming probability. From an analog version of Lemma 5 we could show that the steps 5-6 from the <span class="math">\\mathsf{Check}</span> algorithm from Figure 2 (after the proper modifications) serve as a replacement for the skipped steps 6-7 from the inner-product argument from Figure 3. Say <span class="math">\\mathcal{A}</span> has performed <span class="math">q</span> queries to the random oracle <span class="math">\\mathsf{Hash}</span> and assume without loss of generality that <span class="math">\\mathcal{A}</span> has queried the random oracle on <span class="math">(\\mathsf{com}_{\\bm{f}},z,\\mathsf{com}_{\\bm{v}})</span>, obtaining <span class="math">r</span>, the scalar involved in the inner-product argument. Parse <span class="math">\\mathsf{com}_{\\bm{f}}</span> as <span class="math">(k,G,H)</span>. <span class="math">\\mathcal{E}</span> can leverage the extractor of the inner-product argument to obtain <span class="math">\\bm{\\mu}\\in\\mathbb{G}_{1}^{k}</span> such that <span class="math">\\langle\\bm{\\mu},\\bm{\\tau}[:k]\\rangle=G</span> and <span class="math">\\langle\\bm{\\mu},\\bm{\\tilde{\\tau}}[:k]\\rangle=H</span>, and <span class="math">\\langle\\bm{r},\\bm{\\mu}\\rangle=\\hat{\\mu}</span>. Furthermore, <span class="math">\\mathcal{E}</span> can run the knowledge soundness extractor of <span class="math">\\Psi</span> to obtain a polynomial <span class="math">\\hat{f}</span> such that <span class="math">\\hat{f}(z)=\\hat{v}</span> and <span class="math">\\hat{\\mu}=\\Psi.\\mathsf{Commit}(\\mathsf{ck}_{\\Psi},\\hat{f})</span>. Additionally, <span class="math">\\mathcal{E}</span> can run the knowledge extractor of the given proof of relation (3) to obtain a vector <span class="math">\\bm{v}</span> such that <span class="math">\\mathsf{Commit\\text{-}Evals}(\\bm{v})=\\mathsf{com}_{\\bm{v}}</span> and <span class="math">\\langle\\bm{r_{i}},\\bm{v}\\rangle=\\hat{v}</span>, for every <span class="math">i\\in[k]</span>, where <span class="math">\\bm{r}=(1,r,\\ldots,r^{k-1})</span>. If the total running time of the above extractors is <span class="math">t</span>, by the generalized Forking Lemma <em>[x21, x1]</em>, <span class="math">\\mathcal{E}</span> can run the above extraction <span class="math">k</span> times, on <span class="math">k</span> different <span class="math">r_{i}</span>, obtaining <span class="math">k</span> different tuples <span class="math">(\\bm{\\mu_{i}}\\in\\mathbb{G}_{1}^{k},\\hat{f}_{i}\\in\\mathbb{Z}_{p}[X],\\bm{v_{i}}\\in\\mathbb{Z}_{p}^{k})</span>, such that for every <span class="math">i\\in[k]</span>:</p>

    <p class="text-gray-300"><span class="math">\\langle\\bm{\\mu_{i}},\\bm{\\tau}\\rangle=\\mathsf{com}_{\\bm{f}}\\quad\\wedge\\quad\\langle\\bm{r_{i}},\\bm{v_{i}}\\rangle=\\hat{f}_{i}(z)\\quad\\wedge\\quad\\mathsf{Commit\\text{-}Evals}(\\bm{v_{i}})=\\mathsf{com}_{\\bm{v}}\\quad\\wedge\\quad\\langle\\bm{r_{i}},\\bm{\\mu_{i}}\\rangle=\\Psi.\\mathsf{Commit}(\\mathsf{ck}_{\\Psi},\\hat{f}_{i})\\enspace.</span></p>

    <p class="text-gray-300">The expected running time of such extraction is <span class="math">\\mathcal{O}(kqt/\\delta)</span>, which is polynomial since <span class="math">\\delta</span> is non-negligible and <span class="math">\\mathcal{A}</span> runs in polynomial-time. Now, given that function <span class="math">\\mathsf{Com}</span> is binding, it must be <span class="math">\\bm{\\mu_{i}}=\\bm{\\mu_{j}}</span> for all <span class="math">i,j\\in[k]</span>. Similarly, since <span class="math">\\mathsf{Commit\\text{-}Evals}</span> is binding, we must have <span class="math">\\bm{v_{i}}=\\bm{v_{j}}</span> for every <span class="math">i,j\\in[k]</span>. So <span class="math">\\mathcal{E}</span> ended up with vectors <span class="math">\\bm{\\mu}\\in\\mathbb{G}_{1}^{k}</span> and <span class="math">\\bm{v}\\in\\mathbb{Z}_{p}^{k}</span> such that for every <span class="math">i\\in[k]</span>:</p>

    <p class="text-gray-300"><span class="math">\\langle\\bm{r_{i}},\\bm{v}\\rangle=\\hat{f}_{i}(z)\\quad\\wedge\\quad\\langle\\bm{r_{i}},\\bm{\\mu}\\rangle=\\Psi.\\mathsf{Commit}(\\mathsf{ck}_{\\Psi},\\hat{f}_{i})\\enspace,</span></p>

    <p class="text-gray-300">for <span class="math">k</span> different <span class="math">\\bm{r_{i}}</span>. Let <span class="math">R</span> be the Vandermonde matrix formed by vectors <span class="math">\\bm{r_{i}}</span> for every <span class="math">i\\in[k]</span>, which is invertible given that <span class="math">r_{i}\\neq r_{j}</span> for different <span class="math">i</span>, <span class="math">j</span>. And let <span class="math">\\bm{\\hat{f}}\\coloneqq(\\hat{f}_{1},\\ldots,\\hat{f}_{k})</span>. We have:</p>

    <p class="text-gray-300"><span class="math">R\\bm{v}=\\bm{\\hat{f}}(z)\\wedge R\\bm{\\mu}=\\Psi.\\mathsf{Commit}(\\mathsf{ck}_{\\Psi},\\bm{\\hat{f}})\\qquad\\text{ or equivalently }\\qquad\\bm{v}=R^{-1}\\bm{\\hat{f}}(z)\\wedge\\bm{\\mu}=R^{-1}\\Psi.\\mathsf{Commit}(\\mathsf{ck}_{\\Psi},\\bm{\\hat{f}})\\enspace,</span></p>

    <p class="text-gray-300">where <span class="math">\\Psi.\\mathsf{Commit}(\\mathsf{ck}_{\\Psi},\\bm{\\hat{f}})</span> is a shorthand for the column vector <span class="math">(\\Psi.\\mathsf{Commit}(\\mathsf{ck}_{\\Psi},\\hat{f}_{1}),\\ldots,\\Psi.\\mathsf{Commit}(\\mathsf{ck}_{\\Psi},\\hat{f}_{k}))</span>. Extractor <span class="math">\\mathcal{E}</span> will output <span class="math">\\bm{f}=R^{-1}\\bm{\\hat{f}}</span>, which satisfies <span class="math">\\bm{f}(z)=\\bm{v}</span> and, by the homomorphic property of <span class="math">\\Psi</span>, <span class="math">\\bm{\\mu}=\\Psi.\\mathsf{Commit}(\\mathsf{ck}_{\\Psi},\\bm{f})</span>, where <span class="math">\\langle\\bm{\\mu},\\bm{\\tau}[:k]\\rangle=G</span> and <span class="math">\\langle\\bm{r},\\bm{\\mu}\\rangle=\\hat{\\mu}</span>, so <span class="math">\\mathsf{Commit\\text{-}Polys}(\\mathsf{ck},\\bm{f})=\\mathsf{com}_{\\bm{f}}</span> as desired.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">C.2 Proof of Theorem 2</p>

    <p class="text-gray-300">Theorem 2 establishes that the scheme described in Figure 4 constitutes a <em>SNARK</em> for relation:</p>

    <p class="text-gray-300"><span class="math">\\mathrm{PoK}\\left\\{\\ \\{\\bm{w}_{i}\\in\\mathbb{Z}_{p}^{m-\\ell}\\}_{i\\in[k]}\\ :\\ (\\bm{x_{i}},\\bm{w_{i}})\\in\\mathbb{Z}_{p}^{m}\\ \\text{satisfies}\\ \\mathcal{C}\\ \\ \\forall i\\in[k]\\ \\right\\}\\enspace,</span></p>

    <p class="text-gray-300">if <span class="math">\\Psi</span> is a complete, binding and knowledge sound multi-polynomial commitment scheme and <span class="math">\\mathsf{Hash}:\\{0,1\\}^{*}\\to\\mathbb{Z}_{p}</span> is a random oracle.</p>

    <p class="text-gray-300">We first establish the following helper lemma.</p>

    <h6 id="sec-65" class="text-base font-medium mt-4">Lemma 6.</h6>

    <p class="text-gray-300">Let <span class="math">\\bm{E}</span> be a vector of <span class="math">m</span> multi-variate linear polynomials on <span class="math">n</span> variables over <span class="math">\\mathbb{Z}_{p}</span>. Let <span class="math">k\\in\\mathbb{N}</span> and <span class="math">\\bm{x_{i}}\\in\\mathbb{Z}_{p}^{n}</span> for <span class="math">i\\in[k]</span>. If <span class="math">\\Pr[\\delta\\leftarrow\\mathbb{Z}_{p}:\\ \\bm{E}(\\sum_{i\\in[k]}\\delta^{i-1}\\bm{x_{i}})=\\bm{0}]</span> is non-negligible, then <span class="math">\\bm{E}(\\bm{x_{i}})=\\bm{0}</span> for all <span class="math">i\\in[k]</span>.</p>

    <h6 id="sec-66" class="text-base font-medium mt-4">Proof (by contrapositive).</h6>

    <p class="text-gray-300">Assume there exist <span class="math">i^{<em>}\\in[k]</span> and <span class="math">j^{</em>}\\in[m]</span> such that <span class="math">E_{j^{<em>}}(\\bm{x_{i^{</em>}}})\\neq\\bm{0}</span>. Define <span class="math">P(\\Delta)\\coloneqq E_{j^{<em>}}(\\sum_{i\\in[k]}\\Delta^{i-1}\\bm{x_{i}})</span>. By linearity, it holds that <span class="math">P(\\Delta)=\\sum_{i\\in[k]}\\Delta^{i-1}E_{j^{</em>}}(\\bm{x_{i^{<em>}}})</span>, so <span class="math">P</span> is a non-zero polynomial given that <span class="math">E_{j^{</em>}}(\\bm{x_{i^{*}}})</span> is different from <span class="math">0</span>. Thus, <span class="math">P</span> will not vanish on a uniformly sampled <span class="math">\\delta</span> except with negligible probability. ∎</p>

    <h6 id="sec-67" class="text-base font-medium mt-4">Proof (of Theorem 2).</h6>

    <p class="text-gray-300">Correctness can be checked by inspection. To show knowledge soundness we need to build an extractor which can produce valid witnesses for all the atomic statements from the interaction with a successful <span class="math">a\\mathcal{P}lon\\mathcal{K}</span> prover. We rely on the knowledge soundness extractor of <span class="math">\\mathcal{P}lon\\mathcal{K}</span> <em>[x10]</em>. Note that the scheme from Figure 4 is essentially the original <span class="math">\\mathcal{P}lon\\mathcal{K}</span> construction with the following modifications:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The Fiat-Shamir random challenges <span class="math">\\alpha,\\beta,\\gamma,\\xi</span> are shared across all proofs.</li>

      <li>The <span class="math">\\mathsf{T}</span> polynomial is common for all proofs.</li>

      <li>We use a shared permutation argument, thus there is a common polynomial <span class="math">\\mathsf{Z}</span> for all proofs with respect to the same <span class="math">\\mathcal{P}lon\\mathcal{K}</span> constraint system.</li>

      <li>We use a multi-polynomial commitment scheme instead of a standard polynomial commitment scheme.</li>

      <li>The polynomial evaluations on <span class="math">\\xi</span> (and <span class="math">\\omega\\xi</span>) are not included in the proof. Instead, we include a commitment to them, together with a meta-verification proof of the relation from Figure 5.</li>

    </ol>

    <p class="text-gray-300">As explained in Section 4.1, the <span class="math">\\mathcal{P}lon\\mathcal{K}</span> extractor can be easily modified to support modifications (1)-(2), by extracting a witness for each of the statements when fixing all others.</p>

    <p class="text-gray-300">The shared permutation argument in modification (3) guarantees that a random linear combination of the wires of each proof (through powers of a uniformly sampled random value <span class="math">\\delta</span>) meets the copy-satisfiability constraints of permutation <span class="math">\\sigma</span>. If that is the case with overwhelming probability over the choice of <span class="math">\\delta</span>, then by virtue of Lemma 6, each of the wire evaluations of every individual statement being proved also meets the copy-satisfiability constraints. Thus applying the standard <span class="math">\\mathcal{P}lon\\mathcal{K}</span> on a proof that satisfies the shared permutation argument will result in an extracted set of witnesses that meets the copy-satisfiability constraints as desired.</p>

    <p class="text-gray-300">Modification (4) is minimal from the extractor point of view. Note that <span class="math">\\mathcal{P}lon\\mathcal{K}</span>’s extractor relies on the definition of “knowledge soundness in the algebraic group model” from <em>[x10, Section 3]</em>, a unified security notion that captures extractability and the binding property at the same time. Such definition is the basis of <span class="math">\\mathcal{P}lon\\mathcal{K}</span>’s extractor (then formalized through so-called polynomial protocols). Note that our <em>binding property</em> (on Commit-Polys) and <em>knowledge soundness</em> for multi-polynomial commitments (Section 3) together, imply such definition, which guarantees that the same extractor can be used after modification (4).</p>

    <p class="text-gray-300">Finally, note that modification (5) can be addressed as follows. We can use the extractor of the meta-verification proof for relation <span class="math">\\mathcal{R}_{n,k}((\\alpha,\\beta,\\gamma,\\delta,\\xi,\\nu_{\\mathsf{w}},\\nu_{\\mathsf{z}},\\nu_{\\mathsf{z}},\\nu_{\\mathsf{t}},\\nu_{\\mathsf{pp}},\\{\\bm{x_{j}}\\}_{j\\in[k]})</span>, <span class="math">\\cdot</span> ) (see Figure 5) to obtain evaluations <span class="math">(\\{\\mathsf{a}_{j},\\mathsf{b}_{j},\\mathsf{c}_{j}\\}_{j\\in[k]},\\mathsf{z},\\bar{\\mathsf{z}},\\mathsf{t},\\mathsf{e}_{\\mathsf{q}_{i}},\\mathsf{e}_{\\mathsf{q}_{k}},\\mathsf{e}_{\\mathsf{q}_{0}},\\mathsf{e}_{\\mathsf{q}_{\\mathsf{M}}},\\mathsf{e}_{\\mathsf{q}_{\\mathsf{C}}},\\mathsf{e}_{\\mathsf{s}_{i}},\\mathsf{e}_{\\mathsf{s}_{i}},\\mathsf{e}_{\\mathsf{s}_{i}})</span> that satisfy all identities and are the actual evaluation of the corresponding committed polynomials at <span class="math">\\xi</span> (and <span class="math">\\omega\\xi</span> in the case of <span class="math">\\bar{\\mathsf{z}}</span>), as ensured by the multi-polynomial commitment <em>binding property</em> (on Commit-Evals) and the <em>knowledge soundness</em>. Such extracted evaluations thus satisfy all the properties that are verified in a standard <span class="math">\\mathcal{P}lon\\mathcal{K}</span> proof and can consequently be used by the standard <span class="math">\\mathcal{P}lon\\mathcal{K}</span> extractor. ∎</p>

    <h2 id="sec-68" class="text-2xl font-bold">Appendix</h2>`;
---

<BaseLayout title="aPlonK : Aggregated PlonK from Multi-Polynomial Commitment S... (2022/1352)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2022 &middot; eprint 2022/1352
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
