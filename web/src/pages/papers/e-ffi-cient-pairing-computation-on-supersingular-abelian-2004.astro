---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2004/375';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-17';
const TITLE_HTML = 'Efficient Pairing Computation on Supersingular Abelian Varieties';
const AUTHORS_HTML = 'Paulo S.  L.  M.  Barreto, Steven Galbraith, Colm O hEigeartaigh, Michael Scott';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">We present a general technique for the efficient computation of pairings on supersingular Abelian varieties.  This formulation, which we call the eta pairing, generalises results of Duursma and Lee for computing the Tate pairing on supersingular elliptic curves in characteristic three.

We then show how our general technique leads to a new algorithm which is about twice as fast as the Duursma-Lee method.

These ideas are then used for elliptic and hyperelliptic curves in characteristic 2 with very efficient results. In particular, the hyperelliptic case is faster than all previously known pairing algorithms.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> Tate pairing &middot; supersingular curves &middot; pairing-based cryptosystem &middot; efficient algorithms</p>
    </section>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 The Tate pairing on supersingular curves</h2>

    <p class="text-gray-300">Let C be a smooth, projective, absolutely irreducible curve over a finite field  <span class="math">K = \\mathbb{F}_{q^k}</span> . We denote the degree zero divisor class group of C over K by  <span class="math">\\operatorname{Pic}_0^K(C)</span> . Let r be an integer such that  <span class="math">r \\mid \\#\\operatorname{Pic}_0^K(C)</span> . We denote by  <span class="math">\\operatorname{Pic}_0^K(C)[r]</span>  the divisor classes of order dividing r.</p>

    <p class="text-gray-300">Let  <span class="math">D_1</span>  be a divisor representing a class in  <span class="math">\\operatorname{Pic}_0^K(C)[r]</span>  and let  <span class="math">D_2</span>  be a divisor on C defined over K such that the supports of  <span class="math">D_1</span>  and  <span class="math">D_2</span>  are disjoint. Since  <span class="math">rD_1</span>  is principal there is a function f on C defined over K such that  <span class="math">(f) = rD_1</span> . The Tate pairing (also called the Tate-Lichtenbaum pairing) is</p>

    <p class="text-gray-300"><span class="math">$\\langle D_1, D_2 \\rangle_r = f(D_2).</span>$</p>

    <p class="text-gray-300">One can show (see Frey and R&uuml;ck [14]) that the Tate pairing is a well-defined, non-degenerate, bilinear pairing</p>

    <p class="text-gray-300"><span class="math">$\\operatorname{Pic}_0^K(C)[r] \\times \\operatorname{Pic}_0^K(C)/r\\operatorname{Pic}_0^K(C) \\to K^*/(K^*)^r</span>$
.</p>

    <p class="text-gray-300">The fact that the Tate pairing is only defined up to r-th powers is often undesirable. To obtain a unique value, one defines the reduced pairing</p>

    <p class="text-gray-300"><span class="math">$e(D_1, D_2) = \\langle D_1, D_2 \\rangle_r^{(q^k - 1)/r}</span>$</p>

    <p class="text-gray-300">Throughout the paper we will refer to the extra powering required to compute the reduced pairing as the <em>final exponentiation</em>.</p>

    <p class="text-gray-300">One very important property of the reduced pairing is the following [15]. Let N = hr for some h.</p>

    <p class="text-gray-300"><span class="math">$e(D_1, D_2) = \\langle D_1, D_2 \\rangle_r^{(q^k - 1)/r} = \\langle D_1, D_2 \\rangle_N^{(q^k - 1)/N}.</span>$
(1)</p>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8">2.1 Miller's algorithm in the elliptic case</h3>

    <p class="text-gray-300">We recall how the Tate pairing can be computed in polynomial time using Miller's algorithm [24]. For simplicity we restrict to the case of elliptic curves. The divisor class group of an elliptic curve is isomorphic to the curve itself, so all divisors may be assumed to have the form  <span class="math">D = (P) - (\\infty)</span> .</p>

    <p class="text-gray-300">Let E be an elliptic curve over  <span class="math">\\mathbb{F}_q</span>  and let  <span class="math">r \\mid \\#E(\\mathbb{F}_q)</span>  be a prime. Suppose the embedding degree is k (i.e., k is the smallest positive integer such that  <span class="math">r \\mid (q^k - 1)</span> ). Let  <span class="math">P \\in E[r]</span>  and  <span class="math">Q \\in E(\\mathbb{F}_{q^k})</span> , where typically Q is the image of some multiple of P under a non-rational endomorphism called a distortion map. We construct an  <span class="math">\\mathbb{F}_{q^k}</span> -rational divisor P equivalent to P0 by taking a random point P1 and defining P2 and defining P3. We aim to compute</p>

    <p class="text-gray-300"><span class="math">$e(P, Q) = e((P) - (\\infty), D).</span>$</p>

    <p class="text-gray-300">For every integer n and point P there is a function  <span class="math">f_{n,P}</span>  such that</p>

    <p class="text-gray-300"><span class="math">$(f_{n,P}) = n(P) - ([n]P) - (n-1)(\\infty).</span>$</p>

    <p class="text-gray-300">Miller's algorithm builds up these functions  <span class="math">f_{n,P}</span>  according to the following formula: If l and v are the lines which arise in the addition rule for adding [n]P and [m]P then we have</p>

    <p class="text-gray-300"><span class="math">$f_{n+m,P} = f_{n,P} f_{m,P} l/v</span>$
.</p>

    <p class="text-gray-300">The pairing value  <span class="math">\\langle (P) - (\\infty), D \\rangle_r</span>  is  <span class="math">f_{r,P}(D)</span> .</p>

    <p class="text-gray-300">Miller's algorithm is explicitly described in Algorithm 1. Note that the addition in the final iteration is simplified in that l is a vertical line and v disappears.</p>

    <p class="text-gray-300">Miller's algorithm can be generalised to general divisor class groups. The basic algorithm is the same, but the functions are more complicated.</p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8">2.2 Improvements to Miller's algorithm</h3>

    <p class="text-gray-300">Several improved implementation techniques to compute the reduced Tate pairing on supersingular elliptic curves have been proposed [3, 15]. These include:</p>

    <p class="text-gray-300"><strong>Exploiting properties of the field of definition:</strong> It is typical in pairing applications to pair a point defined over  <span class="math">\\mathbb{F}_q</span>  with a point defined over  <span class="math">\\mathbb{F}_{q^k}</span> . Hence it makes sense to represent  <span class="math">\\mathbb{F}_{q^k}</span>  as an extension of  <span class="math">\\mathbb{F}_q</span>  and to try to simplify the operations in  <span class="math">\\mathbb{F}_{q^k}</span>  as much as possible.</p>

    <p class="text-gray-300">The final exponentiation eliminates terms defined over subfields. Hence, terms defined over subfields can be omitted from the calculations. For example, if k &gt; 1 then the point R can be chosen to be defined over a subfield, in which case all terms l(R) and v(R) may be ignored.</p>

    <h4 id="sec-misc-1" class="text-lg font-semibold mt-6">Algorithm 1 Miller's algorithm (base 2)</h4>

    <pre><code class="language-text">INPUT: r, P, Q + R, R, where the binary representation of r is \\{r_i\\}.
OUTPUT: \\langle P, Q \\rangle_r
 1: T \\leftarrow P
 2: f \\leftarrow 1
 3: for i \\leftarrow \\lfloor \\log_2(r) \\rfloor - 1 downto 0 do
          \\triangleright Calculate lines l and v in doubling T
 5:
           T \\leftarrow \\lceil 2 \\rceil T
           f \\leftarrow f^2 \\cdot l(Q+R)v(R)/(v(Q+R)l(R))
 6:
           if r_i = 1 then
 7:
                \\triangleright Calculate lines l and v in adding P to T
 8:
 9:
                 T \\leftarrow T + P
10:
                 f \\leftarrow f \\cdot l(Q + R)v(R)/((v(Q + R)l(R))
11:
12: end for
13: return f
</code></pre>

    <p class="text-gray-300"><strong>Changing the base in Miller's algorithm:</strong> Miller's algorithm is usually presented as a loop through the binary expansion of the group order. It is sometimes more efficient to use other bases, for example to write the group order in base three when implementing pairings in characteristic three (in which case, in line 6 of Miller's algorithm above, we change  <span class="math">f^2</span>  to  <span class="math">f^3</span>  and there are now two cases in the addition step).</p>

    <p class="text-gray-300"><strong>Replacing divisors by points:</strong> As explained above, the point R can be ignored. In fact, one can choose  <span class="math">R = \\infty</span>  by [3, Theorem 1]. Hence, the reduced pairing can be computed as</p>

    <p class="text-gray-300"><span class="math">$e(P, O) = f_{r,P}(O)^{(q^k-1)/r}</span>$</p>

    <p class="text-gray-300">where the function  <span class="math">f_r</span>  is now evaluated on a <em>point</em> rather than on a divisor.</p>

    <p class="text-gray-300"><strong>Exploiting the form of the distortion maps and denominator elimination:</strong> If the distortion map is chosen so that the <em>x</em>-coordinates always lies in a subfield, then all terms v(Q) may be eliminated. As a result there are no longer any divisions in Miller's algorithm.</p>

    <p class="text-gray-300">Note that a distortion map with this property can always be obtained by combining with a map into the trace zero subgroup (see [27] for an example of this).</p>

    <p class="text-gray-300"><strong>Hamming weight/group order issues:</strong> Miller's algorithm to compute  <span class="math">f_r</span>  involves a number of arithmetic operations proportional to the Hamming weight of r, and for this reason it is advantageous to choose r with low Hamming weight (with respect to the base being used) whenever possible. In many cases it is worth using a small multiple of r which has low Hamming weight and exploiting formula (1).</p>

    <p class="text-gray-300"><strong>Speeding up the final exponentiation:</strong> The naive way to compute the final powering to  <span class="math">(q^k - 1)/N</span>  (for some multiple N of r) has cubic complexity. However, this exponent</p>

    <p class="text-gray-300">has a rather simple structure for supersingular curves when one chooses N to be the full curve order rather than a factor r thereof. By carefully exploiting that structure, one can replace the powering by a few applications of the Frobenius, some multiplications, and one inversion. Details can be found in [3, Appendix A.2].</p>

    <p class="text-gray-300"><strong>Pairing value compression:</strong> It is possible to reduce the bandwidth requirements of pairing values by storing and manipulating traces [28], or by working on a torus [17]. These methods compress pairing values to half their usual size, or to a third thereof in the case of supersingular elliptic curves with embedding degree 6 in characteristic 3, supersingular genus 2 curves with embedding degree 12 in characteristic 2, or ordinary BN elliptic curves [5] with embedding degree 12 in large prime characteristic.</p>

    <p class="text-gray-300">The techniques mentioned above give impressive results for pairing implementation. For the remainder of the paper we focus on further improvements. We consider only supersingular curves over  <span class="math">\\mathbb{F}_q</span>  with embedding degree k &gt; 1 and with suitable distortion maps  <span class="math">\\psi</span> . We will always be computing a modified pairing</p>

    <p class="text-gray-300"><span class="math">$\\hat{e}_r(P,Q) = \\langle P, \\psi(Q) \\rangle_r</span>$</p>

    <p class="text-gray-300">where P and Q are defined over  <span class="math">\\mathbb{F}_q</span> , or its reduced version  <span class="math">\\hat{e}(P,Q) = \\hat{e}_r(P,Q)^{(q^k-1)/r}</span> .</p>

    <p class="text-gray-300">Duursma and Lee [10] gave a significant improvement to the computation of pairings on curves of the form  <span class="math">y^2 = x^p - x + d</span>  over  <span class="math">\\mathbb{F}_{p^m}</span>  where  <span class="math">p \\ge 3</span>  and (m, 2p) = 1 (these curves have embedding degree 2p). In particular, their results apply to the case of the embedding degree 6 curve in characteristic three.</p>

    <p class="text-gray-300">One crucial aspect of [10] is that they replace the group order r by the value  <span class="math">p^{mp} + 1</span>  which has Hamming weight 2 in base p. Also, the final exponentiation is to the power  <span class="math">(p^{2mp} - 1)/(p^{pm} + 1) = p^{mp} - 1</span> , which is simply computing a Frobenius conjugation and a division. Hence, both the final exponentiation and the main body of Miller's algorithm are simplified, at the expense of extending the main loop from m iterations to mp iterations. Duursma and Lee show the surprising fact that this loop can be shortened from mp iterations to m iterations.</p>

    <p class="text-gray-300">A careful reading of [10] shows that it contains four independent contributions:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A nice choice of function for computing pD in the divisor class group;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The definition of a pairing on <em>points</em> (in g &gt; 1). In other words, they propose the use of degenerate divisors rather than general divisors;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A shorter loop than would be expected for the given group order;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Incorporating Frobenius operations directly into the formulae (this has a huge saving, since it removes the exponentiation of <em>f</em> to the power <em>p</em> in line 6 of Miller's algorithm).</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Generalising points 1, 2 and 4 is relatively straightforward. In this paper we show how to generalise the loop shortening idea to many other cases.</p>

    </section>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 The eta pairing approach</h2>

    <p class="text-gray-300">Let C be a curve over  <span class="math">\\mathbb{F}_q</span>  (where  <span class="math">q=p^m</span> ) with a single point at infinity. In all the examples in this paper, C will be an elliptic or hyperelliptic curve. We will always assume that C is supersingular, with even embedding degree k&gt;1, and that there is a distortion map  <span class="math">\\psi</span>  which allows denominator elimination (i.e., if  <span class="math">P \\in C(\\mathbb{F}_q)</span>  then  <span class="math">\\psi(P) \\in C(\\mathbb{F}_{q^k})</span>  has x-coordinate defined over  <span class="math">\\mathbb{F}_{q^{k/2}}</span> ).</p>

    <p class="text-gray-300">Let D, D' be reduced divisors on C defined over  <span class="math">\\mathbb{F}_q</span>  which represent divisor classes of order dividing N. In all examples in this paper, these divisors will be represented using the Mumford notation (see Cantor [8]) which, in the elliptic curve case, corresponds to just a single point. Let  <span class="math">M = (q^k - 1)/N</span> . We want to efficiently compute the Tate pairing (including the final exponentiation)  <span class="math">\\langle D, \\psi(D&#x27;) \\rangle_N^M</span> .</p>

    <p class="text-gray-300">Let  <span class="math">n \\in \\mathbb{N}</span> . We use the notation  <span class="math">D_n</span>  for a reduced divisor equivalent to nD and  <span class="math">f_{n,D}</span>  for a function whose divisor is  <span class="math">nD - D_n - m(\\infty)</span>  for some  <span class="math">m \\in \\mathbb{N}</span> . In the elliptic case we have  <span class="math">D = (P) - (\\infty)</span>  and so  <span class="math">D_n = (nP) - (\\infty)</span>  and  <span class="math">f_{n,D}</span>  is the Miller function introduced in subsection 2.1 . If  <span class="math">n \\in \\mathbb{Z}</span>  with n &lt; 0 then nD = (-n)(-D). We therefore write  <span class="math">D_n</span>  for a divisor equivalent to (-n)(-D) and write  <span class="math">f_{n,D}</span>  for a function with divisor  <span class="math">(-n)(-D) - (D_n) - m(\\infty)</span>  for some m. The Tate pairing is defined to be  <span class="math">\\langle D, D&#x27; \\rangle_N = f_{N,D}(D&#x27;)</span> .</p>

    <p class="text-gray-300">An important observation is that, for many supersingular curves, multiplication by p has an extremely special form. This has already been exploited by many authors. In this paper we will be concerned with cases where multiplication by some power of p can be represented by an automorphism on the curve (which we will call  <span class="math">\\gamma</span> ).</p>

    <p class="text-gray-300"><strong>Definition 1.</strong> For  <span class="math">T \\in \\mathbb{Z}</span>  we define the eta pairing to be</p>

    <p class="text-gray-300"><span class="math">$\\eta_T(D, D&#x27;) = f_{T,D}(\\psi(D&#x27;)).</span>$
(2)</p>

    <p class="text-gray-300">In general, this definition will not give a non-degenerate, bilinear pairing. The aim of this paper is to explain some cases where the resulting pairing is non-degenerate and bilinear. The key property of the eta pairing is that we do not necessarily demand that TD is equivalent to zero. The aim is to choose values of T which are smaller than N. This is a generalisation of the loop reduction idea of Duursma and Lee.</p>

    <p class="text-gray-300">As we will see, the Duursma-Lee method arises from the choice T=q in the above definition while our improved version uses the choice T=q-N. In the later part of the paper, when discussing running times, we will drop the subscript in the case T=q and refer to the pairing as  <span class="math">\\eta</span> . Hence, the notation  <span class="math">\\eta_T</span>  will generally be reserved for the improved version.</p>

    <p class="text-gray-300">The following theorem is the main result of this paper. It relates the eta pairing to the Tate pairing for certain values of T. From this relation one immediately deduces (as long as L, a and T are coprime to N) that the eta pairing (for these values of T) is non-degenerate and bilinear.</p>

    <p class="text-gray-300"><strong>Theorem 1.</strong> Let C be a supersingular curve over  <span class="math">\\mathbb{F}_q</span>  with distortion map  <span class="math">\\psi</span>  and embedding degree k as above. Let D be a divisor on C defined over  <span class="math">\\mathbb{F}_q</span>  with order dividing  <span class="math">N \\in \\mathbb{N}</span>  and let  <span class="math">M = (q^k - 1)/N</span> . Suppose  <span class="math">T \\in \\mathbb{Z}</span>  is such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">TD \\equiv \\gamma(D)</span>  in the divisor class group where  <span class="math">\\gamma</span>  is an automorphism of C which is defined over  <span class="math">\\mathbb{F}_q</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\gamma</span>  and  <span class="math">\\psi</span>  satisfy the condition<sup>4</sup></li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\gamma \\psi^q(Q) = \\psi(Q) \\tag{3}</span>$</p>

    <p class="text-gray-300">for all points  <span class="math">Q \\in C(\\mathbb{F}_q)</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">T^a + 1 = LN</span>  for some  <span class="math">a \\in \\mathbb{N}</span>  and  <span class="math">L \\in \\mathbb{Z}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>T = q + cN for some  <span class="math">c \\in \\mathbb{Z}</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Then</p>

    <p class="text-gray-300"><span class="math">$\\left(\\langle D, \\psi(D&#x27;) \\rangle_N^M \\right)^L = (\\eta_T(D, D&#x27;)^M)^{aT^{a-1}}.</span>$</p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 Proof of Theorem 1</h3>

    <p class="text-gray-300">We split the proof into a number of lemmas.</p>

    <p class="text-gray-300">First note that, since TD is equivalent to  <span class="math">\\gamma(D)</span>  we have  <span class="math">D_{T^i} = \\gamma^i(D)</span> . Write d for the degree of the finite part of D. Then  <span class="math">D = \\sum_{j=1}^{d} (P_j) - d(\\infty)</span>  and so  <span class="math">D_{T^i} = \\sum_{j=1}^{d} (\\gamma^i(P_j)) - d(\\infty)</span> .</p>

    <p class="text-gray-300">The key result is the following.</p>

    <p class="text-gray-300"><strong>Lemma 1.</strong> With notation as above and D any divisor such that TD is equivalent to  <span class="math">\\gamma(D)</span> . Then</p>

    <p class="text-gray-300"><span class="math">$f_{T,D}(\\psi(D&#x27;))^{TM} = f_{T,TD}(\\psi(D&#x27;))^{M}.</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> We have  <span class="math">(f_{T,D}) = TD - D_T - (T-1)d(\\infty)</span>  and  <span class="math">(f_{T,D}^T) = T(f_{T,D})</span>  and  <span class="math">(f_{T,TD}) = TD_T - D_{T^2} - (T-1)d(\\infty)</span> .</p>

    <p class="text-gray-300">We now use the assumption that  <span class="math">TD \\equiv D_T = \\gamma(D)</span> . The pullback (see Silverman [30] Chapter II page 33) satisfies</p>

    <p class="text-gray-300"><span class="math">$\\gamma^*\\left(\\sum_P n_P(P)\\right) = \\sum_P \\sum_{S \\in \\gamma^{-1}(P)} n_P e_\\gamma(S)(S) = \\sum_P n_P(\\gamma^{-1}(P)).</span>$</p>

    <p class="text-gray-300">Hence</p>

    <p class="text-gray-300"><span class="math">$\\gamma^*(f_{T,TD}) = \\gamma^*(TD_T - D_{T^2} - (T - 1)d(\\infty))</span>$</p>

    <p class="text-gray-300">=  <span class="math">TD - D_T - (T - 1)d(\\infty)</span>
=  <span class="math">(f_{T,D}).</span></p>

    <p class="text-gray-300">Also, (Silverman [30] pages 33-34)</p>

    <p class="text-gray-300"><span class="math">$\\gamma^*(f_{T,TD}) = (\\gamma^* f_{T,TD}) = (f_{T,TD} \\circ \\gamma).</span>$</p>

    <p class="text-gray-300">Hence, we have (up to a scalar multiple in  <span class="math">\\mathbb{F}_q^*</span> )</p>

    <p class="text-gray-300"><span class="math">$f_{T,TD} \\circ \\gamma = f_{T,D}</span>$
.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;4</sup> An alternative formulation of this condition is  <span class="math">\\gamma\\psi^{\\pi} = \\psi</span>  where  <span class="math">\\pi</span>  is the <em>q</em>-power Frobenius and  <span class="math">\\psi^{\\pi}</span>  means the map obtained by applying  <span class="math">\\pi</span>  to the coefficients of the map  <span class="math">\\psi</span> .</p>

    <p class="text-gray-300">Evaluating at  <span class="math">\\psi(D&#x27;)</span>  and raising to the power M (which kills  <span class="math">\\mathbb{F}_q^*</span> ) we get</p>

    <p class="text-gray-300"><span class="math">$f_{T,TD}(\\gamma(\\psi(D&#x27;)))^M = f_{T,D}(\\psi(D&#x27;)^M.</span>$</p>

    <p class="text-gray-300">Consider the left hand side of the statement of the Lemma</p>

    <p class="text-gray-300"><span class="math">$f_{T,D}(\\psi(D&#x27;))^{TM} = (f_{T,TD}(\\gamma(\\psi(D&#x27;)))^{TM}.</span>$</p>

    <p class="text-gray-300">Now use the fact that T = q + cN and that  <span class="math">NM = (q^k - 1)</span>  so anything raised to the power NM is 1. We therefore have that the above is equal to</p>

    <p class="text-gray-300"><span class="math">$(f_{T,TD}(\\gamma(\\psi(D&#x27;)))^{qM}.</span>$</p>

    <p class="text-gray-300">Interpreting a power of q as action by Frobenius and using the fact that  <span class="math">f_{T,TD}</span> ,  <span class="math">\\gamma</span>  and D' are defined over  <span class="math">\\mathbb{F}_q</span>  gives</p>

    <p class="text-gray-300"><span class="math">$(f_{TTD}(\\gamma(\\psi^q(D&#x27;)))^M</span>$
.</p>

    <p class="text-gray-300">By condition (3),  <span class="math">\\gamma \\psi^q = \\psi</span>  so we get</p>

    <p class="text-gray-300"><span class="math">$f_{T,TD}(\\psi(D&#x27;))^M</span>$</p>

    <p class="text-gray-300">which proves the result.</p>

    <p class="text-gray-300">Lemma 2. With notation as above</p>

    <p class="text-gray-300"><span class="math">$(f_{T^a,D}) = (f_{T,D}^{T^{a-1}} f_{T,TD}^{T^{a-2}} \\cdots f_{T,T^{a-1}D}).</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> We have  <span class="math">(f_{T^a,D}) = T^aD - D_{T^a} - (T^a - 1)d(\\infty)</span> . Hence</p>

    <p class="text-gray-300"><span class="math">$(f_{T,D}^{T^{a-1}} f_{T,TD}^{T^{a-2}} \\cdots f_{T,T^{a-1}D}) = T^{a-1}(f_{T,D}) + T^{a-2}(f_{T,TD}) + \\cdots + (f_{T,T^{a-1}D})</span>$</p>

    <p class="text-gray-300"><span class="math">$= T^{a-1}(TD - D_T - (T-1)d(\\infty)) + T^{a-2}(TD_T - D_{T^2} - (T-1)d(\\infty)) + \\cdots + TD_{T^{a-1}} - D_{T^a} - (T-1)d(\\infty)</span>$</p>

    <p class="text-gray-300"><span class="math">$= T^a D - D_{T^a} - (T^a - 1)d(\\infty)</span>$</p>

    <p class="text-gray-300">which proves the result.</p>

    <p class="text-gray-300">We can now obtain the statement of the theorem:</p>

    <p class="text-gray-300">Lemma 3. With notation as above</p>

    <p class="text-gray-300"><span class="math">$(f_{N,D}(\\psi(D&#x27;)))^{ML} = (f_{T,D}(\\psi(D&#x27;)))^{MaT^{a-1}}.</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> Note that  <span class="math">f_{N,D}^L = f_{LN,D} = f_{T^a+1,D}</span> . Since  <span class="math">T^a+1 = LN</span>  we know that  <span class="math">(T^a+1)D \\equiv 0</span> , which implies  <span class="math">T^aD \\equiv -D</span>  and so (up to scalar in  <span class="math">\\mathbb{F}_q^*</span> )</p>

    <p class="text-gray-300"><span class="math">$f_{T^a+1,D} = f_{T^a,D} \\cdot v</span>$</p>

    <p class="text-gray-300">where v is the vertical line through D and -D.</p>

    <p class="text-gray-300">Evaluating at  <span class="math">\\psi(D&#x27;)</span>  and raising to the power M we have (since  <span class="math">\\psi</span>  admits denominator elimination)</p>

    <p class="text-gray-300"><span class="math">$f_{N,D}(\\psi(D&#x27;))^{ML} = f_{T^a,D}(\\psi(D&#x27;))^M \\cdot v(\\psi(D&#x27;))^M = f_{T^a,D}(\\psi(D&#x27;))^M.</span>$</p>

    <p class="text-gray-300">By Lemma 2 this is</p>

    <p class="text-gray-300"><span class="math">$\\prod_{i=0}^{a-1} f_{T,T^{i}D}(\\psi(D&#x27;))^{MT^{a-1-j}}.</span>$</p>

    <p class="text-gray-300">Now, substituting  <span class="math">T^{j}D</span>  for D in Lemma 1 implies that</p>

    <p class="text-gray-300"><span class="math">$f_{T,T^{j}D}(\\psi(D&#x27;))^{MT^{a-1-j}} = f_{T,D}^{MT^{a-1}}.</span>$</p>

    <p class="text-gray-300">Hence the result follows.</p>

    <p class="text-gray-300">We first show how the eta pairing idea explains the loop shortening used by Duursma and Lee.</p>

    <p class="text-gray-300">The elliptic curve of interest<sup>5</sup> is  <span class="math">E: y^2 = x^3 - x + b</span>  over  <span class="math">\\mathbb{F}_{3^m}</span>  where  <span class="math">b = \\pm 1</span>  and gcd(m, 6) = 1. The number of points on this curve is given in Table 1. The tripling formula (see [11, 3]) is  <span class="math">[3](x, y) = \\phi \\pi^2(x, y)</span>  where  <span class="math">\\pi</span>  is the 3-power Frobenius and  <span class="math">\\phi(x, y) = (x - b, -y)</span> . Note that  <span class="math">\\phi^2(x, y) = (x - 2b, y)</span> ,  <span class="math">\\phi^3 = -1</span>  etc. The distortion map is  <span class="math">\\psi(x, y) = (\\rho - x, \\sigma y)</span>  where  <span class="math">\\sigma^2 = -1</span>  and  <span class="math">\\rho^3 = \\rho + b</span>  (and thus  <span class="math">\\rho^{3^2} = \\rho + 2b</span> ,  <span class="math">\\rho^{3^3} = \\rho</span> ).</p>

    <p class="text-gray-300"><strong>Table 1.</strong> Order of the curve  <span class="math">E: y^2 = x^3 - x + b</span>  over  <span class="math">\\mathbb{F}_{3^m}</span> ,  <span class="math">b = \\pm 1</span> .</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\#E(\\mathbb{F}_{3^m})</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">condition</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">3^m + 1 + b3^{(m+1)/2}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">m \\equiv 1, 11</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(mod 12)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">3^m + 1 - b3^{(m+1)/2}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">m \\equiv 5,7</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(mod 12)</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Let  <span class="math">q=3^m</span> . It follows that multiplication by [q] is  <span class="math">[q](x,y)=[3^m](x,y)=\\phi^m\\pi^{2m}(x,y)=\\phi^m(x,y)</span> . Hence we take  <span class="math">\\gamma=\\phi^m</span> .</p>

    <p class="text-gray-300"><strong>Lemma 4.</strong> With notation as above, condition (3) is satisfied.</p>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">q = 3^m</span>  with  <span class="math">m \\equiv 1 \\pmod{6}</span> . Suppose  <span class="math">(x, y) \\in E(\\mathbb{F}_q)</span> . Then  <span class="math">[q](x, y) = \\phi(x, y)</span>  and so  <span class="math">\\gamma = \\phi</span> . Now,  <span class="math">\\psi^q = \\psi^3</span>  and so</p>

    <p class="text-gray-300"><span class="math">$\\gamma \\psi^{q}(x, y) = \\phi(\\rho + b - x, -\\sigma y) = (\\rho + b - x - b, \\sigma y) = (\\rho - x, \\sigma y) = \\psi(x, y).</span>$</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;5</sup> Note that all supersingular curves in characteristic three have <em>j</em>-invariant 0 (by Theorem V.4.1 of [30]) and hence are isomorphic over  <span class="math">\\overline{\\mathbb{F}}_3</span>  ([30] Theorem A.1.2). It follows that all choices of supersingular equations over  <span class="math">\\mathbb{F}_{3^m}</span>  with fixed embedding degree k are equally secure for pairing applications and so there is no loss of generality from considering just this case.</p>

    <p class="text-gray-300">Similarly, when  <span class="math">m \\equiv 5 \\pmod{6}</span>  we have  <span class="math">\\gamma = \\phi^5 = -\\phi^2</span>  and  <span class="math">\\psi^q = -\\psi^{3^2}</span>  and so</p>

    <p class="text-gray-300"><span class="math">$\\gamma \\psi^{q}(x, y) = \\phi^{2}(\\rho + 2b - x, \\sigma y) = (\\rho + 2b - x - 2b, \\sigma y) = \\psi(x, y).</span>$</p>

    <p class="text-gray-300">This completes the proof.</p>

    <p class="text-gray-300">Since condition (3) is satisfied we may apply Theorem 1.</p>

    <p class="text-gray-300">The method of Duursma and Lee computes the eta pairing with respect to the value  <span class="math">T = q = 3^m</span> . In the notation of Theorem 1 we have  <span class="math">N = q^3 + 1</span> ,  <span class="math">M = q^3 - 1</span> , a = 3, L = 1 and c = 0. Hence, we have</p>

    <p class="text-gray-300"><span class="math">$\\left(\\eta_T(P,Q)^M\\right)^{3q^2} = \\langle P, \\psi(Q) \\rangle_N^M</span>$</p>

    <p class="text-gray-300">The formulae given in [10] computes the Tate pairing directly by bringing the powering to  <span class="math">3q^2</span>  into the formulae. Further efficiency is obtained in [10] by using the other three techniques mentioned in section 3.</p>

      <h3 id="sec-5.1" class="text-xl font-semibold mt-8">5.1 An improvement on Duursma and Lee</h3>

    <p class="text-gray-300">The power of the eta pairing approach is that one can immediately improve on the Duursma-Lee method giving a further halving of the length of the loop.</p>

    <p class="text-gray-300">We know that the number of points on  <span class="math">E(\\mathbb{F}_q)</span>  is  <span class="math">N = 3^m \\pm 3^{(m+1)/2} + 1</span>  and we have established that  <span class="math">[3^m]P = \\gamma(P)</span>  for some automorphism  <span class="math">\\gamma</span> . If  <span class="math">P \\in E(\\mathbb{F}_q)</span>  then, since  <span class="math">[N]P = \\infty</span> , we deduce that</p>

    <p class="text-gray-300"><span class="math">$[\\mp 3^{(m+1)/2} - 1]P = [q - N]P = [q]P = \\gamma(P).</span>$</p>

    <p class="text-gray-300">We can therefore choose  <span class="math">T=q-N=\\mp 3^{(m+1)/2}-1</span>  (when T is negative we use the relation TD=(-T)(-D)). In the notation of Theorem 1 we have c=-1. Taking a=3 gives  <span class="math">T^3+1=LN</span>  where  <span class="math">L=\\mp 3^{(m+3)/2}</span> . We have  <span class="math">M=(3^{6m}-1)/N</span> . Theorem 1 implies that the pairing satisfies</p>

    <p class="text-gray-300"><span class="math">$\\left(\\eta_T(P,Q)^M\\right)^{3T^2} = \\left(\\langle P, \\psi(Q) \\rangle_N^M\\right)^L</span>$</p>

    <p class="text-gray-300">and so, since 3, T and L are all coprime to N, it is bilinear and non-degenerate.</p>

    <p class="text-gray-300">With this method we can compute the Tate pairing using an algorithm with roughly half as many iterations as the original Duursma-Lee method. However, the final exponentiation is now more complicated since the value M required to obtain a unique pairing value is  <span class="math">(3^{3m} - 1)(3^m + 1)(3^m \\mp 3^{(m+1)/2} + 1)</span> . Unlike the original Duursma-Lee method, this value has terms which are not powers of  <span class="math">3^m</span> , hence an extra (m + 1)/2 cubings in the large field are required. Luckily, cubing is faster than a step in the loop of Miller's algorithm, so this approach does give faster code. Notice that the result of raising to  <span class="math">3^{3m} - 1</span>  produces a unitary value, so that any further inversion reduces to a simple conjugation.</p>

    <p class="text-gray-300">Further exponentiations are also required to transform the value of the eta pairing to a correct Tate pairing value, but the extra cost of these is not very significant (see the end of section 5.2). One possibility is to design cryptosystems using the eta pairing instead of the Tate pairing. On the other hand, for some applications there may be compatibility issues with using a 'non-standard' pairing and so the actual Tate pairing value may be required.</p>

      <h3 id="sec-5.2" class="text-xl font-semibold mt-8">5.2 Implementation details</h3>

    <p class="text-gray-300">We now give some of the implementation details for the eta pairing in this case. Recall from [10] that, for any point  <span class="math">V \\in E(\\mathbb{F}_a)</span>  the function</p>

    <p class="text-gray-300"><span class="math">$g_V(x, y) = y_V^3 y - (x_V^3 - x + b)^2</span>$</p>

    <p class="text-gray-300">has divisor  <span class="math">(g_V) = 3(V) + (-3V) - 4(\\infty)</span> .</p>

    <p class="text-gray-300">Consider the eta pairing of P and Q where  <span class="math">T = q - N = \\mp 3^{(m+1)/2} - 1</span> . If T &lt; 0 we first replace P by -P and T by -T. From Table 1 it follows that we have  <span class="math">T = 3^{(m+1)/2} + b</span>  when  <span class="math">m \\equiv 1, 11 \\pmod{12}</span>  and  <span class="math">T = 3^{(m+1)/2} - b</span>  when  <span class="math">m \\equiv 5, 7 \\pmod{12}</span> .</p>

    <p class="text-gray-300">We are required to compute</p>

    <p class="text-gray-300"><span class="math">$f_{T,P}(\\psi(Q)) = \\left(\\prod_{i=0}^{(m-1)/2} g_{3^{i}P}(\\psi(Q))^{3^{(m-1)/2-i}}\\right) l(\\psi(Q))</span>$</p>

    <p class="text-gray-300">where l is a function corresponding to addition of  <span class="math">3^{(m+1)/2}P</span>  with  <span class="math">\\pm P</span> . Note that this final addition cannot be ommitted since T is not the order of P.</p>

    <p class="text-gray-300">We now explain that the extra addition can be easily handled.</p>

    <p class="text-gray-300"><strong>Lemma 5.</strong> With notation as above, let l(x, y) be the line in the final addition of the algorithm. Then l has slope  <span class="math">\\lambda = y_P</span>  if  <span class="math">m \\equiv 7, 11 \\pmod{12}</span>  or  <span class="math">\\lambda = -y_P</span>  if  <span class="math">m \\equiv 1, 5 \\pmod{12}</span> .</p>

    <p class="text-gray-300">If  <span class="math">m \\equiv 1,11 \\pmod{12}</span>  the equation for l is  <span class="math">y = \\lambda(x - x_P) + by_P</span>  and if  <span class="math">m \\equiv 5,7 \\pmod{12}</span>  then the equation for l is  <span class="math">y = \\lambda(x - x_P) - by_P</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> The proof is straightforward. For example, when  <span class="math">m \\equiv 1 \\pmod{12}</span>  then  <span class="math">T = 3^{(m+1)/2} + b</span>  and  <span class="math">[3^{(m+1)/2}]P = \\phi(x_p^3, y_p^3) = (x_p^3 - b, -y_p^3)</span> . The slope is therefore  <span class="math">\\lambda = (-y_p^3 - y_p)/(x_p^3 - b - x_p)</span> . Using  <span class="math">x_p^3 - x_p - b = y_p^2 + b</span>  gives  <span class="math">\\lambda = -y_p</span> . The addition is of  <span class="math">[3^{(m+1)/2}]P</span>  with bP, from which the equation for l(x, y) follows.</p>

    <p class="text-gray-300">The other cases are similar.</p>

    <p class="text-gray-300">The exponent  <span class="math">3^{(m-1)/2}</span>  is inconvenient and a naive implementation would lead to an unnecessary (m-1)/2 cubings. There are two ways to avoid this problem. One method is to bring the powering  <span class="math">3^{(m-1)/2}</span>  into the formulae as a Frobenius action. The other method, which we adopt here, is to compute the product in reverse, by setting j=(m-1)/2-i. We define  <span class="math">P&#x27;=3^{(m-1)/2}P</span>  which can be efficiently computed as  <span class="math">\\phi^{(m-1)/2}\\pi^{m-1}P=\\phi^{(m-1)/2}(x_p^{1/3},y_p^{1/3})</span> . Then the desired product is</p>

    <p class="text-gray-300"><span class="math">$l(\\psi(Q))\\prod_{j=0}^{(m-1)/2}g_{3^{-j}P&#x27;}(\\psi(Q))^{3^{j}}.</span>$</p>

    <p class="text-gray-300">It is then relatively straightforward to obtain an explicit description of the algorithm. We use the notation  <span class="math">a^{(i)}</span>  for  <span class="math">a^{3^i}</span> . For example, in the case  <span class="math">m \\equiv 1 \\pmod{12}</span>  one shows that</p>

    <p class="text-gray-300"><span class="math">$g_{3^{-j}P&#x27;}(\\psi(Q))^{3^j} = (\\sigma y_P^{(-j)} y_Q^{(j)} - u^2) - \\rho u - \\rho^2</span>$</p>

    <p class="text-gray-300">where  <span class="math">u = x_P^{(-j)} + x_O^{(j)} + b</span> . The algorithm in this case is given in Algorithm 2.</p>

    <p class="text-gray-300"><strong>Algorithm 2</strong> Computation of  <span class="math">\\eta_T(P,Q)</span>  on  <span class="math">E(\\mathbb{F}_{3^m}): y^2 = x^3 - x + b, \\ m \\equiv 1 \\pmod{12}</span></p>

    <pre><code class="language-text">INPUT: P, Q

OUTPUT: \\eta_T(P, Q)

1: P_0 \\leftarrow -P

2: if T &lt; 0 then T \\leftarrow -T, P \\leftarrow -P

3: let P = (x_P, y_P), Q = (x_Q, y_Q)

4: l \\leftarrow the line between 3^{(m+1)/2}P and P_0

5: f \\leftarrow l(\\psi(Q))

6: for j \\leftarrow 0 to (m-1)/2 do

7: u \\leftarrow x_P + x_Q + b

8: g \\leftarrow \\sigma y_P y_Q - u^2 - \\rho u - \\rho^2

9: f \\leftarrow f \\cdot g

10: x_P \\leftarrow x_P^{1/3}, y_P \\leftarrow y_P^{1/3}

11: x_Q \\leftarrow x_Q^3, y_Q \\leftarrow y_Q^3

12: end for

13: return f^{(3^{3m-1)(3^m+1)(3^m-b3^{(m+1)/2}+1)}
</code></pre>

    <p class="text-gray-300">Depending on the choice of basis, we can unroll the loop if necessary to exploit the innate sparseness of g. Cube roots can be calculated quickly using the method described by Barreto [1]. However this is still substantially slower than calculating cubes. Therefore it makes sense to do a precalculation to build a list of all cubes of  <span class="math">x_P</span>  and  <span class="math">y_P</span> , and to get the cube roots by accessing this list in reverse order. Note however that we only need the 'last' half of the cubes.</p>

    <p class="text-gray-300">The final exponentiation can be obtained for the relatively inexpensive cost of (m + 1)/2 extension field cubings, plus nine applications of the  <span class="math">3^m</span> -power Frobenius, nine extension field multiplications, one extension field squaring, one more cubing, and one extension field division.</p>

    <p class="text-gray-300">If the Tate pairing is required then we should also power to  <span class="math">3T^2/L</span> . A sensible strategy seems to be to raise the  <span class="math">\\eta_T</span>  pairing value to  <span class="math">3T^2q/L</span>  instead, and then to compute the inverse q-power Frobenius  <span class="math">\\pi</span>  to get rid of the extra q-th power. Namely, if  <span class="math">u = \\eta_T(P,Q)</span> , then  <span class="math">\\hat{e}(P,Q) = \\pi^{-1}(u^{\\mp 3^{(m-1)/2}})u^{\\mp 3^{(m+1)/2}-2}</span> , which amounts to m extra cubings, one squaring, three products, one inverse Frobenius and at most three conjugations, totalling a small amount of extra work compared to the cost of pairing computation.</p>

    </section>

    <section id="sec-6" class="mb-10">
      <h2 class="text-2xl font-bold">6 Elliptic curves in characteristic 2</h2>

    <p class="text-gray-300">We now consider the case of the supersingular curve<sup>6</sup>  <span class="math">E: y^2 + y = x^3 + x + b</span>  over  <span class="math">\\mathbb{F}_{2^m}</span>  where b = 0, 1 and m is odd. We will use the ideas presented in section 4. The order of E is given in table 2. It follows that the embedding degree in this case is k = 4.</p>

    <p class="text-gray-300">The field  <span class="math">\\mathbb{F}_{2^{4m}}</span>  has elements s, t such that  <span class="math">s^2 = s + 1</span>  and  <span class="math">t^2 = t + s</span> ; we will represent  <span class="math">\\mathbb{F}_{2^{4m}}</span>  using the basis  <span class="math">\\{1, s, t, st\\}</span> . Following [3] we use the distortion map  <span class="math">\\psi(x, y) = (x + s^2, y + sx + t)</span> .</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;6</sup> As before, there is no loss of generality from considering just one curve equation, as all superpersingular curves in characteristic two are isomorphic over  <span class="math">\\overline{\\mathbb{F}}_2</span>  to one other.</p>

    <p class="text-gray-300"><strong>Table 2.</strong> Order of the curve  <span class="math">E: y^2 + y = x^3 + x + b</span>  over  <span class="math">\\mathbb{F}_{2^m}</span> ,  <span class="math">b \\in \\mathbb{F}_2</span> .</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\#E(\\mathbb{F}_{2^m})</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">cond</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^m + 1 + (-1)^b 2^{(m+1)/2}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^m + 1 - (-1)^b 2^{(m+1)/2}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">m \\equiv 3, 5</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(mod 8)</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Let  <span class="math">P = (x_P, y_P) \\in E(\\mathbb{F}_{2^m})</span> . We define  <span class="math">\\phi(x, y) = (x + 1, y + x)</span> . One can verify that  <span class="math">\\phi^2(x, y) = (x, y + 1) = -(x, y)</span> ,  <span class="math">\\phi^3(x, y) = (x + 1, y + x + 1)</span> , and  <span class="math">\\phi^4(x, y) = (x, y)</span> . One can show by induction that</p>

    <p class="text-gray-300"><span class="math">$[2^{i}]P = \\phi^{i}\\left(x_{P}^{(2i)}, y_{P}^{(2i)}\\right) \\tag{4}</span>$</p>

    <p class="text-gray-300">If  <span class="math">q = 2^m</span>  it follows that  <span class="math">[q]P = \\phi^m(P)</span>  and we are in the setting of our main result (set  <span class="math">\\gamma = \\phi^m</span> ).</p>

    <p class="text-gray-300">For any field element a we use the notation  <span class="math">a^{(i)}</span>  for  <span class="math">a^{2^i}</span> . Depending on the field of definition of a we will usually have either  <span class="math">a^{(m)} = a</span>  or  <span class="math">a^{(4m)} = a</span> . Hence we can consider the values (i) as being modulo m or 4m. This allows us to extend to negative values by  <span class="math">a^{(-i)} = a^{(4m-i)}</span> , which can also be interpreted as the  <span class="math">2^i</span> -th root of a.</p>

    <p class="text-gray-300">For future reference we compute how s and t and  <span class="math">\\psi</span>  behave under powers of the 2-power Frobenius. Element s satisfies  <span class="math">s^{(1)} = s^2 = s+1</span> ,  <span class="math">s^{(2)} = s</span> , and thus  <span class="math">s^{(i)} = s+i</span>  and  <span class="math">s^{(-i)} = s^{(4m-i)} = s+i</span> . Similarly for t,  <span class="math">t^{(1)} = t+s</span> ,  <span class="math">t^{(2)} = t+1</span> ,  <span class="math">t^{(3)} = t+s+1</span> ,  <span class="math">t^{(4)} = t</span> , and thus  <span class="math">t^{(i)} = t+is+\\tau(i)</span>  where  <span class="math">\\tau(i) = 0</span>  for  <span class="math">i \\equiv 0, 1 \\pmod{4}</span>  and  <span class="math">\\tau(i) = 1</span>  for  <span class="math">i \\equiv 2, 3 \\pmod{4}</span> . Hence,  <span class="math">t^{(-i)} = t^{(4m-i)} = t+is+\\tau(-i)</span> .</p>

    <p class="text-gray-300">We now show that the eta pairing can be applied in this case.</p>

    <p class="text-gray-300"><strong>Lemma 6.</strong> Let notation be as above, in particular,  <span class="math">q = 2^m</span>  and  <span class="math">\\gamma = \\phi^m</span> . Then condition (3) is satisfied.</p>

    <p class="text-gray-300"><em>Proof.</em> We must show that  <span class="math">\\gamma \\psi^q = \\psi</span> . Consider first the case  <span class="math">m \\equiv 1 \\pmod{4}</span> . We have</p>

    <p class="text-gray-300"><span class="math">$\\gamma \\psi^{2^m}(x, y) = \\phi \\psi^2(x, y) = \\phi(x + s, y + s^2 x + (t + s))</span>$</p>

    <p class="text-gray-300"><span class="math">$= (x + s + 1, y + s^2 x + t + s + x + s)</span>$</p>

    <p class="text-gray-300"><span class="math">$= (x + s^2, y + sx + t)</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\psi(x, y).</span>$</p>

    <p class="text-gray-300">Similarly, when  <span class="math">m \\equiv 3 \\pmod{4}</span>  we find that</p>

    <p class="text-gray-300"><span class="math">$\\gamma \\psi^{2^m}(x, y) = \\phi^3 \\psi^{2^3}(x, y) = \\phi^3(x + s, y + s^2 x + (t + s + 1))</span>$</p>

    <p class="text-gray-300">=  <span class="math">(x + s + 1, y + s^2 x + t + s + 1 + x + s + 1)</span>
=  <span class="math">\\psi(x, y)</span> .</p>

    <p class="text-gray-300">This completes the proof.</p>

    <p class="text-gray-300">To generalise the Duursma-Lee idea to characteristic 2 is now straightforward using Theorem 1. Let  <span class="math">N = 2^{2m} + 1</span>  and  <span class="math">M = 2^{2m} - 1</span> . We take  <span class="math">T = q = 2^m</span>  (so that c = 0) and take a = 2 so that C = 1 so that C = 1 then the eta pairing satisfies</p>

    <p class="text-gray-300"><span class="math">$\\left(\\eta_T(P,Q)^M\\right)^{2q} = \\langle P, \\psi(Q) \\rangle_N^M.</span>$</p>

    <p class="text-gray-300">Adapting the other methods of [10] gives a very fast pairing computation in characteristic 2.</p>

      <h3 id="sec-6.1" class="text-xl font-semibold mt-8">6.1 A further improvement</h3>

    <p class="text-gray-300">As in characteristic 3, we can obtain a further halving of the loop. Let  <span class="math">N = \\#E(\\mathbb{F}_{2^m}) = 2^m \\pm 2^{(m+1)/2} + 1</span> . For  <span class="math">P \\in E(\\mathbb{F}_{2^m})</span>  we have</p>

    <p class="text-gray-300"><span class="math">$[\\mp 2^{(m+1)/2} - 1]P = [2^m - N]P = \\gamma(P).</span>$</p>

    <p class="text-gray-300">Taking  <span class="math">T = \\mp 2^{(m+1)/2} - 1</span>  we have  <span class="math">T = 2^m - N</span>  so c = -1. Taking a = 2 gives  <span class="math">T^2 + 1 = 2N</span>  so L = 2. We have  <span class="math">M = ((2^m)^4 - 1)/N = (2^m \\mp 2^{(m+1)/2} + 1)(2^{2m} - 1)</span> . Theorem 1 therefore implies that</p>

    <p class="text-gray-300"><span class="math">$\\left(\\eta_T(P,Q)^M\\right)^{2T} = \\langle P, \\psi(Q) \\rangle_N^{2M}</span>$</p>

    <p class="text-gray-300">from which it follows that</p>

    <p class="text-gray-300"><span class="math">$\\left(\\eta_T(P,Q)^M\\right)^T = \\langle P, \\psi(Q) \\rangle_N^M.</span>$</p>

    <p class="text-gray-300">We can therefore easily compute the exact Tate pairing using the eta approach in this case. As before, the halving of the loop is slightly offset by the extra squarings required for the final exponentiation, but we still see an overall gain in performance.</p>

      <h3 id="sec-6.2" class="text-xl font-semibold mt-8">6.2 Implementation details</h3>

    <p class="text-gray-300">Let  <span class="math">P,Q \\in E(\\mathbb{F}_{2^m})</span>  be the input points for the eta pairing with  <span class="math">T=\\mp 2^{(m+1)/2}-1</span> . In the case T&lt;0 we replace P by -P and T by -T. Thus we have  <span class="math">T=2^{(m+1)/2}\\pm 1</span> . To compute the eta pairing we must compute the Miller function  <span class="math">f_{T,P}</span> , which will require (m+1)/2 doublings and an addition. Note that the addition cannot be ommitted since the point P does not have order T.</p>

    <p class="text-gray-300">Given a point V, it is easy to show that the straight line in doubling V is given by</p>

    <p class="text-gray-300"><span class="math">$g_V(x, y) = (x_V^2 + 1)(x_V + x) + y_V + y.</span>$</p>

    <p class="text-gray-300">The function  <span class="math">g_V</span>  has divisor  <span class="math">2(V)+(-2V)-3(\\infty)</span> . Hence, by a standard argument similar to the proof of Lemma 2 combined with the fact that we can disregard functions of x only, we have</p>

    <p class="text-gray-300"><span class="math">$f_{T,P}(\\psi(Q)) = \\left(\\prod_{i=0}^{(m-1)/2} \\left(g_{[2^i]P}(\\psi(Q))\\right)^{2^{(m-1)/2-i}}\\right) l(\\psi(Q))</span>$</p>

    <p class="text-gray-300">where the function <em>l</em> comes from the elliptic curve addition of  <span class="math">[2^{(m+1)/2}]P</span>  with  <span class="math">\\pm P</span> .</p>

    <p class="text-gray-300">The power  <span class="math">2^{(m-1)/2}</span>  is somewhat inconvenient. A naive implementation might involve (m-1)/2 unnecessary squarings because of it. There are two ways around this problem, which both give equally efficient solutions. One solution would be to absorb</p>

    <p class="text-gray-300">the powering by  <span class="math">2^{(m-1)/2}</span>  into the equations. Another solution is to re-write the expression by substituting  <span class="math">j = 2^{(m-1)/2} - i</span>  and  <span class="math">P&#x27; = [2^{(m-1)/2}]P</span> . This gives</p>

    <p class="text-gray-300"><span class="math">$f_{T,P}(\\psi(Q)) = l(\\psi(Q)) \\prod_{j=0}^{(m-1)/2} g_{[2^{-j}]P&#x27;}(\\psi(Q))^{2^{j}}.</span>$</p>

    <p class="text-gray-300">Note that, due to our doubling formula, the 'point halving' in  <span class="math">[2^{-j}]P&#x27;</span>  has the same efficiency as point doubling. Also note that  <span class="math">P&#x27; = \\phi^{(m-1)/2}(\\sqrt{x_P}, \\sqrt{y_P})</span> .</p>

    <p class="text-gray-300">We now give some formulae which allow us to present an efficient and general algorithm. The first result gives the equation of the line <em>l</em> for the final addition (note that no inversions are required to compute this). The proof of this result is straightforward.</p>

    <p class="text-gray-300"><strong>Lemma 7.</strong> Let m and b be as above. Define  <span class="math">\\epsilon = -1</span>  when  <span class="math">m \\equiv 1, 7 \\pmod{8}</span>  and b = 1 or when  <span class="math">m \\equiv 3, 5 \\pmod{8}</span>  and b = 0. Define  <span class="math">\\epsilon = 1</span>  in all other cases. Then T is taken to be  <span class="math">2^{(m+1)/2} + \\epsilon</span> .</p>

    <p class="text-gray-300">Let  <span class="math">P = (x_P, y_P)</span> . Define  <span class="math">\\lambda = x_P</span>  when  <span class="math">m \\equiv 1, 5 \\pmod{8}</span>  and  <span class="math">\\lambda = x_P + 1</span>  when  <span class="math">m \\equiv 3, 7 \\pmod{8}</span> . Then the formula for the line l(x, y) through  <span class="math">2^{(m+1)/2}P</span>  and  <span class="math">\\epsilon P</span>  is given by  <span class="math">l(x, y) = y + \\lambda(x + x_P) + y_P + (1 - \\epsilon)/2</span> .</p>

    <p class="text-gray-300"><strong>Lemma 8.</strong> Let notation be as above. Define  <span class="math">v_1 = 1</span>  if  <span class="math">m \\equiv 1, 5 \\pmod{8}</span>  and  <span class="math">v_1 = 0</span>  otherwise. Define  <span class="math">v_2 = 1</span>  if  <span class="math">m \\equiv 5, 7 \\pmod{8}</span>  and  <span class="math">v_2 = 0</span>  otherwise. Define  <span class="math">u = x_P^{(-j)} + v_1</span> . Then the function  <span class="math">g_{[2^{-j}]P&#x27;}(\\psi(Q))^{2^j}</span>  is given by</p>

    <p class="text-gray-300"><span class="math">$u(x_P^{(-1-j)} + x_O^{(j)} + v_1) + y_P^{(-1-j)} + y_O^{(j)} + (1-v_1)x_P^{(-1-j)} + s(u+x_O^{(j)}) + t + v_2.</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> Note that  <span class="math">[2^{-j}]P&#x27; = \\phi^{(m-1)/2-j}(x_P^{(-1-2j)}, y_P^{(-1-2j)})</span> . The result is proved by a tedious case-by-case analysis.</p>

    <p class="text-gray-300">For example, when  <span class="math">m \\equiv 3 \\pmod{8}</span>  and  <span class="math">j \\equiv 2 \\pmod{4}</span>  then  <span class="math">(m-1)/2 - j \\equiv 3 \\pmod{4}</span>  and so  <span class="math">[2^{-j}]P&#x27; = (x_P^{(-1-2j)} + 1, y_P^{(-1-2j)} + x_P^{(-1-2j)} + 1)</span> . The function is therefore</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp;\\left((x_P^{(-2j)})(x_P^{(-1-2j)} + x_Q + s) + y_P^{(-1-2j)} + x_P^{(-1-2j)} + 1 + y_Q + sx_Q + t\\right)^{2^j} \\\\ &amp;= x_P^{(-j)}(x_P^{(-1-j)} + x_O^{(j)} + s) + y_P^{(-1-j)} + x_P^{(-1-j)} + 1 + y_O^{(j)} + sx_O^{(j)} + t + 1. \\end{split}</span>$</p>

    <p class="text-gray-300">Letting  <span class="math">u = x_P^{(-j)}</span>  this simplifies to</p>

    <p class="text-gray-300"><span class="math">$u(x_P^{(-1-j)} + x_O^{(j)}) + y_P^{(-1-j)} + x_P^{(-1-j)} + y_O^{(j)} + s(u + x_O^{(j)}) + t</span>$</p>

    <p class="text-gray-300">as required. The other 15 cases are similar. &#9633;</p>

    <p class="text-gray-300">Here we give the algorithm in the case of a curve with  <span class="math">m \\equiv 3 \\pmod{8}</span> .</p>

    <p class="text-gray-300">In this optimized algorithm the point addition is dealt with first, using the formula of Lemma 7.</p>

    <p class="text-gray-300">Each step in the subsequent loop costs  <span class="math">7 \\mathbb{F}_q</span>  multiplications (1 to compute g, 6 to accumulate it into f by making use of the sparse structure of g). In practise to obtain this speed-up we might have to unroll the loop times 2 (depending on the basis chosen). The total cost of the loop plus the initial point addition is therefore 7(m+1)/2+1</p>

    <p class="text-gray-300"><strong>Algorithm 3</strong> Computation of  <span class="math">\\eta_T(P, Q)</span>  on  <span class="math">E(\\mathbb{F}_{2^m}): y^2 + y = x^3 + x + b, \\ m \\equiv 3 \\pmod{8}</span></p>

    <pre><code class="language-text">INPUT: P, Q

OUTPUT: \\eta_T(P, Q)

1: let P = (x_P, y_P), Q = (x_Q, y_Q)

2: u \\leftarrow x_P + 1

3: f \\leftarrow u \\cdot (x_P + x_Q + 1) + y_P + y_Q + b + 1 + (u + x_Q)s + t

4: for i \\leftarrow 1 to (m + 1)/2 do

5: u \\leftarrow x_P, x_P \\leftarrow \\sqrt{x_P}, y_P \\leftarrow \\sqrt{y_P}

6: g \\leftarrow u \\cdot (x_P + x_Q) + y_P + y_Q + x_P + (u + x_Q)s + t

7: f \\leftarrow f \\cdot g

8: x_Q \\leftarrow x_Q^2, y_Q \\leftarrow y_Q^2

9: end for

10: return f^{(2^{2m}-1)(2^m-2^{(m+1)/2}+1)}
</code></pre>

    <p class="text-gray-300">multiplications. The final exponentiation can be obtained for the relatively inexpensive cost of (m + 1)/2 extension field squarings, plus three applications of the  <span class="math">2^m</span> -power Frobenius, four extension field multiplications, and one extension field division. To obtain the Tate pairing, the result must be further exponentiated to the power of T.</p>

    <p class="text-gray-300">Unlike the case of characteristic three, there seems to be no reason to precompute and store the square roots. This is because a careful implementation of the technique described in [12] for calculating square roots in the field  <span class="math">\\mathbb{F}_{2^m}</span>  is in fact just as fast as squaring. In fact it may be a little faster, as large precomputed tables can lead to memory cache misses which are detrimental to performance.</p>

      <h3 id="sec-6.3" class="text-xl font-semibold mt-8"><strong>6.3</strong> Compression of pairing elements</h3>

    <p class="text-gray-300">Pairing values lie in the subgroup of order  <span class="math">q^2 + 1</span>  in  <span class="math">\\mathbb{F}_{q^4}^*</span> , which is the torus  <span class="math">T_2(\\mathbb{F}_{q^2})</span> . Hence it is trivial to compress pairing values by a factor of 2 using standard torus or trace methods.</p>

    <p class="text-gray-300">In the case of the eta pairing with T=q, the method of Granger, Page and Stam [17] avoids performing the final exponentiation (though note that their compression method requires an inversion so is of similar complexity to the final exponentiation anyway). Their idea is to note that the pairing value e can be written as  <span class="math">e=gh=e_0+e_1t</span>  where g has order dividing  <span class="math">(q^2+1)</span>  and where  <span class="math">h, e_0, e_1 \\in \\mathbb{F}_{q^2}</span> . Hence, the value  <span class="math">e_0/e_1</span>  is a uniquely defined element in  <span class="math">\\mathbb{F}_{q^2}</span>  corresponding to the class of e.</p>

    <p class="text-gray-300">When using the eta pairing with T = q - N the method of Granger, Page and Stam to avoid the final exponentiation cannot be applied. Nevertheless, once the final exponentiation has been performed one can compress by a factor of 2 using traces or tori in the standard way.</p>

    </section>

    <section id="sec-7" class="mb-10">
      <h2 class="text-2xl font-bold">7 Genus 2 curves in characteristic 2</h2>

    <p class="text-gray-300">We now consider the curve  <span class="math">{}^7C_d: y^2 + y = x^5 + x^3 + d</span>  with d = 0 or 1 over  <span class="math">\\mathbb{F}_{2^m}</span> , where m is coprime to 6. This curve is supersingular and has embedding degree 12 (see [16]). The group order is given in Table 3; some examples are listed in Table 4.</p>

    <p class="text-gray-300">In this section we show that the eta pairing approach can be easily applied in this setting. We give an octupling formula which enables fast point exponentiation and give a corresponding function for Miller's algorithm.</p>

    <p class="text-gray-300">A general reduced divisor D on a genus 2 curve has support consisting of two affine points (i.e.,  <span class="math">D = (P_1) + (P_2) - 2(\\infty)</span> ). Following Duursma and Lee [10] (also see [18, 19]) we exploit the benefits of using <em>degenerate divisors</em><sup>8</sup> of the form  <span class="math">D = (P) - (\\infty)</span>  where possible.</p>

    <p class="text-gray-300"><strong>Table 3.</strong> Order of Jac( <span class="math">C_d</span> ) for the curve  <span class="math">C_d: y^2 + y = x^5 + x^3 + d</span>  over  <span class="math">\\mathbb{F}_{2^m}, d \\in \\mathbb{F}_2</span> .</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\#\\mathrm{Jac}(C_d)(\\mathbb{F}_{2^m})</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">condition</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{2m} + (-1)^d 2^{(3m+1)/2} + 2^m + (-1)^d 2^{(m+1)/2} + 1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{2m} - (-1)^d 2^{(3m+1)/2} + 2^m - (-1)^d 2^{(m+1)/2} + 1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">m \\equiv 5, 11, 13, 19 \\pmod{24}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300"><strong>Table 4.</strong> Examples where  <span class="math">\\#Jac(C)(\\mathbb{F}_{2^m})</span>  is equal to a small cofactor times a prime.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">field</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">curve</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">cofactor</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathbb{F}_{2^{79}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">y^2 + y = x^5 + x^3 + 1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">151681</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathbb{F}_{2^{103}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">y^2 + y = x^5 + x^3</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13 &middot; 1237</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathbb{F}_{2^{127}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">y^2 + y = x^5 + x^3 + 1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">198168459411337</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathbb{F}_{2^{199}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">y^2 + y = x^5 + x^3 + 1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2389 &middot; 121789</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathbb{F}_{2^{239}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">y^2 + y = x^5 + x^3 + 1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathbb{F}_{2^{313}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">y^2 + y = x^5 + x^3 + 1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">We note that our special curve has certain properties that lend to faster arithmetic than the explicit formulae given in [22] for general genus 2 curves, namely that the equation is sparse and that all the coefficients are defined over  <span class="math">\\mathbb{F}_2</span> . See [23] for examples of arithmetic on similar (albeit non-supersingular) curves.</p>

      <h3 id="sec-7.1" class="text-xl font-semibold mt-8">7.1 Arithmetic on the curves</h3>

    <p class="text-gray-300">We first introduce the representation of  <span class="math">\\mathbb{F}_{2^{12}}</span>  and the distortion map we will be using.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;7</sup> In this case not all supersingular equations are isomorphic over  <span class="math">\\overline{\\mathbb{F}}_2</span> . Nevertheless, the Jacobians are isogenous, so there seems to be no good reason to consider other curve equations.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;8</sup> Note that the definition of degenerate divisors in [18, 19] is that they have less than g points in their support, whereas our definition is tougher when g &gt; 2 in that we insist on having exactly one point in the support.</p>

    <p class="text-gray-300">Choose  <span class="math">w \\in \\mathbb{F}_{2^6}</span>  to be a root of the polynomial</p>

    <p class="text-gray-300"><span class="math">$x^6 + x^5 + x^3 + x^2 + 1</span>$
.</p>

    <p class="text-gray-300">Note that  <span class="math">w^8 = w + 1</span> . Define  <span class="math">s_1 = w^2 + w^4</span> ,  <span class="math">s_2 = w^4 + 1</span> , and let  <span class="math">s_0 \\in \\mathbb{F}_{2^{12}}</span>  be a solution of  <span class="math">s_0^2 + s_0 = w^5 + w^3</span> .</p>

    <p class="text-gray-300">We will represent elements of the field  <span class="math">\\mathbb{F}_{2^{12m}}</span>  as 12-tuples with respect to the basis</p>

    <p class="text-gray-300"><span class="math">$\\{1, w, w^2, w^3, w^4, w^5, s_0, ws_0, w^2s_0, w^3s_0, w^4s_0, w^5s_0\\}.</span>$</p>

    <p class="text-gray-300">We choose the distortion map</p>

    <p class="text-gray-300"><span class="math">$\\psi(x,y) = (x+w, y+s_2x^2+s_1x+s_0).</span>$</p>

    <p class="text-gray-300">We now consider the octupling formula and hence determine when  <span class="math">[2^{3m}]D</span>  can be written as  <span class="math">\\gamma(D)</span>  for some  <span class="math">\\gamma</span> .</p>

    <p class="text-gray-300">Consider a divisor of form  <span class="math">D=(P)-(\\infty)</span> . In general, jD is not equivalent to a divisor of the form  <span class="math">(Q)-(\\infty)</span> , but as shown in Appendix A, in this case we have the octupling formula  <span class="math">8D=(P&#x27;)-(\\infty)</span>  where  <span class="math">P&#x27;=\\phi\\pi^6(P)</span> ,  <span class="math">\\pi</span>  is the 2-power Frobenius map, and</p>

    <p class="text-gray-300"><span class="math">$\\phi(x, y) = (x + 1, y + x^2 + 1).</span>$</p>

    <p class="text-gray-300">Note that  <span class="math">\\phi^2 = -1</span> . As a suggestive (but non-standard) notation, we write  <span class="math">[8]P = \\phi \\pi^6(P)</span>  and so  <span class="math">8D = ([8]P) - (\\infty)</span> . Koblitz [20] gives a map for 64D, which is exactly the octupling operation applied twice in succession. Similar results for other supersingular curves were obtained by Duursma and Lee [10].</p>

    <p class="text-gray-300">Since our basic operation is octupling, we are forced to consider the  <span class="math">\\eta</span>  pairing in the case where we have a power of  <span class="math">2^3</span> . Hence we will work with  <span class="math">q = 2^{3m}</span>  rather than  <span class="math">q = 2^m</span> . Nevertheless, since our basic operation is octupling, our loops will still have at most m iterations. It follows that, if D is a divisor class defined over  <span class="math">\\mathbb{F}_{2^m}</span> , then</p>

    <p class="text-gray-300"><span class="math">$[q]D = [2^{3m}]D = \\phi^m(D)</span>$</p>

    <p class="text-gray-300">hence we define  <span class="math">\\gamma = \\phi^m</span> .</p>

    <p class="text-gray-300">We also note that it is possible to use the octupling operation for straightforward scalar multiplication, which yields a simple and speedy implementation.</p>

      <h3 id="sec-7.2" class="text-xl font-semibold mt-8">7.2 Eta pairings in genus 2</h3>

    <p class="text-gray-300">We now show that condition (3) is satisfied for our distortion map.</p>

    <p class="text-gray-300"><strong>Lemma 9.</strong> Let the notation be as above with  <span class="math">q = 2^{3m}</span> . Then condition (3) is satisfied.</p>

    <p class="text-gray-300"><em>Proof.</em> We have  <span class="math">q = 2^{3m}</span>  where  <span class="math">m \\equiv 1, 5, 7</span>  or 11 (mod 12) and  <span class="math">\\gamma = \\phi^m</span> .</p>

    <p class="text-gray-300">As before, we write  <span class="math">a^{(i)}</span>  for  <span class="math">a^{2^i}</span> . We will repeatedly use the easily checked formulae that  <span class="math">w^{(3)} = w + 1</span> ,  <span class="math">s_0^{(3)} = s_0 + w^2</span> ,  <span class="math">s_1^{(3)} = s_1</span>  and  <span class="math">s_2^{(3)} = s_2 + 1</span> .</p>

    <p class="text-gray-300">First suppose  <span class="math">m \\equiv 1 \\pmod{4}</span>  (and so  <span class="math">3m \\equiv 3 \\pmod{12}</span> ). Then</p>

    <p class="text-gray-300">$$\\gamma \\psi^{q}(x, y) = \\phi \\psi^{(3)}(x, y)
= \\phi(x + w + 1, y + (s_2 + 1)x^2 + s_1x + s_0 + w^2)
= (x + w, y + s_2x^2 + s_1x + s_0)
= \\psi(x, y).$$</p>

    <p class="text-gray-300">Similarly, when  <span class="math">m \\equiv 3 \\pmod{4}</span>  we have  <span class="math">\\gamma = -\\phi</span>  and  <span class="math">3m \\equiv 9 \\pmod{12}</span> . Hence</p>

    <p class="text-gray-300">$$\\gamma \\psi^{q}(x, y) = -\\phi^{3} \\psi^{(9)}(x, y)
= -\\phi(x + w + 1, y + (s_{2} + 1)x^{2} + s_{1}x + s_{0} + w^{2} + 1)
= (x + w, y + s_{2}x^{2} + s_{1}x + s_{0})
= \\psi(x, y).$$</p>

    <p class="text-gray-300">This proves the lemma.</p>

    <p class="text-gray-300">Having established this, we can now apply Theorem 1. For the basic generalisation of Duursma and Lee we take  <span class="math">T = q = 2^{3m}</span>  so that c = 0. We have  <span class="math">N = 2^{6m} + 1</span>  so that  <span class="math">M = 2^{6m} - 1</span> . We then take a = 2 so that  <span class="math">q^2 + 1 = N</span>  and L = 1. It therefore follows that</p>

    <p class="text-gray-300"><span class="math">$\\left(\\eta_T(D, D&#x27;)^M\\right)^{2q} = \\langle D, \\psi(D&#x27;) \\rangle_N^M.</span>$</p>

    <p class="text-gray-300">Computing the eta pairing with respect to  <span class="math">T = 2^{3m}</span>  requires m iterations of the octupling formula. Interestingly, this is not much better than the basic BKLS-GHS method generalised to genus 2 (see Section 7.7).</p>

    <p class="text-gray-300">As before, we can obtain a further halving of the loop. Let  <span class="math">q=2^{3m}</span>  and  <span class="math">N=2^{2m}\\pm 2^{(3m+1)/2}+2^m\\pm 2^{(m+1)/2}+1</span> . Consider the equation</p>

    <p class="text-gray-300"><span class="math">$(2^m \\mp 2^{(m+1)/2} + 1)N = 2^{3m} \\pm 2^{(3m+1)/2} + 1.</span>$</p>

    <p class="text-gray-300">This suggests taking  <span class="math">T = \\pm 2^{(3m+1)/2} - 1</span>  so that, if D is a divisor defined over  <span class="math">\\mathbb{F}_q</span>  (and hence of order dividing N),</p>

    <p class="text-gray-300"><span class="math">$[T]D = [q - (2^m \\mp 2^{(m+1)/2} + 1)N]D = [q]D = \\gamma(D).</span>$</p>

    <p class="text-gray-300">Then  <span class="math">c = -(2^m \\mp 2^{(m+1)/2} + 1)</span>  in the notation of Theorem 1. Taking a = 2 gives  <span class="math">T^2 + 1 = LN</span>  where  <span class="math">L = 2^{m+1} \\mp 2^{(m+3)/2} + 2</span> . Theorem 1 therefore implies that</p>

    <p class="text-gray-300"><span class="math">$\\left(\\eta_T(D,D&#x27;)^M\\right)^{2T} = \\left(\\langle D,\\psi(D&#x27;)\\rangle_N^M\\right)^L.</span>$</p>

    <p class="text-gray-300">Computing the eta pairing using  <span class="math">T = \\pm 2^{(3m+1)/2} - 1</span>  will require roughly m/2 iterations of the octupling formula, which is clearly superior to the BKLS-GHS method.</p>

      <h3 id="sec-7.3" class="text-xl font-semibold mt-8">7.3 Implementation Details</h3>

    <p class="text-gray-300">We compute the  <span class="math">\\eta_T</span>  pairing of divisors D and D' using the order  <span class="math">T = \\pm 2^{(3m+1)/2} - 1</span> . As usual, if T &lt; 0 then set T = -T and D = -D. Hence we have  <span class="math">T = 2^{(3m+1)/2} \\pm 1</span> .</p>

    <p class="text-gray-300">We will exploit the octupling formula. Let  <span class="math">f_{8,P}</span>  be a function such that  <span class="math">(f_{8,P}) = 8(P) - ([8]P) - 7(\\infty)</span> . We show in appendix A that,</p>

    <p class="text-gray-300"><span class="math">$f_{8,P}(x,y) = \\frac{(y + b_4(x))^2 (y + b_8&#x27;&#x27;(x))}{a_4&#x27;(x)^2 a_8&#x27;(x)}</span>$</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">$b_4(x) = x^3 + (x_P^8 + x_P^4)x^2 + (x_P^4)x + y_P^4</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$b_8&#x27;&#x27;(x) = (x_P^{32} + 1)x^2 + (x_P^{32} + x_P^{16})x + (y_P^{16} + x_P^{16} + x_P^{48} + 1).</span>$</p>

    <p class="text-gray-300">The denominator  <span class="math">a_4&#x27;(x)^2 a_8&#x27;(x)</span>  can be ignored for the usual reasons. We will be composing our function with  <span class="math">\\psi</span> , and so we will use the notation  <span class="math">\\alpha\\beta</span>  for the function, where  <span class="math">\\alpha = (y + b_4(x))^2 \\circ \\psi</span>  and  <span class="math">\\beta = (y + b_8&#x27;&#x27;) \\circ \\psi</span> .</p>

    <p class="text-gray-300">To compute a function  <span class="math">f_{T,P}</span>  with divisor  <span class="math">T(P) - (D_{T,P}) - n(\\infty)</span>  where  <span class="math">D_{T,P}</span>  is a reduced divisor equivalent to TD we want to use the above functions. Since (3m+1)/2 = 3(m-1)/2 + 2 we must use (m-1)/2 octuplings and two doublings.</p>

    <p class="text-gray-300">In other words, we have</p>

    <p class="text-gray-300"><span class="math">$f_{T,P}(\\psi(Q)) = \\left(\\prod_{i=0}^{(m-3)/2} f_{8,[8^i]P}(\\psi(Q))^{2^{(3m-5)/2-3i}}\\right) l_1(\\psi(Q))^2 l_2(\\psi(Q)) l_3(\\psi(Q))</span>$</p>

    <p class="text-gray-300">where  <span class="math">l_1</span>  and  <span class="math">l_2</span>  are functions coming from the extra doublings and  <span class="math">l_3</span>  is from the final addition of  <span class="math">2^{(3m+1)/2}((P)-(\\infty))</span>  and  <span class="math">\\pm((P)-(\\infty))</span> .</p>

    <p class="text-gray-300">Appendix B gives more detail on implementing the pairing. In Appendix B.1 the distortion map is built into the functions, and formulae are derived for  <span class="math">f_{8,[8^i]P}(\\psi(Q))</span>  which do not require the explicit computation of  <span class="math">[8^i]P</span> . These formulae are computed efficiently by accessing a table of precomputed values for  <span class="math">x_P^{2^i}</span>  and  <span class="math">y_P^{2^i}</span> . In Appendix B.4 powers of 8 are absorbed into the formulae, which involves precomputing powers of the second point. Appendix B.7 describes how the final doublings and addition can be simplified for degenerate divisors. Algorithm 4 details the genus 2  <span class="math">\\eta_T</span>  pairing for degenerate divisors in the case when m = 103 (although only trivial changes are required to modify the algorithm for arbitrary m).</p>

    <p class="text-gray-300">All of these optimisations lead to a very fast pairing implementation on genus 2 curves in characteristic two. Details of timings are given in Section 10.</p>

      <h3 id="sec-7.4" class="text-xl font-semibold mt-8">7.4 Degenerate divisors versus general divisors</h3>

    <p class="text-gray-300">We have focussed on the case of degenerate divisors since this gives a convincing example where hyperelliptic curves can be superior to elliptic curves. Nevertheless, most applications will also require pairings to be computed on general divisors.</p>

    <p class="text-gray-300">A general reduced divisor defined over  <span class="math">\\mathbb{F}_q</span>  on a genus 2 curve C is represented by  <span class="math">(P_1)+(P_2)-2(\\infty)</span>  where either  <span class="math">P_1,P_2\\in C(\\mathbb{F}_q)</span>  or  <span class="math">P_1,P_2\\in C(\\mathbb{F}_{q^2})</span>  are Galois conjugates of each other. The Mumford representation for divisors on hyperelliptic curves essentially gives the symmetric functions of the coordinates of the points  <span class="math">P_i</span>  in the support of the divisor.</p>

    <pre><code class="language-text">INPUT: P = (x_P, y_P), Q = (x_Q, y_Q) \\in J_C(F_{2^m})
OUTPUT: f \\in F_{2^{12m}}
 1: \\triangleright Initialisation: set \\gamma = 1 if m \\equiv 1 \\mod 4, otherwise \\gamma = 0
 2: &#9654; Precompute powers of P and Q
 3: x_1[i] \\leftarrow x_P^{2i}, y_1[i] \\leftarrow y_P^{2i}, x_2[i] \\leftarrow x_Q^{2i}, y_2[i] \\leftarrow y_Q^{2i}, 0 &lt;= i &lt;= m-1
 4:\\ f \\leftarrow 1
 5:
 6: for i = 0 to (m - 3)/2 do
            \\rightharpoonup All k_* in the next 2 lines to be considered modulo m
 7:
 8:
            k_1 \\leftarrow (3m - 9 - 6i)/2, k_2 \\leftarrow (k_1 + 1), k_3 \\leftarrow (k_2 + 1)
 9:
            k_4 \\leftarrow (3m - 3 + 6i)/2, k_5 \\leftarrow (k_4 + 1), k_6 \\leftarrow (k_5 + 1)
10:
            &#9658; Calculate \\alpha \\leftarrow a + bw + cw^2 + dw^4 + s_0
11:
12:
            d \\leftarrow x_1[k_4] + x_1[k_5]
13:
            a \\leftarrow y_2[k_2] + (x_1[k_4] + 1 + x_2[k_3]) \\cdot x_2[k_2] + d \\cdot x_2[k_3] + y_1[k_4] + \\gamma
14:
            b \\leftarrow x_2[k_3] + x_2[k_2]
15:
            c \\leftarrow x_2[k_3] + x_1[k_4] + 1
16:
17:
            \\rightharpoonup Calculate \\beta \\leftarrow e + f_2 w + g w^2 + h w^4 + s_0
18:
            f_2 \\leftarrow x_1[k_5] + x_1[k_6]
19:
            e \\leftarrow y_2[k_1] + f_2 \\cdot x_2[k_1] + y_1[k_5] + x_1[k_6] \\cdot (x_1[k_5] + x_2[k_2]) + x_1[k_5] + \\gamma
20:
            g \\leftarrow x_2[k_1] + x_1[k_6] + 1
21:
            h \\leftarrow x_2[k_2] + x_2[k_1]
22:
            f \\leftarrow f \\cdot (\\alpha \\cdot \\beta)
24: end for
25:
26: \\triangleright &quot;Extract&quot; current point (x_P, y_P)
27: x_P \\leftarrow x_1[100] + 1
28: y_P \\leftarrow y_1[100] + x_1[101]
30: &gt; Perform the final doublings/addition
31: t \\leftarrow (y_2[0] + x_2[1] \\cdot (1 + x_2[0] + x_P^8 + x_P^4) + x_P^4 \\cdot x_2[0] + y_P^4)
32: f \\leftarrow f^4 \\cdot (t, x_2[1] + x_P^4, x_P^8 + x_P^4, 1, x_2[1] + x_2[0], 0, 1, 0, 0, 0, 0, 0)
34: \\triangleright Perform the final exponentiation 35: f \\leftarrow f^{(2^{6m}-1)(2^{3m}-2^{4m}2^{(m+1)/2}-1)}
</code></pre>

    <p class="text-gray-300">General divisors may appear as either the first or second components of the pairing (or both). Handling the second case (i.e., generalising evaluation of a function at a point to evaluation at a divisor in Mumford representation) is relatively straightforward.</p>

    <p class="text-gray-300">For the first case, bilinearity implies that  <span class="math">\\eta_T((P_1) + (P_2) - 2(\\infty), D&#x27;) = \\eta_T(P_1, D&#x27;)\\eta_T(P_2, D&#x27;)</span>  and so one can compute a pairing on divisors by taking a product of pairings on points. However, in the case where the points  <span class="math">P_i</span>  are actually defined over  <span class="math">\\mathbb{F}_{q^2}</span>  this will not be the most efficient way to proceed. It is relatively straightforward to obtain the general formulae: just multiply the functions obtained from the single point case and then express the resulting polynomials in terms of the symmetric polynomials in the point coordinates. We leave this as an exercise for the reader; a full discussion will be given in the thesis of the third author.</p>

    <p class="text-gray-300">From a performance point of view, the cost of computing a pairing between general divisors in genus 2 is at worst 4 times the cost of a pairing between single points. Obviously, various optimisations are applicable, including only performing the final exponentiation once, sharing some of the function calculations and only having to precompute squarings of points once.</p>

    <p class="text-gray-300">We now briefly discuss how degenerate divisors can be used to speed up pairing-based cryptosystems. First, note that Katagi <em>et al.</em> [19] showed (using the random self-reducibility of the discrete logarithm problem) that there is no loss of security from using degenerate divisors.</p>

    <p class="text-gray-300">In most of the cases we consider, the divisor class group has (nearly) prime order N and we work with pairings of order N. Hence, a randomly chosen degenerate divisor  <span class="math">(P) - (\\infty)</span>  will have order divisible by our large prime and the pairing value will be non-degenerate. In the general case of pairings on higher genus curves this assumption may not hold; we refer to Frey and Lange [13] for a discussion of these issues.</p>

    <p class="text-gray-300">In the case of pairing-based cryptography it is easy to benefit from the use of degenerate divisors. As a case study we consider the Boneh-Franklin identity-based encryption scheme [7] (similar ideas can speed up aspects of other pairing-based cryptosystems, we refer to Frey and Lange [13] for further discussion). The natural generalisation of this system to genus g curves (see [16]) is to have a master public key pair D,  <span class="math">D_{\\text{pub}} = [s]D</span>  of divisors; identities are hashed to obtain divisors D(ID); user private keys are [s]D(ID); encryption involves computing [r]P and the pairing of  <span class="math">D_{\\text{pub}}</span>  with D(ID) (and then raising to the power r); decryption involves the pairing of [s]D(ID) with [r]P.</p>

    <p class="text-gray-300">Without loss of security, one can choose several of these divisors to be degenerate. For example, one can choose  <span class="math">D_{\\text{pub}}</span>  to be degenerate (i.e., choose  <span class="math">D_{\\text{pub}}</span>  first and then set  <span class="math">D = [s^{-1}]D_{\\text{pub}}</span> ). One can also choose H(ID) to be degenerate, so that we are hashing to points on the curve, rather than general divisors. This simplified hashing process is also easier to implement than the general case. Of course, the user private keys are now general divisors. Encryption therefore involves a pairing of two degenerate divisors and so can be performed very efficiently, while decryption involves a pairing of general divisors. This is similar to RSA with small public exponents, where the public operations are fast compared to the private ones. For some applications this may be a useful feature.</p>

      <h3 id="sec-7.5" class="text-xl font-semibold mt-8">7.5 The Final Exponentiation</h3>

    <p class="text-gray-300">Theorem 1 relates the  <span class="math">\\eta_T</span>  pairing to the Tate pairing in the genus 2 case as follows</p>

    <p class="text-gray-300"><span class="math">$\\left(\\eta_T(D,D&#x27;)^M\\right)^{2T} = \\left(\\langle D,\\psi(D&#x27;)\\rangle_N^M\\right)^L.</span>$</p>

    <p class="text-gray-300">where  <span class="math">T = \\pm 2^{(3m+1)/2} - 1</span> ,  <span class="math">M = (2^{12m} - 1)/N</span> ,  <span class="math">N = 2^{2m} \\pm 2^{(3m+1)/2} + 2^m \\pm 2^{(m+1)/2} + 1</span>  and  <span class="math">L = 2^{m+1} \\pm 2^{(m+3)/2} + 2</span> .</p>

    <p class="text-gray-300">One can compute a bilinear pairing by computing the  <span class="math">\\eta_T</span>  pairing and raising to the power of M. However, it is actually more efficient to compute the full Tate pairing with  <span class="math">\\eta_T^{\\frac{M2T}{L}}</span> . By factoring M we get the product</p>

    <p class="text-gray-300"><span class="math">$M = (2^{6m} - 1)(2^m \\mp 2^{(m+1)/2} + 1)(2^{3m} \\mp 2^{(3m+1)/2} + 1)</span>$</p>

    <p class="text-gray-300">Note that L can be written as  <span class="math">L = 2(2^m \\mp 2^{(m+1)/2} + 1)</span> , which cancels out with the middle factor of M and the squaring of the  <span class="math">\\eta_T</span>  function. The exponent to compute the Tate pairing is now;</p>

    <p class="text-gray-300"><span class="math">$(2^{6m} - 1)(2^{3m} \\mp 2^{(3m+1)/2} + 1)(\\mp 2^{(3m+1)/2} - 1)</span>$</p>

    <p class="text-gray-300">Some cancellations occur whilst unrolling the multiplication of the second and third factor, and we get</p>

    <p class="text-gray-300"><span class="math">$(2^{6m} - 1)(2^{3m} \\mp 2^{4m}2^{(m+1)/2} - 1)</span>$</p>

    <p class="text-gray-300">Note that raising an element to the power of  <span class="math">2^{6m}</span>  over  <span class="math">\\mathbb{F}_{2^{12m}}</span>  can be computed with a simple conjugation. Also note that, once the powering to  <span class="math">(2^{6m}-1)</span>  has been performed, we have  <span class="math">z^{2^{6m}+1}=1</span>  and so  <span class="math">z^{-1}=z^{2^{6m}}</span> , i.e., computing an inverse is done by simple conjugation. Using these facts, we can compute the final exponentiation in (m+1)/2 squarings, 4 Frobenius actions, 2 multiplications and a division.</p>

      <h3 id="sec-7.6" class="text-xl font-semibold mt-8">7.6 Compression of pairing values</h3>

    <p class="text-gray-300">After the final exponentiation our pairing values lie in the subgroup of order  <span class="math">(q^4 - q^2 + 1)</span>  in  <span class="math">\\mathbb{F}_{q^{12}}^*</span> . This subgroup is the torus  <span class="math">T_6(\\mathbb{F}_{q^2})</span>  so we can represent the field elements using 2 elements of  <span class="math">\\mathbb{F}_{q^2}</span>  rather than 6. This gives compression by a factor of 3. The details are similar to those given by [17].</p>

      <h3 id="sec-7.7" class="text-xl font-semibold mt-8">7.7 Computing BKLS-GHS using octupling</h3>

    <p class="text-gray-300">In this section we will briefly look at computing the Tate pairing using the BKLS-GHS algorithm, degenerate divisors and the fast octupling operation defined previously. At first glance, the group order  <span class="math">N \\approx 2^{2m}</span>  requires about 2m/3 iterations of the octupling formula, so the BKLS-GHS method looks competitive. However, care is needed as the additions will destroy the special form of the divisor. The best approach is to postpone the additions until the end. In other words, compute the appropriate functions for  <span class="math">2^{2m}P</span> ,  <span class="math">2^{(3m+1)/2}P</span> ,  <span class="math">2^mP</span>  and  <span class="math">2^{(m+1)/2}P</span>  separately in different loops and then add them up at the end.</p>

    <p class="text-gray-300">Let  <span class="math">h_1, h_2, h_3</span>  be the functions that arise from Cantor composition and reduction of the divisors that occur at  <span class="math">2^{2m}P</span> ,  <span class="math">2^{(3m+1)/2}P</span> ,  <span class="math">2^mP</span>  and  <span class="math">2^{(m+1)/2}P</span> . The function we desire is then:</p>

    <p class="text-gray-300"><span class="math">$f = f_{2^{2m}} f_{2^{(3m+1)/2}} f_{2^m} f_{2^{(m+1)/2}} h_1 h_2 h_3</span>$</p>

    <p class="text-gray-300">This can be computed using 2m/3 octuplings, as well as a few additions and doublings. The powers of 8 can also be absorbed as is done in Appendix B, however as each function is raised to a different power, we require four different sets of formulae. We can take some advantage of similarities between the four functions however, to speed up the computation. The end result is an efficient if messy pairing computation. See section 10 for timings.</p>

    </section>

    <section id="sec-8" class="mb-10">
      <h2 class="text-2xl font-bold">8 The Duursma-Lee hyperelliptic curves</h2>

    <p class="text-gray-300">Duursma and Lee [10] also consider the curves  <span class="math">C: y^2 = x^p - x + d</span>  over  <span class="math">\\mathbb{F}_{p^m}</span>  where  <span class="math">p \\ge 5</span>  and  <span class="math">d \\ne 0</span> . The genus of C is (p-1)/2. When  <span class="math">p \\equiv 3 \\pmod 4</span>  the embedding degree is k = 2p and  <span class="math">\\# \\operatorname{Jac}(C)(\\mathbb{F}_{p^m}) \\mid (p^{mp} + 1)</span> . The distortion map is  <span class="math">\\psi(x, y) = (\\rho - x, iy)</span>  where  <span class="math">i^2 = -1</span>  and  <span class="math">\\rho^p - \\rho + 2d = 0</span> .</p>

    <p class="text-gray-300">Duursma and Lee [10] show that  <span class="math">p((x,y)-(\\infty))</span>  is equivalent to  <span class="math">(x^{p^2}+2d,-y^{p^2})</span> . Let  <span class="math">q=p^m</span>  where m is coprime to 2p. Let  <span class="math">\\phi(x,y)=(x+2d,-y)</span> . If  <span class="math">P\\in C(\\mathbb{F}_{p^m})</span>  then it follows that  <span class="math">q((P)-(\\infty))</span>  is equivalent to  <span class="math">(\\phi^m(P))-(\\infty)</span> . Hence we set  <span class="math">\\gamma=\\phi^m</span> .</p>

    <p class="text-gray-300">We check condition (3) for this case. Note that  <span class="math">\\rho^p = \\rho - 2d</span> .</p>

    <p class="text-gray-300">If  <span class="math">p \\equiv 3 \\pmod{4}</span>  then we have (since <em>m</em> is odd)</p>

    <p class="text-gray-300">$$\\gamma \\psi^{q} = \\phi^{m} \\psi^{p^{m}}(x, y)
= \\phi^{m} (\\rho^{p^{m}} - x, i^{p^{m}} y)
= \\phi^{m} (\\rho - 2dm - x, -iy)
= (\\rho - x, iy)
= \\psi(x, y).$$</p>

    <p class="text-gray-300">Having established this, we set  <span class="math">N = p^{pm} + 1</span> ,  <span class="math">T = p^m</span> , c = 0, a = p and L = 1 and apply Theorem 1 to show that the eta pairing approach recovers the results of Duursma and Lee</p>

    <p class="text-gray-300">If  <span class="math">p \\equiv 1 \\pmod{4}</span>  then the embedding degree is k = p and our methods do not immediately apply. Theorem 1 can be generalised so that condition 3 reads  <span class="math">T^a - 1 = LN</span> , in which case we may choose a = p. But when  <span class="math">p^m \\equiv 1 \\pmod{4}</span>  we have  <span class="math">i^{p^m} = i</span>  and so condition (3) is not satisfied.</p>

    <p class="text-gray-300">There are two natural open problems for these curves. The first is to develop an eta pairing for the cases where  <span class="math">p \\equiv 1 \\pmod{4}</span> . The second natural problem is to give the further halving of the loop for these curves. We leave these problems for future research.</p>

    </section>

    <section id="sec-9" class="mb-10">
      <h2 class="text-2xl font-bold">9 The Rubin-Silverberg approach</h2>

    <p class="text-gray-300">Rubin and Silverberg [25] (also see [26, 29]) have proposed an alternative way to view pairings on Abelian varieties. Their method can be thought of as a method for computing pairings on trace zero subvarieties of Weil restrictions of elliptic curves. A simpler</p>

    <p class="text-gray-300">way to think about their method is as a form of point compression for pairings on elliptic curves.</p>

    <p class="text-gray-300">The Jacobian of the supersingular genus 2 curve considered in Section 7 is a 2-dimensional Abelian variety over  <span class="math">\\mathbb{F}_{2^m}</span>  with embedding degree k=12. Another way to get this Abelian variety (up to isogeny) is with the Rubin-Silverberg approach, by taking the k=4 elliptic case and using the Rubin-Silverberg construction with r=3, to obtain a 2-dimensional Abelian variety with embedding degree  <span class="math">3 \\times 4 = 12</span> . We recall the details in this case.</p>

    <p class="text-gray-300">Let  <span class="math">E_b: y^2 + y = x^3 + x + b</span>  with b = 0, 1 over  <span class="math">\\mathbb{F}_2</span>  be the supersingular elliptic curves with embedding degree k = 4. The idea of Rubin and Silverberg is to compute pairings with points defined over  <span class="math">\\mathbb{F}_{2^{3m}}</span>  where m is coprime to 12. This means that pairing values lie in  <span class="math">\\mathbb{F}_{2^{12m}}</span> .</p>

    <p class="text-gray-300">To transmit group elements, Rubin and Silverberg propose a compression method so that the element is represented using only 2 elements in  <span class="math">\\mathbb{F}_{2^m}</span> . Hence, the bandwidth is about  <span class="math">2^m</span>  bits but the finite field security is  <span class="math">2^{12^m}</span> , which corresponds to 'security multiplier 6'.</p>

    <p class="text-gray-300">The group  <span class="math">E(\\mathbb{F}_{2^{3m}})</span>  clearly has  <span class="math">E(\\mathbb{F}_{2^m})</span>  as a subgroup. Indeed, we can write</p>

    <p class="text-gray-300"><span class="math">$E(\\mathbb{F}_{2^{3m}}) \\cong E(\\mathbb{F}_{2^m}) \\times A</span>$</p>

    <p class="text-gray-300">where A is a finite group and one can check that the order of A is  <span class="math">2^{2m} \\pm 2^{(3m+1)/2} + 2^m \\pm 2^{(m+1)/2} + 1</span> . Note that this agrees with the group orders in Table 3.</p>

    <p class="text-gray-300">The following result is an important classification of A.</p>

    <p class="text-gray-300"><strong>Lemma 10.</strong> Let m be coprime to 12. Let  <span class="math">\\operatorname{Tr}</span>  be the trace map with respect to  <span class="math">\\mathbb{F}_{2^{3m}}/\\mathbb{F}_{2^m}</span> . Then  <span class="math">A = \\{P \\in E(\\mathbb{F}_{2^{3m}}) : \\operatorname{Tr}(P) = 0\\}</span> .</p>

    <p class="text-gray-300">The method is to perform pairing computations with the curve E over  <span class="math">\\mathbb{F}_{2^{3m}}</span>  so that the pairing values lie in  <span class="math">\\mathbb{F}_{2^{12m}}</span> . Suitable group orders are the same as in the genus 2 case (e.g. m = 103 with a 192-bit subgroup).</p>

    <p class="text-gray-300">Write  <span class="math">\\mathbb{F}_{2^{3m}}</span>  as  <span class="math">\\mathbb{F}_{2^m}(\\theta)</span>  where  <span class="math">\\theta^3 = \\theta + 1</span> . So points in  <span class="math">E(\\mathbb{F}_{2^{3m}})</span>  are represented as (x, y) where x is represented as a triple  <span class="math">(x_0, x_1, x_2)</span>  over  <span class="math">\\mathbb{F}_{2^m}</span>  with respect to the basis  <span class="math">\\{1, \\theta, \\theta^2\\}</span> .</p>

    <p class="text-gray-300">To transmit a point we first apply point compression so that we need send only the x-coordinate and a single bit determining the sign (sometimes even this bit can be removed). Then to transmit the x-coordinate just send  <span class="math">x_0</span>  and  <span class="math">x_1</span>  (and possibly another bit).</p>

    <p class="text-gray-300">To recover (decompress) we must do the following: Given  <span class="math">x_0</span>  and  <span class="math">x_1</span>  compute an element  <span class="math">x_2 \\in \\mathbb{F}_{2^m}</span>  such that there is a point P with x-coordinate  <span class="math">(x_0, x_1, x_2)</span>  which satisfies Tr(P) = 0.</p>

    <p class="text-gray-300">In this case the trace is  <span class="math">\\text{Tr}(P) = P + \\pi(P) + \\pi^2(P)</span>  where  <span class="math">\\pi</span>  is the  <span class="math">2^m</span> -power Frobenius map. So the condition is that P,  <span class="math">\\pi(P)</span>  and  <span class="math">\\pi^2(P)</span>  sum to zero, or in other words, lie on a straight line. The decompression procedure is to deduce which  <span class="math">x_2</span>  ensures that there is a line l(x, y) = 0 through the three points.</p>

    <p class="text-gray-300">Let  <span class="math">P=(x_P,y_P)</span>  and write  <span class="math">l(x,y)=y+u_0x+u_1</span>  where  <span class="math">u_0,u_1\\in\\mathbb{F}_{2^{3m}}</span> . Define  <span class="math">\\bar{l}(x,y)=l(x,y)+1</span> . Then</p>

    <p class="text-gray-300"><span class="math">$l(x,y)\\overline{l}(x,y) = y^2 + y + (u_0x + u_1) + (u_0x + u_1)^2</span>$</p>

    <p class="text-gray-300">=  <span class="math">x^3 + u_0^2x^2 + (u_0 + 1)x + (u_1^2 + u_1 + b)</span> .</p>

    <p class="text-gray-300">Also,</p>

    <p class="text-gray-300"><span class="math">$l(x, y)\\bar{l}(x, y) = (x - x_P)(x - x_{\\pi(P)})(x - x_{\\pi^2(P)}) = x^3 + Tx^2 + Sx + N</span>$</p>

    <p class="text-gray-300">from which we deduce that  <span class="math">T = S^2 + 1</span> . One can check that  <span class="math">T = x_0</span>  and  <span class="math">S = x_0^2 + x_1^2 + x_1x_2 + x_2^2</span> . Hence  <span class="math">x_2</span>  is a solution to the equation</p>

    <p class="text-gray-300"><span class="math">$y^4 + x_1 y^2 + (x_0^4 + x_0 + 1 + x_1^2) = 0.</span>$</p>

    <p class="text-gray-300">Solving this equation involves solving a quadratic and then taking square roots. A single bit is needed to distinguish the two roots of the quadratic and to ensure a unique solution to the decompression process.</p>

    <p class="text-gray-300">The total cost is solving a quadratic and then taking a square root, plus solving another quadratic to recover the <em>y</em>-coordinate of the point.</p>

    <p class="text-gray-300">From a performance point of view it is essential to compare the running time of the pairing computation on the genus 2 curve with the Rubin-Silverberg method. In a general implementation, where we may be required to compute the pairing of general divisors on the genus 2 curve, then the Rubin-Silverberg approach may be superior.</p>

    </section>

    <section id="sec-10" class="mb-10">
      <h2 class="text-2xl font-bold">10 Experimental results</h2>

    <p class="text-gray-300">We have proposed a number of algorithms for pairing computation which apply to different supersingular curves. The only natural way to compare these methods is to give running times for equivalent security levels. A precise formulation of 'equivalent security' is deeply problematic, but a reasonable approach is to consider parameters so that the value  <span class="math">q^k</span>  is roughly the same. This would mean that the cost of index calculus in the finite field is roughly equal for all examples. Two different field sizes are chosen for testing. Firstly, 950-bit finite fields with (g=1)  <span class="math">q=2^{239}</span> , (g=1)  <span class="math">q=3^{97}</span> , (g=2)  <span class="math">q=2^{79}</span> , and 1230-bit finite fields with (g=1)  <span class="math">q=2^{307}</span> , (g=1)  <span class="math">q=3^{127}</span> , (g=2)  <span class="math">q=2^{103}</span> .</p>

    <p class="text-gray-300">As noted, there are two different ways to view the dimension two case, the first using the genus 2 curve directly, and the second using the Rubin-Silverberg approach. The relative performance is seen by comparing the running time of the pairing on the Jacobian of the curve over  <span class="math">\\mathbb{F}_{2^m}</span>  with the pairing on  <span class="math">E(\\mathbb{F}_{2^{3m}})</span> . The latter will be roughly the same as the cost of a pairing on  <span class="math">E(\\mathbb{F}_{2^m})</span>  where  <span class="math">m&#x27; \\approx 3m</span> . Note that this does not take into account the cost of conversion between the Rubin-Silverberg Abelian variety representation and the elliptic curve over the larger field.</p>

    <p class="text-gray-300">Table 5 gives some running times for calculating the 950-bit case, and Table 6 the running times for the 1230-bit case. As noted earlier, we use the notation  <span class="math">\\eta</span>  for the eta pairing with T=q and write  <span class="math">\\eta_T</span>  for the faster variant with T=q-N. In both tables, cases 1 to 3 illustrate the computation of the  <span class="math">\\eta</span>  pairing for the elliptic characteristic 2 and 3 cases, as well as the genus 2, characteristic 2 case. Cases 4 to 7 give timings for the computation of the  <span class="math">\\eta_T</span>  pairing, where the genus 2 &quot;general&quot; case is a general divisor, rather than a divisor with one point on it as is the case for the third and sixth entries in the tables. The final case in Table 6 gives a time for computing the Tate pairing using BKLS-GHS.</p>

    <p class="text-gray-300">The first observation to make from the tables is that the new  <span class="math">\\eta_T</span>  method is clearly superior to the  <span class="math">\\eta</span>  generalisation of the Duursma-Lee method for all cases. In Table 5, the</p>

    <p class="text-gray-300"><strong>Table 5.</strong> Running times for pairing computation (950-bit finite field).</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">case</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">curve</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">optimisation</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">pairing time (ms)</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">E(\\mathbb{F}_{2^{239}})</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">elliptic char 2 &eta;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.16</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">E(\\mathbb{F}_{3^{97}})</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">elliptic char 3 (see [17])</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.05</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">C(\\mathbb{F}_{2^{79}})</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">genus 2 <span class="math">\\eta</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.95</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">E(\\mathbb{F}_{2^{239}})</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">elliptic char 2 <span class="math">\\eta_T</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.70</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">E(\\mathbb{F}_{3^{97}})</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">elliptic char 3 <span class="math">\\eta_T</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.72</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">C(\\mathbb{F}_{2^{79}})</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">genus 2 <span class="math">\\eta_T</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.25</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">C(\\mathbb{F}_{2^{79}})</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">genus 2 general <span class="math">\\eta_T</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.20</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300"><strong>Table 6.</strong> Running times for pairing computation (1230-bit finite field).</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">case</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">curve</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">optimisation</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">pairing time (ms)</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">E(\\mathbb{F}_{2^{307}})</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">elliptic char 2 <span class="math">\\eta</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.83</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">E(\\mathbb{F}_{3^{127}})</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">elliptic char 3 <span class="math">\\eta</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8.42</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">C(\\mathbb{F}_{2^{103}})</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">genus 2 <span class="math">\\eta</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.00</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">E(\\mathbb{F}_{2^{307}})</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">elliptic char 2 <span class="math">\\eta_T</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.50</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">E(\\mathbb{F}_{3^{127}})</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">elliptic char 3 <span class="math">\\eta_T</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.36</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">C(\\mathbb{F}_{2^{103}})</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">genus 2 <span class="math">\\eta_T</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.87</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">C(\\mathbb{F}_{2^{103}})</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">genus 2 general <span class="math">\\eta_T</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.42</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">C(\\mathbb{F}_{2^{103}})</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">genus 2 BKLS-GHS</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.15</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">elliptic char 2 case is 46% faster, the elliptic char 3 case is 32% faster, and the genus 2 char 2 case is 36% faster.</p>

    <p class="text-gray-300">The second observation is that the genus 2  <span class="math">\\eta_T</span>  pairing is considerably faster than either of the elliptic cases for both levels of security. In Table 5, the genus 2  <span class="math">\\eta_T</span>  case is 26% faster than the elliptic char 2 case, and 54% faster than the elliptic char 3 case. The difference is even more pronounced in Table 6. The timings for the genus 2 BKLS-GHS method confirm the surprising observation that the BKLS-GHS method is roughly computationally equivalent to the  <span class="math">\\eta</span>  method in the genus 2 case.</p>

    <p class="text-gray-300">One of the potential advantages of using hyperelliptic curves is that the base field can be much smaller than that required for an elliptic curve, for the same level of security. Great potential savings can be realised if an element of the base field can be represented in a single machine word, rather than using a multi-precision representation, and for comparison with elliptic curves we regard it as quite &quot;fair&quot; to try to exploit this feature.</p>

    <p class="text-gray-300">So in implementing arithmetic in the field  <span class="math">\\mathbb{F}_{2^{103}}</span>  and  <span class="math">\\mathbb{F}_{2^{79}}</span>  we take advantage of the 128-bit registers available to those processors, like the Pentium IV, which support the SSE2 instruction set, and have written a special function to carry out field multiplication using SSE2 instructions. This is twice as fast as a standard multi-precision implementation, and improves the overall timings by about 50%.</p>

    <p class="text-gray-300">All timings were done on a Pentium IV running at 3 GHz.</p>

    <p class="text-gray-300">We have presented the eta pairing approach to compute pairings on supersingular curves. This approach generalises and clarifies the Duursma-Lee algorithm. We have provided full examples of the method in characteristic 2 for genus 1 and 2, which turn out to be very efficiently implementable.</p>

    <p class="text-gray-300">We are grateful to Alice Silverberg for discussions regarding section 9, to Eunjeong Lee for pointing out a missing validity condition for theorem 1, and to Tanja Lange for some comments.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>P. S. L. M. Barreto. A note on efficient computation of cube roots in characteristic 3. Cryptology ePrint Archive, Report 2004/305, 2004. Available from http://eprint.iacr.org/ 2004/305.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>P. S. L. M. Barreto. The well-tempered pairing. In <em>8th Workshop on Elliptic Curve Cryptography &ndash; ECC'2004</em>, Bochum, Germany, 2004. Invited talk.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>P. S. L. M. Barreto, H. Y. Kim, B. Lynn, and M. Scott. Efficient algorithms for pairing-based cryptosystems. In <em>Advances in Cryptology &ndash; Crypto'2002</em>, volume 2442 of <em>Lecture Notes in Computer Science</em>, pages 354&ndash;368. Springer-Verlag, 2002.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>P. S. L. M. Barreto, B. Lynn, and M. Scott. Efficient implementation of pairing-based cryptosystems. <em>Journal of Cryptology</em>, 17(4):321&ndash;334, 2004.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>P. S. L. M. Barreto and M. Naehrig. Pairing-friendly elliptic curves of prime order. In <em>Selected Areas in Cryptography &ndash; SAC'2005</em>, Lecture Notes in Computer Science. Springer-Verlag, 2005. to appear.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>I. F. Blake, G. Seroussi, and N. P. Smart. <em>Advances in elliptic curve cryptography</em>. Cambridge, 2005.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>D. Boneh and M. Franklin. Identity-based encryption from the Weil pairing. <em>SIAM Journal of Computing</em>, 32(3):586&ndash;615, 2003.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>D. G. Cantor. Computing in the jacobian of a hyperelliptic curve. <em>Math. Comp.</em>, 48(177):95&ndash; 101, 1987.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>R. Dutta, R. Barua, and P. Sarkar. Pairing-based cryptography: A survey. Cryptology ePrint Archive, Report 2004/064, 2004. http://eprint.iacr.org/2004/064.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>I. Duursma and H.-S. Lee. Tate pairing implementation for hyperelliptic curves <em>y</em> <sup>2</sup> = <em>x <sup>p</sup></em> &minus; <em>x</em>+ <em>d</em>. In <em>Advances in Cryptology &ndash; Asiacrypt'2003</em>, volume 2894 of <em>Lecture Notes in Computer Science</em>, pages 111&ndash;123. Springer-Verlag, 2003.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>I. Duursma and K. Sakurai. Efficient algorithms for the jacobian variety of hyperelliptic curves <em>y</em> <sup>2</sup> = <em>x <sup>p</sup></em>&minus;<em>x</em>+1 over a finite field of odd characteristic <em>p</em>. In <em>Coding theory, cryptography and related areas (Guanajuato, 1998)</em>, pages 73&ndash;89. Springer-Verlag, 2000.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>K. Fong, D. Hankerson, J. Lopez, and A. Menezes. Field inversion and point halving revis- &acute; ited. Technical report CORR 2003-18, University of Waterloo, 2002.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>G. Frey and T. Lange. Fast bilinear maps from the tate-lichtenbaum pairing on hyperelliptic curves, 2005.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>G. Frey and H.-G. Ruck. A remark concerning &uml; <em>m</em>-divisibility and the discrete logarithm problem in the divisor class group of curves. <em>Math. Comp.</em>, 52:865&ndash;874, 1994.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>S. Galbraith, K. Harrison, and D. Soldera. Implementing the Tate pairing. In <em>Algorithmic Number Theory ANTS V</em>, volume 2369 of <em>Lecture Notes in Computer Science</em>, pages 324&ndash;337. Springer-Verlag, 2002.</li>
    </ol></li>
      <li><p class="text-gray-300">S. D. Galbraith. Supersingular curves in cryptography. In ASIACRYPT 2001, volume 2248 of Lecture Notes in Computer Science, pages 495&ndash;513. Springer-Verlag, 2001.</p></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>R. Granger, D. Page, and M. Stam. On small characteristic algebraic tori in pairing-based cryptography. Cryptology ePrint Archive, Report 2004/132, 2004.</li>
    </ol></li>
      <li><p class="text-gray-300">M. Katagi, T. Akishita, I. Kitamura, and T. Takagi. Some improved algorithms for hyperelliptic curve cryptosystems using degenerate divisors. In <em>ICISC</em> 2004, volume 3506, pages 296&ndash;312. Springer-Verlag, 2005.</p></li>
      <li><p class="text-gray-300">M. Katagi, I. Kitamura, T. Akishita, and T. Takagi. Novel efficient implementations of hyperelliptic curve cryptosystems using degenerate divisors. In <em>Information Security Applications</em> &ndash; WISA'2004, volume 3325 of <em>Lecture Notes in Computer Science</em>, pages 345&ndash;359. Springer-Verlag. 2005.</p></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>N. Koblitz. Hyperelliptic cryptosystems. Journal of Cryptology, 1(3):139-150, 1989.</li>
    </ol></li>
      <li><p class="text-gray-300">S. Kwon. Efficient Tate pairing computation for supersingular elliptic curves over binary fields. Cryptology ePrint Archive, Report 2004/303, 2004. http://eprint.iacr.org/ 2004/303.</p></li>
      <li><p class="text-gray-300">T. Lange. Formulae for arithmetic on genus 2 hyperelliptic curves. In Applicable Algebra in Engineering, Communication and Computing, Online publication. Springer-Verlag, 2004. http://www.springerlink.com/openurl.asp?genre=article&amp;id=doi:10.1007/s0%0200-004-0154-8.</p></li>
      <li><p class="text-gray-300">T. Lange and M. Stevens. Efficient doubling on genus two curves over binary fields. In Selected Areas in Cryptography &ndash; SAC'2004, volume 3357 of Lecture Notes in Computer Science, pages 170&ndash;181. Springer-Verlag, 2004.</p></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>V. S. Miller. Short programs for functions on curves. Unpublished manuscript, 1986. http://crypto.stanford.edu/miller/miller.pdf.</li>
    </ol></li>
      <li><p class="text-gray-300">K. Rubin and A. Silverberg. Supersingular abelian varieties in cryptology. In Advances in Cryptology - Crypto'2002, volume 2442 of Lecture Notes in Computer Science, pages 336&ndash;353. Springer-Verlag, 2002.</p></li>
      <li><p class="text-gray-300">K. Rubin and A. Silverberg. Using primitive subgroups to do more with fewer bits. In Algorithmic Number Theory &ndash; ANTS VI, volume 3076 of Lecture Notes in Computer Science, pages 18&ndash;41. Springer-Verlag, 2004.</p></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>M. Scott. Faster identity based encryption. <em>Electronics Letters</em>, 40(14):861, 2004.</li>
    </ol></li>
      <li><p class="text-gray-300">M. Scott and P. Barreto. Compressed pairings. In Advances in Cryptology Crypto' 2004, volume 3152 of Lecture Notes in Computer Science, pages 140&ndash;156. Springer-Verlag, 2004. Also available from http://eprint.iacr.org/2004/032/.</p></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A. Silverberg. Compression for trace zero subgroups of elliptic curves. Preprint, 2004. Available from http://www.math.uci.edu/~asilverb/bibliography/compress.pdf.</li>
    </ol></li>
      <li><p class="text-gray-300">J. H. Silverman. The Arithmetic of Elliptic Curves. Number 106 in Graduate Texts in Mathematics. Springer-Verlag, Berlin, Germany, 1986.</p></li>
    </ul>

    <p class="text-gray-300">We now derive an explicit expression for the function  <span class="math">f_{8,P}</span>  needed for Miller's algorithm on the supersingular hyperelliptic curve  <span class="math">C_b: y^2 + y = x^5 + x^3 + b</span> .</p>

    <p class="text-gray-300">Let  <span class="math">P = (x_P, y_P)</span> . We will consider divisors  <span class="math">D_n = n(P) - n(\\infty)</span> . To achieve this we will consider the <strong>reduced</strong> divisor (via Cantor's algorithm)  <span class="math">D&#x27;_n</span>  which is equivalent to  <span class="math">D_n</span> . We will consider functions such that  <span class="math">D_n = D&#x27;_n + (f_n)</span> .</p>

    <p class="text-gray-300">The divisor  <span class="math">D_1 = (P) - (\\infty)</span>  has Mumford representation</p>

    <p class="text-gray-300"><span class="math">$(a_1(x), b_1(x)) = (x + x_P, y_P).</span>$</p>

    <p class="text-gray-300">We take the function  <span class="math">f_1 = 1</span> .</p>

    <p class="text-gray-300">Now consider  <span class="math">D_2 = 2(P) - 2(\\infty)</span> . One can show that this divisor has Mumford representation  <span class="math">(a_2(x), b_2(x)) = (x^2 + x_P^2, (x_P^4 + x_P^2)x + y_P^2)</span> . This divisor is reduced (so no reduction step in Cantor's algorithm is performed). Hence  <span class="math">D&#x27;_2 = D_2</span>  and so the function  <span class="math">f_2</span>  may be chosen to be 1.</p>

    <p class="text-gray-300">Now consider  <span class="math">D_4 = 4(P) - 4(\\infty)</span> . The Mumford representation (after performing the composition step of Cantor's algorithm) is</p>

    <p class="text-gray-300"><span class="math">$(a_4(x), b_4(x)) = (x^4 + x_P^4, x^3 + (x_P^8 + x_P^4)x^2 + (x_P^4)x + y_P^4).</span>$</p>

    <p class="text-gray-300">This divisor is not reduced. We have  <span class="math">(b_4^2 + b_4 + x^5 + x^3 + b)/a_4(x) = a_4&#x27;(x) = x^2 + x + (x_P^{16} + x_P^8)</span>  and  <span class="math">b_4&#x27;(x) := b_4(x) + 1 \\pmod{a_4&#x27;(x)} = (x_P^{16} + 1)x + (y_P^8 + x_P^8 + x_P^{24} + 1)</span> .</p>

    <p class="text-gray-300">We must consider functions and divisors. The divisor  <span class="math">D_4</span>  is equivalent to the divisor  <span class="math">D_4&#x27; = E - 2(\\infty)</span>  where E is effective. The divisor  <span class="math">D_4&#x27;</span>  has the Mumford representation  <span class="math">(a_4&#x27;(x), b_4&#x27;(x))</span>  given above. Denote by  <span class="math">\\overline{E}</span>  the 'negative' of E. The function  <span class="math">a_4(x)</span>  has divisor  <span class="math">4(P) + 4(\\overline{P}) - 8(\\infty)</span>  while the function  <span class="math">a_4&#x27;(x)</span>  has divisor  <span class="math">E + \\overline{E} - 4(\\infty)</span> . The function  <span class="math">y + b_4(x)</span>  has divisor  <span class="math">4(P) + \\overline{E} - 6(\\infty)</span>  while the function  <span class="math">y + b_4(x) + 1</span>  has divisor  <span class="math">4(\\overline{P}) + E - 6(\\infty)</span> . It follows that</p>

    <p class="text-gray-300"><span class="math">$((y + b_4(x))/a_4&#x27;(x)) = 4(P) - E - 2(\\infty).</span>$</p>

    <p class="text-gray-300">Hence we define  <span class="math">f_4 = (y + b_4(x))/a&#x27;_4(x)</span>  and we have  <span class="math">D_4 = D&#x27;_4 + (f_4)</span> .</p>

    <p class="text-gray-300">Now for the final step (thankfully!). We double the divisor  <span class="math">D_4&#x27;</span>  using Cantor's composition rule to obtain  <span class="math">D_8&#x27;&#x27; = 2E - 4(\\infty)</span> . Note that  <span class="math">D_8 = 2D_4 = 2(D_4&#x27; + (f_4)) = D_8&#x27;&#x27; + (f_4^2)</span> . One computes the Mumford representation of  <span class="math">D_8&#x27;&#x27;</span>  to be</p>

    <p class="text-gray-300"><span class="math">$(a_8&#x27;&#x27;(x), b_8&#x27;&#x27;(x)) = (a_4&#x27;(x)^2, (x_P^{32} + 1)x^2 + (x_P^{32} + x_P^{16})x + (y_P^{16} + x_P^{16} + x_P^{48} + 1))</span>$</p>

    <p class="text-gray-300">and one can check that  <span class="math">((b_8&#x27;&#x27;)^2 + b_8&#x27;&#x27; + f(x))/a_8&#x27;&#x27;(x) = a_8&#x27;(x) = (x + (x_p^{64} + 1))</span> . Thus,  <span class="math">b_8&#x27;(x) := b_8&#x27;&#x27;(x) + 1 \\pmod{a_8&#x27;(x)} = y_p^{64} + x_p^{128} + 1</span> . Define  <span class="math">[8]P = (x_p^{64} + 1, y_p^{64} + x_p^{128} + 1)</span> . We obtain  <span class="math">D_8&#x27; = ([8]P) - (\\infty)</span>  which confirms the octupling formula for the point [8]P. Algorithm 5 describes divisor octupling in detail.</p>

    <p class="text-gray-300">We now consider principal divisors. As before,  <span class="math">y + b_8&#x27;&#x27;(x)</span>  has divisor  <span class="math">2E + (\\overline{[8]P}) - 5(\\infty)</span>  and  <span class="math">(a_8&#x27;(x)) = (\\overline{[8]P}) + (\\overline{[8]P}) - 2(\\infty)</span> . Hence we have  <span class="math">D_8&#x27;&#x27; = D_8&#x27; + (f_8&#x27;)</span>  where  <span class="math">f_8&#x27; = (y + b_8&#x27;&#x27;(x))/a_8&#x27;(x)</span> .</p>

    <p class="text-gray-300">Putting it all together, we get</p>

    <p class="text-gray-300"><span class="math">$(f_8) = 8(P) - ([8]P) - 7(\\infty)</span>$</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">$f_8 = \\left(\\frac{y + b_4(x)}{a_4&#x27;(x)}\\right)^2 \\frac{y + b_8&#x27;&#x27;(x)}{a_8&#x27;(x)}.</span>$</p>

    <h3 id="sec-misc-2" class="text-xl font-semibold mt-8"><strong>Algorithm 5</strong> Octupling of a divisor [u, v]</h3>

    <pre><code class="language-text">INPUT: divisor [u, v].

OUTPUT: [u&#x27;, v&#x27;] = 8[u, v].

1: if deg(u) = 2 then \\triangleright [u, v] = [x^2 + u_1x + u_0, v_1x + v_0]

2: [u&#x27;, v&#x27;] \\leftarrow [x^2 + u_1^{64}x + (u_1 + u_0 + 1)^{64}, (v_1 + u_1)^{64}x + (u_1 + u_0 + v_1 + v_0 + 1)^{64}]

3: else if deg(u) = 1 then \\triangleright [u, v] = [x + u_0, v_0]

4: [u&#x27;, v&#x27;] \\leftarrow [x + (u_0 + 1)^{64}, (v_0 + u_0^2 + 1)^{64}]

5: else \\triangleright [u, v] = [1, 0]

6: [u&#x27;, v&#x27;] \\leftarrow [1, 0]

7: end if
</code></pre>

      <h3 id="app-b.1" class="text-xl font-semibold mt-8"><strong>B.1</strong> Precomputation</h3>

    <p class="text-gray-300">We will precompute a table of powers of  <span class="math">x_P</span>  and  <span class="math">y_P</span>  (these are the initial input values for the point P) labelled as</p>

    <p class="text-gray-300"><span class="math">$x_P^{(i)} = \\pi^i(x_P) = x_P^{2^i}</span>$
, and  <span class="math">y_P^{(i)} = \\pi^i(y_P) = y_P^{2^i}</span></p>

    <p class="text-gray-300">for i = 0, 1, ..., m - 1.</p>

    <p class="text-gray-300">We focus on computing the term  <span class="math">f_{8,P}(\\psi(Q))</span>  (i.e. we do not bring Frobenius actions into this computation).</p>

    <p class="text-gray-300">Note that, at loop iteration i, the current value of the x-coordinate of  <span class="math">[2^{3i}]P</span>  can be written in terms of the precomputed initial values as</p>

    <p class="text-gray-300"><span class="math">$x_P^{(6i)} + \\gamma_1(i)</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\gamma_1(i)</span>  is 1 when i is odd and 0 otherwise. Similarly, the current value of the y-coordinate of  <span class="math">[2^{3i}]P</span>  is</p>

    <p class="text-gray-300"><span class="math">$y_P^{(6i)} + \\gamma_1(i)x_P^{(6i+1)} + \\gamma_3(i)</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\gamma_3(i) = 1</span>  when  <span class="math">i \\equiv 1, 2 \\pmod{4}</span>  and 0 otherwise.</p>

    <p class="text-gray-300">Obviously, in the above the exponents 6i in  <span class="math">x_p^{(6i)}</span>  are taken modulo m. One sees that they wrap around rapidly.</p>

      <h3 id="app-b.2" class="text-xl font-semibold mt-8"><strong>B.2</strong> The <span class="math">\\alpha</span> factor</h3>

    <p class="text-gray-300">Write  <span class="math">\\alpha = (y + b_4(x))^2 \\circ \\psi</span>  as a function of  <span class="math">(x_0, y_0)</span> . We have  <span class="math">(y + b_4(x)) \\circ \\psi =</span></p>

    <p class="text-gray-300"><span class="math">$y + s_2 x^2 + s_1 x + s_0 + (x + w)^3 + (x_P^8 + x_P^4)(x + w)^2 + (x_P^4)(x + w) + y_P^4</span>$</p>

    <p class="text-gray-300">and squaring gives</p>

    <p class="text-gray-300"><span class="math">$y^2 + s_2^2 x^4 + s_1^2 x^2 + s_0^2 + x^6 + x^4 w^2 + x^2 w^4 + w^6 + (x_P^{16} + x_P^8)(x^4 + w^4) + (x_P^8)(x^2 + w^2) + y_P^8.</span>$</p>

    <p class="text-gray-300">Now,
<span class="math">$s_2^2 = (w^4 + 1)^2 = w</span>$
and  <span class="math">s_1^2 = (w^2 + w^4)^2 = w^4 + w + 1</span> . Also,  <span class="math">s_0^2 = s_0 + w^5 + w^3</span> .</p>

    <p class="text-gray-300">Expressing as a 12-tuple we get  <span class="math">\\alpha</span>  as follows: The first component is</p>

    <p class="text-gray-300"><span class="math">$y^2 + x^2 + x^6 + 1 + (x_P^{16} + x_P^8)x^4 + x_P^8x^2 + y_P^8</span>$</p>

    <p class="text-gray-300">and the remaining components are</p>

    <p class="text-gray-300"><span class="math">$(x^4 + x^2, x^4 + 1 + x_p^8, 1 + 1, x^2 + x^2 + x_p^{16} + x_p^8, 1 + 1, 1, 0, 0, 0, 0, 0)</span>$</p>

    <p class="text-gray-300">which can be slightly simplified.</p>

    <p class="text-gray-300">Finally, we want to evaluate this on  <span class="math">(x_Q, y_Q)</span>  and to replace the current value for  <span class="math">x_P</span>  with the precomputed values. We obtain the 12-tuple with first component</p>

    <p class="text-gray-300"><span class="math">$y_O^2 + x_O^6 + (x_P^{(6i+4)} + x_P^{(6i+3)})x_O^4 + (x_P^{(6i+3)} + 1 + \\gamma_1(i))x_O^2 + y_P^{(6i+3)} + \\gamma_1(i)x_P^{(6i+4)} + \\gamma_3(i) + 1</span>$</p>

    <p class="text-gray-300">and remaining components</p>

    <p class="text-gray-300"><span class="math">$(x_O^4 + x_O^2, x_O^4 + x_P^{(6i+3)} + \\gamma_1(i) + 1, 0, x_P^{(6i+4)} + x_P^{(6i+3)}, 0, 1, 0, 0, 0, 0, 0).</span>$</p>

      <h3 id="app-b.3" class="text-xl font-semibold mt-8">B.3 The <span class="math">\\beta</span> factor</h3>

    <p class="text-gray-300">We then do a similar thing for  <span class="math">\\beta = (y + b_g^{&quot;}) \\circ \\psi</span> . We have</p>

    <p class="text-gray-300"><span class="math">$\\beta = y + s_2 x^2 + s_1 x + s_0 + (x_p^{32} + 1)(x + w)^2 + (x_p^{32} + x_p^{16})(x + w) + (y_p^{16} + x_p^{16} + x_p^{48} + 1).</span>$</p>

    <p class="text-gray-300">We expand  <span class="math">s_2 = 1 + w^4</span>  etc and write  <span class="math">x_P^{16} + x_P^{48} = x_P^{16}(1 + x_P^{32})</span> . Hence,  <span class="math">\\beta</span>  can be expressed as a 12-tuple with first component</p>

    <p class="text-gray-300"><span class="math">$y + (x_P^{32})x^2 + (x_P^{32} + x_P^{16})x + y_P^{16} + x_P^{16}(1 + x_P^{32}) + 1</span>$</p>

    <p class="text-gray-300">and remaining components</p>

    <p class="text-gray-300"><span class="math">$(x_P^{32} + x_P^{16}, x + x_P^{32} + 1, 0, x^2 + x, 0, 1, 0, 0, 0, 0, 0).</span>$</p>

    <p class="text-gray-300">Finally, we substitute  <span class="math">(x, y) = (x_Q, y_Q)</span>  and insert the precomputed values  <span class="math">x_P = x_P^{(6i)} + \\gamma_1(i)</span>  and  <span class="math">y_P = y_P^{(6i)} + \\gamma_1(i)x_P^{(6i+1)} + \\gamma_3(i)</span> . Using the formula  <span class="math">\\gamma_1(i)(1 + \\gamma_1(i)) = 0</span>  gives the 12-tuple with first component</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} y_Q + &amp; (x_P^{(6i+5)} + \\gamma_1(i)) x_Q^2 + (x_P^{(6i+5)} + x_P^{(6i+4)}) x_Q \\\\ + &amp; y_P^{(6i+4)} + x_P^{(6i+4)} \\left( x_P^{(6i+5)} + \\gamma_1(i) + 1 \\right) + \\gamma_3(i) + 1. \\end{split}</span>$</p>

    <p class="text-gray-300">and remaining components</p>

    <p class="text-gray-300"><span class="math">$(x_P^{(6i+5)} + x_P^{(6i+4)}, x_Q + x_P^{(6i+5)} + \\gamma_1(i) + 1, 0, x_Q^2 + x_Q, 0, 1, 0, 0, 0, 0, 0).</span>$</p>

    <p class="text-gray-300">It remains to multiply the  <span class="math">\\alpha</span>  and  <span class="math">\\beta</span>  together efficiently. But first we consider how to absorb the powers of 8 into the equations.</p>

      <h3 id="app-b.4" class="text-xl font-semibold mt-8">B.4 Absorbing powers of 8</h3>

    <p class="text-gray-300">We break the computation of the eta pairing  <span class="math">\\eta_T(P,Q)</span>  into two parts, the main part is the loop corresponding to the (m-1)/2 octuplings, and the secondary part is the final two doublings and addition. The main part can be expressed as the product</p>

    <p class="text-gray-300"><span class="math">$\\prod_{i=0}^{(m-3)/2} f_{8,2^{3i}P}(\\psi(Q))^{2^{3(m-3-2i)/2}}</span>$</p>

    <p class="text-gray-300">where  <span class="math">f_{8,2^{3i}P} = \\alpha\\beta</span>  as described previously. The goal of this section is to write this as</p>

    <p class="text-gray-300"><span class="math">$\\prod_{i=0}^{(m-3)/2} f_i</span>$</p>

    <p class="text-gray-300">where each  <span class="math">f_i</span>  is an equation which has the 2-power Frobenius action already brought into the equation. Using the formulae for  <span class="math">\\alpha</span>  and  <span class="math">\\beta</span>  above we will compute  <span class="math">\\alpha^{2^{3(m-3-2i)/2}}</span>  and  <span class="math">\\beta^{2^{3(m-3-2i)/2}}</span> .</p>

    <p class="text-gray-300">To achieve this efficiently requires precomputation of the 2-power Frobenius orbit of the point Q, so define for i = 0, 1, ..., m - 1</p>

    <p class="text-gray-300"><span class="math">$x_Q^{(i)} = x_Q^{2^i}</span>$
and  <span class="math">y_Q^{(i)} = y_Q^{2^i}</span> .</p>

    <p class="text-gray-300">The most delicate part of the argument is handling how w and  <span class="math">s_0</span>  behave under powering by  <span class="math">2^{3(m-3-2i)/2}</span> . Recall that  <span class="math">w^8 = w + 1</span>  from which we deduce</p>

    <p class="text-gray-300">$$s_0^8 = s_0 + w^2
s_0^{8^2} = s_0 + 1
s_0^{8^3} = s_0 + w^2 + 1$$
(5)</p>

    <p class="text-gray-300">Note that m is coprime to 12 and so is odd. We have  <span class="math">w^8 = w + 1</span>  and so, since  <span class="math">(m - 3 - 2i)/2 \\equiv i \\pmod{2}</span>  we have  <span class="math">w^{2^{3(m-3-2i)/2}} = w + \\gamma_1(i)</span> . The same formula holds when w is replaced by  <span class="math">w^2</span>  or  <span class="math">w^4</span> . For  <span class="math">s_0</span>  note that if  <span class="math">m \\equiv 1 \\pmod{4}</span>  then</p>

    <p class="text-gray-300"><span class="math">$s_0^{2^{3(m-3-2i)/2}} = s_0 + \\gamma_1(i)w^2 + \\gamma_3(i)</span>$</p>

    <p class="text-gray-300">while if  <span class="math">m \\equiv 3 \\pmod{4}</span>  then</p>

    <p class="text-gray-300"><span class="math">$s_0^{2^{3(m-3-2i)/2}} = s_0 + \\gamma_1(i)w^2 + \\gamma_3(i) + 1.</span>$</p>

    <p class="text-gray-300">We denote by  <span class="math">\\gamma_4(m, i)</span>  the value  <span class="math">\\gamma_3(i)</span>  when  <span class="math">m \\equiv 1 \\pmod{4}</span>  and  <span class="math">\\gamma_3(i) + 1</span>  otherwise.</p>

      <h3 id="app-b.5" class="text-xl font-semibold mt-8"><strong>B.5</strong> The <span class="math">\\alpha</span> factor</h3>

    <p class="text-gray-300">The basic shape of the term  <span class="math">\\alpha</span>  will be similar to previously, except a few extra terms due to equation (5). The process is simple, just bring the 2-power operation into the formula and simplify the 'exponents'.</p>

    <p class="text-gray-300">The &quot;constant&quot; term will be</p>

    <p class="text-gray-300"><span class="math">$y_Q^{((3m-7-6i)/2)} + (x_Q^{((3m-7-6i)/2)})^3 + (x_P^{((3m-1+6i)/2)} + x_P^{((3m-3+6i)/2)})x_Q^{((3m-6i-5)/2)} + (x_P^{((3m-3+6i)/2)} + 1 + \\gamma_1(i))x_Q^{((3m-7-6i)/2)} + y_P^{((3m-3+6i)/2)} + \\gamma_1(i)x_P^{((3m-1+6i)/2)} + \\gamma_3(i) + 1</span>$</p>

    <p class="text-gray-300">plus when (m-3-2i)/2 is odd (i.e., when <em>i</em> is odd) another term must be added (coming from the fact that  <span class="math">(w^{2j})^8 = w^{2j} + 1</span>  and the  <span class="math">s_0</span>  term). We write this other term as</p>

    <p class="text-gray-300"><span class="math">$\\gamma_1(i) \\left( x_Q^{(3m-7-6i)/2)} + 1 + \\gamma_1(i) + x_P^{((3m-1+6i)/2)} \\right) + \\gamma_4(m,i).</span>$</p>

    <p class="text-gray-300">We can apply  <span class="math">\\gamma_1(i)(1 + \\gamma_1(i)) = 0</span> , cancel various terms and simplify the cubing of  <span class="math">x_O^{((3m-7-6i)/2)}</span> . The expression simplifies to</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} y_Q^{((3m-7-6i)/2)} + (x_P^{((3m-1+6i)/2)} + x_P^{((3m-3+6i)/2)}) x_Q^{((3m-5-6i)/2)} + \\\\ (x_P^{((3m-3+6i)/2)} + 1 + x_Q^{((3m-5-6i)/2)}) x_Q^{((3m-7-6i)/2)} + y_P^{((3m-3+6i)/2)} + \\gamma_5(i) \\end{aligned}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\gamma_5(i) = 1</span>  if  <span class="math">i \\equiv 1 \\pmod{4}</span>  and 0 otherwise.</p>

    <p class="text-gray-300">The remaining terms are (note that there is an additional  <span class="math">\\gamma_1(i)w^2</span>  term due to the  <span class="math">s_0</span>  term):</p>

    <p class="text-gray-300"><span class="math">$(x_Q^{((3m-5-6i)/2)} + x_Q^{((3m-7-6i)/2)})w + (x_Q^{((3m-5-6i)/2)} + x_P^{((3m-3+6i)/2)} + 1)w^2 + (x_P^{((3m-1+6i)/2)} + x_P^{((3m-3+6i)/2)})w^4 + s_0</span>$</p>

    <p class="text-gray-300">As usual, the indices inside round brackets should be reduced modulo m to the range  <span class="math">\\{0, 1, \\ldots, m-1\\}</span> .</p>

      <h3 id="app-b.6" class="text-xl font-semibold mt-8">B.6 The <span class="math">\\beta</span> factor</h3>

    <p class="text-gray-300">We now consider the  <span class="math">\\beta</span>  factor. One sees that the &quot;constant term&quot; of  <span class="math">\\beta^{2^{3((m-3-2i)/2)}}</span>  is</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} y_Q^{((3m-9-6i)/2)} + &amp; (x_P^{((3m+1+6i)/2)} + \\gamma_1(i)) x_Q^{((3m-7-6i)/2)} + (x_P^{((3m+1+6i)/2)} \\\\ &amp; + x_P^{((3m-1+6i)/2)} x_Q^{((3m-9-6i)/2)} + y_P^{(((3m-1+6i)/2)} \\\\ &amp; + x_P^{((3m-1+6i)/2)} (x_P^{((3m+1+6i)/2)} + \\gamma_1(i) + 1) + \\gamma_3(i) + 1 \\end{split}</span>$</p>

    <p class="text-gray-300">plus</p>

    <p class="text-gray-300"><span class="math">$\\gamma_1(i) \\left( x_P^{((3m-1+6i)/2)} + x_Q^{((3m-7-6i)/2)} + \\gamma_1(i) + 1 \\right) + \\gamma_4(m,i).</span>$</p>

    <p class="text-gray-300">This simplifies to</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} y_Q^{((3m-9-6i)/2)} + &amp; (x_P^{((3m+1+6i)/2)} + x_P^{((3m-1+6i)/2)}) x_Q^{((3m-9-6i)/2)} + y_P^{((3m-1+6i)/2)} \\\\ &amp; + x_P^{((3m+1+6i)/2)} (x_P^{((3m-1+6i)/2)} + x_Q^{((3m-7-6i)/2)}) + x_P^{((3m-1+6i)/2)} + \\gamma_5(i) \\end{split}</span>$</p>

    <p class="text-gray-300">The remaining terms are (again, including a  <span class="math">\\gamma_1(i)w^2</span>  term)</p>

    <p class="text-gray-300"><span class="math">$(x_P^{((3m+1+6i)/2)} + x_P^{((3m-1+6i)/2)})w + (x_P^{((3m+1+6i)/2)} + x_Q^{((3m-9-6i)/2)} + 1)w^2 + (x_Q^{((3m-7-6i)/2)} + x_Q^{((3m-9-6i)/2)})w^4 + s_0</span>$</p>

      <h3 id="app-b.7" class="text-xl font-semibold mt-8"><strong>B.7</strong> Simplifying the final operations</h3>

    <p class="text-gray-300">After the loop of (m-1)/2 iterations, it remains to perform two doublings and an addition. For the case in which the input divisors are both of the form  <span class="math">D_i = (P_i) - (\\infty)</span>  the final addition can be skipped as it has no impact on the function. Note that  <span class="math">(2^{(3m+1)/2}+1)D_1 = \\phi(D_1)</span> , where  <span class="math">\\phi(D_1) = (x+1,y+x^2+1) - (\\infty)</span> . Denote by  <span class="math">D_1&#x27;</span>  the reduced divisor  <span class="math">2^{(3m+1)/2}D_1</span> .  <span class="math">D_1&#x27;</span>  is equivalent to  <span class="math">\\phi(D_1) - D_1 = (\\phi(P)) - (P)</span> .</p>

    <p class="text-gray-300">Now, let v be the vertical line through P and -P. So  <span class="math">(v) = (P) + (-P) - 2(\\infty)</span> . Then</p>

    <p class="text-gray-300"><span class="math">$(\\phi(P)) - (P) + (v) = (\\phi(P)) + (-P) - 2(\\infty)</span>$</p>

    <p class="text-gray-300">Hence, by the uniqueness of the reduced divisors in Mumford representation we have</p>

    <p class="text-gray-300"><span class="math">$D&#x27; = (\\phi(P)) + (-P) - 2(\\infty).</span>$</p>

    <p class="text-gray-300">As one of the points on D' is -P, the composition stage of Cantor's algorithm immediately cancels P and -P using a vertical line function. As we don't need to know what the &quot;current&quot; divisor is before the addition, we can also skip the two doublings. We know from Appendix A that the mumford representation of the divisor  <span class="math">D = 4(P) - 4(\\infty)</span>  is  <span class="math">(a_4(x), b_4(x)) = (x^4 + x_P^4, x^3 + (x_P^8 + x_P^4)x^2 + (x_P^4)x + y_P^4)</span> . So, we need to extract the point on the divisor after the (m-1)/2 octupling phase, square the function twice, and then multiply it by the function defined below;</p>

    <p class="text-gray-300"><span class="math">$y + b_4(x) = y + x^3 + (x_P^8 + x_P^4)x^2 + (x_P^4)x + y_P^4</span>$</p>

    <p class="text-gray-300">Building the distortion map into the formula gives us a constant term;</p>

    <p class="text-gray-300"><span class="math">$y + x^2(1 + x + x_P^8 + x_P^4) + x_P^4x + y_P^4</span>$</p>

    <p class="text-gray-300">and the remaining terms are;</p>

    <p class="text-gray-300"><span class="math">$(x^2 + x_P^4, x_P^8 + x_P^4, 1, x^2 + x, 0, 1, 0, 0, 0, 0, 0)</span>$</p>

    <p class="text-gray-300">When we are working with the general divisor case, we cannot skip the final addition as we can for the simple divisor case. For both the doublings and the addition, we need to evaluate the points on the second divisor at the function  <span class="math">y + s_1x^3 + l_2x^2 + l_1x + l_0</span> , where  <span class="math">s_1, l_2, l_1, l_0</span>  come from Cantor's algorithm. After building the distortion map into this formula, we get the &quot;constant&quot; term:</p>

    <p class="text-gray-300"><span class="math">$(y + x^2 + x(s_1x^2 + l_1) + l_2x^2 + l_0)</span>$</p>

    <p class="text-gray-300">and the remaining terms are;</p>

    <p class="text-gray-300"><span class="math">$(s_1x^2 + l_1, x + s_1x + l_2, s_1, x^2 + x, 0, 1, 0, 0, 0, 0)</span>$</p>

    </section>
`;
---

<BaseLayout title="Efficient Pairing Computation on Supersingular Abelian Varie... (2004/375)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2004 &middot; eprint 2004/375
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="e-ffi-cient-pairing-computation-on-supersingular-abelian-2004" />
  </article>
</BaseLayout>
