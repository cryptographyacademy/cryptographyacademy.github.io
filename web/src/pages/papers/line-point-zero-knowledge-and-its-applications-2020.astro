---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/1446';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Line-Point Zero Knowledge and Its Applications';
const AUTHORS_HTML = 'Samuel Dittmer, Yuval Ishai, Rafail Ostrovsky';

const CONTENT = `    <p class="text-gray-300">Line-Point Zero Knowledge and Its Applications*</p>

    <p class="text-gray-300">Samuel Dittmer† Yuval Ishai‡ Rafail Ostrovsky§</p>

    <p class="text-gray-300">We introduce and study a simple kind of proof system called line-point zero knowledge (LPZK). In an LPZK proof, the prover encodes the witness as an affine line <span class="math">\\mathbf{v}(t) \\coloneqq \\mathbf{a}t + \\mathbf{b}</span> in a vector space <span class="math">\\mathbb{F}^n</span>, and the verifier queries the line at a single random point <span class="math">t = \\alpha</span>. LPZK is motivated by recent practical protocols for vector oblivious linear evaluation (VOLE), which can be used to compile LPZK proof systems into lightweight designated-verifier NIZK protocols.</p>

    <p class="text-gray-300">We construct LPZK systems for proving satisfiability of arithmetic circuits with attractive efficiency features. These give rise to designated-verifier NIZK protocols that require only 2-5 times the computation of evaluating the circuit in the clear (following an input-independent preprocessing phase), and where the prover communicates roughly 2 field elements per multiplication gate, or roughly 1 element in the random oracle model with a modestly higher computation cost. On the theoretical side, our LPZK systems give rise to the first linear interactive proofs (Bitansky et al., TCC 2013) that are zero knowledge against a malicious verifier.</p>

    <p class="text-gray-300">We then apply LPZK towards simplifying and improving recent constructions of reusable non-interactive secure computation (NISC) from VOLE (Chase et al., Crypto 2019). As an application, we give concretely efficient and reusable NISC protocols over VOLE for bounded inner product, where the sender's input vector should have a bounded <span class="math">L_{2}</span>-norm.</p>

    <p class="text-gray-300">Zero-knowledge proofs, introduced by Goldwasser, Micali, and Rackoff [29] in the 1980s, are commonly viewed as a gem of theoretical computer science. For many years, they were indeed confined to the theory domain. However, in the past few years we have seen explosive growth in research on concretely efficient zero-knowledge proof systems. This research is motivated by a variety of real-world applications. See [50] for relevant pointers.</p>

    <h2 id="sec-3" class="text-2xl font-bold">Designated-verifier NIZK.</h2>

    <p class="text-gray-300">There are many different kinds of zero-knowledge proof systems. Here we mainly consider the setting of designated-verifier, non-interactive zero knowledge (dv-NIZK), where the proof consists of a single message from the prover to the verifier, but verification requires a secret verification key that is known only to the verifier and is determined during a (reusable) setup phase. Moreover, we consider by default computationally sound proofs, also known as arguments. Designated-verifier NIZK has a rich history starting from [39]; see [43, 40, 19] and references therein for recent works in the area. We will typically consider a more restrictive setting, sometimes referred to as preprocessing NIZK, where also the prover needs to hold secret information. In this variant of dv-NIZK the prover and the verifier engage in a (typically inexpensive and reusable) interaction during an offline preprocessing phase, before the inputs are known. In</p>

    <p class="text-gray-300">*This is a full version of [23].</p>

    <p class="text-gray-300">†Stealth Software Technologies Inc. samuel.dittmer@gmail.com</p>

    <p class="text-gray-300">‡Department of Computer Science, Technion. yuvali@cs.technion.ac.il</p>

    <p class="text-gray-300">§University of California, Los Angeles. Department of Computer Science and Mathematics. rafail@cs.ucla.edu</p>

    <p class="text-gray-300">the end of the interaction the prover and the verifier obtain correlated secret randomness that is consumed by an online protocol in which the prover can prove multiple statements to the verifier. While this preprocessing model will be our default model for NIZK, our results are relevant to both kinds of dv-NIZK.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Efficiency of proof systems.</h4>

    <p class="text-gray-300">We are primarily motivated by the goal of improving the efficiency of zero-knowledge proofs. There are several metrics for measuring efficiency of proof systems. Much of the research in this area focuses on improving succinctness, which refers both to the proof length and to the verifier’s running time. This is highly relevant to the case of publicly verifiable proofs that are generated once and verified many times. However, in the case of a proof that is verified once by a designated verifier, other complexity metrics, such as prover’s running time and space, can become the main performance bottlenecks. Indeed, state-of-the-art succinct proof systems, such as zk-SNARKs based on pairings <em>[30]</em> or IOPs <em>[7]</em>, typically incur high concrete prover computation costs when scaled to large verification tasks. Moreover, they require a big amount of space, and are not compatible with a “streaming” mode of operation in which the proof is generated on the fly together with the computation being verified. On the other hand, non-succinct or semi-succinct proof systems based on the “MPC-in-the-head” <em>[35, 27, 18, 37]</em>, garbled circuits <em>[24, 31]</em>, or interactive proofs <em>[28, 46, 49]</em>, scale better to big verification tasks.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Minimizing prover complexity.</h4>

    <p class="text-gray-300">Our goal is to push the advantages of non-succinct zero-knowledge proof systems to their limits, focusing mainly on optimizing the prover’s computation. This can be motivated by settings in which the prover and the verifier are connected via a fast local network. An extreme case is that of physically connected devices, for which the distinction between computation and communication is blurred. Alternatively, one can think of scenarios in which the proofs can be generated and stored offline on the prover side and only verified at a later point, or possibly not at all. Another motivating scenario is one where the statement is short and simple, but is kept secret from the verifier. In this setting, which comes up in applications such as “commit-and-prove” and NISC on small inputs (which will be discussed later), the concrete overhead of “asymptotically succinct” systems is too high. Finally, if the witness is secret-shared between multiple provers and the proof needs to be generated in a distributed way, the prover’s computation is likely to become a bottleneck. All of the above reasons motivate a systematic study of minimizing the prover’s complexity in zero-knowledge proofs.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Achieving constant computational overhead.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We consider the goal of zero-knowledge proofs with constant computational overhead, namely where the total computational cost (and in particular the prover’s computation) is only a constant times bigger than the cost of performing the verification in the clear. In the case of proving the satisfiability of a Boolean circuit, this question is still open, and the best computational overhead is polylogarithmic in a statistical security parameter <em>[20]</em>. However, when considering arithmetic circuits over a big finite field <span class="math">\\mathbb{F}</span> and settling for $O(1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ soundness error, this goal becomes much easier. The first such proof system was given by Bootle et al. <em>[11]</em>, who also achieved “semi-succinctness.” However, the underlying multiplicative constants are very big, and this system is not considered practical. A more practical approach uses variants of the GKR interactive proofs protocol <em>[46, 49, 48]</em>. Here the concrete computational overhead is smaller, but still quite big: roughly 20x overhead in the best-case scenario of “layered” arithmetic circuits. On top of that, this overhead is only relevant when the verification circuit is much bigger than the witness size. In some of the applications we consider (such as the NISC application discussed below), this will not be the case.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">A third approach, which is most relevant to our work, relies on <em>oblivious linear evaluation</em> (OLE) <em>[42, 36]</em> and its vector variant (VOLE) <em>[2]</em>. An OLE is an arithmetic variant of oblivious transfer, allowing the receiver, on input <span class="math">\\alpha</span>, to learn a linear combination <span class="math">a\\alpha+b</span> of two ring elements held by the sender. VOLE is a natural vector analogue of OLE: the receiver learns <span class="math">\\mathbf{a}\\alpha+\\mathbf{b}</span> for a pair of vectors <span class="math">\\mathbf{a},\\mathbf{b}</span> held by the sender. The idea of using <em>random</em> precomputed instances of OLE and VOLE towards zero-knowledge proofs with constant computational overhead was suggested in <em>[12, 19]</em>. This is motivated by recent techniques for securely realizing pseudorandom instances of (V)OLE with sublinear communication and good concrete overall cost <em>[12, 13, 44, 16, 15]</em>. However, these protocols for zero knowledge from (V)OLE still suffered from a high concrete overhead. For instance, the protocol from <em>[19]</em> requires 44 instances of OLE for each multiplication gate. Recent and concurrent works by Weng et al. <em>[45]</em> and Baum et al. <em>[6]</em> improved this state of affairs. We will discuss these works in Section 1.5 below.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">1.1 Our contribution</h3>

    <p class="text-gray-300">Motivated by the goal of minimizing prover complexity in zero-knowledge proofs, we introduce and study a simple kind of proof systems called <em>line-point zero knowledge</em>. We then apply this proof system towards obtaining simple, concretely efficient, and reusable protocols for <em>non-interactive secure computation</em>. We elaborate on these results below.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">Line-point zero knowledge.</h4>

    <p class="text-gray-300">A recent work of Boyle et al. <em>[12]</em>, with improvements in <em>[13, 44]</em>, has shown how to securely generate a long, pseudorandom instance of a vector oblivious linear evaluation (VOLE) correlation with low communication complexity (sublinear in the vector length) and good concrete efficiency. Here we show how to use this for implementing simple and efficient dv-NIZK protocols for circuit satisfiability, improving over similar protocols from <em>[12, 19]</em>. In particular, previous protocols involve multiple VOLE instances and have a large (constant) overhead in communication and computation compared to the circuit size.</p>

    <p class="text-gray-300">The goal of reducing NIZK to a single instance of VOLE motivates the key new tool we introduce: a simple kind of information-theoretic proof system that we call <em>line point zero knowledge</em> (LPZK). In an LPZK proof, the prover <span class="math">P</span> generates from the witness <span class="math">w</span> (a satisfying assignment) an affine line <span class="math">\\mathbf{v}(t):=\\mathbf{a}t+\\mathbf{b}</span> in an <span class="math">n</span>-dimensional vector space <span class="math">\\mathbb{F}^{n}</span>. The verifier queries a single point <span class="math">\\mathbf{v}(\\alpha)=\\mathbf{a}\\alpha+\\mathbf{b}</span> on this line, and determines whether to accept or reject. We call this proof system LPZK over <span class="math">\\mathbb{F}</span> of length (or dimension) <span class="math">n</span>. We define the LPZK model formally along with more refined cost metrics in Section 2.1.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">Information-theoretic LPZK construction.</h4>

    <p class="text-gray-300">We start by showing the existence of an LPZK for arithmetic circuit satisfiability (an NP-complete problem), where the dimension <span class="math">n</span> and computational costs scale linearly with the circuit size.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Theorem 1.1 (LPZK for arithmetic circuit satisfiability).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For any NP-relation <span class="math">R(x,y)</span> and finite field <span class="math">\\mathbb{F}</span>, there exists an LPZK system for <span class="math">R</span> over <span class="math">\\mathbb{F}</span> with soundness error $O(1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Concretely, in the case of proving the satisfiability of an arithmetic circuit </span>C<span class="math"> over </span>\\mathbb{F}<span class="math">, we have an LPZK over </span>\\mathbb{F}<span class="math"> with dimension </span>n=O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, soundness error </span>\\varepsilon=O(1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, and where the prover and verifier can be implemented by arithmetic circuits of size </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As an information-theoretic proof system, LPZK can be viewed as a simple instance of a (1-round) zero-knowledge <em>linear interactive proof</em> (LIP) <em>[9]</em>, in which the verifier sends a single field element to the prover. Theorem 1.1 implies the first such system that is zero knowledge even against a <em>malicious verifier</em>.</p>

    <p class="text-gray-300">From LPZK to NIZK over random VOLE.</p>

    <p class="text-gray-300">It is easy to convert an LPZK into an NIZK protocol in the rVOLE-hybrid model, namely with a trusted setup in which the prover <span class="math">P</span> receives a random pair of vectors <span class="math">\\mathbf{a}^{\\prime}</span>, <span class="math">\\mathbf{b}^{\\prime}\\in\\mathbb{F}^{n}</span>, while the verifier <span class="math">V</span> receives a random field element <span class="math">\\alpha\\in\\mathbb{F}</span> and the vector <span class="math">\\mathbf{a}^{\\prime}\\alpha+\\mathbf{b}^{\\prime}</span>. This uses a standard reduction from VOLE to rVOLE; see Section 2.2 for details. We refer to the length of the vectors <span class="math">\\mathbf{a}^{\\prime},\\mathbf{b}^{\\prime}</span> as the rVOLE length.</p>

    <p class="text-gray-300">The rVOLE setup, whose efficient implementation will be discussed later, allows the prover to compress the LPZK proof by eliminating entries that can be picked at random independently of the input. Using this and other optimizations, we obtain an information-theoretic NIZK protocol in the rVOLE-hybrid model with the following concrete efficiency features.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Theorem 1.2 (NIZK over a single random VOLE).</h6>

    <p class="text-gray-300">Fix an integer <span class="math">t\\geq 1</span>. There exists an (unconditional, perfect zero-knowledge) NIZK protocol in the rVOLE-hybrid model that proves the satisfiability of an arithmetic circuit <span class="math">C</span> over a field <span class="math">\\mathbb{F}</span>, where <span class="math">C</span> has <span class="math">k</span> inputs, <span class="math">k^{\\prime}</span> outputs and <span class="math">m</span> multiplication gates, with the following security and efficiency features:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Soundness error: $\\varepsilon=2t/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Communication: <span class="math">k+k^{\\prime}+(2+\\frac{1}{t})m</span> field elements from <span class="math">P</span> to <span class="math">V</span>;</li>

      <li>rVOLE length: <span class="math">n=k+2m</span> field elements;</li>

      <li>Computation: Assuming the cost of field additions is negligible compared to multiplications, the computation of the prover is less than <span class="math">4</span> times the cost of evaluation in the clear, and the computation of the verifier is less than <span class="math">5</span> times the cost of evaluation in the clear.</li>

    </ul>

    <p class="text-gray-300">We give a more precise analysis of the computation cost in terms of the cost of additions and multiplications in § 4.4. In Appendix A, we combine this analysis with a consideration of circuit structure and computer architecture to show that, for reasonable choices of parameters, both the prover and verifier computation are between <span class="math">2</span> and <span class="math">5</span> times the cost of evaluation in the clear, depending on the number of operations of each kind.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">VOLE instantiations.</h4>

    <p class="text-gray-300">The random VOLE required by Theorem 1.2 can be instantiated in a variety of ways. For instance, one could use a <span class="math">2</span>-message protocol in the CRS model based on Paillier’s encryption scheme, which yields statistical dv-NIZK arguments for NP from the DCRA assumption <em>[19]</em>. Other efficient VOLE implementations under different assumptions appear in <em>[2, 22, 5]</em>. In terms of asymptotic efficiency, random VOLE can be implemented with constant multiplicative computational overhead under plausible variants of the learning parity with noise (LPN) assumption over big fields <em>[2, 12]</em>. From a concrete efficiency viewpoint, the most appealing current VOLE implementations rely on pseudorandom correlation generators (PCGs) <em>[12, 13, 44]</em>. A PCG for VOLE enables a “silent” generation of a long random VOLE correlation by locally expanding a pair of short, correlated seeds. This local expansion can be done in near-linear or even linear time, and may be carried out in an offline phase before the statement is known. The secure generation of the correlated seeds can also be done by a concretely efficient, low-communication protocol. Optimized pseudorandom function analogs of PCG that enable random access to the outputs of a virtually unbounded VOLE correlation were recently considered in <em>[15]</em>. The above approaches generally lead to a preprocessing NIZK, where both the verifier and the prover are fixed in advance. However, using <span class="math">2</span>-round protocols for VOLE with security against malicious receivers <em>[19, 13]</em>, LPZK can be compiled into dv-NIZK protocols in which the same (short) verifier message can be used by different provers.</p>

    <p class="text-gray-300">1.2 Improving proof size in the random oracle model</p>

    <p class="text-gray-300">Inspired by the concurrent work of Weng et al. <em>[45]</em>, we can improve the communication cost of our proofs in the random oracle model by a factor of 2 (asymptotically) at the cost of a modest increase of prover and verifier computation, in the form of calls to a cryptographic hash function. Note that other attractive features of LPZK such as space- and streaming-friendliness are maintained. See § 1.5 below for a detailed comparison between the results of <em>[45]</em> and our work.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Theorem 1.3 (NIZK over random VOLE in the ROM).</h6>

    <p class="text-gray-300">Fix an integer <span class="math">r\\geq 1</span>. There exists an (unconditional) NIZK protocol in the RO-rVOLE-hybrid model that proves the satisfiability of an arithmetic circuit <span class="math">C</span> over a field <span class="math">\\mathbb{F}</span>, where <span class="math">C</span> has <span class="math">k</span> inputs and <span class="math">m</span> multiplication gates and <span class="math">\\ell</span> is the number of oracle calls a malicious prover <span class="math">P^{*}</span> makes, with the following features:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Soundness error: $\\varepsilon=\\frac{2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}+\\frac{\\ell}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{r}}$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Communication: <span class="math">k+k^{\\prime}+m+2r</span> field elements from <span class="math">P</span> to <span class="math">V</span>;</li>

      <li>rVOLE length: <span class="math">n=k+m+r</span> field elements;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Computation: Computation of $O(r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> field operations and </span>1<span class="math"> cryptographic hash call (from </span>\\mathbb{F}^{m}<span class="math"> to </span>\\mathbb{F}^{mr}$) for both the prover and the verifier.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">1.3 Reusable NISC from LPZK via certified VOLE</h3>

    <p class="text-gray-300">A non-interactive secure computation (NISC) protocol <em>[34]</em> is a two-party protocol that securely computes a function <span class="math">f(x,y)</span> using two messages: a message by a receiver, encrypting its input <span class="math">x</span>, followed by a message by a sender, that depends on its input <span class="math">y</span>. The output <span class="math">f(x,y)</span> is only revealed to the receiver. A major challenge is making such protocols secure even when either party can be malicious. Another challenge is to make such protocols reusable, in the sense that the same encrypted input <span class="math">x</span> can be used to perform computations with many sender inputs <span class="math">y_{i}</span> without violating security. This should hold even when a malicious sender can learn partial information about the honest receiver’s output, such as whether the receiver “aborts” after detecting an inconsistent sender behavior. Existing NISC (or even NIZK) protocols based on parallel calls to oblivious transfer (OT) and symmetric cryptography <em>[39, 34, 1, 41]</em> are not fully reusable, and this is in some sense inherent <em>[19]</em>.</p>

    <p class="text-gray-300">Chase et al. <em>[19]</em> recently showed how to realize reusable NISC by using parallel instances of VOLE instead of OT. This can be seen as a natural extension of the LPZK model, where the receiver randomly encodes its NISC input <span class="math">x</span> into multiple points <span class="math">\\alpha_{i}</span> and the sender randomly encodes is input <span class="math">y</span> into corresponding lines <span class="math">\\mathbf{v}_{i}(t)</span>. Here reusability refers to fixing the VOLE inputs (points) <span class="math">\\alpha_{i}</span> generated by an honest receiver on input <span class="math">x</span> and reusing them in multiple interactions with a malicious sender.</p>

    <p class="text-gray-300">On top of the reusability feature, another advantage of the VOLE-based protocol, which is inherited from earlier protocols with security against semi-honest senders <em>[32, 3]</em>, is that it “natively” supports simple arithmetic computations over the VOLE field. This is contrasted with NISC protocols over OT <em>[34, 1, 41]</em>, which apply to Boolean circuits and are expensive to adapt to arithmetic computations.</p>

    <p class="text-gray-300">We provide an alternative construction of reusable NISC over VOLE that uses LPZK to protect against malicious senders. Our approach significantly simplifies the protocol from <em>[19]</em> and results in much better concrete constants.</p>

    <p class="text-gray-300">NISC for bounded inner product.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To illustrate the concrete efficiency potential of our NISC technique, we optimize it for a simple application scenario. Consider an “inner product” functionality that measures the level of similarity (or correlation) between receiver feature vector <span class="math">x</span> and a sender feature vector <span class="math">y</span>, where the same <span class="math">x</span> can be reused with multiple sender inputs <span class="math">y_{i}</span>. Here we view both <span class="math">x</span> and <span class="math">y</span> as integer vectors that are embedded in a sufficiently large finite field. An obvious problem is that the ideal functionality allows a malicious sender to scale its real input by an arbitrary multiplicative factor, thereby increasing the perceived similarity. To prevent this attack, we modify the functionality to bound the <span class="math">L_{2}</span> norm of the sender’s input. In this way, the sender’s strategy is effectively restricted to choosing the direction of a unit vector, where the bound on the norm determines the level of precision. For this bounded inner product functionality, we obtain a concretely efficient protocol that offers reusable malicious security. Even when considering malicious security alone, without reusability, previous techniques for NISC are much less efficient for such simple arithmetic functionalities. To give just one data point, for vectors of length 1000 over <span class="math">\\mathbb{F}</span>, with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx 2^{64}<span class="math"> and sender </span>L_{2}$ norm bounded by 1024, our protocol requires 1002 instances of VOLE with a total of 21,023 entries and communication of 36,047 field elements (roughly 282 kB) after the offline generation of VOLE instances. Given recent methods for “silent” generation of multiple VOLE instances <em>[13, 44, 16, 15]</em>, the amortized cost of setting up the required VOLE instances is small.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">1.4 Overview of techniques</h3>

    <p class="text-gray-300">From LPZK to NIZK via random VOLE. An LPZK proof system can be directly realized by a single instance of VOLE, where the prover’s line <span class="math">\\mathbf{v}(t):=\\mathbf{a}t+\\mathbf{b}\\in\\mathbb{F}^{n}</span> determines the VOLE sender’s input <span class="math">(\\mathbf{a},\\mathbf{b})</span> and the verifier’s point <span class="math">\\alpha</span> is used as the VOLE receiver’s input. A further observation is that this single VOLE instance can be easily reduced to a random VOLE functionality that assigns to the prover a uniformly random pair of vectors <span class="math">(\\mathbf{a}^{\\prime},\\mathbf{b}^{\\prime})</span> each in <span class="math">\\mathbb{F}^{n}</span> and to the verifier a uniformly random value <span class="math">\\alpha\\in\\mathbb{F}</span> and <span class="math">\\mathbf{v}^{\\prime}=\\mathbf{a}^{\\prime}\\alpha+\\mathbf{b}^{\\prime}</span>. Indeed, the prover can send <span class="math">(\\mathbf{a}-\\mathbf{a}^{\\prime})</span> and <span class="math">(\\mathbf{b}-\\mathbf{b}^{\\prime})</span> to the verifier, who computes <span class="math">\\mathbf{v}(\\alpha)=\\mathbf{v}^{\\prime}+(\\mathbf{a}-\\mathbf{a}^{\\prime})\\alpha+(\\mathbf{b}-\\mathbf{b}^{\\prime})</span>. This requires communication of <span class="math">2n</span> field elements on top of the pre-processing step required to set up the random VOLE instance. Combined with efficient protocols for generating long instances of random VOLE, this gives rise to dv-NIZK protocol in which the offline phase consists of secure generation of random VOLE and the online phase uses the random VOLE as a “one-time pad” for realizing LPZK.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">Constructing information-theoretic LPZK proofs.</h4>

    <p class="text-gray-300">Our information-theoretic LPZK construction follows the general template of similar kinds of proof systems: the verification circuit is evaluated in two different ways that depend on secret randomness picked by the verifier, and the verifier accepts if the two evaluations are consistent. Zero knowledge is obtained by masking the values revealed to the verifier using randomness picked by the prover. This high level approach was used in previous information-theoretic zero-knowledge proof systems (such as succinct zero-knowledge linear PCPs <em>[4, 33, 26, 9]</em>), actively secure computation protocols (such as the SPDZ line of protocols <em>[8, 21]</em>), and circuits resilient to additive attacks <em>[25]</em>. Our LPZK systems most closely resemble the “homomorphic MAC” approach used for actively secure computation in the preprocessing model <em>[8, 21]</em>, but differ in the low-level details.</p>

    <p class="text-gray-300">More concretely, we construct LPZK for proving the satisfiability of an arithmetic circuit <span class="math">C</span> by encoding intermediate wire values in the vector <span class="math">\\mathbf{a}</span> and masking these values with randomness in <span class="math">\\mathbf{b}</span>. This is an information-theoretic encryption: If the verifier holds <span class="math">v_{1}(\\alpha):=a_{1}\\alpha+b_{1}</span> and <span class="math">\\alpha</span>, where <span class="math">a_{1}</span> is sampled from some distribution and <span class="math">b_{1}</span> is chosen uniformly at random from <span class="math">\\mathbb{F}</span>, the distribution of <span class="math">v_{1}(\\alpha)</span> holds no information about <span class="math">a_{1}</span>.</p>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">We can “add” two encrypted wires <span class="math">v_{1}(t)=a_{1}t+b_{1}</span> and <span class="math">v_{2}(t)=a_{2}t+b_{2}</span> non-interactively for free; the prover adds to obtain <span class="math">(a_{1}+a_{2})t+(b_{1}+b_{2})</span>, and the verifier adds <span class="math">v_{1}(\\alpha)+v_{2}(\\alpha)=(a_{1}+a_{2})\\alpha+(b_{1}+b_{2})</span>.</p>

    <p class="text-gray-300">To multiply <span class="math">v_{1}</span> and <span class="math">v_{2}</span>, the prover seeks to construct the encrypted wire <span class="math">a_{1}a_{2}t+b</span>, for some value <span class="math">b</span>. When the prover multiplies <span class="math">v_{1}(t)\\cdot v_{2}(t)</span> they obtain a quadratic in <span class="math">t</span>. By adding and subtracting a masking term <span class="math">b_{3}t</span>, they can write <span class="math">v_{1}(t)v_{2}(t)=tv_{3}(t)+v_{4}(t)</span>, with <span class="math">v_{3}(t)=a_{1}a_{2}t+(b_{1}a_{2}+b_{2}a_{1}-b_{3})</span> and <span class="math">v_{4}(t)=b_{3}t+b_{1}b_{2}</span>, so that <span class="math">v_{3}(t)</span> is the desired encryption of <span class="math">a_{1}a_{2}</span> and satisfies <span class="math">v_{3}(t)=(v_{1}(t)v_{2}(t)-v_{4}(t))/t</span>. The verifier learns <span class="math">v_{i}(\\alpha)</span>, for <span class="math">1\\leq i\\leq 4</span> from the LPZK, and accepts if</p>

    <p class="text-gray-300"><span class="math">v_{3}(\\alpha)=\\frac{v_{1}(\\alpha)v_{2}(\\alpha)-v_{4}(\\alpha)}{\\alpha},</span></p>

    <p class="text-gray-300">and rejects otherwise. Finally, to open the value of an encrypted wire <span class="math">v(t)=at+b</span>, the prover sends <span class="math">b</span> to the verifier who computes <span class="math">a=(v(\\alpha)-b)/\\alpha</span>.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">LPZK-NIZK optimizations.</h4>

    <p class="text-gray-300">There are two optimizations in the compiler from LPZK to NIZK over random VOLE. These take advantage of special features of the LPZK to further reduce communication costs. When the LPZK only requires an entry of <span class="math">\\mathbf{a}</span> or <span class="math">\\mathbf{b}</span> to be chosen uniformly at random over <span class="math">\\mathbb{F}</span>, independently of previous entries, we can leave the corresponding element of <span class="math">\\mathbf{a}^{\\prime}</span> or <span class="math">\\mathbf{b}^{\\prime}</span> in the random VOLE unchanged, reducing communication costs by one. And, when the LPZK requires an entry of <span class="math">\\mathbf{a}</span> to be equal to zero, we can instead send the corresponding entry of <span class="math">\\mathbf{b}</span> in the clear, shortening our random VOLE length by one and reducing communication costs by one.</p>

    <p class="text-gray-300">In the technical sections (cf. 4.1, a refinement of Theorem 1.1) we use length parameters <span class="math">(n,n^{\\prime},n^{\\prime\\prime})</span> to give a more refined complexity measure for LPZK that takes the above optimizations into account. Here <span class="math">n</span> denotes the total LPZK dimension (where <span class="math">\\mathbf{a},\\mathbf{b}\\in\\mathbb{F}^{n}</span>), <span class="math">n^{\\prime}</span> denotes the number of entries in <span class="math">\\mathbf{a}</span> and <span class="math">\\mathbf{b}</span> for which the first and second optimization above do <em>not</em> apply, and by <span class="math">n^{\\prime\\prime}</span> denotes the number of entries where the second optimization <em>does</em> apply.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We perform additional optimizations for the general NIZK construction by batching together tests for multiple gates at once to reduce communication costs. We batch in blocks of <span class="math">t</span> gates, giving an amortized cost of <span class="math">2+\\frac{1}{t}</span> field elements of communication per multiplication gate and increasing the soundness error by a factor of <span class="math">t</span>. In the random oracle setting, we batch together all multiplication gates into a single block, giving an amortized cost of <span class="math">1</span> field elements per multiplication gate plus an additional <span class="math">2r</span> field elements total, where <span class="math">r</span> is some fixed parameter. This approach is theoretically vulnerable to a malicious prover who makes repeated calls to the random oracle until they find a collision. However, when we choose parameters <span class="math">r</span> and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ appropriately, we can bound soundness error reasonably, as we show in Section 5.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">Certified VOLE.</h4>

    <p class="text-gray-300">As a building block for NISC, we build a <em>certified</em> variant of VOLE. This primitive is useful for invoking several parallel instances of VOLE while assuring the receiver that a given circuit <span class="math">C</span> is satisfied when its inputs are a certain subset of the entries of the VOLEs.</p>

    <p class="text-gray-300">We construct fully general certified VOLE from a weaker construction, <em>distributional VOLE with equality constraints</em>. This construction allows us to move all inputs to <span class="math">C</span> to a single VOLE instance. The sender and receiver then prove that <span class="math">C</span> is satisfied using LPZK NIZK.</p>

    <p class="text-gray-300">This weaker variant, which we call eVOLE, is <em>distributional</em>, because it requires the VOLE inputs from the receiver to be chosen independently and uniformly at random. In general certified VOLE, which we call cVOLE, we use two additional evaluation points <span class="math">\\alpha,\\beta</span>, and perform an affine shift to the receiver’s inputs, replacing <span class="math">(\\alpha_{1},\\ldots,\\alpha_{n})</span> with <span class="math">(\\alpha+\\alpha_{1},\\ldots,\\alpha+\\alpha_{n},\\alpha,\\beta)</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">This forces all receiver inputs to be uniformly random, and every input besides <span class="math">\\beta</span> is independent of <span class="math">\\beta</span>. We move all inputs to <span class="math">C</span> to the VOLE instance with receiver input <span class="math">\\beta</span>, and use the VOLE instance with input <span class="math">\\alpha</span> to reverse the affine shift of the receiver’s inputs.</p>

    <h5 id="sec-19" class="text-base font-semibold mt-4">From certified VOLE to NISC.</h5>

    <p class="text-gray-300">Following <em>[19]</em>, our NISC protocol is obtained from certified VOLE in a conceptually straightforward way: we start with existing protocols for arithmetic branching programs <em>[32, 3]</em> that achieve security against a malicious receiver and <em>semi-honest sender</em>. We then protect the receiver against a malicious sender by using certified VOLE to enforce honest behavior. This yields a statistically secure reusable NISC protocol for “simple” arithmetic functions represented by polynomial-size arithmetic branching programs. We can bootstrap this to get reusable NISC over VOLE for general Boolean circuits using the approach of <em>[19]</em>; however, this comes at the cost of making a non-black-box use of a pseudorandom generator and losing the concrete efficiency features of the arithmetic variant of the protocol.</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">1.5 Comparison with concurrent and subsequent work</h3>

    <p class="text-gray-300">In concurrent work, Weng, Yang, Katz and Wang <em>[45]</em> and Baum, Malozemoff, Rosen and Scholl <em>[6]</em> design and implement two concretely efficient VOLE-based ZK protocols, which they call Wolverine and Mac’n’Cheese, respectively. Both protocols have an online phase that can be made non-interactive in the random oracle model. These protocols share some high-level features with each other and with our LPZK-based protocol, but there are some important differences in scope and design, and each work offers unique optimizations and extensions.</p>

    <p class="text-gray-300">A subsequent work by Yang, Sarkar, Weng and Wang <em>[47]</em> gives a protocol Quicksilver which is an extension of our LPZK. We describe their contribution in more detail below.</p>

    <p class="text-gray-300">The following comparison refers to the online phase of the protocols, once a random VOLE correlation has already been generated. In the random oracle model, our LPZK protocol requires at least 2 times less communication and computation per multiplication gate than either Wolverine or Mac’n’Cheese, while offering the possibility of eliminating entirely the “cryptographic” overhead of the online phase. Our information theoretic LPZK NIZK requires similar communication to the best variant of Wolverine described in <em>[45]</em>, with at least 2-3 times less multiplications, and no calls to a cryptographic hash function. We give additional details below.</p>

    <p class="text-gray-300">Baum et al. <em>[6]</em> provide an additional optimization that allows stacking disjunctive statements, similar to the “stacked garbling” improvement over ordinary garbled circuits <em>[31]</em>. The efficiency gains from this optimization depend on the structure of the circuit, of course, and so the only comparison we make to Mac’n’Cheese is for general arithmetic circuits on a per-gate basis.</p>

    <p class="text-gray-300">Weng et al. <em>[45]</em> use subfield VOLE and other optimizations to improve the cost of soundness amplification when working over small (even binary) fields. In an earlier version of this paper, we wrote:</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>Similar techniques could be applied to our approach, but we chose here to focus on the simpler case of arithmetic circuits over large fields. (Alternatively, one can repeat a proof over a smaller field to amplify soundness, though this will typically eliminate the concrete efficiency benefits of our protocol.)</p>
    </blockquote>

    <p class="text-gray-300">This challenge was quickly taken up by Yang et al. in <em>[47]</em>. Their Quicksilver protocol applied the methods of <em>[45]</em> to our LPZK approach, giving an efficient protocol with negligible soundness error over small fields. In addition, they constructed an optimized variant of LPZK for circuits whose gates compute low-degree polynomials.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">We note that in the context of proofs, mixing Boolean and arithmetic operations is easier than in a typical secure computation setting, since the prover can provide a bit-decomposition of an arithmetic value which can be easily verified by an arithmetic circuit.</p>

    <p class="text-gray-300">We draw attention to one low-level detail in the distribution of information between the prover and verifier that distinguishes our approach. In LPZK, the prover holds a line <span class="math">\\mathbf{v}(t)=\\mathbf{a}t+\\mathbf{b}</span> and the verifier queries a single point <span class="math">\\mathbf{v}(\\alpha)</span> on that line. In both <em>[45]</em> and <em>[6]</em>, the prover instead holds <span class="math">\\mathbf{a}</span>, the verifier holds <span class="math">\\mathbf{b}</span> and <span class="math">\\alpha</span>, and the prover learns <span class="math">\\mathbf{v}(\\alpha)</span>. Our construction better exploits the algebraic structure of VOLE, allowing local computation by the verifier to reduce the communication cost of verifying a multiplication gate.</p>

    <p class="text-gray-300">We also note our work is the only to consider reusable NISC over VOLE, in addtion to NIZK.</p>

    <p class="text-gray-300">For NIZK, both in the random oracle model and in the information theoretic setting, we compare our work to Wolverine and Mac’n’Cheese in communication cost and prover and verifier communication complexity.</p>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">Communication:</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our LPZK protocol requires <span class="math">1+o(1)</span> field elements per multiplication gate in the random oracle model, and <span class="math">2+1/t+o(1)</span> elements per multiplication gate for information theroetic NIZK, for some parameter <span class="math">t\\in\\mathbb{Z}</span> that affects soundness error. For large fields, we can choose $t=\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, so the </span>1/t$ term is in practice small.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Mac’n’Cheese <em>[6]</em> requires <span class="math">3+o(1)</span> elements of communication per multiplication gate. Wolverine <em>[45]</em> requires <span class="math">2+o(1)</span> elements of communication per multiplication gate, while a variant discussed in <em>[45]</em> that is more computationally efficient requires <span class="math">4+o(1)</span> elements per multiplication gate. In all cases, the <span class="math">o(1)</span> term is controlled by the growth of circuit size relative to the input size.</p>

    <p class="text-gray-300">Our information theoretic NIZK protocol has comparable communication to the Wolverine protocol in the random oracle setting, and our random oracle NIZK protocol has 2 times less communication.</p>

    <h4 id="sec-22" class="text-lg font-semibold mt-6">Prover computation:</h4>

    <p class="text-gray-300">Our information theoretic LPZK-based NIZK over random VOLE requires prover computation of 3 multiplications per multiplication gate.</p>

    <p class="text-gray-300">Our NIZK protocol in the random oracle model requires <span class="math">(2r+3)</span> multiplications per multiplication gate, and a single call to a cryptographic hash function <span class="math">H:\\mathbb{F}^{m}\\to\\mathbb{F}^{mr}</span>, where <span class="math">m</span> is the number of multiplication gates. The parameter <span class="math">r\\in\\mathbb{N}</span> affects soundness error, but for large fields we can set <span class="math">r=1</span>. The cryptographic hash function <span class="math">H</span> can be evaluated in a streaming fashion to reduce memory costs.</p>

    <p class="text-gray-300">The most computationally efficient variant in Wolverine <em>[45]</em> requires <span class="math">(4r+6)</span> multiplications per multiplication gate, 2 cryptographic hash function calls <span class="math">H_{1}:\\mathbb{F}\\to\\mathbb{F}^{r}</span> per multiplication gate, and one more cryptographic hash function call <span class="math">H_{2}:\\mathbb{F}^{m}\\to\\mathbb{F}^{r}</span> for the entire protocol, with <span class="math">m</span> as above. Mac’n’Cheese <em>[6]</em> requires 13 multiplications per multiplication gate and 3 cryptographic hash function calls <span class="math">H_{3}:\\mathbb{F}^{k+1}\\to\\mathbb{F}</span> per multiplication gate, where <span class="math">k</span> is the number of messages sent so far in the protocol.</p>

    <h4 id="sec-23" class="text-lg font-semibold mt-6">Verifier computation:</h4>

    <p class="text-gray-300">Our information theoretic LPZK NIZK protocol requires verifier computation of 4 multiplications per multiplication gate.</p>

    <p class="text-gray-300">In the random oracle model, our LPZK protocol requires <span class="math">(r+3)</span> multiplications per multiplication gate, and a single cryptographic hash call. As above, for large enough field size, we can set <span class="math">r=1</span> and the cryptographic hash function <span class="math">H:\\mathbb{F}^{2m}\\to\\mathbb{F}^{mr}</span> can be evaluated in a streaming fashion to reduce memory costs.</p>

    <p class="text-gray-300">The most computationally efficient variant in Wolverine <em>[45]</em> requires <span class="math">7r</span> multiplications per multiplication gate, 2 cryptographic hash function calls per multiplication gate, and one more cryptographic hash function call for the entire protocol, with the hash functions <span class="math">H_{1},H_{2}</span> as above. Mac’n’Cheese <em>[6]</em> requires 10 multiplications per multiplication gate and 3 cryptographic hash function calls per multiplication gate, with the hash function <span class="math">H_{3}</span> as above.</p>

    <h2 id="sec-24" class="text-2xl font-bold">2 LPZK and random VOLE</h2>

    <p class="text-gray-300">In this section we give a formal definition of our new notion of LPZK proof system and show how to compile such a proof system into a designated-verifier NIZK when given a random VOLE correlation.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">2.1 Defining LPZK</h3>

    <p class="text-gray-300">While an LPZK proof system can be defined for any NP-relation, we focus here on the case of arithmetic circuit satisfiability that we use for describing our constructions. Our definition can be seen as a simple restriction of the more general notion of (1-round) zero-knowledge <em>linear interactive proof</em> <em>[9]</em> that restricts the verifier to sending a single field element.</p>

    <p class="text-gray-300">Here and in the following, we work in an arithmetic model in which probabilistic polynomial time (PPT) algorithms can sample a uniformly random element from a finite field <span class="math">\\mathbb{F}</span> and perform field operations at a unit cost. All of the protocols we describe make a black-box use of the underlying field <span class="math">\\mathbb{F}</span>.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Definition 2.1 (LPZK).</h6>

    <p class="text-gray-300">A <em>line-point zero-knowledge</em> (LPZK) proof system for arithmetic circuit satisfiability is a pair of algorithms (<em>Prove</em>, <em>Verify</em>) with the following syntax:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">Prove(\\mathbb{F},C,w)</span> is a PPT algorithm that given an arithmetic verification circuit <span class="math">C:\\mathbb{F}^{k}\\to\\mathbb{F}^{k^{\\prime}}</span> and a witness <span class="math">w\\in\\mathbb{F}^{k}</span>, outputs a pair of vectors <span class="math">\\mathbf{a},\\mathbf{b}\\in\\mathbb{F}^{n}</span> that specify an affine line <span class="math">\\mathbf{v}(t):=\\mathbf{a}t+\\mathbf{b}</span>. We assume that the dimension <span class="math">n</span> is determined by <span class="math">C</span>.</li>

      <li><span class="math">Verify(\\mathbb{F},C,\\alpha,\\mathbf{v}_{\\alpha})</span> is a polynomial-time algorithm that, given an evaluation <span class="math">\\mathbf{v}_{\\alpha}</span> of the line <span class="math">\\mathbf{v}(t)</span> at some point <span class="math">\\alpha\\in\\mathbb{F}</span>, outputs <em>acc</em> or <em>rej</em>.</li>

    </ul>

    <p class="text-gray-300">The algorithms (<em>Prove</em>, <em>Verify</em>) should satisfy the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. For any arithmetic circuit <span class="math">C:\\mathbb{F}^{k}\\to\\mathbb{F}^{k^{\\prime}}</span> and witness <span class="math">w\\in\\mathbb{F}^{k}</span> such that <span class="math">C(w)=\\mathbf{0}</span>, and for any fixed <span class="math">\\alpha\\in\\mathbb{F}</span>, we have <span class="math">\\Pr[\\mathbf{v}(t)\\xleftarrow{R}Prove(\\mathbb{F},C,w):Verify(\\mathbb{F},C,\\alpha,\\mathbf{v}(\\alpha))=acc]=1</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Reusable <span class="math">\\varepsilon</span>-soundness. For every arithmetic circuit <span class="math">C:\\mathbb{F}^{k}\\to\\mathbb{F}^{k^{\\prime}}</span> such that <span class="math">C(w)\\neq\\mathbf{0}</span> for all <span class="math">w\\in\\mathbb{F}^{k}</span>, and every (adversarially chosen) line <span class="math">\\mathbf{v}^{<em>}(t)=\\mathbf{a}^{</em>}t+\\mathbf{b}^{<em>}</span>, where the length <span class="math">n</span> of <span class="math">\\mathbf{v}^{</em>}</span> depends on <span class="math">C</span> as above, we have <span class="math">\\Pr[\\alpha\\xleftarrow{R}\\mathbb{F}:Verify(\\mathbb{F},C,\\alpha,\\mathbf{v}^{<em>}(\\alpha))=acc]\\leq\\varepsilon</span>. Moreover, for every <span class="math">\\mathbb{F},C,\\mathbf{v}^{</em>}(t)</span> the probability of <em>Verify</em> accepting (over the choice of <span class="math">\\alpha</span>) is either <span class="math">1</span> or <span class="math">\\leq\\varepsilon</span>. Unless otherwise specified, we assume $\\varepsilon\\leq O(1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Perfect zero knowledge. There exists a PPT simulator <em>Sim</em> such that, for any arithmetic circuit <span class="math">C:\\mathbb{F}^{k}\\to\\mathbb{F}^{k^{\\prime}}</span>, any witness <span class="math">w\\in\\mathbb{F}^{k}</span> such that <span class="math">C(w)=\\mathbf{0}</span>, and any <span class="math">\\alpha\\in\\mathbb{F}</span>, the output of <em>Sim</em><span class="math">(\\mathbb{F},C,\\alpha)</span> is distributed identically to <span class="math">\\mathbf{v}(\\alpha)</span>, where <span class="math">\\mathbf{v}(t)</span> is the affine line produced by <span class="math">\\mathsf{Prove}(\\mathbb{F},C,w)</span>.</li>

    </ul>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">The reusable soundness requirement guarantees that even by observing the verifier’s decision bit on a maliciously chosen circuit <span class="math">C</span>, and line <span class="math">\\mathbf{v}^{<em>}(t)=\\mathbf{a}^{</em>}t+\\mathbf{b}^{*}</span>, the prover learns essentially nothing about the verifier’s secret point <span class="math">\\alpha</span>, which allows the same <span class="math">\\alpha</span> to be reused without substantially compromising soundness.</p>

    <h4 id="sec-27" class="text-lg font-semibold mt-6">Proof of Knowledge.</h4>

    <p class="text-gray-300">For simplicity, we focus here on (reusable) soundness and ignore the additional proof of knowledge property. However, the LPZK systems we construct all satisfy this stronger notion of soundness (see <em>[9]</em> a definition of proofs of knowledge in the context of linear proof systems). More formally, there is an efficient extractor that can extract a valid witness from any (maliciously generated) line that makes the verifier accept with <span class="math">&gt;\\varepsilon</span> probability.</p>

    <h4 id="sec-28" class="text-lg font-semibold mt-6">Computational LPZK.</h4>

    <p class="text-gray-300">The above definition considers our main information-theoretic flavor of LPZK, with statistical soundness and perfect zero knowledge. Computational variants of LPZK can be defined analogously. In particular, we will later consider computationally sound LPZK in the random oracle model, which bounds the number of oracle queries made by a malicious prover.</p>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">Complexity measures for LPZK: <span class="math">(n,n^{\\prime},n^{\\prime\\prime})</span>-LPZK.</h4>

    <p class="text-gray-300">As noted in § 1.4, in addition to the dimension/length parameter <span class="math">n</span>, we use two other parameters <span class="math">n^{\\prime}</span> and <span class="math">n^{\\prime\\prime}</span> as complexity measures for LPZK. These will help us obtain a more efficient compiler from LPZK to NIZK that takes advantage of verifier outputs that are either known by the prover (namely, are independent of <span class="math">\\alpha</span>) or entries of <span class="math">\\mathbf{a},\\mathbf{b}</span> that can be picked at random independently of <span class="math">w</span>. Concretely, the parameter <span class="math">n^{\\prime\\prime}</span> is the number of entries of <span class="math">\\mathbf{a}</span> that are always equal to zero; we assume without loss of generality that these are the last <span class="math">n^{\\prime\\prime}</span> entries. The parameter <span class="math">n^{\\prime}</span> measures the total number of entries of the first <span class="math">n-n^{\\prime\\prime}</span> entries of <span class="math">\\mathbf{a}</span> and <span class="math">\\mathbf{b}</span> that functionally depend on <span class="math">w</span>. To take advantage of the random VOLE setup, we assume the remaining <span class="math">2n-2n^{\\prime\\prime}-n^{\\prime}</span> entries are picked uniformly and independently at random, and then these <span class="math">n^{\\prime}</span> entries are determined by <span class="math">w</span> and the random entries. We will assume that the parameters <span class="math">(n,n^{\\prime},n^{\\prime\\prime})</span> as well as the identity of the entries of each type are determined by the public information <span class="math">C</span>.</p>

    <h3 id="sec-30" class="text-xl font-semibold mt-8">2.2 Compiling LPZK to NIZK over random VOLE</h3>

    <p class="text-gray-300">We now describe and analyze a simple compiler that takes an LPZK proof system as defined above and converts it into a (designated verifier) NIZK protocol that relies on a random VOLE correlation, where the prover gets a random pair of vectors <span class="math">\\mathbf{a}^{\\prime},\\mathbf{b}^{\\prime}\\in\\mathbb{F}^{n}</span> specifying an affine line <span class="math">\\mathbf{a}^{\\prime}t+\\mathbf{b}^{\\prime}</span> in <span class="math">\\mathbb{F}^{n}</span> and the verifier gets the value of the line at a random point <span class="math">\\alpha\\in\\mathbb{F}</span>, namely <span class="math">\\mathbf{v}^{\\prime}=\\mathbf{a}^{\\prime}\\alpha+\\mathbf{b}^{\\prime}</span>. Similarly to previous VOLE-based compilers from <em>[12, 19]</em>, we rely on the simple known reduction from VOLE to random VOLE. Our compiler takes advantage of the extra parameters <span class="math">n^{\\prime}</span> and <span class="math">n^{\\prime\\prime}</span> of the LPZK, which help reduce the cost of the NIZK below the <span class="math">2n</span> field elements communicated by the natural generic compiler.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Lemma 2.1 (From LPZK to NIZK).</h6>

    <p class="text-gray-300">Given <span class="math">(n,n^{\\prime},n^{\\prime\\prime})</span>-LPZK over <span class="math">\\mathbb{F}</span> with soundness error <span class="math">\\varepsilon</span>, there is an NIZK protocol that uses a single instance of random VOLE of length <span class="math">n-n^{\\prime\\prime}</span> and requires communication of <span class="math">n^{\\prime}+n^{\\prime\\prime}</span> field elements from the prover to the verifier.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbf{a},\\mathbf{b}\\in\\mathbb{F}^{n}</span> be the vectors for the prover’s line <span class="math">\\mathbf{a}t+\\mathbf{b}</span>. The prover and verifier are given a random VOLE of length <span class="math">n</span>, so that the prover holds <span class="math">(\\mathbf{a}^{\\prime},\\mathbf{b}^{\\prime})</span>, and the verifier holds <span class="math">\\mathbf{v}^{\\prime}=\\mathbf{a}^{\\prime}\\alpha+\\mathbf{b}^{\\prime}</span> for a random <span class="math">\\alpha\\in\\mathbb{F}</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">We recall a simple self-reduction property of VOLE (see e.g. <em>[12]</em>) that allows us to replace a random pair <span class="math">(\\mathbf{a}^{\\prime},\\mathbf{b}^{\\prime})</span> with the pair <span class="math">(\\mathbf{a},\\mathbf{b})</span> as follows. The prover sends vectors <span class="math">\\mathbf{a}^{\\prime}-\\mathbf{a}</span> and <span class="math">\\mathbf{b}^{\\prime}-\\mathbf{b}</span> to the verifier, who then computes</p>

    <p class="text-gray-300"><span class="math">\\mathbf{v}=\\mathbf{v}^{\\prime}+\\alpha(\\mathbf{a}^{\\prime}-\\mathbf{a})+(\\mathbf{b}^{\\prime}-\\mathbf{b})</span></p>

    <p class="text-gray-300">Finally, the prover sends the final <span class="math">n^{\\prime\\prime}</span> values of <span class="math">\\mathbf{b}</span> to the verifier in the clear, and the verifier appends these values to <span class="math">\\mathbf{v}</span>.</p>

    <p class="text-gray-300">For any entry of <span class="math">\\mathbf{a},\\mathbf{b}</span> that should be chosen randomly for LPZK, the prover sets the corresponding entry of <span class="math">\\mathbf{a}^{\\prime}-\\mathbf{a}</span> or <span class="math">\\mathbf{b}^{\\prime}-\\mathbf{b}</span> to zero, and so no communication is required for those entries. The entire reduction requires a random VOLE of length <span class="math">n</span> with communication of <span class="math">n^{\\prime}+n^{\\prime\\prime}</span> field elements, as desired. The security completeness, soundness, and zero knowledge properties of the above NIZK protocol are inherited directly from the corresponding properties of the LPZK. ∎</p>

    <h4 id="sec-33" class="text-lg font-semibold mt-6">UC security.</h4>

    <p class="text-gray-300">While we only consider here a standard standalone security definition for NIZK proofs <em>[29, 10]</em>, all of our LPZK-based NIZK protocols are in fact UC-secure NIZK protocols (e.g., in the sense of <em>[17]</em>) in the rVOLE-hybrid model. This is the typical situation for information-theoretic protocols.</p>

    <h4 id="sec-34" class="text-lg font-semibold mt-6">Using a corruptible random VOLE functionality.</h4>

    <p class="text-gray-300">When using a pseudorandom correlation generator (PCG) for generating the random VOLE correlation with sublinear communication complexity <em>[12, 14, 44]</em>, what is actually realized is a so-called “corruptible” random VOLE functionality that allows the malicious party to choose its output, and then samples the honest party’s output conditioned on this choice. The transformation of Lemma 2.1 remains secure even when using this corruptible VOLE functionality. Indeed, it was already observed in <em>[12]</em> that the reduction of VOLE to random VOLE remains secure even when using corruptible random VOLE, and the LPZK to NIZK transformation builds on this reduction.</p>

    <h2 id="sec-35" class="text-2xl font-bold">3 Single gate example</h2>

    <p class="text-gray-300">To clarify the exposition, we begin with an example where the prover wishes to convince the verifier that they hold a triple of values <span class="math">x,y,z</span> satisfying <span class="math">xy=z</span>. More precisely, the prover and verifier realize a commit-and-prove functionality for the triple <span class="math">(x,y,z)</span> and the relation <span class="math">R(x,y,z):=xy-z</span>. We prove that our single gate example satisfies this stronger flavor of ZK, which is meaningful even for finite functions. Note that our LPZK construction is adapted from this single gate example, rather than directly built up from it, so this proof and the proof in Section 4 can be read independently.</p>

    <p class="text-gray-300">A commit-and-prove protocol for the above relation <span class="math">R</span> has the same syntax as LPZK, and should satisfy the following loosely stated properties (see, e.g., <em>[38]</em> for a formal definition).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. If the prover runs honestly on <span class="math">(x,y,z)</span> such that <span class="math">z=xy</span>, then the verifier always accepts.</li>

      <li>Binding. There is a deterministic extractor that given a line picked by a (potentially malicious) prover outputs effective inputs <span class="math">(x^{<em>},y^{</em>},z^{*})</span> such that the following holds. Any attempt of the prover to “explain” a different input triple <span class="math">(x^{\\prime},y^{\\prime},z^{\\prime})</span> (by revealing its randomness) would lead to an inconsistent verifier view, except with the binding error probability (over the choice of <span class="math">\\alpha</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Soundness. For any malicious prover, if the extracted values <span class="math">(x^{<em>},y^{</em>},z^{<em>})</span> satisfy <span class="math">z^{</em>}\\neq x^{<em>}y^{</em>}</span>, then the verifier rejects except for the soundness error probability (over the choice of <span class="math">\\alpha</span>).</li>

      <li>Zero knowledge. For any choice of <span class="math">\\alpha</span>, the verifier’s evaluation on an honestly generated line can be simulated without knowing <span class="math">x,y,z</span>.</li>

    </ul>

    <p class="text-gray-300">Random evaluation of the line picked by a prover (even a malicious one) effectively commits the prover to unique values of <span class="math">x,y,z</span>, in the sense that except for the binding error probability it cannot reveal randomness that consistently explains different <span class="math">(x^{\\prime},y^{\\prime},z^{\\prime})</span>), and moreover the verifier rejects unless <span class="math">z=xy</span> (except with soundness error probability).</p>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">3.1 Protocol</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We construct our commit-and-prove protocol for the relation <span class="math">R(x,y,z):=xy-z</span> as a <span class="math">(5,4,1)</span>-LPZK over <span class="math">\\mathbb{F}</span> with binding and soundness error $\\leq 2/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The (honest) prover chooses some triple <span class="math">(x,y,z)</span> and constructs a line <span class="math">\\mathbf{a}t+\\mathbf{b}</span> by setting</p>

    <p class="text-gray-300"><span class="math">\\mathbf{a}=(a_{1},a_{2},a_{3},a_{4},a_{5}):=(x,y,z,xb_{2}+yb_{1}-b_{3},0)</span></p>

    <p class="text-gray-300">with <span class="math">b_{1},b_{2},b_{3},b_{4}</span> chosen uniformly at random and <span class="math">b_{5}:=b_{1}b_{2}-b_{4}</span>. We write</p>

    <p class="text-gray-300"><span class="math">\\mathbf{v}(t):=\\mathbf{a}t+\\mathbf{b},</span></p>

    <p class="text-gray-300">for the line held by the prover, and <span class="math">\\mathbf{v}=\\mathbf{a}\\alpha+\\mathbf{b}</span> for the point received by the verifier, for a random <span class="math">\\alpha\\in\\mathbb{F}</span>. We likewise write the prover’s view of the entries as</p>

    <p class="text-gray-300"><span class="math">\\mathbf{v}(t)=(v_{1}(t),v_{2}(t),v_{3}(t),v_{4}(t),v_{5}(t)),</span></p>

    <p class="text-gray-300">and write <span class="math">v_{i}</span> for <span class="math">v_{i}(\\alpha)</span>. The verifier now checks whether</p>

    <p class="text-gray-300"><span class="math">v_{1}v_{2}-\\alpha v_{3}-v_{4}-v_{5}=0.</span></p>

    <p class="text-gray-300">We remark that it would be possible to present the same protocol as a <span class="math">(4,5,0)</span>-LPZK by dropping the <span class="math">v_{5}</span> term and setting <span class="math">b_{4}:=b_{1}b_{2}</span>. This variant has the same communication and computation complexity, but we give the <span class="math">(5,4,1)</span>-LPZK construction here because it is more similar to the construction in Section 4.3.</p>

    <h3 id="sec-37" class="text-xl font-semibold mt-8">3.2 Proof</h3>

    <p class="text-gray-300">To prove that this is a commit-and-prove protocol for the relation <span class="math">R(x,y,z)=xy-z</span> we give a deterministic extractor that takes the line <span class="math">(\\mathbf{a}^{<em>},\\mathbf{b}^{</em>})</span> generated by a malicious prover, and extracts effective inputs <span class="math">W^{<em>}:=(x^{</em>},y^{<em>},z^{</em>})</span>, and must prove the extractor and protocol satisfy completeness, binding, soundness, and zero knowledge. The extractor is simple: it reads off <span class="math">W^{<em>}</span> as the first three entries of <span class="math">\\mathbf{a}^{</em>}</span>.</p>

    <h4 id="sec-38" class="text-lg font-semibold mt-6">Completeness.</h4>

    <p class="text-gray-300">If the prover is honest, we have</p>

    <p class="text-gray-300"><span class="math">v_{1}v_{2}-\\alpha v_{3}-v_{4}-v_{5}</span> <span class="math">=</span> <span class="math">(xy-z)\\alpha^{2}+(xb_{2}+yb_{1}-b_{3}-(xb_{2}+yb_{1}-b_{3}))\\alpha</span> <span class="math">+b_{1}b_{2}-b_{4}-b_{5}</span> <span class="math">=</span> <span class="math">0</span></p>

    <p class="text-gray-300">identically, as long as <span class="math">xy-z=0</span>.</p>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">.</p>

    <h5 id="sec-39" class="text-base font-semibold mt-4">Binding.</h5>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For any <span class="math">W^{\\prime}\\neq W^{<em>}</span>, the verifier’s values <span class="math">\\mathbf{a}^{</em>}\\alpha+\\mathbf{b}^{<em>}</span> are consistent with <span class="math">W^{\\prime}</span> only if <span class="math">a_{i}^{</em>}\\alpha+b_{i}^{<em>}=a_{i}^{\\prime}\\alpha+b_{i}^{\\prime}</span>, for <span class="math">i\\in\\{1,2,3\\}</span>. For any choice <span class="math">(\\mathbf{a}^{\\prime},\\mathbf{b}^{\\prime})\\neq(\\mathbf{a}^{</em>},\\mathbf{b}^{<em>})</span> where these equality conditions hold, there exists an index <span class="math">i</span> with <span class="math">a_{i}^{</em>}\\neq a_{i}^{\\prime}</span> and <span class="math">b_{i}^{<em>}\\neq b_{i}^{\\prime}</span>, and the prover can compute a corresponding guess <span class="math">\\alpha^{</em>}=(b_{i}^{<em>}-b_{i}^{\\prime})/(a_{i}^{</em>}-a_{i}^{\\prime})</span>. Since <span class="math">\\alpha</span> is chosen uniformly at random, independent of the prover, the probability that <span class="math">\\alpha=\\alpha^{*}</span> is at most $1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h5 id="sec-40" class="text-base font-semibold mt-4">Soundness.</h5>

    <p class="text-gray-300">If the extracted input <span class="math">W^{*}</span> does not satisfy <span class="math">R</span>, then the expression</p>

    <p class="text-gray-300"><span class="math">v_{1}(t)v_{2}(t)-tv_{3}(t)-v_{4}(t)-v_{5}(t)=</span> <span class="math">(x^{<em>}y^{</em>}-z^{<em>})t^{2}</span> <span class="math">+\\big{(}x^{</em>}b_{2}^{<em>}+y^{</em>}b_{1}^{<em>}-b_{3}^{</em>}-a_{4}^{<em>}\\big{)}t</span> <span class="math">+b_{1}^{</em>}b_{2}^{<em>}-b_{4}^{</em>}-b_{5}^{*}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">is a non-trivial polynomial in <span class="math">t</span> of degree <span class="math">2</span>. This polynomial is only satisfied if <span class="math">\\alpha</span> is one of the at most <span class="math">2</span> roots, which gives a soundness error of at most $2/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h5 id="sec-41" class="text-base font-semibold mt-4">Zero knowledge.</h5>

    <p class="text-gray-300"><span class="math">V</span> can simulate their view by generating <span class="math">v_{1}</span>, <span class="math">v_{2}</span>, <span class="math">v_{3}</span> and <span class="math">v_{5}</span> uniformly at random, and computing <span class="math">v_{4}=v_{1}v_{2}-\\alpha v_{3}-v_{5}</span>. We know that <span class="math">v_{1}</span>, <span class="math">v_{2}</span>, <span class="math">v_{3}</span> and <span class="math">v_{5}</span> are uniformly random because of the uniform randomness of <span class="math">b_{1}</span>, <span class="math">b_{2}</span>, <span class="math">b_{3}</span> and <span class="math">b_{4}</span>, respectively. <span class="math">\\square</span></p>

    <h3 id="sec-42" class="text-xl font-semibold mt-8">3.3 Complexity</h3>

    <h5 id="sec-43" class="text-base font-semibold mt-4">Communication.</h5>

    <p class="text-gray-300">The communication cost of implementing <span class="math">(5,4,1)</span>-LPZK over random VOLE is <span class="math">5</span> field elements, as explained in Section 2.</p>

    <h5 id="sec-44" class="text-base font-semibold mt-4">Prover computation.</h5>

    <p class="text-gray-300"><span class="math">3</span> multiplications, <span class="math">2</span> additions, and <span class="math">7</span> subtractions (counting the computation of <span class="math">xy=z</span>, and computing <span class="math">xb_{2}+yb_{1}</span> as <span class="math">(x+b_{1})(y+b_{2})-z-b_{1}b_{2}</span>).</p>

    <h5 id="sec-45" class="text-base font-semibold mt-4">Verifier computation.</h5>

    <p class="text-gray-300"><span class="math">2</span> multiplications, <span class="math">2</span> subtractions, and one equality test.</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Remark 3.1 (Extension to general arithmetic circuits).</h6>

    <p class="text-gray-300">We can convert this protocol to an LPZK for arithmetic circuits by placing all intermediate wire values into <span class="math">\\mathbf{a}</span> and running the commit-and-prove protocol for each multiplication gate. The binding property ensures that the wire values match the values <span class="math">x,y,z</span> for which the prover demonstrates <span class="math">xy=z</span>. For all multiplication gates whose inputs are intermediate values, the verifier no longer needs to learn the values <span class="math">v_{1},v_{2}</span> masking the inputs <span class="math">x,y</span> from VOLE, but can instead compute them as a linear combination of previous multiplication gate outputs. This therefore gives a communication cost of <span class="math">3</span> field elements per multiplication gate. We improve on this by batching together verification messages into blocks of size <span class="math">t</span>, as we show in the next section.</p>

    <h2 id="sec-47" class="text-2xl font-bold">4 Information-Theoretic LPZK for Arithmetic Circuits</h2>

    <p class="text-gray-300">In this section we prove Theorem 1.1 by describing an information-theoretic LPZK for proving the satisfiability of arithmetic circuits.</p>

    <p class="text-gray-300">4.1 Setup</p>

    <p class="text-gray-300">An arithmetic circuit <span class="math">C</span> over a field <span class="math">\\mathbb{F}</span> with <span class="math">k</span> input wires, <span class="math">k^{\\prime}</span> output wires, <span class="math">m</span> multiplication gates, and arbitrarily many addition gates can be converted into an ordered triple <span class="math">(\\mathbf{a},Q_{C},R_{C})</span>, where <span class="math">\\mathbf{a}=(a_{0},a_{1},\\ldots,a_{k+k^{\\prime}+4m})</span> represent wire values. The input wires correspond to indices <span class="math">0,1,\\ldots,k</span>, the intermediate wires correspond to indices <span class="math">k+1,\\ldots,k+4m</span>, and the output wires correspond to indices <span class="math">k+4m+1,\\ldots,k+k^{\\prime}+4m</span>. <span class="math">Q_{C}</span> is a collection of <span class="math">m</span> degree 2 polynomials, with the <span class="math">i</span>th polynomial defined as</p>

    <p class="text-gray-300"><span class="math">q_{i}(\\mathbf{a}):=a_{k+4i-1}-a_{k+4i-3}a_{k+4i-2},</span></p>

    <p class="text-gray-300">and <span class="math">R_{C}</span> is a set of linear relations defining certain <span class="math">a_{i}</span>’s in terms of previous elements. Formally, we write <span class="math">\\mathbf{r}\\cdot\\mathbf{a}</span> for the standard dot product, and write <span class="math">R_{C}</span> as <span class="math">2m+k^{\\prime}</span> vectors <span class="math">\\mathbf{r}_{i}</span> corresponding to the relations</p>

    <p class="text-gray-300"><span class="math">\\mathbf{r}_{2i-j}\\cdot\\mathbf{a}=a_{k+4i-2-j},</span></p>

    <p class="text-gray-300">for <span class="math">j\\in\\{0,1\\}</span>, and <span class="math">1\\leq i\\leq m</span>, where the only nonzero entries of <span class="math">\\mathbf{r}_{2i-j}</span> occur at indices <span class="math">\\leq k+4i-4</span>, and</p>

    <p class="text-gray-300"><span class="math">\\mathbf{r}_{2m+i}\\cdot\\mathbf{a}=0,</span></p>

    <p class="text-gray-300">for <span class="math">1\\leq i\\leq k^{\\prime}</span>.</p>

    <p class="text-gray-300">The wires <span class="math">a_{k+4i}</span> are not needed for the insecure evaluation of the circuit, but we introduce them now to keep indices consistent. We require that each of <span class="math">\\mathbf{r}_{j}</span> have zero at each of their entries in positions <span class="math">k+4i</span>, for <span class="math">1\\leq j\\leq 2m+k^{\\prime}</span> and <span class="math">1\\leq i\\leq m</span>, i.e. the relations in <span class="math">R_{C}</span> cannot depend on the unused <span class="math">a_{k+4i}</span> wires. We set <span class="math">a_{0}=1</span> so that the relations <span class="math">R_{C}</span> can include addition by constant terms.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We construct a NIZK in this setting. Using a <span class="math">(k+2m,k+2m,\\frac{m}{t}+k^{\\prime})</span>-LPZK with soundness error $2t/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, a prover </span>P<span class="math"> will convince a verifier </span>V<span class="math"> that they hold a witness </span>\\mathbf{w}=(w_{1},\\ldots,w_{k})<span class="math"> of circuit inputs to </span>C<span class="math"> such that the </span>k^{\\prime}<span class="math"> entries </span>a_{k+4m+i}=0<span class="math">, for </span>1\\leq i\\leq k^{\\prime}<span class="math">. The circuit </span>C<span class="math"> and associated data </span>k<span class="math">, </span>k^{\\prime}<span class="math">, </span>m<span class="math"> and </span>Q$ are public.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-48" class="text-xl font-semibold mt-8">4.2 The LPZK construction</h3>

    <p class="text-gray-300">To begin, the prover constructs a pair of vectors <span class="math">(\\mathbf{a},\\mathbf{b})\\in\\mathbb{F}^{k+(4+\\frac{1}{t})m+2}</span>, with <span class="math">a_{0}=1</span> and <span class="math">b_{0}=0</span>. The next <span class="math">k</span> elements of <span class="math">\\mathbf{a}</span> are set equal to the witness <span class="math">\\mathbf{w}</span>, and the corresponding elements of <span class="math">\\mathbf{b}</span> are chosen uniformly at random. Using the relations in <span class="math">R_{C}</span>, for the <span class="math">i</span>th multiplication gate, and for <span class="math">j\\in\\{0,1\\}</span>, the prover defines</p>

    <p class="text-gray-300"><span class="math">a_{k+4i-2-j}:=\\mathbf{r}_{2i-j}\\cdot\\mathbf{a}</span> <span class="math">b_{k+4i-2-j}:=\\mathbf{r}_{2i-j}\\cdot\\mathbf{b}</span> <span class="math">a_{k+4i-1}:=a_{k+4i-3}a_{k+4i-2}</span> <span class="math">a_{k+4i}:=a_{k+4i-3}b_{k+4i-2}+a_{k+4i-2}b_{k+4i-3}-b_{k+4i-1},</span></p>

    <p class="text-gray-300">with <span class="math">b_{k+4i-j}</span> chosen uniformly at random, for <span class="math">j\\in\\{0,1\\}</span>. Then, for <span class="math">1\\leq i\\leq k^{\\prime}</span>, <span class="math">P</span> sets <span class="math">a_{k+4m+i}=0</span> and</p>

    <p class="text-gray-300"><span class="math">b_{k+4m+i}:=\\mathbf{r}_{2m+i}\\cdot\\mathbf{b}.</span></p>

    <p class="text-gray-300">Next, <span class="math">P</span> constructs a vector <span class="math">\\mathbf{c}</span> of length <span class="math">m</span> and defines</p>

    <p class="text-gray-300"><span class="math">c_{i}:=b_{k+4i-3}b_{k+4i-2}-b_{k+4i},</span></p>

    <p class="text-gray-300">if this value is not equal to zero, and <span class="math">c_{i}=1</span> otherwise, for <span class="math">1\\leq i\\leq m</span>. Finally, for <span class="math">i=1,\\ldots,m/t</span>, <span class="math">P</span> sets <span class="math">a_{k+k^{\\prime}+4m+i}=0</span> and defines</p>

    <p class="text-gray-300"><span class="math">b_{k+k^{\\prime}+4m+i}:=\\prod_{j=t\\cdot i}^{t\\cdot i+t-1}c_{j}.</span></p>

    <p class="text-gray-300">After constructing <span class="math">(\\mathbf{a},\\mathbf{b})</span>, the prover constructs a shortened pair of vectors <span class="math">(\\hat{\\mathbf{a}},\\hat{\\mathbf{b}})</span> of length <span class="math">k+k^{\\prime}+(2+\\frac{1}{t})m+1</span> by deleting the zeroth entry and the entries <span class="math">k+4i-2-j</span>, for <span class="math">1\\leq i\\leq m</span> and <span class="math">j\\in\\{0,1\\}</span>, and performs LPZK with the verifier so that the verifier learns <span class="math">\\hat{\\mathbf{v}}=\\alpha\\hat{\\mathbf{a}}+\\hat{\\mathbf{b}}</span>.</p>

    <p class="text-gray-300">The verifier then computes from <span class="math">\\hat{\\mathbf{v}}</span> a vector <span class="math">\\mathbf{v}</span> of length <span class="math">k+k^{\\prime}+(4+\\frac{1}{t})m+2</span> by re-indexing to match the indexing of <span class="math">\\mathbf{a}</span> and <span class="math">\\mathbf{b}</span>, setting <span class="math">v_{0}=1</span>, and computing</p>

    <p class="text-gray-300"><span class="math">v_{k+4i-2-j}:=\\mathbf{r}_{2i-j}\\cdot\\mathbf{v},</span></p>

    <p class="text-gray-300">for <span class="math">1\\leq i\\leq m</span> and <span class="math">j\\in\\{0,1\\}</span>.</p>

    <p class="text-gray-300">Then for <span class="math">1\\leq i\\leq k^{\\prime}</span>, the verifier checks that <span class="math">\\mathbf{r}_{2m+i}\\cdot\\mathbf{v}=v_{k+4m+i}</span>. Finally, the verifier defines, for <span class="math">1\\leq i\\leq m</span>, the values</p>

    <p class="text-gray-300"><span class="math">x_{i}:=v_{k+4i-3}v_{k+4i-2}-\\alpha v_{k+4i-1}-v_{k+4i},</span></p>

    <p class="text-gray-300">when this is nonzero, and <span class="math">x_{i}:=1</span> otherwise, and checks that</p>

    <p class="text-gray-300"><span class="math">\\prod_{j=t\\cdot i}^{t\\cdot i+t-1}x_{j}=v_{k+k^{\\prime}+4m+i}.</span></p>

    <h3 id="sec-49" class="text-xl font-semibold mt-8">4.3 Proof</h3>

    <p class="text-gray-300">We now state and prove a more refined version of Theorem 1.1.</p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Theorem 4.1 (LPZK for arithmetic circuit satisfiability).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For any NP-relation <span class="math">R(x,y)</span> and finite field <span class="math">\\mathbb{F}</span>, there exists an LPZK system for <span class="math">R</span> over <span class="math">\\mathbb{F}</span> with soundness error $O(1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Concretely, in the case of proving the satisfiability of an arithmetic circuit </span>C<span class="math"> over </span>\\mathbb{F}<span class="math">, we get LPZK over </span>\\mathbb{F}<span class="math"> with the following size parameters </span>(n,n^{\\prime},n^{\\prime\\prime})<span class="math"> and soundness error </span>\\varepsilon<span class="math"> for every integer </span>t\\geq 1<span class="math">. If </span>C<span class="math"> has </span>k<span class="math"> inputs, </span>k^{\\prime}<span class="math"> outputs, and </span>m<span class="math"> multiplication gates, we have </span>n=k+k^{\\prime}+(2+\\frac{1}{t})m<span class="math">, </span>n^{\\prime}=k+2m<span class="math">, </span>n^{\\prime\\prime}=\\frac{m}{t}+k^{\\prime}<span class="math">, </span>\\varepsilon=2t/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Moreover, assuming that the cost of additions in the field are negligible compared to the cost of multiplications, the computation of the prover is less than </span>4<span class="math"> times the cost of evaluation in the clear, and the computation of the verifier is less than </span>5$ times the cost of evaluation in the clear.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-51" class="text-lg font-semibold mt-6">Completeness:</h4>

    <p class="text-gray-300">If <span class="math">P</span> has a valid witness <span class="math">\\mathbf{w}</span> for <span class="math">C</span> and follows the protocol, then, for the output gates, for <span class="math">1\\leq i\\leq k^{\\prime}</span>, we have</p>

    <p class="text-gray-300"><span class="math">\\mathbf{r}_{2m+i}\\cdot\\mathbf{v}=\\alpha\\mathbf{r}_{2m+i}\\cdot\\mathbf{a}+\\mathbf{r}_{2m+i}\\cdot\\mathbf{b}=b_{k+4m+i}=v_{k+4m+i}.</span></p>

    <p class="text-gray-300">For the multiplication gates, for <span class="math">1\\leq i\\leq m</span>, as in Section 3, we have</p>

    <p class="text-gray-300"><span class="math">(v_{k+4i-3})(v_{k+4i-2})</span> <span class="math">=(\\alpha a_{4i-3}+b_{4i-3})(\\alpha a_{4i-2}+b_{4i-2})</span> <span class="math">=\\alpha^{2}a_{4i-3}a_{4i-2}+\\alpha(a_{4i-3}b_{4i-2}+a_{4i-2}b_{4i-3})+b_{4i-3}b_{4i-2}</span> <span class="math">=\\alpha v_{k+4i-1}+v_{k+4i}+c_{i},</span></p>

    <p class="text-gray-300"><span class="math">b_{4i-3}b_{4i-2}\\neq 0</span>, and <span class="math">(v_{k+4i-3})(v_{k+4i-2})=\\alpha v_{k+4i-1}+v_{k+4i}</span> otherwise. Thus <span class="math">c_{i}=x_{i}</span> for all <span class="math">i</span>, and we have</p>

    <p class="text-gray-300"><span class="math">\\prod_{j=t\\cdot i}^{t\\cdot i+t-1}x_{j}=\\prod_{j=t\\cdot i}^{t\\cdot i+t-1}c_{j}=v_{k+k^{\\prime}+4m+i},</span></p>

    <p class="text-gray-300">as desired.</p>

    <h4 id="sec-52" class="text-lg font-semibold mt-6">Perfect Zero Knowledge:</h4>

    <p class="text-gray-300">The simulator generates <span class="math">\\alpha</span> and <span class="math">v_{1},\\ldots,v_{k}</span> uniformly at random from <span class="math">\\mathbb{F}</span>. Since <span class="math">v_{i}=\\alpha a_{i}+b_{i}</span> for <span class="math">1\\leq i\\leq k</span> under an honest run of the protocol, and <span class="math">b_{1},\\ldots,b_{k}</span> are generated uniformly at random and independently, the <span class="math">v_{i}</span>’s are also uniformly random and independent under an honest run of the protocol. Therefore the distribution produced by the simulator matches the distribution produced by an honest run for <span class="math">v_{1},\\ldots,v_{k}</span>.</p>

    <p class="text-gray-300">Next, the simulator generates <span class="math">v_{k+4i-j}</span> uniformly at random, for <span class="math">1\\leq i\\leq m</span> and <span class="math">j\\in\\{0,1\\}</span>, which again matches exactly the distribution under an honest run of the protocol, by the uniform randomness of the <span class="math">b_{k+4i-j}</span>’s. Then, working from left to right, the simulator computes</p>

    <p class="text-gray-300"><span class="math">v_{k+4i-2-j}:=\\mathbf{r}_{2i-j}\\cdot\\mathbf{v},</span></p>

    <p class="text-gray-300">for <span class="math">j\\in\\{0,1\\}</span> and</p>

    <p class="text-gray-300"><span class="math">x_{i}:=v_{k+4i-3}v_{k+4i-2}-\\alpha v_{k+4i-1}-v_{k+4i}.</span></p>

    <p class="text-gray-300">The simulator then generates</p>

    <p class="text-gray-300"><span class="math">v_{k+4m+i}:=\\mathbf{r}_{2m+i}\\cdot\\mathbf{v}</span></p>

    <p class="text-gray-300">for <span class="math">1\\leq i\\leq k^{\\prime}</span> and</p>

    <p class="text-gray-300"><span class="math">v_{k+k^{\\prime}+4m+i}:=\\prod_{j=t\\cdot i}^{t\\cdot i+t-1}x_{j}</span></p>

    <p class="text-gray-300">for <span class="math">1\\leq i\\leq m/t</span> and outputs accept.</p>

    <h4 id="sec-53" class="text-lg font-semibold mt-6">Soundness:</h4>

    <p class="text-gray-300">We show the stronger proof-of-knowledge property. For a line <span class="math">(\\hat{\\mathbf{a}}^{<em>},\\hat{\\mathbf{b}}^{</em>})</span> generated by a (potentially malicious) prover, we give an efficient extractor <span class="math">E(\\hat{\\mathbf{a}}^{<em>},\\hat{\\mathbf{b}}^{</em>})</span> that extracts the witness <span class="math">\\mathbf{w}^{<em>}</span>. In fact, we have <span class="math">\\mathbf{w}^{</em>}:=(a_{1}^{<em>},\\ldots,a_{k}^{</em>})</span>, i.e. the extractor reads off the first <span class="math">k</span> elements of <span class="math">\\hat{\\mathbf{a}}^{*}</span>. As in Section 3, we write <span class="math">\\hat{\\mathbf{v}}(t)</span> and <span class="math">\\mathbf{v}(t)</span> for the lines the prover holds on which the verifier queries the points <span class="math">\\hat{\\mathbf{v}}</span> and <span class="math">\\mathbf{v}</span>.</p>

    <p class="text-gray-300">Suppose <span class="math">V</span> accepts <span class="math">\\alpha\\hat{\\mathbf{a}}^{<em>}+\\hat{\\mathbf{b}}^{</em>}</span> and <span class="math">C(\\mathbf{w}^{<em>})\\neq\\mathbf{0}</span>. Then either <span class="math">a_{k+4i-1}\\neq a_{k+4i-3}a_{k+4i-2}</span>, for some <span class="math">i\\leq m</span>, or <span class="math">\\mathbf{a}^{</em>}\\cdot\\mathbf{r}_{2m+i}\\neq 0</span>, for some <span class="math">i\\leq k^{\\prime}</span>.</p>

    <p class="text-gray-300">In the first case, the corresponding expression</p>

    <p class="text-gray-300"><span class="math">x_{i}(t)=v_{k+4i-3}(t)v_{k+4i-2}(t)-\\alpha v_{k+4i-1}(t)-v_{k+4i}(t)</span></p>

    <p class="text-gray-300">reduces to a nontrivial polynomial of degree 2 over <span class="math">\\alpha</span>, and so for some <span class="math">i</span> the expression</p>

    <p class="text-gray-300"><span class="math">v_{k+k^{\\prime}+4m+i}(t)-\\prod_{j=t\\cdot i}^{t\\cdot i+t-1}x_{j}(t)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">is a nontrivial polynomial over <span class="math">t</span> of degree at least 2 and at most <span class="math">2t</span>. This gives a soundness error of at most $2t/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In the second case, we have</p>

    <p class="text-gray-300"><span class="math">a_{k+4m+i}t+b_{k+4m+i}=v_{k+4m+i}(t)=\\mathbf{v}^{<em>}(t)\\cdot\\mathbf{r}_{2m+i}=\\mathbf{a}^{</em>}\\cdot\\mathbf{r}_{2m+i}t+\\mathbf{b}^{*}\\cdot\\mathbf{r}_{2m+i},</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">which simplifies to a linear polynomial over <span class="math">t</span>, which corresponds to a soundness error of at most $1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Remark 4.1 (Commit-and-prove construction).</strong> This protocol can be modified slightly to give a commit-and-prove proof system. We can give a deterministic extractor that extracts an effective inputs from the line <span class="math">(\\mathbf{a}^<em>, \\mathbf{b}^</em>)</span> generated by a malicious prover by reading off the entries corresponding to the witness. The argument is similar to the proof of the binding property given in section 5, and we omit the details.</p>

    <h2 id="sec-54" class="text-2xl font-bold">4.4 Complexity</h2>

    <p class="text-gray-300">We give complexity bounds for the online stage of the protocol, for a circuit <span class="math">C</span> with <span class="math">k</span> inputs and <span class="math">m</span> multiplication gates.</p>

    <p class="text-gray-300">Let <span class="math">T(C)</span> denote the time to evaluate the addition and scalar multiplication gates of a circuit <span class="math">C</span> in the clear, <span class="math">T(<em>)</span> the cost of a multiplication and <span class="math">T(+)</span> the cost of an addition, so that the total cost of evaluation in the clear is <span class="math">T(C) + mT(</em>)</span>.</p>

    <p class="text-gray-300"><strong>Communication complexity:</strong> For the <span class="math">k + 2m</span> one-side-fixed VOLE, we require the communication of <span class="math">k + 2m</span> field elements. Our checks of multiplication gates require an additional <span class="math">m / t</span> field elements, and the final output wire checks require <span class="math">k&#x27;</span> more elements, for a total of <span class="math">k + k&#x27; + (2 + \\frac{1}{t})m</span> field elements.</p>

    <p class="text-gray-300"><strong>Prover computation:</strong> Applying § 3.3 and accounting for the additional cost of updating the <span class="math">a_{k+4i-2}, a_{k+4i-3}, b_{k+4i-2}, b_{k+4i-3}</span> terms, the prover's work is <span class="math">2T(C) + (4 - \\frac{1}{t})mT(*) + (k + 6m)T(+)</span>, which assuming the cost of additions is negligible, is less than 4 times the cost of evaluation in the clear.</p>

    <p class="text-gray-300"><strong>Verifier computation:</strong> Similarly, the verifier's work is <span class="math">T(C) + \\left((5 - \\frac{1}{t})m + k\\right)T(<em>) + 2mT(+)</span>, which assuming the cost of additions is negligible, is less than 5 times the cost of evaluation in the clear. Included in this cost is a <span class="math">2m + kT(</em>)</span> term from the conversion from random to fixed VOLE.</p>

    <p class="text-gray-300"><strong>Remark 4.2.</strong> Assuming that the random VOLE instances are already precomputed, or alternatively that such compressed instances can be "unpacked" in a streaming fashion, our NIZK protocol does not require the vectors <span class="math">\\mathbf{a}, \\mathbf{b}, \\mathbf{v}</span> to be computed or stored in their entirety. Instead, the entries corresponding to each gate can be computed on the fly. This makes our protocol friendly to streaming and space considerations.</p>

    <p class="text-gray-300">In particular, computations like <span class="math">a_{k+4i-2-j} = \\mathbf{r}_{2i-j} \\cdot \\mathbf{a}</span> should be treated as shorthand for hard-coded evaluation of addition and scalar multiplication gates, and should certainly not be implemented by actually storing <span class="math">\\mathbf{r}_{2i-j}</span> in memory and performing a dot product.</p>

    <p class="text-gray-300">In fact, besides the memory costs of the VOLE, which can be made sublinear in the circuit size² (see [12, 13, 44, 45, 15] for possible trade-offs and optimizations), the only values that the verifier needs to store beyond what would be required for execution of the program in the clear is a single field element holding the product of the <span class="math">x_{j}</span> terms in the current batch. The prover's memory cost is double the verifier's, since <span class="math">P</span> has to store the values from both <span class="math">\\mathbf{a}</span> and <span class="math">\\mathbf{b}</span> that are currently "in-scope" along with the product of the <span class="math">c_{j}</span> terms in the current batch.</p>

    <p class="text-gray-300">²To this end one can either use the "primal" PCG for VOLE from [12, 44], which has at most quadratic stretch, or store multiple seeds of a higher-stretch PCG where each seed is expanded when processing a different (sublinear-size) segment of the circuit. Alternatively, one could use a pseudorandom correlation function [15].</p>

    <p class="text-gray-300">5 LPZK in the Random Oracle Model</p>

    <p class="text-gray-300">In the section we prove Theorem 1.3, which gives an improved NIZK over random VOLE in the random oracle model (ROM). This follows by applying the compiler of Lemma 2.1 to the LPZK in following theorem.</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Theorem 5.1 (LPZK in the ROM).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For any positive integer <span class="math">r</span>, there exists an LPZK in the ROM for arithmetic circuit satisfiability, with the following size parameters <span class="math">(n,n^{\\prime},n^{\\prime\\prime})</span> and soundness error. If <span class="math">C</span> has <span class="math">k</span> inputs, <span class="math">k^{\\prime}</span> outputs, and <span class="math">m</span> multiplication gates, we have <span class="math">n=k+k^{\\prime}+m+2r</span>, <span class="math">n^{\\prime}=k</span>, <span class="math">n^{\\prime\\prime}=k^{\\prime}+m+2r</span>. For any malicious prover making <span class="math">\\ell</span> calls to a random oracle <span class="math">H:\\mathbb{F}^{m}\\to\\mathbb{F}^{mr}</span>, the soundness error is $\\varepsilon=\\frac{2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}+\\frac{\\ell}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{r}}<span class="math">. Moreover, the computation of both the prover and the verifier consists of </span>O(r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> field operations and a single call to </span>H$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">At a high level, the LPZK construction begins by setting a equal to the wire values in the circuit evaluation, and choosing b at random, as in § 4.2. To convince the verifier that all multiplication gates have been evaluated correctly, the prover must show that a sequence of quadratic polynomials whose coefficients are determined by a and b each have leading term zero, i.e. that this sequence of quadratics is actually a sequence of linear polynomials. The protocol uses LPZK to reveal to the verifier a vector s of the evaluations of those quadratics at <span class="math">\\alpha</span> and then the prover must show they have vectors <span class="math">\\mathbf{y},\\mathbf{z}</span> such that <span class="math">\\mathbf{s}=\\mathbf{y}\\alpha+\\mathbf{z}</span>. In other words, the prover must show that <span class="math">\\mathbf{y},\\mathbf{z}</span> as VOLE inputs give s as a VOLE output.</p>

    <p class="text-gray-300">To do this, prover and verifier choose a random <span class="math">r\\times m</span> matrix <span class="math">M:=H(\\mathbf{w})</span> by evaluating a random oracle <span class="math">H</span> on the prover messages <span class="math">\\mathbf{w}</span> sent during the protocol. Then after adding random masks from the LPZK to <span class="math">\\mathbf{y},\\mathbf{z},\\mathbf{s}</span>, the verifier cheks that <span class="math">M\\mathbf{s}=M\\mathbf{y}\\alpha+M\\mathbf{z}</span>.</p>

    <h3 id="sec-56" class="text-xl font-semibold mt-8">5.1 The LPZK construction</h3>

    <p class="text-gray-300">Similar to § 4.2, the prover begins by constructing a line <span class="math">\\mathbf{v}(t):=\\mathbf{a}t+\\mathbf{b}</span> with <span class="math">\\mathbf{v}\\in\\mathbb{F}^{k+k^{\\prime}+5m+3r+1}</span>, and then reduces to a shorter <span class="math">\\hat{\\mathbf{v}}</span> that is used as VOLE input. For <span class="math">0\\leq i\\leq k+k^{\\prime}+4m</span>, the prover defines <span class="math">a_{i}</span> and <span class="math">b_{i}</span> identically to their definitions in § 4.2, except each entry <span class="math">a_{k+4j}</span> is chosen uniformly at random from <span class="math">\\mathbb{F}</span>, for <span class="math">1\\leq j\\leq m</span>, and each entry <span class="math">b_{k+4j}</span> is chosen so that <span class="math">b_{k+4j}=b_{k+4j-1}</span>. The partial redundancy between the <span class="math">k+4j-1</span>th and <span class="math">k+4j</span>th entry is to preserve the indexing of § 4.2 while enabling the reconstruction of <span class="math">v_{k+4i-1}</span> from <span class="math">v_{k+4i}</span> and the value of <span class="math">a_{k+4j}-a_{k+4j-1}</span>, as described below.</p>

    <p class="text-gray-300">The next <span class="math">r</span> entries of a and b are chosen uniformly at random from <span class="math">\\mathbb{F}</span>. The remaining <span class="math">m+2r</span> entries of a are all set equal to zero, and the remaining <span class="math">m+2r</span> entries of b will be given explicitly later. These <span class="math">m+2r</span> entries, in other words, can be sent from the prover to the verifier directly without require any VOLE overhead.</p>

    <p class="text-gray-300">For <span class="math">1\\leq i\\leq m</span>, the prover computes</p>

    <p class="text-gray-300"><span class="math">y_{i}:=b_{k+4i-1}-a_{k+4i-3}b_{k+4i-2}-a_{k+4i-2}b_{k+4i-3}</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">z_{i}:=-b_{k+4i-3}b_{k+4i-2},</span></p>

    <p class="text-gray-300">and defines <span class="math">\\mathbf{y}=(y_{i})</span> and <span class="math">\\mathbf{z}=(z_{i})</span>, where <span class="math">i</span> ranges from <span class="math">1</span> to <span class="math">m</span>. For <span class="math">r</span> the positive integer fixed in the statement of the theorem, let <span class="math">H:\\mathbb{F}^{m}\\to\\mathbb{F}^{mr}</span> be a random oracle, and treat the output of <span class="math">H</span> as a matrix in <span class="math">M_{r\\times m}(\\mathbb{F})</span>. The prover then defines <span class="math">\\mathbf{w}:=(w_{i}):=(a_{k+4i-1}-a_{k+4i})</span>, where <span class="math">i</span> ranges from <span class="math">1</span> to <span class="math">m</span>. The prover then sets</p>

    <p class="text-gray-300"><span class="math">y:=(a_{k+k^{\\prime}+4m+1},\\ldots,a_{k+k^{\\prime}+4m+r})^{T}+H(\\mathbf{w})\\mathbf{y}^{T}</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">z:=(b_{k+k^{\\prime}+4m+1},\\ldots,b_{k+k^{\\prime}+4m+r})^{T}+H(\\mathbf{w})\\mathbf{z}^{T}.</span></p>

    <p class="text-gray-300">For <span class="math">1\\leq i\\leq m</span>, the prover sets</p>

    <p class="text-gray-300"><span class="math">b_{k+k^{\\prime}+4m+r+i}:=a_{k+4i-1}-a_{k+4i},</span></p>

    <p class="text-gray-300">then the prover sets</p>

    <p class="text-gray-300"><span class="math">\\mathbf{b}[k+k^{\\prime}+5m+r+1:k+k^{\\prime}+5m+2r]=y,</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">\\mathbf{b}[k+k^{\\prime}+5m+2r+1:k+k^{\\prime}+5m+3r]=z,</span></p>

    <p class="text-gray-300">writing <span class="math">\\mathbf{b}[i,j]</span> for the projection onto coordinates <span class="math">i</span> through <span class="math">j</span> inclusive.</p>

    <p class="text-gray-300">Next, the prover computes from the pair <span class="math">(\\mathbf{a},\\mathbf{b})</span> a line in a lower-dimensional space <span class="math">\\hat{\\mathbf{v}}(t):=\\hat{\\mathbf{a}}t+\\hat{\\mathbf{b}}\\in\\mathbb{F}^{k+k^{\\prime}+2m+3r}</span>. For <span class="math">1\\leq i\\leq k</span>, we take <span class="math">\\hat{a}_{i}=a_{i}</span> and <span class="math">\\hat{b}_{i}=b_{i}</span>. For <span class="math">1\\leq i\\leq m</span> we take <span class="math">\\hat{a}_{k+i}=a_{k+4i}</span> and <span class="math">\\hat{b}_{k+i}=b_{k+4i}</span>. For <span class="math">1\\leq i\\leq r</span>, we take <span class="math">\\hat{a}_{k+m+i}=a_{k+k^{\\prime}+4m+i}</span> and <span class="math">\\hat{b}_{k+m+i}=b_{k+k^{\\prime}+4m+i}</span>. The remaining <span class="math">k^{\\prime}+m+2r</span> values of <span class="math">\\mathbf{a}</span> we set equal to zero. For <span class="math">1\\leq i\\leq k^{\\prime}</span>, we set <span class="math">\\hat{b}_{k+m+r+i}=\\mathbf{r}_{2m+i}\\cdot\\mathbf{b}</span>. For <span class="math">1\\leq i\\leq m</span>, we set <span class="math">\\hat{b}_{k+k^{\\prime}+m+r+i}=w_{i}=a_{k+4i-1}-a_{k+4i}</span>. Finally, for <span class="math">1\\leq i\\leq 2r</span>, we set <span class="math">\\hat{b}_{k+k^{\\prime}+2m+r+i}=b_{k+k^{\\prime}+5m+r+i}</span>.</p>

    <p class="text-gray-300">Now, having constructed <span class="math">\\hat{\\mathbf{v}}(t)</span>, the prover and verifier run LPZK so that the verifier learns <span class="math">\\hat{\\mathbf{v}}(\\alpha)</span>, and, similar to § 4.2, expands <span class="math">\\hat{\\mathbf{v}}(\\alpha)</span> to a vector <span class="math">\\mathbf{v}=\\mathbf{a}\\alpha+\\mathbf{b}</span>. The verifier reconstructs <span class="math">v_{k+4i-1}</span> as</p>

    <p class="text-gray-300"><span class="math">v_{k+4i-1}=v_{k+4i}+\\alpha v_{k+k^{\\prime}+m+r+i},</span></p>

    <p class="text-gray-300">and the other missing values as in § 4.2.</p>

    <p class="text-gray-300">The verifier now computes, for <span class="math">1\\leq i\\leq m</span>,</p>

    <p class="text-gray-300"><span class="math">s_{i}:=v_{k+4i-1}\\alpha-v_{k+4i-3}v_{k+4i-2},</span></p>

    <p class="text-gray-300">the vector <span class="math">\\mathbf{s}=(s_{i})</span>, and the value</p>

    <p class="text-gray-300"><span class="math">s</span> <span class="math">:=(v_{k+k^{\\prime}+4m+1},\\ldots,v_{k+k^{\\prime}+4m+r})^{T}+H(\\mathbf{w})\\mathbf{s}^{T},</span> <span class="math">y_{\\alpha}</span> <span class="math">:=(\\mathbf{v}[k+k^{\\prime}+5m+r+1:k+k^{\\prime}+5m+2r])</span> <span class="math">z_{\\alpha}</span> <span class="math">:=(\\mathbf{v}[k+k^{\\prime}+5m+2r+1:k+k^{\\prime}+5m+3r])</span></p>

    <p class="text-gray-300">and returns <span class="math">\\mathsf{rej}</span> unless <span class="math">y\\alpha+z=s</span>. Then for <span class="math">1\\leq i\\leq k^{\\prime}</span>, the verifier checks that <span class="math">\\mathbf{r}_{2m+i}\\cdot\\mathbf{v}=v_{k+4m+i}</span> and returns <span class="math">\\mathsf{rej}</span> if any test fails, and <span class="math">\\mathsf{acc}</span> otherwise.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Remark 5.1.</h6>

    <p class="text-gray-300">As with information-theoretic LPZK, we can convert the algorithm above to a streaming algorithm requiring <span class="math">O(r)</span> local memory beyond what would be required in a plaintext evaluation of the circuit.</p>

    <p class="text-gray-300">The conversion is similar to the information-theoretic case, although we now have to also evaluate the random oracle <span class="math">H</span> in a streaming fashion. We choose a pair of random oracles <span class="math">H_{1},H_{2}</span>, where <span class="math">H_{1}:\\mathbb{F}^{m}\\to\\mathbb{F}</span> can be evaluated in a streaming fashion, and <span class="math">H_{2}:\\mathbb{F}\\times\\{1,\\ldots,m\\}\\to\\mathbb{F}^{r}</span>, and set the <span class="math">i</span>th column of <span class="math">H(\\mathbf{w})</span> equal to <span class="math">H_{2}(H_{1}(\\mathbf{w}),i)</span>.</p>

    <p class="text-gray-300">An honest prover computes <span class="math">H_{1}(\\mathbf{w})</span> before performing the rest of the protocol, and sends this along with the rest of the proof. Then the prover can compute <span class="math">H(\\mathbf{w})\\mathbf{y}^{T}</span> and <span class="math">H(\\mathbf{w})\\mathbf{z}^{T}</span> in a streaming fashion while executing the LPZK protocol, and the verifier can likewise compute <span class="math">H(\\mathbf{w})\\mathbf{s}^{T}</span> and verify the value of <span class="math">H_{1}(\\mathbf{w})</span> sent by the prover based on the messages <span class="math">w_{i}</span> sent during the protocol.</p>

    <p class="text-gray-300">5.2 Proof</p>

    <h4 id="sec-58" class="text-lg font-semibold mt-6">Completeness:</h4>

    <p class="text-gray-300">Each of the tests <span class="math">\\mathbf{r}_{2m+1}\\cdot\\mathbf{v}=v_{k+4m+i}</span> are the same as in the previous section, and completeness follows by the same argument. If the prover is honest, the expression <span class="math">y_{\\alpha}\\alpha+z_{\\alpha}</span> is equal to <span class="math">y\\alpha+z</span>. Comparing <span class="math">y\\alpha+z</span> to <span class="math">s</span>, we have <span class="math">v_{k+k^{\\prime}+4m+r+i}=a_{k+4i-1}-a_{k+4i}</span> by construction and <span class="math">y_{i}\\alpha+z_{i}=s_{i}</span> by the same argument used in the previous section. We have</p>

    <p class="text-gray-300"><span class="math">(v_{k+k^{\\prime}+4m+1},\\ldots,v_{k+k^{\\prime}+4m+r})</span> <span class="math">=</span> <span class="math">(a_{k+k^{\\prime}+4m+1},\\ldots,a_{k+k^{\\prime}+4m+r})\\alpha</span> <span class="math">+(b_{k+k^{\\prime}+4m+1},\\ldots,b_{k+k^{\\prime}+4m+r}),</span></p>

    <p class="text-gray-300">since the underlying elements are terms from the random VOLE, so <span class="math">y\\alpha+z=s</span>, as desired.</p>

    <h4 id="sec-59" class="text-lg font-semibold mt-6">Zero Knowledge:</h4>

    <p class="text-gray-300">The simulator chooses the values of <span class="math">v_{i}</span> uniformly at random from <span class="math">\\mathbb{F}</span>, for <span class="math">1\\leq i\\leq k</span>, and likewise chooses <span class="math">v_{k+4i}</span> uniformly at random for <span class="math">1\\leq i\\leq m</span>, and chooses <span class="math">v_{k+k^{\\prime}+4m+i}</span> uniformly at random, for <span class="math">1\\leq i\\leq r+m</span>. These values are all distributed uniformly at random and independently under an honest run of the protocol; the <span class="math">v_{i}</span>’s are distributed uniformly by the randomness of the <span class="math">b_{i}</span>’s, for <span class="math">1\\leq i\\leq k</span>, the <span class="math">v_{k+4i}</span>’s by the randomness of <span class="math">b_{k+4i}</span>, for <span class="math">1\\leq i\\leq m</span>, the <span class="math">v_{k+k^{\\prime}+4m+i}</span>’s by the randomness of <span class="math">a_{k+4i}</span>, for <span class="math">1\\leq i\\leq m</span>, and the <span class="math">v_{k+k^{\\prime}+5m+r+i}</span>’s by the randomness of <span class="math">b_{k+k^{\\prime}+5m+r+i}</span>, for <span class="math">1\\leq i\\leq r</span>. The simulator then computes <span class="math">v_{k+4i-3},v_{k+4i-2},v_{k+4i-1}</span>, and <span class="math">s_{i}</span>, for <span class="math">1\\leq i\\leq m</span>, and <span class="math">s</span> and <span class="math">y_{\\alpha}</span>, all as the verifier computes them during the actual protocol, and then computes <span class="math">z_{\\alpha}=s-\\alpha y</span>. Finally, the simulator sets</p>

    <p class="text-gray-300"><span class="math">\\mathbf{v}[k+k^{\\prime}+5m+2r+1:k+k^{\\prime}+5m+3r]=z_{\\alpha},</span></p>

    <p class="text-gray-300">and <span class="math">v_{k+4m+i}=\\mathbf{r}_{2m+1}\\cdot\\mathbf{v}</span> for <span class="math">1\\leq i\\leq k^{\\prime}</span> and outputs <span class="math">\\mathsf{acc}</span>.</p>

    <h4 id="sec-60" class="text-lg font-semibold mt-6">Soundness:</h4>

    <p class="text-gray-300">Define the vector</p>

    <p class="text-gray-300"><span class="math">\\mathbf{u}(t):=\\left(v_{k+4i-1}(t)t-v_{k+4i-2}(t)v_{k+4i-3}(t)\\right),</span></p>

    <p class="text-gray-300">where <span class="math">i</span> ranges from <span class="math">1</span> to <span class="math">m</span>. We write</p>

    <p class="text-gray-300"><span class="math">s(t):=yt+z+H(\\mathbf{w})\\cdot\\left(\\mathbf{u}(t)\\right)^{T}</span></p>

    <p class="text-gray-300">for the system of <span class="math">r</span> quadratic equations in <span class="math">t</span> the prover implicitly constructs in the course of the protocol and the verifier evaluates at the point <span class="math">\\alpha</span>. We write <span class="math">\\mathbf{u}:=\\left(a_{k+4i-1}-a_{k+4i-2}a_{k+4i-3}\\right)</span> for the quadratic term of <span class="math">\\mathbf{u}(t)</span>, and note that, since <span class="math">a_{k+4i}</span> is random, and each of <span class="math">a_{k+4i-2}</span> and <span class="math">a_{k+4i-3}</span> are determined by wire values to the left, <span class="math">\\mathbf{u}</span> is determined by <span class="math">\\mathbf{w}</span> along with randomness outside of a cheating prover’s control.</p>

    <p class="text-gray-300">If the prover cheats on a multiplication gate, there is some <span class="math">i</span> for which</p>

    <p class="text-gray-300"><span class="math">(v_{k+4i-1}(t)t-v_{k+4i-2}(t)v_{k+4i-3}(t))-(y_{i}t-z_{i})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">is a nontrivial quadratic in <span class="math">t</span>. Then either <span class="math">s(t)</span> is also a nontrivial quadratic in <span class="math">t</span>, which gives a soundness error of at most $2/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> (i.e. if exactly one of the </span>r$ quadratics is nontrivial), or else</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">0=H(\\mathbf{w})\\cdot\\left(\\mathbf{u}\\right)^{T},</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i.e. <span class="math">\\mathbf{u}^{T}</span> lies in the kernel of <span class="math">H(\\mathbf{w})</span>. By the randomness of the oracle, the kernel is a random subspace of <span class="math">\\mathbb{F}^{m}</span> of codimension <span class="math">r</span>, and the probability that <span class="math">\\mathbf{u}</span> lies in this subspace is $1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{r}<span class="math">, since </span>\\mathbf{u}<span class="math"> is entirely determined from </span>\\mathbf{w}<span class="math">. Over </span>\\ell<span class="math"> evaluations of </span>H<span class="math"> by a malicious prover, this gives a soundness error of </span>\\ell/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{r}$, as desired.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">5.3 Complexity</p>

    <p class="text-gray-300">The computation of complexity is similar to the previous section.</p>

    <p class="text-gray-300">The prover <span class="math">P</span> needs to send <span class="math">y</span> and <span class="math">z</span> to the verifier, giving a communication cost of <span class="math">2r</span> elements for the verification of the multiplication gates, in addition to the <span class="math">k+k^{\\prime}+m</span> communication for wire values. This gives a total of <span class="math">k+k^{\\prime}+m+2r</span> field elements of communication.</p>

    <p class="text-gray-300">The prover performs <span class="math">3</span> multiplications per multiplication gate, while the verifier performs <span class="math">2</span> multiplications. The prover must multiply <span class="math">H(\\mathbf{w})</span> by the vectors <span class="math">\\mathbf{y}^{T}</span>, <span class="math">\\mathbf{z}^{T}</span>, while the verifier does the same multiplication by <span class="math">\\mathbf{s}^{T}</span>. This matrix multiplication requires <span class="math">mr</span> multiplications, giving an amortized cost of <span class="math">2r</span> multiplications per multiplication gate for the prover and <span class="math">r</span> multiplications per multiplication gate for the verifier. Finally, the verifier must perform an additional <span class="math">k+m+r</span> multiplications to convert from random to fixed VOLE. This gives a total cost of <span class="math">3+2r</span> multiplications per multiplication gate for the prover, <span class="math">3+r</span> for the verifier, and the single evaluation of <span class="math">H</span> for both parties.</p>

    <h2 id="sec-61" class="text-2xl font-bold">6 Non-Interactive Secure Computation</h2>

    <p class="text-gray-300">In this section we apply LPZK towards simplifying and improving the efficiency of the reusable protocol for non-interactive secure computation (NISC) from <em>[19]</em>. Our construction relies on a variant of VOLE called <em>certified</em> VOLE, described in more detail in § 6.2.</p>

    <h3 id="sec-62" class="text-xl font-semibold mt-8">6.1 NISC definition</h3>

    <p class="text-gray-300">We start by giving a simplified definition of reusable NISC over VOLE, which strengthens the definition from <em>[19]</em>. The definition can be seen as a natural extension of the definition of LPZK to the case of secure computation, where both the sender and the receiver have secret inputs. Instead of the prover encoding its witness as a line and the verifier picking a random point, here the sender encodes its input as multiple lines and the receiver encodes its input as multiple points, one for each line. (The lines are the sender’s VOLE inputs and the points are the receiver’s VOLE inputs.)</p>

    <p class="text-gray-300">At a high level, reusable security is ensured by preventing a malicious sender from making the receiver’s output depend on its input beyond the dependence allowed by the ideal functionality. This is contrasted with OT-based NISC protocols, where the sender can learn a receiver’s OT input by starting from an honest strategy and replacing one of the sender OT inputs by a random one.</p>

    <p class="text-gray-300">We formulate the NISC definition for arithmetic functions <span class="math">f</span> defined over an arbitrary field <span class="math">\\mathbb{F}</span>, where the security error vanishes with the field size. For simplicity we consider a single function <span class="math">f</span> and information-theoretic security. The definition can be naturally generalized to take a function description as input and allow computational security.</p>

    <h6 id="sec-63" class="text-base font-medium mt-4">Definition 6.1 (Reusable arithmetic NISC).</h6>

    <p class="text-gray-300">A reusable non-interactive secure computation (NISC) protocol over VOLE for an arithmetic function <span class="math">f:\\mathbb{F}^{n}\\times\\mathbb{F}^{m}\\to\\mathbb{F}^{\\ell}</span> is a triple of algorithms <span class="math">(\\mathit{R1},\\mathit{S},\\mathit{R2})</span> with the following syntax:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathit{R1}(\\mathbb{F},\\mathbf{x})</span> is a PPT algorithm that, given an input <span class="math">\\mathbf{x}\\in\\mathbb{F}^{n}</span>, outputs points <span class="math">(\\alpha_{1},\\ldots,\\alpha_{n^{\\prime}})\\in\\mathbb{F}^{n^{\\prime}}</span> and auxiliary information <span class="math">\\mathsf{aux}</span>.</li>

      <li><span class="math">\\mathit{S}(\\mathbb{F},\\mathbf{y})</span> is a PPT algorithm that, given <span class="math">\\mathbf{y}\\in\\mathbb{F}^{m}</span>, outputs <span class="math">n^{\\prime}</span> pairs of vectors <span class="math">\\mathbf{a}_{i},\\mathbf{b}_{i}\\in\\mathbb{F}^{s}</span>, each specifying an affine line <span class="math">\\mathbf{v}_{i}(t):=\\mathbf{a}_{i}t+\\mathbf{b}_{i}</span>.</li>

      <li><span class="math">\\mathit{R2}(\\mathbb{F},\\mathsf{aux},(\\mathbf{v}_{1},\\ldots,\\mathbf{v}_{n^{\\prime}}))</span> is a polynomial-time algorithm that, given auxiliary information <span class="math">\\mathsf{aux}</span> and evaluations <span class="math">\\mathbf{v}_{i}</span>, outputs either <span class="math">\\mathbf{z}\\in\\mathbb{F}^{\\ell}</span> or <span class="math">\\mathit{rej}</span>.</li>

    </ul>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">The algorithms <span class="math">(R1, S, R2)</span> should satisfy the following security requirements:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. When both parties follow the protocol, running the above algorithms in sequence, with <span class="math">\\mathbf{v}_i = \\mathbf{v}_i(\\alpha_i)</span>, results in the output <span class="math">\\mathbf{z} = f(\\mathbf{x}, \\mathbf{y})</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Reusable <span class="math">\\varepsilon</span>-security against malicious sender. There exists a polynomial-time extractor algorithm <span class="math">\\mathsf{Ext}</span> such that for any field <span class="math">\\mathbb{F}</span> and lines <span class="math">\\mathbf{v}_i^<em>(t) := \\mathbf{a}_i^</em> t + \\mathbf{b}_i^<em></span>, the output of <span class="math">\\mathsf{Ext}(\\mathbb{F}, (\\mathbf{a}_1^</em>, \\mathbf{b}_1^<em>), \\ldots, (\\mathbf{a}_{n&#x27;}^</em>, \\mathbf{b}_{n&#x27;}^<em>))</span> is <span class="math">\\mathbf{y}^</em> \\in \\mathbb{F}^m \\cup \\{\\bot\\}</span> such that the following holds: for every honest receiver's input <span class="math">\\mathbf{x} \\in \\mathbb{F}^n</span>, the receiver's output when interacting with malicious sender strategy <span class="math">\\mathbf{v}_i^<em>(t)</span> is equal to <span class="math">f(\\mathbf{x}, \\mathbf{y}^</em>)</span> except with <span class="math">\\leq \\varepsilon</span> probability over the receiver's randomness. Here we assume that the output on <span class="math">\\bot</span> is <span class="math">\\text{rej}</span>. Unless otherwise specified, we assume $\\varepsilon \\leq O(1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. We will also use a random-input variant of the above definition, where the probability is over both the receiver&#x27;s randomness and a uniformly random choice of </span>\\mathbf{x} \\in \\mathbb{F}^n$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Perfect security against malicious receiver. There exist a polynomial-time extractor algorithm <span class="math">\\mathsf{Ext}</span> and PPT simulator algorithm <span class="math">\\mathsf{Sim}</span> such that, for any field <span class="math">\\mathbb{F}</span> and malicious receiver points <span class="math">\\alpha_1^<em>, \\ldots, \\alpha_{n&#x27;}^</em> \\in \\mathbb{F}</span>, the extractor outputs an effective input <span class="math">\\mathbf{x}^<em> = \\mathsf{Ext}(\\mathbb{F}, (\\alpha_1^</em>, \\ldots, \\alpha_{n&#x27;}^<em>))</span>, where <span class="math">\\mathbf{x}^</em> \\in \\mathbb{F}^n</span>, such that the following holds. For every honest sender's input <span class="math">\\mathbf{y} \\in \\mathbb{F}^m</span>, the output distribution of <span class="math">\\mathsf{Sim}(\\mathbb{F}, f(\\mathbf{x}^<em>, \\mathbf{y}))</span> is identical to <span class="math">\\{(\\mathbf{v}_1(\\alpha_1^</em>), \\ldots, \\mathbf{v}_{n&#x27;}(\\alpha_{n&#x27;}^*)) : (\\mathbf{v}_1(t), \\ldots, \\mathbf{v}_{n&#x27;}^t(t)) \\stackrel{R}{\\leftarrow} S(\\mathbb{F}, \\mathbf{y})\\}</span>.</li>

    </ul>

    <p class="text-gray-300">We note that instead of allowing the receiver to output <span class="math">\\text{rej}</span>, we could instead make the receiver use a default value for the sender input and compute the output of <span class="math">f</span>. However, making the receiver reject whenever it detects cheating makes protocol descriptions more natural.</p>

    <p class="text-gray-300">The definition above does not permit the sender to transmit additional values to the receiver in the clear. In order to simplify the definition and the proofs, we note that we can realize plaintext transmission from sender to receiver as a reusable NISC protocol over VOLE. The function <span class="math">f(\\mathbf{x}, \\mathbf{y}) \\coloneqq \\mathbf{y}</span> prints the sender input, the algorithm R1(F, x) outputs random points <span class="math">\\alpha_1, \\alpha_2</span>, and the sender algorithm S(F, y) outputs <span class="math">\\mathbf{a}_i \\coloneqq \\mathbf{0}</span> and <span class="math">\\mathbf{b}_i = \\mathbf{y}</span> for <span class="math">i = 1, 2</span>. Finally, R2(F, (v1, v2)) rejects if <span class="math">\\mathbf{v}_1 \\neq \\mathbf{v}_2</span>, and outputs <span class="math">\\mathbf{v}_1</span> otherwise. The security conditions are straightforward to verify.</p>

    <p class="text-gray-300">In the proofs below, when we refer to "sending values in the clear", we formally mean the protocol above. In actual applications, of course, we will continue to send the plaintexts directly. We use direct transmission, rather than this more involved NISC protocol, in our analysis of computation and communication complexity.</p>

    <p class="text-gray-300">Throughout this section, whenever we desire to refer to the <span class="math">j</span>th entry of a vector <span class="math">\\mathbf{a}_i, \\mathbf{b}_i, \\mathbf{v}_i</span>, etc, we write the entry as <span class="math">a_i^j, b_i^j, v_i^j</span>, etc.</p>

    <h2 id="sec-64" class="text-2xl font-bold">6.2 Certified VOLE</h2>

    <p class="text-gray-300">The main building block for NISC is a certified variant of VOLE, allowing the sender and the receiver to invoke multiple parallel instances of VOLE while assuring the receiver that the sender's VOLE inputs satisfy some global consistency relation.</p>

    <h2 id="sec-65" class="text-2xl font-bold">6.2.1 Definitions and results</h2>

    <p class="text-gray-300">In its general form, certified VOLE with a general arithmetic relation, the VOLE consistency requirement is specified by a general arithmetic circuit. We write cVOLE for this form of certified VOLE.</p>

    <p class="text-gray-300">We begin with a more specialized form, distributional certified VOLE with equality constraints, which we write as eVOLE. In this variant of certified VOLE, the arithmetic circuit on the family</p>

    <p class="text-gray-300">of VOLEs is restricted to a single equality constraint between two coefficients from <span class="math">\\mathbf{a}</span> vectors. In eVOLE, we require additionally that <span class="math">R</span>’s inputs are uniformly distributed over <span class="math">\\mathbb{F}</span> and independent. It is straightforward to extend this result to an arbitrary set of equality constraints on terms from <span class="math">\\mathbf{a}</span> and <span class="math">\\mathbf{b}</span> vectors, and we explain the details below.</p>

    <p class="text-gray-300">Certified VOLE of these flavors can be realized by extending a family of random VOLEs with a NIZK proof that the random VOLEs satisfy the desired constraints. We give more precise definitions of these forms of certified VOLE as ideal functionalities in Figures 1 and 2. We state this result as the following two lemmas.</p>

    <h6 id="sec-66" class="text-base font-medium mt-4">Lemma 6.1.</h6>

    <p class="text-gray-300">A receiver <span class="math">R</span> and a sender <span class="math">S</span> can realize the functionality <span class="math">\\mathcal{F}_{eVOLE}^{(\\mathbb{F})}</span> with parameters <span class="math">(\\ell_{1},\\ell_{2},i,j)</span> in the rVOLE hybrid model with <span class="math">2</span> instances of random VOLE of total length <span class="math">\\ell_{1}+\\ell_{2}+2</span> and communication of <span class="math">3</span> field elements from sender to receiver, in addition to any communication cost for transforming random VOLEs to the VOLEs with inputs <span class="math">(\\hat{\\mathbf{a}}_{1},\\hat{\\mathbf{b}}_{1},\\hat{\\mathbf{a}}_{2},\\hat{\\mathbf{b}}_{2})</span>.</p>

    <h6 id="sec-67" class="text-base font-medium mt-4">Lemma 6.2.</h6>

    <p class="text-gray-300">Fix an integer <span class="math">t\\geq 1</span>. A receiver <span class="math">R</span> and a sender <span class="math">S</span> can realize the functionality <span class="math">\\mathcal{F}_{eVOLE}^{(\\mathbb{F})}</span>, in the rVOLE hybrid model with <span class="math">k+2</span> instances of random VOLE. For a circuit <span class="math">C</span> with <span class="math">q_{\\mathbf{a}}</span> inputs from the <span class="math">\\hat{\\mathbf{a}}_{i}</span>’s, <span class="math">q_{\\mathbf{b}}</span> inputs from the <span class="math">\\hat{\\mathbf{b}}_{i}</span>’s, <span class="math">q^{\\prime}</span> outputs, and <span class="math">m</span> multiplication gates, these VOLE instances have total length</p>

    <p class="text-gray-300"><span class="math">2m+6q_{\\mathbf{a}}+7q_{\\mathbf{b}}+\\sum_{i=1}^{k}\\ell_{i},</span></p>

    <p class="text-gray-300">and the protocol requires communication of</p>

    <p class="text-gray-300"><span class="math">(2+\\tfrac{1}{t})m+q^{\\prime}+8q_{\\mathbf{a}}+9q_{\\mathbf{b}}+2\\sum_{i=1}^{k}\\ell_{i}</span></p>

    <p class="text-gray-300">field elements from sender to receiver.</p>

    <p class="text-gray-300">Figure 1: Distributional certified VOLE with equality constraints</p>

    <p class="text-gray-300">Functionality  <span class="math">\\mathcal{F}_{eVOLE}^{(\\mathbb{F})}</span> : Distributional certified VOLE with equality constraint</p>

    <p class="text-gray-300">Parametrized by a finite field  <span class="math">\\mathbb{F}</span> , length parameters  <span class="math">(\\ell_1, \\ell_2)</span> , and integers  <span class="math">i, j</span>  with  <span class="math">1 \\leq i \\leq \\ell_1</span>  and  <span class="math">1 \\leq j \\leq \\ell_2</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">R</span>  sends  <span class="math">\\mathbf{x} \\coloneqq (\\alpha, \\beta)</span>  to  <span class="math">\\mathcal{F}_{eVOLE}^{(\\mathbb{F})}</span>  // Receiver security is only required for random inputs</li>

      <li><span class="math">S</span>  sends  <span class="math">\\mathbf{y} \\coloneqq (\\hat{\\mathbf{a}}_1, \\hat{\\mathbf{b}}_1, \\hat{\\mathbf{a}}_2, \\hat{\\mathbf{b}}_2)</span>  to  <span class="math">\\mathcal{F}_{eVOLE}^{(\\mathbb{F})}</span> , where  <span class="math">\\hat{\\mathbf{a}}_k, \\hat{\\mathbf{b}}_k \\in \\mathbb{F}^{\\ell_i}</span></li>

      <li><span class="math">\\mathcal{F}_{cVOLE}^{(\\mathbb{F})}</span>  verifies that  <span class="math">\\hat{a}_1^i = \\hat{a}_2^j</span> .</li>

      <li>If the input does not pass verification, the ideal functionality sends  <span class="math">\\perp</span>  to  <span class="math">R</span> . Otherwise,  <span class="math">\\mathcal{F}_{cVOLE}^{(\\mathbb{F})}</span>  computes  <span class="math">\\hat{\\mathbf{v}}_1 \\coloneqq \\hat{\\mathbf{a}}_1\\alpha + \\hat{\\mathbf{b}}_1</span>  and  <span class="math">\\hat{\\mathbf{v}}_2 \\coloneqq \\hat{\\mathbf{a}}_2\\beta + \\hat{\\mathbf{b}}_2</span>  and sends  <span class="math">f(\\mathbf{x},\\mathbf{y}) \\coloneqq (\\mathbf{v}_1,\\mathbf{v}_2)</span>  to  <span class="math">R</span> .</li>

    </ul>

    <p class="text-gray-300">Figure 2: Certified VOLE with a general arithmetic relation</p>

    <p class="text-gray-300">Functionality  <span class="math">\\mathcal{F}_{cVOLE}^{(\\mathbb{F})}</span></p>

    <p class="text-gray-300">Parametrized by a finite field  <span class="math">\\mathbb{F}</span> , a sequence of  <span class="math">k</span>  positive integers  <span class="math">\\ell_1, \\ldots, \\ell_k</span> , and an arithmetic circuit  <span class="math">C</span>  on  <span class="math">q \\leq 2\\sum_{i=1}^{k} \\ell_i</span>  inputs.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">R</span>  sends to  <span class="math">\\mathcal{F}_{cVOLE}^{(\\mathbb{F})}</span>  its input  <span class="math">\\mathbf{x} \\coloneqq (\\alpha_1, \\ldots, \\alpha_k) \\in \\mathbb{F}^k</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">S</span>  sends  <span class="math">\\mathbf{y} \\coloneqq (\\hat{\\mathbf{a}}_1, \\dots, \\hat{\\mathbf{a}}_k, \\hat{\\mathbf{b}}_1, \\dots, \\hat{\\mathbf{b}}_k)</span>  to  <span class="math">\\mathcal{F}_{cVOLE}^{(\\mathbb{F})}</span> , where  <span class="math">\\hat{\\mathbf{a}}_i, \\hat{\\mathbf{b}}_i \\in \\mathbb{F}^{\\ell_i}</span></li>

      <li><span class="math">\\mathcal{F}_{cVOLE}^{(\\mathbb{F})}</span>  verifies that  <span class="math">(\\hat{\\mathbf{a}}_1, \\dots, \\hat{\\mathbf{a}}_k, \\hat{\\mathbf{b}}_1, \\dots, \\hat{\\mathbf{b}}_k)</span>  is a satisfying assignment for  <span class="math">C</span> .</li>

      <li>If the input does not pass verification, the ideal functionality sends  <span class="math">\\perp</span>  to  <span class="math">R</span> . Otherwise,  <span class="math">\\mathcal{F}_{cVOLE}^{(\\mathbb{F})}</span>  computes  <span class="math">\\hat{\\mathbf{v}}_i \\coloneqq \\hat{\\mathbf{a}}_i \\alpha_i + \\hat{\\mathbf{b}}_i</span>  and sends  <span class="math">f(\\mathbf{x}, \\mathbf{y}) \\coloneqq (\\hat{\\mathbf{v}}_1, \\dots, \\hat{\\mathbf{v}}_k)</span>  to  <span class="math">R</span> .</li>

    </ul>

    <p class="text-gray-300">6.2.2 The protocols</p>

    <p class="text-gray-300">eVOLE. eVOLE is a special case of reusable arithmetic NISC where the receiver has no inputs, and R1(F) outputs uniformly random and independent points <span class="math">(\\alpha,\\beta)</span>, and stores their values as the auxiliary information <span class="math">\\mathsf{aux}:=(\\alpha,\\beta)</span>. The sender’s input <span class="math">\\mathbf{y}:=(\\hat{\\mathbf{a}}_{1},\\hat{\\mathbf{b}}_{1},\\hat{\\mathbf{a}}_{2},\\hat{\\mathbf{b}}_{2})</span> is two existing VOLE inputs, and the algorithm S(F,y) outputs vectors <span class="math">(\\mathbf{a}_{1},\\mathbf{b}_{1},\\mathbf{a}_{2},\\mathbf{b}_{2})</span> whose first <span class="math">\\ell,\\ell,\\ell^{\\prime}</span>, and <span class="math">\\ell^{\\prime}</span> coordinates are equal to <span class="math">(\\hat{\\mathbf{a}}_{1},\\hat{\\mathbf{b}}_{1},\\hat{\\mathbf{a}}_{2},\\hat{\\mathbf{b}}_{2})</span>, respectively. The remaining values are defined as <span class="math">a_{1}^{\\ell+1}:=\\hat{b}_{2}^{j}</span>, <span class="math">a_{2}^{\\ell^{\\prime}+1}:=\\hat{b}_{1}^{i}</span>, with <span class="math">b_{1}^{\\ell+1}</span> and <span class="math">b_{2}^{\\ell^{\\prime}+1}</span> chosen uniformly at random. In addition, the sender sends the value <span class="math">b_{1}^{\\ell+1}-b_{2}^{\\ell^{\\prime}+1}</span> in the clear.</p>

    <p class="text-gray-300">The VOLE protocol evaluates the sender’s output on <span class="math">\\alpha</span> and <span class="math">\\beta</span>, respectively, so that in an honest run of the protocol, the receiver learns <span class="math">\\mathbf{v}_{1}:=\\mathbf{a}_{1}\\alpha+\\mathbf{b}_{1}</span> and <span class="math">\\mathbf{v}_{2}:=\\mathbf{a}_{2}\\beta+\\mathbf{b}_{2}</span>. In the algorithm R2(F, <span class="math">\\mathsf{aux},(\\mathbf{v}_{1},\\mathbf{v}_{2})</span>), the receiver tests whether</p>

    <p class="text-gray-300"><span class="math">\\beta v_{1}^{i}-\\alpha v_{2}^{j}+v_{1}^{\\ell+1}-v_{2}^{\\ell^{\\prime}+1}=b_{1}^{\\ell+1}-b_{2}^{\\ell^{\\prime}+1}.</span></p>

    <p class="text-gray-300">The receiver rejects if the test fails, and otherwise outputs the vectors <span class="math">\\hat{\\mathbf{v}}_{1},\\hat{\\mathbf{v}}_{2}</span> obtained by deleting the last element from <span class="math">\\mathbf{v}_{1},\\mathbf{v}_{2}</span>.</p>

    <p class="text-gray-300">This protocol can be modified to prove constraints of the form <span class="math">\\hat{a}_{1}^{i}=\\hat{b}_{2}^{j}</span> or <span class="math">\\hat{b}_{1}^{i}=\\hat{b}_{2}^{j}</span> for the same communication cost and one or two additional multiplications, respectively, by the receiver. Indeed, by multiplying <span class="math">\\mathbf{v}_{1}</span> by <span class="math">\\alpha^{-1}</span> or <span class="math">\\mathbf{v}_{2}</span> by <span class="math">\\beta^{-1}</span>, the receiver can locally obtain the VOLE outputs <span class="math">\\mathbf{w}_{1}:=\\alpha^{-1}\\mathbf{b}_{1}+\\mathbf{a}_{1}</span> and <span class="math">\\mathbf{w}_{2}:=\\beta^{-1}\\mathbf{b}_{2}+\\mathbf{a}_{2}</span>, and the same construction above applies to the pair <span class="math">\\mathbf{v}_{1},\\mathbf{w}_{2}</span> or the pair <span class="math">\\mathbf{w}_{1},\\mathbf{w}_{2}</span>.</p>

    <p class="text-gray-300">Additionally, since the eVOLE protocol transforms VOLE inputs <span class="math">\\hat{\\mathbf{a}}_{i},\\hat{\\mathbf{b}}_{i}</span> for the sender into extended VOLE inputs <span class="math">\\mathbf{a}_{i},\\mathbf{b}_{i}</span> and delivers extended VOLE outputs <span class="math">\\mathbf{v}_{i}</span> to the receiver, this protocol can be implemented repeatedly on the <em>same two instances</em> of VOLE, proving <span class="math">c</span> equality constraints with VOLEs of length <span class="math">\\ell+c</span>, <span class="math">\\ell^{\\prime}+c</span>.</p>

    <p class="text-gray-300">cVOLE. We write the receiver’s inputs as <span class="math">\\mathbf{x}:=(\\alpha_{1},\\ldots,\\alpha_{k})</span>. The receiver’s algorithm R1(F,x) generates their VOLE inputs by choosing random independent values <span class="math">\\alpha,\\beta</span>, and then outputs <span class="math">(\\alpha+\\alpha_{1},\\ldots,\\alpha+\\alpha_{k},\\alpha,\\beta)</span>.</p>

    <p class="text-gray-300">As in eVOLE, the sender defines <span class="math">a_{i}^{j}:=\\hat{a}_{i}^{j}</span> everywhere this is defined. We give the definition of <span class="math">b_{i}^{j}</span> later. Then, for each input to <span class="math">C</span> from the <span class="math">\\hat{\\mathbf{a}}_{i}</span>’s, say <span class="math">\\hat{a}_{i}^{j_{1}}</span>, the sender chooses one entry of <span class="math">\\mathbf{a}_{k+1}</span> and one entry of <span class="math">\\mathbf{a}_{k+2}</span>, say <span class="math">a_{k+1}^{j_{2}}</span> and <span class="math">a_{k+2}^{j_{3}}</span> respectively, and uses eVOLE to prove <span class="math">\\hat{a}_{i}^{j_{1}}=a_{k+2}^{j_{3}}</span> and <span class="math">a_{k+1}^{j_{2}}=a_{k+2}^{j_{3}}</span>. Since each of the pairs <span class="math">(\\alpha+\\alpha_{i},\\beta)</span> and <span class="math">(\\alpha,\\beta)</span> are uniformly random and independent, the conditions for eVOLE are satisfied.</p>

    <p class="text-gray-300">Similarly, for an input <span class="math">\\hat{b}_{i}^{j_{1}}</span> to <span class="math">C</span>, the sender chooses entries <span class="math">b_{k+1}^{j_{2}}</span>, <span class="math">a_{k+2}^{j_{3}}</span> and <span class="math">a_{k+2}^{j_{4}}</span> and proves <span class="math">b_{i}^{j_{1}}=a_{k+2}^{j_{3}}</span> and <span class="math">b_{k+1}^{j_{2}}=a_{k+2}^{j_{4}}</span>. We now define <span class="math">b_{i}^{j_{1}}:=\\hat{b}_{i}^{j_{1}}+b_{k+1}^{j_{2}}</span>. Upon subtracting <span class="math">v_{k+1}^{j_{2}}:=a_{k+1}^{j_{2}}\\alpha+b_{k+1}^{j_{2}}</span> from <span class="math">v_{i}^{j_{1}}:=a_{i}^{j_{1}}(\\alpha+\\alpha_{i})+b_{i}^{j_{1}}</span>, the receiver holds</p>

    <p class="text-gray-300"><span class="math">\\hat{v}_{i}^{j_{1}}:=v_{i}^{j_{1}}-v_{k+1}^{j_{2}}=a_{i}^{j_{1}}\\alpha_{i}+(b_{i}^{j_{1}}-b_{k+1}^{j_{2}})=\\hat{a}_{i}^{j_{1}}\\alpha_{i}+\\hat{b}_{i}^{j_{1}}.</span></p>

    <p class="text-gray-300">After deleting unneeded entries of the <span class="math">\\hat{\\mathbf{v}}_{i}</span>’s receiver ends with the VOLE outputs <span class="math">\\hat{\\mathbf{v}}_{i}:=\\hat{\\mathbf{a}}_{i}\\alpha_{i}+\\hat{\\mathbf{b}}_{i}</span>, as desired. In addition, the elements <span class="math">a_{i}^{j_{1}},b_{i}^{j_{2}},b_{k+1}^{j_{2}}</span> have all been transferred to entries of <span class="math">\\mathbf{a}_{k+2}</span>, so the receiver and sender extend the <span class="math">(k+2)</span>nd instance of VOLE <span class="math">\\mathbf{v}_{k+2}</span> with a NIZK proof that <span class="math">C</span> is satisfied by <span class="math">\\hat{\\mathbf{a}}_{i},\\hat{\\mathbf{b}}_{i}</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">6.2.3 Proof of Lemma 6.1</p>

    <p class="text-gray-300">Completeness: Writing the value the sender transmits in the clear as <span class="math">c</span> in the protocol, we have</p>

    <div class="my-4 text-center"><span class="math-block">v _ {1} ^ {i} \\beta - v _ {2} ^ {j} \\alpha + v _ {1} ^ {\\ell + 1} - v _ {2} ^ {\\ell^ {\\prime} + 1} - c = (\\hat {a} _ {1} ^ {i} - \\hat {a} _ {2} ^ {j}) \\alpha \\beta + (a _ {1} ^ {\\ell + 1} - \\hat {b} _ {2} ^ {j}) \\alpha +</span></div>

    <div class="my-4 text-center"><span class="math-block">(a _ {2} ^ {\\ell^ {\\prime} + 1} - \\hat {b} _ {1} ^ {i}) \\beta + \\left((b _ {1} ^ {\\ell + 1} - b _ {2} ^ {\\ell^ {\\prime} + 1}) - c\\right).</span></div>

    <p class="text-gray-300">If the sender is honest, each of the four terms on the right-hand side vanish, and the receiver accepts the message, as desired.</p>

    <p class="text-gray-300">Perfect security against a malicious receiver: The receiver has no input, so the input extractor does nothing. A malicious receiver's output <span class="math">f(\\mathbf{x}^<em>, \\mathbf{y})</span> is the pair of truncations <span class="math">\\hat{\\mathbf{v}}_1, \\hat{\\mathbf{v}}_2</span> of the VOLE outputs <span class="math">\\mathbf{v}_1, \\mathbf{v}_2</span>. The simulator <span class="math">Sim(\\mathbb{F}, f(\\mathbf{x}^</em>, \\mathbf{y}))</span> obtains <span class="math">\\mathbf{v}_1^<em>, \\mathbf{v}_2^</em></span> from <span class="math">\\hat{\\mathbf{v}}_1, \\hat{\\mathbf{v}}_2</span> by appending a value chosen uniformly at random from <span class="math">\\mathbb{F}</span> to each vector.</p>

    <p class="text-gray-300">By construction, <span class="math">\\mathbf{v}_i^<em> = \\mathbf{v}_i</span> on every entry except the last. For the last entry, we note that, because <span class="math">\\hat{b}_1^{\\ell + 1}</span> and <span class="math">\\hat{b}_2^{\\ell&#x27; + 1}</span> are chosen independently and uniformly at random, the last entries of <span class="math">\\mathbf{v}_i</span> and <span class="math">\\mathbf{v}_i^</em></span> each follow the uniform distribution, so the output distributions are identical, as desired.</p>

    <p class="text-gray-300">Reusable <span class="math">\\varepsilon</span>-security against a malicious sender: The sender's input is two sets of VOLE inputs <span class="math">((\\hat{\\mathbf{a}}_1, \\hat{\\mathbf{b}}_1), (\\hat{\\mathbf{a}}_2, \\hat{\\mathbf{b}}_2))</span>, which are then extended by one entry each in the algorithm <span class="math">S(\\mathbb{F}, \\mathbf{y})</span>. The extractor <span class="math">\\operatorname{Ext}(\\mathbb{F}, (\\mathbf{a}_1^<em>, \\mathbf{b}_1^</em>), (\\mathbf{a}_2^<em>, \\mathbf{b}_2^</em>))</span> sets <span class="math">\\mathbf{y}^<em> = \\bot</span> if any of the conditions <span class="math">a_1^i = a_2^j</span>, <span class="math">a_1^{\\ell + 1} = b_2^j</span>, <span class="math">a_2^{\\ell&#x27; + 1} = b_1^i</span>, <span class="math">c = b_1^{\\ell + 1} - b_2^{\\ell&#x27; + 1}</span> are false, and otherwise computes <span class="math">\\mathbf{y}^</em></span> by truncation. We write <span class="math">tr</span> for the truncation-by-one operator.</p>

    <p class="text-gray-300">By completeness, whenever <span class="math">\\mathbf{y}^<em> \\neq \\bot</span> we have <span class="math">f(\\mathbf{x}, \\mathbf{y}^</em>) = tr(\\mathbf{v}^<em>)</span> which is equal to the receiver's output under an honest run of the protocol. Therefore the probability the receiver's output is not equal to <span class="math">f(\\mathbf{x}, \\mathbf{y}^</em>)</span> is precisely the probability that <span class="math">\\mathbf{y}^* = \\bot</span> and the receiver does not output <span class="math">\\operatorname{rej}</span>.</p>

    <p class="text-gray-300">This occurs precisely when the expression</p>

    <div class="my-4 text-center"><span class="math-block">(a _ {1} ^ {i} - a _ {2} ^ {j}) \\alpha \\beta + (a _ {1} ^ {\\ell + 1} - b _ {2} ^ {j}) \\alpha + (a _ {2} ^ {\\ell^ {\\prime} + 1} - b _ {1} ^ {i}) \\beta + b _ {1} ^ {\\ell + 1} - b _ {2} ^ {\\ell^ {\\prime} + 1} - c = 0,</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">but at least one of the four coefficients in this bivariate polynomial expression are nonzero. For all but at most one choice of <span class="math">\\alpha</span>, either fixing <span class="math">\\alpha</span> determines <span class="math">\\beta</span> or the statement is identically false. Since <span class="math">\\beta</span> is independent of <span class="math">\\alpha</span>, the probability that the true value of <span class="math">\\beta</span> matches the value determined by <span class="math">\\alpha</span> is $1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Together, this gives a soundness error bounded above by </span>2 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Complexity: The total VOLE length is <span class="math">\\ell + \\ell&#x27; + 2</span>, by construction.</p>

    <p class="text-gray-300">In addition to the cost of setting up the fixed VOLE on the first <span class="math">\\ell, \\ell&#x27;</span> entries of <span class="math">\\mathbf{v}_1, \\mathbf{v}_2</span>, respectively, the sender must communicate 3 field elements, 2 to set <span class="math">a_1^{\\ell + 1}</span> and <span class="math">a_2^{\\ell&#x27; + 1}</span>, and the additional value <span class="math">b_1^{\\ell + 1} - b_2^{\\ell&#x27; + 1}</span> that is sent in the clear.</p>

    <p class="text-gray-300">6.2.4 Proof of Lemma 6.2</p>

    <p class="text-gray-300">Correctness and security against malicious sender are immediate from the correctness and security of the underlying protocols. For security against a malicious receiver, the extractor <span class="math">\\mathsf{Ext}</span> obtains the values <span class="math">\\alpha_{1},\\ldots ,\\alpha_{k}</span> by subtracting <span class="math">\\alpha_{1}^{<em>} - \\alpha_{k + 1}^{</em>},\\ldots ,\\alpha_{k}^{<em>} - \\alpha_{k + 1}^{</em>}</span>. The simulator for the receiver generates the entire vectors <span class="math">\\mathbf{v}_{k + 1},\\mathbf{v}_{k + 2}</span> uniformly at random, which matches the distribution under an honest run of the protocol by the randomness of the values <span class="math">b_{k + 1}^{j},b_{k + 2}^{j}</span>. Vector elements <span class="math">v_{i}^{j_{1}}</span> are computed from the formula</p>

    <div class="my-4 text-center"><span class="math-block">v _ {i} ^ {j _ {1}} = \\hat {v} _ {i} ^ {j _ {1}} + v _ {k + 1} ^ {j _ {2}},</span></div>

    <p class="text-gray-300">using the indexing from the previous subsection and writing <span class="math">\\hat{v}_{i}^{j_{1}}</span> for entries of receiver output, i.e. of <span class="math">f(\\mathbf{x}^{*},\\mathbf{y})</span>, as above. All remaining entries of all vectors are chosen uniformly at random. Perfect security follows by the security of NIZK and eVOLE. We only need to check that eVOLE is only applied to pairs of VOLEs where the receiver VOLE inputs are uniformly random and independent. This is true for the pairs <span class="math">(\\alpha+\\alpha_{i},\\beta)</span> and the pair <span class="math">(\\alpha,\\beta)</span>, as desired.</p>

    <h4 id="sec-70" class="text-lg font-semibold mt-6">Complexity:</h4>

    <p class="text-gray-300">For each input to the circuit <span class="math">C</span>, whether from the <span class="math">\\mathbf{a}_{i}</span>’s or <span class="math">\\mathbf{b}_{i}</span>’s, we require two instances of eVOLE. For an entry of the <span class="math">\\hat{\\mathbf{a}}_{i}</span>’s that is an input to <span class="math">C</span>, we require an additional two entries of VOLE from <span class="math">\\mathbf{a}_{k+1}</span> and <span class="math">\\mathbf{a}_{k+2}</span>. For an entry of the <span class="math">\\hat{\\mathbf{b}}_{i}</span>’s that is an input to <span class="math">C</span>, we require three additional entries. For a total of <span class="math">q:=q_{\\mathbf{a}}+q_{\\mathbf{b}}</span> inputs, this requires</p>

    <p class="text-gray-300"><span class="math">6q_{\\mathbf{a}}+7q_{\\mathbf{b}}+\\sum_{i=1}^{k}\\ell_{i}</span></p>

    <p class="text-gray-300">entries of VOLE and</p>

    <p class="text-gray-300"><span class="math">8q_{\\mathbf{a}}+9q_{\\mathbf{b}}+2\\sum_{i=1}^{k}\\ell_{i}</span></p>

    <p class="text-gray-300">field elements of communication.</p>

    <p class="text-gray-300">The LPZK-NIZK proof of <span class="math">C</span> is carried out on the <span class="math">k+2</span>nd instance of VOLE, and the inputs to <span class="math">C</span> have already been included in the cost, so this requires an additional <span class="math">2m</span> entries of VOLE, and an additional <span class="math">k^{\\prime}+(2+\\frac{1}{t})m</span> field elements of communication. Combining these terms gives the VOLE length and communication costs as desired.</p>

    <h3 id="sec-71" class="text-xl font-semibold mt-8">6.3 Reusable NISC over VOLE</h3>

    <p class="text-gray-300">In this section we build on certified VOLE to compile NISC protocols with security against semi-honest senders into reusable NISC protocols in the fully malicious setting. We follow the same high level approach of <em>[19]</em>, but present the compiler at a higher level of generality and with a more refined efficiency analysis.</p>

    <p class="text-gray-300">Consider a two-party sender-receiver functionality <span class="math">f(\\mathbf{x},\\mathbf{y})</span> where the receiver <span class="math">R</span> holds <span class="math">\\mathbf{x}=(x_{1},\\ldots,x_{n})\\in\\mathbb{F}^{n}</span> and the sender <span class="math">S</span> hold inputs <span class="math">\\mathbf{y}=(y_{1},\\ldots,y_{n})\\in\\mathbb{F}^{m}</span>. The function <span class="math">f</span> is arithmetic, in the sense that its outputs are defined by a sequence of <span class="math">\\ell</span> arithmetic branching programs <span class="math">P_{1},\\ldots,P_{\\ell}</span> over <span class="math">\\mathbb{F}</span>, where program <span class="math">P_{i}</span> has <span class="math">s_{i}</span> nodes. (Note that such an arithmetic program <span class="math">P_{i}</span> can simulate any arithmetic formula with <span class="math">s_{i}</span> additions and multiplication gates.)</p>

    <p class="text-gray-300">The goal is to securely evaluate <span class="math">f</span> using only parallel instances of VOLE. (The ideal VOLE instances can be implemented using the same kind of cryptographic compilers we used in the context of LPZK.) We also require the NISC protocol to be reusable in the sense that if the receiver’s input is fixed but the sender’s input changes, the same VOLE inputs of the receiver can be securely reused, even if the sender can obtain partial information about the receiver’s outputs in the different invocations. This feature is impossible to achieve in the information-theoretic setting when we use OT instead of VOLE <em>[19]</em>.</p>

    <p class="text-gray-300">To get a reusable NISC for <span class="math">f</span>, we take the following two-step approach:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Using a so-called “Decomposable Affine Randomized Encoding” (DARE) for branching programs <em>[32, 3]</em> (an arithmetic variant of information-theoretic garbling), we get a NISC protocol for <span class="math">f</span> with <span class="math">n</span> instances of VOLE, each of length <span class="math">S_{j}=\\sum_{i\\in D(j)}{s_{i}\\choose 2}</span>, where <span class="math">D(j)</span> is the set of</li>

    </ol>

    <p class="text-gray-300">output entries that depend on <span class="math">x_j</span>. This protocol is secure against a malicious receiver <span class="math">R</span> and a semi-honest sender <span class="math">R</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>To obtain reusable security against a malicious <span class="math">S</span> (while maintaining security against malicious <span class="math">R</span>) we replace the parallel VOLE in the previous protocol by certified VOLE, where the circuit <span class="math">C</span> specifying the consistency relation takes the sender's input <span class="math">\\mathbf{y}</span> and randomness in the previous protocol as a witness, and checks that the sender's VOLE inputs are obtained by applying the honest sender's algorithm to the witness. Using naive matrix multiplication, this requires a circuit <span class="math">C</span> of size <span class="math">S = \\sum_{j=1}^{n} S_j + \\sum_{i=1}^{\\ell} s_i^3</span>. Applying our protocol for <span class="math">\\mathcal{F}_{cVOLE}^{(\\mathbb{F})}</span> with the arithmetic relation specified by <span class="math">C</span>, we ensure that whenever a malicious sender does not provide a witness that "explains" its VOLE inputs by an honest sender strategy, the receiver outputs <span class="math">\\perp</span> except with <span class="math">O(1 / \\mathbb{F})</span> probability. In particular, a (reusable) simulator for a malicious sender interacting with the <span class="math">\\mathcal{F}_{cVOLE}^{(\\mathbb{F})}</span> functionality either outputs the input <span class="math">\\mathbf{y}</span> found in the witness, if the consistency check specified by <span class="math">C</span> passes, or <span class="math">\\perp</span> if <span class="math">C</span> fails.</li>

    </ol>

    <p class="text-gray-300">Combining the above two steps, we derive the feasibility result from [19] in a simpler way.</p>

    <p class="text-gray-300">Theorem 6.3 (Reusable arithmetic NISC over VOLE). Suppose <span class="math">f: \\mathbb{F}^n \\times \\mathbb{F}^m \\to \\mathbb{F}^\\ell</span> is a sender-receiver functionality whose <span class="math">i</span>-th output can be computed by an arithmetic branching programs over <span class="math">\\mathbb{F}</span> of size <span class="math">s_i</span> that depends on <span class="math">d_i</span> inputs. Then <span class="math">f</span> admits a reusable NISC protocol over VOLE with the following efficiency and security features:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The protocol uses <span class="math">n + 2</span> parallel VOLE instances.</li>

      <li>The total length of the VOLE instances is <span class="math">15\\sum_{i=1}^{\\ell} d_i \\binom{s_i}{2} + 2\\sum_{i=1}^{\\ell} s_i^3</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The simulation error (per invocation) is $\\varepsilon = O(1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Chase et al. [19] show how to bootstrap Theorem 6.3 to get reusable NISC over VOLE for general Boolean circuits, by making (a non-black-box) use of any pseudorandom generator, or equivalently a one-way function.</p>

    <h2 id="sec-72" class="text-2xl font-bold">6.4 NISC Example: Bounded Inner Product</h2>

    <p class="text-gray-300">In this section we showcase the usefulness of reusable arithmetic NISC by presenting an optimized construction for a natural functionality: an inner product between the receiver's input vector and the sender's input vector, where the sender's vector is restricted to have a bounded <span class="math">L_{2}</span> norm. This functionality is useful for measuring similarity between two normalized feature vectors. The bound on the sender's input is essential for preventing a malicious sender from inflating the level of similarity by scaling its input.</p>

    <h2 id="sec-73" class="text-2xl font-bold">6.4.1 Functionality</h2>

    <p class="text-gray-300">Let <span class="math">R</span> hold inputs <span class="math">\\mathbf{x} = (x_{1},\\ldots ,x_{n})</span> and <span class="math">S</span> hold inputs <span class="math">\\mathbf{y} = (y_{1},\\dots ,y_{n})</span> such that <span class="math">y_{i}\\in \\{0,1,\\dots ,K\\}</span> and</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=1}^{n} y_{i}^{2} \\leq L^{2},</span></div>

    <p class="text-gray-300">3In a bit more detail, for a branching program <span class="math">P(x_{1},\\ldots ,x_{n})</span> of size <span class="math">s</span>, the output can be encoded by the <span class="math">n</span> matrices <span class="math">Y_{j} = L\\cdot A_{j}(x_{j})\\cdot R + Z_{j}</span>, where <span class="math">L,R,Z_{j}</span>, and <span class="math">A_{j}(x_{j})</span> are <span class="math">(s - 1)\\times (s - 1)</span> matrices, <span class="math">A_{j}</span> is an affine (degree-1) function of <span class="math">x_{j}</span>, the <span class="math">Z_{j}</span> are random subject to the constraint <span class="math">\\sum Z_{j} = 0</span>, and <span class="math">L,R</span> are random invertible matrices of a special form. The matrix <span class="math">Y_{j}</span> contains <span class="math">\\binom{s}{2}</span> non-constant entries. See [32] for details. The <span class="math">S_{j}</span> entries of VOLE <span class="math">j</span> are the concatenation of the (non-constant entries of) matrices <span class="math">Y_{j}</span> associated with outputs that depend on <span class="math">x_{j}</span>.</p>

    <p class="text-gray-300">29</p>

    <p class="text-gray-300">for some other constant <span class="math">L</span>, so that the <span class="math">\\ell^{2}</span> norm satisfies</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{y}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}\\leq L.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">R</span> desires to compute the dot product <span class="math">\\mathbf{x}\\cdot\\mathbf{y}</span> (as a measure of the similarity of <span class="math">R</span> and <span class="math">S</span>’s inputs). To simplify the protocol, we restrict to the case where <span class="math">K</span> and <span class="math">L</span> are powers of <span class="math">2</span>. When <span class="math">R</span> and <span class="math">S</span> do not wish to impose any bound on individual entries beyond what is implied by the <span class="math">\\ell^{2}</span> norm, they set <span class="math">K=L</span>.</p>

    <p class="text-gray-300">In the above description we assume the inputs to be vectors over non-negative integers. This functionality can be naturally embedded by considering vectors over a finite field <span class="math">\\mathbb{F}</span> of prime order <span class="math">p</span>, provided that <span class="math">p</span> is bigger than the square-norm bound <span class="math">L^{2}</span> and an upper bound on the output size.</p>

    <h4 id="sec-74" class="text-lg font-semibold mt-6">6.4.2 Protocol</h4>

    <p class="text-gray-300"><span class="math">S</span> begins with a sequence of <span class="math">n</span> inputs <span class="math">(y_{i})</span>, and selects associated random masks <span class="math">z_{i}</span>.</p>

    <p class="text-gray-300">First <span class="math">S</span> engages in pre-processing of their data by computing the bit decomposition <span class="math">(c_{ij})</span> of each element <span class="math">y_{i}</span> and the bit decomposition <span class="math">(c_{sj})</span> of the sum of squares <span class="math">\\sigma_{y}:=\\sum y_{i}^{2}</span>. We use <span class="math">\\lg K</span> bits for the bit decompositions <span class="math">(c_{ij})</span> and <span class="math">2\\lg L</span> bits for bit decomposition <span class="math">(c_{sj})</span>, which ensures that <span class="math">\\mathbf{y}</span> satisfies the desired bounds if the bit decompositions are correct.</p>

    <p class="text-gray-300">We give a slightly modified construction of cVOLE, optimized for this setting. <span class="math">R</span> and <span class="math">S</span> generate <span class="math">n+2</span> instances of random VOLE. As in cVOLE, <span class="math">R</span> chooses inputs <span class="math">(x_{1}+\\alpha,\\ldots,x_{n}+\\alpha,\\alpha,\\beta)</span>, with <span class="math">\\alpha,\\beta\\in\\mathbb{F}</span> random and independent. The input of <span class="math">S</span> to the <span class="math">i</span>th instance of VOLE is <span class="math">y_{i}</span>, for <span class="math">1\\leq i\\leq n</span>. Then <span class="math">S</span> uses the entire vector <span class="math">\\mathbf{y}</span> as inputs to the <span class="math">(n+1)</span>st and <span class="math">(n+2)</span>nd instance of VOLE. <span class="math">S</span> also takes as inputs to the <span class="math">(n+2)</span>nd instance all constant terms from the first <span class="math">n</span> VOLEs, the sum of the constant terms from the <span class="math">(n+1)</span>st instance, the squares <span class="math">y_{i}^{2}</span>, and the bit decompositions <span class="math">(c_{ij})</span> and <span class="math">(c_{sj})</span>. After this initial set up, <span class="math">R</span> learns the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">v_{i}^{1}:=y_{i}(x_{i}+\\alpha)+z_{i}</span>, for <span class="math">1\\leq i\\leq n</span>, where <span class="math">z_{i}</span> is a random element determined in the initial random VOLE set up, and thus requires no additional communication.</li>

      <li><span class="math">v_{n+1}^{i}:=y_{i}\\alpha+w_{i}</span>, for <span class="math">1\\leq i\\leq n-1</span>, with <span class="math">w_{i}</span> from the random VOLE.</li>

      <li><span class="math">v_{n+1}^{n}:=y_{n}\\alpha+w_{n}</span>, where <span class="math">w_{n}</span> is chosen such that <span class="math">\\sum_{i=1}^{n}z_{i}=\\sum_{i=1}^{n}w_{i}</span>.</li>

      <li><span class="math">v_{n+2}^{i}:=y_{i}\\beta+u_{i}</span>, for <span class="math">1\\leq i\\leq n</span>, with <span class="math">u_{i}</span> from the random VOLE.</li>

      <li><span class="math">v_{n+2}^{n+i}:=z_{i}\\beta+u_{n+i}</span>, for <span class="math">1\\leq i\\leq n</span>, with <span class="math">u_{i}</span> from the random VOLE.</li>

      <li><span class="math">v_{n+2}^{2n+1}:=(\\sum_{i=1}^{n}w_{i})\\beta+u_{2n+1}</span>, with <span class="math">u_{2n+1}</span> from the random VOLE.</li>

    </ul>

    <p class="text-gray-300">Additionally, <span class="math">\\mathbf{a}_{n+2}</span> holds all of the bit decompositions and associated data mentioned above. To complete the verification step of the protocol, <span class="math">R</span> and <span class="math">S</span> execute eVOLE to ensure that all inputs that occur in multiple VOLE instances are, in fact, equal, and then <span class="math">S</span> uses LPZK-NIZK on the <span class="math">(n+2)</span>nd instance of VOLE to convince <span class="math">R</span> of the validity of <span class="math">S</span>’s input.</p>

    <p class="text-gray-300">The NIZK proof checks that all values <span class="math">y_{i}^{2}</span> sent by <span class="math">S</span> are actually equal to the squares of the values <span class="math">y_{i}</span>, and confirms that <span class="math">c_{ij}</span> and <span class="math">c_{si}</span> are in <span class="math">\\{0,1\\}</span> by evaluating the quadratic <span class="math">t^{2}-t</span> on each entry. The proof then checks that the bit-decompositions are correct by computing and revealing <span class="math">y_{i}-\\sum_{j}c_{ij}2^{j}</span> and <span class="math">\\sum y_{i}^{2}-\\sum_{j}c_{sj}2^{j}</span>, all of which are equal to zero when both parties behave honestly.</p>

    <p class="text-gray-300">Finally, <span class="math">R</span> computes the output value as</p>

    <p class="text-gray-300"><span class="math">\\mathbf{x}\\cdot\\mathbf{y}=\\sum_{i=1}^{n}\\left(v_{i}^{1}-v_{n+1}^{i}\\right).</span></p>

    <p class="text-gray-300">6.4.3 Proof</p>

    <p class="text-gray-300">We have</p>

    <p class="text-gray-300"><span class="math">\\sum_{i=1}^{n}\\left(v_{i}^{1}-v_{n+1}^{i}\\right)=\\sum_{i=1}^{n}y_{i}(x_{i}+\\alpha)-y_{i}\\alpha+z_{i}-w_{i}=\\mathbf{x}\\cdot\\mathbf{y},</span></p>

    <p class="text-gray-300">since <span class="math">\\sum z_{i}=\\sum w_{i}</span>, which shows correctness.</p>

    <p class="text-gray-300">Security against a malicious sender is an immediate consequence of the security of eVOLE and LPZK-NIZK, as in the proof of security of cVOLE.</p>

    <p class="text-gray-300">The argument for security against a malicious receiver follows closely the argument for cVOLE. The simulator Sim can generate each of the elements <span class="math">v_{i}^{j}</span> uniformly at random, due to the randomness of the <span class="math">z_{i}</span>’s, <span class="math">w_{i}</span>’s, and <span class="math">u_{i}</span>’s, except for <span class="math">v_{n+1}^{n}</span>, which the simulator computes via</p>

    <p class="text-gray-300"><span class="math">v_{n+1}^{n}=\\left(\\sum_{i=1}^{n-1}v_{n+1}^{i}-v_{i}^{1}\\right)-v_{n}^{1}-\\mathbf{x}\\cdot\\mathbf{y}.</span></p>

    <h4 id="sec-75" class="text-lg font-semibold mt-6">6.4.4 Complexity</h4>

    <p class="text-gray-300">The protocol requires the <span class="math">4n+1</span> entries of VOLE listed, which in turn require communication of <span class="math">4n+2</span> field elements to convert from random VOLE to fixed VOLE (one per entry, except we need two field elements for <span class="math">\\mathbf{v}_{n+1}^{n}</span>.)</p>

    <p class="text-gray-300">The protocol contains additionally <span class="math">3</span> field elements of communication and <span class="math">2</span> entries of VOLE for each of the <span class="math">3n+1</span> equality constraints implemented under <span class="math">\\mathcal{F}_{eVOLE}^{(\\mathbb{F})}</span>, and a LPZK-NIZK verification of a circuit with <span class="math">2n+n\\lg K+2\\lg(L)</span> inputs and <span class="math">n+n\\lg K+2\\lg(L)</span> multiplication gates.</p>

    <p class="text-gray-300">Combining the results throughout this paper, this gives us a total of</p>

    <p class="text-gray-300"><span class="math">(4n+1)+2(3n+1)+n+n\\lg K+2\\lg(L)=11n+n\\lg K+2\\lg L+3</span></p>

    <p class="text-gray-300">entries of VOLE and communication of</p>

    <p class="text-gray-300"><span class="math">(4n+2)+3(3n+1)</span> <span class="math">+(2+\\tfrac{1}{t})(n+n\\lg K+2\\lg(L))</span> <span class="math">=\\left(15+2\\lg K+\\tfrac{1+\\lg K}{t}\\right)n+\\left(4+\\tfrac{2}{t}\\right)\\lg L+5</span></p>

    <p class="text-gray-300">field elements. Taking <span class="math">K=L=1024</span>, <span class="math">n=1000</span>, and <span class="math">t=11</span> gives total VOLE length <span class="math">21,023</span> and total communication <span class="math">36,047</span> field elements, as stated in the introduction.</p>

    <h4 id="sec-76" class="text-lg font-semibold mt-6">6.4.5 Variations</h4>

    <p class="text-gray-300">We note that we can allow the bounds <span class="math">K</span> and <span class="math">L</span> to hold values other than powers of two by evaluating a boolean comparison circuit on the bit decomposition of the <span class="math">y_{i}</span>’s and the sum <span class="math">y</span>, at the cost of an additional <span class="math">O(n\\lg K)</span> multiplication gates in the LPZK-proof.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Additionally, while the current protocol requires all sender inputs to be positive, we can modify it to allow negative entries by choosing a field <span class="math">\\mathbb{F}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>2L^{2}<span class="math"> and using the entries </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-L^{2},\\ldots,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1<span class="math"> to represent negative integers. Instead of proving the validity of the bit decomposition (</span>c_{ij}<span class="math">) under LPZK-NIZK, </span>S<span class="math"> sends the <em>signed</em> bit decomposition, by sending the bit decomposition of </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> along with an additional sign bit. Then, under LPZK-NIZK, </span>S<span class="math"> proves that </span>y_{i}$ is equal to the sum of the bit decomposition terms times the sign bit.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, we remark that the main way we deviate here from our cVOLE construction is through summing the <span class="math">w_{i}</span> terms on the <span class="math">(n+1)</span>st instance of VOLE and then passing that sum to the <span class="math">(n+2)</span>nd instance, instead of sending each of the <span class="math">w_{i}</span> terms to the <span class="math">(n+2)</span>nd instance of VOLE. This optimization reduces the entries of VOLE needed by <span class="math">(n-1)</span> and communication by <span class="math">4(n-1)</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Acknowledgements</p>

    <p class="text-gray-300">Supported in part by DARPA Contract No. HR001120C0087. Any opinions, findings and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of DARPA. Distribution Statement ”A” (Approved for Public Release, Distribution Unlimited). Y. Ishai supported in part by ERC Project NTSC (742754), NSF-BSF grant 2015782, BSF grant 2018393, and ISF grant 2774/20.</p>

    <h2 id="sec-77" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Arash Afshar, Payman Mohassel, Benny Pinkas, and Ben Riva. Non-interactive secure computation based on cut-and-choose. In EUROCRYPT 2014, pages 387–404, 2014.</li>

      <li>[2] Benny Applebaum, Ivan Damgård, Yuval Ishai, Michael Nielsen, and Lior Zichron. Secure arithmetic computation with constant computational overhead. In CRYPTO 2017, Part I, pages 223–254, 2017.</li>

      <li>[3] Benny Applebaum, Yuval Ishai, and Eyal Kushilevitz. How to garble arithmetic circuits. In FOCS 2011, pages 120–129, 2011.</li>

      <li>[4] Sanjeev Arora, Carsten Lund, Rajeev Motwani, Madhu Sudan, and Mario Szegedy. Proof verification and the hardness of approximation problems. J. ACM, 45(3), 1998.</li>

      <li>[5] Carsten Baum, Daniel Escudero, Alberto Pedrouzo-Ulloa, Peter Scholl, and Juan Ramón Troncoso-Pastoriza. Efficient protocols for oblivious linear function evaluation from Ring-LWE. In SCN 2020, pages 130–149, 2020.</li>

      <li>[6] Carsten Baum, Alex J. Malozemoff, Marc Rosen, and Peter Scholl. Mac’n’cheese: Zero-knowledge proofs for arithmetic circuits with nested disjunctions. Cryptology ePrint Archive, Report 2020/1410, 2020. https://eprint.iacr.org/2020/1410.</li>

      <li>[7] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable zero knowledge with no trusted setup. In CRYPTO 2019, Part III, Lecture Notes in Computer Science, pages 701–732, 2019.</li>

      <li>[8] Rikke Bendlin, Ivan Damgård, Claudio Orlandi, and Sarah Zakarias. Semi-homomorphic encryption and multiparty computation. In EUROCRYPT, 2011.</li>

      <li>[9] Nir Bitansky, Alessandro Chiesa, Yuval Ishai, Rafail Ostrovsky, and Omer Paneth. Succinct non-interactive arguments via linear interactive proofs. In TCC 2013, pages 315–333, 2013.</li>

      <li>[10] Manuel Blum, Paul Feldman, and Silvio Micali. Non-interactive zero-knowledge and its applications (extended abstract). In STOC 1988, pages 103–112, 1988.</li>

      <li>[11] Jonathan Bootle, Andrea Cerulli, Essam Ghadafi, Jens Groth, Mohammad Hajiabadi, and Sune K. Jakobsen. Linear-time zero-knowledge proofs for arithmetic circuit satisfiability. In ASIACRYPT 2017, Part III, pages 336–365, 2017.</li>

      <li>[12] Elette Boyle, Geoffroy Couteau, Niv Gilboa, and Yuval Ishai. Compressing vector OLE. In CCS 2018, pages 896–912, 2018.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[13] Elette Boyle, Geoffroy Couteau, Niv Gilboa, Yuval Ishai, Lisa Kohl, Peter Rindal, and Peter Scholl. Efficient two-round OT extension and silent non-interactive secure computation. In CCS 2019, pages 291–308, 2019.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[14] Elette Boyle, Geoffroy Couteau, Niv Gilboa, Yuval Ishai, Lisa Kohl, and Peter Scholl. Efficient pseudorandom correlation generators: Silent OT extension and more. In CRYPTO 2019, Part III, pages 489–518, 2019.</li>

      <li>[15] Elette Boyle, Geoffroy Couteau, Niv Gilboa, Yuval Ishai, Lisa Kohl, and Peter Scholl. Correlated pseudorandom functions from variable-density LPN. In FOCS 2020, pages 1069–1080, 2020. Full version: https://eprint.iacr.org/2020/1417.</li>

      <li>[16] Elette Boyle, Geoffroy Couteau, Niv Gilboa, Yuval Ishai, Lisa Kohl, and Peter Scholl. Efficient pseudorandom correlation generators from Ring-LPN. In CRYPTO 2020, Part II, pages 387–416, 2020.</li>

      <li>[17] Ran Canetti. Universally composable security: A new paradigm for cryptographic protocols. In FOCS 2001, pages 136–145, 2001.</li>

      <li>[18] Melissa Chase, David Derler, Steven Goldfeder, Claudio Orlandi, Sebastian Ramacher, Christian Rechberger, Daniel Slamanig, and Greg Zaverucha. Post-quantum zero-knowledge and signatures from symmetric-key primitives. In CCS 2017, pages 1825–1842, 2017.</li>

      <li>[19] Melissa Chase, Yevgeniy Dodis, Yuval Ishai, Daniel Kraschewski, Tianren Liu, Rafail Ostrovsky, and Vinod Vaikuntanathan. Reusable non-interactive secure computation. In CRYPTO 2019, Part III, pages 462–488, 2019.</li>

      <li>[20] Ivan Damgård, Yuval Ishai, and Mikkel Krøigaard. Perfectly secure multiparty computation and the computational overhead of cryptography. In EUROCRYPT 2010, pages 445–465, 2010.</li>

      <li>[21] Ivan Damgård, Valerio Pastro, Nigel P. Smart, and Sarah Zakarias. Multiparty computation from somewhat homomorphic encryption. In CRYPTO, 2012.</li>

      <li>[22] Leo de Castro, Chiraag Juvekar, and Vinod Vaikuntanathan. Fast vector oblivious linear evaluation from ring learning with errors. IACR Cryptol. ePrint Arch., 2020:685, 2020. URL: https://eprint.iacr.org/2020/685.</li>

      <li>[23] Sam Dittmer, Yuval Ishai, and Rafail Ostrovsky. Line-point zero knowledge and its applications. In ITC 2021, 2021.</li>

      <li>[24] Tore Kasper Frederiksen, Jesper Buus Nielsen, and Claudio Orlandi. Privacy-free garbled circuits with applications to efficient zero-knowledge. In EUROCRYPT 2015, Part II, pages 191–219, 2015.</li>

      <li>[25] Daniel Genkin, Yuval Ishai, Manoj Prabhakaran, Amit Sahai, and Eran Tromer. Circuits resilient to additive attacks with applications to secure computation. In STOC 2014, pages 495–504, 2014.</li>

      <li>[26] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct nizks without pcps. In EUROCRYPT, 2013.</li>

    </ul>

    <p class="text-gray-300">[27] Irene Giacomelli, Jesper Madsen, and Claudio Orlandi. Zkboo: Faster zero-knowledge for boolean circuits. In USENIX Security 2016), 2016.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[28] Shafi Goldwasser, Yael Tauman Kalai, and Guy N. Rothblum. Delegating computation: Interactive proofs for muggles. J. ACM, 62(4):27:1–27:64, 2015.</li>

      <li>[29] Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of interactive proof systems. SIAM J. Comput., 18(1):186–208, 1989.</li>

      <li>[30] Jens Groth. On the size of pairing-based non-interactive arguments. In Marc Fischlin and Jean-Sébastien Coron, editors, EUROCRYPT 2016, Part II, pages 305–326, 2016.</li>

      <li>[31] David Heath and Vladimir Kolesnikov. Stacked garbling for disjunctive zero-knowledge proofs. In EUROCRYPT 2020, Part III, pages 569–598, 2020.</li>

      <li>[32] Yuval Ishai and Eyal Kushilevitz. Perfect constant-round secure computation via perfect randomizing polynomials. In ICALP 2002, pages 244–256, 2002.</li>

      <li>[33] Yuval Ishai, Eyal Kushilevitz, and Rafail Ostrovsky. Efficient arguments without short PCPs. In CCC, 2007.</li>

      <li>[34] Yuval Ishai, Eyal Kushilevitz, Rafail Ostrovsky, Manoj Prabhakaran, and Amit Sahai. Efficient non-interactive secure computation. In EUROCRYPT 2011, pages 406–425, 2011.</li>

      <li>[35] Yuval Ishai, Eyal Kushilevitz, Rafail Ostrovsky, and Amit Sahai. Zero-knowledge proofs from secure multiparty computation. SIAM J. Comput., 39(3):1121–1152, 2009.</li>

      <li>[36] Yuval Ishai, Manoj Prabhakaran, and Amit Sahai. Secure arithmetic computation with no honest majority. In TCC 2009, pages 294–314, 2009.</li>

      <li>[37] Jonathan Katz, Vladimir Kolesnikov, and Xiao Wang. Improved non-interactive zero knowledge with applications to post-quantum signatures. In CCS 2018, pages 525–537. ACM, 2018.</li>

      <li>[38] Dakshita Khurana, Rafail Ostrovsky, and Akshayaram Srinivasan. Round optimal black-box “commit-and-prove”. In Theory of Cryptography Conference, pages 286–313, 2018.</li>

      <li>[39] Joe Kilian, Silvio Micali, and Rafail Ostrovsky. Minimum resource zero-knowledge proof. In CRYPTO 1989, pages 545–546. Springer, 1989.</li>

      <li>[40] Alex Lombardi, Willy Quach, Ron D. Rothblum, Daniel Wichs, and David J. Wu. New constructions of reusable designated-verifier nizks. In CRYPTO 2019, pages 670–700, 2019.</li>

      <li>[41] Payman Mohassel and Mike Rosulek. Non-interactive secure 2pc in the offline/online and batch settings. In EUROCRYPT 2017, Part III, pages 425–455, 2017.</li>

      <li>[42] Moni Naor and Benny Pinkas. Oblivious polynomial evaluation. SIAM Journal on Computing, 35(5):1254–1281, 2006.</li>

      <li>[43] Willy Quach, Ron D. Rothblum, and Daniel Wichs. Reusable designated-verifier nizks for all NP from CDH. In EUROCRYPT 2019, pages 593–621, 2019.</li>

      <li>[44] Phillipp Schoppmann, Adrià Gascón, Leonie Reichert, and Mariana Raykova. Distributed vector-OLE: Improved constructions and implementation. In CCS 2019, pages 1055–1072, 2019.</li>

    </ul>

    <p class="text-gray-300">[45] Chenkai Weng, Kang Yang, Jonathan Katz, and Xiao Wang. Fast, scalable, and communication-efficient zero-knowledge proofs for boolean and arithmetic circuits. In IEEE Symposium on Security and Privacy (S&P), 2021. Full version: https://eprint.iacr.org/2020/925.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[46] Tiancheng Xie, Jiaheng Zhang, Yupeng Zhang, Charalampos Papamanthou, and Dawn Song. Libra: Succinct zero-knowledge proofs with optimal prover computation. In CRYPTO 2019, Part III, pages 733–764, 2019.</li>

      <li>[47] Kang Yang, Pratik Sarkar, Chenkai Weng, and Xiao Wang. Quicksilver: Efficient and affordable zero-knowledge proofs for circuits and polynomials over any field. In CCS, 2021. Full version: https://eprint.iacr.org/2021/076.</li>

      <li>[48] Jiaheng Zhang, Weijie Wang, Yinuo Zhang, and Yupeng Zhang. Doubly efficient interactive proofs for general arithmetic circuits with linear prover time. Cryptology ePrint Archive, Report 2020/1247, 2020. https://eprint.iacr.org/2020/1247.</li>

      <li>[49] Jiaheng Zhang, Tiancheng Xie, Yupeng Zhang, and Dawn Song. Transparent polynomial delegation and its applications to zero knowledge proof. In 2020 IEEE Symposium on Security and Privacy, pages 859–876, 2020.</li>

      <li>[50] ZKProof. ZKProof Standards, 2020. URL: https://zkproof.org.</li>

    </ul>

    <h2 id="sec-78" class="text-2xl font-bold">Appendix A Concrete computational overhead</h2>

    <p class="text-gray-300">In actual implementations, computation cost is affected by the choice of field size, the computer architecture, and the circuit structure. When considering typical circuits over large finite fields, the ratio between the NIZK online computation cost (given a precomputed random VOLE correlation) and computing the circuit in the clear is typically between 2 and 5 for both the prover and verifier. We describe some possible parameter choices below. We remark, however, that when computation costs are this low, we expect that the overall cost will be typically dominated by online communication and offline computation rather than online computation.</p>

    <p class="text-gray-300">The cost of evaluating a multiplication over <span class="math">\\mathbb{F}</span>, for generic field characteristic, will be dominated by the cost of the modular reduction, which will be far greater than the cost of an addition, and so it is reasonable in this case to treat the cost of additions as negligible.The ratio of NIZK computation cost to plain circuit evaluation now depends on the number of multiplication gates where one multiplicand is a public value. If 70% of the multiplication gates in <span class="math">C</span> satisfy this condition, then, using the more detailed accounting of prover and verifier computation given in § 4.4, we obtain <span class="math">T(C)=\\frac{7}{3}mT(<em>)</span> and cost of evaluation in the clear is <span class="math">\\frac{10}{3}mT(</em>)</span>. This then gives prover work of <span class="math">\\frac{26}{3}mT(<em>)</span> and verifier work of <span class="math">\\frac{22}{3}mT(</em>)</span>, for a prover multiplier of 2.6 and a verifier multiplier of 2.2.</p>

    <p class="text-gray-300">For carefully chosen primes, such as Mersenne primes, modular multiplication can be implemented much more efficiently. Suppose, in this setting, that the cost of a multiplication in the architecture’s instruction set is 6 times the cost of an addition, and suppose the circuit has an equal number of addition, multiplication-by-secret-value, and multiplication-by-public-value gates. Then, using the more detailed accounting of prover and verifier computation given in § 4.4, we obtain <span class="math">T(*)=6T(+)</span>, <span class="math">T(C)=7mT(+)</span>, and cost of evaluation in the clear is <span class="math">13mT(+)</span>. This then gives prover work of <span class="math">44mT(+)</span> and verifier work of <span class="math">39mT(+)</span>, for a prover multiplier of 3.4 and a verifier multiplier of 3.0.</p>

    <p class="text-gray-300">Note that when we compare the computation cost of evaluating a circuit in the clear to the prover or verifier computation cost, we restrict our attention to the case where all parties evaluate an arithmetic circuit over a finite field <span class="math">\\mathbb{F}</span>. In some cases, the circuit could be evaluated more quickly in the clear by treating it as a circuit over <span class="math">\\mathbb{Z}</span>, and therefore avoiding the cost of finite field arithmetic. We leave an empirical cost analysis for realistic use-cases to future implementations.</p>`;
---

<BaseLayout title="Line-Point Zero Knowledge and Its Applications (2020/1446)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/1446
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
