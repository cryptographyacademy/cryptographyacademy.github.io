---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2019/550';
---

<BaseLayout title="Spartan: Efficient and general-purpose zkSNARKs without trusted setup (2019/550)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <!-- ============================================================ -->
    <!-- HEADER                                                       -->
    <!-- ============================================================ -->

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4">
        Spartan: Efficient and General-Purpose zkSNARKs
        without Trusted Setup
      </h1>
      <p class="text-gray-400 mb-2">
        Srinath Setty
      </p>
      <p class="text-gray-500 text-sm mb-4">
        2019 &middot; Microsoft Research &middot; eprint 2019/550
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
    </header>

    <!-- ============================================================ -->
    <!-- TABLE OF CONTENTS                                            -->
    <!-- ============================================================ -->

    <nav id="toc" class="mb-10 p-6 rounded-lg"
      style="background: rgba(255,255,255,0.03);
             border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li>
          <a href="#abstract"
            class="hover:text-white">Abstract</a>
        </li>
        <li>
          <a href="#sec-1"
            class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-1.1"
                class="hover:text-white">
                Summary of Contributions</a>
            </li>
            <li>
              <a href="#sec-1.2"
                class="hover:text-white">
                Additional Related Work</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-2"
            class="hover:text-white">Preliminaries</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-2.1"
                class="hover:text-white">
                Problem Instances in R1CS</a>
            </li>
            <li>
              <a href="#sec-2.2"
                class="hover:text-white">
                Succinct Interactive Arguments of Knowledge</a>
            </li>
            <li>
              <a href="#sec-2.3"
                class="hover:text-white">
                Polynomials and Low-Degree Extensions</a>
            </li>
            <li>
              <a href="#sec-2.4"
                class="hover:text-white">
                A Polynomial Commitment Scheme for
                Multilinear Polynomials</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-3"
            class="hover:text-white">
            The Sum-Check Protocol: Opportunities and
            Challenges</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-3.1"
                class="hover:text-white">
                Challenges with Using the Sum-Check Protocol</a>
            </li>
            <li>
              <a href="#sec-3.2"
                class="hover:text-white">
                Prior Solutions (Spartan&rsquo;s Closely
                Related Works)</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-4"
            class="hover:text-white">
            An Encoding of R1CS Instances as Low-Degree
            Polynomials</a>
        </li>
        <li>
          <a href="#sec-5"
            class="hover:text-white">
            A Family of NIZKs with Succinct Proofs for R1CS</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-5.1"
                class="hover:text-white">
                A New Public-Coin Succinct Interactive Argument
                of Knowledge</a>
            </li>
            <li>
              <a href="#sec-5.2"
                class="hover:text-white">
                A Family of NIZKs with Succinct Proofs for
                R1CS</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-6"
            class="hover:text-white">
            Computation Commitments: zkSNARKs for R1CS from
            NIZK</a>
        </li>
        <li>
          <a href="#sec-7"
            class="hover:text-white">The SPARK Compiler</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-7.1"
                class="hover:text-white">
                SPARK-naive: A Straw-Man Solution</a>
            </li>
            <li>
              <a href="#sec-7.2"
                class="hover:text-white">
                Eliminating Asymptotic Overheads by Leveraging
                Memory Checking</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-8"
            class="hover:text-white">
            Implementation and Optimizations</a>
        </li>
        <li>
          <a href="#sec-9"
            class="hover:text-white">
            Experimental Evaluation</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-9.1"
                class="hover:text-white">
                Metrics, Methodology, and Testbed</a>
            </li>
            <li>
              <a href="#sec-9.2"
                class="hover:text-white">
                Performance Results</a>
            </li>
          </ol>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400 list-disc
        list-inside">
        <li>
          <a href="#acknowledgements"
            class="hover:text-white">Acknowledgements</a>
        </li>
        <li>
          <a href="#appendix-a"
            class="hover:text-white">
            Appendix A: Proof of Witness-Extended Emulation</a>
        </li>
        <li>
          <a href="#references"
            class="hover:text-white">References</a>
        </li>
      </ul>
    </nav>

    <!-- ============================================================ -->
    <!-- ABSTRACT                                                     -->
    <!-- ============================================================ -->

    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">
        This paper introduces Spartan, a new family of zero-knowledge
        succinct non-interactive arguments of knowledge (zkSNARKs) for
        the rank-1 constraint satisfiability (R1CS), an NP-complete
        language that generalizes arithmetic circuit satisfiability.
        A distinctive feature of Spartan is that it offers the first
        zkSNARKs without trusted setup (i.e., transparent zkSNARKs)
        for NP where verifying a proof incurs sub-linear
        costs&mdash;without requiring uniformity in the NP
        statement&rsquo;s structure. Furthermore, Spartan offers
        zkSNARKs with a time-optimal prover, a property that has
        remained elusive for nearly all zkSNARKs in the literature.
      </p>
      <p class="text-gray-300">
        To achieve these results, we introduce new techniques that we
        compose with the sum-check protocol, a seminal interactive
        proof protocol: (1) <em>computation commitments</em>, a
        primitive to create a succinct commitment to a description
        of a computation; this technique is crucial for a verifier to
        achieve sub-linear costs after investing a one-time, public
        computation to preprocess a given NP statement;
        (2) SPARK, a cryptographic compiler to transform any existing
        extractable polynomial commitment scheme for multilinear
        polynomials to one that efficiently handles <em>sparse</em>
        multilinear polynomials; this technique is critical for
        achieving a time-optimal prover; and (3) a compact encoding
        of an R1CS instance as a low-degree polynomial. The end result
        is a public-coin succinct interactive argument of knowledge
        for NP (which can be viewed as <em>a succinct variant of the
        sum-check protocol</em>); we transform it into a zkSNARK
        using prior techniques. By applying SPARK to different
        commitment schemes, we obtain several zkSNARKs where the
        verifier&rsquo;s costs and the proof size range from
        <span class="math">O(\log^2 n)</span> to
        <span class="math">O(\sqrt&#123;n&#125;)</span> depending on
        the underlying commitment scheme
        (<span class="math">n</span> denotes the size of the NP
        statement). These schemes do not require a trusted setup
        except for one that requires a universal trusted setup.
      </p>
      <p class="text-gray-300">
        We implement Spartan as a library in about 8,000 lines of
        Rust. We use the library to build a transparent zkSNARK in
        the random oracle model where security holds under the
        discrete logarithm assumption. We experimentally evaluate it
        and compare with state-of-the-art zkSNARKs for R1CS instance
        sizes up to
        <span class="math">2^&#123;20&#125;</span> constraints.
        Among transparent zkSNARKs, Spartan offers the fastest prover
        with speedups of
        <span class="math">36</span>&ndash;<span class="math">152
        \times</span> depending on the baseline, produces proofs that
        are shorter by
        <span class="math">1.2</span>&ndash;<span class="math">416
        \times</span>, and incurs the lowest verification times with
        speedups of
        <span class="math">3.6</span>&ndash;<span class="math">1326
        \times</span>. The only exception is proof sizes under
        Bulletproofs, but Bulletproofs incurs slower verification
        both asymptotically and concretely. When compared to the
        state-of-the-art zkSNARKs with trusted setup,
        Spartan&rsquo;s prover is
        <span class="math">2\times</span> faster for arbitrary
        R1CS instances and
        <span class="math">16\times</span> faster for data-parallel
        workloads.
      </p>
      <p class="text-gray-300">
        <strong>Keywords:</strong> zkSNARKs, transparent arguments,
        sum-check protocol, R1CS, polynomial commitments
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 1. INTRODUCTION                                              -->
    <!-- ============================================================ -->

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1. Introduction</h2>
      <p class="text-gray-300">
        We revisit the problem of designing zero-knowledge succinct
        non-interactive arguments of knowledge (zkSNARKs) for the
        complexity class NP: they enable a computationally-bounded
        prover to convince the membership of a problem instance in an
        NP language by producing a proof&mdash;without revealing
        anything besides the validity of the statement. Furthermore,
        the proof size and the verifier&rsquo;s costs are sub-linear
        in the size of the statement. We are motivated to design
        zkSNARKs because they enable many applications that involve
        various forms of delegation of computation for scalability or
        privacy.
      </p>
      <p class="text-gray-300">
        Specifically, we are interested in zkSNARKs that prove the
        satisfiability of R1CS instances over a finite field
        <span class="math">\mathbb&#123;F&#125;</span> (an
        NP-complete language that generalizes arithmetic circuit
        satisfiability): given a problem instance
        <span class="math">\mathbb&#123;X&#125; = (\mathbb&#123;F&#125;, A, B, C, io, m, n)</span>,
        we desire a proof that demonstrates the knowledge of a
        witness <span class="math">w</span> such that
        <span class="math">\mathtt&#123;Sat&#125;_&#123;R1CS&#125;(\mathbb&#123;X&#125;, w) = 1</span>.
        We desire zkSNARKs for R1CS because there exist efficient
        toolchains to transform high-level applications of interest
        to R1CS.
      </p>
      <p class="text-gray-300">
        There are many approaches to construct such arguments in the
        literature, starting with the work of Kilian who provided the
        first construction of a succinct interactive argument protocol
        by employing probabilistically checkable proofs (PCPs) in
        conjunction with Merkle trees. Micali made a similar protocol
        non-interactive in the random oracle model, thereby obtaining
        the first zkSNARK. Unfortunately, the underlying PCP
        machinery remains extremely expensive for the prover and the
        verifier&mdash;despite foundational advances.
      </p>
      <p class="text-gray-300">
        The paper discusses how GGPR addressed prover asymptotics with
        quadratic arithmetic programs (QAPs), achieving
        <span class="math">O(n \log n)</span> prover cost,
        <span class="math">O(1)</span> proof size, and
        <span class="math">O(|io|)</span> verification&mdash;but
        requiring a per-statement trusted setup. This motivated
        <em>transparent</em> zkSNARKs including Hyrax, STARK, Aurora,
        Ligero, and Bulletproofs, each facing limitations: Hyrax is
        restricted to low-depth uniform circuits; STARK requires
        uniform circuits; and Ligero, Bulletproofs, and Aurora incur
        <span class="math">O(n)</span> verification costs.
      </p>

      <h3 id="sec-1.1" class="text-xl font-semibold mt-8 mb-3">
        1.1 Summary of Contributions
      </h3>
      <p class="text-gray-300">
        This paper presents a new family of zkSNARKs, which we call
        <em>Spartan</em>, for proving the satisfiability of NP
        statements expressed in R1CS. Spartan offers the first
        transparent zkSNARK that achieves sub-linear verification
        costs for arbitrary NP statements. Spartan also offers
        zkSNARKs with a time-optimal prover.
      </p>
      <p class="text-gray-300">
        Spartan introduces three key techniques:
        (i) <em>computation commitments</em>, a primitive for creating
        succinct cryptographic commitments to a mathematical
        description of an NP statement, critical for achieving
        sub-linear verification costs;
        (ii) <em>SPARK</em>, a cryptographic compiler to transform any
        existing extractable polynomial commitment scheme for
        multilinear polynomials to one that efficiently handles sparse
        multilinear polynomials, critical for achieving a time-optimal
        prover; and
        (iii) a compact encoding of an R1CS instance as a degree-3
        multivariate polynomial that decomposes into four multilinear
        polynomials.
      </p>

      <div class="formal-block formal-block-theorem">
        <div class="formal-block-title text-green-400">
          Theorem 1.1 (Informal)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            There exists a family of public-coin succinct interactive
            arguments of knowledge for NP under standard cryptographic
            hardness assumptions where the prover incurs
            <span class="math">O(n)</span> to
            <span class="math">O(n \log n)</span> costs, and the
            verifier&rsquo;s costs and communication range from
            <span class="math">O(\log^2 n)</span> to
            <span class="math">O(\sqrt&#123;n&#125;)</span>
            (depending on the underlying extractable polynomial
            commitment scheme for multilinear polynomials), where
            <span class="math">n</span> is size of the NP statement.
          </p>
        </div>
      </div>

      <div class="formal-block formal-block-theorem">
        <div class="formal-block-title text-green-400">
          Corollary 1.1
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            There exists a family of zkSNARKs for NP in the random
            oracle model where the prover incurs
            <span class="math">O(n)</span> to
            <span class="math">O(n \log n)</span> costs, and the
            verifier&rsquo;s costs and proof sizes range from
            <span class="math">O(\log^2 n)</span> to
            <span class="math">O(\sqrt&#123;n&#125;)</span>
            (depending on the underlying polynomial commitment scheme
            for multilinear polynomials), where
            <span class="math">n</span> denotes the size of the NP
            statement.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        The paper also contributes: (2) an optimized implementation
        and experimental evaluation in about 8,000 lines of Rust;
        (3) a unified understanding of different strands of theory
        on probabilistic proofs; and (4) improvements in zkSNARKs
        with universal setup via
        Spartan<span class="math">_&#123;\text&#123;KE&#125;&#125;</span>,
        which supports arbitrary R1CS instances instead of layered
        arithmetic circuits.
      </p>

      <h3 id="sec-1.2" class="text-xl font-semibold mt-8 mb-3">
        1.2 Additional Related Work
      </h3>
      <p class="text-gray-300">
        Following the Spartan preprint, three transparent zkSNARKs
        appeared: Fractal, SuperSonic, and Virgo. Fractal and
        SuperSonic achieve sub-linear verification costs for arbitrary
        NP statements by instantiating computation commitments, but
        both incur orders of magnitude higher expense than Spartan.
        Virgo is specialized to layered uniform circuits.
      </p>
      <p class="text-gray-300">
        The paper reviews linear PCPs and QAPs (IKO, GGPR, Pinocchio,
        Zaatar, BCGTV, BCTV, Groth16), interactive proofs (GKR, CMT,
        Hyrax, Libra, Virgo), and how Spartan relates to each line of
        work. Spartan can be viewed as an efficient mechanism to
        compile two-prover protocols into a public-coin succinct
        interactive argument of knowledge without employing FHE or
        low-degree tests.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 2. PRELIMINARIES                                             -->
    <!-- ============================================================ -->

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2. Preliminaries</h2>
      <p class="text-gray-300">
        We use <span class="math">\mathbb&#123;F&#125;</span> to
        denote a finite field (e.g., the prime field
        <span class="math">\mathbb&#123;F&#125;_p</span> for a large
        prime <span class="math">p</span>) and
        <span class="math">\lambda</span> to denote the security
        parameter. We use
        <span class="math">\mathsf&#123;negl&#125;(\lambda)</span>
        to denote a negligible function in
        <span class="math">\lambda</span>.
      </p>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8 mb-3">
        2.1 Problem Instances in R1CS
      </h3>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 2.1 (R1CS Instance)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            An R1CS instance is a tuple
            <span class="math">(\mathbb&#123;F&#125;, A, B, C, io, m, n)</span>,
            where <span class="math">io</span> denotes the public
            input and output of the instance,
            <span class="math">A, B, C \in \mathbb&#123;F&#125;^&#123;m \times m&#125;</span>,
            where
            <span class="math">m \geq |io| + 1</span> and there are
            at most <span class="math">n</span> non-zero entries in
            each matrix.
          </p>
        </div>
      </div>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 2.2 (R1CS Satisfiability)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            An R1CS instance
            <span class="math">(\mathbb&#123;F&#125;, A, B, C, io, m, n)</span>
            is said to be <em>satisfiable</em> if there exists a
            witness
            <span class="math">w \in \mathbb&#123;F&#125;^&#123;m - |io| - 1&#125;</span>
            such that
            <span class="math">(A \cdot z) \circ (B \cdot z) = (C \cdot z)</span>,
            where
            <span class="math">z = (io, 1, w)</span>,
            <span class="math">\cdot</span> is the matrix-vector
            product, and <span class="math">\circ</span> is the
            Hadamard (entry-wise) product.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        R1CS generalizes arithmetic circuit satisfiability because the
        entries in matrices
        <span class="math">A, B, C</span> can encode addition and
        multiplication gates over
        <span class="math">\mathbb&#123;F&#125;</span>. Furthermore,
        they can encode a class of degree-2 constraints of the form
        <span class="math">L(z) \cdot R(z) = O(z)</span>, where
        <span class="math">L, R, O</span> are degree-1 polynomials.
      </p>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 2.3
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            For an R1CS instance
            <span class="math">\mathbf&#123;x&#125; = (\mathbb&#123;F&#125;, A, B, C, io, m, n)</span>
            and a purported witness
            <span class="math">w \in \mathbb&#123;F&#125;^&#123;m - |io| - 1&#125;</span>,
            we define:
          </p>
          <div class="math-block">
            \mathtt&#123;Sat&#125;_&#123;\text&#123;R1CS&#125;&#125;(\mathbf&#123;x&#125;, w) = \begin&#123;cases&#125; 1 &amp; \text&#123;if &#125; (A \cdot (io, 1, w)) \circ (B \cdot (io, 1, w)) = C \cdot (io, 1, w) \\ 0 &amp; \text&#123;otherwise&#125; \end&#123;cases&#125;
          </div>
        </div>
      </div>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 2.4
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            For a given R1CS instance
            <span class="math">\mathbf&#123;x&#125; = (\mathbb&#123;F&#125;, A, B, C, io, m, n)</span>,
            the NP statement that
            <span class="math">\mathbf&#123;x&#125;</span> is
            satisfiable is of size
            <span class="math">O(n)</span>.
          </p>
        </div>
      </div>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8 mb-3">
        2.2 Succinct Interactive Arguments of Knowledge
      </h3>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 2.5
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            A protocol between a pair of PPT algorithms
            <span class="math">\langle \mathcal&#123;P&#125;, \mathcal&#123;V&#125; \rangle</span>
            is called a public-coin succinct interactive argument of
            knowledge for a language
            <span class="math">\mathcal&#123;L&#125;</span> if it
            satisfies:
          </p>
          <ul class="list-disc list-inside text-gray-300 mt-2
            space-y-1">
            <li>
              <strong>Completeness.</strong> For any problem instance
              <span class="math">\mathbf&#123;x&#125; \in \mathcal&#123;L&#125;</span>,
              there exists a witness
              <span class="math">w</span> such that
              <span class="math">\Pr\&#123;\langle \mathcal&#123;P&#125;(pp, w), \mathcal&#123;V&#125;(pp, r) \rangle(\mathbf&#123;x&#125;) = 1\&#125; \geq 1 - \mathsf&#123;negl&#125;(\lambda)</span>.
            </li>
            <li>
              <strong>Soundness.</strong> For any non-satisfiable
              instance and any PPT prover
              <span class="math">\mathcal&#123;P&#125;^*</span>,
              the probability of acceptance is
              <span class="math">\leq \mathsf&#123;negl&#125;(\lambda)</span>.
            </li>
            <li>
              <strong>Knowledge soundness.</strong> For any PPT
              adversary, there exists a PPT extractor that outputs a
              valid witness with overwhelming probability.
            </li>
            <li>
              <strong>Succinctness.</strong> The total communication
              is sub-linear in the size of the NP statement.
            </li>
            <li>
              <strong>Public coin.</strong>
              <span class="math">\mathcal&#123;V&#125;</span>&rsquo;s
              messages are chosen uniformly at random.
            </li>
          </ul>
        </div>
      </div>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 2.6 (Witness-Extended Emulation)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            An interactive argument
            <span class="math">(\text&#123;Setup&#125;, \mathcal&#123;P&#125;, \mathcal&#123;V&#125;)</span>
            for
            <span class="math">\mathcal&#123;L&#125;</span> has
            witness-extended emulation if for all deterministic
            polynomial time programs
            <span class="math">\mathcal&#123;P&#125;^*</span> there
            exists an expected polynomial time emulator
            <span class="math">E</span> such that for all non-uniform
            polynomial time adversaries, the real transcript
            distribution and the emulated transcript distribution
            (which additionally extracts a valid witness whenever the
            transcript is accepting) are computationally
            indistinguishable.
          </p>
        </div>
      </div>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 2.7 (Computational Zero-Knowledge)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            An interactive argument
            <span class="math">(\text&#123;Setup&#125;, \mathcal&#123;P&#125;, \mathcal&#123;V&#125;)</span>
            for
            <span class="math">\mathcal&#123;L&#125;</span> is
            computational zero-knowledge if for every PPT interactive
            machine
            <span class="math">\mathcal&#123;V&#125;^*</span>, there
            exists a PPT simulator
            <span class="math">S</span> such that:
          </p>
          <div class="math-block">
            \text&#123;View&#125;(\langle \mathcal&#123;P&#125;(w), \mathcal&#123;V&#125;^*(z) \rangle(\mathbf&#123;x&#125;)) \approx_c S(\mathbf&#123;x&#125;, z)
          </div>
        </div>
      </div>

      <h3 id="sec-2.3" class="text-xl font-semibold mt-8 mb-3">
        2.3 Polynomials and Low-Degree Extensions
      </h3>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 2.8 (Multilinear Polynomial)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            A multivariate polynomial is called a multilinear
            polynomial if the degree of the polynomial in each
            variable is at most one.
          </p>
        </div>
      </div>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 2.9 (Low-Degree Polynomial)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            A multivariate polynomial
            <span class="math">\mathcal&#123;G&#125;</span> over a
            finite field
            <span class="math">\mathbb&#123;F&#125;</span> is called
            a low-degree polynomial if the degree of
            <span class="math">\mathcal&#123;G&#125;</span> in each
            variable is exponentially smaller than
            <span class="math">|\mathbb&#123;F&#125;|</span>.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        <strong>Low-degree extensions (LDEs).</strong> Given a
        function
        <span class="math">g : \&#123;0,1\&#125;^m \to \mathbb&#123;F&#125;</span>,
        a multilinear extension (MLE) is the unique multilinear
        polynomial
        <span class="math">\widetilde&#123;g&#125; : \mathbb&#123;F&#125;^m \to \mathbb&#123;F&#125;</span>
        such that
        <span class="math">\widetilde&#123;g&#125;(x) = g(x)</span>
        for all
        <span class="math">x \in \&#123;0,1\&#125;^m</span>. Given
        <span class="math">Z: \&#123;0,1\&#125;^m \to \mathbb&#123;F&#125;</span>,
        the MLE is computed as:
      </p>
      <div class="math-block">
        \widetilde&#123;Z&#125;(x_1, \dots, x_m) = \sum_&#123;e \in \&#123;0,1\&#125;^m&#125; Z(e) \cdot \prod_&#123;i=1&#125;^m (x_i \cdot e_i + (1 - x_i) \cdot (1 - e_i))
      </div>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 2.10 (Sparse Multilinear Polynomial)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            A multilinear polynomial
            <span class="math">\mathcal&#123;G&#125;: \mathbb&#123;F&#125;^m \to \mathbb&#123;F&#125;</span>
            is a sparse multilinear polynomial if
            <span class="math">|\mathtt&#123;DenseRepr&#125;(\mathcal&#123;G&#125;)|</span>
            is sub-linear in
            <span class="math">O(2^m)</span>. Otherwise, it is a
            dense multilinear polynomial.
          </p>
        </div>
      </div>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">
          Lemma 2.1
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            If for any
            <span class="math">x \in \&#123;0,1\&#125;^m</span>,
            <span class="math">\mathcal&#123;G&#125;(x) = 0</span>,
            then
            <span class="math">\mathsf&#123;DenseRepr&#125;(\mathcal&#123;G&#125;)</span>
            does not have to include an entry for
            <span class="math">x</span>.
          </p>
        </div>
      </div>

      <h3 id="sec-2.4" class="text-xl font-semibold mt-8 mb-3">
        2.4 A Polynomial Commitment Scheme for Multilinear
        Polynomials
      </h3>
      <p class="text-gray-300">
        A polynomial commitment scheme for multilinear polynomials is
        a tuple of four protocols
        <span class="math">\text&#123;PC&#125; = (\text&#123;Setup&#125;, \text&#123;Commit&#125;, \text&#123;Open&#125;, \text&#123;Eval&#125;)</span>.
      </p>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 2.11 (Extractable PC for Multilinear Polynomials)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            A tuple
            <span class="math">(\text&#123;Setup&#125;, \text&#123;Commit&#125;, \text&#123;Open&#125;, \text&#123;Eval&#125;)</span>
            is an extractable polynomial commitment scheme for
            multilinear polynomials over
            <span class="math">\mathbb&#123;F&#125;</span> if it
            satisfies completeness, binding, and knowledge
            soundness (where Eval has witness-extended emulation
            for the relation
            <span class="math">\mathcal&#123;R&#125;_&#123;\text&#123;Eval&#125;&#125;(pp) = \&#123; \langle (\mathcal&#123;C&#125;, r, v), (\mathcal&#123;G&#125;, \mathcal&#123;S&#125;) \rangle : \mathcal&#123;G&#125; \in \mathbb&#123;F&#125;[\mu] \land \mathcal&#123;G&#125;(r) = v \land \text&#123;Open&#125;(pp, \mathcal&#123;C&#125;, \mathcal&#123;G&#125;, \mathcal&#123;S&#125;) = 1 \&#125;</span>).
          </p>
        </div>
      </div>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 2.12 (Hiding Commitments)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            An extractable polynomial commitment scheme provides
            hiding commitments if for all PPT adversaries, the
            advantage in distinguishing commitments to two different
            polynomials is negligible.
          </p>
        </div>
      </div>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 2.13 (Zero-Knowledge PC)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            An extractable polynomial commitment scheme with hiding
            commitments is zero-knowledge if Eval is a public-coin
            succinct interactive argument of knowledge with
            witness-extended emulation and zero-knowledge.
          </p>
        </div>
      </div>
    </section>

    <!-- ============================================================ -->
    <!-- 3. THE SUM-CHECK PROTOCOL                                    -->
    <!-- ============================================================ -->

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">
        3. The Sum-Check Protocol: Opportunities and Challenges
      </h2>
      <p class="text-gray-300">
        The sum-check protocol is a seminal interactive proof protocol.
        Suppose there is a
        <span class="math">\mu</span>-variate low-degree polynomial
        <span class="math">\mathcal&#123;G&#125;: \mathbb&#123;F&#125;^\mu \to \mathbb&#123;F&#125;</span>
        where the degree of each variable is at most
        <span class="math">\ell</span>. A verifier
        <span class="math">\mathcal&#123;V&#125;_&#123;SC&#125;</span>
        checks if the following claim by an untrusted prover holds:
      </p>
      <div class="math-block">
        T = \sum_&#123;x_1 \in \&#123;0,1\&#125;&#125; \sum_&#123;x_2 \in \&#123;0,1\&#125;&#125; \cdots \sum_&#123;x_\mu \in \&#123;0,1\&#125;&#125; \mathcal&#123;G&#125;(x_1, x_2, \dots, x_\mu)
      </div>
      <p class="text-gray-300">
        The protocol proceeds over
        <span class="math">\mu</span> rounds. At the end,
        <span class="math">\mathcal&#123;V&#125;_&#123;SC&#125;</span>
        must evaluate
        <span class="math">\mathcal&#123;G&#125;</span> at a random
        point
        <span class="math">r \in \mathbb&#123;F&#125;^\mu</span>.
        The properties are: completeness (with probability 1),
        soundness (error at most
        <span class="math">\ell \cdot \mu / |\mathbb&#123;F&#125;|</span>),
        and succinctness (communication
        <span class="math">O(\mu \cdot \ell)</span> elements of
        <span class="math">\mathbb&#123;F&#125;</span>).
      </p>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8 mb-3">
        3.1 Challenges with Using the Sum-Check Protocol for
        Succinct Arguments
      </h3>
      <p class="text-gray-300">
        To build a succinct interactive argument of knowledge for
        R1CS, three sub-problems must be solved:
      </p>
      <ol class="list-decimal list-inside text-gray-300 space-y-2
        mt-2">
        <li>
          <strong>Encode R1CS instances as sum-check instances.</strong>
          Devise a degree-<span class="math">\ell</span>,
          <span class="math">\mu</span>-variate polynomial that sums
          to a specific value over the Boolean hypercube if and only
          if the R1CS instance is satisfiable.
        </li>
        <li>
          <strong>Achieve communication-succinctness.</strong>
          After the sum-check reduction, the verifier must evaluate
          <span class="math">\mathcal&#123;G&#125;(r)</span>, which
          depends on the prover&rsquo;s witness, so naive evaluation
          requires <span class="math">O(m)</span> communication.
        </li>
        <li>
          <strong>Achieve verifier-succinctness.</strong>
          Evaluating <span class="math">\mathcal&#123;G&#125;(r)</span>
          requires <span class="math">O(n)</span> computation if the
          statement has no structure, motivating preprocessing.
        </li>
      </ol>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8 mb-3">
        3.2 Prior Solutions (Spartan&rsquo;s Closely Related Works)
      </h3>
      <p class="text-gray-300">
        Prior literature offers solutions via multi-prover interactive
        proofs (MIPs), short PCPs, and doubly-efficient interactive
        proofs. The paper discusses how Blumberg et al. use two
        non-colluding provers; how Babai et al. devise short PCPs;
        and how GKR-based doubly-efficient IPs solve all three
        sub-problems but restrict to layered circuits. Spartan can be
        viewed as an efficient mechanism to compile such protocols
        into a single-prover succinct argument without FHE or
        low-degree tests.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 4. ENCODING R1CS AS LOW-DEGREE POLYNOMIALS                   -->
    <!-- ============================================================ -->

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">
        4. An Encoding of R1CS Instances as Low-Degree Polynomials
      </h2>

      <div class="formal-block formal-block-theorem">
        <div class="formal-block-title text-green-400">
          Theorem 4.1
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            For any R1CS instance
            <span class="math">\mathbf&#123;x&#125; = (\mathbb&#123;F&#125;, A, B, C, io, m, n)</span>,
            there exists a degree-3
            <span class="math">\log m</span>-variate polynomial
            <span class="math">\mathcal&#123;G&#125;</span> such that
            <span class="math">\sum_&#123;x \in \&#123;0,1\&#125;^&#123;\log m&#125;&#125; \mathcal&#123;G&#125;(x) = 0</span>
            if and only if there exists a witness
            <span class="math">w</span> such that
            <span class="math">\mathtt&#123;Sat&#125;_&#123;\text&#123;R1CS&#125;&#125;(\mathbf&#123;x&#125;, w) = 1</span>
            (except for a soundness error that is negligible in
            <span class="math">\lambda</span>) under the assumption
            that
            <span class="math">|\mathbb&#123;F&#125;|</span> is
            exponential in <span class="math">\lambda</span> and
            <span class="math">m = O(\lambda)</span>.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        Let <span class="math">s = \lceil \log m \rceil</span>. View
        matrices <span class="math">A, B, C</span> as functions
        <span class="math">\&#123;0,1\&#125;^s \times \&#123;0,1\&#125;^s \to \mathbb&#123;F&#125;</span>.
        Given a purported witness <span class="math">w</span>, let
        <span class="math">Z = (io, 1, w)</span>. Define:
      </p>
      <div class="math-block">
        F_&#123;io&#125;(x) = \left(\sum_&#123;y \in \&#123;0,1\&#125;^s&#125; A(x, y) \cdot Z(y)\right) \cdot \left(\sum_&#123;y \in \&#123;0,1\&#125;^s&#125; B(x, y) \cdot Z(y)\right) - \sum_&#123;y \in \&#123;0,1\&#125;^s&#125; C(x, y) \cdot Z(y)
      </div>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">
          Lemma 4.1
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            <span class="math">\forall x \in \&#123;0,1\&#125;^s</span>,
            <span class="math">F_&#123;io&#125;(x) = 0</span> if and
            only if
            <span class="math">\mathtt&#123;Sat&#125;_&#123;\text&#123;R1CS&#125;&#125;(\mathbf&#123;x&#125;, w) = 1</span>.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        The polynomial extension
        <span class="math">\widetilde&#123;F&#125;_&#123;io&#125;</span>
        is defined using MLEs of
        <span class="math">A, B, C, Z</span>:
      </p>
      <div class="math-block">
        \widetilde&#123;F&#125;_&#123;io&#125;(x) = \left(\sum_&#123;y \in \&#123;0,1\&#125;^s&#125; \widetilde&#123;A&#125;(x, y) \cdot \widetilde&#123;Z&#125;(y)\right) \cdot \left(\sum_&#123;y \in \&#123;0,1\&#125;^s&#125; \widetilde&#123;B&#125;(x, y) \cdot \widetilde&#123;Z&#125;(y)\right) - \sum_&#123;y \in \&#123;0,1\&#125;^s&#125; \widetilde&#123;C&#125;(x, y) \cdot \widetilde&#123;Z&#125;(y)
      </div>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">
          Lemma 4.2
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            <span class="math">\forall x \in \&#123;0,1\&#125;^s</span>,
            <span class="math">\widetilde&#123;F&#125;_&#123;io&#125;(x) = 0</span>
            if and only if
            <span class="math">\mathtt&#123;Sat&#125;_&#123;\text&#123;R1CS&#125;&#125;(\mathbf&#123;x&#125;, w) = 1</span>.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        To ensure that all terms are individually zero (not just the
        sum), define:
      </p>
      <div class="math-block">
        Q_&#123;io&#125;(t) = \sum_&#123;x \in \&#123;0,1\&#125;^s&#125; \widetilde&#123;F&#125;_&#123;io&#125;(x) \cdot \widetilde&#123;\text&#123;eq&#125;&#125;(t, x)
      </div>
      <p class="text-gray-300">
        where
        <span class="math">\widetilde&#123;\text&#123;eq&#125;&#125;(t, x) = \prod_&#123;i=1&#125;^s (t_i \cdot x_i + (1 - t_i)(1 - x_i))</span>.
        Then <span class="math">Q_&#123;io&#125;(\cdot)</span> is a
        zero-polynomial if and only if
        <span class="math">\widetilde&#123;F&#125;_&#123;io&#125;</span>
        evaluates to zero at all Boolean points.
      </p>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">
          Lemma 4.3
        </div>
        <div class="formal-block-content">
          <div class="math-block">
            \Pr_\tau\&#123;Q_&#123;io&#125;(\tau) = 0 \mid \exists x \in \&#123;0,1\&#125;^s \text&#123; s.t. &#125; \widetilde&#123;F&#125;_&#123;io&#125;(x) \neq 0\&#125; \leq \frac&#123;\log m&#125;&#123;|\mathbb&#123;F&#125;|&#125;
          </div>
        </div>
      </div>

      <p class="text-gray-300">
        <em>Proof of Theorem 4.1.</em> Define
        <span class="math">\mathcal&#123;G&#125;_&#123;io,\tau&#125;(x) = \widetilde&#123;F&#125;_&#123;io&#125;(x) \cdot \widetilde&#123;\text&#123;eq&#125;&#125;(\tau, x)</span>,
        so
        <span class="math">Q_&#123;io&#125;(\tau) = \sum_&#123;x \in \&#123;0,1\&#125;^s&#125; \mathcal&#123;G&#125;_&#123;io,\tau&#125;(x)</span>.
        This polynomial is degree-3 in
        <span class="math">s = \log m</span> variables. With
        <span class="math">\tau \in_R \mathbb&#123;F&#125;^s</span>,
        the sum equals zero if and only if
        <span class="math">\widetilde&#123;F&#125;_&#123;io&#125;(x) = 0</span>
        for all
        <span class="math">x \in \&#123;0,1\&#125;^s</span>,
        except for negligible soundness error (by Lemmas 4.2 and 4.3).
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 5. A FAMILY OF NIZKs                                         -->
    <!-- ============================================================ -->

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">
        5. A Family of NIZKs with Succinct Proofs for R1CS
      </h2>

      <h3 id="sec-5.1" class="text-xl font-semibold mt-8 mb-3">
        5.1 A New Public-Coin Succinct Interactive Argument of
        Knowledge
      </h3>

      <div class="formal-block formal-block-theorem">
        <div class="formal-block-title text-green-400">
          Theorem 5.1
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Given an extractable polynomial commitment scheme for
            multilinear polynomials, there exists a public-coin
            succinct interactive argument of knowledge where security
            holds under the assumptions needed for the polynomial
            commitment scheme and assuming
            <span class="math">|\mathbb&#123;F&#125;|</span> is
            exponential in
            <span class="math">\lambda</span> and the size parameter
            of the R1CS instance
            <span class="math">n = O(\lambda)</span>.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        The protocol uses two instances of the sum-check protocol.
        After the first sum-check reduces
        <span class="math">\sum_&#123;x \in \&#123;0,1\&#125;^s&#125; \mathcal&#123;G&#125;_&#123;io,\tau&#125;(x) = 0</span>
        to evaluating
        <span class="math">\mathcal&#123;G&#125;_&#123;io,\tau&#125;(r_x)</span>,
        the prover sends claims
        <span class="math">v_A = \overline&#123;A&#125;(r_x)</span>,
        <span class="math">v_B = \overline&#123;B&#125;(r_x)</span>,
        <span class="math">v_C = \overline&#123;C&#125;(r_x)</span>.
        A second sum-check verifies a random linear combination of
        these three claims:
      </p>
      <div class="math-block">
        L(r_x) = \sum_&#123;y \in \&#123;0,1\&#125;^s&#125; \left(r_A \cdot \widetilde&#123;A&#125;(r_x, y) \cdot \widetilde&#123;Z&#125;(y) + r_B \cdot \widetilde&#123;B&#125;(r_x, y) \cdot \widetilde&#123;Z&#125;(y) + r_C \cdot \widetilde&#123;C&#125;(r_x, y) \cdot \widetilde&#123;Z&#125;(y)\right)
      </div>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">
          Lemma 5.1
        </div>
        <div class="formal-block-content">
          <div class="math-block">
            \Pr_&#123;r_A, r_B, r_C&#125;\&#123;r_A \cdot \overline&#123;A&#125;(r_x) + r_B \cdot \overline&#123;B&#125;(r_x) + r_C \cdot \overline&#123;C&#125;(r_x) = c \mid \overline&#123;A&#125;(r_x) \neq v_A \lor \overline&#123;B&#125;(r_x) \neq v_B \lor \overline&#123;C&#125;(r_x) \neq v_C\&#125; \leq \frac&#123;1&#125;&#123;|\mathbb&#123;F&#125;|&#125;
          </div>
        </div>
      </div>

      <p class="text-gray-300">
        At the end of the second sum-check, the verifier evaluates:
      </p>
      <div class="math-block">
        M_&#123;r_x&#125;(r_y) = (r_A \cdot \widetilde&#123;A&#125;(r_x, r_y) + r_B \cdot \widetilde&#123;B&#125;(r_x, r_y) + r_C \cdot \widetilde&#123;C&#125;(r_x, r_y)) \cdot \widetilde&#123;Z&#125;(r_y)
      </div>
      <p class="text-gray-300">
        The only term depending on the witness is
        <span class="math">\widetilde&#123;Z&#125;(r_y)</span>, which
        is handled by an extractable polynomial commitment scheme.
        The prover commits to
        <span class="math">\widetilde&#123;w&#125;(\cdot)</span>
        and uses:
      </p>
      <div class="math-block">
        \widetilde&#123;Z&#125;(r_y) = (1 - r_y[0]) \cdot \widetilde&#123;w&#125;(r_y[1..]) + r_y[0] \cdot \widetilde&#123;(io, 1)&#125;(r_y[1..])
      </div>

      <p class="text-gray-300">
        <strong>Analysis of costs.</strong> The prover incurs
        <span class="math">O(n)</span> for sum-check participation
        plus the cost of PC.Commit and PC.Eval. The verifier incurs
        <span class="math">O(\log m)</span> for sum-check,
        PC.Eval costs, and
        <span class="math">O(n)</span> to evaluate
        <span class="math">\widetilde&#123;A&#125;, \widetilde&#123;B&#125;, \widetilde&#123;C&#125;</span>.
        Communication is
        <span class="math">O(\log m)</span> plus the commitment size
        and PC.Eval communication.
      </p>

      <h3 id="sec-5.2" class="text-xl font-semibold mt-8 mb-3">
        5.2 A Family of NIZKs with Succinct Proofs for R1CS
      </h3>
      <p class="text-gray-300">
        The interactive argument is public coin, so zero-knowledge is
        added using prior compilers (from Hyrax or Libra/Virgo), and
        non-interactivity is achieved via the Fiat-Shamir transform
        in the random oracle model, yielding a family of NIZKs with
        succinct proofs for R1CS.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 6. COMPUTATION COMMITMENTS                                   -->
    <!-- ============================================================ -->

    <section id="sec-6" class="mb-10">
      <h2 class="text-2xl font-bold">
        6. Computation Commitments: zkSNARKs for R1CS from NIZK
      </h2>
      <p class="text-gray-300">
        The NIZK from Section 5 does not yet achieve sub-linear
        verification because the verifier incurs
        <span class="math">O(n)</span> costs to evaluate
        <span class="math">\widetilde&#123;A&#125;, \widetilde&#123;B&#125;, \widetilde&#123;C&#125;</span>
        at
        <span class="math">(r_x, r_y)</span>. Computation commitments
        address this via a preprocessing step.
      </p>
      <p class="text-gray-300">
        In an offline phase, the verifier commits to the sparse
        multilinear polynomials encoding the R1CS structure:
      </p>
      <div class="math-block">
        \text&#123;Encode&#125;(pp_&#123;cc&#125;, (A, B, C)): \quad (\mathcal&#123;C&#125;_A, \mathcal&#123;S&#125;_A) \leftarrow \text&#123;PC.Commit&#125;(pp_&#123;cc&#125;, \widetilde&#123;A&#125;), \;\; (\mathcal&#123;C&#125;_B, \mathcal&#123;S&#125;_B) \leftarrow \text&#123;PC.Commit&#125;(pp_&#123;cc&#125;, \widetilde&#123;B&#125;), \;\; (\mathcal&#123;C&#125;_C, \mathcal&#123;S&#125;_C) \leftarrow \text&#123;PC.Commit&#125;(pp_&#123;cc&#125;, \widetilde&#123;C&#125;)
      </div>
      <p class="text-gray-300">
        During proof verification, the prover evaluates
        <span class="math">\widetilde&#123;A&#125;, \widetilde&#123;B&#125;, \widetilde&#123;C&#125;</span>
        at
        <span class="math">(r_x, r_y)</span> and proves correctness
        via PC.Eval against the retained commitments. This
        preprocessing cost is amortized over all future proofs for
        R1CS instances with the same structure&mdash;and unlike
        GGPR&rsquo;s trusted setup, it does not involve secret
        trapdoors.
      </p>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">
          Lemma 6.1
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            The interactive argument from Section 5.1 where step 16
            is replaced with the evaluation proof protocol is a
            public-coin succinct interactive argument of knowledge
            assuming PC is an extractable polynomial commitment
            scheme for multilinear polynomials.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        However, existing polynomial commitment schemes are
        inefficient for sparse polynomials: the prover incurs at least
        <span class="math">O(m^2)</span> costs for Eval on the
        <span class="math">2\log m</span>-variate polynomials
        <span class="math">\widetilde&#123;A&#125;, \widetilde&#123;B&#125;, \widetilde&#123;C&#125;</span>.
        This motivates the SPARK compiler (Section 7).
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 7. THE SPARK COMPILER                                        -->
    <!-- ============================================================ -->

    <section id="sec-7" class="mb-10">
      <h2 class="text-2xl font-bold">
        7. The SPARK Compiler
      </h2>
      <p class="text-gray-300">
        SPARK is a cryptographic compiler that transforms an existing
        extractable polynomial commitment scheme for dense multilinear
        polynomials into one that efficiently handles sparse
        multilinear polynomials.
      </p>

      <h3 id="sec-7.1" class="text-xl font-semibold mt-8 mb-3">
        7.1 SPARK-naive: A Straw-Man Solution
      </h3>
      <p class="text-gray-300">
        The straw-man builds an
        <span class="math">O(\log \mu)</span>-depth circuit with
        <span class="math">O(n \cdot \mu)</span> gates that evaluates
        <span class="math">\widetilde&#123;M&#125;(r)</span> using
        Equation (1):
      </p>
      <div class="math-block">
        \widetilde&#123;M&#125;(r) = \sum_&#123;i \in \&#123;0,1\&#125;^\mu : M(i) \neq 0&#125; M(i) \cdot \widetilde&#123;\text&#123;eq&#125;&#125;(i, r)
      </div>
      <p class="text-gray-300">
        The circuit is data-parallel (n identical sub-circuits), so
        Hyrax can verify it. However, the prover incurs
        <span class="math">O(n \log n)</span> costs, an asymptotic
        overhead over direct evaluation.
      </p>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">
          Lemma 7.1
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            <span class="math">\text&#123;PC&#125;^&#123;\text&#123;naive&#125;&#125;</span>
            is a polynomial commitment scheme for multilinear
            polynomials. Completeness follows from PC and Hyrax.
            Binding follows from uniqueness of the dense
            representation. Knowledge soundness follows from
            witness-extended emulation of Hyrax and PC.Eval.
          </p>
        </div>
      </div>

      <h3 id="sec-7.2" class="text-xl font-semibold mt-8 mb-3">
        7.2 Eliminating Asymptotic Overheads by Leveraging Memory
        Checking
      </h3>
      <p class="text-gray-300">
        SPARK improves on the straw-man by devising an
        <span class="math">O(n)</span>-sized circuit for sparse
        polynomial evaluation. The key observation is that
        <span class="math">\widetilde&#123;M&#125;(r_x, r_y)</span>
        can be rewritten as:
      </p>
      <div class="math-block">
        \widetilde&#123;M&#125;(r_x, r_y) = \sum_&#123;(i,j) : M(i,j) \neq 0&#125; M(i,j) \cdot \widetilde&#123;\text&#123;eq&#125;&#125;(i, r_x) \cdot \widetilde&#123;\text&#123;eq&#125;&#125;(j, r_y)
      </div>
      <p class="text-gray-300">
        Precomputing tables of
        <span class="math">\widetilde&#123;\text&#123;eq&#125;&#125;(i, r_x)</span>
        and
        <span class="math">\widetilde&#123;\text&#123;eq&#125;&#125;(j, r_y)</span>
        for all <span class="math">i, j \in \&#123;0,1\&#125;^s</span>
        takes <span class="math">O(m)</span> time each. But computing
        the sum requires <span class="math">n</span> random accesses
        into these tables, which is handled by offline memory checking
        techniques with public-coin multiset hash functions:
      </p>
      <div class="math-block">
        h_\gamma(a, v, t) = a \cdot \gamma^2 + v \cdot \gamma + t
      </div>
      <div class="math-block">
        \mathcal&#123;H&#125;_\gamma(\mathcal&#123;M&#125;) = \prod_&#123;e \in \mathcal&#123;M&#125;&#125; (e - \gamma)
      </div>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">
          Lemma 7.2
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            For any two distinct triples
            <span class="math">(a_1, v_1, t_1) \neq (a_2, v_2, t_2) \in \mathbb&#123;F&#125;^3</span>,
            <span class="math">\Pr_\gamma\&#123;h_\gamma(a_1, v_1, t_1) = h_\gamma(a_2, v_2, t_2)\&#125; \leq 3/|\mathbb&#123;F&#125;|</span>.
          </p>
        </div>
      </div>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">
          Lemma 7.3
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            For any
            <span class="math">\ell > 0</span> and distinct tuples
            <span class="math">(A_1, V_1, T_1) \neq (A_2, V_2, T_2) \in (\mathbb&#123;F&#125;^\ell, \mathbb&#123;F&#125;^\ell, \mathbb&#123;F&#125;^\ell)</span>,
            <span class="math">\Pr_\gamma\&#123;\exists i : H_\gamma(A_1, V_1, T_1)[i] = H_\gamma(A_2, V_2, T_2)[i]\&#125; \leq 3\ell / |\mathbb&#123;F&#125;|</span>.
          </p>
        </div>
      </div>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">
          Lemma 7.4
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            For any two multisets
            <span class="math">\mathcal&#123;M&#125;_1, \mathcal&#123;M&#125;_2</span>
            of size <span class="math">\ell</span> over
            <span class="math">\mathbb&#123;F&#125;</span>,
            <span class="math">\Pr_\gamma\&#123;\mathcal&#123;H&#125;_\gamma(\mathcal&#123;M&#125;_1) = \mathcal&#123;H&#125;_\gamma(\mathcal&#123;M&#125;_2) \mid \mathcal&#123;M&#125;_1 \neq \mathcal&#123;M&#125;_2\&#125; \leq \ell / |\mathbb&#123;F&#125;|</span>.
          </p>
        </div>
      </div>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">
          Lemma 7.5
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Assuming
            <span class="math">|\mathbb&#123;F&#125;|</span> is
            exponential in
            <span class="math">\lambda</span> and
            <span class="math">n = O(\lambda)</span>, for any
            <span class="math">2\log m</span>-variate multilinear
            polynomial
            <span class="math">\widetilde&#123;M&#125;</span> whose
            dense representation is of size at most
            <span class="math">n</span>, and for any given
            <span class="math">e_&#123;\text&#123;row&#125;&#125;, e_&#123;\text&#123;col&#125;&#125; \in \mathbb&#123;F&#125;^n</span>:
          </p>
          <div class="math-block">
            \Pr_&#123;\gamma_1, \gamma_2&#125;\&#123;\text&#123;Circuit&#125;_&#123;\text&#123;eval-opt&#125;&#125;(w, (\gamma_1, \gamma_2), r) = v \mid \widetilde&#123;M&#125;(r) \neq v\&#125; \leq \mathsf&#123;negl&#125;(\lambda)
          </div>
        </div>
      </div>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">
          Lemma 7.6
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Assuming
            <span class="math">\text&#123;PC&#125;^&#123;\text&#123;SPARK&#125;&#125;.\text&#123;Commit&#125;</span>
            is run by an honest entity, then
            <span class="math">\text&#123;PC&#125;^&#123;\text&#123;SPARK&#125;&#125;</span>
            is a polynomial commitment scheme for multilinear
            polynomials. Completeness follows from PC, Hyrax, and
            Circuit<span class="math">_&#123;\text&#123;eval-opt&#125;&#125;</span>.
            Binding follows from uniqueness of the dense
            representation. Knowledge soundness follows from
            witness-extended emulation of Hyrax and PC, and from the
            negligible soundness error of
            Circuit<span class="math">_&#123;\text&#123;eval-opt&#125;&#125;</span>
            (Lemma 7.5).
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        <strong>Optimizations.</strong> Several optimizations reduce
        constants: (1) tailoring Hyrax for the specific circuit
        instead of black-box use; (2) building a single circuit for
        <span class="math">\widetilde&#123;A&#125;, \widetilde&#123;B&#125;, \widetilde&#123;C&#125;</span>
        to reuse memory-checking state; (3) deriving write timestamps
        from read timestamps; (4) leveraging succinct representations
        to avoid committing to certain polynomials; (5) combining
        multiple multilinear polynomials into a single polynomial
        with additional variables, reducing from 23 committed
        polynomials to 3.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 8. IMPLEMENTATION AND OPTIMIZATIONS                          -->
    <!-- ============================================================ -->

    <section id="sec-8" class="mb-10">
      <h2 class="text-2xl font-bold">
        8. Implementation and Optimizations
      </h2>
      <p class="text-gray-300">
        Spartan is implemented as a modular library in about 8,000
        lines of Rust. The prover under SPARK outperforms SPARK-naive
        by
        <span class="math">> 10\times</span> for R1CS instances with
        <span class="math">2^&#123;20&#125;</span> constraints. The
        optimizations reduce proof lengths from 3.1 MB to 142 KB
        (<span class="math">> 20\times</span> improvement) and
        improve prover and verification times by about
        <span class="math">10\times</span>.
      </p>
      <p class="text-gray-300">
        The implementation uses curve25519-dalek for a prime-order
        Ristretto group (ristretto255), with optimized scalar
        arithmetic yielding
        <span class="math">\approx 10\times</span> speedup. Zero
        knowledge is added via Hyrax&rsquo;s transformation with a
        simplification: separate dot-product proof protocols per
        sum-check round. The Fiat-Shamir transform uses the merlin
        library.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 9. EXPERIMENTAL EVALUATION                                   -->
    <!-- ============================================================ -->

    <section id="sec-9" class="mb-10">
      <h2 class="text-2xl font-bold">
        9. Experimental Evaluation
      </h2>

      <h3 id="sec-9.1" class="text-xl font-semibold mt-8 mb-3">
        9.1 Metrics, Methodology, and Testbed
      </h3>
      <p class="text-gray-300">
        Evaluation metrics are: prover costs, verifier preprocessing
        costs, verifier proof verification costs, and proof size.
        Experiments use a Microsoft Surface Laptop 3 (Intel Core
        i7-1065G7, 16 GB RAM, Ubuntu 20.04) on a single CPU core.
        Baselines include: Groth16, Ligero, Hyrax, Aurora, and
        Fractal.
      </p>

      <h3 id="sec-9.2" class="text-xl font-semibold mt-8 mb-3">
        9.2 Performance Results
      </h3>
      <p class="text-gray-300">
        <strong>Prover.</strong>
        Spartan<span class="math">_&#123;\text&#123;SNARK&#125;&#125;</span>
        is
        <span class="math">36\times</span> faster than Fractal at
        <span class="math">2^&#123;18&#125;</span> constraints.
        Spartan<span class="math">_&#123;\text&#123;NIZK&#125;&#125;</span>
        is
        <span class="math">24\times</span> faster than Ligero,
        <span class="math">152\times</span> faster than Aurora, and
        <span class="math">99\times</span> faster than Hyrax at
        <span class="math">2^&#123;20&#125;</span> instances.
        Compared to Groth16,
        Spartan<span class="math">_&#123;\text&#123;SNARK&#125;&#125;</span>
        is
        <span class="math">2\times</span> faster and
        Spartan<span class="math">_&#123;\text&#123;NIZK&#125;&#125;</span>
        is
        <span class="math">16\times</span> faster for
        <span class="math">2^&#123;20&#125;</span> constraints.
      </p>
      <p class="text-gray-300">
        <strong>Proof sizes.</strong>
        Spartan<span class="math">_&#123;\text&#123;SNARK&#125;&#125;</span>
        offers
        <span class="math">\approx 23\times</span> shorter proofs
        than Fractal at
        <span class="math">2^&#123;18&#125;</span> constraints.
        Spartan<span class="math">_&#123;\text&#123;NIZK&#125;&#125;</span>
        offers proofs
        <span class="math">1.2</span>&ndash;<span class="math">416\times</span>
        shorter than baselines. All transparent zkSNARKs produce
        orders of magnitude longer proofs than Groth16 (128 bytes).
      </p>
      <p class="text-gray-300">
        <strong>Verifier.</strong> Among transparent schemes,
        Spartan<span class="math">_&#123;\text&#123;SNARK&#125;&#125;</span>
        is
        <span class="math">3.6\times</span> faster than Fractal,
        <span class="math">1326\times</span> faster than Aurora,
        <span class="math">383\times</span> faster than Ligero, and
        <span class="math">80\times</span> faster than Hyrax at
        <span class="math">2^&#123;20&#125;</span> constraints.
        Spartan<span class="math">_&#123;\text&#123;SNARK&#125;&#125;</span>
        beats
        Spartan<span class="math">_&#123;\text&#123;NIZK&#125;&#125;</span>
        for verification at approximately
        <span class="math">2^&#123;17&#125;</span> constraints since
        the former incurs
        <span class="math">O(\sqrt&#123;n&#125;)</span> costs versus
        <span class="math">O(n)</span>.
      </p>
      <p class="text-gray-300">
        <strong>Encoder.</strong>
        Spartan<span class="math">_&#123;\text&#123;SNARK&#125;&#125;</span>&rsquo;s
        encoder is up to
        <span class="math">52\times</span> faster than
        Fractal&rsquo;s and about
        <span class="math">4.7\times</span> faster than
        Groth16&rsquo;s trusted setup at the largest instance sizes.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- ACKNOWLEDGEMENTS                                             -->
    <!-- ============================================================ -->

    <section id="acknowledgements" class="mb-10">
      <h2 class="text-2xl font-bold">Acknowledgements</h2>
      <p class="text-gray-300">
        Comments from Sebastian Angel, Melissa Chase, Hao Chen, Ben
        Fisch, Esha Ghosh, Abhiram Kothapalli, Satya Lokam, Bryan
        Parno, Ioanna Tzialla, Ramarathnam Venkatesan, and the
        CRYPTO 2020 reviewers helped improve this paper. Special
        thanks to Justin Thaler, Riad Wahby, and Michael Walfish for
        their detailed attention and thorough comments, and to
        Jonathan Lee for insightful discussions. We thank Henry de
        Valence for help with curve25519-dalek.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- APPENDIX A                                                   -->
    <!-- ============================================================ -->

    <section id="appendix-a" class="mb-10">
      <h2 class="text-2xl font-bold">
        Appendix A: Proof of Witness-Extended Emulation
      </h2>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">
          Lemma A.1
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            For any non-satisfiable R1CS instance
            <span class="math">\mathbf&#123;x&#125;</span>, any PPT
            prover
            <span class="math">\mathcal&#123;P&#125;^*_&#123;IP&#125;</span>,
            and for all
            <span class="math">w, r \in \&#123;0,1\&#125;^*</span>:
          </p>
          <div class="math-block">
            \Pr\&#123;\langle \mathcal&#123;P&#125;^*_&#123;IP&#125;(w), \mathcal&#123;V&#125;_&#123;IP&#125;(r) \rangle(\mathbf&#123;x&#125;) = 1\&#125; \leq \frac&#123;6 \log m + 1&#125;&#123;|\mathbb&#123;F&#125;|&#125;
          </div>
        </div>
      </div>

      <p class="text-gray-300">
        <em>Proof.</em> If
        <span class="math">\mathbf&#123;x&#125;</span> is not
        satisfiable, then
        <span class="math">Q_&#123;io&#125;(t)</span> is not a
        zero-polynomial. By the Schwartz-Zippel lemma, the verifier
        choosing a &ldquo;bad&rdquo;
        <span class="math">\tau</span> where
        <span class="math">Q_&#123;io&#125;(\tau) = 0</span> happens
        with probability at most
        <span class="math">\log m / |\mathbb&#123;F&#125;|</span>.
        Otherwise, a malicious prover begins with a false claim in
        the sum-check protocol and succeeds with probability at most
        <span class="math">(\ell_1 \cdot \mu_1 + \ell_2 \cdot \mu_2 + 1)/|\mathbb&#123;F&#125;|</span>
        where
        <span class="math">\mu_1 = \mu_2 = \log m</span>,
        <span class="math">\ell_1 = 3</span>,
        <span class="math">\ell_2 = 2</span>. A union bound
        establishes the result.
      </p>

      <div class="formal-block formal-block-theorem">
        <div class="formal-block-title text-green-400">
          Theorem A.1
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Given an extractable polynomial commitment scheme for
            multilinear polynomials PC that satisfies witness-extended
            emulation for PC.Eval, the protocol in Section 5.1 has
            witness-extended emulation.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        <em>Proof.</em> The proof is identical to Hyrax&rsquo;s except
        where their proof invokes properties of Gir++, we invoke
        properties of Spartan-core (the information-theoretic
        variant).
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- REFERENCES                                                   -->
    <!-- ============================================================ -->

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>
      <ul class="space-y-2 text-gray-400 text-sm list-none">
        <li>
          <span class="text-gray-500">[Eth]</span>
          Ethereum Roadmap. ZK-Rollups.
        </li>
        <li>
          <span class="text-gray-500">[Mer]</span>
          Merlin: composable proof transcripts for public-coin
          arguments of knowledge.
        </li>
        <li>
          <span class="text-gray-500">[cur25519]</span>
          A pure-Rust implementation of group operations on
          Ristretto and Curve25519.
        </li>
        <li>
          <span class="text-gray-500">[Ris]</span>
          The Ristretto group.
        </li>
        <li>
          <span class="text-gray-500">[Spa]</span>
          Spartan: High-speed zkSNARKs without trusted setup.
          <a
            href="https://github.com/Microsoft/Spartan"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >github.com/Microsoft/Spartan</a>.
        </li>
        <li>
          <span class="text-gray-500">[AHIV17]</span>
          S. Ames, C. Hazay, Y. Ishai, and M.
          Venkitasubramaniam. &ldquo;Ligero: Lightweight sublinear
          arguments without a trusted setup.&rdquo; In:
          <em>CCS</em>, 2017.
        </li>
        <li>
          <span class="text-gray-500">[Ara+17]</span>
          A. Arasu et al. &ldquo;Concerto: A high concurrency
          key-value store with integrity.&rdquo; In:
          <em>SIGMOD</em>, 2017.
        </li>
        <li>
          <span class="text-gray-500">[ALMS98]</span>
          S. Arora, C. Lund, R. Motwani, M. Sudan, and M.
          Szegedy. &ldquo;Proof verification and the hardness of
          approximation problems.&rdquo; <em>J. ACM</em>,
          45(3), 1998.
        </li>
        <li>
          <span class="text-gray-500">[AS98]</span>
          S. Arora and S. Safra. &ldquo;Probabilistic checking
          of proofs: A new characterization of NP.&rdquo;
          <em>J. ACM</em>, 45(1):70&ndash;122, 1998.
        </li>
        <li>
          <span class="text-gray-500">[AS03]</span>
          S. Arora and M. Sudan. &ldquo;Improved low-degree
          testing and its applications.&rdquo;
          <em>Combinatorica</em>, 23(3):365&ndash;426, 2003.
        </li>
        <li>
          <span class="text-gray-500">[Bab85]</span>
          L. Babai. &ldquo;Trading group theory for
          randomness.&rdquo; In: <em>STOC</em>, 1985.
        </li>
        <li>
          <span class="text-gray-500">[BFLS91]</span>
          L. Babai, L. Fortnow, L. A. Levin, and M. Szegedy.
          &ldquo;Checking computations in polylogarithmic
          time.&rdquo; In: <em>STOC</em>, 1991.
        </li>
        <li>
          <span class="text-gray-500">[BFL92]</span>
          L. Babai, L. Fortnow, and C. Lund.
          &ldquo;Non-deterministic exponential time has two-prover
          interactive protocols.&rdquo; <em>Computational
          Complexity</em>, 2(4), 1992.
        </li>
        <li>
          <span class="text-gray-500">[BO+88]</span>
          M. Ben-Or et al. &ldquo;Everything provable is
          provable in zero-knowledge.&rdquo; In: <em>CRYPTO</em>,
          1988.
        </li>
        <li>
          <span class="text-gray-500">[BBHR18]</span>
          E. Ben-Sasson, I. Bentov, Y. Horesh, and M. Riabzev.
          &ldquo;Scalable, transparent, and post-quantum secure
          computational integrity.&rdquo; ePrint 2018/046.
        </li>
        <li>
          <span class="text-gray-500">[BS+20]</span>
          E. Ben-Sasson et al. &ldquo;Proximity gaps for
          Reed-Solomon codes.&rdquo; ePrint 2020/654.
        </li>
        <li>
          <span class="text-gray-500">[BS+14]</span>
          E. Ben-Sasson et al. &ldquo;Zerocash: Decentralized
          anonymous payments from Bitcoin.&rdquo; In:
          <em>S&amp;P</em>, 2014.
        </li>
        <li>
          <span class="text-gray-500">[BCGT13]</span>
          E. Ben-Sasson, A. Chiesa, D. Genkin, and E. Tromer.
          &ldquo;Fast reductions from RAMs to delegatable succinct
          constraint satisfaction problems.&rdquo; In:
          <em>ITCS</em>, 2013.
        </li>
        <li>
          <span class="text-gray-500">[BS+13a]</span>
          E. Ben-Sasson et al. &ldquo;On the concrete
          efficiency of probabilistically-checkable proofs.&rdquo;
          In: <em>STOC</em>, 2013.
        </li>
        <li>
          <span class="text-gray-500">[BS+13b]</span>
          E. Ben-Sasson et al. &ldquo;SNARKs for C: Verifying
          program executions succinctly and in zero
          knowledge.&rdquo; In: <em>CRYPTO</em>, 2013.
        </li>
        <li>
          <span class="text-gray-500">[BS+19a]</span>
          E. Ben-Sasson et al. &ldquo;Aurora: Transparent
          succinct arguments for R1CS.&rdquo; In:
          <em>EUROCRYPT</em>, 2019.
        </li>
        <li>
          <span class="text-gray-500">[BCS16]</span>
          E. Ben-Sasson, A. Chiesa, and N. Spooner.
          &ldquo;Interactive Oracle Proofs.&rdquo; In:
          <em>TCC</em>, 2016.
        </li>
        <li>
          <span class="text-gray-500">[BS+14b]</span>
          E. Ben-Sasson et al. &ldquo;Scalable zero knowledge
          via cycles of elliptic curves.&rdquo; In:
          <em>CRYPTO</em>, 2014.
        </li>
        <li>
          <span class="text-gray-500">[BS+14c]</span>
          E. Ben-Sasson et al. &ldquo;Succinct non-interactive
          zero knowledge for a von Neumann architecture.&rdquo; In:
          <em>USENIX Security</em>, 2014.
        </li>
        <li>
          <span class="text-gray-500">[BS+05]</span>
          E. Ben-Sasson et al. &ldquo;Short PCPs verifiable in
          polylogarithmic time.&rdquo; In: <em>Computational
          Complexity</em>, 2005.
        </li>
        <li>
          <span class="text-gray-500">[BS05]</span>
          E. Ben-Sasson and M. Sudan. &ldquo;Simple PCPs with
          poly-log rate and query complexity.&rdquo; In:
          <em>STOC</em>, 2005.
        </li>
        <li>
          <span class="text-gray-500">[BS08]</span>
          E. Ben-Sasson and M. Sudan. &ldquo;Short PCPs with
          polylog query complexity.&rdquo; <em>SIAM J.
          Comput.</em>, 38(2), 2008.
        </li>
        <li>
          <span class="text-gray-500">[Bit+12]</span>
          N. Bitansky et al. &ldquo;From extractable collision
          resistance to succinct non-interactive arguments of
          knowledge, and back again.&rdquo; In: <em>ITCS</em>,
          2012.
        </li>
        <li>
          <span class="text-gray-500">[BC12]</span>
          N. Bitansky and A. Chiesa. &ldquo;Succinct arguments
          from multi-prover interactive proofs.&rdquo; In:
          <em>CRYPTO</em>, 2012.
        </li>
        <li>
          <span class="text-gray-500">[Bit+13]</span>
          N. Bitansky et al. &ldquo;Succinct non-interactive
          arguments via linear interactive proofs.&rdquo; In:
          <em>TCC</em>, 2013.
        </li>
        <li>
          <span class="text-gray-500">[BEGK91]</span>
          M. Blum, W. Evans, P. Gemmell, S. Kannan, and M.
          Naor. &ldquo;Checking the correctness of
          memories.&rdquo; In: <em>FOCS</em>, 1991.
        </li>
        <li>
          <span class="text-gray-500">[BTVW14]</span>
          A. J. Blumberg, J. Thaler, V. Vu, and M. Walfish.
          &ldquo;Verifiable computation using multiple
          provers.&rdquo; ePrint 2014/846.
        </li>
        <li>
          <span class="text-gray-500">[Bon+19]</span>
          D. Boneh et al. &ldquo;Zero-knowledge proofs on
          secret-shared data via fully linear PCPs.&rdquo; ePrint
          2019/188.
        </li>
        <li>
          <span class="text-gray-500">[Boo+16]</span>
          J. Bootle et al. &ldquo;Efficient zero-knowledge
          arguments for arithmetic circuits in the discrete log
          setting.&rdquo; In: <em>EUROCRYPT</em>, 2016.
        </li>
        <li>
          <span class="text-gray-500">[Bow]</span>
          S. Bowe. A BLS12-381 implementation.
        </li>
        <li>
          <span class="text-gray-500">[Bow+18]</span>
          S. Bowe et al. &ldquo;Zexe: Enabling decentralized
          private computation.&rdquo; ePrint 2018/962.
        </li>
        <li>
          <span class="text-gray-500">[BCC88]</span>
          G. Brassard, D. Chaum, and C. Cr&eacute;peau.
          &ldquo;Minimum disclosure proofs of knowledge.&rdquo;
          <em>J. Comput. Syst. Sci.</em>, 37(2), 1988.
        </li>
        <li>
          <span class="text-gray-500">[Bra+13]</span>
          B. Braun et al. &ldquo;Verifying computations with
          state.&rdquo; In: <em>SOSP</em>, 2013.
        </li>
        <li>
          <span class="text-gray-500">[BFS19]</span>
          B. B&uuml;nz, B. Fisch, and A. Szepieniec.
          &ldquo;Transparent SNARKs from DARK compilers.&rdquo;
          ePrint 2019/1229.
        </li>
        <li>
          <span class="text-gray-500">[But18]</span>
          V. Buterin. &ldquo;On-chain scaling to potentially
          500 tx/sec through mass tx validation.&rdquo; 2018.
        </li>
        <li>
          <span class="text-gray-500">[But19]</span>
          V. Buterin. &ldquo;The dawn of hybrid layer 2
          protocols.&rdquo; 2019.
        </li>
        <li>
          <span class="text-gray-500">[Bun+18]</span>
          B. B&uuml;nz et al. &ldquo;Bulletproofs: Short
          proofs for confidential transactions and more.&rdquo; In:
          <em>S&amp;P</em>, 2018.
        </li>
        <li>
          <span class="text-gray-500">[CFQ19]</span>
          M. Campanelli, D. Fiore, and A. Querol.
          &ldquo;LegoSNARK: modular design and composition of
          succinct zero-knowledge proofs.&rdquo; ePrint 2019/142.
        </li>
        <li>
          <span class="text-gray-500">[CRR12]</span>
          R. Canetti, B. Riva, and G. N. Rothblum. &ldquo;Two
          protocols for delegation of computation.&rdquo; In:
          <em>ICITS</em>, 2012.
        </li>
        <li>
          <span class="text-gray-500">[CFS17]</span>
          A. Chiesa, M. A. Forbes, and N. Spooner. &ldquo;A
          zero knowledge sumcheck and its applications.&rdquo;
          <em>CoRR</em>, abs/1704.02086, 2017.
        </li>
        <li>
          <span class="text-gray-500">[COS19]</span>
          A. Chiesa, D. Ojha, and N. Spooner.
          &ldquo;Fractal: Post-quantum and transparent recursive
          proofs from holography.&rdquo; ePrint 2019/1076.
        </li>
        <li>
          <span class="text-gray-500">[Cla+03]</span>
          D. Clarke et al. &ldquo;Incremental multiset hash
          functions and their application to memory integrity
          checking.&rdquo; In: <em>ASIACRYPT</em>, 2003.
        </li>
        <li>
          <span class="text-gray-500">[CMT12]</span>
          G. Cormode, M. Mitzenmacher, and J. Thaler.
          &ldquo;Practical verified computation with streaming
          interactive proofs.&rdquo; In: <em>ITCS</em>, 2012.
        </li>
        <li>
          <span class="text-gray-500">[Cos+15]</span>
          C. Costello et al. &ldquo;Geppetto: Versatile
          verifiable computation.&rdquo; In: <em>S&amp;P</em>,
          2015.
        </li>
        <li>
          <span class="text-gray-500">[CD98]</span>
          R. Cramer and I. Damg&aring;rd. &ldquo;Zero-knowledge
          proofs for finite field arithmetic.&rdquo; In:
          <em>CRYPTO</em>, 1998.
        </li>
        <li>
          <span class="text-gray-500">[DL+16]</span>
          A. Delignat-Lavaud et al. &ldquo;Cinderella: Turning
          shabby X.509 certificates into elegant anonymous
          credentials.&rdquo; In: <em>S&amp;P</em>, 2016.
        </li>
        <li>
          <span class="text-gray-500">[Din07]</span>
          I. Dinur. &ldquo;The PCP theorem by gap
          amplification.&rdquo; <em>J. ACM</em>, 54(3), 2007.
        </li>
        <li>
          <span class="text-gray-500">[Dwo+09]</span>
          C. Dwork et al. &ldquo;How efficient can memory
          checking be?&rdquo; In: <em>TCC</em>, 2009.
        </li>
        <li>
          <span class="text-gray-500">[Fei+96]</span>
          U. Feige et al. &ldquo;Interactive proofs and the
          hardness of approximating cliques.&rdquo; <em>J.
          ACM</em>, 43(2), 1996.
        </li>
        <li>
          <span class="text-gray-500">[FS86]</span>
          A. Fiat and A. Shamir. &ldquo;How to prove yourself:
          Practical solutions to identification and signature
          problems.&rdquo; In: <em>CRYPTO</em>, 1986.
        </li>
        <li>
          <span class="text-gray-500">[Fio+16]</span>
          D. Fiore et al. &ldquo;Hash first, argue later:
          Adaptive verifiable computations on outsourced
          data.&rdquo; In: <em>CCS</em>, 2016.
        </li>
        <li>
          <span class="text-gray-500">[GGP10]</span>
          R. Gennaro, C. Gentry, and B. Parno.
          &ldquo;Non-interactive verifiable computing.&rdquo; In:
          <em>CRYPTO</em>, 2010.
        </li>
        <li>
          <span class="text-gray-500">[GGPR13]</span>
          R. Gennaro, C. Gentry, B. Parno, and M. Raykova.
          &ldquo;Quadratic span programs and succinct NIZKs without
          PCPs.&rdquo; In: <em>EUROCRYPT</em>, 2013.
        </li>
        <li>
          <span class="text-gray-500">[Gen09]</span>
          C. Gentry. <em>A fully homomorphic encryption
          scheme</em>. PhD thesis, Stanford, 2009.
        </li>
        <li>
          <span class="text-gray-500">[GW11]</span>
          C. Gentry and D. Wichs. &ldquo;Separating succinct
          non-interactive arguments from all falsifiable
          assumptions.&rdquo; In: <em>STOC</em>, 2011.
        </li>
        <li>
          <span class="text-gray-500">[GKR08]</span>
          S. Goldwasser, Y. T. Kalai, and G. N. Rothblum.
          &ldquo;Delegating computation: Interactive proofs for
          muggles.&rdquo; In: <em>STOC</em>, 2008.
        </li>
        <li>
          <span class="text-gray-500">[GMR85]</span>
          S. Goldwasser, S. Micali, and C. Rackoff. &ldquo;The
          knowledge complexity of interactive proof-systems.&rdquo;
          In: <em>STOC</em>, 1985.
        </li>
        <li>
          <span class="text-gray-500">[Gro10]</span>
          J. Groth. &ldquo;Short pairing-based non-interactive
          zero-knowledge arguments.&rdquo; In:
          <em>ASIACRYPT</em>, 2010.
        </li>
        <li>
          <span class="text-gray-500">[Gro16]</span>
          J. Groth. &ldquo;On the size of pairing-based
          non-interactive arguments.&rdquo; In:
          <em>EUROCRYPT</em>, 2016.
        </li>
        <li>
          <span class="text-gray-500">[GI08]</span>
          J. Groth and Y. Ishai. &ldquo;Sub-linear
          zero-knowledge argument for correctness of a
          shuffle.&rdquo; In: <em>EUROCRYPT</em>, 2008.
        </li>
        <li>
          <span class="text-gray-500">[Gro+18]</span>
          J. Groth et al. &ldquo;Updatable and universal common
          reference strings with applications to
          zk-SNARKs.&rdquo; In: <em>CRYPTO</em>, 2018.
        </li>
        <li>
          <span class="text-gray-500">[Ham15]</span>
          M. Hamburg. &ldquo;Decaf: Eliminating cofactors
          through point compression.&rdquo; In: <em>CRYPTO</em>,
          2015.
        </li>
        <li>
          <span class="text-gray-500">[Has97]</span>
          J. H&aring;stad. &ldquo;Some optimal
          inapproximability results.&rdquo; In: <em>STOC</em>,
          1997.
        </li>
        <li>
          <span class="text-gray-500">[IKO07]</span>
          Y. Ishai, E. Kushilevitz, and R. Ostrovsky.
          &ldquo;Efficient arguments without short PCPs.&rdquo; In:
          <em>Computational Complexity</em>, 2007.
        </li>
        <li>
          <span class="text-gray-500">[Ish+07]</span>
          Y. Ishai et al. &ldquo;Zero-knowledge from secure
          multiparty computation.&rdquo; In: <em>STOC</em>, 2007.
        </li>
        <li>
          <span class="text-gray-500">[Kal17]</span>
          Y. T. Kalai. &ldquo;Delegating computation: A new
          perspective.&rdquo; Workshop at STOC 2017.
        </li>
        <li>
          <span class="text-gray-500">[KZG10]</span>
          A. Kate, G. M. Zaverucha, and I. Goldberg.
          &ldquo;Constant-size commitments to polynomials and their
          applications.&rdquo; In: <em>ASIACRYPT</em>, 2010.
        </li>
        <li>
          <span class="text-gray-500">[Kil92]</span>
          J. Kilian. &ldquo;A note on efficient zero-knowledge
          proofs and arguments.&rdquo; In: <em>STOC</em>, 1992.
        </li>
        <li>
          <span class="text-gray-500">[Kos+16]</span>
          A. Kosba et al. &ldquo;Hawk: The blockchain model of
          cryptography and privacy-preserving smart
          contracts.&rdquo; In: <em>S&amp;P</em>, 2016.
        </li>
        <li>
          <span class="text-gray-500">[KPS18]</span>
          A. Kosba, C. Papamanthou, and E. Shi.
          &ldquo;xJsnark: A framework for efficient verifiable
          computation.&rdquo; In: <em>S&amp;P</em>, 2018.
        </li>
        <li>
          <span class="text-gray-500">[LNS20]</span>
          J. Lee, K. Nikitin, and S. Setty. &ldquo;Replicated
          state machines without replicated execution.&rdquo; In:
          <em>S&amp;P</em>, 2020.
        </li>
        <li>
          <span class="text-gray-500">[libfen]</span>
          libfennel. Hyrax reference implementation.
        </li>
        <li>
          <span class="text-gray-500">[libiop]</span>
          libiop. A C++ library for IOP-based zkSNARK.
        </li>
        <li>
          <span class="text-gray-500">[libsnark]</span>
          libsnark. A C++ library for zkSNARK proofs.
        </li>
        <li>
          <span class="text-gray-500">[Lip12]</span>
          H. Lipmaa. &ldquo;Progression-free sets and
          sublinear pairing-based non-interactive zero-knowledge
          arguments.&rdquo; In: <em>TCC</em>, 2012.
        </li>
        <li>
          <span class="text-gray-500">[LFKN90]</span>
          C. Lund, L. Fortnow, H. Karloff, and N. Nisan.
          &ldquo;Algebraic methods for interactive proof
          systems.&rdquo; In: <em>FOCS</em>, 1990.
        </li>
        <li>
          <span class="text-gray-500">[Mal+19]</span>
          M. Maller et al. &ldquo;Sonic: Zero-knowledge SNARKs
          from linear-size universal and updateable structured
          reference strings.&rdquo; ePrint 2019/099.
        </li>
        <li>
          <span class="text-gray-500">[Mer88]</span>
          R. C. Merkle. &ldquo;A digital signature based on a
          conventional encryption function.&rdquo; In:
          <em>CRYPTO</em>, 1988.
        </li>
        <li>
          <span class="text-gray-500">[Mic94]</span>
          S. Micali. &ldquo;CS proofs.&rdquo; In:
          <em>FOCS</em>, 1994.
        </li>
        <li>
          <span class="text-gray-500">[MR08]</span>
          D. Moshkovitz and R. Raz. &ldquo;Sub-constant error
          low degree test of almost-linear size.&rdquo; <em>SIAM
          J. Comput.</em>, 38(1), 2008.
        </li>
        <li>
          <span class="text-gray-500">[OWB19]</span>
          A. Ozdemir, R. S. Wahby, and D. Boneh.
          &ldquo;Scaling verifiable computation using efficient set
          accumulators.&rdquo; ePrint 2019/1494.
        </li>
        <li>
          <span class="text-gray-500">[PST13]</span>
          C. Papamanthou, E. Shi, and R. Tamassia.
          &ldquo;Signatures of correct computation.&rdquo; In:
          <em>TCC</em>, 2013.
        </li>
        <li>
          <span class="text-gray-500">[PGHR13]</span>
          B. Parno, C. Gentry, J. Howell, and M. Raykova.
          &ldquo;Pinocchio: Nearly practical verifiable
          computation.&rdquo; In: <em>S&amp;P</em>, 2013.
        </li>
        <li>
          <span class="text-gray-500">[RRR16]</span>
          O. Reingold, G. N. Rothblum, and R. D. Rothblum.
          &ldquo;Constant-round interactive proofs for delegating
          computation.&rdquo; In: <em>STOC</em>, 2016.
        </li>
        <li>
          <span class="text-gray-500">[Rot09]</span>
          G. Rothblum. <em>Delegating Computation Reliably:
          Paradigms and Constructions</em>. PhD thesis, MIT, 2009.
        </li>
        <li>
          <span class="text-gray-500">[Set+18]</span>
          S. Setty et al. &ldquo;Proving the correct execution
          of concurrent services in zero-knowledge.&rdquo; In:
          <em>OSDI</em>, 2018.
        </li>
        <li>
          <span class="text-gray-500">[SBW11]</span>
          S. Setty, A. J. Blumberg, and M. Walfish.
          &ldquo;Toward practical and unconditional verification of
          remote computations.&rdquo; In: <em>HotOS</em>, 2011.
        </li>
        <li>
          <span class="text-gray-500">[Set+13]</span>
          S. Setty et al. &ldquo;Resolving the conflict between
          generality and plausibility in verified
          computation.&rdquo; In: <em>EuroSys</em>, 2013.
        </li>
        <li>
          <span class="text-gray-500">[Set+12a]</span>
          S. Setty et al. &ldquo;Making argument systems for
          outsourced computation practical (sometimes).&rdquo; In:
          <em>NDSS</em>, 2012.
        </li>
        <li>
          <span class="text-gray-500">[Set+12b]</span>
          S. Setty et al. &ldquo;Taking proof-based verified
          computation a few steps closer to practicality.&rdquo;
          In: <em>USENIX Security</em>, 2012.
        </li>
        <li>
          <span class="text-gray-500">[Tha13]</span>
          J. Thaler. &ldquo;Time-optimal interactive proofs for
          circuit evaluation.&rdquo; In: <em>CRYPTO</em>, 2013.
        </li>
        <li>
          <span class="text-gray-500">[Tha17]</span>
          J. Thaler. &ldquo;A state of the art MIP for circuit
          satisfiability.&rdquo; Lecture notes, 2017.
        </li>
        <li>
          <span class="text-gray-500">[Tha+12]</span>
          J. Thaler et al. &ldquo;Verifiable computation with
          massively parallel interactive proofs.&rdquo; In:
          <em>HotCloud</em>, 2012.
        </li>
        <li>
          <span class="text-gray-500">[Vu+13]</span>
          V. Vu et al. &ldquo;A hybrid architecture for
          verifiable computation.&rdquo; In: <em>S&amp;P</em>,
          2013.
        </li>
        <li>
          <span class="text-gray-500">[Wah+16]</span>
          R. S. Wahby et al. &ldquo;Verifiable
          ASICs.&rdquo; In: <em>S&amp;P</em>, 2016.
        </li>
        <li>
          <span class="text-gray-500">[Wah+17]</span>
          R. S. Wahby et al. &ldquo;Full accounting for
          verifiable outsourcing.&rdquo; In: <em>CCS</em>, 2017.
        </li>
        <li>
          <span class="text-gray-500">[Wah+15]</span>
          R. S. Wahby et al. &ldquo;Efficient RAM and control
          flow in verifiable outsourced computation.&rdquo; In:
          <em>NDSS</em>, 2015.
        </li>
        <li>
          <span class="text-gray-500">[WTST18]</span>
          R. S. Wahby, I. Tzialla, A. Shelat, J. Thaler, and
          M. Walfish. &ldquo;Doubly-efficient zkSNARKs without
          trusted setup.&rdquo; In: <em>S&amp;P</em>, 2018.
        </li>
        <li>
          <span class="text-gray-500">[WB15]</span>
          M. Walfish and A. J. Blumberg. &ldquo;Verifying
          computations without reexecuting them.&rdquo;
          <em>Commun. ACM</em>, 58(2), 2015.
        </li>
        <li>
          <span class="text-gray-500">[Whi+18]</span>
          B. WhiteHat et al. &ldquo;Roll_up / roll_back snark
          side chain ~17000 tps.&rdquo; 2018.
        </li>
        <li>
          <span class="text-gray-500">[XZZP19]</span>
          T. Xie, J. Zhang, Y. Zhang, C. Papamanthou, and D.
          Song. &ldquo;Libra: Succinct zero-knowledge proofs with
          optimal prover computation.&rdquo; ePrint 2019/317.
        </li>
        <li>
          <span class="text-gray-500">[ZXZS20]</span>
          J. Zhang, T. Xie, Y. Zhang, and D. Song.
          &ldquo;Transparent polynomial delegation and its
          applications to zero knowledge proof.&rdquo; In:
          <em>S&amp;P</em>, 2020.
        </li>
        <li>
          <span class="text-gray-500">[Zha+17]</span>
          Y. Zhang et al. &ldquo;vSQL: Verifying arbitrary
          SQL queries over dynamic outsourced databases.&rdquo; In:
          <em>S&amp;P</em>, 2017.
        </li>
        <li>
          <span class="text-gray-500">[Zha+17b]</span>
          Y. Zhang et al. &ldquo;A zero-knowledge version of
          vSQL.&rdquo; ePrint 2017/1146.
        </li>
        <li>
          <span class="text-gray-500">[Zha+18]</span>
          Y. Zhang et al. &ldquo;vRAM: Faster verifiable RAM
          with program-independent preprocessing.&rdquo; In:
          <em>S&amp;P</em>, 2018.
        </li>
      </ul>
    </section>

  </article>
</BaseLayout>
