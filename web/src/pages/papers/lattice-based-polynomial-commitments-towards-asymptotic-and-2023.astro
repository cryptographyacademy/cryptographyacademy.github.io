---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2023/846';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Lattice-Based Polynomial Commitments: Towards Asymptotic and Concrete Efficiency';
const AUTHORS_HTML = 'Giacomo Fenzi, Hossein Moghaddas, Ngoc Khanh Nguyen';

const CONTENT = `    <p class="text-gray-300">Giacomo Fenzi giacomo.fenzi@epfl.ch EPFL Hossein Moghaddas hossein.moghaddas@epfl.ch EPFL Ngoc Khanh Nguyen khanh.nguyen@epfl.ch EPFL</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Polynomial commitments schemes are a powerful tool that enables one party to commit to a polynomial <span class="math">p</span> of degree <span class="math">d</span>, and prove that the committed function evaluates to a certain value <span class="math">z</span> at a specified point <span class="math">u</span>, i.e. <span class="math">p(u)=z</span>, without revealing any additional information about the polynomial. Recently, polynomial commitments have been extensively used as a cryptographic building block to transform polynomial interactive oracle proofs (PIOPs) into efficient succinct arguments.</p>

    <p class="text-gray-300">In this paper, we propose a lattice-based polynomial commitment that achieves succinct proof size and verification time in the degree <span class="math">d</span> of the polynomial. Extractability of our scheme holds in the random oracle model under a natural ring version of the BASIS assumption introduced by Wee and Wu (EUROCRYPT 2023). Unlike recent constructions of polynomial commitments by Albrecht et al. (CRYPTO 2022), and by Wee and Wu, we do not require any expensive preprocessing steps, which makes our scheme particularly attractive as an ingredient of a PIOP compiler for succinct arguments. We further instantiate our polynomial commitment, together with the Marlin PIOP (Eurocrypt 2020), to obtain a publicly-verifiable trusted-setup succinct argument for Rank-1 Constraint System (R1CS). Performance-wise, we achieve 17MB proof size for <span class="math">2^{20}</span> constraints, which is 15X smaller than currently the only publicly-verifiable lattice-based SNARK proposed by Albrecht et al.</p>

    <p class="text-gray-300">Keywords: lattices, polynomial commitments, succinct arguments,zero-knowledge</p>

    <p class="text-gray-300">2</p>

    <h2 id="sec-4" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">4</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1.1 Our Contributions 5</li>

      <li>1.2 Technical Overview 6</li>

      <li>1.3 BASIS Commitment Scheme 6</li>

      <li>1.4 Framework for Proving Polynomial Evaluations 9</li>

      <li>1.5 Polynomial Commitments over Finite Fields 15</li>

      <li>1.6 Related Works 16</li>

      <li>1.7 Concurrent and Subsequent Works 17</li>

    </ul>

    <h2 id="sec-5" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">19</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>2.1 Lattices 19</li>

      <li>2.2 Power-of-Two Cyclotomic Rings 20</li>

      <li>2.3 Discrete Gaussian Distributions 21</li>

      <li>2.4 NTRU Lattices 23</li>

      <li>2.5 Gadget Trapdoors 23</li>

      <li>2.6 Commitment Scheme 25</li>

      <li>2.7 Polynomial Commitment Scheme 26</li>

      <li>2.8 Interactive Proofs 27</li>

      <li>2.9 Coordinate-Wise Special Soundness 28</li>

    </ul>

    <h2 id="sec-6" class="text-2xl font-bold">3 Power-BASIS Assumption</h2>

    <p class="text-gray-300">30</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>3.1 Hardness of BASIS for Low Dimensions 31</li>

      <li>3.2 Higher Dimensions 34</li>

    </ul>

    <h2 id="sec-7" class="text-2xl font-bold">4 Power-BASIS Commitment Scheme</h2>

    <p class="text-gray-300">36</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>4.1 Security Analysis 38</li>

    </ul>

    <h2 id="sec-8" class="text-2xl font-bold">5 Efficient Proofs of Polynomial Evaluation</h2>

    <p class="text-gray-300">40</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>5.1 Framework for Proving Evaluations 40</li>

      <li>5.2 Monomial Protocol 46</li>

      <li>5.3 Large Sampling Set 48</li>

      <li>5.4 Batching Evaluations 54</li>

      <li>5.4.1 Multiple Evaluations at a Single Point 54</li>

      <li>5.4.2 Multiple Evaluations at Distinct Points 56</li>

      <li>5.5 Honest-Verifier Zero-Knowledge 59</li>

      <li>5.6 Polynomial Commitments over Finite Fields 65</li>

    </ul>

    <h2 id="sec-9" class="text-2xl font-bold">6 Concrete Instantiation and Applications to Marlin</h2>

    <p class="text-gray-300">67</p>

    <h2 id="sec-10" class="text-2xl font-bold">7 Coordinate-Wise Special Soundness Implies Knowledge Soundness</h2>

    <p class="text-gray-300">69</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>7.1 <span class="math">\\Sigma</span>-Protocols 70</li>

      <li>7.2 Multi-Round Protocols 71</li>

      <li>7.3 Comparison with the Generic Extractor 72</li>

    </ul>

    <p class="text-gray-300">8 Knowledge Soundness of a Fiat-Shamir-transformed Coordinate-Wise Special-Sound Multi-Round Protocol</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>8.1 Analysis of the Abstract Sampling Game</li>

      <li>8.2 The Knowledge Extractor</li>

    </ul>

    <h2 id="sec-11" class="text-2xl font-bold">References</h2>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Due to the significant progress in building quantum computers by various industry leaders, e.g. IBM and Google, there has been a tremendous amount of interest in post-quantum cryptography. This is highly evidenced by the NIST PQC Competition for standardising quantum-safe key encapsulation mechanisms and signatures, where the vast majority of the selected algorithms are based on algebraic lattices. Indeed, not only do the lattice-based constructions offer relatively small key and signature sizes <em>[Bos+18, Duc+18, Fou+20]</em>, but they are also renowned for their very fast implementation <em>[x18, x21]</em>. Consequently, lattices seem to be a natural candidate to build more complex quantum-safe primitives, such as non-interactive zero-knowledge proofs (NIZKs).</p>

    <p class="text-gray-300">The last several years have seen enormous progress in constructing practically efficient NIZKs for lattice relations <em>[x1, x10, x15]</em> which can produce proofs of size a few dozen kilobytes. This has led to rather compact and practical constructions of privacy-preserving primitives, such as ring signatures <em>[x16]</em>, blind signatures <em>[x4]</em> and anonymous credentials <em>[x13, x5]</em>. Unfortunately, the aforementioned protocols suffer the following limitations – both the proof size and verification time are linear in the length of the witness. Hence, for proving more complex statements, efficient NIZKs with succinct proof size and verification complexity are desired, i.e. zero-knowledge succinct non-interactive arguments of knowledge (zk-SNARKs).</p>

    <p class="text-gray-300">Polynomial commitment schemes <em>[x19]</em> have been getting more and more spotlight in the SNARKs community. The main reason is that, in combination with Polynomial Interactive Oracle Proofs (PIOPs) <em>[x6, x11]</em>, this cryptographic primitive can be used to obtain succinct arguments with concrete efficiency (see e.g. <em>[x20, x3, x9]</em>). In a polynomial commitment scheme, one can commit to any polynomial <span class="math">f\\coloneqq\\sum_{i=0}^{d}f_{i}\\mathsf{X}^{i}</span> of bounded degree <span class="math">d</span> over a ring <span class="math">R</span>, and then later prove that <span class="math">f</span> evaluated at some public point <span class="math">u\\in R</span> is equal to a public image <span class="math">z\\in R</span>, i.e.</p>

    <p class="text-gray-300"><span class="math">f(u)=z\\;\\;.</span> (1)</p>

    <p class="text-gray-300">In the context of PIOPs, we require both the proof <span class="math">\\pi</span> and the verification time to be succinct (i.e. polylogarithmic in the degree <span class="math">d</span>), even if the evaluation point is chosen adaptively by a verifier. Further, to obtain a SNARK, we need <span class="math">\\pi</span> to be a proof of knowledge; thus we call such a polynomial commitment extractable.</p>

    <p class="text-gray-300">Recently, various lattice-based polynomial commitments <em>[x2, x27, x16, x12, x14]</em> were introduced, mainly as a direct application of functional commitments <em>[x17]</em> over standard cyclotomic rings <span class="math">R\\coloneqq\\mathbb{Z}_{q}[X]/(X^{N}+1)</span> where <span class="math">N</span> is a power-of-two. Indeed, (1) can be seen as a degree-one multivariate polynomial</p>

    <p class="text-gray-300">\\[ \\begin{bmatrix}1&u&u^{2}&\\cdots&u^{d}\\end{bmatrix}\\begin{bmatrix}f_{0}\\\\ f_{1}\\\\ \\vdots\\\\ f_{d}\\end{bmatrix}=z\\;\\;. \\] (2)</p>

    <p class="text-gray-300">Unfortunately, the aforementioned constructions suffer several limitations when applied in the context of PIOPs. Firstly, succinct verification requires a preprocessing step, meaning that the evaluation point <span class="math">u</span> must be known when public parameters are generated and cannot be chosen</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">commit time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">prover time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">verifier time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">crs size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">commitment size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">asymptotic proof size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">commitment size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">concrete proof size</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Construction 1 (Section 5.2)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(d2)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(d)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log d)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(d2)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log d)</td>

            <td class="px-3 py-2 border-b border-gray-700">480 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">105MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Construction 2 (Section 5.3)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(d2)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(d)</td>

            <td class="px-3 py-2 border-b border-gray-700">dO(1/log log d)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(d2)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">dO(1/log log d)</td>

            <td class="px-3 py-2 border-b border-gray-700">209 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">3MB</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Efficiency overview of our polynomial commitment scheme. In this setting, we commit to polynomials of degree at most  <span class="math">d</span>  over the ring  <span class="math">R \\coloneqq \\mathbb{Z}_q[X] / (X^N + 1)</span> . We count the runtime (resp. sizes) in the number of ring operations (resp. elements), which take time (resp. size) polylog(d) each. For clarity, we ignore the terms related to the security parameter  <span class="math">\\lambda</span> . When computing concrete proof sizes, we set  <span class="math">\\lambda = 128</span>  and  <span class="math">d = 2^{20}</span> . We also include the Fiat-Shamir loss of  <span class="math">Q = 2^{64}</span>  random oracle queries.</p>

    <p class="text-gray-300">adaptively. Further, only [ACLMT22; BCFL22] offer extractable polynomial commitments which unfortunately suffer from the following limitations: (i) they rely on a knowledge assumption, which now seems to be at least "morally" broken [WW23a], (ii) message space can only consist of short vectors, and (iii) they only support linear functions with short coefficients. This makes proving relations as in (2) cumbersome for large degrees  <span class="math">d</span> . Even though one of the issues was circumvented by a promising recent work from Wee and Wu [WW23b], which allows committing to vectors of arbitrarily large coefficients, their knowledge soundness analysis is left for future work. Therefore, constructing extractable polynomial commitments with succinct verification from lattices still remains an open problem.</p>

    <p class="text-gray-300">In this work we propose a lattice-based PIOP-friendly polynomial commitment scheme. Concretely, our construction supports committing to arbitrary polynomials  <span class="math">f \\in R[\\mathsf{X}]</span>  of bounded degree  <span class="math">d</span>  over  <span class="math">R</span> , and proving evaluations for any point  <span class="math">u \\in R</span>  with no preprocessing necessary. Extractability holds in the random oracle model via the Fiat-Shamir transformation [FS86] under a variant of the BASIS assumption defined recently by Wee and Wu [WW23b], which we call PowerBASIS.</p>

    <p class="text-gray-300">At the core of our construction lie two split-and-fold interactive protocols for proving polynomial evaluations. The first one, which brings resemblance to lattice Bulletproofs [BLNS20; ACK21; AL21], enjoys proof size and verification complexity polylogarithmic in the degree  <span class="math">d</span> . Unfortunately, due to certain restrictions on the challenge space, which are inherited from the aforementioned works, the protocol achieves only  <span class="math">1 / \\mathrm{poly}(\\lambda)</span>  knowledge soundness error. Even though soundness can be amplified via parallel repetition [AF22] for the interactive protocol, this is not necessarily the case in the non-interactive setting when applying the Fiat-Shamir transformation, as discussed in [AFK22]. To this end, we propose the second protocol, which achieves negligible soundness error in one-shot at the cost of quasi-polylogarithmic  <span class="math">d^{O(1 / \\log \\log d)}</span>  proof size and verification runtime. Furthermore, the non-interactive version of the scheme can be proven secure in the random oracle using the framework by Attema et al. [AFK22]. Last but not least, we show how to upgrade the evaluation proof to achieve zero-knowledge using the standard Fiat-Shamir-with-aborts paradigm [Lyu09; Lyu12; BTT22]. We summarise the efficiency of both schemes in Table 1.</p>

    <p class="text-gray-300">As a direct application, we combine our polynomial commitment scheme, which includes batch evaluation proofs, with the Marlin Polynomial IOP [CHMMVW20] to obtain a trusted-setup (zero-knowledge) succinct non-interactive arguments of knowledge for Rank-1 Constraint System (R1CS).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">assumptions</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">TP NI</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">concrete proof size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">prover verifier</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">crs proof</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[BBCPGL18]</td>

            <td class="px-3 py-2 border-b border-gray-700">(M-)SIS, RO</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(√ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[BLNS20]</td>

            <td class="px-3 py-2 border-b border-gray-700">(M-)SIS, RO</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓc)</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Lattice Bulletproofs [BLNS20; AL21; ACK21]</td>

            <td class="px-3 py-2 border-b border-gray-700">M-SIS</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[BF22]</td>

            <td class="px-3 py-2 border-b border-gray-700">(M)-SIS, RO</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[NS22]</td>

            <td class="px-3 py-2 border-b border-gray-700">M-SIS, RO</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(√ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">6MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Labrador [BS23]</td>

            <td class="px-3 py-2 border-b border-gray-700">M-SIS, RO</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">49KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[ACLMT22]</td>

            <td class="px-3 py-2 border-b border-gray-700">Knowledge k-M-SIS</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ4 log ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ2)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">261MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This Work</td>

            <td class="px-3 py-2 border-b border-gray-700">PowerBASIS, RO</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ2)</td>

            <td class="px-3 py-2 border-b border-gray-700">ℓO(1/ log log ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ2)</td>

            <td class="px-3 py-2 border-b border-gray-700">ℓO(1/ log log ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">17MB</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: Comparison of lattice-based publicly verifiable proof systems for NP relations of size  <span class="math">\\ell</span>  with sublinear communication complexity. We count the runtime (resp. sizes) in the number of ring operations (resp. elements), which take time (resp. size) polylog(d) each, and we ignore the terms related polynomially in the security parameter  <span class="math">\\lambda</span> . We exclude the preprocessing step from the verifier runtime. Here  <span class="math">0 &amp;lt; \\varepsilon &amp;lt; 1</span>  is a constant. The "TP" column specifies whether the scheme has transparent setup, and "NI" means whether the protocol can be made non-interactive with negligible soundness error. The concrete proof sizes correspond to proving R1CS with  <span class="math">\\ell = 2^{20}</span>  as reported in the respective works.</p>

    <p class="text-gray-300">Practically, for  <span class="math">\\approx 2^{20}</span>  constraints our construction achieves proofs of size 17MB, which is around 15X smaller than the only concretely instantiated lattice-based proof system with succinct verification by Albrecht et al. [ACLMT22]. Moreover, we obtain a square-root improvement over [ACLMT22] in terms of the prover runtime. In comparison with other lattice-based arguments which admit linear verification time, our scheme produces comparable proofs to the recent "square-root" protocol by Nguyen and Seiler [NS22] for bigger R1CS instances, such as  <span class="math">2^{30}</span>  constraints, but still more than two orders of magnitude larger than the current state-of-the-art by Beullens and Seiler [BS23]. We refer to Table 2 for full comparison and Section 6 for more details on sizes.</p>

    <p class="text-gray-300">We provide a brief overview of our techniques. Let  <span class="math">\\lambda</span>  be a security parameter,  <span class="math">q</span>  be an odd prime, and  <span class="math">N</span>  be a power-of-two. Define the polynomial rings  <span class="math">\\mathcal{R} \\coloneqq \\mathbb{Z}[X] / (X^N + 1)</span>  and  <span class="math">\\mathcal{R}_q \\coloneqq \\mathbb{Z}_q[X] / (X^N + 1)</span> . Let  <span class="math">\\mathcal{R}_q^\\times</span>  be the set of invertible elements in  <span class="math">\\mathcal{R}_q</span> . For a base  <span class="math">\\delta \\geq 2</span>  and  <span class="math">n \\geq 1</span> , we define the gadget matrix as  <span class="math">\\mathbf{G}_n \\coloneqq \\left[ \\begin{array}{cccc} 1 &amp;amp; \\delta &amp;amp; \\dots &amp;amp; \\delta^{\\tilde{q}} \\end{array} \\right] \\otimes \\mathbf{I}_n \\in \\mathcal{R}_q^{n \\times n\\tilde{q}}</span>  where  <span class="math">\\tilde{q} \\coloneqq \\lfloor \\log_{\\delta} q \\rfloor + 1</span> . For simplicity, we omit the subscript  <span class="math">n</span>  and write  <span class="math">\\mathbf{G} \\coloneqq \\mathbf{G}_n</span>  when it is clear from the context. Further, for a fixed matrix  <span class="math">\\mathbf{T} \\in \\mathcal{R}_q^{n \\times k}</span>  and matrix  <span class="math">\\mathbf{A} \\in \\mathcal{R}_q^{n \\times m}</span> , we denote by  <span class="math">\\mathbf{S} \\gets \\mathbf{A}_{\\sigma}^{-1}(\\mathbf{T})</span>  sampling  <span class="math">\\mathbf{S} \\in \\mathcal{R}_q^{m \\times k}</span>  from the discrete Gaussian distribution with Gaussian parameter  <span class="math">\\sigma &amp;gt; 0</span>  conditioned on  <span class="math">\\mathbf{A}\\mathbf{S} = \\mathbf{T}</span>  over  <span class="math">\\mathcal{R}_q</span> .</p>

    <p class="text-gray-300">Until lately, lattice-based commitment schemes were split into two disjoint classes: Hashed-Message Commitments [Ajt96] and Unbounded-Message Commitments [BDLOP18]. The former one has the property that the sizes of commitments are almost independent of the sizes of the committed values, and thus the commitments are compressing. This comes at the cost of the restricted message space</p>

    <p class="text-gray-300">being only vectors of small norm. On the other hand, the main characteristic of the latter class is the unbounded message space, but the commitment size is linear in the size of the message.</p>

    <p class="text-gray-300">Recently, Wee and Wu [WW23b] proposed the first lattice-based commitment scheme which is compressing, and simultaneously supports arbitrarily large messages over <span class="math">\\mathcal{R}_q</span>. The downside of the construction is a requirement on having a trusted setup, which was not necessary in prior works, as well as the quadratic committing time in the message length. In the following, we describe the main intuition behind the construction by Wee and Wu. To this end, we recall the BASIS assumption², which lies at the core of the binding property of the commitment.</p>

    <p class="text-gray-300"><strong>BASIS assumption.</strong> As in the (Module-)SIS problem [LS15], the adversary's final goal is to find a non-zero vector <span class="math">\\mathbf{s}</span> of small norm such that <span class="math">\\mathbf{A}\\mathbf{s} = \\mathbf{0}</span> for a uniformly random matrix <span class="math">\\mathbf{A} \\gets \\mathcal{R}_q^{n \\times m}</span>. However, in the BASIS setting the adversary is given more information. Namely, let <span class="math">(\\mathbf{B}, \\mathbf{aux}) \\gets \\mathsf{Samp}(\\mathbf{A})</span> be an efficient algorithm, which given matrix <span class="math">\\mathbf{A}</span> as input, outputs another matrix <span class="math">\\mathbf{B} \\in \\mathcal{R}_q^{n&#x27; \\times m&#x27;}</span> along with some auxiliary information <span class="math">\\mathbf{aux}</span>. Then, in addition to the challenge matrix <span class="math">\\mathbf{A}</span>, the adversary is given a tuple <span class="math">(\\mathbf{B}, \\mathbf{aux}, \\mathbf{T})</span>, where <span class="math">\\mathbf{T}</span> is a trapdoor³ for <span class="math">\\mathbf{B}</span>. In particular, <span class="math">\\mathbf{T}</span> can be used to efficiently emulate sampling from <span class="math">\\mathbf{B}_{\\sigma}^{-1}(\\mathbf{t})</span> for any image <span class="math">\\mathbf{t} \\in \\mathcal{R}_q^{n&#x27;}</span> under certain conditions on the parameter <span class="math">\\sigma &amp;gt; 0</span>.</p>

    <p class="text-gray-300">Note that hardness of the BASIS assumption heavily depends on the Samp algorithm. For instance, if <span class="math">\\mathsf{Samp}(\\mathbf{A})</span> is an identity function and simply outputs <span class="math">\\mathbf{B} \\coloneqq \\mathbf{A}</span>, then using the trapdoor <span class="math">\\mathbf{T}</span> we can find a short non-zero solution to <span class="math">\\mathbf{A}</span> by sampling <span class="math">\\mathbf{s} \\gets \\mathbf{B}_{\\sigma}^{-1}(\\mathbf{0})</span>. In this paper, we consider the following three instantiations of the Samp algorithm:</p>

    <p class="text-gray-300"><strong>StructBASIS:</strong> The sampling algorithm <span class="math">\\mathsf{Samp}(\\mathbf{A})</span> first generates a row <span class="math">\\mathbf{a}^{\\intercal} \\gets \\mathcal{R}_q^{\\ell}</span> and sets</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{A}^{\\star} := \\begin{bmatrix} \\mathbf{a}^{\\intercal} \\\\ \\mathbf{A} \\end{bmatrix} \\in \\mathcal{R}_{q}^{(n+1) \\times \\ell}. \\tag{3}</span></div>

    <p class="text-gray-300">Next, it samples square matrices <span class="math">\\mathbf{W}_1, \\ldots, \\mathbf{W}_\\ell \\in \\mathcal{R}_q^{(n+1) \\times (n+1)}</span> and outputs</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{B}_{\\ell} := \\begin{bmatrix} \\mathbf{W}_1 \\mathbf{A}^{\\star} &amp;amp; &amp;amp; -\\mathbf{G}_{n+1} \\\\ &amp;amp; \\ddots &amp;amp; \\\\ &amp;amp; &amp;amp; \\mathbf{W}_\\ell \\mathbf{A}^{\\star} \\end{bmatrix} \\quad \\text{and} \\quad \\mathbf{aux} := (\\mathbf{W}_1, \\ldots, \\mathbf{W}_\\ell).</span></div>

    <p class="text-gray-300"><strong>PowerBASIS:</strong> <span class="math">\\mathsf{Samp}(\\mathbf{A})</span> generates a row <span class="math">\\mathbf{a}^{\\intercal} \\gets \\mathcal{R}_q^{\\ell}</span> and sets <span class="math">\\mathbf{A}^{\\star}</span> as in (3). Then, it samples a single square matrix <span class="math">\\mathbf{W} \\gets \\mathcal{R}_q^{(n+1) \\times (n+1)}</span> and outputs</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{B}_{\\ell} := \\begin{bmatrix} \\mathbf{W}^0 \\mathbf{A}^{\\star} &amp;amp; &amp;amp; -\\mathbf{G}_{n+1} \\\\ &amp;amp; \\ddots &amp;amp; \\\\ &amp;amp; &amp;amp; \\mathbf{W}^{\\ell-1} \\mathbf{A}^{\\star} \\end{bmatrix} \\quad \\text{and} \\quad \\mathbf{aux} := \\mathbf{W}. \\tag{4}</span></div>

    <p class="text-gray-300">²BASIS stands for Basis-Augmented Shortest Integer Solution.</p>

    <p class="text-gray-300">³In [WW23b], the trapdoor <span class="math">\\mathbf{T}</span> is generated by sampling <span class="math">\\mathbf{T} \\gets \\mathbf{B}_{\\sigma}^{-1}(\\mathbf{G})</span>. Since the matrix <span class="math">\\mathbf{T} \\in \\mathcal{R}_q^{m&#x27; \\times n&#x27; \\bar{q}}</span> is short and <span class="math">\\mathbf{BT} = \\mathbf{G}</span>, it can be used in Micciancio-Peikert trapdoor sampling [MP12] to efficiently generate preimages under <span class="math">\\mathbf{B}</span>.</p>

    <p class="text-gray-300">■ PRISIS⁴: Samp(A) samples a row <span class="math">\\mathbf{a}^{\\intercal} \\gets \\mathcal{R}_q^\\ell</span> and sets <span class="math">\\mathbf{A}^{\\star}</span> as in (3). Then, it samples a uniformly random polynomial <span class="math">w \\gets \\mathcal{R}_q</span> and outputs</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{B}_\\ell := \\begin{bmatrix} w^0 \\mathbf{A}^{\\star} &amp;amp; &amp;amp; -\\mathbf{G}_{n+1} \\\\ &amp;amp; \\ddots &amp;amp; \\vdots \\\\ &amp;amp; &amp;amp; w^{\\ell-1} \\mathbf{A}^{\\star} \\\\ \\end{bmatrix} \\quad \\text{and} \\quad \\mathbf{aux} := w.</span></div>

    <p class="text-gray-300">Observe that the only difference between these variants is how the square matrices <span class="math">\\mathbf{W}_1, \\ldots, \\mathbf{W}_\\ell</span> are generated. For StructBASIS they are picked independently and uniformly at random, while for PowerBASIS (resp. PRISIS) each matrix <span class="math">\\mathbf{W}_i</span> is defined as <span class="math">\\mathbf{W}_i := \\mathbf{W}^{i-1}</span> for <span class="math">i \\in [\\ell]</span>, where <span class="math">\\mathbf{W} \\gets \\mathcal{R}_q^{(n+1) \\times (n+1)}</span> (resp. <span class="math">\\mathbf{W} := w \\cdot \\mathbf{I}_{n+1}</span> for <span class="math">w \\gets \\mathcal{R}_q</span>). Not to mention the fact that the functional commitment from [WW23b] can be built on top of all three BASIS instantiations⁵.</p>

    <p class="text-gray-300">In this work, we analyse hardness of the three newly introduced assumptions for <span class="math">\\ell = 2</span>. Concretely, we prove that under a certain parameter selection</p>

    <div class="my-4 text-center"><span class="math-block">\\text{StructBASIS} \\xleftarrow{\\text{Lemma 3.5}} \\text{PowerBASIS} \\quad \\text{and} \\quad \\text{PRISIS} \\xrightarrow{\\text{lemma 3.6}} \\text{MSIS}.</span></div>

    <p class="text-gray-300">Unfortunately, the techniques do not translate well for larger values of <span class="math">\\ell</span>, as we argue in Section 3.2. Therefore, hardness of the BASIS assumption for <span class="math">\\ell &amp;gt; 2</span> is left as an open problem.</p>

    <p class="text-gray-300"><strong>Commitment construction.</strong> We describe a commitment scheme based on the PowerBASIS assumption. Trivial modifications can be made in order to make the scheme secure under the StructBASIS or PRISIS assumptions.</p>

    <p class="text-gray-300">Consider a message space of arbitrary vectors in <span class="math">\\mathcal{R}_q^{d+1}</span> of length <span class="math">d+1</span>. The setup algorithm generates a (pseudo-)random matrix <span class="math">\\mathbf{A} \\in \\mathcal{R}_q^{n \\times m}</span>, along with a uniformly random invertible matrix <span class="math">\\mathbf{W} \\in \\mathcal{R}_q^{n \\times n}</span>. Further, it computes a trapdoor <span class="math">\\mathbf{T}</span> for the matrix</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{B} := \\begin{bmatrix} \\mathbf{W}^0 \\mathbf{A} &amp;amp; &amp;amp; -\\mathbf{G} \\\\ &amp;amp; \\ddots &amp;amp; \\vdots \\\\ &amp;amp; &amp;amp; \\mathbf{W}^d \\mathbf{A} \\\\ \\end{bmatrix} \\quad \\text{. \\tag{5}}</span></div>

    <p class="text-gray-300">Then, the common reference string is <span class="math">\\mathbf{crs} := (\\mathbf{A}, \\mathbf{W}, \\mathbf{T})</span>.</p>

    <p class="text-gray-300">In order to commit to a vector <span class="math">\\mathbf{f} = (f_0, f_1, \\ldots, f_d) \\in \\mathcal{R}_q^{d+1}</span>, one uses the trapdoor <span class="math">\\mathbf{T}</span> to sample short <span class="math">\\mathbf{s}_0, \\ldots, \\mathbf{s}_d \\in \\mathcal{R}_q^m</span> and <span class="math">\\hat{\\mathbf{t}} \\in \\mathcal{R}_q^{n\\tilde{q}}</span> as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{bmatrix} \\mathbf{s}_0 \\\\ \\vdots \\\\ \\mathbf{s}_d \\\\ \\hat{\\mathbf{t}} \\end{bmatrix} \\gets \\mathbf{B}_{\\sigma}^{-1} \\left( \\begin{bmatrix} -f_0 \\mathbf{W}^0 \\mathbf{e}_1 \\\\ -f_1 \\mathbf{W}^1 \\mathbf{e}_1 \\\\ \\vdots \\\\ -f_d \\mathbf{W}^d \\mathbf{e}_1 \\end{bmatrix} \\right)</span></div>

    <p class="text-gray-300">⁴The name stands for Power-Ring-BASIS.</p>

    <p class="text-gray-300">⁵A reader familiar with the work of [WW23b] can notice a difference between StructBASIS and the original BASIS_{struct} from [WW23b, Assumption 3.3]. Namely, the latter one directly sets the matrix <span class="math">\\mathbf{A}^{\\star} := \\mathbf{A}</span> without appending an additional row <span class="math">\\mathbf{a}^{\\intercal}</span> at the top (as in BASIS_{rand} [WW23b, Assumption 3.3]). Note that it is possible to build a commitment scheme based on such a variant, as described in [WW23b, Section 4], but this would increase the commitment, as well the opening sizes, by a factor of <span class="math">n\\tilde{q}</span>. Hence, for efficiency we consider the modified version of BASIS_{struct} as presented here.</p>

    <p class="text-gray-300">where <span class="math">\\mathbf{e}_1 \\coloneqq (1,0,\\ldots,0)^\\top \\in \\mathcal{R}_q^n</span>. The commitment becomes <span class="math">\\mathbf{t} \\coloneqq \\mathbf{G}\\hat{\\mathbf{t}}</span>, and the opening consists of <span class="math">(\\mathbf{s}_i)_{i \\in [0,d]}</span>. The opening algorithm, given the common reference string <span class="math">\\mathsf{crs}</span>, commitment <span class="math">\\mathbf{t} \\in \\mathcal{R}_q^n</span> and openings <span class="math">(\\mathbf{s}_i)_{i \\in [0,d]}</span> as input, checks whether for all <span class="math">i = 0,1,\\ldots,d</span>:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{A} \\mathbf{s}_i + f_i \\mathbf{e}_1 = \\mathbf{W}^{-i} \\mathbf{t} \\quad \\text{and} \\quad \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}_i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">for some norm parameter <span class="math">\\beta &amp;gt; 0</span>.</p>

    <p class="text-gray-300"><strong>Security properties.</strong> In this paper, we consider the notion of <em>relaxed binding</em> [ALS20]. Namely, we say that a relaxed opening for a commitment <span class="math">\\mathbf{t}</span> consists of (i) a vector of openings <span class="math">\\mathbf{s} = (\\mathbf{s}_0, \\dots, \\mathbf{s}_d)</span>, (ii) a message <span class="math">\\mathbf{f} = (f_0, \\dots, f_d) \\in \\mathcal{R}_q^{d+1}</span>, and (iii) a vector of relaxation factors <span class="math">\\mathbf{c} := (c_0, \\dots, c_d) \\in \\mathcal{R}_q^{d+1}</span>, which together satisfy:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{A} \\mathbf{s}_i + f_i \\mathbf{e}_1 = \\mathbf{W}^{-i} \\mathbf{t}, \\quad \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_i \\cdot \\mathbf{s}_i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta, \\quad \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_1 \\leq \\kappa \\quad \\text{and} \\quad c_i \\in \\mathcal{R}_q^\\times</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">for <span class="math">i = 0,1,\\ldots,d</span> and some <span class="math">\\kappa \\geq 1</span>. In particular, vectors <span class="math">\\mathbf{s}_i</span> do not need to be short.</p>

    <p class="text-gray-300">Now, we show that the commitment scheme is binding w.r.t. relaxed openings under the PowerBASIS assumption. Indeed, let <span class="math">\\mathcal{B}</span> be the following adversary for the PowerBASIS security game, which is given as input a tuple <span class="math">(\\mathbf{A}, \\mathbf{B}, \\mathbf{W}, \\mathbf{T})</span> from the challenger, where <span class="math">\\mathbf{B}</span> is defined as in (4) for <span class="math">\\ell = d + 1</span>, and <span class="math">\\mathbf{A}^{\\star}</span> is constructed as in (3). First, <span class="math">\\mathcal{B}</span> aborts if <span class="math">\\mathbf{W}</span> is not invertible<span class="math">^6</span>. Otherwise, <span class="math">\\mathcal{B}</span> passes <span class="math">\\mathsf{crs} := (\\mathbf{A}^{\\star}, \\mathbf{W}, \\mathbf{T})</span> to the adversary <span class="math">\\mathcal{A}</span> against the relaxed binding game. Suppose <span class="math">\\mathcal{A}</span> comes up with two relaxed openings <span class="math">(\\mathbf{s}, \\mathbf{f}, \\mathbf{c})</span> and <span class="math">(\\mathbf{s}&#x27;, \\mathbf{f}&#x27;, \\mathbf{c}&#x27;)</span> for the same commitment <span class="math">\\mathbf{t}</span> and <span class="math">\\mathbf{f} \\neq \\mathbf{f}&#x27;</span>. Thus, for some index <span class="math">i</span> we have <span class="math">f_i \\neq f_i&#x27;</span>. Then, by definition of relaxed openings we have</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{A}^{\\star} (\\mathbf{s}_i - \\mathbf{s}_i&#x27;) + (f_i - f_i&#x27;) \\mathbf{e}_1 = \\mathbf{0}.</span></div>

    <p class="text-gray-300">Since <span class="math">f_i - f_i&#x27; \\neq 0</span>, we must have <span class="math">\\bar{\\mathbf{s}}_i \\coloneqq \\mathbf{s}_i - \\mathbf{s}_i&#x27; \\neq 0</span>. Hence by definition of <span class="math">\\mathbf{A}^{\\star}</span>, <span class="math">\\bar{\\mathbf{s}}_i</span> is a non-zero solution for the matrix <span class="math">\\mathbf{A}</span>, but not necessarily a short one. To conclude the proof, note that <span class="math">c_i c_i&#x27; \\bar{\\mathbf{s}}_i</span> is still a non-zero vector, due to the invertibility property of <span class="math">c_i, c_i&#x27;</span>, and at the same time:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_i c_i' \\bar{\\mathbf{s}}_i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_i' (c_i \\mathbf{s}_i) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_i (c_i' \\mathbf{s}_i') \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2\\kappa\\beta. \\tag{6}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Thus, <span class="math">c_i c_i&#x27; \\bar{\\mathbf{s}}_i</span> is a valid solution for the PowerBASIS problem.</p>

    <p class="text-gray-300">Finally, the statistical hiding property is directly inherited from the original construction of the BASIS commitment by Wee and Wu [WW23b].</p>

    <h2 id="sec-15" class="text-2xl font-bold">1.4 Framework for Proving Polynomial Evaluations</h2>

    <p class="text-gray-300">We use the construction above to build our polynomial commitment scheme. Namely, given a polynomial <span class="math">f \\in \\mathcal{R}_q[\\mathsf{X}]</span> of degree at most <span class="math">d</span> over <span class="math">\\mathcal{R}_q</span>, we commit to <span class="math">f</span> by committing to its coefficient vector <span class="math">\\mathbf{f} = (f_0, f_1, \\ldots, f_d) \\in \\mathcal{R}_q^{d+1}</span>, as described in Section 1.3, to obtain a commitment <span class="math">\\mathbf{t} \\in \\mathcal{R}_q^n</span> along with a short opening <span class="math">(\\mathbf{s}_0, \\mathbf{s}_1, \\ldots, \\mathbf{s}_d)</span>, where each <span class="math">\\mathbf{s}_i \\in \\mathcal{R}_q^m</span>.</p>

    <p class="text-gray-300"><span class="math">^6</span>Unlike in PowerBASIS, the commitment construction requires that matrix <span class="math">\\mathbf{W}</span> is invertible. However, by carefully choosing parameters <span class="math">q</span> and <span class="math">N</span>, one can argue that the probability of <span class="math">\\mathbf{W} \\gets \\mathcal{R}_q^{n \\times n}</span> not being invertible is negligible (c.f. [BTT22, Appendix C.3] and [EZSLL19, Appendix C]).</p>

    <p class="text-gray-300">Prover  <span class="math">\\mathcal{P}(\\mathrm{crs},(\\mathbf{t},u,z),(f,(\\mathbf{s}_i)_{0\\leq i\\leq d}))</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{F}(\\mathsf{X}) = \\sum_{t = 1}^{k}f_{t}(\\mathsf{X}^{k})\\mathsf{X}^{t - 1}</span></p>

    <p class="text-gray-300"><span class="math">z_{t} = f_{t}(u^{k})</span>  for  <span class="math">t = 1,\\ldots k</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{z}_1,\\ldots ,\\mathbf{z}_k</span> <span class="math">\\alpha_{1},\\ldots ,\\alpha_{k}</span> <span class="math">(\\alpha_{1},\\dots ,\\alpha_{k})\\gets \\mathcal{C}\\subseteq \\mathcal{R}_{q}^{k}</span></p>

    <p class="text-gray-300"><span class="math">g(\\mathsf{X}) = \\sum_{t = 1}^{k}\\alpha_{t}f_{t}(\\mathsf{X})</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{z}_i = \\sum_{t = 1}^k\\alpha_t\\mathbf{s}_{ki + t - 1}</span>  for  <span class="math">i = 0,\\dots ,d^{\\prime}</span> <span class="math">\\frac{g,(\\mathbf{z}_i)_{i\\in[0,d^{\\prime}]}}{}</span></p>

    <p class="text-gray-300">Check:</p>

    <p class="text-gray-300"><span class="math">\\sum_{t = 1}^{k}z_{t}u^{t - 1} = z</span></p>

    <p class="text-gray-300"><span class="math">\\sum_{t = 1}^{k}\\alpha_{t}z_{t} = g(u^{k})</span></p>

    <p class="text-gray-300">For  <span class="math">i = 0,1,\\ldots ,d^{\\prime}</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{A}\\mathbf{z}_i + g_i\\mathbf{e}_1 = (\\mathbf{W}^k)^{-i}\\left(\\sum_{i = 1}^k\\alpha_i\\mathbf{W}^{-(i - 1)}\\right)\\mathbf{t}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z}_i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\mathrm{w}\\beta$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 1: Compressed  <span class="math">\\Sigma</span> -protocol for the relation  <span class="math">\\mathsf{R}_{d,\\beta}</span>  from (7). Here,  <span class="math">\\mathsf{crs} = (\\mathbf{A},\\mathbf{W},\\mathbf{T})</span>  is the common reference string for our polynomial commitment scheme and  <span class="math">d + 1 = k^h</span> . We denote  <span class="math">d&#x27; := (d + 1)/k - 1</span>  to be degree of the polynomial  <span class="math">g</span> , and  $\\mathbf{w} := \\max_{\\boldsymbol{\\alpha} \\in \\mathcal{C}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\boldsymbol{\\alpha} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_1$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">An essential property of polynomial commitments is being able to prove that the committed polynomial was evaluated correctly, i.e.  <span class="math">f(u) = z</span>  for public  <span class="math">u</span>  and  <span class="math">z</span>  in  <span class="math">\\mathcal{R}_q</span> . In the setting of our commitment scheme, we are interested in the following ternary relation:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf {R} _ {d, \\beta} := \\left\\{\\left(\\left(\\mathbf {A}, \\mathbf {W}, \\mathbf {T}\\right), (\\mathbf {t}, u, z), \\left(f, \\left(\\mathbf {s} _ {i}\\right) _ {0 \\leq i \\leq d}\\right)\\right) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\forall 0 \\leq i \\leq d, \\mathbf {A} \\mathbf {s} _ {i} + f _ {i} \\mathbf {e} _ {1} = \\mathbf {W} ^ {- i} \\mathbf {t} \\wedge \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {s} _ {i} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta \\\\ \\wedge f (u) = z \\end{array} \\right. \\right\\}. \\tag {7}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">The key ingredient for proving such relations efficiently will be the compressed  <span class="math">\\Sigma</span> -protocol in Figure 1, which we will use recursively.</p>

    <p class="text-gray-300">We take inspiration from a common split-and-fold technique used by prior works, e.g. FRI [BBHR19] and DARK [BFS20]. Concretely, take  <span class="math">k \\in \\mathbb{N}</span>  and suppose  <span class="math">d + 1 = k^h</span>  for some  <span class="math">h \\in \\mathbb{N}</span> . Let us write the polynomial  <span class="math">f(\\mathsf{X}) = \\sum_{i=0}^{d} f_i \\mathsf{X}^i</span>  as</p>

    <div class="my-4 text-center"><span class="math-block">f (\\mathsf {X}) = \\sum_ {t = 1} ^ {k} f _ {t} (\\mathsf {X} ^ {k}) \\mathsf {X} ^ {t - 1}, \\quad \\text {w h e r e} f _ {t} (\\mathsf {X}) := \\sum_ {i = 0} ^ {\\frac {d + 1}{k} - 1} f _ {k i + t - 1} \\mathsf {X} ^ {i} \\quad \\text {f o r} t = 1, 2, \\ldots , k.</span></div>

    <p class="text-gray-300">Then, we want to prove that <span class="math">f(u) = \\sum_{t=1}^{k} f_t(u^k) u^{t-1} = z</span>. To this end, we let the prover send these partial evaluations <span class="math">z_t := f_t(u^k)</span> for <span class="math">t \\in [k]</span>, and the verifier manually checks whether</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{t=1}^{k} z_t u^{t-1} = z \\quad . \\tag{8}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Further, the verifier returns a challenge <span class="math">\\alpha := (\\alpha_1, \\ldots, \\alpha_k)</span> from a challenge space <span class="math">\\mathcal{C} \\subseteq \\mathcal{R}_q^k</span>. We denote $\\mathrm{w} := \\max_{\\boldsymbol{\\alpha} \\in \\mathcal{C}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\boldsymbol{\\alpha} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_1<span class="math">. Later we will discuss concrete instantiations for </span>\\mathcal{C}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Now, consider the folded polynomial <span class="math">g(\\mathsf{X}) = \\sum_{t=1}^{k} \\alpha_t f_t(\\mathsf{X})</span> which is of degree at most <span class="math">d&#x27; := (d+1)/k-1 = k^{h-1}-1</span>. The crucial observation here is that using the structure of the PowerBASIS commitment from Section 1.3 we get for every <span class="math">i = 0,1,\\ldots,d&#x27;</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} (\\mathbf{W}^k)^{-i} \\left(\\sum_{t=1}^{k} \\alpha_t \\mathbf{W}^{-(t-1)}\\right) \\mathbf{t} &amp;amp;= \\sum_{t=1}^{k} \\alpha_t \\mathbf{W}^{-(ki+t-1)} \\mathbf{t} \\\\ &amp;amp;= \\mathbf{A} \\left(\\sum_{t=1}^{k} \\alpha_i \\mathbf{s}_{ki+t-1}\\right) + \\left(\\sum_{t=1}^{k} \\alpha_i f_{ki+t-1}\\right) \\mathbf{e}_1 \\\\ &amp;amp;= \\mathbf{A} \\mathbf{z}_i + g_i \\mathbf{e}_1 \\end{aligned}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">\\mathbf{z}_i := \\sum_{t=1}^{k} \\alpha_t \\mathbf{s}_{ki+t-1}</span> satisfies $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z}_i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta' := \\mathrm{w} \\beta<span class="math">. In other words, </span>\\mathbf{t}' := (\\sum_{t=1}^{k} \\alpha_t \\mathbf{W}^{-(t-1)}) \\cdot \\mathbf{t}<span class="math">, which can be computed by the verifier in time </span>O(k)<span class="math">, is a commitment to the polynomial </span>g<span class="math"> with the opening </span>(\\mathbf{z}_j)_{j \\in [0,d']}<span class="math"> w.r.t. the new common reference string </span>\\mathrm{crs}' := (\\mathbf{A}, \\mathbf{W}^k, \\mathbf{T})<span class="math">. Further, by definition of </span>g$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">g(u^k) = \\sum_{t=1}^{k} \\alpha_t f_t(u^k) = \\sum_{t=1}^{k} \\alpha_t z_t \\quad .</span></div>

    <p class="text-gray-300">Thus, we can conclude that:</p>

    <div class="my-4 text-center"><span class="math-block">\\left((\\mathbf{A}, \\mathbf{W}^k, \\mathbf{T}), \\left(\\sum_{t=1}^{k} \\alpha_t \\mathbf{W}^{-(t-1)} \\mathbf{t}, u^k, \\sum_{t=1}^{k} \\alpha_t z_t\\right), \\left(g, (\\mathbf{z}_i)_{i \\in [0,d&#x27;]}\\right)\\right) \\in \\mathsf{R}_{d&#x27;, \\mathrm{w} \\beta} \\quad . \\tag{9}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In our <span class="math">\\Sigma</span>-protocol, the prover directly outputs <span class="math">\\left(g, (\\mathbf{z}_i)_{j \\in [0,d&#x27;]}\\right)</span> to the verifier, who checks Equations (8) and (9). To achieve succinct proofs and verification, we let the prover recursively run the <span class="math">\\Sigma</span>-protocol on the new instance tuple (9) until the degree of the folded polynomial is zero<span class="math">^9</span>. Overall, the protocol has <span class="math">2h + 1</span> rounds and the last prover message is a pair of the form <span class="math">(g, \\mathbf{z}) \\in \\mathcal{R}_q \\times \\mathcal{R}_q^m</span>, where $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta' := \\mathrm{w}^h \\beta<span class="math">. Performance-wise (excluding the </span>\\mathrm{poly}(\\lambda)<span class="math"> factors), the prover sends </span>O(hk)<span class="math"> elements in </span>\\mathcal{R}_q<span class="math">, while the verifier makes in total </span>O(hk)<span class="math"> operations in </span>\\mathcal{R}_q$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We now focus on knowledge soundness. As common in the lattice setting, we aim to extract a witness with respect to the relaxed relation:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{\\mathsf{R}}_{d,\\beta,\\kappa} := \\left\\{ \\left. \\left((\\mathbf{A}, \\mathbf{W}, \\mathbf{T}), (\\mathbf{t}, u, z), (f, (\\mathbf{s}_i)_{0 \\leq i \\leq d}, (c_i)_{0 \\leq i \\leq d})\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\forall 0 \\leq i \\leq d, \\mathbf{A} \\mathbf{s}_i + f_i \\mathbf{e}_1 = \\mathbf{W}^{-i} \\mathbf{t} \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\wedge \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_i \\cdot \\mathbf{s}_i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta \\wedge \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_1 \\leq \\kappa \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\wedge c_i \\in \\mathcal{R}_q^\\times \\wedge f(u) = z \\end{array} \\right\\} \\quad . $$</p>

    <p class="text-gray-300"><span class="math">^8</span>We note that a similar result could be obtained using PRISIS.</p>

    <p class="text-gray-300"><span class="math">^9</span>For concrete efficiency, it might be more beneficial to apply the protocol recursively until the degree of the folded polynomial is <em>sufficiently</em> small, instead of going down to zero.</p>

    <p class="text-gray-300">In other words, the witness is now a relaxed opening for the commitment <span class="math">\\mathbf{t}</span>. Note that the relation is still meaningful as long as the commitment scheme is binding w.r.t. relaxed openings.</p>

    <p class="text-gray-300">The knowledge extraction strategy for <span class="math">\\tilde{\\mathsf{R}}_{\\beta,\\kappa}</span> will strongly depend on the instantiation of the challenge space <span class="math">\\mathcal{C}</span>. In this work, we consider two variants described below.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">Construction 1: Monomial protocol.</h4>

    <p class="text-gray-300">As the name suggests, we will make use of certain invertibility properties of the set of signed monomials in <span class="math">\\mathcal{R}_{q}</span>, following the approach from lattice Bulletproofs <em>[x1, x2, x3]</em>. Namely, we set <span class="math">(k,h)=(2,\\log(d+1))</span> and define the challenge space</p>

    <p class="text-gray-300"><span class="math">\\mathcal{C}\\coloneqq\\left\\{(1,X^{i}):i\\in\\mathbb{Z}\\right\\}\\subseteq\\mathcal{R}_{q}^{k}\\enspace.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By construction, <span class="math">\\mathrm{w}=2</span> and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2N<span class="math">. Now, we show that for the challenge space </span>\\mathcal{C}<span class="math"> above, the </span>\\Sigma<span class="math">-protocol in Figure 1 is special sound w.r.t. the relaxed relation </span>\\tilde{\\mathsf{R}}<span class="math">. The methodology can then be extended to show that our recursive protocol is </span>(2,\\ldots,2)$-special sound. Thus, the general parallel repetition results <em>[x1]</em>, as well as security of the Fiat-Shamir transformation in the random oracle model <em>[x2]</em> would directly apply here.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To this end, suppose we are given two transcripts</p>

    <p class="text-gray-300"><span class="math">\\mathrm{tr}_{j}\\coloneqq((z_{1},z_{2}),(1,\\alpha_{j}),(g_{j},(\\mathbf{z}_{j,i})_{i\\in[0,d^{\\prime}]}))\\quad\\text{for }j=0,1</span></p>

    <p class="text-gray-300">with the same first message <span class="math">(z_{1},z_{2})</span> and two distinct challenges <span class="math">(1,\\alpha_{0})\\neq(1,\\alpha_{1})</span> in <span class="math">\\mathcal{C}</span> such that</p>

    <p class="text-gray-300">\\[ \\begin{cases}\\Big{(}(\\mathbf{A},\\mathbf{W}^{2},\\mathbf{T}),((\\mathbf{I}_{n}+\\alpha_{j}\\mathbf{W}^{-1})\\mathbf{t},u^{2},z_{1}+\\alpha_{j}z_{2})\\,,\\Big{(}g_{j},(\\mathbf{z}_{j,i})_{i\\in[0,d^{\\prime}]}\\Big{)}\\Big{)}\\in\\mathsf{R}_{d^{\\prime},\\beta^{\\prime}}\\\\ z_{1}+uz_{2}=z\\end{cases} \\]</p>

    <p class="text-gray-300">where <span class="math">\\beta^{\\prime}\\coloneqq\\mathrm{w}\\,\\beta=2\\beta</span>. Observing that <span class="math">\\alpha_{0}-\\alpha_{1}\\in\\mathcal{R}_{q}^{\\times}</span>, we define for <span class="math">i=0,1,\\ldots,d^{\\prime}\\coloneqq(d-1)/2</span></p>

    <p class="text-gray-300"><span class="math">\\bar{f}_{2i+1}\\coloneqq\\frac{g_{0,i}-g_{1,i}}{\\alpha_{0}-\\alpha_{1}},\\quad\\bar{f}_{2i}\\coloneqq\\frac{\\alpha_{1}g_{0,i}-\\alpha_{0}g_{1,i}}{\\alpha_{1}-\\alpha_{0}}</span> (10)</p>

    <p class="text-gray-300">and similarly</p>

    <p class="text-gray-300"><span class="math">\\bar{\\mathbf{s}}_{2i+1}\\coloneqq\\frac{\\mathbf{z}_{0,i}-\\mathbf{z}_{1,i}}{\\alpha_{0}-\\alpha_{1}},\\quad\\bar{\\mathbf{s}}_{2i}\\coloneqq\\frac{\\alpha_{1}\\mathbf{z}_{0,i}-\\alpha_{0}\\mathbf{z}_{1,i}}{\\alpha_{1}-\\alpha_{0}}\\enspace.</span></p>

    <p class="text-gray-300">Denote <span class="math">\\mathbf{2}\\coloneqq(2,\\ldots,2)\\in\\mathcal{R}_{q}^{d+1}</span>. We claim that</p>

    <p class="text-gray-300"><span class="math">\\Big{(}(\\mathbf{A},\\mathbf{W},\\mathbf{T}),(\\mathbf{t},u,z)\\,,\\Big{(}\\bar{f},(\\bar{\\mathbf{s}}_{i})_{i\\in[0,d]},\\mathbf{2}\\Big{)}\\Big{)}\\in\\tilde{\\mathsf{R}}_{d,2N\\beta^{\\prime},2}\\enspace.</span></p>

    <p class="text-gray-300">Let us start with proving correctness of the relaxed opening. By careful inspection:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{A}\\bar{\\mathbf{s}}_{2i+1}+\\bar{f}_{2i+1}\\mathbf{e}_{1}</span> <span class="math">=\\frac{1}{\\alpha_{0}-\\alpha_{1}}\\left((\\mathbf{A}\\mathbf{z}_{0,i}+g_{0,i}\\mathbf{e}_{1})-(\\mathbf{A}\\mathbf{z}_{1,i}+g_{1,i}\\mathbf{e}_{1})\\right)</span> <span class="math">=\\frac{\\mathbf{W}^{-2i}}{\\alpha_{0}-\\alpha_{1}}\\Big{(}(\\mathbf{I}_{n}+\\alpha_{0}\\mathbf{W}^{-1})\\mathbf{t}-(\\mathbf{I}_{n}+\\alpha_{1}\\mathbf{W}^{-1})\\mathbf{t}\\Big{)}</span> <span class="math">=\\mathbf{W}^{-(2i+1)}\\mathbf{t}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and similarly <span class="math">\\mathbf{A}\\bar{\\mathbf{s}}_{2i}+\\bar{f}_{2i}\\mathbf{e}_{1}=\\mathbf{W}^{-2i}\\mathbf{t}</span>. As for shortness, we use the result from <em>[x3]</em> which says that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{2}{\\alpha_{0}-\\alpha_{1}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}=1<span class="math"> for any distinct </span>\\alpha_{0},\\alpha_{1}\\in\\{X^{i}:i\\in\\mathbb{Z}\\}<span class="math">. Thus, for any </span>i\\in[0,d^{\\prime}]$ we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2\\cdot\\bar{\\mathbf{s}}_{2i+1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{2}{\\alpha_{0}-\\alpha_{1}}\\cdot(\\mathbf{z}_{0,i}-\\mathbf{z}_{1,i})\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{2}{\\alpha_{0}-\\alpha_{1}}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{1}\\cdot\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z}_{0,i}-\\mathbf{z}_{1,i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2N\\beta^{\\prime}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and similarly</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2\\cdot\\bar{\\mathbf{s}}_{2i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{2}{\\alpha_{1}-\\alpha_{0}}\\cdot(\\alpha_{1}\\mathbf{z}_{0,i}-\\alpha_{0}\\mathbf{z}_{1,i})\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{2}{\\alpha_{1}-\\alpha_{0}}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{1}\\cdot\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{1}\\mathbf{z}_{0,i}-\\alpha_{0}\\mathbf{z}_{1,i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2N\\beta^{\\prime}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, we need to prove that the extracted polynomial <span class="math">\\bar{f}</span> satisfies <span class="math">\\bar{f}(u)=z</span>. From the verification equations we know that <span class="math">g_{0}(u^{2})=z_{1}+\\alpha_{0}z_{2}</span> and <span class="math">g_{1}(u^{2})=z_{1}+\\alpha_{1}z_{2}</span>. Hence,</p>

    <p class="text-gray-300"><span class="math">\\bar{f}(u)</span> <span class="math">=\\sum_{i=0}^{d^{\\prime}}\\bar{f}_{2i}u^{2i}+\\sum_{i=0}^{d^{\\prime}}\\bar{f}_{2i+1}u^{2i+1}</span> <span class="math">=\\sum_{i=0}^{d^{\\prime}}\\frac{\\alpha_{1}g_{0,i}-\\alpha_{0}g_{1,i}}{\\alpha_{1}-\\alpha_{0}}\\cdot u^{2i}+\\sum_{i=0}^{d^{\\prime}}\\frac{g_{0,i}-g_{1,i}}{\\alpha_{0}-\\alpha_{1}}\\cdot u^{2i+1}</span> <span class="math">=\\frac{\\alpha_{1}g_{0}(u^{2})-\\alpha_{0}g_{1}(u^{2})}{\\alpha_{1}-\\alpha_{0}}+\\frac{g_{0}(u^{2})-g_{1}(u^{2})}{\\alpha_{0}-\\alpha_{1}}\\cdot u</span> <span class="math">=z_{1}+uz_{2}</span> <span class="math">=z</span></p>

    <p class="text-gray-300">which concludes the proof of the claim.</p>

    <p class="text-gray-300">An almost identical strategy can be applied to our recursive protocol when given a general <span class="math">(2,\\ldots,2)</span>-tree of transcripts <em>[x1]</em>. In this case, we can extract a relaxed opening <span class="math">(\\bar{f},(\\bar{\\mathbf{s}}_{i})_{i\\in[0,d]},\\mathbf{2^{h}})</span> to the commitment <span class="math">\\mathbf{t}</span> which satisfies</p>

    <p class="text-gray-300"><span class="math">\\left((\\mathbf{A},\\mathbf{W},\\mathbf{T}),(\\mathbf{t},u,z)\\,,\\left(\\bar{f},(\\bar{\\mathbf{s}}_{i})_{i\\in[0,d]},\\mathbf{2^{h}}\\right)\\right)\\in\\tilde{\\mathsf{R}}_{d,(2N)^{h}\\beta^{\\prime},2^{h}}</span></p>

    <p class="text-gray-300">where <span class="math">\\beta^{\\prime}\\coloneqq 2^{h}\\beta</span> and <span class="math">\\mathbf{2^{h}}\\coloneqq(2^{h},\\ldots,2^{h})</span>. In terms of performance, the communication complexity and the verifier runtime (in terms of operations in <span class="math">\\mathcal{R}_{q}</span>) are <span class="math">O(\\log d)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Using the knowledge soundness result from <em>[x1]</em>, we deduce that the soundness error for our protocol is $h/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=h/(2N)<span class="math">. Since </span>N=\\mathsf{poly}(\\lambda)$, we only manage to obtain an inverse-polynomial soundness error. Even though this can be further reduced via parallel repetition in the interactive case <em>[x2]</em>, such amplification does not combine with the Fiat-Shamir transformation <em>[x3]</em>. Our second construction circumvents this issue by achieving negligible soundness error in one-shot.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">Construction 2: Large sampling set protocol.</h4>

    <p class="text-gray-300">In this scenario, we define the challenge space as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathcal{C}\\coloneqq\\{(\\alpha_{1},\\ldots,\\alpha_{k}):\\forall i\\in[k],\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq\\beta_{\\mathcal{C}}\\}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">for some suitable parameter <span class="math">\\beta_{\\mathcal{C}}\\geq 1</span>. Hence, by construction <span class="math">\\mathrm{w}\\leq k\\beta_{\\mathcal{C}}N</span>.</p>

    <p class="text-gray-300">One could naively adapt the strategy from Construction 1 to prove knowledge soundness of the <span class="math">\\Sigma</span>-protocol as follows. To begin with, we aim to extract <span class="math">k</span> accepting transcripts with <span class="math">k</span> pairwise distinct challenges <span class="math">\\boldsymbol{\\alpha}_{j}\\in\\mathcal{C}</span> for <span class="math">j=1,\\ldots,k</span>. Further, we compute the extracted polynomial <span class="math">f</span> by inverting the <span class="math">k\\times k</span> matrix <span class="math">\\mathbf{C}</span>, where the <span class="math">j</span>-th row corresponds to the challenge <span class="math">\\boldsymbol{\\alpha}_{j}</span> in the <span class="math">j</span>-th transcript. Unfortunately, this approach contains a few critical issues. Firstly, it is unclear whether the matrix <span class="math">\\mathbf{C}</span> is invertible. But even if it is, the resulting polynomial <span class="math">f</span> may contain large coefficients, or in the context of relaxed openings, there might be no sufficiently short element <span class="math">v\\in\\mathcal{R}_{q}</span> such that <span class="math">v\\cdot f_{i}</span> is short for all coefficients <span class="math">f_{i}</span>.</p>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 2: Visualisation of the notion of coordinate-wise special soundness (CWSS) for  <span class="math">k = 4</span>  coordinates. Here,  <span class="math">\\alpha_{i}^{\\star} \\neq \\alpha_{i}</span>  for all  <span class="math">i \\in [4]</span> .</p>

    <p class="text-gray-300">We propose an alternative approach which relies on a notion, called coordinate-wise special soundness <span class="math">^{10}</span>  (CWSS). As in special soundness, it says that given  <span class="math">k + 1</span>  valid transcripts  <span class="math">\\mathbf{tr}_j = (\\mathsf{a}_j,\\pmb {\\alpha}_j,\\mathsf{z}_j)</span>  for  <span class="math">j = 0,1,\\ldots ,d</span> , such that  <span class="math">\\pmb {\\alpha}_0,\\dots ,\\pmb {\\alpha}_k\\in \\mathcal{C}</span>  satisfy a certain relation, then one can extract the witness. The relation is defined as follows: for every  <span class="math">j\\in [k]</span> , vectors  <span class="math">\\pmb{\\alpha}_{0} = (\\alpha_{0,1},\\dots ,\\alpha_{0,k})</span>  and  <span class="math">\\pmb{\\alpha}_{j} = (\\alpha_{j,1},\\dots ,\\alpha_{j,k})</span>  differ exactly in the  <span class="math">j</span> -th coordinate, i.e.  <span class="math">\\forall i\\in [k]\\backslash \\{j\\}</span> ,  <span class="math">\\alpha_{j,i} = \\alpha_{0,i}</span>  and  <span class="math">\\alpha_{j,j}\\neq \\alpha_{0,j}</span>  (see Figure 2 for visualisation). We prove that for multi-round protocols CWSS implies knowledge soundness both in the interactive and non-interactive setting where the Fiat-Shamir transformation is applied.</p>

    <p class="text-gray-300">In the following, we show that our  <span class="math">\\Sigma</span> -protocol satisfies CWSS. Suppose we are given  <span class="math">k + 1</span>  valid transcripts</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {t r} _ {j} := \\left((z _ {1}, \\ldots , z _ {k}), \\boldsymbol {\\alpha} _ {j} = (\\alpha_ {j, 1}, \\ldots , \\alpha_ {j, k}), (g _ {j}, (\\mathbf {z} _ {j, i}) _ {i \\in [ 0, d ^ {\\prime} ]})\\right) \\quad \\mathrm {f o r} j = 0, 1, \\ldots , k.</span></div>

    <p class="text-gray-300">Let us fix  <span class="math">j \\in [k]</span>  and consider the transcripts  <span class="math">\\mathbf{tr}_0</span>  and  <span class="math">\\mathbf{tr}_j</span> . From the verification equations we have for  <span class="math">i = 0, \\ldots, d&#x27;</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A} \\mathbf {z} _ {0, i} + g _ {0, i} \\mathbf {e} _ {1} = \\mathbf {W} ^ {- k i} \\left(\\sum_ {t = 1} ^ {k} \\alpha_ {0, t} \\mathbf {W} ^ {- (t - 1)}\\right) \\mathbf {t}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A} \\mathbf {z} _ {j, i} + g _ {j, i} \\mathbf {e} _ {1} = \\mathbf {W} ^ {- k i} \\left(\\sum_ {t = 1} ^ {k} \\alpha_ {j, t} \\mathbf {W} ^ {- (t - 1)}\\right) \\mathbf {t}.</span></div>

    <p class="text-gray-300">Since  <span class="math">\\alpha_0</span>  and  <span class="math">\\alpha_{j}</span>  are the same in all coordinates apart from the  <span class="math">j</span> -th one, by subtracting the two equations we obtain</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A} (\\mathbf {z} _ {0, i} - \\mathbf {z} _ {j, i}) + (g _ {0, i} - g _ {j, i}) \\mathbf {e} _ {1} = (\\alpha_ {0, j} - \\alpha_ {j, j}) \\mathbf {W} ^ {- (k i + j - 1)} \\mathbf {t}.</span></div>

    <p class="text-gray-300">Now, by choosing parameters  <span class="math">q,N,\\beta_{\\mathcal{C}}</span>  appropriately, and using the result by Lyubashevsky and Seiler that short elements in  <span class="math">\\mathcal{R}_q</span>  are invertible [LS18], we deduce that  <span class="math">\\alpha_{0,j} - \\alpha_{j,j}\\in \\mathcal{R}_q^\\times</span>  and thus can define the extracted openings</p>

    <div class="my-4 text-center"><span class="math-block">\\bar {\\mathbf {s}} _ {k i + j - 1} := \\frac {\\mathbf {z} _ {0 , i} - \\mathbf {z} _ {j , i}}{\\alpha_ {0 , j} - \\alpha_ {j , j}} \\quad \\text {a n d} \\quad \\bar {f} _ {k i + j - 1} := \\frac {g _ {0 , i} - g _ {j , i}}{\\alpha_ {0 , j} - \\alpha_ {j , j}}</span></div>

    <p class="text-gray-300">and the partial vector of relaxation factors  <span class="math">\\mathbf{c}_j\\coloneqq (\\alpha_{0,j} - \\alpha_{j,j},\\ldots ,\\alpha_{0,j} - \\alpha_{j,j})\\in \\mathcal{R}_q^{d&#x27; + 1}</span> . Then, by construction we have  <span class="math">\\mathbf{A}\\bar{\\mathbf{s}}_{ki + j - 1} + \\bar{f}_{ki + j - 1}\\mathbf{e}_1 = \\mathbf{W}^{-(ki + j - 1)}\\mathbf{t}</span> , and further</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left(\\alpha_ {0, j} - \\alpha_ {j, j}\\right) \\cdot \\bar {\\mathbf {s}} _ {k i + j - 1} \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2 \\mathrm {w} \\beta \\quad \\text {a n d} \\quad \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_ {0, j} - \\alpha_ {j, j} \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2 \\beta_ {\\mathcal {C}} N.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">From the other verification checks we similarly conclude that <span class="math">\\sum_{i=0}^{d&#x27;} \\bar{f}_{ki+j-1} u^{ki} = z_j</span>.</p>

    <p class="text-gray-300">Eventually, by running the argument above for <span class="math">j = 1,2,\\ldots,k</span>, we reconstruct a polynomial <span class="math">f \\in \\mathcal{R}_q^{\\leq d}[\\mathsf{X}]</span>, along with <span class="math">(\\mathbf{s}_i)_{i \\in [0,d]}</span>, and the vector <span class="math">\\mathbf{c} \\coloneqq (\\mathbf{c}_1,\\dots,\\mathbf{c}_k)</span> of relaxation factors so that</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\left(\\mathbf {A}, \\mathbf {W}, \\mathbf {T}\\right), \\left(\\mathbf {t}, u, z\\right), \\left(\\bar {f}, \\left(\\bar {\\mathbf {s}} _ {i}\\right) _ {i \\in [ 0, d ]}, \\mathbf {c}\\right)\\right) \\in \\tilde {\\mathrm {R}} _ {d, 2 \\mathrm {w} \\beta , 2 \\beta_ {\\mathcal {C}} N}.</span></div>

    <p class="text-gray-300">In terms of security, we show that the knowledge soundness error of our <span class="math">\\Sigma</span>-protocol is bounded by <span class="math">k / (2\\beta_{\\mathcal{C}} + 1)^N</span>, where <span class="math">(2\\beta_{\\mathcal{C}} + 1)^N</span> is the number of all possible choices for a single coordinate in <span class="math">\\mathcal{C}</span>. Consequently, by picking <span class="math">k, \\beta_{\\mathcal{C}} \\geq 1</span> and <span class="math">N = \\mathrm{poly}(\\lambda)</span> appropriately, we achieve negligible soundness error in one-shot.</p>

    <p class="text-gray-300">This strategy can be further applied in our recursive protocol. That is, analogously as for special soundness, we first generalise the notion of coordinate-wise special soundness in the multi-round setting, and then prove that our protocol satisfies CWSS as above. By following the methodology from [ACK21; AFK22], we obtain the knowledge soundness error equal to <span class="math">hk / (2\\beta_{\\mathcal{C}} + 1)^N</span>, while the knowledge extractor runs the prover expected <span class="math">(k + 1)^h</span> times, and outputs a relaxed opening <span class="math">(\\bar{f},(\\bar{\\mathbf{s}}_i)_{i\\in [0,d]},\\mathbf{c})</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\left(\\mathbf {A}, \\mathbf {W}, \\mathbf {T}\\right), \\left(\\mathbf {t}, u, z\\right), \\left(\\bar {f}, \\left(\\bar {\\mathbf {s}} _ {i}\\right) _ {i \\in [ 0, d ]}, \\mathbf {c}\\right)\\right) \\in \\tilde {\\mathrm {R}} _ {d, \\gamma , \\xi}</span></div>

    <p class="text-gray-300">where <span class="math">\\gamma \\coloneqq (2^{h}(2\\beta_{\\mathcal{C}}N)^{2^{h} - h - 1}\\mathrm{w}^{h})\\cdot \\beta</span> and <span class="math">\\xi \\coloneqq 2\\beta_{\\mathcal{C}}(2\\beta_{\\mathcal{C}}N)^{2^{h} - 2}N</span>. We highlight that the norm blow-up is much larger here than in the monomial case due to certain technical differences<span class="math">^{11}</span>. As a result, we cannot pick <span class="math">k = 2</span> and <span class="math">h = O(\\log d)</span> since then one would require <span class="math">\\log q = O(d)</span> for relaxed binding to hold (c.f. Equation (6)); thus making the proof size and verifier time polynomial in <span class="math">d</span>. Instead, we instantiate the protocol by choosing <span class="math">k = O(d^{\\frac{1}{\\log\\log d}})</span> and <span class="math">h = O(\\log \\log d)</span>. In this case, <span class="math">\\log q = \\mathsf{polylog}(d)</span>, and the proof size and verifier complexity, in terms of operations over <span class="math">\\mathcal{R}_q</span>, become <span class="math">O(d^{\\frac{1}{\\log\\log d}}\\log \\log d) = d^{O(1 / \\log \\log d)}</span>.</p>

    <h2 id="sec-19" class="text-2xl font-bold">1.5 Polynomial Commitments over Finite Fields</h2>

    <p class="text-gray-300">Until now, we were focusing on polynomial commitments over the ring <span class="math">\\mathcal{R}_q\\coloneqq \\mathbb{Z}_q[X] / (X^N +1)</span>. Here, we sketch how to obtain a polynomial commitment over a finite field, which is required by Polynomial IOPs [BFS20; CHMMVW20] to compile into succinct arguments. The key ingredient, which allows us to do that is the ability to commit to arbitrarily large elements in <span class="math">\\mathcal{R}_q</span>.</p>

    <p class="text-gray-300">Let <span class="math">l \\geq 1</span> be a divisor of <span class="math">N</span>. It is a well-known fact [LS18] that if <span class="math">q \\equiv 2N / l + 1 \\pmod{4N / l + 1}</span>, then there exists a ring isomorphism <span class="math">\\varphi</span> from <span class="math">\\mathbb{F}^{N / l}</span> to <span class="math">\\mathcal{R}_q</span>, where <span class="math">\\mathbb{F}</span> is a finite field of size <span class="math">q^l</span>. Thus, we define a map <span class="math">\\varphi_{\\mathbb{F}}: \\mathbb{F} \\to \\mathcal{R}_q</span> as <span class="math">x \\mapsto \\varphi(x,0,\\ldots,0)</span>, and denote the image of <span class="math">\\varphi_{\\mathbb{F}}</span> as <span class="math">S_q</span>. We will make use of the fact that <span class="math">S_q</span> is an ideal of <span class="math">\\mathcal{R}_q</span>.</p>

    <p class="text-gray-300">Suppose we want to commit to a polynomial <span class="math">F \\in \\mathbb{F}^{\\leq d}[\\mathsf{X}]</span> and prove that <span class="math">F(x) = y</span> for <span class="math">x, y \\in \\mathbb{F}</span>. Using the homomorphic property of <span class="math">\\varphi_{\\mathbb{F}}</span>, it is easy to see that this is equivalent to proving <span class="math">f(u) = z</span> over <span class="math">\\mathcal{R}_q</span>, where <span class="math">f[\\mathsf{X}] \\coloneqq \\sum_{i=0}^{d} \\varphi_{\\mathbb{F}}(F_i) \\mathsf{X}^i \\in S_q[\\mathsf{X}]</span>, <span class="math">u = \\varphi_{\\mathbb{F}}(x) \\in S_q</span> and <span class="math">z = \\varphi_{\\mathbb{F}}(y) \\in S_q</span>. Therefore, we commit to the polynomial <span class="math">f \\in \\mathcal{R}_q[\\mathsf{X}]</span> and prove evaluation of <span class="math">u</span> at the point <span class="math">z</span> as before.</p>

    <p class="text-gray-300">What we need to take care of is proving that all coefficients of <span class="math">f</span> indeed lie in <span class="math">S_q</span>. This allows us to extract the polynomial <span class="math">\\bar{F} \\in \\mathbb{F}[\\mathsf{X}]</span> by taking the inverse of <span class="math">\\varphi_{\\mathbb{F}}</span> coefficient-wise. Looking at our</p>

    <p class="text-gray-300">11Roughly speaking, in Construction 1 we managed to keep the norm growth smaller due to the fact that the relaxation factors <span class="math">\\mathbf{2}^{\\mathbf{h}}</span> are independent of the extracted transcripts, which is not the case for the relaxation factors <span class="math">\\mathbf{c}</span> in Construction 2. We refer to Section 5.3 for more details.</p>

    <p class="text-gray-300">underlying <span class="math">\\Sigma</span> protocol in Figure 1, the additional proof comes without any change on the prover’s side, while the verifier also checks whether <span class="math">g\\in\\mathcal{S}_{q}[\\mathsf{X}]</span>, which is the case since <span class="math">\\mathcal{S}_{q}</span> is an ideal. To see why this modification is sufficient, consider the extraction strategy in Equation (10). Since now <span class="math">g_{0,i},g_{1,i}\\in\\mathcal{S}_{q}</span>, we again use the fact that <span class="math">\\mathcal{S}_{q}</span> is an ideal and conclude that <span class="math">\\tilde{f}_{2i+1}=(g_{0,i}-g_{1,i})/(\\alpha_{0}-\\alpha_{1})</span> also lies in <span class="math">\\mathcal{S}_{q}</span>. Identical reasoning follows for both Construction 1 and 2.</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">1.6 Related Works</h3>

    <p class="text-gray-300">The first lattice-based interactive proof with sublinear communication complexity for arithmetic <span class="math">\\ell</span>-gate circuit satisfiability was formally proposed by Baum et al. <em>[x1]</em>, where the authors achieve <span class="math">O(\\sqrt{\\ell})</span> size proofs. The construction was later generalised by Bootle et al. <em>[x2]</em> who define so-called “levelled commitments” and give <span class="math">O(\\ell^{1/k})</span> size proofs for proving knowledge of a commitment opening with <span class="math">k=O(1)</span> levels. The main drawback of the scheme is that the modulus for the proof system increases exponentially in <span class="math">k</span> and thus considering more than 2-3 levels seems impractical. Recently, Nguyen and Seiler <em>[x23]</em> combined the square-root approach from <em>[x1]</em> with the CRT-packing technique from <em>[x10]</em> to obtain a practically efficient square-root NIZK, with 6MB proofs for circuits of size <span class="math">\\ell=2^{20}</span>.</p>

    <p class="text-gray-300">Bootle et al. <em>[x2]</em> also proposed the first lattice adaptation of the Bulletproofs protocol <em>[x6, x3]</em> over polynomial rings <span class="math">\\mathcal{R}_{q}=\\mathbb{Z}_{q}[X]/(X^{N}+1)</span> which offers polylog(<span class="math">\\ell</span>) proof sizes. This approach was later improved independently by Attema et al. <em>[x1]</em> and Albrecht and Lai <em>[x1]</em> in terms of tighter soundness analysis, and also generalised to a more abstract setting by Bootle et al. <em>[x5]</em>. While the <em>split-and-fold</em> strategy from Bulletproofs is very attractive in the discrete logarithm setting and keeps asymptotic efficiency in the lattice scenario, it does not mix well with the shortness condition required in lattice-based cryptography. Consequently, this leads to a concrete blow-up of the parameters as well as the proof size. Roughly speaking, for the knowledge soundness argument it must be possible to invert the folding in the extraction such that the extracted solution vector is still short. To this end, one needs a challenge space of the underlying compressed <span class="math">\\Sigma</span>-protocol to have a property that (a scaled) inverse of a difference of any two distinct challenges is still short - such sets are called <em>subtractive</em>. Hence, Bootle et al. <em>[x2]</em> picked the challenge space to consist of monomial challenges <span class="math">\\mathcal{C}\\coloneqq\\{X^{i}:i\\in\\mathbb{Z}\\}\\subseteq\\mathcal{R}_{q}</span>, which is indeed subtractive as shown in <em>[x3]</em>. Since the <span class="math">\\Sigma</span>-protocol is 3-special sound, norm of the extracted solution vector grows by a factor of <span class="math">O(N^{3})</span> for <em>every</em> level of folding. Then, the parameters must be chosen such that Module-SIS is hard with respect to the norm of the extracted solution vector, resulting in the need for a huge modulus <span class="math">q</span>. Note that a similar issue occurs in our Construction 1 (c.f. Section 5.2). However, since our underlying compressed <span class="math">\\Sigma</span>-protocol is only 2-special sound, norm of the extracted vector grows by only a factor of <span class="math">O(N)</span> for each folding level (but at the price of having a trusted setup).</p>

    <p class="text-gray-300">In addition to the norm growth of the extracted witness, the restriction on the challenges has a negative impact on the soundness error. Indeed, since the challenge space <span class="math">\\mathcal{C}</span> in <em>[x2]</em> has size <span class="math">2N</span>, the soundness error becomes only <span class="math">1/\\mathsf{poly}(\\lambda)</span>. Furthermore, it was proven by Albrecht and Lai <em>[x1]</em> that <em>all</em> subtractive set over <span class="math">\\mathcal{R}_{q}</span> have size <span class="math">O(N)</span>. This becomes problematic especially in the non-interactive setting due to the result by Attema et al. <em>[x2]</em>, who showed that the Fiat-Shamir transformation of a parallel repetition of special sound protocols <em>does not</em> necessarily decrease the soundness error. A promising solution to circumvent this limitation was recently proposed by Bünz and Fisch <em>[x4]</em>, who suggested a new knowledge extraction strategy, i.e. the notion of <em>almost special soundness</em>, which does not require subtractive sets. Instead, the challenges are picked from</p>

    <p class="text-gray-300">the exponential-sized set of integers <span class="math">[0,2^{\\lambda-1})</span>. Unfortunately, the former issue with the norm growth for each folding level is still present in <em>[x1]</em>.</p>

    <p class="text-gray-300">Recently, Beullens and Seiler <em>[x2]</em> showed that by combining a split-and-fold approach with algebraic techniques introduced in linear-sized lattice-based NIZKs <em>[x11]</em>, it is possible to achieve negligible soundness error whilst controlling the norm growth. This is evidenced with impressive 50KB proofs for circuits of size <span class="math">\\ell=2^{20}</span>.</p>

    <p class="text-gray-300">Major downside of all the aforementioned works is a linear verification time, which can be the main efficiency bottleneck when proving satisfiability of large circuits. Until now, the only lattice-based publicly verifiable succinct argument of knowledge with efficient verification (excluding the preprocessing step) was proposed by Albrecht et al. <em>[x1]</em>. The construction is obtained as a direct application of functional commitments <em>[x16]</em> and soundness holds under a knowledge assumption. However, similar to our scheme, a trusted setup is required, and more importantly, the prover algorithm runs in time <span class="math">O(\\ell^{4}\\log\\ell)</span> which makes it unappealing to implement in practice.</p>

    <p class="text-gray-300">Prior to <em>[x1]</em>, all lattice-based zk-SNARKs were in the designated-verifier setting <em>[x8, x13, x21]</em>. The constructions use the Linear-PCP compiler <em>[x3]</em> to transform into succinct arguments. Notably, the most recent work by Steinfeld et al. <em>[x21]</em> achieves proofs of size 6KB for <span class="math">\\ell=2^{20}</span> constraints at the cost of very large <span class="math">\\mathsf{crs}</span> (in the order of tens of gigabytes).</p>

    <p class="text-gray-300">Naturally, there is a line of research focusing on the security of lattice-based zero-knowledge proofs against <em>quantum adversaries</em> <em>[x7, x12, x13]</em>. Particularly, Lai et al. <em>[x13]</em> show that any multi-round protocol, which satisfies special soundness and <em>collapsing</em>, is knowledge sound in the post-quantum setting. As a special case, they demonstrate that the lattice Bulletproofs protocol <em>[x5]</em> is knowledge sound against quantum provers. Since our constructions not only satisfy (coordinate-wise) special soundness but also follow the split-and-fold strategy from <em>[x5]</em>, we believe that the general result from <em>[x13]</em> can be adapted to our setting.</p>

    <p class="text-gray-300">Interestingly, lattice assumptions are not only used to build lattice-based commitments, but also to construct non-interactive arguments in the standard model, i.e. without the random oracle. For instance, there is a line of works <em>[x6, x10, x14]</em> which focuses on instantiating the Fiat-Shamir transformation with a correlation intractable hash function <em>[x9]</em>, that itself can be built from the Learning with Errors (LWE) problem <em>[x12]</em>. Following this template, Choudhuri, Jain and Jin <em>[x7]</em> built a SNARG for languages in P only based on the LWE problem with polynomial modulus. Moreover, the LWE assumption can be used to construct non-interactive succinct (and batched) arguments without the Fiat-Shamir transformation, but via somewhat extractable hash functions <em>[x6, x15]</em>. We believe that naturally, due to relying on more assumptions, constructions based on the random oracle model should perform much better in terms of concrete efficiency.</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">1.7 Concurrent and Subsequent Works</h3>

    <p class="text-gray-300">Recently, Bootle et al. <em>[x2]</em> and Cini et al. <em>[x6]</em> independently proposed variants of the lattice Bulletproofs protocol that achieve polylogarithmic verification time. The former work proposes a new delegation algorithm inspired from <em>[x17]</em>, which requires an additional pre-processing step. The latter one introduces more (power-like) structure on the Ajtai commitment <em>[x2]</em> which allows for fast verification, at the cost of relying on a new assumption called Vanishing-SIS (vSIS). We note that there is a close similarity between vSIS and the PRISIS, and we leave the concrete relationship between the two for the future work. Nevertheless, the aforementioned work inherit the issue from</p>

    <p class="text-gray-300">the original construction <em>[x1]</em> that the soundness error is non-negligible and parallel repetitions are required.</p>

    <p class="text-gray-300">Fisch et al. <em>[x10]</em> recently presented a polynomial commitment scheme, as an application of their linear functional commitment. Following the work of <em>[x2]</em>, the construction relies on the knowledge <span class="math">k</span>-<span class="math">M</span>-ISIS assumption, which appears to be morally invalidated in <em>[x26]</em>.</p>

    <p class="text-gray-300">As a subsequent work, Albrecht et al. <em>[x1]</em> proposed a new polynomial commitment scheme with polylogarithmic communication and verification complexity <em>under standard assumptions</em>. To this end, the authors construct a new commitment scheme that combines our PowerBASIS construction together with the Merkle tree paradigm. Consequently, the committing runtime becomes quasilinear in the length of the message, while the size crs shrinks to only polylogarithmic. The binding property of the commitment relies on a “multi-instance” version of the PRISIS assumption. Finally, using the exact strategy from Lemma 3.6, security of the aforementioned assumption is further reduced to Module-SIS.</p>

    <h5 id="sec-22" class="text-base font-semibold mt-4">Acknowledgements.</h5>

    <p class="text-gray-300">We thank Martin Albrecht and Sasha Lapiha for discussion on the PowerBASIS assumption. Ngoc Khanh Nguyen is supported by the Protocol Labs RFP-013: Cryptonet network grant.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">2 Preliminaries</p>

    <p class="text-gray-300">Notation. We denote the security parameter by <span class="math">\\lambda</span>, which is implicitly given to all algorithms unless specified otherwise. Further, we write <span class="math">\\mathsf{negl}(\\lambda)</span> (resp. <span class="math">\\mathsf{poly}(\\lambda)</span>) to denote an unspecified negligible function (resp. polynomial) in <span class="math">\\lambda</span>. In this work, we implicitly assume that the vast majority of the key parameters, e.g. the ring dimension, and the dimensions of matrices and vectors, are <span class="math">\\mathsf{poly}(\\lambda)</span>. However, the modulus used in this work may be super-polynomial in <span class="math">\\lambda</span>.</p>

    <p class="text-gray-300">For <span class="math">a, b \\in \\mathbb{N}</span> with <span class="math">a &amp;lt; b</span>, write <span class="math">[a, b] \\coloneqq \\{a, a + 1, \\ldots, b\\}</span>, <span class="math">[a] \\coloneqq [1, a]</span>. For <span class="math">q \\in \\mathbb{N}</span> write <span class="math">\\mathbb{Z}_q</span> for the integers modulo <span class="math">q</span>. We denote vectors with lowercase boldface (i.e. <span class="math">\\mathbf{u}, \\mathbf{v}</span>) and matrices with uppercase boldface (i.e. <span class="math">\\mathbf{A}, \\mathbf{B}</span>). For a vector <span class="math">\\mathbf{x}</span> we write <span class="math">x_i</span> or <span class="math">\\mathbf{x}[i]</span> for its <span class="math">i</span>-th entry.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Norms. We define the <span class="math">\\ell_p</span> norm on <span class="math">\\mathbb{C}^n</span> as $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_p = (\\sum_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^p)^{1/p}<span class="math"> for </span>p &lt; \\infty<span class="math"> and </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\coloneqq \\max_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Unless otherwise specified, we use </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> for the </span>\\ell_2$ norm. We let the norm of a matrix be defined as the norm taken over the concatenation of columns of the matrix.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Linear algebra. We let <span class="math">\\mathbf{e}_i</span> be the vector with 1 in its <span class="math">i</span>-th entry, 0 everywhere else. For <span class="math">\\mathbf{B} \\in \\mathbb{R}^{n \\times m}</span> we let $s_1(\\mathbf{B}) = \\sup \\{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{Bv} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">: \\mathbf{v} \\in \\mathbb{R}^m \\land \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{v} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1\\}<span class="math"> be the spectral norm of </span>\\mathbf{B}<span class="math">. We also denote by </span>\\tilde{\\mathbf{B}}<span class="math"> the Gram-Schmidt orthonormalization of </span>\\mathbf{B}<span class="math">. The Gram-Schmidt norm of </span>\\mathbf{B}$ is defined as</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde {\\mathbf {B}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">:= \\max _ {i \\in [ m ]} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde {\\mathbf {b}} _ {i} \\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where <span class="math">\\tilde{\\mathbf{b}}_i</span> is the <span class="math">i</span>-th column of <span class="math">\\tilde{\\mathbf{B}}</span>.</p>

    <p class="text-gray-300">For a ring <span class="math">R</span>, we define <span class="math">\\mathsf{GL}(n,R)</span> to be the group of <span class="math">n\\times n</span> invertible matrices over <span class="math">R</span>.</p>

    <h2 id="sec-23" class="text-2xl font-bold">2.1 Lattices</h2>

    <p class="text-gray-300">A subset <span class="math">\\Lambda \\subseteq \\mathbb{R}^m</span> is a lattice if the following conditions hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{0} \\in \\Lambda</span>, and for <span class="math">\\mathbf{x}, \\mathbf{y} \\in \\Lambda</span>, <span class="math">\\mathbf{x} + \\mathbf{y} \\in \\Lambda</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- For every <span class="math">\\mathbf{x} \\in \\Lambda</span>, there exists <span class="math">\\epsilon &amp;gt; 0</span> such that $\\{\\mathbf{y} \\in \\mathbb{R}^m : \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x} - \\mathbf{y} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; \\epsilon\\} \\cap \\Lambda = \\{\\mathbf{x}\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We say <span class="math">\\mathbf{B} \\in \\mathbb{R}^{m \\times k}</span> is a basis for <span class="math">\\Lambda</span> if its columns are linearly independent and <span class="math">\\Lambda = \\mathcal{L}(\\mathbf{B}) \\coloneqq \\{\\mathbf{Bz} : \\mathbf{z} \\in \\mathbb{Z}^k\\}</span>. If <span class="math">k = m</span> then we say that <span class="math">\\Lambda</span> is full-rank. The span (as a vector space) of the basis of a lattice is the span of a lattice denoted as <span class="math">\\operatorname{Span}(\\Lambda)</span>. We also let <span class="math">\\Lambda^<em></span> be the dual lattice defined as <span class="math">\\Lambda^</em> = \\{\\mathbf{w} \\in \\operatorname{Span}(\\Lambda) : \\langle \\Lambda, \\mathbf{w} \\rangle \\subseteq \\mathbb{Z}\\}</span>. If <span class="math">\\Lambda \\subseteq \\mathbb{Z}^m</span>, we call it an integral lattice. For <span class="math">I</span> an ideal of <span class="math">\\mathbb{R}^m</span>, we let <span class="math">I \\cdot \\Lambda = \\{i \\cdot \\mathbf{x} : i \\in I, \\mathbf{x} \\in \\Lambda\\}</span>, which is also a lattice. For a lattice <span class="math">\\Lambda</span> we denote</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\lambda_ {1} (\\Lambda) := \\min  _ {0 \\neq \\mathbf {x} \\in \\Lambda} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {x} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\quad \\text{and} \\quad \\lambda_ {1} ^ {\\infty} (\\Lambda) := \\min  _ {0 \\neq \\mathbf {x} \\in \\Lambda} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {x} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">For <span class="math">\\mathbf{t} \\in \\operatorname{Span}(\\Lambda)</span>, we also define the shifted lattice <span class="math">\\mathbf{t} + \\Lambda \\coloneqq \\{\\mathbf{t} + \\mathbf{x} : \\mathbf{x} \\in \\Lambda\\}</span>. We also consider <span class="math">q</span>-ary lattices, namely those with <span class="math">q\\mathbb{Z} \\subseteq \\Lambda</span>. For an arbitrary <span class="math">\\mathbf{A} \\in \\mathbb{Z}_q^{n \\times m}</span> we define the full rank <span class="math">q</span>-ary lattice</p>

    <div class="my-4 text-center"><span class="math-block">\\Lambda^ {\\perp} (\\mathbf {A}) = \\left\\{\\mathbf {z} \\in \\mathbb {Z} ^ {m}: \\mathbf {A z} = 0 \\pmod {q} \\right\\}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Lambda (\\mathbf {A}) = \\left\\{\\mathbf {z} \\in \\mathbb {Z} ^ {m}: \\exists \\mathbf {s} \\in \\mathbb {Z} _ {q} ^ {n}, \\mathbf {A z} = \\mathbf {s} \\pmod {q} \\right\\}</span></div>

    <p class="text-gray-300">For any <span class="math">\\mathbf{u} \\in \\mathbb{Z}_q^n</span> such that there exists <span class="math">\\mathbf{x}</span> with <span class="math">\\mathbf{A}\\mathbf{x} = \\mathbf{u}</span>, we define <span class="math">\\Lambda_{\\mathbf{u}}^{\\perp}(\\mathbf{A}) \\coloneqq \\{\\mathbf{z} \\in \\mathbb{Z}^m : \\mathbf{A}\\mathbf{z} = \\mathbf{u} \\pmod{q}\\} = \\Lambda^{\\perp}(\\mathbf{A}) + \\mathbf{x}</span>.</p>

    <p class="text-gray-300">19</p>

    <p class="text-gray-300">20</p>

    <h2 id="sec-24" class="text-2xl font-bold">2.2 Power-of-Two Cyclotomic Rings</h2>

    <p class="text-gray-300">Let <span class="math">N</span> be a power-of-two and <span class="math">\\mathcal{K} = \\mathbb{Q}[X] / (X^N + 1)</span> be the <span class="math">2N</span>-th cyclotomic field. Denote <span class="math">\\mathcal{R} = \\mathbb{Z}[X] / (X^N + 1)</span> to be the ring of integers of <span class="math">\\mathcal{K}</span>. For an odd prime <span class="math">q</span>, we write <span class="math">\\mathcal{R}_q \\coloneqq \\mathcal{R} / (q)</span>. We denote <span class="math">\\mathcal{R}_q^\\times</span> to be the set of invertible elements in <span class="math">\\mathcal{R}_q</span>.</p>

    <p class="text-gray-300">We recall the following inequality, which allows to bound norms on products in the ring <span class="math">\\mathcal{R}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 2.1.</strong> Let <span class="math">u, v \\in R</span>. Then $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">uv\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_1 \\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Proof.</strong> Let <span class="math">u \\coloneqq u_0 + u_1X + \\ldots + u_{N-1}X^{N-1} \\in \\mathcal{R}</span>. Then, by the triangle inequality we get</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u v \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\sum_{i=0}^{N-1} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_i v \\cdot X^i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\sum_{i=0}^{N-1} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_i v \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\sum_{i=0}^{N-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_1 \\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><strong>Coefficient embedding.</strong> For <span class="math">x \\in \\mathcal{K}</span>, we can consider the additive group isomorphism</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{vec}: \\mathcal{K} \\to \\mathbb{Q}^N</span></div>

    <div class="my-4 text-center"><span class="math-block">a_0 + a_1 X + \\cdots + a_{N-1} X^{N-1} \\mapsto (a_0, \\dots, a_{N-1})^\\top</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and we refer this as the coefficient embedding of <span class="math">\\mathcal{K}</span>. Note that, for <span class="math">f, g \\in \\mathcal{K}</span>, <span class="math">\\langle f, g \\rangle = \\langle \\operatorname{vec}(f), \\operatorname{vec}(g) \\rangle</span> and thus $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{vec}(f) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Furthermore, </span>\\operatorname{vec}<span class="math"> restricts to an isomorphism between </span>\\mathcal{R}_q \\cong \\mathbb{Z}_q^N<span class="math"> and </span>\\mathcal{R} \\cong \\mathbb{Z}^N<span class="math">. We also extend this to a mapping </span>\\mathcal{K}^m \\to \\mathbb{Q}^{mN}<span class="math"> by applying it component-wise. For </span>f \\in \\mathcal{K}$, we let</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{rot}(f) := (\\operatorname{vec}(f), \\operatorname{vec}(X \\cdot f), \\dots, \\operatorname{vec}(X^{N-1} \\cdot f)) \\in \\mathbb{Q}^{N \\times N},</span></div>

    <p class="text-gray-300">noting that <span class="math">\\operatorname{rot}(f)\\operatorname{vec}(g) \\coloneqq \\operatorname{vec}(fg)</span> and <span class="math">\\operatorname{rot}(f)\\operatorname{rot}(g) = \\operatorname{rot}(fg)</span>. We extend this to matrices <span class="math">\\mathbf{B} \\in \\mathcal{K}^{m \\times n}</span> by writing</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{rot}(\\mathbf{B}) := \\begin{bmatrix} \\operatorname{rot}(b_{1,1}) &amp;amp; \\cdots &amp;amp; \\operatorname{rot}(b_{1,n}) \\\\ \\vdots &amp;amp; \\ddots &amp;amp; \\vdots \\\\ \\operatorname{rot}(b_{m,1}) &amp;amp; \\cdots &amp;amp; \\operatorname{rot}(b_{m,n}) \\end{bmatrix} \\in \\mathbb{Q}^{mN \\times nN}.</span></div>

    <p class="text-gray-300"><strong>Module lattices.</strong> For <span class="math">\\mathbf{A} \\in \\mathcal{R}_q^{n \\times m}</span>, <span class="math">\\mathbf{x} \\in \\mathcal{R}_q^m</span>, <span class="math">\\mathbf{u} = \\mathbf{A}\\mathbf{x}</span>, define</p>

    <div class="my-4 text-center"><span class="math-block">\\Lambda^{\\perp}(\\mathbf{A}) := \\{\\mathbf{z} \\in \\mathcal{R}^m : \\mathbf{A}\\mathbf{z} = \\mathbf{0} \\bmod q\\}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Lambda_{\\mathbf{u}}^{\\perp}(\\mathbf{A}) := \\{\\mathbf{z} \\in \\mathcal{R}^m : \\mathbf{A}\\mathbf{z} = \\mathbf{u} \\bmod q\\} = \\Lambda^{\\perp}(\\mathbf{A}) + \\mathbf{x}.</span></div>

    <p class="text-gray-300">Then, <span class="math">\\Lambda^{\\perp}(\\mathbf{A}) = \\operatorname{vec}^{-1}(\\Lambda^{\\perp}(\\operatorname{rot}(\\mathbf{A})))</span> and <span class="math">\\Lambda_{\\mathbf{u}}^{\\perp}(\\mathbf{A}) = \\operatorname{vec}^{-1}(\\Lambda_{\\operatorname{vec}(\\mathbf{u})}^{\\perp}(\\operatorname{rot}(\\mathbf{A})))</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Spectral norm.</strong> Let $s_1(\\mathbf{R}) \\coloneqq \\sup \\{ \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{R}\\mathbf{v} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">: \\mathbf{v} \\in \\mathcal{K}^w \\wedge \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{v} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1 \\}<span class="math"> be the spectral norm of </span>\\mathbf{R} \\in \\mathcal{R}^{m \\times w}<span class="math">. Clearly, </span>s_1(\\operatorname{rot}(\\mathbf{R})) = s_1(\\mathbf{R})<span class="math">, where the spectral norm of the left-hand side is over </span>\\mathbb{R}$. Here, we recall a simple bound.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 2.2.</strong> Let <span class="math">\\mathbf{R} \\in \\mathcal{R}_q^{m \\times t}</span>. Then $s_1(\\mathbf{R}) \\leq \\sqrt{N} \\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{R} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Let <span class="math">\\mathbf{r}_1, \\ldots, \\mathbf{r}_m</span> be the rows of <span class="math">\\mathbf{R}</span>. Note that by the Cauchy-Schwarz inequality, for any <span class="math">\\mathbf{u}</span> with $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{u} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1$ we have that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle \\mathbf {r} _ {i}, \\mathbf {u} \\rangle \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^ {2} \\leq \\left(\\sum_ {j \\in [ t ]} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r _ {i, j} s _ {j} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right) ^ {2} \\leq N \\left(\\sum_ {j \\in [ t ]} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r _ {i, j} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s _ {j} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right) ^ {2} \\leq N \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {r} _ {i} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^ {2} \\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {u} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^ {2} \\leq N \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {r} _ {i} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^ {2}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Thus, $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{Ru}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2\\leq N\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{R}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2$ which concludes the proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In this work we will work with <span class="math">q \\equiv 5 \\pmod{8}</span>. In this setting, the probability that a uniformly random matrix is full-rank is overwhelming.</p>

    <p class="text-gray-300">Lemma 2.3 (Appendix C.3 of [BTT22]). Let <span class="math">q \\equiv 5 \\pmod{8}</span> be prime, <span class="math">N = O(\\lambda)</span> and <span class="math">m \\geq n \\geq 1</span>. Then, for a uniformly random matrix <span class="math">\\mathbf{A} \\gets \\mathcal{R}_q^{n \\times m}</span>, the probability that <span class="math">\\mathbf{A}</span> is not full-rank is <span class="math">\\mathrm{negl}(\\lambda)</span>.</p>

    <h2 id="sec-25" class="text-2xl font-bold">2.3 Discrete Gaussian Distributions</h2>

    <p class="text-gray-300">Let <span class="math">\\sigma &amp;gt; 0</span> be a parameter and <span class="math">\\Lambda</span> be a <span class="math">m</span>-dimensional lattice. We then define the discrete Gaussian distribution <span class="math">\\mathcal{D}_{\\sigma, \\mathbf{c}, \\Lambda}</span> over a lattice coset <span class="math">\\mathbf{c} + \\Lambda</span> as follows.</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho_ {\\sigma , \\mathbf {c}} (\\mathbf {z}) := \\exp \\left(- \\frac {\\pi \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {z} - \\mathbf {c} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^ {2}}{\\sigma^ {2}}\\right) \\mathrm {a n d} \\mathcal {D} _ {\\sigma , \\mathbf {c}, \\Lambda} (\\mathbf {z}) := \\frac {\\rho_ {\\sigma , \\mathbf {c}} (\\mathbf {z})}{\\sum_ {\\mathbf {x} \\in \\Lambda} \\rho_ {\\sigma , \\mathbf {c}} (\\mathbf {x})}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">When <span class="math">\\mathbf{c} = \\mathbf{0}</span> or <span class="math">\\Lambda = \\mathbb{Z}^m</span>, we will omit it from the notation. We naturally extend this notion for lattices over the ring of integers <span class="math">\\mathcal{R}</span>, and for matrices by sampling column-wise.</p>

    <p class="text-gray-300">Smoothing parameter. The smoothing parameter <span class="math">\\eta_{\\epsilon}(\\Lambda)</span> of a lattice is the smallest <span class="math">s &amp;gt; 0</span> such that <span class="math">\\rho_{1 / s}(\\Lambda^{*})\\leq 1 + \\epsilon</span>. Below we recall the standard upper-bounds on the smoothing parameter [MR07; GPV08].</p>

    <p class="text-gray-300">Lemma 2.4. Let <span class="math">\\Lambda \\subseteq \\mathbb{R}^m</span> be a lattice, and let <span class="math">\\epsilon &amp;gt;0</span>. Then,</p>

    <div class="my-4 text-center"><span class="math-block">\\eta_ {\\epsilon} (\\Lambda) \\leq \\frac {1}{\\lambda_ {1} ^ {\\infty} (\\Lambda^ {*})} \\cdot \\sqrt {\\frac {\\ln (2 m (1 + 1 / \\epsilon))}{\\pi}}</span></div>

    <p class="text-gray-300">and in fact, for every basis <span class="math">\\mathbf{B}</span> of <span class="math">\\Lambda</span>,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\eta_ {\\epsilon} (\\Lambda) \\leq \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde {\\mathbf {B}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\sqrt {\\frac {\\ln (2 m (1 + 1 / \\epsilon))}{\\pi}}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We also recall the bound from [GPV08, Lemma 5.3] and [WW23b, Lemma 2.5] for the block-diagonal matrices. Here, we consider the ring setting which can be easily adapted from the aforementioned results.</p>

    <p class="text-gray-300">Lemma 2.5. Let <span class="math">\\ell, \\delta &amp;gt; 1</span> and suppose <span class="math">q</span> is prime and <span class="math">m \\geq 2n\\log_{\\delta}q</span>. Then, there exists a negligible function <span class="math">\\varepsilon</span> such that for all <span class="math">\\mathbf{A}_2, \\ldots, \\mathbf{A}_\\ell \\in \\mathcal{R}_q^{n \\times m}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\eta_ {\\varepsilon} \\left(\\Lambda^ {\\perp} \\left(\\operatorname {d i a g} \\left(\\mathbf {A} _ {1}, \\mathbf {A} _ {2}, \\dots , \\mathbf {A} _ {\\ell}\\right)\\right) \\leq \\delta \\cdot \\log (\\ell m N): \\mathbf {A} _ {1} \\leftarrow \\mathcal {R} _ {q} ^ {n \\times m} \\right] \\geq 1 - q ^ {n N} \\right.</span></div>

    <p class="text-gray-300">Further, we recall the regularity lemma from [LPR13].</p>

    <p class="text-gray-300"><strong>Lemma 2.6 (Regularity Lemma).</strong> Let <span class="math">q \\equiv 5 \\pmod{8}</span> be a prime, <span class="math">N = \\mathsf{poly}(\\lambda)</span> and <span class="math">k, n</span> be positive integers such that <span class="math">\\mathsf{poly}(\\lambda) \\geq m \\geq n</span>. Take <span class="math">\\mathfrak{s} &amp;gt; 2N \\cdot q^{n/m + 2/(Nm)}</span>. Then, the following distributions are statistically close:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{(\\mathbf {A}, \\mathbf {A x}) \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathbf {A} \\leftarrow \\mathcal {R} _ {q} ^ {n \\times m} \\\\ \\mathbf {x} \\leftarrow \\mathcal {D} _ {\\mathfrak {s}} ^ {m N} \\end{array} \\right\\} \\text{ and } \\left\\{(\\mathbf {A}, \\mathbf {u}) \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathbf {A} \\leftarrow \\mathcal {R} _ {q} ^ {n \\times m} \\\\ \\mathbf {u} \\leftarrow \\mathcal {R} _ {q} ^ {n} \\end{array} \\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">This is slightly modified from the original result in [LPR13, Corollary 7.5] and [BTT22, Lemma 4.2] in a sense that <span class="math">\\mathbf{A}</span> might not be full-rank. However, Lemma 2.3 makes sure the event happens with negligible probability.</p>

    <p class="text-gray-300"><strong>Tail bounds.</strong> When sampling over a sufficiently wide discrete Gaussian distribution, a small portion of the probability mass will be in the tail of the distribution, and thus with overwhelming probability the sampled lattice elements will have short norm. The following lemma from [MR07] formalises this intuition.</p>

    <p class="text-gray-300"><strong>Lemma 2.7.</strong> For any <span class="math">0 &amp;lt; \\epsilon &amp;lt; 1</span>, lattice <span class="math">\\Lambda \\subseteq \\mathbb{R}^m</span>, center <span class="math">\\mathbf{c} \\in \\operatorname{Span}(\\Lambda)</span> and <span class="math">\\sigma &amp;gt; \\eta_{\\epsilon}(\\Lambda)</span>,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {z} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\sigma \\cdot \\sqrt {m}: \\mathbf {z} \\leftarrow \\mathcal {D} _ {\\sigma , \\Lambda , \\mathbf {c}} \\right] \\leq \\frac {1 + \\epsilon}{1 - \\epsilon} 2 ^ {- m}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We also recall the tail bounds for the regular discrete Gaussian distribution over integers [Lyu12].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 2.8.</strong> Let <span class="math">\\mathbf{z} \\gets D_{\\mathfrak{s}}^{m}</span>. Then $\\operatorname*{Pr}\\left[\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; t \\cdot \\mathfrak{s}\\sqrt{\\frac{m}{2\\pi}}\\right] &lt; \\left(te^{\\frac{1 - t^2}{2}}\\right)^m$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By setting <span class="math">t = \\sqrt{2\\pi}</span>, the right-hand side can be upper-bounded by <span class="math">2^{-2m}</span>.</p>

    <p class="text-gray-300"><strong>Preimage sampling for module lattices.</strong> Let <span class="math">\\mathbf{A} \\in \\mathcal{R}_q^{n \\times m}</span> be a matrix over <span class="math">\\mathcal{R}_q</span> and take any <span class="math">\\mathbf{u} \\in \\mathcal{R}_q^n</span>. We write <span class="math">\\mathbf{s} \\gets \\mathbf{A}_{\\sigma}^{-1}(\\mathbf{u})</span> to denote sampling <span class="math">\\mathbf{s} \\gets \\mathcal{D}_{\\sigma}^{mN}</span> conditioned on <span class="math">\\mathbf{A}\\mathbf{s} = \\mathbf{u}</span>. Assuming there is some <span class="math">\\mathbf{x} \\in \\mathcal{R}_q^m</span> which satisfies <span class="math">\\mathbf{A}\\mathbf{x} = \\mathbf{u}</span>, this is the same as sampling <span class="math">\\mathbf{s} \\gets \\mathcal{D}_{\\sigma, \\mathbf{x}, \\Lambda^\\perp(\\mathbf{A})}</span>.</p>

    <p class="text-gray-300">We will need the following lemma from [WW23b, Lemma 2.7] for proving hiding property of the commitment scheme.</p>

    <p class="text-gray-300"><strong>Lemma 2.9.</strong> Let <span class="math">n, m, q &amp;gt; 0</span>. Take any matrices <span class="math">\\mathbf{A} \\in \\mathcal{R}_q^{n \\times m}</span>, <span class="math">\\mathbf{B} \\in \\mathcal{R}_q^{n \\times \\ell}</span> where <span class="math">\\ell = \\mathrm{poly}(n, \\log q)</span>. Suppose the columns of <span class="math">\\mathbf{A}</span> generate <span class="math">\\mathcal{R}_q</span> and let <span class="math">\\mathbf{C} := [\\mathbf{A} \\mid \\mathbf{B}]</span>. Then, for every target vector <span class="math">\\mathbf{t} \\in \\mathcal{R}_q^n</span> and any <span class="math">\\sigma \\geq \\eta_{\\epsilon}(\\Lambda^{\\perp}(\\mathbf{A}))</span> for some <span class="math">\\epsilon = \\mathrm{negl}(\\lambda)</span>, the following distributions are statistically close:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{\\mathbf {v} \\big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {v} \\leftarrow \\mathbf {C} _ {\\sigma} ^ {- 1} (\\mathbf {t}) \\right\\} \\text{ and } \\left\\{\\left[ \\begin{array}{l} \\mathbf {v} _ {1} \\\\ \\mathbf {v} _ {2} \\end{array} \\right] \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {v} _ {2} \\leftarrow \\mathcal {D} _ {\\sigma} ^ {\\ell N}, \\mathbf {v} _ {1} \\leftarrow \\mathbf {A} _ {\\sigma} ^ {- 1} (\\mathbf {t} - \\mathbf {B v} _ {2}) \\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><strong>Module-SIS.</strong> We recall the standard lattice-based Module-SIS assumption [LS15]</p>

    <p class="text-gray-300"><strong>Definition 2.10 (Module-SIS).</strong> Let <span class="math">q = q(\\lambda)</span>, <span class="math">n = n(\\lambda)</span>, <span class="math">m = m(\\lambda)</span>, <span class="math">\\beta = \\beta(\\lambda)</span> and <span class="math">N = N(\\lambda)</span>. We say that the <span class="math">\\mathsf{MSIS}_{n,m,N,q,\\beta}</span> assumption holds if for any PPT adversary <span class="math">\\mathcal{A}</span>, the following holds:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\begin{array}{l} \\mathbf {A s} = \\mathbf {0} \\wedge 0 &lt;   \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {x} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta \\end{array} \\right] \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathbf {A} \\leftarrow \\mathcal {R} _ {q} ^ {n \\times m} \\\\ \\mathbf {s} \\leftarrow \\mathcal {A} (\\mathbf {A}) \\end{array} \\right] \\leq \\operatorname {n e g l} (\\lambda).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">2.4 NTRU Lattices</p>

    <p class="text-gray-300">As defined before, let <span class="math">N</span> be a power of two, <span class="math">q</span> a positive integer and <span class="math">h\\in\\mathcal{R}_{q}</span>. The NTRU lattice associated to <span class="math">h</span> is defined as</p>

    <p class="text-gray-300"><span class="math">\\Lambda_{h}\\coloneqq\\{(u,v)\\in\\mathcal{R}^{2}:u+vh=0\\bmod q\\}\\enspace.</span></p>

    <p class="text-gray-300">Recall that there is an efficient algorithm NTRU.TrapGen <em>[x13, x35, x11, x20]</em>, which given modulus <span class="math">q</span>, the ring dimension <span class="math">N</span> and the parameter <span class="math">\\mathfrak{s}</span>, outputs <span class="math">h\\in\\mathcal{R}_{q}</span> and a short basis of <span class="math">\\Lambda_{h}</span>. Below, we assume that <span class="math">X^{N}+1</span> splits into two factors modulo <span class="math">q</span> and we apply the main result of Stehlé and Steinfeld <em>[x35]</em>.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Lemma 2.11 (NTRU Trapdoor Generation).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">q=\\omega(N)</span> be a prime such that <span class="math">q\\equiv 5\\pmod{8}</span>. Take <span class="math">\\epsilon\\in(0,1/3)</span> and <span class="math">\\mathfrak{s}\\geq\\max(\\sqrt{N\\ln(8Nq)}\\cdot q^{1/2+\\epsilon},\\omega(N^{3/2}\\ln^{3/2}N))</span>. Then, there is a PPT algorithm NTRU.TrapGen<span class="math">(q,N,\\mathfrak{s})</span> which with an overwhelming probability outputs <span class="math">h\\in\\mathcal{R}_{q}</span> and a basis <span class="math">\\mathbf{T}_{\\textsf{NTRU}}</span> of <span class="math">\\Lambda_{h}</span> such that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{\\mathbf{T}}_{\\textsf{NTRU}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq N\\mathfrak{s}<span class="math">. Further, the statistical distance between the distribution of </span>h<span class="math"> and uniform over </span>\\mathcal{R}_{q}^{\\times}<span class="math"> is at most </span>2^{10N}q^{-\\lfloor\\epsilon N\\rfloor}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">2.5 Gadget Trapdoors</h3>

    <p class="text-gray-300">In this section, we recall the notion of gadget trapdoors as in <em>[x26]</em>, reformulate them for the module setting and state the key results on efficient sampling preimages using trapdoors.</p>

    <p class="text-gray-300">We say that a matrix <span class="math">\\mathbf{G}\\in\\mathcal{R}_{q}^{n\\times t}</span> is primitive if its columns generate <span class="math">\\mathcal{R}_{q}^{n}</span>, i.e. if <span class="math">\\mathbf{G}\\cdot\\mathcal{R}^{t}=\\mathcal{R}_{q}^{n}</span>. Note that if <span class="math">\\mathbf{G}</span> is primitive, then <span class="math">\\textsf{rot}(\\mathbf{G})</span> also is w.r.t. <span class="math">\\mathbb{Z}_{q}^{nN}</span>(i.e. <span class="math">\\textsf{rot}(\\mathbf{G})\\mathbb{Z}^{tN}=\\mathbb{Z}_{q}^{nN}</span>). We also recall the notion of a gadget trapdoor.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Definition 2.12.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbf{A}\\in\\mathcal{R}_{q}^{n\\times m},\\mathbf{H}\\in\\mathcal{R}_{q}^{n\\times n},\\mathbf{G}\\in\\mathcal{R}_{q}^{n\\times t}</span> with <span class="math">t\\geq n</span> and <span class="math">\\mathbf{H}</span> invertible over <span class="math">\\mathcal{R}_{q}</span>. A <span class="math">\\mathbf{G}</span>-trapdoor for <span class="math">\\mathbf{A}</span> with tag <span class="math">\\mathbf{H}</span> is a matrix <span class="math">\\mathbf{R}\\in\\mathcal{R}_{q}^{m\\times t}</span> with <span class="math">\\mathbf{A}\\mathbf{R}=\\mathbf{H}\\mathbf{G}</span>. The quality of a trapdoor is <span class="math">s_{1}(\\mathbf{R})</span>.</p>

    <p class="text-gray-300">When not specified, we set the tag <span class="math">\\mathbf{H}\\coloneqq\\mathbf{I}</span>. In fact, all the theorems in this section can be generalised with a tag.</p>

    <p class="text-gray-300">In this work, we consider one particular primitive matrix that naturally represents <span class="math">\\delta</span>-base decomposition which we call the gadget matrix.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Definition 2.13 (Gadget Matrix).</h6>

    <p class="text-gray-300">Let <span class="math">\\delta\\geq 2</span>. We set <span class="math">\\tilde{q}\\coloneqq\\lfloor\\log_{\\delta}q\\rfloor+1</span>, and <span class="math">\\mathbf{g}^{\\top}=[1,\\delta,\\ldots,\\delta^{\\tilde{q}-1}]\\in\\mathcal{R}_{q}^{1\\times\\tilde{q}}</span> and <span class="math">\\mathbf{G}_{n}\\coloneqq\\mathbf{I}_{n}\\otimes\\mathbf{g}^{\\top}\\in\\mathcal{R}_{q}^{n\\times n\\tilde{q}}</span>. When the dimension are clear from context we simply write <span class="math">\\mathbf{G}</span>. Write <span class="math">\\mathbf{G}_{n}^{-1}:\\mathcal{R}_{q}^{n\\times t}\\to\\mathcal{R}_{q}^{n\\tilde{q}\\times t}</span> for the inverse function that takes a matrix of entries in <span class="math">\\mathcal{R}_{q}</span>, and decomposes each entry w.r.t. the base <span class="math">\\delta</span>. We also write <span class="math">\\mathbf{g}^{-1}</span> for <span class="math">\\mathbf{G}_{1}^{-1}</span>.</p>

    <p class="text-gray-300"><em>[x26, Lemma 5.3]</em> says that having a <span class="math">\\mathbf{G}</span>-trapdoor for some matrix <span class="math">\\mathbf{A}</span> enables to translate any nice basis of <span class="math">\\mathbf{G}</span>’s induced lattice into one for <span class="math">\\mathbf{A}</span>’s, whose shortness is proportional to the quality of the trapdoor.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Lemma 2.14.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbf{A}\\in\\mathcal{R}_{q}^{n\\times m}</span>, <span class="math">\\mathbf{G}\\in\\mathcal{R}_{q}^{n\\times t}</span> be the gadget matrix with decomposition base <span class="math">\\delta</span>, and suppose there exists a <span class="math">\\mathbf{G}</span>-trapdoor <span class="math">\\mathbf{R}</span> for <span class="math">\\mathbf{A}</span>. Then, there is a basis <span class="math">\\mathbf{S}_{\\mathbf{A}}</span> of <span class="math">\\Lambda^{\\perp}(\\mathbf{A})</span> which satisfies $\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{\\mathbf{S}}_{\\mathbf{A}}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq(s_{1}(\\mathbf{R})+1)\\sqrt{\\delta^{2}+1}<span class="math">. In particular, if </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{R}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\beta<span class="math"> then for </span>\\epsilon=\\textsf{negl}(\\lambda)$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\eta_{\\epsilon}(\\Lambda^{\\perp}(\\mathbf{A}))\\leq\\beta\\delta\\cdot\\omega(\\sqrt{N\\log mN})\\enspace.</span></p>

    <p class="text-gray-300">We now give crucial properties about the trapdoor generation from [MP12].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 2.15 (Trapdoor Generation).</strong> Let <span class="math">q \\equiv 5 \\pmod{8}</span> be a prime, <span class="math">N, n &amp;gt; 0, t = n\\tilde{q}</span> and <span class="math">\\mathbf{G}_n \\in \\mathcal{R}_q^{n \\times t}</span> be the gadget matrix. Take <span class="math">m &amp;gt; t + n</span>. Then, there is a PPT algorithm <span class="math">\\mathsf{TrapGen}(n, m)</span> that with an overwhelming probability returns two matrices <span class="math">(\\mathbf{A}, \\mathbf{R}) \\in \\mathcal{R}_q^{n \\times m} \\times \\mathcal{R}_q^{m \\times t}</span> such that <span class="math">\\mathbf{AR} = \\mathbf{G}_n</span> and $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{R} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\mathfrak{s}\\sqrt{2t(m - t)N}<span class="math"> where </span>\\mathfrak{s} &gt; 2N \\cdot q^{\\frac{n}{m - t} + \\frac{2}{N(m - t)}}<span class="math">. Moreover, </span>\\mathbf{A}<span class="math"> is statistically close to a uniformly random matrix in </span>\\mathcal{R}_q^{n \\times m}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Proof.</strong> Let <span class="math">m&#x27; = m - t</span>. Consider the following algorithm [MP12, Alg 1]:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample <span class="math">\\bar{\\mathbf{A}} \\gets \\mathcal{R}_q^{n \\times m&#x27;}</span>.</li>

      <li>Sample a matrix <span class="math">\\bar{\\mathbf{R}} \\gets \\mathcal{D}_{\\mathfrak{s}}^{m&#x27;N \\times tN}</span> from a discrete Gaussian distribution.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. Return $\\mathbf{A} \\coloneqq [\\bar{\\mathbf{A}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{G}_n - \\bar{\\mathbf{A}} \\bar{\\mathbf{R}}]<span class="math"> and </span>\\mathbf{R} \\coloneqq \\begin{bmatrix} \\bar{\\mathbf{R}} \\\\ \\mathbf{I}_l \\end{bmatrix}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">First, <span class="math">\\mathbf{AR} = \\mathbf{G}</span> as desired and $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{R} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\sqrt{t(\\mathfrak{s}^2 m' N + 1)} \\leq \\mathfrak{s} \\sqrt{2t(m - t)N}<span class="math"> with an overwhelming probability by Lemma 2.8 for </span>t = \\sqrt{2\\pi}<span class="math">. To argue pseudorandomness, we apply Lemma 2.6 and the hybrid argument to get that </span>\\bar{\\mathbf{A}} \\bar{\\mathbf{R}}<span class="math"> is statistically close to uniform over </span>\\mathcal{R}_q^{n \\times t}<span class="math">, and thus so is </span>\\mathbf{A}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The next lemma states that given a short <span class="math">\\mathbf{G}</span>-trapdoor matrix <span class="math">\\mathbf{R}</span> for <span class="math">\\mathbf{A}</span>, one can efficiently sample preimages of <span class="math">\\mathbf{A}</span> according to the discrete Gaussian distribution.</p>

    <p class="text-gray-300"><strong>Lemma 2.16 (Preimage Sampling).</strong> Let <span class="math">N, n, m &amp;gt; 0</span> and <span class="math">t = n\\tilde{q}</span>. Then, there exists a PPT algorithm <span class="math">\\mathsf{SamplePre}(\\mathbf{A}, \\mathbf{R}, \\mathbf{v}, \\sigma)</span> that takes as input a matrix <span class="math">\\mathbf{A} \\in \\mathcal{R}_q^{n \\times m}</span>, a <span class="math">\\mathbf{G}_n</span>-trapdoor <span class="math">\\mathbf{R} \\in \\mathcal{R}_q^{m \\times t}</span> for <span class="math">\\mathbf{A}</span> with a tag <span class="math">\\mathbf{H}</span>, a target vector <span class="math">\\mathbf{v} \\in \\mathcal{R}_q^n</span> in the column-span of <span class="math">\\mathbf{A}</span>, and a Gaussian parameter <span class="math">\\sigma</span>, and outputs a vector <span class="math">\\mathbf{s} \\in \\mathcal{R}_q^m</span> such that <span class="math">\\mathbf{A}\\mathbf{s} = \\mathbf{v}</span>. Further, if <span class="math">\\sigma \\geq \\delta s_1(\\mathbf{R}) \\cdot \\omega(\\sqrt{\\log nN})</span>, then the statistical distance between the following distributions is negligible:</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{\\mathbf {s} \\leftarrow \\text {SamplePre} (\\mathbf {A}, \\mathbf {R}, \\mathbf {v}, \\sigma) \\right\\} \\text{ and } \\left\\{\\mathbf {s} \\leftarrow \\mathbf {A} _ {\\sigma} ^ {- 1} (\\mathbf {v}) \\right\\}.</span></div>

    <p class="text-gray-300">We extend this algorithm for matrices, i.e. for a matrix <span class="math">\\mathbf{V} \\in \\mathcal{R}_q^{n \\times \\ell}</span> with columns <span class="math">\\mathbf{v}_1, \\ldots, \\mathbf{v}_\\ell</span>, we define <span class="math">\\text{SamplePre}(\\mathbf{A}, \\mathbf{R}, \\mathbf{V}, \\sigma)</span> to be the algorithm which returns a matrix <span class="math">\\mathbf{S} \\in \\mathcal{R}_q^{m \\times \\ell}</span>, where the <span class="math">i</span>-th column is the output of <span class="math">\\text{SamplePre}(\\mathbf{A}, \\mathbf{R}, \\mathbf{v}_i, \\sigma)</span>.</p>

    <p class="text-gray-300"><strong>Subtractive sets for monomials.</strong> We recall the following widely-used result from [BCKLN14], which says that the (scaled) inverse of two distinct monomials in <span class="math">\\mathcal{R}</span> has coefficients in <span class="math">\\{-1,0,1\\}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 2.17.</strong> Let <span class="math">\\mathcal{C} \\coloneqq \\{X^i : i \\in \\mathbb{Z}\\} \\subseteq \\mathcal{R}</span>. Then, for any two distinct <span class="math">x, y \\in \\mathcal{C}</span>, we have $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{2}{x - y} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = 1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Short elements are invertible.</strong> For <span class="math">\\kappa &amp;gt; 0</span>, we define $S_{\\kappa} \\coloneqq \\{x \\in \\mathcal{R}_q : \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq \\kappa\\}<span class="math"> to be the set of ring elements in </span>\\mathcal{R}_q<span class="math"> with infinity norm at most </span>\\kappa$. We recall the following invertibility result by Lyubashevsky and Seiler [LS18].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Lemma 2.18.</strong> Let <span class="math">1 \\leq l &amp;lt; N</span> be a power-of-two and suppose <span class="math">q \\equiv 2N / l + 1 \\pmod{4N / l}</span>. Then, every non-zero element in <span class="math">S_{\\kappa}</span> is invertible over <span class="math">\\mathcal{R}_q</span> as long as <span class="math">\\kappa &amp;lt; \\sqrt{l / N} \\cdot q^{l / N}</span>.</p>

    <p class="text-gray-300">We will use this lemma for <span class="math">q \\equiv 5 \\pmod{8}</span>.</p>

    <p class="text-gray-300">24</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 3: Rejection sampling [BTT22].</p>

    <p class="text-gray-300">Rejection sampling. A crucial component in proving the zero-knowledge property of lattice-based (non-interactive) arguments is a rejection sampling procedure [Lyu12]. We recall the generalised version introduced recently by Boschini et al. [BTT22] for discrete Gaussian over arbitrary lattices (here we omit the case for ellipsoidal Gaussians).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma 2.19 (Rejection Sampling [BTT22]). Take any  <span class="math">\\alpha, T &amp;gt; 0</span>  and  <span class="math">\\varepsilon \\leq 1/2</span> . Let  <span class="math">\\Lambda \\subseteq \\mathcal{R}^m</span>  be a lattice over  <span class="math">\\mathcal{R}</span>  and  <span class="math">\\sigma \\geq \\max(\\alpha T, \\eta_{\\varepsilon}(\\Lambda))</span>  be a parameter. Let  <span class="math">h: \\mathcal{R}^m \\times \\mathcal{R}^m \\to [0,1]</span>  be a probability distribution which returns  <span class="math">(\\mathbf{u}, \\mathbf{v})</span>  where the vector  <span class="math">\\mathbf{v}</span>  satisfies  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{v}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq T<span class="math"> . Further, define  </span>M := \\exp(\\frac{\\pi}{\\alpha^2} + 1)<span class="math">  and  </span>\\epsilon := 2\\frac{1 + \\varepsilon}{1 - \\varepsilon} \\exp(-\\alpha^2 \\cdot \\frac{\\pi - 1}{\\pi^2})<span class="math"> . Then, the statistical distance between distributions RejSamp and SimRS defined in Figure 3 is at most  </span>\\frac{\\epsilon}{2M} + \\frac{2\\varepsilon}{M}<span class="math"> . Moreover, the probability that RejSamp outputs something is at least  </span>\\frac{1 - \\epsilon}{M} \\left(1 - \\frac{4\\varepsilon}{(1 + \\varepsilon)^2}\\right)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We recall the notion of a commitment scheme, which is a crucial component of various proof systems. As folklore in lattice-based cryptography, we introduce the slack space, which has a role in the binding property.</p>

    <p class="text-gray-300">Definition 2.20. Let  <span class="math">\\mathsf{CM} = (\\mathsf{Setup},\\mathsf{Commit},\\mathsf{Open})</span>  be a triple of PPT algorithms. We say that CM is a commitment scheme over  <span class="math">\\mathcal{M}</span>  with slack space  <span class="math">S</span>  if it has the following syntax:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup  <span class="math">(1^{\\lambda})\\to</span>  crs takes a security parameter  <span class="math">\\lambda</span>  (specified in unary) and outputs a common reference string crs.</li>

      <li>Commit(crs,  <span class="math">m) \\to (C, \\mathsf{st})</span>  takes a common reference string crs a message  <span class="math">m \\in \\mathcal{M}</span>  and outputs a commitment  <span class="math">C</span>  and decommitment state st.</li>

      <li>Open(crs,  <span class="math">C, m, \\mathsf{st}, c</span> ) takes a common reference string crs, a commitment  <span class="math">C</span> , a message  <span class="math">m \\in \\mathcal{M}</span> , a decommitment state st and a relaxation factor  <span class="math">^{12}c \\in S</span>  and outputs a bit indicating whether  <span class="math">C</span>  is a valid commitment to  <span class="math">m</span>  under crs.</li>

    </ul>

    <p class="text-gray-300">We define the key properties of the commitment scheme: correctness, (relaxed) binding and hiding. In the following, we denote the message space as  <span class="math">\\mathcal{M}</span>  and the slack space as  <span class="math">\\mathcal{S}</span> .</p>

    <p class="text-gray-300">Definition 2.21 (Completeness). We say that a commitment scheme  <span class="math">\\mathsf{CM} = (\\mathsf{Setup},\\mathsf{Commit},\\mathsf{Open})</span>  satisfies completeness if there exists a global relaxation factor  <span class="math">c^* \\in S</span>  such that for every  <span class="math">m \\in \\mathcal{M}</span> :</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\mathsf {O p e n} (\\mathsf {c r s}, C, m, \\mathsf {s t}, c ^ {*}) = 1 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\mathsf {c r s} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}) \\\\ C, \\mathsf {s t} \\leftarrow \\mathsf {C o m m i t} (\\mathsf {c r s}, m) \\end{array} \\right. \\right] \\geq 1 - \\mathsf {n e g l} (\\lambda)  .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Definition 2.22 (Relaxed Binding). A commitment scheme <span class="math">\\mathsf{CM} = (\\mathsf{Setup}, \\mathsf{Commit}, \\mathsf{Open})</span> satisfies relaxed binding if for every PPT adversary <span class="math">\\mathcal{A}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} m \\neq m ^ {\\prime} \\wedge m, m ^ {\\prime} \\in \\mathcal {M} \\wedge &amp;amp; \\mathsf {c r s} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}) \\\\ \\mathsf {O p e n} (\\mathsf {c r s}, C, m, \\mathsf {s t}, c) = 1 \\wedge &amp;amp; \\left(C, \\begin{array}{c} (m, \\mathsf {s t}, c), \\\\ (m ^ {\\prime}, \\mathsf {s t} ^ {\\prime}, c ^ {\\prime}) \\end{array} \\right) \\leftarrow \\mathcal {A} (\\mathsf {c r s}) \\end{array} \\right] = \\mathsf {n e g l} (\\lambda).</span></div>

    <p class="text-gray-300">Definition 2.23 (Hiding). A commitment scheme <span class="math">\\mathsf{CM} = (\\mathsf{Setup}, \\mathsf{Commit}, \\mathsf{Open})</span> satisfies hiding if for every (stateful) PPT adversary <span class="math">\\mathcal{A}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} &amp;amp; \\mathsf {c r s} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}), (m _ {0}, m _ {1}) \\leftarrow \\mathcal {A} (\\mathsf {c r s}) \\\\ b \\leftarrow \\{0, 1 \\} \\\\ C, \\mathsf {s t} \\leftarrow \\mathsf {C o m m i t} (\\mathsf {c r s}, m _ {b}) \\\\ b ^ {\\prime} \\leftarrow \\mathcal {A} (C) \\end{array} \\right] \\leq \\frac {1}{2} + \\mathsf {n e g l} (\\lambda).</span></div>

    <h2 id="sec-32" class="text-2xl font-bold">2.7 Polynomial Commitment Scheme</h2>

    <p class="text-gray-300">We also recall the notion of polynomial commitment schemes [KZG10]. Polynomial commitment schemes extend commitments with the ability to prove evaluations of the committed polynomial.</p>

    <p class="text-gray-300">Definition 2.24. Let <span class="math">\\mathsf{PC} = (\\mathsf{Setup},\\mathsf{Commit},\\mathsf{Open},\\mathsf{Eval},\\mathsf{Verify})</span> be a tuple of algorithms. PC is a polynomial commitment scheme over a ring <span class="math">R</span> with degree bound <span class="math">d</span> and slack space <span class="math">\\mathcal{S}</span> if:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(Setup, Commit, Open) is a commitment scheme over</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {M} := \\left\\{(f _ {0}, f _ {1}, \\dots , f _ {d}) \\in R ^ {d + 1}: \\sum_ {i = 0} ^ {d} f _ {i} \\mathsf {X} ^ {i} \\in R [ \\mathsf {X} ] \\right\\}</span></div>

    <p class="text-gray-300">with slack space <span class="math">\\mathcal{S}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Eval(crs, <span class="math">C, u, \\mathsf{st}</span>) <span class="math">\\rightarrow</span> <span class="math">\\pi</span> takes a common reference string crs, a commitment <span class="math">C</span>, an evaluation point <span class="math">u \\in R</span>, auxiliary state st and outputs an evaluation proof <span class="math">\\pi</span>.</li>

      <li>Verify(crs, <span class="math">C, u, z, \\pi) \\to 0/1</span> takes a common reference string crs, a commitment <span class="math">C</span>, an evaluation point <span class="math">u \\in \\mathcal{R}</span>, a claimed image <span class="math">z \\in R</span>, an evaluation proof <span class="math">\\pi</span>, and outputs a bit indicating whether <span class="math">\\pi</span> is a valid evaluation proof that the polynomial committed to in <span class="math">C</span> evaluates to <span class="math">z</span> at the point <span class="math">u</span>. We also consider a setting in which Eval and Verify are replaced with an interactive two-party protocol between a prover and a verifier, and refer to that setting as an interactive polynomial commitment scheme.</li>

    </ul>

    <p class="text-gray-300">Additionally, we require that the evaluations procedure satisfy some additional properties that we detail next. For simplicity, we give these definitions for non-interactive polynomial commitments, the interactive variant follows similarly.</p>

    <p class="text-gray-300">Definition 2.25 (Evaluation Completeness). We say that a polynomial commitment scheme <span class="math">\\mathsf{PC} = (\\mathsf{Setup},\\mathsf{Commit},\\mathsf{Open},\\mathsf{Eval},\\mathsf{Verify})</span> satisfies completeness if for every polynomial <span class="math">f\\in R^{\\leq d}[\\mathsf{X}]</span> and any evaluation point <span class="math">u\\in R</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} &amp;amp; \\mathsf {c r s} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}) \\\\ \\mathsf {V e r i f y} (\\mathsf {c r s}, C, u, f (u), \\pi) = 0 &amp;amp; C, \\mathsf {s t} \\leftarrow \\mathsf {C o m m i t} (\\mathsf {c r s}, f) \\\\ &amp;amp; \\pi \\leftarrow \\mathsf {E v a l} (\\mathsf {c r s}, C, u, \\mathsf {s t}) \\end{array} \\right] = \\mathsf {n e g l} (\\lambda).</span></div>

    <p class="text-gray-300">Definition 2.26 (Knowledge Soundness). We say that a polynomial commitment scheme <span class="math">\\mathsf{PC} = (\\mathsf{Setup}, \\mathsf{Commit}, \\mathsf{Open}, \\mathsf{Eval}, \\mathsf{Verify})</span> is knowledge sound with knowledge error <span class="math">\\kappa</span> if for all stateful PPT adversaries <span class="math">\\mathcal{P}^*</span>, there exists an expected PPT extractor <span class="math">\\mathcal{E}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ b = 1 \\wedge \\left( \\begin{array}{c} \\operatorname {O p e n} (\\operatorname {c r s}, C, f, \\operatorname {s t}, c) \\neq 1 \\vee \\\\ f (u) \\neq z \\end{array} \\right) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\operatorname {c r s} \\leftarrow \\operatorname {S e t u p} (1 ^ {\\lambda}) \\\\ (C, u, z, \\pi) \\leftarrow \\mathcal {P} ^ {<em>} (\\operatorname {c r s}) \\\\ b = \\operatorname {V e r i f y} (\\operatorname {c r s}, C, u, z, \\pi) \\\\ (f, \\operatorname {s t}, c) \\leftarrow \\mathcal {E} ^ {\\mathcal {P} ^ {</em>}} (\\operatorname {c r s}, C, u, z, \\pi) \\end{array} \\right. \\right] \\leq \\kappa (\\lambda) .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Here, the extractor <span class="math">\\mathcal{E}</span> has a black-box oracle access to the (malicious) prover <span class="math">\\mathcal{P}^*</span> and can rewind it to any point in the interaction.</p>

    <h2 id="sec-33" class="text-2xl font-bold">2.8 Interactive Proofs</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathsf{R} \\subseteq \\{0,1\\}^<em> \\times \\{0,1\\}^</em> \\times \\{0,1\\}^*</span> be a ternary relation. If <span class="math">(\\mathfrak{i}, \\mathfrak{x}, \\mathfrak{w}) \\in \\mathsf{R}</span>, we say that <span class="math">\\mathfrak{i}</span> is an index, <span class="math">\\mathfrak{x}</span> is a statement and <span class="math">\\mathfrak{w}</span> is a witness for <span class="math">\\mathfrak{x}</span>. We denote <span class="math">\\mathsf{R}(\\mathfrak{i}, \\mathfrak{x}) = \\{\\mathfrak{w} : \\mathsf{R}(\\mathfrak{i}, \\mathfrak{x}, \\mathfrak{w}) = 1\\}</span>. In this work, we only consider NP relations <span class="math">\\mathsf{R}</span> for which a witness <span class="math">w</span> can be verified in time $\\text{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> for all </span>(\\mathfrak{i}, \\mathfrak{x}, \\mathfrak{w}) \\in \\mathsf{R}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">A proof system <span class="math">\\Pi = (\\mathsf{Setup},\\mathcal{P},\\mathcal{V})</span> for relation <span class="math">\\mathsf{R}</span> consists of three PPT algorithms: the Setup algorithm, prover <span class="math">\\mathcal{P}</span>, and the verifier <span class="math">\\mathcal{V}</span>. The latter two are interactive and stateful. We write <span class="math">(tr,b)\\gets \\langle \\mathcal{P}(\\mathfrak{i},\\mathfrak{x},\\mathfrak{w}),\\mathcal{V}(\\mathfrak{i},\\mathfrak{x})\\rangle</span> for running <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> on inputs <span class="math">\\mathfrak{i},\\mathfrak{x},\\mathfrak{w}</span> and <span class="math">\\mathfrak{i},\\mathfrak{x}</span> respectively and getting communication transcript <span class="math">tr</span> and the verifier's decision bit <span class="math">b</span>. We use the convention that <span class="math">b = 0</span> means reject and <span class="math">b = 1</span> means accept the prover's claim of knowing <span class="math">\\mathfrak{w}</span> such that <span class="math">(\\mathfrak{x},\\mathfrak{w})\\in R</span>. If <span class="math">tr</span> contains a <span class="math">\\perp</span> then we say that <span class="math">\\mathcal{P}</span> aborts. Unless stated otherwise, we will assume that the first and the last message are sent from a prover. Hence, the protocol between <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> has an odd number of rounds. A <span class="math">\\Sigma</span>-protocol is a three-round protocol. Further, we say a protocol is public coin if the verifier's challenges are chosen uniformly at random independently of the prover's messages.</p>

    <p class="text-gray-300">We recall a few basic properties of interactive proof systems: completeness and knowledge soundness.</p>

    <p class="text-gray-300">Definition 2.27 (Completeness). A proof system <span class="math">\\Pi = (\\mathsf{Setup},\\mathcal{P},\\mathcal{V})</span> for the relation <span class="math">\\mathsf{R}</span> has statistical completeness with correctness error <span class="math">\\epsilon</span> if for all adversaries <span class="math">\\mathcal{A}</span>,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ b = 0 \\wedge (\\mathfrak {i}, \\mathfrak {x}, \\mathfrak {w}) \\in \\mathsf {R} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\mathfrak {i} \\leftarrow \\operatorname {S e t u p} (1 ^ {\\lambda}) \\\\ (\\mathfrak {x}, \\mathfrak {w}) \\leftarrow \\mathcal {A} (\\mathfrak {i}) \\\\ (t r, b) \\leftarrow \\langle \\mathcal {P} (\\mathfrak {i}, \\mathfrak {x}, \\mathfrak {w}), \\mathcal {V} (\\mathfrak {i}, \\mathfrak {x}) \\rangle \\end{array} \\right. \\right] \\leq \\epsilon (\\lambda) .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Definition 2.28 (Knowledge Soundness). A proof system <span class="math">\\Pi = (\\mathsf{Setup},\\mathcal{P},\\mathcal{V})</span> for the relation <span class="math">\\mathsf{R}</span> is knowledge sound with knowledge error <span class="math">\\kappa</span> if there exists an expected PPT extractor <span class="math">\\mathcal{E}</span> such that for any stateful PPT adversary <span class="math">\\mathcal{P}^*</span>:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ b = 1 \\wedge (\\mathfrak {i}, \\mathfrak {x}, \\mathfrak {w}) \\notin \\mathsf {R} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\mathfrak {i} \\leftarrow \\operatorname {S e t u p} (1 ^ {\\lambda}) \\\\ (\\mathfrak {x}, \\mathfrak {s t}) \\leftarrow \\mathcal {P} ^ {<em>} (\\mathfrak {i}) \\\\ (t r, b) \\leftarrow \\langle \\mathcal {P} ^ {</em>} (\\mathfrak {i}, \\mathfrak {x}, \\mathfrak {s t}), \\mathcal {V} (\\mathfrak {i}, \\mathfrak {x}) \\rangle \\\\ \\mathfrak {w} \\leftarrow \\mathcal {E} ^ {\\mathcal {P} ^ {*}} (\\mathfrak {i}, \\mathfrak {x}) \\end{array} \\right. \\right] \\leq \\kappa (\\lambda) .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Here, the extractor <span class="math">\\mathcal{E}</span> has a black-box oracle access to the (malicious) prover <span class="math">\\mathcal{P}^*</span> and can rewind it to any point in the interaction.</p>

    <p class="text-gray-300">27</p>

    <p class="text-gray-300">2.9 Coordinate-Wise Special Soundness</p>

    <p class="text-gray-300">We generalise the notion of special soundness in the following way. Let <span class="math">S</span> be a set and <span class="math">\\ell \\in \\mathbb{N}</span>. Namely, take two vectors <span class="math">\\mathbf{x} := (x_1, \\ldots, x_\\ell), \\mathbf{y} := (y_1, \\ldots, y_\\ell) \\in S^\\ell</span>. Then, we define the following relation “<span class="math">\\equiv_i</span>” for fixed <span class="math">i \\in [\\ell]</span> as:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{x} \\equiv_i \\mathbf{y} \\iff x_i \\neq y_i \\wedge \\forall j \\in [\\ell] \\setminus \\{i\\}, x_j = y_j.</span></div>

    <p class="text-gray-300">That is, vectors <span class="math">\\mathbf{x}</span> and <span class="math">\\mathbf{y}</span> have the same values in all coordinates apart from the <span class="math">i</span>-th one. For <span class="math">\\ell = 1</span>, the relations boil down to checking whether two elements are distinct. Further, we can define the set</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{SS}(S, \\ell, k) := \\left\\{ \\begin{array}{l l} \\exists e \\in [K], \\forall i \\in [\\ell], \\\\ \\{\\mathbf{x}_1, \\ldots, \\mathbf{x}_K\\} \\subseteq (S^\\ell)^K: \\exists J = \\{j_1, \\ldots, j_{k-1}\\} \\subseteq [K] \\setminus \\{e\\}, \\\\ \\forall j \\in J, \\mathbf{x}_e \\equiv_i \\mathbf{x}_j \\end{array} \\right\\},</span></div>

    <p class="text-gray-300">where <span class="math">K \\coloneqq \\ell(k - 1) + 1</span>. To develop an intuition of the meaning of <span class="math">\\mathsf{SS}(S, \\ell, k)</span>, consider a set <span class="math">X = \\{\\mathbf{x}_1, \\ldots, \\mathbf{x}_K\\} \\in \\mathsf{SS}(S, \\ell, k)</span>. There is a “central” vector <span class="math">\\mathbf{x}_e \\in X</span> such that for each coordinate of <span class="math">\\mathbf{x}_e</span>, there are <span class="math">k - 1</span> other vectors in <span class="math">X</span> that differ from <span class="math">\\mathbf{x}_e</span> only in that coordinate. In other words, for each coordinate, there are <span class="math">k</span> vectors in <span class="math">X</span> that differ from each other only in that coordinate, and <span class="math">\\mathbf{x}_e</span> is always one of them. As a simple example,</p>

    <div class="my-4 text-center"><span class="math-block">\\{(2, 0, 0), (0, 1, 0), (0, 0, 0), (0, 0, 5), (0, 0, 4), (0, 2, 0), (3, 0, 0) \\} \\in \\mathsf{SS}(\\mathbb{Z}_7, 3, 3)</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the “central” vector <span class="math">(0,0,0)</span> differs in, and only in, each coordinate from two other vectors in the set. Note that for <span class="math">\\ell = 1</span>, this set simply contains <span class="math">k</span>-sets of distinct elements in <span class="math">S</span>.</li>

    </ul>

    <p class="text-gray-300">We are ready to define the notion of coordinate-wise special soundness. We start with the case for <span class="math">\\Sigma</span>-protocols.</p>

    <p class="text-gray-300"><strong>Definition 2.29 (CWSS for <span class="math">\\Sigma</span>-protocols).</strong> Let <span class="math">\\Pi = (\\mathsf{Setup}, \\mathcal{P}, \\mathcal{V})</span> be public-coin three-round interactive proof system for relation <span class="math">\\mathsf{R}</span>, and suppose the challenge space of <span class="math">\\mathcal{V}</span> is <span class="math">\\mathcal{C} = S^\\ell</span>. We say that <span class="math">\\Pi</span> is <span class="math">\\ell</span>-coordinate-wise <span class="math">k</span>-special sound if there exists a polynomial time algorithm that on input an index <span class="math">\\mathbb{i}</span>, statement <span class="math">\\mathbf{x}</span> and <span class="math">\\ell(k - 1) + 1</span> accepting transcripts <span class="math">(a, \\mathbf{c}_i, z_i)_{i \\in [\\ell(k - 1) + 1]}</span>, with <span class="math">\\{\\mathbf{c}_1, \\ldots, \\mathbf{c}_{\\ell(k - 1) + 1}\\} \\in \\mathsf{SS}(S, \\ell, k)</span> and common first message <span class="math">a</span>, outputs a witness <span class="math">\\mathbf{w} \\in \\mathsf{R}(\\mathbb{i}, \\mathbf{x})</span>.</p>

    <p class="text-gray-300">Clearly, we obtain the standard <span class="math">k</span>-special soundness property if <span class="math">\\ell = 1</span>. Next, we extend this notion to multi-round protocols via a tree of transcripts. For simplicity, we assume that in each round the verifier picks challenge uniformly at random from the same challenge space <span class="math">S^\\ell</span>, which will be the case for most of our protocols.</p>

    <p class="text-gray-300"><strong>Definition 2.30 (CWSS for Multi-Round Protocols).</strong> Let <span class="math">\\Pi = (\\mathsf{Setup}, \\mathcal{P}, \\mathcal{V})</span> be public-coin <span class="math">(2\\mu + 1)</span>-round interactive proof system for relation <span class="math">\\mathsf{R}</span>, where in each round the verifier picks a uniformly random challenge from <span class="math">S^\\ell</span>. A tree of transcripts is a set of <span class="math">K = (\\ell(k - 1) + 1)^\\mu</span> arranged in the following tree structure. The nodes in the tree correspond to the prover’s messages and the edges correspond to the verifier’s challenges. Each node at depth <span class="math">i</span> has exactly <span class="math">\\ell(k - 1) + 1</span> children corresponding to <span class="math">\\ell(k - 1) + 1</span> distinct challenges which, as a set of vectors, lie in <span class="math">\\mathsf{SS}(S, \\ell, k)</span>. Every transcript corresponds to exactly one path from the root to a leaf node.</p>

    <p class="text-gray-300">We say that <span class="math">\\Pi</span> is <span class="math">\\ell</span>-coordinate-wise <span class="math">k</span>-special sound if there is a polynomial time algorithm that given an index <span class="math">\\mathbb{i}</span>, statement <span class="math">\\mathbf{x}</span> and the tree of transcripts, outputs a witness <span class="math">\\mathbf{w} \\in \\mathsf{R}(\\mathbb{i}, \\mathbf{x})</span>.</p>

    <p class="text-gray-300">28</p>

    <p class="text-gray-300">In this paper, we only focus on <span class="math">\\ell</span>-coordinate-wise 2-special sound protocols, which we will call <span class="math">\\ell</span>-coordinate-wise special sound.</p>

    <p class="text-gray-300">We prove in Section 7 that coordinate-wise special soundness implies knowledge soundness in the interactive setting.</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Lemma 2.31.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\Pi=(\\mathsf{Setup},\\mathcal{P},\\mathcal{V})</span> be public-coin <span class="math">(2\\mu+1)</span>-round interactive proof system for relation <span class="math">\\mathsf{R}</span> and suppose the challenge space of <span class="math">\\mathcal{V}</span> in each round is <span class="math">S^{\\ell}</span>. If <span class="math">\\Pi</span> is <span class="math">\\ell</span>-coordinate-wise <span class="math">k</span>-special sound and <span class="math">(\\ell(k-1))^{\\mu}=\\mathsf{poly}(\\lambda)</span>, then it is knowledge sound with knowledge error $\\mu\\ell(k-1)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The resulting knowledge extractor runs the malicious prover <span class="math">(\\ell(k-1)+1)^{\\mu}</span> times in expectation. Hence, in order to keep the knowledge extractor expected PPT, we need <span class="math">(\\ell(k-1))^{\\mu}=\\mathsf{poly}(\\lambda)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The result can be easily extended to the case, where in each <span class="math">i</span>-th round the challenges from the verifier are picked from <span class="math">S^{\\ell_{i}}</span> for <span class="math">\\ell_{i}&gt;0</span>. Then, the knowledge error becomes $(\\ell_{1}+\\ldots+\\ell_{\\mu})(k-1)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and the extractor runs the malicious prover at most </span>\\prod_{i=1}^{\\mu}(\\ell_{i}(k-1)+1)$ times.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, using the exact methodology as in <em>[x1]</em>, in Section 8 we show that coordinate-wise special soundness implies (adaptive) knowledge soundness of the Fiat-Shamir transformed protocol in the random oracle model.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Lemma 2.32 (Informal).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\Pi=(\\mathsf{Setup},\\mathcal{P},\\mathcal{V})</span> be public-coin <span class="math">(2\\mu+1)</span>-round interactive proof system for relation <span class="math">\\mathsf{R}</span> and suppose the challenge space of <span class="math">\\mathcal{V}</span> in each round is <span class="math">S^{\\ell}</span>. If <span class="math">\\Pi</span> is <span class="math">\\ell</span>-coordinate-wise <span class="math">k</span>-special sound and <span class="math">(\\ell(k-1))^{\\mu}=\\mathsf{poly}(\\lambda)</span>, then the Fiat-Shamir transformation of <span class="math">\\Pi</span> is knowledge sound in the random oracle model with knowledge error $(Q+1)\\mu\\ell(k-1)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, where </span>Q$ is the number of random oracle queries made by an adversary.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Our construction of the polynomial commitment will rely on a new lattice-based assumption PowerBASIS which is a special case of the BASIS assumption <span class="math">^{13}</span>  introduced by Wee and Wu [WW23b]. We begin by adapting the latter assumption to the ring setting. Recall that  <span class="math">\\mathbf{G}_n</span>  is a gadget matrix with base  <span class="math">\\delta</span>  as in Definition 2.13. We fix the prime modulus  <span class="math">q \\equiv 5 \\pmod{8}</span>  and set  <span class="math">\\tilde{q} \\coloneqq \\lfloor \\log_{\\delta} q \\rfloor + 1</span> .</p>

    <p class="text-gray-300">Definition 3.1 (BASIS). Let  <span class="math">q, n, m, n&#x27;, m&#x27;, \\ell, N, \\sigma, \\beta</span>  be lattice parameters. Let  <span class="math">\\mathsf{Samp}</span>  be a PPT algorithm, which given a matrix  <span class="math">\\mathbf{A} \\in \\mathcal{R}_q^{n \\times m}</span> , outputs a matrix  <span class="math">\\mathbf{B} \\in \\mathcal{R}_q^{n&#x27; \\times m&#x27;}</span>  along with auxiliary information  <span class="math">\\mathsf{aux}</span> . We say the  <span class="math">\\mathsf{BASIS}_{n,m,n&#x27;,m&#x27;,N,q,\\ell,\\sigma,\\beta}</span>  assumption holds w.r.t.  <span class="math">\\mathsf{Samp}</span>  if for any PPT adversary  <span class="math">\\mathcal{A}</span> :</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname * {P r} \\left[ \\begin{array}{c c} \\mathbf {A s} = \\mathbf {0} &amp; \\mathbf {A} \\leftarrow \\mathcal {R} _ {q} ^ {n \\times m}, (\\mathbf {B}, \\mathsf {a u x}) \\leftarrow \\mathsf {S a m p} (\\mathbf {A}) \\\\ 0 &lt;   \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {s} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta &amp; \\mathbf {T} \\leftarrow \\mathbf {B} _ {\\sigma} ^ {- 1} (\\mathbf {G} _ {n ^ {\\prime}}) \\\\ &amp; \\mathbf {s} \\leftarrow \\mathcal {A} (\\mathbf {A}, \\mathbf {B}, \\mathbf {T}, \\mathsf {a u x}) \\end{array} \\right] \\leq \\mathsf {n e g l} (\\lambda) .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Intuitively, the BASIS assumption says that it is hard to find a short solution for  <span class="math">\\mathbf{A}</span> , even when given a trapdoor for a matrix  <span class="math">\\mathbf{B}</span>  related to  <span class="math">\\mathbf{A}</span> . The trapdoor allows the adversary to sample preimages of  <span class="math">\\mathbf{B}</span> , and thus it is easy to break the assumption if  <span class="math">\\mathbf{B}</span>  contains too much information about  <span class="math">\\mathbf{A}</span> , e.g. when  <span class="math">\\mathbf{B} = \\mathbf{A}</span> .</p>

    <p class="text-gray-300">Furthermore, we provide three concrete instantiations of the sampling algorithm  <span class="math">\\mathsf{Samp}</span> .</p>

    <p class="text-gray-300">Definition 3.2 (BASIS Instantiations). We consider three concrete instantiations of the BASIS assumption:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>StructBASIS <span class="math">_{n,m,N,q,\\ell,\\sigma,\\beta}</span> : The sampling algorithm  <span class="math">\\mathsf{Samp}(\\mathbf{A})</span>  first generates a row  <span class="math">\\mathbf{a}^{\\intercal} \\gets \\mathcal{R}_q^m</span>  and sets</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A} ^ {\\star} := \\left[ \\begin{array}{l} \\mathbf {a} ^ {\\intercal} \\\\ \\mathbf {A} \\end{array} \\right] \\in \\mathcal {R} _ {q} ^ {(n + 1) \\times m}. \\tag {11}</span></div>

    <p class="text-gray-300">Further, it samples  <span class="math">\\mathbf{W}_i\\gets \\mathsf{GL}(n + 1,\\mathcal{R}_q)</span>  for all  <span class="math">i\\in [\\ell ]</span>  , and outputs</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {B} _ {\\ell} := \\left[ \\begin{array}{c c c c} \\mathbf {W} _ {1} \\mathbf {A} ^ {\\star} &amp;amp; &amp;amp; &amp;amp; - \\mathbf {G} _ {n + 1} \\\\ &amp;amp; \\ddots &amp;amp; &amp;amp; \\vdots \\\\ &amp;amp; &amp;amp; \\mathbf {W} _ {\\ell} \\mathbf {A} ^ {\\star} &amp;amp; - \\mathbf {G} _ {n + 1} \\end{array} \\right] \\quad a n d \\quad \\mathbf {a u x} := (\\mathbf {W} _ {1}, \\ldots , \\mathbf {W} _ {\\ell}) .</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>PowerBASIS <span class="math">_{n,m,N,q,\\ell,\\sigma,\\beta}</span> : Here,  <span class="math">\\mathsf{Samp}(\\mathbf{A})</span>  generates a row  <span class="math">\\mathbf{a}^{\\intercal} \\gets \\mathcal{R}_q^\\ell</span>  and sets  <span class="math">\\mathbf{A}^\\star</span>  as in (11). Then, it samples  <span class="math">\\mathbf{W} \\gets \\mathsf{GL}(n+1, \\mathcal{R}_q)</span> , and outputs</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {B} _ {\\ell} := \\left[ \\begin{array}{c c c c} \\mathbf {W} ^ {0} \\mathbf {A} ^ {\\star} &amp;amp; &amp;amp; &amp;amp; - \\mathbf {G} _ {n + 1} \\\\ &amp;amp; \\ddots &amp;amp; &amp;amp; \\vdots \\\\ &amp;amp; &amp;amp; \\mathbf {W} ^ {\\ell - 1} \\mathbf {A} ^ {\\star} &amp;amp; - \\mathbf {G} _ {n + 1} \\end{array} \\right] \\quad a n d \\quad \\mathbf {a u x} := \\mathbf {W}.</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>PRISIS <span class="math">_{n,m,N,q,\\ell,\\sigma,\\beta}</span> :  <span class="math">\\mathsf{Samp}(\\mathbf{A})</span>  samples a row  <span class="math">\\mathbf{a}^{\\intercal} \\gets \\mathcal{R}_q^\\ell</span>  and sets  <span class="math">\\mathbf{A}^\\star</span>  as in (11). Then, it samples  <span class="math">w \\gets \\mathsf{GL}(1, \\mathcal{R}_q)</span> , and outputs</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {B} _ {\\ell} := \\left[ \\begin{array}{c c c c} w ^ {0} \\mathbf {A} ^ {\\star} &amp;amp; &amp;amp; &amp;amp; - \\mathbf {G} _ {n + 1} \\\\ &amp;amp; \\ddots &amp;amp; &amp;amp; \\vdots \\\\ &amp;amp; &amp;amp; w ^ {\\ell - 1} \\mathbf {A} ^ {\\star} &amp;amp; - \\mathbf {G} _ {n + 1} \\end{array} \\right] \\quad a n d \\quad \\mathbf {a u x} := w .</span></div>

    <p class="text-gray-300">^{13} BASIS stands for Basis-Augmented Shortest Integer Solution.</p>

    <p class="text-gray-300">Informally, the StructBASIS variant corresponds to the structured version of the BASIS assumption used to build functional commitments [WW23b]. PowerBASIS is the special case, where instead of picking <span class="math">\\ell</span> uniformly random invertible matrices <span class="math">\\mathbf{W}_i</span>, one takes a single invertible matrix, and sets <span class="math">\\mathbf{W}_i \\coloneqq \\mathbf{W}^{i-1}</span> for <span class="math">i \\in [\\ell]</span>. Finally, PRISIS is the instance where each <span class="math">\\mathbf{W}_i \\coloneqq w^{i-1} \\mathbf{I}_{n+1}</span> for <span class="math">i \\in [\\ell]</span> and <span class="math">w \\in \\mathcal{R}_q</span> is an invertible element.</p>

    <p class="text-gray-300">Intuitively, StructBASIS seems to be the hardest variant to break out of the three since it carries the least structure. Then, PowerBASIS should be an easier problem due to the very specific relation between matrices <span class="math">\\mathbf{W}_i</span>. Finally, PRISIS carries a lot of structure, since it introduces commutativity between the matrices <span class="math">\\mathbf{W}_i</span> and <span class="math">\\mathbf{A}^<em></span>, i.e. <span class="math">w^{i-1}\\mathbf{A}^</em> = \\mathbf{A}^*(w^{i-1} \\cdot \\mathbf{I}_m)</span>, which can somehow be useful for the adversary to break the assumption.</p>

    <p class="text-gray-300"><strong>Remark 3.3.</strong> To simplify reductions in the paper, we explicitly require the matrices <span class="math">\\mathbf{W}_i</span> to be invertible (unlike in [WW23b]). Note that this condition can be dropped by arguing that, depending on the parameters <span class="math">q</span> and <span class="math">N</span>, with overwhelming probability a uniformly random matrix <span class="math">\\mathbf{W}</span> is invertible over <span class="math">\\mathcal{R}_q</span> (cf. Lemma 2.3).</p>

    <h2 id="sec-37" class="text-2xl font-bold">3.1 Hardness of BASIS for Low Dimensions</h2>

    <p class="text-gray-300">We analyse the relationship between the three newly introduced instantiations for the dimension <span class="math">\\ell = 2</span>. To this end, we analyse the following technical lemma which will be used in all our results of this section. Intuitively, it says that if one can find a short solution to a specific linear equation, then one can also build a BASIS trapdoor.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 3.4.</strong> Let <span class="math">n, m, N &amp;gt; 0</span> and <span class="math">\\alpha \\geq 1</span>. Denote <span class="math">t = n\\tilde{q}</span>. Then, there exists an efficient deterministic algorithm, that given as input a matrix <span class="math">\\mathbf{A}^* \\in \\mathcal{R}_q^{n \\times m}</span>, invertible <span class="math">\\mathbf{W}_1, \\mathbf{W}_2, \\mathbf{H} \\in \\mathrm{GL}(n, \\mathcal{R}_q)</span> and two matrices <span class="math">\\mathbf{T}_1, \\mathbf{T}_2 \\in \\mathcal{R}_q^{m \\times t}</span>, which satisfy $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\mathbf{T}_1, \\mathbf{T}_2) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\alpha<span class="math"> for </span>i = 1, 2$ and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {W} _ {1} \\mathbf {A} ^ {*} \\mathbf {T} _ {1} - \\mathbf {W} _ {2} \\mathbf {A} ^ {*} \\mathbf {T} _ {2} = \\mathbf {H} \\mathbf {G} _ {n},</span></div>

    <p class="text-gray-300">outputs a tag <span class="math">\\mathbf{H}^* \\in \\mathrm{GL}(2n, \\mathcal{R}_q)</span> and a <span class="math">\\mathbf{G}_{2n}</span>-trapdoor <span class="math">\\mathbf{S}</span> for the matrix <span class="math">\\mathbf{B}</span> defined as:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {B} := \\left[ \\begin{array}{c c c} \\mathbf {W} _ {1} \\mathbf {A} ^ {*} &amp;amp; \\mathbf {0} &amp;amp; - \\mathbf {G} \\\\ \\mathbf {0} &amp;amp; \\mathbf {W} _ {2} \\mathbf {A} ^ {*} &amp;amp; - \\mathbf {G} \\end{array} \\right]</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">with a tag <span class="math">\\mathbf{H}^*</span>, where $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{S}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\sqrt{2(\\alpha^2 + t^2N)}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Proof.</strong> Define the following matrices:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {S} _ {1, 3} := \\mathbf {G} ^ {- 1} \\left(\\mathbf {W} _ {1} \\mathbf {A} ^ {*} \\mathbf {T} _ {1} - \\mathbf {H} \\mathbf {G} _ {n}\\right) = \\mathbf {G} ^ {- 1} \\left(\\mathbf {W} _ {2} \\mathbf {A} ^ {*} \\mathbf {T} _ {2}\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {S} _ {2, 3} := \\mathbf {G} ^ {- 1} \\left(- \\mathbf {W} _ {1} \\mathbf {A} ^ {*} \\mathbf {T} _ {2} - \\mathbf {H} \\mathbf {G} _ {n}\\right) = \\mathbf {G} ^ {- 1} \\left(- \\mathbf {W} _ {1} \\mathbf {A} ^ {*} \\mathbf {T} _ {1}\\right).</span></div>

    <p class="text-gray-300">Then, by construction we get:</p>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\begin{array}{c c c} \\mathbf {W} _ {1} \\mathbf {A} ^ {*} &amp;amp; \\mathbf {0} &amp;amp; - \\mathbf {G} \\\\ \\mathbf {0} &amp;amp; \\mathbf {W} _ {2} \\mathbf {A} ^ {*} &amp;amp; - \\mathbf {G} \\end{array} \\right] \\left[ \\begin{array}{c c} \\mathbf {T} _ {1} &amp;amp; - \\mathbf {T} _ {1} \\\\ \\mathbf {T} _ {2} &amp;amp; - \\mathbf {T} _ {2} \\\\ \\mathbf {S} _ {1, 3} &amp;amp; \\mathbf {S} _ {2, 3} \\end{array} \\right] = \\left[ \\begin{array}{c c} \\mathbf {H G} &amp;amp; \\mathbf {0} \\\\ \\mathbf {0} &amp;amp; \\mathbf {H G} \\end{array} \\right] = \\left[ \\begin{array}{c c} \\mathbf {H} &amp;amp; \\mathbf {0} \\\\ \\mathbf {0} &amp;amp; \\mathbf {H} \\end{array} \\right] \\cdot \\left[ \\begin{array}{c c} \\mathbf {G} &amp;amp; \\mathbf {0} \\\\ \\mathbf {0} &amp;amp; \\mathbf {G} \\end{array} \\right].</span></div>

    <p class="text-gray-300">By setting</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {S} := \\left[ \\begin{array}{l l} \\mathbf {T} _ {1} &amp;amp; - \\mathbf {T} _ {1} \\\\ \\mathbf {T} _ {2} &amp;amp; - \\mathbf {T} _ {2} \\\\ \\mathbf {S} _ {1, 3} &amp;amp; \\mathbf {S} _ {2, 3} \\end{array} \\right] \\quad \\text {and} \\quad \\mathbf {H} ^ {*} := \\left[ \\begin{array}{l l} \\mathbf {H} &amp;amp; \\mathbf {0} \\\\ \\mathbf {0} &amp;amp; \\mathbf {H} \\end{array} \\right] ,</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">we observe that <span class="math">\\mathbf{S}</span> is a <span class="math">\\mathbf{G}_{2n}</span>-trapdoor for <span class="math">\\mathbf{B}</span> with a tag <span class="math">\\mathbf{H}^*</span> and $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{S} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2 \\leq 2\\alpha^2 + 2t^2 N$, which concludes the proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Our first result says that <span class="math">\\text{StructBASIS}</span> and <span class="math">\\text{PowerBASIS}</span> are equivalent for the dimension <span class="math">\\ell = 2</span>.</p>

    <p class="text-gray-300"><strong>Lemma 3.5 (StructBASIS <span class="math">\\iff</span> PowerBASIS).</strong> Let <span class="math">n, N, \\beta \\geq 1</span> and <span class="math">t := (n + 1)\\tilde{q}</span>. Suppose <span class="math">m &amp;gt; t + n</span> and <span class="math">\\mathfrak{s} &amp;gt; 2N \\cdot q^{\\frac{n + 1}{m - t} + \\frac{2}{N(m - t)}}</span>. If <span class="math">\\sigma_0, \\sigma_1</span> satisfy the following inequalities:</p>

    <div class="my-4 text-center"><span class="math-block">\\sigma_ {0} \\geq \\delta \\mathfrak {s} N \\cdot \\omega (\\sqrt {t (m - t) \\log m N}), \\quad \\sigma_ {1} \\geq \\delta \\sqrt {2 t N (\\sigma_ {1} ^ {2} m ^ {\\prime} + t)} N \\cdot \\omega (\\sqrt {\\log n N}),</span></div>

    <p class="text-gray-300">where <span class="math">m&#x27; = 2m + t</span>, then the following statements are true:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\text{StructBASIS}_{n,m,N,q,2,\\sigma_0,\\beta}</span> assumption holds under the <span class="math">\\text{PowerBASIS}_{n,m,N,q,2,\\sigma_1,\\beta}</span> assumption.</li>

      <li><span class="math">\\text{PowerBASIS}_{n,m,N,q,2,\\sigma_0,\\beta}</span> assumption holds under the <span class="math">\\text{StructBASIS}_{n,m,N,q,2,\\sigma_1,\\beta}</span> assumption.</li>

    </ol>

    <p class="text-gray-300"><strong>Proof.</strong> We only show the first statement since the other direction follows identically. Let <span class="math">\\mathcal{A}</span> be a PPT adversary for the <span class="math">\\text{StructBASIS}_{n,m,N,q,2,\\sigma,\\beta}</span> problem and suppose it wins with probability <span class="math">\\epsilon</span>. We provide a PPT algorithm <span class="math">\\mathcal{B}</span> for solving <span class="math">\\text{PowerBASIS}_{n,m,N,q,2,\\sigma,\\beta}</span> which does the following. First, <span class="math">\\mathcal{B}</span> is given a tuple <span class="math">(\\mathbf{A},\\mathbf{B},\\mathbf{T},\\mathbf{W})</span> where</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {B} := \\left[ \\begin{array}{c c c} \\mathbf {A} ^ {\\star} &amp;amp; \\mathbf {0} &amp;amp; - \\mathbf {G} \\\\ \\mathbf {0} &amp;amp; \\mathbf {W A} ^ {\\star} &amp;amp; - \\mathbf {G} \\end{array} \\right] \\quad \\text {and} \\quad \\mathbf {T} := \\left[ \\begin{array}{l l} \\mathbf {T} _ {1, 1} &amp;amp; \\mathbf {T} _ {1, 2} \\\\ \\mathbf {T} _ {2, 1} &amp;amp; \\mathbf {T} _ {2, 2} \\\\ \\mathbf {T} _ {3, 1} &amp;amp; \\mathbf {T} _ {3, 2} \\end{array} \\right].</span></div>

    <p class="text-gray-300">First, we claim that the following probability is negligible:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\epsilon_ {\\text {s m o o t h}} := \\Pr \\left[ \\sigma_ {0} &lt;   \\eta_ {\\epsilon} (\\Lambda^ {\\perp} (\\mathbf {B})) \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {A} ^ {\\star} \\leftarrow \\mathcal {R} _ {q} ^ {(n + 1) \\times m} \\right].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Indeed, note that by Lemma 2.15 we obtain:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\sigma_ {0} &lt;   \\eta_ {\\epsilon} (\\Lambda^ {\\perp} (\\mathbf {B})) \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\mathbf {A} ^ {\\star}, \\mathbf {R}) \\leftarrow \\operatorname {T r a p G e n} (n + 1, m) \\right] \\geq \\epsilon_ {\\text {s m o o t h}} - \\operatorname {n e g l} (\\lambda).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">If <span class="math">(\\mathbf{A}^{\\star},\\mathbf{R})\\gets \\mathsf{TrapGen}(n + 1,m)</span> then the following matrix <span class="math">\\mathbf{R}^{<em>}</span> is a <span class="math">\\mathbf{G}_{2n}</span>-trapdoor for <span class="math">\\mathbf{B}</span> with a tag <span class="math">\\mathbf{H}^{</em>}</span>, where:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {R} ^ {*} := \\left[ \\begin{array}{c c} \\mathbf {R} &amp;amp; \\mathbf {0} \\\\ \\mathbf {0} &amp;amp; \\mathbf {R} \\\\ \\mathbf {0} &amp;amp; \\mathbf {0} \\end{array} \\right] \\quad \\text {and} \\quad \\mathbf {H} ^ {*} := \\left[ \\begin{array}{c c} \\mathbf {I} _ {n + 1} &amp;amp; \\mathbf {0} \\\\ \\mathbf {0} &amp;amp; \\mathbf {W} \\end{array} \\right].</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Moreover, $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{R}^*\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2\\mathfrak{s}\\sqrt{t(m - t)N}<span class="math"> with an overwhelming probability. If this is the case then by assumption </span>\\sigma_0\\geq \\delta \\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{R}^*\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\omega (\\sqrt{t(m - t)}\\log mN)$. Then, by combining Lemma 2.14 with Lemma 2.2, we obtain</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname {n e g l} (\\lambda) = \\Pr \\left[ \\sigma_ {0} &lt;   \\eta_ {\\epsilon} (\\Lambda^ {\\perp} (\\mathbf {B})) \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\mathbf {A} ^ {\\star}, \\mathbf {R}) \\leftarrow \\operatorname {T r a p G e n} (n + 1, m) \\right] \\geq \\epsilon_ {\\text {s m o o t h}} - \\operatorname {n e g l} (\\lambda)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">and thus <span class="math">\\sigma_0 \\geq \\eta_\\epsilon (\\Lambda^\\perp (\\mathbf{B}))</span> with an overwhelming probability, where <span class="math">\\mathbf{B}</span> is the matrix received by <span class="math">\\mathcal{B}</span>. Thus, we can apply Lemma 2.7 to deduce that with an overwhelming probability<span class="math">^{14}</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left[ \\begin{array}{l} \\mathbf {T} _ {1, 1} \\\\ \\mathbf {T} _ {1, 2} \\end{array} \\right] \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\alpha := \\sigma_ {0} \\sqrt {m ^ {\\prime} t N}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Further, by simple calculation we can deduce that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A} ^ {\\star} \\mathbf {T} _ {1, 1} - \\mathbf {W A} ^ {\\star} \\mathbf {T} _ {1, 2} = \\mathbf {G}.</span></div>

    <p class="text-gray-300">The reduction <span class="math">\\mathcal{B}</span> now samples a uniformly random <span class="math">\\mathbf{W}_1 \\gets \\mathsf{GL}(n + 1, \\mathcal{R}_q)</span> and defines <span class="math">\\mathbf{W}_2 \\coloneqq \\mathbf{W}_1\\mathbf{W}</span>. Thus</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {W} _ {1} \\mathbf {A} ^ {\\star} \\mathbf {T} _ {1, 1} - \\mathbf {W} _ {2} \\mathbf {A} ^ {\\star} \\mathbf {T} _ {1, 2} = \\mathbf {W} _ {1} \\mathbf {G}.</span></div>

    <p class="text-gray-300">By applying Lemma 3.4, <span class="math">\\mathcal{B}</span> can obtain a <span class="math">\\mathbf{G}_{2(n + 1)}</span>-trapdoor <span class="math">\\mathbf{S}</span> for</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {B} ^ {\\prime} := \\left[ \\begin{array}{c c c} \\mathbf {W} _ {1} \\mathbf {A} ^ {\\star} &amp;amp; \\mathbf {0} &amp;amp; - \\mathbf {G} \\\\ \\mathbf {0} &amp;amp; \\mathbf {W} _ {2} \\mathbf {A} ^ {\\star} &amp;amp; - \\mathbf {G} \\end{array} \\right]</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">with the tag <span class="math">\\mathbf{H}^{\\star} \\coloneqq \\mathbf{I}_2 \\otimes \\mathbf{W}_1</span> where $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{S} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\sqrt{2(\\alpha^2 + t^2N)} \\leq \\sqrt{2tN(\\sigma_1^2m' + t)}<span class="math">. Then, the algorithm </span>\\mathcal{B}<span class="math"> runs </span>\\mathbf{T}' \\gets \\text{SamplePre}(\\mathbf{B}', \\mathbf{S}, \\mathbf{G}_{2(n+1)}, \\sigma_1)<span class="math">. Finally, </span>\\mathcal{B}<span class="math"> sends </span>(\\mathbf{A}, \\mathbf{B}', \\mathbf{T}', \\mathsf{aux}') := (\\mathbf{W}_1, \\mathbf{W}_2)<span class="math"> to </span>\\mathcal{A}<span class="math"> and returns what </span>\\mathcal{A}$ outputs.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To argue correctness of the reduction, first note that <span class="math">\\mathsf{aux}&#x27;</span> and <span class="math">\\mathbf{B}&#x27;</span> are correctly generated. Further, by assumption we have $\\sigma_1 \\geq \\delta \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{S} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\omega(\\sqrt{N \\log nN})<span class="math"> and thus by Lemma 2.16, the distribution of </span>\\text{SamplePre}(\\mathbf{B}', \\mathbf{S}, \\mathbf{G}_{2(n+1)}, \\sigma_1)<span class="math"> is statistically close to </span>\\mathbf{B}_{\\sigma_1}'^{-1}(\\mathbf{G}_{2(n+1)})<span class="math">. Consequently, </span>\\mathcal{A}<span class="math"> outputs a valid answer to </span>\\mathcal{B}<span class="math"> with probability </span>\\epsilon - \\mathsf{negl}(\\lambda)$. Finally, a valid solution for StructBASIS implies a valid solution for PowerBASIS, which concludes the proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The next result focuses on the PRISIS variant. It turns out that the commutative property of the assumption allows to reduce to standard assumptions.</p>

    <p class="text-gray-300"><strong>Lemma 3.6 (PRISIS <span class="math">\\Rightarrow</span> MSIS).</strong> Let <span class="math">n &amp;gt; 0, m \\geq n</span> and denote <span class="math">t = (n + 1)\\tilde{q}</span>. Let <span class="math">q = \\omega(N)</span>. Take <span class="math">\\epsilon \\in (0,1/3)</span> and <span class="math">\\mathfrak{s} \\geq \\max(\\sqrt{N \\ln(8Nq)} \\cdot q^{1/2 + \\epsilon}, \\omega(N^{3/2} \\ln^{3/2} N))</span> such that <span class="math">2^{10N} q^{-\\lfloor \\epsilon N \\rfloor}</span> is negligible. Let</p>

    <div class="my-4 text-center"><span class="math-block">\\sigma \\geq \\delta \\sqrt {t N \\cdot (N ^ {2} \\mathfrak {s} ^ {2} m + 2 t)} \\cdot \\omega (\\sqrt {N \\log n N}).</span></div>

    <p class="text-gray-300">Then, <span class="math">\\mathsf{PRISIS}_{n,m,N,q,2,\\sigma,\\beta}</span> is hard under the <span class="math">\\mathsf{MSIS}_{n,m,N,q,\\beta}</span> assumption.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Suppose there is a PPT algorithm <span class="math">\\mathcal{A}</span> which wins <span class="math">\\mathsf{PRISIS}_{n,m,N,q,2,\\sigma,\\beta}</span> with probability <span class="math">\\epsilon</span>. We revisit the PRISIS security game and introduce a single game hop. The purpose of the hybrid argument will be to plug in the NTRU trapdoor inside the auxiliary information <span class="math">w</span>. We define <span class="math">\\varepsilon_{i}</span> to be the probability that <span class="math">\\mathcal{A}</span> wins Game <span class="math">i</span>.</p>

    <p class="text-gray-300"><strong>Game 1:</strong> This is the standard PRISIS security game. To recall, the challenger samples <span class="math">\\mathbf{a} \\gets \\mathcal{R}_q^m</span>, <span class="math">\\mathbf{A} \\gets \\mathcal{R}_q^{n \\times m}</span> and sets <span class="math">\\mathbf{A}^\\star</span> as in (11). Then, it generates an invertible element <span class="math">w \\gets \\mathcal{R}_q^\\times</span> and computes the matrix:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {B} := \\left[ \\begin{array}{c c c} \\mathbf {A} ^ {\\star} &amp;amp; \\mathbf {0} &amp;amp; - \\mathbf {G} \\\\ \\mathbf {0} &amp;amp; \\mathbf {W A} ^ {\\star} &amp;amp; - \\mathbf {G} \\end{array} \\right].</span></div>

    <p class="text-gray-300"><span class="math">^{14}</span>We note that the bound is not tight.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{W}:=w\\cdot\\mathbf{I}_{n+1}</span>. Then, it samples <span class="math">\\mathbf{T}\\leftarrow\\mathbf{B}^{-1}_{\\sigma_{1}}(\\mathbf{G}_{2(n+1)})</span> and outputs <span class="math">(\\mathbf{A},\\mathbf{B},\\mathbf{T},w)</span> to the adversary <span class="math">\\mathcal{A}</span>. By definition, <span class="math">\\varepsilon_{1}=\\epsilon</span>.</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Game 2</h6>

    <p class="text-gray-300">In this game, we obtain <span class="math">w</span> by running <span class="math">(w,\\mathbf{T}_{\\mathsf{NTRU}})\\leftarrow\\mathsf{NTRU.TrapGen}(q,N,\\mathfrak{s})</span> algorithm. By Lemma 2.11, <span class="math">\\varepsilon_{2}\\geq\\varepsilon_{1}-2^{10N}q^{-\\lfloor\\varepsilon N\\rfloor}</span>.</p>

    <p class="text-gray-300">Suppose there is an adversary which wins <span class="math">\\mathsf{Game}_{2}</span>. We now show how to build a PRISIS trapdoor <span class="math">\\mathbf{T}</span> given the Module-SIS matrix <span class="math">\\mathbf{A}</span> and the NTRU trapdoor <span class="math">\\mathbf{T}_{\\mathsf{NTRU}}</span>. To this end, we will show how to find short matrices <span class="math">\\mathbf{S}_{1},\\mathbf{S}_{2}</span> such that:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{A}^{\\star}\\mathbf{S}_{1}-w\\mathbf{A}^{\\star}\\mathbf{S}_{2}=\\mathbf{G}\\enspace.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbf{g}_{i}</span> be the <span class="math">i</span>-th column of <span class="math">\\mathbf{G}</span>. Assuming that <span class="math">\\mathbf{A}^{\\star}</span> is full-rank (cf. Lemma 2.3) and using linear algebra, we can find a (possibly large) vector <span class="math">\\mathbf{t}</span> such that <span class="math">\\mathbf{A}^{\\star}\\mathbf{t}=\\mathbf{g}_{i}</span>. Now, using the NTRU trapdoor <span class="math">\\mathbf{T}_{\\mathsf{NTRU}}</span> (such that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{\\mathbf{T}}_{\\mathsf{NTRU}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq N\\mathfrak{s}<span class="math"> by Lemma 2.11) and the nearest plane algorithm <em>[x14]</em>, we can find vectors </span>(\\mathbf{s}_{1,i},\\mathbf{s}_{2,i})\\in\\mathcal{R}_{q}^{m}\\times\\mathcal{R}_{q}^{m}$ such that:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathbf{s}_{1,i}-w\\mathbf{s}_{2,i}=\\mathbf{t}\\text{ and }\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\mathbf{s}_{1,i},\\mathbf{s}_{2,i})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq N\\mathfrak{s}\\sqrt{mN/2}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Therefore</p>

    <p class="text-gray-300"><span class="math">\\mathbf{A}^{\\star}\\mathbf{s}_{1,i}-w\\mathbf{A}^{\\star}\\mathbf{s}_{2,i}=\\mathbf{A}^{\\star}(\\mathbf{s}_{1,i}-w\\mathbf{s}_{2,i})=\\mathbf{A}^{\\star}\\mathbf{t}=\\mathbf{g}_{i}\\enspace.</span></p>

    <p class="text-gray-300">Thus, we obtain the matrices <span class="math">\\mathbf{S}_{1},\\mathbf{S}_{2}</span> by concatenation where</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{bmatrix}\\mathbf{S}_{1}\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Consequently, by Lemma 3.4, we can build a <span class="math">\\mathbf{G}_{2(n+1)}</span>-trapdoor <span class="math">\\mathbf{S}</span> for <span class="math">\\mathbf{B}</span> such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{S}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\sqrt{2(\\alpha^{2}+t^{2}N)}=\\sqrt{tN\\cdot(N^{2}\\mathfrak{s}^{2}m+2t)}\\enspace.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Hence, the reduction <span class="math">\\mathcal{B}</span> can construct the trapdoor <span class="math">\\mathbf{S}</span> as above and then randomise the trapdoor for <span class="math">\\mathbf{B}</span> by running <span class="math">\\mathbf{T}\\leftarrow\\mathsf{SamplePre}(\\mathbf{B},\\mathbf{S},\\mathbf{G}_{2(n+1)},\\sigma)</span>. Finally it sends the tuple to <span class="math">\\mathcal{A}</span> and returns what it outputs. By Lemma 2.16, <span class="math">\\mathcal{B}</span> wins the Module-SIS game with probability at least <span class="math">\\varepsilon_{2}-\\mathsf{negl}(\\lambda)</span>, which concludes the proof. ∎</p>

    <h3 id="sec-39" class="text-xl font-semibold mt-8">3.2 Higher Dimensions</h3>

    <p class="text-gray-300">One could hope that the techniques to analyse hardness of the BASIS assumption can be translated to higher dimensions. This could be promising especially for the PRISIS assumption, which we managed to reduce to standard lattice assumptions for the <span class="math">\\ell=2</span> case. Unfortunately, the reduction falls flat when considering higher dimensions.</p>

    <p class="text-gray-300">We showcase this for <span class="math">\\ell=3</span>. Following the approach for the smaller dimension, the goal is to find short matrices <span class="math">\\mathbf{S}_{1},\\mathbf{S}_{2},\\mathbf{S}_{3}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\mathbf{A}^{\\star}\\mathbf{S}_{1}-w\\mathbf{A}^{\\star}\\mathbf{S}_{2}</span> <span class="math">=\\mathbf{Z}_{1}</span> (12) <span class="math">\\mathbf{A}^{\\star}\\mathbf{S}_{2}-w\\mathbf{A}^{\\star}\\mathbf{S}_{3}</span> <span class="math">=\\mathbf{Z}_{2}</span></p>

    <p class="text-gray-300">for any <span class="math">\\mathbf{Z}_1, \\mathbf{Z}_2</span> given the NTRU trapdoor for <span class="math">w</span>. If this is possible, we could set <span class="math">\\mathbf{Z}_1 = \\mathbf{G}</span> and <span class="math">\\mathbf{Z}_2 = \\mathbf{0}</span> which would give us:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{A}^* \\mathbf{S}_1 - w \\mathbf{A}^* \\mathbf{S}_2 = \\mathbf{G}</span></div>

    <div class="my-4 text-center"><span class="math-block">w \\mathbf{A}^* \\mathbf{S}_2 - w^2 \\mathbf{A}^* \\mathbf{S}_3 = \\mathbf{0}.</span></div>

    <p class="text-gray-300">Set <span class="math">\\mathbf{S}_4 \\coloneqq \\mathbf{G}^{-1}(\\mathbf{A}^* \\mathbf{S}_1 - \\mathbf{G})</span>. Then, we have:</p>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\begin{array}{cccc} \\mathbf{A}^* &amp;amp; \\mathbf{0} &amp;amp; \\mathbf{0} &amp;amp; -\\mathbf{G} \\\\ \\mathbf{0} &amp;amp; w \\mathbf{A}^* &amp;amp; \\mathbf{0} &amp;amp; -\\mathbf{G} \\\\ \\mathbf{0} &amp;amp; \\mathbf{0} &amp;amp; w^2 \\mathbf{A}^* &amp;amp; -\\mathbf{G} \\end{array} \\right] \\left[ \\begin{array}{c} \\mathbf{S}_1 \\\\ \\mathbf{S}_2 \\\\ \\mathbf{S}_3 \\\\ \\mathbf{S}_4 \\end{array} \\right] = \\left[ \\begin{array}{c} \\mathbf{G} \\\\ \\mathbf{0} \\\\ \\mathbf{0} \\end{array} \\right].</span></div>

    <p class="text-gray-300">We proceed similarly for</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathbf{Z}_1, \\mathbf{Z}_2) = (-\\mathbf{G}, w^{-1} \\mathbf{G}) \\quad \\text{and} \\quad (\\mathbf{Z}_1, \\mathbf{Z}_2) = (\\mathbf{0}, -w^{-1} \\mathbf{G}).</span></div>

    <p class="text-gray-300">Thus, we managed to build a <span class="math">\\mathbf{G}_{3(n+1)}</span>-trapdoor for <span class="math">\\mathbf{B}</span>. What is left to do is to produce short <span class="math">\\mathbf{S}_1, \\mathbf{S}_2, \\mathbf{S}_3</span> which satisfy (12). To this end, consider the <span class="math">q</span>-ary lattice</p>

    <div class="my-4 text-center"><span class="math-block">\\Lambda = \\left\\{(s_1, s_2, s_3): \\left[ \\begin{array}{ccc} 1 &amp;amp; -w &amp;amp; 0 \\\\ 0 &amp;amp; w &amp;amp; -w^2 \\end{array} \\right] \\left[ \\begin{array}{c} s_1 \\\\ s_2 \\\\ s_3 \\end{array} \\right] = \\mathbf{0} \\bmod q \\right\\}.</span></div>

    <p class="text-gray-300">Suppose we can build a short basis for <span class="math">\\Lambda</span> given the NTRU trapdoor for <span class="math">w</span>. Let <span class="math">\\mathbf{z}_{1,i}, \\mathbf{z}_{2,i}</span> be the <span class="math">i</span>-th column of <span class="math">\\mathbf{Z}_1</span> and <span class="math">\\mathbf{Z}_2</span>. Now, assuming that <span class="math">\\mathbf{A}^<em></span> is full-rank, we can find (possibly large) <span class="math">\\mathbf{t}_1</span> and <span class="math">\\mathbf{t}_2</span> such that <span class="math">\\mathbf{A}^</em> \\mathbf{t}_j = \\mathbf{z}_{j,i}</span> for <span class="math">j = 1,2</span>. Now, using the short basis for <span class="math">\\Lambda</span>, we can sample short vectors <span class="math">\\mathbf{s}_{1,i}, \\mathbf{s}_{2,i}, \\mathbf{s}_{3,i}</span> such that:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{s}_{1,i} - w \\mathbf{s}_{2,i} = \\mathbf{t}_1</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{s}_{2,i} - w \\mathbf{s}_{3,i} = \\mathbf{t}_2.</span></div>

    <p class="text-gray-300">Hence,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{A}^* \\mathbf{s}_{1,i} - w \\mathbf{A}^* \\mathbf{s}_{2,i} = \\mathbf{A}^* (\\mathbf{s}_{1,i} - w \\mathbf{s}_{2,i}) = \\mathbf{A}^* \\mathbf{t}_1 = \\mathbf{z}_{1,i}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{A}^* \\mathbf{s}_{2,i} - w \\mathbf{A}^* \\mathbf{s}_{3,i} = \\mathbf{A}^* (\\mathbf{s}_{2,i} - w \\mathbf{s}_{3,i}) = \\mathbf{A}^* \\mathbf{t}_2 = \\mathbf{z}_{2,i}.</span></div>

    <p class="text-gray-300">Therefore, we obtain the matrices <span class="math">\\mathbf{S}_1, \\mathbf{S}_2, \\mathbf{S}_3</span> by concatenation.</p>

    <p class="text-gray-300">Unfortunately, we are only aware of the following two bases of <span class="math">\\Lambda</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\begin{array}{ccc} w^2 &amp;amp; w &amp;amp; 1 \\\\ q &amp;amp; 0 &amp;amp; 0 \\\\ 0 &amp;amp; q &amp;amp; 0 \\end{array} \\right] \\quad \\text{and} \\quad \\left[ \\begin{array}{ccc} u^2 &amp;amp; uv &amp;amp; v^2 \\\\ \\bar{u}^2 &amp;amp; \\bar{u}\\bar{v} &amp;amp; \\bar{v}^2 \\\\ \\bar{u}u &amp;amp; \\bar{u}v &amp;amp; \\bar{v}v \\end{array} \\right],</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">\\mathbf{T}_{\\mathsf{NTRU}} := ((u,v), (\\bar{u},\\bar{v}))</span> is the short NTRU basis. Since $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx \\sqrt{q}$, the latter basis cannot have short coefficients. We leave further analysis of this approach for future work.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">35</p>

    <p class="text-gray-300">In this section we define a compressing commitment scheme which stems from the vector commitment construction of Wee and Wu [WW23b]. We inherit a crucial property from the aforementioned work that we support committing to arbitrarily large ring elements. Let <span class="math">\\ell \\coloneqq d + 1</span> be the length of the committed vectors over <span class="math">\\mathcal{R}_q</span>. Thus, the message space is <span class="math">\\mathcal{M} \\coloneqq \\mathcal{R}_q^{d + 1}</span>. We let <span class="math">\\gamma, \\beta_s</span> be the parameters controlling the norm of various vectors. Further, we define the slack space as the vector of short polynomials:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{S} := \\left\\{ (c_0, \\ldots, c_d) : \\forall i \\in [0, d], c_i \\in \\mathcal{R}_q^\\times \\wedge \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_1 \\leq \\beta_s \\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Informally, we say that a slack is a single element <span class="math">c \\in \\mathcal{R}_q</span> if <span class="math">(c, \\ldots, c) \\in \\mathcal{S}</span>. Finally, we define <span class="math">t = n\\tilde{q}</span> and <span class="math">\\mathbf{G} \\coloneqq \\mathbf{G}_n \\in \\mathcal{R}_q^{n \\times t}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We now give intuition on the construction, and provide a formal description in Figure 4. The setup algorithm uses the TrapGen and SamplePre algorithms defined in Section 2.5. Namely, it first generates the two matrices <span class="math">(\\mathbf{A}, \\mathbf{R}) \\gets \\mathrm{TrapGen}(n, m)</span> along with a uniformly random invertible <span class="math">\\mathbf{W} \\gets \\mathsf{GL}(n, \\mathcal{R}_q)</span>. Then, <span class="math">\\mathbf{AR} = \\mathbf{G}</span>, where $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{R} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\mathfrak{s} \\sqrt{2t(m - t)N}<span class="math"> and </span>\\mathfrak{s} &gt; 2N \\cdot q^{\\frac{n}{m - t} + \\frac{2}{N(m - t)}}<span class="math"> (c.f. Lemma 2.6). Further, it computes </span>\\mathbf{R}_i := \\mathbf{RG}^{-1}(\\mathbf{W}^{-i}\\mathbf{G})<span class="math"> for </span>i = 0, 1, \\ldots, d$. Note that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{W}^i \\mathbf{A} \\mathbf{R}_i = \\mathbf{W}^i \\mathbf{A} \\mathbf{R} \\mathbf{G}^{-1} (\\mathbf{W}^{-i} \\mathbf{G}) = \\mathbf{W}^i \\mathbf{G} \\mathbf{G}^{-1} (\\mathbf{W}^{-i} \\mathbf{G}) = \\mathbf{G}</span></div>

    <p class="text-gray-300">and thus <span class="math">\\mathbf{R}_i</span> is a <span class="math">\\mathbf{G}</span>-trapdoor for <span class="math">\\mathbf{W}^i\\mathbf{A}</span> and by Lemma 2.2:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{R}_i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{R} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot N \\sqrt{n t} \\leq \\mathfrak{s} N t \\sqrt{2 n (m - t) N}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Then, the algorithm computes the PowerBASIS matrix along with its trapdoor:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{B} := \\begin{bmatrix} \\mathbf{A} &amp;amp; &amp;amp; &amp;amp; -\\mathbf{G} \\\\ &amp;amp; \\ddots &amp;amp; &amp;amp; \\vdots \\\\ &amp;amp; &amp;amp; \\mathbf{W}^d \\mathbf{A} &amp;amp; -\\mathbf{G} \\end{bmatrix}, \\quad \\tilde{\\mathbf{R}} := \\begin{bmatrix} \\mathbf{R}_0 &amp;amp; &amp;amp; \\\\ &amp;amp; \\ddots &amp;amp; \\\\ &amp;amp; &amp;amp; \\mathbf{R}_d \\\\ \\hline &amp;amp; \\mathbf{0} \\end{bmatrix}. \\tag{13}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Indeed, one can check that <span class="math">\\mathbf{B} \\tilde{\\mathbf{R}} = \\mathbf{G}_{n(d+1)}</span> and $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{\\mathbf{R}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\mathfrak{s} N t \\sqrt{2(d+1) n(m-t)N}<span class="math">. Finally, the setup algorithm re-randomises the trapdoor </span>\\tilde{\\mathbf{R}}$ by running</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{T} \\leftarrow \\text{SamplePre}(\\mathbf{B}, \\tilde{\\mathbf{R}}, \\mathbf{G}_{n(d+1)}, \\sigma_0),</span></div>

    <p class="text-gray-300">and thus <span class="math">\\mathbf{BT} = \\mathbf{G}_{n(d+1)}</span>. Finally, the public parameters <span class="math">\\mathbf{crs} := (\\mathbf{A}, \\mathbf{W}, \\mathbf{T})</span> are returned.</p>

    <p class="text-gray-300">Suppose we want to commit to a vector <span class="math">(f_0, f_1, \\ldots, f_d)</span> of length <span class="math">d + 1</span>. To this end, we use crs to compute</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{bmatrix} \\mathbf{s}_0 \\\\ \\vdots \\\\ \\mathbf{s}_d \\\\ \\mathbf{t} \\end{bmatrix} \\gets \\text{SamplePre} \\left( \\begin{bmatrix} \\mathbf{A} &amp;amp; &amp;amp; &amp;amp; -\\mathbf{G} \\\\ &amp;amp; \\ddots &amp;amp; &amp;amp; \\vdots \\\\ &amp;amp; &amp;amp; \\mathbf{W}^d \\mathbf{A} &amp;amp; -\\mathbf{G} \\end{bmatrix}, \\begin{bmatrix} -f_0 \\mathbf{W}^0 \\mathbf{e}_1 \\\\ \\vdots \\\\ -f_d \\mathbf{W}^d \\mathbf{e}_1 \\end{bmatrix}, \\mathbf{T}, \\sigma_1 \\right).</span></div>

    <p class="text-gray-300">By definition, this means that <span class="math">\\mathbf{s}_0, \\mathbf{s}_1, \\ldots, \\mathbf{s}_d \\in \\mathcal{R}_q^m</span> and <span class="math">\\mathbf{t} := \\mathbf{G} \\hat{\\mathbf{t}}</span> satisfy:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{A} \\mathbf{s}_i + f_i \\mathbf{e}_1 = \\mathbf{W}^{-i} \\mathbf{t} \\quad \\text{for } i = 0, 1, \\ldots, d. \\tag{14}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample  <span class="math">(\\mathbf{A},\\mathbf{R})\\gets \\mathrm{TrapGen}(n,m)</span></li>

      <li>Sample  <span class="math">\\mathbf{W} \\gets \\mathsf{GL}(n, \\mathcal{R}_q)</span></li>

      <li>Let  <span class="math">\\mathbf{R}_i\\coloneqq \\mathbf{R}\\mathbf{G}^{-1}(\\mathbf{W}^{-i}\\mathbf{G})</span>  for  <span class="math">i\\in [0,d]</span></li>

      <li>Set</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {B} := \\left[ \\begin{array}{c c c c} \\mathbf {A} &amp;amp; &amp;amp; &amp;amp; - \\mathbf {G} \\\\ &amp;amp; \\ddots &amp;amp; &amp;amp; \\vdots \\\\ &amp;amp; &amp;amp; \\mathbf {W} ^ {d} \\mathbf {A} &amp;amp; - \\mathbf {G} \\end{array} \\right], \\quad \\tilde {\\mathbf {R}} := \\left[ \\begin{array}{c c c c} \\mathbf {R} _ {0} &amp;amp; &amp;amp; &amp;amp; \\\\ &amp;amp; \\ddots &amp;amp; &amp;amp; \\\\ &amp;amp; &amp;amp; \\mathbf {R} _ {d} \\\\ \\hline &amp;amp; \\mathbf {0} &amp;amp; &amp;amp; \\end{array} \\right].</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample  <span class="math">\\mathbf{T} \\gets \\text{SamplePre}(\\mathbf{B}, \\tilde{\\mathbf{R}}, \\mathbf{G}_{n(d+1)}, \\sigma_0)</span> .</li>

      <li>Return  <span class="math">\\mathbf{crs} \\coloneqq (\\mathbf{A}, \\mathbf{W}, \\mathbf{T})</span> .</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse  <span class="math">\\mathbf{f} \\coloneqq (f_0, f_1, \\ldots, f_d)</span></li>

      <li>Set  <span class="math">\\mathbf{u} := \\begin{bmatrix} -f_0\\mathbf{W}^0\\mathbf{e}_1 \\\\ \\vdots \\\\ -f_d\\mathbf{W}^d\\mathbf{e}_1 \\end{bmatrix}</span></li>

      <li>Sample  <span class="math">\\left[ \\begin{array}{l}\\mathbf{s}_0\\\\ \\vdots \\\\ \\mathbf{s}_d\\\\ \\mathbf{t} \\end{array} \\right]\\gets</span>  SamplePre(B,u,T,  <span class="math">\\sigma_{1}</span></li>

      <li>Set  <span class="math">\\mathbf{t} \\coloneqq \\mathbf{G}\\mathbf{t}</span> .</li>

      <li>Return  <span class="math">(C\\coloneqq \\mathbf{t},\\mathsf{st}\\coloneqq (\\mathbf{s}_i)_{i\\in [0,d]})</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse  <span class="math">\\mathbf{f} \\coloneqq (f_0, f_1, \\ldots, f_d)</span>  and  <span class="math">\\mathbf{c} \\coloneqq (c_0, \\ldots, c_d)</span> .</li>

      <li>Parse  <span class="math">C\\coloneqq \\mathbf{t}\\in \\mathcal{R}_q^n</span>  and  <span class="math">\\mathsf{st}\\coloneqq (\\mathbf{s}_i)_{d\\in [0,d]}</span></li>

      <li>Return 1 if and only if for all  <span class="math">i \\in [0, d]</span> ,</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathbf{A}\\mathbf{s}_i + f_i\\mathbf{e}_1 = \\mathbf{W}^{-i}\\mathbf{t}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{i}\\mathbf{s}_{i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\gamma$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 4: PowerBASIS commitment scheme for arbitrary messages in the message space  <span class="math">\\mathcal{M} = \\mathcal{R}_q^{d + 1}</span>  with the slack space  $\\mathcal{S} \\coloneqq \\{(c_0, \\ldots, c_d) : \\forall i \\in [0, d], c_i \\in \\mathcal{R}_q^\\times \\land \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_\\infty \\leq \\beta_s\\}<span class="math"> . Here,  </span>\\mathbf{G} \\in \\mathcal{R}_q^{n \\times n\\bar{q}}<span class="math">  is the gadget matrix of height  </span>n$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The commitment and the decommitment state are <span class="math">C\\coloneqq \\mathbf{t}</span> and <span class="math">\\mathsf{st}\\coloneqq (\\mathbf{s}_i)_{i\\in [0,d]}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Finally, the opening function takes the public parameters <span class="math">\\mathbf{crs}</span>, the commitment <span class="math">\\mathbf{t}</span>, a message vector <span class="math">\\mathbf{f} \\coloneqq (f_0, \\ldots, f_d)</span>, the decommitment state <span class="math">(\\mathbf{s}_i)_{i \\in [0,d]}</span> and a relaxation factor <span class="math">(c_0, \\ldots, c_d) \\in S</span>, and accepts if and only if (14) holds and $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_i \\mathbf{s}_i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\gamma<span class="math"> for all </span>i = 0,1,\\ldots,d$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-45" class="text-2xl font-bold">4.1 Security Analysis</h2>

    <p class="text-gray-300">In the following, we show that the PowerBASIS commitment scheme satisfies completeness, relaxed binding and hiding. As before, we assume <span class="math">q \\equiv 5 \\pmod{8}</span> is a prime.</p>

    <p class="text-gray-300"><strong>Lemma 4.1 (Completeness).</strong> Suppose <span class="math">n, N, \\beta_s \\geq 1</span> and denote <span class="math">t \\coloneqq n\\tilde{q}</span>. Let <span class="math">m &amp;gt; t + n</span>, <span class="math">m&#x27; \\coloneqq m(d + 1) + n\\tilde{q}</span>, <span class="math">n&#x27; \\coloneqq n\\tilde{q}(d + 1)</span> and <span class="math">t&#x27; \\coloneqq \\max(n&#x27;, m&#x27;)</span>. Take <span class="math">\\mathfrak{s} &amp;gt; 2N \\cdot q^{\\frac{n}{m - t} + \\frac{2}{N(m - t)}}</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\sigma_ {0} \\geq \\delta \\mathfrak {s} N t \\omega (\\sqrt {2 (d + 1) n (m - t) N} \\log t ^ {\\prime} N) \\quad \\text{and} \\quad \\sigma_ {1} \\geq \\delta \\sigma_ {0} N \\cdot \\omega (\\sqrt {m ^ {\\prime} n ^ {\\prime}} \\log t ^ {\\prime} N).</span></div>

    <p class="text-gray-300">If <span class="math">\\gamma \\geq \\sigma_1\\sqrt{m&#x27;N}</span> then the PowerBASIS commitment scheme satisfies completeness.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> In the discussion above, we already showed that Equation (14) is true. We will show that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}_i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\gamma<span class="math"> for all </span>i<span class="math">, and thus we can pick the global relaxation to be </span>(1,\\dots ,1)\\in S$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">First, note that the matrix <span class="math">\\tilde{\\mathbf{R}}\\in \\mathcal{R}_q^{m&#x27;\\times n&#x27;}</span> satisfies $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{\\mathbf{R}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\mathfrak{s}Nt\\sqrt{2(d + 1)n(m - t)N}<span class="math"> with high probability by Lemma 2.8. Hence </span>\\sigma_0\\geq \\delta \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{\\mathbf{R}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\omega (\\sqrt{N\\log t'N})<span class="math"> for </span>t^{\\prime} = \\max (n^{\\prime},m^{\\prime})<span class="math"> and thus we can apply both Lemma 2.16 and Lemma 2.7 to deduce that with an overwhelming probability </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{T}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\sigma_0\\sqrt{m'n'N}<span class="math">. Similarly, we have </span>\\sigma_{1}\\geq \\delta \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{T}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\omega (\\sqrt{N\\log t'N})<span class="math"> and thus </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}_i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\sigma_1\\sqrt{m'N}\\leq \\gamma<span class="math"> with an overwhelming probability for all </span>i = 0,1,\\ldots ,d$, which concludes the proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Based on the parameters above, we would require <span class="math">\\sigma_0 = \\tilde{O} (\\sqrt{d})</span> and <span class="math">\\sigma_{1} = \\tilde{O} (d^{3 / 2})</span>, ignoring the polynomial factors related to the security parameter.</p>

    <p class="text-gray-300"><strong>Lemma 4.2 (Relaxed Binding).</strong> Let <span class="math">t = n\\tilde{q}</span>, <span class="math">m &amp;gt; t + n</span> and <span class="math">n&#x27; = n\\tilde{q}(d + 1)</span>. Take <span class="math">\\mathfrak{s} &amp;gt; 2N \\cdot q^{\\frac{n}{m - t} + \\frac{2}{N(m - t)}}</span>. If <span class="math">\\sigma_0 \\geq \\delta \\mathfrak{s}Nt\\omega (\\sqrt{2(d + 1)n(m - t)N}\\log n&#x27;N)</span> then under the PowerBASIS<span class="math">_{n-1,m,N,q,d+1,\\sigma_0,2\\beta_s\\gamma}</span> assumption, PowerBASIS commitment scheme satisfies relaxed binding.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Let <span class="math">\\mathcal{A}</span> be an adversary for the relaxed binding game which succeeds with probability <span class="math">\\epsilon</span>. We prove the statement using an hybrid argument. We define <span class="math">\\varepsilon_{i}</span> to be the probability that <span class="math">\\mathcal{A}</span> wins Game <span class="math">i</span>.</p>

    <p class="text-gray-300"><strong>Game 0:</strong> This is the standard relaxed binding game. By definition <span class="math">\\varepsilon_0 = \\epsilon</span>.</p>

    <p class="text-gray-300"><strong>Game 1:</strong> Here, we swap the SamplePre algorithm with sampling truly from a discrete Gaussian distribution. Since <span class="math">\\sigma_0 \\geq \\delta \\mathfrak{s}Nt\\omega (\\sqrt{2(d + 1)n(m - t)N}\\log n&#x27;N)</span>, we can argue as in Lemma 4.1 that <span class="math">\\varepsilon_1 \\geq \\varepsilon_0 - \\mathrm{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300"><strong>Game 2:</strong> In this game we do not run TrapGen anymore, but instead the matrix <span class="math">\\mathbf{A} \\gets \\mathcal{R}_q^{n \\times m}</span> is selected uniformly at random. By Lemma 2.6, we deduce that <span class="math">\\varepsilon_2 \\geq \\varepsilon_1 - \\mathrm{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">We claim that <span class="math">\\varepsilon_{2} = \\mathrm{negl}(\\lambda)</span> under the PowerBASIS assumption. First, by definition of the PowerBASIS assumption, our goal is to extract a short non-zero solution for the matrix <span class="math">\\mathbf{A}^*</span>, where</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A} := \\left[ \\begin{array}{c} \\mathbf {a} ^ {\\top} \\\\ \\mathbf {A} ^ {*} \\end{array} \\right]  .</span></div>

    <p class="text-gray-300">Denote the tuple <span class="math">\\mathcal{A}</span> outputs as:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {t}, (\\mathbf {f}, (\\mathbf {v} _ {0} \\dots , \\mathbf {v} _ {d}), (c _ {0}, \\dots , c _ {d})), (\\mathbf {f} ^ {\\prime}, (\\mathbf {v} _ {0} ^ {\\prime} \\dots , \\mathbf {v} _ {d} ^ {\\prime}), (c _ {0} ^ {\\prime}, \\dots , c _ {d} ^ {\\prime})).</span></div>

    <p class="text-gray-300">By definition, whenever <span class="math">\\mathcal{A}</span> wins, it must be that openings are valid and <span class="math">\\mathbf{f} \\neq \\mathbf{f}&#x27;</span>, which implies there is at least an index <span class="math">j</span> with <span class="math">f_{j} \\neq f_{j}&#x27;</span>. Thus, by subtracting the verification equations, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A} (\\mathbf {v} _ {j} - \\mathbf {v} _ {j} ^ {\\prime}) = \\left[ \\begin{array}{c} f _ {j} ^ {\\prime} - f _ {j} \\\\ 0 \\\\ \\vdots \\\\ 0 \\end{array} \\right] .</span></div>

    <p class="text-gray-300">Since <span class="math">f_{j}^{\\prime} - f_{j} \\neq 0</span>, this implies that <span class="math">\\bar{\\mathbf{v}} := (\\mathbf{v}_{j} - \\mathbf{v}_{j}^{\\prime}) \\neq \\mathbf{0}</span>. Consequently, <span class="math">\\mathbf{A}^{<em>}\\bar{\\mathbf{v}} = \\mathbf{0}</span>. Now, <span class="math">\\bar{\\mathbf{v}}</span> might not be short. Hence, we consider <span class="math">c_{j}c_{j}^{\\prime}\\bar{\\mathbf{v}}</span> instead. Clearly, this is still a non-zero solution for <span class="math">\\mathbf{A}^{</em>}</span> since <span class="math">c_{j}, c_{j}^{\\prime}</span> are invertible. Further,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c _ {j} c _ {j} ^ {\\prime} \\bar {\\mathbf {v}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c _ {j} ^ {\\prime} (c _ {j} \\mathbf {v}) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c _ {j} (c _ {j} ^ {\\prime} \\mathbf {v} ^ {\\prime}) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2 \\beta_ {s} \\gamma .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Therefore, <span class="math">c_{j}c_{j}^{\\prime}\\bar{\\mathbf{v}}</span> is a valid solution to PowerBASIS.</p>

    <p class="text-gray-300">Lemma 4.3 (Hiding). Suppose <span class="math">n, N \\geq 1</span> and denote <span class="math">t \\coloneqq n\\tilde{q}</span>. Let <span class="math">m &amp;gt; t + n</span>, <span class="math">m&#x27; \\coloneqq m(d + 1) + n\\tilde{q}</span>, <span class="math">n&#x27; \\coloneqq n\\tilde{q}(d + 1)</span> and <span class="math">t&#x27; \\coloneqq \\max(n&#x27;, m&#x27;)</span>. Take</p>

    <div class="my-4 text-center"><span class="math-block">\\sigma_ {0} \\geq \\delta \\mathfrak {s} N t \\omega (\\sqrt {2 (d + 1) n (m - t) N \\log t ^ {\\prime} N}),</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sigma_ {1} \\geq \\delta \\cdot \\max  \\left(\\log ((d + 1) m N), \\sigma_ {0} N \\cdot \\omega (\\sqrt {m ^ {\\prime} n ^ {\\prime} \\log t ^ {\\prime} N})\\right).</span></div>

    <p class="text-gray-300">Then, the PowerBASIS commitment scheme satisfies hiding.</p>

    <p class="text-gray-300">Proof. Take an unbounded adversary <span class="math">\\mathcal{A}</span> which wins the hiding game with probability <span class="math">\\epsilon</span>. We prove the statement via a sequence of games, where in each game we change the algorithm of Commit. Let <span class="math">\\epsilon_{i}</span> be the advantage of the adversary against Game <span class="math">i</span>.</p>

    <p class="text-gray-300">Game 1: This is the original hiding game where Commit is defined in Figure 4. For the purpose of the proof, we assume Commit does not output st. Then, by definition <span class="math">\\epsilon_{1} = \\epsilon</span>.</p>

    <p class="text-gray-300">Game 2: In this game, Commit (inefficiently) samples</p>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\begin{array}{c} \\mathbf {s} _ {0} \\\\ \\vdots \\\\ \\mathbf {s} _ {d} \\\\ \\mathbf {t} \\end{array} \\right] \\gets \\mathbf {B} _ {\\sigma_ {1}} ^ {- 1} \\left(\\left[ \\begin{array}{c} - f _ {0} \\mathbf {W} ^ {0} \\mathbf {e} _ {1} \\\\ \\vdots \\\\ - f _ {d} \\mathbf {W} ^ {d} \\mathbf {e} _ {1} \\end{array} \\right]\\right)</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and outputs <span class="math">\\mathbf{t} \\coloneqq \\mathbf{G}\\hat{\\mathbf{t}}</span>. By our assumption on <span class="math">\\sigma_0, \\sigma_1</span> we can argue similarly as in Lemma 4.1 to deduce that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\epsilon_2 - \\epsilon_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\mathrm{negl}(\\lambda)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Game 3: Here we make use of the fact that <span class="math">\\mathbf{B} \\coloneqq [\\mathbf{E} \\mid \\mathbf{F}]</span> where</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {E} := \\left[ \\begin{array}{c c c} \\mathbf {A} &amp;amp; &amp;amp; \\\\ &amp;amp; \\ddots &amp;amp; \\\\ &amp;amp; &amp;amp; \\mathbf {W} ^ {d} \\mathbf {A} \\end{array} \\right] \\quad \\text {and} \\quad \\mathbf {F} := \\left[ \\begin{array}{c} - \\mathbf {G} \\\\ \\vdots \\\\ - \\mathbf {G} \\end{array} \\right] .</span></div>

    <p class="text-gray-300">Concretely, the Commit algorithm first samples <span class="math">\\hat{\\mathbf{t}}\\leftarrow\\mathcal{D}_{\\sigma_1}^{tN}</span>, sets</p>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\begin{array}{c} \\mathbf {t} \\\\ \\vdots \\\\ \\mathbf {t} \\end{array} \\right] := \\mathbf {F} \\hat {\\mathbf {t}}</span></div>

    <p class="text-gray-300">and then generates</p>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\begin{array}{c} \\mathbf {s} _ {1} \\\\ \\vdots \\\\ \\mathbf {s} _ {d} \\end{array} \\right] \\gets \\mathbf {E} _ {\\sigma_ {1}} ^ {- 1} \\left(\\left[ \\begin{array}{c} - f _ {0} \\mathbf {W} ^ {0} \\mathbf {e} _ {1} \\\\ \\vdots \\\\ - f _ {d} \\mathbf {W} ^ {d} \\mathbf {e} _ {1} \\end{array} \\right] - \\left[ \\begin{array}{c} \\mathbf {t} \\\\ \\vdots \\\\ \\mathbf {t} \\end{array} \\right]\\right)  .</span></div>

    <p class="text-gray-300">Finally, the algorithm outputs <span class="math">\\mathbf{t}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By Lemma 2.5, there is a negligible function <span class="math">\\varepsilon</span> such that <span class="math">\\sigma_{1} \\geq \\eta_{\\varepsilon}(\\Lambda^{\\perp}(\\mathbf{E}))</span>. Further, by Lemma 2.3 the matrix <span class="math">\\mathbf{A}</span> is full-rank (and so is <span class="math">\\mathbf{E}</span>) with an overwhelming probability. Hence, we can apply Lemma 2.9 to conclude $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\epsilon_3 - \\epsilon_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\mathrm{negl}(\\lambda)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Game 4: The Commit algorithm simply samples <span class="math">\\hat{\\mathbf{t}}\\gets \\mathcal{D}_{\\sigma_1}^{tN}</span> and outputs <span class="math">\\mathbf{t}\\coloneqq \\mathbf{G}\\hat{\\mathbf{t}}</span>. Clearly, there is no difference between the outputs of Game 3 and 4, thus <span class="math">\\epsilon_4 = \\epsilon_3</span>.</p>

    <p class="text-gray-300">Finally, the output of Commit in Game 4 does not depend on the challenge messages <span class="math">m_0, m_1</span> from <span class="math">\\mathcal{A}</span>. Hence, we get that <span class="math">\\epsilon_4 = 1/2</span>. By the hybrid argument we obtain <span class="math">\\epsilon = 1/2 + \\mathrm{negl}(\\lambda)</span>, which concludes the proof.</p>

    <p class="text-gray-300">Efficiency. The main bottleneck of the Commit algorithm is the trapdoor sampling procedure, which asymptotically takes <span class="math">O(d^{2})</span> operations over <span class="math">\\mathcal{R}_q</span>. On the other hand, the opening algorithm makes <span class="math">O(d)</span> operations in <span class="math">\\mathcal{R}_q</span>.</p>

    <p class="text-gray-300">Remark 4.4. Wee and Wu [WW23b] proposed an alternative approach, which allows for linear-time commitment generation. This comes at the cost of (i) losing the hiding property, and (ii) the message space inherently must only contain short vectors. Since both properties are important in our polynomial commitment scheme, we do not describe the more efficient method in this work and refer to [WW23b, Remark 4.12] for more details.</p>

    <p class="text-gray-300">In this section we illustrate how to prove evaluations of a polynomial that is committed using the PowerBASIS commitment scheme from Figure 4. We start by presenting a general framework for proving polynomial evaluations in Section 5.1, and then we describe two distinct instantiations in Sections 5.2 and 5.3. For clarity, we give an overview of frequently used parameters in Table 3. We implicitly assume that lattice dimension parameters, such as <span class="math">n, m, N</span>, are <span class="math">\\mathrm{poly}(\\lambda)</span>.</p>

    <p class="text-gray-300">The main intuition can be described as follows. We design a relation that captures statements of the form: "the commitment <span class="math">\\mathbf{t}</span> has an opening <span class="math">f\\in \\mathcal{R}_q^{d + 1}</span> (with respect to a given crs) such that <span class="math">f(u) = v</span>, where <span class="math">f\\in \\mathcal{R}_q^{\\leq d}[\\mathsf{X}]</span> is now interpreted as polynomial". The core observation is that there</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Parameter</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Explanation</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">q</td>

            <td class="px-3 py-2 border-b border-gray-700">proof system modulus</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">N</td>

            <td class="px-3 py-2 border-b border-gray-700">degree of the cyclotomic ring R := Z[X]/(XN+1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">l</td>

            <td class="px-3 py-2 border-b border-gray-700">power-of-two such that q ≡ 2N/l + 1 (mod 4N/l)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">d</td>

            <td class="px-3 py-2 border-b border-gray-700">degree of the committed polynomial f ∈ Rq[X]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">height of the matrix A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">m</td>

            <td class="px-3 py-2 border-b border-gray-700">width of the matrix A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">δ</td>

            <td class="px-3 py-2 border-b border-gray-700">decomposition base of the gadget matrix G</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">q̅</td>

            <td class="px-3 py-2 border-b border-gray-700">[logδq] + 1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">n'</td>

            <td class="px-3 py-2 border-b border-gray-700">nq(d+1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">m'</td>

            <td class="px-3 py-2 border-b border-gray-700">mq(d+1) + nq</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">t'</td>

            <td class="px-3 py-2 border-b border-gray-700">max(n', m')</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">k</td>

            <td class="px-3 py-2 border-b border-gray-700">folding factor of the folding protocol</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">h</td>

            <td class="px-3 py-2 border-b border-gray-700">2h+1 is the number of rounds</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">β</td>

            <td class="px-3 py-2 border-b border-gray-700">initial norm of the witness openings</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">w</td>

            <td class="px-3 py-2 border-b border-gray-700">L1 norm of elements in the challenge space C</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">βC</td>

            <td class="px-3 py-2 border-b border-gray-700">L∞ of elements in C (used in Section 5.3)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">βh</td>

            <td class="px-3 py-2 border-b border-gray-700">norm of the opening vectors sent in the last round</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">βs</td>

            <td class="px-3 py-2 border-b border-gray-700">infinity norm of the extracted relaxation factors</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">γ</td>

            <td class="px-3 py-2 border-b border-gray-700">extracted norm</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3: Overview of parameters and notation.</p>

    <p class="text-gray-300">exists a  <span class="math">\\Sigma</span> -protocol that interactively reduces an instance of that relation to a related one, in which the size of the committed polynomial is decreased. This new relation is with respect to a different common reference string, that can be efficiently computed from the previous one. We then exploit this recursion to shrink to a commitment with a constant-size opening.</p>

    <p class="text-gray-300">We formalise this discussion by introducing the opening relation below</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf {R} _ {d, \\beta} := \\left\\{\\left(\\left(\\mathbf {A}, \\mathbf {W}\\right), (\\mathbf {t}, u, z), \\left(f, \\left(\\mathbf {s} _ {i}\\right) _ {i}\\right)\\right) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} f (u) = z \\\\ \\forall i \\in [ 0, d ], \\mathbf {A} \\mathbf {s} _ {i} + f _ {i} \\mathbf {e} _ {1} = \\mathbf {W} ^ {- i} \\mathbf {t} \\\\ \\wedge \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {s} _ {i} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta \\end{array} \\right. \\right\\}. \\tag {15}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We describe the  <span class="math">\\Sigma</span> -protocol, upon which our main evaluation protocol is built, in Figure 5. Roughly speaking, the prover divides the initial polynomial  <span class="math">f</span>  of degree at most  <span class="math">d</span>  into  <span class="math">k</span>  polynomials  <span class="math">g_1, \\ldots, g_k</span>  of degree at most  <span class="math">d&#x27; := (d + 1)/k - 1</span>  by writing</p>

    <div class="my-4 text-center"><span class="math-block">f (\\mathrm {X}) := \\sum_ {t \\in [ k ]} \\mathrm {X} ^ {t - 1} g _ {t} \\left(\\mathrm {X} ^ {k}\\right). \\tag {16}</span></div>

    <p class="text-gray-300">Then, it "commits" to the partial polynomials by providing their evaluations at the point  <span class="math">u</span> , say</p>

    <p class="text-gray-300"><span class="math">z_{i}\\coloneqq g_{i}(u^{k})</span>. Thus, by construction</p>

    <div class="my-4 text-center"><span class="math-block">z = f (u) = \\sum_ {t \\in [ k ]} u ^ {t - 1} g _ {t} \\left(u ^ {k}\\right) = \\sum_ {t = 1} ^ {k} z _ {t} u ^ {t - 1}. \\tag {17}</span></div>

    <p class="text-gray-300">Next, the verifier outputs a challenge  <span class="math">(\\alpha_{1},\\ldots ,\\alpha_{k})\\gets \\mathcal{C}\\subseteq \\mathcal{R}_{q}^{k}</span> . Note that by considering the folded polynomial  <span class="math">g = \\sum_{t = 1}^{k}\\alpha_{t}g_{t}</span>  of degree at most  <span class="math">d^{\\prime}</span> , we obtain a new polynomial evaluation statement about  <span class="math">g</span> :</p>

    <div class="my-4 text-center"><span class="math-block">g \\left(u ^ {k}\\right) = \\sum_ {t = 1} ^ {k} \\alpha_ {t} z _ {t}. \\tag {18}</span></div>

    <p class="text-gray-300">The main strength of the PowerBASIS commitment from Figure 4 is that the commitment (resp. openings) to  <span class="math">g</span>  can be efficiently computed from the commitment  <span class="math">\\mathbf{t}</span>  (resp. openings  <span class="math">\\mathbf{s}_i</span> ) of  <span class="math">f</span>  given  <span class="math">\\alpha_1, \\ldots, \\alpha_k</span>  in time  <span class="math">O(k)</span> . This is the key idea for achieving succinct verification. Hence, the prover outputs the polynomial  <span class="math">g</span>  in the clear, along with its opening vectors. The verifier eventually checks correctness of the openings with respect to the message  <span class="math">g</span> , as well as (17) and (18).</p>

    <p class="text-gray-300">We first prove that this protocol transforms an instance of  <span class="math">\\mathsf{R}_{d,\\beta}</span>  into a smaller one of  <span class="math">\\mathsf{R}_{d&#x27;,\\beta&#x27;}</span> .</p>

    <p class="text-gray-300"><strong>Lemma 5.1 (Completeness).</strong> Let  <span class="math">\\Pi \\coloneqq \\Sigma [d,k,\\mathcal{C},\\beta ]</span>  as in Figure 5. Then,  <span class="math">\\Pi</span>  is an interactive protocol with perfect completeness for  <span class="math">\\mathsf{R}_{d,\\beta}</span> .</p>

    <p class="text-gray-300"><strong>Proof.</strong> Let  <span class="math">(\\mathbf{i},\\mathbf{x},\\mathbf{w}) = ((\\mathbf{A},\\mathbf{W}),(\\mathbf{t},u,z),(f,(\\mathbf{s}_i)_{i\\in [0,d]}))\\in \\mathsf{R}_{d,\\beta}</span> . Since  <span class="math">f(u) = z</span> , the first verification check always succeeds by Equation (17). We are left to show that the new instance is valid. First,  <span class="math">g(u^{k}) = \\sum_{t\\in [k]}\\alpha_{t}g_{t}(u^{k}) = \\sum_{t\\in [k]}\\alpha_{t}z_{t}</span> . Further, recall that for  <span class="math">i\\in [0,d^{\\prime}]</span>  and  <span class="math">t\\in [k]</span>  we have</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {s} _ {t, i} = \\mathbf {s} _ {k i + t - 1} \\quad \\text {and} \\quad g _ {t, i} = f _ {k i + t - 1},</span></div>

    <p class="text-gray-300">where  <span class="math">g_{t,i}</span>  is the  <span class="math">i</span> -th coefficient of the polynomial  <span class="math">g_t</span> . Hence, the  <span class="math">i</span> -th coefficient of  <span class="math">g</span>  satisfies  <span class="math">g_i = \\sum_{t \\in [k]} \\alpha_t g_{t,i} = \\sum_{t \\in [k]} \\alpha_t f_{ki + t - 1}</span> . Therefore,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf {A} \\mathbf {z} _ {i} + g _ {i} \\mathbf {e} _ {1} = \\mathbf {A} \\left(\\sum_ {t \\in [ k ]} \\alpha_ {t} \\mathbf {s} _ {t, i}\\right) + \\left(\\sum_ {t \\in [ k ]} \\alpha_ {i} f _ {k i + t - 1}\\right) \\cdot \\mathbf {e} _ {1} \\\\ = \\sum_ {t \\in [ k ]} \\alpha_ {t} \\left(\\mathbf {A} \\mathbf {s} _ {k i + t - 1} + f _ {k i + t - 1} \\mathbf {e} _ {1}\\right) \\\\ = \\sum_ {t \\in [ k ]} \\alpha_ {t} \\left(\\mathbf {W} ^ {- (k i + t - 1)} \\mathbf {t}\\right) \\\\ = \\left(\\sum_ {t \\in [ k ]} \\alpha_ {t} \\mathbf {W} ^ {- (k i + t - 1)}\\right) \\cdot \\mathbf {t} \\\\ = \\left(\\mathbf {W} ^ {k}\\right) ^ {- i} \\left(\\sum_ {t \\in [ k ]} \\alpha_ {t} \\mathbf {W} ^ {- (t - 1)}\\right) \\cdot \\mathbf {t}. \\\\ \\end{array}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Finally, by Lemma 2.1 for  <span class="math">\\pmb{\\alpha} \\in \\mathcal{C}</span> ,  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z}_i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\sum_{t \\in [k]} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_t \\mathbf{s}_{t,i} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\sum_{t \\in [k]} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_t \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_1 \\cdot \\beta \\leq \\mathrm{w} \\beta<span class="math">  where  </span>\\mathrm{w} := \\max_{\\pmb{\\alpha} \\in \\mathcal{C}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_1<span class="math"> . This shows that the new instance is in  </span>\\mathsf{R}_{d',\\beta'}$ , and thus the verifier accepts.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\sum_{t\\in [k]}\\mathsf{X}^{t - 1}g_t(\\mathsf{X}^k)\\eqqcolon f(\\mathsf{X})</span></p>

    <p class="text-gray-300"><span class="math">z_{t}\\coloneqq g_{t}(u^{k})</span>  for  <span class="math">t\\in [k]</span></p>

    <p class="text-gray-300"><span class="math">\\alpha \\gets \\mathcal{C}\\subseteq \\mathcal{R}_q^k</span></p>

    <p class="text-gray-300"><span class="math">\\alpha</span></p>

    <p class="text-gray-300"><span class="math">g\\coloneqq \\sum_{t\\in [k]}\\alpha_tg_t</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{z}_i\\coloneqq \\sum_{t\\in [k]}\\alpha_t\\mathbf{s}_{t,i}</span>  for  <span class="math">i\\in [0,d^{\\prime}]</span></p>

    <p class="text-gray-300"><span class="math">\\underline{g,(\\mathbf{z}_i)_{i\\in[0,d^{\\prime}]}}</span></p>

    <p class="text-gray-300"><span class="math">\\beta^{\\prime}\\coloneqq \\mathrm{w}\\beta</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{t}^{\\prime}\\coloneqq \\left(\\sum_{t\\in [k]}\\alpha_{t}\\mathbf{W}^{-(t - 1)}\\right)\\cdot \\mathbf{t}</span></p>

    <p class="text-gray-300"><span class="math">\\mathrm{i}^{\\prime}\\coloneqq (\\mathbf{A},\\mathbf{W}^{k})</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{x}^{\\prime}\\coloneqq \\left(\\mathbf{t}^{\\prime},u^{k},\\sum_{t\\in [k]}\\alpha_{t}z_{t}\\right)</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{w}^{\\prime}\\coloneqq (g,(\\mathbf{z}_i)_{i\\in [0,d^{\\prime}]})</span></p>

    <p class="text-gray-300">Check:</p>

    <p class="text-gray-300"><span class="math">z = \\sum_{t\\in [k]}u^{t - 1}z_{t}</span></p>

    <p class="text-gray-300"><span class="math">(\\mathrm{i}^{\\prime},\\mathbf{x}^{\\prime},\\mathbf{w}^{\\prime})\\in \\mathsf{R}_{d^{\\prime},\\beta^{\\prime}}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 5: The  <span class="math">\\Sigma</span> -protocol  <span class="math">\\Sigma[d, k, \\mathcal{C}, \\beta]</span>  for relation  <span class="math">\\mathsf{R}_{d,\\beta}</span>  in Equation (15). Here,  <span class="math">d&#x27; := (d + 1)/k - 1</span> ,  $\\mathrm{w} := \\max_{\\alpha \\in \\mathcal{C}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_1<span class="math">  and  </span>\\mathbf{s}_{t,i} := \\mathbf{s}_{ki + t - 1}<span class="math">  for  </span>i \\in [0, d']<span class="math">  and  </span>t \\in [k]$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We now apply the <span class="math">\\Sigma</span>-protocol recursively <span class="math">h</span> times, reducing the final opening size to <span class="math">(d+1)/k^{h}</span>, while increasing the final norm for verification by a factor <span class="math">\\mathrm{w}^{h}</span>.</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Construction 5.2.</h6>

    <p class="text-gray-300">Let <span class="math">k,h</span> be integers, and let <span class="math">\\mathcal{C}\\subseteq\\mathcal{R}_{q}^{k}</span>. We let <span class="math">\\mathsf{Eval}[d,k,h,\\mathcal{C},\\beta]\\coloneqq(\\mathcal{P},\\mathcal{V})</span> be the protocol that we describe in Figure 6.</p>

    <p class="text-gray-300">Completeness of the protocol is easily shown by applying Lemma 5.1 <span class="math">h</span> times.</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Lemma 5.3 (Completeness).</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi\\coloneqq\\mathsf{Eval}[d,k,h,\\mathcal{C},\\beta]</span>. Then, <span class="math">\\Pi</span> is an interactive protocol with perfect completeness for <span class="math">\\mathsf{R}_{d,\\beta}</span>.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Denote by <span class="math">(\\mathfrak{i}_{r},\\mathbb{x}_{r},\\mathbb{w}_{r})\\coloneqq((\\mathbf{A},\\mathbf{W}_{r}),(\\mathbf{t}_{r},u_{r},z_{r}),(f_{r},(\\mathbf{s}_{r,i})_{i\\in[d_{r}]}))</span> for <span class="math">r\\in[h]</span>. By Lemma 5.1, <span class="math">(\\mathfrak{i}_{r},\\mathbb{x}_{r},\\mathbb{w}_{r})\\in\\mathsf{R}_{d_{r},\\beta_{r}}</span> implies <span class="math">(\\mathfrak{i}_{r+1},\\mathbb{x}_{r+1},\\mathbb{w}_{r+1})\\in\\mathsf{R}_{d_{r+1},\\beta_{r+1}}</span> with probability 1. Since <span class="math">(\\mathfrak{i}_{0},\\mathbb{x}_{0},\\mathbb{w}_{0})\\in\\mathsf{R}_{d,\\beta_{0}}</span>, then <span class="math">(\\mathfrak{i}_{h},\\mathbb{x}_{h},\\mathbb{w}_{h})\\in\\mathsf{R}_{d_{h},\\beta_{h}}</span>, and thus the verifier final checks accept. ∎</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Remark 5.4.</h6>

    <p class="text-gray-300">The protocol that we have described has folding factor <span class="math">k</span> constant across every round of interaction. In fact, we can gain more flexibility by allowing each round to use a different folding factor. This can be beneficial, for example, to obtain a constant polynomial in the last round of the protocol when the original degree is not a <span class="math">h</span>-power.</p>

    <p class="text-gray-300">We analyse the communication complexity of <span class="math">\\mathsf{Eval}[d,k,h,\\mathcal{C},\\beta]</span> in the next lemma.</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Lemma 5.5 (Efficiency).</h6>

    <p class="text-gray-300">The total communication complexity of <span class="math">\\mathsf{Eval}[d,k,h,\\mathcal{C},\\beta]</span> (in bits) can be bounded by</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$h\\cdot(kN\\lceil\\log q\\rceil+\\lceil\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rceil)+\\frac{d+1}{k^{h}}\\left(N\\lceil\\log q\\rceil+mN\\lceil\\log(2\\,\\mathrm{w}^{h}\\,\\beta)\\rceil\\right)\\enspace.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Further, the prover makes <span class="math">O(md)</span> operations in <span class="math">\\mathcal{R}_{q}</span> while the verifier makes <span class="math">O\\left((n+m)^{2}(hk+d/k^{h})\\right)</span> operations in <span class="math">\\mathcal{R}_{q}</span>.</p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">In each round the prover sends <span class="math">k</span> elements of <span class="math">\\mathcal{R}_{q}</span> to the verifier, and the verifier sends 1 element of <span class="math">\\mathcal{C}</span>. In the final round, the prover sends a polynomial with <span class="math">d_{h}=(d+1)/k^{h}</span> coefficients, and <span class="math">d_{h}+1</span> opening vectors, each of which has norm at most <span class="math">\\beta_{h}</span>.</p>

    <p class="text-gray-300">We turn to the prover complexity and first consider Step 2. Every <span class="math">r</span>-th round out of <span class="math">[h]</span>, the prover makes <span class="math">O(mkd_{r})=O(md_{r-1})</span> operations in <span class="math">\\mathcal{R}_{q}</span>. Since <span class="math">d_{0}=O(d)</span> and in general <span class="math">d_{r}=O(d/k^{r})</span>, the total runtime of the prover can be bounded by</p>

    <p class="text-gray-300"><span class="math">O\\left(\\sum_{r=0}^{h-1}md_{r}\\right)=O\\left(m\\sum_{r=0}^{h-1}d/k^{r}\\right)=O\\left(md\\cdot\\frac{1-1/k^{h}}{1-1/k}\\right)=O(md)\\enspace.</span></p>

    <p class="text-gray-300">We move to the verifier analysis. In Step 2, for every round <span class="math">r\\in[h]</span>, the verifier makes at most <span class="math">O(kn^{2})</span> operations. Hence, the total cost of Step 2 is <span class="math">O(hkn^{2})</span>. The rest of the algorithm takes <span class="math">O(d_{h}(nm+n^{2}))</span> steps. Thus, the total runtime can be bounded by <span class="math">O\\left((n+m)^{2}(hk+d/k^{h})\\right)</span> ring operations. ∎</p>

    <p class="text-gray-300">Next, we provide two instantiations of the protocol in Figure 6 which will differ in the selection of the challenge space <span class="math">\\mathcal{C}</span>. This has direct impact on the knowledge extraction strategy</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}((\\mathbf{A},\\mathbf{W}),(\\mathbf{t},u_0,z_0),(f_0,(\\mathbf{s}_{0,i})_{i\\in [0,d]}))</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">d_0 \\coloneqq d</span> .</li>

      <li>For  <span class="math">r \\in [h]</span> :</li>

    </ol>

    <p class="text-gray-300">(a) Set  <span class="math">d_r \\coloneqq (d_{r-1} + 1) / k - 1</span> . (b) Write  <span class="math">f_{r - 1}(\\mathsf{X})\\coloneqq \\sum_{t\\in [k]}\\mathsf{X}^{t - 1}f_{r - 1,t}(\\mathsf{X}^k)</span>  for  <span class="math">f_{r - 1,1},\\ldots f_{r - 1,k}\\in \\mathcal{R}_{\\overline{q}}^{\\leq d_r}[\\mathsf{X}]</span> (c) Set  <span class="math">z_{r - 1,t}\\coloneqq f_{r - 1,t}(u_{r - 1}^k)</span>  for  <span class="math">t\\in [k]</span> (d) Send  <span class="math">(z_{r - 1,t})_{t\\in [k]}</span>  to the verifier. (e) Receive  <span class="math">\\alpha_{r}</span>  from the verifier. (f) Compute  <span class="math">f_{r}\\coloneqq \\sum_{t\\in [k]}\\alpha_{r,t}f_{r - 1,t}</span> (g) Compute  <span class="math">\\mathbf{s}_{r,i} \\coloneqq \\sum_{t \\in [k]} \\alpha_{r,t} \\mathbf{s}_{r-1,ki+t-1}</span>  for  <span class="math">i \\in [0, d_r]</span> . (h) Compute  <span class="math">u_{r}\\coloneqq u_{r - 1}^{k}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Send  <span class="math">(f_h, (\\mathbf{s}_{h,i})_{i \\in [0,d_h]})</span>  to the verifier.</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathcal{V}((\\mathbf{A},\\mathbf{W}_0),(\\mathbf{t}_0,u_0,z_0))</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\beta_0\\coloneqq \\beta</span></li>

      <li>For  <span class="math">r \\in [h]</span> :</li>

    </ol>

    <p class="text-gray-300">(a)Receive  <span class="math">(z_{r - 1,t})_{t\\in [k]}</span>  from the prover. (b) Check  <span class="math">z_{r - 1} = \\sum_{t\\in [k]}u_{r - 1}^{t - 1}z_{r - 1,t}</span> (c) Sample  <span class="math">\\alpha_{r}\\gets \\mathcal{C}</span>  and send it to the prover. (d) Set  <span class="math">\\mathbf{W}_r\\coloneqq \\mathbf{W}_{r - 1}^k</span> (e) Set  <span class="math">\\mathbf{t}_r\\coloneqq \\left(\\sum_{t\\in [k]}\\alpha_{r,t}\\mathbf{W}_{r - 1}^{-(t - 1)}\\right)\\cdot \\mathbf{t}_{r - 1}.</span> (f) Set  <span class="math">\\beta_r\\coloneqq \\mathrm{w}\\cdot \\beta_{r - 1}</span> (g) Set  <span class="math">u_{r}\\coloneqq u_{r - 1}^{k}</span> (h) Set  <span class="math">z_{r}\\coloneqq \\sum_{t\\in [k]}\\alpha_{r,t}z_{r - 1,t}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Receive  <span class="math">(f_h, (\\mathbf{s}_{h,i})_{i \\in [0,d_h]})</span>  from the prover.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check:</li>

    </ol>

    <p class="text-gray-300">(a)  <span class="math">f_{h}(u_{h}) = z_{h}</span> (b)  <span class="math">\\mathbf{A}\\mathbf{s}_{h,i} + f_{h,i}\\mathbf{e}_1 = \\mathbf{W}_h^{-i}\\mathbf{t}_h</span>  for  <span class="math">i\\in [0,d_h]</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(c)  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}_{h,i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta_h<span class="math">  for  </span>i\\in [0,d_h]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 6: The protocol  <span class="math">\\mathsf{Eval}[d,k,h,\\mathcal{C},\\beta]</span>  for  <span class="math">\\mathsf{R}_{d,\\beta}</span> . As before, we denote  $\\mathbf{w} := \\max_{\\boldsymbol{\\alpha} \\in \\mathcal{C}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\boldsymbol{\\alpha} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_1$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">5.2 Monomial Protocol</p>

    <p class="text-gray-300">In the following, we describe a so-called <em>monomial</em> variant of the protocol, where the name comes from the description of the challenge space <span class="math">\\mathcal{C}</span>. Fix <span class="math">k\\coloneqq 2</span>, and <span class="math">\\mathcal{C}\\coloneqq\\{1\\}\\times\\{X^i:i\\in\\mathbb{Z}\\}</span>. Note that by definition <span class="math">\\mathrm{w}=2</span>, and <span class="math">\\boldsymbol{\\alpha},\\boldsymbol{\\alpha}^{\\prime}\\in\\mathcal{C}</span> with <span class="math">\\boldsymbol{\\alpha}\\neq\\boldsymbol{\\alpha}^{\\prime}</span> implies that <span class="math">\\alpha_{2}-\\alpha_{2}^{\\prime}\\in\\mathcal{R}_{q}^{\\times}</span>. In this section, we also assume that <span class="math">2\\in\\mathcal{R}_{q}^{\\times}</span> (which can be enforced if <span class="math">\\gcd(2,q)=1</span>).</p>

    <p class="text-gray-300">We aim to show that <span class="math">\\Pi\\coloneqq\\mathsf{Eval}[d,2,h,\\mathcal{C},\\beta]</span> is 2-special sound. In fact, we will not be able to show this <em>exactly</em>, as the extraction will introduce some slack. Rather we show that <span class="math">\\Pi</span> is special sound for the <em>relaxed</em> opening relation that we describe next:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\tilde{\\mathsf{R}}_{d,c,\\gamma}\\coloneqq\\left\\{\\left((\\mathbf{A},\\mathbf{W}),(\\mathbf{t},u,z),(f,(\\mathbf{s}_{i})_{i\\in[0,d]})\\right)\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{c}\\forall i\\in[0,d],\\mathbf{A}\\mathbf{s}_{i}+f_{i}\\mathbf{e}_{1}=\\mathbf{W}^{-i}\\mathbf{t}\\wedge\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\wedge f(u)=z\\end{array}\\right.\\right\\}~{}~{}. \\] (19)</p>

    <p class="text-gray-300">We will directly show that <span class="math">\\mathsf{Eval}</span> is special sound, which also implies special soundness of the <span class="math">\\Sigma</span>-protocol by noting that the two protocols are equivalent when <span class="math">h=1</span>. To argue soundness we will first prove that there exists an extractor that is able to extract witnesses of the higher layer of the transcript tree from the children.</p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Lemma 5.6 (Special Soundness for <span class="math">\\Sigma</span>).</h6>

    <p class="text-gray-300">Let <span class="math">c\\in\\mathcal{R}_{q}^{\\times}</span>, and let <span class="math">\\mathbbm{i}=(\\mathbf{A},\\mathbf{W})</span>, <span class="math">\\mathbbm{x}=(\\mathbf{t},u,z)</span>. There exists an algorithm that, given two transcripts <span class="math">\\mathsf{tr}_{j}</span> of the following form</p>

    <p class="text-gray-300"><span class="math">\\mathsf{tr}_{j}\\coloneqq\\left((z_{1},z_{2}),\\boldsymbol{\\alpha}_{j}\\coloneqq(1,\\alpha_{j})\\in\\mathcal{C},\\mathbbm{w}_{j}^{\\prime}\\coloneqq(g_{j},(\\mathbf{z}_{j,i})_{i})\\right)\\quad\\text{for }j=0,1</span></p>

    <p class="text-gray-300">where <span class="math">\\alpha_{0}\\neq\\alpha_{1}</span>, outputs <span class="math">\\mathbbm{w}\\coloneqq(\\bar{f},(\\bar{\\mathbf{s}}_{i})_{i})</span>. Furthermore, let <span class="math">d^{\\prime},\\mathbbm{i}^{\\prime}</span>, <span class="math">\\mathbbm{x}_{0}^{\\prime},\\mathbbm{x}_{1}^{\\prime}</span> be obtained as in Figure 5. If, for <span class="math">i\\in\\{0,1\\}</span>, <span class="math">(\\mathbbm{i}^{\\prime},\\mathbbm{x}_{i}^{\\prime},\\mathbbm{w}_{i}^{\\prime}),\\in\\tilde{\\mathsf{R}}_{d^{\\prime},c,\\beta}</span>, and <span class="math">z=z_{1}+uz_{2}</span>, then <span class="math">(\\mathbbm{i},\\mathbbm{x},\\mathbbm{w})\\in\\tilde{\\mathsf{R}}_{d,2c,\\gamma}</span> where <span class="math">\\gamma\\coloneqq 2N\\beta</span>.</p>

    <h6 id="sec-59" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider the following algorithm:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{E}(\\mathsf{tr}_{0},\\mathsf{tr}_{1})</span>:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">\\bar{\\mathbf{s}}_{2i}\\coloneqq\\frac{\\alpha_{1}\\mathbf{z}_{0,i}-\\alpha\\mathbf{z}_{1,i}}{\\alpha_{1}-\\alpha_{0}}</span>, <span class="math">\\bar{\\mathbf{s}}_{2i+1}\\coloneqq\\frac{\\mathbf{z}_{0,i}-\\mathbf{z}_{1,i}}{\\alpha_{0}-\\alpha_{1}}</span> for <span class="math">i\\in[0,(d-1)/2]</span>.</li>

      <li>Set <span class="math">\\bar{f}_{1}\\coloneqq\\frac{\\alpha_{1}g_{0}-\\alpha_{0}g_{1}}{\\alpha_{1}-\\alpha_{0}}</span>, <span class="math">\\bar{f}_{2}\\coloneqq\\frac{g_{0}-g_{1}}{\\alpha_{0}-\\alpha_{1}}</span>.</li>

      <li>Set <span class="math">\\bar{f}\\coloneqq f_{1}(\\mathsf{X}^{2})+\\mathsf{X}\\bar{f}_{2}(\\mathsf{X}^{2})</span>.</li>

      <li>Return <span class="math">\\bar{f},(\\bar{\\mathbf{s}}_{i})_{i\\in[0,d]}</span>.</li>

    </ol>

    <p class="text-gray-300">Let now <span class="math">(\\bar{f},(\\bar{\\mathbf{s}}_{i})_{i})\\leftarrow\\mathcal{E}(\\mathsf{tr})</span>. Note that</p>

    <p class="text-gray-300"><span class="math">\\mathbf{A}\\bar{\\mathbf{s}}_{2i}+\\bar{f}_{2i}\\mathbf{e}_{1}</span> <span class="math">=\\mathbf{W}^{-2i}\\mathbf{t}</span> <span class="math">\\mathbf{A}\\bar{\\mathbf{s}}_{2i+1}+\\bar{f}_{2i+1}\\mathbf{e}_{1}</span> <span class="math">=\\mathbf{W}^{-(2i+1)}\\mathbf{t}~{}~{}.</span></p>

    <p class="text-gray-300">Now, we have that:</p>

    <p class="text-gray-300"><span class="math">\\bar{f}(u)</span> <span class="math">=\\bar{f}_{1}(u^{2})+u\\bar{f}_{2}(u^{2})</span> <span class="math">=\\frac{\\alpha_{1}g_{0}(u^{2})-\\alpha_{0}g_{1}(u^{2})}{\\alpha_{1}-\\alpha_{0}}+u\\frac{g_{0}(u^{2})-g_{1}(u^{2})}{\\alpha_{0}-\\alpha_{1}}</span> <span class="math">=z_{1}+uz_{2}</span> <span class="math">=z~{}~{}.</span></p>

    <p class="text-gray-300">Finally, we set <span class="math">c^<em> \\coloneqq 2c</span>. First, note that <span class="math">c^</em> \\in \\mathcal{R}_q^\\times</span> since <span class="math">2 \\in \\mathcal{R}_q^\\times</span>. Now, for <span class="math">i \\in [0, d&#x27;]</span>, we have:</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c^* \\cdot \\bar{\\mathbf{s}}_{2i} \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{2}{\\alpha_1 - \\alpha_0} \\cdot c \\cdot (\\alpha_1 \\mathbf{z}_{0,i} - \\alpha_0 \\mathbf{z}_{1,i}) \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">= \\left\\</td>

            <td class="px-3 py-2 border-b border-gray-700">c (\\alpha_1 \\mathbf{z}_{0,i} - \\alpha_0 \\mathbf{z}_{1,i}) \\right\\</td>

            <td class="px-3 py-2 border-b border-gray-700">_1 \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\leq \\sqrt{N} \\left( \\left\\</td>

            <td class="px-3 py-2 border-b border-gray-700">\\alpha_1 c \\mathbf{z}_{0,i} \\right\\</td>

            <td class="px-3 py-2 border-b border-gray-700">+ \\left\\</td>

            <td class="px-3 py-2 border-b border-gray-700">\\alpha_0 c \\mathbf{z}_{1,i} \\right\\</td>

            <td class="px-3 py-2 border-b border-gray-700">\\right) \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\leq N \\left( \\left\\</td>

            <td class="px-3 py-2 border-b border-gray-700">\\alpha_1 \\right\\</td>

            <td class="px-3 py-2 border-b border-gray-700">\\cdot \\left\\</td>

            <td class="px-3 py-2 border-b border-gray-700">c \\mathbf{z}_{0,i} \\right\\</td>

            <td class="px-3 py-2 border-b border-gray-700">+ \\left\\</td>

            <td class="px-3 py-2 border-b border-gray-700">\\alpha_0 \\right\\</td>

            <td class="px-3 py-2 border-b border-gray-700">\\cdot \\left\\</td>

            <td class="px-3 py-2 border-b border-gray-700">c \\mathbf{z}_{1,i} \\right\\</td>

            <td class="px-3 py-2 border-b border-gray-700">\\right) \\\\</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\leq 2N\\beta = \\gamma \\\\ \\end{array} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where the second equality follows by Lemma 2.17 and the last inequality by $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1<span class="math"> for </span>(1, \\alpha) \\in \\mathcal{C}<span class="math">. Similarly, </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c^* \\cdot \\bar{\\mathbf{s}}_{2i+1} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\gamma$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Using this extractor, we show that <span class="math">\\Pi</span> is <span class="math">(2,\\ldots,2)</span>-special sound. The new extractor will start from the leaves of the tree of transcripts, applying the extractor described in Lemma 5.6 to obtain witnesses <span class="math">^{15}</span> for the upper layer.</p>

    <p class="text-gray-300"><strong>Lemma 5.7 (Special Soundness for Eval).</strong> Let <span class="math">\\mathcal{C} \\coloneqq \\{1\\} \\times \\{X^i : i \\in \\mathbb{Z}\\}</span> and let <span class="math">\\Pi \\coloneqq \\mathsf{Eval}[d,2,h,\\mathcal{C},\\beta]</span> be as in Construction 5.2. Set <span class="math">\\gamma \\coloneqq (2N)^h \\cdot \\beta_h</span>. Then <span class="math">\\Pi</span> is a special sound proof system for <span class="math">\\bar{\\mathsf{R}}_{d,2^h,\\gamma}</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Let <span class="math">\\mathbf{tr}</span> be a tree of transcripts, which we index as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\alpha_{(r,j)}</span> for <span class="math">(r,j) \\in [h] \\times [2^r]</span> is the <span class="math">j</span>-th challenge in the <span class="math">r</span>-th layer of the transcript.</li>

      <li><span class="math">(z_{(r,j),1}, z_{(r,j),2})</span> for <span class="math">(r,j) \\in [0, h - 1] \\times [2^r]</span> is the <span class="math">j</span>-th response in the <span class="math">r</span>-th layer of the transcript.</li>

      <li><span class="math">(\\bar{f}_{(h,j)}, (\\bar{\\mathbf{s}}_{(h,j),i})_i)</span> for <span class="math">j \\in [2^h]</span> is the final message sent by the prover.</li>

    </ul>

    <p class="text-gray-300">We introduce the following notation as in the verifier algorithm:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">d_0 := d</span>, <span class="math">d_r := d_{r-1}/2</span> for <span class="math">r \\in [h]</span></li>

      <li><span class="math">\\mathbf{W}_0 := \\mathbf{W}</span>, <span class="math">\\mathbf{W}_r := \\mathbf{W}_{r-1}^2</span> for <span class="math">r \\in [h]</span>.</li>

      <li><span class="math">\\mathbf{t}_{(0,1)} := \\mathbf{t}</span>, <span class="math">\\mathbf{t}_{(r,2j-1)} := (1 + \\alpha_{(r,2j-1)} \\mathbf{W}_{r-1}^{-1}) \\mathbf{t}_{(r-1,j)}</span>, <span class="math">\\mathbf{t}_{(r,2j)} := (1 + \\alpha_{(r,2j)} \\mathbf{W}_{r-1}^{-1}) \\mathbf{t}_{(r-1,j)}</span> for <span class="math">(r,j) \\in [h] \\times [2^r]</span>.</li>

      <li><span class="math">\\beta_0 := \\beta</span>, <span class="math">\\beta_r := 2N \\cdot \\beta_{r-1}</span> for <span class="math">r \\in [h]</span>.</li>

      <li><span class="math">u_0 := u</span>, <span class="math">u_r := u_{r-1}^2</span> for <span class="math">r \\in [h]</span>.</li>

      <li><span class="math">z_{(r,2j-1)} := z_{(r-1,j),1} + \\alpha_{(r,2j-1)} z_{(r-1,j),2}</span>, <span class="math">z_{(r,2j)} := z_{(r-1,j),1} + \\alpha_{(r,2j)} z_{(r-1,j),2}</span> for <span class="math">(r,j) \\in [h] \\times [2^r - 1]</span>.</li>

    </ul>

    <p class="text-gray-300">Denote with <span class="math">\\mathcal{E}^{(1)}</span> the extractor of Lemma 5.6.</p>

    <p class="text-gray-300"><strong><span class="math">\\mathcal{E}(\\mathrm{tr})</span>:</strong></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">d_0 := d</span>, <span class="math">d_r := d_{r-1}/2</span> for <span class="math">r \\in [h]</span>.</li>

      <li>For <span class="math">r := h, \\ldots, 1</span>:</li>

    </ol>

    <p class="text-gray-300">15We also implicitly collect the corresponding relaxation factors, which are the same across the same layer.</p>

    <p class="text-gray-300">47</p>

    <p class="text-gray-300">(a) Set, for <span class="math">j \\in [2^{r-1}]</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{tr}_{(r-1,j)} := \\left( (z_{(r-1,j),1}, z_{(r-1,j),2}), \\begin{array}{c} \\alpha_{(r,2j-1)}, (\\bar{f}_{(r,2j-1)}, (\\bar{\\mathbf{s}}_{(r,2j-1),i})_{i}) \\\\ \\alpha_{(r,2j)}, (\\bar{f}_{(r,2j)}, (\\bar{\\mathbf{s}}_{(r,2j),i})_{i}) \\end{array} \\right) \\quad .</span></div>

    <p class="text-gray-300">(b) Compute <span class="math">\\bar{f}_{(r-1,j)}, (\\bar{\\mathbf{s}}_{(r-1,j),i})_{i \\in [0,d_{r-1}]} \\gets \\mathcal{E}^{(1)}(\\mathrm{tr}_{(r-1,j)})</span> for <span class="math">j \\in [2^{r-1}]</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Return <span class="math">\\bar{f}_{(0,1)}, (\\bar{\\mathbf{s}}_{(0,1),i})_{i \\in [d]}</span>.</li>

    </ol>

    <p class="text-gray-300">We prove that this extractor yields a valid witness by induction on <span class="math">r</span>. First note that, by the verifier checks, for <span class="math">(r,j) \\in [h] \\times [2^r]</span></p>

    <div class="my-4 text-center"><span class="math-block">z_{(r-1,j)} = z_{(r-1,j),1} + u_{r-1} z_{(r-1,j),2}.</span></div>

    <p class="text-gray-300">Write <span class="math">\\dot{\\mathbf{i}}_{(r,j)} \\coloneqq (\\mathbf{A}, \\mathbf{W}_r)</span>, <span class="math">\\mathbf{z}_{(r,j)} \\coloneqq (\\mathbf{t}_{(r,j)}, u_{(r,j)}, z_{(r,j)})</span>, <span class="math">\\mathbf{w}_{(r,j)} \\coloneqq (\\bar{f}_{(r,j)}, (\\bar{\\mathbf{s}}_{(r,j),i})_i)</span> for <span class="math">(r,j) \\in [h] \\times [2^r]</span>. For <span class="math">r = h</span>, since the transcripts are accepting, <span class="math">(\\dot{\\mathbf{i}}_{(h,j)}, \\mathbf{z}_{(h,j)}, \\mathbf{w}_{(h,j)}) \\in \\mathsf{R}_{d_h, \\beta_h} = \\tilde{\\mathsf{R}}_{d_h, 1, \\beta_h}</span> for <span class="math">j \\in [2^h]</span>. Thus, by Lemma 5.6, <span class="math">(\\dot{\\mathbf{i}}_{(h-1,j)}, \\mathbf{z}_{(h-1,j)}, \\mathbf{w}_{(h-1,j)}) \\in \\tilde{\\mathsf{R}}_{d_{h-1}, 2, 2N\\beta_h}</span>.</p>

    <p class="text-gray-300">We can continue with the induction, and this yields that for the extracted witness <span class="math">\\mathbf{w}_{(0,1)} \\coloneqq (\\bar{f}_{(0,1)}, (\\bar{\\mathbf{s}}_{(0,1),i})_{i \\in [d]})</span> we have that:</p>

    <div class="my-4 text-center"><span class="math-block">(\\dot{\\mathbf{i}}_{(0,1)}, \\mathbf{z}_{(0,1)}, \\mathbf{w}_{(0,1)}) \\in \\tilde{\\mathsf{R}}_{d, 2^h, (2N)^h \\beta_h}.</span></div>

    <p class="text-gray-300">Setting <span class="math">\\gamma \\coloneqq (2N)^h \\beta_h</span>, and noting that <span class="math">2^h \\in \\mathcal{R}_q^\\times</span>, this concludes our proof.</p>

    <p class="text-gray-300">We can use Eval to construct a polynomial commitment scheme. We detail the construction in Theorem 5.8 and summarise the parameters and efficiency features in Table 4.</p>

    <p class="text-gray-300"><strong>Theorem 5.8.</strong> Let <span class="math">\\mathsf{PC} = (\\mathsf{Setup}, \\mathsf{Commit}, \\mathsf{Open}, \\mathcal{P}^t, \\mathcal{V}^t)</span> where <span class="math">\\mathsf{Setup}, \\mathsf{Commit}, \\mathsf{Open}</span> are as in Figure 4 and <span class="math">\\mathcal{P}^t, \\mathcal{V}^t</span> are the <span class="math">t</span>-parallel repetitions of the prover and verifier of Eval. Then <span class="math">\\mathsf{PC}</span> is an interactive polynomial commitment scheme with the efficiency properties and parameters shown in Table 4. In particular, when <span class="math">h = O(\\log d)</span> and <span class="math">t &amp;gt; \\frac{\\lambda}{\\log N + 1 - \\log h}</span> we obtain an interactive polynomial commitment scheme with negligible knowledge soundness error, polylogarithmic communication complexity, and polylogarithmic verifier time.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Completeness and relaxed binding follow from Lemmata 4.1 and 4.2. Perfect evaluation completeness follows from Lemma 5.1. For evaluation knowledge soundness, we apply [AF22, Theorem 4] to Lemma 5.7. Communication complexity follows from Lemma 5.5. Additionally, claims about the prover and verifier runtime hold by Lemma 5.5 and the fact that both <span class="math">\\log q</span> and <span class="math">N</span> are polynomial in <span class="math">\\lambda</span>.</p>

    <h2 id="sec-60" class="text-2xl font-bold">5.3 Large Sampling Set</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We present a second instantiation which allows us to obtain negligible knowledge soundness error without parallel repetition, using coordinate-wise special soundness (c.f. Section 2.9) and a large challenge space. We let <span class="math">t, k \\in \\mathbb{N}</span>. Fix also <span class="math">\\beta_{\\mathcal{C}} &amp;gt; 0</span>. Recall that $S_{\\kappa} \\coloneqq \\{\\alpha \\in \\mathcal{R}_q : \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq \\kappa \\}$. We define the challenge space and the slack space as</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{C} := S_{\\beta_{\\mathcal{C}}}^k \\quad \\text{and} \\quad \\mathcal{S}_t := \\left\\{ \\prod_{i \\in [t]} \\alpha_i - \\alpha_i&#x27; : \\alpha_i, \\alpha_i&#x27; \\in S_{\\beta_{\\mathcal{C}}}, \\alpha_i \\neq \\alpha_i&#x27; \\right\\}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Parameters</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Instantiation</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">m</td>

            <td class="px-3 py-2 border-b border-gray-700">≥ n(1 + q)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">l</td>

            <td class="px-3 py-2 border-b border-gray-700">N/2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">δ</td>

            <td class="px-3 py-2 border-b border-gray-700">q1/O(1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">s</td>

            <td class="px-3 py-2 border-b border-gray-700">> 2Nqn/m-nq+2/N(m-nq)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">σ0</td>

            <td class="px-3 py-2 border-b border-gray-700">≥ δsNnq·ω(√2(d+1)n(m-nq)N log t'N)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">σ1</td>

            <td class="px-3 py-2 border-b border-gray-700">≥ δσ0N·ω(√m'n' log t'N)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">β</td>

            <td class="px-3 py-2 border-b border-gray-700">≥ σ1√m'N</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">k</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">{1} × {Xi: i ∈ Z}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">w</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">βh</td>

            <td class="px-3 py-2 border-b border-gray-700">wh·β</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">γ</td>

            <td class="px-3 py-2 border-b border-gray-700">(2N)h·βh</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">βs</td>

            <td class="px-3 py-2 border-b border-gray-700">2h</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Soundness</td>

            <td class="px-3 py-2 border-b border-gray-700">(h/2N)l</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Commitment size</td>

            <td class="px-3 py-2 border-b border-gray-700">nN log q</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Communication complexity</td>

            <td class="px-3 py-2 border-b border-gray-700">l·(h(2N log q + log N + 1) + d+1/2h(N log q + mN log βh))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Prover time</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ·md)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verifier time</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ·(n+m)2·(2h+d/2h))</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 4: Parameters for the interactive polynomial commitment scheme obtained from Figure 4 and running the  <span class="math">\\ell</span> -parallel repetition of  <span class="math">\\mathsf{Eval}[d,2,h,\\mathcal{C},\\beta]</span>  for proofs of evaluation. We compute the prover and verifier runtime in terms of operations in  <span class="math">\\mathcal{R}_q</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= (2\\beta_{\\mathcal{C}} + 1)^{kN}<span class="math">  and  </span>\\mathrm{w} \\leq \\beta_{\\mathcal{C}} k N<span class="math"> . We also let  </span>\\beta_{s,t} \\coloneqq \\max_{c \\in S_t} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math"> . Note that, for  </span>c \\in S_t$ ,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} \\leq \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\prod_ {i} \\left(\\alpha_ {i} - \\alpha_ {i} ^ {\\prime}\\right) \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} \\leq \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_ {1} - \\alpha_ {1} ^ {\\prime} \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} \\cdot \\prod_ {i \\neq 1} \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_ {i} - \\alpha_ {i} ^ {\\prime} \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {1} \\leq 2 \\beta_ {\\mathcal {C}} \\cdot \\left(2 \\beta_ {\\mathcal {C}} N\\right) ^ {t - 1},</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and thus  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_1\\leq (2\\beta_{\\mathcal{C}}N)^t$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We show a simple invertibility result that will be useful in the proof of soundness.</p>

    <p class="text-gray-300">Lemma 5.9. Let  <span class="math">1 \\leq l &amp;lt; N</span>  be a power of two, and suppose that  <span class="math">q \\equiv 2N / l + 1 \\pmod{4N / l}</span> . If  <span class="math">2\\beta_{\\mathcal{C}} &amp;lt; \\sqrt{l / N} q^{l / N}</span> , then for any  <span class="math">t \\geq 1</span> ,  <span class="math">\\mathcal{S}_t \\subseteq \\mathcal{R}_q^\\times</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Let  <span class="math">\\alpha \\neq \\alpha&#x27; \\in S_{\\beta_{\\mathcal{C}}}</span> . Then,  <span class="math">\\alpha - \\alpha&#x27; \\neq 0</span> , and  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha - \\alpha' \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq 2\\beta_{\\mathcal{C}}<span class="math"> . Thus, by Lemma 2.18,  </span>\\alpha - \\alpha' \\in \\mathcal{R}_q^\\times<span class="math"> . Elements of  </span>S_t$  are products of elements of that form, and since the product of invertible elements is itself invertible, the result follows.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We will assume thereafter that we are in the regime in which Lemma 2.18 holds (as in Table 3).</p>

    <p class="text-gray-300">We again aim to show that  <span class="math">\\mathsf{Eval}[d,k,h,\\mathcal{C},\\beta]</span>  is knowledge sound. As before, we define an opening relation, which will differ from Equation (19) in that the relaxation factors will not be the same across openings, but rather will be included as part of the witness. This will reflect the fact that the extracted opening will have different slack derived from the challenges.</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde {\\mathrm {R}} _ {d, \\beta , t} := \\left\\{\\left(\\left(\\mathbf {A}, \\mathbf {W}\\right), \\left(\\mathbf {t}, u, z\\right), \\left(f, \\left(\\mathbf {s} _ {i}\\right) _ {i}, \\left(c _ {i}\\right) _ {i}\\right)\\right) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\forall i \\in [ 0, d ], \\mathbf {A} \\mathbf {s} _ {i} + f _ {i} \\mathbf {e} _ {1} = \\mathbf {W} ^ {- i} \\mathbf {t} \\wedge \\\\ \\wedge c _ {i} \\in \\mathcal {S} _ {t} \\wedge \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c _ {i} \\cdot \\mathbf {s} _ {i} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta \\\\ \\wedge f (u) = z \\end{array} \\right. \\right\\} \\tag {20}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">As before, to argue that the protocol is knowledge sound, we will first show an extractor to be used to move between layers of the transcript tree. In this case however, we will argue using coordinate-wise special soundness instead of special soundness.</p>

    <p class="text-gray-300"><strong>Lemma 5.10</strong> (Coordinate-Wise Special Soundness for <span class="math">\\Sigma</span>). Let <span class="math">c \\in \\mathcal{R}_q^\\times</span>, and let <span class="math">\\mathbb{i} = (\\mathbf{A}, \\mathbf{W})</span>, <span class="math">\\mathbf{x} = (\\mathbf{t}, u, z)</span>. There exists an algorithm that, given <span class="math">k + 1</span> transcripts <span class="math">(\\mathrm{tr}_j)_{j \\in [0,k]}</span> of the following form:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {t r} _ {j} := \\left( \\begin{array}{c} (z _ {1}, \\ldots , z _ {k}) \\\\ \\boldsymbol {\\alpha} _ {j} \\\\ (g _ {j}, (\\mathbf {s} _ {j, i}) _ {i \\in [ 0, d ^ {\\prime} ]}) \\end{array} \\right) \\text{ with } (\\boldsymbol {\\alpha} _ {j}) _ {j} \\in \\mathsf {S S} (S _ {\\beta_ {C}}, k),</span></div>

    <p class="text-gray-300">and slack <span class="math">(c_{j,i})_{j,i}</span> outputs <span class="math">\\mathbf{w} := (\\bar{f}, (\\bar{\\mathbf{s}}_i)_i, (\\bar{c}_i)_i)</span>. Furthermore, let <span class="math">\\mathbf{i}&#x27;</span>, <span class="math">(\\mathbf{x}_j&#x27;)_{j \\in [k]}</span> be obtained as in Figure 5 (where <span class="math">\\mathbf{x}_j&#x27;</span> is obtained from the <span class="math">j</span>-th leaf of the transcript) and <span class="math">\\mathbf{w}_j&#x27; := (g_j, (s_{j,i})_i, (c_{j,i})_i)</span>. If, for <span class="math">i \\in [0,k]</span>, <span class="math">(\\mathbf{i}&#x27;, \\mathbf{x}_i&#x27;, \\mathbf{w}_i&#x27;) \\in \\tilde{\\mathsf{R}}_{d&#x27;,\\beta,t}</span>, and <span class="math">z = \\sum_{t \\in [k]} u^{t-1} z_t</span>, then <span class="math">(\\mathbf{i}, \\mathbf{x}, \\mathbf{w}) \\in \\tilde{\\mathsf{R}}_{d,\\gamma,2t+1}</span> where <span class="math">\\gamma := 2\\beta</span> if <span class="math">t = 0</span> and <span class="math">\\gamma := 2N\\beta_{s,t}\\beta</span> otherwise.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Assume, without loss of generality, that the transcripts are arranged so that, for <span class="math">j \\in [k]</span>, <span class="math">\\alpha_0 \\equiv_j \\alpha_j</span>. We thus can write <span class="math">\\alpha_0 = (\\alpha_1, \\ldots, \\alpha_k)</span> and <span class="math">\\alpha_j := (\\alpha_1, \\ldots, \\alpha_j&#x27;, \\ldots, \\alpha_k)</span> with <span class="math">\\alpha_j \\neq \\alpha_j&#x27;</span>. Consider the extractor</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {E} (\\operatorname {t r} = \\left(\\operatorname {t r} _ {0}, \\dots , \\operatorname {t r} _ {k}\\right), \\left(\\tilde {c} _ {j, i}\\right) _ {j, i}):</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">j \\in [k]</span>:</li>

    </ol>

    <p class="text-gray-300">(a) Set <span class="math">\\bar{f}_j \\coloneqq \\frac{g_0 - g_j}{\\alpha_j - \\alpha_j&#x27;}</span>.</p>

    <p class="text-gray-300">(b) For <span class="math">i \\in [0, d&#x27;]</span>:</p>

    <p class="text-gray-300">i. Set <span class="math">\\bar{\\mathbf{s}}_{ki + j - 1} \\coloneqq \\frac{\\mathbf{z}_{0,i} - \\mathbf{z}_{j,i}}{\\alpha_j - \\alpha_j&#x27;}</span>.</p>

    <p class="text-gray-300">ii. Set <span class="math">\\bar{c}_{ki + j - 1} \\coloneqq (\\alpha_j - \\alpha_j&#x27;) c_{0,i} c_{j,i}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">\\bar{f} := \\sum_{j \\in [k]} \\mathsf{X}^{j-1} \\bar{f}_j(\\mathsf{X}^k)</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Return <span class="math">(\\bar{f}, (\\bar{\\mathbf{s}}_i)_{i \\in [0, d]}), (\\bar{c}_i)_{i \\in [0, d]}</span>.</li>

    </ol>

    <p class="text-gray-300">Since the transcript is accepting, for <span class="math">j \\in [0,k], i \\in [0,d&#x27;]</span> we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A} \\mathbf {z} _ {j, i} + g _ {j, i} \\mathbf {e} _ {1} = (\\mathbf {W} ^ {k}) ^ {- i} \\left(\\sum_ {t \\in [ k ]} \\alpha_ {j, t} \\mathbf {W} ^ {t - 1}\\right) \\mathbf {t}.</span></div>

    <p class="text-gray-300">Subtracting the equation for <span class="math">j = 0</span> from the equation for <span class="math">j \\in [k]</span> yields that, for <span class="math">i \\in [0, d&#x27;]</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A} \\left(\\frac {\\mathbf {z} _ {0 , i} - \\mathbf {z} _ {j , i}}{\\alpha_ {j} - \\alpha_ {j} ^ {\\prime}}\\right) + \\left(\\frac {g _ {0 , i} - g _ {j , i}}{\\alpha_ {j} - \\alpha_ {j} ^ {\\prime}}\\right) \\mathbf {e} _ {1} = \\mathbf {W} ^ {- (k i + j - 1)} \\mathbf {t}.</span></div>

    <p class="text-gray-300">To show that the extracted <span class="math">\\bar{f}</span> evaluates to <span class="math">z</span> at <span class="math">u</span>, note that:</p>

    <div class="my-4 text-center"><span class="math-block">\\bar {f} (u) = \\sum_ {j \\in [ k ]} u ^ {j - 1} \\bar {f} _ {j} (u ^ {k})</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} = \\sum_{j \\in [k]} u^{j-1} \\frac{g_0(u^k) - g_j(u^k)}{\\alpha_j - \\alpha_j&#x27;} \\\\ = \\sum_{j \\in [k]} u^{j-1} \\frac{\\sum_{t \\in [k]} (\\alpha_{0,t} - \\alpha_{j,t}) z_t}{\\alpha_j - \\alpha_j&#x27;} \\\\ = \\sum_{j \\in [k]} u^{j-1} z_j = z. \\end{array}</span></div>

    <p class="text-gray-300">Where in the third equality we have used that the verifier check accepts, and for the fourth <span class="math">\\sum_{t \\in [k]} (\\alpha_{0,t} - \\alpha_{j,t}) z_t = (\\alpha_j - \\alpha_j&#x27;) z_j</span>. We argue that the extracted <span class="math">\\bar{\\mathbf{s}}_i</span> are (relaxed) short.</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{c}_{ki+j-1} \\cdot \\bar{\\mathbf{s}}_{ki+j-1} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\alpha_j - \\alpha_j') c_{0,i} c_{j,i} \\frac{\\mathbf{z}_{0,i} - \\mathbf{z}_{j,i}}{\\alpha_j - \\alpha_j'} \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\leq \\</td>

            <td class="px-3 py-2 border-b border-gray-700">c_{j,i} c_{0,i} \\mathbf{z}_{0,i} \\</td>

            <td class="px-3 py-2 border-b border-gray-700">+ \\</td>

            <td class="px-3 py-2 border-b border-gray-700">c_{0,i} c_{j,i} \\mathbf{z}_{j,i} \\</td>

            <td class="px-3 py-2 border-b border-gray-700">\\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\leq \\sqrt{N} \\beta_{s,t} \\left( \\</td>

            <td class="px-3 py-2 border-b border-gray-700">c_{0,i} \\mathbf{z}_{0,i} \\</td>

            <td class="px-3 py-2 border-b border-gray-700">_1 + \\</td>

            <td class="px-3 py-2 border-b border-gray-700">c_{j,i} \\mathbf{z}_{j,i} \\</td>

            <td class="px-3 py-2 border-b border-gray-700">_1 \\right) \\\\</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\leq 2N \\beta_{s,t} \\beta = \\gamma. \\end{array} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">t = 0</span>, then the slacks must have been 1, and thus $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{c}_{ki+j-1} \\bar{\\mathbf{s}}_{ki+j-1} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z}_{0,i} - \\mathbf{z}_{j,i} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2\\beta<span class="math"> as desired. Finally, what is left to show is that the new slack is in the prescribed slack space. This is easy to show as the previous two slacks are a product of </span>t<span class="math"> differences of challenges, that we then multiply with a new difference, leading to a product of </span>2t + 1<span class="math"> differences of challenges. Lemma 5.9 guarantees that this new slack is invertible as long as </span>\\beta_{\\mathcal{C}}$ is small enough.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We then use this extractor recursively to show that Eval is coordinate-wise special sound.</p>

    <p class="text-gray-300"><strong>Lemma 5.11</strong> (Coordinate-Wise Special Soundness for Eval). Let <span class="math">k, h \\in \\mathbb{N}</span>, <span class="math">\\beta_{\\mathcal{C}} &amp;gt; 0</span>. Let <span class="math">\\Pi \\coloneqq \\operatorname{Eval}[d, k, h, \\mathcal{C}, \\beta]</span> be as in Construction 5.2. Then, <span class="math">\\Pi</span> is a <span class="math">k</span>-coordinate-wise special sound proof system for the relation <span class="math">\\bar{\\mathsf{R}}_{d,\\gamma,t}</span> where</p>

    <div class="my-4 text-center"><span class="math-block">\\gamma := 2^h \\cdot (2 \\beta_{\\mathcal{C}} N)^{2^h - h - 1} \\cdot \\beta_h</span></div>

    <div class="my-4 text-center"><span class="math-block">t := 2^h - 1.</span></div>

    <p class="text-gray-300"><strong>Proof.</strong> We index the transcript as in Lemma 5.7. Denote by <span class="math">\\mathcal{E}^{(1)}</span> the extractor of Lemma 5.10. Consider the new extractor</p>

    <p class="text-gray-300"><span class="math">\\mathcal{E}(\\mathrm{tr})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">\\bar{c}_{(h,j)} = 1</span> for <span class="math">j \\in [(k + 1)^h]</span>.</li>

      <li>For <span class="math">r \\coloneqq h, \\ldots, 1</span>:</li>

    </ol>

    <p class="text-gray-300">(a) Set for <span class="math">j \\in [(k + 1)^{r - 1}]</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{tr}_{(r-1,j)} := \\left( \\begin{array}{c} (\\alpha_{(r,(j-1)(k+1)+1)}, (\\bar{f}_{(r,(j-1)(k+1)+1)}, (\\bar{\\mathbf{s}}_{(r,(j-1)(k+1)+1),i})_{i})) \\\\ (z_{(r-1,j),t})_{t \\in [k]} \\\\ \\quad \\vdots \\\\ (\\alpha_{(r,j(k+1))}, (\\bar{f}_{(r,j(k+1))}, (\\bar{\\mathbf{s}}_{(r,j(k+1)),i})_{i})) ) . \\end{array} \\right).</span></div>

    <p class="text-gray-300">(b) Compute <span class="math">(\\bar{f}_{(r-1,j)}, (\\bar{\\mathbf{s}}_{(r-1,j),i})_i, (\\bar{c}_{(r-1,j),i})_i) \\gets \\mathcal{E}^{(1)}(\\mathrm{tr}_{(r-1,j)}, (\\bar{c}_{(r,(j-1)(k+1)+t),i})_{t,i})</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Return <span class="math">\\bar{f}_{(0,1)},(\\bar{\\mathbf{s}}_{(0,1),t}),(\\bar{c}_{(0,1),t})_t</span>.</li>

    </ol>

    <p class="text-gray-300">We argue that the extractor yields a valid witness inductively. We again note that for <span class="math">(r,j) \\in [h] \\times [(k + 1)^r]</span>, since the transcripts are accepting,</p>

    <div class="my-4 text-center"><span class="math-block">z_{(r-1,j)} = \\sum_{t \\in [k]} u_{r-1}^{k-1} z_{(r-1,j),t}.</span></div>

    <p class="text-gray-300">Write <span class="math">\\dot{\\mathbf{s}}_{(r,j)} \\coloneqq (\\mathbf{A}, \\mathbf{W}_r)</span>, <span class="math">\\mathbf{x}_{(r,j)} \\coloneqq (\\mathbf{t}_{(r,j)}, u_r, (z_{(r,j),i})_i)</span> and <span class="math">\\mathbf{w}_{(r,j)} \\coloneqq (\\bar{f}_{(r,j)}, (\\bar{\\mathbf{s}}_{(r,j),i})_i, (\\bar{c}_{(r,j),i})_i)</span>. Since the leaves are accepting (and the relaxed relation is equivalent to the exact one when the relaxation factors are one), <span class="math">(\\dot{\\mathbf{s}}_{(h,j)}, \\mathbf{x}_{(h,j)}, \\mathbf{w}_{(h,j)}) \\in \\tilde{\\mathsf{R}}_{d_h, \\beta_h, 0}</span>. Thus, Lemma 5.10 (in the case <span class="math">t = 0</span>) implies that <span class="math">(\\dot{\\mathbf{s}}_{(h-1,j)}, \\mathbf{x}_{(h-1,j)}, \\mathbf{w}_{(h-1,j)}) \\in \\tilde{\\mathsf{R}}_{d_{h-1}, 2\\beta_h, 1}</span>. Now, we define the recurrence relations:</p>

    <div class="my-4 text-center"><span class="math-block">t_r := \\begin{cases} 1 &amp;amp; \\text{if } r = 1 \\\\ 2 t_{r-1} + 1 &amp;amp; \\text{otherwise} \\end{cases} \\quad \\text{and} \\quad \\gamma_r := \\begin{cases} 2\\beta &amp;amp; \\text{if } r = 1 \\\\ 2N\\beta_{s,t_{r-1}}\\gamma_{r-1} &amp;amp; \\text{otherwise} \\end{cases}</span></div>

    <p class="text-gray-300">Lemma 5.10 implies exactly that, if <span class="math">(\\dot{\\mathbf{s}}_{(r,j)},\\mathbf{x}_{(r,j)},\\mathbf{w}_{(r,j)}) \\in \\tilde{\\mathsf{R}}_{d_{r-i},\\gamma_r,t_r}</span>, then the extracted witness <span class="math">(\\dot{\\mathbf{s}}_{(r+1,j)},\\mathbf{x}_{(r+1,j)},\\mathbf{w}_{(r+1,j)}) \\in \\tilde{\\mathsf{R}}_{d_{k-r-1},\\gamma_{r+1},t_{r+1}}</span>. Unfolding the recurrence relations, we note that <span class="math">t_r = 2^r - 1</span> and</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\gamma_r &amp;amp;= 2^r N^{r-1} \\left(\\prod_{i=1}^{r-1} \\beta_{s,t_i}\\right) \\beta_h \\\\ &amp;amp;\\leq 2^r N^{r-1} \\left(\\prod_{i=1}^{r-1} 2\\beta_{\\mathcal{C}} (2\\beta_{\\mathcal{C}} N)^{2^i - 2}\\right) \\beta_h \\\\ &amp;amp;= 2^r N^{r-1} (2\\beta_{\\mathcal{C}})^{r-1} (2\\beta_{\\mathcal{C}} N)^{\\sum_{i=1}^{r-1} 2^i - 2} \\cdot \\beta_h \\\\ &amp;amp;= 2^j N^{r-1} (2\\beta_{\\mathcal{C}})^{r-1} (2\\beta_{\\mathcal{C}} N)^{2^r - 2r} \\cdot \\beta_h \\\\ &amp;amp;= 2^r (2\\beta_{\\mathcal{C}} N)^{2^r - r-1} \\cdot \\beta_h \\end{aligned}</span></div>

    <p class="text-gray-300">Taking this to its natural conclusion:</p>

    <div class="my-4 text-center"><span class="math-block">(\\dot{\\mathbf{s}}_{(0,1)}, \\mathbf{x}_{(0,1)}, \\mathbf{w}_{(0,1)}) \\in \\tilde{\\mathsf{R}}_{d,\\gamma_h,t_h},</span></div>

    <p class="text-gray-300">and setting <span class="math">\\gamma \\coloneqq \\gamma_h</span>, <span class="math">t \\coloneqq t_h</span> implies the result.</p>

    <p class="text-gray-300">Again, we can use Eval to construct a polynomial commitment scheme.</p>

    <p class="text-gray-300"><strong>Theorem 5.12.</strong> Let <span class="math">\\mathsf{PC} = (\\mathsf{Setup}, \\mathsf{Commit}, \\mathsf{Open}, \\mathsf{Eval}, \\mathsf{Verify})</span> where <span class="math">\\mathsf{Setup}, \\mathsf{Commit}, \\mathsf{Open}</span> are as in Figure 4 and <span class="math">\\mathsf{Eval}, \\mathsf{Verify}</span> are obtained by applying the Fiat-Shamir transform to <span class="math">\\mathsf{Eval}[d, k, h, \\mathcal{C}, \\beta]</span> when <span class="math">k^h = \\mathsf{poly}(d)</span>. Then, <span class="math">\\mathsf{PC}</span> is an polynomial commitment scheme with the efficiency properties and parameters shown in Table 4.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Completeness and relaxed binding follow from Lemmata 4.1 and 4.2. Perfect evaluation completeness follows from Lemma 5.1. Communication complexity and runtimes follow from Lemma 5.5. Knowledge soundness follows from Lemma 2.31 and Lemma 5.11, noting that when <span class="math">k^h = \\mathsf{poly}(d)</span> and thus the extractor runs in expected polynomial time.</p>

    <p class="text-gray-300">52</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Parameters</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Instantiation</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">m</td>

            <td class="px-3 py-2 border-b border-gray-700">≥ n(1 + q̅) + ω(log λ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">l</td>

            <td class="px-3 py-2 border-b border-gray-700">N/2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">δ</td>

            <td class="px-3 py-2 border-b border-gray-700">q1/O(1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">s</td>

            <td class="px-3 py-2 border-b border-gray-700">> 2Nqn/m-nq+2/N(m-nq̅)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">σ0</td>

            <td class="px-3 py-2 border-b border-gray-700">≥ δsNnq·ω(√2(d+1)n(m-nq̅)N log t'N)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">σ1</td>

            <td class="px-3 py-2 border-b border-gray-700">≥ δσ0N·ω(√m'n' log t'N)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">β</td>

            <td class="px-3 py-2 border-b border-gray-700">≥ σ1√m'N</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">Sk/βc</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">βC</td>

            <td class="px-3 py-2 border-b border-gray-700">< 1/2√l/Nq l/N</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">w</td>

            <td class="px-3 py-2 border-b border-gray-700">kNβC</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">βh</td>

            <td class="px-3 py-2 border-b border-gray-700">wh·β</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">γ</td>

            <td class="px-3 py-2 border-b border-gray-700">2h·(2βC N)2h-h-1·βh</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">βs</td>

            <td class="px-3 py-2 border-b border-gray-700">(2βC N)2h-1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Soundness</td>

            <td class="px-3 py-2 border-b border-gray-700">(Q+1)·hk</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Commitment size</td>

            <td class="px-3 py-2 border-b border-gray-700">(2βC+1)N</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Proof size</td>

            <td class="px-3 py-2 border-b border-gray-700">nN log q</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | h(kN log q) + d+1/kh(N log q + mN log βh)  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(md)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 5: Parameters for the polynomial commitment scheme obtained from Figure 4 and the Fiat-Shamir transform of  <span class="math">\\mathsf{Eval}[d,k,h,\\mathcal{C},\\beta]</span>  for proofs of evaluation. We let  <span class="math">Q</span>  be an upper bound on the number of queries an adversary can make to the random oracle.</p>

    <p class="text-gray-300">At this point, one might be tempted to instantiate the scheme in Theorem 5.12 with  <span class="math">h = O(\\log d)</span>  and  <span class="math">k = O(1)</span>  to obtain a protocol with logarithmic communication complexity as in Theorem 5.8 and small soundness error. This unfortunately does not succeed, as the extracted norm in this case grows  <span class="math">\\exp(\\mathrm{d})</span>  and thus  <span class="math">\\log q \\geq \\mathrm{poly}(d)</span> . The resulting protocol will communicate logarithmically many elements of  <span class="math">\\mathcal{R}_q</span> , but the overall communication complexity will thus be polynomial in  <span class="math">d</span> . Thus,  <span class="math">h</span>  must be at most  <span class="math">O(\\log \\log d)</span> . In fact, let  <span class="math">0 &amp;lt; \\epsilon &amp;lt; 1</span>  be a constant and set  <span class="math">h = 1 / \\epsilon = O(1)</span> ,  <span class="math">k = d^{\\epsilon}</span> . It is easy to see from Table 5 that then the communication complexity will be  <span class="math">O(d^{1 / \\epsilon})</span>  elements of  <span class="math">\\mathcal{R}_q</span>  and we can set  <span class="math">\\log q = \\mathrm{polylog}(d)</span>  to obtain overall sublinear communication complexity. Accordingly, the verifier time will also be sublinear. In fact, we can further improve on this. Set now  <span class="math">h \\approx \\log \\log d</span> , and  <span class="math">k \\approx d^{1 / \\log \\log d}</span> . It can be easily verified that in this case we obtain</p>

    <div class="my-4 text-center"><span class="math-block">\\log q = O \\left(\\frac {\\log^ {2} d}{\\log \\log d}\\right),</span></div>

    <p class="text-gray-300">and in terms of communication complexity:  <span class="math">O((\\log \\log d) \\cdot d^{1 / \\log \\log d})</span>  elements of  <span class="math">\\mathcal{R}_q</span>  or polylog(d)  <span class="math">\\cdot d^{1 / \\log \\log d}</span>  bits (similarly for the verifier complexity). As such, we can conclude that Theorem 5.12 gives rise to a quasi-polylogarithmic non-interactive polynomial commitment scheme from lattice assumptions.</p>

    <p class="text-gray-300">54</p>

    <h2 id="sec-62" class="text-2xl font-bold">5.4.1 Multiple Evaluations at a Single Point</h2>

    <p class="text-gray-300">We show a simple approach to amortise the cost of proving evaluations of multiple evaluations at a single point. More concretely, we have a list of (committed) polynomials <span class="math">f_{1},\\ldots ,f_{r}</span> and want to show that <span class="math">f_{i}(u) = z_{i}</span>. First we define the corresponding relation, namely:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf {R} _ {d, \\beta} ^ {r} := \\left\\{(\\mathbf {A}, \\mathbf {W}), ((\\mathbf {t} _ {j}) _ {j}, u, (z _ {j}) _ {j}), ((f _ {j}) _ {j}, (\\mathbf {s} _ {j, i}) _ {j, i}) \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\forall j \\in [ r ], \\\\ ((\\mathbf {A}, \\mathbf {W}), (\\mathbf {t} _ {j}, u, z _ {j}), (f _ {j}, (\\mathbf {s} _ {j, i}) _ {i})) \\in \\mathsf {R} _ {d, \\beta} \\end{array} \\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">The intuition of the protocol that we design is to take a random linear combinations of the polynomials <span class="math">f_{1},\\ldots ,f_{r}</span>, and prove that its evaluation at <span class="math">u</span> is equal to the linear combination of the claimed evaluations. The protocol that we describe in Figure 7 takes this idea and combines it with one round of Figure 5, which is useful for better concrete efficiency.</p>

    <p class="text-gray-300"><strong>Lemma 5.13 (Completeness).</strong> Let <span class="math">\\Pi \\coloneqq \\mathsf{multiEval}[d,r,k,\\mathcal{C},\\beta]</span> be the protocol in Figure 7. Then, <span class="math">\\Pi</span> is a <span class="math">\\Sigma</span>-protocol with perfect completeness for <span class="math">\\mathsf{R}_{d,\\beta}^{r}</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> It is easy to see that <span class="math">g(u^{k}) = \\sum_{\\iota ,t}\\alpha_{\\iota ,t}g_{\\iota ,t}(u^{k}) = \\sum \\alpha_{\\iota ,t}z_{\\iota ,t}</span>. Also, for <span class="math">i\\in [0,d^{\\prime}]</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf {A} \\mathbf {z} _ {i} + g _ {i} \\mathbf {e} _ {1} = \\sum_ {\\iota , t \\in [ r ] \\times [ k ]} \\alpha_ {\\iota , t} \\left(\\mathbf {A} \\mathbf {s} _ {\\iota , t, i} + g _ {\\iota , t, i} \\mathbf {e} _ {1}\\right) \\\\ = \\sum_ {\\iota , t \\in [ r ] \\times [ k ]} \\alpha_ {\\iota , t} \\left(\\mathbf {A} \\mathbf {s} _ {\\iota , k i + t - 1} + g _ {\\iota , k i + t - 1} \\mathbf {e} _ {1}\\right) \\\\ = \\sum_ {\\iota , t \\in [ r ] \\times [ k ]} \\alpha_ {\\iota , t} \\mathbf {W} ^ {- (k i + t - 1)} \\mathbf {t} _ {\\iota}. \\\\ \\end{array}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Finally, $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z}_i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_{\\iota ,t}\\alpha_{\\iota ,t}\\mathbf{s}_{\\iota ,t,i}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\mathrm{w}\\beta = \\beta^{\\prime}$ as desired.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As before, we define a relaxed opening relation (we use the definition of <span class="math">\\tilde{\\mathbf{R}}</span> from Equation (20)):</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde {\\mathsf {R}} _ {d, \\beta , t} ^ {r} := \\left\\{\\left( \\begin{array}{c} (\\mathbf {A}, \\mathbf {W}), \\\\ ((\\mathbf {t} _ {\\iota}) _ {\\iota}, u, (z _ {\\iota}) _ {\\iota}), \\\\ ((f _ {\\iota}) _ {\\iota}, (\\mathbf {s} _ {\\iota , i}) _ {\\iota , i}, (c _ {\\iota , i}) _ {\\iota , i}) \\end{array} \\right) \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\forall \\iota \\in [ r ], \\\\ ((\\mathbf {A}, \\mathbf {W}), (\\mathbf {t} _ {\\iota}, u, z _ {j}), (f _ {\\iota}, (\\mathbf {s} _ {\\iota , i}) _ {i}), (c _ {\\iota , i}) _ {i})) \\in \\tilde {\\mathsf {R}} _ {d, \\beta , t} \\end{array} \\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We now prove coordinate-wise special soundness for the set <span class="math">\\mathcal{C} \\coloneqq S_{\\beta_{\\mathcal{C}}}^{rk} \\subseteq \\mathcal{R}_{q}^{rk}</span>, where each element has <span class="math">rk</span> coordinates. Then, it is easy to show (e.g. using the composition results as in [BS23, Section 3]) that composing multiEval with Eval yields a knowledge sound protocol for this relaxed relation.</p>

    <p class="text-gray-300"><strong>Lemma 5.14 (Coordinate-Wise Special Soundness).</strong> Let <span class="math">\\Pi \\coloneqq \\mathsf{multiEval}[d,r,k,\\mathcal{C},\\beta]</span> be the protocol in Figure 7. Let <span class="math">\\mathbb{i} \\coloneqq (\\mathbf{A},\\mathbf{W})</span> , <span class="math">\\mathbb{x} \\coloneqq ((\\mathbf{t}_{\\iota})_{\\iota},u,(z_{\\iota})_{\\iota})</span>. There exists an algorithm that, given <span class="math">rk + 1</span> transcripts <span class="math">(\\mathrm{tr}_j)_{j\\in [0,rk]}</span> of the following form:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {t r} _ {j} := \\left( \\begin{array}{c} (z _ {\\iota , t}) _ {\\iota , t} \\\\ \\boldsymbol {\\alpha} _ {j} \\\\ (g _ {j}, (\\mathbf {z} _ {j, i}) _ {i \\in [ 0, d ]}) \\end{array} \\right) \\text{ with } (\\boldsymbol {\\alpha} _ {j}) _ {j} \\in \\mathsf {S S} (S _ {\\beta_ {\\mathcal {C}}}, r k),</span></div>

    <p class="text-gray-300">and relaxation factors <span class="math">(c_{j,i})_{j,i}</span>, outputs <span class="math">\\mathbb{W} := ((\\bar{f}_{\\iota})_{\\iota}, (\\bar{\\mathbf{s}}_{\\iota,i})_{\\iota,i}, (\\bar{c}_{\\iota,i})_{\\iota,i})</span>. Now, set <span class="math">\\mathbb{i}&#x27; := (\\mathbf{A}, \\mathbf{W}^k)</span>, <span class="math">\\mathbb{x}_j := (\\sum_{\\iota,t} \\alpha_{j,\\iota,t} \\mathbf{t}_{\\iota}, u^k, \\sum_{\\iota,t} \\alpha_{j,\\iota,t} z_{\\iota,t})</span>, <span class="math">\\mathbb{W}_j := (g_j, (\\mathbf{z}_{j,i})_i, (c_{j,i})_i)</span>. If for <span class="math">j \\in [0,r]</span>, <span class="math">(\\mathbb{i}&#x27;, \\mathbb{x}_j, \\mathbb{W}_j) \\in \\tilde{\\mathbb{R}}_{d,\\beta,t}</span>, and <span class="math">z_{\\iota} = \\sum_{t \\in [k]} u^{t-1} z_{\\iota,t}</span> for <span class="math">\\iota \\in [r]</span>, then <span class="math">(\\mathbb{i}, \\mathbb{x}, \\mathbb{W}) \\in \\tilde{\\mathbb{R}}_{d,\\gamma,t&#x27;}^r</span> where <span class="math">\\gamma := 2N\\beta_{s,t}\\beta</span>, <span class="math">t&#x27; := 2t + 1</span>.</p>

    <p class="text-gray-300"><span class="math">\\sum_{t\\in [k]}\\mathsf{X}^{t - 1}g_{\\iota ,t}(\\mathsf{X}^k)\\coloneqq f_\\iota (\\mathsf{X})</span>  for  <span class="math">\\iota \\in [r]</span></p>

    <p class="text-gray-300"><span class="math">z_{\\iota ,t}\\coloneqq g_{\\iota ,t}(u^k)</span>  for  <span class="math">(\\iota ,t)\\in [r]\\times [k]</span></p>

    <p class="text-gray-300">Verifier</p>

    <p class="text-gray-300"><span class="math">\\pmb {\\alpha} = (\\pmb {\\alpha}_1,\\dots ,\\pmb {\\alpha}_r)\\gets \\mathcal{C}\\coloneqq S_{\\beta_{\\mathcal{C}}}^{rk}</span></p>

    <p class="text-gray-300"><span class="math">g\\coloneqq \\sum_{(\\iota ,t)\\in [r]\\times [k]}\\alpha_{\\iota ,t}g_{\\iota ,t}</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{z}_i\\coloneqq \\sum_{(\\iota ,t)\\in [r]\\times [k]}\\alpha_{\\iota ,t}\\mathbf{s}_{\\iota ,t,i}</span>  for  <span class="math">i\\in [0,d^{\\prime}]</span></p>

    <p class="text-gray-300"><span class="math">\\alpha = (\\alpha_{1},\\dots ,\\alpha_{r})\\gets \\mathcal{C}\\coloneqq S_{\\beta_{\\mathcal{C}}}^{rk}</span></p>

    <p class="text-gray-300"><span class="math">\\beta^{\\prime}\\coloneqq \\mathrm{w}\\beta</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{t}^{\\prime}\\coloneqq \\left(\\sum_{(\\iota ,t)\\in [r]\\times [k]}\\alpha_{\\iota ,t}\\mathbf{W}^{-(t - 1)}\\cdot \\mathbf{t}_{\\iota}\\right)</span></p>

    <p class="text-gray-300"><span class="math">\\mathrm{i}&#x27;\\coloneqq (\\mathbf{A},\\mathbf{W}^k)</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{x}^{\\prime}\\coloneqq \\left(\\mathbf{t}^{\\prime},u^{k},\\sum_{(\\iota ,t)\\in [r]\\times [k]}\\alpha_{\\iota ,t}z_{\\iota ,t}\\right)</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{w}^{\\prime}\\coloneqq (g,(\\mathbf{z}_{\\iota})_{i\\in [0,d^{\\prime}]})</span></p>

    <p class="text-gray-300">Check:</p>

    <p class="text-gray-300"><span class="math">z_{\\iota} = \\sum_{t\\in [k]}u^{t - 1}z_{\\iota ,t}</span>  for  <span class="math">\\iota \\in [r]</span></p>

    <p class="text-gray-300"><span class="math">(\\mathbf{i}^{\\prime},\\mathbf{x}^{\\prime},\\mathbf{w}^{\\prime})\\in \\mathsf{R}_{d^{\\prime},\\beta^{\\prime}}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 7: The protocol multiEval  <span class="math">[d, r, k, \\mathcal{C}, \\beta]</span>  for proving evaluations of  <span class="math">r</span>  polynomials at a single point. In the above  $\\mathbf{w} := \\max_{\\alpha \\in \\mathcal{C}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_1<span class="math"> . As before, we define  </span>d' := (d + 1)/k - 1<span class="math">  and  </span>\\mathbf{s}_{\\iota, t, i} := \\mathbf{s}_{\\iota, ki + t - 1}<span class="math">  for  </span>\\iota \\in [r]$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. Again, assume without loss of generality that <span class="math">\\alpha_0 \\equiv_j \\alpha_j</span> for <span class="math">j \\in [rk]</span>. Now, reindex <span class="math">\\alpha_1, \\ldots, \\alpha_{rk}</span> into a <span class="math">r \\times k</span> matrix <span class="math">\\alpha_{1,1}, \\ldots, \\alpha_{r,k}</span>. We write <span class="math">\\alpha_0 = (\\alpha_{1,1}^<em>, \\ldots, \\alpha_{r,k}^</em>)</span> and thus assume that <span class="math">\\alpha_{v,w} = (\\alpha_{1,1}^<em>, \\ldots, \\alpha_{v,w}&#x27;, \\ldots, \\alpha_{r,k}^</em>)</span> with <span class="math">\\alpha_{v,w}&#x27; \\neq \\alpha_{v,w}^*</span>. We also reindex <span class="math">(g_j)_j, (\\mathbf{z}_{j,i})</span> accordingly so that <span class="math">g_{v,w}</span> corresponds the <span class="math">\\alpha_{v,w}</span> challenge (note that we skip the 0-th challenge <span class="math">\\alpha_0</span>).</p>

    <p class="text-gray-300">With these conventions, we let the extractor be the following.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{E}(\\mathrm{tr})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">\\iota \\in [r], t \\in [k]</span>:</li>

    </ol>

    <p class="text-gray-300">(a) Let <span class="math">\\bar{f}_{\\iota,t} \\coloneqq \\frac{g_0 - g_{\\iota,t}}{\\alpha_{\\iota,t}^* - \\alpha_{\\iota,t}&#x27;}</span>.</p>

    <p class="text-gray-300">(b) Let <span class="math">\\bar{\\mathbf{s}}_{\\iota,ki + t - 1} \\coloneqq \\frac{\\mathbf{z}_{0,i} - \\mathbf{z}_{\\iota,t,i}}{\\alpha_{\\iota,t}^* - \\alpha_{\\iota,t}&#x27;}</span> for <span class="math">i \\in [0, d&#x27;]</span>.</p>

    <p class="text-gray-300">(c) Let <span class="math">\\bar{c}_{l,ki + t - 1} \\coloneqq (\\alpha_{\\iota,t}^* - \\alpha_{\\iota,t}&#x27;) c_{0,i} c_{\\iota,t,i}</span> for <span class="math">i \\in [0, d&#x27;]</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">\\bar{f}_{\\iota} \\coloneqq \\sum_{t \\in [k]} \\mathsf{X}^{t-1} f_{\\iota,t}</span> for <span class="math">\\iota \\in [r]</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Return <span class="math">(\\bar{f}_{\\iota})_{\\iota}, ((\\bar{\\mathbf{s}}_{\\iota,i})_{i})_{\\iota}, ((\\bar{c}_{\\iota,i})_{i})_{\\iota}</span>.</li>

    </ol>

    <p class="text-gray-300">First note that by assumption, <span class="math">g_0(u^k) = \\sum_{\\iota,t} \\alpha_{\\iota,t}^<em> z_{\\iota,t}</span> and <span class="math">g_{v,w}(u^k) = \\alpha_{v,w}&#x27; z_{v,w} + \\sum_{(\\iota,t) \\neq (v,w)} \\alpha_{\\iota,t}^</em> z_{\\iota,t}</span>. Thus, <span class="math">\\bar{f}_{v,w}(u^k) = \\frac{g_0 - g_{v,w}}{\\alpha_{v,w}^* - \\alpha_{v,w}&#x27;}(u^k) = z_{v,w}</span>. Thus, for <span class="math">\\iota \\in [r]</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\bar {f} _ {\\iota} (u) = \\sum_ {t \\in [ k ]} u ^ {t - 1} \\bar {f} _ {\\iota , t} (u ^ {k}) = \\sum_ {t \\in [ k ]} u ^ {t - 1} \\frac {g _ {0} - g _ {\\iota , t}}{\\alpha_ {\\iota , t} - \\alpha_ {\\iota , t} ^ {\\prime}} (u ^ {k}) = \\sum_ {t \\in [ k ]} u ^ {t - 1} z _ {\\iota , t} = z _ {\\iota}.</span></div>

    <p class="text-gray-300">Now, also by assumption:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A} \\mathbf {z} _ {0, i} + g _ {0, i} \\mathbf {e} _ {1} = \\mathbf {W} ^ {- i} \\left(\\sum_ {(\\iota , t)} \\alpha_ {\\iota , t} ^ {*} \\mathbf {t} _ {\\iota}\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A} \\mathbf {z} _ {v, w, i} + g _ {v, w, i} \\mathbf {e} _ {1} = \\mathbf {W} ^ {- i} \\left(\\alpha_ {v, w} ^ {\\prime} \\mathbf {t} _ {v} + \\sum_ {(\\iota , t) \\neq (v, w)} \\alpha_ {\\iota , t} ^ {*} \\mathbf {t} _ {\\iota}\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Downarrow</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A} \\left(\\frac {\\mathbf {z} _ {0 , i} - \\mathbf {z} _ {v , w , i}}{\\alpha_ {v , w} ^ {*} - \\alpha_ {v , w} ^ {\\prime}}\\right) + \\left(\\frac {g _ {0 , i} - g _ {v , w , i}}{\\alpha_ {v , w} ^ {*} - \\alpha_ {v , w} ^ {\\prime}}\\right) \\cdot \\mathbf {e} _ {1} = \\mathbf {W} ^ {- (k i + w - 1)} \\mathbf {t} _ {v}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Downarrow</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A} \\bar {\\mathbf {s}} _ {v, k i + w - 1} + \\bar {f} _ {v, k i + w - 1} \\mathbf {e} _ {1} = \\mathbf {W} ^ {- (k i + w - 1)} \\mathbf {t} _ {v}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Finally, note that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{c}_{\\iota ,i}\\bar{\\mathbf{s}}_{\\iota ,i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2N\\beta_{s,t}\\beta$ by exactly the same reasoning as in Lemma 5.10.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-65" class="text-2xl font-bold">5.4.2 Multiple Evaluations at Distinct Points</h2>

    <p class="text-gray-300">Next, we consider the dual problem, namely amortising proving many statements of the form <span class="math">f_{\\iota}(u_{\\iota}) = z_{\\iota}</span> for <span class="math">\\iota \\in [r]</span> where <span class="math">u_{1}, \\ldots, u_{r}</span> can be potentially distinct. Looking at Lemma 5.5, a large part of the communication complexity is represented by the last round, where the prover has to send openings <span class="math">\\mathbf{s}_0, \\ldots, \\mathbf{s}_{d_h}</span>. We amortise this by taking a random linear combination of these openings. As before, for concrete efficiency reasons, we integrate this within a round of compression.</p>

    <p class="text-gray-300">The relation that we consider is the following:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf {R} _ {d, \\beta} ^ {r} := \\left\\{\\left. \\left( \\begin{array}{c} (\\mathbf {A}, \\mathbf {W}), \\\\ (\\mathbf {t} _ {\\iota}, u _ {\\iota}, z _ {\\iota}) _ {\\iota} \\\\ (f _ {\\iota}, \\mathbf {s} _ {\\iota , i}) _ {\\iota , i} \\end{array} \\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\forall \\iota \\in [ r ] \\\\ ((\\mathbf {A}, \\mathbf {W}), (\\mathbf {t} _ {\\iota}, u _ {\\iota}, z _ {\\iota}), (f _ {\\iota}, \\mathbf {s} _ {\\iota , i}) _ {\\iota , i}) \\in \\mathsf {R} _ {d, \\beta} \\end{array} \\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><span class="math">\\sum_{t\\in [k]}\\mathsf{X}^{t - 1}h_{\\iota ,t}(\\mathsf{X}^k)\\coloneqq f_\\iota (\\mathsf{X})</span>  for  <span class="math">l\\in [r]</span></p>

    <p class="text-gray-300"><span class="math">z_{\\iota ,t}\\coloneqq h_{\\iota ,t}(u_{\\iota}^{k})</span></p>

    <p class="text-gray-300"><span class="math">\\frac{(z_{\\iota,t})_{\\iota,t}}{\\alpha}</span></p>

    <p class="text-gray-300"><span class="math">\\alpha \\gets \\mathcal{C} \\coloneqq S_{\\beta_{\\mathcal{C}}}^{rk}</span></p>

    <p class="text-gray-300"><span class="math">g_{\\iota}\\coloneqq \\sum_{t\\in [k]}\\alpha_{\\iota ,t}h_{\\iota ,t}</span>  for  <span class="math">\\iota \\in [r]</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{z}_i\\coloneqq \\sum_{\\iota ,t\\in [r]\\times [k]}\\alpha_{\\iota ,t}\\mathbf{s}_{\\iota ,t,i}</span>  for  <span class="math">i\\in [d^{\\prime}]</span></p>

    <p class="text-gray-300"><span class="math">(g_{\\iota})_{\\iota ,}(\\mathbf{z}_{\\iota})_{\\iota}</span></p>

    <p class="text-gray-300">Check:</p>

    <p class="text-gray-300"><span class="math">z_{\\iota} = \\sum_{t\\in [k]}u_{\\iota}^{t - 1}z_{\\iota ,t}</span>  for  <span class="math">\\iota \\in [r]</span></p>

    <p class="text-gray-300"><span class="math">g_{\\iota}(u_{\\iota}^{k}) = \\sum_{\\ell \\in [k]}\\alpha_{\\iota ,t}z_{\\iota ,t}</span>  for  <span class="math">\\iota \\in [r]</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{A}\\mathbf{z}_i + \\left(\\sum_{\\iota \\in [r]}g_{\\iota ,i}\\right)\\mathbf{e}_1 = \\mathbf{W}^{-ki}\\left(\\sum_{\\iota ,t}\\alpha_{\\iota ,t}\\mathbf{t}_i\\right)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z}_i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\mathrm{w}\\beta<span class="math">  for  </span>i\\in [0,d^{\\prime}]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 8: The protocol evalMulti  <span class="math">[d, r, k, \\mathcal{C}, \\beta]</span>  for proving evaluations of multiple polynomials at multiple points. In the above  $\\mathrm{w} := \\max_{\\alpha \\in \\mathcal{C}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_1<span class="math">  and  </span>d' := (d + 1)/k - 1$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The protocol is then described in Figure 8. Now, we show evalMulti has perfect completeness..</p>

    <p class="text-gray-300">Lemma 5.15 (Completeness). Let  <span class="math">\\Pi \\coloneqq \\operatorname{evalMulti}[d, r, k, \\mathcal{C}, \\beta]</span> . Then  <span class="math">\\Pi</span>  is a  <span class="math">\\Sigma</span> -protocol with perfect completeness for  <span class="math">\\mathsf{R}_{d,\\beta}^r</span> .</p>

    <p class="text-gray-300">Proof. For the first verifier check,</p>

    <div class="my-4 text-center"><span class="math-block">z _ {\\iota} = f _ {\\iota} (u _ {\\iota}) = \\sum_ {t \\in [ k ]} u _ {\\iota} ^ {t - 1} h _ {\\iota , t} (u _ {\\iota} ^ {k}) = \\sum_ {t \\in [ k ]} u _ {\\iota} ^ {t - 1} z _ {\\iota , t}.</span></div>

    <p class="text-gray-300">Next, we check that  <span class="math">g_{\\iota}</span>  evaluates to the correct value.</p>

    <div class="my-4 text-center"><span class="math-block">g _ {\\iota} (u _ {\\iota} ^ {k}) = \\sum_ {t \\in [ k ]} \\alpha_ {\\iota , t} h _ {\\iota , t} (u _ {\\iota} ^ {k}) = \\sum_ {t \\in [ k ]} \\alpha_ {\\iota , t} z _ {\\iota , t}.</span></div>

    <p class="text-gray-300">Checking validity of the openings is similarly straightforward:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A} \\mathbf {z} _ {i} + \\left(\\sum_ {\\iota} g _ {\\iota , i}\\right) \\mathbf {e} _ {1} = \\mathbf {A} \\left(\\sum_ {\\iota , t} \\alpha_ {\\iota , t} \\mathbf {s} _ {\\iota , t, i}\\right) + \\left(\\sum_ {\\iota , t} \\alpha_ {\\iota , t} h _ {\\iota , t, i}\\right) \\mathbf {e} _ {1}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} = \\sum_{\\iota, t} \\alpha_{\\iota, t} \\left(\\mathbf{A} \\mathbf{s}_{\\iota, t, i} + h_{\\iota, t, i} \\mathbf{e}_1\\right) \\\\ = \\sum_{\\iota, t} \\alpha_{\\iota, t} \\left(\\mathbf{A} \\mathbf{s}_{\\iota, k i + t - 1} + f_{\\iota, k i + t - 1} \\mathbf{e}_1\\right) \\\\ = \\sum_{\\iota, t} \\alpha_{\\iota, t} \\left(\\mathbf{W}^{-(k i + t - 1)} \\mathbf{t}_{\\iota}\\right) \\\\ = \\left(\\mathbf{W}^k\\right)^{-i} \\cdot \\left(\\sum_{\\iota, t} \\alpha_{\\iota, t} \\mathbf{W}^{-(t - 1)} \\mathbf{t}_{\\iota}\\right). \\end{array}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Finally, $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z}_i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_{\\iota ,t}\\alpha_{\\iota ,t}\\mathbf{s}_{\\iota ,t,i}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\mathrm{w}\\beta<span class="math">. </span>\\square$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For knowledge soundness, we again define a relaxed opening relation, namely:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{\\mathrm{R}}_{d, \\beta}^{r} := \\left\\{ \\left( \\begin{array}{c} (\\mathbf{A}, \\mathbf{W}), \\\\ (\\mathbf{t}_{\\iota}, u_{\\iota}, z_{\\iota})_{\\iota} \\\\ (f_{\\iota}, \\mathbf{s}_{\\iota, i}, c_{\\iota, i})_{\\iota, i} \\end{array} \\right) \\Bigg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\forall \\iota \\in [r] \\\\ ((\\mathbf{A}, \\mathbf{W}), (\\mathbf{t}_{\\iota}, u_{\\iota}, z_{\\iota}), (f_{\\iota}, \\mathbf{s}_{\\iota, i}, c_{\\iota, i})_{\\iota, i}) \\in \\tilde{\\mathrm{R}}_{d, \\beta, 1} \\end{array} \\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><strong>Lemma 5.16</strong> (Coordinate-Wise Special Soundness). Let <span class="math">\\Pi := \\text{multiEval}[d, r, k, \\mathcal{C}, \\beta]</span> be the protocol in Figure 7. Then, <span class="math">\\Pi</span> is a <span class="math">rk</span>-coordinate-wise knowledge sound proof system for <span class="math">\\tilde{\\mathbb{R}}_{d,2\\beta}^{r}</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> For <span class="math">j \\in [0, rk]</span>, consider transcripts of the following form:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{tr}_{j} := \\left( \\begin{array}{c} (z_{\\iota, t})_{\\iota, t} \\\\ \\boldsymbol{\\alpha}_{j} \\\\ ((g_{j, \\iota})_{\\iota}, (\\mathbf{z}_{j, i})_{\\iota}) \\end{array} \\right) \\text{ with } (\\boldsymbol{\\alpha}_{j})_{j} \\in \\mathsf{SS}(S_{\\beta_{\\mathcal{C}}}, rk),</span></div>

    <p class="text-gray-300">and again assume, without loss of generality, that the transcripts are arranged so that, for <span class="math">j \\in [r]</span>, <span class="math">\\alpha_0 \\equiv_j \\alpha_j</span>. Reindex and arrange the challenges as in the proof of Lemma 5.14.</p>

    <p class="text-gray-300">Consider the following extractor:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{E}(\\mathrm{tr}_0,\\dots ,\\mathrm{tr}_{rk})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">\\iota \\in [r], t \\in [k]</span>:</li>

    </ol>

    <p class="text-gray-300">(a) Set <span class="math">\\bar{f}_{\\iota,t} := \\frac{g_0 - g_{\\iota,t}}{\\alpha_{\\iota,t}^<em> - \\alpha_{\\iota,t}^</em>}</span>.</p>

    <p class="text-gray-300">(b) Set <span class="math">\\bar{\\mathbf{s}}_{\\iota, k i + t - 1} := \\frac{\\mathbf{z}_{0, i} - \\mathbf{z}_{\\iota, t, i}}{\\alpha_{\\iota, t}^<em> - \\alpha_{\\iota, t}^</em>}</span> for <span class="math">i \\in [0, d&#x27;]</span>.</p>

    <p class="text-gray-300">(c) Set <span class="math">\\bar{c}_{\\iota, k i + t - 1} := \\alpha_{\\iota, t}^* - \\alpha_{\\iota, t}&#x27;</span> for <span class="math">i \\in [0, d&#x27;]</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">\\bar{f}_{\\iota} := \\sum_{t \\in [k]} \\mathsf{X}^{t-1} \\bar{f}_{\\iota,t}</span> for <span class="math">\\iota \\in [r]</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Return <span class="math">(\\bar{f}_{\\iota})_{\\iota}, (\\bar{\\mathbf{s}}_{\\iota,i})_{\\iota,i}, (\\bar{c}_{\\iota,i})_{\\iota,i}</span>.</li>

    </ol>

    <p class="text-gray-300">Since the transcripts are accepting, we have that <span class="math">z_{\\iota} = \\sum_{t\\in [k]}u_{\\iota}^{t - 1}z_{\\iota ,t}</span> for <span class="math">\\iota \\in [r]</span>. Also, <span class="math">g_{0,\\iota}(u_{\\iota}^{k}) = \\sum_{t\\in [k]}\\alpha_{\\iota ,t}^{<em>}z_{\\iota ,t}</span> and <span class="math">g_{v,w,\\iota}(u_{\\iota}^{k}) = \\alpha_{v,w}^{\\prime}z_{v,w} + \\sum_{t\\neq w}\\alpha_{\\iota ,t}^{</em>}z_{\\iota ,t}</span>. Thus, <span class="math">\\frac{g_{0,\\iota} - g_{v,w}}{\\alpha_{v,w}^{\\ast} - \\alpha_{v,w}^{\\prime}}(u_{\\iota}^{k}) = z_{v,w}</span>. Now,</p>

    <div class="my-4 text-center"><span class="math-block">\\bar{f}_{\\iota}(u_{\\iota}) = \\sum_{t \\in [k]} u_{\\iota}^{t - 1} \\bar{f}_{\\iota,t}(u_{\\iota}^{k}) = \\sum_{t \\in [k]} u_{\\iota}^{t - 1} \\frac{g_{0} - g_{\\iota,t}}{\\alpha_{\\iota,t}^{*} - \\alpha_{\\iota,t}^{\\prime}}(u_{\\iota}^{k}) = \\sum_{t \\in [k]} u_{\\iota}^{t - 1} z_{\\iota,t} = z_{\\iota}.</span></div>

    <p class="text-gray-300">We also have that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{A} \\mathbf{z}_{0, i} + \\left(\\sum_{\\iota} g_{0, \\iota, i}\\right) \\mathbf{e}_{1} = \\mathbf{W}^{-k i} \\left(\\sum_{\\iota, t} \\alpha_{\\iota, t}^{*} \\mathbf{W}^{-(t - 1)} \\mathbf{t}_{\\iota}\\right)</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Parameters</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Instantiation</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">m</td>

            <td class="px-3 py-2 border-b border-gray-700">≥ n(1 + q̂) + ω(log λ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">δ</td>

            <td class="px-3 py-2 border-b border-gray-700">q1/O(1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">s</td>

            <td class="px-3 py-2 border-b border-gray-700">> 2Nqn/m-nq̂ + 2/N(m-nq̂)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">σ0</td>

            <td class="px-3 py-2 border-b border-gray-700">≥ δsNnq̂ · ω(√2(d+1)n(m-nq̂)N log t'N)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">σ1</td>

            <td class="px-3 py-2 border-b border-gray-700">≥ δσ0N · ω(√m'n' log t'N)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">β</td>

            <td class="px-3 py-2 border-b border-gray-700">≥ σ1√m'N</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">βC</td>

            <td class="px-3 py-2 border-b border-gray-700">< 1/2√l/Nq'N</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ws</td>

            <td class="px-3 py-2 border-b border-gray-700">sNβC</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">βh</td>

            <td class="px-3 py-2 border-b border-gray-700">(maxi wr,k) wk hrk · β</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">γ</td>

            <td class="px-3 py-2 border-b border-gray-700">2h+2 · (2βCN)2h+2-h-3 · βh</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">βs</td>

            <td class="px-3 py-2 border-b border-gray-700">(2βCN)2h+2-1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Soundness</td>

            <td class="px-3 py-2 border-b border-gray-700">(Q+1) · ((maxi r_i+h+r)k/(2βC+1)N)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Commitment size</td>

            <td class="px-3 py-2 border-b border-gray-700">nN log q · ∑i r_i</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Proof size</td>

            <td class="px-3 py-2 border-b border-gray-700">(∑i r_i kN log q) + r(h+1) · (kN log q) + d+1/k^h+2 (rN log q + mN log βh)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 6: Parameters and complexity of the multi-evaluation protocol.</p>

    <p class="text-gray-300">|  Azv,w,i + (∑i gv,w,i,i) e1 = W-ki (α′v,wW-(w-1)t v + ∑i,t≠(v,w) α* i,tW-(t-1)t i)  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  ↓  |</p>

    <p class="text-gray-300">|  A (z0,i - zv,w,i/α* v,w - α′ v,w) + f v,w,i e1 = W-ki (W-(w-1)t v)  |</p>

    <p class="text-gray-300">|  ↓  |</p>

    <p class="text-gray-300">|  A s v,ki+w-1 + f v,ki+w-1 e1 = W-(ki+w-1)t v .  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Finally,  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{c}_{\\iota ,ki + t - 1}\\bar{\\mathbf{s}}_{\\iota ,ki + t - 1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z}_{0,i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z}_{\\iota ,t,i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2\\beta$  as desired.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We can combine these two newly presented protocols with Eval to obtain a protocol for multiple evaluations. Let  <span class="math">u_{1}, \\ldots, u_{r} \\in \\mathcal{R}_{q}</span> , and suppose we want to show that  <span class="math">f_{\\iota, m}(u_{\\iota}) = z_{\\iota, m}</span>  for  <span class="math">\\iota \\in [r]</span> ,  <span class="math">m \\in [r_{\\iota}]</span>  for committed polynomials  <span class="math">(f_{\\iota, m})_{\\iota, m}</span> . Write  $\\mathrm{w}_{s} := \\max_{\\alpha \\gets S_{\\beta_{C}}^{s}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{1}<span class="math"> . The combined protocol runs (in parallel) multiEval  </span>[d, r_{\\iota}, k, S_{\\beta_{C}}^{r, \\cdot k}, \\beta]<span class="math">  with input  </span>(f_{\\iota, m})_{m \\in [r_{\\iota}]}<span class="math">  for  </span>\\iota \\in [r]<span class="math"> . This outputs  </span>r<span class="math">  claims, which we handle by running Eval  </span>[d / k, k, S_{\\beta_{C}}^{k}, \\mathrm{w}_{r, k} \\cdot \\beta]<span class="math"> </span>r<span class="math"> -times into parallel. Finally, we run a single instance of multiEval  </span>[d / k^{h + 1}, r, k, S_{\\beta_{C}}^{r k}, (\\max_{\\iota} \\mathrm{w}_{r, k}) \\cdot \\mathrm{w}_{k}^{h} \\beta]$ . The final complexity of this protocol is summarised in Table 6.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We provide a linear-sized  <span class="math">\\Sigma</span> -protocol for the relation  <span class="math">\\mathsf{R}_{d,\\beta}</span>  (c.f. Equation (15)) which satisfies honest-verifier zero-knowledge. Combined with the recursive methodology described above, we can achieve zero-knowledge succinct proofs of polynomial evaluation. The strategy can identically be applied when proving knowledge of multiple polynomials at the same query point, which brings resemblance to [BBCPGL18].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Recall that we want to prove knowledge of the polynomial <span class="math">f \\in \\mathcal{R}_q[\\mathsf{X}]</span> of degree at most <span class="math">d</span>, and the openings <span class="math">(\\mathbf{s}_i)_{i \\in [0,d]}</span> such that <span class="math">f(u) = z</span> and <span class="math">\\mathbf{A}\\mathbf{s}_i + f_i\\mathbf{e}_1 = \\mathbf{W}^{-i}\\mathbf{t}</span> and $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}_i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta<span class="math"> for </span>i = 0,1,\\ldots,d<span class="math">. In addition to the public matrices </span>(\\mathbf{A} \\in \\mathcal{R}_q^{n \\times m}, \\mathbf{W} \\in \\mathcal{R}_q^{n \\times n})<span class="math">, this time the index </span>\\mathbf{i}<span class="math"> contains a short basis </span>\\mathbf{T}<span class="math"> such that </span>\\mathbf{B}\\mathbf{T} = \\mathbf{G}_{n(d+1)}$ where</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {B} := \\left[ \\begin{array}{c c c c} \\mathbf {A} &amp; &amp; &amp; - \\mathbf {G} \\\\ &amp; \\ddots &amp; &amp; \\vdots \\\\ &amp; &amp; \\mathbf {W} ^ {d} \\mathbf {A} &amp; - \\mathbf {G} \\end{array} \\right] \\quad \\text {and} \\quad \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {T} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta_ {T}. \\tag {21}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">This is the case when generating the PowerBASIS commitment in Section 4 since the public parameters are indeed of the form <span class="math">\\mathbf{crs} \\coloneqq (\\mathbf{A}, \\mathbf{W}, \\mathbf{T})</span>.</p>

    <p class="text-gray-300">We present the protocol in Figure 10. The strategy follows the Fiat-Shamir with Aborts paradigm [Lyu09] using the generalised rejection sampling from [BTT22]. That is, the prover starts by sampling uniformly random <span class="math">\\mathbf{g} \\coloneqq (g_0, \\ldots, g_d) \\gets \\mathcal{R}_q^{d+1}</span>, which corresponds to coefficients of a uniformly random polynomial <span class="math">g \\in \\mathcal{R}_q[\\mathsf{X}]</span> of degree at most <span class="math">d</span>. Then, the prover runs the PowerBASIS commitment algorithm for <span class="math">\\mathbf{g}</span> (c.f. Figure 4). Namely, it samples</p>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\begin{array}{c} \\mathbf {y} _ {0} \\\\ \\vdots \\\\ \\mathbf {y} _ {d} \\\\ \\hat {\\mathbf {t}} _ {y} \\end{array} \\right] \\gets \\text {SamplePre} (\\mathbf {B}, \\mathbf {u}, \\mathbf {T}, \\sigma), \\quad \\text {where} \\mathbf {u} := \\left[ \\begin{array}{c} - g _ {0} \\mathbf {W} ^ {0} \\mathbf {e} _ {1} \\\\ \\vdots \\\\ - g _ {d} \\mathbf {W} ^ {d} \\mathbf {e} _ {1} \\end{array} \\right],</span></div>

    <p class="text-gray-300">and sets <span class="math">\\mathbf{t}_y \\coloneqq \\mathbf{G}\\hat{\\mathbf{t}}_y</span>. The first message sent by the prover is <span class="math">(\\mathbf{t}_y, v)</span> where <span class="math">v \\coloneqq \\sum_{i=0}^{d} g_i u^i</span> is the evaluation of <span class="math">g</span> at the point <span class="math">u</span>. Then, the verifier picks a challenge <span class="math">\\alpha</span> from the challenge space <span class="math">\\mathcal{C} \\coloneqq S_{\\beta_{\\mathcal{C}}}</span> of short polynomials of infinity norm at most <span class="math">\\beta_{\\mathcal{C}}</span>.</p>

    <p class="text-gray-300">Next, given a challenge <span class="math">\\alpha \\gets \\mathcal{C}</span> from the verifier, the prover computes</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {z} _ {i} := \\mathbf {y} _ {i} + \\alpha \\mathbf {s} _ {i} \\quad \\text {and} \\quad h _ {i} := g _ {i} + \\alpha f _ {i} \\quad \\text {for} \\ i = 0, 1, \\ldots , d,</span></div>

    <p class="text-gray-300">and outputs <span class="math">(\\mathbf{z}_i, \\mathbf{h}_i)</span> after performing the rejection sampling procedure. Note that the distribution of <span class="math">\\mathbf{z}_i</span> can be written alternatively as:</p>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\begin{array}{c} \\mathbf {z} _ {0} \\\\ \\vdots \\\\ \\mathbf {z} _ {d} \\\\ \\hat {\\mathbf {t}} _ {z} \\end{array} \\right] = \\left[ \\begin{array}{c} \\mathbf {y} _ {0} \\\\ \\vdots \\\\ \\mathbf {y} _ {d} \\\\ \\hat {\\mathbf {t}} _ {y} \\end{array} \\right] + \\alpha \\left[ \\begin{array}{c} \\mathbf {s} _ {0} \\\\ \\vdots \\\\ \\mathbf {s} _ {d} \\\\ \\hat {\\mathbf {t}} \\end{array} \\right] \\tag {22}</span></div>

    <p class="text-gray-300">where</p>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\begin{array}{c} \\mathbf {y} _ {0} \\\\ \\vdots \\\\ \\mathbf {y} _ {d} \\\\ \\hat {\\mathbf {t}} _ {y} \\end{array} \\right] \\gets \\text {SamplePre} \\left(\\left[ \\begin{array}{c c c c} \\mathbf {A} &amp;amp; &amp;amp; &amp;amp; - \\mathbf {G} \\\\ &amp;amp; \\ddots &amp;amp; &amp;amp; \\vdots \\\\ &amp;amp; &amp;amp; \\mathbf {W} ^ {d} \\mathbf {A} &amp;amp; - \\mathbf {G} \\end{array} \\right], \\left[ \\begin{array}{c} - g _ {0} \\mathbf {W} ^ {0} \\mathbf {e} _ {1} \\\\ \\vdots \\\\ - g _ {d} \\mathbf {W} ^ {d} \\mathbf {e} _ {1} \\end{array} \\right], \\mathbf {T}, \\sigma\\right) \\tag {23}</span></div>

    <p class="text-gray-300">and <span class="math">\\hat{\\mathbf{t}} = \\mathbf{G}^{-1}(\\mathbf{t})</span>. Hence, this vector comes from a shifted discrete Gaussian distribution (over a coset of <span class="math">\\Lambda^{\\perp}(\\mathbf{B})</span>), where the norm of the shifted vector can be bounded by:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha \\left[ \\begin{array}{l} \\mathbf {s} _ {0} \\\\ \\vdots \\\\ \\mathbf {s} _ {d} \\\\ \\hat {\\mathbf {t}} \\end{array} \\right] \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta_ {\\mathcal {C}} N \\cdot \\sqrt {(d + 1) \\beta^ {2} + n \\tilde {q} N}. \\tag {24}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">This interpretation will be useful when analysing the rejection sampling algorithm.</p>

    <p class="text-gray-300">Finally, the verifier checks whether</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A} \\mathbf {z} _ {i} + \\mathbf {h} _ {i} \\mathbf {e} _ {1} = \\mathbf {W} ^ {- i} (\\mathbf {t} _ {y} + \\alpha \\mathbf {t}) \\quad \\text {for} \\ i = 0, 1, \\dots , d</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z _ {i} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta_ {z} \\quad \\text {for} \\ i = 0, 1, \\dots , d</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {i = 0} ^ {d} h _ {i} u ^ {i} = v + \\alpha z.</span></div>

    <p class="text-gray-300">In the following, we give a brief reasoning about completeness, special soundness and honest-verifier zero-knowledge.</p>

    <p class="text-gray-300"><strong>Completeness.</strong> By careful inspection, we can deduce from the third verification check:</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {i = 0} ^ {d} h _ {i} u ^ {i} = \\sum_ {i = 0} ^ {d} g _ {i} u ^ {i} + \\alpha \\sum_ {i = 0} ^ {d} f _ {i} u ^ {i} = v + \\alpha z,</span></div>

    <p class="text-gray-300">and from the second verification check:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A} \\mathbf {z} _ {i} + \\mathbf {h} _ {i} \\mathbf {e} _ {1} = \\mathbf {A} \\mathbf {y} _ {i} + \\mathbf {g} _ {i} \\mathbf {e} _ {1} + \\alpha (\\mathbf {A} \\mathbf {s} _ {i} + \\mathbf {f} _ {i} \\mathbf {e} _ {1}) = \\mathbf {W} ^ {- i} \\mathbf {t} _ {y} + \\alpha \\mathbf {W} ^ {- i} \\mathbf {t} = \\mathbf {W} ^ {- i} (\\mathbf {t} _ {y} + \\alpha \\mathbf {t}).</span></div>

    <p class="text-gray-300">What we have left to show is shortness of <span class="math">\\mathbf{z}_i</span>. Take the standard deviation</p>

    <div class="my-4 text-center"><span class="math-block">\\sigma \\geq \\max  \\left(O (\\sqrt {\\lambda}) \\cdot \\beta_ {\\mathcal {C}} N \\cdot \\sqrt {(d + 1) \\beta^ {2} + n \\tilde {q} N}, \\beta_ {T} \\cdot \\omega (\\sqrt {N \\log t N})\\right) \\tag {25}</span></div>

    <p class="text-gray-300">where <span class="math">t = \\max (n,m)</span>. By Lemma 2.16, we can swap the SamplePre algorithm with truly sampling from a discrete Gaussian. Further, since <span class="math">\\sigma</span> is larger than the shifted vector in (24) by a factor of <span class="math">O(\\sqrt{\\lambda})</span>, using rejection sampling (c.f. Lemma 2.19) we enforce the distribution of <span class="math">(\\mathbf{z}_0,\\dots ,\\mathbf{z}_d,\\hat{\\mathbf{t}}_z)</span> from (22) to be from a discrete Gaussian on <span class="math">\\Lambda_{\\mathbf{u}}^{\\perp}(\\mathbf{B})</span> where</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {u} := \\left[ \\begin{array}{c} - (g _ {0} + \\alpha f _ {0}) \\mathbf {W} ^ {0} \\mathbf {e} _ {1} \\\\ \\vdots \\\\ - (g _ {d} + \\alpha f _ {d}) \\mathbf {W} ^ {d} \\mathbf {e} _ {1} \\end{array} \\right] .</span></div>

    <p class="text-gray-300">Thus, by Lemma 2.8, we can set <span class="math">\\beta_z \\coloneqq \\sigma \\sqrt{(d + 1)mN + n\\tilde{q}N}</span>. The correctness error becomes <span class="math">\\approx 1 / M</span>.</p>

    <p class="text-gray-300">61</p>

    <p class="text-gray-300"><span class="math">\\mathbf{s}\\coloneqq (\\mathbf{s}_0,\\dots ,\\mathbf{s}_d,\\hat{\\mathbf{t}})</span>  where  <span class="math">\\hat{\\mathbf{t}}\\coloneqq \\mathbf{G}^{-1}(\\mathbf{t})</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{g}\\coloneqq (g_0,\\ldots ,g_d)\\gets \\mathcal{R}_q^{d + 1}</span></p>

    <p class="text-gray-300"><span class="math">v\\coloneqq g_0 + g_1u + \\ldots +g_du^d</span></p>

    <p class="text-gray-300">Sample  <span class="math">\\left[ \\begin{array}{l}\\mathbf{y}_0\\\\ \\vdots \\\\ \\mathbf{y}_d\\\\ \\hat{\\mathbf{t}}_y \\end{array} \\right]</span>  as in (23)</p>

    <p class="text-gray-300"><span class="math">\\mathbf{t}_y\\coloneqq \\mathbf{G}\\hat{\\mathbf{t}}_y</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{t}_y,v</span></p>

    <p class="text-gray-300"><span class="math">\\alpha \\gets \\mathcal{C} \\coloneqq S_{\\beta_c}</span></p>

    <p class="text-gray-300"><span class="math">\\hat{\\mathbf{t}}_z\\coloneqq \\hat{\\mathbf{t}}_y + \\alpha \\hat{\\mathbf{t}}</span></p>

    <p class="text-gray-300">for  <span class="math">i = 0,1,\\ldots ,d</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{z}_i\\coloneqq \\mathbf{y}_i + \\alpha \\mathbf{s}_i</span></p>

    <p class="text-gray-300"><span class="math">h_i\\coloneqq g_i + \\alpha f_i</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{z}\\coloneqq (\\mathbf{z}_1,\\dots ,\\mathbf{z}_d,\\hat{\\mathbf{t}}_z)</span></p>

    <p class="text-gray-300"><span class="math">\\rho \\gets [0,1)</span></p>

    <p class="text-gray-300">if  <span class="math">\\rho &amp;gt;\\min \\left(\\frac{\\mathcal{D}_{\\sigma}^{m&#x27;N}(\\mathbf{z})}{M\\cdot\\mathcal{D}_{\\sigma,\\alpha\\mathbf{z}}^{m&#x27;N}(\\mathbf{z})},1\\right)</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{z}\\coloneqq \\bot</span></p>

    <p class="text-gray-300"><span class="math">\\alpha \\gets \\mathcal{C} \\coloneqq S_{\\beta_c}</span></p>

    <p class="text-gray-300"><span class="math">\\left(z_{i},h_{i}\\right)_{i\\in [0,d]}</span></p>

    <p class="text-gray-300">Check:</p>

    <p class="text-gray-300"><span class="math">\\sum_{i\\in [0,d]}h_iu^{i - 1} = v + \\alpha z</span></p>

    <p class="text-gray-300"><span class="math">\\forall i, \\mathbf{A} \\mathbf{z}_i + \\mathbf{h}_i \\mathbf{e}_1 = \\mathbf{W}^{-i} (\\mathbf{t}_y + \\alpha \\mathbf{t})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\forall i, \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z}_i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta_z$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 9: The honest-verifier zero-knowledge  <span class="math">\\Sigma</span> -protocol for  <span class="math">\\mathsf{R}_{d,\\beta}</span> . Here,  <span class="math">m&#x27; := (d + 1)m + n\\tilde{q}</span>  is the width of the matrix  <span class="math">\\mathbf{B}</span>  in (21).</p>

    <p class="text-gray-300">special soundness. Given two valid transcripts  <span class="math">(\\mathbf{t}_y, v, \\alpha, (z_i, h_i)), (\\mathbf{t}_y, v, \\alpha&#x27;, (z_i&#x27;, h_i&#x27;))</span>  with distinct challenges  <span class="math">\\alpha, \\alpha&#x27; \\in \\mathcal{C}</span> , we can define</p>

    <div class="my-4 text-center"><span class="math-block">\\bar {\\mathbf {s}} _ {i} := \\frac {\\mathbf {z} _ {i} - \\mathbf {z} _ {i} ^ {\\prime}}{\\alpha - \\alpha^ {\\prime}} \\quad \\text {and} \\quad \\bar {f} _ {i} := \\frac {h _ {i} - h _ {i} ^ {\\prime}}{\\alpha - \\alpha^ {\\prime}} \\quad \\text {for} i = 0, 1, \\dots , d.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha - \\alpha' \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq 2\\beta_{\\mathcal{C}}<span class="math"> . If  </span>\\beta_{\\mathcal{C}}<span class="math">  is chosen according to Lemma 2.18 then we deduce that the difference is invertible over  </span>\\mathcal{R}_q$ . Further, by construction</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\bar {f} (u) = \\sum_ {i = 0} ^ {d} \\bar {f} _ {i} u ^ {i} = \\frac {1}{\\alpha - \\alpha^ {\\prime}} \\sum_ {i = 0} ^ {d} (h _ {i} - h _ {i} ^ {\\prime}) u ^ {i} = \\frac {\\alpha z - \\alpha^ {\\prime} z}{\\alpha - \\alpha^ {\\prime}} = z.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Furthermore, for  <span class="math">i = 0,1,\\ldots ,d</span>  we have  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\alpha -\\alpha^{\\prime})\\mathbf{s}_i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2\\beta_z$  and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A} \\bar {\\mathbf {s}} _ {i} + \\bar {f} _ {i} \\mathbf {e} _ {1} = \\frac {1}{\\alpha - \\alpha^ {\\prime}} \\left(\\mathbf {A} \\mathbf {z} _ {i} + h _ {i} \\mathbf {e} _ {1} - \\left(\\mathbf {A} \\mathbf {z} _ {i} ^ {\\prime} + h _ {i} ^ {\\prime} \\mathbf {e} _ {1}\\right)\\right) = \\frac {1}{\\alpha - \\alpha^ {\\prime}} \\left(\\alpha \\mathbf {W} ^ {- i} \\mathbf {t} - \\alpha^ {\\prime} \\mathbf {W} ^ {- i} \\mathbf {t}\\right) = \\mathbf {W} ^ {- i} \\mathbf {t}.</span></div>

    <p class="text-gray-300">Thus,  <span class="math">(\\bar{\\mathbf{s}}_0,\\dots ,\\bar{\\mathbf{s}}_d)</span>  along with the message  <span class="math">(\\bar{f}_0,\\dots ,\\bar{f}_d)</span>  is a relaxed opening for the PowerBASIS commitment  <span class="math">\\mathbf{t}</span>  with the relaxation factor  <span class="math">\\alpha -\\alpha^{\\prime}</span> . Hence, we can extract the witness for the relaxed relation  <span class="math">\\bar{\\mathsf{R}}_{d,2\\beta_z,1}</span>  in (20).</p>

    <p class="text-gray-300">Honest-verifier zero-knowledge. We show how to simulate the transcripts when the verifier behaves honestly. To this end, we prove the following lemma which is almost analogous to [BTT22, Lemma B.8].</p>

    <p class="text-gray-300">Lemma 5.17 (Honest-Verifier Zero-Knowledge). Let  <span class="math">\\sigma</span>  be chosen as in (25) where  <span class="math">t = \\max(n, m)</span> . Then, the output distributions of  <span class="math">\\mathcal{T}</span>  and  <span class="math">\\mathcal{S}</span>  in Figure 10 are statistically indistinguishable.</p>

    <p class="text-gray-300">Proof. We prove the statement via a standard hybrid argument.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Hyb}_0</span>  is identical to  <span class="math">\\mathcal{T}</span>  as in Figure 10.</li>

      <li><span class="math">\\mathsf{Hyb}_1</span>  is identical to  <span class="math">\\mathsf{Hyb}_0</span> , but now we define  <span class="math">\\hat{\\mathbf{t}}_z \\coloneqq \\hat{\\mathbf{t}}_y + \\alpha \\hat{\\mathbf{t}}</span> , where  <span class="math">\\hat{\\mathbf{t}} \\coloneqq \\mathbf{G}^{-1}(\\mathbf{t})</span> , and compute  <span class="math">\\mathbf{t}_y \\coloneqq \\mathbf{G}\\hat{\\mathbf{t}}_z - \\alpha \\mathbf{t}</span> . By construction, the output distribution of  <span class="math">\\mathsf{Hyb}_1</span>  is identical to  <span class="math">\\mathsf{Hyb}_0</span>  and</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\begin{array}{c} \\mathbf {z} _ {0} \\\\ \\vdots \\\\ \\mathbf {z} _ {d} \\\\ \\hat {\\mathbf {t}} _ {z} \\end{array} \\right] = \\left[ \\begin{array}{c} \\mathbf {y} _ {0} \\\\ \\vdots \\\\ \\mathbf {y} _ {d} \\\\ \\hat {\\mathbf {t}} _ {y} \\end{array} \\right] + \\alpha \\left[ \\begin{array}{c} \\mathbf {s} _ {0} \\\\ \\vdots \\\\ \\mathbf {s} _ {d} \\\\ \\hat {\\mathbf {t}} \\end{array} \\right] \\quad \\text {w h e r e} \\quad \\left[ \\begin{array}{c} \\mathbf {y} _ {0} \\\\ \\vdots \\\\ \\mathbf {y} _ {d} \\\\ \\hat {\\mathbf {t}} _ {y} \\end{array} \\right] \\gets \\text {S a m p l e P r e} \\left(\\left[ \\begin{array}{c c c c c} \\mathbf {A} &amp;amp; &amp;amp; &amp;amp; &amp;amp; - \\mathbf {G} \\\\ &amp;amp; \\ddots &amp;amp; &amp;amp; &amp;amp; \\vdots \\\\ &amp;amp; &amp;amp; \\mathbf {W} ^ {d} \\mathbf {A} &amp;amp; &amp;amp; - \\mathbf {G} \\end{array} \\right], \\left[ \\begin{array}{c} - g _ {0} \\mathbf {W} ^ {0} \\mathbf {e} _ {1} \\\\ &amp;amp; \\vdots \\\\ - g _ {d} \\mathbf {W} ^ {d} \\mathbf {e} _ {1} \\end{array} \\right], \\mathbf {T}, \\sigma\\right).</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Hyb}_2</span>  is identical to  <span class="math">\\mathsf{Hyb}_1</span> , but now we compute</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\begin{array}{c} \\mathbf {z} _ {0} \\\\ \\vdots \\\\ \\mathbf {z} _ {d} \\\\ \\hat {\\mathbf {t}} _ {z} \\end{array} \\right] = \\left[ \\begin{array}{c} \\mathbf {y} _ {0} \\\\ \\vdots \\\\ \\mathbf {y} _ {d} \\\\ \\hat {\\mathbf {t}} _ {y} \\end{array} \\right] + \\alpha \\left[ \\begin{array}{c} \\mathbf {s} _ {0} \\\\ \\vdots \\\\ \\mathbf {s} _ {d} \\\\ \\hat {\\mathbf {t}} \\end{array} \\right] \\quad \\text {w h e r e} \\left[ \\begin{array}{c} \\mathbf {y} _ {0} \\\\ \\vdots \\\\ \\mathbf {y} _ {d} \\\\ \\hat {\\mathbf {t}} _ {y} \\end{array} \\right] \\gets \\left[ \\begin{array}{c c c c c} \\mathbf {A} &amp;amp; &amp;amp; &amp;amp; &amp;amp; - \\mathbf {G} \\\\ &amp;amp; \\ddots &amp;amp; &amp;amp; &amp;amp; \\vdots \\\\ &amp;amp; &amp;amp; \\mathbf {W} ^ {d} \\mathbf {A} &amp;amp; &amp;amp; - \\mathbf {G} \\end{array} \\right] _ {\\sigma} ^ {- 1} \\left(\\left[ \\begin{array}{c} - g _ {0} \\mathbf {W} ^ {0} \\mathbf {e} _ {1} \\\\ &amp;amp; \\vdots \\\\ - g _ {d} \\mathbf {W} ^ {d} \\mathbf {e} _ {1} \\end{array} \\right]\\right).</span></div>

    <p class="text-gray-300">By Lemma 2.16,  <span class="math">\\mathsf{Hyb}_1</span>  and  <span class="math">\\mathsf{Hyb}_2</span>  are statistically close.</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 10: Simulating the transcripts from the  <span class="math">\\Sigma</span> -protocol described in Figure 10.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Hyb}_3</span>  is identical to  <span class="math">\\mathsf{Hyb}_2</span> , but here we directly sample</li>

    </ul>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a></p>

    <p class="text-gray-300">and with probability  <span class="math">1 - 1 / M</span>  we output  <span class="math">\\mathbf{z} \\coloneqq \\bot</span> . By the generalised rejection sampling (c.f. Lemma 2.19),  <span class="math">\\mathsf{Hyb}_3</span>  and  <span class="math">\\mathsf{Hyb}_2</span>  are statistically close.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Hyb}_4</span>  is identical to  <span class="math">\\mathsf{Hyb}_3</span> , except now we efficiently sample:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\begin{array}{c} \\mathbf {z} _ {0} \\\\ \\vdots \\\\ \\mathbf {z} _ {d} \\\\ \\mathbf {t} _ {z} \\end{array} \\right] \\gets \\text {S a m p l e P r e} \\left(\\left[ \\begin{array}{c c c c} \\mathbf {A} &amp;amp; &amp;amp; &amp;amp; - \\mathbf {G} \\\\ &amp;amp; \\ddots &amp;amp; &amp;amp; \\vdots \\\\ &amp;amp; &amp;amp; \\mathbf {W} ^ {d} \\mathbf {A} &amp;amp; - \\mathbf {G} \\end{array} \\right], \\left[ \\begin{array}{c} - (g _ {0} + \\alpha f _ {0}) \\mathbf {W} ^ {0} \\mathbf {e} _ {1} \\\\ \\vdots \\\\ - (g _ {d} + \\alpha f _ {d}) \\mathbf {W} ^ {d} \\mathbf {e} _ {1} \\end{array} \\right], \\mathbf {T}, \\sigma\\right).</span></div>

    <p class="text-gray-300">As before, by Lemma 2.16 we deduce that  <span class="math">\\mathsf{Hyb}_4</span>  and  <span class="math">\\mathsf{Hyb}_3</span>  are statistically close.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Hyb}_5</span>  is identical to  <span class="math">\\mathsf{Hyb}_4</span> , except now we define  <span class="math">h_i \\coloneqq g_i - \\alpha f_i</span>  for  <span class="math">i = 0,1,\\ldots,d</span> . Thus,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\begin{array}{c} \\mathbf {z} _ {0} \\\\ \\vdots \\\\ \\mathbf {z} _ {d} \\\\ \\mathbf {t} _ {z} \\end{array} \\right] \\gets \\text {S a m p l e P r e} \\left(\\left[ \\begin{array}{c c c c} \\mathbf {A} &amp;amp; &amp;amp; &amp;amp; - \\mathbf {G} \\\\ &amp;amp; \\ddots &amp;amp; &amp;amp; \\vdots \\\\ &amp;amp; &amp;amp; \\mathbf {W} ^ {d} \\mathbf {A} &amp;amp; - \\mathbf {G} \\end{array} \\right], \\left[ \\begin{array}{c} - h _ {0} \\mathbf {W} ^ {0} \\mathbf {e} _ {1} \\\\ \\vdots \\\\ - h _ {d} \\mathbf {W} ^ {d} \\mathbf {e} _ {1} \\end{array} \\right], \\mathbf {T}, \\sigma\\right).</span></div>

    <p class="text-gray-300">Furthermore, we set  <span class="math">v \\coloneqq h(v) - \\alpha z</span> . Clearly, the output distributions of  <span class="math">\\mathsf{Hyb}_5</span>  and  <span class="math">\\mathsf{Hyb}_4</span>  are identical.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Hyb}_6</span>  is identical to  <span class="math">\\mathsf{Hyb}_5</span> , but now we sample each  <span class="math">h_i \\gets \\mathcal{R}_q</span>  uniformly at random. Since in  <span class="math">\\mathsf{Hyb}_5</span>  each  <span class="math">g_i</span>  was sampled uniformly at random from  <span class="math">\\mathcal{R}_q</span> , we conclude that the output distributions of  <span class="math">\\mathsf{Hyb}_6</span>  and  <span class="math">\\mathsf{Hyb}_5</span>  are identical.</li>

    </ul>

    <p class="text-gray-300">Finally, the output distribution of  <span class="math">\\mathsf{Hyb}_6</span>  is identical to the one by  <span class="math">\\mathcal{S}</span>  which ends the proof.</p>

    <p class="text-gray-300">Remark 5.18. Similarly as in Section 5.4, we can combine the HVZK protocol with one round of folding to minimise the total round complexity, and thus the extracted norm growth. This yields an almost identical protocol as in [BBCPGL18].</p>

    <p class="text-gray-300">So far we showed how to commit and prove evaluations of polynomials over the cyclotomic ring  <span class="math">\\mathcal{R}_q</span> . We now present how to build polynomial commitments over finite fields of specific form. This will be useful when combining with Polynomial IOPs to obtain succinct arguments of knowledge.</p>

    <p class="text-gray-300">Suppose  <span class="math">q</span>  is a prime which satisfies  <span class="math">q \\equiv 2N / l + 1 \\pmod{4N / l}</span>  for some positive divisor  <span class="math">l</span>  of  <span class="math">N</span> . Then by [LS18, Corollary 1.2], the polynomial  <span class="math">X^{N} + 1</span>  factors as:</p>

    <div class="my-4 text-center"><span class="math-block">X ^ {N} + 1 \\equiv \\prod_ {i = 1} ^ {N / l} (X ^ {l} - r _ {i}) \\pmod {q}</span></div>

    <p class="text-gray-300">for distinct  <span class="math">r_i \\in \\mathbb{Z}_q^*</span>  where all  <span class="math">X^l - r_i</span>  are irreducible in the ring  <span class="math">\\mathbb{Z}_q[X]</span> . Further, by the Chinese Remainder Theorem, there exists a ring isomorphism  <span class="math">\\varphi : \\mathbb{F}^{N / l} \\to \\mathcal{R}_q</span>  where  <span class="math">\\mathbb{F}</span>  is a finite field of size  <span class="math">q^l</span> . Consider the restricted function:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\varphi_ {\\mathbb {F}}: \\mathbb {F} \\to \\mathcal {R} _ {q} \\\\ x \\mapsto \\phi (x, 0, \\dots , 0). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">By construction, the image of <span class="math">\\varphi_{\\mathbb{F}}</span> can be described as</p>

    <p class="text-gray-300"><span class="math">\\mathcal{S}_{q}\\coloneqq\\mathsf{Im}(\\varphi_{\\mathbb{F}})=\\{\\phi(x,0,\\ldots,0):x\\in\\mathbb{F}\\}\\enspace.</span></p>

    <p class="text-gray-300">The following simple lemma states that <span class="math">\\mathcal{S}_{q}</span> is an ideal of <span class="math">\\mathcal{R}_{q}</span>.</p>

    <h6 id="sec-73" class="text-base font-medium mt-4">Lemma 5.19.</h6>

    <p class="text-gray-300">The set <span class="math">\\mathcal{S}_{q}\\subseteq\\mathcal{R}_{q}</span> defined above is an ideal.</p>

    <h6 id="sec-74" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The fact that <span class="math">\\mathcal{S}_{q}</span> is an additive subgroup of <span class="math">\\mathcal{R}_{q}</span> follows directly from the additively homomorphic properties of <span class="math">\\varphi</span>. Now let <span class="math">a\\in\\mathcal{S}_{q}</span>, i.e. <span class="math">\\varphi(x,0,\\ldots,0)=a</span> for some <span class="math">x\\in\\mathbb{F}</span>. Further, take arbitrary <span class="math">\\gamma\\in\\mathcal{R}_{q}</span> and let <span class="math">(\\gamma_{1},\\ldots,\\gamma_{N/l})\\coloneqq\\varphi^{-1}(\\gamma)</span>. Then, by the multiplicative homomorphism of <span class="math">\\varphi</span> we get</p>

    <p class="text-gray-300"><span class="math">\\gamma\\cdot a=\\varphi(\\gamma_{1},\\ldots,\\gamma_{N/l})\\cdot\\varphi(x,0,\\ldots,0)=\\varphi(\\gamma_{1}x,0,\\ldots,0)=\\varphi_{\\mathbb{F}}(\\gamma_{1}x)\\in\\mathcal{S}_{q}\\enspace,</span></p>

    <p class="text-gray-300">which concludes the proof. ∎</p>

    <p class="text-gray-300">Suppose we want to commit to a polynomial <span class="math">F\\coloneqq\\sum_{i=0}^{d}F_{i}\\mathsf{X}^{i}\\in\\mathbb{F}[\\mathsf{X}]</span> of degree at most <span class="math">d</span>, and prove evaluation <span class="math">F(x)=y</span> for <span class="math">x,y\\in\\mathbb{F}</span>. By the homomorphic property of <span class="math">\\varphi_{\\mathbb{F}}</span>, this is equivalent to proving <span class="math">f(u)=z</span> over <span class="math">\\mathcal{R}_{q}</span> where</p>

    <p class="text-gray-300">\\[ \\begin{cases}f[\\mathsf{X}]=\\sum_{i=0}^{d}\\varphi_{\\mathbb{F}}(F_{i})\\mathsf{X}^{i}\\in\\mathcal{S}_{q}[\\mathsf{X}]\\\\ u=\\varphi_{\\mathbb{F}}(x)\\in\\mathcal{S}_{q}\\\\ z=\\varphi_{\\mathbb{F}}(y)\\in\\mathcal{S}_{q}\\end{cases}\\enspace. \\]</p>

    <p class="text-gray-300">Hence, we can commit to the polynomial <span class="math">f\\in\\mathcal{R}_{q}[\\mathsf{X}]</span> and prove evaluation of <span class="math">u</span> at the point <span class="math">z</span> as before. What is new is that we additionally need to prove that coefficients of <span class="math">f</span> indeed lie in <span class="math">\\mathcal{S}_{q}</span>. Therefore, we are interested in a stronger relation:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\left\\{((\\mathbf{A},\\mathbf{W}),(\\mathbf{t},u,z),(f,(\\mathbf{s}_{i})_{i}))\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{c}f(u)=z\\wedge f\\in\\mathcal{S}_{q}[\\mathsf{X}]\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\forall i\\in[0,d],\\mathbf{A}\\mathbf{s}_{i}+f_{i}\\mathbf{e}_{1}=\\mathbf{W}^{-i}\\mathbf{t}\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\wedge\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}_{i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\beta\\end{array}\\right.\\right.\\enspace. \\] (26)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We show how to modify the protocol in Figure 6 to accommodate for this change. Actually, the interaction between the prover and the verifier stays the same but the verifier additionally performs a check whether the final polynomial <span class="math">f_{h}\\in\\mathcal{R}_{q}[\\mathsf{X}]</span> sent by the prover has coefficients in <span class="math">\\mathcal{S}_{q}</span>.</p>

    <p class="text-gray-300">Completeness follows by induction. We start with the initial polynomial <span class="math">f_{0}\\coloneqq f\\in\\mathcal{S}_{q}[\\mathsf{X}]</span>. Then for each <span class="math">r\\in[h]</span>, the prover computes the polynomial <span class="math">f_{r}\\in\\mathcal{R}_{q}[\\mathsf{X}]</span> as a linear combination of “partial terms” of <span class="math">f_{r-1}</span>:</p>

    <p class="text-gray-300"><span class="math">f_{r}\\coloneqq\\sum_{t\\in[k]}\\alpha_{r,t}f_{r-1,t}\\enspace.</span></p>

    <p class="text-gray-300">If <span class="math">f_{r-1}\\in\\mathcal{S}_{q}[\\mathsf{X}]</span>, then by Lemma 5.19 we deduce that <span class="math">f_{r}\\in\\mathcal{S}_{q}[\\mathsf{X}]</span>.</p>

    <p class="text-gray-300">To argue (coordinate-wise) special soundness, consider the extractor in the proof of Lemma 5.6. The coefficients of the extracted polynomial <span class="math">f</span> are computed as</p>

    <p class="text-gray-300"><span class="math">f_{2i}\\coloneqq\\frac{\\alpha_{1}g_{0,i}-\\alpha_{0}g_{1,i}}{\\alpha_{1}-\\alpha_{0}},\\quad f_{2i+1}\\coloneqq\\frac{g_{0,i}-g_{1,i}}{\\alpha_{0}-\\alpha_{1}}\\quad\\text{for }i\\in[0,d/2]\\enspace.</span></p>

    <p class="text-gray-300">If polynomials <span class="math">g_{0}</span> and <span class="math">g_{1}</span> have coefficients in <span class="math">\\mathcal{S}_{q}</span>, then again by Lemma 5.19 we can deduce that <span class="math">f\\in\\mathcal{S}_{q}[\\mathsf{X}]</span>. Identical argument holds when analysing Lemma 5.10.</p>

    <p class="text-gray-300">Finally, to support honest-verifier zero-knowledge in Figure 9, we let the prover pick uniformly random elements <span class="math">g_{i}</span> from <span class="math">\\mathcal{S}_{q}</span> instead of <span class="math">\\mathcal{R}_{q}</span> in order to fully mask the coefficients <span class="math">f_{i}</span>. Thus, by construction and Lemma 5.19, <span class="math">h_{i}=g_{i}+\\alpha f_{i}\\in\\mathcal{S}_{q}</span> for all <span class="math">i=0,\\ldots,d</span>. Hence, the verifier additionally performs the check whether coefficients <span class="math">h_{i}</span> lie in <span class="math">\\mathcal{S}_{q}</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">6 Concrete Instantiation and Applications to Marlin</p>

    <h5 id="sec-75" class="text-base font-semibold mt-4">Hardness of PowerBASIS.</h5>

    <p class="text-gray-300">In parameter selection, we make a heuristic assumption that PowerBASIS is exactly as hard as MSIS. Hence, one should treat our computed sizes only as intuition on how practical the polynomial commitment is.</p>

    <p class="text-gray-300">In the literature, hardness of the MSIS problems is often analysed identically as the plain SIS since, so far, the best known attacks do not make use of the algebraic structure of the polynomial ring <em>[x1]</em>. We follow the methodology from Dilithium <em>[x13, Appendix C]</em>. That is, <span class="math">\\mathsf{MSIS}_{n,m,N,q,\\beta}</span> for matrix <span class="math">\\mathbf{A}</span> is equivalent to finding a non-trivial vector of norm smaller than <span class="math">\\beta</span> in the lattice <span class="math">\\Lambda\\coloneqq\\Lambda^{\\perp}(\\mathbf{A})</span>. In order to find short non-trivial vectors in <span class="math">\\Lambda</span>, we apply the Block-Korkine-Zolotarev algorithm (BKZ) <em>[x30, x11]</em>. As a subroutine, BKZ uses an algorithm for the shortest vector problem (SVP) in lattices of dimension <span class="math">b</span>, where <span class="math">b</span> is called the block size. If we apply the best known algorithm for solving SVP with no memory constraints by Becker et al. <em>[x5]</em>, the time required by BKZ to run on the <span class="math">mN</span>-dimensional lattice <span class="math">\\Lambda</span> with block size <span class="math">b</span> is given by <span class="math">8mN\\cdot 2^{0.292b+16.4}</span> (one also considers a more <em>conservative</em> variant with runtime <span class="math">2^{0.292b}</span>). The algorithm outputs a vector of norm <span class="math">\\delta_{\\mathsf{rhf}}^{mN}\\det(\\Lambda)^{\\frac{1}{mN}}</span> where <span class="math">\\delta_{\\mathsf{rhf}}</span> is the root Hermite factor and it is given by</p>

    <p class="text-gray-300"><span class="math">\\delta_{\\mathsf{rhf}}=\\left(\\frac{b(\\pi b)^{1/b}}{2\\pi e}\\right)^{\\frac{1}{2(b-1)}}\\enspace.</span> (27)</p>

    <p class="text-gray-300">For our usual parameter selection, the probability that a random matrix <span class="math">\\mathbf{A}\\in\\mathcal{R}_{q}^{n\\times m}</span> is of full rank is overwhelming (see <em>[x15, Appendix C]</em>) and thus <span class="math">\\det(\\Lambda)=q^{nN}.</span> Next, Micciancio and Regev <em>[x26]</em> show that</p>

    <p class="text-gray-300"><span class="math">\\delta_{\\mathsf{rhf}}^{mN}\\det(\\Lambda)^{\\frac{1}{mN}}=\\delta_{\\mathsf{rhf}}^{mN}q^{\\frac{nN}{mN}}\\geq 2^{2\\sqrt{nN\\log q\\log\\delta}}</span></p>

    <p class="text-gray-300">and the equality holds when <span class="math">mN=\\sqrt{nN\\log q/\\log\\delta}</span>. Hence, given a bound <span class="math">\\beta&lt;q</span> we compute <span class="math">\\delta_{\\mathsf{rhf}}</span> from the equation <span class="math">\\beta=2^{2\\sqrt{nN\\log q\\log\\delta}}</span>. Next, we calculate the minimum block size <span class="math">b</span> from Equation (27), and thus we get the total time for BKZ to solve <span class="math">\\mathsf{MSIS}_{n,m,N,q,\\beta}</span>. Hereafter, we will refer to the “aggressive strategy” to set PowerBASIS as the one using the estimate from Becker et al. <em>[x5]</em>, and to the the “conservative strategy” as the one using <span class="math">2^{0.292b}</span>.</p>

    <h5 id="sec-76" class="text-base font-semibold mt-4">Parameters.</h5>

    <p class="text-gray-300">Using a combination of randomised and exhaustive search, we found parameters for the schemes in Theorem 5.8 and Theorem 5.12. In Table 7 we detail the parameters obtained for the scheme presented in Theorem 5.12 and in Table 8 for that in Theorem 5.8. We also make use of the techniques in <em>[x1, Sec 5.5, Sec 6]</em> to further optimise the parameters. Namely, we use the transformation therein to convert our polynomial commitment scheme to one that supports prime order fields, and we use deterministic preimage sampling (since in this section we are not concerned with zero-knowledge). We stress that these parameters are presented to give the reader an indication of the concrete efficiency of the scheme. The commitments have sizes on the order of hundreds of kilobytes, while evaluation proofs are on the order of a few megabytes, and so are larger than desirable in most applications. We also emphasise that the assumption that the hardness of PowerBASIS is as hard as MSIS is an heuristic, and thus, until this heuristic is backed or disproved by sufficient cryptanalysis, the sizes should be considered as an optimistic lower bound.</p>

    <h5 id="sec-77" class="text-base font-semibold mt-4">Applications to Polynomial IOPs.</h5>

    <p class="text-gray-300">Marlin <em>[x10]</em> is a widely deployed preprocessing zkSNARK. As many modern constructions, Marlin is constructed by combining two ingredients:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">λ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">δ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">log q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2γβs</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">β</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">βC</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">βh</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">π</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">214</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">87</td>

            <td class="px-3 py-2 border-b border-gray-700">1697</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

            <td class="px-3 py-2 border-b border-gray-700">204</td>

            <td class="px-3 py-2 border-b border-gray-700">203</td>

            <td class="px-3 py-2 border-b border-gray-700">148</td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">166</td>

            <td class="px-3 py-2 border-b border-gray-700">139 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">2.6 MB</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">230</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">139</td>

            <td class="px-3 py-2 border-b border-gray-700">2919</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">322</td>

            <td class="px-3 py-2 border-b border-gray-700">322</td>

            <td class="px-3 py-2 border-b border-gray-700">196</td>

            <td class="px-3 py-2 border-b border-gray-700">49</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">225</td>

            <td class="px-3 py-2 border-b border-gray-700">350 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">6.9 MB</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">220</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">117</td>

            <td class="px-3 py-2 border-b border-gray-700">2106</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">229</td>

            <td class="px-3 py-2 border-b border-gray-700">222</td>

            <td class="px-3 py-2 border-b border-gray-700">163</td>

            <td class="px-3 py-2 border-b border-gray-700">42</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">182</td>

            <td class="px-3 py-2 border-b border-gray-700">209 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">3.4 MB</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">230</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">168</td>

            <td class="px-3 py-2 border-b border-gray-700">3528</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">339</td>

            <td class="px-3 py-2 border-b border-gray-700">338</td>

            <td class="px-3 py-2 border-b border-gray-700">202</td>

            <td class="px-3 py-2 border-b border-gray-700">53</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">234</td>

            <td class="px-3 py-2 border-b border-gray-700">445 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">8.3 MB</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 7: Parameters and concrete sizes for the polynomial commitment described in Theorem 5.12.  <span class="math">\\delta</span> , norms and standard deviation given in log form.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">λ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">δ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">log q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2γβs</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">β</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">βh</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cc</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">220</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

            <td class="px-3 py-2 border-b border-gray-700">383</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

            <td class="px-3 py-2 border-b border-gray-700">314</td>

            <td class="px-3 py-2 border-b border-gray-700">314</td>

            <td class="px-3 py-2 border-b border-gray-700">170</td>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">333 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">64.1 MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

            <td class="px-3 py-2 border-b border-gray-700">230</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700">608</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">38</td>

            <td class="px-3 py-2 border-b border-gray-700">548</td>

            <td class="px-3 py-2 border-b border-gray-700">523</td>

            <td class="px-3 py-2 border-b border-gray-700">249</td>

            <td class="px-3 py-2 border-b border-gray-700">78</td>

            <td class="px-3 py-2 border-b border-gray-700">291</td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">925 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">183.7 MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">220</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">54</td>

            <td class="px-3 py-2 border-b border-gray-700">4096</td>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700">320</td>

            <td class="px-3 py-2 border-b border-gray-700">320</td>

            <td class="px-3 py-2 border-b border-gray-700">191</td>

            <td class="px-3 py-2 border-b border-gray-700">65</td>

            <td class="px-3 py-2 border-b border-gray-700">207</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">480 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">105.4 MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">230</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

            <td class="px-3 py-2 border-b border-gray-700">408</td>

            <td class="px-3 py-2 border-b border-gray-700">1024</td>

            <td class="px-3 py-2 border-b border-gray-700">33</td>

            <td class="px-3 py-2 border-b border-gray-700">515</td>

            <td class="px-3 py-2 border-b border-gray-700">515</td>

            <td class="px-3 py-2 border-b border-gray-700">234</td>

            <td class="px-3 py-2 border-b border-gray-700">72</td>

            <td class="px-3 py-2 border-b border-gray-700">274</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">1.07 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">324.4 MB</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 8: Parameters and concrete sizes for the interactive polynomial commitment in Theorem 5.8.  <span class="math">\\delta</span> , norms and standard deviation given in log form.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h d</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">λ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">δ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">log q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2γβs</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">β</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">βC</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">βh</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">π</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[32, 32, 48]</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">220</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">138</td>

            <td class="px-3 py-2 border-b border-gray-700">2691</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700">324</td>

            <td class="px-3 py-2 border-b border-gray-700">321</td>

            <td class="px-3 py-2 border-b border-gray-700">181</td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">224</td>

            <td class="px-3 py-2 border-b border-gray-700">6.1 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">6.6 MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[32, 128, 128, 192]</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">230</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">224</td>

            <td class="px-3 py-2 border-b border-gray-700">5376</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

            <td class="px-3 py-2 border-b border-gray-700">517</td>

            <td class="px-3 py-2 border-b border-gray-700">517</td>

            <td class="px-3 py-2 border-b border-gray-700">231</td>

            <td class="px-3 py-2 border-b border-gray-700">66</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">292</td>

            <td class="px-3 py-2 border-b border-gray-700">15.9 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">19.6 MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[32, 32, 48]</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">220</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">186</td>

            <td class="px-3 py-2 border-b border-gray-700">3627</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700">343</td>

            <td class="px-3 py-2 border-b border-gray-700">339</td>

            <td class="px-3 py-2 border-b border-gray-700">189</td>

            <td class="px-3 py-2 border-b border-gray-700">54</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">234</td>

            <td class="px-3 py-2 border-b border-gray-700">8.8 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">8.6 MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[32, 128, 128, 192]</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">230</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">271</td>

            <td class="px-3 py-2 border-b border-gray-700">6504</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">36</td>

            <td class="px-3 py-2 border-b border-gray-700">562</td>

            <td class="px-3 py-2 border-b border-gray-700">552</td>

            <td class="px-3 py-2 border-b border-gray-700">244</td>

            <td class="px-3 py-2 border-b border-gray-700">74</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">309</td>

            <td class="px-3 py-2 border-b border-gray-700">20.9 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">23.6 MB</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 9: Parameters and concrete sizes for Marlin when instantiated with the commitment described in Theorem 5.12 with amortisation as in Table 6.  <span class="math">\\delta</span> , norms and standard deviation given in log form. Folding factor varies across rounds as mentioned in Remark 5.4</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a polynomial interactive oracle proof (PIOP) (therein a algebraic holographic proof);</li>

      <li>and a polynomial commitment scheme.</li>

    </ul>

    <p class="text-gray-300">An interactive oracle proof (IOP) is a generalisation of both probabilistically checkable proofs and interactive proofs. Informally, they are interactive protocols between a prover and a verifier, in which the prover sends oracle messages, which the verifier is allowed to not read in their entirety. A PIOP is simply an IOP where the prover messages are guaranteed to be (low degree) polynomials. IOPs and PIOPs are information theoretic object, and as such inherit a number of efficiency limitations (for example, IOP proof length are required to be at least linear in the size of the instance), but can be compiled using cryptography (see <em>[x1]</em>) to obtain arguments that are both asymptotically and concretely efficient. Informally, to compile a PIOP into an interactive argument, the prover can commit to each polynomial oracle using a polynomial commitment scheme, and then prove to the verifier that the evaluations (at points chosen by the verifier) are as claimed. Then, to obtain a NARK, we can apply the Fiat-Shamir transformation to this interactive protocol. We can thus aim to use our polynomial commitment scheme in Theorem 5.12 as an ingredient of Marlin to obtain a zkSNARK for R1CS. Let <span class="math">d</span> denote the size of the R1CS instance that we aim to prove. As detailed in <em>[x1, Section 9]</em>, Marlin after compilation has commitments to 19 total polynomials of degree at most <span class="math">6d</span>. The prover has then to produce 19 evaluations proofs for these polynomials, at three distinct points. We can thus apply the techniques in Section 5.4 to batch evaluations together and amortise the cost of the last round. In Table 9 we compute parameters for Marlin instantiated using our polynomial commitment scheme and the PIOP therein described. Again, these sizes are meant to give a rough estimate of the concrete efficiency of the scheme, and the same caveats apply as with the polynomial commitment scheme. We also note that Marlin operates over fields with a large multiplicative (or additive) subgroup with smooth order, which imposes an additional requirement on the size of <span class="math">q</span>. Since our moduli are again quite large, this additional requirement is immaterial.</p>

    <h5 id="sec-78" class="text-base font-semibold mt-4">Falsifiable version of PowerBASIS.</h5>

    <p class="text-gray-300">Note that the challenger in the PowerBASIS game from Section 3 is not efficient since it needs to sample a random trapdoor <span class="math">\\mathbf{T}</span> according to a discrete Gaussian distribution. In order to make the assumption falsifiable, one could let the challenger sample efficiently using the SamplePre algorithm, e.g. as in the Setup algorithm of Figure 4. Further, for efficiency we can ensure that the sampled matrix <span class="math">\\mathbf{A}</span> from <span class="math">(\\mathbf{A},\\mathbf{R})\\leftarrow\\texttt{ TrapGen}(n,m)</span> is computationally indistinguishable from random. However, we do not apply this heuristic in our parameter selection.</p>

    <h2 id="sec-79" class="text-2xl font-bold">7 Coordinate-Wise Special Soundness Implies Knowledge Soundness</h2>

    <p class="text-gray-300">In this section we show that coordinate-wise special soundness implies knowledge soundness for multi-round protocols by extending the techniques presented in <em>[x1, x2]</em> (cf. Lemma 2.31). We also show that our knowledge extractor is exponentially more efficient than the generic extractor introduced by Attema et al. <em>[x3]</em>. The intuition behind this efficiency is that the extractor samples challenges in a certain way that is the most plausible for having a monotone structure. For reference, we will use identical terminology as in <em>[x2, Section 6.4]</em>. In the following, we define a</p>

    <p class="text-gray-300">challenge space <span class="math">\\mathcal{C}:=S^{\\ell}</span>.</p>

    <h3 id="sec-80" class="text-xl font-semibold mt-8">7.1 <span class="math">\\Sigma</span>-Protocols</h3>

    <p class="text-gray-300">We start by considering three-round public coin interactive proofs, i.e. <span class="math">\\Sigma</span>-protocols. Namely, let <span class="math">\\mathcal{A}:\\mathcal{C}\\to\\{0,1\\}^{<em>}</span> be an arbitrary (probabilistic) algorithm, and <span class="math">V:\\mathcal{C}\\times\\{0,1\\}^{</em>}\\to\\{0,1\\}</span> be the verification function. Then, <span class="math">\\mathcal{A}</span> has naturally defined success probability:</p>

    <p class="text-gray-300"><span class="math">\\epsilon^{V}(\\mathcal{A}):=\\Pr_{\\mathbf{c}\\leftarrow\\mathcal{C}}[V(\\mathbf{c},\\mathcal{A}(\\mathbf{c}))=1].</span></p>

    <p class="text-gray-300">The standard interpretation is that <span class="math">\\mathcal{A}</span> is a malicious prover, which tries to convince the verifier of the underlying <span class="math">\\Sigma</span>-protocol.</p>

    <p class="text-gray-300">The following lemma describes how to extract from CWSS <span class="math">\\Sigma</span>-protocols. The proof methodology is identical to <em>[x1, Lemma 6.5]</em>.</p>

    <h6 id="sec-81" class="text-base font-medium mt-4">Lemma 7.1.</h6>

    <p class="text-gray-300">Let <span class="math">k,\\ell\\in\\mathbb{N}</span>, and <span class="math">S</span> be a finite set of cardinality <span class="math">N</span>. Define <span class="math">\\mathcal{C}:=S^{\\ell}</span> and take any verification function <span class="math">V:\\mathcal{C}\\times\\{0,1\\}^{<em>}\\to\\{0,1\\}</span>. Then there exists an oracle algorithm <span class="math">\\mathcal{E}</span> with the following properties: the algorithm <span class="math">\\mathcal{E}^{\\mathcal{A}}</span>, given oracle access to a (probabilistic) algorithm <span class="math">\\mathcal{A}:\\mathcal{C}\\to\\{0,1\\}^{</em>}</span>, requires an expected number of at most <span class="math">\\ell(k-1)+1</span> queries to <span class="math">\\mathcal{A}</span> and with probability at least</p>

    <p class="text-gray-300"><span class="math">\\epsilon^{V}(\\mathcal{A})-\\frac{\\ell(k-1)}{N}</span></p>

    <p class="text-gray-300">outputs <span class="math">\\ell(k-1)+1</span> pairs <span class="math">(\\mathbf{c}_{0},y_{0}),\\ldots,(\\mathbf{c}_{\\ell(k-1)},y_{\\ell(k-1)})</span> such that <span class="math">V(\\mathbf{c}_{i},y_{i})=1</span> for all <span class="math">i\\in[0,\\ell(k-1)]</span> and <span class="math">\\{\\mathbf{c}_{0},\\ldots,\\mathbf{c}_{\\ell(k-1)}\\}\\in\\mathsf{SS}(S,\\ell,k)</span>.</p>

    <h6 id="sec-82" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The extractor <span class="math">\\mathcal{E}^{\\mathcal{A}}</span> is defined in Figure 11. We denote by <span class="math">\\mathbf{C}_{0}:=(C_{0,1},\\ldots,C_{0,\\ell})</span> the random variable for the first challenge sampled by <span class="math">\\mathcal{E}</span>. Also, we denote <span class="math">\\Gamma=V(\\mathbf{C}_{0},\\mathcal{A}(\\mathbf{C}_{0}))</span>. In particular, <span class="math">\\Pr[\\Gamma=1]=\\epsilon^{V}(\\mathcal{A})</span>.</p>

    <p class="text-gray-300">Let <span class="math">T</span> be the number of <span class="math">\\mathcal{A}</span>-queries made by <span class="math">\\mathcal{E}</span>. For <span class="math">i\\in[\\ell]</span>, define <span class="math">T_{i}</span> to be the number of queries made during the <span class="math">i</span>-th iteration of the loop. By linearity of expectation, we have <span class="math">\\mathbb{E}[T]=1+\\sum_{i=1}^{\\ell}\\mathbb{E}[T_{i}]</span>. Also, if <span class="math">\\Gamma=0</span> then <span class="math">T_{i}=0</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Further, define the random variable $X_{i}:=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{x\\in S:V(\\mathbf{C}(x),\\mathcal{A}(\\mathbf{C}(x))=1\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, where </span>\\mathbf{C}(x):=(C_{0,1},\\ldots,C_{0,i-1},x,C_{0,i+1},\\ldots,C_{0,\\ell})<span class="math">. Then, for </span>l\\geq 0$ we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathbb{E}[T_{l}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X_{i}=l]=\\Pr[\\Gamma=1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X_{i}=l]\\cdot\\mathbb{E}[T_{l}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Gamma=1\\wedge X_{i}=l].$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">First, note that $\\Pr[\\Gamma=1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X_{i}=l]=l/N<span class="math">. Moreover, assume that the first query to </span>\\mathcal{A}<span class="math"> was successful, i.e. </span>\\Gamma=1<span class="math">. Then, assuming that </span>X_{i}=l<span class="math">, each </span>i<span class="math">-th iteration of the loop in Step 4 can be modelled as a negative hypergeometric distribution, i.e. challenges are drawn (without replacement) from a set of size </span>N-1<span class="math"> containing </span>l-1<span class="math"> correct responses. Therefore </span>\\mathbb{E}[T_{l}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Gamma=1\\wedge X_{i}=l]\\leq(k-1)N/l$. Thus</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathbb{E}[T_{i}]\\leq l/N\\cdot(k-1)N/l=k-1,</span></p>

    <p class="text-gray-300">and consequently <span class="math">\\mathbb{E}[T]\\leq\\ell(k-1)+1</span>.</p>

    <p class="text-gray-300">We now move to the success probability of <span class="math">\\mathcal{E}^{\\mathcal{A}}</span>. Note that the extractor succeeds with probability <span class="math">\\Pr[\\Gamma=1\\wedge(\\wedge_{i=1}^{\\ell}X_{i}\\geq k)]</span>. Now, by the union bound we have</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\Gamma=1\\wedge(\\wedge_{i=1}^{\\ell}X_{i}\\geq 2)]=\\Pr[\\Gamma=1]-\\Pr[\\Gamma=1\\wedge(\\vee_{i=1}^{\\ell}X_{i}\\leq k-1)]</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{c}_0\\coloneqq (c_{0,1},\\ldots ,c_{0,\\ell})\\gets \\mathcal{C}</span></li>

      <li><span class="math">y_0\\gets \\mathcal{A}(\\mathbf{c}_0)</span></li>

      <li>If  <span class="math">V(\\mathbf{c}_0, y_0) = 0</span> , then abort</li>

      <li>For  <span class="math">i = 1,\\dots ,\\ell</span>  , repeat:</li>

    </ol>

    <p class="text-gray-300">(a) Sample  <span class="math">c_{i}^{<em>}\\gets S\\backslash \\{c_{0,i}\\}</span>  without replacement (b)  <span class="math">\\mathbf{c}_i\\coloneqq (c_{0,1},\\ldots ,c_{0,i - 1},c_i^</em>,c_{0,i + 1},\\ldots ,c_{0,\\ell})</span> (c)  <span class="math">y_{i}\\gets \\mathcal{A}(\\mathbf{c}_{i})</span> (d) If  <span class="math">V(\\mathbf{c}_i, y_i) = 0</span> , go to Step 4(a)</p>

    <p class="text-gray-300">until  <span class="math">k - 1</span>  pairs  <span class="math">(\\mathbf{c}_{i,j},y_{i,j})_{j\\in [k - 1]}</span>  s.t.  <span class="math">V(\\mathbf{c}_{i,j},y_{i,j}) = 1</span>  are collected, or until all  <span class="math">c_i^*</span>  have been tried (in the latter case abort)</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Return the corresponding  <span class="math">(\\mathbf{c}_0,y_0),(\\mathbf{c}_{i,j},y_{i,j})_{i\\in [\\ell ],j\\in [k - 1]}</span></li>

    </ol>

    <p class="text-gray-300">Figure 11: Knowledge extractor for the proof of Lemma 7.1.</p>

    <p class="text-gray-300"><span class="math">\\geq \\operatorname<em>{Pr}[\\Gamma = 1] - \\sum_{i = 1}^{\\ell}\\operatorname</em>{Pr}[\\Gamma = 1\\wedge X_i\\leq k - 1]</span> <span class="math">\\geq \\operatorname<em>{Pr}[\\Gamma = 1] - \\sum_{i = 1}^{\\ell}\\sum_{j = 1}^{k - 1}\\operatorname</em>{Pr}[\\Gamma = 1\\wedge X_i = j]</span> <span class="math">\\geq \\operatorname<em>{Pr}[\\Gamma = 1] - \\sum_{i = 1}^{\\ell}\\sum_{j = 1}^{k - 1}\\frac{j}{N}</span> <span class="math">\\geq \\operatorname</em>{Pr}[\\Gamma = 1] - \\frac{\\ell(k - 1)}{N}.</span></p>

    <p class="text-gray-300">The statement follows by recalling that  <span class="math">\\operatorname*{Pr}[\\Gamma = 1] = \\epsilon^V (\\mathcal{A})</span></p>

    <p class="text-gray-300">Next, we move on to  <span class="math">(2\\mu + 1)</span> -round interactive proofs. To this end, we consider an arbitrary probabilistic algorithm  <span class="math">\\mathcal{A}: \\mathcal{C} \\times \\dots \\times \\mathcal{C} \\to \\{0,1\\}^<em></span> , and a verification function  <span class="math">V: \\mathcal{C} \\times \\dots \\times \\mathcal{C} \\times \\{0,1\\}^</em> \\to \\{0,1\\}</span> . Similarly as before, we define</p>

    <p class="text-gray-300"><span class="math">\\epsilon^V (\\mathcal{A}):= \\operatorname *{Pr}\\left[V(\\bar{\\mathbf{c}},\\mathcal{A}(\\bar{\\mathbf{c}}))\\right],</span></p>

    <p class="text-gray-300">where  <span class="math">\\bar{\\mathbf{c}}\\gets \\mathcal{C}^{\\mu}</span></p>

    <p class="text-gray-300">Now, the goal of the extractor is, given oracle access to  <span class="math">\\mathcal{A}</span> , to efficiently extract a tree of transcripts, as in Definition 2.30. We will follow the footsteps of [Att23, Lemma 6.6] and recursively use Lemma 7.1 for the  <span class="math">\\Sigma</span> -protocol case.</p>

    <p class="text-gray-300">Lemma 7.2. Let  <span class="math">k, \\ell, \\mu \\in \\mathbb{N}</span> , and  <span class="math">S</span>  be a finite set of cardinality  <span class="math">N</span> . Define  <span class="math">\\mathcal{C} \\coloneqq S^{\\ell}</span>  and take any verification function  <span class="math">V: \\mathcal{C} \\times \\dots \\times \\mathcal{C} \\times \\{0,1\\}^{*} \\to \\{0,1\\}</span> . Then there exists an oracle algorithm  <span class="math">\\mathcal{E}</span></p>

    <p class="text-gray-300">with the following properties: the algorithm <span class="math">\\mathcal{E}^{\\mathcal{A}}</span>, given oracle access to a (probabilistic) algorithm <span class="math">\\mathcal{A}:\\mathcal{C}\\times\\cdots\\times\\mathcal{C}\\to\\{0,1\\}^{*}</span>, requires an expected number of at most <span class="math">K:=(\\ell(k-1)+1)^{\\mu}</span> queries to <span class="math">\\mathcal{A}</span> and with probability at least</p>

    <p class="text-gray-300"><span class="math">\\epsilon^{V}(\\mathcal{A})-\\mu\\cdot\\frac{\\ell(k-1)}{N}</span></p>

    <p class="text-gray-300">outputs <span class="math">K</span> pairs <span class="math">(\\mathbf{c}_{i},y_{i})_{i\\in[K]}</span> such that <span class="math">V(\\mathbf{c}_{i},y_{i})=1</span> for all <span class="math">i\\in[K]</span> and <span class="math">(\\mathbf{c}_{i})_{i\\in[K]}</span> form a tree of challenges as described in Definition 2.30.</p>

    <h6 id="sec-86" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We prove the statement by induction on <span class="math">\\mu\\geq 1</span>. For <span class="math">\\mu=1</span>, we can apply Lemma 7.1. Hence, assume the lemma holds for <span class="math">\\mu=M\\geq 1</span> and focus on the case <span class="math">\\mu=M+1</span>.</p>

    <p class="text-gray-300">For <span class="math">\\mathbf{c}\\in\\mathcal{C}</span>, we define <span class="math">\\mathcal{A}_{\\mathbf{c}}</span> to be the algorithm, which takes input <span class="math">(\\mathbf{c}^{(2)},\\ldots,\\mathbf{c}^{(\\mu)})\\in\\mathcal{C}^{\\mu-1}</span>, and outputs <span class="math">\\mathcal{A}(\\mathbf{c},\\mathbf{c}^{(2)},\\ldots,\\mathbf{c}^{(\\mu)})</span>. We similarly define a verification function <span class="math">V_{\\mathbf{c}}</span> as <span class="math">V_{\\mathbf{c}}(\\mathbf{c}^{(2)},\\ldots,\\mathbf{c}^{(\\mu)},y):=V(\\mathbf{c},\\mathbf{c}^{(2)},\\ldots,\\mathbf{c}^{(\\mu)},y)</span>. By the induction hypothesis, there exists an extractor <span class="math">\\mathcal{E}^{\\mathcal{A}_{\\mathbf{c}}}_{\\mu-1}</span>, that given oracle access to <span class="math">\\mathcal{A}_{\\mathbf{c}}</span>, outputs a set <span class="math">\\mathcal{Y}</span> of <span class="math">K^{\\prime}:=(\\ell(k-1)+1)^{\\mu-1}</span> pairs <span class="math">(\\mathbf{c}_{i},y_{i})\\in\\mathcal{C}^{\\mu-1}\\times\\{0,1\\}^{*}</span>, such that <span class="math">V_{\\mathbf{c}}(\\mathbf{c}_{i},y_{i})=1</span> for all <span class="math">i\\in[K^{\\prime}]</span> and <span class="math">(\\mathbf{c}_{i})_{i\\in[K^{\\prime}]}</span> form a tree of challenge vectors of level <span class="math">\\mu-1</span>, with probability at least</p>

    <p class="text-gray-300"><span class="math">\\epsilon^{V_{\\mathbf{c}}}(\\mathcal{A}_{\\mathbf{c}})-(\\mu-1)\\cdot\\frac{\\ell(k-1)}{N},</span></p>

    <p class="text-gray-300">and makes at most <span class="math">K^{\\prime}</span> queries to <span class="math">\\mathcal{A}_{\\mathbf{c}}</span>. Now, we define <span class="math">W:\\mathcal{C}\\times\\{0,1\\}^{<em>}\\to\\{0,1\\}</span> as <span class="math">W(\\mathbf{c},\\mathcal{Y})=1</span> if and only if <span class="math">\\mathcal{Y}</span> satisfies all the properties above. Further, define <span class="math">\\mathcal{B}^{\\mathcal{A}}:\\mathcal{C}\\to\\{0,1\\}^{</em>}</span> to be the algorithm, which takes as input <span class="math">\\mathbf{c}\\in\\mathcal{C}</span>, and runs <span class="math">\\mathcal{E}^{\\mathcal{A}_{\\mathbf{c}}}_{\\mu-1}</span>. By Lemma 7.1, there is an extractor <span class="math">\\mathcal{E}^{\\mathcal{B}^{\\mathcal{A}}}_{1}</span> that aims to output <span class="math">\\ell(k-1)+1</span> pairs <span class="math">(\\mathbf{c}^{(1)}_{0},\\mathcal{Y}_{0}),\\ldots,(\\mathbf{c}^{(1)}_{\\ell(k-1)},\\mathcal{Y}_{\\ell(k-1)})</span> such that <span class="math">W(\\mathbf{c}^{(1)}_{i},\\mathcal{Y}_{i})=1</span> for <span class="math">i\\in[0,\\ell(k-1)]</span> and <span class="math">(\\mathbf{c}^{(1)}_{i})_{i\\in[0,\\ell(k-1)]}\\in\\mathsf{SS}(S,\\ell,k)</span>. Note that such a set of <span class="math">\\ell(k-1)+1</span> trees of challenges is also a tree of challenges of level <span class="math">\\mu</span>. Thus, we define the extractor <span class="math">\\mathcal{E}^{\\mathcal{A}}</span> to simply run <span class="math">\\mathcal{E}^{\\mathcal{B}^{\\mathcal{A}}}_{1}</span>.</p>

    <p class="text-gray-300">We first discuss the expected number of queries to <span class="math">\\mathcal{A}</span> made by <span class="math">\\mathcal{E}</span>. By Lemma 7.1, <span class="math">\\mathcal{E}^{\\mathcal{A}_{\\mathbf{c}}}_{\\mu-1}</span> makes at most <span class="math">\\ell(k-1)+1</span> queries to <span class="math">\\mathcal{B}^{\\mathcal{A}}</span> in expectation. Then, by induction hypothesis, <span class="math">\\mathcal{B}^{\\mathcal{A}}</span> makes at most <span class="math">K^{\\prime}</span> calls to <span class="math">\\mathcal{A}</span> in expectation. Hence, the total expected number of <span class="math">\\mathcal{A}</span>-queries is at most <span class="math">(\\ell(k-1)+1)K^{\\prime}=(\\ell(k-1)+1)^{\\mu}</span>. As for the success probability, we know from Lemma 7.1 and induction hypothesis that <span class="math">\\mathcal{E}^{\\mathcal{B}^{\\mathcal{A}}}_{1}</span> succeeds with probability at least <span class="math">\\epsilon^{\\prime}</span> where</p>

    <p class="text-gray-300"><span class="math">\\epsilon^{\\prime}</span> <span class="math">\\geq\\epsilon^{W}(\\mathcal{B}^{\\mathcal{A}})-\\frac{\\ell(k-1)}{N}</span> <span class="math">\\geq\\mathbb{E}_{\\mathbf{c}}\\left[\\Pr[\\mathcal{E}^{\\mathcal{A}_{\\mathbf{c}}}_{\\mu-1}\\neq\\bot]\\right]-\\frac{\\ell(k-1)}{N}</span> <span class="math">\\geq\\mathbb{E}_{\\mathbf{c}}\\left[\\epsilon^{V_{\\mathbf{c}}}(\\mathcal{A}_{\\mathbf{c}})-(\\mu-1)\\frac{\\ell(k-1)}{N}\\right]-\\frac{\\ell(k-1)}{N}</span> <span class="math">\\geq\\epsilon^{V}(\\mathcal{A})-\\mu\\frac{\\ell(k-1)}{N},</span></p>

    <p class="text-gray-300">which concludes the proof. ∎</p>

    <p class="text-gray-300">Finally, Lemma 2.31 follows straightforwardly from Lemma 7.2.</p>

    <h3 id="sec-87" class="text-xl font-semibold mt-8">7.3 Comparison with the Generic Extractor</h3>

    <p class="text-gray-300">The notion of coordinate-wise special soundness is a specific case of general notion of <span class="math">\\Gamma</span>-out-of-<span class="math">\\mathcal{C}</span> special soundness introduced by Attema et al. <em>[x1]</em>. We refer to their notation and definitions</p>

    <p class="text-gray-300">in this section. In their work, a generic knowledge extractor for <span class="math">\\Gamma</span>-out-of-<span class="math">\\mathcal{C}</span> special-sound protocols is presented. As they note, as long as the expected runtime of the generic knowledge extractor is polynomial, <span class="math">\\Gamma</span>-out-of-<span class="math">\\mathcal{C}</span> special soundness implies knowledge soundness. Although the generic extractor can be useful in many settings, we show that, for <span class="math">\\ell&gt;1,k&gt;0</span>, when the generic extractor runs to get a set of accepting challenges <span class="math">C\\in\\Gamma\\subseteq 2^{\\mathcal{C}}</span>, where <span class="math">\\mathcal{C}\\coloneqq S^{\\ell}</span> and</p>

    <p class="text-gray-300"><span class="math">\\Gamma\\coloneqq\\{C\\colon\\exists X\\in\\mathsf{SS}(S,\\ell,k),X\\subseteq C\\}\\enspace,</span></p>

    <p class="text-gray-300">it cannot output the witness in expected polynomial time. Notice that <span class="math">\\Gamma</span> denotes the monotone structure here.</p>

    <p class="text-gray-300">To that end, let us first recall two crucial definitions from <em>[x1]</em>: the set of useful elements and <span class="math">t</span>-value. Then, we prove a lower bound on <span class="math">t</span>-value, which gives us a lower bound for the expected runtime of the generic extractor.</p>

    <h6 id="sec-88" class="text-base font-medium mt-4">Definition 7.3 (Useful Elements, <em>[x1]</em>).</h6>

    <p class="text-gray-300">For a monotone structure <span class="math">(\\Gamma,\\mathcal{C})</span>, we define the following function:</p>

    <p class="text-gray-300"><span class="math">U_{\\Gamma}\\colon 2^{\\mathcal{C}}\\to 2^{\\mathcal{C}},S\\mapsto\\{c\\in\\mathcal{C}\\setminus S\\colon\\exists A\\in\\Gamma\\text{ s.t. }S\\subset A\\wedge A\\setminus\\{c\\}\\notin\\Gamma\\}\\enspace.</span></p>

    <h6 id="sec-89" class="text-base font-medium mt-4">Definition 7.4 (<span class="math">t</span>-value, <em>[x1]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">(\\Gamma,\\mathcal{C})</span> be a monotone structure and <span class="math">S\\subseteq\\mathcal{C}</span>. Then</p>

    <p class="text-gray-300">\\[ t_{\\Gamma}(S)\\coloneqq\\max\\left\\{t\\in\\mathbb{N}_{0}\\colon\\begin{array}[]{c}\\exists c_{1},\\dots,c_{t}\\in\\mathcal{C}\\text{ s.t.}\\\\ \\forall i,c_{i}\\in U_{\\Gamma}(S\\cup\\{c_{1},\\dots,c_{i-1}\\})\\end{array}\\right\\}\\enspace. \\]</p>

    <p class="text-gray-300">Further,</p>

    <p class="text-gray-300"><span class="math">t_{\\Gamma}\\coloneqq t_{\\Gamma}(\\emptyset)\\enspace.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma 5 from <em>[x1]</em> states that the expected runtime of the generic extractor is <span class="math">2t_{\\Gamma}-1</span>. Therefore, we need to find a bound for <span class="math">t_{\\Gamma}</span>. For simplicity, let <span class="math">k=2</span>. We claim that $t_{\\Gamma}\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\ell-1}+1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For <span class="math">d,d^{\\prime}\\in S,d\\neq d^{\\prime}</span>, and <span class="math">\\mathbf{v}=(v_{2},\\dots,v_{\\ell})\\in S^{\\ell-1}</span>, consider the sets</p>

    <p class="text-gray-300"><span class="math">\\mathcal{A}_{d}</span> <span class="math">\\coloneqq\\{\\mathbf{c}=(c_{1},\\dots,c_{\\ell})\\in\\mathcal{C}\\colon c_{1}=d\\}\\text{ and}</span> <span class="math">\\mathcal{B}_{d^{\\prime},\\mathbf{v}}</span> <span class="math">\\coloneqq\\{\\mathbf{c}=(c_{1},\\dots,c_{\\ell})\\in\\mathcal{C}\\colon c_{1}=d^{\\prime},\\exists\\mathbf{c}^{\\prime}\\in\\mathcal{A}_{d^{\\prime}},\\forall 2\\leq i\\leq\\ell,c^{\\prime}_{i}=v_{i}\\}\\enspace.</span></p>

    <p class="text-gray-300">We note that although <span class="math">\\mathcal{B}_{d^{\\prime},\\mathbf{v}}</span> has only one member, it is convenient for our proof to use set notation. Now, notice that <span class="math">t_{\\Gamma}</span> is defined on the longest possible sequence of challenges such that each challenge is in the set of useful elements of all the previous ones. We argue that, for <span class="math">d,d^{\\prime}\\in S,d\\neq d^{\\prime}</span>, and <span class="math">\\mathbf{v}=(v_{2},\\dots,v_{\\ell})\\in S^{\\ell-1}</span>, the sequence</p>

    <p class="text-gray-300"><span class="math">\\mathbf{c}_{1},\\dots,\\mathbf{c}_{t},\\quad\\forall i\\in[t-1],\\;\\mathbf{c}_{i}\\in\\mathcal{A}_{d},\\quad\\mathbf{c}_{t}\\in\\mathcal{B}_{d^{\\prime},\\mathbf{v}},</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">fulfills the mentioned conditions, where $t\\coloneqq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{A}_{d}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+1<span class="math">. This implies that </span>t_{\\Gamma}\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{A}_{d}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+1=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\ell-1}+1<span class="math">. We are left to prove that the specified sequence meets the constraint in the definition of </span>t_{\\Gamma}<span class="math">. First, observe that for </span>d,d^{\\prime}\\in S,d\\neq d^{\\prime}$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\forall\\mathbf{c}=(d,\\mathbf{v})\\in\\mathcal{A}_{d},\\quad\\mathcal{A}_{d}\\cup\\mathcal{B}_{d^{\\prime},\\mathbf{v}}\\in\\Gamma\\wedge\\mathcal{A}_{d}\\cup\\mathcal{B}_{d^{\\prime},\\mathbf{v}}\\setminus\\{\\mathbf{c}\\}\\notin\\Gamma\\enspace.</span></p>

    <p class="text-gray-300">Hence, <span class="math">\\mathcal{A}_{d}\\subseteq U_{\\Gamma}(\\emptyset)</span>. Similarly, for any <span class="math">T\\subseteq\\mathcal{A}_{d}</span>,</p>

    <p class="text-gray-300"><span class="math">\\forall\\mathbf{c}=(d,\\mathbf{v})\\in\\mathcal{A}_{d}\\setminus T,\\quad\\mathcal{A}_{d}\\cup\\mathcal{B}_{d^{\\prime},\\mathbf{v}}\\in\\Gamma\\wedge\\mathcal{A}_{d}\\cup\\mathcal{B}_{d^{\\prime},\\mathbf{v}}\\setminus\\{\\mathbf{c}\\}\\notin\\Gamma\\enspace.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">So, <span class="math">\\mathcal{A}_{d}\\setminus T\\subseteq U_{\\Gamma}(T)</span>. Finally, given that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{B}_{d^{\\prime},\\mathbf{v}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1<span class="math">, for any </span>\\mathbf{v}\\in S^{\\ell-1}$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathcal{A}_{d}\\cup\\mathcal{B}_{d^{\\prime},\\mathbf{v}}\\in\\Gamma\\wedge\\mathcal{A}_{d}\\notin\\Gamma\\enspace.</span></p>

    <p class="text-gray-300">Therefore, <span class="math">\\mathcal{B}_{d^{\\prime},\\mathbf{v}}\\subseteq U_{\\Gamma}(\\mathcal{A}_{d})</span>.</p>

    <p class="text-gray-300">In summary, we proved that the expected runtime of the generic extractor is exponential in <span class="math">\\ell</span>, while our extractor is linear in <span class="math">\\ell</span>. Consequently, we cannot prove knowledge soundness of the protocol by leveraging <span class="math">\\Gamma</span>-out-of-<span class="math">\\mathcal{C}</span> special soundness and the generic extractor.</p>

    <h2 id="sec-90" class="text-2xl font-bold">8 Knowledge Soundness of a Fiat-Shamir-transformed Coordinate-Wise Special-Sound Multi-Round Protocol</h2>

    <p class="text-gray-300">In this section, we show there is an efficient knowledge extractor for the non-interactive protocol obtained by applying Fiat-Shamir transformation on a <span class="math">\\ell</span>-coordinate-wise <span class="math">k</span>-special-sound multi-round protocol.</p>

    <p class="text-gray-300">In the following, we leverage the approach presented by Attema et al. <em>[x1]</em>. Namely, we define and analyze an abstract sampling game where the extractor plays the role of a sampler who tries to find “good” entries. In the meantime, we elaborate on how this game relates to knowledge extraction. For reference, we use notation from <em>[x1]</em>. Furthermore, we prove a slightly different version of Lemmata 2 and 5 from <em>[x1]</em> for our specific reprogramming of the random oracle. As Lemmata 3 and 6 from <em>[x1]</em> are independent of how random oracle gets reprogrammed, we only use them as they are.</p>

    <h3 id="sec-91" class="text-xl font-semibold mt-8">8.1 Analysis of the Abstract Sampling Game</h3>

    <p class="text-gray-300">Figure 12 shows the mentioned sampling game. Similar to <em>[x1]</em>, the sequence of <span class="math">j_{1},\\ldots,j_{U}\\in\\{1,\\ldots,N\\}^{\\ell}</span> specifies the function table of the random oracle. Notice that the cardinality of the input space of the random oracle is <span class="math">U</span>. Each entry of <span class="math">M</span> determines what the first message chosen by the deterministic prover would be and if it would be an accepting transcript. For a given sequence of <span class="math">j_{1},\\ldots,j_{U}</span>, we can extract when the following happens. First, <span class="math">M(j_{1},\\ldots,j_{U})=(1,i)</span> for some <span class="math">i\\in\\{1,\\ldots,U\\}</span>, and second, by reprogramming <span class="math">j_{i}</span> to some <span class="math">j^{\\prime}_{i}</span> (which is different from <span class="math">j_{i}</span> coordinate-wisely) for enough many times, <span class="math">M(j_{1},\\ldots,j^{\\prime}_{i},\\ldots,j_{U})=(1,i)</span>. In other words, the prover chooses the same first message when given each of these different functional tables of the random oracle, and by coordinate-wise special soundness, it is feasible to extract.</p>

    <p class="text-gray-300">Similar to <em>[x1]</em>, we define the functions <span class="math">a_{i},a_{i,l}:\\left(\\{1,\\ldots,N\\}^{\\ell}\\right)^{U}\\to\\mathbb{N}_{\\geq 0}</span> where</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$a_{i,l}:j\\mapsto\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{j^{\\prime}:\\left(\\forall(i^{\\prime},l^{\\prime})\\in[N]\\times[\\ell]\\setminus\\{(i,l)\\},j^{\\prime}_{i^{\\prime},l^{\\prime}}=j_{i^{\\prime},l^{\\prime}}\\right)\\wedge M(j^{\\prime})=(1,i)\\right\\}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\enspace\\text{and}$ (28)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The value of <span class="math">a_{i,l}(j)</span> shows how many “good” entries there are on a 1-dimensional subarray of <span class="math">M</span> where only <span class="math">j_{i,l}</span> is not fixed. Similarly, <span class="math">a_{i,l}(j)</span> determines how many “good” entries there are on a</p>

    <p class="text-gray-300">Parameters:  <span class="math">\\ell, k, N, U \\in \\mathbb{N}</span> , and a  <span class="math">U\\ell</span> -dimensional array  <span class="math">M</span>  with entries in  <span class="math">M(j_1, \\ldots, j_U) \\in \\{0, 1\\} \\times \\{1, \\ldots, U\\}</span>  for all tuples  <span class="math">j_1, \\ldots, j_U \\in \\{1, \\ldots, N\\}^\\ell</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample  <span class="math">(j_{1},\\ldots ,j_{U})\\in \\left(\\{1,\\ldots ,N\\}^{\\ell}\\right)^{U}</span>  uniformly at random and set  <span class="math">(v,i) = M(j_{1},\\dots ,j_{U})</span></li>

      <li>If  <span class="math">v = 0</span> , abort.</li>

      <li>Else, for  <span class="math">1 \\leq l \\leq \\ell</span> , repeat</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>sample  <span class="math">j_{l}^{\\prime}\\in \\{1,\\dots ,N\\} \\setminus \\{j_{i,l}\\}</span>  (without replacement),</li>

      <li>set  <span class="math">j&#x27; = (j_{i,1}, \\ldots, j_{i,l-1}, j_l&#x27;, j_{i,l+1}, \\ldots, j_{i,\\ell})</span></li>

      <li>compute  <span class="math">(v&#x27;, i&#x27;) = M(j_1, \\ldots, j_{i-1}, j&#x27;, j_{i+1}, \\ldots, j_U)</span> ,</li>

    </ul>

    <p class="text-gray-300">until either  <span class="math">k - 1</span>  additional entries equal to  <span class="math">(1, i)</span>  have been found or until all indices  <span class="math">j_{l}^{\\prime}</span>  have been tried.</p>

    <p class="text-gray-300">Figure 12: Abstract sampling game.</p>

    <p class="text-gray-300"><span class="math">\\ell</span> -dimensional subarray of  <span class="math">M</span>  where the entire tuple of  <span class="math">j_{i}</span>  is not fixed. Having these two functions, in the following lemma, we find two essential properties of this game: the probability of "success" and the expected runtime (i.e., number of samples).</p>

    <p class="text-gray-300">Lemma 8.1 (Abstract Sampling Game). Consider the game in Figure 12. Let  <span class="math">J = (J_{1},\\dots,J_{U})</span>  be uniformly distributed in  <span class="math">\\left(\\{1,\\ldots ,N\\}^{\\ell}\\right)^{U}</span> , indicating the first entry sampled, and let  <span class="math">(V,I) = M(J_1,\\ldots ,J_U)</span> . Further, for all  <span class="math">1\\leq i\\leq U</span>  and  <span class="math">1\\leq l\\leq \\ell</span> , let  <span class="math">A_{i,l} = a_{i,l}(J)</span>  and  <span class="math">A_{i} = a_{i}(J)</span> . Moreover, let  <span class="math">X</span>  be the number of entries of the form  <span class="math">(1,i)</span>  with  <span class="math">i = I</span>  sampled (including the first one), and let  <span class="math">\\varLambda</span>  be the total number of entries sampled in this game. Then,</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}\\left[\\varLambda\\right]\\leq 1+\\ell(k-1)P\\quad and</span></p>

    <p class="text-gray-300"><span class="math">\\operatorname<em>{Pr}\\left[X=k\\right]\\geq\\frac{N}{N-k+1}\\left(\\operatorname</em>{Pr}\\left[V=1\\right]-P\\cdot\\frac{\\ell(k-1)}{N}\\right)\\enspace,</span></p>

    <p class="text-gray-300">where  <span class="math">P = \\sum_{i=1}^{U} \\operatorname*{Pr}\\left[A_i &amp;gt; 0\\right]</span> .</p>

    <p class="text-gray-300">Proof (of Lemma 8.1). Expected Number of Samples. Let us first derive the upper bound on the expected value of  <span class="math">\\varLambda</span> . To this end, let  <span class="math">X_{l}^{\\prime}</span>  be the number of sampled entries of the form  <span class="math">(1,i)</span>  with  <span class="math">i = I</span>  in the  <span class="math">l^{th}</span>  iteration of the for loop. Similarly, let  <span class="math">Y_{l}^{\\prime}</span>  denote the number of sampled entries of the form  <span class="math">(v,i)</span>  with  <span class="math">v = 0</span>  or  <span class="math">i\\neq I</span> , again in the  <span class="math">l^{th}</span>  iteration. Then  <span class="math">\\varLambda=1+\\sum_{l=1}^{\\ell}X_{l}^{\\prime}+\\sum_{l=1}^{\\ell}Y_{l}^{\\prime}</span>  and for all  <span class="math">1\\leq l\\leq \\ell</span></p>

    <p class="text-gray-300"><span class="math">\\operatorname<em>{Pr}\\left[X_l&#x27; = 0 \\mid V = 0\\right] = \\operatorname</em>{Pr}\\left[Y_l&#x27; = 0 \\mid V = 0\\right] = 1</span>  .</p>

    <p class="text-gray-300">Hence, for all  <span class="math">1 \\leq l \\leq \\ell</span> ,  <span class="math">\\mathbb{E}[X_l&#x27; \\mid V = 0] = \\mathbb{E}[Y_l&#x27; \\mid V = 0] = 0</span> . Let us consider the expected value  <span class="math">\\mathbb{E}[Y_l&#x27; \\mid V = 1]</span>  for any  <span class="math">1 \\leq l \\leq \\ell</span> . Notice that, conditioned on the event  <span class="math">V = 1 \\wedge I = i \\wedge A_{i,l} = a</span>  with</p>

    <p class="text-gray-300"><span class="math">A_{i,l}=a&gt;0</span>, <span class="math">Y_{l}^{\\prime}</span> follows a negative hypergeometric distribution with parameters <span class="math">N-1</span>, <span class="math">a-1</span>, and <span class="math">k-1</span>. Hence, using Lemma 1 from <em>[x1]</em>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathbb{E}\\left[Y_{l}^{\\prime}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,V=1\\wedge I=i\\wedge A_{i,l}=a\\right.\\right]\\leq(k-1)\\frac{N-a}{a}\\enspace,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and thus, using that $\\Pr\\left[X_{l}^{\\prime}\\leq k-1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V=1\\right]=1$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathbb{E}\\left[X_{l}^{\\prime}+Y_{l}^{\\prime}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,V=1\\wedge I=i\\wedge A_{i,l}=a\\right.\\right]\\leq(k-1)+(k-1)\\frac{N-a}{a}=(k-1)\\frac{N}{a}\\enspace.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">On the other hand,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[V=1\\wedge I=i\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,A_{i,l}=a\\right.\\right]=\\frac{a}{N}\\enspace,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and thus,</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[V=1\\wedge I=i\\wedge A_{i,l}=a\\right]=\\Pr\\left[A_{i,l}=a\\right]\\frac{a}{N}\\enspace.</span> (30)</p>

    <p class="text-gray-300">Since <span class="math">\\Pr\\left[V=1\\wedge I=i\\wedge A_{i,l}=0\\right]=0</span>, we write</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[V=1\\right]\\cdot\\mathbb{E}\\left[X_{l}^{\\prime}+Y_{l}^{\\prime}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,V=1\\right.\\right]=<span class="math"> </span>\\sum_{i=1}^{U}\\sum_{a=1}^{N}\\Pr\\left[V=1\\wedge I=i\\wedge A_{i,l}=a\\right]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\leq\\sum_{i=1}^{U}\\sum_{a=1}^{N}\\Pr\\left<a href="k-1">A_{i,l}=a\\right</a></span> <span class="math">=(k-1)\\sum_{i=1}^{U}\\Pr\\left[A_{i,l}&gt;0\\right]\\enspace.</span></p>

    <p class="text-gray-300">Consequently,</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}\\left[\\Lambda\\right]</span> <span class="math">=\\mathbb{E}\\left[1+\\sum_{l=1}^{\\ell}(X_{l}^{\\prime}+Y_{l}^{\\prime})\\right]</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$=1+\\sum_{l=1}^{\\ell}\\left(\\Pr\\left[V=0\\right]\\cdot\\mathbb{E}\\left[X_{l}^{\\prime}+Y_{l}^{\\prime}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,V=0\\right.\\right]+\\Pr\\left[V=1\\right]\\cdot\\mathbb{E}\\left[X_{l}^{\\prime}+Y_{l}^{\\prime}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,V=1\\right.\\right]\\right)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\leq 1+(k-1)\\sum_{l=1}^{\\ell}\\sum_{i=1}^{U}\\Pr\\left[A_{i,l}&gt;0\\right]</span> <span class="math">\\leq 1+\\ell(k-1)\\sum_{i=1}^{U}\\Pr\\left[A_{i}&gt;0\\right]</span> <span class="math">\\leq 1+\\ell(k-1)P\\enspace,</span></p>

    <p class="text-gray-300">where we used the fact that for all <span class="math">1\\leq l\\leq\\ell</span>, <span class="math">\\Pr\\left[A_{i,l}&gt;0\\right]\\leq\\Pr\\left[A_{i}&gt;0\\right]</span>. Hence, the claimed upper bound on <span class="math">\\mathbb{E}\\left[\\Lambda\\right]</span> is proven.</p>

    <p class="text-gray-300">Success Probability. Success happens when for all <span class="math">1\\leq l\\leq\\ell</span>, we have <span class="math">X_{l}^{\\prime}=k-1</span>. For all <span class="math">1\\leq l\\leq\\ell</span>, let <span class="math">X_{l}</span> be the number of sampled entries of the form <span class="math">(1,i)</span> in the <span class="math">l^{th}</span> iteration of for loop and the single sampled entry outside of the loop. Notice that if <span class="math">V=1</span>, for all <span class="math">1\\leq l\\leq\\ell</span>, we have</p>

    <p class="text-gray-300"><span class="math">X_{l}\\geq 1</span> even if we do not sample any other entries of the form <span class="math">(1,i)</span> in the for loop. We are interested in finding a lower bound for <span class="math">\\Pr\\left[\\bigwedge_{l=1}^{\\ell}X_{l}=k\\right]</span>.</p>

    <p class="text-gray-300">For all <span class="math">1\\leq l\\leq\\ell</span>, <span class="math">V=0</span> implies <span class="math">X_{l}=0</span>. Therefore, using <span class="math">k&gt;0</span>, for all <span class="math">1\\leq l\\leq\\ell</span>, we write <span class="math">\\Pr\\left[X_{l}=k\\right]=\\Pr\\left[X_{l}=k\\wedge V=1\\right]</span> and <span class="math">\\Pr\\left[\\bigwedge_{l=1}^{\\ell}X_{l}=k\\right]=\\Pr\\left[\\bigwedge_{l=1}^{\\ell}X_{l}=k\\wedge V=1\\right]</span>. Therefore, we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[\\bigwedge_{l=1}^{\\ell}X_{l}=k\\,\\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,V=1\\right]<span class="math"> </span>=\\frac{\\Pr\\left[\\bigwedge_{l=1}^{\\ell}X_{l}=k\\right]}{\\Pr\\left[V=1\\right]}\\qquad\\text{and}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Furthermore, since we sample at most <span class="math">k-1</span> entries of the form <span class="math">(1,i)</span> in each iteration, we can write</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[\\bigwedge_{l=1}^{\\ell}X_{l}=k\\,\\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,V=1\\right]<span class="math"> </span>=\\left(1-\\Pr\\left[\\bigvee_{l=1}^{\\ell}X_{l}<k\\,\\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,V=1\\right]\\right)$</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">$=\\left(1-\\sum_{l=1}^{\\ell}\\left(1-\\Pr\\left[X_{l}=k\\,</td>

            <td class="px-3 py-2 border-b border-gray-700">\\,V=1\\right]\\right)\\right)$</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">=\\left(1-\\sum_{l=1}^{\\ell}\\left(1-\\frac{\\Pr\\left[X_{l}=k\\right]}{\\Pr\\left[V=1\\right]}\\right)\\right)\\enspace,</span> (32)</p>

    <p class="text-gray-300">where we obtain the first inequality by using a union bound. We need to find a lower bound on <span class="math">\\Pr\\left[X_{l}=k\\right]</span> for all <span class="math">1\\leq l\\leq\\ell</span>. Since we have Equation (30), we can reuse the bound shown by Attema et al. <em>[x1]</em>. Hence,</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[X_{l}=k\\right]</span> <span class="math">\\geq\\frac{N}{N-k+1}\\left(\\Pr\\left[V=1\\right]-P_{l}\\cdot\\frac{k-1}{N}\\right)\\enspace,</span></p>

    <p class="text-gray-300">where <span class="math">P_{l}=\\sum_{i=1}^{U}\\Pr\\left[A_{i,l}&gt;0\\right]</span>. By putting this bound back into Equation (32), we obtain</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[\\bigwedge_{l=1}^{\\ell}X_{l}=k\\,\\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,V=1\\right]<span class="math"> </span>\\geq\\left(1-\\sum_{l=1}^{\\ell}\\left(\\frac{P_{l}\\cdot(k-1)}{\\Pr\\left[V=1\\right]\\cdot(N-k+1)}-\\frac{k-1}{N-k+1}\\right)\\right)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\geq\\left(\\frac{N+(\\ell-1)(k-1)}{N-k+1}-\\frac{\\ell\\cdot P\\cdot(k-1)}{\\Pr\\left[V=1\\right]\\cdot(N-k+1)}\\right)</span> <span class="math">\\geq\\left(\\frac{N}{N-k+1}-\\frac{\\ell\\cdot P\\cdot(k-1)}{\\Pr\\left[V=1\\right]\\cdot(N-k+1)}\\right)</span> <span class="math">\\geq\\frac{N}{N-k+1}\\left(1-P\\frac{\\ell(k-1)}{\\Pr\\left[V=1\\right]\\cdot N}\\right)\\enspace,</span></p>

    <p class="text-gray-300">where <span class="math">P=\\sum_{i=1}^{U}\\Pr\\left[A_{i}&gt;0\\right]</span>. To get the second inequality, we use that for all <span class="math">1\\leq l\\leq\\ell</span>, <span class="math">\\Pr\\left[A_{i,l}&gt;0\\right]\\leq\\Pr\\left[A_{i}&gt;0\\right]</span>, and consequently, <span class="math">P_{l}\\leq P</span>. Also, <span class="math">(\\ell-1)(k-1)\\geq 0</span> leads us to the third inequality. Using Equation (31), we have</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\bigwedge_{l=1}^{\\ell}X_{l}=k\\right]</span> <span class="math">\\geq\\frac{N}{N-k+1}\\left(\\Pr\\left[V=1\\right]-P\\frac{\\ell(k-1)}{N}\\right)\\enspace,</span></p>

    <p class="text-gray-300">which completes the proof. ∎</p>

    <p class="text-gray-300">Lemma 8.1 states bounds that are sufficient for bounding the knowledge error and the runtime of the knowledge extractor in the case of a Fiat-Shamir-transformed <span class="math">\\Sigma</span>-protocol. However, as noted by Attema et al. <em>[x1]</em>, to show the knowledge extractor of a Fiat-Shamir-transformed multi-round protocol runs in expected polynomial time, we need a refined analysis of expected runtime of the game. The sub-tree knowledge extractor may have an expensive runtime <span class="math">\\Gamma</span> or a cheap runtime <span class="math">\\gamma</span>. We now prove a better bound on runtime for the weighted version of this game which models the cost of sub-tree extractors.</p>

    <h6 id="sec-93" class="text-base font-medium mt-4">Lemma 8.2 (Abstract Sampling Game - Weighted Version).</h6>

    <p class="text-gray-300">Consider the game in Figure 12, as well a cost function <span class="math">\\Gamma:\\left(\\{1,\\ldots,N\\}^{\\ell}\\right)^{U}\\to\\mathbb{R}_{\\geq 0}</span> and a constant cost <span class="math">\\gamma\\in\\mathbb{R}_{\\geq 0}</span>. Let <span class="math">J=(J_{1},...,J_{U})</span> be uniformly distributed in <span class="math">\\left(\\{1,\\ldots,N\\}^{\\ell}\\right)^{U}</span>, indicating the first entry sampled, and let <span class="math">(V,I)=M(J)</span>. Further, for all <span class="math">1\\leq i\\leq U</span>, let <span class="math">A_{i}=a_{i}(J)</span>, where the function <span class="math">a_{i}</span> is as defined in Equation (29).</p>

    <p class="text-gray-300">We define the cost of sampling an entry <span class="math">M(j)=(v,i)</span> with <span class="math">i=I</span> to be <span class="math">\\Gamma(j)</span> and the cost of an entry <span class="math">M(j)=(v,i)</span> with <span class="math">i\\neq I</span> to be <span class="math">\\gamma</span>. Let <span class="math">\\Delta</span> be the total cost of playing this game. Then</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}\\left[\\Delta\\right]\\leq(1+\\ell(k-1))\\cdot\\mathbb{E}\\left[\\Gamma(J)\\right]+\\ell(k-1)\\cdot T\\cdot\\gamma\\enspace,</span></p>

    <p class="text-gray-300">where <span class="math">T=\\sum_{i=1}^{U}\\Pr\\left[I\\neq i\\wedge A_{i}&gt;0\\right]\\leq P</span>.</p>

    <h6 id="sec-94" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let us break the cost <span class="math">\\Delta</span> down to <span class="math">\\Delta_{1}</span>, <span class="math">\\Delta_{2}</span>, and <span class="math">\\Delta_{3}</span>, defined as follows. <span class="math">\\Delta_{1}</span> denotes cost of sampling entries of the form <span class="math">(1,i)</span> with <span class="math">i=I</span>, and <span class="math">X_{l}</span> denotes the number of such entries in the <span class="math">l^{th}</span> iteration. Similarly, <span class="math">\\Delta_{2}</span> denotes cost of sampling entries of the form <span class="math">(0,i)</span> with <span class="math">i=I</span>, and <span class="math">Y_{l}</span> denotes the number of such entries in the <span class="math">l^{th}</span> iteration. Finally, <span class="math">\\Delta_{3}</span> denotes cost of <span class="math">(v,i)</span> where <span class="math">i\\neq I</span>, and <span class="math">Z_{l}</span> denotes the number of such entries in the <span class="math">l^{th}</span> iteration. We use <span class="math">\\Delta_{1,l}^{\\prime}</span> (resp. <span class="math">\\Delta_{2,l}^{\\prime}</span>) for denoting the part of <span class="math">\\Delta_{1}</span> (resp. <span class="math">\\Delta_{2}</span>) that is added during the <span class="math">l^{th}</span> iteration. Clearly, <span class="math">\\Delta=\\Delta_{1}+\\Delta_{2}+\\Delta_{3}</span>.</p>

    <p class="text-gray-300">For <span class="math">1\\leq i\\leq U</span> and <span class="math">1\\leq l\\leq\\ell</span>, let us write</p>

    <p class="text-gray-300"><span class="math">J_{i}^{*}=(J_{1},\\ldots,J_{i-1},J_{i+1},\\ldots,J_{U})\\enspace\\text{and }J_{i,l}^{\\dagger}=(J_{i,1},\\ldots,J_{i,l-1},J_{i,l+1},\\ldots,J_{i,\\ell})\\enspace\\enspace,</span></p>

    <p class="text-gray-300">which are respectively uniformly random with support <span class="math">\\{1,\\ldots,N\\}^{(U-1)\\ell}</span> and <span class="math">\\{1,\\ldots,N\\}^{\\ell-1}</span>. Moreover, for all <span class="math">1\\leq i\\leq U</span>, <span class="math">1\\leq l\\leq\\ell</span>,</p>

    <p class="text-gray-300"><span class="math">j^{<em>}</span> <span class="math">=(j_{1}^{</em>},\\ldots,j_{i-1}^{<em>},j_{i+1}^{</em>},\\ldots,j_{U}^{*})\\in\\{1,\\ldots,N\\}^{(U-1)\\ell}\\enspace,\\text{ and }</span> <span class="math">j^{\\dagger}</span> <span class="math">=(j_{1}^{\\dagger},\\ldots,j_{l-1}^{\\dagger},j_{l+1}^{\\dagger},\\ldots,j_{\\ell}^{\\dagger})\\in\\{1,\\ldots,N\\}^{\\ell-1}\\enspace,</span></p>

    <p class="text-gray-300">let <span class="math">\\Lambda(i,j^{*})</span> denote the event</p>

    <p class="text-gray-300"><span class="math">\\Lambda(i,j^{<em>})=[I=i\\wedge J_{i}^{</em>}=j^{*}]</span></p>

    <p class="text-gray-300">and <span class="math">\\Theta(i,j^{*},j^{\\dagger})</span> denote the event</p>

    <p class="text-gray-300"><span class="math">\\Theta(i,j^{<em>},j^{\\dagger})=[\\Lambda(i,j^{</em>})\\wedge J_{i,l}^{\\dagger}=j^{\\dagger}]\\enspace.</span></p>

    <p class="text-gray-300">Notice that conditioned on the event <span class="math">\\Lambda(i,j^{*})</span>, all samples are picked from subarray</p>

    <p class="text-gray-300"><span class="math">M\\left(j_{1}^{<em>},\\ldots,j_{i-1}^{</em>},\\cdot,j_{i+1}^{<em>},\\ldots,j_{U}^{</em>}\\right)\\enspace;</span></p>

    <p class="text-gray-300">the first one uniformly at random subject to the index <span class="math">I</span> being <span class="math">i</span>, and the remaining ones (if <span class="math">V = 1</span>) uniformly at random (without replacement) for each coordinate. Similarly, conditioned on the event <span class="math">\\Theta(i,j^{*},j^{\\dagger})</span>, the sampling process follows the same criteria, with samples drawn from subarray</p>

    <div class="my-4 text-center"><span class="math-block">M \\left(j _ {1} ^ {*}, \\dots , j _ {i - 1} ^ {*}, \\left(j _ {1} ^ {\\dagger}, \\dots , j _ {l - 1} ^ {\\dagger}, \\cdot , j _ {l + 1} ^ {\\dagger}, \\dots , j _ {\\ell} ^ {\\dagger}\\right), j _ {i + 1} ^ {*}, \\dots , j _ {U} ^ {*}\\right).</span></div>

    <p class="text-gray-300">Let us first look into <span class="math">\\mathbb{E}\\left[\\varDelta_1\\mid\\varLambda(i,j^<em>)\\right]</span>. We notice that for all <span class="math">i</span>, and <span class="math">j^{</em>}</span> with <span class="math">\\operatorname<em>{Pr}\\left[\\varLambda(i,j^{</em>})\\right] &amp;gt; 0</span></p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\mathbb {E} \\left[ \\Delta_ {1} \\mid \\Lambda (i, j ^ {<em>}) \\right] = \\Pr \\left[ V = 1 \\mid \\Lambda (i, j ^ {</em>}) \\right] \\cdot \\mathbb {E} \\left[ \\Delta_ {1} \\mid \\Lambda (i, j ^ {*}) \\wedge V = 1 \\right] \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\Pr \\left[ V = 0 \\mid \\Lambda (i, j ^ {<em>}) \\right] \\cdot \\mathbb {E} \\left[ \\Delta_ {1} \\mid \\Lambda (i, j ^ {</em>}) \\wedge V = 0 \\right] \\\\</li>

    </ul>

    <p class="text-gray-300">= \\Pr \\left[ V = 1 \\mid \\Lambda (i, j ^ {<em>}) \\right] \\cdot \\mathbb {E} \\left[ \\Delta_ {1} \\mid \\Lambda (i, j ^ {</em>}) \\wedge V = 1 \\right] \\\\ = \\Pr \\left[ V = 1 \\mid \\Lambda (i, j ^ {<em>}) \\right] \\cdot \\mathbb {E} \\left[ \\sum_ {l} \\Delta_ {1, l} ^ {\\prime} \\mid \\Lambda (i, j ^ {</em>}) \\wedge V = 1 \\right] \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\Pr \\left[ V = 1 \\mid \\Lambda (i, j ^ {<em>}) \\right] \\cdot \\mathbb {E} \\left[ \\Gamma (J) \\mid \\Lambda (i, j ^ {</em>}) \\wedge V = 1 \\right] \\\\</li>

    </ul>

    <p class="text-gray-300">= \\sum_ {l} \\left(\\Pr \\left[ V = 1 \\mid \\Lambda (i, j ^ {<em>}) \\right] \\cdot \\mathbb {E} \\left[ \\Delta_ {1, l} ^ {\\prime} \\mid \\Lambda (i, j ^ {</em>}) \\wedge V = 1 \\right]\\right) \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\Pr \\left[ V = 1 \\mid \\Lambda (i, j ^ {<em>}) \\right] \\cdot \\mathbb {E} \\left[ \\Gamma (J) \\mid \\Lambda (i, j ^ {</em>}) \\wedge V = 1 \\right] \\\\</li>

    </ul>

    <p class="text-gray-300">= \\sum_ {l} \\mathbb {E} \\left[ \\Delta_ {1, l} ^ {\\prime} \\mid \\Lambda (i, j ^ {*}) \\right] \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\Pr \\left[ V = 1 \\mid \\Lambda (i, j ^ {<em>}) \\right] \\cdot \\mathbb {E} \\left[ \\Gamma (J) \\mid \\Lambda (i, j ^ {</em>}) \\wedge V = 1 \\right]. \\tag {33}</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">In the above, we use linearity of expectation and <span class="math">\\mathbb{E}\\left[\\varDelta_{1,l}^{\\prime}\\mid\\varLambda(i,j^{*})\\wedge V=0\\right] = 0</span>. Moreover, by conditioning on the value of <span class="math">X_{l}</span>, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {E} \\left[ \\Delta_ {1, l} ^ {\\prime} \\mid \\Lambda (i, j ^ {*}) \\right] = \\sum_ {x _ {l} = 0} ^ {N - 1} \\Pr \\left[ X _ {l} = x _ {l} \\mid \\Lambda (i, j ^ {*}) \\right] \\cdot \\mathbb {E} \\left[ \\Delta_ {1, l} ^ {\\prime} \\mid \\Lambda (i, j ^ {*}) \\wedge X _ {l} = x _ {l} \\right]. \\tag {34}</span></div>

    <p class="text-gray-300">Also,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbb {E} \\left[ \\Delta_ {1, l} ^ {\\prime} \\mid \\Lambda (i, j ^ {*}) \\wedge X _ {l} = x _ {l} \\right] = \\\\ \\sum_ {j ^ {\\dagger}} \\Pr \\left[ J _ {i, l} ^ {\\dagger} = j ^ {\\dagger} \\mid \\Lambda (i, j ^ {*}) \\wedge X _ {l} = x _ {l} \\right] \\cdot \\mathbb {E} \\left[ \\Delta_ {1, l} ^ {\\prime} \\mid \\Theta (i, j ^ {*}, j ^ {\\dagger}) \\wedge X _ {l} = x _ {l} \\right]. \\tag {35} \\end{array}</span></div>

    <p class="text-gray-300">Let us try to understand <span class="math">\\mathbb{E}\\left[\\Delta_{1,l}^{\\prime}\\mid \\Theta (i,j^{<em>},j^{\\dagger})\\wedge X_{l} = x_{l}\\right]</span>. The condition means that we are sampling only on coordinate <span class="math">l</span>, the rest of the tuple is fixed on <span class="math">j^{\\dagger}</span>, and we sample <span class="math">x_{l}</span> entries of the form <span class="math">(1,i)</span>. In other words, we are looking for a subset of entries of the form <span class="math">(1,i)</span> with size <span class="math">x_{l}</span>, and also, since <span class="math">J</span> is not fixed, the sampling process is uniform among such entries. Notice that the probability of choosing any of them is <span class="math">x_{l}</span> times bigger than the probability of choosing the same entry when the size of a subset was one. Therefore, the expected total cost is <span class="math">x_{l}</span> times the expected cost of sampling only one such entry. We can write the expected cost of only one such entry as <span class="math">\\mathbb{E}\\left[\\Gamma (J)\\mid \\Theta (i,j^{</em>},j^{\\dagger})\\wedge V = 1\\right]</span>. So, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {E} \\left[ \\Delta_ {1, l} ^ {\\prime} \\mid \\Theta (i, j ^ {*}, j ^ {\\dagger}) \\wedge X _ {l} = x _ {l} \\right] = \\mathbb {E} \\left[ \\Gamma (J) \\mid \\Theta (i, j ^ {*}, j ^ {\\dagger}) \\wedge V = 1 \\right] \\cdot x _ {l}.</span></div>

    <p class="text-gray-300">Putting this expression back into Equation (35) and Equation (34), we get</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {E} \\left[ \\Delta_ {1, l} ^ {\\prime} \\mid \\Lambda (i, j ^ {*}) \\right] = \\mathbb {E} \\left[ X _ {l} \\mid \\Lambda (i, j ^ {*}) \\right] \\cdot \\mathbb {E} \\left[ \\Gamma (J) \\mid \\Lambda (i, j ^ {*}) \\wedge V = 1 \\right]. \\tag {36}</span></div>

    <p class="text-gray-300">Similarly, for  <span class="math">\\varDelta_{2}</span> , we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbb {E} \\left[ \\Delta_ {2} \\mid \\Lambda (i, j ^ {*}) \\right] = \\sum_ {l} \\mathbb {E} \\left[ \\Delta_ {2, l} ^ {\\prime} \\mid \\Lambda (i, j ^ {*}) \\right] + \\\\ \\Pr \\left[ V = 0 \\mid \\Lambda (i, j ^ {*}) \\right] \\cdot \\mathbb {E} \\left[ \\Gamma (J) \\mid \\Lambda (i, j ^ {*}) \\wedge V = 0 \\right] \\quad \\text {and} \\tag {37} \\\\ \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {E} \\left[ \\Delta_ {2, l} ^ {\\prime} \\mid \\Lambda (i, j ^ {*}) \\right] = \\mathbb {E} \\left[ Y _ {l} \\mid \\Lambda (i, j ^ {*}) \\right] \\cdot \\mathbb {E} \\left[ \\Gamma (J) \\mid \\Lambda (i, j ^ {*}) \\wedge V = 0 \\right]. \\tag {38}</span></div>

    <p class="text-gray-300">Now, our goal is to upper bound  <span class="math">\\mathbb{E}\\left[X_l\\mid \\varLambda (i,j^<em>)\\right]</span>  and  <span class="math">\\mathbb{E}\\left[Y_l\\mid \\varLambda (i,j^</em>)\\right]</span> . Knowing that  <span class="math">V = 0</span>  implies  <span class="math">X_{l} = 0</span>  and  <span class="math">V = 1</span>  implies  <span class="math">X_{l}\\leq k</span> , we write</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbb {E} \\left[ X _ {l} \\mid \\Lambda (i, j ^ {*}) \\right] = \\Pr \\left[ V = 0 \\mid \\Lambda (i, j ^ {*}) \\right] \\cdot \\mathbb {E} \\left[ X _ {l} \\mid \\Lambda (i, j ^ {*}) \\wedge V = 0 \\right] \\\\ + \\Pr \\left[ V = 1 \\mid \\Lambda (i, j ^ {*}) \\right] \\cdot \\mathbb {E} \\left[ X _ {l} \\mid \\Lambda (i, j ^ {*}) \\wedge V = 1 \\right] \\\\ \\leq (k - 1) \\cdot \\Pr \\left[ V = 1 \\mid \\Lambda (i, j ^ {*}) \\right]. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Hence, and using Equation (33) and Equation (36), we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbb {E} \\left[ \\Delta_ {1} \\mid \\Lambda (i, j ^ {*}) \\right] \\leq \\sum_ {l} (k - 1) \\cdot \\Pr \\left[ V = 1 \\mid \\Lambda (i, j ^ {*}) \\right] \\cdot \\mathbb {E} \\left[ \\Gamma (J) \\mid \\Lambda (i, j ^ {*}) \\wedge V = 1 \\right] \\\\ + \\Pr \\left[ V = 1 \\mid \\Lambda (i, j ^ {*}) \\right] \\cdot \\mathbb {E} \\left[ \\Gamma (J) \\mid \\Lambda (i, j ^ {*}) \\wedge V = 1 \\right] \\\\ \\leq (1 + \\ell (k - 1)) \\cdot \\Pr [ V = 1 \\mid \\Lambda (i, j ^ {*}) ] \\cdot \\mathbb {E} [ \\Gamma (J) \\mid \\Lambda (i, j ^ {*}) \\wedge V = 1 ]. \\tag {39} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Bounding  <span class="math">\\mathbb{E}\\left[Y_l\\mid \\varLambda (i,j^<em>)\\right]</span>  is more involved and we need to leverage the functions defined in Equation (28) and Equation (29). For the fixed choice of the index  <span class="math">1\\leq i\\leq U</span>  and of  <span class="math">j^{</em>} = (j_{1}^{<em>},\\ldots ,j_{i - 1}^{</em>},j_{i + 1}^{<em>},\\ldots ,j_{U}^{</em>})\\in \\{1,\\dots ,N\\}^{\\ell (U - 1)}</span> , and for all  <span class="math">1\\leq l\\leq \\ell</span>  and  <span class="math">j^{\\dagger}\\in \\{1,\\dots ,N\\}^{\\ell -1}</span> , we define new parameters</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a := \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{j: (v _ {j}, i _ {j}) = M (j _ {1} ^ {<em>}, \\dots , j _ {i - 1} ^ {</em>}, j, j _ {i + 1} ^ {<em>}, \\dots , j _ {U} ^ {</em>}) = (1, i) \\right\\} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b := \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{j: (v _ {j}, i _ {j}) = M (j _ {1} ^ {<em>}, \\ldots , j _ {i - 1} ^ {</em>}, j, j _ {i + 1} ^ {<em>}, \\ldots , j _ {U} ^ {</em>}) = (0, i) \\right\\} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a _ {l, j ^ {\\dagger}} := \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{j: (v _ {j}, i _ {j}) = M \\left( \\begin{array}{c} j _ {1} ^ {<em>}, \\ldots , j _ {i - 1} ^ {</em>}, \\\\ \\left( \\begin{array}{c} j _ {1} ^ {\\dagger}, \\ldots , j _ {l - 1} ^ {\\dagger}, \\\\ j, \\end{array} \\right), \\\\ j _ {l + 1} ^ {\\dagger}, \\ldots , j _ {\\ell} ^ {\\dagger} \\end{array} \\right), j _ {i + 1} ^ {<em>}, \\ldots , j _ {U} ^ {</em>}\\right) = (1, i) \\right\\} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\text { and}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b _ {l, j ^ {\\dagger}} := \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{j: \\left(v _ {j}, i _ {j}\\right) = M \\left( \\begin{array}{c} j _ {1} ^ {<em>}, \\dots , j _ {i - 1} ^ {</em>}, \\\\ \\left( \\begin{array}{c} j _ {1} ^ {\\dagger}, \\dots , j _ {l - 1} ^ {\\dagger}, \\\\ j, \\end{array} \\right), \\\\ j _ {l + 1} ^ {\\dagger}, \\dots , j _ {\\ell} ^ {\\dagger} \\end{array} \\right), j _ {i + 1} ^ {<em>}, \\dots , j _ {U} ^ {</em>}\\right) = (0, i) \\right\\} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">. \\tag {40}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Notice that  <span class="math">\\operatorname<em>{Pr}\\left[V = 1\\mid \\varLambda (i,j^{</em>})\\right] = \\frac{a}{a + b}</span>  and  <span class="math">\\operatorname<em>{Pr}\\left[V = 0\\mid \\varLambda (i,j^{</em>})\\right] = \\frac{b}{a + b}</span>  for all  <span class="math">i</span>  and  <span class="math">j^{<em>}</span>  with  <span class="math">\\operatorname</em>{Pr}\\left[\\varLambda (i,j^{<em>})\\right] &amp;gt; 0</span> . Observe that if we condition on the event  <span class="math">V = 1\\wedge \\varLambda (i,j^{</em>})</span>  (resp.  <span class="math">V = 1\\wedge \\Theta (i,j^{*},j^{\\dagger}))</span> , we</p>

    <p class="text-gray-300">80</p>

    <p class="text-gray-300">implicitly assume that <span class="math"> a &amp;gt; 0 </span> (resp. <span class="math"> a_{l,j^{\\dagger}} &amp;gt; 0 </span>). Moreover, <span class="math"> \\sum_{j^{\\dagger}} a_{l,j^{\\dagger}} = a </span> and <span class="math"> \\sum_{j^{\\dagger}} b_{l,j^{\\dagger}} = b </span>. Using the fact that <span class="math"> \\mathbb{E}[Y_l \\mid V = 0 \\land \\Lambda(i,j^*)] = 0 </span>, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {E} \\left[ Y _ {l} \\mid \\Lambda (i, j ^ {*}) \\right] = \\frac {a}{a + b} \\cdot \\mathbb {E} \\left[ Y _ {l} \\mid V = 1 \\wedge \\Lambda (i, j ^ {*}) \\right].</span></div>

    <p class="text-gray-300">Conditioned on <span class="math"> V = 1 \\wedge \\Theta(i, j^*, j^\\dagger) </span>, <span class="math"> Y_l </span> follows a negative hypergeometric distribution with parameters <span class="math"> a + b - 1 </span>, <span class="math"> a - 1 </span>, and <span class="math"> k - 1 </span>. We write</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\mathbb {E} \\left[ Y _ {l} \\mid V = 1 \\wedge \\Lambda (i, j ^ {*}) \\right] &amp;amp;= \\sum_ {j ^ {\\dagger}} \\Pr \\left[ J _ {i, l} ^ {\\dagger} = j ^ {\\dagger} \\mid V = 1 \\wedge \\Lambda (i, j ^ {*}) \\right] \\cdot \\mathbb {E} \\left[ Y _ {l} \\mid V = 1 \\wedge \\Theta (i, j ^ {*}, j ^ {\\dagger}) \\right] \\\\ &amp;amp;= \\sum_ {j ^ {\\dagger}} \\frac {a _ {l , j ^ {\\dagger}}}{a} \\cdot \\mathbb {E} \\left[ Y _ {l} \\mid V = 1 \\wedge \\Theta (i, j ^ {*}, j ^ {\\dagger}) \\right] \\\\ &amp;amp;\\leq \\sum_ {j ^ {\\dagger}} \\frac {a _ {l , j ^ {\\dagger}}}{a} \\cdot (k - 1) \\frac {b _ {l , j ^ {\\dagger}}}{a _ {l , j ^ {\\dagger}}} \\quad (\\text{by [AFK22, Lemma 1]}) \\\\ &amp;amp;= (k - 1) \\frac {b}{a}. \\end{aligned}</span></div>

    <p class="text-gray-300">This implies that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {E} \\left[ Y _ {l} \\mid \\Lambda (i, j ^ {*}) \\right] \\leq (k - 1) \\cdot \\Pr \\left[ V = 0 \\mid \\Lambda (i, j ^ {*}) \\right].</span></div>

    <p class="text-gray-300">Using Equation (37) and Equation (38), we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\mathbb {E} \\left[ \\Delta_ {2} \\mid \\Lambda (i, j ^ {*}) \\right] &amp;amp;\\leq \\sum_ {l} (k - 1) \\cdot \\Pr \\left[ V = 0 \\mid \\Lambda (i, j ^ {*}) \\right] \\cdot \\mathbb {E} \\left[ \\Gamma (J) \\mid \\Lambda (i, j ^ {*}) \\wedge V = 0 \\right] \\\\ &amp;amp;\\quad + \\Pr \\left[ V = 0 \\mid \\Lambda (i, j ^ {*}) \\right] \\cdot \\mathbb {E} \\left[ \\Gamma (J) \\mid \\Lambda (i, j ^ {*}) \\wedge V = 0 \\right] \\\\ &amp;amp;\\leq (1 + \\ell (k - 1)) \\cdot \\Pr \\left[ V = 0 \\mid \\Lambda (i, j ^ {*}) \\right] \\cdot \\mathbb {E} \\left[ \\Gamma (J) \\mid \\Lambda (i, j ^ {*}) \\wedge V = 0 \\right]. \\end{aligned}</span></div>

    <p class="text-gray-300">Combining with Equation (39), we have</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {E} \\left[ \\Delta_ {1} + \\Delta_ {2} \\mid \\Lambda (i, j ^ {*}) \\right] \\leq (1 + \\ell (k - 1)) \\cdot \\mathbb {E} \\left[ \\Gamma (J) \\mid \\Lambda (i, j ^ {*}) \\right].</span></div>

    <p class="text-gray-300">We can remove the condition <span class="math"> \\Lambda(i, j^<em>) </span> since this inequality holds for all <span class="math"> i </span> and <span class="math"> j^</em> </span> with <span class="math"> \\operatorname{Pr}[\\Lambda(i, j^*)] &amp;gt; 0 </span>. Therefore,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {E} \\left[ \\Delta_ {1} + \\Delta_ {2} \\right] \\leq (1 + \\ell (k - 1)) \\cdot \\mathbb {E} \\left[ \\Gamma (J) \\right].</span></div>

    <p class="text-gray-300">The final step is to show <span class="math"> \\mathbb{E}[\\Delta_3] \\leq \\ell(k - 1)T\\gamma </span>, or equivalently, <span class="math"> \\mathbb{E}[Z] \\leq \\ell(k - 1)T </span>, where <span class="math"> Z = \\sum_{l} Z_l </span>. Again, we follow the approach we used previously. We fix a choice of <span class="math"> i </span> and <span class="math"> j^<em> </span> and set the parameters <span class="math"> a, b, a_{l,j^\\dagger} </span>, and <span class="math"> b_{l,j^\\dagger} </span> as defined in Equation (40). Consequently, we observe that conditioning on the event <span class="math"> V = 1 \\wedge \\Theta(i,j^</em>,j^\\dagger) </span>, <span class="math"> Z_l </span> follows a negative hypergeometric distribution with parameters <span class="math"> N - b - 1 </span>, <span class="math"> a - 1 </span>, and <span class="math"> k - 1 </span>. Therefore, using the bound in Lemma 1 from [AFK22], we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\mathbb {E} \\left[ Z _ {l} \\mid V = 1 \\wedge \\Lambda (i, j ^ {*}) \\right] &amp;amp;= \\sum_ {j ^ {\\dagger}} \\Pr \\left[ J _ {i, l} ^ {\\dagger} = j ^ {\\dagger} \\mid V = 1 \\wedge \\Lambda (i, j ^ {*}) \\right] \\cdot \\mathbb {E} \\left[ Z _ {l} \\mid V = 1 \\wedge \\Theta (i, j ^ {*}, j ^ {\\dagger}) \\right] \\\\ &amp;amp;= \\sum_ {j ^ {\\dagger}} \\frac {a _ {l , j ^ {\\dagger}}}{a} \\cdot \\mathbb {E} \\left[ Y _ {l} \\mid V = 1 \\wedge \\Theta (i, j ^ {*}, j ^ {\\dagger}) \\right] \\end{aligned}</span></div>

    <p class="text-gray-300"><span class="math">\\leq\\sum_{j^{\\dagger}}\\frac{a_{l,j^{\\dagger}}}{a}\\cdot(k-1)\\frac{N-a_{l,j^{\\dagger}}-b_{l,j^{\\dagger}}}{a_{l,j^{\\dagger}}}</span> <span class="math">=(k-1)\\frac{N-a-b}{a}\\enspace.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Also, since $\\mathbb{E}\\left[Z_{l}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,V=0\\wedge\\Lambda(i,j^{*})\\right]=0$, we write</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathbb{E}\\left[Z_{l}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\Lambda(i,j^{*})\\right]\\leq\\frac{a}{a+b}\\cdot\\mathbb{E}\\left[Z_{l}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,V=1\\wedge\\Lambda(i,j^{*})\\right]=(k-1)\\frac{N-a-b}{a+b}\\enspace.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Using $\\Pr\\left[I=i\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,J_{i}^{<em>}=j^{</em>}\\right]=\\frac{a+b}{N}$, we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathbb{E}\\left[Z_{l}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\Lambda(i,j^{<em>})\\right]\\leq(k-1)\\cdot\\left(\\frac{\\Pr\\left[I\\neq i\\wedge J_{i}^{</em>}=j^{<em>}\\right]}{\\Pr\\left[\\Lambda(i,j^{</em>})\\right]}\\right)\\enspace,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and since <span class="math">Z=\\sum_{l}Z_{l}</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathbb{E}\\left[\\Delta_{3}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\Lambda(i,j^{<em>})\\right]\\leq\\ell(k-1)\\gamma\\cdot\\left(\\frac{\\Pr\\left[I\\neq i\\wedge J_{i}^{</em>}=j^{<em>}\\right]}{\\Pr\\left[\\Lambda(i,j^{</em>})\\right]}\\right)\\enspace.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">From this point, using the exact same argument by Attema et al. <em>[x1, Lemma 5]</em>, we have <span class="math">\\mathbb{E}\\left[\\Delta_{3}\\right]\\leq\\ell(k-1)\\cdot\\gamma\\cdot T</span>, and the proof is complete. ∎</p>

    <p class="text-gray-300">Now, the analysis of the game is complete, and we move forward to knowledge extraction.</p>

    <h3 id="sec-95" class="text-xl font-semibold mt-8">8.2 The Knowledge Extractor</h3>

    <p class="text-gray-300">This section introduces our knowledge extractor for a Fiat-Shamir-transformed <span class="math">\\ell</span>-coordinate-wise <span class="math">k</span>-special-sound <span class="math">\\Sigma</span>-protocol. One can generalize this extractor for multi-round protocols as done by Attema et al. <em>[x1, Section 6]</em>. In the following, we use the notation of Section 4 from <em>[x1]</em>. Figure 13 demonstrates our knowledge extractor <span class="math">\\mathcal{E}</span>. Instead of, for example, answering the query on the first message with a fresh random value in <span class="math">\\mathcal{C}\\coloneqq S^{\\ell}</span>, <span class="math">\\mathcal{E}</span> uses new values coordinate by coordinate. Notice that this manner of answering query on the first message is analogous to our abstract sampling game in Figure 12.</p>

    <p class="text-gray-300">Having Lemmata 8.1 and 8.2 along with <em>[x1, Lemmata 3 and 6]</em> at hand, and using the bounds in Section 7, we deduce that the knowledge error and the expected runtime of the extractor for a <span class="math">\\ell</span>-coordinate-wise <span class="math">k</span>-special-sound multi-round protocol degrades by a factor of <span class="math">Q+1</span> after applying Fiat-Shmair transformation, and it is independent from the number of rounds.</p>

    <p class="text-gray-300">We note that one can easily generalize this conclusion for a <span class="math">(\\ell_{1},\\ldots,\\ell_{\\mu})</span>-coordinate-wise <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special-sound <span class="math">(2\\mu+1)</span>-move protocol and the corresponding Fiat-Shamir-transformed protocol. We omit the details here because they do not contain any novel aspects.</p>

    <h2 id="sec-96" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[ACK21] Thomas Attema, Ronald Cramer, and Lisa Kohl. “A Compressed <span class="math">\\Sigma</span>-Protocol Theory for Lattices”. In: CRYPTO (2). Vol. 12826. Lecture Notes in Computer Science. Springer, 2021, pp. 549–579.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run  <span class="math">\\mathcal{A}</span>  to get  <span class="math">(I, y_1, v)</span>  in the following manner: answer all (distinct) random oracle queries with uniformly random values in  <span class="math">\\mathcal{C} \\coloneqq S^\\ell</span> . Set  <span class="math">i \\coloneqq I</span> , let  <span class="math">c_i</span>  be the response to query  <span class="math">i</span> .</li>

      <li>If  <span class="math">v = 0</span> , abort.</li>

      <li>Else, for  <span class="math">1 \\leq l \\leq \\ell</span> , repeat</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>sample  <span class="math">c_{i,l}^{\\prime} \\in S \\setminus \\{c_{i,l}\\}</span>  (without replacement),</li>

      <li>set  <span class="math">c_{i}^{\\prime} = \\left(c_{i,1},\\ldots ,c_{i,l - 1},c_{i,l}^{\\prime},c_{i,l + 1},\\ldots ,c_{i,\\ell}\\right)</span></li>

      <li>run  <span class="math">\\mathcal{A}</span>  to get  <span class="math">(I&#x27;, y&#x27;, v&#x27;)</span>  in the following manner: answer the query to  <span class="math">i</span>  with  <span class="math">c_i&#x27;</span> , while answering all other queries consistently if the query was performed by  <span class="math">\\mathcal{A}</span>  already on a previous run, and otherwise, with a fresh random value in  <span class="math">\\mathcal{C}</span> .</li>

    </ul>

    <p class="text-gray-300">until either  <span class="math">k - 1</span>  additional challenges with  <span class="math">v&#x27; = 1</span>  and  <span class="math">I&#x27; = I</span>  have been found or until all challenges  <span class="math">c_{i,l}&#x27; \\in S</span>  have been tried.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If the former happens for all  <span class="math">1 \\leq l \\leq \\ell</span> , output the  <span class="math">\\ell(k - 1) + 1</span>  accepting transcripts  <span class="math">y_1, \\ldots, y_{\\ell(k - 1) + 1}</span> .</li>

    </ul>

    <p class="text-gray-300">Figure 13: Knowledge Extractor  <span class="math">\\mathcal{E}</span> .</p>

    <p class="text-gray-300">[ACLMT22] Martin R. Albrecht, Valerio Cini, Russell W. F. Lai, Giulio Malavolta, and Sri Aravinda Krishnan Thyagarajan. "Lattice-Based SNARKs: Publicly Verifiable, Preprocessing, and Recursively Composable - (Extended Abstract)". In: CRYPTO (2). Vol. 13508. Lecture Notes in Computer Science. Springer, 2022, pp. 102-132. [ADPS16] Erdem Alkim, Léo Ducas, Thomas Pöppelmann, and Peter Schwabe. "Post-quantum Key Exchange - A New Hope". In: USENIX Security Symposium. USENIX Association, 2016, pp. 327-343. [AF22] Thomas Attema and Serge Fehr. “Parallel Repetition of  <span class="math">(k_{1},\\ldots ,k_{\\mu})</span> -Special-Sound Multi-Round Interactive Proofs”. In: CRYPTO (1). Vol. 13507. Lecture Notes in Computer Science. Springer, 2022, pp. 415-443. [AFK22] Thomas Attema, Serge Fehr, and Michael Kloos. Fiat-Shamir Transformation of Multi-round Interactive Proofs. 2022. [AFLN23] Martin R. Albrecht, Giacomo Fenzi, Oleksandra Lapiha, and Ngoc Khanh Nguyen. SLAP: Succinct Lattice-Based Polynomial Commitments from Standard Assumptions. Cryptology ePrint Archive, Paper 2023/1469. https://eprint.iacr.org/2023/1469. 2023. URL: https://eprint.iacr.org/2023/1469. [AFR23] Thomas Attema, Serge Fehr, and Nicolas Resch. A Generalized Special-Soundness Notion and its Knowledge Extractors. Cryptology ePrint Archive, Paper 2023/818. https://eprint.iacr.org/2023/818. 2023. URL: https://eprint.iacr.org/2023/818.</p>

    <p class="text-gray-300">[AKSY22] Shweta Agrawal, Elena Kirshanova, Damien Stehlé, and Anshu Yadav. “Practical, Round-Optimal Lattice-Based Blind Signatures”. In: CCS. ACM, 2022, pp. 39–53.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AL21] Martin R. Albrecht and Russell W. F. Lai. “Subtractive Sets over Cyclotomic Rings - Limits of Schnorr-Like Arguments over Lattices”. In: CRYPTO (2). Vol. 12826. Lecture Notes in Computer Science. Springer, 2021, pp. 519–548.</li>

      <li>[ALS20] Thomas Attema, Vadim Lyubashevsky, and Gregor Seiler. “Practical Product Proofs for Lattice Commitments”. In: CRYPTO (2). Vol. 12171. Lecture Notes in Computer Science. Springer, 2020, pp. 470–499.</li>

      <li>[Ajt96] Miklós Ajtai. “Generating hard instances of lattice problems”. In: Proceedings of the 28th Annual ACM Symposium on the Theory of Computing. STOC ’96. 1996, pp. 99–108.</li>

      <li>[Att23] Thomas Attema. Compressed Sigma-protocol theory. PhD Thesis. 2023. url: https://scholarlypublications.universiteitleiden.nl/access/item%3A3619598/view.</li>

      <li>[BBBPWM18] Benedikt Bünz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Gregory Maxwell. “Bulletproofs: Short Proofs for Confidential Transactions and More”. In: IEEE Symposium on Security and Privacy. 2018, pp. 315–334.</li>

      <li>[BBCPGL18] Carsten Baum, Jonathan Bootle, Andrea Cerulli, Rafaël del Pino, Jens Groth, and Vadim Lyubashevsky. “Sub-linear Lattice-Based Zero-Knowledge Arguments for Arithmetic Circuits”. In: CRYPTO. 2018, pp. 669–699.</li>

      <li>[BBHR19] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. “Scalable Zero Knowledge with No Trusted Setup”. In: Proceedings of the 39th Annual International Cryptology Conference. CRYPTO ’19. 2019, pp. 733–764.</li>

      <li>[BCCGP16] Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe Petit. “Efficient Zero-Knowledge Arguments for Arithmetic Circuits in the Discrete Log Setting”. In: EUROCRYPT. 2016, pp. 327–357.</li>

      <li>[BCFL22] David Balbás, Dario Catalano, Dario Fiore, and Russell W. F. Lai. Functional Commitments for Circuits from Falsifiable Assumptions. Cryptology ePrint Archive, Paper 2022/1365. https://eprint.iacr.org/2022/1365. 2022. url: https://eprint.iacr.org/2022/1365.</li>

      <li>[BCHO22] Jonathan Bootle, Alessandro Chiesa, Yuncong Hu, and Michele Orrù. “Gemini: Elastic SNARKs for Diverse Environments”. In: Proceedings of the 41st Annual International Conference on the Theory and Applications of Cryptographic Techniques. EUROCRYPT ’22. 2022, pp. 427–457.</li>

      <li>[BCIOP13] Nir Bitansky, Alessandro Chiesa, Yuval Ishai, Rafail Ostrovsky, and Omer Paneth. “Succinct Non-Interactive Arguments via Linear Interactive Proofs”. In: Proceedings of the 10th Theory of Cryptography Conference. TCC ’13. 2013, pp. 315–333.</li>

      <li>[BCKLN14] Fabrice Benhamouda, Jan Camenisch, Stephan Krenn, Vadim Lyubashevsky, and Gregory Neven. “Better Zero-Knowledge Proofs for Lattice Encryption and Their Application to Group Signatures”. In: ASIACRYPT. 2014, pp. 551–572.</li>

      <li>[BCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. “Interactive Oracle Proofs”. In: Proceedings of the 14th Theory of Cryptography Conference. TCC ’16-B. 2016, pp. 31–60.</li>

      <li>[BCS21] Jonathan Bootle, Alessandro Chiesa, and Katerina Sotiraki. “Sumcheck Arguments and Their Applications”. In: CRYPTO (1). Vol. 12825. Lecture Notes in Computer Science. Springer, 2021, pp. 742–773.</li>

    </ul>

    <p class="text-gray-300">[BCS23] Jonathan Bootle, Alessandro Chiesa, and Katerina Sotiraki. “Lattice-Based Succinct Arguments for NP with Polylogarithmic-Time Verification”. In: <em>Advances in Cryptology - CRYPTO 2023</em>. Ed. by Helena Handschuh and Anna Lysyanskaya. Vol. 14082. Lecture Notes in Computer Science. Springer, 2023, pp. 227–251. doi: 10.1007/978-3-031-38545-2\\_8. URL: https://doi.org/10.1007/978-3-031-38545-2\\_8.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BDGL16] Anja Becker, Léo Ducas, Nicolas Gama, and Thijs Laarhoven. “New directions in nearest neighbor searching with applications to lattice sieving”. In: <em>SODA</em>. SIAM, 2016, pp. 10–24.</li>

      <li>[BDLOP18] Carsten Baum, Ivan Damgård, Vadim Lyubashevsky, Sabine Oechsner, and Chris Peikert. “More Efficient Commitments from Structured Lattice Assumptions”. In: <em>SCN</em>. 2018, pp. 368–385.</li>

      <li>[BF22] Benedikt Bünz and Ben Fisch. <em>Multilinear Schwartz-Zippel mod N with Applications to Succinct Arguments</em>. Cryptology ePrint Archive, Paper 2022/458. https://eprint.iacr.org/2022/458. 2022. URL: https://eprint.iacr.org/2022/458.</li>

      <li>[BFS20] Benedikt Bünz, Ben Fisch, and Alan Szepieniec. “Transparent SNARKs from DARK Compilers”. In: <em>EUROCRYPT (1)</em>. Vol. 12105. Lecture Notes in Computer Science. Springer, 2020, pp. 677–706.</li>

      <li>[BLNS20] Jonathan Bootle, Vadim Lyubashevsky, Ngoc Khanh Nguyen, and Gregor Seiler. “A Non-PCP Approach to Succinct Quantum-Safe Zero-Knowledge”. In: <em>CRYPTO (2)</em>. Vol. 12171. Lecture Notes in Computer Science. Springer, 2020, pp. 441–469.</li>

      <li>[BLNS23] Jonathan Bootle, Vadim Lyubashevsky, Ngoc Khanh Nguyen, and Alessandro Sorniotti. <em>A Framework for Practical Anonymous Credentials from Lattices</em>. To appear at CRYPTO 2023. https://eprint.iacr.org/2023/560. 2023. URL: https://eprint.iacr.org/2023/560.</li>

      <li>[BS23] Ward Beullens and Gregor Seiler. “LaBRADOR: Compact Proofs for R1CS from ModuleSIS”. In: <em>CRYPTO (5)</em>. Vol. 14085. Lecture Notes in Computer Science. Springer, 2023, pp. 518–548.</li>

      <li>[BTT22] Cecilia Boschini, Akira Takahashi, and Mehdi Tibouchi. “MuSig-L: Lattice-Based Multi-Signature With Single-Round Online Phase”. In: https://eprint.iacr.org/2022/1036. 2022. URL: https://eprint.iacr.org/2022/1036.</li>

      <li>[Bos+18] Joppe W. Bos et al. “CRYSTALS - Kyber: A CCA-Secure Module-Lattice-Based KEM”. In: <em>2018 IEEE European Symposium on Security and Privacy, EuroS&P</em>. 2018, pp. 353–367.</li>

      <li>[CGH04] Ran Canetti, Oded Goldreich, and Shai Halevi. “The random oracle methodology, revisited”. In: <em>J. ACM</em> 51.4 (2004), pp. 557–594.</li>

      <li>[CHMMVW20] Alessandro Chiesa, Yuncong Hu, Mary Maller, Pratyush Mishra, Noah Vesely, and Nicholas Ward. “Marlin: Preprocessing zkSNARKs with Universal and Updatable SRS”. In: <em>Proceedings of the 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques</em>. EUROCRYPT ’20. 2020, pp. 738–768.</li>

      <li>[CJJ21] Arka Rai Choudhuri, Abhishek Jain, and Zhengzhong Jin. “SNARGs for <span class="math">\\matical{P}</span> from LWE”. In: <em>FOCS</em>. IEEE, 2021, pp. 68–79.</li>

      <li>[CLM23] Valerio Cini, Russell W. F. Lai, and Giulio Malavolta. “Lattice-Based Succinct Arguments from Vanishing Polynomials”. In: <em>Advances in Cryptology – CRYPTO 2023</em>. Ed. by Helena Handschuh and Anna Lysyanskaya. Cham: Springer Nature Switzerland, 2023, pp. 72–105.</li>

      <li>[CN11] Yuanmi Chen and Phong Q. Nguyen. “BKZ 2.0: Better Lattice Security Estimates”. In: <em>ASIACRYPT</em>. Vol. 7073. Lecture Notes in Computer Science. Springer, 2011, pp. 1–20.</li>

      <li>[CP22] Leo de Castro and Chris Peikert. “Functional Commitments for All Functions, with Transparent Setup”. In: <em>IACR Cryptol. ePrint Arch.</em> (2022), p. 1368.</li>

    </ul>

    <p class="text-gray-300">[Can+19] Ran Canetti, Yilei Chen, Justin Holmgren, Alex Lombardi, Guy N. Rothblum, Ron D. Rothblum, and Daniel Wichs. “Fiat-Shamir: from practice to theory”. In: STOC. ACM, 2019, pp. 1082–1090.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[DFM20] Jelle Don, Serge Fehr, and Christian Majenz. “The Measure-and-Reprogram Technique 2.0: Multi-round Fiat-Shamir and More”. In: CRYPTO (3). Vol. 12172. Lecture Notes in Computer Science. Springer, 2020, pp. 602–631.</li>

      <li>[DGKV22] Lalita Devadas, Rishab Goyal, Yael Kalai, and Vinod Vaikuntanathan. “Rate-1 Non-Interactive Arguments for Batch-NP and Applications”. In: FOCS. IEEE, 2022, pp. 1057–1068.</li>

      <li>[DLP14] Léo Ducas, Vadim Lyubashevsky, and Thomas Prest. “Efficient Identity-Based Encryption over NTRU Lattices”. In: ASIACRYPT. 2014, pp. 22–41.</li>

      <li>[Duc+18] Léo Ducas, Eike Kiltz, Tancrède Lepoint, Vadim Lyubashevsky, Peter Schwabe, Gregor Seiler, and Damien Stehlé. “CRYSTALS-Dilithium: A Lattice-Based Digital Signature Scheme”. In: IACR Trans. Cryptogr. Hardw. Embed. Syst. 2018.1 (2018), pp. 238–268.</li>

      <li>[ENS20] Muhammed F. Esgin, Ngoc Khanh Nguyen, and Gregor Seiler. “Practical Exact Proofs from Lattices: New Techniques to Exploit Fully-Splitting Rings”. In: ASIACRYPT (2). 2020, pp. 259–288.</li>

      <li>[EZSLL19] Muhammed F. Esgin, Raymond K. Zhao, Ron Steinfeld, Joseph K. Liu, and Dongxi Liu. “MatRiCT: Efficient, Scalable and Post-Quantum Blockchain Confidential Transactions Protocol”. In: CCS. ACM, 2019, pp. 567–584.</li>

      <li>[FLV23] Ben Fisch, Zeyu Liu, and Psi Vesely. “Orbweaver: Succinct Linear Functional Commitments from Lattices”. In: Advances in Cryptology – CRYPTO 2023. Ed. by Helena Handschuh and Anna Lysyanskaya. Cham: Springer Nature Switzerland, 2023, pp. 106–131.</li>

      <li>[FS86] Amos Fiat and Adi Shamir. “How to Prove Yourself: Practical Solutions to Identification and Signature Problems”. In: CRYPTO. 1986, pp. 186–194.</li>

      <li>[Fou+20] Pierre-Alain Fouque et al. Falcon: Fast-Fourier Lattice-based Compact Signatures over NTRU. Tech. rep. https:/https://falcon-sign.info/falcon.pdf. 2020.</li>

      <li>[GLSTW21] Alexander Golovnev, Jonathan Lee, Srinath T. V. Setty, Justin Thaler, and Riad S. Wahby. “Brakedown: Linear-time and post-quantum SNARKs for R1CS”. In: IACR Cryptol. ePrint Arch. (2021), p. 1043.</li>

      <li>[GMNO18] Rosario Gennaro, Michele Minelli, Anca Nitulescu, and Michele Orrù. “Lattice-Based zkSNARKs from Square Span Programs”. In: Proceedings of the 25th ACM Conference on Computer and Communications Security. CCS ’18. 2018, pp. 556–573.</li>

      <li>[GPV08] Craig Gentry, Chris Peikert, and Vinod Vaikuntanathan. “Trapdoors for hard lattices and new cryptographic constructions”. In: STOC. 2008, pp. 197–206.</li>

      <li>[HHGPSW03] Jeffrey Hoffstein, Nick Howgrave-Graham, Jill Pipher, Joseph H. Silverman, and William Whyte. “NTRUSIGN: Digital Signatures Using the NTRU Lattice”. In: CT-RSA. 2003, pp. 122–140.</li>

      <li>[HJKS22] James Hulett, Ruta Jawale, Dakshita Khurana, and Akshayaram Srinivasan. “SNARGs for P from Sub-exponential DDH and QR”. In: EUROCRYPT (2). Vol. 13276. Lecture Notes in Computer Science. Springer, 2022, pp. 520–549.</li>

      <li>[HLR21] Justin Holmgren, Alex Lombardi, and Ron D. Rothblum. “Fiat-Shamir via list-recoverable codes (or: parallel repetition of GMW is not zero-knowledge)”. In: STOC. ACM, 2021, pp. 750–760.</li>

      <li>[ISW21] Yuval Ishai, Hang Su, and David J. Wu. “Shorter and Faster Post-Quantum Designated-Verifier zkSNARKs from Lattices”. In: CCS. ACM, 2021, pp. 212–234.</li>

    </ul>

    <p class="text-gray-300">[JRLS22] Corentin Jeudy, Adeline Roux-Langlois, and Olivier Sanders. Lattice Signature with Efficient Protocols, Application to Anonymous Credentials. Cryptology ePrint Archive, Paper 2022/509. https://eprint.iacr.org/2022/509. 2022. URL: https://eprint.iacr.org/2022/509.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[KLVW23] Yael Kalai, Alex Lombardi, Vinod Vaikuntanathan, and Daniel Wichs. “Boosting Batch Arguments and RAM Delegation”. In: STOC. ACM, 2023, pp. 1545–1552.</li>

      <li>[KZG10] Aniket Kate, Gregory M. Zaverucha, and Ian Goldberg. “Constant-Size Commitments to Polynomials and Their Applications”. In: ASIACRYPT. Vol. 6477. Lecture Notes in Computer Science. Springer, 2010, pp. 177–194.</li>

      <li>[Kat21] Shuichi Katsumata. “A New Simple Technique to Bootstrap Various Lattice Zero-Knowledge Proofs to QROM Secure NIZKs”. In: CRYPTO (2). Vol. 12826. Lecture Notes in Computer Science. Springer, 2021, pp. 580–610.</li>

      <li>[LLL82] Arjen Lenstra, Hendrik Lenstra Jr., and Laszlo Lovasz. “Factoring polynomials with rational coefficients”. In: Mathematische Annalen 261 (1982), pp. 513–534.</li>

      <li>[LMS22] Russell W. F. Lai, Giulio Malavolta, and Nicholas Spooner. “Quantum Rewinding for Many-Round Protocols”. In: TCC (1). Vol. 13747. Lecture Notes in Computer Science. Springer, 2022, pp. 80–109.</li>

      <li>[LN22] Vadim Lyubashevsky and Ngoc Khanh Nguyen. “BLOOM: Bimodal Lattice One-out-of-Many Proofs and Applications”. In: ASIACRYPT (4). Vol. 13794. Lecture Notes in Computer Science. Springer, 2022, pp. 95–125.</li>

      <li>[LNP22] Vadim Lyubashevsky, Ngoc Khanh Nguyen, and Maxime Plançon. “Lattice-Based Zero-Knowledge Proofs and Applications: Shorter, Simpler, and More General”. In: CRYPTO (2). Vol. 13508. Lecture Notes in Computer Science. Springer, 2022, pp. 71–101.</li>

      <li>[LPR13] Vadim Lyubashevsky, Chris Peikert, and Oded Regev. “A Toolkit for Ring-LWE Cryptography”. In: EUROCRYPT. 2013, pp. 35–54.</li>

      <li>[LRY16] Benoît Libert, Somindu C. Ramanna, and Moti Yung. “Functional Commitment Schemes: From Polynomial Commitments to Pairing-Based Accumulators from Simple Assumptions”. In: ICALP. Vol. 55. LIPIcs. Schloss Dagstuhl - Leibniz-Zentrum für Informatik, 2016, 30:1–30:14.</li>

      <li>[LS15] Adeline Langlois and Damien Stehlé. “Worst-case to average-case reductions for module lattices”. In: Des. Codes Cryptogr. 75.3 (2015), pp. 565–599.</li>

      <li>[LS18] Vadim Lyubashevsky and Gregor Seiler. “Short, Invertible Elements in Partially Splitting Cyclotomic Rings and Applications to Lattice-Based Zero-Knowledge Proofs”. In: EUROCRYPT (1). Springer, 2018, pp. 204–224.</li>

      <li>[LS19] Vadim Lyubashevsky and Gregor Seiler. “NTTRU: Truly Fast NTRU Using NTT”. In: IACR Trans. Cryptogr. Hardw. Embed. Syst. 2019.3 (2019), pp. 180–201.</li>

      <li>[Lee21] Jonathan Lee. “Dory: Efficient, Transparent Arguments for Generalised Inner Products and Polynomial Commitments”. In: TCC (2). Vol. 13043. Lecture Notes in Computer Science. Springer, 2021, pp. 1–34.</li>

      <li>[Lyu09] Vadim Lyubashevsky. “Fiat-Shamir with Aborts: Applications to Lattice and Factoring-Based Signatures”. In: ASIACRYPT. 2009, pp. 598–616.</li>

      <li>[Lyu12] Vadim Lyubashevsky. “Lattice Signatures Without Trapdoors”. In: EUROCRYPT. 2012, pp. 738–755.</li>

      <li>[MP12] Daniele Micciancio and Chris Peikert. “Trapdoors for Lattices: Simpler, Tighter, Faster, Smaller”. In: EUROCRYPT. 2012, pp. 700–718.</li>

    </ul>

    <p class="text-gray-300">[MR07] Daniele Micciancio and Oded Regev. “Worst-Case to Average-Case Reductions Based on Gaussian Measures”. In: SIAM Journal on Computing 37 (1 2007), pp. 267–302.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[MR09] Daniele Micciancio and Oded Regev. “Lattice-based Cryptography”. In: Post-Quantum Cryptography. Ed. by Daniel J. Bernstein, Johannes Buchmann, and Erik Dahmen. Berlin, Heidelberg: Springer Berlin Heidelberg, 2009, pp. 147–191. isbn: 978-3-540-88702-7. doi: 10.1007/978-3-540-88702-7_5. url: https://doi.org/10.1007/978-3-540-88702-7_5.</li>

      <li>[NS22] Ngoc Khanh Nguyen and Gregor Seiler. “Practical Sublinear Proofs for R1CS from Lattices”. In: CRYPTO (2). Vol. 13508. Lecture Notes in Computer Science. Springer, 2022, pp. 133–162.</li>

      <li>[PPS21] Chris Peikert, Zachary Pepin, and Chad Sharp. “Vector and Functional Commitments from Lattices”. In: TCC (3). Vol. 13044. Lecture Notes in Computer Science. Springer, 2021, pp. 480–511.</li>

      <li>[SE94] Claus-Peter Schnorr and M. Euchner. “Lattice basis reduction: Improved practical algorithms and solving subset sum problems”. In: Math. Program. 66 (1994), pp. 181–199.</li>

      <li>[SS13] Damien Stehlé and Ron Steinfeld. “Making NTRUEncrypt and NTRUSign as Secure as Standard Worst-Case Problems over Ideal Lattices”. In: IACR Cryptol. ePrint Arch. (2013), p. 4.</li>

      <li>[SSEK22] Ron Steinfeld, Amin Sakzad, Muhammed F. Esgin, and Veronika Kuchta. Private Re-Randomization for Module LWE and Applications to Quasi-Optimal ZK-SNARKs. Cryptology ePrint Archive, Paper 2022/1690. https://eprint.iacr.org/2022/1690. 2022. url: https://eprint.iacr.org/2022/1690.</li>

      <li>[Sei18] Gregor Seiler. “Faster AVX2 optimized NTT multiplication for Ring-LWE lattice cryptography”. In: IACR Cryptology ePrint Archive 2018 (2018). http://eprint.iacr.org/2018/039, p. 39.</li>

      <li>[Set20] Srinath Setty. “Spartan: Efficient and general-purpose zkSNARKs without trusted setup”. In: Proceedings of the 40th Annual International Cryptology Conference. CRYPTO ’20. Referencing Cryptology ePrint Archive, Report 2019/550, revision from 2020.02.28. 2020, pp. 704–737.</li>

      <li>[WW23a] Hoeteck Wee and David J. Wu. “Lattice-Based Functional Commitments: Fast Verification and Cryptanalysis”. In: Springer-Verlag, 2023.</li>

      <li>[WW23b] Hoeteck Wee and David J. Wu. “Succinct Vector, Polynomial, and Functional Commitments from Lattices”. In: EUROCRYPT (3). Vol. 14006. Lecture Notes in Computer Science. Full version: https://eprint.iacr.org/2022/1515. Springer, 2023, pp. 385–416.</li>

    </ul>`;
---

<BaseLayout title="Lattice-Based Polynomial Commitments: Towards Asymptotic and... (2023/846)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2023 &middot; eprint 2023/846
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
