---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2022/621';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Caulk: Lookup Arguments in Sublinear Time';
const AUTHORS_HTML = 'Arantxa Zapico, Vitalik Buterin, Dmitry Khovratovich, Mary Maller, Anca Nitulescu, Mark Simkin';

const CONTENT = `    <p class="text-gray-300">Caulk: Lookup Arguments in Sublinear Time</p>

    <p class="text-gray-300">Arantxa Zapico\\*, Vitalik Buterin², Dmitry Khovratovich², Mary Maller², Anca Nitulescu³, and Mark Simkin²</p>

    <p class="text-gray-300">¹ Universitat Pompeu Fabra†</p>

    <p class="text-gray-300">² Ethereum Foundation‡</p>

    <p class="text-gray-300">³ Protocol Labs§</p>

    <p class="text-gray-300">We present position-hiding linkability for vector commitment schemes: one can prove in zero knowledge that one or <span class="math">m</span> values that comprise commitment cm all belong to the vector of size <span class="math">N</span> committed to in C. Our construction Caulk can be used for membership proofs and lookup arguments and outperforms all existing alternatives in prover time by orders of magnitude.</p>

    <p class="text-gray-300">For both single- and multi-membership proofs the Caulk protocol beats SNARKed Merkle proofs by the factor of 100 even if the latter is instantiated with Poseidon hash. Asymptotically our prover needs <span class="math">O(m^2 + m \\log N)</span> time to prove a batch of <span class="math">m</span> openings, whereas proof size is <span class="math">O(1)</span> and verifier time is <span class="math">O(\\log (\\log N))</span>.</p>

    <p class="text-gray-300">As a lookup argument, Caulk is the first scheme with prover time sublinear in the table size, assuming <span class="math">O(N \\log N)</span> preprocessing time and <span class="math">O(N)</span> storage. It can be used as a subprimitive in verifiable computation schemes in order to drastically decrease the lookup overhead.</p>

    <p class="text-gray-300">Our scheme comes with a reference implementation and benchmarks.</p>

    <p class="text-gray-300">A vector commitment is a basic cryptographic scheme, which lies at the foundation of numerous constructions and protocols. In a nutshell, a vector commitment is a compact data structure that contains a potentially very large number of elements and allows proving that a specific element has been committed to it. A natural requirement is that a proof is succinct and unforgeable. A Merkle tree is a well-known example of a vector commitment.</p>

    <p class="text-gray-300">For privacy-preserving applications it is vital to make proofs zero-knowledge, i.e. hiding the element that is asserted to be in the commitment, while still establishing a certain relationship, or link, to that element. A vector commitment to <span class="math">\\pmb{c} = (c_{1},\\dots ,c_{N})</span> is linkable, if it permits proving that you know a secret <span class="math">s_i</span> mathematically linked to <span class="math">c_{i}</span>. The simplest example is a proof of authorization where a party proves knowledge of a secret key belonging to one of multiple public keys in a set. A more elaborate example is a proof of coin ownership in private cryptocurrencies: coins are stored as hashes of a secret <span class="math">k</span> and values <span class="math">v</span> in a list or a tree and to spend <span class="math">v</span> one proves knowledge of <span class="math">v</span> and <span class="math">k</span> without revealing them. A third example are lookup arguments in verifiable computation: prove that intermediate values <span class="math">a_1,a_2,\\ldots ,a_m</span> are all contained in a certain table, e.g., a table of all 16-bit numbers for the purpose of overflow checks in financial or mathematical computations. Other applications also include membership proofs, ring signatures, anonymous credentials and other schemes.</p>

    <p class="text-gray-300">Currently, all of the above examples are being solved using heavy cryptography machinery involving significant computational overheads, which limits their scalability and adoption. The first version of</p>

    <p class="text-gray-300">\\*This work was done while Arantxa Zapico was an intern at the Ethereum Foundation.</p>

    <p class="text-gray-300">†arantxa.zapico@upf.edu</p>

    <p class="text-gray-300">‡{v_buterin, mary.maller, mark.simkin}@ethereum.org, khovratovich@gmail.com</p>

    <p class="text-gray-300">§anca@protocol.ai</p>

    <p class="text-gray-300">the Zcash cryptocurrency <em>[30]</em> used a SHA-2-based Merkle tree to store the coins and the Groth16 <em>[20]</em> SNARK to prove coin ownership. The relatively high costs of Groth16 and the large prime-field circuits of SHA-2 made the resulting prover time of 40 seconds barely usable in practice. Even the most recent developments of algebraic hashes <em>[1, 19]</em> reduce <em>prover time</em> by an order of magnitude only. Another application of concern, lookup tables, so far has required the generic construction of Plookup <em>[17]</em>, that makes the prover be <em>at least as big</em> as the table itself, no matter how many values they look up.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.1 Our Contributions</h3>

    <p class="text-gray-300">In this paper we present a novel construction, named Caulk, that allows to link a public set with a hidden subset in zero-knowledge and performs with unprecedented efficiency. We construct a proof of membership, with asymptotic complexity of <span class="math">O(\\log N)</span> for <span class="math">N</span>-sized commitments, with a concrete efficiency improvement of a factor of 100x over SNARKs on top of a Merkle trees that uses the Poseidon hash function. The prover benefits of our construction are even more extreme when compared with Merkle trees that use SHA-2. Our construction achieves statistical zero-knowledge and soundness in the algebraic group model, requires a universal setup, and <span class="math">O(N)</span> storage.</p>

    <p class="text-gray-300">Our construction naturally extends to proof of subset memberships, thus leading the way to more efficient lookup arguments. We are the first to remove the bottleneck of big tables by achieving a <span class="math">O(m\\log N+m^{2})</span> prover cost for <span class="math">m</span>-subvector lookups. The verifier is succinct as it requires only <span class="math">O(\\log(\\log N))</span> scalar operations as well as constant number of pairings to verify a constant-size proof. We envision the widespread deployment of our construction both in generic lookup-equipped proof systems <em>[17, 27]</em> and specific applications with membership proofs.</p>

    <p class="text-gray-300">We have implemented Caulk in Rust, and we use that implementation for concrete comparison with other solutions as well.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.2 Paper Structure</h3>

    <p class="text-gray-300">We start with a technical overview of Caulk in Section 2 and related work is discussed in Section 3. In Section 4 we provide a self-contained description of the tools we use, in particular the polynomial commitment scheme by Kate, Zaverucha and Goldberg <em>[22]</em> (KZG) and associated precomputation techniques, which can be skipped by a knowledgeable reader.</p>

    <p class="text-gray-300">In Section 5 we identify our constructions as special cases of a more general family of protocols that add a property that we call <em>position-hiding linkability</em> to vector commitment schemes. This primitive asserts that all (hidden) entries committed in an element cm are also (publicly) committed to in C. Position-hiding refers to the fact that no information about which elements were taken to construct cm should be leaked. We formalize its definition as well as the security notions it should satisfy.</p>

    <p class="text-gray-300">In Section 6 we formally describe Caulk for the case of proving membership of a single element (<span class="math">m=1</span>) and show that it is sound in the algebraic group model and statistically zero-knowledge. As an important building block we also present a construction of a proof system that demonstrates that a Pedersen commitment contains a root of unity. In Section 7 we extend Caulk even further to <span class="math">m</span>-subset (<span class="math">m&gt;1</span>) proofs, with some values possibly repeating. In this scenario Caulk can be seen as a lookup table, and is thus a prover efficient alternative to schemes such as Plookup <em>[17]</em>. We discuss various optimizations in Section 8.</p>

    <p class="text-gray-300">Caulk comes with an open source reference implementation in Rust using arkworks library. In Section 9 we compare its efficiency with some rival schemes.</p>

    <h2 id="sec-5" class="text-2xl font-bold">2 Caulk in a nutshell</h2>

    <p class="text-gray-300">In the following we explain the high-level ideas behind our constructions for the case of proving membership of a single element (<span class="math">m=1</span>) and the case of proving membership of multiple elements (<span class="math">m&gt;1</span>). The starting point of both is the KZG polynomial commitment scheme, which we describe in Section 4.2, that allows for committing to a polynomial <span class="math">C(X)</span> and then later on opening evaluations <span class="math">C(\\alpha)</span> for some publicly known <span class="math">\\alpha</span>. We note that a vector <span class="math">\\vec{c}</span> can be encoded as a polynomial <span class="math">C(X)=\\sum_{i=1}^{N}c_{i}\\lambda_{i}(X)</span>, where <span class="math">\\{\\lambda_{i}(X)\\}_{i=1}^{N}</span> are the Lagrange interpolation polynomials corresponding to some set of roots of unity</p>

    <p class="text-gray-300"><span class="math">\\mathbb{H}=\\{1,\\omega,\\ldots,\\omega^{N-1}\\}</span> with <span class="math">\\omega^{N}=1</span>. That is, <span class="math">\\lambda_{i}(\\omega^{i-1})=1</span> and <span class="math">\\lambda_{i}(\\omega^{j})=0</span> for all <span class="math">j\\neq i-1.</span> Opening position <span class="math">i</span> in the vector is done by simply revealing the corresponding evaluation of the polynomial at element <span class="math">\\omega^{i-1}</span>.</p>

    <p class="text-gray-300">A KZG commitment to <span class="math">C(X)</span> is an element <span class="math">\\mathsf{C}=\\sum_{i=1}^{N}c_{i}[\\lambda_{i}(x)]_{1}</span> where <span class="math">x</span> is secret and <span class="math">[.]_{1}</span> denotes it is given in the source group <span class="math">\\mathbb{G}_{1}</span> of some (asymmetric) bilinear group. A proof of opening for value <span class="math">v</span> at position <span class="math">i</span> is an element <span class="math">[Q_{i}]_{1}</span> such that</p>

    <p class="text-gray-300"><span class="math">e\\left(\\mathsf{C}-[v]_{1},[1]_{2}\\right)=e\\left([Q_{i}]_{1},[x-\\omega^{i-1}]_{2}\\right).</span></p>

    <p class="text-gray-300">A proof of opening for a subset of positions <span class="math">I\\subset[N]</span> is an element <span class="math">[H_{I}]_{1}</span>, such that if <span class="math">C_{I}(X)=\\sum_{i\\in I}c_{i}\\tau_{i}(X)</span> and <span class="math">z_{I}(X)=\\prod_{i\\in I}(X-\\omega^{i-1})</span>, where <span class="math">\\{\\tau_{i}(X)\\}_{i\\in I}</span> are the Lagrange interpolation polynomials of <span class="math">\\mathbb{H}_{I}=\\{\\omega^{i-1}\\}_{i\\in I}</span>, then</p>

    <p class="text-gray-300"><span class="math">e(\\mathsf{C}-[C_{I}(x)]_{1},[1]_{2})=e([H_{I}]_{1},[z_{I}(x)]_{2}).</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our prover time is almost unaffected by the computation of the non-hiding KZG proofs <span class="math">[Q_{i}]_{1}</span> and <span class="math">[H_{I}]_{1}</span>. Indeed, the former can be pre-computed along with all proofs for individual positions using <span class="math">N\\log N</span> group operations, and the latter can be obtained from the pre-computed proofs for all <span class="math">i\\in I</span>, in time dependent on $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$, as shown in <em>[28, 13]</em> and discussed in Section 4.3. As a result, note that our prover does require linear storage.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In our case, we would like to show that a secret committed value (or a set of committed values) is at a secret position of our committed vector. On a very high level, the idea behind Caulk is to re-randomize the values provided as part of a KZG opening by appropriate blinders, such that no information about which element is at which position is revealed. The main technical challenge lies in efficiently proving that the blinded KZG opening is still well-formed. We outline the technical ideas between the single and multiple element cases separately.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Single Element.</h4>

    <p class="text-gray-300">Instead of directly revealing value <span class="math">v</span>, the prover now demonstrates knowledge of <span class="math">v</span> and <span class="math">r</span> behind a Pedersen commitment <span class="math">\\mathsf{cm}=[v+\\mathsf{hr}]_{1}</span>, for unknown <span class="math">\\mathsf{h}</span> given as <span class="math">[\\mathsf{h}]_{1}</span> in the setup. Next, the prover would like to convince the verifier that <span class="math">v</span> is stored somewhere in the vector. For this, the prover publishes <span class="math">[z(x)]_{2}=[a(x-\\omega^{i-1})]_{2}</span> and shows that it is a blind commitment to polynomial <span class="math">X-\\omega^{i-1}</span>, which implies proving that it is a polynomial of degree <span class="math">1</span> and that <span class="math">\\omega^{i-1}</span> is an <span class="math">N</span>th root of unity i.e. that <span class="math">(\\omega^{i-1})^{N}=1</span>.</p>

    <p class="text-gray-300">To prove well-formation of <span class="math">z(X)</span>, the prover additionally commits to an auxiliary polynomial <span class="math">f(X)</span> of degree <span class="math">n=\\log(N)+6</span>, which effectively encodes a set of constraints on <span class="math">z(X)</span>. Crucially important for efficiency, we define <span class="math">f(X)</span> over a small subgroup of roots of unity <span class="math">\\mathbb{V}_{n}=\\{1,\\ldots,\\sigma^{n-1}\\}</span> with <span class="math">\\sigma^{n}=1</span>. Concretely, the first <span class="math">5</span> coefficients of <span class="math">f(X)</span> are used to, by comparing it to <span class="math">z(X)</span>, <em>extract</em> <span class="math">\\omega^{i-1}</span>, the next <span class="math">\\log(N)</span> coefficients are used to obtain the <span class="math">2</span>-powers of <span class="math">(\\omega^{i-1})^{-1}</span> up to <span class="math">2^{\\log(N)}=N</span>, and the last one to prove that <span class="math">((\\omega^{i-1})^{-1})^{2^{\\log(N)}}=((\\omega^{i-1})^{-1})^{N}=(\\omega^{i-1})^{N}=1</span>.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Multiple Elements.</h4>

    <p class="text-gray-300">For the case of multiple elements, the prover would like to convince the verifier that all elements in vector <span class="math">\\vec{a}=(a_{1},\\ldots,a_{m})</span> that are committed to in a KZG commitment <span class="math">\\mathsf{cm}</span>, are also somewhere in the vector <span class="math">\\vec{c}</span> committed as <span class="math">\\mathsf{C}</span>. We first encode <span class="math">\\vec{a}</span> as a polynomial <span class="math">\\phi(X)=\\sum_{j=1}^{m}a_{j}\\mu_{j}(X)</span>, where <span class="math">\\{\\mu_{j}(X)\\}_{j=1}^{m}</span> are Lagrange interpolation polynomials over a subgroup of roots of unity <span class="math">\\mathbb{V}_{m}=\\{1,\\nu,\\ldots,\\nu^{m-1}\\}</span> with <span class="math">\\nu^{m}=1</span>, and set <span class="math">\\mathsf{cm}=[\\phi(x)]_{1}</span>.</p>

    <p class="text-gray-300">To prove linkability between <span class="math">\\vec{c}</span> and <span class="math">\\vec{a}</span>, the prover first sets <span class="math">\\vec{c}_{I}</span> to be the subvector of <span class="math">\\vec{c}</span> that contains all the elements <span class="math">c_{i}</span> such that <span class="math">c_{i}=a_{j}</span> for some <span class="math">a_{j}</span>, without repetitions, and comptues <span class="math">C_{I}(X)</span> using the Lagrange polynomials <span class="math">\\{\\tau_{i}(X)\\}_{i\\in I}</span> that correspond to <span class="math">\\mathbb{H}_{I}=\\{\\omega^{i-1}\\}_{i\\in I}</span>. Using KZG proofs of openings for blinded commitments to <span class="math">C_{I}(X)</span> and <span class="math">z_{I}(X)</span>, the prover sends <span class="math">[H_{I}(x)]_{1}</span> where <span class="math">H_{I}(X)</span> is a blinded version of the polynomial <span class="math">H_{I}^{\\prime}(X)</span> such that</p>

    <p class="text-gray-300"><span class="math">C(X)-C_{I}(X)=z_{I}(X)H_{I}^{\\prime}(X).</span></p>

    <p class="text-gray-300">Then, it remains to prove that <span class="math">z_{I}(X)</span> has the right form and <span class="math">[C_{I}(x)]_{1}</span> is a commitment to the same values as <span class="math">\\mathsf{cm}=\\sum_{j}^{m}a_{j}\\mu_{j}(X)</span>, just in a different basis, namely <span class="math">\\{\\tau_{i}(X)\\}</span> vs <span class="math">\\{\\mu_{j}(X)\\}</span>. For the first statement we again introduce an auxiliary polynomial <span class="math">u(X)=\\sum_{j=1}^{m}\\omega^{i_{j}-1}\\mu_{j}(X)</span> that includes all the <span class="math">\\omega^{i-1}</span> with <span class="math">i\\in I</span>, but with the corresponding repetitions. We prove that <span class="math">u(X)</span>’s coefficients are <span class="math">N</span>th roots of unity by providing a proof that <span class="math">u_{j}(X)=u_{j-1}(X)u_{j-1}(X)</span> for <span class="math">j=1,\\ldots,m</span>, when evaluated at elements in <span class="math">\\mathbb{V}_{m}</span>,</p>

    <p class="text-gray-300">and showing that <span class="math">u_{0}(X)=u(X)</span> and <span class="math">u_{n}(X)=1</span>. Then it remains to prove that <span class="math">z_{I}(X)</span> vanishes at every coefficient of <span class="math">u(X)</span> i.e. <span class="math">z_{I}(u(X))</span> vanishes at all elements of <span class="math">\\mathbb{V}_{m}</span>. This is done by providing <span class="math">H_{2}(X)</span> such that <span class="math">z_{I}(u(X))=z_{H}(X)H_{2}(X)</span>. Note that the argument holds also when <span class="math">u(X)</span> has repeating coefficients.</p>

    <p class="text-gray-300">For the first statement, we introduce an auxiliary polynomial <span class="math">u(X)=\\sum_{j=1}^{m}\\omega^{i_{j}-1}\\mu_{j}(X)</span> that includes all the <span class="math">\\omega^{i-1}</span> with <span class="math">i\\in I</span> but with the corresponding repetitions. We also define polynomials <span class="math">\\{u_{j}(X)\\}_{j=0}^{n}</span> and show that <span class="math">u(X)</span>’s coefficients are <span class="math">N</span>th roots of unity by providing a proof that <span class="math">u_{j}(X)=u_{j-1}(X)u_{j-1}(X)</span> for <span class="math">j=1,\\ldots,m</span>, when evaluated at elements in <span class="math">\\mathbb{V}_{m}</span>, and that <span class="math">u_{0}(X)=u(X)</span> and <span class="math">u_{n}(X)=1</span>. Then it remains to prove that <span class="math">z_{I}(X)</span> vanishes at every coefficient of <span class="math">u(X)</span> i.e. <span class="math">z_{I}(u(X))</span> vanishes at all elements of <span class="math">\\mathbb{V}_{m}</span>. This is done by providing <span class="math">H_{2}(X)</span> such that <span class="math">z_{I}(u(X))=z_{H}(X)H_{2}(X)</span>. Note that the argument holds also when <span class="math">u(X)</span> has repeating coefficients.</p>

    <p class="text-gray-300"><span class="math">(ii)</span> is proven by asserting the polynomial equation</p>

    <p class="text-gray-300"><span class="math">C_{I}(u(X))-\\phi(X)=z_{H}(X)H_{3}(X)</span></p>

    <p class="text-gray-300">holds for some <span class="math">H_{3}(X)</span>, thus linking an input <span class="math">\\phi(X)</span> in the known basis <span class="math">\\{\\mu_{j}(X)\\}_{j=1}^{m}</span> to <span class="math">C_{I}(X)</span> in the unknown basis <span class="math">\\{\\tau_{i}(X)\\}_{i\\in I}</span>.</p>

    <h2 id="sec-8" class="text-2xl font-bold">3 Related Work</h2>

    <p class="text-gray-300"><em>Merkle-SNARK.</em> Zcash protocol <em>[30]</em> proposed a SNARK over a circuit describing a Merkle tree opening for the anonymous proof of coin ownership. It remains a very popular approach for various set membership proof protocols <em>[29, 31]</em>. The prover costs are logarithmic in the number of tree leafs, but the concrete efficiency varies depending on the hash function that comprises the tree <em>[1, 19]</em>. Regular hash functions such as SHA-2 are known to be very slow, whereas algebraic alternatives are rather novel and some applications are reluctant to use them.</p>

    <p class="text-gray-300"><em>Pairing Based.</em> Camenisch et al.<em>[9]</em> describe a vector commitment that only requires constant prover and verifier costs. However the commitments themselves are computed by a trusted third party and have linear size because the prover requires access to <span class="math">[\\frac{1}{x-c_{i}}]_{1}</span> for all <span class="math">c_{i}</span> in the vector and <span class="math">x</span> secret. Benarroch et al. introduced in <em>[5]</em> what we define as position-hiding linkability for a commitment <span class="math">\\mathsf{C}</span> corresponding to the PST vector commitment scheme <em>[26]</em> and a commitment <span class="math">\\mathsf{cm}</span> to one element using Pedersen’s scheme. Similar to ours, their construction consists on opening a public polynomial encoding a vector at some hiding position <span class="math">s</span> (instead of at element <span class="math">\\omega^{i-1}</span>) and prove that the output is the element committed in <span class="math">\\mathsf{cm}</span>, along with well formation of the input (by showing that <span class="math">s&lt;N</span>). Still, their construction has a proof of size logarithmic in <span class="math">N</span> and asks the verifier to perform <span class="math">O(\\log N)</span> group operations and <span class="math">\\log(N)</span> pairings.</p>

    <p class="text-gray-300"><em>Discrete-Log Based.</em> In the discrete-logarithm setting a series of works have looked into achieving logarithmic sized zero-knowledge membership proof <em>[3, 21, 7, 8]</em>. These have the advantage that there is no trusted setup or pairings. The prover and verifier costs are asymptotically dominated by a linear number of field operations. For modest sized vectors this can be practical because the number of more computationally intensive group operations is logarithmic.</p>

    <p class="text-gray-300"><em>RSA Accumulators.</em> Camenisch and Lysyanskaya <em>[10]</em> design a proof of knowledge protocol for linking a commitment over a prime ordered group to an RSA accumulator. There are no a-priori bounds on the size of the vector and nicely, RSA based schemes have constant size public parameters. This approach is used by Zerocoin <em>[25]</em> which is a privacy preserving payments system (the predecessor to Zerocash <em>[4]</em>). Benarroch et al. <em>[5]</em> improve on this result by allowing the use of prime ordered groups of “standard” size, e.g., 256 bits, whereas <em>[10]</em> needs a much larger group. As opposite to Merkle tree constructions, <em>[5]</em> has prover time constant on the size of the table, and gets up to almost four times faster for elements of arbitrary size and between 4.5 and 23.5 for elements that are large prime numbers; as drawback, proof size goes from 4 to 5 KB. Later, Campanelli et al. <em>[11]</em> present also an scheme for position-hiding linkability of RSA accumulators for large prime numbers and Pedersen commitments. Their proving times does not depend on the size of the accumulator and outperforms Merkle tree approaches by orders of magnitude; however they require either a trusted RSA modulus or class groups.</p>

    <h2 id="sec-9" class="text-2xl font-bold">4 Preliminaries</h2>

    <p class="text-gray-300">A bilinear group <span class="math">gk</span> is a tuple <span class="math">gk=(q,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e,[1]_{1},[1]_{2})</span> where <span class="math">\\mathbb{G}_{1},\\mathbb{G}_{2}</span> and <span class="math">\\mathbb{G}_{T}</span> are groups of prime order <span class="math">q</span>, the elements <span class="math">[1]_{1},[1]_{2}</span> are generators of <span class="math">\\mathbb{G}_{1},\\mathbb{G}_{2}</span> respectively. We also consider <span class="math">[\\mathsf{h}]_{1}</span> another</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Trusted Params</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">srs</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover work</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier work</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Merkle trees + zkSNARKs</td>

            <td class="px-3 py-2 border-b border-gray-700">Updatable</td>

            <td class="px-3 py-2 border-b border-gray-700">m log(N)</td>

            <td class="px-3 py-2 border-b border-gray-700">13G1, 8F</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log(N))</td>

            <td class="px-3 py-2 border-b border-gray-700">2P</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">RSA accumulators</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">2 G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log(m))</td>

            <td class="px-3 py-2 border-b border-gray-700">m exp</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Caulk single opening (Sec. 6)</td>

            <td class="px-3 py-2 border-b border-gray-700">Updatable</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N)</td>

            <td class="px-3 py-2 border-b border-gray-700">6G1, 2G2, 4F</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log(N))</td>

            <td class="px-3 py-2 border-b border-gray-700">4P</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Caulk lookup (Sec. 7)</td>

            <td class="px-3 py-2 border-b border-gray-700">Updatable</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N)</td>

            <td class="px-3 py-2 border-b border-gray-700">14G1, 1G2, 4F</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m2 + m log(N))</td>

            <td class="px-3 py-2 border-b border-gray-700">4P</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Cost comparison of our scheme with alternative proofs for membership and lookups.  <span class="math">N</span>  is the size of the table and  <span class="math">m</span>  the size of the set to be opened. We consider that Merkle trees + zk-SNARKs are implemented using Marlin [12] and note that these numbers are different with other SNARKs. Note that the asymptotic prover work for the Merkle trees + zkSNARKs hides the large constants involved in arithmetising hash functions. The RSA accumulator asymptotics hides large constants: for example  <span class="math">\\mathcal{G}</span>  denotes a hidden order group that has larger size than  <span class="math">\\mathbb{G}_1</span> ,  <span class="math">\\mathbb{G}_2</span> .</p>

    <p class="text-gray-300">generator of  <span class="math">\\mathbb{G}_1</span> , where  <span class="math">\\mathsf{h}</span>  is unknown and  <span class="math">\\mathsf{h}[1]_1 = [\\mathsf{h}]_1</span> .  <span class="math">e:\\mathbb{G}_1\\times \\mathbb{G}_2\\to \\mathbb{G}_T</span>  is an efficiently computable, non-degenerate bilinear map, and there is no efficiently computable isomorphism between  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span> . Elements in  <span class="math">\\mathbb{G}_{\\gamma}</span> , are denoted implicitly as  <span class="math">[a]_{\\gamma} = a[1]_{\\gamma}</span> , where  <span class="math">\\gamma \\in \\{1,2,T\\}</span>  and  <span class="math">[1]_T = e([1]_1,[1]_2)</span> . With this notation,  <span class="math">e([a]_1,[b]_2) = [ab]_T</span> .</p>

    <p class="text-gray-300">Let  <span class="math">\\lambda \\in \\mathbb{N}</span>  denote the security parameter and  <span class="math">1^{\\lambda}</span>  its unary representation. A function  <span class="math">\\mathsf{negl}:\\mathbb{N}\\to \\mathbb{R}</span>  is called negligible if for all  <span class="math">c &amp;gt; 0</span> , there exists  <span class="math">k_{0}</span>  such that  <span class="math">\\mathsf{negl}(k) &amp;lt; \\frac{1}{k^c}</span>  for all  <span class="math">k &amp;gt; k_{0}</span> . For a non-empty set  <span class="math">S</span> , let  <span class="math">x\\gets S</span>  denote sampling an element of  <span class="math">S</span>  uniformly at random and assigning it to  <span class="math">x</span> .</p>

    <p class="text-gray-300">Let PPT denote probabilistic polynomial-time. Algorithms are randomized unless explicitly noted otherwise. Let  <span class="math">y \\gets A(x; r)</span>  denote running algorithm  <span class="math">A</span>  on input  <span class="math">x</span>  and randomness  <span class="math">r</span>  and assigning its output to  <span class="math">y</span> . Let  <span class="math">y \\gets A(x)</span>  denote  <span class="math">y \\gets A(x; r)</span>  for a uniformly random  <span class="math">r</span> .</p>

    <p class="text-gray-300">Lagrange Polynomials and Roots of Unity. We use  <span class="math">\\omega</span>  to denote a root of unity such that  <span class="math">\\omega^{N} = 1</span> , and define  <span class="math">\\mathbb{H} = \\{1, \\omega, \\dots, \\omega^{N-1}\\}</span> . Also, we let  <span class="math">\\lambda_{i}(X)</span>  denote the  <span class="math">i^{\\text{th}}</span>  lagrange polynomial, i.e.,  <span class="math">\\lambda_{i}(X) = \\prod_{s \\neq i-1} \\frac{X - \\omega^{i}}{\\omega^{i-1} - \\omega^{s}}</span>  and  <span class="math">z_{H}(X) = \\prod_{i=0}^{N-1} (X - \\omega^{i}) = X^{N} - 1</span>  the vanishing polynomial of  <span class="math">\\mathbb{H}</span> . We will additionally consider smaller groups of roots of unity in Sections 6, 7 and 7.2, that will be introduced accordingly.</p>

    <p class="text-gray-300">The security of our protocols holds in the Algebraic Group Model (AGM) of Fuchsbauer et al. [15], using the bilinear version of the dlog, qDHE, qSFrac, and qSDH assumptions [18, 6]. In the AGM adversaries are restricted to be algebraic algorithms, namely, whenever  <span class="math">\\mathcal{A}</span>  outputs a group element  <span class="math">[y]</span>  in a cyclic group  <span class="math">\\mathbb{G}</span>  of order  <span class="math">p</span> , it also outputs its representation as a linear combination of all previously received group elements. In other words, if  <span class="math">[y] \\gets \\mathcal{A}([x_1], \\ldots, [x_m])</span> ,  <span class="math">\\mathcal{A}</span>  must also provide  <span class="math">\\vec{z}</span>  such that  <span class="math">[y] = \\sum_{j=1}^{m} z_j[x_j]</span> . This definition generalizes naturally in asymmetric bilinear groups with a pairing  <span class="math">e: \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T</span> , where the adversary must construct new elements as a linear combination of elements in the same group.</p>

    <p class="text-gray-300">Our constructions heavily rely on the KZG polynomial commitment scheme (Def. A.3) that we describe below, as well as its adaptation for vector commitments that we explain in the next section. For efficiency, we slightly modify the polynomial commitment in order to add degree checks to the original protocol, without incurring in extra proof elements or pairings. The polynomial commitment introduced by Kate, Zaverucha and Goldberg in [22] is a tuple of algorithms (KZG.Setup, KZG.Commit, KZG.Open, KZG.Verify) such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{srs}_{\\mathsf{KZG}} \\gets \\mathsf{KZG.Setup}(\\mathsf{par}_{\\mathsf{KZG}}, d)</span> : On input the system parameters and a degree bound  <span class="math">d</span> , it outputs a structured reference string  <span class="math">\\mathsf{srs}_{\\mathsf{KZG}} = \\left(\\{[x^i]_{1,2}\\}_{i=1}^d\\right)</span> .</li>

      <li><span class="math">\\mathsf{C} \\gets \\mathsf{KZG. Commit}(\\mathsf{srs}_{\\mathsf{KZG}}, p(X))</span> : It outputs  <span class="math">\\mathsf{C} = [p(x)]_1</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(s,\\pi_{\\mathsf{KZG}})\\leftarrow\\mathsf{KZG}.{\\sf Open}\\big{(}\\mathsf{srs}_{\\mathsf{KZG}},p(X),\\alpha\\big{)}:~{}\\text{Let deg}&lt;d</span> be the degree of <span class="math">p(X)</span>. Prover computes</li>

    </ul>

    <p class="text-gray-300"><span class="math">q(X)=\\frac{p(X)-p(\\alpha)}{X-\\alpha}~{},</span></p>

    <p class="text-gray-300">sets <span class="math">s=p(\\alpha),[Q]_{1}=[q(x)x^{d-\\deg+2}]_{1}</span>, and outputs <span class="math">(s,\\pi_{\\mathsf{KZG}}=[Q]_{1})</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">1/0\\leftarrow\\mathsf{KZG}.{\\sf Verify}\\big{(}\\mathsf{srs}_{\\mathsf{KZG}},{\\sf C},\\deg,\\alpha,s,\\pi_{\\mathsf{KZG}}\\big{)}:~{}\\text{Verifier accepts if and only if}</span></li>

    </ul>

    <p class="text-gray-300"><span class="math">e({\\sf C}-s,[x^{d-\\deg+2}]_{2})=e([Q]_{1},[x-\\alpha]_{2}).</span></p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">Security.</h4>

    <p class="text-gray-300">It has been proven in <em>[22, 12, 16]</em> that the original KZG protocol, i.e., where <span class="math">[Q]_{1}=[q(x)]_{1}</span> and the pairing equation is <span class="math">e({\\sf C}-s,[1]_{2})=e([Q]_{1},[x-\\alpha]_{2})</span>, is a polynomial commitment scheme that satisfies completeness, evaluation blinding and extractability as in Def. A.3 in the AGM, under the dlog assumption. What is more, Marlin presents an alternative version of KZG with degree checks that does not require additional powers in <span class="math">\\mathbb{G}_{2}</span>. For our construction, we claim that adding <span class="math">x^{d-\\deg+2}</span> to the pairing and element <span class="math">[Q]_{1}</span> does not affect completeness or extractability. We also argue that under the AGM, no PPT adversary <span class="math">\\mathcal{A}</span> can break soundness by providing a commitment to a polynomial <span class="math">p(X)</span> such that <span class="math">\\deg(p)&gt;\\deg</span>. Indeed, if that is the case, <span class="math">\\deg(Q)=d+1</span> for <span class="math">Q(X)</span> the algebraic representation of <span class="math">[Q]_{1}</span>, which will imply an attack to the <span class="math">d</span>-DHE assumption, as the srs only contains powers <span class="math">[x^{i}]_{1}</span> up to <span class="math">d</span>.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">4.3 KZG as Vector Commitment Scheme</h3>

    <p class="text-gray-300">There is a natural isomorphism between vectors of size <span class="math">m</span> and polynomials of degree <span class="math">m-1</span>; where we can represent <span class="math">\\vec{c}=(c_{1},\\ldots,c_{m})\\in\\mathbb{F}^{m}</span> as <span class="math">C(X)=\\sum_{j=1}^{m}c_{j}B_{j}(X)</span>, where <span class="math">\\mathcal{B}=\\{B_{j}(X)\\}_{j=1}^{m}</span> is a basis of the space of polynomials of degree up to <span class="math">m-1</span>, and vice versa. This fact implies as well a natural relation between polynomial and vector commitments (Def. A.2), where in particular, the former implies the latter. What is more, when the basis <span class="math">\\mathcal{B}</span> chosen to encode the vector consists of Lagrange polynomials we have vector commitments with <em>easy</em> individual position openings: evaluating <span class="math">V(X)</span> in the <span class="math">i-1</span>th interpolation point returns <span class="math">c_{i}</span>.</p>

    <p class="text-gray-300">In this work we will use the protocol by Kate et al. for both cases, polynomial and vector commitments. For the latter, we will not only consider individual openings but also subset openings. In particular, let <span class="math">\\mathbb{H}=\\{1,\\omega,\\ldots,\\omega^{N-1}\\}</span> be a set of roots of unity and <span class="math">\\{\\lambda_{i}(X)\\}_{i=1}^{N}</span> its corresponding Lagrange interpolation set, with vanishing polynomial <span class="math">z_{H}(X)</span>. That is, <span class="math">\\lambda_{i}(\\omega^{i-1})=1</span> and <span class="math">\\lambda_{i}(\\omega^{j})=0</span> for all <span class="math">j\\neq i-1</span>. We have that for some polynomial <span class="math">H(X)</span>,</p>

    <p class="text-gray-300"><span class="math">C(X)-s=(X-\\omega^{i-1})H(X)~{}\\text{if and only if}~{}C(\\omega^{i-1})=c_{i}=s.</span></p>

    <p class="text-gray-300">For a polynomial <span class="math">C_{I}(X)=\\sum_{i\\in I}s_{i}\\tau_{i}(X)</span> where <span class="math">s_{i}</span> are claimed values for <span class="math">v_{i}</span> and <span class="math">\\{\\tau_{i}(X)\\}_{i\\in I}</span> the Lagrange interpolation polynomials of the set <span class="math">\\{\\omega^{i-1}\\}_{i\\in I}</span>,</p>

    <p class="text-gray-300"><span class="math">C(X)-C_{I}(X)=\\prod_{i\\in I}(X-\\omega^{i-1})H(X)~{}\\text{iff}~{}V(\\omega^{i-1})=c_{i}=s_{i}~{}\\text{for all}~{}i\\in I.</span></p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">4.4 Subset openings</h3>

    <p class="text-gray-300">For a vector <span class="math">\\vec{c}\\in\\mathbb{F}^{m}</span> and a subset <span class="math">I\\subset[m]</span>, the subvector opening scheme of Tomescu et. al <em>[28]</em> that works for the VC inspired by KZG presented above, consists on algorithms Open and Verify such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Open}(\\mathsf{srs}_{\\mathsf{KZG}},I,\\vec{c}_{I}):</span> Compute <span class="math">C_{I}(X)=\\sum_{i\\in I}c_{i}\\tau_{i}(X)</span>, where <span class="math">\\{\\tau_{i}(X)\\}</span> are the Lagrange interpolation polynomials of the set <span class="math">\\{\\omega^{i-1}\\}_{i\\in I}</span>, and find <span class="math">H(X)</span> such that for <span class="math">z_{I}(X)=\\prod_{i\\in I}(X-\\omega^{i-1})</span>,</li>

    </ul>

    <p class="text-gray-300"><span class="math">C(X)-C_{I}(X)=z_{I}(X)H(X).</span></p>

    <p class="text-gray-300">Output <span class="math">\\pi_{I}=[H]_{1}=[H(x)]_{1}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Verify}(\\mathsf{srs}_{\\mathsf{KZG}},{\\sf C},I,\\vec{c}_{I},\\pi_{I}):</span> Compute <span class="math">[z_{I}]_{2}=[z_{I}(x)]_{2}</span>, <span class="math">C_{I}(X)=\\sum_{i\\in I}c_{i}\\tau_{i}(X)</span>, and <span class="math">{\\sf C}_{I}=[C_{I}(x)]_{1}</span> and output <span class="math">1</span> if and only if</li>

    </ul>

    <p class="text-gray-300"><span class="math">e\\big{(}{\\sf C}-{\\sf C}_{I},[1]_{2}\\big{)}=e\\big{(}[H]_{1},[z_{I}]_{2}\\big{)}.</span></p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">Open as aggregation of individual proofs</h4>

    <p class="text-gray-300">We will additionally use a result by Tomescu et al. <em>[28]</em> that allows the prover to compute <span class="math">[H]_{1}</span> in time <span class="math">\\mathcal{O}(m\\log^{2}(m))</span> given it already has stored proofs <span class="math">\\{[H_{i}]_{1}\\}_{i\\in I}</span> that <span class="math">C(\\omega^{i-1})=c_{i}</span>. Indeed the prover sets</p>

    <p class="text-gray-300"><span class="math">[H]_{1}=\\sum_{i\\in I}\\left(\\prod_{k=1,k\\neq i}^{m}\\frac{1}{(\\omega^{i-1}-\\omega^{k-1})}\\right)[H_{i}]_{1}</span></p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Remark 1.</h6>

    <p class="text-gray-300">We remark that precomputing all the proofs <span class="math">[H_{1}]_{1},\\ldots,[H_{N}]_{1}</span> that <span class="math">C(\\omega^{i-1})=c_{i}</span> can be achieved in time <span class="math">\\mathcal{O}(N\\log N)</span> using techniques by Feist and Khovratovich <em>[13]</em>. The overview of this technique by Tomescu et al. (<em>[28]</em>, Section 3.4.4, “Computing All <span class="math">u_{i}</span>’s Fast”) is explained well.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">4.5 Multiple Openings</h3>

    <p class="text-gray-300">A KZG proof of opening can naturally be extended to open one polynomial in many points. Indeed, let <span class="math">p(X)</span> be a polynomial, <span class="math">\\vec{\\alpha}\\in\\mathbb{F}^{m}</span> a vector of opening points and <span class="math">\\vec{s}</span> such that <span class="math">s_{i}=p(\\alpha_{i})</span> for all <span class="math">i=1,\\ldots,m</span>. Define <span class="math">C_{\\vec{\\alpha}}(X)</span> as the unique polynomial of degree <span class="math">m-1</span> such that <span class="math">C_{\\vec{\\alpha}}(\\alpha_{i})=s_{i}</span> for all <span class="math">i\\in[m]</span>. We have that <span class="math">p(\\alpha_{i})=s_{i}</span> for all <span class="math">i=1,\\ldots,m</span> if and only if there exists <span class="math">q(X)</span> such that</p>

    <p class="text-gray-300"><span class="math">p(X)-C_{\\vec{\\alpha}}(X)=\\prod_{i=1}^{m}(X-\\alpha_{i})Q(X)</span></p>

    <p class="text-gray-300">We can thus redefine the KZG prover and verifier the following way:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(s,\\pi_{\\mathsf{KZG}})\\leftarrow\\mathsf{KZG}.{\\sf Open}\\big{(}\\mathsf{srs}_{\\mathsf{KZG}},p(X),\\vec{\\alpha}\\big{)}</span>: Prover computes <span class="math">\\{\\tau_{i}(X)\\}_{i=1}^{m}</span> the interpolation Lagrange polynomials for the set <span class="math">\\{\\alpha_{i}\\}_{i=1}^{m}</span>, <span class="math">z_{\\alpha}(X)=\\prod_{i=1}^{m}(X-\\alpha_{i})</span> and define <span class="math">C_{\\vec{\\alpha}}(X)=\\sum_{i=1}^{m}p(\\alpha_{i})\\tau_{i}(X)</span>. Then, it computes</li>

    </ul>

    <p class="text-gray-300"><span class="math">Q(X)=\\frac{p(X)-C_{\\vec{\\alpha}}(X)}{z_{\\alpha}(X)}\\;,</span></p>

    <p class="text-gray-300">sets <span class="math">s_{i}=p(\\alpha_{i}),[Q]_{1}=[Q(x)]_{1}</span>, and outputs <span class="math">(\\vec{s},\\pi_{\\mathsf{KZG}}=[Q]_{1})</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">1/0\\leftarrow\\mathsf{KZG}.{\\sf Verify}\\big{(}\\mathsf{srs}_{\\mathsf{KZG}},\\mathsf{C},\\vec{\\alpha},\\vec{s},\\pi_{\\mathsf{KZG}}\\big{)}</span>: The verifier computes <span class="math">\\{\\tau_{i}(X)\\}_{i=1}^{m}</span>, <span class="math">\\mathsf{C}_{\\vec{\\alpha}}=[C_{\\vec{\\alpha}}(x)]_{1}</span>, <span class="math">[z_{\\alpha}(x)]_{2}</span> and verifies</li>

    </ul>

    <p class="text-gray-300"><span class="math">p(X)-C_{\\vec{\\alpha}}(X)=Q(X)z_{\\alpha}(X)</span></p>

    <p class="text-gray-300">by making the pairing check</p>

    <p class="text-gray-300"><span class="math">e(\\mathsf{C}-\\mathsf{C}_{\\vec{\\alpha}},[1]_{2})=e([Q]_{1},[z_{\\alpha}(x)]_{2}),</span></p>

    <p class="text-gray-300">and outputs <span class="math">1</span> if and only if the equation is satisfied and <span class="math">\\deg(p)\\leq d</span>.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">4.6 KZG for Bivariate Polynomials</h3>

    <p class="text-gray-300">For the protocol in Section 7.2 we will use bivariate polynomials, or polynomials of higher degree. What this mean is that, if we have a bivariate polynomial <span class="math">P(X,Y)</span> with degree up to <span class="math">d_{1}-1</span> in <span class="math">X</span> and <span class="math">d_{2}-1</span> in <span class="math">Y</span> then we require a universal setup with <span class="math">d_{1}d_{2}</span> powers. We work with a version of KZG that uses a univariate setup because these are already available for multiple different curves (i.e. we do <em>not</em> need a specialist setup just for our protocol and can work with prior KZG setups).</p>

    <p class="text-gray-300">We observe that, by using the KZG open algorithm, we can commit to <span class="math">P(X,Y)</span> as <span class="math">[P(x^{d_{2}},x)]_{1}</span>. We must open <span class="math">P(X,Y)</span> in two steps. First we <em>partially</em> open <span class="math">P(X,Y)</span> at some point <span class="math">X=\\alpha</span> to a commitment <span class="math">[P(\\alpha,x)]_{1}</span>. The partial proof is given by a commitment <span class="math">[w_{\\alpha}(x^{d_{2}},x)]</span> to a partial witness</p>

    <p class="text-gray-300"><span class="math">w_{\\alpha}(X,Y)=\\frac{P(X,Y)-P(\\alpha,Y)}{X-\\alpha}</span></p>

    <p class="text-gray-300">We then fully evaluate <span class="math">P(\\alpha,Y)</span> at <span class="math">Y=\\beta</span> via a standard KZG proof with a degree bound of <span class="math">d_{2}-1</span> on <span class="math">[P(\\alpha,x)]_{1}</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">4.7 Proof of Opening of a Pedersen Commitment</p>

    <p class="text-gray-300">Pedersen commitment schemes are a particular case of vector commitments. We will consider them for committing to single values in a zero knowledge way. Thus, the <span class="math">\\mathsf{srs}</span> will additionally output <span class="math">[h]_{1}</span> for some secret <span class="math">\\mathsf{h}</span> and the commitment to some element <span class="math">s</span> is computed as <span class="math">v[1]_{1}+r[\\mathsf{h}]_{1}=[v+\\mathsf{hr}]</span>, for some randomly sampled <span class="math">\\mathsf{h}\\in\\mathbb{F}</span> . We suggest a standard Fiat-Shamired Sigma protocol <em>[24]</em> to demonstrate knowledge of <span class="math">v,r</span> such that <span class="math">\\mathsf{cm}=[v+\\mathsf{hr}]_{1}</span> for some <span class="math">v,r</span>:</p>

    <p class="text-gray-300"><span class="math">R_{\\mathsf{ped}}=\\{(\\mathsf{cm};\\ (v,r)):\\quad\\mathsf{cm}=[v+\\mathsf{hr}]_{1}\\}</span></p>

    <p class="text-gray-300">The proof consists of <span class="math">R=[s_{1}+\\mathsf{h}s_{2}]_{1}</span>, <span class="math">t_{1}=s_{1}+vc</span> and <span class="math">t_{2}=s_{2}+rc</span>, where <span class="math">c=\\mathsf{H}(\\mathsf{cm},R)</span> and <span class="math">s_{1},s_{2}</span> are elements chosen by the verifier. At the end, the verifier checks that <span class="math">R+c\\cdot\\mathsf{cm}=[t_{1}+\\mathsf{h}t_{2}]_{1}</span>.</p>

    <h2 id="sec-19" class="text-2xl font-bold">5 Position-Hiding Linkable Vector Commitments</h2>

    <p class="text-gray-300">We introduce the concept of position-hiding linkable vector commitment schemes. Informally, two vector commitment schemes <span class="math">\\mathsf{VC}_{1}</span> and <span class="math">\\mathsf{VC}_{2}</span> are position-hiding linkable if a prover is able to convince a verifier that for a given commitments <span class="math">\\mathsf{C}</span> corresponding to <span class="math">\\mathsf{VC}_{1}</span> and <span class="math">\\mathsf{cm}</span> corresponding to <span class="math">\\mathsf{VC}_{2}</span>, it is true that all the elements in the vector committed in <span class="math">\\mathsf{cm}</span> are also elements of the vector committed in <span class="math">\\mathsf{C}</span>.</p>

    <p class="text-gray-300">Basically, position-hiding linkability allows the prover to extract or isolate in zero-knowledge elements from some public set or table, and later prove further attributes on them. This new primitive should satisfy three security notions: completeness, as usual; <em>linkability</em>, that captures the fact that if the proof verifies then there is no element committed in <span class="math">\\mathsf{cm}</span> that is not also committed in <span class="math">\\mathsf{C}</span>; and <em>position-hiding</em>, which holds only if no information about the set of elements in <span class="math">\\mathsf{C}</span> that have been used to construct <span class="math">\\mathsf{cm}</span> is leaked.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Definition 5.1 (Position-Hiding Linkability for Vector Commitments).</h6>

    <p class="text-gray-300">Two vector commitment schemes <span class="math">\\mathsf{VC}_{1}</span> and <span class="math">\\mathsf{VC}_{2}</span> are position-hiding linkable if there exist algorithms <span class="math">\\left(\\mathsf{Setup}_{\\mathsf{link}},\\mathsf{Prove}_{\\mathsf{link}},\\mathsf{Verify}_{\\mathsf{link}},\\mathsf{Simulate}_{\\mathsf{link}}\\right)</span> that behave as follows,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}_{\\mathsf{link}}(1^{\\lambda},d_{1},d_{2}):</span> takes as input the security parameter, bounds on the length of vectors in <span class="math">\\mathsf{VC}_{1}</span> and <span class="math">\\mathsf{VC}_{2}</span>, and outputs common parameters <span class="math">\\mathsf{srs}</span> that include <span class="math">\\mathsf{srs}_{1}=\\mathsf{VC}_{1}.\\mathsf{srs}</span> and <span class="math">\\mathsf{srs}_{2}=\\mathsf{VC}_{2}.\\mathsf{srs}</span> as well as trapdoor <span class="math">x</span>, including the corresponding trapdoors <span class="math">x_{1}</span> and <span class="math">x_{2}</span>.</li>

      <li><span class="math">\\mathsf{Prove}_{\\mathsf{link}}(\\mathsf{srs},r,r^{\\prime},\\vec{v},\\vec{a}):</span> on input the <span class="math">\\mathsf{srs}</span>, commitment randomness <span class="math">r</span> to vector <span class="math">\\vec{v}\\in\\mathbb{F}^{N}</span> and commitment randomness <span class="math">r^{\\prime}</span> to <span class="math">\\vec{a}\\in\\mathbb{F}^{m}</span>, outputs a proof <span class="math">\\pi</span> that there exists some <span class="math">I\\subset[N]</span> such that for all <span class="math">j=1,\\ldots,m</span>, <span class="math">a_{j}=v_{i}</span> for some <span class="math">i\\in I</span>.</li>

      <li><span class="math">\\mathsf{Verify}_{\\mathsf{link}}(\\mathsf{srs},\\mathsf{C},\\mathsf{cm},\\pi):</span> On input the <span class="math">\\mathsf{srs}</span>, commitments <span class="math">\\mathsf{C}</span> and <span class="math">\\mathsf{cm}</span>, and proof <span class="math">\\pi</span>, accepts or rejects.</li>

      <li><span class="math">\\mathsf{Simulate}_{\\mathsf{link}}(x,\\mathsf{C},\\mathsf{cm}):</span> On input the trapdoors <span class="math">x</span> and commitments <span class="math">\\mathsf{C}</span> and <span class="math">\\mathsf{cm}</span>, outputs a simulated proof <span class="math">\\pi_{\\mathsf{sim}}</span>,</li>

    </ul>

    <p class="text-gray-300">and satisfy the following properties:</p>

    <h5 id="sec-21" class="text-base font-semibold mt-4">Completeness:</h5>

    <p class="text-gray-300">For all <span class="math">N,m</span> with <span class="math">N\\leq d_{1},m\\leq d_{2}</span>, all <span class="math">\\vec{v}\\in\\mathbb{F}^{N}</span>, and all <span class="math">\\vec{a}\\in\\mathbb{F}^{m}</span> such that for all <span class="math">j=1,\\ldots,m</span>, <span class="math">a_{j}=v_{i}</span> for some <span class="math">i\\in I</span>, it holds that:</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\mathsf{Verify}_{\\mathsf{link}}(\\mathsf{srs},\\mathsf{C},\\mathsf{cm},\\pi)=1\\begin{vmatrix}(\\mathsf{srs},x)\\leftarrow\\mathsf{Setup}_{\\mathsf{link}}(1^{\\lambda},d_{1},d_{2});\\\\ \\mathsf{C}\\leftarrow\\mathsf{VC}_{1}.\\mathsf{Commit}(\\mathsf{srs}_{1},\\vec{v},r);\\\\ \\mathsf{cm}\\leftarrow\\mathsf{VC}_{2}.\\mathsf{Commit}(\\mathsf{srs}_{2},\\vec{a},r^{\\prime});\\\\ \\pi\\leftarrow\\mathsf{Prove}_{\\mathsf{link}}(\\mathsf{srs},r,r^{\\prime},\\vec{v},\\vec{a})\\end{vmatrix}\\right]=1. \\]</p>

    <p class="text-gray-300">Linkability For all  <span class="math">N, m</span>  with  <span class="math">N \\leq d_1, m \\leq d_2</span> , and all PPT adversaries, there exists an extractor  <span class="math">\\mathcal{X}_{\\mathcal{A}}</span>  such that:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname * {P r} \\left[ \\begin{array}{c c} \\mathsf {V e r i f y} _ {\\mathrm {l i n k}} (\\mathsf {s r s}, \\mathsf {C}, \\mathsf {c m}, \\pi) = 1 \\wedge &amp; (\\mathsf {s r s}, x) \\leftarrow \\mathsf {S e t u p} _ {\\mathrm {l i n k}} (1 ^ {\\lambda}, d _ {1}, d _ {2}); \\\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec {v}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= N \\wedge &amp; \\vec {v} \\leftarrow \\mathsf {A} (\\mathsf {s r s}); \\\\ \\big (\\exists j \\in [ m ] s. t. a _ {j} \\neq c _ {i} \\forall i \\in [ N ] \\vee &amp; \\mathsf {C} \\leftarrow \\mathsf {V C} _ {1}. \\mathsf {C o m m i t} (\\mathsf {s r s} _ {1}, \\vec {v}); \\\\ \\mathsf {V C} _ {2}. \\mathsf {C o m m i t} (\\mathsf {s r s} _ {2}, \\vec {a}, r ^ {\\prime}) \\neq \\mathsf {c m} \\big) &amp; (\\pi , \\mathsf {c m}) \\leftarrow \\mathsf {A} (\\mathsf {s r s}, \\mathsf {C}); \\\\ &amp; (\\vec {a}, r ^ {\\prime}) \\leftarrow \\mathcal {X} _ {\\mathcal {A}} (\\mathsf {c m}, \\pi) \\end{array} \\right] = \\mathsf {n e g l} (\\lambda).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Position-Hiding For all  <span class="math">N, m</span>  with  <span class="math">N \\leq d_1</span> ,  <span class="math">m \\leq d_2</span> , for all  <span class="math">\\vec{v}</span>  and  <span class="math">\\vec{a}</span> , all PPT adversaries  <span class="math">\\mathcal{A}</span> , there exists a PPT algorithm Simulate link such that:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left[ \\mathcal {A} (\\mathsf {s r s}, \\mathsf {C}, \\mathsf {c m}, \\pi) = 1 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} (\\mathsf {s r s}, x) \\leftarrow \\mathsf {S e t u p} _ {\\mathrm {l i n k}} (1 ^ {\\lambda}, d _ {1}, d _ {2}) \\\\ \\mathsf {C} \\leftarrow \\mathsf {V C} _ {1}. \\mathsf {C o m m i t} (\\mathsf {s r s} _ {1}, \\vec {v}, r) \\\\ \\mathsf {c m} \\leftarrow \\mathsf {V C} _ {2}. \\mathsf {C o m m i t} (\\mathsf {s r s} _ {2}, \\vec {a}, r ^ {\\prime}) \\\\ \\pi \\leftarrow \\mathsf {P r o v e} _ {\\mathrm {l i n k}} (\\mathsf {s r s}, r, r ^ {\\prime}, \\vec {v}, \\vec {a}) \\end{array} \\right. \\right. \\approx \\left[ \\mathcal {A} (\\mathsf {s r s}, \\mathsf {C}, \\mathsf {c m}, \\pi_ {\\mathsf {s i m}}) = 1 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} (\\mathsf {s r s}, x) \\leftarrow \\mathsf {S e t u p} _ {\\mathrm {l i n k}} (1 ^ {\\lambda}, d _ {1}, d _ {2}) \\\\ \\mathsf {C} \\leftarrow \\mathsf {V C} _ {1}. \\mathsf {C o m m i t} (\\mathsf {s r s} _ {1}, \\vec {v}, r) \\\\ \\mathsf {c m} \\leftarrow \\mathsf {V C} _ {2}. \\mathsf {C o m m i t} (\\mathsf {s r s} _ {2}, \\vec {a}, r ^ {\\prime}) \\\\ \\pi_ {\\mathsf {s i m}} \\leftarrow \\mathsf {S i m u l a t e} _ {\\mathrm {l i n k}} (x, \\mathsf {C}, \\mathsf {c m}) \\end{array} \\right. \\right. \\right. \\right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">In the next sections, we introduce position-hiding linkability for KZG commitments of arbitrary size and Pedersen commitments for single elements (Section 6), as well as for two KZG commitments (Section 7).</p>

    <p class="text-gray-300">In this section we present a method to link a commitment  <span class="math">\\mathsf{C}</span>  to a vector  <span class="math">\\vec{c} \\in \\mathbb{F}^N</span>  (computed as  <span class="math">\\mathsf{C} = [C(x)]_1</span>  with  <span class="math">C(X) = \\sum_{i=1}^{N} c_i \\lambda_i(X)</span> ), to a Pedersen commitment  <span class="math">\\mathsf{cm}</span> . By this we mean a method for a prover to convince a verifier that there exists an  <span class="math">i</span>  such that  <span class="math">\\mathsf{C}</span>  opens to  <span class="math">v</span>  at some  <span class="math">N</span> th rooth of unity  <span class="math">\\omega^{i-1}</span>  and  <span class="math">\\mathsf{cm} = [v + \\mathsf{hr}]_1</span> .</p>

    <p class="text-gray-300">We will consider two groups of roots of unity:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbb{H} = \\{1, \\omega, \\dots, \\omega^{N - 1}\\}</span>  of size  <span class="math">N</span>  with  <span class="math">\\omega^N = 1</span> , Lagrange interpolation polynomials  <span class="math">\\{\\lambda_i(X)\\}_{i=1}^N</span>  where  <span class="math">\\lambda_i(\\omega^{i-1}) = 1</span>  and  <span class="math">\\lambda_i(\\omega^j) = 0</span>  if  <span class="math">j \\neq i - 1</span> , and vanishing polynomial  <span class="math">z_H(X)</span> .</li>

      <li><span class="math">\\mathbb{V}_n = \\{1, \\sigma, \\dots, \\sigma^{n-1}\\}</span>  of size  <span class="math">n = \\log(N) + 6</span>  with  <span class="math">\\sigma^n = 1</span> , Lagrange interpolation polynomials  <span class="math">\\{\\rho_s(X)\\}_{s=1}^n</span>  and vanishing polynomial  <span class="math">z_{V_n}(X)^2</span> .</li>

    </ul>

    <p class="text-gray-300">Our construction can be divided into three main components. The first one is a proof of knowledge for the element  <span class="math">v</span>  committed in  <span class="math">\\mathsf{cm}</span> , that is a proof for relation  <span class="math">R_{\\mathrm{ped}}</span>  as defined in Section 4.7. The second is a modified protocol for computing blinded versions of KZG openings for statements  <span class="math">C(\\omega^{i-1}) = v</span>  that does not reveal the coordinate  <span class="math">i</span>  or the evaluation  <span class="math">v</span> , which we describe below. The high-level idea here is to re-randomize a regular KZG opening with an additional blinding factor. Our third component then proves that the re-randomized vanishing polynomial used for the KZG opening is well-formed, i.e., a NIZK argument (as in Def. A.1) for the relation</p>

    <div class="my-4 text-center"><span class="math-block">R _ {\\text {u n i t y}} = \\left\\{\\left(\\mathsf {s r s}, [ z ] _ {2}; (a, i)\\right): [ z ] _ {2} = \\left[ a (x - \\omega^ {i - 1}) \\right] _ {2} \\wedge (\\omega^ {i - 1}) ^ {N} = 1 \\right\\}</span></div>

    <p class="text-gray-300">Our prover takes  <span class="math">(r&#x27; = \\bot, \\vec{c})</span>  and  <span class="math">(r, v)</span>  as input, where the first tuple represents the vector inside the (deterministic) KZG commitment and the second tuple represents the randomness and value for the pedersen commitment. Let  <span class="math">C(X) = \\sum_{i=1}^{N} c_i \\lambda_i(X)</span>  be the polynomial encoding vector  <span class="math">\\vec{c}</span> . In a regular KZG opening for position  <span class="math">i</span> , the prover would compute  <span class="math">Q(X) = \\frac{C(X) - v}{X - \\omega^{i-1}}</span>  and reveal  <span class="math">Q = [Q(x)]_1</span> . Instead, our prover computes a special kind of obfuscated commitment to  <span class="math">\\omega^{i-1}</span>  by selecting a random  <span class="math">a</span>  and committing to  <span class="math">z(X) = aX - b = a(X - \\omega^{i-1})</span>  where  <span class="math">\\omega^{i-1} = \\frac{b}{a}</span> , as an element  <span class="math">[z]_2 = [z(x)]_2</span> . The blinding factor is necessary, because the set  <span class="math">\\{\\omega^{i-1}\\}_{i=1}^m</span>  is polynomial sized, so revealing  <span class="math">[x - \\omega^{i-1}]_1</span>  would allow</p>

    <p class="text-gray-300">the verifier to do a brute force search to find the index. The prover then computes  <span class="math">[T]_1 = [T(x)]_1</span>  and  <span class="math">[S]_2 = [S(x)]_2</span> , where</p>

    <div class="my-4 text-center"><span class="math-block">T (X) = \\frac {Q (X)}{a} + \\mathsf {h} s, \\quad S (X) = - r - s z (X),</span></div>

    <p class="text-gray-300">and  <span class="math">s</span>  is a uniformly random value chosen by the prover.  <span class="math">T(X)</span>  is the KZG quotient polynomial  <span class="math">Q(X)</span>  divided by  <span class="math">a</span>  (the blinding factor above) to compensate for  <span class="math">z(X)</span>  having that blinding factor. The additional term  <span class="math">[\\mathsf{hs}]_1</span>  mixed in to fully blind the evaluation  <span class="math">[\\frac{Q(X)}{a}]_1</span>  and preserve zero-knowledge.  <span class="math">[S]_2</span>  is a term that compensates for the  <span class="math">\\mathsf{h}</span>  terms in both  <span class="math">[T]_1</span>  and  <span class="math">\\mathsf{cm}</span> . In the pairing equation that checks these points,  <span class="math">[S]_2</span>  will be paired with  <span class="math">\\mathsf{h}</span>  to ensure that it can only cancel out terms containing  <span class="math">\\mathsf{h}</span>  and cannot make incorrect quotient polynomials appear correct.</p>

    <p class="text-gray-300">We use two proofs of knowledge  <span class="math">\\pi_{\\mathrm{ped}}</span>  and  <span class="math">\\pi_{\\mathrm{unity}}</span>  as described in Section 4.7 and Section 6.2 respectively. The proof  <span class="math">\\pi_{\\mathrm{ped}}</span>  is for  <span class="math">v, r</span>  such that  <span class="math">\\mathsf{cm} = [v + \\mathsf{hr}]_1</span> . The proof  <span class="math">\\pi_{\\mathrm{unity}}</span>  is for  <span class="math">a, b</span>  such that  <span class="math">[z]_2 = [ax - b]_2</span>  and  <span class="math">a^N = b^N</span> . The verifier checks the pairing equation</p>

    <div class="my-4 text-center"><span class="math-block">e (\\mathsf {C} - \\mathsf {c m}, [ 1 ] _ {2}) = e ([ T ] _ {1}, [ z ] _ {2}) + e ([ h ] _ {1}, [ S ] _ {2}).</span></div>

    <p class="text-gray-300">This equation asserts that, for the polynomials  <span class="math">C(X), T(X), z(X), S(X)</span>  encoded in  <span class="math">\\mathsf{C}, [T]_1, [z]_2</span> , and  <span class="math">[S]_2</span>  respectively, it holds that</p>

    <div class="my-4 text-center"><span class="math-block">C (X) - v - \\mathsf {h} r = T (X) z (X) + \\mathsf {h} S (X).</span></div>

    <p class="text-gray-300">Now, because  <span class="math">T(X) = \\frac{Q(X)}{a} + s\\mathsf{h}</span> ,  <span class="math">z(X) = a(X - \\omega^{i-1})</span> , and  <span class="math">S(X) = -r - sz(X)</span> , this is</p>

    <div class="my-4 text-center"><span class="math-block">C (X) - v - \\mathsf {h} r = \\left(\\frac {Q (X)}{a} + s \\mathsf {h}\\right) z (X) - \\mathsf {h} r - \\mathsf {h} s z (X) \\Leftrightarrow C (X) - v = \\left(\\frac {Q (X)}{a}\\right) z (X).</span></div>

    <p class="text-gray-300">The full description of our protocol is given in Figure 1.</p>

    <p class="text-gray-300">Prover: Sample blinders  <span class="math">a, s \\gets \\mathbb{F}</span></p>

    <p class="text-gray-300">Using  <span class="math">C(X) = \\sum_{i=1}^{N} c_i \\lambda_i(X)</span> , encoding of  <span class="math">\\vec{c}</span>  and  <span class="math">v, r</span>  such that  <span class="math">\\mathsf{cm} = v[1]_1 + r[\\mathsf{h}]_1</span></p>

    <p class="text-gray-300">Define</p>

    <div class="my-4 text-center"><span class="math-block">z (X) = a \\left(X - \\omega^ {i - 1}\\right), \\quad T (X) = \\frac {C (X) - v}{z (X)} + s \\mathsf {h}, \\quad S (X) = - r - s z (X)</span></div>

    <p class="text-gray-300"><span class="math">\\pi_{\\mathrm{ped}} \\gets \\operatorname{Prove}(R_{\\mathrm{ped}}, \\mathsf{cm}, (v, r))</span></p>

    <p class="text-gray-300"><span class="math">\\pi_{\\mathrm{unity}} \\gets \\operatorname{Prove}(R_{\\mathrm{unity}}, (\\mathsf{srs}, [z]_2), (a, a\\omega^{i-1}))</span></p>

    <p class="text-gray-300">Set  <span class="math">[z]_2 = [z(x)]_2, [T]_1 = [T(x)]_1, [S]_2 = [S(x)]_2</span>  and return  <span class="math">([z]_2, [T]_1, [S]_2, \\pi_{\\mathrm{ped}}, \\pi_{\\mathrm{unity}})</span></p>

    <p class="text-gray-300">Verifier: Accept if and only if the following conditions hold</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} e (\\mathsf {C} - \\mathsf {c m}, [ 1 ] _ {2}) = e ([ T ] _ {1}, [ z ] _ {2}) + e ([ \\mathsf {h} ] _ {1}, [ S ] _ {2}) \\\\ 1 \\leftarrow \\operatorname {V e r i f y} _ {\\text {p e d}} (\\text {s r s}, \\text {c m}, \\pi_ {\\text {p e d}}) \\\\ 1 \\leftarrow \\operatorname {V e r i f y} _ {\\text {u n i t y}} (\\text {s r s}, [ z ] _ {2}, \\pi_ {\\text {u n i t y}}) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Figure 1: Zero-knowledge proof of membership. Shows that  <span class="math">(v,r)</span>  is an opening of  <span class="math">\\mathsf{cm}</span>  and that  <span class="math">\\mathsf{C}</span>  opens to  <span class="math">v</span>  at  <span class="math">\\omega^{i - 1}</span> .</p>

    <p class="text-gray-300">Theorem 1. Let  <span class="math">R_{\\mathrm{ped}}</span>  and  <span class="math">R_{\\mathrm{unity}}</span>  be relations for which zero-knowledge argument of knowledge systems are given. The construction in Figure 1 implies position-hiding linkability for the commitment schemes corresponding to  <span class="math">\\mathsf{C}</span>  and  <span class="math">\\mathsf{cm}</span>  in the algebraic group model under the qSDH and dlog assumptions.</p>

    <p class="text-gray-300">.</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">Intuition.</h4>

    <p class="text-gray-300">The arguments of knowledge for <span class="math">R_{\\sf{ped}}</span> and <span class="math">R_{\\sf{unity}}</span> imply well formation of <span class="math">\\mathsf{cm}</span> and <span class="math">[z]_{2}</span>, i.e. assert that except with negligible probability, <span class="math">\\mathsf{cm}</span> is a pedersen commitment to a value <span class="math">v</span> and <span class="math">[z]_{2}</span> is a commitment to a polynomial <span class="math">z(X)=a(X+\\omega^{i-1})</span> for some <span class="math">i\\in[N]</span>.</p>

    <p class="text-gray-300">Then, the fact that the first verification equation is satisfied imply there exist polynomials <span class="math">T(X),S(X)</span> such that <span class="math">C(X)-(v+\\mathsf{hr})=T(X)z(X)+\\mathsf{h}S(X)</span>. Because the prover does not know <span class="math">\\mathsf{h}</span> in the field, this either implies that the prover gets to know <span class="math">\\mathsf{h}</span> from <span class="math">[\\mathsf{h}]_{1}</span>, breaking <span class="math">\\mathsf{dlog}</span>, or that they output a valid KZG proof for <span class="math">C(\\omega^{i-1})=v</span>, therefore either the statement is true, or the adversary breaks <span class="math">q</span>SDH.</p>

    <p class="text-gray-300">The full proof is given in Appendix B.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">6.2 Correct computation of <span class="math">z(X)</span></h3>

    <p class="text-gray-300">The purpose of this section is provide a zero-knowledge proof of knowledge for relation <span class="math">R_{\\sf{unity}}</span>, i.e. that the prover knows <span class="math">a,b</span> such that <span class="math">[z]_{2}=[ax-b]_{2}</span> and <span class="math">a^{N}=b^{N}</span>. This proof is used as a subprotocol in Fig. 1’s construction for linkability of vector commitments.</p>

    <p class="text-gray-300">In order to prove that <span class="math">\\frac{a}{b}</span> is inside the evaluation domain i.e. is an <span class="math">N</span>th root of unity, we prove that its <span class="math">N</span>th power is one. This can be done in time <span class="math">\\log(N)</span> by defining elements <span class="math">f_{0},\\ldots,f_{\\log(N)}</span> such that satisfy the following conditions: <span class="math">(i)</span> <span class="math">f_{0}=\\frac{a}{b}</span>, <span class="math">(ii)</span> for <span class="math">i=1,\\ldots,\\log(N)</span> <span class="math">f_{i}=f_{i-1}^{2}</span>, and <span class="math">(iii)</span> <span class="math">f_{\\log(N)}=1</span>.</p>

    <p class="text-gray-300">Because we want to assert <span class="math">f_{1}=\\frac{a}{b}</span> for the same elements <span class="math">a,b</span> in <span class="math">z(X)=aX+b</span> and we want to do it without giving <span class="math">z(X)</span> in the field, we will assert this relation by adding 4 extra elements and replacing step <span class="math">(i)</span> with the following constraints:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">f_{0}=z(1)=a-b</span></li>

      <li><span class="math">f_{1}=z(\\sigma)=a\\sigma-b</span></li>

      <li><span class="math">f_{2}=\\frac{f_{0}-f_{1}}{1-\\sigma}=\\frac{a(1-\\sigma)}{1-\\sigma}=a</span></li>

      <li><span class="math">f_{3}=\\sigma f_{2}-f_{1}=\\sigma a-a\\sigma+b=b</span>, and finally</li>

      <li><span class="math">f_{4}=\\frac{f_{2}}{f_{3}}=\\frac{a}{b}</span>.</li>

    </ul>

    <p class="text-gray-300">Once we have <span class="math">(i)</span>, we redefine the other conditions: <span class="math">(ii)</span> For <span class="math">i=0,\\ldots,\\log(N)-1</span>, <span class="math">f_{5+i}=f_{4+i}^{2}</span>, and <span class="math">(iii)</span> <span class="math">f_{4+\\log(N)}=1.</span> For succinctness, we aggregate all these constraints in a polynomial <span class="math">f(X)</span> whose coefficients in the Lagrange basis associated to <span class="math">\\mathbb{V}_{n}</span> are the <span class="math">f_{i}^{\\prime}s</span>, i.e, such that <span class="math">f(\\sigma^{i})=f_{i}</span> using the following lemma:</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Lemma 1.</h6>

    <p class="text-gray-300">Let <span class="math">z(X)</span> be a polynomial of degree <span class="math">1</span>, <span class="math">n=\\log(N)+6</span> and <span class="math">\\sigma</span> such that <span class="math">\\sigma^{n}=1.</span> If there exists a polynomial <span class="math">f(X)\\in\\mathbb{F}[X]</span> such that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">f(X)=z(X)</span> for <span class="math">1,\\sigma</span>.</li>

      <li><span class="math">f(\\sigma^{2})(1-\\sigma)=f(1)-f(\\sigma)</span></li>

      <li><span class="math">f(\\sigma^{3})=\\sigma f(\\sigma^{2})-f(\\sigma)</span></li>

      <li><span class="math">f(\\sigma^{4})f(\\sigma^{3})=f(\\sigma^{2})</span></li>

      <li><span class="math">f(\\sigma^{4+i+1})=f(\\sigma^{4+i})^{2}</span>, for all <span class="math">i=0,\\ldots,\\log(N)-1</span></li>

      <li><span class="math">f(\\sigma^{5+\\log(N)}\\sigma^{-1})=1</span></li>

    </ol>

    <p class="text-gray-300">Then, <span class="math">z(X)=aX-b</span> where <span class="math">\\frac{b}{a}</span> is an <span class="math">N</span>-th root of unity.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The proof is given in Appendix C and we also depict the constraints acting on the evaluations of <span class="math">f(X)</span> in Fig. 2. In this Lemma we have assumed for simplicity that <span class="math">n=\\log(N)+6</span> divides $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$, however it is possible to remove this requirement with appropriate padding.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The prover will construct the polynomial <span class="math">f(X)</span> as</p>

    <p class="text-gray-300"><span class="math">f(X)=(a-b)\\rho_{1}(X)+(a\\sigma-b)\\rho_{2}(X)+a\\rho_{3}(X)+b\\rho_{4}(X)+\\sum_{i=0}^{\\log(N)}\\left(\\frac{a}{b}\\right)^{2^{i}}\\rho_{5+i}(X).</span> (1)</p>

    <p class="text-gray-300">and commit to it in zero-knowledge. Then, it will show it is correct by comparing <span class="math">f(\\sigma^{i})</span> with the corresponding values from the constraints in Lemma 1. Namely, for some <span class="math">\\alpha</span> chosen by the verifier, it</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 2: Coefficients of  <span class="math">f(X)</span>  in the basis  <span class="math">\\{\\rho_s(X)\\}</span>  and relation with those in  <span class="math">z(X)</span>  in Lemma 1.</p>

    <p class="text-gray-300">sets  <span class="math">\\alpha_{1} = \\sigma^{-1}\\alpha</span> ,  <span class="math">\\alpha_{2} = \\sigma^{-2}\\alpha</span>  and sends  <span class="math">v_{1} = f(\\alpha_{1})</span>  and  <span class="math">v_{2} = f(\\alpha_{2})</span>  along with the corresponding proofs of opening. Given  <span class="math">v_{1}, v_{2}</span>  it then shows that the following polynomial, which proves the constraints in Lemma 1, evaluates to 0 in  <span class="math">\\alpha</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} p _ {\\alpha} (X) = - h (X) z _ {V _ {n}} (\\alpha) + \\left(f (X) - z (X)\\right) \\left(\\rho_ {1} (\\alpha) + \\rho_ {2} (\\alpha)\\right) + \\left((1 - \\sigma) f (X) - f (\\alpha_ {2}) + f (\\alpha_ {1})\\right) \\rho_ {3} (\\alpha) \\\\ + \\left(f (X) + f (\\alpha_ {2}) - \\sigma f (\\alpha_ {1})\\right) \\rho_ {4} (\\alpha) + \\left(f (X) f (\\alpha_ {1}) - f (\\alpha_ {2})\\right) \\rho_ {5} (\\alpha) \\\\ + \\left(f (X) - f (\\alpha_ {1}) f (\\alpha_ {1})\\right) \\prod_ {i \\notin [ 5, \\dots , 4 + \\log (N) ]} (\\alpha - \\sigma^ {i}) + \\left(f (\\alpha_ {1}) - 1\\right) \\rho_ {n} (\\alpha). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Note that the polynomials that are already evaluated in  <span class="math">\\alpha</span>  in  <span class="math">p_{\\alpha}(X)</span>  are such that either the verifier can compute them, or they are opened by the prover.</p>

    <p class="text-gray-300">Using  <span class="math">v_{1}, v_{2}</span> , the commitments to  <span class="math">h(X), f(X)</span>  and after computing  <span class="math">\\rho_{i}(\\alpha)</span>  for  <span class="math">i = 1, 2, 3, 4, n - 1, n</span>  and  <span class="math">\\prod_{i \\notin [5, \\dots, 4 + \\log(N)]} (\\alpha - \\sigma^{i})</span> , the verifier computes a commitment  <span class="math">[P]_{1}</span>  to  <span class="math">p_{\\alpha}(X)</span>  and checks that (i)  <span class="math">v_{1}, v_{2}</span>  are correct openings of  <span class="math">f(X)</span>  at  <span class="math">\\alpha_{1} = \\sigma^{-1}\\alpha</span>  and  <span class="math">\\alpha_{2} = \\sigma^{-2}\\alpha</span> , (ii) 0 is a correct opening of  <span class="math">p_{\\alpha}(X)</span>  at  <span class="math">\\alpha</span> , and (iii)  <span class="math">[z]_{2}</span>  has degree 1.</p>

    <p class="text-gray-300">For this last check, we ask the prover to include a term  <span class="math">X^{d - 1}z(X)</span>  in  <span class="math">h(X)</span>  and then the verifier computes  <span class="math">[P]_1</span>  without the terms including  <span class="math">z(X)</span> , i.e., without  <span class="math">-X^d z(X)z_{V_n}(\\alpha) - z(X)(\\rho_1(\\alpha) + \\rho_2(\\alpha))</span> . It will instead add them in the group via the pairing later, to assure that it cannot be the case that  <span class="math">\\deg (z) &amp;gt; 1</span> , unless  <span class="math">\\deg (p_{\\alpha}) &amp;gt; d</span> , which is not possible under the AGM.</p>

    <p class="text-gray-300">We describe the interactive protocol in Fig. 3. In order to turn this public-coin interactive argument into a NIZK we can apply the Fiat-Shamir heuristic: all challenges sent by the verifier are instead generated from a cryptographic hash function.</p>

    <p class="text-gray-300">Theorem 2. The protocol in Fig. 3 is a knowledge-sound argument (as defined in Def.A.1) for relation  <span class="math">\\mathsf{R}_{\\text {unity }}</span>  if KZG is a sound polynomial commitment scheme, under the the Algebraic Group and Random Oracle models. When used as a building block in the argument of Figure 1, the whole protocol satisfies zero-knowledge <span class="math">^3</span> .</p>

    <p class="text-gray-300">Intuition. We first define an extractor that will use the algebraic representations provided by the adversary. We must show that the output of this extractor is a valid witness with overwhelming probability. The proof proceeds via a series of games where the final game is statistically hard.  <span class="math">\\mathsf{Game}_0</span>  is the knowledge soundness game for the protocol in Fig 3.  <span class="math">\\mathsf{Game}_1</span>  is defined by  <span class="math">\\mathsf{Game}_0</span>  except that it checks whether  <span class="math">f(\\alpha_1) = v_1</span> ,  <span class="math">f(\\alpha_2) = v_2</span>  and  <span class="math">p_{\\alpha}(\\alpha) = 0</span> . The advantage of  <span class="math">\\mathcal{A}</span>  in  <span class="math">\\mathsf{Game}_1</span>  is negligible close to the one in  <span class="math">\\mathsf{Game}_0</span>  or it breaks soundness of the KZG polynomial commitment scheme.  <span class="math">\\mathsf{Game}_2</span>  is defined as  <span class="math">\\mathsf{Game}_1</span>  except that it also checks whether the degree of  <span class="math">z(X)</span> , the algebraic representation of  <span class="math">[z]_2</span> , is one. Note that if  <span class="math">deg(z) &amp;gt; 1</span>  then  <span class="math">p(X)</span> , the algebraic representation of  <span class="math">[P]_1</span> , would be a polynomial of degree higher than  <span class="math">d</span> , where  <span class="math">d</span>  is the bound for the powers of  <span class="math">x</span>  the adversary has access to. The advantage of the adversary in  <span class="math">\\mathsf{Game}_2</span>  then is the same as in  <span class="math">\\mathsf{Game}_1</span>  unless they are able to break  <span class="math">q</span>  DHE and compute  <span class="math">[x^{d + 1}]</span> .</p>

    <p class="text-gray-300">Now, because  <span class="math">\\alpha</span>  is sent by the verifier after the prover sends  <span class="math">[F]_1, [H]_1</span> , under the ROM we have that either  <span class="math">p(X) - ((\\rho_n(X) + \\rho_1(X)) + z_{V_n}(X)X^{d-1})z(X) = 0</span>  or  <span class="math">\\alpha</span>  is one of its roots, so we conclude that the polynomial equation holds with overwhelming probability. Finally, note that its evaluation in each of the elements of  <span class="math">\\mathbb{V}_n</span> , implies satisfiability of one of the constraints in Lemma 1 and as it includes them all, we have well formation of the polynomial  <span class="math">z(X)</span>  such that  <span class="math">[z]_2 = [z(x)]_2</span> .</p>

    <p class="text-gray-300">Common input:  <span class="math">[z]_2</span></p>

    <p class="text-gray-300">Prover: Sample  <span class="math">r_0, r_1, r_2, r_3 \\stackrel{\\</span>}{\\leftarrow} \\mathbb{F}<span class="math">  and let  </span>r(X) \\gets r_1 + r_2 X + r_3 X^2$</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} f (X) = (a - b) \\rho_ {1} (X) + (a \\sigma - b) \\rho_ {2} (X) + a \\rho_ {3} (X) + b \\rho_ {4} (X) + \\sum_ {i = 0} ^ {\\log (N)} \\left(\\frac {a}{b}\\right) ^ {2 ^ {i}} \\rho_ {5 + i} (X) \\\\ + r _ {0} \\rho_ {5 + \\log (N)} (X) + r (X) z _ {V _ {n}} (X), \\\\ \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} p (X) = \\left(f (X) - (a X - b)\\right) \\left(\\rho_ {1} (X) + \\rho_ {2} (X)\\right) + \\left((1 - \\sigma) f (X) - f (\\sigma^ {- 2} X) + f (\\sigma^ {- 1} X)\\right) \\rho_ {3} (X) \\\\ + \\left(f (X) + f \\left(\\sigma^ {- 2} X\\right) - \\sigma f \\left(\\sigma^ {- 1} X\\right)\\right) \\rho_ {4} (X) + \\left(f (X) f \\left(\\sigma^ {- 1} X\\right) - f \\left(\\sigma^ {- 2} X\\right)\\right) \\rho_ {5} (X) \\\\ + \\left(f (X) - f (\\sigma^ {- 1} X) f (\\sigma^ {- 1} X)\\right) \\prod_ {i \\notin [ 5; 4 + \\log (N) ]} (X - \\sigma^ {i}) + \\left(f (\\sigma^ {- 1} X) - 1\\right) \\rho_ {n} (X), \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Set  <span class="math">\\hat{h}(X) = \\frac{p(X)}{z_{V_n}(X)}</span> ,  <span class="math">h(X) = \\hat{h}(X) + X^{d-1}z(X)</span>  and output  <span class="math">([F]_1 = [f(x)]_1, [H]_1 = [h(x)]_1)</span> .</p>

    <p class="text-gray-300">Verifier: Send challenge  <span class="math">\\alpha \\in \\mathbb{F}</span></p>

    <p class="text-gray-300">Prover:  <span class="math">\\alpha_{1} = \\sigma^{-1}\\alpha</span> ,  <span class="math">\\alpha_{2} = \\sigma^{-2}\\alpha</span> ;</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} p _ {\\alpha} (X) = - z _ {V _ {n}} (\\alpha) h (X) + \\left(f (X) - z (X)\\right) \\left(\\rho_ {1} (\\alpha) + \\rho_ {2} (\\alpha)\\right) + \\left((1 - \\sigma) f (X) - f (\\alpha_ {2}) + f (\\alpha_ {1})\\right) \\rho_ {3} (\\alpha) \\\\ + \\left(f (X) + f (\\alpha_ {2}) - \\sigma f (\\alpha_ {1})\\right) \\rho_ {4} (\\alpha) + \\left(f (X) f (\\alpha_ {1}) - f (\\alpha_ {2})\\right) \\rho_ {5} (\\alpha) \\\\ + \\left(f (X) - f (\\alpha_ {1}) f (\\alpha_ {1})\\right) \\prod_ {i \\notin [ 5; 4 + \\log (N) ]} (\\alpha - \\sigma^ {i}) + \\left(f (\\alpha_ {1}) - 1\\right) \\rho_ {n} (\\alpha), \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Compute</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\left(v _ {1}, v _ {2}\\right), \\pi_ {1}\\right) \\leftarrow \\text {K Z G . O p e n} \\left(\\operatorname {s r s} _ {\\text {K Z G}}, f (X), \\deg = \\perp , \\left(\\alpha_ {1}, \\alpha_ {2}\\right)\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">(0, \\pi_ {2}) \\leftarrow \\text {K Z G . O p e n} (\\text {s r s} _ {\\text {K Z G}}, p _ {\\alpha} (X), \\deg = \\perp , \\alpha),</span></div>

    <p class="text-gray-300">and output  <span class="math">(v_{1},v_{2},\\pi_{1},\\pi_{2})</span></p>

    <p class="text-gray-300">Verifier: Set  <span class="math">\\alpha_{1} = \\sigma^{-1}\\alpha</span> ;  <span class="math">\\alpha_{2} = \\sigma^{-2}\\alpha</span></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} [ P ] _ {1} = - z _ {V _ {n}} (\\alpha) [ H ] _ {1} + \\left(\\rho_ {1} (\\alpha) + \\rho_ {2} (\\alpha)\\right) [ F ] _ {1} + \\rho_ {3} (\\alpha) \\left((1 - \\sigma) [ F ] _ {1} + v _ {1} - v _ {2}\\right) + \\rho_ {4} (\\alpha) \\left([ F ] _ {1} + v _ {2} - \\sigma v _ {1}\\right) \\\\ + \\rho_ {5} (\\alpha) \\left(v _ {1} [ F ] _ {1} - v _ {2}\\right) + \\rho_ {n} (\\alpha) \\left(v _ {1} - 1\\right) + \\prod_ {i \\notin [ 5, \\dots , 4 + \\log (N) ]} \\left(\\alpha - \\sigma^ {i}\\right) \\left([ F ] _ {1} - v _ {1} ^ {2}\\right), \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Parse  <span class="math">\\pi_2 = [q]_1</span>  and accept if and only if</p>

    <div class="my-4 text-center"><span class="math-block">1 \\leftarrow K Z G. V e r i f y \\left(\\operatorname {s r s} _ {K Z G}, [ F ] _ {1}, \\deg = \\perp , (\\alpha_ {1}, \\alpha_ {2}), (v _ {1}, v _ {2}), \\pi_ {1}\\right),</span></div>

    <div class="my-4 text-center"><span class="math-block">e \\left([ P ] _ {1}, [ 1 ] _ {2}\\right) + e \\left(- \\left(\\rho_ {1} (\\alpha) + \\rho_ {2} (\\alpha)\\right) - z _ {V _ {n}} (\\alpha) \\left[ x ^ {d - 1} \\right] _ {1}, [ z ] _ {2}\\right) = e \\left([ q ] _ {1}, [ x - \\alpha ] _ {2}\\right)</span></div>

    <p class="text-gray-300">Figure 3: NIZK argument of knowledge for  <span class="math">\\mathsf{R}_{\\mathrm{unity}}</span>  and  <span class="math">\\deg (z)\\leq 1</span></p>

    <p class="text-gray-300">The full proof is in Appendix D.</p>

    <h2 id="sec-27" class="text-2xl font-bold">7 Lookup tables for hiding values</h2>

    <p class="text-gray-300">In this section we present the algorithms for position-hiding linkability of KZG vector commitment schemes. The aim is to prove that a commitment <span class="math">\\mathsf{cm}</span> contains a <em>subset</em> of some larger vector committed in <span class="math">\\mathsf{C}</span>. We refer to a subset and not to a subvector since our scheme proves that all the elements committed in <span class="math">\\mathsf{cm}</span> are also committed in <span class="math">\\mathsf{C}</span>, but with no specific order and possible repetitions. This is essentially a lookup table if we consider that <span class="math">\\mathsf{C}</span> contains the honestly generated table.</p>

    <h4 id="sec-28" class="text-lg font-semibold mt-6">Concrete efficiency.</h4>

    <p class="text-gray-300">Our lookup proof has preprocessing time for <span class="math">\\mathsf{C}</span> of <span class="math">N\\log N</span> <span class="math">\\mathbb{G}_{2}</span> operations, for <span class="math">N</span> the size of the table. Prover time is <span class="math">m\\log(N)</span> scalar multiplications for <span class="math">m</span> the size of the subset, proof size is constant and verifier time <span class="math">\\log\\log N</span> scalar multiplications and constant number of pairing checks; additionally, update of proofs can be done in <span class="math">O(N)</span> <span class="math">\\mathbb{G}_{2}</span> operations;</p>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">Preliminaries</h4>

    <p class="text-gray-300">We will consider three evaluation domains</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbb{H}=\\{1,\\omega,\\ldots,\\omega^{N-1}\\}</span> is a group of roots of unity with Lagrange and vanishing polynomials <span class="math">\\{\\lambda_{i}(X)\\}_{i=1}^{N},z_{H}(X)</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. For subset <span class="math">\\mathbb{H}_{I}=\\{\\omega^{i-1}\\}_{i\\in I}</span> of <span class="math">\\mathbb{H}</span> defined by <span class="math">I\\subset[N]</span>, <span class="math">\\{\\tau_{i}(X)\\}_{i\\in I}</span> is the set of its interpolation Lagrange polynomials with degree $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1<span class="math"> and </span>z_{I}(X)<span class="math"> its vanishing polynomial. Note that typically </span>\\mathbb{H}_{I}$ is not a subgroup.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For some constant <span class="math">m</span> that bounds the size of the vector committed in <span class="math">\\mathsf{cm}</span>, we consider another group of roots of unity <span class="math">\\mathbb{V}_{m}=\\{1,\\nu,\\ldots,\\nu^{m-1}\\}</span>, where <span class="math">\\nu^{m}=1</span>, as well as its Lagrange and vanishing polynomials, <span class="math">\\{\\mu_{j}(X)\\}_{j=1}^{m}</span> and <span class="math">z_{V_{m}}(X)</span>.</li>

    </ol>

    <h3 id="sec-30" class="text-xl font-semibold mt-8">7.1 Technical Overview</h3>

    <p class="text-gray-300">Our scheme uses as subprotocol a NIZK argument of knowledge for relation <span class="math">\\mathsf{R}_{\\mathsf{unity}}</span>,</p>

    <p class="text-gray-300"><span class="math">R_{\\mathsf{unity}}=\\left\\{(\\mathsf{srs},[z_{I}]_{2},N;\\ (I,r)):\\ I\\subset[N]\\ \\wedge\\ [z_{I}]_{2}=r\\prod_{i\\in I}[x-\\omega^{i-1}]_{2},\\ \\text{s.t.}(\\omega^{i-1})^{N}=1,\\forall i\\in I\\right\\}</span></p>

    <p class="text-gray-300">The proof for this relation will be divided in two parts, one is a proof of relation</p>

    <p class="text-gray-300"><span class="math">R^{\\prime}_{\\mathsf{unity}}=\\left\\{\\ \\ (\\mathsf{srs},[u]_{1},\\mathbb{H},\\mathbb{V}):\\ [u]_{1}=[u(x)]_{1}\\ \\text{for}\\ u(X)\\ \\text{s.t.}\\ \\forall\\nu^{j}\\in\\mathbb{V},\\ u(\\nu^{j})=\\omega^{i},\\ \\text{for some}\\ \\omega^{i}\\in\\mathbb{H}\\ \\ \\right\\},</span></p>

    <p class="text-gray-300">and the other a proof that there exists some polynomial <span class="math">H(X)</span> s.t. <span class="math">z_{I}(u(X))=z_{V_{m}}H(X)</span>.</p>

    <p class="text-gray-300">In our protocol, the prover takes as input a commitment <span class="math">C(X)=\\sum_{i=1}^{N}c_{i}\\lambda_{i}(X)</span> to the lookup table <span class="math">\\vec{c}</span>, a structured reference string <span class="math">\\mathsf{srs}</span>, a commitment</p>

    <p class="text-gray-300"><span class="math">\\mathsf{cm}=[\\phi(x)]_{1}=\\left[\\sum_{j=1}^{m}a_{j}\\mu_{j}(x)+a_{m+1}z_{V_{m}}(x)\\right]_{1}</span></p>

    <p class="text-gray-300">to some vector <span class="math">\\vec{a}</span> and the opening witness <span class="math">\\vec{a}=(a_{1},\\ldots,a_{m+1})</span>. Here <span class="math">a_{m+1}</span> is a random field element that blinds <span class="math">\\mathsf{cm}</span>. The prover must show that it knows an opening <span class="math">\\phi(X)=\\sum_{j=1}^{m}a_{j}\\mu_{j}(X)+a_{m+1}z_{V_{m}}(X)</span> to <span class="math">\\mathsf{cm}</span> such that <span class="math">a_{j}\\in\\{c_{i}\\}_{i=1}^{N}</span> for all <span class="math">1\\leq j\\leq m</span>. The full argument is given in Fig. 4 and can be divided into three steps.</p>

    <p class="text-gray-300">First, the prover considers the subset <span class="math">I\\subset[N]</span> such that for all <span class="math">j=1,\\ldots,m</span>, <span class="math">a_{j}=c_{i}</span> for some <span class="math">i\\in I</span>, and constructs the subvector <span class="math">\\vec{c}_{I}=(c_{i})_{i\\in I}</span> of <span class="math">\\vec{c}</span>. It commits to it in the Lagrange basis corresponding to <span class="math">\\{\\omega^{i-1}\\}_{i\\in I}</span>; namely, <span class="math">C_{I}(X)=\\sum_{i\\in I}c_{i}\\tau_{i}(X)</span>. Basically, the prover isolates the elements of <span class="math">\\vec{c}</span> that will compare with <span class="math">\\vec{a}</span> so they can work with polynomials of smaller degree.</p>

    <p class="text-gray-300">To convince the verifier that all the elements in <span class="math">C_{I}(X)</span> are elements of <span class="math">C(X)</span>, it provides commitments to <span class="math">z_{I}(X),H_{1}(X)</span> such that</p>

    <p class="text-gray-300"><span class="math">C(X)-C_{I}(X)=z_{I}(X)H_{1}(X).</span> (2)</p>

    <p class="text-gray-300">Here is the place where the precomputation is used: <span class="math">C(X)</span> has degree <span class="math">N</span> and so does <span class="math">H_{1}(X)</span>. In order to compute a commitment to <span class="math">H_{1}(X)</span>, we use the method described in Section 4.4. This is at the same time the most expensive step in updating a proof whenever <span class="math">C(X)</span> is changed. However, if <span class="math">c_{i}</span> values are updated in known order, and we precompute an opening for <span class="math">\\tau_{i}</span>, then whenever new <span class="math">c_{i}</span> is available all openings can be updated in <span class="math">O(N)</span> time, hence the claimed update cost.</p>

    <p class="text-gray-300">Our challenge now is hiding <span class="math">C_{I}(X)</span> and <span class="math">z_{I}(X)</span> from the verifier without breaking soundness. In our solution the prover first demonstrates that <span class="math">z_{I}(X)</span> is of the right form, meaning it is the vanishing polynomial of some subset <span class="math">\\mathbb{H}_{I}</span> of <span class="math">\\mathbb{H}</span>; specifically, we need not only a hiding commitment but also a zero-knowledge proof of well formation of <span class="math">z_{I}(X)</span>.</p>

    <p class="text-gray-300">We divide the proof of well formation of <span class="math">z_{I}(X)</span> in two steps. First, the prover creates the polynomial <span class="math">u(X)=\\sum_{j=1}^{m}\\omega^{i_{j}}\\mu_{j}(X)</span> of degree <span class="math">m-1</span> whose coefficients are the roots of unity <span class="math">\\{\\omega^{i-1}\\}_{i\\in I}</span> and prove, in zero knowledge, its well formation. For that, it demonstrates that for all <span class="math">\\nu^{j}\\in\\mathbb{V}</span> it is the case that <span class="math">(u(\\nu^{j}))^{N}=1</span>, via a call to a subprotocol <span class="math">\\Pi_{\\textsf{unity}^{\\prime}}</span> that we describe in Section 7.2. This guarantees that <span class="math">u(X)</span> is a commitment to elements in <span class="math">\\mathbb{H}</span>. Secondly, on input a commitment to <span class="math">u(X)</span> as above and given that <span class="math">u(X)</span> passes the verification of <span class="math">\\Pi_{\\textsf{unity}^{\\prime}}</span>, we prove well formation of <span class="math">z_{I}(X)</span> and thus that it satisfies relation <span class="math">R_{\\textsf{unity}}</span>. To achieve this we use the fact that all the coefficients of <span class="math">u(X)</span> in the basis <span class="math">\\{\\mu_{j}(X)\\}_{j=1}^{m}</span> are roots of <span class="math">z_{I}(X)</span>. For that, prover convinces verifier that</p>

    <p class="text-gray-300"><span class="math">z_{I}(u(X))=z_{V_{m}}(X)H_{2}(X),\\text{ for some polynomial }H_{2}(X).</span> (3)</p>

    <p class="text-gray-300">Finally, note that <span class="math">C_{I}(X)</span> has been committed to in an unknown-to-the-verifier Lagrange basis, which is <span class="math">\\{\\tau_{i}(X)\\}</span>. So the last step of our argument consists on linking the commitment to <span class="math">C_{I}(X)</span> with <span class="math">[\\phi(x)]_{1}</span>, which is an input to the argument and a commitment to the same element in a known basis. The prover does so by providing <span class="math">H_{3}(X)</span> such that</p>

    <p class="text-gray-300"><span class="math">C_{I}(u(X))-\\phi(X)=z_{V_{m}}(X)H_{3}(X).</span> (4)</p>

    <p class="text-gray-300">In order to achieve zero-knowledge, upon receiving an aggregation challenge <span class="math">\\chi</span> from the verifier, the prover actually provides one commitment <span class="math">[H_{2}]_{1}+\\chi[H_{3}]_{1}</span> to prove equations 3 and 4 together.</p>

    <p class="text-gray-300">Note that for equation 2 to be satisfied, <span class="math">C_{I}(X)</span> cannot take more than once each of the coefficients of <span class="math">C(X)</span>. On the other hand, when linking <span class="math">C_{I}(X)</span> and <span class="math">\\phi(X)</span> through equation 4, we can only prove that all the coefficients of <span class="math">\\phi(X)</span> in the basis <span class="math">\\{\\mu_{j}(X)\\}_{j=1}^{m}</span> are also coefficients of <span class="math">C_{I}(X)</span> in the basis <span class="math">\\{\\tau_{i}(X)\\}_{i\\in I}</span>, but we cannot say in which order or how many times each of them appears. At the end, what we get, is a lookup table argument that assures that some element <span class="math">[\\phi(x)]_{1}</span> is a commitment in the Lagrange basis <span class="math">\\{\\mu_{j}(X)\\}_{j=1}^{m}</span> to some vector <span class="math">\\vec{a}=(a_{1},\\ldots,a_{m})</span> such that for all <span class="math">j=1,\\ldots,m</span> there exists some <span class="math">i\\in I</span> such that <span class="math">a_{j}=c_{i}</span>, i.e., a lookup table for potentially repeated indexes.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Theorem 3.</h6>

    <p class="text-gray-300">Suppose that the argument of Fig. 4 is instantiated with a knowledge-sound scheme for relation <span class="math">\\mathcal{R}^{\\prime}_{\\textsf{unity}}</span>. Then in the AGM with non-programmable ROs, either the argument of Fig. 4 implies linkability for the vector commitment schemes of <span class="math">\\mathsf{C}</span> and <span class="math">\\mathsf{cm}</span>, or there exists an adversary that breaks the <span class="math">q</span>-SDH assumption.</p>

    <h5 id="sec-32" class="text-base font-semibold mt-4">Intuition</h5>

    <p class="text-gray-300">We prove linkability through a sequence of games. <span class="math">\\mathsf{Game}_{0}</span> is the linkability game for the protocol of Fig. 4. <span class="math">\\mathsf{Game}_{1}</span> additionally checks that: <span class="math">(i)</span> <span class="math">[u]_{1}</span> is the commitment to a polynomial <span class="math">u(X)</span> such that <span class="math">u(\\alpha)=v_{1}</span>, <span class="math">(ii)</span> <span class="math">[P]_{1}</span> encodes a polynomial <span class="math">P_{1}(X)=z_{I}(X)+\\chi C_{I}(X)</span> such that <span class="math">P_{1}(v_{1})=v_{2}</span>, i.e, <span class="math">P_{1}(u(\\alpha))=z_{I}(u(\\alpha))+\\chi C_{I}(u(\\alpha))=v_{2}</span>, and <span class="math">(iii)</span> <span class="math">[P]_{2}</span> is the commitment to a polynomial <span class="math">P_{2}(X)=v_{2}-\\chi\\phi(X)-z_{V_{m}}(\\alpha)H_{2}(X)</span> such that <span class="math">P_{2}(\\alpha)=0</span>, that is, <span class="math">z_{I}(u(\\alpha))+\\chi C_{I}(u(\\alpha))-\\chi\\phi(\\alpha)=z_{V_{m}}(\\alpha)H_{2}(\\alpha)</span>. Soundness of the KZG polynomial commitment scheme assures that the advantages of <span class="math">\\mathcal{A}</span> in both games have a negligible difference.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Game}_{2}</span> behaves identically to <span class="math">\\mathsf{Game}_{1}</span> but it also verifies that <span class="math">u(X)</span> is such that <span class="math">u(\\nu^{j})^{N}=1</span>. The advantage of <span class="math">\\mathcal{A}</span> in <span class="math">\\mathsf{Game}_{2}</span> is then the same as in <span class="math">\\mathsf{Game}_{1}</span>, due to knowledge soundness of the argument for <span class="math">\\mathcal{R}^{\\prime}_{\\textsf{unity}}</span>. <span class="math">\\mathsf{Game}_{3}</span> works as <span class="math">\\mathsf{Game}_{2}</span> but further checks that <span class="math">(iv)</span> <span class="math">C(X)-C_{I}(X)=z_{I}(X)H_{1}(X)</span>. The advantage of the adversary in <span class="math">\\mathsf{Game}_{3}</span> is the same as in <span class="math">\\mathsf{Game}_{2}</span>, unless the trapdoor <span class="math">x</span> is a root to the polynomial, in which case we can use <span class="math">\\mathcal{A}</span> as a subroutine for a successful adversary against <span class="math">q</span>SDH. This</p>

    <p class="text-gray-300">Common input:  <span class="math">\\mathsf{C} = [C(x)]_1</span> , for  <span class="math">C(X) = \\sum_{i=1}^{N} c_i \\lambda_i(X)</span>  and  <span class="math">\\mathsf{cm} = [\\phi(x)]_1</span> .</p>

    <p class="text-gray-300">Prover: Take as input srs and  <span class="math">\\phi(X)</span>  and proof  <span class="math">[Q(x)]_2</span>  attesting that  <span class="math">\\{c_i\\}_{i \\in I}</span>  are openings of C. I.e., a commitment to  <span class="math">Q(X) = \\frac{C(X) - \\sum_{i \\in I} c_i \\tau_i(X)}{\\prod_{i \\in I} (X - \\omega^{i-1})}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Choose blinders  <span class="math">r_1, r_2, r_3, r_4, r_5, r_6, r_7 \\stackrel{\\S}{\\leftarrow} \\mathbb{F}</span>  uniformly at random.</li>

      <li>For  <span class="math">\\mathbb{H}_I = \\{\\omega^{i - 1}\\}_{i\\in I}</span> , compute the interpolation polynomials  <span class="math">\\{\\tau_i(X)\\}_{i\\in I}</span> .</li>

      <li>Define  <span class="math">z_{I}(X) = r_{1}\\prod_{i\\in I}(X - \\omega^{i - 1})</span>  and  <span class="math">C_I(X) = \\sum_{i\\in I}c_i\\tau_i(X) + (r_2 + r_3X + r_4X^2)z_I(X)</span> .</li>

      <li>Compute  <span class="math">[H_1(x)]_2 = [r_1^{-1}Q(x) - (r_2 + r_3x + r_4x^2)]_2</span> .</li>

      <li>Define  <span class="math">\\omega^{i_j}</span>  as the  <span class="math">j</span> th element in  <span class="math">\\{\\omega^{i - 1}\\}_{i\\in I}</span>  and compute</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">u (X) = \\sum_ {j = 1} ^ {m} \\omega^ {i _ {j}} \\mu_ {j} (X) + (r _ {5} + r _ {6} X + r _ {7} X ^ {2}) z _ {V _ {m}} (X).</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute a proof  <span class="math">\\pi_{\\text{unity}&#x27;}</span>  as in Fig. 5, proving that  <span class="math">[u]_1</span>  satisfies  <span class="math">R_{\\text{unity}}&#x27;</span> .</li>

      <li>Output  <span class="math">[C_I]_1 = [C_I(x)]_1</span> ,  <span class="math">[z_I]_1 = [z_I(x)]_1</span> ,  <span class="math">[u]_1 = [u(x)]_1</span> ,  <span class="math">[H_1]_2 = [H_1(x)]_2</span> ,  <span class="math">\\pi_{\\text{unity}&#x27;}</span> .</li>

    </ul>

    <p class="text-gray-300">Verifier: Send challenge  <span class="math">\\chi \\in \\mathbb{F}</span></p>

    <p class="text-gray-300">Prover: Find  <span class="math">H_{2}(X)</span>  such that  <span class="math">z_{I}(u(X)) + \\chi (C_{I}(u(X)) - \\phi (X)) = z_{V_{m}}(X)H_{2}(X)</span> Output  <span class="math">[H_2]_1 = [H_2(x)]_1</span></p>

    <p class="text-gray-300">Verifier: Send challenge  <span class="math">\\alpha \\in \\mathbb{F}</span></p>

    <p class="text-gray-300">Prover: Compute</p>

    <p class="text-gray-300"><span class="math">p_1(X)\\gets z_I(X) + \\chi C_I(X)</span> <span class="math">p_2(X)\\gets z_I(u(\\alpha)) + \\chi (C_I(u(\\alpha)) - \\phi (X)) - z_{V_m}(\\alpha)H_2(X)</span> <span class="math">(v_{1},\\pi_{1})\\gets \\mathsf{KZG.Open}(\\mathsf{srs}_{\\mathsf{KZG}},u(X),\\deg = \\bot ,\\alpha)</span> <span class="math">(v_{2},\\pi_{2})\\gets \\mathsf{KZG.Open}(\\mathsf{srs}_{\\mathsf{KZG}},p_{1}(X),\\deg = \\bot ,v_{1})</span> <span class="math">(0,\\pi_3)\\gets \\mathsf{KZG.Open}(\\mathsf{srs}_{\\mathsf{KZG}},p_2(X),\\deg = \\bot ,\\alpha)</span></p>

    <p class="text-gray-300">Output  <span class="math">(v_{1},v_{2},\\pi_{1},\\pi_{2},\\pi_{3})</span></p>

    <p class="text-gray-300">Verifier: Compute  <span class="math">[P_1]_1 \\gets [z_I]_1 + \\chi [C_I]_1</span>  and  <span class="math">[P_2]_1 \\gets v_2 - \\chi \\mathsf{cm} - z_{V_m}(\\alpha)[H_2]_1</span> .</p>

    <p class="text-gray-300">Accept if and only if (i)  <span class="math">V_{\\pi_{\\mathrm{unity}}^{\\prime}}</span>  accepts, (ii)</p>

    <p class="text-gray-300"><span class="math">1\\gets \\mathsf{KZG.Verify}\\big(\\mathsf{srs}_{\\mathsf{KZG}},[u]_1,\\deg = \\bot ,\\alpha ,v_1,\\pi_1\\big)</span> <span class="math">1\\gets \\mathsf{KZG.Verify}\\big(\\mathsf{srs}_{\\mathsf{KZG}},[P_1]_1,\\deg = \\bot ,v_1,v_2,\\pi_2\\big)</span> <span class="math">1\\gets \\mathsf{KZG.Verify}\\big(\\mathsf{srs}_{\\mathsf{KZG}},[P_2]_1,\\deg = \\bot ,\\alpha ,0,\\pi_3\\big),</span>  and</p>

    <p class="text-gray-300">(iii)  <span class="math">e\\big([C]_1 - [C_I]_1,[1]_2\\big) = e\\big([z_I]_1,[H_1]_2\\big)</span>  (5)</p>

    <p class="text-gray-300">Figure 4: Lookup table for non-repeated indexes that uses a proof for  <span class="math">\\mathsf{R}_{\\mathrm{unity}}^{\\prime}</span>  as blackbox.</p>

    <p class="text-gray-300">polynomial equation implies then that <span class="math">C(\\omega^{i-1})-C_{I}(\\omega^{i-1})=0</span> for all <span class="math">i\\in I</span> and thus <span class="math">C_{I}(X)</span> encodes the subvector <span class="math">\\vec{c}_{I}</span> of <span class="math">\\vec{c}</span>. Lastly, we show that the advantage of <span class="math">\\mathcal{A}</span> in <span class="math">\\mathsf{Game}_{3}</span> is negligible.</p>

    <p class="text-gray-300">Because <span class="math">\\alpha</span> was sent after prover sends <span class="math">[C_{I}]_{1},[z_{I}]_{1},[u]_{1}</span>, <span class="math">[H_{1}]_{1}</span> and <span class="math">[H_{2}]_{1}</span>, except with negligible probability, condition <span class="math">(iii)</span> holds as a polynomial equation for all <span class="math">X</span>, that is, <span class="math">z_{I}(u(X))+\\chi C_{I}(u(X))-\\chi\\phi(X)=z_{V_{m}}(X)H_{2}(X)</span>. Similarly, because <span class="math">\\chi</span> was sampled by the verifier after receiving <span class="math">[C_{I}]_{1},[z_{I}]_{1},[u]_{1}</span>, and <span class="math">[H_{1}]_{1}</span>, we have that there exist <span class="math">H_{21}(X)</span> and <span class="math">H_{22}(X)</span> such that <span class="math">H_{2}(X)=H_{21}(X)+\\chi H_{22}(X)</span>, <span class="math">z_{I}(u(X))=z_{V_{m}}(X)H_{21}(X)</span> and <span class="math">C_{I}(u(X))-\\phi(X)=z_{V_{m}}(X)H_{22}(X)</span>.</p>

    <p class="text-gray-300">The first equation says that <span class="math">z_{I}(X)</span> is a polynomial with the coefficients of <span class="math">u(X)</span> in the basis <span class="math">\\{\\mu_{j}(X)\\}_{j=1}^{m}</span> (that are <span class="math">N</span>th roots of unity) as roots (it may have more); on the other hand, <span class="math">C_{I}(u(X))-\\phi(X)=z_{V_{m}}(X)H_{22}(X)</span> implies that the values that <span class="math">C_{I}(X)</span> takes in the elements of <span class="math">\\mathbb{H}_{I}</span> are the values that <span class="math">\\phi(X)</span> takes in <span class="math">\\mathbb{V}_{m}</span>.</p>

    <p class="text-gray-300">The full proof is given in Appendix. E</p>

    <h4 id="sec-33" class="text-lg font-semibold mt-6">Subtables</h4>

    <p class="text-gray-300">There is another nice feature that can be derived by the protocol in Fig. 4 and is the creation of sub-lookup tables. Namely, for some <span class="math">I\\subset[N]</span>, prover generates <span class="math">t(X)=\\prod_{i\\in I}(X-c_{i})</span>. To prove well formation of it, after having some <span class="math">C_{I}(X)</span> that has been proven correct, it shows that there exists some <span class="math">H_{3}(X)</span> such that</p>

    <p class="text-gray-300"><span class="math">t(\\tilde{C}_{I}(X))=z_{V_{m}}(X)H_{3}(X).</span></p>

    <p class="text-gray-300">Then, for any polynomial <span class="math">a(X)</span> of degree up to <span class="math">m-1</span>, if there exists <span class="math">H_{4}(X)</span> such that</p>

    <p class="text-gray-300"><span class="math">t(a(X))=z_{V_{m}}(X)H_{4}(X),</span></p>

    <p class="text-gray-300">then the coefficients of <span class="math">a(X)</span> in the basis <span class="math">\\{\\mu_{j}(X)\\}_{j=1}^{m}</span> are coefficients of <span class="math">C_{I}(X)</span> in basis <span class="math">\\{\\tau_{i}(X)\\}_{i\\in I}</span>, with no specific order and potential repetitions.</p>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">7.2 Multi-Unity Proof or Proving well formation of <span class="math">u(X)</span></h3>

    <p class="text-gray-300">The aim of this section is to prove in zero-knowledge that a commitment <span class="math">[u]_{1}</span> is well formed, that is, encodes the polynomial <span class="math">u(X)=\\sum_{j=1}^{m}\\omega^{i_{j}}\\mu_{j}(X)+r(X)z_{V_{m}}(X)</span>, where <span class="math">\\omega^{i_{j}}</span> is the <span class="math">j</span>-th element in <span class="math">I</span>. Namely, that <span class="math">u(X)=\\sum_{j=1}^{m}u_{j}\\mu_{j}(X)+r(X)z_{V_{m}}(X)</span> is such that all its coefficients are elements in <span class="math">\\mathbb{H}</span> and thus, they are all <span class="math">N</span>th roots of unity, or what is the same, that <span class="math">u_{j}^{N}=1</span> for all <span class="math">j=1,\\ldots,m</span>.</p>

    <p class="text-gray-300">For this argument, we will consider another group of roots of unity <span class="math">\\mathbb{V}_{n}=\\{1,\\sigma,\\ldots,\\sigma^{n-1}\\}</span> of size <span class="math">n=\\log(N)</span>, with <span class="math">\\sigma^{n}=1</span>, Lagrange interpolation polynomials <span class="math">\\{\\rho_{s}(X)\\}_{s=1}^{n}</span> and vanishing polynomial <span class="math">z_{V_{n}}(X)</span>.</p>

    <p class="text-gray-300">Techniques. The prover first defines <span class="math">\\vec{u}_{0}=(u_{1},\\ldots,u_{m})\\in\\mathbb{F}^{m}</span> to be the vector whose elements are the coefficients of <span class="math">u(X)</span>. They then iteratively define <span class="math">\\vec{u}_{j}=\\vec{u}_{j-1}\\circ\\vec{u}_{j-1}</span>. I.e., they set</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\vec{u}_{1}=\\vec{u}_{0}\\circ\\vec{u}_{0}=(u_{1}^{2},\\ldots,u_{m}^{2})</span>;</li>

      <li>and for all <span class="math">j=2,\\ldots,n</span>, <span class="math">\\vec{u}_{j}=\\vec{u}_{j-1}\\circ\\vec{u}_{j-1}=(u_{1}^{2^{j}},\\ldots,u_{m}^{2^{j}})</span>.</li>

    </ul>

    <p class="text-gray-300">They then must prove three conditions to the verifier: <span class="math">(i)</span> <span class="math">\\vec{u}_{0}</span> consists on the coefficients of <span class="math">u(X)</span>, <span class="math">(ii)</span> equation <span class="math">\\vec{u}_{j}=\\vec{u}_{j-1}\\circ\\vec{u}_{j-1}</span> holds for all <span class="math">j=1,\\ldots,n-1</span> and <span class="math">(iii)</span> <span class="math">\\vec{u}_{n-1}\\circ\\vec{u}_{n-1}=\\vec{1}</span>. Together this gives that all the coefficients <span class="math">u_{j}</span> are <span class="math">N</span>th roots of unity.</p>

    <p class="text-gray-300">As we are working with encodings as polynomials rather than vectors, the prover sets <span class="math">u_{0}(X)=u(X)</span>, <span class="math">u_{n}(X)=\\mathsf{id}(X)</span> (for <span class="math">\\mathsf{id}(X)</span> the polynomial that evaluates to <span class="math">1</span> over <span class="math">\\mathbb{V}_{m}</span>), and shows to the verifier that each of the following equations hold:</p>

    <p class="text-gray-300"><span class="math">u(X)u(X)-u_{1}(X)</span> <span class="math">\\equiv z_{V_{m}}(X)H_{1}(X),</span> <span class="math">\\vdots</span> <span class="math">u_{n-1}(X)u_{n-1}(X)-\\mathsf{id}(X)</span> <span class="math">\\equiv z_{V_{m}}(X)H_{n}(X),</span></p>

    <p class="text-gray-300">To aggregate all of these checks into one verification equation we consider <span class="math">\\{\\rho_{s}(Y)\\}</span> the linear independent Lagrange interpolation polynomials over <span class="math">\\mathbb{V}_{n}</span> and demonstrate that</p>

    <p class="text-gray-300"><span class="math">\\left(u^{2}(X)\\rho_{1}(Y)+\\sum_{s=2}^{n}u_{s-1}^{2}(X)\\rho_{s}(Y)\\right)-\\left(\\sum_{s=1}^{n-1}u_{s}(X)\\rho_{s}(Y)+\\mathsf{id}(X)\\rho_{n}(Y)\\right)=z_{V_{m}}(X)h_{2}(X,Y),</span> (6)</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300">for some polynomial <span class="math">h_{2}(X,Y)</span>.</p>

    <p class="text-gray-300">In the remainder of this section the prover aims to demonstrate that (6) holds at a challenge point <span class="math">(\\alpha,\\beta)</span>.</p>

    <h4 id="sec-35" class="text-lg font-semibold mt-6">Proving (6): Strategy</h4>

    <p class="text-gray-300">We prove (6) by showing that for some polynomial <span class="math">h_{1}(Y)</span>, the polynomial</p>

    <p class="text-gray-300"><span class="math">p(Y)</span> <span class="math">=\\big{(}\\underbrace{u^{2}(\\alpha)\\rho_{1}(\\beta)+\\sum_{s=2}^{n}u_{s-1}^{2}(\\alpha)\\rho_{s}(\\beta)+z_{V_{n}}(\\beta)(-h_{1}(\\beta)}_{\\text{Denote </span>\\xi_{1}<span class="math">}}+h_{1}(Y))\\big{)}</span> <span class="math">-\\big{(}\\underbrace{\\sum_{s=1}^{n-1}u_{s}(\\alpha)\\rho_{s}(\\beta)}_{\\text{Denote </span>\\xi_{2}<span class="math">}}+\\mathsf{id}(\\alpha)\\rho_{n}(\\beta)\\big{)}-\\underbrace{z_{V_{m}}(\\alpha)h_{2}(\\alpha,Y)}_{\\text{Denote </span>\\xi_{4}<span class="math">}}</span></p>

    <p class="text-gray-300">evaluates to <span class="math">0</span> at <span class="math">Y=\\beta</span>. For this the prover sends several values needed to reconstruct the commitment <span class="math">[P]_{1}</span> to <span class="math">p(Y)</span>, and then provides a proof that <span class="math">[P]_{1}</span> opens to <span class="math">0</span> at <span class="math">\\beta</span>.</p>

    <h4 id="sec-36" class="text-lg font-semibold mt-6">Proving (6): Extra Notation</h4>

    <p class="text-gray-300">First note that since the polynomials <span class="math">\\rho_{s}(Y)</span> take <span class="math">1</span> and <span class="math">0</span> values only, we obtain that for all <span class="math">Y\\in\\mathbb{V}_{n}</span></p>

    <p class="text-gray-300"><span class="math">u^{2}(X)\\rho_{1}(Y)+\\sum_{s=2}^{n}u_{s-1}^{2}(X)\\rho_{s}(Y)=\\big{(}u(X)\\rho_{1}(Y)+\\sum_{s=2}^{n}u_{s-1}(X)\\rho_{s}(Y)\\big{)}^{2}</span></p>

    <p class="text-gray-300">We denote <span class="math">\\bar{U}(X,Y)=\\sum_{s=2}^{n}u_{s-1}(X)\\rho_{s}(Y)</span> and <span class="math">U(X,Y)=u(X)\\rho_{1}(Y)+\\bar{U}(X,Y)</span> The prover begins by sending one commitment <span class="math">[\\bar{U}]_{1}</span> to <span class="math">\\bar{U}(X,Y)</span> and a second commitment <span class="math">[h_{2}]</span> to <span class="math">h_{2}(X,Y)</span>. These are bivariate commitments. While there exist bivariate polynomial commitment schemes <em>[26]</em>, these are incompatible with universal power-of-tau setups that are publicly available <em>[23]</em>. We thus instead view <span class="math">\\bar{U}(X,Y)</span> and <span class="math">h_{2}(X,Y)</span> as the univariate polynomials <span class="math">U(X^{n},X)</span> and <span class="math">h_{2}(X^{n},X)</span>. See Section 4.6 for more details.</p>

    <p class="text-gray-300">The verifier responds with a random challenge <span class="math">X=\\alpha</span>.</p>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">Proving (6): Definition of and commitment to <span class="math">h_{1}</span></h4>

    <p class="text-gray-300">The prover now wishes to find <span class="math">h_{1}</span> such that <span class="math">p(Y)</span> can be fully defined and its commitment can be computed by the verifier. They first provide a partial opening <span class="math">[\\bar{U}_{\\alpha}]_{1}</span> to <span class="math">\\bar{U}(\\alpha,Y)</span> and proves this is consistent with <span class="math">[\\bar{U}]_{1}</span>. They also open <span class="math">[u(x)]_{1}</span> at <span class="math">\\alpha</span> to get <span class="math">v_{1}=u(\\alpha)</span>. This allows the verifier to compute a commitment to the polynomial <span class="math">U(\\alpha,Y)</span> as <span class="math">U=[u(\\alpha)]_{1}\\rho_{1}(x)+[\\bar{U}_{\\alpha}]_{1}</span>.</p>

    <p class="text-gray-300">The prover sends a commitment <span class="math">[h_{1}]_{1}=[h_{1}(x)]_{1}</span> to <span class="math">h_{1}(Y)</span> such that</p>

    <p class="text-gray-300"><span class="math">\\sum_{s=1}^{n}u_{s-1}^{2}(\\alpha)\\rho_{s}(Y)=\\left(U(\\alpha,Y)\\right)^{2}+h_{1}(Y)z_{V_{n}}(Y).</span> (7)</p>

    <p class="text-gray-300">The verifier responds with a second random challenge <span class="math">Y=\\beta</span> and then (7) appears as</p>

    <p class="text-gray-300"><span class="math">\\sum_{s=1}^{n}u_{s-1}^{2}(\\alpha)\\rho_{s}(\\beta)=\\left(U(\\alpha,\\beta)\\right)^{2}+h_{1}(\\beta)z_{V_{n}}(\\beta)</span> (8)</p>

    <h4 id="sec-38" class="text-lg font-semibold mt-6">Proving (6): Degree bound</h4>

    <p class="text-gray-300">The prover must show that <span class="math">\\bar{U}_{1}(X,1)=0</span> i.e. that there is no <span class="math">\\rho_{1}(Y)</span> term. This convinces the verifier that the first term of <span class="math">U(\\alpha,Y)</span> is indeed <span class="math">u(\\alpha)\\rho_{1}(Y)</span>. When opening <span class="math">[\\bar{U}_{\\alpha}]_{1}</span> we enforce a degree bound of <span class="math">n-1</span>. This is necessary because we are capturing bivariate polynomials with a univariate polynomial commitment scheme and we need to enforce that there are no <span class="math">X^{n}</span> terms lingering in <span class="math">\\bar{U}(\\alpha,X)</span>.</p>

    <h4 id="sec-39" class="text-lg font-semibold mt-6">Proving (6): Sending <span class="math">\\xi_{1}</span></h4>

    <p class="text-gray-300">The prover communicates <span class="math">\\xi_{1}</span> by opening <span class="math">[\\bar{U}_{\\alpha}]_{1}</span> to <span class="math">v_{2}</span> at <span class="math">Y=\\beta</span> and verifier gets</p>

    <p class="text-gray-300"><span class="math">\\xi_{1}=\\{(8)\\}=U(\\alpha,\\beta)^{2}=(u(\\alpha)\\rho_{1}(\\beta)+\\bar{U}(\\alpha,\\beta))^{2}=(v_{1}\\rho_{1}(\\beta)+v_{2})^{2}</span></p>

    <p class="text-gray-300">Proving (6): Sending <span class="math">\\xi_{2}</span> The prover communicates <span class="math">\\xi_{2}=\\sum_{s=1}^{n-1}u_{s}(\\alpha)\\rho_{s}(\\beta)</span>. To do this we open <span class="math">[\\bar{U}(\\alpha,Y)]=[\\bar{U}_{\\alpha}]_{1}</span> to <span class="math">v_{3}</span> at <span class="math">Y=\\sigma\\beta</span> for <span class="math">\\sigma</span> the generator of <span class="math">\\mathbb{V}_{n}</span>. Indeed</p>

    <p class="text-gray-300"><span class="math">\\bar{U}(\\alpha,\\sigma\\beta)=\\sum_{s=2}^{n}u_{s-1}(\\alpha)\\rho_{s}(\\sigma\\beta)=\\sum_{s=1}^{n-1}u_{s}(\\alpha)\\rho_{s}(\\beta)</span> (9)</p>

    <p class="text-gray-300">Proving (6): Finale Finally the verifier can compute a commitment to <span class="math">p(Y)</span> as <span class="math">[p(Y)]_{1}=[(v_{2}+v_{1}\\rho_{1}(\\beta))^{2}]_{1}+z_{V_{n}}(\\beta)[h_{1}]_{1}-[v_{3}+\\mathsf{id}(\\alpha)\\rho_{n}(\\beta)]_{1}-z_{V_{m}}(\\alpha)[h_{2}]_{1}</span>. Thus the prover finishes by demonstrating that <span class="math">p(\\beta)=0</span>.</p>

    <p class="text-gray-300">The protocol is shown in Figure 5.</p>

    <p class="text-gray-300">Efficiency. In the protocol of Fig. 4, the work of the prover is dominated by the computation of <span class="math">H(X)</span> and <span class="math">p_{2}(X)</span> which have degree <span class="math">m^{2}</span>, because <span class="math">[H_{1}]</span> is formed in time <span class="math">m</span> by using the pre-computed individual proofs, and all the other proof elements are commitments to polynomials of degree <span class="math">m</span>. In the protocol of Fig. 5, prover work is dominated by the computation of <span class="math">[\\bar{U}]_{1}</span> and <span class="math">[h_{2}]_{1}</span> that are commitments to polynomials of degree <span class="math">m\\log(N)</span>.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Theorem 4.</h6>

    <p class="text-gray-300">The protocol in Figure 5 is a knowledge-sound argument for relation <span class="math">\\mathsf{R}^{\\prime}_{\\mathsf{unity}}</span> under the algebraic group model and random oracle model if the <span class="math">q</span>SDH, <span class="math">q</span>DHE, and <span class="math">q</span>SFrac assumptions hold.</p>

    <p class="text-gray-300">Intuition. We first define an extractor that will use the algebraic representations provided by the adversary. We must show that the output of this extractor is a valid witness with overwhelming probability. The proof proceeds via a series of games where the final game is statistically hard. <span class="math">\\mathsf{Game}_{0}</span> is the knowledge-soundness game for the protocol in Fig. 5. <span class="math">\\mathsf{Game}_{1}</span> behaves identically except that it checks whether <span class="math">u(\\alpha)=v_{1}</span>, <span class="math">\\bar{U}_{\\alpha}(1)=0</span>, <span class="math">\\bar{U}_{\\alpha}(\\beta)=v_{2}</span>, <span class="math">\\bar{U}_{\\alpha}(\\beta\\sigma)=v_{3}</span>, and <span class="math">p(\\beta)=0</span> for <span class="math">u(X)</span>, <span class="math">\\bar{U}_{\\alpha}(X)</span>, <span class="math">p(X)</span> being the algebraic representations of <span class="math">[u]_{1},[\\bar{U}_{\\alpha}]_{1}</span>, and <span class="math">[P]_{1}</span>, respectively. Soundness of the KZG polynomial commitment asserts that the difference of the advantages of <span class="math">\\mathcal{A}</span> in <span class="math">\\mathsf{Game}_{0}</span> and <span class="math">\\mathsf{Game}_{1}</span> is negligible.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Game}_{2}</span> is the same as <span class="math">\\mathsf{Game}_{1}</span> but it additionally checks that <span class="math">deg(\\bar{U}_{\\alpha})\\leq n-1</span> and <span class="math">deg(h_{2})\\leq n-1</span>, and aborts otherwise. To instantiate the protocol, we use the KZG polynomial commitment with the modification exposed in Section 4.2 and, as stated there, a prover that outputs a valid proof of opening for a polynomial with higher degree than the one declared, implies an attack to <span class="math">q</span>DHE. Therefore, <span class="math">\\mathsf{Adv}^{\\mathsf{Game}_{2}}_{\\mathcal{A}}\\leq\\mathsf{Adv}^{\\mathsf{Game}_{1}}_{\\mathcal{A}}+\\mathsf{Adv}^{\\mathsf{qDHE}}_{\\mathcal{A}}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Game}_{3}</span> behaves as <span class="math">\\mathsf{Game}_{2}</span> but additionally verifies that <span class="math">\\bar{U}(\\alpha,Y)=\\bar{U}_{\\alpha}(Y)</span>, <span class="math">h_{2}(\\alpha,Y)=h_{2,\\alpha}(Y)</span>, for <span class="math">\\bar{U}_{\\alpha}(X)</span>, <span class="math">h_{2}(X)</span>, <span class="math">h_{2,\\alpha}(X)</span>, the algebraic representations of <span class="math">[\\bar{U}_{\\alpha}]_{1}</span>, <span class="math">[h_{2}]_{1}</span>, and <span class="math">[h_{2,\\alpha}]_{1}</span>. That is, <span class="math">\\mathsf{Game}_{3}</span> checks correctness of the partial evaluations (see Section 4.6). In the full proof, we show that if it is not the case, the adversary can be used as a subroutine for a successful adversary against <span class="math">q</span>SFrac.</p>

    <p class="text-gray-300">Finally, since <span class="math">p(\\beta)=0</span> and since <span class="math">[u]_{1},[\\bar{U}]_{1}</span>, <span class="math">[h_{1}]_{1}</span>, <span class="math">[h_{2}]_{1}</span> have been sent by the prover before it sees challenge <span class="math">\\beta</span>, and <span class="math">[u]_{1},[\\bar{U}]_{1}</span>, <span class="math">[h_{2}]_{1}</span>before it sees challenge <span class="math">\\alpha</span>, with overwhelming probability</p>

    <p class="text-gray-300"><span class="math">p(X)</span> <span class="math">=\\left(u(X)\\rho_{1}(Y)+\\bar{U}(X,Y)\\right)^{2}-h_{1}(X)z_{V_{n}}(Y)</span> <span class="math">-\\left(\\bar{U}(X,Y\\sigma)+\\mathsf{id}(X)\\rho_{n}(Y)\\right)-z_{V_{m}}(X)h_{2}(X,Y).</span></p>

    <p class="text-gray-300">Note that the latter is equation 6 as at the beginning of Section 7.2. That is, it is the aggregation of the constraints that prove <span class="math">u(X)</span> is a polynomial such that all its coefficients in the Lagrange basis <span class="math">\\{\\mu_{j}(X)\\}</span> are <span class="math">N</span>th roots of unity.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We proceed through a series of games to show that the protocol defined in Fig. 4 satisfies knowledge soundness. We set <span class="math">\\mathsf{Game}_{0}</span> to be the knowledge soundness game as defined in Definition A.1 and consider an algebraic adversary <span class="math">\\mathcal{A}</span> against it which has advantage <span class="math">\\mathsf{Adv}^{\\mathsf{knowledge-sound}}_{\\mathcal{A}}(\\lambda)</span> . We define <span class="math">\\mathsf{Game}_{1}</span> and <span class="math">\\mathsf{Game}_{2}</span> and specify reductions <span class="math">\\mathcal{B}_{1}</span> and <span class="math">\\mathcal{B}_{2}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}^{\\mathsf{k-sound}}_{\\mathcal{A}}(\\lambda)=\\mathsf{Adv}^{\\mathsf{Game}_{0}}_{\\mathcal{A}}(\\lambda)\\leq\\mathsf{Adv}^{\\mathsf{Game}_{1}}_{\\mathcal{A}}(\\lambda)+\\mathsf{Adv}^{\\mathsf{qSDH}}_{\\mathcal{B}_{1}}(\\lambda)</span> <span class="math">\\leq\\mathsf{Adv}^{\\mathsf{Game}_{2}}_{\\mathcal{A}}(\\lambda)+\\mathsf{Adv}^{\\mathsf{qSDH}}_{\\mathcal{B}_{1}}(\\lambda)+\\mathsf{Adv}^{\\mathsf{qDHE}}_{\\mathcal{B}_{2}}(\\lambda)</span> <span class="math">\\leq\\mathsf{Adv}^{\\mathsf{Game}_{3}}_{\\mathcal{A}}(\\lambda)+\\mathsf{Adv}^{\\mathsf{qSDH}}_{\\mathcal{B}_{1}}(\\lambda)+\\mathsf{Adv}^{\\mathsf{qDHE}}_{\\mathcal{B}_{2}}(\\lambda)+\\mathsf{Adv}^{\\mathsf{qSFrac}}_{\\mathcal{B}_{3}}(\\lambda)</span> <span class="math">\\leq\\mathsf{Adv}^{\\mathsf{qSDH}}_{\\mathcal{B}_{1}}(\\lambda)+\\mathsf{Adv}^{\\mathsf{qDHE}}_{\\mathcal{B}_{2}}(\\lambda)+\\mathsf{Adv}^{\\mathsf{qSFrac}}_{\\mathcal{B}_{3}}(\\lambda)+\\mathsf{negl}(\\lambda)</span></p>

    <p class="text-gray-300">Common input:  <span class="math">[u]_1</span>  where  <span class="math">[u]_1 = [u_0(X)]_1</span></p>

    <p class="text-gray-300">Prover: Take as input srs and  <span class="math">u(X)</span></p>

    <p class="text-gray-300">Samples blinders  <span class="math">t_1, \\ldots, t_n \\gets \\mathbb{F}</span> .</p>

    <p class="text-gray-300">For  <span class="math">s = 1,\\ldots ,n</span>  , define  <span class="math">u_{s}(X) = \\sum_{j = 1}^{m}\\left(\\omega^{i_{j}}\\right)^{2^{s}}\\mu_{j}(X) + t_{s}z_{V_{m}}(X),</span></p>

    <p class="text-gray-300">Define  <span class="math">U(X,Y) = \\sum_{s=1}^{n} u_{s-1}(X)\\rho_s(Y)</span> .</p>

    <p class="text-gray-300">Define  <span class="math">\\bar{U} (X,Y) = U(X,Y) - u(X)\\rho_1(Y)</span></p>

    <p class="text-gray-300">Define  <span class="math">h_2(X) = \\sum_{s=1}^{n} \\rho_s(Y) H_s(X)</span>  for  <span class="math">H_s(X) = (u_{s-1}^2(X) - u_s(X)) / z_{V_m}(X)</span> .</p>

    <p class="text-gray-300">Output  <span class="math">\\left([ \\bar {U} ] _ {1} = [ \\bar {U} (x ^ {n}, x) ] _ {1}, [ h _ {2} ] _ {1} = [ h _ {2} (x ^ {n}, x) ] _ {1}\\right)</span></p>

    <p class="text-gray-300">Verifier: Send challenge  <span class="math">\\alpha \\in \\mathbb{F}</span></p>

    <p class="text-gray-300">Prover: Define  <span class="math">h_1(Y) \\gets \\left( U^2(\\alpha, Y) - \\sum_{s=1}^{n} u_{s-1}^2(\\alpha) \\rho_s(Y) \\right) / z_{V_n}(Y)</span></p>

    <p class="text-gray-300">Output  <span class="math">[h_1]_1 = [h_1(x)]_1</span></p>

    <p class="text-gray-300">Verifier: Send challenge  <span class="math">\\beta \\in \\mathbb{F}</span></p>

    <p class="text-gray-300">Prover:</p>

    <p class="text-gray-300"><span class="math">p(Y)\\gets (U^{2}(\\alpha ,\\beta) - h_{1}(Y)z_{V_{n}}(\\beta)) - \\bar{U} (\\alpha ,\\beta \\sigma) + \\mathsf{id}(\\alpha)\\rho_{n}(\\beta)) - z_{V_{m}}(\\alpha)h_{2}(\\alpha ,Y)</span></p>

    <p class="text-gray-300"><span class="math">(v_{1},\\pi_{1})\\gets \\mathsf{KZG.Open}\\big(\\mathsf{srs},u(X),\\deg = \\bot ,X = \\alpha \\big)</span></p>

    <p class="text-gray-300"><span class="math">([\\bar{U} (\\alpha ,x)]_1,\\pi_2)\\gets \\mathsf{KZG.Open}\\big(\\mathsf{srs},\\bar{U} (X,Y),\\deg = \\bot ,X = \\alpha \\big)</span></p>

    <p class="text-gray-300"><span class="math">([h_2(\\alpha ,x)]_1,\\pi_3)\\gets \\mathsf{KZG.Open}\\big(\\mathsf{srs},h_2(X,Y),\\deg = \\bot ,X = \\alpha \\big)</span></p>

    <p class="text-gray-300"><span class="math">((0,v_{2},v_{3}),\\pi_{4})\\gets \\mathsf{KZG.Open}\\big(\\mathsf{srs},\\bar{U} (\\alpha ,Y),\\deg = n - 1,Y = (1,\\beta ,\\beta \\sigma)\\big)</span></p>

    <p class="text-gray-300"><span class="math">(0,\\pi_5)\\gets \\mathsf{KZG.Open}\\big(\\mathsf{srs},p(Y),\\deg = n - 1,Y = \\beta \\big)</span></p>

    <p class="text-gray-300">Set  <span class="math">\\left([ \\bar {U} _ {\\alpha} ] _ {1} = [ \\bar {U} (\\alpha , x) ] _ {1}, [ h _ {2, \\alpha} ] _ {1} = [ h _ {2} (\\alpha , x) ] _ {1} \\right.</span>  and output  <span class="math">\\left([ \\bar {U} _ {\\alpha} ] _ {1}, [ h _ {2, \\alpha} ] _ {1}, v _ {1}, v _ {2}, v _ {3}, \\pi_ {1}, \\pi_ {2}, \\pi_ {3}, \\pi_ {4}, \\pi_ {5}\\right)</span></p>

    <p class="text-gray-300">Verifier: Compute  <span class="math">U \\gets v_{1}\\rho_{1}(\\beta) + v_{2}</span> ,  <span class="math">[P]_{1} \\gets U^{2} - [h_{1}]_{1}z_{V_{n}}(\\beta) - (v_{3} + \\mathsf{id}(\\alpha)\\rho_{n}(\\beta)) - z_{V_{m}}(\\alpha)[h_{2,\\alpha}]_{1}</span> .</p>

    <p class="text-gray-300">Accept if and only if</p>

    <p class="text-gray-300"><span class="math">1 = \\mathsf{KZG.Verify}\\big(\\mathsf{srs}_{\\mathsf{KZG}},[u]_1,\\deg = \\bot ,X = \\alpha ,v_1,\\pi_1\\big)</span> <span class="math">1 = \\mathsf{KZG.Verify}\\big(\\mathsf{srs}_{\\mathsf{KZG}},[\\bar{U} ]_{1},\\deg = \\bot ,X = \\alpha ,[\\bar{U}_{\\alpha}]_{1},\\pi_{2}\\big)</span> <span class="math">1 = \\mathsf{KZG.Verify}\\big(\\mathsf{srs}_{\\mathsf{KZG}},[h_2]_1,\\deg = \\bot ,X = \\alpha ,[h_{2,\\alpha}]_2,\\pi_3\\big)</span> <span class="math">1 = \\mathsf{KZG.Verify}\\big(\\mathsf{srs}_{\\mathsf{KZG}},[\\bar{U}_{\\alpha}]_{1},\\deg = n - 1,Y = (1,\\beta ,\\beta \\sigma),(0,v_{2},v_{3}),\\pi_{4}\\big)</span> <span class="math">1 = \\mathsf{KZG.Verify}\\big(\\mathsf{srs}_{\\mathsf{KZG}},[P]_1,\\deg = n - 1,Y = \\beta ,0,\\pi_5\\big)</span></p>

    <p class="text-gray-300">Figure 5: Argument for proving that some polynomial  <span class="math">u(X)</span>  has  <span class="math">N</span> th roots of unity as coefficients in the basis  <span class="math">\\{\\mu_j(X)\\}_{j=1}^m</span> .</p>

    <p class="text-gray-300">.</p>

    <p class="text-gray-300">In <span class="math">\\mathsf{Game}_{0}</span> the adversary will return <span class="math">[u]_{1}=[u(x)]</span> along with a proof. We define <span class="math">\\mathsf{Game}_{1}</span> identically to <span class="math">\\mathsf{Game}_{0}</span>, but after the adversary returns <span class="math">[u]_{1}</span> and a proof, <span class="math">\\mathsf{Game}_{1}</span> additionally checks whether for <span class="math">u(X),\\bar{U}_{\\alpha}(X),p(X)</span> the algebraic representations of <span class="math">[u]_{1},[\\bar{U}_{\\alpha}]_{1}</span>, <span class="math">[P]_{1}</span>, it is true that <span class="math">u(\\alpha)=v_{1}</span>, <span class="math">\\bar{U}_{\\alpha}(1)=0</span>, <span class="math">\\bar{U}_{\\alpha}(\\beta)=v_{2}</span>, <span class="math">\\bar{U}_{\\alpha}(\\beta\\sigma)=v_{3}</span>, and <span class="math">p(\\beta)=0</span>; and it aborts if one of the conditions does not hold.</p>

    <p class="text-gray-300">The redution <span class="math">\\mathcal{B}_{1}</span> takes as input the challenge <span class="math">[y_{1}]_{1},\\ldots,[y_{q}]_{1}</span>. It runs the following reduction <span class="math">\\mathcal{B}_{\\mathsf{KZG}}</span> as a subroutine. The <span class="math">\\mathcal{B}_{\\mathsf{KZG}}</span> runs the adversary <span class="math">\\mathcal{A}</span> against <span class="math">\\mathsf{Game}_{0}</span> over an <span class="math">\\mathsf{srs}</span> in which <span class="math">[x]_{1}=[y_{1}]_{1}</span>. Whenever <span class="math">\\mathcal{A}</span> returns an output which wins the <span class="math">\\mathsf{Game}_{0}</span> game, if <span class="math">(f(X),\\mathbf{v},\\mathbf{z})</span> for some <span class="math">(f(X),\\mathbf{v},\\mathbf{z})\\in\\{(u(X),v_{1},\\alpha),(\\bar{U}_{\\alpha}(X),(1,\\beta,\\sigma\\beta),(0,v_{2},v_{3})),(p(X),\\beta,0)\\}</span> is such that <span class="math">f(v_{i})\\neq z_{i}</span>, then <span class="math">\\mathcal{B}_{KZG}</span> computes <span class="math">f(z)=v^{\\prime}</span> and a valid proof <span class="math">\\pi^{\\prime}</span>. It outputs <span class="math">([f(x)]_{1},\\mathbf{z},\\mathbf{v},\\pi)</span> and <span class="math">([f(x)]_{1},\\mathbf{z},\\mathbf{v}^{\\prime},\\pi^{\\prime})</span> and wins evaluation binding as they are both proofs that verify and open to different elements. Then <span class="math">\\mathcal{B}_{\\mathsf{qSDH}}</span> can extract a <span class="math">q</span>SDH solution from these openings following the proof in Theorem 3 of <em>[22]</em>. Thus</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}_{\\mathcal{A}}^{\\mathsf{k}\\text{-sound}}(\\lambda)\\text{=}\\mathsf{Adv}_{\\mathcal{A}}^{\\mathsf{Game}_{0}}(\\lambda)\\leq\\mathsf{Adv}_{\\mathcal{A}}^{\\mathsf{Game}_{1}}(\\lambda)+\\mathsf{Adv}_{\\mathcal{A}^{\\mathsf{qSDH}}}^{\\mathsf{qSDH}}(\\lambda)</span></p>

    <p class="text-gray-300">Now <span class="math">\\mathsf{Game}_{2}</span> behaves identically as <span class="math">\\mathsf{Game}_{1}</span> but it additionally checks that <span class="math">\\deg(\\bar{U}_{\\alpha})\\leq n-1</span> and <span class="math">\\deg(h_{2})\\leq n-1</span>. If it is not the case, it aborts. Suppose <span class="math">\\mathcal{A}</span> returns either <span class="math">\\deg(\\bar{U}_{\\alpha})=n-1+d</span> or <span class="math">\\deg(h_{2})=n-1+d</span> for some <span class="math">d&gt;0</span>. We argue the advantage of <span class="math">\\mathcal{A}</span> in <span class="math">\\mathsf{Game}_{1}</span> and <span class="math">\\mathsf{Game}_{2}</span> is the same unless we can build an adversary <span class="math">\\mathcal{B}_{2}</span> that succeeds against <span class="math">q</span>DHE. The <span class="math">\\mathcal{B}_{2}</span> takes as input the challenge <span class="math">[y_{1}]_{1},\\ldots,[y_{q+d-1}]_{1}</span> and runs the adversary <span class="math">\\mathcal{A}</span> against <span class="math">\\mathsf{Game}_{1}</span> over an <span class="math">\\mathsf{srs}</span> in which <span class="math">[x]_{1}=[y_{1}]_{1}</span>. Whenever <span class="math">\\mathcal{A}</span> returns an output which wins the <span class="math">\\mathsf{Game}_{1}</span> game, if <span class="math">(f(X),\\mathbf{v},\\mathbf{z})</span> for</p>

    <p class="text-gray-300"><span class="math">(f(X),\\mathbf{v},\\mathbf{z})\\in\\{(\\bar{U}_{\\alpha}(X),(1,\\beta,\\sigma\\beta),(0,v_{2},v_{3})),(p(X),\\beta,0)\\}</span></p>

    <p class="text-gray-300">is such that <span class="math">f(X)</span> has degree greater than <span class="math">n-1</span>, then the corresponding proof <span class="math">\\pi=[q(x)]_{1}</span> has a representation <span class="math">q(X)</span> has degree <span class="math">q+1</span>. Thus <span class="math">\\mathcal{B}_{2}</span> succeeds in returning <span class="math">[\\pi-\\sum_{i=0}^{q-1}x^{i}]_{1}</span> and</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}_{\\mathcal{A}}^{\\mathsf{Game}_{1}}(\\lambda)\\leq\\mathsf{Adv}_{\\mathcal{A}}^{\\mathsf{Game}_{2}}(\\lambda)+\\mathsf{Adv}_{\\mathcal{A}^{\\mathsf{qDHE}}}^{\\mathsf{qDHE}}(\\lambda)</span></p>

    <p class="text-gray-300">We define <span class="math">\\mathsf{Game}_{3}</span> identically to <span class="math">\\mathsf{Game}_{2}</span>, but after the adversary returns <span class="math">[u]_{1}</span> and a proof, <span class="math">\\mathsf{Game}_{3}</span> additionally checks whether for <span class="math">\\bar{U}(X),h_{2}(X),\\bar{U}_{\\alpha}(X),h_{2,\\alpha}(X)</span> the algebraic representations of <span class="math">[\\bar{U}]_{1},[\\bar{U}_{\\alpha}]_{1},[h_{2}]_{1},[h_{2,\\alpha}]_{1}</span>, it is true that</p>

    <p class="text-gray-300"><span class="math">\\bar{U}_{\\alpha}(X)=\\sum_{i,j}\\alpha^{i}\\bar{U}_{ni}X^{j}\\text{ and }h_{2,\\alpha}(X)=\\sum_{i,j}\\alpha^{i}h_{2,ni}X^{j}</span></p>

    <p class="text-gray-300">and it aborts if one of the conditions does not hold.</p>

    <p class="text-gray-300">The redution <span class="math">\\mathcal{B}_{3}</span> against <span class="math">q</span>SFrac <em>[18]</em> takes as input the challenge <span class="math">[y_{1}]_{1},\\ldots,[y_{q}]_{1}</span> and runs the adversary <span class="math">\\mathcal{A}</span> against <span class="math">\\mathsf{Game}_{2}</span> over an <span class="math">\\mathsf{srs}</span> in which <span class="math">[x]_{1}=[y_{1}]_{1}</span>. Whenever <span class="math">\\mathcal{A}</span> returns an output which wins the <span class="math">\\mathsf{Game}_{2}</span> game, if <span class="math">(f(X),V,z)</span> for</p>

    <p class="text-gray-300"><span class="math">(f(X),\\phi(X),z)\\in\\{(\\bar{U}(X),\\bar{U}_{\\alpha}(X),\\alpha),(h_{2}(X),h_{2,\\alpha}(X),\\alpha)\\}</span></p>

    <p class="text-gray-300">is such that <span class="math">\\phi(X)\\neq\\phi^{\\prime}(X)=\\sum_{i,j}\\alpha^{i}f_{ni}X^{j}</span>, then set <span class="math">\\pi</span> be the proof for <span class="math">(f(X),\\phi(X),z)</span>. Then <span class="math">\\mathcal{B}_{3}</span> returns</p>

    <p class="text-gray-300"><span class="math">\\phi(X)-\\phi^{\\prime}(X),(X^{n}-z),\\pi-\\left[\\frac{f(x)-\\phi^{\\prime}(x)}{x^{n}-z}\\right]_{1}</span></p>

    <p class="text-gray-300">We have that <span class="math">\\deg(\\phi(X)-\\phi^{\\prime}(X))&lt;\\deg(X^{n}-z)</span> because <span class="math">\\phi(X)</span> has degree bounded by <span class="math">n-1</span>. Hence this is as a valid solution and</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}_{\\mathcal{A}}^{\\mathsf{Game}_{2}}(\\lambda)\\leq\\mathsf{Adv}_{\\mathcal{A}}^{\\mathsf{Game}_{3}}(\\lambda)+\\mathsf{Adv}_{\\mathcal{A}^{\\mathsf{qSFrac}}}^{\\mathsf{qSFrac}}(\\lambda)</span></p>

    <p class="text-gray-300">Lets see that the advantage of <span class="math">\\mathcal{A}</span> in <span class="math">\\mathsf{Game}_{3}</span> is negligible.</p>

    <p class="text-gray-300">Consider <span class="math">h_{1}(X),h_{2}(X,Y)</span> the algebraic representations of <span class="math">[h_{1}]_{1}</span>, <span class="math">[h_{2}]_{1}</span>. We can use the equations verified by <span class="math">\\mathsf{Game}_{1}</span> and replace the corresponding values in <span class="math">p(X)</span>, obtaining</p>

    <p class="text-gray-300"><span class="math">p(X)</span> <span class="math">=(v_{1}\\rho_{1}(\\beta)+v_{2})^{2}-h_{1}(X)z_{V_{n}}(\\beta)-(v_{3}+\\mathsf{id}(\\alpha)\\rho_{n}(\\beta))-z_{V_{m}}(\\alpha)h_{2,\\alpha}(X)</span> <span class="math">=\\big{(}u(\\alpha)\\rho_{1}(\\beta)+\\bar{U}_{\\alpha}(\\beta)\\big{)}^{2}-h_{1}(X)z_{V_{n}}(\\beta)-(\\bar{U}_{\\alpha}(\\beta\\sigma)+\\mathsf{id}(\\alpha)\\rho_{n}(\\beta))-z_{V_{m}}(\\alpha)h_{2,\\alpha}(X)</span> <span class="math">=\\big{(}u(\\alpha)\\rho_{1}(\\beta)+\\bar{U}(\\alpha,\\beta)\\big{)}^{2}-h_{1}(X)z_{V_{n}}(\\beta)-(\\bar{U}(\\alpha,\\beta\\sigma)+\\mathsf{id}(\\alpha)\\rho_{n}(\\beta))-z_{V_{m}}(\\alpha)h_{2}(\\alpha,X)</span></p>

    <p class="text-gray-300">From the fact that <span class="math">p(\\beta)=0</span> we get that</p>

    <p class="text-gray-300"><span class="math">0=\\big{(}u(\\alpha)\\rho_{1}(\\beta)+\\bar{U}(\\alpha,\\beta)\\big{)}^{2}-(\\bar{U}(\\alpha,\\beta\\sigma)+\\mathsf{id}(\\alpha)\\rho_{n}(\\beta))-z_{V_{m}}(\\alpha)h_{2}(\\alpha,\\beta)-h_{1}(\\beta)z_{V_{n}}(\\beta)</span></p>

    <p class="text-gray-300">Since <span class="math">[u]_{1},[\\bar{U}]_{1}</span>, <span class="math">[h_{1}]_{1}</span>, <span class="math">[h_{2}]_{1}</span> have been sent by the prover before it sees challenges <span class="math">\\beta</span>, we have that except in the case where <span class="math">(Y=\\beta)</span> is a root of the polynomial below, which happens with negligible probability, for all <span class="math">Y</span>,</p>

    <p class="text-gray-300"><span class="math">0=\\big{(}u(\\alpha)\\rho_{1}(Y)+\\bar{U}(\\alpha,Y)\\big{)}^{2}-(\\bar{U}(\\alpha,Y\\sigma)+\\mathsf{id}(\\alpha)\\rho_{n}(Y))-z_{V_{m}}(\\alpha)h_{2}(\\alpha,Y)-h_{1}(Y)z_{V_{n}}(Y)</span> (10)</p>

    <p class="text-gray-300">Thus we have that</p>

    <p class="text-gray-300"><span class="math">i=0\\Rightarrow 0</span> <span class="math">=u^{2}(\\alpha)-\\bar{U}(\\alpha,\\sigma^{1})-z_{V_{m}}(\\alpha)h_{2}(\\alpha,\\sigma^{1})</span> <span class="math">1\\leq i\\leq n-1\\Rightarrow 0</span> <span class="math">=\\bar{U}^{2}(\\alpha,\\sigma^{i})-\\bar{U}(\\alpha,\\sigma^{i+1})-z_{V_{m}}(\\alpha)h_{2}(\\alpha,\\sigma^{i})</span> <span class="math">i=n\\Rightarrow 0</span> <span class="math">=\\bar{U}^{2}(\\alpha,\\sigma^{n-1})-\\mathsf{id}(\\alpha)-z_{V_{m}}(\\alpha)h_{2}(\\alpha,\\sigma^{1})</span></p>

    <p class="text-gray-300">Since <span class="math">[u]_{1},[\\bar{U}]_{1}</span>, <span class="math">[h_{2}]_{1}</span> have been sent by the prover before it sees challenges <span class="math">\\alpha</span>, we have that except in the case where <span class="math">(X=\\alpha)</span> is a root of the polynomial below, which happens with negligible probability, for all <span class="math">X</span>,</p>

    <p class="text-gray-300"><span class="math">i=0\\Rightarrow 0</span> <span class="math">=u^{2}(X)-\\bar{U}(X,\\sigma^{1})-z_{V_{m}}(X)h_{2}(X,\\sigma^{1})</span> <span class="math">1\\leq i\\leq n-1\\Rightarrow 0</span> <span class="math">=\\bar{U}^{2}(X,\\sigma^{i})-\\bar{U}(X,\\sigma^{i+1})-z_{V_{m}}(X)h_{2}(X,\\sigma^{i})</span> <span class="math">i=n\\Rightarrow 0</span> <span class="math">=\\bar{U}^{2}(X,\\sigma^{n-1})-\\mathsf{id}(X)-z_{V_{m}}(X)h_{2}(X,\\sigma^{1})</span></p>

    <p class="text-gray-300">Over <span class="math">\\nu\\in V_{m}</span> we thus have that</p>

    <p class="text-gray-300"><span class="math">i=0\\Rightarrow 0</span> <span class="math">=u^{2}(\\nu)-\\bar{U}(\\nu,\\sigma^{1})</span> <span class="math">1\\leq i\\leq n-1\\Rightarrow 0</span> <span class="math">=\\bar{U}^{2}(\\nu,\\sigma^{i})-\\bar{U}(\\nu,\\sigma^{i+1})</span> <span class="math">i=n\\Rightarrow 0</span> <span class="math">=\\bar{U}^{2}(\\nu,\\sigma^{n-1})-1</span></p>

    <p class="text-gray-300">Together these gives us the desired requirement that <span class="math">u^{N}(\\nu)=1</span> for all <span class="math">\\nu\\in V_{m}</span> except with negligible probability. ∎</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Theorem 5.</h6>

    <p class="text-gray-300">The protocol in Fig. 4 and 5 implies position-hiding linkability between the vector commitment schemes of <span class="math">\\mathsf{C}</span> and <span class="math">\\mathsf{cm}</span>, provided that the zk proof for <span class="math">\\mathsf{R}^{\\prime}_{\\mathsf{unity}}</span> is instantiated with a the protocol in Fig. 5 and that <span class="math">\\log(N)&gt;6</span>.</p>

    <p class="text-gray-300">The proof is in Appendix F.</p>

    <h2 id="sec-43" class="text-2xl font-bold">8 Optimizations</h2>

    <p class="text-gray-300">In this section we describe some optimizations we apply to the protocols in Fig. 4 and 5 in order to achieve the efficiency claimed in Table 1.</p>

    <h5 id="sec-44" class="text-base font-semibold mt-4">Opening <span class="math">t</span> polynomials in one point.</h5>

    <p class="text-gray-300">As noted in <em>[16]</em>,<em>[12]</em>, whenever we have <span class="math">t</span> openings of different polynomials at the same point i.e. for <span class="math">t=2</span> this would be of the form</p>

    <p class="text-gray-300"><span class="math">\\pi_{1}</span> <span class="math">\\leftarrow\\mathsf{KZG.Open}(\\mathsf{srs}_{\\mathsf{KZG}},f_{1}(X),\\deg=d,\\alpha)</span> <span class="math">\\pi_{2}</span> <span class="math">\\leftarrow\\mathsf{KZG.Open}(\\mathsf{srs}_{\\mathsf{KZG}},f_{2}(X),\\deg=d,\\alpha)</span></p>

    <p class="text-gray-300">then we can send a single opening proof <span class="math">\\pi</span> as opposed to <span class="math">t</span> opening proofs <span class="math">\\pi_{1},\\ldots,\\pi_{t}</span>.</p>

    <p class="text-gray-300">#####</p>

    <h4 id="sec-45" class="text-lg font-semibold mt-6">Batching Pairings.</h4>

    <p class="text-gray-300">We also apply standard techniques to batch pairings that share the same elements in one of the two groups. Namely, we can aggregate the equations</p>

    <p class="text-gray-300"><span class="math">e([a]_{1},[b_{1}]_{2})=e([c_{1}]_{1},[d]_{2})\\text{ and }e([a]_{1},[b_{2}]_{2})=e([c_{2}]_{1},[d]_{2}),</span> <span class="math">\\text{as }e([a]_{1},[b_{1}+\\gamma b_{2}]_{2})=e([c_{1}+\\gamma c_{2}]_{1},[d]_{2})</span></p>

    <p class="text-gray-300">for <span class="math">\\gamma</span> some random field element sampled by the verifier.</p>

    <p class="text-gray-300">Note that we can adapt KZG openings equations so they can be batched further, namely if we parse the verification pairing as <span class="math">e\\bigl{(}[F_{1}]_{1}-s_{1}+[Q_{1}]_{1}\\alpha,[1]_{2}\\bigr{)}=e\\bigl{(}[Q_{1}]_{1},[x]_{2}\\bigr{)}</span>, then two openings of different polynomials at different points can be verified by two pairings.</p>

    <h4 id="sec-46" class="text-lg font-semibold mt-6">Fig. 1 and 3:</h4>

    <p class="text-gray-300">In Fig. 1 proofs have the form <span class="math">([z]_{2},[T]_{1},[S]_{2},\\pi_{\\mathsf{ped}},\\pi_{\\mathsf{unity}})</span>. See that <span class="math">\\pi_{\\mathsf{ped}}</span> consists of 1 <span class="math">\\mathbb{G}_{1}</span> and 2<span class="math">\\mathbb{F}</span> elements. In Fig. 3 proofs have the form <span class="math">([F]_{1},[H]_{1},v_{1},v_{2},\\pi_{1},\\pi_{2})</span> which amounts to <span class="math">4\\mathbb{G}_{1}</span> and 2<span class="math">\\mathbb{F}</span>. Thus we have a total of <span class="math">6\\mathbb{G}_{1}</span>, <span class="math">2\\mathbb{G}_{2}</span> and 4<span class="math">\\mathbb{F}</span>.</p>

    <p class="text-gray-300">For the verifier, their first pairing check in Fig. 1 uses pairings of the form <span class="math">e(<em>,[1]_{2})</span>, <span class="math">e(</em>,[z]_{2})</span>, and <span class="math">e([h]_{1},<em>)</span> amounting to 3 pairings. The Pedersen verifier uses no pairings. In Fig. 3 we have a KZG verifier which uses pairings of the form <span class="math">e(</em>,[1]_{2})</span>, <span class="math">e(<em>,[x]_{2})</span>, and a pairing check that uses pairings of the form <span class="math">e(</em>,[1]_{2})</span>, <span class="math">e(<em>,[z]_{2})</span>, and <span class="math">e(</em>,[x]_{2})</span>. Thus we can batch the pairing checks to get a total of 4 unique pairings over the two constructions.</p>

    <h4 id="sec-47" class="text-lg font-semibold mt-6">Fig. 4 and 5:</h4>

    <p class="text-gray-300">In Fig. 4 proofs have the form <span class="math">([C_{I}]_{1},[z_{I}]_{1},[u]_{1},[H_{1}]_{2},[H_{2}]_{1},v_{1},v_{2},\\pi_{1},\\pi_{2},\\pi_{3},\\pi_{\\mathsf{unity}^{\\prime}})</span>. Here the <span class="math">\\pi_{1},\\pi_{3}</span> are both openings at the same <span class="math">\\alpha</span> and can be batched into one proof. Thus there are <span class="math">7\\mathbb{G}_{1}</span>, <span class="math">1\\mathbb{G}_{2}</span> and 2<span class="math">\\mathbb{F}</span> in addition to the <span class="math">\\pi_{\\mathsf{unity}^{\\prime}}</span>. In 3 proofs have that form <span class="math">\\bigl{(}[\\bar{U}]_{1},[h_{2}]_{1},[h_{1}]_{1},[\\bar{U}_{\\alpha}]_{1},[h_{2,\\alpha}]_{1},</span> <span class="math">v^{\\prime}_{1},v^{\\prime}_{2},v^{\\prime}_{3},\\pi^{\\prime}_{1},\\pi^{\\prime}_{2},\\pi^{\\prime}_{3},\\pi^{\\prime}_{4},\\pi^{\\prime}_{5}\\bigr{)}</span>. Here we can send the same verifier challenge <span class="math">\\alpha</span> in both Fig. 4 and Fig. 5 (assuming we run the protocols in parallel) which allows us to avoid sending <span class="math">v^{\\prime}_{1},\\pi^{\\prime}_{1}</span> in Fig. 5. Further, this allows us to batch the proofs <span class="math">(\\pi^{\\prime}_{2},\\pi^{\\prime}_{3})</span> with the proof for <span class="math">(\\pi_{1},\\pi_{3})</span> because these all use the same <span class="math">\\alpha</span>. Thus <span class="math">\\pi_{\\mathsf{unity}^{\\prime}}</span> contributes <span class="math">7\\mathbb{G}_{1}</span>, and 2<span class="math">\\mathbb{F}</span> Thus we have a total of <span class="math">14\\mathbb{G}_{1}</span>, <span class="math">1\\mathbb{G}_{2}</span> and 4<span class="math">\\mathbb{F}</span>.</p>

    <p class="text-gray-300">For the verifier, their pairing check in Fig. 4 uses pairings of the form <span class="math">e(<em>,[1]_{2})</span> and <span class="math">e([z_{I}]_{1})</span>. We also have 3 KZG verifiers which use pairings of the form <span class="math">e(</em>,[1]_{2})</span>, <span class="math">e(<em>,[x]_{2})</span>. This amounts to 2 batched pairings. In Fig. 3 we have a 5 KZG verifiers. Two use a degree check and thus use pairings of the form <span class="math">e(</em>,[1]_{2})</span>, <span class="math">e(<em>,[x]_{2})</span>, and <span class="math">e(</em>,[x^{d-n+1}]_{2})</span>. The others have the usual pairings as these do not have degree checks. Thus we can batch the pairing checks to get a total of 4 unique pairings over the two constructions.</p>

    <h2 id="sec-48" class="text-2xl font-bold">9 Implementation</h2>

    <p class="text-gray-300">We have implemented our scheme in Rust using the arkworks library <em>[2]</em>, and have released the implementation in open source. The code contains a subroutine that computes all KZG openings, which we need for fast proof preprocessing and which can be used in other projects. For all the schemes different from Caulk, we used the Legosnark implementation. All the benchmarks included in this section have been obtained by running the corresponding codes in a laptop with CPU i7-8565U and 8GB of RAM; which allowed us to run the code for public sets of size up to <span class="math">2^{22}</span> for the single case and <span class="math">2^{20}</span> for lookups.</p>

    <p class="text-gray-300">In Table 2 we compare Caulk’s prover and verfiier time as well as proof size with its alternatives in the scenario where <span class="math">m=1</span> and for different values of <span class="math">N</span>. In Figure 6, we highlight prover time in the <span class="math">y</span> axis, while <span class="math">N</span> is represented in the <span class="math">x</span> axis on a logarithmic scale. We consider the following schemes:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Caulk: the <span class="math">m=1</span> version;</li>

      <li>MT-Pos: SNARKed Merkle Poseidon tree with <span class="math">N</span> elements.</li>

      <li>MT-SHA: SNARKed Merkle SHA-2 tree with <span class="math">N</span> elements.</li>

      <li>Harisa <em>[11]</em>: RSA-2048 accumulator of <span class="math">N</span> elements.</li>

    </ul>

    <p class="text-gray-300">We see that Caulk's prover is almost 100 times as fast as Merkle trees instantiated with a Poseidon Hash and Groth16 zkSNARK on top, and 10 times as fast as the RSA accumulator. Although the latter stays constant while Caulk's time grows slowly, we claim Caulk will still perform better for all values  <span class="math">N</span>  that can be consider practical.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover Time (s)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier Time (s)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof Size (KB)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">log(N) =</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MTPos</td>

            <td class="px-3 py-2 border-b border-gray-700">2.360</td>

            <td class="px-3 py-2 border-b border-gray-700">4.235</td>

            <td class="px-3 py-2 border-b border-gray-700">5.279</td>

            <td class="px-3 py-2 border-b border-gray-700">6.881</td>

            <td class="px-3 py-2 border-b border-gray-700">8.953</td>

            <td class="px-3 py-2 border-b border-gray-700">0.025</td>

            <td class="px-3 py-2 border-b border-gray-700">0.027</td>

            <td class="px-3 py-2 border-b border-gray-700">0.026</td>

            <td class="px-3 py-2 border-b border-gray-700">0.028</td>

            <td class="px-3 py-2 border-b border-gray-700">0.300</td>

            <td class="px-3 py-2 border-b border-gray-700">0.290</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MTSha</td>

            <td class="px-3 py-2 border-b border-gray-700">52.310</td>

            <td class="px-3 py-2 border-b border-gray-700">77.619</td>

            <td class="px-3 py-2 border-b border-gray-700">110.183</td>

            <td class="px-3 py-2 border-b border-gray-700">141.280</td>

            <td class="px-3 py-2 border-b border-gray-700">160.027</td>

            <td class="px-3 py-2 border-b border-gray-700">0.030</td>

            <td class="px-3 py-2 border-b border-gray-700">0.028</td>

            <td class="px-3 py-2 border-b border-gray-700">0.028</td>

            <td class="px-3 py-2 border-b border-gray-700">0.026</td>

            <td class="px-3 py-2 border-b border-gray-700">0.027</td>

            <td class="px-3 py-2 border-b border-gray-700">0.290</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Harisa</td>

            <td class="px-3 py-2 border-b border-gray-700">0.029</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">0.011</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1.170</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Caulk</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0164</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0164</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0249</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0294</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0299</td>

            <td class="px-3 py-2 border-b border-gray-700">0.009</td>

            <td class="px-3 py-2 border-b border-gray-700">0.009</td>

            <td class="px-3 py-2 border-b border-gray-700">0.009</td>

            <td class="px-3 py-2 border-b border-gray-700">0.011</td>

            <td class="px-3 py-2 border-b border-gray-700">0.011</td>

            <td class="px-3 py-2 border-b border-gray-700">0.600</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 6: Comparison for single openings</p>

    <p class="text-gray-300">Table 2: Comparison Table for individual openings</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover Time (s)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier Time (s)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof Size</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">m =</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">(KB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MTPos8</td>

            <td class="px-3 py-2 border-b border-gray-700">26.820</td>

            <td class="px-3 py-2 border-b border-gray-700">41.290</td>

            <td class="px-3 py-2 border-b border-gray-700">53.027</td>

            <td class="px-3 py-2 border-b border-gray-700">81.605</td>

            <td class="px-3 py-2 border-b border-gray-700">126.940</td>

            <td class="px-3 py-2 border-b border-gray-700">0.027</td>

            <td class="px-3 py-2 border-b border-gray-700">0.028</td>

            <td class="px-3 py-2 border-b border-gray-700">0.031</td>

            <td class="px-3 py-2 border-b border-gray-700">0.031</td>

            <td class="px-3 py-2 border-b border-gray-700">0.032</td>

            <td class="px-3 py-2 border-b border-gray-700">0.290</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Caulk8</td>

            <td class="px-3 py-2 border-b border-gray-700">0.087</td>

            <td class="px-3 py-2 border-b border-gray-700">0.113</td>

            <td class="px-3 py-2 border-b border-gray-700">0.183</td>

            <td class="px-3 py-2 border-b border-gray-700">0.255</td>

            <td class="px-3 py-2 border-b border-gray-700">0.469</td>

            <td class="px-3 py-2 border-b border-gray-700">0.038</td>

            <td class="px-3 py-2 border-b border-gray-700">0.042</td>

            <td class="px-3 py-2 border-b border-gray-700">0.043</td>

            <td class="px-3 py-2 border-b border-gray-700">0.044</td>

            <td class="px-3 py-2 border-b border-gray-700">0.042</td>

            <td class="px-3 py-2 border-b border-gray-700">0.890</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Harisa</td>

            <td class="px-3 py-2 border-b border-gray-700">1.228</td>

            <td class="px-3 py-2 border-b border-gray-700">2.014</td>

            <td class="px-3 py-2 border-b border-gray-700">2.374</td>

            <td class="px-3 py-2 border-b border-gray-700">3.939</td>

            <td class="px-3 py-2 border-b border-gray-700">6.011</td>

            <td class="px-3 py-2 border-b border-gray-700">0.011</td>

            <td class="px-3 py-2 border-b border-gray-700">0.011</td>

            <td class="px-3 py-2 border-b border-gray-700">0.012</td>

            <td class="px-3 py-2 border-b border-gray-700">0.012</td>

            <td class="px-3 py-2 border-b border-gray-700">0.013</td>

            <td class="px-3 py-2 border-b border-gray-700">1.170</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MTPos20</td>

            <td class="px-3 py-2 border-b border-gray-700">69.715</td>

            <td class="px-3 py-2 border-b border-gray-700">102.607</td>

            <td class="px-3 py-2 border-b border-gray-700">128.766</td>

            <td class="px-3 py-2 border-b border-gray-700">200.975</td>

            <td class="px-3 py-2 border-b border-gray-700">271.400</td>

            <td class="px-3 py-2 border-b border-gray-700">0.029</td>

            <td class="px-3 py-2 border-b border-gray-700">0.033</td>

            <td class="px-3 py-2 border-b border-gray-700">0.032</td>

            <td class="px-3 py-2 border-b border-gray-700">0.027</td>

            <td class="px-3 py-2 border-b border-gray-700">0.028</td>

            <td class="px-3 py-2 border-b border-gray-700">0.290</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Caulk20</td>

            <td class="px-3 py-2 border-b border-gray-700">0.565</td>

            <td class="px-3 py-2 border-b border-gray-700">0.803</td>

            <td class="px-3 py-2 border-b border-gray-700">0.991</td>

            <td class="px-3 py-2 border-b border-gray-700">1.468</td>

            <td class="px-3 py-2 border-b border-gray-700">2.767</td>

            <td class="px-3 py-2 border-b border-gray-700">0.045</td>

            <td class="px-3 py-2 border-b border-gray-700">0.046</td>

            <td class="px-3 py-2 border-b border-gray-700">0.041</td>

            <td class="px-3 py-2 border-b border-gray-700">0.043</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0483</td>

            <td class="px-3 py-2 border-b border-gray-700">0.890</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3: Comparison table for lookups</p>

    <p class="text-gray-300">We compare Caulk's performance for lookup tables in Table 3 with its most direct competitors. We consider the following schemes:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>MT-Pos-20: SNARKed Merkle tree with Poseidon hashes and  <span class="math">N = 2^{20}</span>  elements.</li>

      <li>MT-Pos-8: SNARKed Merkle tree with Poseidon hashes and  <span class="math">N = 2^{8}</span>  elements.</li>

      <li>Caulk-8: Caulk for vectors of size  <span class="math">N = 2^{8}</span> .</li>

      <li>Caulk-20: Caulk for vectors of size  <span class="math">N = 2^{20}</span> .</li>

      <li>Harisa [11]: RSA-2048 accumulator for vectors of size  <span class="math">N = 2^{16}</span>  elements. The performance of the prover in RSA accumulators is independent on the size of the vector.</li>

    </ul>

    <p class="text-gray-300">In Figure 7, the  <span class="math">y</span>  axis represent prover time, while the  <span class="math">x</span>  axis represent the value of  <span class="math">m</span> . The size of the vector is different for every color line. Caulk is faster than Harisa for all the values of  <span class="math">N</span>  we were able to compute, but approaches as  <span class="math">N</span>  grows, and will perform worse for bigger tables. Also, we consider small values for  <span class="math">m</span>  (up to 50) but we expect that for larger values of  <span class="math">m</span>  the quadratic component of Caulk's prover time would make it unpractical. Both constructions are significantly faster than Merkle-SNARK.</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 7: Comparison for lookup tables</p>

    <p class="text-gray-300">For pre-processing the powers of  <span class="math">x</span>  in  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span>  as well as the single opening proofs, we use a laptop Dell XPS 17, CPU: Intel Core i9-11900H @2.5 Ghz, 16 GB RAM. The computation was single-core and the times are shown in Table 4.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">log(N)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">8</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">12</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">16</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">20</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Time(sec)</td>

            <td class="px-3 py-2 border-b border-gray-700">3.5</td>

            <td class="px-3 py-2 border-b border-gray-700">100</td>

            <td class="px-3 py-2 border-b border-gray-700">874</td>

            <td class="px-3 py-2 border-b border-gray-700">32830</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 4: Pre-processing times</p>

    <p class="text-gray-300">We thank Matteo Campanelli for his help on running the LegoSNARK code.</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] M. R. Albrecht, L. Grassi, C. Rechberger, A. Roy, and T. Tiessen. MiMC: Efficient Encryption and Cryptographic Hashing with Minimal Multiplicative Complexity. In ASIACRYPT 2016, volume 10031 of LNCS, pages 191–219, 2016.</li>

      <li>[2] arkworks contributors. arkworks zksnark ecosystem, 2022.</li>

      <li>[3] S. Bayer and J. Groth. Zero-knowledge argument for polynomial evaluation with application to blacklists. In T. Johansson and P. Q. Nguyen, editors, Advances in Cryptology - EUROCRYPT 2013, 32nd Annual International Conference on the Theory and Applications of Cryptographic Techniques, Athens, Greece, May 26-30, 2013. Proceedings, volume 7881 of Lecture Notes in Computer Science, pages 646–663. Springer, 2013.</li>

      <li>[4] E. Ben-Sasson, A. Chiesa, C. Garman, M. Green, I. Miers, E. Tromer, and M. Virza. Zerocash: Decentralized anonymous payments from bitcoin. In 2014 IEEE Symposium on Security and Privacy, SP 2014, Berkeley, CA, USA, May 18-21, 2014, pages 459–474. IEEE Computer Society, 2014.</li>

      <li>[5] D. Benarroch, M. Campanelli, D. Fiore, K. Gurkan, and D. Kolonelos. Zero-knowledge proofs for set membership: Efficient, succinct, modular. In N. Borisov and C. Díaz, editors, Financial Cryptography and Data Security - 25th International Conference, FC 2021, Virtual Event, March 1-5, 2021, Revised Selected Papers, Part I, volume 12674 of Lecture Notes in Computer Science, pages 393–414. Springer, 2021.</li>

      <li>[6] D. Boneh and X. Boyen. Short signatures without random oracles. In EUROCRYPT, volume 3027 of Lecture Notes in Computer Science, pages 56–73. Springer, 2004.</li>

      <li>[7] J. Bootle, A. Cerulli, P. Chaidos, E. Ghadafi, J. Groth, and C. Petit. Short accountable ring signatures based on DDH. In G. Pernul, P. Y. A. Ryan, and E. R. Weippl, editors, Computer Security - ESORICS 2015 - 20th European Symposium on Research in Computer Security, Vienna, Austria, September 21-25, 2015, Proceedings, Part I, volume 9326 of Lecture Notes in Computer Science, pages 243–265. Springer, 2015.</li>

      <li>[8] J. Bootle and J. Groth. Efficient batch zero-knowledge arguments for low degree polynomials. In M. Abdalla and R. Dahab, editors, Public-Key Cryptography - PKC 2018 - 21st IACR International Conference on Practice and Theory of Public-Key Cryptography, Rio de Janeiro, Brazil, March 25-29, 2018, Proceedings, Part II, volume 10770 of Lecture Notes in Computer Science, pages 561–588. Springer, 2018.</li>

      <li>[9] J. Camenisch, R. Chaabouni, and A. Shelat. Efficient protocols for set membership and range proofs. In J. Pieprzyk, editor, Advances in Cryptology - ASIACRYPT 2008, 14th International Conference on the Theory and Application of Cryptology and Information Security, Melbourne, Australia, December 7-11, 2008. Proceedings, volume 5350 of Lecture Notes in Computer Science, pages 234–252. Springer, 2008.</li>

      <li>[10] J. Camenisch and A. Lysyanskaya. Dynamic accumulators and application to efficient revocation of anonymous credentials. In M. Yung, editor, Advances in Cryptology - CRYPTO 2002, 22nd Annual International Cryptology Conference, Santa Barbara, California, USA, August 18-22, 2002, Proceedings, volume 2442 of Lecture Notes in Computer Science, pages 61–76. Springer, 2002.</li>

      <li>[11] M. Campanelli, D. Fiore, S. Han, J. Kim, D. Kolonelos, and H. Oh. Succinct zero-knowledge batch proofs for set accumulators. IACR Cryptol. ePrint Arch., page 1672, 2021.</li>

      <li>[12] A. Chiesa, Y. Hu, M. Maller, P. Mishra, P. Vesely, and N. Ward. Marlin: Preprocessing zksnarks with universal and updatable srs. In A. Canteaut and Y. Ishai, editors, Advances in Cryptology - EUROCRYPT 2020 - 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Virtual Conference, May 1-15, 2020, Proceedings, Part I, volume 12105 of Lecture Notes in Computer Science, pages 738–768. Springer, 2020.</li>

      <li>[13] D. Feist and D. Khovratovich. Fast amortized kate proofs.</li>

    </ul>

    <p class="text-gray-300">[14] A. Fiat and A. Shamir. How to prove yourself: Practical solu- tions to identification and signature problems. In A. M. Odlyzko, editor, Advances in Cryptology - CRYPTO 1986, volume 263 of Lecture Notes in Computer Science, pages 186–194. Springer, 1987.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[15] G. Fuchsbauer, E. Kiltz, and J. Loss. The algebraic group model and its applications. In H. Shacham and A. Boldyreva, editors, CRYPTO 2018, Santa Barbara, CA, USA, August 19-23, 2018, Proceedings, Part II, volume 10992 of LNCS, pages 33–62. Springer, 2018.</li>

      <li>[16] A. Gabizon and Z. J. Williamson. Plonk: Permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge. IACR Cryptol. ePrint Arch., page 953, 2019.</li>

      <li>[17] A. Gabizon and Z. J. Williamson. plookup: A simplified polynomial protocol for lookup tables. IACR Cryptol. ePrint Arch., page 315, 2020.</li>

      <li>[18] E. Ghadafi and J. Groth. Towards a classification of non-interactive computational assumptions in cyclic groups. IACR Cryptol. ePrint Arch., page 343, 2017.</li>

      <li>[19] L. Grassi, D. Khovratovich, A. Roy, C. Rechberger, and M. Schofnegger. Poseidon: A new hash function for zero-knowledge proof systems. Usenix Security 2021, 2021.</li>

      <li>[20] J. Groth. On the size of pairing-based non-interactive arguments. In EUROCRYPT (2), volume 9666 of Lecture Notes in Computer Science, pages 305–326. Springer, 2016.</li>

      <li>[21] J. Groth and M. Kohlweiss. One-out-of-many proofs: Or how to leak a secret and spend a coin. In E. Oswald and M. Fischlin, editors, Advances in Cryptology - EUROCRYPT 2015 - 34th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Sofia, Bulgaria, April 26-30, 2015, Proceedings, Part II, volume 9057 of Lecture Notes in Computer Science, pages 253–280. Springer, 2015.</li>

      <li>[22] A. Kate, G. M. Zaverucha, and I. Goldberg. Constant-size commitments to polynomials and their applications. In ASIACRYPT, volume 6477 of Lecture Notes in Computer Science, pages 177–194. Springer, 2010.</li>

      <li>[23] M. Kohlweiss, M. Maller, J. Siim, and M. Volkhov. Snarky ceremonies. In ASIACRYPT (3), volume 13092 of Lecture Notes in Computer Science, pages 98–127. Springer, 2021.</li>

      <li>[24] U. M. Maurer. Unifying zero-knowledge proofs of knowledge. In AFRICACRYPT, volume 5580 of Lecture Notes in Computer Science, pages 272–286. Springer, 2009.</li>

      <li>[25] I. Miers, C. Garman, M. Green, and A. D. Rubin. Zerocoin: Anonymous distributed e-cash from bitcoin. In 2013 IEEE Symposium on Security and Privacy, SP 2013, Berkeley, CA, USA, May 19-22, 2013, pages 397–411. IEEE Computer Society, 2013.</li>

      <li>[26] C. Papamanthou, E. Shi, and R. Tamassia. Signatures of correct computation. In TCC, volume 7785 of Lecture Notes in Computer Science, pages 222–242. Springer, 2013.</li>

      <li>[27] L. Pearson, J. Fitzgerald, H. Masip, M. Bellés-Muñoz, and J. L. Muñoz-Tapia. Plonkup: Reconciling plonk with plookup. IACR Cryptol. ePrint Arch., page 86, 2022.</li>

      <li>[28] A. Tomescu, I. Abraham, V. Buterin, J. Drake, D. Feist, and D. Khovratovich. Aggregatable subvector commitments for stateless cryptocurrencies. In C. Galdi and V. Kolesnikov, editors, Security and Cryptography for Networks - 12th International Conference, SCN 2020, Amalfi, Italy, September 14-16, 2020, Proceedings, volume 12238 of Lecture Notes in Computer Science, pages 45–64. Springer, 2020.</li>

      <li>[29] Tornado cash privacy solution version 1.4, 2021. https://tornado.cash/Tornado.cash_ whitepaper_v1.4.pdf.</li>

      <li>[30] ZCash protocol specification, 2022, 1st February. https://github.com/zcash/zips/blob/master/protocol/protocol.pdf.</li>

      <li>[31] Zksync rollup protocol, 2021. https://github.com/matter-labs/zksync/blob/master/docs/protocol.md.</li>

    </ul>

    <p class="text-gray-300">A Definitions</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathcal{R}</span> be a family of universal relations. Given a relation <span class="math">\\mathsf{R}\\in\\mathcal{R}</span> and an instance <span class="math">\\mathsf{x}</span> we call <span class="math">w</span> a <em>witness</em> for <span class="math">\\mathsf{x}</span> if <span class="math">(\\mathsf{x},w)\\in\\mathsf{R}</span>, $\\mathcal{L}(\\mathsf{R})=\\{\\mathsf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ \\exists w:(\\mathsf{x},w)\\in\\mathsf{R}\\}<span class="math"> is the language of all the </span>\\mathsf{x}<span class="math"> that have a witness </span>w<span class="math"> in the relation </span>\\mathsf{R}<span class="math">, while </span>\\mathcal{L}(\\mathsf{R})<span class="math"> is the language of all the pairs </span>(\\mathsf{x},\\mathsf{R})<span class="math"> such that </span>\\mathsf{x}\\in\\mathcal{L}(\\mathsf{R})<span class="math">. We will assume </span>\\mathsf{R}$ it is implicit as prover and verifier input.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-50" class="text-base font-medium mt-4">Definition A.1.</h6>

    <p class="text-gray-300">A Non-Interactive Zero-Knowledge Argument of Knowledge is a tuple of PPT algorithms <span class="math">(\\mathsf{Setup},\\mathsf{Prove},\\mathsf{Verify},\\mathsf{Simulate})</span> such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{srs},x)\\leftarrow\\mathsf{Setup}(\\mathcal{R})</span>: On input a family of relations <span class="math">\\mathcal{R}</span>, <span class="math">\\mathsf{Setup}</span> outputs a structured reference string <span class="math">\\mathsf{srs}</span> and a trapdoor <span class="math">x</span>;</li>

      <li><span class="math">\\pi\\leftarrow\\mathsf{Prove}(\\mathsf{srs},(\\mathsf{x},w))</span>: On input a pair <span class="math">(\\mathsf{x},w)\\in\\mathsf{R}</span>, it outputs a proof <span class="math">\\pi</span> of the fact that <span class="math">\\mathsf{x}\\in\\mathcal{L}(\\mathsf{R})</span>;</li>

      <li><span class="math">1/0\\leftarrow\\mathsf{Verify}(\\mathsf{srs},\\mathsf{x},\\pi)</span>: On input the <span class="math">\\mathsf{srs}</span>, the instance <span class="math">\\mathsf{x}</span> and the proof, it produces a bit expressing acceptance <span class="math">(1)</span>, or rejection <span class="math">(0)</span>;</li>

      <li><span class="math">\\pi_{\\mathrm{sim}}\\leftarrow\\mathsf{Simulate}(\\mathsf{srs},x,\\mathsf{x})</span>: The simulator has the <span class="math">\\mathsf{srs}</span>, the trapdoor <span class="math">x</span> and the instance <span class="math">\\mathsf{x}</span> as inputs and it generates a simulated proof <span class="math">\\pi_{\\mathrm{sim}}</span>,</li>

    </ul>

    <p class="text-gray-300">and that satisfies completeness, knowledge soundness and zero-knowledge as defined below.</p>

    <h5 id="sec-51" class="text-base font-semibold mt-4">Completeness:</h5>

    <p class="text-gray-300">holds if an honest prover will always convince an honest verifier. Formally, <span class="math">\\forall\\ \\mathsf{R}\\in\\mathcal{R},(\\mathsf{x},w)\\in\\mathsf{R}</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\Pr\\left[\\begin{array}[]{c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cc}\\mathsf{Verify}(\\mathsf{srs},\\mathsf{x},\\pi)=1&\\left(\\mathsf{srs},x\\right)\\leftarrow\\mathsf{Setup}(\\mathcal{R})\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\pi\\leftarrow\\mathsf{Prove}(\\mathsf{srs},(\\mathsf{x},w))\\end{array}\\right]=1. \\]</p>

    <h5 id="sec-52" class="text-base font-semibold mt-4">Knowledge-Soundness:</h5>

    <p class="text-gray-300">captures the fact that a cheating prover cannot, except with negligible probability, create a proof <span class="math">\\pi</span> accepted by the verification algorithm unless it has a witness <span class="math">w</span> such that <span class="math">(\\mathsf{x},w)\\in\\mathsf{R}</span>. Formally, for all PPT adversaries <span class="math">\\mathcal{A}</span>, there exists a PPT extractor <span class="math">\\mathcal{E}</span> such that the following probability is negligible in <span class="math">\\lambda</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\Pr\\left[\\begin{array}[]{c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cc}(\\mathsf{x},w)\\notin\\mathsf{R}\\land\\mathsf{Verify}(\\mathsf{srs},\\mathsf{x},\\pi)=1&\\left(\\mathsf{srs},x\\right)\\leftarrow\\mathsf{Setup}(\\mathcal{R})\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(\\mathsf{x},\\pi)\\leftarrow\\mathcal{A}(\\mathsf{srs})\\\\ w\\leftarrow\\mathcal{E}(\\mathsf{srs},\\mathsf{x},\\pi)\\end{array}\\right] \\]</p>

    <h5 id="sec-53" class="text-base font-semibold mt-4">Zero-Knowledge:</h5>

    <p class="text-gray-300">(<span class="math">\\mathsf{Setup},\\mathsf{Prove},\\mathsf{Verify},\\mathsf{Simulate}</span>) is zero-knowledge if for all <span class="math">\\mathsf{R}\\in\\mathcal{R}</span>, instances <span class="math">\\mathsf{x}</span> and PPT adversaries <span class="math">\\mathcal{A}</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\Pr\\left[\\begin{array}[]{c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cc}\\mathcal{A}(\\mathsf{srs},\\pi)=1&\\left(\\mathsf{srs},x\\right)\\leftarrow\\mathsf{Setup}(\\mathcal{R})\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\mathsf{x}\\leftarrow\\mathcal{A}(\\mathsf{srs})\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi\\leftarrow\\mathsf{Prove}(\\mathsf{srs},(\\mathsf{x},w))\\end{array}\\right]\\ \\approx\\Pr\\left[\\begin{array}[]{c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cc}\\mathcal{A}(\\mathsf{srs},\\pi_{\\mathrm{sim}})=1&\\left(\\mathsf{srs},x\\right)\\leftarrow\\mathsf{Setup}(\\mathcal{R})\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\mathsf{x}\\leftarrow\\mathcal{A}(\\mathsf{srs})\\\\ \\pi_{\\mathrm{sim}}\\leftarrow\\mathsf{Simulate}(\\mathsf{srs},x,\\mathsf{x})\\end{array}\\right]. \\]</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Definition A.2 (Vector Commitment Scheme).</h6>

    <p class="text-gray-300">A <em>Vector Commitment Scheme</em> is a tuple of algorithms <span class="math">(\\mathsf{Setup},\\mathsf{Commit},\\mathsf{Open},\\mathsf{Verify})</span> such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(x,\\mathsf{srs})\\leftarrow\\mathsf{Setup}\\big{(}\\mathsf{par},d\\big{)}</span>: On input the system parameters and a bound <span class="math">d</span> on the size of the vectors, it outputs a structured reference string and trapdoor <span class="math">x</span>.</li>

      <li><span class="math">\\mathsf{C}\\leftarrow\\mathsf{Commit}\\big{(}\\mathsf{srs},\\vec{v},r\\big{)}</span>: On input the <span class="math">\\mathsf{srs}</span>, a vector <span class="math">\\vec{v}</span>, and randomness <span class="math">r</span> it outputs a commitment <span class="math">\\mathsf{C}</span>.</li>

      <li><span class="math">(v_{i},\\pi)\\leftarrow\\mathsf{Open}\\big{(}\\mathsf{srs},\\vec{v},r,i\\big{)}</span>: On input the <span class="math">\\mathsf{srs}</span>, the vector, its size , the commitment randomness, and a position <span class="math">i\\in[m]</span> it outputs <span class="math">v_{i}\\in\\mathbb{F}</span> and proof <span class="math">\\pi</span> that <span class="math">v_{i}</span> is the <span class="math">i</span>th element of vector <span class="math">\\vec{v}</span>.</li>

      <li><span class="math">1/0\\leftarrow\\mathsf{Verify}\\big{(}\\mathsf{srs},\\mathsf{C},i,v_{i},\\pi\\big{)}</span>: On input the <span class="math">\\mathsf{srs}</span>, the commitment, position, claimed value <span class="math">v_{i}</span>, and the proof, it outputs a bit indicating acceptance or rejection.</li>

    </ul>

    <p class="text-gray-300">A vector commitment scheme should satisfy the following properties:</p>

    <p class="text-gray-300">Correctness: It captures the fact that an honest prover will always convince an honest verifier. Namely, for all vectors  <span class="math">\\vec{v} \\in \\mathbb{F}^N</span>  and  <span class="math">i \\in [N]</span></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\operatorname {V e r i f y} (\\mathsf {s r s}, \\mathsf {C}, i, v _ {i}, \\pi) = 1 &amp;amp; \\begin{array}{c} \\mathsf {s r s} \\leftarrow \\operatorname {S e t u p} (\\mathsf {p a r}, N) \\\\ \\mathsf {C} \\leftarrow \\operatorname {C o m m i t} (\\mathsf {s r s}, \\vec {v}, r) \\\\ (v _ {i}, \\pi) \\leftarrow \\operatorname {O p e n} (\\mathsf {s r s}, \\vec {v}, r, i) \\end{array} \\end{array} \\right] = 1</span></div>

    <p class="text-gray-300">(Weak) Position Binding: Captures the fact that no PPT adversary  <span class="math">\\mathcal{A}</span>  should be able to present for one commitment two valid openings for the same position. Formally:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\operatorname {V e r i f y} (\\mathsf {s r s}, \\mathsf {C}, i, y, \\pi) = 1, &amp;amp; \\mathsf {s r s} \\leftarrow \\operatorname {S e t u p} (\\mathsf {p a r}, N) \\\\ \\operatorname {V e r i f y} (\\mathsf {s r s}, \\mathsf {C}, i, y ^ {\\prime}, \\pi^ {\\prime}) = 1 &amp;amp; (\\vec {v}, r, i, y, y ^ {\\prime}, \\pi , \\pi^ {\\prime}) \\leftarrow \\mathcal {A} (\\mathsf {s r s}) \\\\ \\text {a n d} y \\neq y ^ {\\prime} &amp;amp; \\mathsf {C} \\leftarrow \\operatorname {C o m m i t} (\\mathsf {s r s}, \\vec {v}, r) \\end{array} \\right] \\approx 0</span></div>

    <p class="text-gray-300">(Strong) Position Binding: Captures the fact that no PPT adversary  <span class="math">\\mathcal{A}</span>  should be able to present for one commitment two valid openings for the same position. Formally:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\operatorname {V e r i f y} (\\mathsf {s r s}, \\mathsf {C}, i, y, \\pi) = 1, &amp;amp; \\mathsf {s r s} \\leftarrow \\operatorname {S e t u p} (\\mathsf {p a r}, N) \\\\ \\operatorname {V e r i f y} (\\mathsf {s r s}, \\mathsf {C}, i, y ^ {\\prime}, \\pi^ {\\prime}) = 1 &amp;amp; (\\mathsf {C}, i, y, y ^ {\\prime}, \\pi , \\pi^ {\\prime}) \\leftarrow \\mathcal {A} (\\mathsf {s r s}) \\\\ \\text {a n d} y \\neq y ^ {\\prime} &amp;amp; \\end{array} \\right] \\approx 0</span></div>

    <p class="text-gray-300">Knowledge Soundness: Captures the fact that whenever the prover provides a valid opening, it knows a valid pair  <span class="math">(p(X), p(\\alpha)) \\in \\mathbb{F}[X] \\times \\mathbb{F}</span> , where  <span class="math">\\deg(p) \\leq \\deg</span> . Formally, for all PPT adversaries  <span class="math">\\mathcal{A}</span>  there exists an efficient extractor  <span class="math">\\mathcal{E}</span>  such that:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\operatorname {V e r i f y} (\\mathsf {s r s}, \\mathsf {C}, i, y, \\pi) = 1 &amp;amp; \\mathsf {s r s} \\leftarrow \\operatorname {S e t u p} (\\mathsf {p a r}, N) \\\\ \\wedge v _ {i} \\neq y &amp;amp; \\mathcal {C} \\leftarrow \\mathcal {A} (\\mathsf {s r s}) \\\\ &amp;amp; \\vec {v} \\leftarrow \\mathcal {E} (\\mathsf {s r s}, \\mathsf {C}, N) \\\\ &amp;amp; (i, y, \\pi) \\leftarrow \\mathcal {A} (\\mathsf {s r s}, \\vec {v}, N, i) \\end{array} \\right] \\approx 0</span></div>

    <p class="text-gray-300">Definition A.3 (Polynomial Commitment Scheme). A Polynomial Commitment Scheme is a tuple of algorithms (Setup, Commit, Open, Verify) such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(x, \\mathsf{srs}) \\gets \\operatorname{Setup}(\\mathsf{par}, d)</span> : On input the system parameters and a degree bound  <span class="math">d</span> , it outputs a structured reference string and trapdoor  <span class="math">x</span> .</li>

      <li><span class="math">\\mathsf{C} \\gets \\mathsf{Commit}(\\mathsf{srs}, p(X), r)</span> : On input the  <span class="math">srs</span>  and a polynomial  <span class="math">p(X)</span> , and randomness  <span class="math">r</span>  it outputs a commitment  <span class="math">\\mathsf{C}</span>  to  <span class="math">p(X)</span> .</li>

      <li><span class="math">(s, \\pi) \\gets \\operatorname{Open}(\\mathsf{srs}, p(X), r, \\alpha)</span> : On input the  <span class="math">srs</span> , the polynomial, commitment randomness  <span class="math">r</span> , a query point  <span class="math">\\alpha \\in \\mathbb{F}</span> , it outputs  <span class="math">s \\in \\mathbb{F}</span>  and an evaluation proof  <span class="math">\\pi</span>  that  <span class="math">s = p(\\alpha)</span> .</li>

      <li><span class="math">1/0 \\gets \\operatorname{Verify}(\\mathsf{srs}, \\mathsf{C}, \\deg, \\alpha, s, \\pi)</span> : On input the  <span class="math">srs</span> , the commitment, degree bound, query and evaluation points  <span class="math">\\alpha, s</span> , and the proof of correct evaluation, it outputs a bit indicating acceptance or rejection.</li>

    </ul>

    <p class="text-gray-300">A polynomial commitment scheme should satisfy the following properties:</p>

    <p class="text-gray-300">Completeness: It captures the fact that an honest prover will always convince an honest verifier. Formally, for any polynomial  <span class="math">p(X)</span>  such that  <span class="math">\\deg(p) \\leq d</span>  and query point  <span class="math">\\alpha \\in \\mathbb{F}</span>  the following probability is 1:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\operatorname {V e r i f y} (\\mathsf {s r s}, \\mathsf {C}, \\deg , \\alpha , s, \\pi) = 1 &amp;amp; \\begin{array}{c} \\mathsf {s r s} \\leftarrow \\operatorname {S e t u p} (\\mathsf {p a r}, d) \\\\ \\mathsf {C} \\leftarrow \\operatorname {C o m m i t} (\\mathsf {s r s}, p (X), r) \\\\ s = p (\\alpha), \\deg (p) = \\deg \\\\ (s, \\pi) \\leftarrow \\operatorname {O p e n} (\\mathsf {s r s}, p (X), r, \\alpha) \\end{array} \\end{array} \\right]</span></div>

    <p class="text-gray-300">Soundness: Captures the fact that a cheating prover should not be able to convince the verifier of a false opening. Formally, for all stateful PPT adversaries  <span class="math">\\mathcal{A}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} (p (\\alpha) \\neq s \\lor d e g (p) &amp;gt; d e g) &amp;amp; \\mathsf {s r s} \\leftarrow \\mathsf {S e t u p} (\\mathsf {p a r}, d) \\\\ \\wedge &amp;amp; (p (X), \\mathsf {C}) \\leftarrow \\mathcal {A} (\\mathsf {s r s}) \\\\ \\mathsf {V e r i f y} (\\mathsf {s r s}, \\mathsf {C}, d e g, \\alpha , s, \\pi) = 1 &amp;amp; \\alpha \\leftarrow \\mathbb {F} \\\\ &amp;amp; (s, \\pi) \\leftarrow \\mathcal {A} (\\alpha) \\end{array} \\right] \\approx 0</span></div>

    <p class="text-gray-300">Evaluation Binding:</p>

    <p class="text-gray-300">Captures the fact that no PPT adversary <span class="math">\\mathcal{A}</span> should be able to present two valid openings for different values but same evaluation point. Formally:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\operatorname {V e r i f y} \\big (\\mathsf {s r s}, \\mathsf {C}, \\deg , \\alpha , s, \\pi \\big) = 1, &amp;amp; \\mathsf {s r s} \\leftarrow \\operatorname {S e t u p} \\big (\\mathsf {p a r}, N \\big) \\\\ \\operatorname {V e r i f y} \\big (\\mathsf {s r s}, \\mathsf {C}, \\deg , \\alpha , s ^ {\\prime}, \\pi^ {\\prime} \\big) = 1 &amp;amp; (\\mathsf {C}, \\alpha , s, s ^ {\\prime}, \\pi , \\pi^ {\\prime}) \\leftarrow \\mathcal {A} \\big (\\mathsf {s r s} \\big) \\\\ \\text {a n d} s \\neq s ^ {\\prime} &amp;amp; \\end{array} \\right] \\approx 0</span></div>

    <p class="text-gray-300">Extractability: Captures the fact that whenever the prover provides a valid opening, it knows a valid pair <span class="math">(p(X), p(\\alpha)) \\in \\mathbb{F}[X] \\times \\mathbb{F}</span>, where <span class="math">\\deg(p) \\leq \\deg</span>. Formally, for all PPT adversaries <span class="math">\\mathcal{A}</span> there exists an efficient extractor <span class="math">\\mathcal{E}</span> such that:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\operatorname {V e r i f y} \\big (\\mathsf {s r s}, \\mathsf {C}, \\deg , \\alpha , s, \\pi \\big) = 1 &amp;amp; \\mathsf {s r s} \\leftarrow \\operatorname {S e t u p} \\big (\\mathsf {p a r}, \\deg \\big) \\\\ \\wedge &amp;amp; \\mathsf {C} \\leftarrow \\mathcal {A} \\big (\\mathsf {s r s} \\big) \\\\ \\big (p (\\alpha) \\neq s \\lor \\deg (p) &amp;gt; \\deg \\big) &amp;amp; p (X) \\leftarrow \\mathcal {E} \\big (\\mathsf {s r s}, \\mathsf {C}, \\deg \\big) \\\\ &amp;amp; \\alpha \\leftarrow \\mathcal {A} \\big (\\mathsf {s r s}, \\mathsf {C}, \\deg \\big) \\\\ &amp;amp; (s, \\pi) \\leftarrow \\mathcal {A} \\big (\\mathsf {s r s}, p (X), \\deg , \\alpha \\big) \\end{array} \\right] \\approx 0</span></div>

    <h2 id="sec-55" class="text-2xl font-bold">B Proof of Thm 1</h2>

    <p class="text-gray-300">Proof. We will proceed through a series of games to show that the protocol defined in Fig. 1 satisfies the linkability property. Let <span class="math">\\mathcal{A}</span> be an arbitrary algebraic PPT adversary in the linkability game and let <span class="math">\\mathsf{Adv}_{\\mathcal{A}}^{\\mathrm{linkability}}(\\lambda)</span> be their advantage. Let <span class="math">\\mathsf{Game}_0</span> be defined as in Definition 5.1, which is where we want to bound the adversary's success probability. We define <span class="math">\\mathsf{Game}_1, \\mathsf{Game}_2</span> and denote <span class="math">\\mathsf{Adv}_{\\mathcal{A}}^{G_i}</span> as the advantage of the adversary <span class="math">\\mathcal{A}</span> in game <span class="math">i</span>. We also specify reductions <span class="math">\\mathcal{B}_1, \\mathcal{B}_2, \\mathcal{B}_3, \\mathcal{B}_4</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\operatorname {A d v} _ {\\mathcal {A}} ^ {\\text {l i n k a b i l i t y}} = \\operatorname {A d v} _ {\\mathcal {A}} ^ {\\text {G a m e} _ {0}} \\leq \\operatorname {A d v} _ {\\mathcal {A}} ^ {\\text {G a m e} _ {1}} (\\lambda) + \\operatorname {A d v} _ {\\mathcal {B} _ {1}} ^ {\\text {u n i t y}} (\\lambda) \\\\ \\leq \\operatorname {A d v} _ {\\mathcal {A}} ^ {\\text {G a m e} _ {2}} (\\lambda) + \\operatorname {A d v} _ {\\mathcal {B} _ {2}} ^ {\\text {p e d}} (\\lambda) + \\operatorname {A d v} _ {\\mathcal {B} _ {1}} ^ {\\text {u n i t y}} (\\lambda) \\\\ \\leq \\operatorname {A d v} _ {\\mathcal {B} _ {1}} ^ {\\text {u n i t y}} (\\lambda) + \\operatorname {A d v} _ {\\mathcal {B} _ {2}} ^ {\\text {p e d}} (\\lambda) + \\operatorname {A d v} _ {\\mathcal {B} _ {3}} ^ {\\text {d i s g}} (\\lambda) + \\operatorname {A d v} _ {\\mathcal {B} _ {4}} ^ {\\text {S D H}} (\\lambda) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">In <span class="math">\\mathsf{Game}_0</span> the adversary will return <span class="math">\\mathsf{cm}</span> along with a proof <span class="math">([z]_2 = [z(x)]_2, [T]_1 = [T(x)]_1, [S]_2 = [S(x)]_2, \\pi_{\\mathsf{ped}}, \\pi_{\\mathsf{unity}})</span>. We define <span class="math">\\mathsf{Game}_1</span> identically to <span class="math">\\mathsf{Game}_0</span>, but after the adversary returns <span class="math">\\mathsf{cm}</span> along with the proof, <span class="math">\\mathsf{Game}_1</span> additionally checks whether there exists <span class="math">a, b</span> such that <span class="math">z(X) = a(X - b)</span> with <span class="math">a^N = b^N</span> and abort if this is not the case. Note that <span class="math">\\mathsf{Game}_1</span> can extract <span class="math">z(X)</span>, the algebraic representation of <span class="math">[z]_2</span>, because the adversary <span class="math">\\mathcal{A}</span> is algebraic.</p>

    <p class="text-gray-300">We observe that the adversary's advantage in <span class="math">\\mathsf{Game}_0</span> and <span class="math">\\mathsf{Game}_1</span> is identical, unless it manages to break the knowledge soundness of <span class="math">R_{\\mathsf{unity}}</span>. Given such an <span class="math">\\mathcal{A}</span>, we can thus directly get a reduction <span class="math">\\mathcal{B}_1</span> against the knowledge soundness of <span class="math">R_{\\mathsf{unity}}</span> and let the advantage of this adversary be <span class="math">\\mathsf{Adv}_{\\mathcal{B}_1}^{\\mathsf{unity}}</span>. The reduction <span class="math">\\mathcal{B}_1</span> simply runs <span class="math">\\mathcal{A}</span> and returns <span class="math">\\pi_{\\mathsf{unity}}</span> that is returned by <span class="math">\\mathcal{A}</span>. It thus holds that</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {A d v} _ {\\mathcal {A}} ^ {\\text {l i n k a b i l i t y}} (\\lambda) = \\operatorname {A d v} _ {\\mathcal {A}} ^ {\\text {G a m e} _ {0}} (\\lambda) \\leq \\operatorname {A d v} _ {\\mathcal {A}} ^ {\\text {G a m e} _ {1}} (\\lambda) + \\operatorname {A d v} _ {\\mathcal {B} _ {1}} ^ {\\text {u n i t y}} (\\lambda).</span></div>

    <p class="text-gray-300">Now define <span class="math">\\mathsf{Game}_2</span>, which is identical to <span class="math">\\mathsf{Game}_1</span>, but after the (algebraic) adversary <span class="math">\\mathcal{A}</span> outputs <span class="math">\\mathsf{cm}</span> the game <span class="math">\\mathsf{Game}_2</span> extracts <span class="math">v</span> and <span class="math">r</span> such that <span class="math">\\mathsf{cm} = [v + \\mathsf{hr}]_1</span>. If this extraction fails, meaning that <span class="math">\\mathsf{cm}</span> is not correctly formed, then <span class="math">\\mathsf{Game}_2</span> aborts. We note that the <span class="math">\\mathcal{A}</span>'s advantage in <span class="math">\\mathsf{Game}_1</span> is identical to its advantage in <span class="math">\\mathsf{Game}_2</span>, unless it manages to break the knowledge soundness of <span class="math">R_{\\mathsf{ped}}</span>. Given <span class="math">\\mathcal{A}</span>, we can construct a reduction <span class="math">\\mathcal{B}_2</span> against the knowledge soundness of <span class="math">R_{\\mathsf{ped}}</span> analogously to the reduction above and let the advantage of this adversary be <span class="math">\\mathsf{Adv}_{\\mathcal{B}_2}^{\\mathsf{ped}}</span>. We observe that</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {A d v} _ {\\mathcal {A}} ^ {\\text {G a m e} _ {1}} (\\lambda) \\leq \\operatorname {A d v} _ {\\mathcal {A}} ^ {\\text {G a m e} _ {2}} (\\lambda) + \\operatorname {A d v} _ {\\mathcal {B} _ {2}} ^ {\\text {p e d}} (\\lambda).</span></div>

    <p class="text-gray-300">Recall that any adversary who successfully wins <span class="math">\\mathsf{Game}_2</span> must output a proof that satisfies the following equation from the verification procedure</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} C (x) - v - \\mathrm {h} r = T (x) z (x) + \\mathrm {h} S (x) \\Leftrightarrow \\\\ C (x) - v = T (x) a \\left(x - \\omega^ {i}\\right) + \\mathrm {h} (r + S (x)), \\\\ \\end{array}</span></div>

    <p class="text-gray-300">while at the same time it must hold that</p>

    <p class="text-gray-300"><span class="math">C(X)-v\\neq(X-\\omega^{i})aT(X)</span></p>

    <p class="text-gray-300">for any polynomial <span class="math">aT(X)</span>, since <span class="math">v</span> is not in the committed vector <span class="math">\\vec{c}</span>. Intuitively, the adversary cannot satisfy this equation, since <span class="math">\\mathsf{h}</span> is unknown to the prover and thus <span class="math">(r+S(X))</span> is chosen independently of <span class="math">\\mathsf{h}</span>. More formally, we consider two cases here. If</p>

    <p class="text-gray-300"><span class="math">C(x)-v\\neq T(x)a(x-\\omega^{i})</span></p>

    <p class="text-gray-300">then we can construct a reduction <span class="math">\\mathcal{B}_{3}</span> breaking the discrete logarithm problem. Else if</p>

    <p class="text-gray-300"><span class="math">C(x)-v=T(x)a(x-\\omega^{i})</span></p>

    <p class="text-gray-300">then we can construct a reduction <span class="math">\\mathcal{B}_{4}</span> breaking the <span class="math">q</span>SDH problem.</p>

    <p class="text-gray-300">The reduction <span class="math">\\mathcal{B}_{3}</span> takes as input a challenge <span class="math">[y]_{1}</span>. It runs the adversary <span class="math">\\mathcal{A}</span> against <span class="math">\\mathsf{Game}_{2}</span> over an <span class="math">\\mathsf{srs}</span> in which <span class="math">[\\mathsf{h}]_{1}=[y]_{1}</span> and <span class="math">\\mathcal{B}_{3}</span>’s choice of <span class="math">x</span> (where <span class="math">x</span> is the trapdoor information of the KZG commitment). Whenever the adversary returns an output <span class="math">([z]_{2}=[z(x)]_{2},[T]_{1}=[T(x)]_{1},[S]_{2}=[S(x)]_{2},\\pi_{\\mathsf{ped}},\\pi_{\\mathsf{unity}})</span> which wins the <span class="math">\\mathsf{Game}_{2}</span> game, then <span class="math">\\mathcal{B}_{3}</span> returns</p>

    <p class="text-gray-300"><span class="math">\\mathsf{h}=\\frac{C(x)-v-T(x)z(x)}{r+S(x)},</span></p>

    <p class="text-gray-300">where <span class="math">T(X),r</span> and <span class="math">S(X)</span> are extracted from the outputs of <span class="math">\\mathcal{A}</span>. The reduction’s success probability is exactly the success probability of the adversary conditioned on <span class="math">(r+S(x))\\neq 0</span>.</p>

    <p class="text-gray-300">The reduction <span class="math">\\mathcal{B}_{4}</span> takes as input the challenge <span class="math">[y_{1}]_{1},\\ldots,[y_{q}]_{1}</span>. It runs the following reduction <span class="math">\\mathcal{B}_{4}</span> as a subroutine. The <span class="math">\\mathcal{B}_{\\mathsf{KZG}}</span> runs the adversary <span class="math">\\mathcal{A}</span> against <span class="math">\\mathsf{Game}_{2}</span> over an <span class="math">\\mathsf{srs}</span> in which <span class="math">[x]_{1}=[y_{1}]_{1}</span> and <span class="math">\\mathcal{B}_{\\mathsf{KZG}}</span> ’s choice of <span class="math">\\mathsf{h}</span>. Whenever the adversary returns an output <span class="math">([z]_{2}=[z(x)]_{2},[T]_{1}=[T(x)]_{1},[S]_{2}=[S(x)]_{2},\\pi_{\\mathsf{ped}},\\pi_{\\mathsf{unity}})</span> which wins the <span class="math">\\mathsf{Game}_{2}</span> game, then <span class="math">\\mathcal{B}_{\\mathsf{KZG}}</span> returns the KZG openings</p>

    <p class="text-gray-300"><span class="math">(v,[a^{-1}T]_{1})\\text{ and }(C(\\omega^{i}),[\\frac{C(x)-C(\\omega^{i})}{x-\\omega^{i}}]_{1})</span></p>

    <p class="text-gray-300">for <span class="math">v\\neq C(x)</span>. Then <span class="math">\\mathcal{B}_{4}</span> can extract a <span class="math">q</span>SDH solution from these openings following the proof in Theorem 1 of <em>[22]</em>.</p>

    <p class="text-gray-300">We can thus conclude that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}_{\\mathcal{A}}^{\\mathsf{linkability}}(\\lambda)\\leq\\mathsf{Adv}_{\\mathcal{B}_{1}}^{\\mathsf{unity}}(\\lambda)+\\mathsf{Adv}_{\\mathcal{B}_{2}}^{\\mathsf{ped}}(\\lambda)+\\mathsf{Adv}_{\\mathcal{B}_{3}}^{\\mathsf{dlog}}(\\lambda)+\\mathsf{Adv}_{\\mathcal{B}_{4}}^{\\mathsf{qSDH}}(\\lambda).</span></p>

    <p class="text-gray-300">Lastly, we prove the position hiding property of our construction. We define a simulator <span class="math">\\mathsf{Simulate}</span> that has access to the trapdoor <span class="math">x</span> of <span class="math">\\mathsf{srs}</span> that is indistinguishable from an honest prover. First, <span class="math">\\mathsf{Simulate}</span> calls the simulators of <span class="math">R_{\\mathsf{ped}}</span> and <span class="math">R_{\\mathsf{unity}}</span> on input the trapdoor <span class="math">x</span>, and gets simulated proofs <span class="math">\\pi_{\\mathsf{ped}}^{\\prime}</span> and <span class="math">\\pi_{\\mathsf{unity}}^{\\prime}</span>. Then, it samples <span class="math">a,r,s\\leftarrow\\mathbb{F}</span> and sets <span class="math">[z^{\\prime}]_{2}=[a]_{2}</span>, <span class="math">[S^{\\prime}]_{2}=[s]_{2}</span>, <span class="math">[T^{\\prime}]_{1}=(\\mathsf{C}\\cdot\\mathsf{cm}^{-1}-[\\mathsf{h}s]_{1})/a</span>, and outputs <span class="math">([z^{\\prime}]_{2},[T^{\\prime}]_{1},[S^{\\prime}]_{2},\\pi_{\\mathsf{ped}}^{\\prime},\\pi_{\\mathsf{unity}}^{\\prime})</span>. Note that honestly generated <span class="math">[z]_{2},[S]_{2}</span> are randomized by <span class="math">a</span> and <span class="math">s</span>, respectively, and thus indistinguishable from <span class="math">[z^{\\prime}]_{2},[S^{\\prime}]_{2}</span>. Finally, <span class="math">[T^{\\prime}]_{1}</span> is the only element satisfying the verifying equation for given <span class="math">[z^{\\prime}]_{2},[S^{\\prime}]_{2}</span> and thus indistinguishable from honest <span class="math">[T]_{1}</span> as well, which concludes the proof. ∎</p>

    <h2 id="sec-56" class="text-2xl font-bold">Appendix C Proof of Lemma1</h2>

    <h6 id="sec-57" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Because <span class="math">z(X)</span> has degree 1, there exist <span class="math">a,b\\in\\mathbb{F}</span> such that <span class="math">z(X)=aX-b</span>.</p>

    <p class="text-gray-300">From the first condition, we have <span class="math">f(1)=a(1)=a-b</span>, and <span class="math">f(\\sigma)=a(\\sigma)=a\\sigma-b</span>. From items 2 and 3,</p>

    <p class="text-gray-300"><span class="math">f(\\sigma^{2})=\\frac{f(1)-f(\\sigma)}{1-\\sigma}=\\frac{a-a\\sigma}{1-\\sigma}=a,</span> <span class="math">f(\\sigma^{3})=\\sigma f(\\sigma^{2})-f(\\sigma)=\\sigma a-a\\sigma+b=b</span></p>

    <p class="text-gray-300">By substituting <span class="math">f(\\sigma^{2})=a</span> and <span class="math">f(\\sigma^{3})=b</span> into condition 4 we see that <span class="math">f(\\sigma^{4})=\\frac{a}{b}</span>. Therefore, from item 5 we have that for every <span class="math">i=0,\\ldots,\\log(N)-1</span>, <span class="math">f(\\sigma^{4+i+1})=f(\\sigma^{4+i})^{2}=\\left(\\frac{a}{b}\\right)^{2^{i+1}}</span>. In particular, <span class="math">f(\\sigma^{4+(\\log(N)-1)+1})=\\left(\\frac{a}{b}\\right)^{2^{\\log(N)}}=\\left(\\frac{a}{b}\\right)^{N}</span>, that equals 1 by the 5th condition, proves that <span class="math">\\frac{a}{b}</span> is a <span class="math">N</span>th root of unity as required.</p>

    <p class="text-gray-300">∎</p>

    <h2 id="sec-58" class="text-2xl font-bold">Appendix</h2>

    <p class="text-gray-300">D Proof of Thm. 2</p>

    <h6 id="sec-59" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We proceed through a series of games to show that the protocol defined in Fig. 3 satisfies knowledge soundness. We set <span class="math">\\mathsf{Game}_{0}</span> to be the soundness game as in Def. A.1 and consider an algebraic adversary <span class="math">\\mathcal{A}</span> against it which has advantage <span class="math">\\mathsf{Adv}_{\\mathcal{A}}^{\\mathsf{k-sound}}</span>. We define <span class="math">\\mathsf{Game}_{1}</span>, <span class="math">\\mathsf{Game}_{2}</span> and specify reductions <span class="math">\\mathcal{B}_{1}</span> and <span class="math">\\mathcal{B}_{2}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}_{\\mathcal{A}}^{\\mathsf{k-sound}}(\\lambda)</span> <span class="math">=\\mathsf{Adv}_{\\mathcal{A}}^{\\mathsf{Game}_{0}}(\\lambda)\\leq\\mathsf{Adv}_{\\mathcal{A}}^{\\mathsf{Game}_{1}}(\\lambda)+\\mathsf{Adv}_{\\mathcal{B}_{1}}^{\\mathsf{qSDH}}(\\lambda)</span> <span class="math">\\leq\\mathsf{Adv}_{\\mathcal{A}}^{\\mathsf{Game}_{2}}(\\lambda)+\\mathsf{Adv}_{\\mathcal{B}_{2}}^{\\mathsf{qDHE}}(\\lambda)+\\mathsf{Adv}_{\\mathcal{B}_{1}}^{\\mathsf{qSDH}}(\\lambda)</span> <span class="math">\\leq\\mathsf{Adv}_{\\mathcal{B}_{1}}^{\\mathsf{qSDH}}(\\lambda)+\\mathsf{Adv}_{\\mathcal{B}_{2}}^{\\mathsf{qDHE}}(\\lambda)+\\mathsf{negl}(\\lambda).</span></p>

    <p class="text-gray-300">In <span class="math">\\mathsf{Game}_{0}</span> the adversary will return <span class="math">[z]_{2}</span> along with a proof <span class="math">([F]_{1}=[f(x)]_{1},[H]_{2}=[h(x)],v_{1},v_{2},\\pi_{1},\\pi_{2})</span>. We also consider <span class="math">\\hat{p}(X)</span>, the algebraic representation of <span class="math">[P]_{1}</span> as constructed by the verifier. Note that <span class="math">\\pi_{2}</span> is KZG opening proof for <span class="math">p(X)=\\hat{p}(X)-z(X)(\\rho_{1}(\\alpha)+\\rho_{2}(\\alpha)-z_{V_{n}}(\\alpha)X^{d-1})</span> opening to <span class="math">0</span> at <span class="math">\\alpha</span>. We define <span class="math">\\mathsf{Game}_{1}</span> identically to knowledge soundness, but after the adversary returns <span class="math">[z]_{2}</span> along with the proof, <span class="math">\\mathsf{Game}_{2}</span> additionally checks whether <span class="math">f(\\alpha_{1})=v_{1}</span>, <span class="math">f(\\alpha_{2})=v_{2}</span>, <span class="math">p(\\alpha)=0</span> and aborts otherwise. Note that <span class="math">\\mathsf{Game}_{1}</span> can extract <span class="math">f(X)</span>, <span class="math">h(x)</span> because the adversary <span class="math">\\mathcal{A}</span> is algebraic, and <span class="math">p(X)</span> is constructed from them.</p>

    <p class="text-gray-300">We show the probability that <span class="math">f(\\alpha_{1})=v_{1}</span>, <span class="math">f(\\alpha_{2})=v_{2}</span>, <span class="math">p(\\alpha)=0</span> is bounded by <span class="math">q</span>SDH. We construct a reduction <span class="math">\\mathcal{B}_{1}</span> that takes as input a challenge <span class="math">[y]_{1},\\ldots,[y_{q}]_{1}</span>. It runs the following reduction <span class="math">\\mathcal{B}_{\\mathsf{KZG}}</span> as a subroutine. The <span class="math">\\mathcal{B}_{\\mathsf{KZG}}</span> runs the adversary <span class="math">\\mathcal{A}</span> against <span class="math">\\mathsf{Game}_{0}</span> over an <span class="math">\\mathsf{srs}</span> in which <span class="math">[x]_{1}=[y]_{1}</span>. Whever the adversary returns an output <span class="math">([F]_{1}=[f(x)]_{1},[H]_{2}=[h(x)],v_{1},v_{2},\\pi_{1},\\pi_{2},\\pi_{3})</span> that wins the <span class="math">\\mathsf{Game}_{0}</span> but not the <span class="math">\\mathsf{Game}_{1}</span> game, then <span class="math">\\mathcal{B}_{\\mathsf{KZG}}</span> returns the KZG openings</p>

    <p class="text-gray-300"><span class="math">\\Big{(}(v_{1},[F]_{1})\\text{ and }(f(\\alpha_{1}),[\\frac{f(x)-f(\\alpha_{1})}{x-\\alpha_{1}}])\\Big{)},\\Big{(}(v_{2},[F]_{1})\\text{ and }(f(\\alpha_{2}),[\\frac{f(x)-f(\\alpha_{2})}{x-\\alpha_{2}}])\\Big{)}\\text{ or }</span> <span class="math">\\Big{(}(0,[P]_{1})\\text{ and }(p(\\alpha),[\\frac{p(x)-p(\\alpha)}{x-\\alpha}])\\Big{)}</span></p>

    <p class="text-gray-300">for either <span class="math">v_{1}\\neq f(\\alpha_{1})</span>, <span class="math">v_{2}\\neq f(\\alpha_{2})</span> or <span class="math">p(\\alpha)\\neq 0</span>. Then <span class="math">\\mathcal{B}_{1}</span> can extract a <span class="math">q</span>-SDH solution from these openings following the proof of Theorem 3 in <em>[22]</em>. Thus</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}_{\\mathcal{A}}^{\\mathsf{k-sound}}(\\lambda)=\\mathsf{Adv}_{\\mathcal{A}}^{\\mathsf{Game}_{0}}(\\lambda)\\leq\\mathsf{Adv}_{\\mathcal{A}}^{\\mathsf{Game}_{1}}(\\lambda)+\\mathsf{Adv}_{\\mathcal{B}_{1}}^{\\mathsf{qSDH}}(\\lambda).</span></p>

    <p class="text-gray-300">We define <span class="math">\\mathsf{Game}_{2}</span> as <span class="math">\\mathsf{Game}_{1}</span> except that <span class="math">\\mathsf{Game}_{2}</span> additionally checks whether <span class="math">\\deg(z)\\leq 1</span> for <span class="math">z(X)</span> being the algebraic representation of <span class="math">[z]_{2}</span>, and aborts otherwise. We show that <span class="math">\\mathcal{A}</span>’s advantage in both games is the same unless it breaks <span class="math">q</span>DHE. Indeed, assume <span class="math">\\deg(z)=2</span>, we construct an adversary <span class="math">\\mathcal{B}_{2}</span> against <span class="math">q</span>DHE. The <span class="math">\\mathcal{B}_{2}</span> takes as input the challenge <span class="math">[y_{1}]_{1},\\ldots,[y_{q}]_{1}</span> and runs <span class="math">\\mathcal{A}</span> against <span class="math">\\mathsf{Game}_{1}</span> over an <span class="math">\\mathsf{srs}</span> in which <span class="math">[x]_{1}=[y]_{1}</span>. When <span class="math">\\mathcal{A}</span> returns an output <span class="math">([F]_{1}=[f(x)]_{1},[H]_{2}=[h(x)],v_{1},v_{2},\\pi_{1},\\pi_{2})</span> that wins the <span class="math">\\mathsf{Game}_{1}</span> but not the <span class="math">\\mathsf{Game}_{2}</span> game, then <span class="math">\\mathcal{B}_{2}</span> extracts <span class="math">\\hat{p}(X)=\\sum_{s=0}^{d+1}\\hat{p}_{s}X^{s}</span> as the algebraic representation of <span class="math">[P]_{1}</span> computed by the verifier. Note that, since <span class="math">\\big{(}-\\rho_{1}(\\alpha)-\\rho_{2}(\\alpha)-z_{V_{n}}(\\alpha)X^{d-1}\\big{)}z(X)</span> does not vanish at <span class="math">X=\\alpha</span>, we have that <span class="math">\\hat{p}_{d+1}\\neq 0</span>. Then, <span class="math">\\mathcal{B}_{2}</span> sets <span class="math">\\hat{P}(X)=P(X)-\\hat{p}_{d+1}X^{d+1}</span> and outputs <span class="math">\\big{(}[P]_{1}-[\\hat{P}(x)]_{1}\\big{)}\\frac{1}{\\hat{p}_{d+1}}=[x^{d+1}]_{1}</span>, wining <span class="math">d</span>-DHE. Thus</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}_{\\mathcal{A}}^{\\mathsf{Game}_{1}}(\\lambda)=\\mathsf{Adv}_{\\mathcal{A}}^{\\mathsf{Game}_{2}}(\\lambda)+\\mathsf{Adv}_{\\mathcal{B}_{2}}^{\\mathsf{qDHE}}(\\lambda).</span></p>

    <p class="text-gray-300">Finally, let us show that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}_{\\mathcal{A}}^{\\mathsf{Game}_{2}}(\\lambda)\\leq\\mathsf{negl}(\\lambda).</span></p>

    <p class="text-gray-300">Consider <span class="math">f(X)</span>, <span class="math">h(X)</span> the algebraic representations of <span class="math">[F]_{1}</span>, <span class="math">[H]_{1}</span>. The algebraic representation of the element <span class="math">[P]_{1}</span> that the verifier constructs is</p>

    <p class="text-gray-300"><span class="math">p(X)</span> <span class="math">=-z_{V_{n}}(\\alpha)h(X)+\\big{(}\\rho_{1}(\\alpha)+\\rho_{2}(\\alpha)\\big{)}f(X)+\\rho_{3}(\\alpha)\\big{(}(1-\\sigma)f(X)+v_{1}-v_{2}\\big{)}+\\rho_{4}(\\alpha)\\big{(}f(X)+v_{2}-\\sigma v_{1}\\big{)}</span> <span class="math">+\\rho_{5}(\\alpha)\\big{(}v_{1}f(X)-v_{2}\\big{)}+\\rho_{n}(\\alpha)\\big{(}v_{1}-1\\big{)}+\\prod_{i\\not\\in[5,\\ldots,4+\\log(N)]}(\\alpha-\\sigma^{i})\\big{(}f(X)-v_{1}^{2}\\big{)}</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300">Since <span class="math">\\mathsf{Game}_2</span> checks that <span class="math">v_{1} = f(\\sigma^{-1}\\alpha), v_{2} = f(\\sigma^{-2}\\alpha)</span>, we can replace these values and see that</p>

    <p class="text-gray-300">$$ \\begin{array}{l} p (X) = - z _ {V _ {n}} (\\alpha) h (X) + \\left(\\rho_ {1} (\\alpha) + \\rho_ {2} (\\alpha)\\right) f (X) + \\rho_ {3} (\\alpha) \\left((1 - \\sigma) f (X) + f \\left(\\sigma^ {- 1} \\alpha\\right) - f \\left(\\sigma^ {- 2} \\alpha\\right)\\right) \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\rho_ {4} (\\alpha) (f (X) + f (\\sigma^ {- 2} \\alpha) - \\sigma f (\\sigma^ {- 1} \\alpha)) + \\rho_ {5} (\\alpha) (f (\\sigma^ {- 1} \\alpha) f (X) - f (\\sigma^ {- 2} \\alpha)) \\\\</li>

      <li>\\rho_ {n} (\\alpha) (f (\\sigma^ {- 1} \\alpha) - 1) + \\prod_ {i \\notin [ 5, \\dots , 4 + \\log (N) ]} (\\alpha - \\sigma^ {i}) (f (X) - f (\\sigma^ {- 1} \\alpha) ^ {2})</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">Now, because <span class="math">p(\\alpha) = 0</span> and <span class="math">\\alpha</span> has been chosen by the verifier after the prover has sent <span class="math">[H]_1, [F]_1</span>, except in the negligible case that <span class="math">\\alpha</span> is a root of <span class="math">p(X)</span>, we have that <span class="math">p(X) \\equiv 0</span>, i.e,</p>

    <p class="text-gray-300">$$ \\begin{array}{l} z _ {V _ {n}} (X) h (X) = - \\left(\\rho_ {1} (X) + \\rho_ {2} (X)\\right) f (X) + \\rho_ {3} (X) \\left((1 - \\sigma) f (X) + f \\left(\\sigma^ {- 1} X\\right) - f \\left(\\sigma^ {- 2} X\\right)\\right) \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\rho_ {4} (X) (f (X) + f (\\sigma^ {- 2} X) - \\sigma f (\\sigma^ {- 1} X)) + \\rho_ {5} (X) (f (\\sigma^ {- 1} X) f (X) - f (\\sigma^ {- 2} X)) \\\\</li>

      <li>\\rho_ {n} (X) (f (\\sigma^ {- 1} X) - 1) + \\prod_ {i \\notin [ 5, \\dots , 4 + \\log (N) ]} (X - \\sigma^ {i}) (f (X) - f (\\sigma^ {- 1} X) ^ {2})</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300"><span class="math">z_{V_n}(X)</span> divides the right side of the equation and thus, the latter vanishes for all the powers <span class="math">\\{\\sigma^i\\}_{i=0}^{n-1}</span>. This implies that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">f(1) = a(1), f(\\sigma) = a(\\sigma)</span></li>

      <li><span class="math">f(\\sigma^2) = \\frac{v_2 - v_1}{1 - \\sigma} = \\frac{f(\\sigma^2\\sigma^{-2}) - f(\\sigma^2\\sigma^{-1})}{1 - \\sigma} = \\frac{f(1) - f(\\sigma)}{1 - \\sigma}</span></li>

      <li><span class="math">f(\\sigma^3) = r f(\\sigma^3 \\sigma^{-1}) - f(\\sigma^3 \\sigma^{-2}) = r f(\\sigma^2) - f(\\sigma)</span></li>

      <li><span class="math">f(\\sigma^4) f(\\sigma^4 \\sigma^{-1}) = f(\\sigma^4 \\sigma^{-2})</span>, i.e., <span class="math">f(\\sigma^4) f(\\sigma^3) = f(\\sigma^2)</span></li>

      <li><span class="math">1 = f(\\sigma^{5 + \\log (N)}\\sigma^{-1}) = f(\\sigma^{4 + \\log (N)})</span></li>

      <li><span class="math">\\left(f(\\sigma^{4 + i + 1}) - f(\\sigma^{4 + i + 1}\\sigma^{-1})f(\\sigma^{4 + i + 1}\\sigma^{-1})\\right)(\\sigma^i -\\sigma^{5 + \\log (N)})\\prod_{j = 1}^{5}(\\sigma^j -\\sigma^j) = 0</span> for all <span class="math">i = 0,\\ldots ,\\log (N) - 1</span>. Note that <span class="math">\\prod_{j\\notin [5,\\dots,4 + \\log (N)]} (\\sigma^j -\\sigma^j) \\neq 0</span> implies that <span class="math">0 = f(\\sigma^{4 + i + 1}) - f(\\sigma^{4 + i + 1}\\sigma^{-1})f(\\sigma^{4 + i + 1}\\sigma^{-1}) = f(\\sigma^{4 + i + 1}) - f(\\sigma^{4 + i})^2.</span></li>

    </ul>

    <p class="text-gray-300">By Lemma 1 we have that <span class="math">z(X) = aX - b</span> where <span class="math">\\frac{a}{b}</span> is an <span class="math">N</span>-th root of unity.</p>

    <p class="text-gray-300">For zero-knowledge, we define a simulator Simulate that has access to the trapdoor of srs and is indistinguishable from an honest prover. The simulator first chooses <span class="math">s_1, s_2, v_1, v_2</span> uniformly at random and sets <span class="math">[F]_1 = [s_1]_1</span> and <span class="math">[H]_1 = [s_2]_1</span>. It computes <span class="math">\\alpha_1 = \\sigma^{-1}\\alpha</span>, <span class="math">\\alpha_2 = \\sigma^{-2}\\alpha</span>. It then computes <span class="math">[w_1]_1 = ([F]_1 - v_1\\tau_1(x) - v_2\\tau_2(x)]\\frac{1}{(x - \\alpha_1)(x - \\alpha_2)}</span>, for <span class="math">\\tau_1(x) = \\frac{x - \\alpha_2}{\\alpha_1 - \\alpha_2}</span>, <span class="math">\\tau_2(x) = \\frac{x - \\alpha_1}{\\alpha_2 - \\alpha_1}</span>.</p>

    <p class="text-gray-300">It sets <span class="math">[P]_1</span> the same as the verifier i.e.</p>

    <p class="text-gray-300">$$ \\begin{array}{l} [ P ] _ {1} = - [ H ] _ {1} z _ {V _ {n}} (\\alpha) + [ F ] _ {1} \\left(\\rho_ {1} (\\alpha) + \\rho_ {2} (\\alpha)\\right) + \\left([ F ] _ {1} (1 - \\sigma) - v _ {2} + v _ {1}\\right) \\rho_ {3} (\\alpha) + \\left([ F ] _ {1} + v _ {2} - \\sigma v _ {1}\\right) \\rho_ {4} (\\alpha) \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\left([ F ] _ {1} v _ {1} - v _ {2}\\right) \\rho_ {5} (\\alpha) + \\left(v _ {1} - 1\\right) \\rho_ {n} (\\alpha) + \\left([ F ] _ {1} - v _ {1} ^ {2}\\right) \\prod_ {i \\notin [ 5, \\dots , 4 + \\log (N) ]} (\\alpha - \\sigma^ {i})</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">and then computes <span class="math">[w_2]_1 = ([P]_1 - (\\rho_n(\\alpha) + \\rho_1(\\alpha) + z_{V_n}(\\alpha)x^{d-1})z)\\frac{1}{x - \\alpha}</span>, where <span class="math">z = a</span> is the output of the simulator in the proof of Theorem 1. It returns <span class="math">([F]_1, [H]_1, v_1, v_2, \\pi_1 = [w_1]_1, \\pi_2 = [w_2]_2)</span>.</p>

    <p class="text-gray-300">We must argue that the simulators output is distributed identically to the honest provers. Then the provers components are randomised by</p>

    <div class="my-4 text-center"><span class="math-block">F: \\quad r _ {0} \\rho_ {5 + \\log (N)} (x) \\quad H: \\quad r (x)</span></div>

    <div class="my-4 text-center"><span class="math-block">v _ {1}: \\quad r (\\sigma^ {- 1} \\alpha) z _ {V _ {n}} (\\alpha) \\quad v _ {2}: \\quad r (\\sigma^ {- 2} \\alpha) z _ {V _ {n}} (\\alpha)</span></div>

    <p class="text-gray-300">and the elements <span class="math">[w]_1, [w]_2</span> are the unique elements satisfying the verifies equations given <span class="math">[F]_1, [H]_1, v_1, v_2</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The probability that the values <span class="math">r_{1}\\rho_{6+\\log(N)}(x)</span>, <span class="math">r(x)</span>, <span class="math">r(\\sigma^{-1}\\alpha)z_{V_{\\alpha}}(\\alpha)</span>, <span class="math">r(\\sigma^{-2}\\alpha)z_{V_{\\alpha}}(\\alpha)</span> are dependent for random <span class="math">\\alpha</span> is negligible because <span class="math">r(X)</span> is a random degree 2 polynomial and the probability that <span class="math">\\sigma^{-1}\\alpha=x</span> or <span class="math">\\sigma^{-2}\\alpha=x</span> is $\\frac{2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. Where the simulators terms </span>[F]_{1},[H]_{1},v_{1},v_{2}<span class="math"> are chosen uniformly at random and </span>[w_{1}]_{1},[w_{2}]_{1}$ are the unique terms that satisfy the verifies equations, we have that these distributions are identical except with negligible probability. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-60" class="text-2xl font-bold">Appendix E Proof of Thm. 3</h2>

    <h6 id="sec-61" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We will proceed through a series of games to show that the protocol defined in Fig. 4 satisfies linkability as defined in Def. 5.1. Let <span class="math">\\mathcal{A}</span> be an arbitrary PPT adversary in the linkability game with advantage <span class="math">\\mathsf{Adv}_{\\mathcal{A}}^{\\mathsf{linkability}}(\\lambda)</span>. We define <span class="math">\\mathsf{Game}_{1}</span>, <span class="math">\\mathsf{Game}_{2}</span> and specify reductions <span class="math">\\mathcal{B}_{1}</span> and <span class="math">\\mathcal{B}_{2}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}_{\\mathcal{A}}^{\\mathsf{linkability}}(\\lambda)\\leq\\mathsf{Adv}_{\\mathcal{B}_{1}}^{\\mathsf{qSDH}}(\\lambda)+\\mathsf{Adv}_{\\mathcal{B}_{2}}^{\\mathsf{k-sound}}(\\lambda)+\\mathsf{negl}(\\lambda)</span></p>

    <p class="text-gray-300">Let us transition from the linkability game for the protocol of Fig. 4 to a game <span class="math">\\mathsf{Game}_{1}</span>. <span class="math">\\mathsf{Game}_{1}</span> behaves as linkability except that when <span class="math">\\mathcal{A}</span> returns <span class="math">v_{1},v_{2}</span>, <span class="math">\\mathsf{Game}_{1}</span> checks whether <span class="math">u(\\alpha)=v_{1}</span>, <span class="math">p_{1}(v_{1})=v_{2}</span>, and <span class="math">p_{2}(\\alpha)=0</span>, for <span class="math">u(X),p_{1}(X),p_{2}(X)</span>, the algebraic representations of <span class="math">[u]_{1},[P_{1}]_{1}=[z_{I}]_{1}+\\chi[C_{I}]_{1}</span>, and <span class="math">[P_{2}]_{1}=v_{2}-\\chi\\mathsf{cm}-z_{V_{\\alpha_{i}}}(\\alpha)[H_{2}]_{1}</span>. If not then <span class="math">\\mathsf{Game}_{1}</span> aborts. We design <span class="math">\\mathcal{B}_{1}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}_{\\mathcal{A}}^{\\mathsf{linkability}}(\\lambda)\\leq\\mathsf{Adv}_{\\mathcal{A}}^{\\mathsf{Game}_{1}}(\\lambda)+\\mathsf{Adv}_{\\mathcal{B}_{1}}^{\\mathsf{qSDH}}(\\lambda)</span></p>

    <p class="text-gray-300">Indeed, assume that <span class="math">\\mathcal{A}</span> succeeds against linkability but not <span class="math">\\mathsf{Game}_{1}</span>. Then this corresponds to the case where <span class="math">\\mathcal{A}</span> returns verifying <span class="math">v_{1}</span>, <span class="math">v_{2}</span>, <span class="math">\\pi_{1}</span>, <span class="math">\\pi_{2}</span>, <span class="math">\\pi_{3}</span> but the equality does not hold for some <span class="math">p(X)\\in\\{u(X),p_{1}(X),p_{2}(X)\\}</span>. Thus <span class="math">\\mathcal{B}_{1}</span> takes as input a challenge <span class="math">[y_{1}]_{1},\\ldots,[y_{q}]_{1}</span> and runs the following reduction <span class="math">\\mathcal{B}_{KZG}</span> as a subroutine. The <span class="math">\\mathcal{B}_{KZG}</span> runs the adversary <span class="math">\\mathcal{A}</span> against <span class="math">\\mathsf{Game}_{0}</span> over an <span class="math">\\mathsf{srs}</span> in which <span class="math">[x]_{1}=[y_{1}]_{1}</span>. Whenever the adversary wins the <span class="math">\\mathsf{Game}_{0}</span> but not the <span class="math">\\mathsf{Game}_{1}</span> game, then <span class="math">\\mathcal{B}_{KZG}</span> returns the KZG opening</p>

    <p class="text-gray-300"><span class="math">(v,\\pi)\\text{ and }(f(\\alpha),[(f(x)-f(\\alpha))/(x-\\alpha)]_{1})</span></p>

    <p class="text-gray-300">for <span class="math">(v,f(X))</span> corresponding to either <span class="math">(v_{1},u(X))</span>, <span class="math">(v_{2},p_{1}(X))</span>, <span class="math">(v_{3},p_{2}(X))</span> and <span class="math">\\pi</span> the corresponding proof. Then <span class="math">\\mathcal{B}_{\\mathsf{qSDH}}</span> can extract a solution from these openings following the proof in Theorem 1 in <em>[22]</em>.</p>

    <p class="text-gray-300">Now let us transition to a new game. <span class="math">\\mathsf{Game}_{2}</span> behaves identically except that when <span class="math">\\mathcal{A}</span> returns <span class="math">[u]_{1}</span>, then <span class="math">\\mathsf{Game}_{2}</span> checks whether its algebraic representation <span class="math">u(X)</span> is such that <span class="math">u(\\nu^{j})^{N}=1</span> for all <span class="math">j</span>. If not then <span class="math">\\mathsf{Game}_{2}</span> aborts. We design <span class="math">\\mathcal{B}_{2}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}_{\\mathcal{A}}^{\\mathsf{Game}_{1}}(\\lambda)\\leq\\mathsf{Adv}_{\\mathcal{A}}^{\\mathsf{Game}_{2}}(\\lambda)+\\mathsf{Adv}_{\\mathcal{B}_{2}}^{\\mathsf{k-sound}}(\\lambda)</span></p>

    <p class="text-gray-300">Assume that <span class="math">\\mathcal{A}</span> succeeds against <span class="math">\\mathsf{Game}_{1}</span> but not <span class="math">\\mathsf{Game}_{2}</span>. Then <span class="math">\\mathcal{B}_{2}</span> chooses <span class="math">[u]_{1}=[u(x)]_{1}</span> in its own game and uses it as input to run <span class="math">\\mathcal{A}</span>. When <span class="math">\\mathcal{A}</span> returns <span class="math">\\pi_{\\mathsf{unity}}</span>, <span class="math">\\mathcal{B}_{2}</span> forwards it and wins knowledge-soundness of <span class="math">\\Pi_{\\mathsf{unity}}</span> whenever <span class="math">\\mathcal{A}</span> succeeds.</p>

    <p class="text-gray-300">Next we transition to a game <span class="math">\\mathsf{Game}_{3}</span> that behaves as <span class="math">\\mathsf{Game}_{2}</span> except that when <span class="math">\\mathcal{A}</span> returns its proof, <span class="math">\\mathsf{Game}_{3}</span> checks whether <span class="math">C(X)-C_{I}(X)=z_{I}(X)H_{1}(X)</span>, for <span class="math">C(X),C_{I}(X),z_{I}(X),H_{1}(X)</span> the algebraic representations of <span class="math">[C]_{1},[C_{I}]_{1},[H_{1}]_{2},[z_{I}]_{1}</span>. If not then <span class="math">\\mathsf{Game}_{3}</span> aborts. We design <span class="math">\\mathcal{B}_{3}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}_{\\mathcal{A}}^{\\mathsf{Game}_{2}}(\\lambda)\\leq\\mathsf{Adv}_{\\mathcal{A}}^{\\mathsf{Game}_{3}}(\\lambda)+\\mathsf{Adv}_{\\mathcal{B}_{3}}^{\\mathsf{qSDH}}(\\lambda)</span></p>

    <p class="text-gray-300">The <span class="math">\\mathcal{B}_{3}</span> takes as input a challenge <span class="math">[y_{1}]_{1},\\ldots,[y_{q}]_{1}</span> and runs the adversary <span class="math">\\mathcal{A}</span> against <span class="math">\\mathsf{Game}_{2}</span> over an <span class="math">\\mathsf{srs}</span> in which <span class="math">[x]_{1}=[y_{1}]_{1}</span>. Whenever the adversary wins the <span class="math">\\mathsf{Game}_{2}</span> but not the <span class="math">\\mathsf{Game}_{3}</span> game, then <span class="math">\\mathcal{B}_{3}</span> learns</p>

    <p class="text-gray-300"><span class="math">d(X)=C(X)-C_{I}(X)-z_{I}(X)H_{1}(X)</span></p>

    <p class="text-gray-300">such that <span class="math">d(x)=0</span> and <span class="math">d(X)\\neq 0</span>. Thus <span class="math">\\mathcal{B}_{3}</span> returns <span class="math">(1,[1/(x-1)]_{1})</span> as a valid <span class="math">q</span>-SDH solution.</p>

    <p class="text-gray-300">Finally we show that the probability that <span class="math">\\mathsf{Game}_{3}</span> returns <span class="math">1</span> but that for some <span class="math">j\\in[m]</span>, and for <span class="math">\\vec{c}</span> such that <span class="math">C(X)=\\sum_{i=1}^{N}c_{i}\\lambda_{i}(X)</span>,</p>

    <p class="text-gray-300"><span class="math">\\phi(\\nu^{j})\\not\\in\\vec{c}</span></p>

    <p class="text-gray-300">is negligible.</p>

    <p class="text-gray-300">Recall that <span class="math">p_{2}(\\alpha)=v_{2}-\\chi\\mathsf{cm}-z_{V_{m}}(\\alpha)H_{2}(\\alpha)=z_{I}(v_{1})+\\chi C_{I}(v_{1})-\\chi\\mathsf{cm}-z_{V_{m}}(\\alpha)H_{2}(\\alpha)=z_{I}(u(\\alpha))+\\chi C_{I}(u(\\alpha))-\\chi\\mathsf{cm}-z_{V_{m}}(\\alpha)H_{2}(\\alpha)=0.</span> First, because <span class="math">\\alpha</span> has been sent by the verifier after the prover commits to <span class="math">\\phi(X),z_{I}(X),u(X),H_{2}(X)</span> and <span class="math">C_{I}(X)</span>, we have that</p>

    <p class="text-gray-300"><span class="math">z_{I}(u(X))+\\chi C_{I}(u(X))-\\chi\\phi(X)-z_{V_{m}}(X)H_{2}(X)=0</span></p>

    <p class="text-gray-300">for all <span class="math">X</span> except with negligible probability. Further, because <span class="math">\\chi</span> has been sent by the verifier after the prover commits, we have that there exists <span class="math">H_{2,1}(X)</span> and <span class="math">H_{2,2}(X)</span> such that</p>

    <p class="text-gray-300"><span class="math">0</span> <span class="math">=z_{I}(u(X))-z_{V_{m}}(X)H_{2,1}(X)</span> <span class="math">0</span> <span class="math">=C_{I}(u(X))-\\phi(X)-z_{V_{m}}(X)H_{2,2}(X)</span></p>

    <p class="text-gray-300">except with negligible probability.</p>

    <p class="text-gray-300">Thus,</p>

    <p class="text-gray-300"><span class="math">z_{I}(u(\\nu^{j}))=z_{I}(\\omega^{i_{j}})=0\\text{ for all }j=1,\\ldots,m.</span></p>

    <p class="text-gray-300">and <span class="math">z_{I}(X)=\\prod_{j=1}^{m}(X-\\omega^{i_{j}})\\hat{z}(X)=\\prod_{i\\in I}(X-\\omega^{i})\\hat{z}(X)</span>, for some polynomial <span class="math">\\hat{z}(X)</span>. From the second equation we also we have that</p>

    <p class="text-gray-300"><span class="math">C_{I}(u(\\nu^{j}))=\\phi(\\nu^{j})\\ \\forall\\ j\\in[m],\\text{i.e., }C_{I}(\\omega^{i_{j}})=\\phi(\\nu^{j}).</span></p>

    <p class="text-gray-300">Using</p>

    <p class="text-gray-300"><span class="math">C(u(X))-C_{I}(u(X))=z_{I}(u(X))H_{1}(u(X))</span></p>

    <p class="text-gray-300">we hence gets that</p>

    <p class="text-gray-300"><span class="math">0=C(u(\\nu^{j}))-C_{I}(u(\\nu^{j}))=C(\\omega^{k})-\\phi(\\nu^{j})</span></p>

    <p class="text-gray-300">which concludes the proof.</p>

    <p class="text-gray-300">∎</p>

    <h2 id="sec-62" class="text-2xl font-bold">Appendix F Proof of Thm. 5</h2>

    <h6 id="sec-63" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We first define a simulator Simulate and then argue that their transcript is indistinguishable from an honest provers transcript. The Simulate subverts the setup algorithm such that it knows the secret <span class="math">x</span> contained in <span class="math">[x]_{1},[x^{2}]_{1},[x^{3}]_{1},\\ldots</span>. It takes as input some instance <span class="math">(C,\\mathsf{cm})</span> and aims to generate a verifying transcript.</p>

    <p class="text-gray-300">It samples <span class="math">s_{1}</span>, <span class="math">s_{2}</span>, <span class="math">s_{3}</span>, <span class="math">s_{4}</span>, <span class="math">s_{5}</span>, <span class="math">s_{6},s_{7},s_{8}\\leftarrow\\mathbb{F}</span> at random and outputs <span class="math">[C_{I}]_{1}=[s_{1}]_{1},[z_{I}]_{1}=[s_{2}]_{1}</span>, <span class="math">[u]_{1}=[s_{3}]_{1}</span>, <span class="math">[H_{1}]_{2}=[(C-s_{1})/s_{2}]_{2}</span> and a simulated proof <span class="math">\\pi_{\\mathsf{unity}}</span> that we describe in the next paragraph. After receiving <span class="math">\\chi</span> it outputs <span class="math">[H_{2}]_{1}=[s_{4}]_{1}</span>. After receiving <span class="math">\\alpha</span> it outputs <span class="math">v_{1}=s_{5}</span>, <span class="math">v_{2}=s_{6}</span>. and</p>

    <p class="text-gray-300"><span class="math">\\pi_{1}</span> <span class="math">=[(u-v_{1})/(x-\\alpha)]_{1}</span> <span class="math">\\pi_{2}</span> <span class="math">=[(z_{I}+\\chi C_{I})/(x-v_{1})]_{1}</span> <span class="math">\\pi_{3}</span> <span class="math">=[(v_{2}-\\chi\\mathsf{cm}-z_{V_{m}}(\\alpha)H_{2})/(x-\\alpha)]</span></p>

    <p class="text-gray-300">To simulate <span class="math">\\pi_{\\mathsf{unity}}</span> the simulate Simulate outputs <span class="math">[\\bar{U}]_{1}=[s_{7}]_{1}</span>, <span class="math">[h_{2}]_{1}=[s_{8}]_{1}</span>. After receiving <span class="math">\\alpha</span> it outputs <span class="math">[h_{1}]_{1}=[s_{9}]_{1}</span>. After receiving <span class="math">\\beta</span> it outputs <span class="math">[\\bar{U}_{\\alpha}]_{1}=[s_{10}]_{1}</span>, <span class="math">[h_{2,\\alpha}]=[s_{11}]_{1}</span> and <span class="math">v_{1}=s_{12}</span>, <span class="math">v_{2}=s_{13}</span>, <span class="math">v_{3}=s_{14}</span> and</p>

    <p class="text-gray-300"><span class="math">\\pi_{1}</span> <span class="math">=[(u-v_{1})/(x-\\alpha)]_{1}</span> <span class="math">\\pi_{2}</span> <span class="math">=[(\\bar{U}+\\bar{U}_{\\alpha})/(x-\\alpha)]_{1}</span> <span class="math">\\pi_{3}</span> <span class="math">=[(h_{2}-h_{2,\\alpha})/(x-\\alpha)]_{1}</span> <span class="math">\\pi_{4}</span> <span class="math">=[x^{\\mathsf{max\\_deg}-n}(\\bar{U}_{\\alpha}+\\ell(x))/(x-1)(x-\\beta)(x-\\beta\\sigma)]_{1}</span> <span class="math">\\pi_{5}</span> <span class="math">=[x^{\\mathsf{max\\_deg}-n}((v_{1}\\rho_{1}(\\beta)+v_{2})^{2}-h_{1}z_{V_{n}}(\\beta)-(v_{3}+\\mathsf{id}(\\alpha)\\rho_{n}(\\beta))-z_{V_{m}}(\\alpha)h_{2,\\alpha})/(x-\\beta)]_{1}</span></p>

    <p class="text-gray-300">where <span class="math">\\ell(x)</span> is the polynomial that interpolates to <span class="math">(0,v_{2},v_{3})</span> at <span class="math">(1,\\beta\\beta\\sigma)</span>.</p>

    <p class="text-gray-300">We now argue Simulate’s output is indistinguishable from an honest prover’s output.</p>

    <p class="text-gray-300">We consider each of the elements in Fig. 4 separately and argue they are identically distributed with overwhelming probability.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">[C_I]_1</span> is blinded by <span class="math">r_2</span> for the prover and <span class="math">s_1</span> for the simulator.</li>

      <li><span class="math">[z_I]_1</span> is blinded by <span class="math">r_1</span> for the prover and <span class="math">s_2</span> for the simulator.</li>

      <li><span class="math">[u]_1</span> is blinded by <span class="math">r_5</span> for the prover and <span class="math">s_3</span> for the simulator.</li>

      <li><span class="math">[H_1]_2</span> is the unique element satisfied by the pairing check for both the prover and simulator given <span class="math">[C_I]_1</span> and <span class="math">[z_I]_1</span>.</li>

      <li><span class="math">[H_2]_1</span> is blinded by <span class="math">r_3</span> for the prover and <span class="math">s_4</span> for the simulator. Note that <span class="math">r_3 \\frac{\\chi u(x) z_I(u(x))}{z_{V_m(x)}}</span> is non-zero with overwhelming probability.</li>

      <li><span class="math">v_1</span> is blinded by <span class="math">r_6</span> for the prover and <span class="math">s_5</span> for the simulator. Note that <span class="math">r_6 \\alpha z_{V_m}(\\alpha)</span> is non-zero with overwhelming probability.</li>

      <li><span class="math">v_2</span> is blinded by <span class="math">r_4</span> for the prover and <span class="math">s_6</span> for the simulator. Note that <span class="math">r_4 u^2 \\alpha z_I(u(\\alpha))</span> is non-zero with overwhelming probability.</li>

      <li><span class="math">\\pi_1, \\pi_2, \\pi_3</span> are the unique element satisfied by the KZG opening checks for both the prover and the simulator.</li>

    </ul>

    <p class="text-gray-300">Finally we consider each of the elements in Fig. 5 separately and argue they are identically distributed with overwhelming probability.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">[\\bar{U}]_1</span> is blinded by <span class="math">t_1</span> for the prover and <span class="math">s_7</span> for the simulator.</li>

      <li><span class="math">[h_2]_1</span> is blinded by <span class="math">t_2</span> for the prover and <span class="math">s_8</span> for the simulator. Note that there exists a <span class="math">\\rho_2(x)t_2</span> term in the provers <span class="math">[h_2]_1</span> which is linearly independent from all other terms and thus not cancelled with overwhelming probability.</li>

      <li><span class="math">[h_1]_1</span> is blinded by <span class="math">t_3</span> for the prover and <span class="math">s_9</span> for the simulator. Note that there is a <span class="math">t_3^2 z_{V_m}^2 (\\alpha) \\frac{\\rho_2^2(x) - \\rho_4(x)}{z_{V_n}(x)}</span> term in the provers <span class="math">[h_1]_1</span> which is linearly independent from all other terms.</li>

      <li><span class="math">[\\bar{U}_\\alpha]_1</span> is blinded by <span class="math">t_4</span> for the prover and <span class="math">s_{10}</span> for the simulator. Note that there is a <span class="math">t_4 z_{V_m}(\\alpha) \\rho_5(x)</span> term in the provers <span class="math">[\\bar{U}_\\alpha]_1</span> which is linearly independent from all other terms.</li>

      <li><span class="math">[h_{2,\\alpha}]_1</span> is blinded by <span class="math">t_5</span> for the prover and <span class="math">s_{11}</span> for the simulator. Note that there is a <span class="math">\\rho_2(x)t_2</span> term in the provers <span class="math">[h_{2,\\alpha}]_1</span> which is linearly independent from all other terms.</li>

      <li><span class="math">v_1</span> is blinded by <span class="math">r_7</span> for the prover and <span class="math">s_{12}</span> for the simulator.</li>

      <li><span class="math">v_2</span> is blinded by <span class="math">t_5</span> for the prover and <span class="math">s_{13}</span> for the simulator. Note that there is a <span class="math">t_5 z_{V_m}(\\alpha) \\rho_6(\\beta)</span> term in the provers <span class="math">v_2</span> which is linearly independent from all other terms.</li>

      <li><span class="math">v_3</span> is blinded by <span class="math">t_6</span> for the prover and <span class="math">s_{14}</span> for the simulator. Note that there is a <span class="math">t_6 z_{V_m}(\\alpha) \\rho_7(\\beta)</span> term in the provers <span class="math">v_3</span> which is linearly independent from all other terms.</li>

      <li><span class="math">\\pi_1, \\pi_2, \\pi_3, \\pi_4, \\pi_5</span> are the unique elements satisfied by the KZG opening checks for both the prover and the simulator.</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300">36</p>`;
---

<BaseLayout title="Caulk: Lookup Arguments in Sublinear Time (2022/621)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2022 &middot; eprint 2022/621
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
