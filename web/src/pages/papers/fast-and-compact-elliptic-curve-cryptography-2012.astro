---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2012/309';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Fast and compact elliptic-curve cryptography';
const AUTHORS_HTML = 'Mike Hamburg';

const CONTENT = `    <p class="text-gray-300">Fast and compact elliptic-curve cryptography</p>

    <p class="text-gray-300">Mike Hamburg</p>

    <h6 id="sec-1" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Elliptic curve cryptosystems have improved greatly in speed over the past few years. In this paper we outline a new elliptic curve signature and key agreement implementation. We achieve record speeds for signatures while remaining relatively compact. For example, on Intel Sandy Bridge, a curve with about <span class="math">2^{250}</span> points produces a signature in just under 60k clock cycles, verifies in under 169k clock cycles, and computes a Diffie-Hellman shared secret in under 153k clock cycles. Our implementation has a small footprint: the library is under 55kB. We also post competitive timings on ARM processors, verifying a signature in under 618k Tegra-2 cycles. We introduce faster field arithmetic, a new point compression algorithm, an improved fixed-base scalar multiplication algorithm and a new way to verify signatures without inversions or coordinate recovery. Some of these improvements should be applicable to other systems.</p>

    <h2 id="sec-2" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Of the many applications for digital signatures, most use some variant of the venerable RSA scheme. RSA signatures have several advantages, such as age, simplicity and extreme speed of verification. For example, NIST’s recommendations <em>[2]</em> hold RSA-2048 and the elliptic curve signature scheme ECDSA-<span class="math">p_{224}</span> to be similarly secure, and the former verifies signatures more than 13<span class="math">\\times</span> faster than the latter <em>[7]</em>.</p>

    <p class="text-gray-300">Elliptic curve signatures have many advantages, however. Current attacks against elliptic curves scale exponentially with key size. Therefore ECC key and signatures can be considerably smaller than their RSA counterparts, and key generation and signing are much faster. Still, elliptic curve signatures’ historically slow verification has kept these signatures out of protocols such as DNSSEC (though a draft is in progress <em>[20]</em>), and still makes them a difficult choice for less powerful systems such as embedded devices and smart phones.</p>

    <p class="text-gray-300">*Cryptography Research, a division of Rambus.</p>

    <p class="text-gray-300">^{1} Eurocrypt's report [1] estimates ECDSA- p_{224} to be slightly stronger than RSA-2048.</p>

    <p class="text-gray-300">This performance gap has narrowed in recent years. Edwards’ elliptic curves <em>[11]</em> and their twists provide faster operations <em>[5, 18, 19]</em> than the traditional projective or Jacobian coordinates for Weierstrass curves, and make it easier to achieve resistance to side-channel attacks. Bernstein et al.’s Ed25519 software <em>[6]</em>, which uses these curves, verifies signatures in some 234k cyles on Intel’s Sandy Bridge microarchitecture. While RSA-2048 is still considerably faster at approximately 98k (even in the conservative OpenSSL implementation), this is a significant improvement over ECDSA <em>[7]</em>.</p>

    <p class="text-gray-300">Here we continue to push the envelope. We demonstrate improved field arithmetic and improved algorithms for scalar multiplication and point compression. These enable us to achieve approximately 172k median Sandy Bridge cycles for verification, 52k for signing and 55k for key generation. These benchmarks were measured with SUPERCOP <em>[7]</em> and adjusted for Turbo Boost, so they should be reproducible.</p>

    <p class="text-gray-300">Our code is not optimized purely for speed. Rather, it is designed to balance speed with security, simplicity, portability and small cache footprint. For example, we decided to use only 7.5kiB of tables for key generation and signing (compare to 30kiB in <em>[6]</em>). We believe the above speeds are fast enough that additional cache pollution would not be worth the modest speed increase in most applications. We also provide standard protection against timing and cache-leakage attacks, by avoiding the use of secret data in conditional branches and array indices. These countermeasures are not necessary for verification since it uses no secrets, but we used the same constant-time arithmetic for simplicity. We made no attempt to protect against physical side-channels such as SPA and DPA.</p>

    <p class="text-gray-300">Fast Sandy Bridge benchmarks are somewhat unsatisfying. We set new records for signing and verification, but the reduction in verification times from 73µs to 53µs will be irrelevant most of the time. However, asymmetric cryptography is somewhat more costly on smartphones, with OpenSSL ECC verifies taking 7.7ms on our 1GHz Tegra 2 (ARM Cortex A9) test machine. On this platform, our implementation also does well. For example, it verifies signatures in under 618k cycles, that is, well under a millisecond. Our ARM code does not currently take advantage of ARM’s NEON vector instructions; indeed, our Tegra 2 test machine does not support NEON. Still, our ARM code’s performance is similar to Bernstein and Schwabe’s NEON results <em>[8]</em>: slower for key agreement, faster for verification, and much faster for signing. This is not an apples-to-apples comparison: our A9 lacks NEON, but its support out-of-order execution improves the performance of our code. Still, the implication is clear: even where our arithmetic code is slower than the state of the art, our algorithmic improvements enable us to set new records.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.1 Overview</h3>

    <p class="text-gray-300">The rest of this paper is organized as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In Section 2.1, we demonstrate a previously unrecognized class of primes which allow for particularly fast arithmetic. The arithmetic in our system is done modulo such a prime.</li>

      <li>In Section 2.2, we describe the Montgomery curve and equivalent twisted Edwards curves which will be used in our system. These curves were chosen to have security properties similar to Curve25519 <em>[3]</em>. Our system uses <span class="math">q</span>-torsion points on these curves.</li>

      <li>In Section 2.3, we describe how <span class="math">q</span>-torsion points are encoded and decoded as field elements, without any extra bits. In order to encode and decode elements efficiently, we use a simple simultaneous inversion and square root algorithm, which is to our knowledge novel.</li>

      <li>In Section 3.1, we describe our signatures, which are modeled on Ed25519 <em>[6]</em> and are similar to Schnorr signatures <em>[23]</em>.</li>

      <li>In Section 3.2, we describe the “extensible” coordinates we use for twisted Edwards curves. These are a variant of Hışıl’s “mixed homogeneous projective coordinates” <em>[18]</em> with Niels coordinates <em>[6]</em> for readdition. Our coordinates combine many of the strengths of projective coordinates and extended coordinates, without Hışıl’s requirement to schedule doublings and additions in advance.</li>

      <li>In Section 3.3, we describe how we sign messages. We introduce a new “multiple signed comb” algorithm which is simpler, more flexible and more efficient than previous algorithms for scalar multiplication with precomputation.</li>

      <li>In Section 3.4, we describe how to verify signatures.</li>

      <li>In Section 4, we describe how we implement elliptic-curve Diffie-Hellman with Montgomery curves, including a technique for coordinate recovery after a Montgomery ladder.</li>

      <li>In Section 5, we show benchmarks on Intel Sandy Bridge and Nvidia Tegra-2 processors. These benchmarks were taken with SUPERCOP <em>[7]</em>, so they should be reproducible.</li>

      <li>In Appendix A, we describe an alternative technique for signature verification which avoids point decompression. With the parameters we chose, it is slightly slower than the techniques presented in the main body of the paper.</li>

    </ul>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">2 Design parameters</p>

    <p class="text-gray-300">We made a number of choices in our system’s design in order to simultaneously achieve high speed and high security. We emphasize that this paper is intended as a demonstration of new algorithms, fields and formulae, and that we do not intend these parameters as a new standard. Before doing that, more work is necessary. We would first want to examine more trade-offs in fields, security levels, hash functons, encodings, curves and signature forms, and to test on a wider variety of hardware configurations.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">2.1 Special Montgomery fields</h3>

    <p class="text-gray-300">Most implementations of arithmetic in general prime-order fields use Montgomery reduction, because it is usually faster than other options such as Barrett reduction. When choosing special prime-order fields, we would like to use Mersenne primes, but there are no such primes between <span class="math">2^{127}-1</span> and <span class="math">2^{521}-1</span>. Therefore, special fields of other forms are used. These fields usually use Barrett reduction, of which Solinas reduction <em>[24]</em> is a special case.</p>

    <p class="text-gray-300">However, it is possible — and profitable — to use Montgomery reduction in special prime-order fields. For example, let <span class="math">p=k\\cdot 2^{aw}-1</span>, where <span class="math">w</span> is the machine’s word size, <span class="math">a\\geq 1</span>, and <span class="math">k</span> is an arbitrary constant. We call such a <span class="math">p</span> a special Montgomery number, or a special Montgomery prime if it is prime. To perform a Montgomery reduction step <span class="math">x\\to x/2^{w}</span>, we use the identity</p>

    <p class="text-gray-300"><span class="math">1/2^{w}\\equiv k\\cdot 2^{(a-1)w}\\pmod{p}</span></p>

    <p class="text-gray-300">That is, to divide by <span class="math">2^{w}</span>, shift each word down by one position. The bottom word cannot be shifted down; instead, shift it up <span class="math">a-1</span> words, multiply it by <span class="math">k</span>, and accumulate. If <span class="math">k</span> is a single word, then this process can be a single multiply-and-accumulate instruction. If <span class="math">k</span> is low-weight, then this process can be accomplished with a few shifts and adds, similar to Solinas reduction. This version of the technique works for the NIST primes with the exception of <span class="math">p_{224}=2^{224}-2^{96}+1</span> However, except for <span class="math">p_{256}</span>, the NIST primes’ coefficients are weighted toward the least significant side, giving an advantage to Barrett reduction.</p>

    <p class="text-gray-300">For our implementation, we wanted a field with slightly fewer than <span class="math">2^{256}</span> elements. We chose <span class="math">p:=2^{252}-2^{232}-1</span>, a special Montgomery prime with a single-word <span class="math">k</span> on both 32- and 64-bit architectures. The gap between <span class="math">p</span> and <span class="math">2^{256}</span> enables lazy reduction: the result of a multiply is under <span class="math">2p</span>, which can be added or subtracted once without reduction; the results can be Montgomery multiplied to produce results under <span class="math">16p^{2}/2^{256}+p&lt;2p</span>. In cases where more additions or subtractions are needed, Barrett reduction is still efficient. Alternatively, when projective coordinates are used, we can insert an extra Montgomery reduction step –</p>

    <p class="text-gray-300">a one-word multiply and accumulate – in two balancing places. This option is applicable mainly in twisted Edwards doubling formulas, where it maximizes speed and minimizes code size. In microbenchmarks, our field seemed considerably faster than primes of other forms, and in the end our benchmarks validate our choice.</p>

    <p class="text-gray-300">We considered several other primes for our implementation, but ultimately decided on this 252-bit <span class="math">p</span>. Our analysis of the alternatives is found in Appendix B. Certain primes work better for different machines and different situations, and there is a performance vs security trade-off to consider as well. For example, some primes are faster on AMD but slower on Intel, or faster on 32-bit machines but slower on 64-bit machines, or faster with NEON but slower in scalar code. Our <span class="math">p</span> is a compromise. We do not intend to set a new standard, but instead to suggest that future efforts should consider special Montgomery primes.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">2.2 Curve choice</h3>

    <p class="text-gray-300">We chose a Montgomery curve</p>

    <p class="text-gray-300"><span class="math">\\mathcal{E}_{m}:v^{2}=u^{3}+Au^{2}+u\\pmod{p}</span></p>

    <p class="text-gray-300">The laddering operation on such curves requires a multiplication by <span class="math">A^{\\prime}=(A-2)/4</span>, so we set <span class="math">A^{\\prime}:=1107/2^{64}</span> in order to use Montgomery multiplication. This gives a curve of order</p>

    <p class="text-gray-300"><span class="math">4q=p-k\\ \\ \\text{where}\\ \\ k=48305947151610022181991269137732172107</span></p>

    <p class="text-gray-300">with twist of order</p>

    <p class="text-gray-300"><span class="math">4\\hat{q}=p+k+2</span></p>

    <p class="text-gray-300">Here <span class="math">q</span> and <span class="math">\\hat{q}</span> are both primes, and are both slightly smaller than <span class="math">2^{250}</span>. In other words, both <span class="math">\\mathcal{E}_{m}</span> and its quadratic twist have cofactor 4. This is important for Curve25519-style protocols, where parties need not check that a point is on <span class="math">\\mathcal{E}_{m}</span> before operating on it <em>[3]</em>. For our designs, we only use the order-<span class="math">q</span> subgroup of <span class="math">\\mathcal{E}_{m}</span>.</p>

    <p class="text-gray-300">We have checked that neither <span class="math">\\mathcal{E}_{m}</span> nor its quadratic twist have any low-degree complex endomorphisms, and that the orders of <span class="math">p</span> modulo <span class="math">q</span> and <span class="math">\\hat{q}</span> are large — in fact, <span class="math">p</span> is a generator modulo both.</p>

    <p class="text-gray-300">The curve <span class="math">\\mathcal{E}_{m}</span> is isomorphic to the twisted Edwards curve</p>

    <p class="text-gray-300"><span class="math">\\mathcal{E}:y^{2}-x^{2}=1+dx^{2}y^{2}\\ \\ \\text{where}\\ \\ d=-\\frac{A-2}{A+2}=-\\frac{1107}{1107+2^{64}}</span></p>

    <p class="text-gray-300">We work only in the order-<span class="math">q</span> subgroups of these curves. Because Edwards curves are faster for most operations, we spent most of our effort on the <span class="math">q</span>-torsion group of <span class="math">\\mathcal{E}</span>.</p>

    <p class="text-gray-300">2.3 Point compression</p>

    <p class="text-gray-300">We compress <span class="math">q</span>-torsion points in <span class="math">\\mathcal{E}</span> and <span class="math">\\mathcal{E}_{m}</span> down to a single element of <span class="math">\\mathbb{F}</span>. That is, we do not send a separate sign bit. Saving a bit is somewhat gratuitous with our 252-bit prime, but it would be more relevant to a system whose elements have sizes that are a multiple of a byte. Our compression technique uses the following lemma:</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Lemma.</h6>

    <p class="text-gray-300">Let <span class="math">P_{1}=(u_{1},v_{1}),P_{2}=(u_{2},v_{2}),P_{3}=(u_{3},v_{3})</span> be finite points on a curve defined by <span class="math">v^{2}=u^{3}+Au^{2}+Bu</span>, with <span class="math">P_{1}=P_{2}+P_{3}</span>. Then <span class="math">u_{1}u_{2}u_{3}</span> is a quadratic residue in <span class="math">\\mathcal{F}</span>.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The points <span class="math">-P_{1},P_{2}</span> and <span class="math">P_{3}</span> lie on a line <span class="math">v=mu+b</span>, so that <span class="math">u^{3}+Au^{2}+Bu-(mu+b)^{2}=0</span> at <span class="math">u_{1},u_{2}</span> and <span class="math">u_{3}</span>. Thus</p>

    <p class="text-gray-300"><span class="math">u^{3}+Au^{2}+Bu-(mu+b)^{2}=(u-u_{1})\\cdot(u-u_{2})\\cdot(u-u_{3})</span></p>

    <p class="text-gray-300">and <span class="math">u_{1}\\cdot u_{2}\\cdot u_{3}=b^{2}</span> is a quadratic residue. ∎</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Corollary.</h6>

    <p class="text-gray-300">If <span class="math">P=(u,v)=2Q</span> on such a curve, then <span class="math">u</span> is a quadratic residue.</p>

    <p class="text-gray-300">In light of this lemma, we choose to represent points of <span class="math">\\mathcal{E}_{m}</span> as <span class="math">1/\\sqrt{u}</span> with the same sign as <span class="math">v</span>, encoded as 32 bytes in little-endian order. Call this encoding <span class="math">\\underline{\\mathrm{P}}</span>. For “sign” we choose the Legendre symbol, but another choice such as the least-significant bit would also suffice. With this representation, the identity is encoded as 0. The point <span class="math">(0,0)\\in\\mathcal{E}_{m}</span> is not a <span class="math">q</span>-torsion point, so we need not worry about <span class="math">u</span> being 0. This form of point compression is also compatible with a fast Montgomery ladder.</p>

    <p class="text-gray-300">To compress a point <span class="math">(X/Z,Y/Z)\\in\\mathcal{E}</span>, we need to compute <span class="math">\\tau:=\\sqrt{(Z-Y)/(Z+Y)}</span> with the same sign as <span class="math">XZ</span>. To decompress a point encoded as <span class="math">\\tau</span>, we need to compute</p>

    <p class="text-gray-300"><span class="math">y=\\frac{1+\\tau^{2}}{1-\\tau^{2}}\\ \\ \\text{and}\\ \\ x=\\tau\\sqrt{\\frac{-A-2}{\\tau^{4}+A\\tau^{2}+1}}</span></p>

    <p class="text-gray-300">In order to perform these computations efficiently, we use a <em>simultaneous inversion and square root</em> algorithm, similar to Montgomery’s simultaneous inversion trick or batch RSA <em>[13]</em>, and similar to the accelerated decompression in Ed25519 <em>[6]</em>. Since <span class="math">p\\equiv 3\\pmod{4}</span>, for <span class="math">a\\in\\mathbb{F}(p)^{*}</span> we might compute <span class="math">1/a=a^{p-2}</span> and <span class="math">\\sqrt{\\pm a}=a^{(p+1)/4}</span>. We can just as easily compute the intermediate <span class="math">1/\\sqrt{\\pm a}=a^{(p-3)/4}</span>. The inverses and square roots in decompression have the form <span class="math">1/a</span> and <span class="math">\\sqrt{1/c}</span>, which must be computed with Legendre symbol 1. We can compute these by first setting <span class="math">s=1/\\sqrt{a^{4}c}</span>, whence <span class="math">1/a=s^{2}a^{3}c=sa\\cdot sa^{2}\\cdot c</span> and <span class="math">\\sqrt{1/c}=sa^{2}</span>. Similarly, for compression we must compute <span class="math">\\sqrt{a/b}</span> with the same sign as <span class="math">c</span>; we can compute this as <span class="math">a^{2}c/\\sqrt{a^{3}bc^{2}}</span>. For any of these formulas, if one of the inputs is zero it will ruin the</p>

    <p class="text-gray-300">computation; we can avoid this problem by replacing zeros with ones in constant time in suitable places.</p>

    <p class="text-gray-300">Note that formulas like these can compute any number of inversions and any number of relatively prime roots or symbols simultaneously. In essence, they compute a suitable generator of the lattice containing the logarithms of the desired results, quotiented by the lattice of the logarithms of the inputs. But when the roots to be taken are not relatively prime, this quotient lattice has dimension higher than 1, so more than one expensive root operation will be required. In particular, these formulas do not reduce the time required to take two separate square roots.</p>

    <h2 id="sec-9" class="text-2xl font-bold">3 Signatures</h2>

    <p class="text-gray-300">We follow the form of Schnorr signatures <em>[23]</em> used in Ed25519 <em>[6]</em>. We do not follow the EdDSA standard itself, because it is too strict for us; for example, it requires the field order to be congruent 1 mod 4. Our base point <span class="math">P</span> is the <span class="math">q</span>-torsion point with the numerically minimum encoding, the byte sequence <span class="math">[4,0,0,\\ldots,0]</span>. A secret key is an integer <span class="math">a\\in[0,q)</span>, with corresponding public key <span class="math">Q=a\\cdot P</span>.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">3.1 Signature form</h3>

    <p class="text-gray-300">To sign a message, the signer chooses a pseudorandom <span class="math">r\\stackrel{{\\scriptstyle\\underline{\\mathrm{R}}}}{{\\leftarrow}}\\mathbb{Z}/q\\mathbb{Z}</span> and computes <span class="math">R\\leftarrow r\\cdot P</span>. It computes a hash <span class="math">c\\leftarrow H(\\underline{\\mathrm{Q}},\\underline{\\mathrm{R}},m)</span> — we use SHA-256 for <span class="math">H</span> — and sets</p>

    <p class="text-gray-300"><span class="math">t\\leftarrow r+c\\cdot a\\pmod{q}</span></p>

    <p class="text-gray-300">The signature is then <span class="math">(\\underline{\\mathrm{R}},t)</span>. The verifier can likewise compute <span class="math">c</span> and then check that <span class="math">R</span> is on the curve and that</p>

    <p class="text-gray-300"><span class="math">t\\cdot P\\ \\stackrel{{\\scriptstyle?}}{{=}}\\ c\\cdot Q\\ +\\ R</span></p>

    <p class="text-gray-300">We could simplify our implementation by not checking the sign of <span class="math">R</span>, i.e. verifying this equation for <span class="math">\\pm R</span> instead of <span class="math">R</span>. This would save some 3% in verification and a few kiB of code size, and probably would not impact security at all. Additionally, we could choose a hash with a 128-bit output <em>[4, 23]</em>. But in order to remain conservative, and to enable apples-to-apples comparisons with other systems, we chose to use a 256-bit output and to verify the <span class="math">x</span>-coordinate.</p>

    <p class="text-gray-300">The signer may choose <span class="math">r</span> at random, but following <em>[6]</em>, we instead choose <span class="math">r=H(a,m)</span> except when a streaming API is desired.</p>

    <p class="text-gray-300">3.2 Coordinate choice</p>

    <p class="text-gray-300">Our signature implementation internally uses points on the twisted Edwards curve <span class="math">\\mathcal{E}</span>, so it is important to choose efficient coordinates for this curve. Projective coordinates (with 3 coefficients) support the fastest doublings <em>[5]</em>, but extended coordinates (with 4 coefficients) support the fastest additions <em>[19]</em>.</p>

    <p class="text-gray-300">Hışıl proposes “mixed homogeneous projective coordinates” <em>[18]</em>. With this technique, one determines whether the next operation will be an addition or a doubling, and if so the extra coordinate <span class="math">T</span> must be computed; otherwise, it is omitted. We wished to avoid this look-ahead. So instead we store <span class="math">(X,Y,Z,T_{1},T_{2})</span>, where <span class="math">x=X/Z,y=Y/Z</span> and <span class="math">T_{1}\\cdot T_{2}=T=XY/Z</span>. The last step of a doubling or addition with extended coordinates <em>[19]</em> amounts to computing <span class="math">T=T_{1}\\cdot T_{2}</span>. We skip that step and leave <span class="math">T_{1}</span> and <span class="math">T_{2}</span> in memory, saving a multiply. The <span class="math">T</span>-coordinate is required for additions, so we compute it at the cost of a multiply when beginning an addition. Thus, as with mixed homogeneous projective coordinates, our “extensible” coordinates cost 4 squares and 3 multiplies to double, and 8 multiplies for addition (7 for mixed addition). Since in most cases only one point is in this form, we aren’t concerned with the 5-element size. Occasionally we may end up computing <span class="math">T</span> twice, but this is rare enough that we will ignore it. Because we use only <span class="math">q</span>-torsion points, the formulas in <em>[19]</em> are strongly unified even though <span class="math">-1</span> is not a quadratic residue in <span class="math">\\mathbb{F}(p)</span>.</p>

    <p class="text-gray-300">For mixed readdition, we use a variant of “Niels coordinates”, of the form</p>

    <p class="text-gray-300"><span class="math">\\alpha=(y-x)/2,\\beta=(y+x)/2,\\gamma=dxy</span></p>

    <p class="text-gray-300">where <span class="math">d</span> is the Edwards curve constant. For unmixed readdition, we add a <span class="math">Z</span> coordinate.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">3.3 Key generation and signing</h3>

    <p class="text-gray-300">The bulk of the work in key generation and signing is the computation of <span class="math">e\\cdot P</span> for (pseudo)-random values <span class="math">e</span>. For this we use a novel signed multi-comb algorithm. This is similar to the algorithm of Lim and Lee <em>[21]</em>. It is also similar in spirit to the signed MSB-set comb algorithm of Feng et al. <em>[12]</em> and the multiple-comb algorithm in Hankerson, Menezes and Vanstone <em>[17]</em>. Our algorithm combines the simplicity and flexibility of the HMV algorithm with the speed advantages of the signed comb algorithms, and is faster than all of them.</p>

    <p class="text-gray-300">Let <span class="math">D&gt;\\log_{2}q</span> be enough digits to write the scalar <span class="math">e</span>. We first write the scalar in signed binary form:</p>

    <p class="text-gray-300"><span class="math">e\\equiv\\sum_{i=0}^{D}d_{i}\\cdot 2^{i}\\pmod{q}\\ \\ \\text{where}\\ \\ d_{i}\\in\\{\\pm 1\\}</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300">To do this, note that</p>

    <p class="text-gray-300"><span class="math">\\frac{e+2^{D}-1}{2}=\\sum_{i=0}^{D}\\frac{d_{i}+1}{2}\\cdot 2^{i}</span></p>

    <p class="text-gray-300">so that <span class="math">(d_{i}+1)/2\\in\\{0,1\\}</span> is the <span class="math">i</span>th binary digit of <span class="math">(e+2^{D}-1)/2\\pmod{q}</span>. Here we take advantage of the fact that <span class="math">q</span> is odd, so halving is always possible mod <span class="math">q</span>. Next, we divide the digits into disjoint blocks:</p>

    <p class="text-gray-300"><span class="math">e\\equiv\\sum_{j=0}^{n-1}\\ B_{j}\\ \\ \\text{where}\\ \\ B_{j}:=\\sum_{i=o_{j}}^{o_{j+1}-1}d_{i}\\cdot 2^{i}</span></p>

    <p class="text-gray-300">Here <span class="math">o_{j}</span> is the (suitably chosen) offset of the <span class="math">j</span>th block, and <span class="math">o_{n}:=D</span> so that all the digits are accounted for. Finally, we divide the digits in each block into combs. The <span class="math">j</span>th combset has <span class="math">t_{j}</span> teeth and spacing <span class="math">s_{j}</span>, where <span class="math">s_{j}\\cdot t_{j}=o_{j+1}-o_{j}</span>. Set</p>

    <p class="text-gray-300"><span class="math">B_{j}=2^{o_{j}}\\cdot\\sum_{k=0}^{s_{j}-1}2^{k}\\cdot C_{j,k}\\ \\ \\text{where}\\ \\ C_{j,k}:=\\sum_{i=0}^{t_{j}-1}d_{o_{j}+s_{j}i+k}\\cdot 2^{s_{j}i}</span></p>

    <p class="text-gray-300">We then have</p>

    <p class="text-gray-300">\\[ e\\ \\ \\equiv\\ \\ \\sum_{k=0}^{\\max s_{j}-1}2^{k}\\cdot\\sum_{\\begin{subarray}{c}j=0\\\\ s_{j}>k\\end{subarray}}^{n-1}C_{j,k}\\ \\ =\\ \\ \\sum_{k=0}^{\\max s_{j}-1}2^{k}\\cdot\\sum_{\\begin{subarray}{c}j=0\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{j}>k\\end{subarray}}^{n-1}\\pm</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{j,k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ \\ \\ (\\text{mod}\\ q) \\]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our algorithm follows directly. Given a base point <span class="math">P</span>, precompute the <span class="math">2^{t_{j}}-1</span> values of $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{j,k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot P<span class="math"> for each </span>j\\in[0,n)<span class="math">. To perform a multiplication, compute the signed digits </span>d_{i}<span class="math"> of </span>e$, then evaluate</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\[ e\\cdot P\\ \\ =\\ \\ \\sum_{k=0}^{\\max s_{j}-1}2^{k}\\cdot\\sum_{\\begin{subarray}{c}j=0\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{j}>k\\end{subarray}}^{n-1}\\pm</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{j,k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot P \\]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">with <span class="math">\\left(\\sum_{j=0}^{n-1}s_{j}\\right)-1</span> additions (from the inner sum) and <span class="math">\\max s_{j}-1</span> doublings (from the outer sum). Figure 1 summarizes the algorithm.</p>

    <p class="text-gray-300">In a conventional point multiplication algorithm, point additions can be skipped when the coefficient happens to be zero. A similar optimization is possible with our comb algorithm. When <span class="math">C_{j,k}=-C_{j,k+1}</span>, then the former can be inverted and the latter skipped. This process replaces a higher and a lower coefficient with only the lower one, and so should be performed from the top down; in this case, it should save <span class="math">n(s-1)/2^{t}</span> point additions in expectation. We could divide the bits into combs differently, so that they interlock; in this case, the above optimization saves <span class="math">(ns-1)/2^{t}</span> additions in expectation. We do not perform this optimization, because it would introduce a timing or SPA attack, and because it wouldn’t save much time</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: Comb algorithm with  <span class="math">n = 2, s = 3, t = 4</span> . A 24-bit multiplication with 5 additions, 2 doublings and 2, 8-element tables.</p>

    <p class="text-gray-300">anyway. We also do not interlock the combs, because gathering the digits from the entirety of  <span class="math">e</span>  is slightly more complicated and expensive.</p>

    <p class="text-gray-300">To prevent timing attacks, we fetch points from memory using a linear pass over the table with arithmetic operations. With Sandy Bridge's vector unit <span class="math">^6</span> , this costs about  <span class="math">4 - 5\\%</span>  of a multiply. This penalty discourages large tables.</p>

    <p class="text-gray-300">We can use either affine or Niels coordinates for these tables. An extensible+Niels addition costs  <span class="math">7M</span> , and an extensible+affine addition costs  <span class="math">8M</span> . Additionally, the Niels addition formula is strongly unified, but a strongly unified affine addition costs another multiply by  <span class="math">d</span> . We do not consider this in Table 5.1, as most applications of fixed-base scalar multiplication do not require unified addition. Affine coordinates have two elements of  <span class="math">\\mathbb{F}(p)</span> , and Niels coordinates have three; in many cases, a  <span class="math">50\\%</span>  bigger table is faster than saving a multiply.</p>

    <p class="text-gray-300">With  <span class="math">\\lceil \\log_2q\\rceil = 250</span> , we can set  <span class="math">D</span>  to either 250 or 252 and use the same  <span class="math">t</span>  for each  <span class="math">t_j</span>  and the same  <span class="math">s</span>  for each  <span class="math">s_j</span> . This works well because such  <span class="math">D</span>  divide evenly into appropriately-sized  <span class="math">n\\cdot t\\cdot s</span> . Alternatively, we can set  <span class="math">D = 250</span> ,  <span class="math">n = 4</span>  and  <span class="math">s_0 = s_1 = 12</span>  but  <span class="math">s_2 = s_3 = 13</span> , or some other combination. We used a script to estimate the cost for different choices of  <span class="math">n,t</span>  and  <span class="math">s</span> , with either affine or Niels coordinates. Some of the results are shown in Table 5.1. Side-channel protection makes large  <span class="math">t</span>  exponentially costly, so that the benefits top out at  <span class="math">t = 5</span>  with Niels coordinates and  <span class="math">t = 6</span>  with affine coordinates. On the other hand,  <span class="math">t = 5</span>  is generally faster than  <span class="math">t = 4</span>  even for small tables.</p>

    <p class="text-gray-300">We somewhat arbitrarily chose  <span class="math">(t,n,s) = (5,5,10)</span>  with Niels coordinates. This makes</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Affine</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Niels</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">size</td>

            <td class="px-3 py-2 border-b border-gray-700">prot</td>

            <td class="px-3 py-2 border-b border-gray-700">unprot</td>

            <td class="px-3 py-2 border-b border-gray-700">size</td>

            <td class="px-3 py-2 border-b border-gray-700">prot</td>

            <td class="px-3 py-2 border-b border-gray-700">unprot</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">2.0</td>

            <td class="px-3 py-2 border-b border-gray-700">2.45</td>

            <td class="px-3 py-2 border-b border-gray-700">2.11</td>

            <td class="px-3 py-2 border-b border-gray-700">3.0</td>

            <td class="px-3 py-2 border-b border-gray-700">2.40</td>

            <td class="px-3 py-2 border-b border-gray-700">1.92</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

            <td class="px-3 py-2 border-b border-gray-700">3.0</td>

            <td class="px-3 py-2 border-b border-gray-700">2.29</td>

            <td class="px-3 py-2 border-b border-gray-700">1.95</td>

            <td class="px-3 py-2 border-b border-gray-700">4.5</td>

            <td class="px-3 py-2 border-b border-gray-700">2.24</td>

            <td class="px-3 py-2 border-b border-gray-700">1.75</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">12,13</td>

            <td class="px-3 py-2 border-b border-gray-700">4.0</td>

            <td class="px-3 py-2 border-b border-gray-700">2.16</td>

            <td class="px-3 py-2 border-b border-gray-700">1.82</td>

            <td class="px-3 py-2 border-b border-gray-700">6.0</td>

            <td class="px-3 py-2 border-b border-gray-700">2.11</td>

            <td class="px-3 py-2 border-b border-gray-700">1.62</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">5.0</td>

            <td class="px-3 py-2 border-b border-gray-700">2.08</td>

            <td class="px-3 py-2 border-b border-gray-700">1.74</td>

            <td class="px-3 py-2 border-b border-gray-700">7.5</td>

            <td class="px-3 py-2 border-b border-gray-700">2.03</td>

            <td class="px-3 py-2 border-b border-gray-700">1.55</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">6.0</td>

            <td class="px-3 py-2 border-b border-gray-700">2.12</td>

            <td class="px-3 py-2 border-b border-gray-700">1.61</td>

            <td class="px-3 py-2 border-b border-gray-700">9.0</td>

            <td class="px-3 py-2 border-b border-gray-700">2.20</td>

            <td class="px-3 py-2 border-b border-gray-700">1.45</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">10.0</td>

            <td class="px-3 py-2 border-b border-gray-700">1.96</td>

            <td class="px-3 py-2 border-b border-gray-700">1.62</td>

            <td class="px-3 py-2 border-b border-gray-700">15.0</td>

            <td class="px-3 py-2 border-b border-gray-700">1.91</td>

            <td class="px-3 py-2 border-b border-gray-700">1.43</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">12.0</td>

            <td class="px-3 py-2 border-b border-gray-700">1.95</td>

            <td class="px-3 py-2 border-b border-gray-700">1.44</td>

            <td class="px-3 py-2 border-b border-gray-700">18.0</td>

            <td class="px-3 py-2 border-b border-gray-700">2.03</td>

            <td class="px-3 py-2 border-b border-gray-700">1.28</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">14.0</td>

            <td class="px-3 py-2 border-b border-gray-700">1.92</td>

            <td class="px-3 py-2 border-b border-gray-700">1.42</td>

            <td class="px-3 py-2 border-b border-gray-700">21.0</td>

            <td class="px-3 py-2 border-b border-gray-700">2.01</td>

            <td class="px-3 py-2 border-b border-gray-700">1.25</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">16.0</td>

            <td class="px-3 py-2 border-b border-gray-700">2.16</td>

            <td class="px-3 py-2 border-b border-gray-700">1.31</td>

            <td class="px-3 py-2 border-b border-gray-700">24.0</td>

            <td class="px-3 py-2 border-b border-gray-700">2.44</td>

            <td class="px-3 py-2 border-b border-gray-700">1.17</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Precomputation trade-off: space in KiB vs. approximate time in multiplies per bit, 250-bit scalar. Estimates with timing attack protection in "prot" column, and without in "unprot".</p>

    <p class="text-gray-300">our tables fairly compact, yet fast for operations with and without side channel protection. We would need to nearly double the table size in order to achieve a  <span class="math">5\\%</span>  speedup.</p>

    <p class="text-gray-300">We can generate the tables reasonably efficiently by iterating over the points in each comb in Gray-code order. We compute the first point in the comb with  <span class="math">t - 1</span>  additions. Each additional point requires one addition or subtraction. We compute all the combs in projective Niels coordinates, then normalize all of them with one simultaneous inversion. We benchmarked this precomputation at around 219k Sandy Bridge cycles for  <span class="math">(t,n,s) = (5,5,10)</span> , making it worthwhile when more than 3 point multiplications will be done with the same base. The same speedup applies to signature verification as well.</p>

    <p class="text-gray-300">To verify signatures, we use a standard WNAF linear-combination algorithm. For the multiples of the fixed base point  <span class="math">P</span> , we use a  <span class="math">2^{5}</span> -element precomputed table in Niels coordinates. This requires 1/8 mixed readdition per bit in expectation. For the multiples of the public key  <span class="math">Q</span> , we precompute  <span class="math">2^{3}</span>  points on the fly in projective Niels coordinates; the main computation then requires 1/6 readdition per bit in expectation. This requires a 3kiB table. Doubling the table size would be acceptable space-wise, but produces only a  <span class="math">2\\%</span>  speedup.</p>

    <p class="text-gray-300">We decompress the public key  <span class="math">Q</span> , but not the signature's challenge point  <span class="math">R</span> . Instead, we check the signature directly from the encoding of  <span class="math">R</span> , using the output of the linear combination algorithm in projective coordinates. This requires a few multiplications, plus a</p>

    <p class="text-gray-300">Legendre symbol computation to check the sign. If we wished to frequently check signatures with a single public key, we could precompute combs for that public key. This reduces the time required to verify by over 60%.</p>

    <h2 id="sec-13" class="text-2xl font-bold">4 EC Diffie-Hellman key agreement</h2>

    <p class="text-gray-300">For Diffie-Hellman key exchange, the input point (the public key) is encoded using the Montgomery curve <span class="math">\\mathcal{E}_{m}</span>, so we use a Montgomery ladder. We use the formulas in Appendix A.3 to recover the sign of the <span class="math">v</span>-coordinate so that we can encode the output point. By using the simultaneous multiplication and square root formulae, this costs only 10 multiplications (well under 1%) more than compressing without the <span class="math">v</span>-coordinate.</p>

    <p class="text-gray-300">The Montgomery ladder is faster than using Edwards coordinates because the input point does not have to be decompressed. When computing secret multiples of a point which is already decompressed (for example, in a password-authenticated key exchange protocol), it is faster to use a 4-bit signed-binary fixed-window algorithm. We cannot use a WNAF algorithm in this situation because we wish to protect against timing attacks.</p>

    <h2 id="sec-14" class="text-2xl font-bold">5 Benchmarks</h2>

    <p class="text-gray-300">For fair and reproducible measurements, we used the SUPERCOP <em>[7]</em> benchmarking suite. We modified our key generation routines to use randombytes for their entropy, while our signature algorithm uses the deterministic option, hashing its secret key and the message to choose its nonce. This is significant because randombytes runs very slowly, taking about 10k Sandy Bridge cycles to generate 256 bits of randomness, similar to a read of /dev/urandom. These choices were made to match Ed25519 to make a more direct comparison. We used our own (simple and slow) implementation of SHA256 for the hash, but the hashing time is a small fraction of the numbers presented here. A production-ready implementation would use a tuned implementation, and might rather use SHA512, or SHA-3 when it becomes available.</p>

    <p class="text-gray-300">Our primary test machine is a laptop with a 2.2GHz Intel Core i7 2720QM Sandy Bridge processor, running on only one of its 4 cores. The processor Turbo Boosts to at most 3.2GHz, while its cycle counter always runs at 2.2GHz. SUPERCOP does not notice this, so we multiplied our cycle counts by 3.2/2.2. We found the actual boost rate to be somewhat variable in practice, but we do not believe it can exceed this ratio.</p>

    <p class="text-gray-300">Our second test machine is a TrimSlice nettop with a dual-core 1GHz Tegra 2 core (Cortex A9, no NEON vector unit), running on only one of its 2 cores. SUPERCOP uses the Linux perf-events system to measure timings.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Operation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our System</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ed/Curve25519</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">SBR</td>

            <td class="px-3 py-2 border-b border-gray-700">A9</td>

            <td class="px-3 py-2 border-b border-gray-700">SBR</td>

            <td class="px-3 py-2 border-b border-gray-700">A8+NEON</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Generate keys</td>

            <td class="px-3 py-2 border-b border-gray-700">60kcy</td>

            <td class="px-3 py-2 border-b border-gray-700">254kcy</td>

            <td class="px-3 py-2 border-b border-gray-700">73kcy</td>

            <td class="px-3 py-2 border-b border-gray-700">?kcy</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Sign</td>

            <td class="px-3 py-2 border-b border-gray-700">60kcy</td>

            <td class="px-3 py-2 border-b border-gray-700">262kcy</td>

            <td class="px-3 py-2 border-b border-gray-700">70kcy</td>

            <td class="px-3 py-2 border-b border-gray-700">368kcy</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verify</td>

            <td class="px-3 py-2 border-b border-gray-700">169kcy</td>

            <td class="px-3 py-2 border-b border-gray-700">618kcy</td>

            <td class="px-3 py-2 border-b border-gray-700">226kcy</td>

            <td class="px-3 py-2 border-b border-gray-700">650kcy</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Compute shared secret</td>

            <td class="px-3 py-2 border-b border-gray-700">153kcy</td>

            <td class="px-3 py-2 border-b border-gray-700">616kcy</td>

            <td class="px-3 py-2 border-b border-gray-700">194kcy</td>

            <td class="px-3 py-2 border-b border-gray-700">527kcy</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Fixed signing tables</td>

            <td class="px-3 py-2 border-b border-gray-700">7.5kiB</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">30kiB</td>

            <td class="px-3 py-2 border-b border-gray-700">?kiB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Fixed verification tables</td>

            <td class="px-3 py-2 border-b border-gray-700">3kiB</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3.75kiB</td>

            <td class="px-3 py-2 border-b border-gray-700">?kiB</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: Benchmarks on Sandy Bridge, Cortex-A9 (Nvidia Tegra 2 1GHz, no NEON) and Cortex-A8 (Apple A4 1GHz with NEON). Median SUPERCOP cycles. Signatures on 59-byte messages. Our results rounded up to the next multiple of 1000 cycles, previous results rounded down.</p>

    <p class="text-gray-300">Our benchmarks, shown in Table 3, compare well with previous systems. Our software takes  <span class="math">20 - 25\\%</span>  less time on Sandy Bridge than Bernstein's  <span class="math">\\mathbb{F}(2^{255} - 19)</span>  software. We did not find any other elliptic curve signing and key exchange implementations which are optimized for NEON-less ARM processors, and comparing even our minimally-optimized ARM code with reference code would not be fair. We do not know all the relevant figures for Bernstein and Schwabe's A8+NEON implementation, as they are not listed in [8] and the source code is not available.</p>

    <p class="text-gray-300">We wished to compare with Hüseyin Hişil's ecfp256 software as well, but a comparison is much more difficult. It would also not be entirely fair, since our implementation and ecfp256 are both prototype implementations, designed to test different things. eBATS [7] reports 53kcy key generation on Sandy Bridge using 192kiB tables, no randombytes and no side-channel protection. However, ecfp256 uses a bigger prime and is factored differently, with less aggressive inlining. ecfp does not implement signatures or Montgomery laddering — it uses Edwards coordinates for Diffie-Hellman exchanges — and it does not run on ARM.</p>

    <p class="text-gray-300">Longa and Sica implemented variable-base scalar multiplication on elliptic curves with endomorphisms [22]. Their fastest curve is an Edwards curve over a quadratic extension of a 127-bit special Barrett prime field, supporting a degree-4 endomorphism. For this curve they reported a variable-base scalar multiplication in 91k Sandy Bridge cycles without side-channel protection, and 137k cycles with protection. This operation represents almost all the work of a shared-secret computation. Longa and Sica did not implement key generation, signatures or point compression, and they reported results only for x86-64 processors.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Operation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">SBR</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A9</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Precompute verification table</td>

            <td class="px-3 py-2 border-b border-gray-700">219kcy</td>

            <td class="px-3 py-2 border-b border-gray-700">862kcy</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verify</td>

            <td class="px-3 py-2 border-b border-gray-700">169kcy</td>

            <td class="px-3 py-2 border-b border-gray-700">618kcy</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verify with table</td>

            <td class="px-3 py-2 border-b border-gray-700">62kcy</td>

            <td class="px-3 py-2 border-b border-gray-700">238kcy</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verification table size</td>

            <td class="px-3 py-2 border-b border-gray-700">7.5kiB</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3: Benchmarks with precomputation on Sandy Bridge and Cortex-A9 (Nvidia Tegra 2 1GHz, no NEON). Median cycles, rounded up to the next multiple of 1000 cycles. Signatures on 59-byte messages. This is not a SUPERCOP-supported benchmark.</p>

    <p class="text-gray-300">Our software is capable of precomputing tables for commonly-used keys in order to speed up verification with those keys. This code uses the same (5, 5, 10) comb tables as signing and key generation. As Table 5.1 shows, this reduces verification time by over  <span class="math">60\\%</span> , putting it near the performance level of multivariate quadratic signatures [16, 10, 9]. One possible use of this code is to replace MACs between peers in systems where nonrepudiation would be desirable. While 62kcy is nowhere near as fast as a MAC, it may be fast enough to make such a replacement feasible.</p>

    <p class="text-gray-300">We have presented a new, faster implementation of elliptic-curve cryptography. In particular, we have demonstrated faster fields, a new point compression algorithm and a new algorithm for scalar multiplication with precomputation. Our system is faster than previous software implementations of ECC signatures at comparable security levels. It does not use the NEON vector unit found in some smartphones, but it is competitive with software that does. It does not use curves with endomorphisms, but for side-channel-resistant operations it is competitive with software that does.</p>

    <p class="text-gray-300">These techniques are applicable to many other systems, and this application we leave as future work. We would like to investigate other curve forms, particularly elliptic curves with endomorphisms. We would like to examine fields for curves at stronger security levels. We are interested in performance on other platforms such as hardware and ARM+NEON. We would like to extend our toolkit to other cryptographic algorithms such as as batch signature verification, oblivious function evaluation and password-authenticated key exchange.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Yearly report on algorithms and keysizes (2010-2011), 2011.</li>

      <li>[2] E. Barker, W. Barker, W. Burr, W. Polk, and M. Smid. Recommendation for key management–part 1: General (revision 3). NIST special publication, 800:57, 2011.</li>

      <li>[3] D. Bernstein. Curve25519: new Diffie-Hellman speed records. Public Key Cryptography-PKC 2006, pages 207–228, 2006.</li>

      <li>[4] D. Bernstein. ElGamal vs Schnorr vs ECDSA vs…, August 29 2006. Posted to sci.crypt.</li>

      <li>[5] D. Bernstein, P. Birkner, M. Joye, T. Lange, and C. Peters. Twisted edwards curves. Progress in Cryptology–AFRICACRYPT 2008, pages 389–405, 2008.</li>

      <li>[6] D.J. Bernstein, N. Duif, T. Lange, P. Schwabe, and B.Y. Yang. High-speed high-security signatures. Cryptographic Hardware and Embedded Systems, CHES 2011, 2011.</li>

      <li>[7] D.J. Bernstein and T. Lange. eBACS: Ecrypt benchmarking of cryptographic systems. http://bench.cr.yp.to, accessed 28 October 2011.</li>

      <li>[8] D.J. Bernstein and P. Schwabe. Neon crypto, March 20 2012. http://cryptojedi.org/papers/neoncrypto-20120320.pdf.</li>

      <li>[9] Jiun-Ming Chen and Bo-Yin Yang. A more secure and efficacious tts signature scheme. In Jong-In Lim and Dong-Hoon Lee, editors, Information Security and Cryptology - ICISC 2003, volume 2971 of Lecture Notes in Computer Science, pages 320–338. Springer Berlin / Heidelberg, 2004.</li>

      <li>[10] Jintai Ding and Dieter Schmidt. Rainbow, a new multivariable polynomial signature scheme. In Proceedings of the Third international conference on Applied Cryptography and Network Security, ACNS’05, pages 164–175, Berlin, Heidelberg, 2005. Springer-Verlag.</li>

      <li>[11] H.M. Edwards. A normal form for elliptic curves. Bulletin-American Mathematical Society, 44(3):393, 2007.</li>

      <li>[12] M. Feng, B. Zhu, C. Zhao, and S. Li. Signed MSB-set comb method for elliptic curve point multiplication. Information Security Practice and Experience, pages 13–24, 2006.</li>

      <li>[13] A. Fiat. Batch RSA. Journal of Cryptology, 10(2):75–88, 1997.</li>

    </ul>

    <p class="text-gray-300">[14] S. Galbraith, X. Lin, and M. Scott. Endomorphisms for faster elliptic curve cryptography on a large class of curves. Advances in Cryptology-EUROCRYPT 2009, pages 518–535, 2009.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[15] R. Gallant, R. Lambert, and S. Vanstone. Faster point multiplication on elliptic curves with efficient endomorphisms. In Advances in CryptologyCRYPTO 2001, pages 190–200. Springer, 2001.</li>

      <li>[16] Danilo Gligoroski, Rune Steinsmo Ødegård, Rune Erlend Jensen, Ludovic Perret, Jean-Charles Faugère, Svein Johan Knapskog, and Smile Markovski. The digital signature scheme mqq-sig. Cryptology ePrint Archive, Report 2010/527, 2010. http://eprint.iacr.org/.</li>

      <li>[17] D.R. Hankerson, S.A. Vanstone, and A.J. Menezes. Guide to elliptic curve cryptography. Springer-Verlag New York Inc, 2004.</li>

      <li>[18] H. Hışıl. Elliptic curves, group law, and efficient computation, 2010.</li>

      <li>[19] H. Hışıl, K. Wong, G. Carter, and E. Dawson. Twisted edwards curves revisited. Advances in Cryptology–ASIACRYPT 2008, pages 326–343, 2008.</li>

      <li>[20] P. Hoffman. Elliptic curve dsa for dnssec. http://tools.ietf.org/html/draft-hoffman-dnssec-ecdsa-04, accessed 14 March 2012.</li>

      <li>[21] C. Lim and P. Lee. More flexible exponentiation with precomputation. In Advances in CryptologyCRYPTO94, pages 95–107. Springer, 1994.</li>

      <li>[22] P. Longa and F. Sica. Four-dimensional Gallant-Lambert-Vanstone scalar multiplication, 2012. http://eprint.iacr.org/2011/608.</li>

      <li>[23] C. Schnorr. Efficient identification and signatures for smart cards. In Advances in CryptologyCrypto89 Proceedings, pages 239–252. Springer, 1990.</li>

      <li>[24] J.A. Solinas. Generalized mersenne numbers, 1999.</li>

    </ul>

    <h2 id="sec-18" class="text-2xl font-bold">Appendix A Verification without decompression</h2>

    <p class="text-gray-300">We experimented with an alternative strategy for signature verification, which we ultimately abandoned in favor of a traditional linear-combination implementation.</p>

    <p class="text-gray-300">We wish to verify a signature which is of the form  <span class="math">t \\cdot P = c \\cdot Q + R</span> , for some scalars  <span class="math">t, c</span>  and points  <span class="math">P, Q, R</span> , of which  <span class="math">P</span>  is fixed. However, it suffices to verify a weaker equation, such as  <span class="math">t \\cdot P = c \\cdot Q \\pm R</span>  or  <span class="math">t \\cdot P = \\pm c \\cdot Q \\pm R</span> . The usual strategy (and the one we ultimately adopted) is to compute  <span class="math">t \\cdot P - c \\cdot Q</span> . With extensible coordinates, this costs:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Decompressing R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1S</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">One doubling per bit</td>

            <td class="px-3 py-2 border-b border-gray-700">3M + 4S</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">One readdition every 6 bits in expectation</td>

            <td class="px-3 py-2 border-b border-gray-700">8M/6.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">One mixed readdition every 9 bits in expectation</td>

            <td class="px-3 py-2 border-b border-gray-700">7M/9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Precomputation of about 8 points over 250 bits</td>

            <td class="px-3 py-2 border-b border-gray-700">8M * 16/250</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Total</td>

            <td class="px-3 py-2 border-b border-gray-700">5.62M + 5S</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">With  <span class="math">S \\approx 0.8M</span> , this comes out to some  <span class="math">9.62M</span>  per bit. An alternative is to use the fastest available algorithms to compute  <span class="math">t \\cdot P</span>  and  <span class="math">c \\cdot Q</span>  separately, and then to combine them. For  <span class="math">t \\cdot P</span>  we use the signed multi-comb method, and for  <span class="math">c \\cdot Q</span>  we use a Montgomery ladder over  <span class="math">\\mathcal{E}_m</span> . Using the (5,5,10) combs, this costs:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">49 mixed readditions</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">49·7M/250</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">9 doublings</td>

            <td class="px-3 py-2 border-b border-gray-700">9·(3M+4S)/250</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">One mixed ladder step per bit</td>

            <td class="px-3 py-2 border-b border-gray-700">5M+4S</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Total</td>

            <td class="px-3 py-2 border-b border-gray-700">6.48M+4.14S</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">With  <span class="math">S \\approx 0.8M</span> , this comes out to  <span class="math">9.79M</span>  per bit. In our implementation with (5,5,10) combs, this split method was indeed slightly slower — 152k cycles vs 148k cycles. With larger precomputed tables, the trade-off is slightly more favorable to the Montgomery method. Likewise, if the hash is truncated to 128 bits, the split method has an advantage. But with our parameters, the traditional linear-combination method is faster.</p>

    <p class="text-gray-300">A tricky question arises in our split formulation, however. The Montgomery ladder only computes the  <span class="math">u</span> -coordinate of  <span class="math">c \\cdot Q</span> , and without performing decompression, we do not have the  <span class="math">v</span>  coordinate of either  <span class="math">c \\cdot Q</span>  nor  <span class="math">R</span> . How then can we verify the addition, even if we weaken it to</p>

    <div class="my-4 text-center"><span class="math-block">t \\cdot P \\stackrel {?} {=} \\pm R \\pm c \\cdot Q</span></div>

    <p class="text-gray-300">We cannot compute the right side of this equation, even up to sign, without recovering a  <span class="math">v</span> -coordinate. However, we can still verify the equation given the  <span class="math">u</span> -coordinates of these</p>

    <p class="text-gray-300">values, say <span class="math">u_{1}</span>, <span class="math">u_{2}</span> and <span class="math">u_{3}</span> for <span class="math">t\\cdot P</span>, <span class="math">R</span> and <span class="math">c\\cdot Q</span> respectively. Recall that these points lie on the Montgomery curve</p>

    <p class="text-gray-300"><span class="math">\\mathcal{E}:v^{2}=u^{3}+Au^{2}+u</span></p>

    <p class="text-gray-300">The verification equation will hold if some line</p>

    <p class="text-gray-300"><span class="math">v=mu+b</span></p>

    <p class="text-gray-300">intersects <span class="math">\\mathcal{E}</span> in three points with the given <span class="math">u</span>-coordinates, with appropriate multiplicities if the coordinates are repeated. Thus we will have</p>

    <p class="text-gray-300"><span class="math">u^{3}+Au^{2}+u-(mu+b)^{2}</span> <span class="math">=</span> <span class="math">(u-u_{1})(u-u_{2})(u-u_{3})</span> <span class="math">=</span> <span class="math">u^{3}-(u_{1}+u_{2}+u_{3})u^{2}</span> <span class="math">+\\ (u_{1}u_{2}+u_{2}u_{3}+u_{3}u_{1})u+u_{1}u_{2}u_{3}</span></p>

    <p class="text-gray-300">whence</p>

    <p class="text-gray-300"><span class="math">m^{2}=u_{1}+u_{2}+u_{3}+A,\\ \\ 2mb=1-u_{1}u_{2}-u_{2}u_{3}-u_{3}u_{1}\\ \\ \\text{and}\\ \\ b^{2}=u_{1}u_{2}u_{3}</span></p>

    <p class="text-gray-300">These equations will be solvable (i.e. the line will exist) over a quadratic extension of <span class="math">\\mathbb{F}</span> if and only if</p>

    <p class="text-gray-300"><span class="math">4(u_{1}+u_{2}+u_{3}+A)(u_{1}u_{2}u_{3})=(1-u_{1}u_{2}-u_{2}u_{3}-u_{3}u_{1})^{2}</span></p>

    <p class="text-gray-300">If <span class="math">m</span> and <span class="math">b</span> are not in <span class="math">\\mathbb{F}</span>, then since their squares and product are in <span class="math">\\mathbb{F}</span>, they must both be “pure imaginary”. In this case, we would still have</p>

    <p class="text-gray-300"><span class="math">t\\cdot P=\\pm c\\cdot Q\\ \\pm\\ R</span></p>

    <p class="text-gray-300">with <span class="math">t\\cdot P,c\\cdot Q</span> and <span class="math">R</span> lying not on <span class="math">\\mathcal{E}</span>, but on its quadratic twist. However, this cannot happen because <span class="math">P</span> and <span class="math">Q</span> are on <span class="math">\\mathcal{E}</span>. So to check that <span class="math">t\\cdot P\\ \\stackrel{{\\scriptstyle?}}{{=}}\\ \\pm R\\ \\pm\\ c\\cdot Q</span>, it suffices to check this equation, which takes about as long as a point addition.</p>

    <p class="text-gray-300">Note that <span class="math">u_{1}</span> and <span class="math">u_{3}</span> above will be given in projective coordinates, i.e. as <span class="math">U_{1}/Z_{1}</span> and <span class="math">U_{3}/Z_{3}</span>, respectively; the formula is easily adapted to this case by clearing the denominators. In this case, the formula is still correct even if one or both of the points is the identity.</p>

    <p class="text-gray-300">This formula is easily adapted to curves in other cubic forms, even over binary fields. For twisted Edwards curves, the birational equivalence to Montgomery curves computes the <span class="math">u</span> coordinate on the Montgomery curve using only the <span class="math">y</span> coordinate of the Edwards curve, so this equation can check relations on twisted Edwards curves with <span class="math">Y,Z</span> coordinates as well.</p>

    <p class="text-gray-300">##</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">A.3 Checking the <span class="math">v</span> coordinate</h3>

    <p class="text-gray-300">The split equation does not check the <span class="math">v</span> coordinate given in signatures. However, we will show in this section that it is possible to do so.</p>

    <p class="text-gray-300">Given the <span class="math">v</span>-coordinate of one of the points, we can solve for those of the others. We have</p>

    <p class="text-gray-300"><span class="math">v_{1}\\cdot v_{2}</span> <span class="math">=</span> <span class="math">(mu_{1}+b)\\cdot(mu_{1}+b)</span> <span class="math">=</span> <span class="math">m^{2}u_{1}u_{2}+mb(u_{1}+u_{2})+b^{2}</span> <span class="math">=</span> <span class="math">\\frac{1}{2}\\left((u_{1}u_{2}+1)(u_{1}+u_{2})-u_{3}(u_{1}-u_{2})^{2}+2Au_{1}u_{2}\\right)</span></p>

    <p class="text-gray-300">by plugging in the formulas for <span class="math">m^{2},2mb</span> and <span class="math">b^{2}</span>. Since the Edwards scalar-multiplication algorithm and isomorphism will produce the <span class="math">v</span>-coordinate of <span class="math">t\\cdot P</span>, we can recover that of <span class="math">R</span> and that of <span class="math">c\\cdot Q</span>. Since this last value was computed with a Montgomery ladder, we also have access to the <span class="math">u</span>-coordinates of <span class="math">Q</span> and <span class="math">(c+1)\\cdot Q</span>, we can repeat this equation again to solve for the <span class="math">v</span>-coordinate of <span class="math">Q</span>.</p>

    <p class="text-gray-300">Since we chose the Legendre symbol as our sign bit, we can check the sign of the <span class="math">v</span>-coordinates with one Legendre symbol calculation each. In our experiments, the Legendre symbol takes about <span class="math">40\\%</span> as long as an inversion by exponentiation, so it is cheaper to verify both <span class="math">v</span>-coordinates than to actually compute either of them.</p>

    <h2 id="sec-22" class="text-2xl font-bold">Appendix B Other prime fields</h2>

    <p class="text-gray-300">We considered several other fields for our implementation. For clarity, let <span class="math">p_{252}=2^{252}-2^{232}-1</span> be the prime we chose.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">B.1 Special primes with Barrett reduction</h3>

    <p class="text-gray-300">We first considered a conventional choice such as <span class="math">2^{255}-19</span>, <span class="math">2^{256}-189</span> or similar with Barrett reduction. We found Montgomery reduction to be significantly more efficient than Barrett reduction, because no contortions are required to limit carry-propagation. Multiplication modulo these primes took some 80 cycles in our tests, compared with 55 cycles for <span class="math">p_{252}</span>. Perhaps more tuning would improve this.</p>

    <p class="text-gray-300">Bernstein <em>[3]</em> changes the radix from <span class="math">2^{64}</span> to <span class="math">2^{51}</span> and stores elements in 5 words. This helps on processors such as Sandy Bridge which sport fast multipliers and slow carries – but in our measurements the increased number of multiplies, higher register pressure and larger memory footprint negated these benefits.</p>

    <p class="text-gray-300">B.2 Slightly larger fields</p>

    <p class="text-gray-300">We strongly considered using <span class="math">p_{256}:=2^{256}-2^{194}-1</span>. This special Montgomery prime is slightly larger than our <span class="math">p_{252}</span>, and its round size and Solinas form are appealing. Reductions can be done with shifting and addition; and its Barrett reduction algorithm is faster than that of <span class="math">p_{252}</span>. We need one extra Montgomery reduction in the multiplication step to reduce from less than <span class="math">2p</span> to less than <span class="math">2^{256}</span>. However, if we wish to keep elements under 4 words with <span class="math">p_{256}</span>, we will also have to reduce after every addition or subtraction; expanding to 5 words would slow down multiplication and worsen register pressure.</p>

    <p class="text-gray-300">The performance difference between these primes depends heavily on the platform. On Sandy Bridge, <span class="math">p_{256}</span> operations take 8% longer than <span class="math">p_{252}</span>; on Core 2 Conroe (which sports a respectably fast multiplier, but slow add-with-carry), they take up to 50% longer; on AMD K8 (with a slower multiplier, but fast add-with-carry), they take 2% less time. We did not implement <span class="math">p_{256}</span> arithmetic on ARM, but we conjecture that it would perform slightly worse than <span class="math">p_{252}</span>.</p>

    <p class="text-gray-300">In light of <span class="math">p_{256}</span>’s slow performance on Conroe, we chose <span class="math">p_{252}</span> for this paper. However, we are interested in future work with <span class="math">p_{256}</span>.</p>

    <p class="text-gray-300">Adding an extra bit for point compression would ruin the round 256-bit size of <span class="math">p_{256}</span> — but our compression technique does not require an extra bit (see Section 2.3).</p>

    <p class="text-gray-300">We also considered <span class="math">2^{255}-2^{224}\\cdot 29-1</span>. This prime is a compromise between <span class="math">p_{256}</span> and <span class="math">p_{252}</span>, and its non-Solinas form hurts the performance of Barrett reduction, but it does allow some degree of laziness. It also has an extra bit for point compression in protocols over prime-order curves, where the compression techniques in Section 2.3 do not apply.</p>

    <h3 id="sec-24" class="text-xl font-semibold mt-8">B.3 Composite Mersenne fields</h3>

    <p class="text-gray-300">We considered primes such as <span class="math">(2^{281}-1)/80929</span>, representing each number internally modulo <span class="math">2^{281}-1</span>. However, for computations without a vector unit, we believe that the increased number of multiplications outweighs the simpler reduction. For example, on ARM such a prime would require <span class="math">9^{2}</span> 32-bit multiplies and a few shifts and adds, but <span class="math">p_{252}</span> requires only <span class="math">8\\cdot 9</span> multiplies.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">B.4 Much larger fields</h3>

    <p class="text-gray-300">We are interested in trying larger pseudo-Mersenne and/or trinomial primes, but they are beyond the scope of this work.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">B.5 Extension fields</p>

    <p class="text-gray-300">We considered odd-prime-power extension fields, particularly the popular <span class="math">\\mathbb{F}((2^{127}-1)^{2})</span>. The smaller multiplies and double reductions required for this field lengthen its multiplication to about 75 Sandy Bridge cycles in our implementation, with or without Karatsuba. However, this field allows endomorphisms for faster point multiplication <em>[15]</em> on a wide variety of curves <em>[14]</em>. What is more, extension fields support much faster inversion and square roots, which may balance their slower multiplication in some applications.</p>

    <p class="text-gray-300">The disadvantages of this field do not apply as strongly in larger extension fields, such as <span class="math">\\mathbb{F}((2^{192}-2^{64}-1)^{2})</span>. But in this paper we target a security level near 128 bits. Similarly, we suspect that <span class="math">\\mathbb{F}((2^{127}-1)^{2})</span> would perform well on 32-bit platforms such as ARM.</p>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">B.6 Primes supporting endomorphisms</h3>

    <p class="text-gray-300">We considered primes supporting ordinary curves with endomorphism. For example, we looked into <span class="math">2^{252}-739448\\cdot 2^{224}-1;\\;\\;\\;2^{255}-209264\\cdot 2^{224}-1;\\;\\;\\;2^{256}-44416\\cdot 2^{224}-1</span>; etc. Modulo these primes, both</p>

    <p class="text-gray-300"><span class="math">\\mathcal{E}_{3}:y^{2}=x^{3}-\\frac{3}{4}x^{2}-2x-1</span></p>

    <p class="text-gray-300">and its quadratic twist have 8<span class="math">\\cdot</span>prime order, and <span class="math">-7</span> is a quadratic residue. Such curves have complex multiplication modulo <span class="math">(1+\\sqrt{-7})/2</span>, and therefore support an efficiently computable endomorphism <em>[15]</em>. We leave exploration of such endomorphisms to future work. We suspect that they will noticeably speed up verification and key exchange, but not key generation or signing.</p>

    <h2 id="sec-27" class="text-2xl font-bold">Appendix</h2>`;
---

<BaseLayout title="Fast and compact elliptic-curve cryptography (2012/309)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2012 &middot; eprint 2012/309
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
