---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2025/2040';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'The Algebraic CheapLunch: Extending FreeLunch Attacks on Arithmetization-Oriented Primitives Beyond CICO-1';
const AUTHORS_HTML = 'Antoine Bak, Augustin Bariant, Aur&eacute;lien Boeuf, Pierre Briaud, Morten &Oslash;ygarden, Atharva Phanse';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">The security of many arithmetization-oriented (AO) hash functions depends of the hardness of Constrained-input constrained-output (CICO) problems. These problems have received significant attention from the cryptographic community in recent years, with notable advances in Gr&ouml;bner basis and resultant-based attacks, yet progress has mainly been limited to CICO problems restricted to a single output. In this work, we build on the &quot;FreeLunch method&quot; of Bariant et al. (Crypto 2024) that constructs Gr&ouml;bner bases &quot;for free&quot; in this particular case, and extend it to CICO problems with multiple outputs. More precisely, we consider tools for solving weighted polynomial systems, and show how to apply them in the AO setting. This results in new polynomial modelings, more efficient methods for computing the initial Gr&ouml;bner basis under certain assumptions, and improved complexity estimates for the change of ordering step, derived from tighter upper bounds on the ideal degree. We apply our framework to Poseidon, Neptune and XHash8, where our assumptions are experimentally verified, and theory matches practice. For Griffin and ArionHash our assumptions are not verified, leaving us with improved, yet loose, upper bounds on the ideal degree. While our results do not threaten the security of any full-round hash function, they provide new insights into the security of these primitives under more general CICO problems.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> Gr&ouml;bner basis &middot; Hash function &middot; Poseidon &middot; XHash &middot; Arion-Hash &middot; Griffin</p>
    </section>

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">The increasing deployment of practical zero-knowledge (ZK) proof protocols has created a need for hash functions that allow a preimage to be proven efficiently using the corresponding proof system. The construction of these hash functions depends a lot on the cost model of the target proof system. In general, a requirement is that the round functions of the permutation can be verified using a low-degree function, hence the name <em>Arithmetization-Oriented</em> (AO). This can be achieved by having the entire round function be of low degree, such as in Poseidon [34] and Neptune [37], or by including operations that have a low degree inverse, such as in Anemoi [16], XHash [2], Griffin [31], and ArionHash [44]. Due to their inherent algebraic structure, algebraic attacks (especially Gr&ouml;bner basis attacks) are often the main attack vector against these hash functions. We remark that some recent designs also rely on the use of Split-and-Lookup S-boxes, such as Monolith [33], Reinforced Concrete [32], and Tip5 [45], which will remain beyond the scope of this analysis.</p>

    <p class="text-gray-300">AO hash functions are typically constructed by first designing a permutation  <span class="math">F: \\mathbb{F}_p^t \\longrightarrow \\mathbb{F}_p^t</span>  and then using it in a sponge construction [14]. By their very nature, the security of hash functions in sponge constructions is directly dependent on the difficulty of solving the <em>Constrained-Input Constrained-Output</em> (CICO) problem for the underlying permutation. The abovementioned algebraic attacks generally proceed by modeling this CICO problem as a multivariate polynomial system, and then find its solution(s). These solutions can, in turn, be used to instantiate attacks on the overall sponge construction.</p>

    <p class="text-gray-300">The CICO modeling is usually solved as follows. First, ones computes a Gr&ouml;bner basis for the ideal it generates, with respect to a suitable monomial order. This first basis is then converted into a second Gr&ouml;bner basis that contains a univariate polynomial, whose roots contain the value of one of the entries of a solution. The remaining entries are now (comparatively) easy to recover. While the default choice in earlier attacks on AO hash functions was to adopt the grevlex order for the first step, recent progress came from choosing an &quot;easier&quot; order tailored to the modeling [7,17], for which generic Gr&ouml;bner basis algorithms [19,20] seemed more efficient or could even be bypassed. For the second step, all attacks rely on change-of-ordering algorithms in the FGLM framework [28].</p>

    <p class="text-gray-300">Estimating the complexity of these two steps is essential for assessing the security guarantees of a given hash function. These complexities are influenced by intrinsic properties of the CICO modeling such as regularity conditions, or the degree of the associated ideal. However, these properties are often challenging to determine theoretically. As a result, many earlier works have taken a more pragmatic approach by partially relying on small-scale experiments for this estimation &ndash; or indeed to extrapolate the entire solving cost from small-scale tests. The difficulties in estimating these attacks are generally related to understanding the particular structure of the underlying AO permutation, in combination with that of the precise CICO problem we are trying to solve. In particular, a more fine-grained examination of these structures has already led to improved solving methods and, in some cases, to improved polynomial modelings [7,17].</p>

    <p class="text-gray-300">Influence of the prime field size. The size of the prime p in the finite field  <span class="math">\\mathbb{F}_p</span>  used in ZK-friendly primitives varies greatly depending on the use case. It ranges from 31-bit primes (eg. in Plonky3) to 256-bit primes when the field is the scalar</p>

    <p class="text-gray-300">field of an elliptic curve. When p &sim; 2 <sup>256</sup>, a permutation in sponge mode with capacity c = 1 is sufficient for guaranteeing 128 bits of security against collision and preimage attacks. This makes CICO-1 &ndash; i.e., the CICO problem with a single degree of input freedom, and a single output is observed &ndash; relevant for assessing the security of the sponge hash function. However, for smaller fields, such as 64 or 31-bit prime fields<a href="#page-2-0">5</a> , a larger capacity is required for guaranteeing 128 bits of security. In this setting, a study of the CICO-k problem for k &gt; 1 is more relevant for assessing the security of the hash function.</p>

    <p class="text-gray-300">Previous works. In the CICO-1 setting, several works have already been able to leverage the structure of the input modeling to obtain more efficient attacks, for instance, by choosing a custom ordering for which this modeling is already a Gr&uml;obner basis <a href="#page-28-2">[7]</a> and/or by using resultants for variable elimination to obtain a univariate expression in a somewhat more direct way than using FGLM methods <a href="#page-30-4">[47</a><a href="#page-28-4">,8]</a>. While these approaches have been very successful for CICO-k problems with k = 1, it is unclear whether they can be extended to larger values of k. The case of k &gt; 1 has received much less attention from the cryptographic community. So far, most works in this setting either extrapolate complexity estimates from experiments on reduced primitives (see <a href="#page-27-1">[3]</a> for Poseidon and <a href="#page-30-5">[40]</a> for Anemoi) or use generic bounds on the Gr&uml;obner basis computation with respect to the grevlex ordering to estimate the complexity of the first step <a href="#page-30-6">[36]</a>. The only exception we are aware of is the recent work of <a href="#page-28-3">[17]</a> on Anemoi, that derives an explicit Gr&uml;obner basis for CICO-k with t = 2k branches, and proves the degree of the ideal it generates.</p>

    <p class="text-gray-300">Our results. In this work, we propose an extension of the so-called FreeLunch approach of <a href="#page-28-2">[7]</a> to the k &gt; 1 case, that we refer to as the &quot;CheapLunch&quot; approach. In particular, we give a general framework allowing us to model primitives in such a way that, under some genericity assumptions and for a custom monomial ordering, a Gr&uml;obner basis of the modeling can be computed efficiently (though not quite &quot;for free&quot;). In turn, this transfers the bottleneck for Gr&uml;obner basis attacks from the Gr&uml;obner basis computation step to the change-of-ordering step, just as in the FreeLunch setting when k = 1.</p>

    <p class="text-gray-300">This custom ordering, as well as our estimates for the first step, are related to well-known results on weighted systems <a href="#page-29-6">[26]</a>. The initial motivation for using these results was, in fact, to compute tight upper bounds on the ideal degree D<sup>I</sup> , as these bounds are instrumental to estimate the change-of-ordering step. Finally, when the genericity assumptions required by the CheapLunch framework do not hold, our work still provides (loose) upper bounds on D<sup>I</sup> . We find these to be valuable in cases where such bounds were either entirely missing, or purely experimentally derived.</p>

    <p class="text-gray-300">We have applied our framework to a number of primitives, all backed by experiments<a href="#page-2-1">6</a> . The underlying genericity assumptions are verified for Poseidon,</p>

    <p class="text-gray-300"><sup>5</sup> As in the instances of Poseidon2 used in the <a href="https://www.poseidon-initiative.info/" target="_blank" rel="noopener noreferrer">Ethereum bounty program.</a></p>

    <p class="text-gray-300"><sup>6</sup> Our code is available at <a href="https://github.com/atharva-simulauib/algebraic-cheaplunch" target="_blank" rel="noopener noreferrer">https://github.com/atharva-simulauib/</a> <a href="https://github.com/atharva-simulauib/algebraic-cheaplunch" target="_blank" rel="noopener noreferrer">algebraic-cheaplunch</a></p>

    <p class="text-gray-300">NEPTUNE and XHash8. As a particular contribution, we provide a new modeling for the CICO-k problem for the two former primitives, to which our framework can be applied and prove bounds on the ideal degree that were first claimed in [11]. We note that the results on POSEIDON are especially timely due to the ongoing cryptanalysis initiative organized by the Ethereum Foundation (see the earlier footnote). We also apply the CheapLunch framework to GRIFFIN and ArionHash, although we find that the genericity assumptions are not satisfied for these primitives. Our results are summarized in Table 1.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Primitive</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">D_I \\le</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Cheap GB</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">source</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(d+2)^{k\\cdot R}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#10003;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[17]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">XHash8 <span class="math">(k + n_S \\le t)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(d^{n_S+2k})^R</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#10003;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Section 4.1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Poseidon</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">d^{k \\cdot R_F + R_P}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#10003;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Section 4.2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Neptune</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">4^{k \\cdot R_F} \\cdot d^{R_P \\dagger} \\atop 4^{(k-1)R_{f,1} + R_{f,2}} \\cdot d^{R_P - (t-k) \\ddagger}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Section 4.2<br>Section 4.3</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">GRIFFIN</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(d^2 \\cdot 3^k)^R</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">X</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Section 5.1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ArionHash</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(16)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">X</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Section 5.2</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;&dagger;</sup>Sponge mode, without round skipping tricks.</p>

    <p class="text-gray-300"><sup>&Dagger;</sup>Preimage on k output coordinates in compression mode, with subspace trails. <strong>Table 1.</strong> Ideal degree  <span class="math">D_I</span>  and applicability of the CheapLunch method to solve CICO-k on several primitives, where t is the number of branches, d is the degree of the monomial power maps, and R is the number of rounds ( <span class="math">R_F</span>  for full rounds and  <span class="math">R_P</span>  for partial rounds for Poseidon and Neptune), without considering round-skipping tricks.</p>

    <p class="text-gray-300">Outline. We provide background on the CICO problem in sponge hash functions, Gr&ouml;bner bases and weighted systems in Section 2. Our approach is presented in Section 3, where we define CheapLunch systems and then detail how to perform and analyze the two solving steps when these systems satisfy the genericity assumptions of above. We provide applications where these assumptions are verified in Section 4, and conclude with cases where they are not in Section 5.</p>

    </section>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 Preliminaries</h2>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8">2.1 CICO problem</h3>

    <p class="text-gray-300">The main focus of this work will be the analysis of AO hash functions using the sponge construction [14]. These sponges are, in our setting, typically instantiated via AO permutations  <span class="math">F: \\mathbb{F}_q^t \\to \\mathbb{F}_q^t</span>  (where  <span class="math">\\mathbb{F}_q</span>  is a finite field). A crucial</p>

    <p class="text-gray-300">security requirement for these constructions is for the underlying permutation to be secure with respect to the <em>Constrained-Input Constrained-Output</em> (CICO) problem. For algebraic cryptanalysis, this problem is typically defined as follows.</p>

    <p class="text-gray-300"><strong>Definition 1 (CICO-(</strong>IN,OUT) <strong>Problem).</strong> Let  <span class="math">F: \\mathbb{F}_q^t \\longrightarrow \\mathbb{F}_q^t</span>  be a permutation and let  <span class="math">1 \\leq \\text{IN,OUT} &lt; t</span>  such that  <span class="math">\\text{IN} + \\text{OUT} \\leq t</span> . The CICO-(IN,OUT) problem asks to find  <span class="math">\\mathbf{x} \\in \\{0\\}^{\\text{IN}} \\times \\mathbb{F}_q^{t-\\text{IN}}</span>  such that  <span class="math">F(\\mathbf{x}) \\in \\{0\\}^{\\text{OUT}} \\times \\mathbb{F}_q^{t-\\text{OUT}}</span> .</p>

    <p class="text-gray-300">Said differently, a CICO-(IN,OUT) instance is a CICO instance where out output constraints of F need to be satisfied through the choice of t &ndash; IN degrees of freedom in the input. We recall the sponge construction and discuss how CICO problems are related to concrete hash function attacks in Appendix A. When IN = OUT = k, we simply use the notation CICO-k.</p>

    <p class="text-gray-300">As mentioned in the introduction, the majority of recent algebraic cryptanalyses focuses on the CICO-1 case, with the exception of [17] in the case of Anemoi. In the works of [7,47,8], the condition OUT = 1 (or IN = 1 if  <span class="math">F^{-1}</span>  is considered) is a requirement for the applicability of their attacks and no straightforward adaptation exists for larger OUT values. We also note that other works relying on extrapolating scaled-down experiments [9,40] pragmatically target CICO-1, as the CICO problem is easier in this setting and thus allows more reliable extrapolations. In this work, however, we will tackle the general CICO-(IN,OUT) problem with IN <span class="math">\\geq</span>  2 and OUT <span class="math">\\geq</span>  2 for various permutations, through both theoretical arguments and extensive experiments.</p>

    <p class="text-gray-300">The initial step in our attacks is to model a given CICO problem as a system of multivariate polynomial equations whose common solution(s) correspond to the solution(s) of this problem. Possible modelings will be further explored in Section 4 and 5, while the rest of Section 2 is devoted to solving tools.</p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8">2.2 Polynomial system solving via Gr&ouml;bner bases</h3>

    <p class="text-gray-300">Let  <span class="math">\\{P_1,\\ldots,P_m\\}\\subset\\mathbb{F}[x_1,\\ldots,x_n]</span>  be a polynomial system over a field  <span class="math">\\mathbb{F}</span>  and let  <span class="math">I=\\langle P_1,\\ldots,P_m\\rangle</span>  be its associated ideal. An essential tool for computing with I &ndash; which will ultimately allow us to solve  <span class="math">\\{P_1,\\ldots,P_m\\}</span>  &ndash; is that of Gr&ouml;bner bases, which are defined up to a choice of monomial ordering. A monomial ordering is a well-order on  <span class="math">\\mathbb{N}^n</span>  such that if  <span class="math">\\alpha \\prec \\beta</span> , then  <span class="math">\\alpha + \\gamma \\prec \\beta + \\gamma</span>  for  <span class="math">\\gamma \\in \\mathbb{N}^n</span> . We say that  <span class="math">x^{\\alpha} \\prec x^{\\beta}</span>  if  <span class="math">\\alpha \\prec \\beta</span> . In this paper, we will make use of the three following monomial orderings:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Lexicographical (lex): We have  <span class="math">\\alpha \\prec_{lex} \\beta</span>  if there exists an index  <span class="math">1 \\leq i \\leq n</span>  such that  <span class="math">\\alpha_j = \\beta_j</span> , j &lt; i and  <span class="math">\\alpha_i &lt; \\beta_i</span> .</li>
      <li>Weighted graded reverse lexicographical (wgrevlex): Let  <span class="math">w \\in \\mathbb{R}^n_{\\geq 0}</span>  a weight vector. We have that  <span class="math">\\alpha \\prec_w \\beta</span>  if  <span class="math">\\sum_{i=1}^n w_i \\alpha_i &lt; \\sum_{i=1}^n w_i \\beta_i</span>  or  <span class="math">\\sum_{i=1}^n w_i \\alpha_i = \\sum_{i=1}^n w_i \\beta_i</span>  and  <span class="math">\\alpha \\succ_{lex} \\beta</span>  (note that we take the reversed lexicographical order in the case where the two monomials have the same weight).</li>
      <li>Graded reverse lexicographical (grevlex): This order is a particular case of the wgrevlex ordering, in the case where w = (1, ..., 1).</li>
    </ul>

    <p class="text-gray-300">For a polynomial P, we denote by  <span class="math">LM_{\\prec}(P)</span>  its leading monomial with respect to  <span class="math">\\prec</span>  and by  <span class="math">P^{\\text{top}}</span>  its homogeneous component of highest weight with respect to a given weight vector w.</p>

    <p class="text-gray-300"><strong>Definition 2 (Gr&ouml;bner Basis).</strong> A Gr&ouml;bner basis of I with respect to a monomial ordering  <span class="math">\\prec</span> , also referred to as a  <span class="math">\\prec</span> -Gr&ouml;bner basis of I, is a set of polynomials  <span class="math">G \\subset I</span>  such that</p>

    <p class="text-gray-300">
<span class="math">$\\langle \\mathrm{LM}_{\\prec}(h) \\mid h \\in I \\rangle = \\langle \\mathrm{LM}_{\\prec}(g) \\mid g \\in G \\rangle := \\langle LM(G) \\rangle \\ .</span>$</p>

    <p class="text-gray-300">We moreover say that G is reduced if every  <span class="math">g \\in G</span>  is monic, and does not contain any monomial in  <span class="math">LM_{\\prec}(G \\setminus \\{g\\})</span> .</p>

    <p class="text-gray-300">From the knowledge of a Gr&ouml;bner basis of an ideal, one can perform <em>reductions</em> modulo this ideal. For a polynomial P and a system G that is a  <span class="math">\\prec</span> -Gr&ouml;bner basis, we denote by  <span class="math">\\operatorname{Red}_{G,\\prec}(P)</span>  its reduction modulo  <span class="math">I=\\langle G\\rangle</span>  using the ordering  <span class="math">\\prec</span> , i.e., the only polynomial in P+I which contains no monomial in  <span class="math">\\langle \\operatorname{LM}_{\\prec}(h) \\mid h \\in I \\rangle</span> .</p>

    <p class="text-gray-300">Due to the elimination property of the lex ordering, we know that the (reduced) Gr&ouml;bner basis of a zero-dimensional ideal contains a univariate polynomial  <span class="math">G_n</span>  in  <span class="math">x_n</span> , and we can solve the remaining system efficiently from its roots. Note that some recent cryptanalyses of Anemoi [40,17] have put emphasis on the extra property that the ideal is in shape position [30] to facilitate this remaining solving process. Although it helps simplify the approach, and while this property is generic for radical zero-dimensional ideals [10], it is not strictly needed in our setting. Indeed, while the number of variables n in the system may be fairly large, we are usually interested in solving CICO-(IN,OUT) problems, in which we only need to recover at most IN variables. Furthermore, we expect a significant reduction in complexity as more of these variables are recovered. We may thus summarize the main steps of solving a zero-dimensional ideal I as:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Find a Gr&ouml;bner basis of I for a suitable monomial order.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Convert this Gr&ouml;bner basis into a Gr&ouml;bner basis in the <em>lex</em> order.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Solve the polynomial  <span class="math">G_n</span>  and recover the solutions.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">In the general case, we expect Step 1. to be the bottleneck in solving I, with grevlex chosen as the default order as it is usually the most efficient in practice to compute Gr&ouml;bner bases. However, this is not necessarily true for the AO setting, where Step 1. can sometimes be made trivial through the use of weighted orders tailored to the underlying permutation [7]. In this case, we naturally expect Step 2. to form the bottleneck of the solving method. Indeed, either way, we typically expect that Step 3. will be negligible compared to the first two steps.</p>

      <h3 id="sec-2.3" class="text-xl font-semibold mt-8">2.3 Gr&ouml;bner bases for weighted homogeneous systems</h3>

    <p class="text-gray-300">Our approach will make use of a tailored wgrevlex ordering for the first Gr&ouml;bner basis computation. While the analysis of Gr&ouml;bner basis algorithms with respect to graded monomial orders (i.e., w = (1, ..., 1)) is well-known among experts</p>

    <p class="text-gray-300">in algebraic cryptanalysis when applied to generic systems, we anticipate that readers may be less familiar with the case of more general weight vectors w; the analysis of which has been mainly restricted to the computer algebra literature [25,26]. We therefore devote this subsection to survey the results from this area that will be useful to us. As in the graded case, it seems that tighter complexity bounds are known for Gr&ouml;bner basis algorithms applied to weighted homogeneous systems than to affine ones. In fact, if our affine CICO modeling satisfies a regularity condition detailed below, we will see that finding a first Gr&ouml;bner basis reduces to computing a Gr&ouml;bner basis for the homogeneous components of maximal weighted degree. As such, we do not focus on the affine case here, and will return to it in Section 5 when this condition does not apply.</p>

    <p class="text-gray-300">For homogeneous systems, it is known that a grevlex Gr&ouml;bner basis can be computed incrementally by performing row reduction on homogeneous Macaulay matrices up to some degree D using Lazard's approach [42]. Note that state-of-the-art Gr&ouml;bner basis algorithms [19,20] follow the same framework. In [25,26], these algorithms have been adapted to a weighted homogeneous system  <span class="math">\\mathcal P</span>  by observing that for any polynomial P that is homogeneous with respect to w, the polynomial  <span class="math">\\hom_w(P) := P(x_1^{w_1}, \\dots, x_n^{w_n})</span>  is homogeneous in the usual sense. For instance, their approach is to apply [19,20] to the system</p>

    <p class="text-gray-300"><span class="math">$hom_w(\\mathcal{P}) = \\{hom_w(P_1), \\dots, hom_w(P_m)\\},\\</span>$</p>

    <p class="text-gray-300">without requiring any modifications, and then to deduce from the grevlex Gr&ouml;bner basis of  <span class="math">\\hom_w(\\mathcal{P})</span>  the desired reduced Gr&ouml;bner basis for  <span class="math">\\mathcal{P}</span>  [26, Proposition 10]. This method leverages the structure of  <span class="math">\\mathcal{P}</span> , as it does not consider all the homogeneous Macaulay matrices associated to the system.</p>

    <p class="text-gray-300"><strong>Definition 3 (Weighted homogeneous Macaulay matrix).</strong> Let  <span class="math">\\mathcal{P} \\subset \\mathbb{F}[\\mathbf{x}]</span>  be a system that is weighted homogeneous with respect to a weight vector w. The associated weighted homogeneous Macaulay matrix of weight D is the matrix whose rows represent the polynomials  <span class="math">x^{\\alpha}P_i</span> ,  <span class="math">\\operatorname{wt}(x^{\\alpha}P_i) = D</span>  and the columns represent the monomials of weight D. The coefficient  <span class="math">((\\alpha, i), \\beta)</span>  is equal to the coefficient of  <span class="math">x^{\\beta}</span>  in  <span class="math">x^{\\alpha}P_i</span> .</p>

    <p class="text-gray-300">The approach of [26] can equivalently be viewed as performing row reduction on Macaulay matrices of this kind up to a certain degree, referred to as the weighted degree of regularity  <span class="math">wd_{reg}</span> .</p>

    <p class="text-gray-300"><strong>Definition 4 (Weighted degree of regularity, Definition 2 in [26]).</strong> The weighted degree of regularity of a weighted homogeneous system  <span class="math">\\mathcal{P}</span> , denoted  <span class="math">wd_{reg}</span> , is the lowest degree D such that the rowspan of the Macaulay matrices of weight  <span class="math">d \\leq D</span>  contains a wgrevlex Gr&ouml;bner basis of  <span class="math">\\mathcal{P}</span> .</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;7</sup> The only exception that we are aware of is [22], which applied to methods of [25] in elliptic curve cryptanalysis.</p>

    <p class="text-gray-300">If  <span class="math">w_1, \\ldots, w_n</span>  denote the respective weights of  <span class="math">x_1, \\ldots, x_n</span> , then the number of entries in the weighted Macaulay matrices can be bounded by</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{SD}(wd_{\\text{reg}}; (\\mathbf{w}, 1)) := \\# \\left\\{ (a_1, \\dots, a_n) \\in \\mathbb{N}^n \\mid \\sum_{i=1}^n w_i \\cdot a_i \\le wd_{\\text{reg}} \\right\\} , \\quad (1)</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\mathcal{SD}</span>  is known as the <em>Sylvester denumerant</em>. There is no analytic formula for this value, but it can be computed exactly using the generating series in [1, Theorem 4.1.2]. For our purposes, it will be sufficient to approximate this value (as in [26, Section 5]) and estimate the complexity of computing a <em>wgrevlex</em> Gr&ouml;bner basis for a weighted homogeneous system  <span class="math">\\mathcal{P}</span>  of m polynomials in n variables by</p>

    <p class="text-gray-300">
<span class="math">$\\mathcal{O}\\left(\\left(\\frac{1}{\\prod_{i=1}^{n} w_i}\\right)^{\\omega} \\binom{n + w d_{\\text{reg}}}{n}^{\\omega}\\right),\\tag{2}</span>$</p>

    <p class="text-gray-300">where  <span class="math">2 \\le \\omega \\le 3</span>  is the linear algebra constant and  <span class="math">wd_{\\rm reg}</span>  is the weighted degree of regularity. This estimate calls for tight upper bounds on  <span class="math">wd_{\\rm reg}</span> . Such bounds are known under standard genericity assumptions used for graded systems, by taking into account the extra weight condition. The first of these is as follows.</p>

    <p class="text-gray-300"><strong>Definition 5 (Regular sequence, Definition 4 in [26]).</strong> Let  <span class="math">(w_1, \\ldots, w_n)</span>  be a system of weights and let  <span class="math">\\mathcal{P} = (P_1, \\ldots, P_m) \\subset \\mathbb{F}[x_1, \\ldots, x_n]</span>  be a sequence of weighted homogeneous polynomials of respective weighted degrees  <span class="math">d_1, \\ldots, d_m</span> . The sequence  <span class="math">\\mathcal{P}</span>  is said to be regular in  <span class="math">\\mathbb{F}[x_1, \\ldots, x_n]</span>  if it satisfies one of the following equivalent properties</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\forall i \\in \\{1..m\\}, P_i \\text{ is not a zero divisor in } \\mathbb{F}[x_1, \\ldots, x_n]/\\langle P_1, \\ldots, P_{i-1} \\rangle;</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The Hilbert series of the ideal generated by P is equal to</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\mathcal{H}_{\\mathbb{F}[x_1,\\dots,x_n]/\\langle \\mathcal{P} \\rangle}(z) = \\frac{\\prod_{i=1}^m (1 - z^{d_i})}{\\prod_{i=1}^n (1 - z^{w_i})}.</span>$
(3)</p>

    <p class="text-gray-300">Remark 1. Both of the equivalent conditions above will be useful to us. Indeed, we will use Condition 1. for complexity estimates and theoretical arguments on regularity, while we will adopt Condition 2. in experimental verification.</p>

    <p class="text-gray-300">For a regular sequence  <span class="math">\\mathcal{P}</span> , the weighted degree of regularity can be upper bounded by the weighted Macaulay bound [25, Theorem 2]:</p>

    <p class="text-gray-300">
<span class="math">$wd_{\\text{reg}} \\le \\sum_{i=1}^{n} (d_i - w_i) + \\max\\{w_i\\}.</span>$
(4)</p>

    <p class="text-gray-300">This bound can be further sharpened if the sequence  <span class="math">\\mathcal{P}</span>  satisfies the following slightly stronger property.</p>

    <p class="text-gray-300"><strong>Definition 6 (Simultaneous Noether Position (Determined Case)).</strong> Let  <span class="math">\\mathcal{P} = (P_1, \\ldots, P_n)</span>  be a polynomial sequence in  <span class="math">\\mathbb{F}[x_1, \\ldots, x_n]</span> . We say that  <span class="math">\\mathcal{P}</span>  is in Simultaneous Noether Position (SNP) if for all  <span class="math">1 \\leq i \\leq n</span> , the projected sequence  <span class="math">(P_1(x_1, \\ldots, x_i, 0, \\ldots, 0), \\ldots, P_i(x_1, \\ldots, x_i, 0, \\ldots, 0))</span>  is regular over  <span class="math">\\mathbb{F}[x_1, \\ldots, x_i]</span> .</p>

    <p class="text-gray-300">If the sequence  <span class="math">\\mathcal{P}</span>  is in SNP, and its weighted degrees satisfy a certain condition relative to w, the following upper bound on  <span class="math">wd_{\\text{reg}}</span>  holds.</p>

    <p class="text-gray-300"><strong>Theorem 1 (Theorem 12 in [26]).</strong> Let  <span class="math">(w_1, \\ldots, w_n)</span>  be a system of weights and let  <span class="math">\\mathcal{P} = (P_1, \\ldots, P_m)</span>  be a sequence of weighted homogeneous polynomials of respective weighted degrees  <span class="math">d_1, \\ldots, d_m</span>  such that  <span class="math">d_i</span>  is divisible by  <span class="math">w_i</span>  for any  <span class="math">1 \\leq i \\leq n</span>  and  <span class="math">d_i \\geq w_{i-1}</span>  for any  <span class="math">2 \\leq i \\leq n</span> . Assume that the sequence  <span class="math">\\mathcal{P}</span>  is in SNP for the variable ordering  <span class="math">x_1 &gt; \\cdots &gt; x_n</span> . Then the weighted degree of regularity of  <span class="math">\\mathcal{P}</span>  is bounded by</p>

    <p class="text-gray-300"><span class="math">$wd_{\\text{reg}} \\le \\sum_{i=1}^{n} (d_i - w_i) + w_n.</span>$</p>

      <h3 id="sec-2.4" class="text-xl font-semibold mt-8">2.4 Ideal degree for weighted homogeneous systems</h3>

    <p class="text-gray-300">The complexity of the change-of-order algorithms used in the second step in the solving method presented in Section 2.2 is polynomial in the <em>degree of the ideal</em>, which we define in the following. A lengthier discussion on these algorithms will be provided in Appendix C.</p>

    <p class="text-gray-300"><strong>Definition 7 (Ideal degree).</strong> For a zero-dimensional ideal  <span class="math">I \\subset \\mathbb{F}[x_1, \\ldots, x_n]</span> , the ideal degree  <span class="math">D_I</span>  is the dimension of the  <span class="math">\\mathbb{F}</span> -vector space  <span class="math">\\mathbb{F}[x_1, \\ldots, x_n]/I</span> .</p>

    <p class="text-gray-300">For weighted homogeneous systems, the ideal degree can be upper bounded using the weighted B&eacute;zout bound  <span class="math">\\,</span></p>

    <p class="text-gray-300">
<span class="math">$D_I \\le \\frac{\\prod_{i=1}^n d_i}{\\prod_{i=1}^n w_i},\\tag{5}</span>$</p>

    <p class="text-gray-300">that can be seen as a particular case of the BKK bound [12,39,41]. We will not discuss equality cases here, though we note that they do arise in particular when the input sequence is regular. For example, the following result is derived in [25, Theorem 2] by evaluating the Hilbert series of Definition 5 with m = n at z = 1.</p>

    <p class="text-gray-300">Theorem 2 (Weighted B&eacute;zout equality in the regular case, Theorem 2 in [25]). Let  <span class="math">(w_1, \\ldots, w_n)</span>  be a system of weights and let  <span class="math">\\mathcal{P} = (P_1, \\ldots, P_n)</span>  be a sequence of weighted homogeneous polynomials of respective weighted degrees  <span class="math">d_1, \\ldots, d_n</span>  which is also regular. Then, the degree of the ideal  <span class="math">\\langle \\mathcal{P} \\rangle</span>  is equal to the weighted B&eacute;zout bound:</p>

    <p class="text-gray-300"><span class="math">$D_{\\langle \\mathcal{P} \\rangle} = \\frac{\\prod_{i=1}^{n} d_i}{\\prod_{i=1}^{n} w_i}.</span>$</p>

    <p class="text-gray-300">For an affine system  <span class="math">\\mathcal{P}</span>  whose components of highest weight form a homogeneous regular sequence, it is explained at the end of [26, &sect;5.2] that one can use the same bound in the complexity estimates.</p>

    </section>

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3 The CheapLunch Framework for Solving CICO-k</h2>

    <p class="text-gray-300">The CICO modeling we consider is akin to that of [7, Section 3]. We recall its generation in Section 3.1 on a toy example. The rationale behind our approach is to pick a certain weighted monomial order for which we can precisely analyze the first Gr&ouml;bner basis computation for several ciphers, and which allowed us to find tighter upper bounds on the ideal degree.</p>

    <p class="text-gray-300">To find a first Gr&ouml;bner basis, we observe that this order effectively splits our modeling into two parts: one part  <span class="math">\\mathcal{Q}</span>  for which we will compute a Gr&ouml;bner basis  <span class="math">G(\\mathcal{Q})</span>  and one part  <span class="math">\\mathcal{P}</span>  whose leading monomials will be coprime to those of  <span class="math">G(\\mathcal{Q})</span> , whenever  <span class="math">\\mathcal{Q}^{\\text{top}}</span>  is regular. Using Propositions 3 and 4 from Appendix A.1), the system  <span class="math">\\mathcal{P} \\cup G(\\mathcal{Q})</span>  is then a Gr&ouml;bner basis, making the computation of  <span class="math">G(\\mathcal{Q})</span>  the only non-trivial task in our first step. Note that the use of tailored monomial orders to ensure coprimality among the leading terms of polynomials has already been studied in [7,47] for the AO setting. However, when  <span class="math">\\mathcal{Q}^{\\text{top}}</span>  is not regular, one cannot apply the same Gr&ouml;bner basis approach.</p>

    <p class="text-gray-300">In the change of ordering step, we also use this weighted structure in order to give tight upper bounds on the ideal degree  <span class="math">D_I</span>  and to marginally improve generic FGLM estimates (Section 3.5 and Appendix C).</p>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8">3.1 Toy example</h3>

    <p class="text-gray-300">Recall that we are interested in solving the CICO-(IN,OUT) problem (Definition 1) for an AO permutation  <span class="math">F: \\mathbb{F}^t \\to \\mathbb{F}^t</span> . For the purposes of illustration, we set t-IN = OUT = k, that is, we want to solve for  <span class="math">x_1, \\ldots, x_k</span>  such that  <span class="math">F(\\underbrace{0,\\ldots,0}_{t-k},\\underbrace{x_1,\\ldots,x_k}_k) = \\underbrace{(0,\\ldots,0}_{k},\\underbrace{*,\\ldots,*}_{t-k})</span> . Furthermore, let F be of the form</p>

    <p class="text-gray-300"><span class="math">$F = A_r \\circ S \\circ A_{r-1} \\circ S \\circ \\cdots \\circ S \\circ A_0</span>$</p>

    <p class="text-gray-300">where  <span class="math">A_i: \\mathbb{F}^t \\to \\mathbb{F}^t</span>  is an invertible, affine mapping for  <span class="math">0 \\leq i \\leq r</span> , and</p>

    <p class="text-gray-300"><span class="math">$S: (z_1,\\ldots,z_t) \\longmapsto \\left(z_1^{1/\\alpha},f_2(z_1,\\ldots,z_t),\\ldots,f_t(z_1,\\ldots,z_t)\\right),</span>$</p>

    <p class="text-gray-300">where  <span class="math">f_2, \\ldots, f_t</span>  are polynomials of degree d, and  <span class="math">\\alpha &gt; 1</span>  is an integer such that the power  <span class="math">1/\\alpha</span>  forms an inverse map over  <span class="math">\\mathbb{F}</span> . To ensure both efficiency and a high overall degree, the integers d and  <span class="math">\\alpha</span>  are typically be chosen to be small, while  <span class="math">1/\\alpha</span>  is large (as a power over  <span class="math">\\mathbb{F}</span> ).</p>

    <p class="text-gray-300"><strong>Polynomial modeling.</strong> The modeling we consider is (a slight generalization of) the modeling considered in [7, Section 3]. The idea is to symbolically evaluate the permutation F round by round from the initial <strong>x</strong>-variables  <span class="math">x_1, \\ldots, x_k</span> , and only introduce new <strong>y</strong>-variables and equations to circumvent the large degree caused by the power  <span class="math">1/\\alpha</span> . More concretely, write  <span class="math">(h_1, \\ldots, h_t)</span>  for the symbolic evaluation of the state before the  <span class="math">\\ell</span> -th S-box, where each  <span class="math">h_i</span>  is a polynomial in</p>

    <p class="text-gray-300">the variables  <span class="math">\\mathbf{x}, y_1, \\dots, y_{\\ell-1}</span> . The first entry in the output state is represented by a new variable  <span class="math">y_{\\ell}</span> , while the remaining entries are defined by symbolic evaluation of the input state. The output of the S-box is</p>

    <p class="text-gray-300">
<span class="math">$(y_{\\ell}, f_2(h_1, \\ldots, h_t), \\ldots, f_t(h_1, \\ldots, h_t)),</span>$</p>

    <p class="text-gray-300">and the equation relating the new variable  <span class="math">y_{\\ell}</span>  to the earlier input state is</p>

    <p class="text-gray-300"><span class="math">$P_{\\ell}(\\mathbf{x}, y_1, \\dots, y_{\\ell}) = y_{\\ell}^{\\alpha} - h_1(\\mathbf{x}, y_1, \\dots, y_{\\ell-1}),</span>$
(6)</p>

    <p class="text-gray-300">which is added to the polynomial system. This construction yields a system of k+r polynomials over  <span class="math">\\mathbb{F}[\\mathbf{x},\\mathbf{y}]</span> , where  <span class="math">\\mathbf{y}:=y_1,\\ldots,y_r</span> . This system can further be divided into two parts:  <span class="math">\\mathcal{P}=\\{P_1,\\ldots,P_r\\}</span>  which are the round polynomials as described in (6), and  <span class="math">\\mathcal{Q}=\\{Q_1,\\ldots,Q_k\\}</span>  which are given by the symbolic state of the k first outputs of F, which we require to be zero. Note that the polynomials in  <span class="math">\\mathcal{Q}</span>  will depend on all variables  <span class="math">\\mathbf{x}, \\mathbf{y}</span>  and generically be of degree  <span class="math">d^r</span> . The equations  <span class="math">P_i</span>  will be of degree  <span class="math">d^i</span> , and contain the variables  <span class="math">\\mathbf{x}, y_1, \\ldots y_\\ell</span> .</p>

    <p class="text-gray-300"><strong>Monomial ordering.</strong> The idea of [7] was to choose a weighted order in which  <span class="math">y_i^{\\alpha}</span>  is the leading term of  <span class="math">P_i</span> . To achieve this, we consider a weight vector  <span class="math">w = (w_{\\mathbf{x}}, w_{\\mathbf{y}})</span> , where  <span class="math">w_{\\mathbf{x}} \\in \\mathbb{Z}^k</span>  and  <span class="math">w_{\\mathbf{y}} \\in \\mathbb{Z}^r</span>  encode the weight of the <strong>x</strong>- and <strong>y</strong>-variables, respectively. Following [7], we choose  <span class="math">w_{\\mathbf{x}} = (1, \\ldots, 1)</span>  and  <span class="math">w_{\\mathbf{y}} = (1, d, d^2, \\ldots, d^{r-1})</span> . On the one hand, examining the weighted degree of  <span class="math">P_{\\ell}</span>  in Equation (6) yields</p>

    <p class="text-gray-300"><span class="math">$\\operatorname{wt}(h_1) \\le d^{\\ell-1} &lt; \\alpha d^{\\ell-1} = \\operatorname{wt}(y_{\\ell}^{\\alpha}),</span>$</p>

    <p class="text-gray-300">which ensures that  <span class="math">\\mathrm{LM}(P_\\ell) = y_\\ell^\\alpha</span> , for all  <span class="math">1 \\leq \\ell \\leq r</span> . On the other hand, the polynomials in  <span class="math">\\mathcal{Q}</span>  will have weight at most  <span class="math">d^r</span> , which can only be achieved by monomials in pure  <span class="math">\\mathbf{x}</span> -variables. Thus, we generically expect the leading monomials in the  <span class="math">Q_i</span> -polynomials to only depend on  <span class="math">\\mathbf{x}</span> . In particular, we expect  <span class="math">\\mathrm{LM}(Q_1) = x_1^{d^r}</span>  when k = 1, which implies that all polynomials in  <span class="math">\\{\\mathcal{P}, Q_1\\}</span>  have coprime leading terms under this monomial order, and hence form a Gr&ouml;bner basis for the associated ideal by Proposition 4. In fact, this particular case readily corresponds to the FreeLunch setting of [7].</p>

    <p class="text-gray-300">The Case of  <span class="math">k \\geq 2</span> . When  <span class="math">k \\geq 2</span> , one can no longer directly apply the above reasoning, as the leading monomials in the polynomials  <span class="math">\\mathcal{Q}</span>  can no longer be expected to be coprime (although they still only depend on  <span class="math">\\mathbf{x}</span>  under the above weight vector  <span class="math">\\mathbf{w}</span> ). Moreover, since all variables  <span class="math">\\mathbf{x}</span>  are introduced at the start, and are presumable efficiently mixed throughout the application of F, it seems very unlikely that there will exist combinations of polynomial modelings and monomial orders that will yield a direct Gr&ouml;bner basis without any computation. Still, we note that the above modeling  <span class="math">\\{\\mathcal{P},\\mathcal{Q}\\}</span>  yields a portion of the polynomials,  <span class="math">\\mathcal{P}</span> , whose leading monomials are well-behaved and coprime with respect to  <span class="math">\\mathbf{y}</span>  and the other polynomials. In particular, if the Gr&ouml;bner basis  <span class="math">G(\\mathcal{Q})</span>  were to contain leading monomials only involving  <span class="math">\\mathbf{x}</span> , the above approach could be adapted.</p>

    <p class="text-gray-300">We will see that this scenario occurs whenever the system  <span class="math">\\mathcal{Q}^{\\text{top}}</span>  formed by the components of highest weight in  <span class="math">\\mathcal{Q}</span>  is regular in the sense of Definition 5 (to achieve this, we may possibly refine the modeling of  <span class="math">\\mathcal{Q}</span>  and carefully choosing  <span class="math">w_{\\mathbf{x}}</span> ). In this case, we can essentially reduce the problem of Gr&ouml;bner basis computation for the whole system  <span class="math">\\{\\mathcal{P},\\mathcal{Q}\\}\\subset R:=\\mathbb{F}[\\mathbf{x},\\mathbf{y}]</span>  to the well-understood problem of Gr&ouml;bner basis computation of the weighted regular system  <span class="math">\\mathcal{Q}^{\\text{top}}</span>  in the polynomial subring  <span class="math">R_{\\mathbf{x}}:=\\mathbb{F}[\\mathbf{x}]</span> .</p>

    <p class="text-gray-300">Definition 8 formalizes the type of polynomial system illustrated in our toy example, that will be the focus of our work. Note again that FreeLunch systems as introduced in [7] correspond to the case m=1 in this definition.</p>

    <p class="text-gray-300"><strong>Definition 8 (CheapLunch system (CLS)).</strong> Let  <span class="math">m, n \\geq 0</span>  and  <span class="math">R = \\mathbb{F}[x_1, \\ldots, x_m, y_1, \\ldots, y_n]</span>  be a ring with a weighted monomial ordering w. We say that the polynomials  <span class="math">P_1, \\ldots, P_n, Q_1, \\ldots, Q_m \\in R</span>  form a CheapLunch system (CLS) if the following is satisfied.</p>

    <p class="text-gray-300">
<span class="math">$\\begin{split} \\operatorname{LM}(P_j) &amp;= y_j^{\\alpha_j}, \\ \\alpha_j \\geq 1, \\ \\text{for all} \\ 1 \\leq j \\leq n, \\\\ Q_i^{\\operatorname{top}} &amp;\\in \\mathbb{F}[x_1, \\dots, x_m] \\ \\text{for all} \\ 1 \\leq i \\leq m. \\end{split}</span>$</p>

    <p class="text-gray-300">We moreover write  <span class="math">\\mathcal{P} = (P_1, \\dots, P_n)</span>  and  <span class="math">\\mathcal{Q} = (Q_1, \\dots, Q_m)</span> .</p>

    <p class="text-gray-300">Motivated by the above discussion, the rest of Section 3 will study the solving of CheapLunch systems for which the top part  <span class="math">\\mathcal{Q}^{\\text{top}}</span>  is regular. Non-regular CheapLunch systems arising from some AO hash functions are tackled in Section 5.</p>

    <p class="text-gray-300"><strong>Definition 9 (Regular CheapLunch system).</strong> By slight abuse of terminology, we say that a CheapLunch system  <span class="math">\\{\\mathcal{P},\\mathcal{Q}\\}\\subset R</span>  is regular for a weight vector  <span class="math">w=(w_{\\mathbf{x}},w_{\\mathbf{y}})</span>  if the sequence  <span class="math">\\mathcal{Q}^{\\text{top}}</span>  formed by the components of highest weight in  <span class="math">\\mathcal{Q}</span>  is regular in  <span class="math">R_{\\mathbf{x}}</span>  in the sense of Definition 5 for the weight vector  <span class="math">w_{\\mathbf{x}}</span> .</p>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8">3.2 Gr&ouml;bner bases for regular CheapLunch systems</h3>

    <p class="text-gray-300">We now justify the first step of our solving method for regular CheapLunch systems. We will see that the regularity of  <span class="math">\\mathcal{Q}^{\\text{top}}</span>  plays a role much beyond its use in the estimate for computing  <span class="math">G(\\mathcal{Q}^{\\text{top}})</span> . As in the graded case, Lemma 1 below follows from the absence of degree falls in  <span class="math">\\mathcal{Q}</span>  when  <span class="math">\\mathcal{Q}^{\\text{top}}</span>  is weighted regular and shows that a Gr&ouml;bner basis  <span class="math">G(\\mathcal{Q})</span>  can be computed from that of  <span class="math">G(\\mathcal{Q}^{\\text{top}})</span> .</p>

    <p class="text-gray-300"><strong>Lemma 1.</strong> Let  <span class="math">Q = (Q_1, \\ldots, Q_m) \\subset \\mathbb{F}[x_1, \\ldots, x_m]</span>  be an affine sequence and let  <span class="math">\\prec</span>  be some (weighted) monomial order for which  <span class="math">Q^{\\text{top}}</span>  is regular. Suppose further that the set  <span class="math">\\{\\sum_{j=1}^m f_{ij} \\cdot Q_j^{\\text{top}}\\}_{1 \\leq i \\leq g}</span>  is a reduced  <span class="math">\\prec</span> -Gr&ouml;bner basis of  <span class="math">\\langle Q^{\\text{top}} \\rangle = \\langle Q_1^{\\text{top}}, \\ldots, Q_m^{\\text{top}} \\rangle</span> . Then we have that  <span class="math">\\{\\sum_{j=1}^m f_{ij}Q_j\\}_{1 \\leq i \\leq g}</span>  is a (not necessarily reduced)  <span class="math">\\prec</span> -Gr&ouml;bner basis for the inhomogeneous ideal  <span class="math">I = \\langle Q_1, \\ldots, Q_m \\rangle</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Using Definition 2, we want to show that  <span class="math">LM(h) \\in \\langle LM(\\sum_{j=1}^m f_{ij}Q_j) | 1 \\le i \\le g \\rangle</span>  for any element  <span class="math">h \\in I</span> . Without loss of generality, we can assume that h</p>

    <p class="text-gray-300">is of the form  <span class="math">h = \\sum_{j=1}^{m} h_j Q_j</span> , where  <span class="math">h_j</span>  is top-reduced by  <span class="math">\\langle Q_1, \\dots, Q_{j-1} \\rangle</span> . We can now rewrite h as follows:</p>

    <p class="text-gray-300"><span class="math">$h = \\sum_{j=1}^{m} h_j Q_j = \\sum_{j=1}^{m} h_j^{\\text{top}} Q_j^{\\text{top}} + \\sum_{j=1}^{m} (h_j - h_j^{\\text{top}}) Q_j^{\\text{top}} + \\sum_{j=1}^{m} h_j^{\\text{top}} (Q_j - Q_j^{\\text{top}}) + \\sum_{j=1}^{m} (h_j - h_j^{\\text{top}}) (Q_j - Q_j^{\\text{top}}) .</span>$</p>

    <p class="text-gray-300">We can distinguish two cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">Case  <span class="math">LM(h) = LM(\\sum_{j=1}^m h_j^{\\text{top}} Q_j^{\\text{top}})</span> . In this case,  <span class="math">\\sum_{j=1}^m h_j^{\\text{top}} Q_j^{\\text{top}} \\in \\langle \\mathcal{Q}^{\\text{top}} \\rangle</span> , hence  <span class="math">LM(h) \\in \\langle LM(\\sum_{j=1}^m f_{ij} Q_j^{\\text{top}}) \\mid 1 \\leq i \\leq g \\rangle</span> .</p></li>
      <li><p class="text-gray-300">Case  <span class="math">LM(h) \\neq LM(\\sum_{j=1}^m h_j^{\\text{top}} Q_j^{\\text{top}})</span> . As the other terms in the sum have lower weight, this implies that  <span class="math">\\sum_{j=1}^m h_j^{\\text{top}} Q_j^{\\text{top}} = 0</span> . Thus, there exist  <span class="math">1 \\leq i \\leq m</span>  such that  <span class="math">h_i^{\\text{top}} \\neq 0</span>  and  <span class="math">h_i^{\\text{top}} Q_i^{\\text{top}} \\in \\langle Q_{i-1}^{\\text{top}}, \\dots, Q_1^{\\text{top}} \\rangle</span> . As the sequence is regular, this implies that  <span class="math">h_i^{\\text{top}} \\in \\langle Q_{i-1}^{\\text{top}}, \\dots, Q_1^{\\text{top}} \\rangle</span> , which contradicts the assumption that  <span class="math">h_i</span>  is top-reduced by  <span class="math">\\langle Q_1, \\dots, Q_{i-1} \\rangle</span> .</p></li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Finally, Proposition 1 gives the structure of the Gr&ouml;bner basis for a regular CheapLunch system  <span class="math">\\{\\mathcal{P}, \\mathcal{Q}\\}</span> , obtained from  <span class="math">G(\\mathcal{Q})</span>  by simply appending the polynomials of  <span class="math">\\mathcal{P}</span> .</p>

    <p class="text-gray-300">Proposition 1 (Gr&ouml;bner basis of a regular CLS). Let  <span class="math">\\{\\mathcal{P}, \\mathcal{Q}\\}\\</span>  be a regular CheapLunch system with respect to a weighted monomial order  <span class="math">\\prec</span>  and let  <span class="math">G(\\mathcal{Q})</span> be a  <span class="math">\\prec</span> -Gr&ouml;bner basis of  <span class="math">\\mathcal{Q}</span> . Then, the set  <span class="math">G(\\mathcal{Q}) \\cup \\mathcal{P}</span>  is a  <span class="math">\\prec</span> -Gr&ouml;bner basis for the  <span class="math">ideal \\langle \\mathcal{P} \\rangle + \\langle \\mathcal{Q} \\rangle</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Using the proof of Lemma 1, we have that  <span class="math">\\langle LM(\\mathcal{Q})\\rangle = \\langle LM(\\mathcal{Q}^{\\text{top}})\\rangle</span>  as  <span class="math">\\mathcal{Q}^{\\text{top}}</span>  is weighted regular. In particular, this means that the leading monomials of the elements in  <span class="math">G(\\mathcal{Q})</span>  will be in  <span class="math">\\mathbb{F}[x_1,\\ldots,x_m]</span> . We can eventually apply Buchberger's Criterion (Proposition 3 in Appendix B) to any pair of distinct elements  <span class="math">f_1, f_2 \\in G(\\mathcal{Q}) \\cup \\mathcal{P}</span>  to conclude. First, if both  <span class="math">f_1</span>  and  <span class="math">f_2</span>  belong to  <span class="math">G(\\mathcal{Q})</span> , then  <span class="math">Spol(f_1, f_2)</span>  will reduce to 0 by applying this criterion in the reverse direction in the Gr&ouml;bner basis G(Q). Otherwise, if  <span class="math">f_1</span>  or  <span class="math">f_2</span>  is an element of P, then its leading monomial will, by Definition 8, be coprime to the leading monomial of the other element of the pair, and we can conclude by Proposition 4.</p>

    <h4 id="sec-misc-1" class="text-lg font-semibold mt-6">Gr&ouml;bner basis computation procedure 3.3</h4>

    <p class="text-gray-300">Lemma 1 and Proposition 1 suggest a natural way of computing a Gr&ouml;bner basis of a regular CheapLunch system  <span class="math">\\{\\mathcal{P},\\mathcal{Q}\\}</span> . The idea is to first compute a Gr&ouml;bner basis for  <span class="math">\\mathcal{Q}^{\\text{top}}</span>  over the subring  <span class="math">\\mathbb{F}[x_1,\\ldots,x_m]</span> , which can then be lifted to a Gr&ouml;bner basis for  <span class="math">(\\mathcal{P}, \\mathcal{Q})</span>  in the larger ring R. We proceed as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute homogeneous polynomials  <span class="math">\\{f_{ij}\\}\\subset \\mathbb{F}[x_1,\\ldots,x_m]</span>  such that</li>
    </ol>

    <p class="text-gray-300"><span class="math">$G(\\mathcal{Q}^{\\text{top}}) = \\left\\{ \\sum_{j=1}^{m} f_{ij} Q_j^{\\text{top}} \\right\\}_{1 \\le i \\le g}</span>$</p>

    <p class="text-gray-300">forms a reduced Gr&ouml;bner basis for  <span class="math">Q^{\\text{top}}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Using  <span class="math">\\{f_{ij}\\}</span> , multiply with the respective  <span class="math">Q_j</span> -polynomials to compute the set</li>
    </ol>

    <p class="text-gray-300"><span class="math">$G(\\mathcal{Q}) = \\left\\{ \\sum_{j=1}^{m} f_{ij} Q_j \\right\\}_{1 \\le i \\le g} .</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Return  <span class="math">G(\\mathcal{Q}) \\cup \\mathcal{P}</span>  as a Gr&ouml;bner basis for the full system.</li>
    </ol>

      <h3 id="sec-3.4" class="text-xl font-semibold mt-8">3.4 Complexity estimates</h3>

    <p class="text-gray-300">We now estimate the complexity of the method described in Section 3.3. We will assume that the system  <span class="math">\\{\\mathcal{P},\\mathcal{Q}\\}</span>  can be efficiently computed and fully reduced according to the relevant weighted order  <span class="math">\\prec</span>  for any given instance, as is required by Lemma 1. In particular, this means that for all  <span class="math">1 \\leq i \\leq m</span>  and  <span class="math">1 \\leq j \\leq n</span> , we have  <span class="math">\\deg_{y_i}(Q_j) &lt; \\alpha_i</span>  (as the monomials of higher  <span class="math">y_i</span> -degree can be reduced by the leading monomial of  <span class="math">P_i</span> ). A similar task has been studied and estimated under the name of SYSGEN in [8, Section 3], and we expect their work to translate to our use cases in a straightforward manner. The analysis of [8] further shows that, with a few minor exceptions, SYSGEN does not form the bottleneck of an attack, and we expect the same to hold in our case.</p>

    <p class="text-gray-300"><strong>Step 1.</strong> The first step of our procedure consists of computing a Gr&ouml;bner basis of  <span class="math">\\mathcal{Q}^{\\text{top}}</span>  over  <span class="math">\\mathbb{F}[x_1,\\ldots,x_m]</span> , i.e., a homogeneous system of m equations in m variables. To estimate the complexity of this step, we can readily use Equation (2) with n=m (determined case):</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{C}_1 = \\left(\\mathcal{SD}(wd_{\\text{reg}}; (\\mathbf{w}, 1))\\right)^{\\omega} \\approx \\left(\\frac{\\binom{wd_{\\text{reg}} + m}{m}}{\\prod_{i=1}^{m} w_i}\\right)^{\\omega} ,</span>$</p>

    <p class="text-gray-300">where  <span class="math">wd_{\\text{reg}}</span>  is the weighted degree of regularity of  <span class="math">\\mathcal{Q}^{\\text{top}}</span>  (Definition 4). As we are already assuming that  <span class="math">\\mathcal{Q}^{\\text{top}}</span>  is regular by applying this procedure, we can upper bound  <span class="math">wd_{\\text{reg}}</span>  by the Macaulay bound (4). If we further assume that this system is also in SNP (Definition 6), we may also use the stronger bound of Theorem 1.</p>

    <p class="text-gray-300"><strong>Step 2.</strong> The second step performs polynomial multiplications between the coefficients  <span class="math">f_{ij}</span>  of the elements of  <span class="math">G(\\mathcal{Q}^{\\text{top}})</span>  in terms of the original generating set  <span class="math">\\mathcal{Q}^{\\text{top}}</span>  and the  <span class="math">Q_i</span>  polynomials, recalling that  <span class="math">G(\\mathcal{Q}^{\\text{top}})</span>  is reduced and that all  <span class="math">Q_j</span> -polynomials have been properly reduced by the  <span class="math">P_i</span> 's according to  <span class="math">\\prec</span> . If we</p>

    <p class="text-gray-300">let  <span class="math">A := \\{0, \\dots, \\alpha_1 - 1\\} \\times \\dots \\times \\{0, \\dots, \\alpha_n - 1\\} \\subset \\mathbb{N}^n</span> , we can then write these  <span class="math">Q_j</span> -polynomials as follows:</p>

    <p class="text-gray-300"><span class="math">$Q_j = \\sum_{\\mathbf{a} \\in A} Q_{j,\\mathbf{a}}(x_1, \\dots, x_m) \\cdot \\mathbf{y}^{\\mathbf{a}} ,</span>$</p>

    <p class="text-gray-300">and it is easy to see that there are at most  <span class="math">|A| = \\prod_{j=1}^n \\alpha_j</span>  terms  <span class="math">Q_{j,\\mathbf{a}}</span>  in the sum. To compute each  <span class="math">f_{ij} \\cdot Q_j</span> , we first compute the individual products  <span class="math">f_{ij} \\cdot Q_{j,\\mathbf{a}}(x_1,\\ldots,x_m)</span>  for each  <span class="math">\\mathbf{a} \\in A</span>  and sum them together. From the definition of the weighted degree of regularity, we know that</p>

    <p class="text-gray-300"><span class="math">$\\operatorname{wdeg}(f_{ij} \\cdot Q_{j,\\mathbf{a}}(x_1,\\ldots,x_m)) \\le wd_{\\operatorname{reg}}</span>$</p>

    <p class="text-gray-300">Thus, the second step amounts to performing  <span class="math">mg \\cdot (\\prod_{j=1}^n \\alpha_j)</span>  multiplications of polynomials in m variables whose result has weighted degree at most  <span class="math">wd_{\\text{reg}}</span> , where g is the size of the reduced Gr&ouml;bner basis  <span class="math">G(\\mathcal{Q}^{\\text{top}})</span> . Using [28, Corollary 2.1], this latter quantity can be upper bounded by  <span class="math">m \\cdot D_{\\langle \\mathcal{Q}^{\\text{top}} \\rangle}</span> . To estimate the complexity of each of the multiplications, we make use of the following result:</p>

    <p class="text-gray-300"><strong>Theorem 3 (Multivariate multiplication</strong> [46]). Let  <span class="math">P_1, P_2 \\in \\mathbb{F}[x_1, \\ldots, x_m]</span>  such that  <span class="math">\\operatorname{wdeg}(P_1) + \\operatorname{wdeg}(P_2) \\leq D</span> . Let assume that  <span class="math">\\mathbb{F}</span>  has at least D points in arithmetic progression. Then we can compute the product  <span class="math">P_1 \\cdot P_2</span>  in time:</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{O}(m \\cdot M(D)/D \\cdot \\mathcal{SD}(D; (\\mathbf{w}, 1))) = \\mathcal{O}(m \\cdot M(\\mathcal{SD}(D; (\\mathbf{w}, 1))))</span>$
,</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{SD}(D; (\\mathbf{w}, 1)) = \\# \\left\\{ (a_1, \\dots, a_m) \\in \\mathbb{N}^m \\ \\left| \\ \\sum_{i=1}^m w_i \\cdot a_i \\le D \\right. \\right\\} \\simeq \\frac{\\binom{D+m}{m}}{\\prod_{i=1}^m w_i}</span>$</p>

    <p class="text-gray-300">is the number of terms of weight at most D from Equation (1), and</p>

    <p class="text-gray-300"><span class="math">$M(d) = \\mathcal{O}(d \\cdot \\log(d) \\log \\log(d))</span>$</p>

    <p class="text-gray-300">is the time complexity for multiplying univariate polynomials of degree d.</p>

    <p class="text-gray-300">Applying this result to our case with  <span class="math">D = wd_{reg}</span>  yields the following complexity bound for the second step:</p>

    <p class="text-gray-300"><span class="math">$C_2 = m^3 D_{\\langle \\mathcal{Q}^{\\text{top}} \\rangle} \\cdot \\prod_{j=1}^n \\alpha_j \\cdot M(\\mathcal{SD}(wd_{\\text{reg}}; (\\mathbf{w}, 1))),</span>$</p>

    <p class="text-gray-300">where  <span class="math">SD(wd_{reg}; (\\mathbf{w}, 1))</span>  is given in Equation (1).</p>

    <p class="text-gray-300">Cost comparison. Note that the cost of Step 1. does not depend on  <span class="math">\\prod_{j=1}^{n} \\alpha_j</span> , while the cost of Step 2. only grows linearly with it. This is in contrast to the change of ordering step, whose cost will grow with  <span class="math">\\left(\\prod_{j=1}^{n} \\alpha_j\\right)^{\\omega}</span> . As such, we expect that this method will allow us to significantly reduce the cost of Gr&ouml;bner basis computation for several instances of ZK-friendly primitives, and that it will transfer the bottleneck of the overall attack to the change of ordering step. Examples of this will be given in Section 4.</p>

      <h3 id="sec-3.5" class="text-xl font-semibold mt-8">3.5 Change of ordering step</h3>

    <p class="text-gray-300">It remains to estimate the complexity of the change of ordering, whose cost has already been stated to be polynomial in  <span class="math">D_I</span>  in Section 2.4. To do so, we instantiate more fine-grained bounds from the computer algebra literature and/or we slightly improve them using the CheapLunch particularities.</p>

    <p class="text-gray-300">We start by recalling some known results for converting a Gr&ouml;bner basis from the wqrevlex ordering to the lex ordering in the zero-dimensional case. Most algorithms for this purpose work as follows: we define the  <span class="math">\\mathbb{F}</span> -linear maps  <span class="math">T_{x_i}</span>  over R/I as  <span class="math">P \\mapsto x_i \\cdot P \\pmod{I}</span> , represented as a  <span class="math">D_I \\times D_I</span>  matrix in  <span class="math">\\mathbb{F}</span>  for some basis of R/I. It is known that the characteristic polynomial of  <span class="math">T_{x_n}</span>  lies in the ideal I. Hence, by computing this characteristic polynomial and finding its root(s), we recover the n-th coordinate of a solution. Computing the characteristic polynomial of  <span class="math">T_{x_n}</span>  is done in two steps: first, choose a basis of R/I and compute the matrices of the  <span class="math">T_{x_i}</span>  under this choice of basis. Those matrices are known as multiplication matrices. Then, compute the characteristic polynomial of  <span class="math">T_{x_n}</span>  using linear algebra algorithms. While the second step has received a lot of attention in the computer algebra community [21,24,13], the first step was less studied since it is free under the <em>stability</em> property that is expected for generic systems. However, this property is not verified by our systems. The first work tackling the multiplication matrix computation is the original FGLM paper [23], that gives a complexity in  <span class="math">\\mathcal{O}(n \\cdot D_I^3)</span>  where n is the number of variables. With a refined complexity analysis, we show in Appendix C.1 that under the stability and SNP assumption of the  <span class="math">\\mathcal{Q}^{top}</span> , and if the weights of the  <span class="math">x_i</span> 's w.r.t.  <span class="math">\\prec</span>  are all equal to  <span class="math">w_x</span> for  <span class="math">1 \\le i \\le m</span> , the computation of all multiplication matrices in the CheapLunch case would have a complexity of</p>

    <p class="text-gray-300">
<span class="math">$\\mathcal{O}\\left(\\frac{(n+m)\\cdot D_I^3 \\cdot w_x}{\\deg_{\\prec}(Q_m)}\\right) . \\tag{7}</span>$</p>

    <p class="text-gray-300">A more recent work [27] leverages fast linear algebra to compute the multiplication matrices in time  <span class="math">\\mathcal{O}(d_{\\max} \\cdot n^{\\omega} D_I^{\\omega})</span> , where  <span class="math">d_{\\max}</span>  is the maximal degree of elements in the canonical basis of R/I and n is the number of variables. We adapt this algorithm to weighted orderings and refine its analysis in Appendix C.2. Let  <span class="math">wd_{\\max} \\leq \\sum_{i=1}^{n+m} (d_i - w_i)</span>  be the maximal weighted degree of monomials in the canonical basis of R/I; if the weights  <span class="math">w_i</span>  are integer, the complexity for the computation of the multiplication matrix for CLS is:</p>

    <p class="text-gray-300">
<span class="math">$\\mathcal{O}\\left(wd_{\\max}^{3-\\omega}(n+m)^{\\omega-1}D_I^{\\omega}\\right) . \\tag{8}</span>$</p>

    <p class="text-gray-300">The choice of the best multiplication matrices computation algorithm among (7) and (8) depends on the parameters of the CLS.</p>

    <p class="text-gray-300">Then, we use more recent algorithms than FGLM to compute the desired characteristic polynomial (for a detailed discussion on these algorithms, see Appendix C). Among them, the <em>Hermite Normal Form</em> (HNF) algorithm [13] provides the characteristic polynomial of  <span class="math">T_{x_m}</span>  in time</p>

    <p class="text-gray-300">
<span class="math">$\\mathcal{O}(t_m^{\\omega} M(D_I/t_m)(\\log(t_m)^2 + \\log(D_I/t_m))) = \\tilde{\\mathcal{O}}\\left(D_I \\cdot t_m^{\\omega - 1}\\right) , \\qquad (9)</span>$</p>

    <p class="text-gray-300">where t<sup>m</sup> is a sparsity indicator of this multiplication matrix. More precisely, the matrix Tx<sup>m</sup> has two sets of columns: those which come from the identity matrix, thus only containing one nonzero entry, and those which are dense or close to dense. The parameter t<sup>m</sup> is the number of these dense columns. It is shown in Appendix <a href="#page-34-0">C</a> that for a CheapLunch system and under the SNP and stability assumptions for Q, and if the wt&#8826;(xi) = w<sup>x</sup> for 1 &le; i &le; m and a certain weight wx, the multiplication matrix Tx<sup>m</sup> has a sparsity indicator t<sup>m</sup> &le; 2DIwx/deg&#8826;(Qm). Taking &omega; = 2 and neglecting logarithmic factors in Equation <a href="#page-15-3">(9)</a> as a conservative estimate from a designer's point of view, we get the following lower bound on the complexity:</p>

    <p class="text-gray-300">
<span class="math">$D_I^2 \\operatorname{wt}_{\\prec}(x_m) / \\operatorname{deg}_{\\prec}(Q_m)</span>$
(10)</p>

    <p class="text-gray-300">Note that this conservative bound also roughly corresponds to the number of non-zero coefficients in the multiplication matrix. We will use <a href="#page-15-2">(8)</a> with &omega; = 2.807 as a realistic complexity estimate from an attacker's point of view. In contrast, the estimate <a href="#page-16-2">(10)</a> will be used as a worst case scenario from the designer's point of view.</p>

    </section>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 Primitives with Regular CheapLunch Systems</h2>

    <p class="text-gray-300">We now apply the framework of Section <a href="#page-9-0">3</a> to CheapLunch systems arising from AO hash functions that are assumed to be regular (i.e., for which the part <sup>Q</sup>top is regular) from Hilbert series experiments (see Remark <a href="#page-7-5">1)</a>. While being weighted regular is a generic property <a href="#page-29-6">[26,</a> Proposition 4], we have no way to prove regularity for <sup>Q</sup>top apart from proving its Hilbert series.</p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 XHash8</h3>

    <p class="text-gray-300">XHash8 <a href="#page-27-0">[2]</a> is a permutation derived from Rescue-Prime Optimized (RPO) <a href="#page-28-10">[4]</a> that is defined over F 12 p , where <sup>p</sup> is the so-called Goldilocks prime 2<sup>64</sup> <sup>&minus;</sup> <sup>2</sup> <sup>32</sup> + 1. It is designed to be used in a sponge construction with rate 8 and capacity 4, and was originally defined alongside another permutation called XHash12. The particularity of XHash8 is that some of its nonlinear layers are partial: they only activate 8 out of 12 branches. It is for that reason that our framework directly applies to XHash8, and not to its siblings Rescue, Rescue-Prime, RPO and XHash12. Using the notations of the original XHash paper, we decompose XHash8 into the following 10 steps:</p>

    <p class="text-gray-300"><span class="math">$(F)(B&#x27;)(P3)(F)(B&#x27;)(P3)(F)(B&#x27;)(P3)(MC),</span>$</p>

    <p class="text-gray-300">where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the (F) step is an affine layer followed by the application of x 7&rarr; x 7 to the whole state,</li>
      <li>the (B&prime; ) step is an affine layer followed by the application of x 7&rarr; x <sup>1</sup>/<sup>7</sup> to 8 out of 12 branches of the state,</li>
    </ul>

    <p class="text-gray-300">&ndash; the (P3) step is a constant injection followed by the mapping of the 12  <span class="math">\\mathbb{F}_p</span>  elements to 4  <span class="math">\\mathbb{F}_{p^3}</span>  elements<sup>8</sup>, which are then raised to the 7-th power:</p>

    <p class="text-gray-300"><span class="math">$(s_0,\\ldots,s_{11})\\mapsto (S_0,S_1,S_2,S_3)\\mapsto (S_0^7,S_1^7,S_2^7,S_3^7)\\mapsto (s_0&#x27;,\\ldots,s_{11}&#x27;).</span>$</p>

    <p class="text-gray-300">Altogether, this step can be represented as a polynomial of total degree 7 over  <span class="math">\\mathbb{F}_p^{12}</span> , which we use in the construction of polynomial models of XHash8.</p>

    <p class="text-gray-300">For a figure of the round function, see Appendix 4.</p>

    <p class="text-gray-300">CICO-(12-k,k) model for XHash8 (no round skip). We use the same system as the authors of the Freelunch [7, Section 4.3 and Appendix A], expanded to CICO-(12-k,k). In other words, we have k input variables  <span class="math">x_1,\\ldots,x_k</span> , and as many intermediate variables as there are  <span class="math">x\\mapsto x^{1/7}</span>  Sboxes: for the j-th (B') step, we define  <span class="math">y_{1,j},\\ldots,y_{8,j}</span>  at the output of these Sboxes, lexicographically higher than all previously defined variables. We give the following weights to these variables:</p>

    <p class="text-gray-300"><span class="math">$\\operatorname{wt}(x_i) = 1</span>$
for  <span class="math">1 \\le i \\le k</span> ,
<span class="math">\\operatorname{wt}(y_{i,j}) = 7^{2j-2}</span>  for  <span class="math">1 \\le i \\le 8, 1 \\le j \\le 3</span> .</p>

    <p class="text-gray-300">Then, the full system is a CheapLunch system that contains, for  <span class="math">1 \\leq i \\leq 8</span> ,  <span class="math">1 \\leq j \\leq 24</span> , a polynomial  <span class="math">P_{i,j}</span>  of leading monomial  <span class="math">y_{i,j}^7</span> , and for  <span class="math">1 \\leq i \\leq k</span> , a polynomial  <span class="math">Q_i</span>  such that  <span class="math">Q_i^{\\text{top}}</span>  has weighted degree  <span class="math">7^6</span>  and is in  <span class="math">\\mathbb{F}[x_1,\\ldots,x_k]</span> . Indeed, at the j-th (B') step, we introduce new monomials  <span class="math">y_{1,j},\\ldots,y_{8,j}</span>  of weight  <span class="math">7^{2j-2}</span>  on branches that contain an Sbox, and the branches that don't have an Sbox contain polynomials whose top homogeneous part is in  <span class="math">\\mathbb{F}[x_1,\\ldots,x_k]</span>  and has weight  <span class="math">7^{2j-1}</span> . From Theorem 2, we directly get the following bound on  <span class="math">D_I</span>  for solving CICO-(12-k,k):</p>

    <p class="text-gray-300"><span class="math">$D_I \\le 7^{24+6k}.</span>$</p>

    <p class="text-gray-300">Finally, notice that  <span class="math">\\mathcal{Q}^{\\text{top}}</span>  is generated by k homogeneous polynomials of degree  <span class="math">7^6</span>  in k variables. We can use Theorem 1 (which is in fact the classical Macaulay bound in this context) and get that</p>

    <p class="text-gray-300"><span class="math">$wd_{\\text{reg}} \\le k(7^6 - 1) + 1.</span>$</p>

    <p class="text-gray-300">Experimental results. We verified our approach experimentally on versions of XHash8 with less rounds and less branches. Our results are summarized in Table 9. Let  <span class="math">n_S</span>  be the number of Sboxes in (B') (so,  <span class="math">n_S = 8</span>  for the full XHash8). In our experiments, we have noted that whenever  <span class="math">t &lt; n_S + k</span> , then the ideal generated by  <span class="math">\\mathcal{Q}^{\\text{top}}</span>  does not have dimension 0. However, as long as  <span class="math">n_S + k \\leq t</span> , our assumptions work well and the bound on  <span class="math">D_I</span>  is tight. Note that the full sponge used for XHash has capacity 4, therefore it is sufficient to solve CICO-(8, 4) to break the scheme, and we conjecture that  <span class="math">\\mathcal{Q}^{\\text{top}}</span>  has dimension 0 in this case, as  <span class="math">n_S + c = t</span> . We believe that CICO-(7,5) and CICO-(6,6) are still of academic interest, but arguably less so.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;8</sup> To define this map, one must choose a &quot;representation&quot; of  <span class="math">\\mathbb{F}_{p^3}</span>  &ndash; in other words, an irreducible polynomial of degree 3 in  <span class="math">\\mathbb{F}_p</span> . The authors of XHash do not give that polynomial: instead, they give the algebraic normal form of (P3) in [2, Appendix A].</p>

    <p class="text-gray-300">About Conjecture 1 of [2]. A conjecture is given in the paper where XHash is defined. The authors call it the &quot;Monotonous Ideal Degree Conjecture&quot;. With our notations, this conjecture translates to, for solving any CICO-(12 - k, k),  <span class="math">D_I \\geq 7^{30}</span> . It comes from the leading monomials of the form  <span class="math">y_{i,j}^7</span>  for each (P') layer Sbox, and a leading monomial  <span class="math">x_i^{7^6}</span>  for some i in  <span class="math">\\mathcal{Q}</span> . This intuition is true in our case, assuming that  <span class="math">\\mathcal{Q}</span>  is regular, following Proposition 1. Indeed, we get that the monomials  <span class="math">y_{i,j}^7</span>  are leading monomials in the reduced Gr&ouml;bner basis of  <span class="math">\\langle \\mathcal{P}, \\mathcal{Q} \\rangle</span> , and all other leading monomials come from  <span class="math">G(\\mathcal{Q})</span> . The leading monomials of  <span class="math">G(\\mathcal{Q})</span>  are those of  <span class="math">G(\\mathcal{Q}^{\\text{top}})</span> , which must have, for all i, a leading monomial divisible by  <span class="math">x_i^{7^6}</span> , as  <span class="math">\\mathcal{Q}^{\\text{top}}</span>  is homogeneous of degree  <span class="math">7^6</span> . Thus, we get the following:</p>

    <p class="text-gray-300"><strong>Proposition 2.</strong> We can define a CheapLunch system  <span class="math">\\mathcal{Q}, \\mathcal{P}</span>  to solve CICO-(12-k, k) instances of XHash8 for  <span class="math">k \\leq 4</span> , and assuming that  <span class="math">\\mathcal{Q}</span>  is regular, its ideal degree can be bounded by:</p>

    <p class="text-gray-300"><span class="math">$7^{30} &lt; D_I &lt; 7^{24+6k}</span>$</p>

    <p class="text-gray-300">which validates Conjecture 1 of [2] in this context (without round skips).</p>

    <p class="text-gray-300">On round skips. We refer to [5, Appendix D] and D.1 for the round skip method, as XHash falls exactly in this framework. With this, we find that for CICO-1 and CICO-2, we can skip the first (F) layer, and respectively 9 Sboxes (8 for XHash8) and 2 Sboxes of the first (P') layer. For CICO-3 and CICO-4, we expect that it would decrease the degree of the ideal respectively by  <span class="math">7^2</span>  and 7.</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">4.2 Poseidon and Neptune</h3>

    <p class="text-gray-300"><strong>Polynomial modeling</strong> In this section, we describe a polynomial modeling for the CICO problem on both Poseidon and Neptune, that will feature a CheapLunch structure and get us a tight upper bound on the ideal degree. We recall that both primitives are defined as:</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{E}^{(R_F)} \\circ \\cdots \\circ \\mathcal{E}^{(R_{f,1}+1)} \\circ \\mathcal{I}^{(R_P)} \\circ \\dots \\mathcal{I}^{(1)} \\circ \\mathcal{E}^{(R_{f,1})} \\circ \\cdots \\circ \\mathcal{E}^{(1)} \\circ M_E</span>$</p>

    <p class="text-gray-300">where we let  <span class="math">R_F = R_{f,1} + R_{f,2}</span> , the  <span class="math">\\mathcal{E}^{(i)}</span>  are permutations of degree d for Poseidon and 4 for Neptune, and  <span class="math">\\mathcal{I}^{(j)}</span>  are defined as  <span class="math">\\mathcal{I}^{(j)}(\\mathbf{x}) = M_I \\cdot S_I(\\mathbf{x}) + C_I^{(j)}</span> , with  <span class="math">S_I(\\mathbf{x}) = (x_1^d, x_2, \\dots, x_t)</span> . As our analysis of Poseidon and Neptune in sponge mode will be similar, we set  <span class="math">\\delta</span>  the degree of the full rounds of the primitive (ie.  <span class="math">\\delta = d</span>  for Poseidon and  <span class="math">\\delta = 4</span>  for Neptune). We define a polynomial modeling of the CICO-(t - k, k) problem as follows:</p>

    <p class="text-gray-300">&ndash; We let  <span class="math">k+R_P</span>  variables  <span class="math">(x_1,\\ldots,x_k,y_1,\\ldots,y_{R_P})</span> . We let the input of the permutation to be  <span class="math">(x_1,\\ldots,x_k,0,\\ldots,0)</span> . The state of the permutation after the first  <span class="math">R_{f,1}</span>  full rounds becomes</p>

    <p class="text-gray-300"><span class="math">$(R_1^{(0)}(x_1,\\ldots,x_k),\\ldots,R_t^{(0)}(x_1,\\ldots,x_k))</span>$</p>

    <p class="text-gray-300">where the  <span class="math">R_i^{(0)}</span>  have total degree  <span class="math">\\delta^{R_{f,1}}</span>  in the  <span class="math">x_j</span> .</p>

    <p class="text-gray-300">&ndash; Let  <span class="math">1 \\leq i \\leq R_P</span> , we define polynomials  <span class="math">P_i(x_1, \\ldots, x_k, y_1, \\ldots, y_i)</span>  as follows: let  <span class="math">(R_1^{(i)}(x_1,\\ldots,x_k,y_1,\\ldots,y_{i-1}),\\ldots,R_t^{(i)}(x_1,\\ldots,x_k,y_1,\\ldots,y_{i-1}))</span>  the state after the <em>i</em>-th partial round, we let</p>

    <p class="text-gray-300"><span class="math">$P_i(x_1,\\ldots,x_k,y_1,\\ldots,y_i) = y_i - R_1^{(i-1)}(x_1,\\ldots,x_k,y_1,\\ldots,y_{i-1})</span>$
.</p>

    <p class="text-gray-300">Thus, the state after the partial nonlinear layer becomes</p>

    <p class="text-gray-300"><span class="math">$(y_i^d, R_2^{(i-1)}(\\mathbf{x}, \\mathbf{y}), \\dots, R_t^{(i-1)}(\\mathbf{x}, \\mathbf{y}))</span>$
,</p>

    <p class="text-gray-300">and we can get the polynomials  <span class="math">R_i^{(i)}</span>  by multiplying this vector with  <span class="math">M_I</span>  and adding the round constant  <span class="math">\\mathbf{C}^{(i)}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>After all partial rounds, we get the state  <span class="math">(R_1^{(R_P)}(\\mathbf{x}, \\mathbf{y}), \\dots, R_t^{(R_P)}(\\mathbf{x}, \\mathbf{y}))</span> . By applying the last  <span class="math">R_{f,2}</span>  full rounds, we get a state  <span class="math">(Q_1(\\mathbf{x}, \\mathbf{y}), \\dots, Q_t(\\mathbf{x}, \\mathbf{y}))</span> and add the equations  <span class="math">Q_1(\\mathbf{x}, \\mathbf{y}), \\dots, Q_k(\\mathbf{x}, \\mathbf{y})</span>  to the system. Finally, the ideal corresponding to the CICO problem is:</li>
    </ul>

    <p class="text-gray-300"><span class="math">$I = \\langle P_1, \\dots, P_{R_P}, Q_1, \\dots, Q_k \\rangle .</span>$</p>

    <p class="text-gray-300">Monomial ordering. We give the following weights to the variables:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">-\\operatorname{wt}(x_j) = d \\text{ for } 1 \\le j \\le k.</span>  \\text{wt}(y_i) = \\delta^{R_{f,1}} \\text{ for } 1 \\le i \\le R_P.</li>
    </ul>

    <p class="text-gray-300">The weights have been chosen such that the weighted degree of the state  <span class="math">R_i^{(i)}, 1 \\leq</span>  <span class="math">j \\leq t, 0 \\leq i \\leq R_P</span>  stays upper bounded by  <span class="math">d \\cdot \\delta^{R_{f,1}}</span>  through the partial rounds. Moreover, we order the variables in such a way that, for monomials with an equal weight:  <span class="math">y_1 \\succ \\cdots \\succ y_{R_P} \\succ x_1 \\succ \\cdots \\succ x_k</span> .</p>

    <p class="text-gray-300">    <img src="_page_19_Picture_11.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300"><strong>Fig. 1.</strong> The polynomial modeling in the case  <span class="math">k=2, R_P=2</span> .</p>

    <p class="text-gray-300">A CheapLunch structure We prove that the system we defined has a Cheap-Lunch structure. Indeed, after replacing  <span class="math">P_i</span>  with  <span class="math">NF_{\\succ,\\langle P_1,...,P_{i-1}\\rangle}(P_i)</span>  and the  <span class="math">Q_j</span>  with  <span class="math">NF_{\\succ,\\langle P_1,\\ldots,P_{R_P}\\rangle}(Q_j)</span>  (which can be done efficiently during the system generation), we get a polynomial system with the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">-Q_j^{\\text{top}} \\in \\mathbb{F}_p[x_1, \\dots, x_k, y_{R_P}^d] \\text{ for } 1 \\leq j \\leq k, \\text{ and } P_1^{\\text{top}} \\in \\mathbb{F}_p[x_1, \\dots, x_k].</span>  <span class="math">-\\text{LM}(P_j^{\\text{top}}) = y_{j-1}^d \\text{ for } 2 \\leq j \\leq R_P.</span></li>
    </ul>

    <p class="text-gray-300">Thus, setting  <span class="math">\\mathcal{P} = \\{P_2, \\dots, P_{R_P}\\}, \\mathcal{Q} = \\{P_1, Q_1, \\dots, Q_c\\}</span> , we get a CheapLunch system. We also made extensive tests to check the regularity of the system, and all of them succeeded (see the parameters we verified in Table 4).</p>

    <p class="text-gray-300">Evaluating the weighted degree of regularity To compute the complexity of the Gr&ouml;bner basis computation, we have to estimate the weighted degree of regularity of the system, as defined in Definition 4. The system Q contains k equations of weight  <span class="math">d \\cdot \\delta^{R_F}</span>  and 1 equation of weight  <span class="math">d \\cdot \\delta^{R_{f,1}}</span>  in k variables of weight d and one of weight  <span class="math">\\delta^{R_{f,1}}</span> . Thus, applying the weighted Macaulay bound with the SNP assumption yields:</p>

    <p class="text-gray-300"><span class="math">$wd_{\\text{reg}} \\le d \\cdot (k(\\delta^{R_F} - 1) + (\\delta^{R_{f,1}} - \\delta^{R_{f,1}}/d) + 1)</span>$
.</p>

    <p class="text-gray-300">However, we have seen that for all  <span class="math">1 \\leq i \\leq k</span> ,  <span class="math">Q_j^{\\text{top}} \\in \\mathbb{F}_p[x_1, \\dots, x_k, y_{R_P}^d]</span> . Thus, we can set a new variable  <span class="math">\\tilde{y} = y_{R_P}^d</span>  of weight  <span class="math">d \\cdot \\delta^{R_{f,1}}</span> . Such an operation does not change the degree of regularity of the ideal, and applying the same bound on the new system yields:</p>

    <p class="text-gray-300"><span class="math">$wd_{\\text{reg}} \\le d \\cdot (k(\\delta^{R_F} - 1) + (\\delta^{R_{f,1}} - \\delta^{R_{f,1}}) + 1) = d \\cdot (k(\\delta^{R_F} - 1) + 1)</span>$
.</p>

    <p class="text-gray-300">This bound is matched in our experiments. For instance, the estimates from Section 3.4 yield a Gr&ouml;bner basis for Poseidon in time:</p>

    <p class="text-gray-300"><span class="math">$\\left(\\frac{1}{d^{R_{f,1}}} \\binom{k \\cdot d^{R_F} + 2}{k+1}\\right)^{\\omega} + k^3 \\cdot d^{k \\cdot R_F + R_P - 1} \\cdot M \\left(\\frac{1}{d^{R_{f,1} - 1}} \\binom{k \\cdot d^{R_F} + 2}{k+1}\\right)\\right) \\ .</span>$</p>

    <p class="text-gray-300">Ideal degree To evaluate precisely the degree of the ideal, we make use of the weighted B&eacute;zout bound as stated in Theorem 2. We have that the equations  <span class="math">Q_i</span>  have weighted degree  <span class="math">d \\cdot \\delta^{R_F}</span> , and the equations  <span class="math">P_j</span>  have weighted degree  <span class="math">d \\cdot \\delta^{R_{f,1}}</span> . Moreover, the variables  <span class="math">x_i</span>  have weight d and the variables  <span class="math">y_j</span>  have weight  <span class="math">\\delta^{R_{f,1}}</span> . The weighted B&eacute;zout bound yields:</p>

    <p class="text-gray-300"><span class="math">$D_I \\leq (d \\cdot \\delta^{R_F})^k \\cdot (d \\cdot \\delta^{R_{f,1}})^{R_P} / (\\delta^{R_P \\cdot R_{f,1}} \\cdot d^k) = \\delta^{k \\cdot R_F} \\cdot d^{R_P} \\ .</span>$</p>

    <p class="text-gray-300">We conjecture that this bound is achieved.</p>

    <p class="text-gray-300">Note that a similar result for Poseidon has already been reported in [11, Section 10.1], where the ideal degree of the CICO-k problem was evaluated as</p>

    <p class="text-gray-300"><span class="math">$D_I = d^{k \\cdot (R_F - 2) + R_P + 1} .</span>$</p>

    <p class="text-gray-300">To the best of our knowledge, the authors of this report did not publish any proof of it. The difference between this result and ours comes from the fact they considered Poseidon instances with only  <span class="math">R_F - 1</span>  full rounds and starting with a layer of monomials instead of a linear layer.</p>

    <p class="text-gray-300">Skipping rounds on Poseidon Following [9], our attacks on Poseidon can be improved by tricks allowing to skip the first rounds, and thus reduce the ideal degree. In general, it is feasible reduce the degree in the first  <span class="math">s = \\lfloor t/k \\rfloor - 2</span>  variables  <span class="math">x_i</span>  of the polynomials by a factor d, reducing the ideal degree by a factor  <span class="math">d^s</span> . Additionally, some instances of Poseidon2 use non-MDS matrices, which may make this round-skipping trick more efficient than expected. We observed for instance that in the case t = 16, k = 1, two rounds can be freely skipped using the  <span class="math">M_E</span>  matrix from Poseidon2. We leave as an open problem a further study of this phenomena. Full details are provided in Appendix D.1.</p>

    <h4 id="sec-misc-2" class="text-lg font-semibold mt-6">Comparison to previous cryptanalysis of CICO-k</h4>

    <p class="text-gray-300">Comparison to [3] We report in Table 2 a comparison between our attacks and a previous Gr&ouml;bner basis cryptanalysis on very high security level instances. We recall that their instances have been generated using  <span class="math">p \\sim 2^{128}</span> ,  <span class="math">c = \\lambda/128</span> ,  <span class="math">t = 3 \\cdot c</span>  to ensure  <span class="math">\\lambda</span>  bits of security against CICO-c attacks (but only  <span class="math">\\lambda/2</span>  bits of security against collision attacks or 2-block preimage attacks in sponge mode). The round numbers have then been generated using the formulas from the Poseidon design paper taking into account the security margin. For each instance, we have added two rows depending on the complexity estimate we consider for the change of ordering step (we use (8) when taking into account the complexity for generating the multiplication matrix, and (10) corresponds to a conservative choice from the designers' point of view). We discard the column on the univariate solving step as it is never a bottleneck in our or their attack.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">&lambda;</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">d</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">t</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">k</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">R_F</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">R_P</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">GB</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">FGLM</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">source</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">712.98</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">712.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">712.98</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">705.67</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[3]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1024</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">85</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">367.94</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">673.32</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(8)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">307.94</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">307.34</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">456.47</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(10)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">430.71</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">615.40</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[3]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">512</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">512 5 1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12 4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">57</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">303.81</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">588.25</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(8)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">303.81</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">390.08</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">351.56</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">593.25</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[3]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">384</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">384 7 9 3 8 47</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">287.81</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">566.46</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(8)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">207.01</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">370.57</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(10)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">49</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">46</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">219.30</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">253.59</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(10)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 2. Comparison with [3] on high security level instances.</p>

    <p class="text-gray-300">Comparison to designers' analysis Using conservative estimates from the designers' point of view, we compared our estimates to the expected security level for full Poseidon with no security margin (ie.  <span class="math">R_F=6</span> , and no margin on  <span class="math">R_P</span> ), taking  <span class="math">\\omega=2</span>  which corresponds to a conservative choice from a designer point of view. Our analysis using (10) outperforms their analysis for some 256 bit instances  <span class="math">(D_I^2/d^{R_F}\\simeq 2^{253.59})</span>  on the full version, without security margin). We emphasize that even with  <span class="math">\\omega=2</span> , we found no attacks on full Poseidon with its security margin for realistic security levels ( <span class="math">80 \\le \\lambda \\le 256</span> ).</p>

    <p class="text-gray-300">Comparison to [36] This article exploits some invariant subspace property in the internal rounds to reduce the degree of the equations compared to a trivial forward modeling of Poseidon. In particular, they find a linear subspace  <span class="math">\\mathcal{S}^{(\\ell)} \\subset \\mathbb{F}_p^t</span>  of dimension k such that for  <span class="math">0 \\leq r \\leq \\ell-1, y \\in \\mathcal{S}^{(\\ell)}</span> , we have that</p>

    <p class="text-gray-300"><span class="math">$(M_I^r y) \\cdot (1, 0, \\dots, 0) = 0</span>$
.</p>

    <p class="text-gray-300">This way, we can skip the first  <span class="math">\\ell</span>  partial rounds, which will reduce the degree of the equations by  <span class="math">d^{\\ell}</span> . While the authors evaluated the complexity of the Gr&ouml;bner basis step by making some tradeoffs in the generic complexity formula for grevlex Gr&ouml;bner basis, they also provided a conjecture on the ideal degree achieved by their modeling. They conjectured [36, Conjecture 1] that</p>

    <p class="text-gray-300"><span class="math">$D_I = d^{t \\cdot R_{f,1} + R_P - \\ell} .</span>$</p>

    <p class="text-gray-300">Note that the authors made their experiments using  <span class="math">R_{f,1} = R_{f,2} = R_f</span> . Using a similar analysis as we did for our modeling, we could prove the following bound:</p>

    <p class="text-gray-300"><span class="math">$D_I \\le d^{kR_F + R_P + R_{f,1}(t-2k) - \\ell}</span>$</p>

    <p class="text-gray-300">We see that their ideal degree is lower than ours only if  <span class="math">s \\leq \\ell - R_{f,1}(t-2k)</span> . As  <span class="math">s \\geq 0</span>  and  <span class="math">R_{f,1} &gt; 0</span> , this would imply that  <span class="math">\\ell &gt; (t-2k)</span> . The case  <span class="math">\\ell &gt; (t-2k)</span>  corresponds to the case where a nontrivial invariant subspace exists for  <span class="math">M_I</span> , which is avoided in the new POSEIDON instances.</p>

    <p class="text-gray-300">Thus, our modeling leads to a lower ideal degree than theirs. Moreover, we have shown that the Gr&ouml;bner basis computation step has negligible complexity compared to the change of ordering step for most sets of parameters, which was not the case in their work. This implies the following complexity comparison:</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{C}_{\\mathrm{GB,ours}} \\leq \\mathcal{C}_{\\mathrm{FGLM,ours}} \\leq \\mathcal{C}_{\\mathrm{FGLM,[36]}} \\; .</span>$</p>

      <h3 id="sec-4.3" class="text-xl font-semibold mt-8">4.3 Neptune in compression mode</h3>

    <p class="text-gray-300">While NEPTUNE has originally been intended for use in sponge mode, a recent work [36] has considered its security in compression mode, and provided an attack exploiting the low degree of the inverse of full rounds. We recall that the compression mode they considered for a permutation  <span class="math">P \\colon \\mathbb{F}_p^t \\to \\mathbb{F}_p^t</span>  is defined as  <span class="math">\\mathbf{x} \\mapsto \\mathsf{Trunc}_k(\\mathbf{x} + P(\\mathbf{x}))</span> , where  <span class="math">\\mathsf{Trunc}_k</span>  returns the first k coordinates of its input. In this section, we show that our framework can greatly improve their results by computing a Gr&ouml;bner basis efficiently, in a way similar to the previous subsection, and providing precise bounds for the ideal degree of the system.</p>

    <p class="text-gray-300">More precisely, if we let  <span class="math">\\ell = t - k</span>  the length of the subspace trail in the partial rounds,  <span class="math">R_{f,1}</span>  (resp.  <span class="math">R_{f,2}</span> ) the number of full rounds in the input (resp. output) side of the permutation, we provide a modeling of a preimage attack whose ideal degree is upper bounded as:</p>

    <p class="text-gray-300"><span class="math">$D_I \\le d^{R_P - \\ell} \\cdot 4^{(k-1) \\cdot R_{f,1} + R_{f,2}} .</span>$</p>

    <p class="text-gray-300">as long as  <span class="math">R_{f,1} \\geq R_{f,2}</span>  and  <span class="math">R_P \\geq \\ell + \\lfloor \\log_d(4^{R_{f,1}-R_{f,2}}) \\rfloor + 1</span>  (which is the case for any realistic set of parameters). Note that this upper bound matches the results from [36, Table 10], i.e. it corresponds to the ideal degrees they observed for  <span class="math">R_P \\geq 4</span>  (this condition corresponds exactly to the one we required for our bound to be true).</p>

    <p class="text-gray-300"><strong>Polynomial modeling</strong> We model the preimage on the compression function as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We recall the subspace trail technique from [15]: We let  <span class="math">e_1, \\ldots, e_k \\in \\mathbb{F}_p^t</span>  a basis of the vector space  <span class="math">\\{v \\in \\mathbb{F}_p^t \\mid M_I^j \\cdot v \\in \\{0\\} \\times \\mathbb{F}_p^{t-1}, 0 \\leq j \\leq t-k-1\\}.</span> Setting the state before partial rounds as  <span class="math">\\sum_{i=1}^{k} x_i \\cdot e_i</span>  allows the state after  <span class="math">\\ell = t - k</span>  partial rounds to be linear in the  <span class="math">x_i</span>  (as this space avoids the  <span class="math">x^d</span> through t - k rounds). We set  <span class="math">wt(x_i) = d</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>In a similar way as for Poseidon, we introduce variables  <span class="math">y_i</span>  in the input of the j-th partial round  <span class="math">x^d</span> , when  <span class="math">\\ell + 1 \\leq j \\leq R_P - \\lfloor \\log_d(4^{R_{f,1} - R_{f,2}}) \\rfloor - 1</span> . We set their weight to  <span class="math">\\operatorname{wt}(y_i) = 1</span> . This adds polynomials  <span class="math">P_i = y_i - R_1^{(j-1)}</span> , where  <span class="math">R_1^{(j-1)}</span>  is a polynomial representing the first coordinate of the state vector before the j-th partial round.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We add an additional variable y in the input of the  <span class="math">R_P |\\log_d(4^{R_{f,1}-R_{f,2}})|</span> -th round  <span class="math">x^d</span> . We set its weight to</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\operatorname{wt}(y) = \\frac{4^{R_{f,1} - R_{f,2}}}{d^{\\lfloor \\log_d(4^{R_{f,1} - R_{f,2}}) \\rfloor}} \\ .</span>$</p>

    <p class="text-gray-300">This adds a polynomial  <span class="math">P = y - R_1^{(R_P - \\lfloor \\log_d(4^{R_{f,1} - R_{f,2}}) \\rfloor - 1)}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We apply the  <span class="math">\\lfloor \\log_d(4^{R_{f,1} - R_{f,2}}) \\rfloor</span>  last partial rounds, and  <span class="math">R_{f,2}</span>  full rounds in the forward direction to get the first k output words of the permutation. Likewise, we apply the  <span class="math">R_{f,1}</span>  full rounds in the backward direction to get the first k input words. Summing the input and output gets us the equations  <span class="math">Q_1, \\ldots, Q_k</span>  corresponding to being a preimage of the compression function.</li>
    </ol>

    </section>

    <section id="app-a" class="mb-10">
      <h2 class="text-2xl font-bold">A CheapLunch structure Our system is as follows:</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>k variables  <span class="math">x_i</span>  of weight d,  <span class="math">R_P |\\log_d(4^{R_{f,1}-R_{f,2}})| \\ell 1</span>  variables  <span class="math">y_i</span>  of weight 1 and one variable y of weight  <span class="math">4^{R_{f,1}-R_{f,2}}/d^{\\lfloor \\log_d(4^{R_{f,1}-R_{f,2})}\\rfloor}</span> .</li>
      <li>-k equations  <span class="math">Q_i</span>  of weight  <span class="math">4^{R_f,1} \\cdot d</span> , whose homogeneous component of highest weight only depends on  <span class="math">x_2, \\ldots, x_k, y</span> .</li>
      <li>The equation  <span class="math">P_{\\ell+1}</span> , whose leading monomial is  <span class="math">x_1</span> .  <span class="math">\\text{LM}(P_j) = y_{j-1}^d</span>  for  <span class="math">\\ell+2 \\leq j \\leq R_P \\lfloor \\log_d(4^{R_{f,1}-R_{f,2}}) \\rfloor 1</span>  and LM(P) = 1 <span class="math">y_{R_P-|\\log_d(4^{R_{f,1}-R_{f,2}})|-1}^d</span> .</li>
    </ul>

    <p class="text-gray-300">Ideal degree It follows from the weighted B&eacute;zout bound and from what we observed in the previous paragraph, that:</p>

    <p class="text-gray-300"><span class="math">$D_I \\le d^{R_P - \\ell} \\cdot 4^{(k-1) \\cdot R_{f,1} + R_{f,2}}</span>$
.</p>

    <p class="text-gray-300">Gr&ouml;bner basis computation We have seen that the system has a CheapLunch structure. In addition to this structure, we can observe that the top parts of the  <span class="math">Q_i</span>  are of the form:</p>

    <p class="text-gray-300"><span class="math">$Q_i^{\\text{top}} = \\mu_i \\cdot y^{d^{\\lfloor \\log_d(4^{R_{f,1} - R_{f,2}}) \\rfloor + 1} \\cdot 4^{R_{f,2}}} + \\tilde{Q}_i(x_2, \\dots x_k) ,</span>$</p>

    <p class="text-gray-300">where at least one  <span class="math">\\mu_i \\neq 0</span> . Thus, taking a monomial ordering such that  <span class="math">x_i \\prec y \\prec y_j</span> , we can, up to an invertible  <span class="math">\\mathbb{F}_p</span> -linear transform of the  <span class="math">Q_i</span> , get to:</p>

    <p class="text-gray-300"><span class="math">$LM(Q_1) = y^{d^{\\lfloor \\log_d(4^{R_{f,1} - R_{f,2}}) \\rfloor + 1} \\cdot 4^{R_{f,2}}}, \\ Q_i^{\\text{top}} \\in \\mathbb{F}_p[x_2, \\dots, x_k], \\ 2 \\le i \\le k.</span>$</p>

    <p class="text-gray-300">Hence, we get a new CheapLunch structure where  <span class="math">Q = \\{Q_i \\mid 2 \\leq i \\leq k\\}</span>  is a system with k-1 equations of weight  <span class="math">d \\cdot 4^{R_{f,1}}</span>  in  <span class="math">x_2, \\ldots, x_k</span> . Using Theorem 1, we get</p>

    <p class="text-gray-300"><span class="math">$wd_{\\text{reg}} \\le d \\cdot ((k-1) \\cdot 4^{R_{f,1}} + 1)</span>$
.</p>

    <p class="text-gray-300">This bound matches the one we observe experimentally.</p>

    </section>

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5 Non-Regular Examples</h2>

    <p class="text-gray-300">We now move on to CheapLunch systems that do <em>not</em> follow Definition 9. In other words,  <span class="math">\\mathcal{Q}^{\\text{top}}</span>  is not regular, so that we can no longer rely on the arguments used to prove Lemma 1. In particular, the computation of the Gr&ouml;bner basis of  <span class="math">\\mathcal{Q}</span>  may feature non-trivial cancellation in the top parts of the polynomials, which we refer to as degree fall polynomials. Thus, the Gr&ouml;bner basis may contain polynomials that are not in  <span class="math">\\mathcal{P}</span> , but such that some  <span class="math">y_i</span>  divides its leading monomial. This prevents us from applying the strategy from Section 3 directly to our system.</p>

    <p class="text-gray-300">In this section, we report our observations on these systems and give some proven and conjectured upper bounds on the associated ideal degree. We leave as an open problem a more efficient computation of the first Gr&ouml;bner basis in this case. In the meantime, we advise the designers to consider the change-of-order step as the most costly and to use these conjectured bounds for its estimation.</p>

      <h3 id="sec-5.1" class="text-xl font-semibold mt-8">5.1 Griffin</h3>

    <p class="text-gray-300">The GRIFFIN hash function was introduced at Crypto 2023 [31]. While several full-round instances have been broken in the k=1 case [7,8], no cryptanalysis has been done for the case where k&gt;1. In what follows, we propose a new modeling for the CICO-k problem when k&gt;1. This modeling provides an upper bound on the ideal degree, that we observed to be not tight. We also made, based on our observation a conjecture on the actual ideal degree of the system. We leave as an interesting open problem a proof of Conjecture 1 as well as finding efficient ways of computing a Gr&ouml;bner basis.</p>

    <p class="text-gray-300"><strong>Specification of Griffin</strong> The GRIFFIN round function is defined as a composition of three steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A partial-SPN step  <span class="math">(x_1, x_2, x_3, \\dots, x_t) \\mapsto (x_1^{1/d}, x_2^d, x_3, \\dots, x_t)</span>  where d &gt; 1 is minimal such that  <span class="math">\\gcd(p-1, d) = 1</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A Horst layer that maps  <span class="math">x_i</span>  to  <span class="math">x_i</span>  if i=1,2,  <span class="math">x_i \\cdot G_1(x_1,x_2,0)</span>  if i=3 and  <span class="math">x_i \\cdot G_{i-2}(x_1,x_2,x_{i-1})</span>  when i&gt;3, where the  <span class="math">G_i</span>  are quadratic functions that never equal 0.</li>
    </ol></li>
    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>An affine layer defined using a matrix M and round constants  <span class="math">c^{(i)}</span> .</li>
    </ol>

    <p class="text-gray-300">The round function is also represented in Figure 5. Note that the permutation applies a linear layer before the first round. The round numbers of full instances of Griffin can be found in [31].</p>

    <p class="text-gray-300"><strong>Proving an upper bound on</strong>  <span class="math">D_I</span>  We introduce for each round  <span class="math">1 \\le i \\le R</span>  intermediate variables  <span class="math">y_i, z_i</span> , where  <span class="math">y_i</span>  lies in the input of the  <span class="math">x^d</span>  and  <span class="math">z_i</span>  in the output of  <span class="math">x^{1/d}</span> . We also set  <span class="math">\\operatorname{wt}(y_i) = \\operatorname{wt}(z_i) = 3^{i-1}/d, 1 \\le i \\le R</span> , and  <span class="math">x_j, 1 \\le j \\le k</span>  on the branches of the unknown input, with  <span class="math">\\operatorname{wt}(x_j) = 1</span> . From the cubic Horst layer, we can easily prove that at each round,  <span class="math">\\operatorname{wdeg}(R_j^{(i)}) = 3^{i-1}</span> , thus:</p>

    <p class="text-gray-300"><span class="math">$\\operatorname{wdeg}(z_i^d - R_1^{(i)}) = \\operatorname{wdeg}(y_i - R_2^{(i)}) = 3^{i-1}, \\quad \\operatorname{wdeg}(Q_j) = 3^R.</span>$</p>

    <p class="text-gray-300">Applying the weighted B&eacute;zout bound (5) to the system  <span class="math">\\{z_i^d - R_1^{(i)}, y_i - R_2^{(i)} \\mid 1 \\le i \\le R\\} \\cup \\{Q_j \\mid 1 \\le j \\le k\\}</span>  gives:</p>

    <p class="text-gray-300">
<span class="math">$D_I \\le \\left(d^2 \\cdot 3^k\\right)^R .</span>$</p>

    <p class="text-gray-300">Note that this bound is not tight even for k = 1, it has been proven in [7] that in this setting,  <span class="math">D_I = (d \\cdot (2d+1))^R</span> . Based on our experiments with differing values of k, d, we make the following conjecture:</p>

    <p class="text-gray-300">Conjecture 1. The ideal degree of an R-round GRIFFIN CICO-k problem is upper bounded by</p>

    <p class="text-gray-300"><span class="math">$D_I \\le \\left(d \\cdot \\left(d(3^k - 1) + 1\\right)\\right)^R.</span>$</p>

      <h3 id="sec-5.2" class="text-xl font-semibold mt-8">5.2 ArionHash</h3>

    <p class="text-gray-300">ArionHash is an arithmetization oriented hash function proposed in [44]. Similar to Griffin, the underlying permutation uses inversion on one branch of its nonlinear layer, and low degree functions on the other branches. The constructions follows the so called Generalized Triangular Dynamical System (GTDS) formulation [43]. ArionHash instantiates, in sponge mode, the permutation Arion- <span class="math">\\pi</span>  which we briefly recall below. Let  <span class="math">p \\geq 5</span>  be a prime, t the number of branches, e the smallest positive integer such that  <span class="math">\\gcd(e, p-1)=1</span> , and  <span class="math">121 \\leq \\alpha \\leq 257</span>  an integer such that  <span class="math">\\gcd(\\alpha, p-1)=1</span> . For  <span class="math">1 \\leq i \\leq t-1</span> , let  <span class="math">\\delta_{i,1}, \\delta_{i,2}, \\mu_i \\in \\mathbb{F}_q</span>  be such that  <span class="math">g_i(x)=x^2+\\delta_{i,1}\\cdot x+\\delta_{i,2}</span>  is a quadratic function without zeroes in  <span class="math">\\mathbb{F}_q</span>  and define  <span class="math">h_i(x)=x^2+\\mu_i\\cdot x</span> . Then the non-linear layer of Arion- <span class="math">\\pi</span>  is  <span class="math">\\mathcal{F}=\\{f_1,\\ldots,f_t\\}</span> , where each  <span class="math">f_i</span>  is defined &quot;from-right-to-left&quot; by the equations:</p>

    <p class="text-gray-300">
<span class="math">$f_t(y_1, \\dots, y_t) = y_t^{1/\\alpha}, f_i(y_1, \\dots, y_t) = y_i^e \\cdot g_i(\\sigma_{i,t}) + h_i(\\sigma_{i,t}), \\quad t - 1 \\ge i \\ge 0</span>$
(11)</p>

    <p class="text-gray-300">where  <span class="math">\\sigma_{i,t}</span>  represents the sum of all previously computed inputs and outputs</p>

    <p class="text-gray-300"><span class="math">$\\sigma_{i,t} = \\sum_{j=i+1}^{t} y_j + f_j(y_1, \\dots, y_t).</span>$</p>

    <p class="text-gray-300">The permutation Arion- <span class="math">\\pi</span>  is defined as follows, where  <span class="math">\\mathcal{L}_{\\gamma}</span>  is an affine function defined as in [44, Definition 3]</p>

    <p class="text-gray-300">Arion-
<span class="math">$\\pi: \\mathbb{F}_p^t \\longrightarrow \\mathbb{F}_p^t, \\quad \\mathbf{x} \\longmapsto \\mathcal{L}_r \\circ \\mathcal{F}_r \\cdots \\mathcal{L}_1 \\circ \\mathcal{F}_1 \\circ \\mathcal{L}_0(\\mathbf{x})</span>$
(12)</p>

    <p class="text-gray-300"><strong>Polynomial Modeling</strong> Consider the CICO-k problem for ArionHash, where we write the input state as  <span class="math">(x_1, ..., x_k, 0^{t-k})</span> . Let us denote by  <span class="math">L_j^{(i)}</span> , and  <span class="math">F_j^{(i)}</span>  the value on branch j after  <span class="math">\\mathcal{L}_i</span>  and  <span class="math">\\mathcal{F}_i</span> , respectively. For i-th round, we introduce intermediate variable  <span class="math">y_i</span>  on the last branch and the corresponding equation</p>

    <p class="text-gray-300"><span class="math">$P_i := y_i^{\\alpha} - L_t^{(i-1)}(x_1, \\dots, x_k, y_1, \\dots, y_{i-1})</span>$
(13)</p>

    <p class="text-gray-300">The CICO-k constraints on the final output will yield polynomials  <span class="math">Q_1, \\ldots, Q_k</span>  of degree  <span class="math">(2^{t-1}(e+1)-e)^r</span> . Assigning the weights  <span class="math">\\operatorname{wt}(x_i)=1, 1\\leq i\\leq k</span>  and  <span class="math">\\operatorname{wt}(y_i)=deg(L_t^{(i-1)}), 1\\leq i\\leq r</span>  gives us the system  <span class="math">\\mathcal{P}=\\{P_2,\\ldots,P_r\\},\\mathcal{Q}=\\{Q_1,\\ldots,Q_k\\}</span>  in the CheapLunch form</p>

    <p class="text-gray-300"><strong>Explaining non-regularity</strong> With the above weighted monomial order the polynomials of  <span class="math">\\mathcal{P} = \\{P_2, \\dots, P_r\\}</span>  will have co-prime leading monomials. However, the homogeneous component of the highest weight of  <span class="math">\\mathcal{Q}</span> , that is  <span class="math">Q_1^{top}, \\dots, Q_k^{top}</span>  will not be regular. This because the highest degree terms of all polynomials will be constant multiples of the same state element from previous round. More concretely, the state after the non-linear layer of the last round will be  <span class="math">(F_1^{(r)}, \\dots, F_t^{(r)})</span> . After the final linear layer, the output will be linear combination of these state elements. So, for  <span class="math">1 \\leq j \\leq k</span>  we have</p>

    <p class="text-gray-300"><span class="math">$Q_{j} = \\sum_{m=1}^{t} c_{j,m} F_{m}^{(r)}(x_{1}, \\dots, x_{k}, y_{1}, \\dots, y_{r})</span>$
(14)</p>

    <p class="text-gray-300">where we omit the round constant addition for simplicity, We see (for instance from [44, Lemma 2] that  <span class="math">deg(F_1^r) &gt; deg(F_2^r) &gt; \\ldots &gt; deg(F_t^r)</span> . The highest degree component of each of  <span class="math">Q_1, \\ldots, Q_k</span>  will be the highest degree term of  <span class="math">F_1^{(r)}</span> , and we have trivial relations involving the  <span class="math">Q_i</span> 's. For example, denoting by  <span class="math">Top(p(\\mathbf{x}))</span>  the homogeneous component of highest degree of some polynomial p, we have</p>

    <p class="text-gray-300"><span class="math">$\\frac{Q_1^{top}}{c_{1,1}} = \\frac{Q_2^{top}}{c_{2,1}} = Top(F_1^{(r)}) . {15}</span>$</p>

    <p class="text-gray-300">As a result, condition 1 of Definition 5 will not be satisfied and hence the system will not be regular. We can cancel out this common term from, say  <span class="math">Q_2</span>  by a</p>

    <p class="text-gray-300">linear combination and define  <span class="math">\\bar{Q}_2</span> , which will now have the highest degree term from  <span class="math">F_2^{(r)}</span> , while  <span class="math">Q_1</span>  remains the same. Essentially, we have eliminated the higher degree terms in  <span class="math">Q_2</span>  that are constant multiples of  <span class="math">F_1^{(r)}</span>  (and not just  <span class="math">Top(F_1^{(r)})</span> ), and we still have  <span class="math">\\langle Q_1^{top}, Q_2^{top} \\rangle = \\langle Q_1^{top}, \\bar{Q}_2^{top} \\rangle</span> . In fact, we can generalize this for k &gt; 2, and perform similar linear transformations pair by pair for  <span class="math">Q_1^{top}, \\ldots, Q_k^{top}</span> , after which we get  <span class="math">Q_1^{top}, \\bar{Q}_2^{top}, \\ldots, \\bar{Q}_k^{top}</span> , that still generate the same ideal. When we replace  <span class="math">deg(Q_j)</span>  with  <span class="math">deg(\\bar{Q}_j)</span>  for  <span class="math">j = 2, \\ldots, k</span> , in the Weighted B&eacute;zout Bound (2), we get the following upper bound for the ideal degree</p>

    <p class="text-gray-300">
<span class="math">$D_I \\le \\frac{\\alpha^r(\\prod_{j=1}^k deg(\\bar{Q}_j))}{\\prod_{j=1}^r w_j} \\tag{16}</span>$</p>

    <p class="text-gray-300">where  <span class="math">w_j</span>  are the monomial weights and it can be shown, following induction argument similar to [44, Appendix C.1] that</p>

    <p class="text-gray-300"><span class="math">$deg(\\bar{Q}_j) = deg(F_j^r) = (2^{t-1}(e+1) - e)^{(r-1)} \\cdot (2^{t-j}(e+1) - e)</span>$</p>

    <p class="text-gray-300">Note that since  <span class="math">Q_1, \\ldots, Q_k</span>  were initially of degree  <span class="math">(2^{t-1}(e+1)-e)^r</span>  we improved the Weighted B&eacute;zout Bound by replacing the generators of the ideal with new generators that have a smaller degree. We present the experimental results and other observations for  <span class="math">D_I</span>  in Appendix E.2.</p>

    </section>

    <section id="acknowledgements" class="mb-10">
      <h2 class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">This work has been facilitated through the COSINUS associate team between Inria and Simula. The authors would like to thank Vincent Neiger and Ma&euml;l Hostettler for insightful discussions in the early stages of this work. The work of Antoine Bak and Aur&eacute;lien Boeuf was supported by the European Research Council (ERC, grant agreement no. 101041545 &quot;ReSCALE&quot;). Aur&eacute;lien Boeuf was also supported in part by the French Agence Nationale de la Recherche through the SWAP project under Contract ANR-21-CE39-0012. Antoine Bak was also supported by the French DGA. The work of Morten &Oslash;ygarden and Atharva Phanse has been funded by a research grant from the Ethereum Foundation through the Poseidon Cryptanalysis Initiative.</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><p class="text-gray-300">1. Alfons&iacute;n, J.L.R.: The Diophantine Frobenius Problem, vol. 30. Oxford University Press (2005)</p></li>
      <li><p class="text-gray-300"> Ashur, T., Bhati, A.S., Kindi, A., Mahzoun, M., Perrin, L.: XHash: Efficient STARK-friendly hash function. Cryptology ePrint Archive, Report 2023/1045 (2023), https://eprint.iacr.org/2023/1045</p></li>
      <li><p class="text-gray-300">3. Ashur, T., Buschman, T., Mahzoun, M.: Algebraic cryptanalysis of HADES design strategy: Application to POSEIDON and poseidon2. Cryptology ePrint Archive, Paper 2023/537 (2023), https://eprint.iacr.org/2023/537</p></li>
      <li><p class="text-gray-300">4. Ashur, T., Kindi, A., Meier, W., Szepieniec, A., Threadbare, B.: Rescue-prime optimized. Cryptology ePrint Archive, Report 2022/1577 (2022), <a href="https://eprint.iacr.org/2022/1577" target="_blank" rel="noopener noreferrer">https://eprint.</a> <a href="https://eprint.iacr.org/2022/1577" target="_blank" rel="noopener noreferrer">iacr.org/2022/1577</a></p></li>
      <li><p class="text-gray-300">5. Bak, A., Perrin, L.: On the security of Split-and-Lookup-based ZK-friendly primitives. IACR Transactions on Symmetric Cryptology 2025(2), 87&ndash;123 (2025)</p></li>
      <li><p class="text-gray-300">6. Bardet, M., Faug\`ere, J.C., Salvy, B.: On the complexity of the f5 gr&uml;obner basis algorithm. Journal of Symbolic Computation 70, 49&ndash;70 (2015)</p></li>
      <li><p class="text-gray-300">7. Bariant, A., Boeuf, A., Lemoine, A., Manterola Ayala, I., &Oslash;ygarden, M., Perrin, L., Raddum, H.: The Algebraic FreeLunch: Efficient Gr&uml;obner Basis Attacks Against Arithmetization-Oriented Primitives. In: Annual International Cryptology Conference (Crypto). pp. 139&ndash;173. Springer (2024)</p></li>
      <li><p class="text-gray-300">8. Bariant, A., Boeuf, A., Briaud, P., Hostettler, M., &Oslash;ygarden, M., Raddum, H.: Improved Resultant Attack against Arithmetization-Oriented Primitives. Cryptology ePrint Archive, Paper 2025/259 (2025), <a href="https://eprint.iacr.org/2025/259" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2025/259</a></p></li>
      <li><p class="text-gray-300">9. Bariant, A., Bouvier, C., Leurent, G., Perrin, L.: Algebraic attacks against some arithmetization-oriented primitives. IACR Transactions on Symmetric Cryptology 2022(3), 73&ndash;101 (Sep 2022). <a href="https://doi.org/10.46586/tosc.v2022.i3.73-101" target="_blank" rel="noopener noreferrer">https://doi.org/10.46586/tosc.v2022.i3.73-101</a>, <a href="https://tosc.iacr.org/index.php/ToSC/article/view/9850" target="_blank" rel="noopener noreferrer">https://tosc.iacr.org/index.php/ToSC/article/view/9850</a></p></li>
      <li><p class="text-gray-300">10. Becker, E., Mora, T., Marinari, M.G., Traverso, C.: The shape of the shape lemma. In: Proceedings of the 1994 International Symposium on Symbolic and Algebraic Computation. p. 129&ndash;133 (1994)</p></li>
      <li><p class="text-gray-300">11. Ben-Sasson, E., Goldberg, L., Levit, D.: STARK friendly hash &ndash; survey and recommendation. Cryptology ePrint Archive, Paper 2020/948 (2020), <a href="https://eprint.iacr.org/2020/948" target="_blank" rel="noopener noreferrer">https://eprint.</a> <a href="https://eprint.iacr.org/2020/948" target="_blank" rel="noopener noreferrer">iacr.org/2020/948</a></p></li>
      <li><p class="text-gray-300">12. Bernshtein, D.N.: The number of roots of a system of equations. Functional Analysis and Its Applications 9, 183&ndash;185 (1975), <a href="https://api.semanticscholar.org/CorpusID:122772773" target="_blank" rel="noopener noreferrer">https://api.semanticscholar.org/</a> <a href="https://api.semanticscholar.org/CorpusID:122772773" target="_blank" rel="noopener noreferrer">CorpusID:122772773</a></p></li>
      <li><p class="text-gray-300">13. Berthomieu, J., Neiger, V., Safey El Din, M.: Faster change of order algorithm for gr&uml;obner bases under shape and stability assumptions. In: Proceedings of the 2022 International Symposium on Symbolic and Algebraic Computation. pp. 409&ndash;418 (2022)</p></li>
      <li><p class="text-gray-300">14. Bertoni, G., Daemen, J., Peeters, M., Van Assche, G.: On the Indifferentiability of the Sponge Construction. In: Annual International Conference on the Theory and Applications of Cryptographic Techniques. pp. 181&ndash;197. Springer (2008)</p></li>
      <li><p class="text-gray-300">15. Beyne, T., Canteaut, A., Dinur, I., Eichlseder, M., Leander, G., Leurent, G., Naya-Plasencia, M., Perrin, L., Sasaki, Y., Todo, Y., et al.: Out of oddity&ndash;new cryptanalytic techniques against symmetric primitives optimized for integrity proof systems. In: Advances in Cryptology&ndash;CRYPTO 2020: 40th Annual International Cryptology Conference, CRYPTO 2020, Santa Barbara, CA, USA, August 17&ndash;21, 2020, Proceedings, Part III 40. pp. 299&ndash;328. Springer (2020)</p></li>
      <li><p class="text-gray-300">16. Bouvier, C., Briaud, P., Chaidos, P., Perrin, L., Salen, R., Velichkov, V., Willems, D.: New design techniques for efficient arithmetization-oriented hash functions: Anemoi permutations and jive compression mode. In: Annual International Cryptology Conference. pp. 507&ndash;539. Springer (2023)</p></li>
      <li><p class="text-gray-300">17. Campa, L., Roy, A.: Groebner basis cryptanalysis of anemoi. Cryptology ePrint Archive, Paper 2025/814 (2025). <a href="https://doi.org/10.1007/978-3-031-91107-1_11" target="_blank" rel="noopener noreferrer">https://doi.org/10.1007/</a> <a href="https://doi.org/10.1007/978-3-031-91107-1_11" target="_blank" rel="noopener noreferrer">978-3-031-91107-1\\_11</a>, <a href="https://eprint.iacr.org/2025/814" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2025/814</a></p></li>
      <li><p class="text-gray-300">18. Cox, D.A., Little, J., O'Shea, D.: Ideals, Varieties, and Algorithms: An Introduction to Computational Algebraic Geometry and Commutative Algebra. Springer, fourth edn. (2015)</p></li>
      <li><p class="text-gray-300">19. Faug\`ere, J.C.: A new efficient algorithm for computing gr&uml;obner bases (f4). Journal of Pure and Applied Algebra 139(1), 61&ndash;88 (1999). <a href="https://doi.org/https://doi.org/10.1016/S0022-4049(99" target="_blank" rel="noopener noreferrer">https://doi.org/https://doi.org/10.1016/S0022-4049(99)00005-5</a>00005-5), <a href="https://www.sciencedirect.com/science/article/pii/S0022404999000055" target="_blank" rel="noopener noreferrer">https://www.sciencedirect.com/science/article/pii/S0022404999000055</a></p></li>
      <li><p class="text-gray-300">20. Faug\`ere, J.C.: A new efficient algorithm for computing gr&uml;obner bases without reduction to zero (f5). In: Proceedings of the 2002 International Symposium on Symbolic and Algebraic Computation. p. 75&ndash;83. ISSAC '02, Association for Computing Machinery, New York, NY, USA (2002). <a href="https://doi.org/10.1145/780506.780516" target="_blank" rel="noopener noreferrer">https://doi.org/10.1145/780506.</a> <a href="https://doi.org/10.1145/780506.780516" target="_blank" rel="noopener noreferrer">780516</a>, <a href="https://doi.org/10.1145/780506.780516" target="_blank" rel="noopener noreferrer">https://doi.org/10.1145/780506.780516</a></p></li>
      <li><p class="text-gray-300">21. Faug\`ere, J.C., Gaudry, P., Huot, L., Renault, G.: Sub-cubic change of ordering for gr&uml;obner basis: a probabilistic approach. In: Proceedings of the 39th International Symposium on Symbolic and Algebraic Computation. pp. 170&ndash;177 (2014)</p></li>
      <li><p class="text-gray-300">22. Faug\`ere, J.C., Gaudry, P., Huot, L., Renault, G.: Using symmetries in the index calculus for elliptic curves discrete logarithm. Journal of Cryptology 27(4), 595&ndash;635 (2014)</p></li>
      <li><p class="text-gray-300">23. Faug\`ere, J., Gianni, P.M., Lazard, D., Mora, T.: Efficient computation of zerodimensional gr&uml;obner bases by change of ordering. J. Symb. Comput. 16(4), 329&ndash;344 (1993). <a href="https://doi.org/10.1006/JSCO.1993.1051" target="_blank" rel="noopener noreferrer">https://doi.org/10.1006/JSCO.1993.1051</a>, <a href="https://doi.org/10.1006/jsco.1993.1051" target="_blank" rel="noopener noreferrer">https://doi.org/10.1006/</a> <a href="https://doi.org/10.1006/jsco.1993.1051" target="_blank" rel="noopener noreferrer">jsco.1993.1051</a></p></li>
      <li><p class="text-gray-300">24. Faug\`ere, J.C., Mou, C.: Sparse FGLM algorithms. Journal of Symbolic Computation 80, 538&ndash;569 (2017)</p></li>
      <li><p class="text-gray-300">25. Faug\`ere, J.C., Safey El Din, M., Verron, T.: On the Complexity of Computing Gr&uml;obner Bases for Quasi-homogeneous Systems. In: ISSAC '13 : Proceedings of the 38th International Symposium on Symbolic and Algebraic Computation. pp. 189&ndash;196. ACM, Boston, Maine, United States (Jun 2013). <a href="https://doi.org/10.1145/2465506.2465943" target="_blank" rel="noopener noreferrer">https://doi.org/10.</a> <a href="https://doi.org/10.1145/2465506.2465943" target="_blank" rel="noopener noreferrer">1145/2465506.2465943</a>, <a href="https://inria.hal.science/hal-00780388" target="_blank" rel="noopener noreferrer">https://inria.hal.science/hal-00780388</a></p></li>
      <li><p class="text-gray-300">26. Faug\`ere, J.C., Safey El Din, M., Verron, T.: On the complexity of computing Gr&uml;obner bases for weighted homogeneous systems. Journal of Symbolic Computation 76, 107&ndash;141 (2016)</p></li>
      <li><p class="text-gray-300">27. Faug\`ere, J.C., Gaudry, P., Huot, L., Renault, G.: Polynomial systems solving by fast linear algebra (2013), <a href="https://arxiv.org/abs/1304.6039" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/1304.6039</a></p></li>
      <li><p class="text-gray-300">28. Faug\`ere, J.C., Gianni, P., Lazard, D., Mora, T.: Efficient computation of zerodimensional gr&uml;obner bases by change of ordering. Journal of Symbolic Computation 16(4), 329&ndash;344 (1993)</p></li>
      <li><p class="text-gray-300">29. Fusco, G., Bach, E.: Phase transition of multivariate polynomial systems. Mathematical Structures in Computer Science 19(1), 9&ndash;23 (2009)</p></li>
      <li><p class="text-gray-300">30. Gianni, P., Mora, T.: Algebraic solution of systems of polynomial equations using groebner bases. vol. 356, pp. 247&ndash;257 (01 1987)</p></li>
      <li><p class="text-gray-300">31. Grassi, L., Hao, Y., Rechberger, C., Schofnegger, M., Walch, R., Wang, Q.: Horst meets fluid-SPN: Griffin for zero-knowledge applications. In: Annual international cryptology conference. pp. 573&ndash;606. Springer (2023)</p></li>
      <li><p class="text-gray-300">32. Grassi, L., Khovratovich, D., L&uml;uftenegger, R., Rechberger, C., Schofnegger, M., Walch, R.: Reinforced concrete: A fast hash function for verifiable computation. p. 1323&ndash;1335. CCS '22, Association for Computing Machinery, New York, NY, USA (2022). <a href="https://doi.org/10.1145/3548606.3560686" target="_blank" rel="noopener noreferrer">https://doi.org/10.1145/3548606.3560686</a>, <a href="https://doi.org/10.1145/3548606.3560686" target="_blank" rel="noopener noreferrer">https://doi.org/10.</a> <a href="https://doi.org/10.1145/3548606.3560686" target="_blank" rel="noopener noreferrer">1145/3548606.3560686</a></p></li>
      <li><p class="text-gray-300">33. Grassi, L., Khovratovich, D., L&uml;uftenegger, R., Rechberger, C., Schofnegger, M., Walch, R.: Monolith: Circuit-friendly hash functions with new nonlinear layers for fast and constant-time implementations. IACR Transactions on Symmetric Cryptology 2024(3), 44&ndash;83 (Sep 2024). <a href="https://doi.org/10.46586/tosc.v2024.i3.44-83" target="_blank" rel="noopener noreferrer">https://doi.org/10.46586/tosc.v2024.i3.</a> <a href="https://doi.org/10.46586/tosc.v2024.i3.44-83" target="_blank" rel="noopener noreferrer">44-83</a>, <a href="https://tosc.iacr.org/index.php/ToSC/article/view/11810" target="_blank" rel="noopener noreferrer">https://tosc.iacr.org/index.php/ToSC/article/view/11810</a></p></li>
      <li><p class="text-gray-300">34. Grassi, L., Khovratovich, D., Rechberger, C., Roy, A., Schofnegger, M.: Poseidon: A New Hash Function for Zero-Knowledge Proof Systems. In: 30th USENIX Security Symposium (USENIX Security 21). pp. 519&ndash;535 (2021)</p></li>
      <li><p class="text-gray-300">35. Grassi, L., Khovratovich, D., Schofnegger, M.: Poseidon2: A faster version of the poseidon hash function. In: International Conference on Cryptology in Africa. pp. 177&ndash;203. Springer (2023)</p></li>
      <li><p class="text-gray-300">36. Grassi, L., Koschatko, K., Rechberger, C.: Poseidon and neptune: Gr&uml;obner basis cryptanalysis exploiting subspace trails. Cryptology ePrint Archive, Paper 2025/954 (2025), <a href="https://eprint.iacr.org/2025/954" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2025/954</a></p></li>
      <li><p class="text-gray-300">37. Grassi, L., Onofri, S., Pedicini, M., Sozzi, L.: Invertible quadratic non-linear layers for mpc-/fhe-/zk-friendly schemes over fnp: Application to poseidon. IACR Transactions on Symmetric Cryptology 2022(3), 20&ndash;72 (Sep 2022). <a href="https://doi.org/10.46586/tosc.v2022.i3.20-72" target="_blank" rel="noopener noreferrer">https://</a> <a href="https://doi.org/10.46586/tosc.v2022.i3.20-72" target="_blank" rel="noopener noreferrer">doi.org/10.46586/tosc.v2022.i3.20-72</a>, <a href="https://tosc.iacr.org/index.php/ToSC/article/view/9849" target="_blank" rel="noopener noreferrer">https://tosc.iacr.org/index.php/</a> <a href="https://tosc.iacr.org/index.php/ToSC/article/view/9849" target="_blank" rel="noopener noreferrer">ToSC/article/view/9849</a></p></li>
      <li><p class="text-gray-300">38. Jean, J.: TikZ for Cryptographers. <a href="https://www.iacr.org/authors/tikz/" target="_blank" rel="noopener noreferrer">https://www.iacr.org/authors/tikz/</a> (2016)</p></li>
      <li><p class="text-gray-300">39. Khovanskii, A.: Newton polyhedra and toroidal varieties. Functional Analysis and Its Applications 11, 289&ndash;296 (1977), <a href="https://api.semanticscholar.org/CorpusID:53613658" target="_blank" rel="noopener noreferrer">https://api.semanticscholar.org/</a> <a href="https://api.semanticscholar.org/CorpusID:53613658" target="_blank" rel="noopener noreferrer">CorpusID:53613658</a></p></li>
      <li><p class="text-gray-300">40. Koschatko, K., L&uml;uftenegger, R., Rechberger, C.: Exploring the six worlds of gr&uml;obner basis cryptanalysis: Application to anemoi. IACR Transactions on Symmetric Cryptology 2024(4), 138&ndash;190 (Dec 2024). <a href="https://doi.org/10.46586/tosc.v2024.i4.138-190" target="_blank" rel="noopener noreferrer">https:</a> <a href="https://doi.org/10.46586/tosc.v2024.i4.138-190" target="_blank" rel="noopener noreferrer">//doi.org/10.46586/tosc.v2024.i4.138-190</a>, <a href="https://tosc.iacr.org/index.php/ToSC/article/view/11953" target="_blank" rel="noopener noreferrer">https://tosc.iacr.org/index.</a> <a href="https://tosc.iacr.org/index.php/ToSC/article/view/11953" target="_blank" rel="noopener noreferrer">php/ToSC/article/view/11953</a></p></li>
      <li><p class="text-gray-300">41. Kushnirenko, A.G.: Newton polytopes and the bezout theorem. Functional Analysis and Its Applications 10(3), 233&ndash;235 (1976). <a href="https://doi.org/10.1007/BF01075534" target="_blank" rel="noopener noreferrer">https://doi.org/10.1007/</a> <a href="https://doi.org/10.1007/BF01075534" target="_blank" rel="noopener noreferrer">BF01075534</a>, <a href="https://link.springer.com/article/10.1007/BF01075534" target="_blank" rel="noopener noreferrer">https://link.springer.com/article/10.1007/BF01075534</a></p></li>
      <li><p class="text-gray-300">42. Lazard, D.: Gr&uml;obner bases, gaussian elimination and resolution of systems of algebraic equations. In: van Hulzen, J.A. (ed.) Computer Algebra. pp. 146&ndash;156. Springer Berlin Heidelberg, Berlin, Heidelberg (1983)</p></li>
      <li><p class="text-gray-300">43. Roy, A., Steiner, M.J.: Generalized triangular dynamical system: An algebraic system for constructing cryptographic permutations over finite fields. In: International Conference on Selected Areas in Cryptography. pp. 139&ndash;165. Springer (2024)</p></li>
      <li><p class="text-gray-300">44. Roy, A., Steiner, M.J., Trevisani, S.: Arion: Arithmetization-oriented permutation and hashing from generalized triangular dynamical systems. arXiv preprint arXiv:2303.04639 (2023)</p></li>
      <li><p class="text-gray-300">45. Szepieniec, A., Lemmens, A., Sauer, J.F., Threadbare, B., Al-Kindi: The tip5 hash function for recursive STARKs. Cryptology ePrint Archive, Paper 2023/107 (2023), <a href="https://eprint.iacr.org/2023/107" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2023/107</a></p></li>
      <li><p class="text-gray-300">46. Van Der Hoeven, J., Schost, E.: Multi-point evaluation in higher dimensions. Appli- &acute; cable Algebra in Engineering, Communication and Computing 24(1), 37&ndash;52 (2013)</p></li>
      <li><p class="text-gray-300">47. Yang, H.S., Zheng, Q.X., Yang, J., Liu, Q.F., Tang, D.: A New Security Evaluation Method Based on Resultant for Arithmetic-Oriented Algorithms. In: International Conference on the Theory and Application of Cryptology and Information Security (AsiaCrypt). pp. 457&ndash;489. Springer (2024)</p></li>
    </ul>

    </section>

    <section id="app-a" class="mb-10">
      <h2 class="text-2xl font-bold">A On Sponges and CICOs</h2>

    <p class="text-gray-300">In this appendix we briefly recall the sponge function <a href="#page-28-1">[14]</a>, its usage in AOcryptography and how various CICO problems (Definition <a href="#page-4-1">1)</a> relate to concrete attacks on it. We will consider a AO-permutations  <span class="math">F: \\mathbb{F}_p^t \\longrightarrow \\mathbb{F}_p^t</span> , where p is large. (More precisely, so large that it will not be feasible to guess inputs or take advantage of field equations  <span class="math">x_i^p = x_i</span> .) Before introducing the sponge construction itself, we start with a brief discussion on polynomial systems solving relevant to our setting.</p>

      <h3 id="app-a.1" class="text-xl font-semibold mt-8">A.1 Polynomial Systems in the AO Setting</h3>

    <p class="text-gray-300">Since the function F can be written as t polynomials in t input variables, the CICO-(IN,OUT) problem can essentially be viewed as solving a system of polynomial equations</p>

    <p class="text-gray-300"><span class="math">$f_i(x_1, \\dots, x_{t-\\text{IN}}) = 0,</span>$
for  <span class="math">1 \\le i \\le \\text{OUT}.</span></p>

    <p class="text-gray-300">As seen in the main body of this paper, an attacker often introduces further variables and equations to this system, in order to simplify computations and/or keep degrees small. As this expands the system by the same number of equations and variables, the difference between variables and equations will solely be determined by the pair (t - IN, OUT). This difference lead to the following cases.</p>

    <p class="text-gray-300">Determined Systems, IN + OUT = t. All instances of polynomial system solving in this work consider a determined case (possibly after a reduction from an underdetermined case, see below). In this setting we expect the polynomial ideal to be zero dimensional, and have ideal degree  <span class="math">D_I &gt; 1</span> . The probability for random determined systems to have at least one solution is given in [29] as 1 - 1/e (this is proved in the asymptotic case, and is also observed to hold in small-scale experiments by the authors). We therefore expect that determined CICO instances will have a solution with a fairly high probability, assuming that the underlying permutation behaves like a random system in this manner.</p>

    <p class="text-gray-300">Underdetermined Systems, IN + OUT &lt; t. Underdetermined polynomial systems will have a positive dimensional ideal, and we expect many solutions. Finding the whole solution space is generally difficult, as we lack efficient, direct methods for solving positive dimensional polynomial systems. One immediate workaround in cases where any one solution will do, is to fix a value for t - (IN + OUT) input variables and solve for the resulting determined system as above. However, for AO-permutations we can often do better. The idea is to fix t - (IN + OUT) linear combinations among the input to effectively cancel out some of the initial nonlinear operations, thus resulting in a determined system that is easier to solve. The details of this strategy will vary depending of the specifications of F, and we refer to [9,7,8], as well as Appendix D for specific examples.</p>

    <p class="text-gray-300">Overdetermined Systems, IN + OUT &gt; t. Random overdetermined systems is only expected to have a solution with probability  <span class="math">1 - e^{-p^{-\\alpha}}</span> , where  <span class="math">\\alpha = \\text{IN} + \\text{OUT} - t</span>  [29]. As such, given the larger values of p considered in this work, they are only relevant in cases where the attacker knows that there will exist a solution (e.g., certain preimage attacks on an observed digest).</p>

    <p class="text-gray-300">We remark that an overdetermined system can naively be reduced to a determined case, by only considering  <span class="math">t-{\\rm IN}</span>  output constraints. As we generically expect a small number of solutions for determined cases, we do not anticipate that spurious solutions will pose a problem for this method, and they can easily be disregarded a-posteriori through evaluating with the remaining output constraints.</p>

    <p class="text-gray-300">More direct methods for solving overdetermined CICO problems is out of scope for this work, and we restrict ourselves to offer only a few remarks. Gr&ouml;bner bases for overdetermined systems are, generally speaking, easier to compute than those of (under)determined systems with the same number of variables. Note that this does not necessarily translate into overdetermined CICO problems from AO permutations being easier to solve than their (under)determined counterparts, given that Gr&ouml;bner basis computation is often not the bottleneck for the latter case. However, solving overdetermined systems will indeed boil down to computing their Gr&ouml;bner bases, as we expect either  <span class="math">D_I = 1</span>  (with a single solution) or  <span class="math">D_I = 0</span>  (no solutions). We therefore believe that the behavior of overdetermined CICO problems from AO permutations will differ significantly from the setting investigated in this paper, and that its study will provide an interesting topic for future work.</p>

      <h3 id="app-a.2" class="text-xl font-semibold mt-8">A.2 The Sponge Construction</h3>

    <p class="text-gray-300">The sponge construction is a general framework that constructs a hash function from the permutation F. Let integers r, c &gt; 0 denote the rate and capacity respectively, where r+c = t. Figure 2 depicts the sponge function with respect to the permutation F. An input  <span class="math">m \\in \\mathbb{F}_p^s</span>  is partitioned into blocks  <span class="math">m_1, \\ldots, m_k \\in \\mathbb{F}_p^r</span> .</p>

    <p class="text-gray-300">    <img src="_page_32_Picture_4.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 2. The sponge construction (Figure from [38]).</p>

    <p class="text-gray-300">If r does not divide the input length s, then the last tuple  <span class="math">m_k</span>  is padded via a suitable scheme to ensure length r (concrete examples of this can be found in [35, Section 3.1] and [2, Section 5.5]). The left half of the figure depicts the <em>absorption</em> phase, where the blocks of m is added to the state in between iterations of F.</p>

    <p class="text-gray-300">The right half of the figure is the <em>squeeze</em> phase where blocks of the digest is taken from the rate in between iterations of F. If the required digest length is not divisible by r, the remaining field elements are simply discarded at the end (along with the final state).</p>

      <h3 id="app-a.3" class="text-xl font-semibold mt-8">A.3 Modeling Polynomial Systems From the Sponge</h3>

    <p class="text-gray-300">Depending on its specifications, the sponge construction allows for several CICO problems to be modeled. Based on our discussion in Appendix A.1, we derive the following two rules of thumb for when modeling CICO systems that are easier to solve. Firstly, an attacker wishes to minimize the &quot;size&quot; of the CICO problem. In our setting this means looking for (under)determined cases that minimize OUT. Secondly, if there are more than one cases that yield the same OUT, we go for the problem with largest IN, as this typically allows the attacker for bypass the most S-boxes.</p>

    <p class="text-gray-300">With these considerations in mind, we offer the following concrete CICO problems and discuss how they translate to attacks on the overall hash function. We emphasize that this is not intended as an exhaustive list, nor will all cases be applicable in every scenario. (There is, in particular, a notable variation in sponge settings allowed by different designers. See, e.g., [34,35,2].)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Collision Attack (IN,OUT) = (c,c). Solving this problem yields an output state where the capacity is 0, and hence a valid input state for the sponge. This enables an attacker to set up collision attacks in settings that allow for different input length for the sponge.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Preimage Attack I</strong> (IN,OUT) = (c,r). If r field elements are kept as output from the squeezing (i.e., a single squeezing iteration), then solving this problem yields a preimage of r field elements. More generally, for a digest DIG&lt; r, this attack becomes (IN,OUT) = (c,DIG).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Preimage Attack II</strong> (IN,OUT) = (r,r). In cases with more than one squeezing iteration, an attacker can attempt to recover a valid state by solving for the unknown capacity elements (as the rate from two consecutive states can be observed). We remark that for c &gt; r, the CICO-problem itself will have many valid solutions, although we expect only a single of them to yield a valid preimage of the sponge. Hence, finding any valid CICO-solution, as discussed in A.1 need not yield a valid attack. If, moreover, the digest is not a multiple of r (i.e., DIG mod  <span class="math">r \\neq 0</span> ), we can focus on the CICO problem from the last squeeze with parameters (IN,OUT) =  <span class="math">(r,DIG \\mod r)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Preimage Attack III</strong> (IN,OUT) = (&gt;c,r). This is a particular variant of Preimage Attack I in settings that allow for the use of input size INPUT &lt; r. In this case, an attacker can hope that a given digest has been hashed with a small input, and attempt to solve for increasing input sizes (note that the public padding scheme does not increase the degrees of freedom of the system). This will result in (a series of) overdetermined system(s) where the attacker will have a reasonable chance of success. If, in addition, we have a digest DIG&lt; r, this attack becomes (IN,OUT) = (t-INPUT,DIG).</li>
    </ol></li>
    </ul>

    </section>

    <section id="app-b" class="mb-10">
      <h2 class="text-2xl font-bold">B Background on Gr&ouml;bner Bases</h2>

    <p class="text-gray-300">This appendix provides some definitions and results on Gr&ouml;bner bases that are used throughout the paper.</p>

    <p class="text-gray-300"><strong>Definition 10 (S-Polynomials).</strong> Let  <span class="math">P, Q \\in \\mathbb{F}[\\mathbf{x}]</span> , we define the S-polynomial of P and Q as:</p>

    <p class="text-gray-300"><span class="math">$\\operatorname{Spol}(P,Q) = \\frac{\\operatorname{LCM}(\\operatorname{LM}(P),\\operatorname{LM}(Q))}{\\operatorname{LT}(P)} \\cdot P - \\frac{\\operatorname{LCM}(\\operatorname{LM}(P),\\operatorname{LM}(Q))}{\\operatorname{LT}(Q)} \\cdot Q \\ .</span>$</p>

    <p class="text-gray-300">Proposition 3 (Buchberger's Criterion, Chapter 2, &sect;6, Theorem 6 in [18]). Let  <span class="math">I \\subset \\mathbb{F}[\\mathbf{x}]</span>  an ideal,  <span class="math">\\mathcal{G} = \\{G_1, \\ldots, G_g\\}</span>  such that  <span class="math">I = \\langle \\mathcal{G} \\rangle</span> . We have that  <span class="math">\\mathcal{G}</span>  is a Gr&ouml;bner basis for I if and only if for all  <span class="math">1 \\leq i &lt; j \\leq g</span> , we have that</p>

    <p class="text-gray-300"><span class="math">$\\operatorname{Spol}(G_i, G_j) \\xrightarrow{\\mathcal{G}} 0</span>$
.</p>

    <p class="text-gray-300">Proposition 4 (Coprime leading monomials [18, Chapter 2,&sect;9,Prop 4]). Let  <span class="math">\\mathcal{G} \\subset \\mathbb{F}[\\mathbf{x}]</span>  a finite set. Let  <span class="math">G_1, G_2 \\in \\mathcal{G}</span>  whose leading monomials are coprime. Then we have that</p>

    <p class="text-gray-300"><span class="math">$\\operatorname{Spol}(G_1, G_2) \\xrightarrow{\\mathcal{G}} 0</span>$
.</p>

    </section>

    <section id="app-c" class="mb-10">
      <h2 class="text-2xl font-bold">C Change of ordering</h2>

    <p class="text-gray-300">The most general algorithm for performing a change of ordering from a (w) grevlex Gr&ouml;bner basis to a lex Gr&ouml;bner basis is the FGLM algorithm [28]. This algorithm has complexity  <span class="math">\\mathcal{O}(n\\cdot D_I^3)</span>  where n is the number of variables. Here we recall the main refinements of this result. Note that all the algorithms discussed in this appendix, with the exception of FGLM, assumes the knowledge of the multiplication matrix of some variable. This multiplication matrix can be computed freely under some stability condition [13]. Unfortunately, this assumption does not hold for the systems we describe in this paper, which may make the computation of the multiplication matrix a nontrivial step. A dedicated analysis for this step for CLS is given in C.1.</p>

    <p class="text-gray-300">Linear algebra-based change of ordering. Following [21], as long as the multiplication matrix of  <span class="math">x_n</span>  is known, we can compute the last polynomial of a lex Gr&ouml;bner basis in time</p>

    <p class="text-gray-300"><span class="math">$\\tilde{\\mathcal{O}}(D_I^{\\omega})</span>$
.</p>

    <p class="text-gray-300">This is done by computing the characteristic polynomial of the multiplication matrix of  <span class="math">x_n</span> .</p>

    <p class="text-gray-300">Sparse FGLM. In the case where we know that the multiplication matrix of  <span class="math">x_n</span>  is sparse, we can apply the Sparse-FGLM algorithm [24]. This algorithm recovers the last polynomial of the lex Gr&ouml;bner basis in time</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{O}(D_I \\cdot (N_n + \\log_2(D_I)))</span>$
,</p>

    <p class="text-gray-300">where  <span class="math">N_n</span>  is the number of nonzero coefficients in the multiplication matrix of  <span class="math">x_n</span> . It is known [24] that in the case of a generic system of n equations of degree d, we have that  <span class="math">N_n \\sim \\sqrt{6/n\\pi} \\cdot D_I^2/d</span>  as d goes to infinity. This gives a complexity in  <span class="math">\\sqrt{6/n\\pi} \\cdot D_I^{2+(n-1)/n}</span>  for Sparse-FGLM, which was used in [3] to assess the security of POSEIDON. Neglecting for the  <span class="math">\\sqrt{6/n\\pi}</span>  factor, this estimate compares well to the linear algebra-based one when  <span class="math">\\omega &gt; 2 + (n-1)/n</span> . Taking  <span class="math">\\omega = 2.807</span>  as in the Strassen algorithm, this happens only when  <span class="math">n \\leq 5</span> , which is neither the case for the modeling presented in [3] nor in our paper.</p>

    <p class="text-gray-300">Hermite Normal Form change of ordering. When the multiplication matrix of  <span class="math">x_n</span>  is known, and when the system is in shape position, <em>i.e.</em> its lex Gr&ouml;bner basis contains a univariate polynomial of degree  <span class="math">D_I</span> , [13] shows that the change of order can be computed in time</p>

    <p class="text-gray-300"><span class="math">$\\tilde{\\mathcal{O}}\\left(t_n^{\\omega-1}D_I\\right)</span>$
,</p>

    <p class="text-gray-300">where  <span class="math">t_n</span>  is a sparsity indicator of this multiplication matrix, with  <span class="math">t_n D_I \\approx N_n</span> , which shows that this bound improves on both the linear algebra-based and Sparse FGLM techniques. In particular,  <span class="math">t_n</span>  being the number of non-trivial columns in the multiplication matrix, it is equal the size of the bordering  <span class="math">|B_{x_n}(G)|</span> , as defined in Appendix C.1, which we bound in Lemma 2 with some additional hypotheses. In our case, we are only looking for a single univariate polynomial in the ideal, and we can safely ignore ignore the shape assumption of the HNF paper. Indeed, we can re-order the coefficients of the multiplication matrix using an adaptation of Theorem 5.2 when y is not the smallest variable (as this last hypothesis is unused in the proof), and computing its Hermite Normal Form in the said complexity.</p>

    <p class="text-gray-300">We here present a dedicated complexity analysis of the computation of the multiplication matrix described in FGLM [28, Proposition 3.1]. The general principle of the algorithm is the same, but we define borderings w.r.t some variable  <span class="math">x_i</span>  or  <span class="math">y_i</span> , and give an upper bound on their sizes. This allows us to show that the complexity of computing the multiplication matrices for CLS in SNP, under some stability assumption of  <span class="math">\\mathcal{Q}</span> , can be reduced to</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{O}\\left(\\frac{(n+m)D_I^3}{d_m}\\right)</span>$
,</p>

    <p class="text-gray-300">where  <span class="math">d_i = \\deg(Q_i^{top})</span>  for  <span class="math">1 \\le i \\le m</span> .</p>

    <p class="text-gray-300">Bordering of an ideal. Let  <span class="math">(\\mathcal{Q}, \\mathcal{P}) \\subset R = \\mathbb{F}[x_1, \\dots, x_m, y_1, \\dots, y_n]</span>  be a CLS in SNP for some monomial order  <span class="math">\\prec</span> , and G be a Gr&ouml;bner basis of  <span class="math">I = \\langle \\mathcal{Q} \\cup \\mathcal{P} \\rangle</span>  w.r.t.  <span class="math">\\prec</span> . We denote by  <span class="math">\\mathcal{C}</span>  the canonical basis (w.r.t. G) of the quotient ring R/I. The bordering of the ideal I w.r.t a variable  <span class="math">x \\in R</span>  is defined as</p>

    <p class="text-gray-300"><span class="math">$B_x(G) = \\{x\\mathfrak{m} \\mid \\mathfrak{m} \\in \\mathcal{C}\\} \\setminus \\mathcal{C},</span>$</p>

    <p class="text-gray-300">and we obtain the <em>bordering</em> of I by taking the union over all variables in R:</p>

    <p class="text-gray-300">
<span class="math">$B(G) = \\bigcup_{z \\in \\{x_1, \\dots, x_m, y_1, \\dots, y_n\\}} B_z.</span>$</p>

    <p class="text-gray-300">In other words, the surface B(G) is made up of monomials t that do not themselves belong to  <span class="math">\\mathcal{C}</span> , but where we can find a variable  <span class="math">z \\mid t</span>  such that  <span class="math">\\frac{\\mathfrak{m}}{z} \\in \\mathcal{C}</span> . For a CLS in SNP the size of these borderings are restricted as follows.</p>

    <p class="text-gray-300"><strong>Lemma 2.</strong> Let  <span class="math">(\\mathcal{P}, \\mathcal{Q})</span>  be a CLS with  <span class="math">\\mathcal{Q}</span>  that verifies stability and is in SNP for some monomial order  <span class="math">\\prec</span>  s.t. wt <span class="math">(x_i) = w_x</span>  is constant for the variables  <span class="math">x_i</span> ,  <span class="math">1 \\leq i \\leq m</span>  (but the weights of the  <span class="math">y_i</span>  are not necessarily constant). Let G be a Gr&ouml;bner basis for the CLS w.r.t  <span class="math">\\prec</span> , and let us denote  <span class="math">d_l = \\deg(Q_l^{top})</span> . Then we have</p>

    <p class="text-gray-300"><span class="math">$|B_{x_m}(G)| \\le \\left(\\prod_{l=1}^n \\alpha_l\\right) \\cdot \\left(\\sum_{\\ell=1}^{m-1} \\left(\\prod_{l=1}^\\ell \\frac{d_l}{w_x}\\right)\\right),</span>$</p>

    <p class="text-gray-300">where the  <span class="math">\\alpha_i</span> 's are as described in Definition 8. In particular, when none of the  <span class="math">Q_l^{top}</span>  are linear in the  <span class="math">x_i</span> 's (i.e.  <span class="math">d_l \\geq 2w_x</span>  for all l), we have, if we denote  <span class="math">D_I</span>  the ideal degree:</p>

    <p class="text-gray-300"><span class="math">$|B_{x_m}(G)| \\le \\frac{2D_I w_x}{d_m} \\ .</span>$</p>

    <p class="text-gray-300">Proof. First, let us consider the monomial ordering  <span class="math">\\prec&#x27;</span>  on the  <span class="math">x_i</span>  such that  <span class="math">\\operatorname{wt}_{\\prec&#x27;}(x_i) = \\operatorname{wt}_{\\prec}(x_i)/w_x</span> . The monomial ordering  <span class="math">\\prec&#x27;</span>  is a grevlex ordering on the  <span class="math">x_i</span>  since all its weights are 1. It can easily be seen that these ordering are equivalent when comparing monomials containing  <span class="math">x_i</span> 's, therefore that  <span class="math">G_{\\prec&#x27;}(\\mathcal{Q}^{\\text{top}}) = G_{\\prec}(\\mathcal{Q}^{\\text{top}})</span>  which we denote  <span class="math">G(\\mathcal{Q}^{\\text{top}})</span> , and that the borderings w.r.t. the variables  <span class="math">x_i</span>  are equal in both cases. Let us assume the stability of  <span class="math">\\mathcal{Q}</span> . This property implies that  <span class="math">B_{x_m}(G(\\mathcal{Q}^{\\text{top}})) \\subset \\operatorname{LM}(G(\\mathcal{Q}^{\\text{top}}))</span> . As:</p>

    <p class="text-gray-300"><span class="math">$C = \\left\\{ \\mathbf{y}^{\\gamma} \\mathbf{x}^{\\beta} \\mid \\gamma \\in \\prod_{i=1}^{n} \\{0, \\dots, \\alpha_{i} - 1\\}, \\ \\beta \\in \\mathcal{C}(G(\\mathcal{Q}^{\\text{top}})) \\right\\} ,</span>$</p>

    <p class="text-gray-300">we have for  <span class="math">t \\in \\mathcal{C}</span> , that  <span class="math">x_m t \\notin \\mathcal{C}</span>  only if  <span class="math">t = \\mathbf{y}^{\\gamma} \\mathbf{x}^{\\beta}, \\beta \\in B_{x_m}(G(\\mathcal{Q}^{\\text{top}}))</span> . Thus</p>

    <p class="text-gray-300"><span class="math">$|B_{x_m}(G)| = \\left(\\prod_{i=1}^n \\alpha_i\\right) \\cdot |B_{x_m}(\\mathcal{Q}^{\\text{top}})| \\le \\left(\\prod_{i=1}^n \\alpha_i\\right) \\cdot |G(\\mathcal{Q}^{\\text{top}})| \\ .</span>$</p>

    <p class="text-gray-300">We can then use the SNP of Q<sup>top</sup> and Theorem 12 from [6] with the grevlex ordering  <span class="math">\\prec&#x27;</span>  (such that  <span class="math">\\deg_{\\prec&#x27;}(Q_l^{top}) = d_l/w_x</span> ) to upper bound the number of elements in a reduced Gr&ouml;bner basis by</p>

    <p class="text-gray-300"><span class="math">$|G(\\mathcal{Q}^{\\text{top}})| \\le \\sum_{\\ell=1}^{m-1} \\left( \\prod_{l=1}^{\\ell} \\frac{d_l}{w_x} \\right) .</span>$</p>

    <p class="text-gray-300">This concludes the first part of the theorem. When the  <span class="math">Q_l^{top}</span>  are not linear, then  <span class="math">d_l/w_x \\geq 2</span>  for all l, thus the sums of these terms can be bounded by twice the largest term, i.e:</p>

    <p class="text-gray-300"><span class="math">$|G(\\mathcal{Q}^{\\text{top}})| \\le \\sum_{\\ell=1}^{m-1} \\left( \\prod_{l=1}^{\\ell} \\frac{d_l}{w_x} \\right) \\le 2 \\prod_{l=1}^{m-1} \\frac{d_l}{w_x}.</span>$</p>

    <p class="text-gray-300">This, together with  <span class="math">D_I = (\\prod_{l=1}^n \\alpha_l) \\prod_{l=1}^m (d_l/w_x)</span> , concludes the proof.  <span class="math">\\square</span></p>

    <p class="text-gray-300">Refined algorithm. The algorithm proceeds as follows, from a Gr&ouml;bner basis G (whose leading terms have coefficient one) w.r.t. an order  <span class="math">\\prec</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Sort the bordering B(G) according to the monomial order  <span class="math">\\prec</span> , and denote the elements of the sorted bordering as  <span class="math">\\{b_1, \\ldots b_{|B(G)|}\\}</span>  (s.t.  <span class="math">b_i \\prec b_{i+1}</span>  for all i).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Iterate on i = 1 ... |B(G)|. At each iteration, compute  <span class="math">\\text{Red}_{G, \\prec}(b_i)</span>  using the already computed normal forms of  <span class="math">b_j</span> , for j &lt; i. To do so, proceed the following way:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) If  <span class="math">b_i</span>  is the leading term of an element of  <span class="math">g \\in G</span> , the reduction is  <span class="math">b_i g</span> .</li>
      <li>(b) Else, if  <span class="math">x_m|b_i</span>  and  <span class="math">b_i/x_m \\in B(G)</span> , compute  <span class="math">Q = x_m \\operatorname{Red}_{G,\\prec}(b_i/x_m)</span> . The monomials of Q which are not in  <span class="math">\\mathcal{C}</span>  are all in  <span class="math">B_{x_m}(G)</span> , thus there are at most  <span class="math">|B_{x_m}(G)|</span>  of them. Reduce each using the already computed normal forms.</li>
      <li>(c) Else, there exists another variable  <span class="math">z \\in \\{y_1, \\dots, y_n, x_1, \\dots, x_{m-1}\\}</span>  s.t.  <span class="math">b_i/z \\in B(G)</span> . In this case, compute  <span class="math">Q = \\text{Red}_{G, \\prec}(z\\text{Red}_{G, \\prec}(b_i/z))</span> .</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Once all the normal forms of the bordering have been computed, all the multiplication matrices  <span class="math">T_i</span>  can be freely recovered.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Complexity Analysis. We iterate  <span class="math">|B(G)| \\leq (n+m)D_I</span>  times. At each iteration, step (a) costs at most  <span class="math">\\mathcal{O}(D_I)</span> , for a total cost of roughly  <span class="math">\\mathcal{O}(|B(G)| \\cdot D_I)</span> . At each iteration, step (b) costs  <span class="math">|B_{x_m}(G)| \\cdot D_I</span> , for a total cost of roughly  <span class="math">\\mathcal{O}(|B(G)| \\cdot |B_{x_m}(G)| \\cdot D_I)</span> . For estimating the cost of step (c), let us give an upper bound on the number of elements of B(G) which do not satisfy the condition of (b). Condition of (b) is not satisfied if either  <span class="math">b_i \\notin B_{x_m}(G)</span>  or  <span class="math">x_m \\nmid b_i</span> . There are at most  <span class="math">|B_{x_m}(G)|</span>  iterations such that  <span class="math">b_i \\in B_{x_m}(G)</span> . Let us now estimate the number of monomials  <span class="math">b_i \\in B(G)</span>  which are such that  <span class="math">x_m \\nmid b_i</span>  with  <span class="math">b_i \\notin B_{x_m}(G)</span> . For  <span class="math">z \\in \\{y_1, \\ldots, y_n, x_1, \\ldots, x_{m-1}\\}</span> , if  <span class="math">b_i \\in B_z(G)</span>  is not divisible by  <span class="math">x_m</span> , then  <span class="math">b_i/z \\in \\mathcal{C}</span> , and there exists j s.t.  <span class="math">b_i/z \\times x_m^i \\in B_{x_m}(G)</span> . This</p>

    <p class="text-gray-300">map from monomials  <span class="math">B_z(G)</span>  non divisible by  <span class="math">x_m</span>  to  <span class="math">B_{x_m}(G)</span>  is injective, therefore there are at most  <span class="math">|B_{x_m}(G)|</span>  monomials of  <span class="math">B_z(G)</span>  that are not divisible by  <span class="math">x_m</span> . In total,  <span class="math">(n+m)|B_{x_m}(G)|</span>  is an upper bound of the number of elements of B(G) going through (c). Each element going through (c) induces a complexity of  <span class="math">|D_I| \\cdot |B_z(G)| \\leq D_I^2</span>  look-up table accesses, therefore this last step has a total complexity  <span class="math">\\mathcal{O}((n+m)|B_{x_m}(G)| \\cdot D_I^2)</span> .</p>

    <p class="text-gray-300">In total, given that  <span class="math">|B(G)| \\leq (n+m)D_I</span>  and  <span class="math">|B_{x_m}(G)| = \\mathcal{O}(D_I \\operatorname{wt}(x_m)/d_m)</span> , the complexity of computing the multiplication matrix is:</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{O}\\left((n+m)D_I^3w_x/d_m\\right)</span>$
.</p>

      <h3 id="app-c.2" class="text-xl font-semibold mt-8">C.2 Refined analysis of the multiplication matrix based on [27]</h3>

    <p class="text-gray-300">Computing the multiplication matrix in a grevlex ordering. Let  <span class="math">\\prec</span>  be a grevlex ordering and  <span class="math">d_{\\text{max}}</span>  be the maximal total degree among monomials in the canonical basis of R/I, so that  <span class="math">d_{max} + 1</span>  is a bound for the total degree of elements in B(G). The idea of [27, Algorithm 4] is to sort the elements in the bordering B(G) according to their total degree instead of the monomial ordering, that is, for each  <span class="math">1 \\leq d \\leq d_{\\text{max}} + 1</span> , consider  <span class="math">B(G)_d</span>  the elements of the bordering B(G) of degree d. [27] remarked that if the normal forms of elements of  <span class="math">B(G)_1 \\dots B(G)_{d-1}</span>  have been computed, then the normal forms of all elements of  <span class="math">B(G)_d</span>  can be computed simultaneously. To do so, for each  <span class="math">m \\in B(G)_d</span> , [27] finds a polynomial in I whose leading term is m: either m is the leading term of an element of G, or m can be written as  <span class="math">x_i \\times m&#x27;</span>  with  <span class="math">m&#x27; \\in B(G)_{d-1}</span> , which implies that  <span class="math">x_i(m&#x27;-Red_{G,\\prec}(m&#x27;))</span>  is a polynomial in I whose leading term is m. [27] places each such polynomial in a Macaulay-like matrix  <span class="math">M_d</span> , whose columns represent the monomials in  <span class="math">B(G)_1 \\cup \\cdots \\cup B(G)_d \\cup \\mathcal{C}</span> . [27] also places the polynomials  <span class="math">m - Red_{G, \\prec}(m)</span>  for  <span class="math">m \\in B(G)_1 \\cup \\cdots \\cup B(G)_{d-1}</span>  in  <span class="math">M_d</span> . Let us define  <span class="math">B_d = |B(G)_d|</span>  and  <span class="math">B_{1,d-1} = \\sum_{i=1}^{d-1} B_i</span> . All in all,  <span class="math">M_d</span>  is a  <span class="math">B_{1,d} \\times (B_{1,d} + D_I)</span> matrix. the inner structure of  <span class="math">M_d</span>  can be described as:</p>

    <p class="text-gray-300"><span class="math">$M_{d} = \\begin{pmatrix} B_{d} &amp; B_{1,d-1} &amp; D_{I} \\\\ A &amp; B &amp; C \\\\ 0 &amp; I &amp; D \\end{pmatrix} \\updownarrow B_{1,d-1}</span>$</p>

    <p class="text-gray-300">where 0 and I correspond to respectively the zero and identity matrices. From this matrix, in order to obtain the normal forms of the elements of  <span class="math">B(G)_d</span> , all one has to do is to compute  <span class="math">A^{-1}(C-BD)</span> , which is a  <span class="math">B_d \\times D_I</span>  matrix containing all the desired normal forms.</p>

    <p class="text-gray-300">Complexity analysis. We make use of the following lemma:</p>

    <p class="text-gray-300"><strong>Lemma 3 (Rectangular matrix multiplication).</strong> Let M and  <span class="math">m \\times n</span>  matrix and N an  <span class="math">n \\times p</span>  matrix. The product  <span class="math">M \\cdot N</span>  can be computed in time:</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{O}(\\max(mnp^{\\omega-2}, m^{\\omega-2} \\cdot np, mn^{\\omega-2} \\cdot p))</span>$
.</p>

    <p class="text-gray-300">The lemma follows from a decomposition of M and N in square blocks of size  <span class="math">\\min(m,n,p)</span> .</p>

    <p class="text-gray-300">Computing the normal forms of the elements of  <span class="math">B(G)_d</span>  at step d requires to compute  <span class="math">A^{-1}</span>  in</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{O}(B_d^{\\omega})</span>$</p>

    <p class="text-gray-300">operations, computing  <span class="math">B \\times D</span>  in</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{O}\\left(\\max(B_d^{\\omega-2}\\cdot B_{1,d}\\cdot D_I,\\ B_d\\cdot B_{1,d}^{\\omega-2}\\cdot D_I,\\ B_d\\cdot B_{1,d}\\cdot D_I^{\\omega-2})\\right)</span>$</p>

    <p class="text-gray-300">operations, and finally computing  <span class="math">A^{-1} \\times (C - BD)</span>  in</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{O}\\left(\\max(B_d^{\\omega-1}\\cdot D_I, B_d\\cdot D_I^{\\omega-1})\\right)</span>$</p>

    <p class="text-gray-300">operations.</p>

    <p class="text-gray-300">Since  <span class="math">B_d \\leq B_{1,d} \\leq nD_I</span>  (where n is the number of variables) and  <span class="math">\\max(a,b) \\leq a+b</span> , the cost of step d can easily be bounded by:</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{O}(B_d^{\\omega-2} \\cdot nD_I^2 + nB_d \\cdot D_I^{\\omega-1}).</span>$</p>

    <p class="text-gray-300">Therefore, because of the concavity of the function  <span class="math">x \\mapsto x^{\\omega-2}</span> , and assuming that  <span class="math">n \\leq d_{\\text{max}}</span> , the total complexity can be bounded by:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp;\\sum_{d=1}^{d_{\\max}+1} \\mathcal{O}\\left(B_d^{\\omega-2} \\cdot nD_I^2 + nB_d \\cdot D_I^{\\omega-1}\\right) \\\\ &amp;\\leq \\mathcal{O}\\left(nD_I^2 d_{\\max}\\left(\\frac{\\sum_{d=1}^{d_{\\max}+1} B_d}{d_{\\max}}\\right)^{\\omega-2} + nB_{1,d_{\\max}} D_I^{\\omega-1}\\right) \\\\ &amp;= \\mathcal{O}(d_{\\max}^{3-\\omega} n^{\\omega-1} D_I^{\\omega} + n^2 D_I^{\\omega}) \\\\ &amp;= \\mathcal{O}(d_{\\max}^{3-\\omega} n^{\\omega-1} D_I^{\\omega}). \\end{split}</span>$</p>

    <p class="text-gray-300">Adaptation to weighted orderings. Let us now assume that we possess a Gr&ouml;bner basis for a weighted monomial ordering with weights  <span class="math">(w_1, \\ldots w_n)</span> . In order to use the multiplication matrix computation algorithm of [27] with weighted orderings, we need the  <span class="math">w_i</span> 's to be integers, so that the elements in the bordering B(G) have integer weighted degrees, and so that for each  <span class="math">m \\in B(G)</span> , there exists an integer  <span class="math">1 \\le d \\le w d_{\\max} + \\max(w_i)</span> , where  <span class="math">w d_{\\max}</span>  is the maximum weighted degree among monomials in the canonical basis of R/I, such that  <span class="math">m \\in B(G)_d</span> . The same analysis holds, but  <span class="math">d_{\\max} + 1</span>  should be replaced by  <span class="math">w d_{\\max} + \\max(w_i)</span> . Since we expect every variable to appear in R/I, we expect  <span class="math">w d_{\\max} \\ge \\max(w_i)</span> , giving the following bound for computing a multiplication matrix for CheapLunch systems:</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{O}\\left(wd_{\\max}^{3-\\omega}(n+m)^{\\omega-1}D_I^{\\omega}\\right). \\tag{17}</span>$</p>

    </section>

    <section id="app-d" class="mb-10">
      <h2 class="text-2xl font-bold">D Round-skipping trick on the first rounds</h2>

      <h3 id="app-d.1" class="text-xl font-semibold mt-8">D.1 Case of SPN with monomial S-boxes</h3>

    <p class="text-gray-300">Case of an MDS matrix In this section, we show how reduce the ideal degree of the ideal by partially skipping the first round. Let M an MDS matrix, and  <span class="math">s = \\lfloor t/k \\rfloor - 2 \\leq k</span> . We also let  <span class="math">M^{-1} = (m_{ij}^{\\text{inv}})_{1 \\leq i,j \\leq t}</span>  the inverse of M, which is also MDS. For  <span class="math">1 \\leq l \\leq s</span> , we consider the matrix  <span class="math">(m_{ij}^{\\text{inv}})_{\\substack{t-k+1 \\leq i \\leq t \\ (l-1)(k+1)+1 \\leq j \\leq l(k+1)}}</span>  this  <span class="math">k \\times (k+1)</span>  matrix has a kernel of dimension at least 1. We let  <span class="math">a_l</span>  a nonzero vector in this kernel.</p>

    <p class="text-gray-300">Then, we turn our attention to  <span class="math">(m_{ij}^{\\mathrm{inv}})_{\\substack{t-k+1\\leq i\\leq t\\\\s(k+1)+1\\leq j\\leq t}}</span> , this is a  <span class="math">k\\times (t-s(k+1))</span>  submatrix of  <span class="math">M^{-1}</span> . As  <span class="math">M^{-1}</span>  is MDS, its submatrix has full rank. Thus, we can find independent vectors  <span class="math">a_{s+1},\\ldots a_k</span>  in its kernel (as  <span class="math">k-s\\leq t-s(k+1)-k</span> ) and a vector  <span class="math">b\\in \\mathbb{F}_p^{t-s(k+1)}</span>  such that  <span class="math">M^{-1}((0,\\ldots,0,b)-c_E^{(1)})\\in \\mathbb{F}_p^{t-k}\\times \\{0\\}^k</span> .</p>

    <p class="text-gray-300">Setting the state after the affine layer to</p>

    <p class="text-gray-300"><span class="math">$\\left(a_1 \\cdot x_1^{1/d}, \\dots, a_s \\cdot x_s^{1/d}, \\sum_{l=s+1}^k a_l \\cdot x_l + b\\right)</span>$
,</p>

    <p class="text-gray-300">we get after the layer of S-boxes the state</p>

    <p class="text-gray-300"><span class="math">$(a_1^d \\cdot x_1, \\dots, a_s^d \\cdot x_s, P_1(x_{s+1}, \\dots, x_k), \\dots, P_{t-s(k+1)}(x_{s+1}, \\dots, x_k))</span>$
,</p>

    <p class="text-gray-300">where the  <span class="math">P_i</span>  have degree d. Multiplying the weight of  <span class="math">x_1, \\ldots, x_s</span>  by d and keeping weights of  <span class="math">x_{s+1}, \\ldots, x_k</span>  and the  <span class="math">y_j</span> , we keep the same bounds on the weighted degrees of the polynomials in the system from Section 4.1 and 4.2. Thus, our new weights only increase the denominator in the weighted B&eacute;zout bound by a factor  <span class="math">d^s</span> , dividing the upper bound on  <span class="math">D_I</span>  by the same factor.</p>

    <p class="text-gray-300">Case of a non-MDS matrix Though we did not manage to do an extensive study of the round-skipping tricks in the non-MDS case, we have made some observations that tend to show that non-MDS matrices such as the ones defined in Poseidon2 may be weaker against such tricks than MDS ones. We provide here an example of a vector allowing to skip two rounds in the case where  <span class="math">M_E</span>  is defined as in [35] and where t = 16, k = 1 (ie. we reduce  <span class="math">D_I</span>  by a factor  <span class="math">d^2</span>  instead of d). This tends to show that contrary to what was believed by the designers of Poseidon2, using non-MDS matrices not only weakens the security against statistical attacks, but also against some algebraic attacks. The matrix  <span class="math">M_E</span>  is as</p>

    <p class="text-gray-300">    <img src="_page_41_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 3. Round-skipping trick for t = 9, k = 3, s = 1.</p>

    <p class="text-gray-300">follows:</p>

    <pre><code class="language-text"> 10 14 2 6 5 7 1 3 5 7 1 3 5 7 1 3
 8 12 2 2 4 6 1 1 4 6 1 1 4 6 1 1
 2 6 10 14 1 3 5 7 1 3 5 7 1 3 5 7
 2 2 8 12 1 1 4 6 1 1 4 6 1 1 4 6
 5 7 1 3 10 14 2 6 5 7 1 3 5 7 1 3
 4 6 1 1 8 12 2 2 4 6 1 1 4 6 1 1
 1 3 5 7 2 6 10 14 1 3 5 7 1 3 5 7
 1 1 4 6 2 2 8 12 1 1 4 6 1 1 4 6
 5 7 1 3 5 7 1 3 10 14 2 6 5 7 1 3
 4 6 1 1 4 6 1 1 8 12 2 2 4 6 1 1
 1 3 5 7 1 3 5 7 2 6 10 14 1 3 5 7
 1 1 4 6 1 1 4 6 2 2 8 12 1 1 4 6
 5 7 1 3 5 7 1 3 5 7 1 3 10 14 2 6
 4 6 1 1 4 6 1 1 4 6 1 1 8 12 2 2
 1 3 5 7 1 3 5 7 1 3 5 7 2 6 10 14
 1 1 4 6 1 1 4 6 1 1 4 6 2 2 8 12
</code></pre>

    <p class="text-gray-300">.</p>

    <p class="text-gray-300">We can for instance skip two rounds on an instance defined over the prime number <sup>p</sup>koalabear = 2<sup>31</sup> <sup>&minus;</sup> <sup>2</sup> <sup>24</sup> + 1, in which case d = 3 and the first two round constants<sup>9</sup> are:</p>

    <p class="text-gray-300"><span class="math">$C^{(1)} = \\begin{pmatrix} 0x1b9721fa\\\\ 0x1252dc26\\\\ 0x686dc5c6\\\\ 0x65e48721\\\\ 0x68c4a3e4\\\\ 0x5dc974d7\\\\ 0x6c06ab8f\\\\ 0x286a3475\\\\ 0x103790a\\\\ 0x30cfa2c1\\\\ 0x6087354f\\\\ 0x7c66b137\\\\ 0x42070c64\\\\ 0x6f777ed5\\\\ 0xbc35277 \\end{pmatrix}, C^{(2)} = \\begin{pmatrix} 0x37b608e3\\\\ 0x2a201928\\\\ 0x6a38a2ab\\\\ 0x796c8c09\\\\ 0x460cd14\\\\ 0x6bac6d28\\\\ 0x4551b22d\\\\ 0x773c1a8d\\\\ 0x5e977d45\\\\ 0x463ecca9\\\\ 0x7011d7aa\\\\ 0x7767d67f\\\\ 0x545d8d19\\\\ 0x2801b9fe\\\\ 0x143c8a7e\\\\ 0x1bdd37c \\end{pmatrix}</span>$</p>

    <p class="text-gray-300">We can have a subspace chain of the form:</p>

    <p class="text-gray-300"><span class="math">$a_0 \\cdot X + b_0 \\xrightarrow{S_E \\circ (C^{(1)} + M_E(.))} a_1 \\cdot Y + b_1 \\xrightarrow{S_E \\circ (C^{(2)} + M_E(.))} a_2 \\cdot Z + b_2 \\ .</span>$</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">$a_0 = \\begin{pmatrix} 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times 0 \\\\ 0 \\times</span>$</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;9</sup> Taken from: https://github.com/0xPolygonZero/hash-constants</p>

    <p class="text-gray-300"><span class="math">$b_1 = \\begin{pmatrix} 0x7735495b \\\\ 0x537f27be \\\\ 0x1bb89dd6 \\\\ 0x8 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x0 \\\\ 0x1d4d82d8 \\\\ 0x710ad114 \\\\ 0x19a2ea37 \\\\ 0x565348fb \\\\ 0x66dd789c \\\\ 0x906ff3d \\end{pmatrix}</span>$</p>

    <p class="text-gray-300">We leave as an open problem a more systematic study of this phenomenon.</p>

      <h3 id="app-d.2" class="text-xl font-semibold mt-8">D.2 Case of Griffin</h3>

    <p class="text-gray-300">The bounds on the ideal degree have been derived by introducing the variables  <span class="math">x_1, \\ldots, x_k</span>  on k input branches in a naive way and setting the t-k other ones to 0. When t&gt;2k, it is feasible to choose the input state to get a modeling with a lower ideal degree. Let  <span class="math">t, k \\in \\mathbb{N}</span> , we can skip rounds in GRIFFIN as summarized in Table 3. We introduce  <span class="math">\\alpha_{d,k} = d(3^k - 1) + 1</span>  and recall that without round-skipping, we conjecture that  <span class="math">D_I \\leq (d \\cdot \\alpha_{d,k})^R</span> . We say that we have an advantage over  <span class="math">D_I</span>  of  <span class="math">\\alpha</span>  if we can find a modeling of the CICO problem that makes the ideal degree upper bounded by  <span class="math">(d \\cdot \\alpha_{d,k})^R/\\alpha</span> .</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\overline{t}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">2k + 1</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\geq 2k+2</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">4k + 2 - 2s, s \\le k/2</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">4k + 4</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\geq 4k + 6</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Adv.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">d</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">d \\cdot \\alpha_{d,k}/3^k</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">d \\cdot \\alpha_{d,k}/3^{2s-1}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">d^2 \\cdot \\alpha_{d,k}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\left(d\\cdot\\alpha_{d,k}\\right)^2/3^k</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300"><strong>Table 3.</strong> Advantage over  <span class="math">D_I</span>  using round skips in GRIFFIN.</p>

    <p class="text-gray-300">The round-skipping tricks are performed as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">Let t = 2k + 1: We can find a k-dimensional vector space  <span class="math">X \\subset \\mathbb{F}_p^{t-k} \\times \\{0\\}^k</span>  such that for  <span class="math">x \\in X</span> ,  <span class="math">M \\cdot x \\in \\{0\\} \\times \\mathbb{F}_p^{t-1}</span> . Thus we do not activate the first round  <span class="math">x^{1/d}</span> , reducing the ideal degree by a factor d.</p></li>
      <li><p class="text-gray-300">Let  <span class="math">t \\geq 2k + 2</span> : We take a k-dimensional space such that for  <span class="math">x \\in X</span> ,  <span class="math">M \\cdot x \\in \\{0\\}^2 \\times \\mathbb{F}_p^{t-2}</span> . Thus we do not activate the first round  <span class="math">x^{1/d}</span>  and  <span class="math">x^d</span> , so that we only have degree 3 polynomials in the  <span class="math">x_i</span>  at round 2 (we do not have to introduce  <span class="math">y_1</span>  and  <span class="math">z_1</span> ).</p></li>
      <li><p class="text-gray-300">Let  <span class="math">t = 4k + 2 - 2s, s \\le k/2</span> : We can find a k-dimensional vector space  <span class="math">X \\subset \\mathbb{F}_p^{t-k} \\times \\{0\\}^k</span>  such that for  <span class="math">x \\in X</span> ,  <span class="math">M \\cdot x \\in \\{0\\}^2 \\times (\\mathbb{F}_p \\times \\{0\\})^{2(k-s)} \\times \\mathbb{F}_p^{2s}</span> . Taking an input state in X, we can get after the first nonlinear layer a state of the form:</p></li>
    </ul>

    <p class="text-gray-300"><span class="math">$(0,0,L_1(\\mathbf{x}),0,\\ldots,L_{2(k-s)}(\\mathbf{x}),0,\\tilde{L}_1(\\mathbf{x}),P_2(\\mathbf{x}),\\ldots,P_{2s}(\\mathbf{x}))</span>$
,</p>

    <p class="text-gray-300">where the  <span class="math">L_i</span> ,  <span class="math">\\tilde{L}_1</span>  are linear functions, and the  <span class="math">P_i</span>  have degree 3. Introducing for each  <span class="math">P_i</span>  a variable  <span class="math">\\tilde{x}_i = P_i(\\mathbf{x})</span>  of weight 1, we get a state of weight 1 after one round at the cost of 2s-1 equations of degree 3. Hence, it amounts to skipping one round of GRIFFIN and adding 2s-1 equations of degree 3, which adds a factor  <span class="math">3^{2s-1}</span>  to the ideal degree of an R-1-round GRIFFIN.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let t=4k+4: In addition to not activating the  <span class="math">x^d, x^{1/d}</span>  and one out of two branches in the Horst layer in the first round, we also do not activate the second round  <span class="math">x^{1/d}</span> . This is feasible as we can find a k+1-dimensional space such that for  <span class="math">x \\in X</span> ,  <span class="math">M \\cdot x \\in \\{0\\}^2 \\times (\\mathbb{F}_p \\times \\{0\\})^{2k+1}</span> . After the first nonlinear layer, this space is mapped to another k+1-dimensional vector space and we can cancel out the coordinate in  <span class="math">x^{1/d}</span>  of the second round.</li>
      <li>The case  <span class="math">t \\ge 4k+6</span>  is very similar to the previous one, except that we make use of our additional degree of freedom to not activate the second round  <span class="math">x^d</span> .</li>
    </ul>

    </section>

    <section id="app-e" class="mb-10">
      <h2 class="text-2xl font-bold">E Experiments</h2>

      <h3 id="app-e.1" class="text-xl font-semibold mt-8">E.1 Regularity assumption tests</h3>

    <p class="text-gray-300">We test the property of regularity (Definition 9)used in proving results on the Gr&ouml;bner basis computation of CheapLunch systems from Section 4. Specifically, we check if the Hilbert series of the highest degree component of the subsystem  <span class="math">\\mathcal Q</span>  is equal to the expected form as stated in Definition 5. To make the computation of the system more efficient, we make certain simplifications in our experiment. Specifically, as we are only interested in higest degree (&quot;top&quot;) part of the system, we remove (at round level computation) the constant addition and also get rid of the lower degree terms after computing the partial rounds. This allows us to construct the polynomials more efficiently in order to test closer to realistic parameters. Then we compute the Hilbert series in Magma and compare it with the expected form, in python, Following is the table of parameters for which we performed the tests.</p>

    <p class="text-gray-300"><strong>Poseidon</strong> For generating the MDS matrix, we used the SageMath script  <span class="math">^{10}</span>  provided in the Poseidon paper, and use the same primes for our tests. In Table 4 we list the different values of number of full rounds  <span class="math">R_F</span> , number of partial rounds  <span class="math">R_P</span> , S-Box exponent  <span class="math">\\alpha</span> , number of branches t, CICO-constraint k for which we verified the regularity assumption.</p>

    <p class="text-gray-300">https://extgit.isec.tugraz.at/krypto/hadeshash/-/tree/master/code?ref_ type=heads</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Field size (bits)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">R_F/2</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">R_P</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\alpha</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">t</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">k</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2,3</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">254</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2,3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">254</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2,3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">255</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">255</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 4. Parameters tested for regularity for Poseidon</p>

    <p class="text-gray-300"><strong>Neptune</strong> We follow the design from [37] and generator random matrices, which are used to define external and internal MDS matrix. In Table 5 we list the different values of number of first full rounds  <span class="math">R_{F1}</span> , number of partial rounds  <span class="math">R_{P}</span> , number of first full rounds  <span class="math">R_{F2}</span> , number of branches t, CICO-constraint k for which we verified the regularity assumption. The S-Box exponent  <span class="math">\\alpha</span>  is always set to 3.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Field size (bits)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">R_{F1}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">R_P</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">R_{F2}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">t</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">k</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4,6,8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">255</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4,6,8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">254</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4,6,8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 5. Parameters tested for regularity for Neptune</p>

      <h3 id="app-e.2" class="text-xl font-semibold mt-8">E.2 ArionHash</h3>

    <p class="text-gray-300">We provide the details of experiments for testing the ideal degree for some instances of ArionHash. We choose small scale parameter sets, following [44]. Specifically, for two cases p=10007, e=3 and p=15013, e=5, we vary the values of  <span class="math">t, k, \\alpha</span>  and compute the degree of the ideal  <span class="math">D_I</span> . In [44] this was only tested for the case of k=1, and in this case the experimental data matches their conjectured upper bound. However for k&gt;1 we observed that the Weighted B&eacute;zout bound 2 is not tight for estimating the value of  <span class="math">D_I</span> . This is expected since the system is not regular as discussed in 5.2. Below we present the experimental results for ideal degree of ArionHash in table E.2 and show that the upper bound we derive in (16) holds.</p>

    <p class="text-gray-300">A better upper bound for  <span class="math">D_I</span>  As discussed in 5.2, the output constraint polynomials  <span class="math">Q_1, \\ldots, Q_k</span>  are linear combinations of  <span class="math">F_1^{(r)}, \\ldots, F_t^{(r)}</span>  and  <span class="math">deg(F_1^r) &gt;</span></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">t</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">k</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">p = 100</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">p = 10007, e = 3</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">013, e = 5</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">D_I</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Bound</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">D_I</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Bound</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\alpha = 7</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">623</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2639</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1351</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5719</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1855</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12383</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4207</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">27391</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3619</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">160979</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11557</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">520429</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4991</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">53375</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11599</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">119119</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\alpha = 257</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">22873</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">96889</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">49601</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">209969</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300"><strong>Table 6.</strong> Experimental results for Ideal degree of ArionHash</p>

    <p class="text-gray-300"><span class="math">deg(F_2^r) &gt; \\dots &gt; deg(F_t^r)</span> . Hence, the system os not regular, but we use these dependencies to cancel out higher degree terms and improve the upper bound for  <span class="math">D_I</span> . Moreover, as seen in table E.2, this bound is far from being a tight bound and we point out a possible cause of this, which is presence of further dependencies in the polynomials. From equation (11), we can write</p>

    <p class="text-gray-300"><span class="math">$Top(F_{j-1}^{r}(\\mathbf{x})) = L_{j-1}^{(r-1)}(\\mathbf{x})^{e} \\cdot Top(\\sigma_{j,t})^{2} = L_{j-1}^{(r-1)}(\\mathbf{x})^{e} \\cdot Top(F_{j}^{r}(\\mathbf{x}))^{2}</span>$
(18)</p>

    <p class="text-gray-300">
<span class="math">$Top(F_{t-1}^{(r)}) = L_{t-1}^{(r-1)}(\\mathbf{x})^e \\cdot (L_t^{(r-1)}(\\mathbf{x}))^2 , \\qquad (19)</span>$</p>

    <p class="text-gray-300">Thus, we can see that after the non-linear layer, the highest degree component of output on a branch depends on the input of that branch, and the highest degree component of the previous branch. (In fact this property was used in [44, Lemma 2] to prove the degree at every round). This observation could possibly be exploited to improve the upper bound from (16), since the degrees of polynomials in the state after a non-linear round decrease from &quot;left-to -right&quot;</p>

    <p class="text-gray-300">However, there are certain limitations in test this experimentally. The highest degree at j-th round of ArionHash is  <span class="math">(2^{t-1}(e+1)-e)^j</span> . This limits us in the number of rounds for which we can build the polynomial system and compute the ideal degree. In our experiments, we could only test for r=1. As a result of this, it is important to note that we cannot take into consideration the contribution of r and the contribution of weights in experimental values of  <span class="math">D_I</span> . Moreover, from (19) the terms  <span class="math">F_j^{(r)}</span>  have a recurrence relation, but they also depend on  <span class="math">L_j^{(r-1)}</span>  from the previous round, and for  <span class="math">r=1,L_k^{(r-1)}</span> ) are simply linear functions in the input variables  <span class="math">x_1,\\ldots,x_k</span> . Thus, the exact contribution of these dependencies may not appear in experiments for r=1.</p>

      <h3 id="app-e.3" class="text-xl font-semibold mt-8">E.3 Griffin</h3>

    <p class="text-gray-300">We provide here the results of our experiments on the weighted degree of regularity for the Griffin CICO-k problem. We conducted experiments on various values of k, d, R (with t=8) and made the following conjecture:</p>

    <p class="text-gray-300">Conjecture 2 (weighted degree of regularity of GRIFFIN). For all t, k, d, R, the weighted degree of regularity  <span class="math">wd_{\\text{reg}}</span>  of the GRIFFIN CICO-k problem is upper bounded as:</p>

    <p class="text-gray-300"><span class="math">$wd_{\\text{reg}} \\leq dk \\cdot 3^R</span>$
.</p>

    <p class="text-gray-300">We computed the weighted degree of regularity by running weighted F5 on the system, and take the highest weighted degree at which a new polynomial is added to the Gr&ouml;bner basis. It is easy to check that the Macaulay matrix at this degree contains a Gr&ouml;bner basis of the system, and that this is the lowest degree verifying such condition. We report our results in the following tables, with a comparison to our conjectured upper bound.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\overline{d}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">2</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">3</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">5</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">7</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">wd_{\\mathrm{reg}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">34</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">48</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">79</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">122</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">dk \\cdot 3^R</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">36</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">54</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">90</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">126</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300"><strong>Table 7.</strong> Influence of d on  <span class="math">wd_{reg}</span>  in the case where k = R = 2.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">(R,k,d)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">(2, 3, 2)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">(2, 3, 3)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">(3, 2, 2)</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">wd_{\\mathrm{reg}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">49</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">74</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">105</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">dk \\cdot 3^R</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">54</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">81</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">108</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300"><strong>Table 8.</strong> Influence of R, k on  <span class="math">wd_{reg}</span> .</p>

      <h3 id="app-e.4" class="text-xl font-semibold mt-8">E.4 Experimental results on XHash</h3>

    <p class="text-gray-300">In the following table, our results on XHash are described. The column &quot;Does Sec. 3.3 apply?&quot; has a checkmark  <span class="math">(\\checkmark)</span>  if and only if  <span class="math">\\mathcal{G}(P,Q)</span>  can be decomposed as  <span class="math">P \\cup \\mathcal{G}(Q)</span> , and  <span class="math">\\mathcal{G}(Q)</span>  can directly be computed from  <span class="math">\\mathcal{G}(Q^{\\text{top}})</span>  as per Section 3.3. Experimentally, we can use the following heuristic workaround in some of the &quot;bad&quot; cases: instead of defining  <span class="math">\\mathcal{Q}^{\\text{top}}</span>  only with the homogeneous top part of the  <span class="math">Q_i</span> , use several &quot;top homogeneous slices&quot; from the  <span class="math">Q_i</span> , none of which contain the  <span class="math">y_{i,j}</span>  variables. The system obtained is not homogeneous, but we can still use  <span class="math">F_4</span></p>

    <p class="text-gray-300">to compute a GB for it, and a variant of Lemma <a href="#page-11-1">1</a> applies correctly. The precise study of this approach falls outside of the scope of this paper, and we leave it for future work.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">(t, k, nS)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">wdreg</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">(Thm. 1)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">DI</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">(B&acute;ezout)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Does Sec. 3.3 apply?</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(2,2,1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(17)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">81</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(243)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#10007;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(3,2,1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(17)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">243</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(243)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#10003;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(3,2,2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(17)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">243</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(729)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#10007;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(3,3,1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(25)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">729</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(2187)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#10007;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(3,3,2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(25)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">729</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(6561)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#10007;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(4,2,1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(17)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">243</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(243)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#10003;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(4,2,2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(17)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">729</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(729)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#10003;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(4,2,3)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(17)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">729</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(2187)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#10007;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(4,3,1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">25</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(25)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2187</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(2187)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#10003;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(4,3,2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(25)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2187</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(6561)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#10007;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(5,2,1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(17)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">243</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(243)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#10003;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(5,2,2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(17)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">729</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(729)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#10003;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(5,2,3)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(17)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2187</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(2187)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#10003;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(5,2,4)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(17)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2187</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(6561)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#10007;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(5,3,1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">25</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(25)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2187</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(2187)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#10003;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(6,2,1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(17)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">243</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(243)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#10003;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(6,2,2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(17)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">729</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(729)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#10003;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(7,2,1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(17)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">243</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(243)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#10003;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(7,2,2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(17)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">729</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(729)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#10003;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(8,2,1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(17)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">243</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(243)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#10003;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(8,2,2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(17)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">729</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(729)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#10003;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(9,2,1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(17)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">243</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(243)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#10003;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(9,2,2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(17)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">729</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(729)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#10003;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(10,2,1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(17)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">243</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(243)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#10003;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(10,2,2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(17)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">729</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(729)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#10003;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(11,2,1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(17)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">243</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(243)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#10003;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(11,2,2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(17)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">729</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(729)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#10003;</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 9. Experimental data of XHash8 on a reduced version of (F)(B )(P3). n<sup>S</sup> is the number of Sboxes per (P &prime; ) layer. We take &alpha; = 3 instead of 7.</p>

    </section>

    <section id="app-f" class="mb-10">
      <h2 class="text-2xl font-bold">F Figures of some round function</h2>

    <p class="text-gray-300">    <img src="_page_49_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 4. The first round of XHash8.</p>

    <p class="text-gray-300">    <img src="_page_49_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300"><strong>Fig. 5.</strong> The Griffin round function for t = 4.</p>

    </section>
`;
---

<BaseLayout title="The Algebraic CheapLunch: Extending FreeLunch Attacks on Ari... (2025/2040)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2025 &middot; eprint 2025/2040
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#sec-1" class="hover:text-white">Introduction</a></li>
        <li>
          <a href="#sec-2" class="hover:text-white">Preliminaries</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-2.1" class="hover:text-white">CICO problem</a></li>
            <li><a href="#sec-2.2" class="hover:text-white">Polynomial system solving via Gr&ouml;bner bases</a></li>
            <li><a href="#sec-2.3" class="hover:text-white">Gr&ouml;bner bases for weighted homogeneous systems</a></li>
            <li><a href="#sec-2.4" class="hover:text-white">Ideal degree for weighted homogeneous systems</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-3" class="hover:text-white">The CheapLunch Framework for Solving CICO-k</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-3.1" class="hover:text-white">Toy example</a></li>
            <li><a href="#sec-3.2" class="hover:text-white">Gr&ouml;bner bases for regular CheapLunch systems</a></li>
            <li><a href="#sec-3.4" class="hover:text-white">Complexity estimates</a></li>
            <li><a href="#sec-3.5" class="hover:text-white">Change of ordering step</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-4" class="hover:text-white">Primitives with Regular CheapLunch Systems</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-4.1" class="hover:text-white">XHash8</a></li>
            <li><a href="#sec-4.2" class="hover:text-white">Poseidon and Neptune</a></li>
            <li><a href="#sec-4.3" class="hover:text-white">Neptune in compression mode</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-5" class="hover:text-white">Non-Regular Examples</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-5.1" class="hover:text-white">Griffin</a></li>
            <li><a href="#sec-5.2" class="hover:text-white">ArionHash</a></li>
          </ol>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li>
          <a href="#app-a" class="hover:text-white">On Sponges and CICOs</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-a.1" class="hover:text-white">Polynomial Systems in the AO Setting</a></li>
            <li><a href="#app-a.2" class="hover:text-white">The Sponge Construction</a></li>
            <li><a href="#app-a.3" class="hover:text-white">Modeling Polynomial Systems From the Sponge</a></li>
          </ol>
        </li>
        <li><a href="#app-b" class="hover:text-white">Background on Gr&ouml;bner Bases</a></li>
        <li>
          <a href="#app-c" class="hover:text-white">Change of ordering</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-c.1" class="hover:text-white">Refined analysis of the multiplication matrix computation for CheapLunch Systems based on FGLM&#x27;s approach</a></li>
            <li><a href="#app-c.2" class="hover:text-white">Refined analysis of the multiplication matrix based on [27]</a></li>
          </ol>
        </li>
        <li>
          <a href="#app-d" class="hover:text-white">Round-skipping trick on the first rounds</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-d.1" class="hover:text-white">Case of SPN with monomial S-boxes</a></li>
            <li><a href="#app-d.2" class="hover:text-white">Case of Griffin</a></li>
          </ol>
        </li>
        <li>
          <a href="#app-e" class="hover:text-white">Experiments</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-e.1" class="hover:text-white">Regularity assumption tests</a></li>
            <li><a href="#app-e.2" class="hover:text-white">ArionHash</a></li>
            <li><a href="#app-e.3" class="hover:text-white">Griffin</a></li>
            <li><a href="#app-e.4" class="hover:text-white">Experimental results on XHash</a></li>
          </ol>
        </li>
        <li><a href="#app-f" class="hover:text-white">Figures of some round function</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#acknowledgements" class="hover:text-white">Acknowledgements</a></li>
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="c-1-refined-analysis-of-the-multiplication-matrix-2025" />
  </article>
</BaseLayout>
