---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2017/602';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-21';
const TITLE_HTML = 'A multi-party protocol for constructing the public parameters of the Pinocchio zk-SNARK';
const AUTHORS_HTML = 'Sean Bowe, Ariel Gabizon, Matthew D.  Green';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">Recent efficient constructions of zero-knowledge Succinct Non-interactive Arguments of Knowledge (zk-SNARKs),
require a setup phase in which a common-reference string (CRS) with a certain structure is generated.
This CRS is sometimes referred to as the public parameters of the system, and is used for constructing and verifying proofs.
A drawback of these constructions is that whomever runs the setup phase subsequently possesses trapdoor information enabling them
to produce fraudulent pseudoproofs.

Building on a work of Ben-Sasson, Chiesa, Green, Tromer and Virza [BCGTV15], we construct a multi-party protocol for generating the CRS of the Pinocchio zk-SNARK [PHGR16], such that as long as at least one participating party is not malicious, no party can later construct fraudulent proofs except with negligible probability. The protocol also provides a strong zero-knowledge guarantee even in the case that all participants are malicious.

This method has been used in practice to generate the required CRS for the Zcash cryptocurrency blockchain.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> SNARKs &middot; zero-knowledge &middot; cryptocurrencies &middot; multi-party computation</p>
    </section>

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">The recently deployed Zcash cryptocurrency supports shielded (private) transactions where sender, receiver and amount are not revealed; and yet, an outside observer can still distinguish between a valid and non-valid transaction. The &quot;cryptographic engine&quot; that enables these shielded transactions is a zero-knowledge Succinct Non-interactive Argument of Knowledge (zk-SNARK); currently, Zcash uses the Pinocchio zk-SNARK [PHGR16], or more precisely, the variant of it described in [BCTV14] as implemented in libsnark[lib].</p>

    <p class="text-gray-300">A potential weakness of Zcash, is that if anybody obtained the trapdoor information corresponding to the Common Reference String (CRS) used for constructing and verifying the SNARKs, they could forge unlimited amounts of the currency, potentially without anyone detecting they are doing so.</p>

    <p class="text-gray-300">Motivated by this, Zcash generated the required CRS in an elaborate &quot;ceremony&quot; [Wil] to reduce the chance of this happening. The purpose of this technical report is to give a detailed description of the multi-party protocol that was used in the ceremony.</p>

    <p class="text-gray-300">Our results Ben-Sasson, Chiesa, Green, Tromer and Virza [BCG+15] presented a generic method for computing CRSs of zk-SNARKs in a multi-party protocol, with the property that only if all players collude together they can reconstruct the trapdoor, or, more generally, deduce any other useful information beyond the resultant CRS.</p>

    <p class="text-gray-300">Based on [BCG<sup>+</sup>15], we devise an arguably simpler method for generating the CRS of the Pinocchio zk-SNARK [PHGR16] with a similar security guarantee: Namely, given that the CRS generated by the protocol is later used to verify proofs; a party controlling all but one of the players will not be able to construct fraudulent proofs except with negligible probability. See Theorem 4.8 for details.</p>

    <p class="text-gray-300">Moreover, we show that even if a malicious party controls <em>all</em> players, statistical zero-knowledge holds when constructing proofs according to the resultant parameters. Interestingly, this means the protocol is useful also when <em>run by one player</em>; as the transcript will provide proof to the prover that sending her proof will not leak additional information.<sup>1</sup></p>

    <p class="text-gray-300">This property has been recently called <em>subversion Zero-Knowledge</em> [BFS16]. As opposed to the soundness guarantee, zero-knowledge only requires the random oracle model; and in particular, no knowledge assumptions in contrast to some recent works on subversion-ZK [Fuc17, ABLZ17]. On the other hand, our proof only obtains statistical-ZK with polynomially small error as opposed to the mentioned recent works that can obtain negligible error (again, using knowledge assumptions). See Theorem 4.10 for details.</p>

    <p class="text-gray-300"><strong>Organization of paper</strong> Section 2 introduces some terminology and auxiliary methods that will be used in the protocol. Section 3 describes the protocol in detail. Section 4 describes the security proof of the protocol.</p>

    </section>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 Definitions, notation and auxiliary methods</h2>

    <p class="text-gray-300"><strong>Terminology:</strong> We always assume we are working with a field  <span class="math">\\mathbb{F}_r</span>  for prime r chosen according to a desired security parameter (more details on this in Section 4). We assume together with  <span class="math">\\mathbb{F}_r</span>  we have generated groups  <span class="math">\\mathbb{G}_1,\\mathbb{G}_2,\\mathbb{G}_t</span> , all cyclic of order r; where we write  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span>  in additive notation and  <span class="math">\\mathbb{G}_t</span>  in multiplicative notation. Furthermore, we have access to generators  <span class="math">g_1 \\in \\mathbb{G}_1, g_2 \\in \\mathbb{G}_2</span> , and an efficiently computable pairing  <span class="math">e : \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_t</span> , i.e., a non-trivial map such that for any  <span class="math">a, b \\in \\mathbb{F}_r</span></p>

    <p class="text-gray-300"><span class="math">$e(a \\cdot g_1, b \\cdot g_2) = g_T^{a \\cdot b},</span>$</p>

    <p class="text-gray-300">for a fixed generator  <span class="math">g_T \\in \\mathbb{G}_t</span> . We use the notations  <span class="math">g := (g_1, g_2)</span>  and  <span class="math">G^* := \\mathbb{G}_1 \\setminus \\{0\\} \\times \\mathbb{G}_2 \\setminus \\{0\\}</span> .</p>

    <p class="text-gray-300">We think of the field size r as a parameter against which we measure efficiency. In particular, we say a circuit A is <em>efficient</em> if its size is polynomial in  <span class="math">\\log r</span> . More precisely, when we refer in the security analysis to an efficient adversary or efficient algorithm, we mean it is a (non-uniform) sequence of circuits indexed by r, of size poly  <span class="math">\\log r</span> . When we say &quot;with probability p&quot;, we mean &quot;with probability at least p&quot;.</p>

    <p class="text-gray-300">We assume we have at our disposal a function COMMIT taking as input strings of arbitrary length; that, intuitively speaking, behaves like a commitment scheme. That is, it is infeasible to deduce COMMIT's input from seeing its output, and it is infeasible to find two inputs that COMMIT maps to the same output. In our implementation we use the BLAKE-2 hash function as COMMIT. For the actual security proof, we need to assume that COMMIT's outputs are chosen by a random oracle.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;1</sup>Thanks to Eran Tromer for pointing this out, and more generally the connection to subversion zero-knowledge.</p>

    <p class="text-gray-300"><strong>Symmetric definitions</strong> In the following sections we introduce several methods that receive as parameters elements of both  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span> . We assume implicitly that whenever such a definition is made, we also have the symmetric definition where the roles are reversed between what parameters come from  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span> . For example, if we define a method receiving as input a vector of  <span class="math">\\mathbb{G}_1</span>  elements and a pair of  <span class="math">\\mathbb{G}_2</span>  elements. We assume thereafter that we also have the symmetric method receiving as input a vector of  <span class="math">\\mathbb{G}_2</span>  elements and a pair of  <span class="math">\\mathbb{G}_1</span>  elements.</p>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8">2.1 Comparing ratios of pairs using pairings</h3>

    <p class="text-gray-300"><strong>Definition 2.1.</strong> Given  <span class="math">s \\in \\mathbb{F}_r^*</span> , an s-pair is a pair (p,q) such that  <span class="math">p,q \\in \\mathbb{G}_1 \\setminus \\{0\\}</span> , or  <span class="math">p,q \\in \\mathbb{G}_2 \\setminus \\{0\\}</span> ; and  <span class="math">s \\cdot p = q</span> . When not clear from the context whether p,q are in  <span class="math">\\mathbb{G}_1</span>  or  <span class="math">\\mathbb{G}_2</span> , we use the terms  <span class="math">\\mathbb{G}_1</span> -s-pair and  <span class="math">\\mathbb{G}_2</span> -s-pair.</p>

    <p class="text-gray-300">A recurring theme in the protocol will be to check that two pairs of elements in  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span>  respectively, &quot;have the same ratio&quot;, i.e., are s-pairs for the same  <span class="math">s \\in \\mathbb{F}_r^*</span> . SameRatio((p,q),(f,H)):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If one of the elements p, q, f, H is zero; return rej.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Return acc if e(p, H) = e(q, f); return rej otherwise.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Claim 2.2. Given  <span class="math">p, q \\in \\mathbb{G}_1</span>  and  <span class="math">f, H \\in \\mathbb{G}_2</span> , SameRatio((p, q), (f, H)) = acc if and only if there exists  <span class="math">s \\in \\mathbb{F}_r^*</span>  such that (p, q) is a  <span class="math">\\mathbb{G}_1</span> -s-pair and (f, H) is a  <span class="math">\\mathbb{G}_2</span> -s-pair.</p>

    <p class="text-gray-300"><em>Proof.</em> Suppose that  <span class="math">s \\cdot p = q</span>  and  <span class="math">s&#x27; \\cdot f = H</span> . Write  <span class="math">p = a \\cdot g_1, f = b \\cdot g_2</span>  for some  <span class="math">a, b \\in \\mathbb{F}_r</span> . Note that if one of  <span class="math">\\{a, b, s, s&#x27;\\}</span>  is 0, we return rej in the first step.</p>

    <p class="text-gray-300">Otherwise, we have</p>

    <p class="text-gray-300"><span class="math">$e(p,H) = (a \\cdot g_1, bs&#x27; \\cdot g_2) = g_T^{abs&#x27;},</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$e(q, f) = (as \\cdot g_1, b \\cdot g_2) = g_T^{abs},</span>$</p>

    <p class="text-gray-300">and thus  <span class="math">\\mathsf{SameRatio}((p,q),(f,H)) = 1</span>  if and only if  <span class="math">s = s&#x27; \\pmod{r}</span> .</p>

    <p class="text-gray-300">Let  <span class="math">V = ((p_i, q_i))_{i \\in [d]}</span> , be a vector of pairs in  <span class="math">\\mathbb{G}_1</span> . We say V is an s-vector in  <span class="math">\\mathbb{G}_1</span>  if for each  <span class="math">i \\in [d]</span> ,  <span class="math">(p_i, q_i)</span>  is a  <span class="math">\\mathbb{G}_1</span> -s-pair, or is equal to (0,0). We make the analogous definition for  <span class="math">\\mathbb{G}_2</span> , and similarly to above, sometimes omit the group name when it is clear from the context what group the elements are in, simply using the term s-vector. In our protocol we often want to check if a long vector  <span class="math">((p_i, q_i))_{i \\in [d]}</span>  is an s-vector for some  <span class="math">s \\in \\mathbb{F}_r^*</span> . The next claim enables us to do so with just one pairing.</p>

    <p class="text-gray-300">Claim 2.3. Suppose that  <span class="math">((p_i, q_i))_{i \\in [d]}</span>  is a vector of elements in  <span class="math">\\mathbb{G}_1 \\setminus \\{0\\}</span>  that is not an s-vector. Choose random  <span class="math">c_1, \\ldots, c_d \\in \\mathbb{F}_r</span>  and define</p>

    <p class="text-gray-300"><span class="math">$p \\triangleq \\sum_{i \\in [d]} c_i \\cdot p_i, \\quad q \\triangleq \\sum_{i \\in [d]} c_i \\cdot q_i.</span>$</p>

    <p class="text-gray-300">Then, with probability at least 1-2/r, both  <span class="math">(p,q) \\neq (0,0)</span>  and (p,q) is not an s-pair</p>

    <p class="text-gray-300">Proof. Write  <span class="math">p_i = a_i \\cdot g_1</span>  for  <span class="math">a_i \\in \\mathbb{F}_r</span> , and  <span class="math">q_i = s_i \\cdot p_i</span>  for some  <span class="math">s_i \\in \\mathbb{F}_r</span> . Thus, we have  <span class="math">p = a \\cdot g_1</span>  for  <span class="math">a \\triangleq \\sum_{i \\in [d]} c_i a_i</span>  and  <span class="math">q = b \\cdot g_1</span>  for  <span class="math">b \\triangleq \\sum_{i \\in [d]} \\alpha_i a_i s_i</span> . Let us assume  <span class="math">a \\neq 0</span> . This happens with probability 1 - 1/r. Write [d] as a disjoint union  <span class="math">S \\cup T</span>  where S is the set of indices of the s-pairs. That is  <span class="math">S \\triangleq \\{i \\in [d] | s_i = s\\}</span> . We have</p>

    <p class="text-gray-300"><span class="math">$b/a = \\frac{\\sum_{i \\in [d]} c_i a_i s_i}{\\sum_{i \\in [d]} c_i a_i} = s + \\frac{\\sum_{i \\in T} c_i \\cdot (s - s_i)}{\\sum_{i \\in [d]} c_i a_i} = s + \\frac{\\sum_{i \\in T} c_i \\cdot (s - s_i)}{a}.</span>$</p>

    <p class="text-gray-300">Thus, b/a = s if and only if the fraction in the right hand side is zero. As the numerator is a random combination of non-zero elements, this happens with probability 1/r.</p>

    <p class="text-gray-300">We conclude that with probability at least 1-2/r, (p,q) is not an s-pair</p>

    <p class="text-gray-300">Claim 2.3 implies the correctness of  <span class="math">\\mathsf{sameRatio}(V,(f,H))</span>  that given an s-pair (f,H) in  <span class="math">\\mathbb{G}_2</span> , checks whether V is an s-vector in  <span class="math">\\mathbb{G}_1</span> .  <span class="math">\\mathsf{sameRatio}(V=((p_i,q_i))_{i\\in[d]},(f,H))</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If there exists a pair of the form (0,a) or (a,0) for some  <span class="math">a \\neq 0</span>  in V; return rej.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>&quot;Put aside&quot; all elements of the form (0,0), and from now on assume all pairs in V are in  <span class="math">\\mathbb{G}_1 \\setminus \\{0\\}</span> . (If all pairs are of the form (0,0) then return acc).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Choose random  <span class="math">c_1, \\ldots, c_d \\in \\mathbb{F}_r</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Define  <span class="math">p \\triangleq \\sum_{i \\in [d]} c_i \\cdot p_i</span> , and  <span class="math">q \\triangleq \\sum_{i \\in [d]} c_i \\cdot q_i</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If p = q = 0, return acc.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Otherwise, return  <span class="math">\\mathsf{SameRatio}((p,q),(f,H))</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Corollary 2.4. Suppose  <span class="math">\\operatorname{rp}_s</span>  in a  <span class="math">\\mathbb{G}_2</span> -s-pair, and V is a vector of pairs of  <span class="math">\\mathbb{G}_1</span>  elements. If V is an s-vector, sameRatio(V,  <span class="math">\\operatorname{rp}_s</span> ) accepts with probability one. If V is not an s-vector, sameRatio(V,  <span class="math">\\operatorname{rp}_s</span> ) accepts with probability at most 2/r.</p>

    <p class="text-gray-300">Let V be a vector of  <span class="math">\\mathbb{G}_1</span> -elements and  <span class="math">\\mathsf{rp}_s</span>  be a pair of  <span class="math">\\mathbb{G}_2</span> -elements. We also use a method  <span class="math">\\mathsf{sameRatioSeq}(V,\\mathsf{rp}_s)</span>  that given an s-pair  <span class="math">\\mathsf{rp}_s</span> , checks that each two consecutive elements of V are an s-pair. It does so by calling  <span class="math">\\mathsf{sameRatio}(V&#x27;,\\mathsf{rp}_s)</span>  with  <span class="math">V&#x27; = ((V_0,V_1),(V_1,V_2),\\ldots,(V_{d-1},V_d))</span> .</p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8">2.2 Schnorr NIZKs for knowledge of discrete log</h3>

    <p class="text-gray-300">We review and define notation for using the well-known Schnorr protocol [Sch89]. Given an s-pair  <span class="math">\\mathsf{rp}_s = (f, H = s \\cdot f)</span> , and a string h, we define the (randomized) string NIZK( <span class="math">\\mathsf{rp}_s, h</span> ) that can be interpreted as a proof that the generator of the string knows s.</p>

    <h2 id="sec-misc-1" class="text-2xl font-bold"><span class="math">\\underline{\\mathrm{NIZK}}(\\mathsf{rp}_s,h)</span> :</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Choose random  <span class="math">a \\in \\mathbb{F}_r^*</span>  and let  <span class="math">R := a \\cdot f</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let  <span class="math">c := \\mathsf{COMMIT}(R \\circ h)</span>  and interpret c as an element of  <span class="math">\\mathbb{F}_r</span> , e.g. by taking it's first  <span class="math">\\log r</span>  bits.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let u := a + cs.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Define  <span class="math">NIZK(rp_s, h) := (R, u)</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Let us denote by  <span class="math">\\pi</span>  a string that is supposedly of the form NIZK( <span class="math">\\mathsf{rp}_s, h</span> ), for some string h.</p>

    <p class="text-gray-300">VERIFY-NIZK <span class="math">(\\mathsf{rp}_s, \\pi, h)</span>  is a boolean predicate that verifies that  <span class="math">\\pi</span>  is indeed of this form for the same given h.</p>

    <h2 id="sec-misc-2" class="text-2xl font-bold">VERIFY-NIZK( <span class="math">(f, H), \\pi, h</span> ):</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let R, u be as in the description above.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">c := \\mathsf{COMMIT}(R \\circ h)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Return acc when  <span class="math">u \\cdot f = R + c \\cdot H</span> ; and rej otherwise.</li>
    </ol></li>
    </ul>

      <h3 id="sec-2.3" class="text-xl font-semibold mt-8">2.3 The random-coefficient subprotocol</h3>

    <p class="text-gray-300">A large part of the protocol will consist of invocations of the random-coefficient subprotocol. In this subprotocol, we multiply a vector of  <span class="math">\\mathbb{G}_1</span>  elements coordinate-wise by the same scalar  <span class="math">\\alpha \\in \\mathbb{F}_r^*</span> .  <span class="math">\\alpha</span>  here is a product of secret elements  <span class="math">\\{\\alpha_i\\}_{i\\in[n]}</span> , that we refer to later as comitted elements. By this we mean, that before the subprotocol is invoked, for each  <span class="math">i\\in[n]</span> ,  <span class="math">P_i</span>  has broadcasted a  <span class="math">\\mathbb{G}_2</span> - <span class="math">\\alpha_i</span> -pair, denoted  <span class="math">\\mathsf{rp}_{\\alpha_i}</span> , that is accessible to the protocol verifier. (This will become clearer in the context of Section 3).</p>

    <h2 id="sec-misc-3" class="text-2xl font-bold"><span class="math">\\mathrm{RCPC}(V, \\alpha)</span> :</h2>

    <p class="text-gray-300">Common Input: vector  <span class="math">V \\in \\mathbb{G}_1^d</span> .</p>

    <p class="text-gray-300">Individual inputs: element  <span class="math">\\alpha_i \\in \\mathbb{F}_r^*</span>  for each  <span class="math">i \\in [n]</span> .</p>

    <p class="text-gray-300"><strong>Output:</strong> vector  <span class="math">\\alpha \\cdot V \\in \\mathbb{G}_1^d</span> , where  <span class="math">\\alpha = \\prod_{i=1}^n \\alpha_i</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">P_1</span>  computes broadcasts  <span class="math">V_1 := \\alpha_1 \\cdot V</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For i = 2, ..., n,  <span class="math">P_i</span>  broadcasts  <span class="math">V_i := \\alpha_i \\cdot V_{i-1}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Players out  <span class="math">V_n</span>  (which should equal  <span class="math">\\alpha \\cdot V</span> ).</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Before discussing the transcript verification we define one more useful notation. For vectors  <span class="math">S, T \\in \\mathbb{G}_1^d</span>  and a  <span class="math">\\mathbb{G}_2</span> - <span class="math">\\alpha</span> -pair  <span class="math">\\mathsf{rp}_\\alpha</span> , sameRatio <span class="math">((S,T),\\mathsf{rp}_\\alpha)</span>  returns  <span class="math">\\mathsf{sameRatio}(V,\\mathsf{rp}_\\alpha)</span> , where  <span class="math">V_i := (S_i,T_i)</span> . The transcript verification procedure receives as input  <span class="math">V,V_1,\\ldots,V_n</span> , and for each  <span class="math">i \\in [n]</span> , the  <span class="math">\\mathbb{G}_2</span> - <span class="math">\\alpha_i</span> -pair,  <span class="math">\\mathsf{rp}_{\\alpha_i}</span> .</p>

    <h2 id="sec-misc-4" class="text-2xl font-bold"><span class="math">\\underline{\\mathsf{verify}} \\mathsf{RCPC}(V, \\alpha) \\textbf{:}</span></h2>

    <p class="text-gray-300"><strong>Input:</strong> V, protocol transcript  <span class="math">V_1, \\ldots, V_n \\in \\mathbb{G}_1^d</span> , for each  <span class="math">i \\in [n]</span>  a  <span class="math">\\mathbb{G}_2</span> - <span class="math">\\alpha_i</span> -pair  <span class="math">\\mathsf{rp}_{\\alpha_i}</span> .</p>

    <p class="text-gray-300">Output: acc or rej.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Run sameRatio((V, V1),rp&alpha;<sup>1</sup> ).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For i = 2, . . . , n, run sameRatio((Vi&minus;1, Vi),rp&alpha;<sup>i</sup> ).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Return acc if all invocations returned acc; and return rej otherwise.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">From the correctness of the sameRatio(,) method (Corollary 2.4) we have that</p>

    <p class="text-gray-300">Claim 2.5. If the players follow the protocol correctly, the output is &alpha;&middot;V , and transcript verification outputs acc with probability one. Otherwise, transcript verification outputs acc with probability at most 2/r.</p>

    </section>

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3 Protocol description</h2>

    <p class="text-gray-300">The participants The protocol is conducted by n players, a coordinator, and a protocol verifier. In the implementation the role of the coordinator and protocol verifier can be played by the same server. We find it useful to separate these roles, though, as the actions of the protocol verifier may be executed only after the protocol has terminated, if one wishes to reduce the time the players have to be engaged. Moreover, any party wishing to check the validity of the transcript and generated parameters can do so solely with access to the protocol transcript. On the other hand, this has the disadvantage that non-valid messages will be detected only in hindsight, and the whole process will have to be restarted if one wishes to generate valid SNARK parameters.</p>

    <p class="text-gray-300">Similarly, the role of the coordinator is not strictly necessary if one assumes a blackboard model where each player sees all messages broadcasted. (In our actual implementation the coordinator passes messages between the players). Our security analysis holds when all messages are seen by all players. However, even in such a blackboard model there is an advantage of having of a coordinator role: At the beginning of Round 3 a heavy computation needs to performed (Subsection 3.3) that in theory could be performed by the first player before he sends his message for that round. However, as this heavy computation does not require access to any secrets of the players, having the coordinator perform it can save much time, if the coordinator is run on a strong server, and the players have weaker machines.</p>

    <p class="text-gray-300">The protocol consists of four &quot;round-robin&quot; rounds, where for each i &isin; [n], player P<sup>i</sup> can send his message after receiving the message of Pi&minus;1. P<sup>1</sup> can send his message after receiving an &quot;initializer message&quot; from the coordinator, which is empty in some of the rounds. An exception of this is the first round, where all players may send their message to the coordinator in parallel. However, security is not harmed if a player sees other players' messages before sending his in that round. Round 2 is divided into several parts for clarity, however the messages of a player P<sup>i</sup> in all parts of that round can be sent in parallel. Similarly, Round 3 and 4 consist of several one round roundrobin subprotocols; however, the messages of a player P<sup>i</sup> in all these subprotocols can be sent in parallel.</p>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8">3.1 Round 1: commitments</h3>

    <p class="text-gray-300">For each i &isin; [n], P<sup>i</sup> does the following.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Generate a set of uniform elements in  <span class="math">\\mathbb{F}_r^*</span></li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\mathsf{secrets}_i := \\{ \\tau_i, \\rho_{A,i}, \\rho_{B,i}, \\alpha_{A,i}, \\alpha_{B,i}, \\alpha_{C,i}, \\beta_i, \\gamma_i \\}.</span>$</p>

    <p class="text-gray-300">Omitting the index i for readability from now on, let</p>

    <p class="text-gray-300">elements<sub>i</sub> :=
<span class="math">$\\{\\tau, \\rho_A, \\rho_B, \\alpha_A, \\alpha_B, \\alpha_C, \\beta, \\gamma, \\rho_A \\alpha_A, \\rho_B \\alpha_B, \\rho_A \\rho_B \\alpha_C, \\beta \\gamma\\}</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Now  <span class="math">P_i</span>  generates the set of group elements<sup>2</sup></li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\mathbf{e}_i := (\\tau, \\rho_A, \\rho_A \\rho_B, \\rho_A \\alpha_A, \\rho_A \\rho_B \\alpha_B, \\rho_A \\rho_B \\alpha_C, \\gamma, \\beta \\gamma) \\cdot g.</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">P_i</span>  computes  <span class="math">h_i := \\mathsf{COMMIT}(\\mathsf{e}_i)</span>  and broadcasts  <span class="math">h_i</span> .</li>
    </ol>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8">3.2 Round 2</h3>

    <h4 id="sec-misc-5" class="text-lg font-semibold mt-6">Part 1: Revealing commitments</h4>

    <p class="text-gray-300">For each  <span class="math">i \\in [n]</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">P_i</span>  broadcasts  <span class="math">e_i</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The protocol verifier checks that indeed  <span class="math">h_i = \\mathsf{COMMIT}(\\mathsf{e}_i)</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><strong>Committed elements</strong> From the end of Round 2, part 1 of the protocol, we refer to the elements of elements<sub>i</sub> for some  <span class="math">i \\in [n]</span>  as committed elements. The reason is that by this stage of the protocol, for each  <span class="math">s \\in</span>  elements<sub>i</sub>,  <span class="math">P_i</span>  has sent an s-pair in both  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span> , effectively committing him to the value of s. For each such element s, we refer to the s-pair in  <span class="math">\\mathbb{G}_1</span>  by  <span class="math">\\mathsf{rp}_s</span>  and the s-pair in  <span class="math">\\mathbb{G}_2</span>  by  <span class="math">\\mathsf{rp}_s^2</span> . We list the corresponding elements and s-pairs, omitting the i subscript for readability:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\bullet \\ \\tau \\colon (\\operatorname{rp}_\\tau^1, \\operatorname{rp}_\\tau^2) = (g, \\tau \\cdot g).</span></li>
      <li><span class="math">\\bullet \\ \\rho_A \\colon (\\mathsf{rp}^1_{\\rho_A}, \\mathsf{rp}^2_{\\rho_A}) = (g, \\rho_A \\cdot g).</span></li>
      <li><span class="math">\\rho_B</span> :  <span class="math">(\\operatorname{rp}_{\\rho_B}^1, \\operatorname{rp}_{\\rho_B}^2) = (g, \\rho_B \\cdot g)</span> .</li>
      <li><span class="math">\\bullet \\ \\alpha_A \\colon (\\operatorname{rp}_{\\alpha_A}^1,\\operatorname{rp}_{\\alpha_A}^2) = (\\rho_A \\cdot g,\\rho_A \\alpha_A \\cdot g).</span></li>
      <li><span class="math">\\bullet \\ \\alpha_B \\colon (\\mathsf{rp}^1_{\\alpha_B}, \\mathsf{rp}^2_{\\alpha_B}) = (\\rho_A \\rho_B \\cdot g, \\rho_A \\rho_B \\alpha_B \\cdot g).</span></li>
      <li><span class="math">\\bullet \\ \\alpha_C \\colon (\\operatorname{rp}^1_{\\alpha_C}, \\operatorname{rp}^2_{\\alpha_C}) = (\\rho_A \\rho_B \\cdot g, \\rho_A \\rho_B \\alpha_C \\cdot g).</span></li>
      <li><span class="math">\\bullet \\ \\beta \\colon (\\mathsf{rp}^1_\\beta, \\mathsf{rp}^2_\\beta) = (\\gamma \\cdot g, \\beta \\gamma \\cdot g).</span></li>
    </ul>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;2</sup>In the actual code a more complex set of elements is used that can be efficiently derived from  <span class="math">elements_i</span> , as described in Appendix A. The reason we use the more complex set is that it potentially provides more security as it contains less information about  <span class="math">secrets_i</span> . However, the proof works as well with this definition of  <span class="math">e_i</span>  and it provides a significantly simpler presentation. We explain in Appendix A the slight modification for protocol and proof for using the more complex element set.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\gamma</span> :  <span class="math">(\\mathsf{rp}^1_\\alpha, \\mathsf{rp}^2_\\alpha) = (q, \\gamma \\cdot q)</span> .</li>
      <li><span class="math">\\rho_A \\alpha_A</span> :  <span class="math">(\\mathsf{rp}^1_{\\rho_A \\alpha_A}, \\mathsf{rp}^2_{\\rho_A \\alpha_A}) = (g, \\rho_A \\alpha_A \\cdot g)</span> .</li>
      <li><span class="math">\\rho_B \\alpha_B</span> :  <span class="math">(\\mathsf{rp}^1_{\\rho_B \\alpha_B}, \\mathsf{rp}^2_{\\rho_B \\alpha_B}) = (\\rho_A \\cdot g, \\rho_A \\rho_B \\alpha_B \\cdot g)</span> .</li>
      <li><span class="math">\\rho_A \\rho_B</span> :  <span class="math">(\\mathsf{rp}^1_{\\rho_A \\rho_B}, \\mathsf{rp}^2_{\\rho_A \\rho_B}) = (g, \\rho_A \\rho_B \\cdot g)</span> .</li>
      <li><span class="math">\\bullet \\ \\rho_A \\rho_B \\alpha_C \\colon (\\mathsf{rp}^1_{\\rho_A \\rho_B \\alpha_C}, \\mathsf{rp}^2_{\\rho_A \\rho_B \\alpha_C}) = (g, \\rho_A \\rho_B \\alpha_C \\cdot g).</span></li>
      <li><span class="math">\\beta \\gamma</span> :  <span class="math">(\\mathsf{rp}_{\\beta \\gamma}^1, \\mathsf{rp}_{\\beta \\gamma}^2) = (g, \\beta \\gamma \\cdot g)</span> .</li>
    </ul>

    <p class="text-gray-300">Of course, we need to check that  <span class="math">P_i</span>  has committed to the same element  <span class="math">s \\in \\mathbb{F}_r^*</span>  by  <span class="math">\\mathsf{rp}_s</span>  and  <span class="math">\\mathsf{rp}_s^2</span> . This is done by the protocol verifier in the next stage.</p>

    <h4 id="sec-misc-6" class="text-lg font-semibold mt-6">Part 2: Checking commitment consistency between both groups</h4>

    <p class="text-gray-300">For each  <span class="math">i \\in [n]</span> , and  <span class="math">s \\in \\mathsf{elements}_i</span> , the protocol verifier runs  <span class="math">\\mathsf{SameRatio}(\\mathsf{rp}_s, \\mathsf{rp}_\\mathsf{s}^2)</span> , and outputs  <span class="math">\\mathsf{rej}</span> if any invocation returned rej.</p>

    <h4 id="sec-misc-7" class="text-lg font-semibold mt-6">Part 3: Proving and verifying knowledge of discrete logs</h4>

    <p class="text-gray-300">Let  <span class="math">h := \\mathsf{COMMIT}(h_1 \\circ \\ldots \\circ h_n)</span>  be the hash of the transcript of Round 1.  <span class="math">P_1</span>  computes and broadcasts h.</p>

    <p class="text-gray-300">For each  <span class="math">i \\in [n]</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For  <span class="math">s \\in \\mathsf{secrets}_i</span> , let  <span class="math">h_{i,s} := h \\circ \\mathsf{rp}_s^1</span> . Note that both  <span class="math">P_i</span>  and the protocol verifier, seeing the transcript up to this point, can efficiently compute the elements  <span class="math">\\{h_{i,s}\\}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For each  <span class="math">s \\in \\text{secrets}_i</span> ,  <span class="math">P_i</span>  broadcasts  <span class="math">\\pi_{i,s} := \\text{NIZK}(\\mathsf{rp}_s^1, h_{i,s})</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The protocol verifier checks for each  <span class="math">s \\in \\text{secrets}_i</span>  that VERIFY-NIZK <span class="math">(\\mathsf{rp}_s^1, \\pi_{i,s}, h_{i,s}) = \\mathsf{acc}</span> .</li>
    </ol></li>
    </ul>

    <h4 id="sec-misc-8" class="text-lg font-semibold mt-6">Part 4: The random powers subprotocol:</h4>

    <p class="text-gray-300">The purpose of the subprotocol is to output the vector</p>

    <p class="text-gray-300">POWERS<sub>\\tau</sub> :=
<span class="math">$\\left( (1, \\tau, \\tau^2, \\dots, \\tau^d) \\cdot g_1, (1, \\tau, \\tau^2, \\dots, \\tau^d) \\cdot g_2 \\right)</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\tau := \\tau_1 \\cdots \\tau_n</span> . Recall that  <span class="math">\\tau_1, \\ldots, \\tau_n</span>  are committed values from Round 1. For a vector  <span class="math">V \\in \\mathbb{G}_1^{d+1}</span> , and  <span class="math">a \\in \\mathbb{F}_r</span> , we use below the notation  <span class="math">\\mathsf{powerMult}(V, a) \\in \\mathbb{G}_1^{d+1}</span> , defined</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{powerMult}(V, a)_i \\triangleq a^i \\cdot V,</span>$</p>

    <p class="text-gray-300">for  <span class="math">i \\in \\{0, ..., d\\}</span> . We use the analogous notation for a vector  <span class="math">V \\in \\mathbb{G}_2^{d+1}</span> .</p>

    <h4 id="sec-misc-9" class="text-lg font-semibold mt-6">Phase 1: Computing power vectors</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">P_1</span>  does the following.</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Computes  <span class="math">V_1 = (1, \\tau_1, \\tau_1^2, \\dots, \\tau_1^d) \\cdot g_1</span>  and  <span class="math">V_1&#x27; = (1, \\tau_1, \\tau_1^2, \\dots, \\tau_1^d) \\cdot g_2</span> .</li>
      <li>(b) Broadcasts  <span class="math">(V_1, V_1&#x27;)</span> .</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For i = 2, ..., n,  <span class="math">P_i</span>  does the following:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Compute  <span class="math">V_i \\triangleq \\mathsf{powerMult}(V_{i-1}, \\tau_i)</span>  and  <span class="math">V_i&#x27; \\triangleq \\mathsf{powerMult}(V_{i-1}&#x27;, \\tau_{i-1})</span> .</li>
      <li>(b) Broadcasts  <span class="math">(V_i, V&#x27;_i)</span> .</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">Phase 2: Checking power vectors are valid The protocol verifier performs the following checks<sup>3</sup> on the broadcasted data from Phase 1:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check that</li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\mathsf{sameRatioSeq}(V_1, \\mathsf{rp}_{\\tau_1}^2),</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{sameRatioSeq}(V_1&#x27;,(V_{1,0},V_{1,1}))</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For each  <span class="math">i \\in [n] \\setminus \\{1\\}</span>  check that</li>
    </ol>

    <p class="text-gray-300">sameRatioSeq
<span class="math">$(V_i, (V&#x27;_{i,0}, V&#x27;_{i,1})),</span>$</p>

    <p class="text-gray-300">sameRatioSeq
<span class="math">$(V_i&#x27;, (V_{i,0}, V_{i,1})),</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{SameRatio}((V_{i-1,1},V_{i,1}),\\mathsf{rp}_{\\tau_{\\mathsf{i}}}^2)</span>$</p>

    <p class="text-gray-300">The protocol verifier rejects the transcript if one of the checks failed; otherwise, the coordinator defines  <span class="math">(PK_H \\triangleq V_n, PK&#x27;_H \\triangleq V&#x27;_n)</span>  is taken as the subprotocol output.</p>

    <p class="text-gray-300">Phase 3: Checking we didn't land in the zeros of Z The zero-knowledge property of the SNARK requires we weren't unlucky and  <span class="math">\\tau</span>  landed in the zeroes of  <span class="math">Z(X) := X^d - 1</span> .</p>

    <p class="text-gray-300">&bull; Protocol verifier and all players check that  <span class="math">Z(\\tau) \\cdot g_1 = (\\tau^d - 1) \\cdot g_1 = V_{n,d} - V_{n,0} \\neq 1</span> . If the check fails the protocol is aborted and restarted.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;3</sup>The checks below could be simplified if we had also used  <span class="math">\\mathsf{rp}_{\\tau_i}^1</span> . We do not use it as in the actual code, as explained in Appendix A, we do not have a  <span class="math">\\mathbb{G}_1</span> - <span class="math">\\tau_i</span> -pair.</p>

    <p class="text-gray-300">To avoid a quadratic proving time the polynomials in the QAP must be evaluated in a Lagrange basis. There seems to be no way of directly computing a Lagrange basis at  <span class="math">\\tau</span>  in a 1-round MPC in a similar way we did for the standard basis in the Random-Powers subprotocol. Thus we will do 'FFT in the coefficient' to compute the Lagrange basis on the output of the random-powers subprotocol. Details and definitions follow. Let  <span class="math">\\omega \\in \\mathbb{F}_r</span>  be a primitive root of unity of order  <span class="math">d = 2^{\\ell}</span> , in code d is typically the first power of two larger or equal to the circuit size.</p>

    <p class="text-gray-300">For i = 1, ..., d, we define  <span class="math">L_i</span>  to be the <em>i</em>'th Lagrange polynomial over the points  <span class="math">\\{\\omega^i\\}_{i \\in [d]}</span> . That is,  <span class="math">L_i</span>  is the unique polynomial of degree smaller than d, such that  <span class="math">L_i(\\omega^i) = 1</span>  and  <span class="math">L_i(\\omega^j) = 0</span> , for  <span class="math">j \\in [d] \\setminus \\{i\\}</span> .</p>

    <p class="text-gray-300">Claim 3.1. For  <span class="math">i \\in [d]</span>  we have</p>

    <p class="text-gray-300"><span class="math">$L_i(X) := c_d \\cdot \\sum_{j=0}^{d-1} (X/\\omega^i)^j,</span>$</p>

    <p class="text-gray-300">for  <span class="math">c_d := \\frac{1}{d}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Substituting  <span class="math">X = \\omega^{i&#x27;}</span>  for  <span class="math">i&#x27; \\neq i</span>  we have a sum over all roots of unity of order d which is 0. Substituting  <span class="math">X = \\omega^{i}</span>  we have a sum of d ones divided by d which is one.</p>

    <p class="text-gray-300">For  <span class="math">\\tau \\in \\mathbb{F}_r^*</span> , denote by we denote by  <span class="math">LAG_{\\tau} \\in \\mathbb{G}_1^d \\times \\mathbb{G}_2^d</span>  the vector</p>

    <p class="text-gray-300"><span class="math">$LAG_{\\tau} := ((L_i(\\tau) \\cdot g_1)_{i \\in [d]}, (L_i(\\tau) \\cdot g_2)_{i \\in [d]}).</span>$</p>

    <p class="text-gray-300">The purpose of the FFT-protocol is to compute  <span class="math">LAG_{\\tau}</span>  from  <span class="math">POWERS_{\\tau}</span> . Let us focus for simplicity how to compute the first half containing the  <span class="math">\\mathbb{G}_1</span>  elements. Computing the second half is completely analogous. We define the polynomial  <span class="math">P(Y)(=P_{\\tau}(Y))</span>  by</p>

    <p class="text-gray-300"><span class="math">$P(Y) := \\sum_{j=0}^{&lt; d} (\\tau \\cdot Y)^j.</span>$</p>

    <p class="text-gray-300">It is easy to check that</p>

    <p class="text-gray-300">Claim 3.2. For  <span class="math">i \\in [d]</span></p>

    <p class="text-gray-300"><span class="math">$L_i(\\tau) = P(\\omega^{-i}) = P(\\omega^{d-i}),</span>$</p>

    <p class="text-gray-300">and thus</p>

    <p class="text-gray-300"><span class="math">$LAG_{\\tau} = (P(\\omega^{-i}))_{i \\in [d]} \\cdot g</span>$</p>

    <p class="text-gray-300">Thus our task reduces to computing the vector  <span class="math">(P(\\omega^i))_{i \\in [d]} \\cdot g_1</span>  (and then reordering accordingly). We describe an algorithm to compute the vector  <span class="math">(P(\\omega^i))_{i \\in [d]}</span>  using the vector  <span class="math">(1, \\tau, \\tau^2, \\dots, \\tau^d)</span>  as input and only linear combination gates. This suffices as these linear combinations can be simulated by scalar multiplication and addition in  <span class="math">\\mathbb{G}_1</span> , when operating on POWERS<sub> <span class="math">\\tau</span> </sub>. We proceed to review standard FFT tricks that will be used.</p>

    <p class="text-gray-300">For a polynomial  <span class="math">P(Y) = \\sum_{i=0}^{&lt; d} a_i \\cdot Y^i</span>  of degree smaller than d, where d is even, we define the polynomials</p>

    <p class="text-gray-300"><span class="math">$P_{\\text{EVEN}}(Y) := \\sum_{i=0}^{&lt; d/2} a_{2i} \\cdot Y^i,</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$P_{\\text{ODD}}(Y) := \\sum_{i=0}^{&lt; d/2} a_{2i+1} \\cdot Y^i.</span>$</p>

    <p class="text-gray-300">It is easy to see that</p>

    <p class="text-gray-300"><span class="math">$P(Y) = P_{\\text{EVEN}}(Y^2) + Y \\cdot P_{\\text{ODD}}(Y^2).</span>$</p>

    <p class="text-gray-300">In particular, for  <span class="math">i \\in [d]</span></p>

    <p class="text-gray-300"><span class="math">$P(\\omega^i) = P_{\\text{EVEN}}(\\omega^{2i}) + \\omega^i \\cdot P_{\\text{ODD}}(\\omega^{2i})</span>$</p>

    <p class="text-gray-300">For  <span class="math">j=0,\\ldots,\\ell-1</span>  denote  <span class="math">\\omega_j\\triangleq\\omega^{2^j}</span> . Note further that  <span class="math">\\left\\{\\omega^{2i}\\right\\}_{i\\in[d]}</span>  is a subgroup if size d/2 generated by  <span class="math">\\omega_1</span> . More generally, for  <span class="math">j=1,\\ldots,\\ell-1</span>   <span class="math">\\left\\{\\omega^{2i}_{j-1}\\right\\}_{i\\in[d]}</span>  is a subgroup of size  <span class="math">2^{d-j}</span>  generated by  <span class="math">\\omega_j</span> . The above discussion suggests the following (well-known FFT) recursive algorithm.</p>

    <h4 id="sec-misc-10" class="text-lg font-semibold mt-6"><span class="math">\\underline{\\mathbf{F}}\\mathbf{F}\\mathbf{T}</span></h4>

    <p class="text-gray-300">input: Polynomial P, given as list of coefficients, element  <span class="math">\\omega \\in \\mathbb{F}_r</span>  generating a group of size  <span class="math">d = 2^{\\ell}</span> . output: The vector  <span class="math">V = (P(\\omega^i))_{i \\in [d]}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If d = 2 compute V directly.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Otherwise,</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Call the method recursively twice; first with  <span class="math">P_{\\text{EVEN}}</span>  and  <span class="math">\\omega^2</span>  to obtain output  <span class="math">E:=(P_{\\text{EVEN}}(\\omega^{2i}))_{i\\in[d/2]}</span> , and then with  <span class="math">P_{\\text{ODD}}</span>  and  <span class="math">\\omega^2</span>  to obtain the vector  <span class="math">O:=(P_{\\text{ODD}}(\\omega^{2i}))_{i\\in[d/2]}</span> .</li>
      <li>(b) Compute the vector V using E, O and the equality mentioned above. More specifically, each element  <span class="math">V_i</span>  of V is computed as</li>
    </ul></li>
    </ul>

    <p class="text-gray-300"><span class="math">$V_i = P(\\omega^i) = P_{\\text{EVEN}}(\\omega^{2i}) + \\omega^i \\cdot P_{\\text{ODD}}(\\omega^{2i}) = E_i + \\omega^i \\cdot O_i,</span>$</p>

    <p class="text-gray-300">(where we subtract d/2 from indices of E and O when they are larger than d/2).</p>

    <p class="text-gray-300">In summary, we obtain  <span class="math">LAG_{\\tau}</span>  by applying the FFT and the polynomial P described above, with coefficients  <span class="math">1, \\tau, \\ldots, \\tau^{d-1}</span>  and an  <span class="math">\\omega</span>  of order d - which should be the same  <span class="math">\\omega</span>  used in the QAP construction. After getting the result from the FFT, we reverse the order of the vector and multiply each element by the scalar 1/d.</p>

    <p class="text-gray-300"><strong>Preparing the vectors</strong>  <span class="math">\\vec{A}, \\vec{B}</span>  and  <span class="math">\\vec{C}</span>  We need to compute the vectors  <span class="math">\\vec{A} := (A_i(\\tau))_{i \\in [0..m+1]} \\cdot g_1</span> ,  <span class="math">\\vec{B} := (B_i(\\tau))_{i \\in [0..m+1]} \\cdot g_1</span> ,  <span class="math">\\vec{B} := (B_i(\\tau))_{i \\in [0..m+1]} \\cdot g_2</span> , and  <span class="math">\\vec{C} := (C_i(\\tau))_{i \\in [0..m+1]} \\cdot g_1</span> . We remark that [BCTV14] use the same notation for vectors of polynomials, while we are looking at the vector of these polynomials evaluated at  <span class="math">\\tau</span> .</p>

    <p class="text-gray-300">Note that  <span class="math">A_{m+1} = B_{m+1} = C_{m+1} := Z[\\tau] \\cdot g_1 = (\\tau^d - 1) \\cdot g_1</span> . After the FFT, we have obtained LAG<sub>\\tau</sub>, so each such element is a linear combination of elements of LAG<sub>\\tau</sub>; except  <span class="math">Z(\\tau) \\cdot g</span> , that can be computed using the elements  <span class="math">\\tau^d \\cdot g</span>  in POWERS<sub>\\tau</sub>.</p>

      <h3 id="sec-3.4" class="text-xl font-semibold mt-8">3.4 Round 3</h3>

    <p class="text-gray-300">After the random-powers subprotocol and the FFT, the MPC consists of a few invocations of the random-coefficient subprotocol. These invocations add a total of two rounds to the MPC, as sometimes and random-coefficient subprotocol will need the output of a previous random-coefficient subprotocol as input.</p>

    <p class="text-gray-300">Part 1: broadcasting result of FFT The coordinator broadcasts the vectors  <span class="math">\\vec{A}, \\vec{B}, \\vec{C}, \\vec{B_2}</span> .</p>

    <p class="text-gray-300">Part 2: Random coefficient subprotocol invocations We apply the random-coefficient subprotocol numerous times to obtain the different key elements. For an element  <span class="math">\\alpha_i \\in \\mathsf{elements}_i</span> , we abuse notation here and denote  <span class="math">\\alpha := \\alpha_1 \\cdots \\alpha_n</span>  (as opposed to ommitting the index i and writing  <span class="math">\\alpha</span> for  <span class="math">\\alpha_i</span>  which we did when describing Round 1).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">PK_A = \\text{RCPC}(\\vec{A}, \\rho_A)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">PK_B = \\text{RCPC}(\\vec{B_2}, \\rho_B)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">PK_C = \\text{RCPC}(\\vec{C}, \\rho_A \\rho_B)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">PK&#x27;_A = \\text{RCPC}(\\vec{A}, \\rho_A \\alpha_A)</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">PK&#x27;_B = \\text{RCPC}(\\vec{B}, \\rho_B \\alpha_B)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">PK&#x27;_C = \\text{RCPC}(\\vec{C}, \\rho_A \\rho_B \\alpha_C))</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">temp_B = RCPC(\\vec{B}, \\rho_B)</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">VK_Z = \\text{RCPC}(g_2 \\cdot Z(\\tau), \\rho_A \\rho_B)</span> . We use that  <span class="math">g_2 \\cdot Z(\\tau) = g_2 \\cdot (\\tau^d 1)</span>  can be computed from  <span class="math">PK&#x27;_H</span>  that was computed in Round 2, part 2, as described in Section 3.2.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">VK_A = RCPC(g_2, \\alpha_A)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">VK_B = \\text{RCPC}(g_1, \\alpha_B)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">VK_C = \\text{RCPC}(g_2, \\alpha_C)</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;4</sup>A technicality is that in the protocol description in [BCTV14]  <span class="math">Z(\\tau) \\cdot g_2</span>  is appended with index m+2 in  <span class="math">\\vec{B_2}</span> , and  <span class="math">Z(\\tau) \\cdot g_1</span>  is appended in index m+3 in C. However in the actual libsnark code, they are appended in index m+1, and the prover algorithm is slightly modified to take this into account. But for the security proof we assume later on as in [BCTV14] that  <span class="math">A_{m+1} = C_{m+3} = Z(\\tau) \\cdot g_1</span> ,  <span class="math">B_{m+2} = Z(\\tau) \\cdot g_2</span> ,  <span class="math">A_{m+2}</span> ,  <span class="math">A_{m+3}</span> ,  <span class="math">B_{m+1}</span> ,  <span class="math">B_{m+3}</span> ,  <span class="math">C_{m+1}</span> ,  <span class="math">C_{m+2} = 0</span> .</p>

      <h3 id="sec-3.5" class="text-xl font-semibold mt-8">3.5 Round 4: Computing key elements involving <span class="math">\\beta</span> , especially <span class="math">PK_K</span></h3>

    <p class="text-gray-300">Each player (or just the coordinator) computes  <span class="math">V := PK_A + temp_B + PK_C</span> . The players compute</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">PK_K = RCPC(V, \\beta)</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">VK_{\\gamma} = \\text{RCPC}(g_2, \\gamma)</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">VK_{\\beta\\gamma}^1 = RCPC(g_1, \\beta\\gamma)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">VK_{\\beta\\gamma}^2 = RCPC(g_2, \\beta\\gamma)</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Finally, the protocol verifier will run verifyRCPC(,) on the input and transcript of each subprotocol executed in Round 3 or 4; and output acc if and only if all invocations of verifyRCPC(,) returned acc.</p>

    </section>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 Security proof</h2>

    <p class="text-gray-300">Fix a QAP instance  <span class="math">\\phi</span>  and input x for  <span class="math">\\phi</span> . Let V be the snark verifier of [PHGR16]. We denote by  <span class="math">T \\subset [n]</span> , |T| = n - 1, the subset of players controlled by the adversary B. Our goal is to show that under certain cryptographic assumptions, most notably the Knowledge of Exponent (KEA) assumption, if B can generate a proof that  <span class="math">V(\\phi, x)</span>  accepts with non-negligible probability, when V is using the parameters generated in the protocol, then there exists an extractor E generating a witness  <span class="math">\\omega</span>  satisfying  <span class="math">(\\phi, x)</span>  with non-negligible probability. Our proofs hold in the random oracle model where a random oracle  <span class="math">\\mathcal R</span>  takes the place of COMMIT in the protocol.</p>

    <p class="text-gray-300"><strong>Notational conventions</strong> To simplify notations we will refer to a fixed pair of groups  <span class="math">(\\mathbb{G}_1, \\mathbb{G}_2)</span> . of order r; we implicitly assume that we have a generator  <span class="math">\\mathcal{G}</span>  that when given integer t as parameter, returns a prime r with r = poly(t) and groups  <span class="math">\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_t</span>  of order r, with the property that for all cryptographic problems described next (Knowledge of Exponent, Strong Diffie-Helman, Power Diffie-Helman) an efficient adversary has  <span class="math">\\operatorname{negl}(\\log r)</span>  success probability; where we remind that by efficient adversary we mean a non-uniform (sequence of) circuit(s) of size  <span class="math">\\operatorname{poly}(\\log r)</span> .</p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 Cryptographic assumptions</h3>

    <p class="text-gray-300">We use bilinear versions of the Strong Diffie-Helman, Power Diffie-Helman, and Knowledge of Exponent assumption as in [CFH<sup>+</sup>15]. It will be convenient to denote  <span class="math">G^* := \\mathbb{G}_1 \\setminus \\{0\\} \\times \\mathbb{G}_2 \\setminus \\{0\\}</span> , and as before by  <span class="math">g = (g_1, g_2)</span>  a pair of generators for both groups.</p>

    <p class="text-gray-300"><strong>Definition 4.1</strong> (Knowledge of Exponent Assumption (KEA)). For any efficient A there exists an efficient E such that the following holds. Fix positive integer d, and an efficient randomized circuit S with input domain  <span class="math">(G^*)^{2(d+1)}</span> . Consider the following experiment.</p>

    <p class="text-gray-300"><span class="math">\\tau, \\alpha \\in \\mathbb{F}_r^*</span>  and  <span class="math">g \\in G^*</span>  are chosen uniformly. We denote  <span class="math">V := (1, \\tau, \\dots, \\tau^d, \\alpha, \\alpha\\tau, \\dots, \\alpha\\tau^d) \\cdot g</span> Then A is given as input S(V); and outputs a pair of the form (c, d) in  <span class="math">\\mathbb{G}_1 \\setminus \\{0\\}</span> , which he &quot;hopes&quot; is of the form  <span class="math">(c, \\alpha c)</span> . E, given the same input, outputs  <span class="math">a_0, a_1, \\dots, a_d \\in \\mathbb{F}_r</span>  such that the probability that both</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">A &quot;succeeded&quot;, i.e.,  <span class="math">d = \\alpha \\cdot c</span> . But,</p></li>
      <li><p class="text-gray-300">E &quot;failed&quot;, i.e.,
<span class="math">$c \\neq (\\sum_{i=0}^{d} a_i \\tau^i) \\cdot g_1</span>$</p></li>
      <li></li>
    </ol>

    <p class="text-gray-300">is  <span class="math">negl(\\log r)</span> . The same holds when  <span class="math">\\mathbb{G}_1 \\setminus \\{0\\}</span>  is replaced by  <span class="math">\\mathbb{G}_2 \\setminus \\{0\\}</span>  and  <span class="math">g_1</span>  is replaced by  <span class="math">g_2</span> .</p>

    <p class="text-gray-300"><strong>Remark 4.2.</strong> Bitansky et. al [BCPR14], in fact show that the above assumption is false, assuming the existence of indistinguishability obfuscation, when allowing a general S. If one is troubled by this, one may replace the general S in the above definition, by limiting S to be a circuit that computes one of the functions in Claim 4.5, after computing its inputs from a uniformly chosen vector secrets  <span class="math">\\in (\\mathbb{F}_r^*)^8</span> .</p>

    <p class="text-gray-300">We preferred to stick with the less cumbersome definition above, particularly, as the existence of indistinguishability obfuscation is questionable.</p>

    <p class="text-gray-300"><strong>Definition 4.3</strong> (q-SDH assumption). Fix positive integer q. Consider the following experiment.  <span class="math">\\tau \\in \\mathbb{F}_r^*</span>  and  <span class="math">g \\in G^*</span>  are chosen uniformly. Then an efficient A is given as input  <span class="math">(1, \\tau, \\ldots, \\tau^q) \\cdot g</span> . Then the probability that A outputs  <span class="math">e(g_1, g_2)^{\\frac{1}{\\tau+c}}</span> , for some  <span class="math">c \\in \\mathbb{F}_r^*</span>  is  <span class="math">\\mathsf{negl}(\\log r)</span> .</p>

    <p class="text-gray-300"><strong>Definition 4.4</strong> (q-PDH assumption). Fix positive integer q. Consider the following experiment.  <span class="math">\\tau \\in \\mathbb{F}_r^*</span>  and  <span class="math">g \\in G^*</span>  are chosen uniformly. Then an efficient A is given as input  <span class="math">(1, \\tau, \\dots, \\tau^q, \\tau^{q+2}, \\dots, \\tau^{2q})</span> . g. Then the probability that A outputs  <span class="math">\\tau^{q+1} \\cdot g_1</span>  is  <span class="math">\\operatorname{negl}(\\log r)</span> .</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">4.2 The Pinocchio Theorem</h3>

    <p class="text-gray-300">We refer to Appendix B of [BCTV14] for a description of the Pinocchio protocol [PHGR16] with notation close to what is used here. We also give a semi-formal description of the protocol in Appendix B.</p>

    <p class="text-gray-300">Furthermore, one may refer to [PHGR16] and [BCTV14] for definitions relating to quadratic arithmetic programs (QAPs), that we assume familiarity with here. Given a QAP instance  <span class="math">\\phi</span>  of degree d, we typically denote by  <span class="math">\\mathsf{params}_{\\phi}</span>  a legitimate set of Pinocchio parameters, i.e., proving key and verification key, for  <span class="math">\\phi</span> . We can think of  <span class="math">\\mathsf{params}_{\\phi}</span>  as a deterministic function of the values  <span class="math">\\tau, \\rho_A, \\rho_B, \\alpha_A, \\alpha_B, \\alpha_C, \\gamma, \\beta \\in \\mathbb{F}_r^*</span> ; or alternatively of a vector  <span class="math">\\mathsf{secrets} \\in (\\mathbb{F}_r^*)^8</span>  consisting of these values. Actually, for our security proof we need to define  <span class="math">\\mathsf{params}_{\\phi}</span>  to include all Pinocchio key elements &quot;given in both groups&quot;. Specifically, denoting  <span class="math">g := (g_1, g_2)</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{params}_{\\phi}(\\mathsf{secrets}) := (P_H, P_{\\phi}, P_{\\alpha\\phi}, P_K, V),</span>$</p>

    <p class="text-gray-300">where  <span class="math">P_H := \\{\\tau^i \\cdot g\\}_{i \\in [d]}, P_\\phi := (P_A, P_B, P_C), P_{\\alpha\\phi} := (P_{\\alpha A}, P_{\\alpha B}, P_{\\alpha C}), P_K := \\beta \\cdot (P_A + P_B + P_C), P_{\\alpha C} := (P_{\\alpha A}, P_{\\alpha B}, P_{\\alpha C}), P_{\\alpha C} := (P_A + P_B + P_C), P_{\\alpha C} := (P_A + P_C), P_{\\alpha C} := (P_A + P_C), P_{\\alpha C} := (P_A + P_C), P_{\\alpha C} := (P_A + P_C), P_{\\alpha C} := (P_A + P_C), P_{\\alpha C} := (P_A + P_C), P_{\\alpha C} := (P_A + P_C), P_{\\alpha C} := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P_C), P_C := (P_A + P</span></p>

    <p class="text-gray-300"><span class="math">$P_A := (A_i \\cdot g_A)_{i \\in [m]}, P_{\\alpha A} := (A_i \\alpha_A \\cdot g_A)_{i \\in [m]},</span>$</p>

    <p class="text-gray-300">and  <span class="math">P_B, P_{\\alpha B}, P_C, P_{\\alpha C}</span>  defined similarly, where  <span class="math">g_A := \\rho_A \\cdot g, g_B := \\rho_B \\cdot g</span>  and  <span class="math">g_C := \\rho_A \\rho_B \\cdot g</span> , and</p>

    <p class="text-gray-300"><span class="math">$V := (\\rho_A, \\rho_B, \\alpha_A, \\alpha_B, \\alpha_C, \\rho_A \\rho_B Z(\\tau), \\gamma, \\beta \\gamma) \\cdot g</span>$</p>

    <p class="text-gray-300">The following claim enables us to use the knowledge of exponent assumption in the proof of Theorem 4.6.</p>

    <p class="text-gray-300">Claim 4.5. There are efficient (deterministic) functions  <span class="math">F_A, F_B, F_C</span>  such that the following holds. Fix any vector secrets =  <span class="math">(\\tau, \\rho_A, \\rho_B, \\alpha_A, \\alpha_B, \\alpha_C, \\gamma, \\beta)</span>  in  <span class="math">(\\mathbb{F}_r^*)^8</span>  and instance  <span class="math">\\phi</span> . Denote by secrets<sub>A</sub>, secrets<sub>B</sub> and secrets<sub>C</sub> the vector secrets when omitting the element  <span class="math">\\alpha_A, \\alpha_B</span>  and  <span class="math">\\alpha_C</span>  respectively. Then</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} &amp;\\mathsf{params}_{\\phi}(\\mathsf{secrets}) = F_A(P_H, P_H \\cdot \\alpha_A, \\mathsf{secrets}_A, \\phi) \\\\ &amp;= F_B(P_H, P_H \\cdot \\alpha_B, \\mathsf{secrets}_B, \\phi) = F_C(P_H, P_H \\cdot \\alpha_C, \\mathsf{secrets}_C, \\phi) \\end{aligned}</span>$</p>

    <p class="text-gray-300">Proof. By simple examination of the elements of  <span class="math">\\mathsf{params}_\\phi(\\mathsf{secrets})</span> . For example, the only elements in  <span class="math">\\mathsf{params}_\\phi(\\mathsf{secrets})</span>  that are not a function of  <span class="math">\\mathsf{secrets}_A</span>  are  <span class="math">P_{\\alpha A}</span>  and  <span class="math">\\alpha_A \\cdot g \\in V</span> . Both are a joint efficient function of  <span class="math">\\rho_A</span>  and  <span class="math">P_H \\cdot \\alpha_A</span> : We can compute  <span class="math">P_H \\cdot \\alpha_A \\cdot \\rho_A = \\left\\{ \\tau^i \\rho_A \\alpha_A \\cdot g \\right\\}_{i \\in [d]}</span>  and then  <span class="math">P_{\\alpha A}</span>  elements are linear combinations of elements of this vector, and  <span class="math">\\alpha_A \\cdot g</span>  is simply the first element of  <span class="math">P_H \\cdot \\alpha_A</span> .</p>

    <p class="text-gray-300">Recall that V denotes the Pinocchio protocol verifier. The inputs of V include the QAP instance  <span class="math">\\phi</span> , the instance input x, the CRS or public parameters  <span class="math">\\mathsf{params}_{\\phi}</span> , and the purported proof  <span class="math">\\pi</span>  that indeed x satisfies  <span class="math">\\phi</span> , and that the prover knows a witness showing this. A slight modification of the security proof of [PHGR16] shows that</p>

    <p class="text-gray-300"><strong>Theorem 4.6.</strong> [Pinocchio proof of knowledge] For any efficient A there exists an efficient extractor E such that for any instance  <span class="math">\\phi</span>  and input x the following holds. The probability over secrets  <span class="math">\\in (\\mathbb{F}_r^*)^8</span> , when A and E are given  <span class="math">(\\phi, x)</span>  and params <span class="math">_{\\phi}</span> (secrets) as input that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A produces  <span class="math">\\pi</span>  such that  <span class="math">V(\\phi, x, params_{\\phi}(secrets), \\pi) = acc</span> , but</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>E does not output a witness  <span class="math">\\omega</span>  satisfying  <span class="math">(\\phi, x)</span> ,</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">is \\text{ negl}(\\log r).</span></p>

    <p class="text-gray-300">The proof is almost identical to that of [PHGR16], but we present it here for completeness, at times referring to [PHGR16] for details. An advantage of this proof is that it works for the variant of Pinocchio actually implemented in libsnark, as described in Appendix B of [BCTV14]. To our knowledge, no proof for this variant is written elsewhere. We also recommend looking at the proofs of [GGPR13, CFH<sup>+</sup>15] for intuition and clarifications.</p>

    <p class="text-gray-300"><em>Proof.</em> We are given A and wish to construct E. We describe how E operates given inputs  <span class="math">(\\phi, x)</span>  and  <span class="math">\\mathsf{params}_{\\phi}(\\mathsf{secrets})</span> . Recall that the purported proof  <span class="math">\\pi</span>  produced by A has the structure, in the notation of [BCTV14],</p>

    <p class="text-gray-300"><span class="math">$\\pi = (\\pi_A, \\pi_B, \\pi_C, \\pi&#x27;_A, \\pi&#x27;_B, \\pi&#x27;_C, \\pi_K, \\pi_H).</span>$</p>

    <p class="text-gray-300">From the description of V, we know that whenever A produces a proof  <span class="math">\\pi</span>  accepted by V, we have in particular,  <span class="math">\\pi&#x27;_A = \\alpha_A \\cdot \\pi_A, \\pi&#x27;_B = \\alpha_B \\cdot \\pi_B</span>  and  <span class="math">\\pi&#x27;_C = \\alpha_C \\cdot \\pi_C</span> , where  <span class="math">\\alpha_A, \\alpha_B, \\alpha_C</span>  are the corresponding elements of the vector secrets. E works as follows. It gives  <span class="math">\\mathsf{params}_\\phi(\\mathsf{secrets})</span>  as input to the extractors  <span class="math">E_A, E_B, E_C</span>  that exist by the KEA assumption together with Claim 4.5 and Remark 4.2. Let  <span class="math">a_0, \\ldots, a_d</span>  be  <span class="math">E_A</span> 's output. Define  <span class="math">A_{\\mathrm{mid}}(X) := \\sum_{i=0}^d a_i \\cdot X^i</span> . Let  <span class="math">A_{io}</span>  be the polynomial of degree at most d defined by the io elements in x; i.e., when  <span class="math">x = (c_1, \\ldots, c_n)</span> ,  <span class="math">A_{io}(X) := A_0(X) + \\sum_{i=1}^n c_i \\cdot A_i(X)</span> . Define  <span class="math">A(X) := A_{io}(X) + A_{\\mathrm{mid}}(X)</span> . E does an analogous thing with  <span class="math">E_B</span>  and  <span class="math">E_C</span>  to obtain polynomials B, C. Now, using linear algebra, E determines whether there exists a set of coefficients  <span class="math">c = (c_0 = 1, c_1, \\ldots, c_m)</span> , such that</p>

    <p class="text-gray-300"><span class="math">$A(X) = \\sum_{i=0}^{m} c_i \\cdot A_i(X), B(X) = \\sum_{i=0}^{m} c_i \\cdot B_i(X), C(X) \\cdot \\sum_{i=0}^{m} c_i \\cdot C_i(X).</span>$</p>

    <p class="text-gray-300">From the non-degeneracy property<sup>5</sup> [BCTV14], it follows that if there exists such c it coincides with x on  <span class="math">c_1, \\ldots, c_n</span> . If such c exists, output any such c as the proposed QAP witness  <span class="math">\\omega</span>  for  <span class="math">(\\phi, x)</span> .</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;5</sup>One needs to make a stronger definition of non-degeneracy than given in [BCTV14]. Specifically, we require that  <span class="math">A_0, \\ldots, A_n</span>  are linearly independent and their span is disjoint form the span of  <span class="math">\\{A_{n+1}, \\ldots, A_m\\}</span>  except for 0.</p>

    <p class="text-gray-300">Otherwise, abort. Let  <span class="math">\\eta</span>  be the probability that A produced a valid proof but E did not produce a valid assignment for  <span class="math">(\\phi, x)</span> . Let q := 4d + 4. We construct an efficient B with the following property. Given a challenge challenge = challenge<sub>s</sub> :=  <span class="math">(1, s, \\ldots, s^q, s^{q+2}, \\ldots, s^{2q}) \\cdot g</span> , where s is uniform in  <span class="math">\\mathbb{F}_r^*</span> , B outputs with probability  <span class="math">\\eta</span>  &ndash; negl(log r) either</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">s^{q+1} \\cdot g_1</span> , or</li>
      <li><span class="math">e(g_1, g_2)^{\\frac{1}{s+t}}</span> , for some  <span class="math">t \\in \\mathbb{F}_r^*</span> .</li>
    </ul>

    <p class="text-gray-300">This implies that  <span class="math">\\eta = \\mathsf{negl}(\\log r)</span> , as otherwise it would contradict the 2q - SDH or q - PDH assumption. Thus, showing  <span class="math">\\eta = \\mathsf{negl}(\\log r)</span>  suffices to prove the theorem. <sup>6</sup></p>

    <p class="text-gray-300"><strong>Description of</strong> B: Given challenge, B begins by constructing a valid set of parameters params<sup>pin</sup>, that are a randomized function params<sup>pin</sup>(s) of  <span class="math">s \\in \\mathbb{F}_r^*</span> , as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\alpha_A, \\alpha_B, \\alpha_C, \\rho_A&#x27;, \\rho_B&#x27;, \\gamma&#x27;</span>  are chosen uniformly in  <span class="math">\\mathbb{F}_r^*</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We define  <span class="math">\\rho_A := \\rho_A&#x27; \\cdot s^{d+1}, \\rho_B := \\rho_B&#x27; \\cdot s^{2(d+1)}</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For  <span class="math">i \\in [0..m]</span> , define the polynomial  <span class="math">P_i(X) := \\rho_A&#x27; X^{d+1} \\cdot A_i(X) + \\rho_B&#x27; X^{2(d+1)} \\cdot B_i(X) + \\rho_A&#x27; \\rho_B&#x27; X^{3(d+1)} \\cdot C_i(X)</span> . Define V to be the  <span class="math">\\mathbb{F}_r</span> -linear space  <span class="math">V := \\operatorname{span} \\{P_i\\}_{i \\in [0..m]}</span>  and U to be the  <span class="math">\\mathbb{F}_r</span> -linear space of all polynomials f of degree at most 3d+3 such that  <span class="math">f \\cdot P_i</span>  has a zero coefficient at  <span class="math">X^q</span>  for each  <span class="math">i \\in [0..m]</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Choose random  <span class="math">f \\in U</span> , and let  <span class="math">\\beta := s \\cdot f(s)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let  <span class="math">\\gamma := \\gamma&#x27; \\cdot s^{q+2}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>output params<sup>pin</sup> <span class="math">(s) := \\mathsf{params}_{\\phi}(s, \\rho_A, \\rho_B, \\alpha_A, \\alpha_B, \\alpha_C, \\gamma, \\beta)</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">It can be verified that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>When s is uniform in  <span class="math">\\mathbb{F}_r^*</span> , params<sup>pin</sup>(s) is distributed as  <span class="math">\\mathsf{params}_{\\phi}(\\mathsf{secrets})</span>  for uniform value of  <span class="math">\\mathsf{secrets}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">params^{pin}(s)</span>  can be efficiently computed from challenge<sub>s</sub>.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">The main point to see the second item is that the power  <span class="math">s^{q+1}</span>  does not appear in any of the elements of params<sup>pin</sup>(s) (this is immediate for most elements, and requires a calculation for elements containing  <span class="math">\\beta</span> ).</p>

    <p class="text-gray-300">Now B runs A on  <span class="math">(\\phi, x, \\mathsf{params}^{\\mathsf{pin}}(s))</span>  to obtain a purported proof  <span class="math">\\pi = (\\pi_A, \\pi_B, \\pi_C, \\pi_A&#x27;, \\pi_B&#x27;, \\pi_C&#x27;, \\pi_K, \\pi_H)</span> . B also runs  <span class="math">E_A, E_B, E_C</span>  on  <span class="math">\\mathsf{params}^{\\mathsf{pin}}(s)</span>  to obtain polynomials A, B, C described above, and attempts to find a vector c of coefficients as above. Because of Item 1, together with the KEA and the reasoning above, we know that with probability at least  <span class="math">\\eta - \\mathsf{negl}(\\log r)</span>  over s,</p>

    <p class="text-gray-300"><span class="math">$A_{io}(s)\\rho_A \\cdot g_1 + \\pi_A = A(s)\\rho_A \\cdot g_1; \\pi_B = B(s)\\rho_B \\cdot g_2; \\pi_C = C(s)\\rho_A\\rho_B \\cdot g_1,</span>$</p>

    <p class="text-gray-300">but one of the following happened</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;6</sup>For the completely precise argument one must also choose  <span class="math">g \\in G^*</span>  randomly and take success probability over that. To avoid having to &quot;carry the g&quot;, we implicitly assume that whenever a statement is made about fixed g it happens with non-negligible probability over a uniform choice of g. e.g. in the theorem statement we are actually assuming A produces a valid proof for  <span class="math">(\\phi, x, \\mathsf{params}_{\\phi}(\\mathsf{secrets}))</span>  with probability  <span class="math">\\delta</span> , for a non-negligible fraction of  <span class="math">g \\in G^*</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>There does not exist a vector c as described above.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Such c exists but is not a valid QAP witness for  <span class="math">(\\phi, x)</span></li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Define the polynomial</p>

    <p class="text-gray-300"><span class="math">$R(X) := \\rho_A&#x27; X^{d+1} \\cdot A(X) + \\rho_B&#x27; X^{2(d+1)} \\cdot B(X) + \\rho_A&#x27; \\rho_B&#x27; X^{3(d+1)} \\cdot C(X).</span>$</p>

    <p class="text-gray-300">These two cases are equivalent, respectively, to the following two.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>R(X) is not in the subspace V.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">P(X) := A(X) \\cdot B(X) C(X)</span>  is not a multiple of Z(X).</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Suppose that R(X) is not in V. We show that in this case B can efficiently compute  <span class="math">s^{q+1} \\cdot g_1</span> : It follows from Lemma 10 of [GGPR13] that except with probability 1/r (over s and the inner randomness of params<sup>pin</sup>),  <span class="math">R&#x27;(X) := X \\cdot f(X) \\cdot R(X)</span>  has a non-zero coefficient at  <span class="math">X^{q+1}</span> . But note that as  <span class="math">\\pi</span>  was valid,</p>

    <p class="text-gray-300"><span class="math">$\\pi_K = \\beta \\cdot (\\rho_A \\cdot A(s) + \\rho_B \\cdot B(s) + \\rho_A \\rho_B \\cdot C(s)) \\cdot g_1 = R&#x27;(s) \\cdot g_1.</span>$</p>

    <p class="text-gray-300">B can thus use challenge to erase all elements of  <span class="math">R&#x27;(s) \\cdot g_1</span>  of powers different than q+1, obtaining  <span class="math">s^{q+1} \\cdot g_1</span> .</p>

    <p class="text-gray-300">Now suppose that P(X) is not a multiple of Z(X). The same argument as in [PHGR16] can now be used to obtain  <span class="math">e(g_1, g_2)^{\\frac{1}{s+t}}</span> , for some  <span class="math">t \\in \\mathbb{F}_r^*</span> .</p>

    <p class="text-gray-300">We say an adversary A defeats the protocol, if it is able to produce a set of parameters for which it can construct a valid proof, when COMMIT is replaced by a random oracle. More formally,</p>

    <p class="text-gray-300"><strong>Definition 4.7.</strong> Let B be an adversary controlling n-1 out of n players in our protocol. We assume B is deterministic (as we can fix its randomness to maximize its success probability as defined next). Let  <span class="math">P \\in \\{P_1, \\ldots, P_n\\}</span>  be the player not controlled by B. We say B  <span class="math">\\delta</span> -defeats the protocol on  <span class="math">(\\phi, x)</span>  if with probability at least  <span class="math">\\delta</span>  over the randomness of P in the protocol, and over the choices of a random oracle choosing the output values of COMMIT in the protocol description, the protocol verifier accepts the transcript, and B afterwards produces a proof  <span class="math">\\pi</span>  such that  <span class="math">V(\\phi, x, \\pi, \\mathsf{params}_{\\phi}^B) = \\mathsf{acc}</span> , where  <span class="math">\\mathsf{params}_{\\phi}^B</span>  are the Pinocchio parameters for instance  <span class="math">\\phi</span>  that were generated by the protocol.</p>

    <p class="text-gray-300">The correctness of the protocol lies in the following theorem.</p>

    <p class="text-gray-300"><strong>Theorem 4.8.</strong> For any efficient B controlling some subset of n-1 out of n players, there is an efficient A such that the following holds. Fix any instance  <span class="math">\\phi</span>  and input x. Suppose that B  <span class="math">\\delta</span> -defeats the protocol on  <span class="math">(\\phi, x)</span> . Then A  <span class="math">\\frac{\\delta}{\\operatorname{poly}(\\log r)}</span> -defeats Pinocchio on  <span class="math">(\\phi, x)</span> . In particular, if B's success probability is non-negligible, so is A's success probability.</p>

    <p class="text-gray-300">Before proving the theorem note that an immediate corollary of Theorems 4.6 and 4.8 is</p>

    <p class="text-gray-300">Corollary 4.9. [Knowledge Soundness of Protocol] For any efficient B controlling some subset of n-1 out of n players, there is an efficient extractor E such that the following holds. Fix any instance  <span class="math">\\phi</span>  and input x. Suppose that B  <span class="math">\\delta</span> -defeats the protocol on  <span class="math">(\\phi, x)</span> . Then E produces a witness  <span class="math">\\omega</span>  satisfying  <span class="math">(\\phi, x)</span>  with probability  <span class="math">\\frac{\\delta}{\\text{poly}(\\log r)}</span>  over secrets  <span class="math">\\in (\\mathbb{F}_r^*)^8</span> , when given  <span class="math">(\\phi, x)</span>  params <span class="math">_{\\phi}(\\text{secrets})</span>  as input.</p>

    <p class="text-gray-300">We proceed to prove Theorem 4.8.</p>

    <h4 id="sec-misc-11" class="text-lg font-semibold mt-6">Proof of Theorem 4.8</h4>

    <p class="text-gray-300">For ease of notation, we assume that B controls  <span class="math">P_2,\\ldots,P_n</span> . Also, we describe a non-uniform algorithm making choices depending on  <span class="math">(\\phi,x)</span> . However, inspection shows that making all these choices uniformly (and independently of  <span class="math">(\\phi,x)</span> ) succeeds with probability  <span class="math">\\delta/\\text{poly}\\log r</span> . We denote by  <span class="math">\\mathcal R</span>  the random oracle that chooses the values of COMMIT in the protocol. We assume the range (i.e. domain of replies) of  <span class="math">\\mathcal R</span>  is of size  <span class="math">\\mathsf M=\\text{poly}(r)</span>  which is exponential in our prespective. We will denote by  <span class="math">\\pi</span>  the purported proof and  <span class="math">\\mathsf{params}_\\phi^B</span>  the Pinocchio parameters generated in the protocol when B is participating. (These are randomized functions of various elements as will be discussed below). We will say  <span class="math">\\mathsf{params}_\\phi^B</span>  and  <span class="math">\\pi</span>  are accepted by  <span class="math">\\mathsf V</span> , if  <span class="math">\\mathsf V(\\phi,x,\\mathsf{params}_\\phi^B,\\pi)=\\mathsf{acc}</span> . It will be convenient to view the protocol as divided into two main phases.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The <em>commit and prove phase</em> which consists of Round 1 and Parts 1-3 of Round 2, i.e., all parts of Round 2 except the random powers subprotocol.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the <em>compute parameters phase</em> which consists of the random powers subprotocol in Round 2, together with Rounds 3 and 4.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Let  <span class="math">e = \\{e_i\\}_{i \\in [n]}</span>  be the set of elements broadcast in Round 2 Part 1 during some execution of the protocol. Inspection of the protocol shows that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If all players follow the protocol, the transcript of the compute parameters phase is a deterministic function comp-transcript(e) of e.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Using the correctness of the sameRatio(,) method, given the value of e in the commit and prove phase, if one of the players writes a message that does not coincide with comp-transcript(e) in the compute parameters phase, the transcript will be accepted by the protocol verifier with probability at most 2/r. Thus, we assume that after the commit and prove phase, B follows the protocol correctly in the compute parameters phase; as otherwise we may replace him by another adversary B' that does so, and  <span class="math">\\delta \\mathsf{negl}(\\log r)</span> -defeats the protocol.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>In Round 2 Part 3, whenever B broadcasts an element R in one of the nizks, if he has not queried  <span class="math">\\mathcal{R}(R \\circ h)</span>  where h will be the appropriate element  <span class="math">h_{s,j}</span> , the transcript will be accepted with probability at most  <span class="math">1/\\mathsf{M} = \\mathsf{negl}(\\log r)</span> . Thus we can assume B always makes these queries, as otherwise he may be replaced with an B' that does and  <span class="math">\\delta \\mathsf{negl}(\\log r)</span>  defeats the protocol.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Similarly, if B has not queried  <span class="math">\\mathcal{R}(e_i)</span>  before broadcasting  <span class="math">h_i</span> , and has not indeed broadcasted  <span class="math">\\mathcal{R}(e_i)</span>  as  <span class="math">h_i</span> , where  <span class="math">e_i</span>  is what he will broadcast in Round 2 Part 1 his success probability is negligible, and we can assume this is not the case.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Note that  <span class="math">P_1</span> , acting honestly makes 10 calls to  <span class="math">\\mathcal{R}</span> - one in the first round to compute his message  <span class="math">h_1</span> , and 9 to compute the elements h,  <span class="math">\\{h_{1,s}\\}</span>  in Round 2 Part 3. Let us assume B makes exactly Q' queries to  <span class="math">\\mathcal{R}</span>  during Round one and two, and let Q := Q' + 10 be the total number of queries made to  <span class="math">\\mathcal{R}</span> . Note that  <span class="math">Q = \\text{poly}(\\log r)</span>  since the size of B is  <span class="math">\\text{poly}(\\log r)</span> . Denote the answers of  <span class="math">\\mathcal{R}</span>  by  <span class="math">C := \\{c_1, \\ldots, c_Q\\}</span> . Denote the queries by  <span class="math">q_1, \\ldots, q_Q</span> . Assume  <span class="math">q_1, \\ldots, q_{Q/2}</span>  are exactly the ones made before the broadcast of  <span class="math">e_1</span>  in Round 2. Denote by M the set of messages of  <span class="math">P_1</span>  in the Round 2 part of the commit and prove phase, that are not outputs of  <span class="math">\\mathcal{R}</span> - so M consists of the values  <span class="math">e_i</span>  and the outputs  <span class="math">\\{\\pi_{1,s}\\}</span>  of the nizks from Round 2 Part 3.</p>

    <p class="text-gray-300">Under this assumption, together with items 2 and 3 above, the whole protocol transcript, and in particular the Pinocchio parameters  <span class="math">\\mathsf{params}_\\phi^B</span>  and the purported proof  <span class="math">\\pi</span>  generated by B, are a deterministic function F of (C, M); i.e., we can denote  <span class="math">(\\mathsf{params}_\\phi^B, \\pi) = F(C, M)</span> . From the fact that B  <span class="math">\\delta</span> -defeats the protocol, we know that there is a set of density  <span class="math">\\delta</span>  of sequences (C, M) that cause B to produce a valid proof  <span class="math">\\pi</span>  when  <span class="math">\\mathsf{V}</span>  uses  <span class="math">\\mathsf{params}_\\phi^B</span> . We can thus, using an averaging argument, fix a set of values S for (C, M) such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>S has probability mass  <span class="math">\\delta&#x27; = \\delta \\text{negl}(\\log r)</span>  in the space of all possible values for (C, M), when C is random, and M is distributed according to an honest player  <span class="math">P_1</span> 's messages.</li>
    </ol></li>
      <li><span class="math">2.\\ C</span>  contains all distinct elements.</li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For any  <span class="math">(C, M) \\in S</span> , F(C, M) is accepted by V.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Denote  <span class="math">E:=\\bigcup_{i\\in[2..n]}\\mathsf{secrets}_i</span> , and enumerate the elements of E somehow as  <span class="math">E_1,\\ldots,E_\\ell</span> , where  <span class="math">\\ell:=8\\cdot(n-1)</span> . Note that the elements of E are determined (although not efficiently) by the protocol transcript and thus by (C,M). Note that in Round 2, E has to present Schnorr nizk proofs for all elements of E, each requiring a query to E0 on the corresponding element E1 on E2 another averaging argument similar to the &quot;forking lemma&quot;, there exists a permutation E3 on E4 and indices E5 of density (meaning probability mass) E6 in the space of all values for E7 such that for each E8 of density (meaning probability mass) E9.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>F(C, M) is accepted by V.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>When executing the protocol with (C, M), for each  <span class="math">j \\in [\\ell]</span> , B uses the value  <span class="math">c_{i_j}</span>  for the challenge c in the nizk of  <span class="math">E_{\\sigma(j)}</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">We assume from now on that  <span class="math">\\sigma</span>  is the identity for simplicity of notation. Yet another averaging argument, using the non-negligibility of  <span class="math">\\delta&#x27;&#x27;</span> , allows us to construct a string  <span class="math">C^*</span>  such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">(C^*, M) \\in T</span>  with probability  <span class="math">\\delta&#x27;&#x27;</span>  over M.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For any  <span class="math">j \\in [\\ell]</span> , there are strings  <span class="math">(C&#x27;, M&#x27;), (C&#x27;&#x27;, M&#x27;) \\in T</span> , i.e., that agree on the M' part, such that C' and C'' agree with  <span class="math">C^*</span>  on first  <span class="math">i_j 1</span>  indices, but disagree with each other on the  <span class="math">i_j</span> 'th coordinate.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">We now note an important point:</p>

    <p class="text-gray-300">Fix some  <span class="math">j \\in [\\ell]</span> . Then any string  <span class="math">(C&#x27;, M&#x27;) \\in T</span>  in which C' agrees with  <span class="math">C^*</span>  on indices  <span class="math">1, \\ldots, i_j-1</span> , must lead to the same value of  <span class="math">E_j</span> . This is because conditioned on being in T, the query  <span class="math">q_{i_j}</span>  to  <span class="math">\\mathcal{R}</span>  will contain  <span class="math">\\operatorname{rp}_{E_j}^1</span> - which uniquely determines  <span class="math">E_j</span> , and the value of  <span class="math">q_{i_j}</span>  is a deterministic function of  <span class="math">c_1, \\ldots, c_{i_j-1}</span> , when  <span class="math">i_j \\leq Q/2</span> , and otherwise using item  <span class="math">4 E_j</span>  is determined by  <span class="math">c_1, \\ldots, c_{Q/2}</span> . The second property above about the elements  <span class="math">(C&#x27;, M&#x27;), (C&#x27;&#x27;, M&#x27;) \\in T</span>  implies we have access to two valid Schnorr nizks for  <span class="math">E_j</span>  with the same R but different challenges c, which implies using the well-known Schnorr extractability property that A can extract the value  <span class="math">E_j</span>  used by B given any  <span class="math">(C^*, M) \\in T</span> .</p>

    <p class="text-gray-300">Now let T' be the subset of T consisting of elements beginning with  <span class="math">C^*</span></p>

    <p class="text-gray-300">Now let  <span class="math">\\mathsf{params}_{\\phi} = \\mathsf{params}_{\\phi}(\\mathsf{secrets})</span>  be the parameters given as a challenge to A (for which he should construct an accepting proof). Let  <span class="math">\\mathsf{secrets}_1 := \\mathsf{secrets}/(\\mathsf{secrets}_2 \\cdots \\mathsf{secrets}_n)</span>  be the coordinate wise division of the corresponding secrets vectors. Recall  <span class="math">E = \\mathsf{secrets}_2 \\cup \\ldots \\cup \\mathsf{secrets}_n</span>  is fixed</p>

    <p class="text-gray-300">conditioned on  <span class="math">(C, M) \\in T&#x27;</span> , and A has extracted the values E. Inspection of the protocol shows that A can efficiently play the role of  <span class="math">P_1</span>  when he chooses this value of  <span class="math">\\operatorname{secrets}_1</span> , just from knowing E and  <span class="math">\\operatorname{params}_{\\phi}(\\operatorname{secrets})</span> , with one potential exception: Constructing valid nizks of the elements of  <span class="math">\\operatorname{secrets}_1</span>  which he does not know. However, he can do this also using his ability to program E. He will choose random E elements as the answers E in the nizks and then compute E is a conduct the protocol with E using the values E in which case he aborts. He then conducts the protocol with E using the values E in the nizks are uniformly distributed. Thus the probability that E in the E is at least E in the probability that E is at least E when E is non-negligible when E is non-negligible.</p>

      <h3 id="sec-4.3" class="text-xl font-semibold mt-8">4.3 Zero-Knowledge</h3>

    <p class="text-gray-300">Campanelli, Gennaro, Goldfeder and Nizzardo [CGGN17] have recently noted that a malicious choice of  <span class="math">\\mathsf{params}_\\phi</span>  can potentially break the zero-knowledge guarantee of the Pinocchio protocol. We prove that statistical zero-knowledge holds when using the parameters generated by our protocol, even in the case that all n players are malicious and colluding, provided the prover verifies the protocol transcript before sending her proof.</p>

    <p class="text-gray-300">Denote by P the (honest) prover of the Pinocchio protocol. We can think of P as a randomized function  <span class="math">P(\\phi, x, \\mathsf{params}_{\\phi}, \\omega)</span>  generating a proof according to the instance, input, public parameters and witness. (See Appendix B of [BCTV14] for a full description of P.) We slightly alter P and think of it as an algorithm  <span class="math">P(\\phi, x, \\mathsf{transcript}, \\omega)</span>  that also receives a protocol transcript transcript, and first applies the protocol verifier on transcript. If the protocol verifier rejects, P outputs rej and nothing else. If the protocol verifier accepts, P derives the parameters  <span class="math">\\mathsf{params}_{\\phi}</span>  from the transcript, and outputs  <span class="math">P(\\phi, x, \\mathsf{params}_{\\phi}, \\omega)</span>  for the original prover P. We will assume further for simplicity that P applies a deterministic protocol verifier. This mean she will not use the more efficient randomized checking of whether a vector is an s-vector as described in Claim 2.3, but will check each s-pair separately as described in Claim 2.2.</p>

    <p class="text-gray-300"><strong>Theorem 4.10.</strong> [Statistical Zero-Knowledge] For any polynomial P and positive integer<sup>8</sup> n, there is an efficient sim such that the following holds. Fix any efficient B controlling all n players in the protocol, instance  <span class="math">\\phi</span> , input x and witness  <span class="math">\\omega</span> . Let  <span class="math">\\mathcal{D}</span>  be the distribution obtained by outputting the protocol transcript transcript(B) concatenated with the proof  <span class="math">P(\\phi, x, \\text{transcript}(B), \\omega)</span>  (over the randomness of B in the protocol, the randomness of the oracle  <span class="math">\\mathcal{R}</span> , and that of P in generating the proof). Then the distribution  <span class="math">\\mathcal{D}_{sim}</span>  of the output of  <span class="math">sim^B</span>  has distance at most  <span class="math">1/P(\\log r)</span>  to  <span class="math">\\mathcal{D}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Note that if we can simulate  <span class="math">\\mathcal{D}</span>  with error  <span class="math">1/P(\\log r)</span>  conditioned on every fixing of the randomness of B, we can simulate the fully randomized B with the same error. So the simulator begins by choosing the randomness of B uniformly, and we can assume we are working with a deterministic B. Assume B always makes exactly Q queries to the random oracle  <span class="math">\\mathcal{R}</span>  emulating COMMIT (if this is just an upper bound we can think of B not reading the last answers sometimes). As before, we denote by M the range size of  <span class="math">\\mathcal{R}</span>  and assume  <span class="math">r \\leq M \\leq \\operatorname{poly}(r)</span> . The transcript output</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;7</sup>This is the place where it is essential that  <span class="math">\\mathsf{params}_{\\phi}(\\mathsf{secrets})</span>  contains an extended CRS with elements in both groups; otherwise this claim would be false.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;8</sup>Examining the proof shows that it works also for  <span class="math">n = \\text{poly} \\log r</span>  but since our soundness proof requires constant n, we state the theorem here also for constant n.</p>

    <p class="text-gray-300">transcript(B) is a deterministic function of a sequence r of answers of R to queries of B. We denote this transcript transcript(r). The corresponding set of queries {q1, . . . , qQ} of B to R is also a deterministic function of r. More specifically, the first i + 1 queries are a deterministic function of the first i elements of r. We denote by D<sup>r</sup> the distribution of P(&phi;, x,transcript(r), &omega;).</p>

    <p class="text-gray-300">We will show that for a (1 &minus; 1/P(log r))-fraction of the sequences r, sim can simulate D<sup>r</sup> with error negl(log r) given r. Clearly this suffices - as sim can choose a random r, output transcript(r) and then try to simulate D<sup>r</sup> using this method.</p>

    <p class="text-gray-300">sim begins by sampling a random sequence r and characterizing it as either good, negligible or bad. This characterization will have the property that a bad sequence r will have D<sup>r</sup> be rej with probability 1 &minus; negl(log r), and the negligible r together will have probability negl(log r).</p>

    <p class="text-gray-300">Characterizing r: If r has repetitions it is labeled negligible - because since Q = poly log r, such sequences are a negl(log r) fraction. Otherwise sim executes B(r). If B aborts before producing a full transcript, r is labeled bad. In particular, sim has checked if the values {ei}i&isin;[n] and nizk proofs {&pi;i,s}i&isin;[n],s&isin;secrets<sup>i</sup> are present in the Round 2 part of the transcript and otherwise labeled r bad.</p>

    <p class="text-gray-300">It then checks if the queries {R(ei)}i&isin;[n] ,h := R(R(e1)&#9702;. . .&#9702;R(en)), R(R<sup>s</sup> &#9702; h &#9702; rp<sup>1</sup> s ) i&isin;[n],s&isin;secrets<sup>i</sup> were made (recall that B's sequence of queries is a deterministic function of r that can be efficiently derived given blackbox access to B); here R<sup>s</sup> is the first part of &pi;i,s. If not all queries were made, r is labeled as bad - as the transcript is correct only if</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the values {hi} in the transcript are equal to {R(ei)},</li>
      <li>the nizk proofs &pi;i,s are verified with challenges ci,s(r) := R(R<sup>s</sup> &#9702; h &#9702; rp<sup>1</sup> s ) , which in turn determine a unique uniformly distributed correct second element of &pi;i,s,</li>
    </ul>

    <p class="text-gray-300">and this requires guessing in advance at least one output of R, that can succeed only with probability 1/M.</p>

    <p class="text-gray-300">If all queries were made, sim derives the sequence of indices I = I(r) of the queries R(e1), . . . , R(en), and a sequence of indices J = J(r) where the queries {ci,s} were made. Note that in this case the transcript validity is a deterministic function of transcript(r) and r; as r contains all queries to R of the protocol verifier. sim checks if the protocol verifier accepts and if not labels r bad. sim checks if the query to h was made after all queries in I, if not r is labeled negligible as the transcript will only be valid if for some i &isin; [n], denoting the query R(h<sup>1</sup> &#9702; . . . &#9702; hn), h<sup>i</sup> corresponds to the later determined R(ei). sim then checks if I &lt; J in the sense that all elements of I are smaller than all elements of J. If this is not the case, r is labeled negligible - as in this case the transcript is valid only if for some i &isin; [n] the value h in the queries R(R<sup>s</sup> &#9702; h &#9702; rp<sup>1</sup> s ) equals the value R(R(e1), &#9702; . . . &#9702; R(en)) determined later in the sequence r. If r has been labeled so far sim outputs rej. If sim has not been labeled so far (as bad or neutral), it is labeled good. In this case we can define the vector secrets(r), such that the parameters derived from transcript(r) are params<sup>&phi;</sup> (secrets), which is the vector of secrets uniquely determined by the product of secrets of each player which in turn are uniquely determined by the elements e1, . . . , e<sup>n</sup> in transcript(r).</p>

    <p class="text-gray-300">The proof now follows from two claims. The first tells us that for a good r, D<sup>r</sup> can be simulated given secrets(r). The second tells us that for a (1 &minus; 1/P(log r))-fraction of good r, we can obtain secrets(r) with probability 1 &minus; 1/r.</p>

    <p class="text-gray-300">Claim 4.11. For any polynomial P, there is an algorithm alg that for a (1 &minus; 1/P(log r))-fraction of good r, obtains secrets(r) given r with probability 1 &minus; 1/r in time poly log r.</p>

    <p class="text-gray-300">Proof. Denote  <span class="math">S = \\bigcup_{i \\in [n]} \\mathsf{secrets}_i</span> , where  <span class="math">\\mathsf{secrets}_i</span>  is the vector of variables  <span class="math">\\tau_i, \\rho_{A,i}, \\rho_{B,i}, \\alpha_{A,i}, \\alpha_{B,i}, \\alpha_{C,i}, \\gamma_i, \\beta_i</span> . For good  <span class="math">\\mathsf{r}</span> , and  <span class="math">s \\in S</span>  we denote by  <span class="math">i_s(\\mathsf{r})</span>  the index corresponding to s in  <span class="math">I(\\mathsf{r})</span>  and by  <span class="math">j_s(\\mathsf{r})</span>  the index corresponding to s in  <span class="math">J(\\mathsf{r})</span> . Note that for good  <span class="math">\\mathsf{r}</span>  we always have  <span class="math">i_s(\\mathsf{r}) &lt; j_s(\\mathsf{r})</span> .</p>

    <p class="text-gray-300">For  <span class="math">j \\in [Q]</span> , and  <span class="math">\\mathbf{r} \\in [\\mathsf{M}]^Q</span> , we denote by  <span class="math">W|_{\\mathsf{r}\\setminus j}</span>  the strings  <span class="math">\\mathsf{r}&#x27; \\in [\\mathsf{M}]^Q</span>  that are equal to  <span class="math">\\mathsf{r}</span>  outside of j. For  <span class="math">s \\in S</span>  and good  <span class="math">\\mathsf{r}</span> , we denote by  <span class="math">W_{\\mathsf{r},s}</span>  the set of good  <span class="math">\\mathsf{r}&#x27; \\in [\\mathsf{M}]^Q</span>  that are equal to  <span class="math">\\mathsf{r}</span>  outside of  <span class="math">j_s(\\mathsf{r})</span> , and have  <span class="math">i_s(\\mathsf{r}&#x27;) = i_s(\\mathsf{r})</span>  and  <span class="math">j_s(\\mathsf{r}&#x27;) = j_s(\\mathsf{r})</span> . Note that the set  <span class="math">W_{\\mathsf{r},s}</span>  is determined by the two indices  <span class="math">i_s(\\mathsf{r}), j_s(\\mathsf{r})</span>  and the values of  <span class="math">\\mathsf{r}</span>  outside of  <span class="math">j_s(\\mathsf{r})</span> ; thus, there are at most  <span class="math">\\mathsf{M}^{Q-1} \\cdot Q^2</span>  such distinct sets. Note also that  <span class="math">W_{\\mathsf{r},s} \\subseteq W|_{\\mathsf{r}\\setminus j_s(\\mathsf{r})}</span> .</p>

    <p class="text-gray-300">Now given good r, alg does the following. Denote  <span class="math">P&#x27; := 2P \\cdot Q^2</span> . For each  <span class="math">s \\in S</span> , letting  <span class="math">j := j_s(\\mathbf{r})</span> , alg samples  <span class="math">2P&#x27;(\\log r) \\cdot \\log r</span>  strings r' from  <span class="math">W|_{\\mathbf{r} \\setminus j}</span> . For each one he checks if  <span class="math">\\mathbf{r}&#x27; \\in W_{\\mathbf{r},s}</span>  and if  <span class="math">\\mathbf{r}&#x27;_j \\neq \\mathbf{r}_j</span> . If both checks hold, it means, that in transcript(r) and transcript(r') he possesses two valid nizk proofs for s with the same first prover message  <span class="math">R_s</span>  but different challenges. This means he can obtain  <span class="math">s(\\mathbf{r})</span>  using Schnorr's extractability property.</p>

    <p class="text-gray-300">Now the question is what is the probability of not finding a sequence  <span class="math">\\mathbf{r}&#x27;</span>  enabling extraction of  <span class="math">s(\\mathbf{r})</span> . We claim this is at most 1/r, when the density of  <span class="math">W_{\\mathbf{r},s}</span>  in  <span class="math">W|_{\\mathbf{r}\\setminus j}</span>  is at least  <span class="math">1/P&#x27;(\\log r)</span> : In this case the density of elements of  <span class="math">W_{\\mathbf{r},s}</span>  such that  <span class="math">\\mathbf{r}&#x27;_j \\neq \\mathbf{r}_j</span>  is at least  <span class="math">1/P&#x27;(\\log r) - 1/\\mathsf{M} \\geq 1/2P&#x27;(\\log r)</span>  for large enough r. Thus, the probability that no such element  <span class="math">\\mathbf{r}&#x27;</span>  is found is at most  <span class="math">(1-1/2P&#x27;(\\log r))^{2P&#x27;(\\log r)\\cdot \\log r} \\leq 1/r</span> .</p>

    <p class="text-gray-300">Using the union bound, alg extracts all secrets with probability 1 - 8n/r for r such that the density of  <span class="math">W_{\\mathsf{r},s}</span>  in  <span class="math">W|_{\\mathsf{r}\\setminus j_s(\\mathsf{r})}</span>  is at least  <span class="math">1/P&#x27;(\\log r)</span>  for each  <span class="math">s\\in S</span> . Now we must bound the density of good r that do not have this property. Each such r belongs to a set  <span class="math">W_{\\mathsf{r},s}</span>  containing at most  <span class="math">\\mathsf{M}/P&#x27;(\\log r)</span>  elements. Thus, there at most</p>

    <p class="text-gray-300"><span class="math">$\\frac{\\mathsf{M} \\cdot \\mathsf{M}^{Q-1} \\cdot Q^2}{P&#x27;(\\log r)} = \\frac{\\mathsf{M}^Q \\cdot Q^2}{2P(\\log r) \\cdot Q^2} = \\frac{\\mathsf{M}^Q}{2P(\\log r)}</span>$</p>

    <p class="text-gray-300">such elements, which is a  <span class="math">1/2P(\\log r)</span>  fraction of the space.</p>

    <p class="text-gray-300">Claim 4.12. Suppose that r is good. Then given secrets(r),  <span class="math">\\mathcal{D}_r</span>  can be efficiently simulated with no error</p>

    <p class="text-gray-300"><em>Proof.</em> The proof is similar to that of Theorem 13 in [GGPR13]. Note that when r is good the elements  <span class="math">A_{m+1} = B_{m+2} = C_{m+3}</span>  in  <span class="math">\\mathsf{params}_{\\phi}(\\mathsf{secrets}(\\mathsf{r}))</span>  are non-zero, as this is required for the transcript to be accepted.</p>

    <p class="text-gray-300">We abuse notation and denote the discrete logs of the proof elements by themselves. As  <span class="math">A_{m+1}, B_{m+2}, C_{m+3}</span>  are non-zero,  <span class="math">\\pi_A, \\pi_B, \\pi_C</span>  are uniformly distributed in  <span class="math">\\mathbb{F}_r</span>  since  <span class="math">c_{m+1}, c_{m+2}, c_{m+3}</span>  are chosen uniformly by P. Now, in a valid proof the other proof elements  <span class="math">\\pi&#x27;_A, \\pi&#x27;_B, \\pi&#x27;_C, \\pi_K, \\pi_H</span>  are deterministic functions of  <span class="math">\\pi_A, \\pi_B, \\pi_C</span> , derived from the verification constraints (see Appendix B). Moreover, given secrets and the discrete logs of  <span class="math">\\pi_A, \\pi_B, \\pi_C</span> , they can be efficiently derived: Defining  <span class="math">A_{io}</span>  as in the proof of Theorem 4.6, we have</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\pi&#x27;_A = \\alpha_A \\cdot \\pi_A</span></li>
    </ol></li>
      <li><span class="math">2. \\ \\pi_B&#x27; = \\alpha_B \\cdot \\pi_B</span></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\pi&#x27;_C = \\alpha_C \\cdot \\pi_C</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\pi_H = ((A_{io}(s) + \\pi_A) \\cdot \\pi_B \\pi_C)/Z(s)</span></li>
    </ol></li>
    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>&pi;<sup>K</sup> = &beta; &middot; ((Aio(s) + &pi;A) + &pi;<sup>B</sup> + &pi;C)</li>
    </ol>

    <p class="text-gray-300">Thus, given the value of secrets(r), sim can efficiently simulate the distribution D<sup>r</sup> .</p>

    </section>

    <section id="acknowledgements" class="mb-10">
      <h2 class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">We thank Eli Ben-Sasson, Alessandro Chiesa, Jens Groth, Daira Hopwood, Hovav Shacham, Eran Tromer, Madars Virza, Nathan Wilcox and Zooko Wilcox for helpful discussions. We thank Daira Hopwood for pointing out some technical inaccuracies. We thank Eran Tromer for bringing to our attention the work of [CGGN17], and the relevance of our protocol to that work, and the connection to subversion zero-knowledge in general.</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><p class="text-gray-300">[ABLZ17] B. Abdolmaleki, K. Baghery, H. Lipmaa, and M. Zajc. A subversion-resistant snark. 2017.</p></li>
      <li><p class="text-gray-300">[BCG+15] E. Ben-Sasson, A. Chiesa, M. Green, E. Tromer, and M. Virza. Secure sampling of public parameters for succinct zero knowledge proofs. In 2015 IEEE Symposium on Security and Privacy, SP 2015, San Jose, CA, USA, May 17-21, 2015, pages 287&ndash;304, 2015.</p></li>
      <li><p class="text-gray-300">[BCPR14] N. Bitansky, R. Canetti, O. Paneth, and A. Rosen. On the existence of extractable one-way functions. In Symposium on Theory of Computing, STOC 2014, New York, NY, USA, May 31 - June 03, 2014, pages 505&ndash;514, 2014.</p></li>
      <li><p class="text-gray-300">[BCTV14] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. Succinct non-interactive zero knowledge for a von neumann architecture. In Proceedings of the 23rd USENIX Security Symposium, San Diego, CA, USA, August 20-22, 2014., pages 781&ndash;796, 2014.</p></li>
      <li><p class="text-gray-300">[BFS16] M. Bellare, G. Fuchsbauer, and A. Scafuro. Nizks with an untrusted CRS: security in the face of parameter subversion. IACR Cryptology ePrint Archive, 2016:372, 2016.</p></li>
      <li><p class="text-gray-300">[CFH+15] C. Costello, C. Fournet, J. Howell, M. Kohlweiss, B. Kreuter, M. Naehrig, B. Parno, and S. Zahur. Geppetto: Versatile verifiable computation. In 2015 IEEE Symposium on Security and Privacy, SP 2015, San Jose, CA, USA, May 17-21, 2015, pages 253&ndash;270, 2015.</p></li>
      <li><p class="text-gray-300">[CGGN17] M. Campanelli, R. Gennaro, S. Goldfeder, and L. Nizzardo. Zero-knowledge contingent payments revisited: Attacks and payments for services. Commun. ACM, 2017.</p></li>
      <li><p class="text-gray-300">[Fuc17] G. Fuchsbauer. Subversion zero-knowledge snarks. 2017.</p></li>
      <li><p class="text-gray-300">[GGPR13] R. Gennaro, C. Gentry, B. Parno, and M. Raykova. Quadratic span programs and succinct nizks without pcps. In Advances in Cryptology - EUROCRYPT 2013, 32nd Annual International Conference on the Theory and Applications of Cryptographic Techniques, Athens, Greece, May 26-30, 2013. Proceedings, pages 626&ndash;645, 2013.</p></li>
      <li><p class="text-gray-300">[lib] https://github.com/scipr-lab/libsnark,https://github.com/zcash/libsnark.</p></li>
      <li><p class="text-gray-300">[PHGR16] B. Parno, J. Howell, C. Gentry, and M. Raykova. Pinocchio: nearly practical verifiable computation. <em>Commun. ACM</em>, 59(2):103&ndash;112, 2016.</p></li>
      <li><p class="text-gray-300">[Sch89] C. Schnorr. Efficient identification and signatures for smart cards. In Advances in Cryptology CRYPTO '89, 9th Annual International Cryptology Conference, Santa Barbara, California, USA, August 20-24, 1989, Proceedings, pages 239&ndash;252, 1989.</p></li>
      <li><p class="text-gray-300">[Wil] Z. Wilcox. https://z.cash/blog/the-design-of-the-ceremony.html.</p></li>
    </ul>

    </section>

    <section id="app-a" class="mb-10">
      <h2 class="text-2xl font-bold">A Actual, more complicated version of <span class="math">e_i</span> in code</h2>

    <p class="text-gray-300">For each  <span class="math">i \\in [n]</span> ,  <span class="math">P_i</span>  first constructs elements, as in Subsection 3.1. That is</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>As described in Generate a set of uniform elements in  <span class="math">\\mathbb{F}_r^*</span></li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\mathsf{secrets}_i := \\{\\tau_i, \\rho_{A,i}, \\rho_{B,i}, \\alpha_{A,i}, \\alpha_{B,i}, \\alpha_{C,i}, \\beta_i, \\gamma_i\\}</span>$</p>

    <p class="text-gray-300">, and let</p>

    <p class="text-gray-300">elements
<span class="math">$_i := \\{ \\tau_i, \\rho_{A,i}, \\rho_{B,i}, \\alpha_{A,i}, \\alpha_{B,i}, \\alpha_{C,i}, \\beta_i, \\gamma_i, \\rho_{A,i}\\alpha_{A,i}, \\rho_{B,i}\\alpha_{B,i}, \\rho_{A,i}\\rho_{B,i}, \\rho_{A,i}\\rho_{B,i}\\alpha_{C,i}, \\beta_i\\gamma_i \\}</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Now each player generates a somewhat complex set of group elements from its set of secrets. We omit the index i for clarity of notation, but it should be appended to all elements below:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a)  <span class="math">P_i</span>  chooses random elements  <span class="math">f_1, f_2, f_3 \\in \\mathbb{G}_2 \\setminus \\{0\\}</span>  and random elements  <span class="math">f_4, f_5, f_6, f_7, f_8 \\in \\mathbb{G}_1 \\setminus \\{0\\}</span> .</li>
      <li>(b)  <span class="math">P_i</span>  stores the sets of  <span class="math">\\mathbb{G}_2</span>  elements</li>
    </ul></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\mathbf{e}_{i}^{2} := \\{ f_{1}, f_{1} \\cdot \\rho_{A}, f_{1} \\cdot \\rho_{A} \\alpha_{A}, f_{1} \\cdot \\rho_{A} \\rho_{B} \\alpha_{C}, f_{1} \\cdot \\rho_{A} \\rho_{B}, f_{1} \\cdot \\rho_{A} \\rho_{B} \\alpha_{B}, f_{2} \\cdot \\beta_{2} \\cdot \\beta_{3}, f_{3} \\cdot \\tau \\},</span>$</p>

    <p class="text-gray-300">and the set of  <span class="math">\\mathbb{G}_1</span>  elements</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{e}_{i}^{1} := \\left\\{ f_{4}, f_{4} \\cdot \\alpha_{A}, f_{5}, f_{5} \\cdot \\alpha_{C}, f_{6}, f_{6} \\cdot \\rho_{B}, f_{7}, f_{7} \\cdot \\rho_{A}, f_{8}, f_{8} \\cdot \\gamma \\right\\}.</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Finally, define  <span class="math">e_i := e_i^1 \\circ e_i^2</span> .</li>
    </ol>

    <p class="text-gray-300">Validity of more complicated definition The only requirement for  <span class="math">\\mathbf{e}_i</span>  to run the protocol is that we always have the needed s-pair for each  <span class="math">s \\in \\mathsf{elements}_i</span> . Inspection shows this is the case with the definition here. For example,  <span class="math">P_i</span>  has broadcasted (omitting index i)  <span class="math">f_1, f_1\\rho_A</span>  and  <span class="math">f_1\\rho_A\\rho_B</span>  as part of  <span class="math">\\mathbf{e}_i^2</span> , out of which we can construct the  <span class="math">\\rho_A</span> -pair  <span class="math">(f_1, f_1\\rho_A)</span> , the  <span class="math">\\rho_B</span> -pair  <span class="math">(f_1\\rho_A, f_1\\rho_A\\rho_B)</span> , and the  <span class="math">\\rho_A\\rho_B</span> -pair  <span class="math">(f_1, f_1\\rho_A\\rho_B)</span> . Since here we don't have a  <span class="math">\\mathbb{G}_1</span> -s-pair and  <span class="math">\\mathbb{G}_2</span> -s-pair for each  <span class="math">s \\in \\mathsf{elements}_i</span> , less consistency checks are performed in Part 2 of Round 2. (Note that to run the protocol we don't need an s-pair for each  <span class="math">s \\in \\mathsf{elements}_i</span>  in each group. For example, we only need a  <span class="math">\\mathbb{G}_2</span> - <span class="math">\\rho_A</span> -pair which is used in Round 3 to compute  <span class="math">PK_A</span> , but we never use a  <span class="math">\\mathbb{G}_1</span> - <span class="math">\\rho_A</span> -pair).</p>

    </section>

    <section id="app-b" class="mb-10">
      <h2 class="text-2xl font-bold">B Implementation details</h2>

    <p class="text-gray-300">In our implementation we use the libsnark alt_bn128 curve implementation where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\mathbb{G}_1 = E/\\mathbb{F}_q</span>  is a BN curve over  <span class="math">\\mathbb{F}_q</span> . That is the set of solutions in  <span class="math">\\mathbb{F}_q^2</span>  of an equation of the form  <span class="math">y^2 = x^3 + b</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\mathbb{G}_2 = E&#x27;/\\mathbb{F}_{q^2}</span>  is a subgroup of order r of a sextic twist of  <span class="math">\\mathbb{G}_1</span> . Where a sextic twist of  <span class="math">\\mathbb{G}_1</span>  means the set of solutions in  <span class="math">\\mathbb{F}_{q^2}</span>  of  <span class="math">y^2 = x^3 + b/\\xi</span> , where  <span class="math">\\xi \\in \\mathbb{F}_{q^2} \\setminus \\mathbb{F}_q</span>  is an element such that the polynomial  <span class="math">W^6 \\xi</span>  is irreducible over  <span class="math">\\mathbb{F}_{q^2}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\mathbb{G}_t</span>  is a subgroup of order r in  <span class="math">\\mathbb{F}_{a^{12}}</span> .</li>
    </ol></li>
    </ul>

    </section>

    <section id="app-c" class="mb-10">
      <h2 class="text-2xl font-bold">C Pinocchio reminder</h2>

    <p class="text-gray-300">We give a brief reminder of how the proof and verification procedure of [PHGR16] look like using the notation of [BCG<sup>+</sup>15]. The prover has in his hand a QAP solution  <span class="math">(c_0 = 1, c_1, \\ldots, c_m)</span>  that coincides with the public input  <span class="math">x = (c_1, \\ldots, c_n)</span>  and satisfies the following. If we define  <span class="math">A := \\sum_{i=0}^m c_i \\cdot A_i</span> ,  <span class="math">B := \\sum_{i=0}^m c_i \\cdot B_i</span> , and  <span class="math">C := \\sum_{i=0}^m c_i \\cdot C_i</span> ; then the polynomial  <span class="math">P := A \\cdot B - C</span>  will be divisble by the target polynomial Z. Given params<sub> <span class="math">\\phi</span> </sub>(secrets), V will compute</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\pi_A := \\rho_A A(s) \\cdot g_1, \\ \\pi&#x27;_A := \\alpha_A \\rho_A A(s) \\cdot g_2.</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\pi_B := \\rho_B B(s) \\cdot g_2, \\ \\pi&#x27;_B := \\alpha_B \\rho_B B(s) \\cdot g_1.</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\pi_C := \\rho_A \\rho_B C(s) \\cdot g_1, \\ \\pi&#x27;_C := \\alpha_C \\rho_A \\rho_B C(s) \\cdot g_2.</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\pi_K := \\beta(\\rho_A A(s) + \\rho_B B(s) + \\rho_A \\rho_B C(s)) \\cdot g_1</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\pi_H := (P(s)/Z(s)) \\cdot g_1</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Now, abuse notation and denote the discrete log of each element above in base  <span class="math">g_1</span>  or  <span class="math">g_2</span>  by the element itself. The verifier, using pairings and the verification key V, will check the following.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\pi&#x27;_A = \\alpha_A \\pi_A</span> .</li>
    </ol></li>
      <li><span class="math">2. \\ \\pi_B&#x27; = \\alpha_B \\pi_B.</span></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\pi&#x27;_C = \\alpha_C \\pi_C</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\pi_K = \\beta(\\pi_A + \\pi_B + \\pi_C)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\pi_A \\cdot \\pi_B \\pi_C = \\pi_H \\cdot Z(s) \\rho_A \\rho_B</span> .</li>
    </ol></li>
    </ul>

    </section>
`;
---

<BaseLayout title="A multi-party protocol for constructing the public parameter... (2017/602)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2017 &middot; eprint 2017/602
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#abstract" class="hover:text-white">Abstract</a></li>
        <li><a href="#sec-1" class="hover:text-white">Introduction</a></li>
        <li>
          <a href="#sec-2" class="hover:text-white">Definitions, notation and auxiliary methods</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-2.1" class="hover:text-white">Comparing ratios of pairs using pairings</a></li>
            <li><a href="#sec-2.2" class="hover:text-white">Schnorr NIZKs for knowledge of discrete log</a></li>
            <li><a href="#sec-2.3" class="hover:text-white">The random-coefficient subprotocol</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-3" class="hover:text-white">Protocol description</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-3.1" class="hover:text-white">Round 1: commitments</a></li>
            <li><a href="#sec-3.2" class="hover:text-white">Round 2</a></li>
            <li><a href="#sec-3.3" class="hover:text-white">Coordinator after Round 2: Computing Lagrange basis using FFT, and preparing the vectors \vec&#123;A&#125;, \vec&#123;B&#125; and \vec&#123;C&#125;</a></li>
            <li><a href="#sec-3.4" class="hover:text-white">Round 3</a></li>
            <li><a href="#sec-3.5" class="hover:text-white">Round 4: Computing key elements involving \beta, especially PK_K</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-4" class="hover:text-white">Security proof</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-4.1" class="hover:text-white">Cryptographic assumptions</a></li>
            <li><a href="#sec-4.2" class="hover:text-white">The Pinocchio Theorem</a></li>
            <li><a href="#sec-4.3" class="hover:text-white">Zero-Knowledge</a></li>
          </ol>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li><a href="#app-a" class="hover:text-white">Actual, more complicated version of e_i in code</a></li>
        <li><a href="#app-b" class="hover:text-white">Implementation details</a></li>
        <li><a href="#app-c" class="hover:text-white">Pinocchio reminder</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#acknowledgements" class="hover:text-white">Acknowledgements</a></li>
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="3-3-coordinator-after-round-2-computing-lagrange-basis-2017" />
  </article>
</BaseLayout>
