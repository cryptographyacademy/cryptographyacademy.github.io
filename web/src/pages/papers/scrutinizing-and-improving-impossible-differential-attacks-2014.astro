---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2014/699';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-18';
const TITLE_HTML = 'Scrutinizing and Improving Impossible Differential Attacks: Applications to CLEFIA, Camellia, LBlock and Simon (Full Version)';
const AUTHORS_HTML = 'Christina Boura, Mar&iacute;a Naya-Plasencia, Valentin Suder';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">Impossible differential cryptanalysis has shown to be a very powerful form of cryptanalysis against block ciphers. These attacks, even if extensively used, remain not fully understood because of their high technicality. Indeed, numerous are the applications where mistakes have been discovered or where the attacks lack optimality. This paper aims in a first step at formalizing and improving this type of attacks and in a second step at applying our work to block ciphers based on the Feistel construction. In this context, we derive generic complexity analysis formulas for mounting such attacks and develop new ideas for optimizing impossible differential cryptanalysis. These ideas include for example the testing of parts of the internal state for reducing the number of involved key bits. We also develop in a more general way the concept of using multiple differential paths, an idea introduced before in a more restrained context. These advances lead to the improvement of previous attacks against well known ciphers such as CLEFIA-128 and Camellia, while also to new attacks against 23-round LBlock and all members of the Simon family.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> block ciphers &middot; impossible differential attacks &middot; CLEFIA &middot; Camellia &middot; LBlock &middot; Simon.</p>
    </section>

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Impossible differential attacks were independently introduced by Knudsen [22] and Biham et al. [7]. Unlike differential attacks [8] that exploit differential paths of high probability, the aim of impossible differential cryptanalysis is to use differentials that have a probability of zero to occur in order to eliminate the key candidates leading to such impossible differentials.</p>

    <p class="text-gray-300">The first step in an impossible differential attack is to find an impossible differential covering the maximum number of rounds. This is a procedure that has been extensively studied and there exist algorithms for finding such impossible differentials efficiently [21, 20, 12]. Once such a maximum-length impossible differential has been found and placed, one extends it by some rounds to both directions. After this, if a candidate key partially encrypts/decrypts a given pair to the impossible differential, then this key certainly cannot be the right one and is thus rejected. This technique provides a sieving of the key space and the remaining candidates can be tested by exhaustive search.</p>

    <p class="text-gray-300">Despite the fact that impossible differential cryptanalysis has been extensively employed, the key sieving step of the attack does not seem yet fully understood. Indeed, this part of the procedure is highly technical and many parameters have to be taken into consideration. Questions that naturally arise concern the way to choose the plaintext/ciphertext pairs, the way to calculate the necessary data to mount the attack, the time complexity of the overall procedure as well as which are the parameters that optimize the attack. However, no simple and generalized way for answering these questions has been provided until now and the generality of most of the published attacks is lost within the tedious details of each application. The problems that arise from this approach is that mistakes become very common and attacks become difficult to verify. Errors in the analysis are often discovered and as we demonstrate in the next paragraph, many papers in the literature present flaws. These flaws include errors in the computation of the time or the data complexity, in the analysis of the memory requirements or of the complexity of some intermediate steps of the attacks. We can cite many such cases for different algorithms, as shown in Table 1. Note however, that the list of flaws presented in this table is not exhaustive.</p>

    <p class="text-gray-300"><sup>*</sup>Partially supported by the French Agence Nationale de la Recherche through the BLOC project under Contract ANR-11-INS-011. &copy;IACR 2014. This article is the full version of the paper submitted by the authors to the IACR and to Springer-Verlag in September 2014, to appear in the proceedings of ASIACRYPT 2014.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Algorithm</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"># rounds</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Reference</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Type of error</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Gravity of error</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Where discovered</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">CLEFIA-128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[40]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">data complexity higher</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">attack does not work</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[32]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(without whit. layers)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">than codebook</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">CLEFIA-128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[33]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">cannot be verified</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[10]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">without implementation</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Camellia</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[38]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">big flaw in computation</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">attack does not work</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">this paper</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(without F L/F L&minus;1<br>layers)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">as in [37]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Camellia-128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[37]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">big flaw in computation</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">attack does not work</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[26]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Camellia-128/192/256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11/13/14</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[24]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">small complexity flaws</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">corrected attacks work</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[38]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(without F L/F L&minus;1<br>layers)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">LBlock</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">22</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[27]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">small complexity flaw</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">corrected attack works</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[28]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Simon<br>(all versions)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14/15/15/16/16/</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[4]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">data complexity higher</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">attacks do not work</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Table 1 of [4]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19/19/22/22/22</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">than codebook</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Simon<br>(all versions)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13/15/17/20/25/</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[1, 2]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">big flaw in computation</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">attacks do not work</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Appendix A.2</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 1. Summary of flaws in previous impossible differential attacks on CLEFIA-128, Camellia, LBlock and Simon.</p>

    <p class="text-gray-300">Instances of such flaws can for example be found in analyses of the cipher CLEFIA. CLEFIA is a lightweight 128-bit block cipher developed by SONY in 2007 [29] and adopted as an international ISO/IEC 29192 standard in lightweight cryptography. This cipher has attracted the attention of many researchers and numerous attacks have been published so far on reduced round versions [34, 35, 33, 25, 31, 11]. Most of these attacks rely on impossible differential cryptanalysis. However, as pointed out by the designers of CLEFIA [30], some of these attacks seem to have flaws, especially in the key filtering phase. We can cite here a recent paper by Blondeau [10] that challenges the validity of the results in [33], or a claimed attack on 14 rounds of CLEFIA-128 [40], for which the designers of CLEFIA showed that the necessary data exceeds the whole codebook [32]. Another extensively analyzed cipher is the ISO/IEC 18033 standard Camellia, designed by Mitsubishi and NTT [5]. Among the numerous attacks presented against this cipher, some of the more successful ones rely on impossible differential cryptanalysis [38, 37, 23, 26, 24]. In the same way as for CLEFIA, some of these attacks were detected to have flaws. For instance, the attack from [37] was shown in [26] to be invalid. We discovered a similar error in the computation that invalidated the attack of [38]. Also, [38] reveals small flaws in [24]. Errors in impossible differential attacks were also detected for other ciphers. For example, in a cryptanalysis against the lightweight block cipher LBlock [27], the time complexity revealed to be incorrectly computed [28]. Another problem can be found in [4], where the data complexity is higher than the amount of data available in the block cipher Simon, or in [1, 2], where some parameters are not correctly computed. During our analysis, we equally discovered problems in some attacks that do not seem to have been pointed out before. In addition to all this, the more the procedure becomes complicated, the more the approach lacks optimality. To illustrate this lack of optimality presented in many attacks we can mention a cryptanalysis against 22-round LBlock [19], that could easily be extended to 23 rounds if a more optimal approach had been used to evaluate the data and time complexities, as well as an analysis of Camellia [23] which we improve in Section 4.</p>

    <p class="text-gray-300">The above examples clearly show that impossible differential attacks suffer from the lack of a unified and optimized approach. For this reason, the first aim of our paper is to provide a general framework for dealing with impossible differential attacks. In this direction, we provide new generic formulas for computing the data, time and memory complexities. These formulas take into account the different parameters that intervene into the attacks and provide a highly optimized way for mounting them. Furthermore, we present some new techniques that can be applied in order to reduce the data needed or to reduce the number of key bits that need to be guessed. In particular we present a new method that helps reducing the number of key bits to be guessed by testing instead some bits of the internal state during the sieving phase. This technique has some similarities with the methods introduced in [15, 17], however important differences exist as both techniques are applied in a completely different context. In addition to this, we apply and develop the idea of multiple impossible differentials, introduced in [35], to obtain more data for mounting our attacks. To illustrate the strength of our new approach we consider Feistel constructions and we apply the above ideas to a number of lightweight block ciphers, namely CLEFIA, Camellia, LBlock and Simon.</p>

    <p class="text-gray-300">More precisely, we present an attack as well as different time/data trade-offs on 13-round CLEFIA-128 that improve the time and data complexity of the previous best known attack [26] and improvements in the complexity of the best known attacks against all versions of Camellia [23]. In addition, in order to demonstrate the generality of our method, we provide the results of our attacks against 23-round LBlock and all versions of the Simon block cipher. The attack on LBlock is the best attack so far in the single-key setting <sup>3</sup>, while our attacks on Simon are the best known impossible differential attacks for this family of ciphers and the best attacks in general for the three smaller versions of Simon.</p>

    <p class="text-gray-300">Summary of our attacks. We present here a summary of our results on the block ciphers CLEFIA-128, Camellia, LBlock and Simon and compare them to the best impossible differential attacks known for the four analyzed algorithms. This summary is given in Table 2, where we point out with a '*' if the mentioned attack is the best cryptanalysis result on the target cipher or not, i.e. by the best known attack we consider any attack reaching the highest number of rounds, and with the best complexities among them.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Algorithm</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"># Rounds</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">\\ /</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Memory (Blocks)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Reference</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">CLEFIA-128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{121.2}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{117.8}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">286.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[25]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">using state-test technique</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{116.90}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{116.33}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{83.33}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Section 3</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">using multiple impossible differentials</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{122.26}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{111.02}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{82.60}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Section 3*</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">combining with state-test technique</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{116.16}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{114.58}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{83.16}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Section 3*</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Camellia-128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{122}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{122}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{98}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[23]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{118.43}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{118.4}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{92.4}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Section 4*</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Camellia-192</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{187.2}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{123}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{155.41}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[23]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{161.06}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{119.7}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{150.7}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Section 4*</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Camellia-256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{251.1}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{123}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{203}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[23]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{225.06}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{198.71}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Section 4*</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Camellia-256 <sup>&dagger;</sup></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{250.5}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{120}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{120}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[23]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 <sup>220</sup></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{118}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{173}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Section 4</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">LBlock</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">22</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{79.28}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{58}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 <sup>72.67</sup></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[19]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">22</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{71.53}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{60}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{59}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Appendix B,[13]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{75.36}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{59}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{74}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Appendix B,[13]*</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Simon32/64</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{62.56}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{32}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{44}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Appendix A*</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SIMON48/72</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{70.69}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{48}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{58}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Appendix A*</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SIMON48/96</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{94.73}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{48}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{70}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Appendix A*</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Simon64/96</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{94.56}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{64}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{60}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Appendix A</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Simon64/128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">22</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{126.56}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{64}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{75}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Appendix A</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Simon96/96</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{94.62}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{94}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{61}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Appendix A</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Simon96/144</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">25</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{190.56}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{128}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{77}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Appendix A</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SIMON128/128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">27</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{126.6}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{94}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{61}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Appendix A</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SIMON128/192</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">28</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{190.56}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{128}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{77}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Appendix A</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SIMON128/256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">30</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{254.68}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{128}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{111}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Appendix A</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300"><strong>Table 2.</strong> Summary of the best impossible differential attacks on CLEFIA-128, Camellia, LBlock and SIMON and presentation of our results. The presence of a '*' mentions if the current attack is the best known attack against the target cipher. Note here that we provide only the best of our results with respect to the time complexity. Other trade-offs can be found in the following sections. &dagger; see Section 4.1 for details.</p>

    <p class="text-gray-300">The rest of the paper is organized as follows. In Section 2 we present a generic methodology for mounting impossible differential attacks, provide our complexity formulas and show new techniques and improvements for attacking a Feistel-like block cipher using impossible differential cryptanalysis. Section 3 is dedicated to the details of our attacks on CLEFIA and Section 4 presents our applications to all versions of Camellia. Finally, our attacks on the other ciphers can be found in Appendix A and B.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;3</sup>In [14], an independent and simultaneous result on 23-round LBlock with worse time complexity was proposed.</p>

    </section>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 Complexity analysis</h2>

    <p class="text-gray-300">We provide in this section a comprehensive complexity analysis of impossible differential attacks against block ciphers as well as some new ideas that help improving the time and data complexities. We derive in this direction new generic formulas for the complexity evaluation of such attacks. The role of these formulas is twofold; on the one hand we aim at clarifying the attack procedure by rendering it as general as possible and on the other hand help at optimizing the time and data requirements. Establishing generic formulas should help mounting as well as verifying such attacks by avoiding the use of complicated procedures often leading to mistakes.</p>

    <p class="text-gray-300">An impossible differential attack consists mainly of two general steps. The first one deals with the discovery of a maximum-length impossible differential, that is an input difference  <span class="math">\\Delta_X</span>  and an output difference  <span class="math">\\Delta_Y</span>  such that the probability that  <span class="math">\\Delta_X</span>  propagates after a certain number of rounds,  <span class="math">r_{\\Delta}</span> , to  <span class="math">\\Delta_Y</span>  is zero. The second step, called the key sieving phase, consists in the addition of some rounds to potentially both directions. These extra added rounds serve to verify which key candidates partially encrypt (resp. decrypt) data to the impossible differential. As this impossible differential is of probability zero, keys showing such behavior are clearly not the right encryption key and are thus removed from the candidate keys space.</p>

    <p class="text-gray-300">We start by introducing the notation that will be used in the rest of the paper. As in this work we are principally interested in the key sieving phase, we start our attack after a maximum impossible differential has been found for the target cipher.</p>

    <p class="text-gray-300">The differential  <span class="math">(\\Delta_X \\to \\Delta_{in})</span>  (resp.  <span class="math">(\\Delta_Y \\to \\Delta_{out})</span> ) occurs with probability 1 while the differential  <span class="math">(\\Delta_X \\leftarrow \\Delta_{in})</span>  (resp.  <span class="math">(\\Delta_Y \\leftarrow \\Delta_{out})</span> ) is verified with probability  <span class="math">\\frac{1}{2^{c_{in}}}</span>  (resp.  <span class="math">\\frac{1}{2^{c_{out}}}</span> ), where  <span class="math">c_{in}</span>  (resp.  <span class="math">c_{out}</span> ) is the number of bit-conditions that have to be verified to obtain  <span class="math">\\Delta_X</span>  from  <span class="math">\\Delta_{in}</span>  (resp.  <span class="math">\\Delta_Y</span>  from  <span class="math">\\Delta_{out}</span> ).</p>

    <p class="text-gray-300">It is important to correctly determine the number of key bits intervening during an attack. We call this quantity information key bits. In an impossible differential attack, one starts by determining all the subkey bits that are involved in the attack. We denote by  <span class="math">k_{in}</span>  the subset of subkey bits involved in the attack during the first  <span class="math">r_{in}</span>  rounds, and  <span class="math">k_{out}</span>  during the last  <span class="math">r_{out}</span>  ones. However, some of these subkey bits can be related between them. For example, two different subkey bits can actually be the same bit of the master key. Alternatively, a bit in the set can be some combination, or can be easily determined by some other bits of the set. The way that the different key bits in the target set are related is determined by the key schedule. The actual parameter that we need to determine for computing the complexity of the attacks is the information key bits intervening in total, that is from an information theoretical point of view, the log of the entropy of the involved key bits, that we denote by  <span class="math">|k_{in} \\cup k_{out}|</span> .</p>

    <p class="text-gray-300">    <img src="_page_3_Figure_6.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">-\\Delta_X, \\Delta_Y</span> : input (resp. output) differences of the impossible differential.</li>
      <li><span class="math">-r_{\\Delta}</span> : number of rounds of the impossible differential</li>
      <li><span class="math">-\\Delta_{in}, \\Delta_{out}</span> : set of all possible input (resp. output) differences of the cipher.</li>
      <li><span class="math">-r_{in}</span> : number of rounds of the differential path <span class="math">(\\Delta_X, \\Delta_{in})</span> .</li>
      <li><span class="math">r_{out}</span> : number of rounds of the differential path <span class="math">(\\Delta_Y, \\Delta_{out})</span> .</li>
    </ul>

    <p class="text-gray-300">We continue now by describing our attack scenario on  <span class="math">(r_{in} + r_{\\Delta} + r_{out})</span>  rounds of a given cipher.</p>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8">2.1 Attack scenario</h3>

    <p class="text-gray-300">Suppose that we are dealing with a block cipher of block size n parametrized by a key K of size |K|. Let the impossible differential be placed between the rounds  <span class="math">(r_{in} + 1)</span>  and  <span class="math">(r_{in} + r_{\\Delta})</span> . As already said, the impossible differential implies that it is not feasible that an input difference  <span class="math">\\Delta_X</span>  at round  <span class="math">(r_{in} + 1)</span></p>

    <p class="text-gray-300">propagates to an output difference  <span class="math">\\Delta_Y</span>  at the end of round  <span class="math">(r_{in} + r_{\\Delta})</span> . Thus, the goal is, for each given pair of inputs (and their corresponding outputs), to discard the keys that generate a difference  <span class="math">\\Delta_X</span>  at the beginning of round  <span class="math">(r_{in} + 1)</span>  and at the same time, a difference  <span class="math">\\Delta_Y</span>  at the output of round  <span class="math">(r_{in} + r_{\\Delta})</span> . We need then enough pairs so that the number of non-discarded keys is significantly lower than the a priori total number of key candidates.</p>

    <p class="text-gray-300">Suppose that the first  <span class="math">r_{in}</span>  rounds have an input truncated difference in  <span class="math">\\Delta_{in}</span>  and an output difference  <span class="math">\\Delta_X</span> , which is the input of the impossible differential. Suppose that there are  <span class="math">c_{in}</span>  bit-conditions that need to be verified so that  <span class="math">\\Delta_{in}</span>  propagates to  <span class="math">\\Delta_X</span>  and  <span class="math">|k_{in}|</span>  information key bits involved.</p>

    <p class="text-gray-300">In a similar way, suppose that the last  <span class="math">r_{out}</span>  rounds have a truncated output difference in  <span class="math">\\Delta_{out}</span>  and an input difference  <span class="math">\\Delta_Y</span> , which is the output of the impossible differential. Suppose that there are  <span class="math">c_{out}</span>  bit-conditions that need to be verified so that  <span class="math">\\Delta_{out}</span>  propagates to  <span class="math">\\Delta_Y</span>  in the backward direction and  <span class="math">|k_{out}|</span>  information key bits involved.</p>

    <p class="text-gray-300">We show next how to determine the amount of data needed for an attack.</p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8">2.2 Data complexity</h3>

    <p class="text-gray-300">The probability that for a given key, a pair of inputs already satisfying the differences  <span class="math">\\Delta_{in}</span>  and  <span class="math">\\Delta_{out}</span>  verifies all the  <span class="math">(c_{in} + c_{out})</span>  bit-conditions is  <span class="math">2^{-(c_{in} + c_{out})}</span> . In other words, this is the probability that for a pair of inputs having a difference in  <span class="math">\\Delta_{in}</span>  and an output difference in  <span class="math">\\Delta_{out}</span> , a key from the possible key set is discarded. Therefore, by repeating the procedure with N different input (or output) pairs, the probability that a trial key is kept in the candidate keys set is  <span class="math">P = (1 - 2^{-(c_{in} + c_{out})})^N</span> .</p>

    <p class="text-gray-300">There is not a unique strategy for choosing the amount of input (or output) pairs N. This choice principally depends on the overall time complexity, which is influenced by N, and the induced data complexity. Different trade-offs are therefore possible. A popular strategy, generally used by default is to choose N such that only the right key is left after the sieving procedure. This amounts to choose P as</p>

    <p class="text-gray-300"><span class="math">$P = (1 - 2^{-(c_{in} + c_{out})})^N &lt; \\frac{1}{2^{|k_{in} \\cup k_{out}|}}.</span>$</p>

    <p class="text-gray-300">In this paper we adopt a different approach that can help reducing the number of pairs needed for the attack and offers better trade-offs between the data and time complexity. More precisely, we permit smaller values of N. By proceeding like this, we will be probably left with more than one key in our candidate keys set and we will need to proceed to an exhaustive search among the remaining candidates, but the total time complexity of the attack will probably be much lower. In practice, we will start considering values of N such that P is slightly smaller than  <span class="math">\\frac{1}{2}</span>  so to reduce the exhaustive search by at least one bit. The smallest value of N, denoted by  <span class="math">N_{\\min}</span> , verifying</p>

    <p class="text-gray-300"><span class="math">$P = (1 - 2^{-(c_{in} + c_{out})})^{N_{\\min}} \\simeq e^{-N_{\\min} \\times 2^{-(c_{in} + c_{out})}} &lt; \\frac{1}{2}</span>$</p>

    <p class="text-gray-300">is approximately  <span class="math">N_{\\min} = 2^{c_{in} + c_{out}}</span> . Then we have to choose  <span class="math">N \\geq N_{\\min}</span> .</p>

    <p class="text-gray-300">We provide now a solution for determining the cost of obtaining N pairs such that their input difference belongs to  <span class="math">\\Delta_{in}</span>  and their output difference belongs to  <span class="math">\\Delta_{out}</span> . To the best of our knowledge, this is the first generic solution to this problem.</p>

    <p class="text-gray-300">Finding N pairs verifying a given truncated differential. Gilbert and Peyrin gave in [16] a solution to the so-called limited birthday problem that searches for a pair of inputs whose difference lies in an input space  <span class="math">\\Delta_{in}</span>  and whose output (ciphertext) difference lies in an output space  <span class="math">\\Delta_{out}</span>  (see Figure 1). According to this solution, prooved in [18], the cost for finding one such pair is given by</p>

    <p class="text-gray-300"><span class="math">$C_1 = \\max \\left\\{ \\min_{\\Delta \\in \\{\\Delta_{in}, \\Delta_{out}\\}} \\left\\{ \\sqrt{2^{n+1-|\\Delta|}} \\right\\}, 2^{n+1-(|\\Delta_{in}|+|\\Delta_{out}|)} \\right\\}.</span>$</p>

    <p class="text-gray-300">    <img src="_page_5_Picture_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 1. A pair of inputs to the encryption function can differ in the subspace  <span class="math">\\Delta_{in}</span>  and the difference of the ciphertext values can lie in the subspace  <span class="math">\\Delta_{out}</span> .</p>

    <p class="text-gray-300">In our attack we search for a solution to a generalization of this problem, i.e. we want to determine the cost of finding not just one but N pairs lying in the given input and output spaces  <span class="math">\\Delta_{in}</span>  and  <span class="math">\\Delta_{out}</span> . A direct way to treat this problem would be to estimate this cost by  <span class="math">N \\times C_1</span> . However, this solution is not always optimal. In particular, as we will explain in a while, when the input space  <span class="math">\\Delta_{in}</span>  is relatively large, the number of inputs that we will need, which determines the data complexity of the attack and at the same time the cost for constructing N pairs, can be lower than  <span class="math">N \\times C_1</span> . We denote, the number of necessary inputs as  <span class="math">C_N</span> , as this quantity corresponds equally to the cost of constructing N pairs.</p>

    <p class="text-gray-300">We can distinguish between two cases, depending on the dimension of the input space,  <span class="math">|\\Delta_{in}|</span> , the dimension of the output space,  <span class="math">|\\Delta_{out}|</span>  and the value of N. More precisely, the cost for constructing N pairs will depend on the value of</p>

    <p class="text-gray-300"><span class="math">$\\frac{2^{|\\Delta_{in}|}2^{|\\Delta_{in}|-1}}{2^{n-|\\Delta_{out}|}}</span>$</p>

    <p class="text-gray-300">compared to N. The quantity  <span class="math">2^{|\\Delta_{in}|}2^{|\\Delta_{in}|-1}</span>  corresponds to the number of pairs that can be constructed if the values in  <span class="math">\\Delta_{in}</span>  can take all possible values. On the other hand, the quantity  <span class="math">n - |\\Delta_{out}|</span>  stands for the size of the partial collision, as we permit the output of these pairs to vary only in the subspace  <span class="math">\\Delta_{out}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">If  <span class="math">N \\leq \\frac{2^{|\\Delta_{in}|}2^{|\\Delta_{in}|-1}}{2^{n-|\\Delta_{out}|}}</span> , this means that  <span class="math">|\\Delta_{in}|</span>  is large enough to allow us to build  <span class="math">C_N</span>  inputs belonging to the same structure  <span class="math">(C_N \\leq 2^{|\\Delta_{in}|})</span> . For the sake of clarity, we define a structure, as the set of inputs that can take all possible values in the subspace  <span class="math">\\Delta_{in}</span>  and whose remaining  <span class="math">n-|\\Delta_{in}|</span>  bits are fixed to a constant value. Therefore  <span class="math">N = \\frac{C_N \\cdot C_N/2}{2^{n-|\\Delta_{out}|}}</span> , which means that we need  <span class="math">C_N = \\sqrt{N2^{n-|\\Delta_{out}|+1}}</span>  inputs.</p>

    <p class="text-gray-300">Otherwise, if  <span class="math">N &gt; \\frac{2^{|\\Delta_{in}|}2^{|\\Delta_{in}|-1}}{2^{n-|\\Delta_{out}|}}</span>  which means that  <span class="math">|\\Delta_{in}|</span>  is not large enough, we will need to consider</p></li>
      <li><p class="text-gray-300">Otherwise, if  <span class="math">N &gt; \\frac{2^{|\\Delta_{in}|}2^{|\\Delta_{in}|-1}}{2^{n-|\\Delta_{out}|}}</span>  which means that  <span class="math">|\\Delta_{in}|</span>  is not large enough, we will need to consider several structures of size  <span class="math">2^{|\\Delta_{in}|}</span> . Let  <span class="math">2^y</span>  be the number of these extra structures chosen in a way that  <span class="math">N = 2^y \\frac{2^{|\\Delta_{in}|}2^{|\\Delta_{in}|-1}}{2^{n-|\\Delta_{out}|}}</span> . The number of inputs is in this case given by:</p></li>
    </ul>

    <p class="text-gray-300"><span class="math">$C_N = 2^y 2^{|\\Delta_{in}|} = N 2^{n-|\\Delta_{out}|-|\\Delta_{in}|+1}.</span>$</p>

    <p class="text-gray-300">By taking all of this into account together with the fact that we are dealing with a permutation (having thus a symmetry in both directions) and by considering the attacker to be able to choose the ciphertexts as well as the plaintexts, we can conclude that the cost of obtaining the N pairs will be:</p>

    <p class="text-gray-300"><span class="math">$C_N = \\max \\left\\{ \\min_{\\Delta \\in \\{\\Delta_{in}, \\Delta_{out}\\}} \\left\\{ \\sqrt{N2^{n+1-|\\Delta|}} \\right\\}, N2^{n+1-|\\Delta_{in}|-|\\Delta_{out}|} \\right\\}.</span>$
(1)</p>

    <p class="text-gray-300">We can observe thus that we gain a factor of  <span class="math">\\sqrt{N}</span>  in the first of the two above cases compared to the trivial solution of taking  <span class="math">C_N = N \\times C_1</span> . As we've already mentioned the cost  <span class="math">C_N</span>  represents the amount of data needed for the attack. Obviously, as the size of the state is equal to n, the following inequality, should hold:</p>

    <p class="text-gray-300"><span class="math">$C_N &lt; 2^n</span>$
.</p>

    <p class="text-gray-300">This inequality simply states that the total amount of data used for the attack cannot exceed the codebook. These conditions are not verified in several cases from [4], as well as in the corrected version of [40] which invalidates the corresponding attacks.</p>

      <h3 id="sec-2.3" class="text-xl font-semibold mt-8">2.3 Time and memory complexity</h3>

    <p class="text-gray-300">We are going to detail now the computation of the time complexity of the attack. Note that the formulas that we are presenting in this section are the first generic formulas given for estimating the complexity of impossible differential attacks.</p>

    <p class="text-gray-300">By following the early abort technique [24], the attack consists in storing the N pairs and testing out step by step the key candidates, by reducing at each time the size of the remaining possible pairs. The time complexity is then determined by three quantities. The first term is the cost  <span class="math">C_N</span> , that is the amount of needed data (see Formula (1)) for obtaining the N pairs, where N is such that P &lt; 1/2. The second term corresponds to the number of candidate keys  <span class="math">2^{|k_{in} \\cup k_{out}|}</span> , multiplied by the average cost of testing the remaining pairs. For all the applications that we have studied, this cost can be very closely approximated by  <span class="math">\\left(N + 2^{|k_{in} \\cup k_{out}|} \\frac{N}{2^{c_{in} + c_{out}}}\\right) C&#x27;_E</span> , where  <span class="math">C&#x27;_E</span>  is the ratio of the cost of partial encryption to the full encryption. Finally, the third term is the cost of the exhaustive search for the key candidates still in the candidate keys set after the sieving. By taking into account the cost of one encryption  <span class="math">C_E</span> , we conclude that the time complexity of the attack is</p>

    <p class="text-gray-300"><span class="math">$T_{comp} = \\left( C_N + \\left( N + 2^{|k_{in} \\cup k_{out}|} \\frac{N}{2^{c_{in} + c_{out}}} \\right) C_E&#x27; + 2^{|K|} P \\right) C_E, \\tag{2}</span>$</p>

    <p class="text-gray-300">where  <span class="math">C_N = \\max \\left\\{ \\min_{\\Delta \\in \\{\\Delta_{in}, \\Delta_{out}\\}} \\left\\{ \\sqrt{N2^{n+1-|\\Delta|}} \\right\\}, N2^{n+1-|\\Delta_{in}|-|\\Delta_{out}|} \\right\\}</span> , with N such that  <span class="math">P = (1 - 1/(2^{c_{in}+c_{out}}))^N &lt; 1/2</span>  and where the last term corresponds to  <span class="math">2^{|K|-|k_{in}\\cup k_{out}|}P2^{|k_{in}\\cup k_{out}|}</span> . Obviously, as we want the attack complexity to be smaller than the exhaustive search complexity, the above quantity should be smaller than  <span class="math">2^{|K|}C_E</span> .</p>

    <p class="text-gray-300">It must be noted here that this is a minimum estimation of the complexity, that, in practice, and thanks to the idea of Section 2.4, it approximates really well the actual time complexity, as it can be seen in the applications, and in particular, in the tight correspondance shown between the LBlock estimation that we detail in Appendix B and the exact calculation from [13]. The precise evaluation of  <span class="math">C&#x27;_E</span>  (that is always smaller than 1) can only be done once the attack parameters are known. However,  <span class="math">C&#x27;_E</span>  can be estimated quite easily by calculating the ratio between the active SBoxes during a partial encryption and the total number of SBoxes (thought it is not always the best approximation, it is a common practice).</p>

    <p class="text-gray-300">Memory complexity. By using the early abort technique [24], the only elements that need to be stored are the N pairs. Therefore, the memory complexity  <span class="math">^4</span>  of the attack is determined by N.</p>

      <h3 id="sec-2.4" class="text-xl font-semibold mt-8">2.4 Choosing <span class="math">\\Delta_{in}, \\Delta_{out}, c_{in}</span> and <span class="math">c_{out}</span> .</h3>

    <p class="text-gray-300">We explain now, the two possible ways for choosing  <span class="math">\\Delta_{in}</span> ,  <span class="math">\\Delta_{out}</span> ,  <span class="math">c_{in}</span>  and  <span class="math">c_{out}</span> . For this, we introduce the following example that can be visualized in Figure 2 and where we consider an Sbox-based cipher. In this example, we will only talk about  <span class="math">\\Delta_{in}</span>  and  <span class="math">c_{in}</span> , however the approach for  <span class="math">\\Delta_{out}</span>  and  <span class="math">c_{out}</span>  is identical.</p>

    <p class="text-gray-300">Suppose that the state is composed of two branches of four nibbles each. The round function is composed of a non-linear layer S, seen as a concatenation of four Sboxes  <span class="math">S_0, S_1, S_2</span>  and  <span class="math">S_3</span> , followed by a linear layer M. There exist two different ways for choosing  <span class="math">|\\Delta_{in}|</span>  and  <span class="math">c_{in}</span> :</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The most intuitive way is to consider  <span class="math">|\\Delta_{in}| = 4 + 4</span>  and  <span class="math">c_{in} = 4</span> , as the size of  <span class="math">\\alpha</span>  and of  <span class="math">\\beta</span>  is 4 bits, and in the first round we want 4 bits to collide. In this case, for a certain key, the average probability that a pair taken out of the  <span class="math">2^{4+4}2^{4+4-1}</span>  pairs belonging to  <span class="math">\\Delta_{in}</span>  leads to  <span class="math">\\Delta_X</span>  is  <span class="math">2^{-4}</span> .</li>
    </ol>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;4 \\&lt;/sup&gt;text{If } N &gt; 2^{|k_{in} \\cup k_{out}|}</span>  we could store the discarded key candidates instead, but in practice this is rarely the case. We can therefore consider a memory complexity of min <span class="math">\\{N, 2^{|k_{in} \\cup k_{out}|}\\}</span> .</p>

    <p class="text-gray-300">    <img src="_page_7_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300"><strong>Fig. 2.</strong> Choosing  <span class="math">\\Delta_{in}</span>  and  <span class="math">c_{in}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>In general, the difference  <span class="math">\\alpha</span>  can take  <span class="math">2^4-1</span>  different values. However, each value can be associated by the differential distribution table of the Sbox  <span class="math">S_0</span>  to  <span class="math">2^3</span>  output differences on average<sup>5</sup>, so the possibilities for the difference  <span class="math">\\beta</span>  are limited to  <span class="math">2^3</span> . Therefore, we can consider that  <span class="math">|\\Delta_{in}| \\approx 4+3</span> . But, in this case  <span class="math">c_{in}=3</span> , as for each input pair belonging to the  <span class="math">2^{4+3}2^{4+3-1}</span>  possible ones, there exist on average 2 values that make the differential transition  <span class="math">\\alpha \\to \\beta</span>  possible (instead of 1 in the previous case).</li>
    </ol>

    <p class="text-gray-300">We can see, by using the generic formulas provided in Section 2.3, that both cases induce practically the same time complexity, as the difference in N compensates with the difference in  <span class="math">c_{in} + c_{out}</span> . However, the memory complexity, given by N, is slightly better in case 2. Furthermore, case 2, in which a preliminary filtering of the pairs is done, allows to reduce the average cost of using the early abort technique [24].</p>

    <p class="text-gray-300">In several papers, for example in [37] and [24], the second case is followed. However, its application is partial (either for the input or the output part) and this with no apparent reason. Note however, that in these papers, the associated  <span class="math">c_{out}</span>  was not always correctly computed and sometimes, 8-bit conditions were considered when 7-bit conditions should have been accounted for. For reasons of simplicity, we will consider case 1 in our applications and check afterwards the actual memory needed.</p>

      <h3 id="sec-2.5" class="text-xl font-semibold mt-8">2.5 Using multiple impossible differentials to reduce the data complexity</h3>

    <p class="text-gray-300">We explain in this section a method to reduce the data complexity of an attack. This method is inspired by the notion of multiple impossible differentials that was introduced by Tsunoo et al. [35] and applied to 12-round CLEFIA-128. The idea in this technique is to consider simultaneously several impossible differentials, instead of taking just one. We assume, as done in [16], that the differences in  <span class="math">\\Delta_{in}</span>  (and in  <span class="math">\\Delta_{out}</span> ) lie in a closed set. We can mention two ways in which this can be a priori done:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Take rotated versions of a certain impossible differential. We call  <span class="math">n_{in}</span>  the number of different input pattern differences generated by the rotated versions of the chosen impossible differential.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>When the middle conditions have several impossible combinations, we can consider the same first half of the differential path together with a rotated version of the second one, in a way to get a different impossible differential. We call  <span class="math">n_{out}</span>  the number of different output pattern differences generated by the rotated versions of the second part of the path that we will consider. For the sake of simplicity and without loss of generality we will only consider the case of rotating the second half of the path.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">It is important to point out that for our analysis to be valid, in both cases the number of conditions associated to the impossible differential attack should stay the same. Both cases can be translated into a higher amount of available data by redefining two quantities,  <span class="math">|\\Delta&#x27;_{in}|</span>  and  <span class="math">|\\Delta&#x27;_{out}|</span> , that will take the previous roles of  <span class="math">|\\Delta_{in}|</span>  and  <span class="math">|\\Delta_{out}|</span> ,</p>

    <p class="text-gray-300"><span class="math">$|\\Delta&#x27;_{in}| = |\\Delta_{in}| + \\log_2(n_{in}) \\text{ and } |\\Delta&#x27;_{out}| = |\\Delta_{out}| + \\log_2(n_{out}).</span>$</p>

    <p class="text-gray-300"><span class="math">|\\Delta&#x27;_{in}|</span>  is the log of the total size of the set of possible input differences, and  <span class="math">|\\Delta&#x27;_{out}|</span>  is the log of the total size of the set of possible output differences.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;5</sup>This quantity depends on the Sbox. In this example, we consider that all four Sboxes have good cryptographic properties.</p>

    <p class="text-gray-300">In this case, the data complexity  <span class="math">C_N</span>  is computed with the corrected values for the input sizes and is, as can be easily seen, smaller than if only one path had been used. The time complexity remains the same, except for the  <span class="math">C_N</span>  term. Indeed, the middle term of Formula (2) remains the same, as for a given pair, the number of key bits involved stays  <span class="math">2^{|k_{in} \\cup k_{out}|}</span> . Equally, as the number of partial possible keys involved in the attack is  <span class="math">n_{in}n_{out}2^{|k_{in} \\cup k_{out}|}</span> , the last term of Formula (2) is now</p>

    <p class="text-gray-300"><span class="math">$\\frac{2^{|K|}}{n_{in} \\cdot n_{out} 2^{|k_{in} \\cup k_{out}|}} (P \\cdot n_{in} \\cdot n_{out} \\cdot 2^{|k_{in} \\cup k_{out}|}) = 2^{|K|} P</span>$</p>

    <p class="text-gray-300">and so also stays the same.</p>

    <p class="text-gray-300">In Section 3 we present our attacks on CLEFIA. In part of these attacks, we use multiple impossible differentials to reduce the data complexity. Besides, this technique shows particularly useful for mounting attacks on some versions of the Simon family for which there is not enough available data to mount a valid attack with the traditional method.</p>

      <h3 id="sec-2.6" class="text-xl font-semibold mt-8">2.6 Introducing the state-test technique</h3>

    <p class="text-gray-300">We introduce now a new method that consists in making a test for some part of the internal state instead of guessing the necessary key bits for computing it. This somewhat reminds the techniques presented in [15, 17] in the context of meet-in-the-middle attacks. However, the technique that we present in this section, and that we call the <em>state-test</em> technique is different since it consists in checking the values of the internal state to verify if we can discard all the involved candidates.</p>

    <p class="text-gray-300">Very often during the key filtering phase of impossible differential attacks, the size of the internal state that needs to be known is smaller than the number of key bits on which it depends. As we will see, focusing on the values that a part of the state can take permits to eliminate some key candidates without considering all the values for the involved key bits. The state-test technique works by fixing s bits of the plaintexts, something which allows us to reduce the number of information key bits by s. We will explain how this method works by a small example.</p>

    <p class="text-gray-300">Consider a 32-bit Feistel construction, where each branch can be seen as a concatenation of four nibbles (see Figure 3). Suppose that the round function is composed of a non-linear layer S, seen as a concatenation of four 4-bit invertible Sboxes  <span class="math">(S_0, S_1, S_2, S_3)</span>  and of a linear layer M on  <span class="math">\\mathbb{F}_{2^4}</span> . We suppose for this example that the branch number of M, that is the minimal number of active Sboxes in any two consecutive rounds, is less than 5. Let  <span class="math">\\Delta_X = (\\alpha, 0, 0, 0)|(0, 0, 0, 0)</span>  be the input difference of the impossible differential, placed at the end of the second round and let  <span class="math">\\Delta_{in} = (*, *, *, 0)|(*, *, *, *)</span>  be the difference at the input of the block cipher. Note however that in reality, the leftmost side of  <span class="math">\\Delta_{in}</span>  only depends on a 4-bit non-zero difference  <span class="math">\\delta</span> , i.e.  <span class="math">\\Delta_{in} = M(\\delta, 0, 0, 0)|(*, *, *, *)</span> .</p>

    <p class="text-gray-300">As can be seen in Figure 3, there are in total 4 active Sboxes and thus there are  <span class="math">c_{in} = 16</span>  conditions that have to be verified in order to have a transition from  <span class="math">\\Delta_{in}</span>  to  <span class="math">\\Delta_X</span> . Therefore, the first step is to collect N pairs such that  <span class="math">P = (1 - 2^{-(c_{in} + c_{out})})^N = (1 - 2^{-c_{in}})^N = (1 - 2^{-16})^N &lt; \\frac{1}{2}</span> . The exact value of N will be chosen in a way to obtain the best trade-off for the complexities. Before describing the new method, we start by explaining how this attack would have worked in the classical way. As we can see in Figure 3, there are  <span class="math">3 \\times 4</span>  bits that have to be guessed  <span class="math">(K_{0,0}, K_{0,1} \\text{ and } K_{0,2})</span>  in order to verify the conditions on the first round and there are  <span class="math">2 \\times 4</span>  bits that have to be guessed  <span class="math">(K_{0,3} \\text{ and } K_{1,0})</span>  in order to verify the conditions on the second round. Therefore, for all N pairs, one starts by testing all the  <span class="math">2^4</span>  possible values for the first nibble of  <span class="math">K_0</span> . After this first guess,  <span class="math">N \\times 2^{-4}</span>  pairs remain in average, as there are 4-bit conditions that need to be verified by the guess through the first round. Then one continues by testing the second and the third nibble of  <span class="math">K_0</span>  and finally the last nibble of  <span class="math">K_0</span>  and the first nibble of  <span class="math">K_1</span> . At each step, the amount of data remaining is divided by  <span class="math">2^4</span> . To summarize, we have  <span class="math">|k_{in} \\cup k_{out}| = |k_{in}| = 20</span>  and  <span class="math">2^{c_{in} + c_{out}} = 2^{d_2} 2^4 2^4 2^4</span> . Then Formula (2) can be used to evaluate the time complexity of the attack as</p>

    <p class="text-gray-300"><span class="math">$\\left(C_N + \\left(N + 2^{20} \\frac{N}{2^{16}}\\right) C_E&#x27; + 2^{20} P 2^{|K| - 20}\\right) C_E.</span>$
(3)</p>

    <p class="text-gray-300">    <img src="_page_9_Picture_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300"><strong>Fig. 3.</strong> Grey color stands for nibbles with non-zero difference. Hatched key nibbles correspond to the part of the subkeys that have to be guessed. The nibble x is the part of the state on which we apply the state-test technique.</p>

    <p class="text-gray-300">We will see now how the state-test technique applies to this example and how it permits to decrease the time complexity. Consider the first nibble of the left part of the state after the addition of the subkey  <span class="math">K_1</span> . We denote this nibble by x. Note that mathematically, x can be expressed as</p>

    <p class="text-gray-300"><span class="math">$x = K_{1,0} \\oplus P_{1,0} \\oplus M(S(K_0 \\oplus P_0))_0</span>$</p>

    <p class="text-gray-300"><span class="math">$x \\oplus P_{1,0} = K_{1,0} \\oplus m_0 S_0(K_{0,0} \\oplus P_{0,0}) \\oplus m_1 S_1(K_{0,1} \\oplus P_{0,1}) \\oplus m_2 S_2(K_{0,2} \\oplus P_{0,2}) \\oplus m_3 S_3(K_{0,3} \\oplus P_{0,3}),</span>$
(4)</p>

    <p class="text-gray-300">where the  <span class="math">m_i</span> 's are coefficients in  <span class="math">\\mathbb{F}_2^4</span> .</p>

    <p class="text-gray-300">Suppose now that for all pairs, we fix the last s=4 bits of  <span class="math">P_0</span>  to the same constant value. One can verify that this is a reasonable assumption, as by fixing this part of the inputs we still have enough data to mount the attack. Then one starts as before, by guessing the first three nibbles of  <span class="math">K_0</span> . After this 12-bit guess, approximately  <span class="math">N \\times 2^{-12}</span>  pairs remain. We know for each pair the input and output differences of the Sbox of the second round as the needed part of  <span class="math">K_0</span>  has been guessed. Therefore, by a simple lookup at the differential distribution table of the involved Sbox, we obtain one value for x that verifies the second round conditions in average per pair (about half of the time the transition is not possible, whereas for the other half we find two values). Equation (4) becomes</p>

    <p class="text-gray-300"><span class="math">$x \\oplus P_{1,0} \\oplus m_0 S_0(K_{0,0} \\oplus P_{0,0}) \\oplus m_1 S_1(K_{0,1} \\oplus P_{0,1}) \\oplus m_2 S_2(K_{0,2} \\oplus P_{0,2}) = K_{1,0} \\oplus m_3 S_3(K_{0,3} \\oplus P_{0,3}), (5)</span>$</p>

    <p class="text-gray-300">where the left side of Equation (5), that we denote by x', is known for each pair.</p>

    <p class="text-gray-300">Thus, for each guess of  <span class="math">(K_{0,0}, K_{0,1}, K_{0,2})</span> , we construct a table of size  <span class="math">N \\times 2^{-12}</span> , where we store these values of x'. The last and more important step consists now in looking if all  <span class="math">2^4</span>  possible values of x' appear in the table. Note here, that as  <span class="math">N \\ge 2^{16}</span> , the size of the table is necessarily greater than or equal to  <span class="math">2^4</span> .</p>

    <p class="text-gray-300">Since  <span class="math">P_{0,3}</span>  is fixed, the only unknown values in Equation (5) are  <span class="math">K_{1,0}</span>  and  <span class="math">K_{0,3}</span> . If all values for x' are in the table and since  <span class="math">S_3</span>  is a permutation, for any choice of  <span class="math">K_{1,0}</span>  and any choice of  <span class="math">K_{0,3}</span> , there will always exist (at least) one pair such that  <span class="math">K_{1,0} \\oplus m_3S_3(K_{0,3} \\oplus P_{0,3})</span>  is in the table, leading thus to the impossible differential. As a conclusion, we know that if x' takes all the possible values in the table, we can remove the keys composed by the guessed value  <span class="math">(K_{0,0}, K_{0,1}, K_{0,3})</span>  from the candidate keys set, as for all the values of  <span class="math">(K_{1,0}, K_{0,3})</span> , they would imply the impossible differential. If instead, x' does not take all the possible values for a certain value of  <span class="math">(K_{0,0}, K_{0,1}, K_{0,3})</span> , we can test this partial key combined to all the possibilities of the remaining key bits that verify Equation (5) for the missing x', as they belong to the remaining key candidates.</p>

    <p class="text-gray-300">The main gain of the state-test technique is that it decreases the number of information key bits and therefore the time complexity. For instance, in this example, the variable x' can be seen as 4 information</p>

    <p class="text-gray-300">key bits <sup>6</sup> instead of  <span class="math">2 \\times 4</span>  key bits we had to guess in the classic approach (the bits of  <span class="math">K_{0,3}</span>  and of  <span class="math">K_{1,0}</span> ). We have s=4 less bits to guess thanks to the s=4 bits of the plaintext that we have fixed. Thus the time complexity in this case becomes</p>

    <p class="text-gray-300"><span class="math">$\\left(C_N + \\left(N + 2^{20-4} \\frac{N}{2^{16}}\\right) C_E&#x27; + 2^{20-4} P 2^{|K| - (20-4)}\\right) C_E.</span>$
(6)</p>

    <p class="text-gray-300">One can see now by comparing Equations (6) and (3) that the time complexity is lower with the state-test technique, than with the trivial method. Indeed, the first and the third term of the Equations (6) and (3) remain the same, while the second term is lower in Equation (6). Finally, note that the probability P for a key to be still in the candidate keys set remains the same as before. Indeed, during the attack we detect all and the same candidate keys for which none of the N pairs implies the impossible differential, which are the same candidate keys that we would have detected in a classic attack.</p>

    <p class="text-gray-300">We would like to note here that we have implemented the state-test technique on a toy cipher, having a structure similar to the one that we introduced in this section, and we have verified its correcteness.</p>

    <p class="text-gray-300">Application of the state-test technique in parallel for decreasing the probability P. An issue that could appear with this technique is that as we have to fix a part of the plaintexts, s bits, the amount of data available for computing the N pairs is reduced. The probability P associated to an attack is the probability for a key to remain in the candidate keys set. When the amount of available data is small, the number of pairs N that we can construct is equally small and thus the probability P is high. In such a situation, the dominant term of the time complexity (Formula (2)), is in general the third one, i.e.  <span class="math">2^{|K|}P</span> .</p>

    <p class="text-gray-300">More precisely, we need the sum of  <span class="math">\\log_2(C_N)</span>  and s, the number of plaintext bits that we fix, to be less than or equal to the block size. This limits the size of N that we can consider, leading to higher probabilities P, and could lead, sometimes, to higher time complexities. To avoid this, one can repeat the attack in parallel for several different values, say Y, of the fixed part of the plaintext. In this case, the data and memory needed are multiplied by Y. On the other hand, repeating the attack in parallel permits to detect more efficiently if a guessed key could be the right one. Indeed, for a guessed key, only if none of the tables constructed as described above contains all the values for x', one can test if this guessed key is the correct one.</p>

    <p class="text-gray-300">To summarize, by repeating the state-test technique in parallel, we multiply the available data by Y, as well as the available pairs, and since the attack is done Y times in parallel, the probability P becomes  <span class="math">P^Y</span> . The probability decreases much faster than the data or the other terms of the time complexity increase. Therefore, the Formula (2) becomes in this case:</p>

    <p class="text-gray-300"><span class="math">$\\left(C_N \\times Y + \\left(N \\times Y + 2^{|k_{in} \\cup k_{out}| - s} \\frac{N \\times Y}{2^{c_{in} + c_{out}}}\\right) C_E&#x27; + 2^{|K|} P^Y\\right) C_E.</span>$
(7)</p>

    <p class="text-gray-300">In Section 3, we are going to see an application of this technique to 13-round CLEFIA-128, and at the end of Section 4.1 we show an application on Camellia-256.</p>

    </section>

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3 Application to CLEFIA</h2>

    <p class="text-gray-300">CLEFIA is a lightweight 128-bit block cipher designed by Shirai et al. in 2007 [29] and based on a 4-branch generalized Feistel network. We provide here a short description of the algorithm specifications. See [29] for a more complete description.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;6</sup>Note that we could, equivalently, consider all possible values of x' in the last step, and consider the associated remaining pairs table, that would have a size of  <span class="math">N2^{-16}</span>  (empty if the key is a good candidate, not empty otherwise), obtaining the same key candidates of 16 bits, 12 from  <span class="math">(K_{0,0}, K_{0,1}, K_{0,3})</span>  and 4 information key bits from x', with the same complexity as in the previously described method.</p>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8">3.1 Description of CLEFIA</h3>

    <p class="text-gray-300">Encryption algorithm. Denote by  <span class="math">P = P_0|P_1|P_2|P_3</span>  a 128-bit plaintext, where each  <span class="math">P_i</span> , i = 0, 1, 2, 3, is a 32-bit vector. Denote by C be the corresponding ciphertext. CLEFIA supports keys of size 128, 192 or 256 bits and the total number of iterations, say R, depends on the key size. More precisely, R = 18 for the 128-bit version, while R = 22 and R = 26 for the two following variants. A key-scheduling algorithm, whose description we omit, is used to generate 2R round keys  <span class="math">RK_0, \\ldots, RK_{2R-1}</span>  and 4 whitening keys  <span class="math">WK_0, \\ldots, WK_3</span> . The encryption is performed as follows:</p>

    <p class="text-gray-300">    <img src="_page_11_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300"><span class="math">- C = P_0^R | P_1^R \\oplus W K_2 | P_2^R | P_3^R \\oplus W K_3.</span></p>

    <p class="text-gray-300">Fig. 4. A round of CLEFIA.</p>

    <p class="text-gray-300">Round functions  <span class="math">F_0</span> ,  <span class="math">F_1</span> . Each round of CLEFIA is composed of two 32-bit round functions  <span class="math">F_0</span>  and  <span class="math">F_1</span>  (see Figure 4) that have the same structure. The first step in the function  <span class="math">F_0</span>  (resp.  <span class="math">F_1</span> ) is an XOR between the 32-bit subkey  <span class="math">RK_{2i-2}</span>  (resp.  <span class="math">RK_{2i-1}</span> ) and  <span class="math">P_0^{i-1}</span>  (resp.  <span class="math">P_2^{i-1}</span> ). Then, two 8 &times; 8-bit SBoxes  <span class="math">S_0</span>  and  <span class="math">S_1</span>  compose a layer which is applied to the result. Finally, the four obtained bytes are mixed by a 4 &times; 4-byte matrix,  <span class="math">M_0</span>  (resp.  <span class="math">M_1</span> ) that has a maximal branch number, i.e. 5. A detailed description of the SBoxes  <span class="math">S_0</span> ,  <span class="math">S_1</span>  while also the matrices  <span class="math">M_0</span> ,  <span class="math">M_1</span>  can be found in [29].</p>

    <p class="text-gray-300">We are going to describe now an impossible differential cryptanalysis of 13-round CLEFIA-128.</p>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8">3.2 Impossible Differential Cryptanalysis of 13-round CLEFIA-128</h3>

    <p class="text-gray-300">The authors of [34] noticed that a difference on the internal state of CLEFIA of the form  <span class="math">P^i = 0_{32}|0_{32}|A</span>  cannot lead to a difference  <span class="math">P^{i+9} = 0_{32}|0_{32}|B|0_{32}</span>  after 9 rounds, where A and B are 4-byte vectors for which only one byte in a different position is active (e.g.  <span class="math">A = (\\alpha, 0_8, 0_8, 0_8)</span>  and  <span class="math">B = (0_8, \\beta, 0_8, 0_8)</span> ). We use this same 9-round impossible differential and place it between rounds 3 and 11. Therefore, for our attack,  <span class="math">r_{in} = r_{out} = 2</span>  and  <span class="math">r_{\\Delta} = 9</span> , as in [25].</p>

    <p class="text-gray-300">    <img src="_page_11_Figure_9.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 5. The attack on CLEFIA-128. Grey color stands for bytes with a non-zero difference, while hatched bytes are the subkey bytes that have to be guessed.</p>

    <p class="text-gray-300">The differential placed on the top and at the bottom of the impossible differential are depicted in Figure 5. We describe now the parameters for our cryptanalysis of 13-round CLEFIA-128. As can be seen</p>

    <p class="text-gray-300">in Figure 5 there are  <span class="math">c_{in} + c_{out} = 40 + 40</span>  bit-conditions that need to be verified so that the difference in the plaintexts  <span class="math">\\Delta_{in} = 0_{32}|(*_8, 0_8, 0_8, 0_8)|M_0(*_8, 0_8, 0_8, 0_8)|*_{32}</span>  propagates to  <span class="math">\\Delta_X = 0_{32}|0_{32}|0_{32}|(\\alpha, 0_8, 0_8, 0_8)</span>  and the difference in the ciphertexts  <span class="math">\\Delta_{out} = 0_{32}|(0_8, *_8, 0_8, 0_8)|M_1(0_8, *_8, 0_8, 0_8)|*_{32}</span>  propagates to  <span class="math">\\Delta_Y = 0_{32}|0_{32}|(0_8, \\beta, 0_8, 0_8)|0_{32}</span> . In this way,  <span class="math">|\\Delta_{in}| = |\\Delta_{out}| = 48</span> .</p>

    <p class="text-gray-300">Following the complexity analysis of Section 2, we need to construct at least  <span class="math">N_{\\min} = 2^{80}</span>  pairs whose input difference is in  <span class="math">\\Delta_{in}</span>  and whose output difference is in  <span class="math">\\Delta_{out}</span> . The cost to construct these pairs is</p>

    <p class="text-gray-300"><span class="math">$C_{N_{\\min}} = \\max\\left\\{\\sqrt{2^{80}2^{129-48}}, 2^{80}2^{129-48-48}\\right\\} = 2^{113}.</span>$</p>

    <p class="text-gray-300">Using the state-test technique. We use now the state-test technique, described in Section 2.6 to test the 8 bits of the internal state denoted by x in Figure 5, instead of guessing the whole subkey  <span class="math">RK_0</span>  and the XOR of the leftmost byte of  <span class="math">RK_2</span>  and  <span class="math">WK_0</span> . For doing this, we need to fix part of the 32 leftmost bits of the plaintexts. As the number of needed data is  <span class="math">C_{N_{\\min}} = 2^{113}</span> , we can fix at most 128 - 113 = 15 bits. However, as each Sbox is applied to 8 bits, we will only fix one byte of this part of the plaintexts. We will guess then 24 bits of the subkey  <span class="math">RK_0</span>  which are situated on the other bytes.</p>

    <p class="text-gray-300">During a classical attack procedure, we would need to guess 32 bits of  <span class="math">RK_1</span> , 32 bits of  <span class="math">RK_0</span>  and 8 bits of  <span class="math">RK_2 \\oplus WK_0</span> , thus  <span class="math">k_{in} = 72</span> . We would also need to guess 8 bits of  <span class="math">RK_{23} \\oplus WK_2</span> , 32 bits of  <span class="math">RK_{24}</span>  and 32 bits of  <span class="math">RK_{25}</span> , therefore  <span class="math">k_{out} = 72</span> . However, the subkeys  <span class="math">RK_1</span>  and  <span class="math">RK_{24}</span>  share 22 bits in common. As a consequence, the number of information key bits would be  <span class="math">|k_{in} \\cup k_{out}| = 72 + 72 - 22 = 122</span> . As we will fix 8 bits of the plaintexts, with respect to Section 2 on the state-test technique, it is the same to say that there will be  <span class="math">|k_{in} \\cup k_{out}| - 8 = 122 - 8 = 114</span>  bits to test. The time complexity of our attack, computed using Formula (2) is then</p>

    <p class="text-gray-300"><span class="math">$\\left(C_N + \\left(N + 2^{114} \\frac{N}{2^{80}}\\right) \\frac{18}{104} + 2^{128} P\\right) C_E,</span>$</p>

    <p class="text-gray-300">where the fraction 18/104 is the ratio of the cost of partial encryption to the full encryption, that we noted  <span class="math">C&#x27;_E</span> . Since our attack needs at least  <span class="math">2^{113}</span>  plaintexts and since we fixed 8 bits out of them, we have 128 - 113 - 8 = 7 bits of freedom for building structures. Among all the possible trade-offs with respect to the amount of data, the best time complexity we obtained is  <span class="math">2^{116.90}C_E</span>  with  <span class="math">2^{83.33}</span>  pairs built from  <span class="math">2^{116.33}</span>  plaintexts.</p>

    <p class="text-gray-300">Using multiple impossible differentials. The authors of [34] noticed that there exist several different 9-round impossible differentials, see [34, Table 1]. In [35], the authors used these multiple impossible differentials to attack 12 rounds of CLEFIA-128. Here, we will apply our formalized approach of this idea presented in Section 2.5, to reduce the data complexity of the attack on 13 rounds of CLEFIA-128.</p>

    <p class="text-gray-300">We use the  <span class="math">n_{in}=2\\times 4</span>  different inputs to the impossible differentials, that is  <span class="math">P^i=0_{32}|A|0_{32}|0_{32}</span>  and  <span class="math">P^i=0_{32}|0_{32}|0_{32}|A</span> , where A can take a difference on only one of the four possible bytes. For each one of them, there are  <span class="math">n_{out}=3</span>  different output impossible differences  <span class="math">P^{i+9}=0_{32}|0_{32}|B|0_{32}</span>  after 9 rounds, where B has only one byte active in a different position than the active byte in A. We have now  <span class="math">|\\Delta&#x27;_{in}|=|\\Delta_{in}|+\\log_2(8)=48+3</span>  and  <span class="math">|\\Delta&#x27;_{out}|=|\\Delta_{out}|+\\log_2(3)=48+1.58</span> . Since the bit-conditions remain unchanged,  <span class="math">c_{in}+c_{out}=80</span> , the minimal number of pairs needed for the attack to work is  <span class="math">N_{\\min}=2^{80}</span> . For this number of pairs, we need  <span class="math">C_{N_{\\min}}=2^{113-4.58}=2^{108.42}</span>  plaintexts. The number of information key bits is  <span class="math">|k_{in}\\cup k_{out}|=122</span> . We have then  <span class="math">\\left(C_N+\\left(N+2^{122}\\frac{N}{2^{80}}\\right)\\frac{18}{104}+P2^{128}\\right)C_E</span> . Among all the possible trade-offs with respect to the amount of data, the best time complexity we obtained is  <span class="math">2^{122.26}C_E</span>  with  <span class="math">2^{82.6}</span>  pairs built from  <span class="math">2^{111.02}</span>  plaintexts. Recall here that the aim of this approach was to reduce data complexity. Thus, in this attack the gain on the data complexity is the important part  <span class="math">^7</span> .</p>

    <p class="text-gray-300">Combining the state-test technique with multiple impossible differentials. We can combine now both previous approaches in order to reduce at the same time the time and the data complexity.</p>

    <p class="text-gray-300">We consider here only 2 out of the 3 different  <span class="math">n_{out}</span>  presented in the previous paragraph for one fixed first half of the impossible differential. We have now  <span class="math">|\\Delta&#x27;_{out}| = |\\Delta_{out}| + \\log_2(2) = 48 + 1</span>  while  <span class="math">|\\Delta_{in}|</span>  remains</p>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;\\&lt;/sup&gt;overline{^{7}\\text{In}}</span>  [25], the authors used a loose approximation for a partial encryption as  <span class="math">C&#x27;_E = 1/104</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Since the bit-conditions remain unchanged, i.e.  <span class="math">c_{in} + c_{out} = 80</span> , the minimal number of pairs needed for the attack to work is  <span class="math">N_{\\min} = 2^{80}</span> . For this number of pairs, we need  <span class="math">C_{N_{\\min}} = 2^{113-1} = 2^{112}</span>  plaintexts which allow us to fix 16 bits on the plaintexts in order to use the state-test technique. Fixing 16 bits on the plaintexts means that we only have to guess 16 bits of the subkey  <span class="math">RK_0</span> .</li>
    </ol>

    <p class="text-gray-300">As we are fixing s = 16 bits of the plaintexts, the number of information key bits is then  <span class="math">|k_{in} \\cup k_{out}| = 122 - 16 = 106</span> . Then, by combining multiple impossible differentials and the state-test technique we have</p>

    <p class="text-gray-300"><span class="math">$\\left(C_N + \\left(N \\times 2^7 + 2^{106} \\frac{N \\times 2^7}{2^{80}}\\right) \\frac{18}{104} + P2^{128}\\right) C_E,</span>$</p>

    <p class="text-gray-300">where the second term is multiplied by  <span class="math">2^7</span> , which is the cost for checking the table combinations of the different output impossible differentials. If we consider  <span class="math">N = 2^{80+3.16}</span>  pairs, we need  <span class="math">C_N = 2^{115}</span>  plaintexts to construct them and thus the time complexity is  <span class="math">2^{116.16}C_E</span> .</p>

    <p class="text-gray-300">Camellia is a 128-bit block cipher designed by Aoki et. al. in 2000 [5]. It is a Feistel-like construction where two key-dependent layers FL and  <span class="math">FL^{-1}</span>  are applied every 6 rounds to each branch. There exist three different versions of the cipher, that we note Camellia-128, Camellia-192 and Camellia-256, depending on the key size used. The number of iterations, say R, is R=18 for the 128-bit version and R=24 rounds for the other two versions. We give here a brief description of the algorithm specifications. For more details, one can refer to [5].</p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 Description of Camellia.</h3>

    <p class="text-gray-300">We briefly describe the encryption process for Camellia. A 128-bit plaintext P is first XORed with the prewhitening key  <span class="math">kw_1|kw_2</span> . The encryption process, is as follows:</p>

    <p class="text-gray-300">    <img src="_page_13_Figure_8.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300"><span class="math">-C = (R_{24}|L_{24}) \\oplus kw_3|kw_4,</span>  Fig. 6. Round function of Camellia.</p>

    <p class="text-gray-300">where  <span class="math">kw_3</span>  and  <span class="math">kw_4</span>  are the two postwhitening keys,  <span class="math">kl_r</span>  are the keys parametrizing the FL-layers and  <span class="math">k_r</span>  are the round subkeys. The round function F can be visualized in Figure 6.</p>

    <p class="text-gray-300"><strong>Previous Cryptanalysis.</strong> Camellia is since 2005 an international ISO/IEC standard and has therefore attracted a lot of attention from the cryptographic community. Since Camellia has a particular design, involving the so-called  <span class="math">FL/FL^{-1}</span>  layers, its cryptanalysis can be classified in several categories. Some attacks consider the  <span class="math">FL/FL^{-1}</span>  functions, while others do not take them into consideration. Equally, some attacks take into account the whitening keys, whereas others don't and finally all attacks do not start from the same round. The best attacks on Camellia in terms of the number of rounds and the complexities are those presented in [23, Section 4.2]. In this section we first present improvements of the best attacks that include the  <span class="math">FL/FL^{-1}</span>  layers and the whitening keys. Next we build an attack using the state-test technique on 14-round Camellia-256 starting from the first round but without the  <span class="math">FL/FL^{-1}</span>  layers and the whitening keys.</p>

    <p class="text-gray-300">Improvements. We improve here the complexities of the previous attacks that take into account the  <span class="math">FL/FL^{-1}</span>  layers and the whitening keys on all three versions of Camellia. By using the complexity analysis introduced in Section 2, we can optimize the complexities of the corresponding attacks from [23]. Note that we use for this the same parameters as in [23]. The parameters of our attacks on 11-round Camellia-128, 12-round Camellia-192 and 13-round Camellia-256 are depicted in Table 3. As can be seen in Table 2, the time complexity of our improved attack on Camellia-128 is  <span class="math">2^{118.43}C_E</span> , with data complexity  <span class="math">2^{118.4}</span>  and memory complexity  <span class="math">2^{92.4}</span> . For Camellia-192, the time, data and memory complexities are  <span class="math">2^{161.06}C_E</span> ,  <span class="math">2^{119.7}</span>  and  <span class="math">2^{150.7}</span>  respectively, while for Camellia-256 the corresponding complexities are  <span class="math">2^{225.06}C_E</span> ,  <span class="math">2^{119.71}</span>  and  <span class="math">2^{198.71}</span> .</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Algorithm</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">$ \\Delta_{in} $</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">$ \\Delta_{out} $</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">r_{in}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">r_{out}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">r_{\\Delta}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">c_{in}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">c_{out}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">$ k_{in} \\cup k_{out} $</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Camellia-128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">80</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">57</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">96</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Camellia-192</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">80</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">80</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">73</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">73</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">160</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Camellia-256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">80</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">73</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">121</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">224</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 3. Attack parameters against all versions of Camellia</p>

    <p class="text-gray-300">Using the state-test technique on Camellia-256. We provide here an impossible differential attack on Camellia-256 without  <span class="math">FL/FL^{-1}</span>  layers and without whitening keys by using the state-test technique. Note here, that unlike all previous attacks of this kind that do not start from the first round in order to take advantage of the key schedule asymmetry, our attack starts from the first round of the cipher. This attack covers 14 rounds of Camellia-256 which is, based on our knowledge, the highest number of rounds attacked for this version of the cipher. In [23] another attack on 14 rounds of Camellia-256 without  <span class="math">FL/FL^{-1}</span>  and whitening keys is presented, however, as said before, it does not start from the first round, and it equally uses a specific property of the key schedule in the rounds where it is applied.</p>

    <p class="text-gray-300">In this attack, we consider the same 8-round impossible differential as in [26] and we add 4+2 rounds such that  <span class="math">r_{in}=4</span> ,  <span class="math">r_{out}=2</span>  and  <span class="math">r_{\\Delta}=8</span> . We have  <span class="math">|\\Delta_{in}|=128</span> ,  <span class="math">|\\Delta_{out}|=56</span> ,  <span class="math">c_{in}=120</span>  and  <span class="math">c_{out}=48</span> . Then we need at least  <span class="math">N_{\\min}=2^{168}</span>  plaintext pairs for our attack to work. The amount of data needed to construct these pairs is  <span class="math">C_{N_{\\min}}=\\max\\left\\{\\sqrt{2^{168}2^{129-128}},2^{168}2^{129-184}\\right\\}=2^{113}</span> . There remain then 128-113=15 bits of freedom. Thus, we can fix s=8 bits on the ciphertexts to apply the state-test technique on the 8 bits of the internal state at the penultimate round. The number of information key bits is  <span class="math">|k_{in}\\cup k_{out}|=227-8=219</span>  since there are 45 bits shared between the subkeys with respect to the key schedule of Camellia-256. The best attack is obtained with  <span class="math">N=2^{118}</span>  pairs. In this case, the time complexity is  <span class="math">2^{220}C_E</span> , the data complexity is  <span class="math">2^{118}</span>  plaintexts and the memory is  <span class="math">2^{118}</span> .</p>

    </section>

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5 Conclusion</h2>

    <p class="text-gray-300">To start with, we have proposed in this paper a generic vision of impossible differential attacks with the aim of simplifying and helping the construction and verification of this type of cryptanalysis. Until now, these attacks were very tedious to mount and even more to verify, and so, very often flaws appeared in the computations. We believe that our objective has been successfully reached, as it can be seen by the high amount of new improved attacks that we have been able to propose, as well as by all the different possible trade-offs for each one of them, something that would be near to unthinkable prior to our work.</p>

    <p class="text-gray-300">Next, the generic and clear vision of impossible differental attacks has allowed us to discover and propose new ideas for improving these attacks. In particular, we have proposed the <em>state-test</em> technique, that allows to reduce the number of key bits involved in the attack, and so to reduce the time complexity. We have also formalized and adapted to our generic scenario the notion introduced in [35] of multiple impossible differentials. This option allows reducing the data complexity. Finally, we have proposed several applications to different variants of the Feistel block ciphers CLEFIA, Camellia, LBlock and SIMON, providing in most of the cases, the best known attack on reduced-round versions of these ciphers.</p>

    <p class="text-gray-300">We hope that these results will simplify and improve future impossible attacks on Feistel ciphers, as well as their possible combination with other attacks. For instance, in [39] a combination of impossible differential with linear attacks is proposed. We have not been able to verify these results, but this direction could be promising.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>F. Abed, E. List, S. Lucks, and J. Wenzel. Differential and linear cryptanalysis of reduced-round SIMON. Cryptology ePrint Archive, Report 2013/526, 2013.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>F. Abed, E. List, J. Wenzel, and S. Lucks. Differential Cryptanalysis of round-reduced Simon and Speck. In FSE 2014, LNCS. Springer, 2014. To appear.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>J. Alizadeh, N. Bagheri, P. Gauravaram, A. Kumar, and S. K. Sanadhya. Linear Cryptanalysis of Round Reduced Variants of SIMON. Cryptology ePrint Archive, Report 2013/663, 2013.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>H. A. Alkhzaimi and M. M. Lauridsen. Cryptanalysis of the SIMON Family of Block Ciphers. Cryptology ePrint Archive, Report 2013/543, 2013.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>K. Aoki, T. Ichikawa, M. Kanda, M. Matsui, S. Moriai, J. Nakajima, and T. Tokita. Camellia: A 128-Bit Block Cipher Suitable for Multiple Platforms - Design and Analysis. In Selected Areas in Cryptography - SAC 2000, volume 2012 of LNCS, pages 39&ndash;56. Springer, 2000.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>R. Beaulieu, D. Shors, J. Smith, S. Treatman-Clark, B. Weeks, and L. Wingers. The SIMON and SPECK Families of Lightweight Block Ciphers. Cryptology ePrint Archive, Report 2013/404, 2013.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>E. Biham, A. Biryukov, and A. Shamir. Cryptanalysis of Skipjack Reduced to 31 Rounds Using Impossible Differentials. In EUROCRYPT 1999, volume 1592 of LNCS, pages 12&ndash;23. Springer, 1999.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>E. Biham and A. Shamir. Differential Cryptanalysis of DES-like Cryptosystems. In CRYPTO 1990, volume 537 of LNCS, pages 2&ndash;21. Springer, 1990.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A. Biryukov, A. Roy, and V. Velichkov. Differential Analysis of Block Ciphers SIMON and SPECK. In FSE 2014, LNCS. Springer, 2014. To appear.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>C. Blondeau. Improbable Differential from Impossible Differential: On the Validity of the Model. In INDOCRYPT, volume 8250 of LNCS, pages 149&ndash;160. Springer, 2013.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A. Bogdanov, H. Geng, M. Wang, L. Wen, and B. Collard. Zero-Correlation Linear Cryptanalysis with FFT and Improved Attacks on ISO Standards Camellia and CLEFIA. In Selected Areas in Cryptography - SAC 2013, volume 8282 of LNCS, pages 306&ndash;323. Springer, 2013.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>C. Bouillaguet, O. Dunkelman, P-A. Fouque, and G. Leurent. New Insights on Impossible Differential Cryptanalysis. In Selected Areas in Cryptography-SAC 2011, volume 7118 of LNCS, pages 243&ndash;259. Springer, 2011.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>C. Boura, M. Minier, M. Naya-Plasencia, and V. Suder. Improved Impossible Differential Attacks against Round-Reduced LBlock. Cryptology ePrint Archive, Report 2014/279, 2014.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>J. Chen, Y. Futa, A. Miyaji, and C. Su. Impossible differential cryptanalysis of LBlock with concrete investigation of key scheduling algorithm. Cryptology ePrint Archive, Report 2014/272, 2014.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>O. Dunkelman, G. Sekar, and B. Preneel. Improved Meet-in-the-Middle Attacks on Reduced-Round DES. In IN-DOCRYPT, volume 4859 of LNCS, pages 86&ndash;100. Springer, 2007.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>H. Gilbert and T. Peyrin. Super-Sbox Cryptanalysis: Improved Attacks for AES-Like Permutations. In FSE 2010, volume 6147 of LNCS, pages 365&ndash;383. Springer, 2010.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>T. Isobe and K. Shibutani. Generic Key Recovery Attack on Feistel Scheme. In ASIACRYPT (1), volume 8269 of LNCS, pages 464&ndash;485. Springer, 2013.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>M. Iwamoto, T. Peyrin, and Y. Sasaki. Limited-Birthday Distinguishers for Hash Functions Collisions beyond the Birthday Bound Can Be Meaningful. In ASIACRYPT (2), volume 8269 of LNCS, pages 504&ndash;523. Springer, 2013.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>F. Karako&cedil;c, H. Demirci, and A. E. Harmanci. Impossible Differential Cryptanalysis of Reduced-Round LBlock. In WISTP 2012, volume 7322 of LNCS, pages 179&ndash;188. Springer, 2012.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>J. Kim, S. Hong, and J. Lim. Impossible differential cryptanalysis using matrix method. Discrete Mathematics, 310(5):988&ndash;1002, 2010.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>J. Kim, S. Hong, J. Sung, C. Lee, and S. Lee. Impossible Differential Cryptanalysis for Block Cipher Structures. In INDOCRYPT 2003, volume 2904 of LNCS, pages 82&ndash;96. Springer, 2003.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>L. R. Knudsen. DEAL A 128-bit cipher. Technical Report, Department of Informatics, University of Bergen, Norway, 1998.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Y. Liu, L. Li, D. Gu, X. Wang, Z. Liu, J. Chen, and W. Li. New Observations on Impossible Differential Cryptanalysis of Reduced-Round Camellia. In FSE 2012, volume 7549 of LNCS, pages 90&ndash;109. Springer, 2012.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>J. Lu, J. Kim, N. Keller, and O. Dunkelman. Improving the Efficiency of Impossible Differential Cryptanalysis of Reduced Camellia and MISTY1. In CT-RSA, volume 4964 of LNCS, pages 370&ndash;386. Springer, 2008.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>H. Mala, M. Dakhilalian, and M. Shakiba. Impossible Differential Attacks on 13-Round CLEFIA-128. J. Comput. Sci. Technol., 26(4):744&ndash;750, 2011.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>H. Mala, M. Shakiba, M. Dakhilalian, and G. Bagherikaram. New Results on Impossible Differential Cryptanalysis of Reduced-Round Camellia-128. In Selected Areas in Cryptography-SAC 2009, volume 5867 of LNCS, pages 281&ndash;294. Springer, 2009.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>M. Minier and M. Naya-Plasencia. A Related Key Impossible Differential Attack Against 22 Rounds of the Lightweight Block Cipher LBlock. <em>Inf. Process. Lett.</em>, 112(16):624&ndash;629, 2012.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>M. Minier and M. Naya-Plasencia. Private communication, May 2013.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>T. Shirai, K. Shibutani, T. Akishita, S. Moriai, and T. Iwata. The 128-Bit Blockcipher CLEFIA (Extended Abstract). In Fast Software Encryption FSE 2007, volume 4593 of LNCS, pages 181&ndash;195. Springer, 2007.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>T. Shirai, K. Shibutani, T. Akishita, S. Moriai, and T. Iwata. Private communication, May 2014.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>X. Tang, B. Sun, R. Li, and C. Li. Impossible differential cryptanalysis of 13-round CLEFIA-128. <em>Journal of Systems and Software</em>, 84(7):1191&ndash;1196, 2011.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>CLEFIA Design Team. Comments on the impossible differential analysis of reduced round CLEFIA presented at Inscrypt 2008, Jan. 8, 2009.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>C. Tezcan. The Improbable Differential Attack: Cryptanalysis of Reduced Round CLEFIA. In <em>INDOCRYPT</em>, volume 6498 of <em>LNCS</em>, pages 197&ndash;209. Springer, 2010.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Y. Tsunoo, E. Tsujihara, M. Shigeri, T. Saito, T. Suzaki, and H. Kubo. Impossible Differential Cryptanalysis of CLEFIA. In FSE, volume 5086 of LNCS, pages 398&ndash;411. Springer, 2008.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Y. Tsunoo, E. Tsujihara, M. Shigeri, T. Suzaki, and T. Kawabata. Cryptanalysis of CLEFIA using multiple impossible differentials. In <em>Information Theory and Its Applications. ISITA 2008</em>, pages 1&ndash;6, 2008.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>W. Wu and L. Zhang. LBlock: A Lightweight Block Cipher. In ACNS 2011, volume 6715 of LNCS, pages 327&ndash;344. Springer, 2011.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>W. Wu, L. Zhang, and W. Zhang. Improved Impossible Differential Cryptanalysis of Reduced-Round Camellia. In Selected Areas in Cryptography-SAC 2008, volume 5381 of LNCS, pages 442&ndash;456. Springer, 2008.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>W. Wu, W. Zhang, and D. Feng. Impossible Differential Cryptanalysis of Reduced-Round ARIA and Camellia. <em>J. Comput. Sci. Technol.</em>, 22(3):449&ndash;456, 2007.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Z. Yuan, X. Li, and H. Liu. Impossible Differential-Linear Cryptanalysis of Reduced-Round CLEFIA-128. Cryptology ePrint Archive, Report 2013/301, 2013.</li>
    </ol></li>
      <li><p class="text-gray-300">W. Zhang and J. Han. Impossible Differential Analysis of Reduced Round CLEFIA. In <em>Inscrypt</em>, volume 5487 of <em>LNCS</em>, pages 181&ndash;191. Springer, 2008.</p></li>
    </ul>

    <p class="text-gray-300">SIMON is a family of lightweight block ciphers, optimized for performance on hardware devices, recently proposed by the NSA [6]. Though its very recent appearance and the fact that nothing is said about its resistance against cryptanalysis in the description document, several results on reduced versions have already appeared [4, 2, 3, 9]. We apply here our method on SIMON and come out with the best impossible differential attacks for all versions of the algorithm, as well as with the best known attacks on the smaller variants.</p>

      <h3 id="app-a.1" class="text-xl font-semibold mt-8">A.1 Brief description of the Simon family</h3>

    <p class="text-gray-300">The SIMON family of block ciphers is based on a classical Feistel construction operating on two <em>n</em>-bit branches. Therefore, the total block size is equal to 2n bits. The round function is composed of very simple operations consisting of rotations, XORs and the AND operation. More precisely, at each round, a nonlinear function  <span class="math">F: \\mathbb{F}_2^n \\to \\mathbb{F}_2^n</span>  transforms the left branch in the following way:</p>

    <p class="text-gray-300"><span class="math">$F(L_{i-1}) = ((L_{i-1} \\ll 8) \\&amp; (L_{i-1} \\ll 1)) \\oplus (L_{i-1} \\ll 2).</span>$</p>

    <p class="text-gray-300">The output of F is then XORed with the round subkey and with the right branch  <span class="math">R_{i-1}</span>  to form the left input of the next round. The round function is iterated r times, where the exact number of iterations r depends on the cipher's version. There exist in total ten members of the SIMON family, each one characterized by different block and key sizes. We denote a member of the SIMON family by SIMONX/x', where x denotes the block size and x' the key size. All versions can be seen in column 1 of Table 2. For the key schedule description, we refer to the description document [6].</p>

      <h3 id="app-a.2" class="text-xl font-semibold mt-8">A.2 Previous cryptanalysis and comparison to our results</h3>

    <p class="text-gray-300">Since its recent publication, SIMON has received a remarkable amount of analysis from the community. Most of these works [4, 2, 3, 9] analyze the resistance of the cipher against differential, impossible differential linear and rectangle attacks. The best current results are due to differential cryptanalysis [2, 9], while</p>

    <p class="text-gray-300">the number of attacked rounds with impossible differential attacks is much lower for all versions. Also, proposed impossible differential attacks on SIMON present flaws. In [4], the data complexity is too high for the attack to work, while in [1, 2] the computed  <span class="math">c_{in}</span>  is not correct, as we can check from our Figure 7, where the input rounds are the same as in their case, and  <span class="math">c_{in}</span>  should be 22, instead of 10.</p>

    <p class="text-gray-300">We provide here impossible differential attacks for all members of the Simon family. With these results we attack, for all versions, much more rounds than the previous best impossible differential attacks. Furthermore, our attacks constitute the best known cryptanalysis results for the three smaller versions.</p>

      <h3 id="app-a.3" class="text-xl font-semibold mt-8">A.3 Impossible differential attacks on Simon</h3>

    <p class="text-gray-300">We provide here our attacks on the Simon family. As the approach used in our analysis is the same for all the versions except of Simon96/96 and 128/128, we will only present the details of the attack on Simon32/64 and give briefly the attack parameters for the other versions.</p>

    <p class="text-gray-300">Without using the improvements of Section 2.5, it would not have been possible to mount impossible differential attacks on any version of SIMON, as the data available from the obtained patterns would not have been enough. Indeed, for all versions of SIMON, it holds that  <span class="math">c_{in} = |\\Delta_{in}|</span>  and  <span class="math">c_{out} = |\\Delta_{out}|</span>  implying that  <span class="math">C_N \\geq 2^{n+1}</span>  for all  <span class="math">N \\geq 2^{c_{in}+c_{out}}</span> . This is why we mount our attacks by rotating the second part of the impossible differential while keeping the same first part (see Section 2.5) so that another impossibility in the middle is produced. If we rotate the output pattern by 2 bits (see Table 4), it is possible to generate a second impossible differential with the same first part of the differential. More precisely, for each version of SIMON, there exist at least two output patterns that give the longest impossible differential for a given input pattern. Therefore, for all versions  <span class="math">|\\Delta&#x27;_{out}| = |\\Delta_{out}| + 1</span> . This method ensures enough data to attack all versions of the SIMON family except for SIMON96/96 and 128/128.</p>

    <p class="text-gray-300">In Section A.5 we present an example of how to simultaneously apply both ideas from Section 2.5. This approach does not change the number of attacked rounds but it permits to improve the data complexity for all versions and to provide valid attacks against SIMON96/96 and 128/128.</p>

    <p class="text-gray-300">Attack on Simon32/64. By following the previous approach we found that the longest impossible differentials (32 in total) are covering 11 rounds. The impossible differentials that we used for our attack can be visualized in Table 4. However, we note here, that any other maximum-length differential would have led to an equivalent attack. This differential was placed between rounds 5 and 16 and extended by  <span class="math">r_{in} = 4</span>  rounds and  <span class="math">r_{out} = 4</span>  rounds to both directions. In such a way, the first 19 (= 4 + 11 + 4) rounds of the cipher were attacked. It can be seen in Figure 7 that the number of bit-conditions is  <span class="math">c_{in} + c_{out} = 44</span> , with  <span class="math">c_{in} = c_{out} = 22</span> . We can equally see that  <span class="math">|\\Delta_{in}| = 22</span>  and  <span class="math">|\\Delta&#x27;_{out}| = 23</span> . Determining the number of information key bits is simply the sum of the different subkey bits intervening in the attack. These bits are marked in blue in Figure 7, from where we can easily verify that  <span class="math">|k_{in} \\cup k_{out}| = 2 * 27 = 54</span> . The complexity of our attack can be seen in Table 5. Notice that for this attack on Simon32/64,  <span class="math">C&#x27;_E = \\frac{54}{16.19} = 2^{-2.49}</span> .</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">r</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Left branch <span class="math">L_r</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Right branch <span class="math">R_r</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">000000000000000000</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">000000000000000000</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">000000000000000000</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">000000000000000000</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0000000<em>00001</em>0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">000000000000000001</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">00000<strong>00001</strong>0*</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0 0 0 0 0 0 0 0 * 0 0 0 0 0 1 * 0</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">000***01*****</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0 0 0 0 0 0 * * 0 0 0 0 1 * * 0 *</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0 * * * * * * 1 * * * * * * 0 *</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0 0 0 * * * 0 * 0 1 * * * * * 0</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">* * * * * * * * * * * * * * *</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0 * * * * * * 1 * * * * * * 0 *</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">* 0 1 * * * * * * 0 0 0 0 0 * * * * 0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1 * * * * * * * 0 * 0 * * * * * * *</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">00001<strong>0*00000</strong></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">* 0 1 * * * * * * 0 0 0 0 0 * * * 0</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">* 0 0 0 0 0 1 * 0 0 0 0 0 0 0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0 0 0 0 1 * * 0 * 0 0 0 0 0 * *</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">$ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 1\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">* 0 0 0 0 0 1 * 0 0 0 0 0 0 0 0</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">$ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 1\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">000000001000000</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300"><strong>Table 4.</strong> Impossible differential for the attack on SIMON32/64. 0 denotes a bit without difference, 1 denotes a bit with a difference, and * denotes a bit for which we do not know whether there is a difference or not.</p>

    <p class="text-gray-300">    <img src="_page_18_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 7. The initial rounds (on the left) and the final rounds (on the right) of the attack on SIMON32/64.</p>

      <h3 id="app-a.4" class="text-xl font-semibold mt-8">A.4 Attacks on the other versions</h3>

    <p class="text-gray-300">We used the same strategy to attack the other versions of the Simon family. The results for all versions except for Simon96/96 and 128/128 are summarized in Table 5.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">SIMON<br>32/64</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Simon<br>48/72</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Simon<br>48/96</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Simon<br>64/96</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">SIMON<br>64/128</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Simon<br>96/144</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">SIMON<br>128/192</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Simon<br>128/256</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Rounds</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">22</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">25</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">28</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">30</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Time</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{62.56}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{70.69}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{94.73}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{94.56}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{126.56}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{142.59}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{190.56}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{254.68}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Data</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{32}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{48}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{48}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{64}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{64}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{96}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{128}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{128}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Memory</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{44}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{58}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{70}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{60}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{75}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{77}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{77}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{111}</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 5. Complexity summary of our attacks on the majority of Simon versions.</p>

      <h3 id="app-a.5" class="text-xl font-semibold mt-8">A.5 Using multiple impossible differentials for attacking Simon32/64-96/96 and 128/128</h3>

    <p class="text-gray-300">Example on SIMON32/64. When considering both possibilities from Section 2.5, we can easily find 4 rotated input patterns (by 0,7,8,31 to the left), independent one from another. We can then define  <span class="math">|\\Delta&#x27;_{in}| = 22 + \\log 4 = 24</span>  and  <span class="math">|\\Delta&#x27;_{out}| = 22 + \\log 2 = 23</span> . All the remaining parameters stay the same as in the attack described in Section A.3. The best complexities for the attack are given by considering  <span class="math">N = 2^{45}</span> , with  <span class="math">C_N = 2^{31}</span>  and a time complexity of  <span class="math">2^{61.12}C_E</span> , or by using the whole codebook giving a time complexity of  <span class="math">2^{58.28}C_E</span> .</p>

    <p class="text-gray-300">Example on Simon96/96 and 128/128. In the 96/96 case, we consider an attack on 24 rounds (4+16+4), where we can find 8 independent input patterns generated by rotations of an original one (by 0,7,8,16,19,25,31,37 to the left). With  <span class="math">|\\Delta&#x27;_{in}|=33</span>  and  <span class="math">|\\Delta&#x27;_{out}|=31</span> , if we consider  <span class="math">N=2^{61}</span> , we</p>

    <p class="text-gray-300">have  <span class="math">C_N = 2^{94}</span>  and a time complexity of  <span class="math">2^{94.62}C_E</span> . The same can be done with 128/128 and 27 rounds (4+19+4), obtaining a time complexity of  <span class="math">2^{126.6}C_E</span> .</p>

    <p class="text-gray-300">LBlock is a lightweight block cipher designed by Wu and Zhang in 2011 [36]. It is an iterated construction that can be seen as a variant of a Feistel network. The total number of iterations is equal to 32. The cipher operates on a 64-bit state and encrypts messages by using a 80-bit key.</p>

    <p class="text-gray-300">We start by providing a short description of the algorithm specifications. For a more complete description one can refer to [36].</p>

      <h3 id="app-b.1" class="text-xl font-semibold mt-8">B.1 Description of LBlock</h3>

    <p class="text-gray-300">Encryption algorithm. Denote by  <span class="math">P = L_0|R_0</span>  a 64-bit plaintext, where  <span class="math">L_0</span>  and  <span class="math">R_0</span>  are 32-bit vectors. The encryption procedure is as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For i = 1, 2, ..., 31 do    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\bullet \\ R_i = L_{i-1}</span></li>
      <li><span class="math">L_i = F(L_{i-1}, K_i) \\oplus (R_{i-1} \\ll 8).</span></li>
    </ul></li>
      <li><span class="math">-L_{32}=L_{31}</span></li>
      <li><span class="math">-R_{32} = F(L_{31}, K_{32}) \\oplus (R_{31} \\ll 8).</span></li>
      <li>Output the ciphertext  <span class="math">C = L_{32}|R_{32}</span> .</li>
    </ul>

    <p class="text-gray-300">    <img src="_page_19_Picture_12.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 8. A round of LBlock</p>

    <p class="text-gray-300">Round function F. A round of LBlock is depicted in Figure 8. The round function F can be divided into three steps. First, the 32-bit subkey  <span class="math">K_i</span>  is added to  <span class="math">L_{i-1}</span>  by a simple XOR. Then, a nonlinear layer applies to the result. This nonlinear layer consists of the application nibble by nibble of eight different 4-bit Sboxes  <span class="math">S_0, \\ldots, S_7</span> . The description of these Sboxes can be found in [36]. Finally, the resulting nibbles are permuted as seen in Figure 8.</p>

    <p class="text-gray-300">We are going now to describe our attack against 23 rounds of LBlock. To our knowledge, this is so far the best known attack against this cipher. We will equally present an improved impossible differential attack of the one published so far on 22 rounds. Here, we show how to build the attack using the generic attack strategy and the time complexity estimation, and it can be seen in [13] how this generic estimation perfectly corresponds to the detailed and careful time complexity computation.</p>

      <h3 id="app-b.2" class="text-xl font-semibold mt-8">B.2 Impossible differential attack on 23 rounds of LBlock</h3>

    <p class="text-gray-300">First, we notice that a difference  <span class="math">P^i = 0_{32}|(0_4, 0_4, 0_4, 0_4, 0_4, 0_4, 0_4, 0_4)</span>  cannot lead to a difference  <span class="math">P^{i+14} = (0_4, 0_4, 0_4, 0_4, 0_4, 0_4, 0_4, 0_4,</span></p>

    <p class="text-gray-300">We extend this impossible differential by adding  <span class="math">r_{in} = 5</span>  rounds to the input and  <span class="math">r_{out} = 4</span>  rounds to the output and attack therefore the 23 first rounds of the cipher. As can be seen in Figure 9, the number of input bit-conditions is  <span class="math">c_{in} = 4 \\times 11 = 44</span>  and the number of output bit-conditions  <span class="math">c_{out} = 4 \\times 7 = 28</span> . In the same way,  <span class="math">|\\Delta_{in}| = 12 \\times 4 = 48</span>  and  <span class="math">|\\Delta_{out}| = 8 \\times 4 = 32</span> .</p>

    <p class="text-gray-300">the same way,  <span class="math">|\\Delta_{in}| = 12 \\times 4 = 48</span>  and  <span class="math">|\\Delta_{out}| = 8 \\times 4 = 32</span> . As  <span class="math">c_{in} + c_{out} = 72</span> , we see that we need at least  <span class="math">N_{\\min} = 2^{72}</span>  pairs for the attack to work. By trying different values for N, we found out that the best time complexity is given when choosing  <span class="math">N = 2^{74}</span> . The amount of data we need to construct these pairs is</p>

    <p class="text-gray-300"><span class="math">$C_N = \\max\\left\\{\\sqrt{2^{74}2^{65-48}}, 2^{74}2^{65-48-32}\\right\\} = 2^{59}.</span>$</p>

    <p class="text-gray-300">    <img src="_page_20_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 9. The initial rounds (on the left) and the final rounds (on the right). Different colors stand for the round that these key bits intervene.</p>

    <p class="text-gray-300">When analyzing the key schedule of LBlock, whose detailed description can be found in [36], we noticed that the amount of information key bits in our attack is  <span class="math">|k_{in} \\cup k_{out}| = 73</span>  bits.</p>

    <p class="text-gray-300">We briefly recall in Figure 10 the parameters of our attack on 23 rounds.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\Delta_{in}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">(*0 * 0 * * * 0, * * * * * * * * * * * *</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\Delta_X</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">(00000000,0000\\alpha000)</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">] [</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">$ \\Delta_{in} $</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">$ \\Delta_{out} $</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">r_{in}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">r_{out}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">r_{\\Delta}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">c_{in}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">c_{out}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">$ k_{in} \\cup k_{out} $</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\Delta_{out}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(<strong>0***00,0</strong>0000*)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\Delta_Y</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(00000\\beta00,00000000)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">48</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">44</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">28</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">73</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Fig. 10. Parameters of our impossible differential cryptanalysis of 23-round LBlock.</p>

    <p class="text-gray-300">By using the Formula (2) we compute the time complexity of our 23-round attack on LBlock with  <span class="math">2^{59}</span>  chosen plaintexts, to be  <span class="math">2^{75.36}C_E</span> . The memory complexity, determined by N, is  <span class="math">2^{74}</span> . It is important to point out that this estimated complexity perfectly correspond to the carefully computed one that is detailed in [13], showing that our time complexity estimation is indeed very tight.</p>

      <h3 id="app-b.3" class="text-xl font-semibold mt-8">B.3 Improvement of the Impossible Differential Cryptanalysis of 22-round LBlock</h3>

    <p class="text-gray-300">The previous best known attack against LBlock was an impossible differential attack on 22 rounds [19], of time complexity  <span class="math">2^{79.28}C_E</span> . We show here that it is possible to mount an 22-round attack with an improved time complexity. More precisely, by applying the formulas of Section 2, we obtain an attack of data complexity  <span class="math">2^{60}</span> , time complexity  <span class="math">2^{71.53}C_E</span>  and memory complexity  <span class="math">2^{59}</span> . The parameters of our attack are depicted in Figure 11.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\Delta_{in} \\left[ (***00000, *0*0****0) \\right]</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\Delta_X (00000000, 0000\\alpha000)</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">$ \\Delta_{in}   \\Delta_{out} $</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">r_{in} r_{out}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">r_{\\Delta}    c_{in} c_{out}   </span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\#(k_{in} \\cup k_{out})</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\Delta_{out}   (**0***00, 0**0000*)  </span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Fig. 11. Parameters of our impossible differential cryptanalysis of 22 rounds of LBlock.</p>

    </section>
`;
---

<BaseLayout title="Scrutinizing and Improving Impossible Differential Attacks: ... (2014/699)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2014 &middot; eprint 2014/699
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#sec-1" class="hover:text-white">Introduction</a></li>
        <li>
          <a href="#sec-2" class="hover:text-white">Complexity analysis</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-2.1" class="hover:text-white">Attack scenario</a></li>
            <li><a href="#sec-2.2" class="hover:text-white">Data complexity</a></li>
            <li><a href="#sec-2.3" class="hover:text-white">Time and memory complexity</a></li>
            <li><a href="#sec-2.4" class="hover:text-white">Choosing \Delta_&#123;in&#125;, \Delta_&#123;out&#125;, c_&#123;in&#125; and c_&#123;out&#125;.</a></li>
            <li><a href="#sec-2.5" class="hover:text-white">Using multiple impossible differentials to reduce the data complexity</a></li>
            <li><a href="#sec-2.6" class="hover:text-white">Introducing the state-test technique</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-3" class="hover:text-white">Application to CLEFIA</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-3.1" class="hover:text-white">Description of CLEFIA</a></li>
            <li><a href="#sec-3.2" class="hover:text-white">Impossible Differential Cryptanalysis of 13-round CLEFIA-128</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-4" class="hover:text-white">Applications to Camellia</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-4.1" class="hover:text-white">Description of Camellia.</a></li>
          </ol>
        </li>
        <li><a href="#sec-5" class="hover:text-white">Conclusion</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li>
          <a href="#app-a" class="hover:text-white">Application to the Simon family of block ciphers</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-a.1" class="hover:text-white">Brief description of the Simon family</a></li>
            <li><a href="#app-a.2" class="hover:text-white">Previous cryptanalysis and comparison to our results</a></li>
            <li><a href="#app-a.3" class="hover:text-white">Impossible differential attacks on Simon</a></li>
            <li><a href="#app-a.4" class="hover:text-white">Attacks on the other versions</a></li>
            <li><a href="#app-a.5" class="hover:text-white">Using multiple impossible differentials for attacking Simon32/64-96/96 and 128/128</a></li>
          </ol>
        </li>
        <li>
          <a href="#app-b" class="hover:text-white">Application to LBlock</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-b.1" class="hover:text-white">Description of LBlock</a></li>
            <li><a href="#app-b.2" class="hover:text-white">Impossible differential attack on 23 rounds of LBlock</a></li>
            <li><a href="#app-b.3" class="hover:text-white">Improvement of the Impossible Differential Cryptanalysis of 22-round LBlock</a></li>
          </ol>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="scrutinizing-and-improving-impossible-differential-attacks-2014" />
  </article>
</BaseLayout>
