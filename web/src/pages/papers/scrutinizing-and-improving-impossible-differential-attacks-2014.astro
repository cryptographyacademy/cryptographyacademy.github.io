---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2014/699';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Scrutinizing and Improving Impossible Differential Attacks: Applications to CLEFIA, Camellia, LBlock and Simon (Full Version)';
const AUTHORS_HTML = 'Christina Boura, María Naya-Plasencia, Valentin Suder';

const CONTENT = `    <p class="text-gray-300">Christina Boura¹, María Naya-Plasencia², Valentin Suder²</p>

    <p class="text-gray-300">¹ Versailles Saint-Quentin-en-Yvelines University, France christina.boura@prism.uvsq.fr ² Inria, France Maria.Naya.Plasencia@inria.fr, Valentin.Suder@inria.fr</p>

    <p class="text-gray-300">Abstract. Impossible differential cryptanalysis has shown to be a very powerful form of cryptanalysis against block ciphers. These attacks, even if extensively used, remain not fully understood because of their high technicality. Indeed, numerous are the applications where mistakes have been discovered or where the attacks lack optimality. This paper aims in a first step at formalizing and improving this type of attacks and in a second step at applying our work to block ciphers based on the Feistel construction. In this context, we derive generic complexity analysis formulas for mounting such attacks and develop new ideas for optimizing impossible differential cryptanalysis. These ideas include for example the testing of parts of the internal state for reducing the number of involved key bits. We also develop in a more general way the concept of using multiple differential paths, an idea introduced before in a more restrained context. These advances lead to the improvement of previous attacks against well known ciphers such as CLEFIA-128 and Camellia, while also to new attacks against 23-round LBlock and all members of the SIMON family.</p>

    <p class="text-gray-300">Keywords. block ciphers, impossible differential attacks, CLEFIA, Camellia, LBlock, SIMON.</p>

    <p class="text-gray-300">Impossible differential attacks were independently introduced by Knudsen [22] and Biham et al. [7]. Unlike differential attacks [8] that exploit differential paths of high probability, the aim of impossible differential cryptanalysis is to use differentials that have a probability of zero to occur in order to eliminate the key candidates leading to such impossible differentials.</p>

    <p class="text-gray-300">The first step in an impossible differential attack is to find an impossible differential covering the maximum number of rounds. This is a procedure that has been extensively studied and there exist algorithms for finding such impossible differentials efficiently [21, 20, 12]. Once such a maximum-length impossible differential has been found and placed, one extends it by some rounds to both directions. After this, if a candidate key partially encrypts/decrypts a given pair to the impossible differential, then this key certainly cannot be the right one and is thus rejected. This technique provides a sieving of the key space and the remaining candidates can be tested by exhaustive search.</p>

    <p class="text-gray-300">Despite the fact that impossible differential cryptanalysis has been extensively employed, the key sieving step of the attack does not seem yet fully understood. Indeed, this part of the procedure is highly technical and many parameters have to be taken into consideration. Questions that naturally arise concern the way to choose the plaintext/ciphertext pairs, the way to calculate the necessary data to mount the attack, the time complexity of the overall procedure as well as which are the parameters that optimize the attack. However, no simple and generalized way for answering these questions has been provided until now and the generality of most of the published attacks is lost within the tedious details of each application. The problems that arise from this approach is that mistakes become very common and attacks become difficult to verify. Errors in the analysis are often discovered and as we demonstrate in the next paragraph, many papers in the literature present flaws. These flaws include errors in the computation of the time or the data complexity, in the analysis of the memory requirements or of the complexity of some intermediate steps of the attacks. We can cite many such cases for different algorithms, as shown in Table 1. Note however, that the list of flaws presented in this table is not exhaustive.</p>

    <p class="text-gray-300">*Partially supported by the French Agence Nationale de la Recherche through the BLOC project under Contract ANR-11-INS-011. ©IACR 2014. This article is the full version of the paper submitted by the authors to the IACR and to Springer-Verlag in September 2014, to appear in the proceedings of ASIACRYPT 2014.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"># rounds</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Reference</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Type of error</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Gravity of error</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Where discovered</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CLEFIA-128 (without whit. layers)</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">[40]</td>

            <td class="px-3 py-2 border-b border-gray-700">data complexity higher than codebook</td>

            <td class="px-3 py-2 border-b border-gray-700">attack does not work</td>

            <td class="px-3 py-2 border-b border-gray-700">[32]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CLEFIA-128</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">[33]</td>

            <td class="px-3 py-2 border-b border-gray-700">cannot be verified without implementation</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">[10]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Camellia (without FL/FL-1 layers)</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">[38]</td>

            <td class="px-3 py-2 border-b border-gray-700">big flaw in computation as in [37]</td>

            <td class="px-3 py-2 border-b border-gray-700">attack does not work</td>

            <td class="px-3 py-2 border-b border-gray-700">this paper</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Camellia-128</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">[37]</td>

            <td class="px-3 py-2 border-b border-gray-700">big flaw in computation</td>

            <td class="px-3 py-2 border-b border-gray-700">attack does not work</td>

            <td class="px-3 py-2 border-b border-gray-700">[26]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Camellia-128/192/256 (without FL/FL-1 layers)</td>

            <td class="px-3 py-2 border-b border-gray-700">11/13/14</td>

            <td class="px-3 py-2 border-b border-gray-700">[24]</td>

            <td class="px-3 py-2 border-b border-gray-700">small complexity flaws</td>

            <td class="px-3 py-2 border-b border-gray-700">corrected attacks work</td>

            <td class="px-3 py-2 border-b border-gray-700">[38]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">LBlock</td>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

            <td class="px-3 py-2 border-b border-gray-700">[27]</td>

            <td class="px-3 py-2 border-b border-gray-700">small complexity flaw</td>

            <td class="px-3 py-2 border-b border-gray-700">corrected attack works</td>

            <td class="px-3 py-2 border-b border-gray-700">[28]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SIMON (all versions)</td>

            <td class="px-3 py-2 border-b border-gray-700">14/15/15/16/16/19/19/22/22/22</td>

            <td class="px-3 py-2 border-b border-gray-700">[4]</td>

            <td class="px-3 py-2 border-b border-gray-700">data complexity higher than codebook</td>

            <td class="px-3 py-2 border-b border-gray-700">attacks do not work</td>

            <td class="px-3 py-2 border-b border-gray-700">Table 1 of [4]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SIMON (all versions)</td>

            <td class="px-3 py-2 border-b border-gray-700">13/15/17/20/25/</td>

            <td class="px-3 py-2 border-b border-gray-700">[1,2]</td>

            <td class="px-3 py-2 border-b border-gray-700">big flaw in computation</td>

            <td class="px-3 py-2 border-b border-gray-700">attacks do not work</td>

            <td class="px-3 py-2 border-b border-gray-700">Appendix A.2</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1. Summary of flaws in previous impossible differential attacks on CLEFIA-128, Camellia, LBlock and SIMON.</p>

    <p class="text-gray-300">Instances of such flaws can for example be found in analyses of the cipher CLEFIA. CLEFIA is a lightweight 128-bit block cipher developed by SONY in 2007 [29] and adopted as an international ISO/IEC 29192 standard in lightweight cryptography. This cipher has attracted the attention of many researchers and numerous attacks have been published so far on reduced round versions [34, 35, 33, 25, 31, 11]. Most of these attacks rely on impossible differential cryptanalysis. However, as pointed out by the designers of CLEFIA [30], some of these attacks seem to have flaws, especially in the key filtering phase. We can cite here a recent paper by Blondeau [10] that challenges the validity of the results in [33], or a claimed attack on 14 rounds of CLEFIA-128 [40], for which the designers of CLEFIA showed that the necessary data exceeds the whole codebook [32]. Another extensively analyzed cipher is the ISO/IEC 18033 standard Camellia, designed by Mitsubishi and NTT [5]. Among the numerous attacks presented against this cipher, some of the more successful ones rely on impossible differential cryptanalysis [38, 37, 23, 26, 24]. In the same way as for CLEFIA, some of these attacks were detected to have flaws. For instance, the attack from [37] was shown in [26] to be invalid. We discovered a similar error in the computation that invalidated the attack of [38]. Also, [38] reveals small flaws in [24]. Errors in impossible differential attacks were also detected for other ciphers. For example, in a cryptanalysis against the lightweight block cipher LBlock [27], the time complexity revealed to be incorrectly computed [28]. Another problem can be found in [4], where the data complexity is higher than the amount of data available in the block cipher SIMON, or in [1, 2], where some parameters are not correctly computed. During our analysis, we equally discovered problems in some attacks that do not seem to have been pointed out before. In addition to all this, the more the procedure becomes complicated, the more the approach lacks optimality. To illustrate this lack of optimality presented in many attacks we can mention a cryptanalysis against 22-round LBlock [19], that could easily be extended to 23 rounds if a more optimal approach had been used to evaluate the data and time complexities, as well as an analysis of Camellia [23] which we improve in Section 4.</p>

    <p class="text-gray-300">The above examples clearly show that impossible differential attacks suffer from the lack of a unified and optimized approach. For this reason, the first aim of our paper is to provide a general framework for dealing with impossible differential attacks. In this direction, we provide new generic formulas for computing the data, time and memory complexities. These formulas take into account the different parameters that intervene into the attacks and provide a highly optimized way for mounting them. Furthermore, we present some new techniques that can be applied in order to reduce the data needed or to reduce the number of key bits that need to be guessed. In particular we present a new method that helps reducing the number of key bits to be guessed by testing instead some bits of the internal state during the sieving phase. This technique has some similarities with the methods introduced in [15, 17], however important differences exist as both techniques are applied in a completely different context. In addition to this, we apply and develop the idea of multiple impossible differentials, introduced in [35], to obtain more data for mounting our attacks. To illustrate the strength of our new approach we consider Feistel constructions and we apply the above ideas to a number of lightweight block ciphers, namely CLEFIA, Camellia, LBlock and SIMON.</p>

    <p class="text-gray-300">More precisely, we present an attack as well as different time/data trade-offs on 13-round CLEFIA-128 that improve the time and data complexity of the previous best known attack [26] and improvements in the complexity of the best known attacks against all versions of Camellia [23]. In addition, in order to demonstrate the generality of our method, we provide the results of our attacks against 23-round LBlock and all versions of the SIMON block cipher. The attack on LBlock is the best attack so far in the single-key setting  <span class="math">^{3}</span> , while our attacks on SIMON are the best known impossible differential attacks for this family of ciphers and the best attacks in general for the three smaller versions of SIMON.</p>

    <p class="text-gray-300">Summary of our attacks. We present here a summary of our results on the block ciphers CLEFIA-128, Camellia, LBlock and SIMON and compare them to the best impossible differential attacks known for the four analyzed algorithms. This summary is given in Table 2, where we point out with a  <span class="math">*</span>  if the mentioned attack is the best cryptanalysis result on the target cipher or not, i.e. by the best known attack we consider any attack reaching the highest number of rounds, and with the best complexities among them.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"># Rounds</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Data (CP)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Memory (Blocks)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Reference</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CLEFIA-128</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">2121.2</td>

            <td class="px-3 py-2 border-b border-gray-700">2117.8</td>

            <td class="px-3 py-2 border-b border-gray-700">286.8</td>

            <td class="px-3 py-2 border-b border-gray-700">[25]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">using state-test technique</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">2116.90</td>

            <td class="px-3 py-2 border-b border-gray-700">2116.33</td>

            <td class="px-3 py-2 border-b border-gray-700">283.33</td>

            <td class="px-3 py-2 border-b border-gray-700">Section 3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">using multiple impossible differentials</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">2122.26</td>

            <td class="px-3 py-2 border-b border-gray-700">2111.02</td>

            <td class="px-3 py-2 border-b border-gray-700">282.60</td>

            <td class="px-3 py-2 border-b border-gray-700">Section 3*</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">combining with state-test technique</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">2116.16</td>

            <td class="px-3 py-2 border-b border-gray-700">2114.58</td>

            <td class="px-3 py-2 border-b border-gray-700">283.16</td>

            <td class="px-3 py-2 border-b border-gray-700">Section 3*</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Camellia-128</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">2122</td>

            <td class="px-3 py-2 border-b border-gray-700">2122</td>

            <td class="px-3 py-2 border-b border-gray-700">298</td>

            <td class="px-3 py-2 border-b border-gray-700">[23]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">2118.43</td>

            <td class="px-3 py-2 border-b border-gray-700">2118.4</td>

            <td class="px-3 py-2 border-b border-gray-700">292.4</td>

            <td class="px-3 py-2 border-b border-gray-700">Section 4*</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Camellia-192</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">2187.2</td>

            <td class="px-3 py-2 border-b border-gray-700">2123</td>

            <td class="px-3 py-2 border-b border-gray-700">2155.41</td>

            <td class="px-3 py-2 border-b border-gray-700">[23]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">2161.06</td>

            <td class="px-3 py-2 border-b border-gray-700">2119.7</td>

            <td class="px-3 py-2 border-b border-gray-700">2150.7</td>

            <td class="px-3 py-2 border-b border-gray-700">Section 4*</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Camellia-256</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">2251.1</td>

            <td class="px-3 py-2 border-b border-gray-700">2123</td>

            <td class="px-3 py-2 border-b border-gray-700">2203</td>

            <td class="px-3 py-2 border-b border-gray-700">[23]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">2225.06</td>

            <td class="px-3 py-2 border-b border-gray-700">2119.71</td>

            <td class="px-3 py-2 border-b border-gray-700">2198.71</td>

            <td class="px-3 py-2 border-b border-gray-700">Section 4*</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Camellia-256†</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">2250.5</td>

            <td class="px-3 py-2 border-b border-gray-700">2120</td>

            <td class="px-3 py-2 border-b border-gray-700">2120</td>

            <td class="px-3 py-2 border-b border-gray-700">[23]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">2220</td>

            <td class="px-3 py-2 border-b border-gray-700">2118</td>

            <td class="px-3 py-2 border-b border-gray-700">2173</td>

            <td class="px-3 py-2 border-b border-gray-700">Section 4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">LBlock</td>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

            <td class="px-3 py-2 border-b border-gray-700">279.28</td>

            <td class="px-3 py-2 border-b border-gray-700">258</td>

            <td class="px-3 py-2 border-b border-gray-700">272.67</td>

            <td class="px-3 py-2 border-b border-gray-700">[19]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

            <td class="px-3 py-2 border-b border-gray-700">271.53</td>

            <td class="px-3 py-2 border-b border-gray-700">260</td>

            <td class="px-3 py-2 border-b border-gray-700">259</td>

            <td class="px-3 py-2 border-b border-gray-700">Appendix B,[13]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">23</td>

            <td class="px-3 py-2 border-b border-gray-700">275.36</td>

            <td class="px-3 py-2 border-b border-gray-700">259</td>

            <td class="px-3 py-2 border-b border-gray-700">274</td>

            <td class="px-3 py-2 border-b border-gray-700">Appendix B,[13]*</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SIMON32/64</td>

            <td class="px-3 py-2 border-b border-gray-700">19</td>

            <td class="px-3 py-2 border-b border-gray-700">262.56</td>

            <td class="px-3 py-2 border-b border-gray-700">232</td>

            <td class="px-3 py-2 border-b border-gray-700">244</td>

            <td class="px-3 py-2 border-b border-gray-700">Appendix A*</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SIMON48/72</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">270.69</td>

            <td class="px-3 py-2 border-b border-gray-700">248</td>

            <td class="px-3 py-2 border-b border-gray-700">258</td>

            <td class="px-3 py-2 border-b border-gray-700">Appendix A*</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SIMON48/96</td>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

            <td class="px-3 py-2 border-b border-gray-700">294.73</td>

            <td class="px-3 py-2 border-b border-gray-700">248</td>

            <td class="px-3 py-2 border-b border-gray-700">270</td>

            <td class="px-3 py-2 border-b border-gray-700">Appendix A*</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SIMON64/96</td>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

            <td class="px-3 py-2 border-b border-gray-700">294.56</td>

            <td class="px-3 py-2 border-b border-gray-700">264</td>

            <td class="px-3 py-2 border-b border-gray-700">260</td>

            <td class="px-3 py-2 border-b border-gray-700">Appendix A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SIMON64/128</td>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

            <td class="px-3 py-2 border-b border-gray-700">2126.56</td>

            <td class="px-3 py-2 border-b border-gray-700">264</td>

            <td class="px-3 py-2 border-b border-gray-700">275</td>

            <td class="px-3 py-2 border-b border-gray-700">Appendix A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SIMON96/96</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">294.62</td>

            <td class="px-3 py-2 border-b border-gray-700">294</td>

            <td class="px-3 py-2 border-b border-gray-700">261</td>

            <td class="px-3 py-2 border-b border-gray-700">Appendix A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SIMON96/144</td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">2190.56</td>

            <td class="px-3 py-2 border-b border-gray-700">2128</td>

            <td class="px-3 py-2 border-b border-gray-700">277</td>

            <td class="px-3 py-2 border-b border-gray-700">Appendix A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SIMON128/128</td>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700">2126.6</td>

            <td class="px-3 py-2 border-b border-gray-700">294</td>

            <td class="px-3 py-2 border-b border-gray-700">261</td>

            <td class="px-3 py-2 border-b border-gray-700">Appendix A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SIMON128/192</td>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700">2190.56</td>

            <td class="px-3 py-2 border-b border-gray-700">2128</td>

            <td class="px-3 py-2 border-b border-gray-700">277</td>

            <td class="px-3 py-2 border-b border-gray-700">Appendix A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SIMON128/256</td>

            <td class="px-3 py-2 border-b border-gray-700">30</td>

            <td class="px-3 py-2 border-b border-gray-700">2254.68</td>

            <td class="px-3 py-2 border-b border-gray-700">2128</td>

            <td class="px-3 py-2 border-b border-gray-700">2111</td>

            <td class="px-3 py-2 border-b border-gray-700">Appendix A</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2. Summary of the best impossible differential attacks on CLEFIA-128, Camellia, LBlock and SIMON and presentation of our results. The presence of a \\* mentions if the current attack is the best known attack against the target cipher. Note here that we provide only the best of our results with respect to the time complexity. Other trade-offs can be found in the following sections.  <span class="math">\\dagger</span>  see Section 4.1 for details.</p>

    <p class="text-gray-300">The rest of the paper is organized as follows. In Section 2 we present a generic methodology for mounting impossible differential attacks, provide our complexity formulas and show new techniques and improvements for attacking a Feistel-like block cipher using impossible differential cryptanalysis. Section 3 is dedicated to the details of our attacks on CLEFIA and Section 4 presents our applications to all versions of Camellia. Finally, our attacks on the other ciphers can be found in Appendix A and B.</p>

    <p class="text-gray-300">We provide in this section a comprehensive complexity analysis of impossible differential attacks against block ciphers as well as some new ideas that help improving the time and data complexities. We derive in this direction new generic formulas for the complexity evaluation of such attacks. The role of these formulas is twofold; on the one hand we aim at clarifying the attack procedure by rendering it as general as possible and on the other hand help at optimizing the time and data requirements. Establishing generic formulas should help mounting as well as verifying such attacks by avoiding the use of complicated procedures often leading to mistakes.</p>

    <p class="text-gray-300">An impossible differential attack consists mainly of two general steps. The first one deals with the discovery of a maximum-length impossible differential, that is an input difference  <span class="math">\\Delta_X</span>  and an output difference  <span class="math">\\Delta_Y</span>  such that the probability that  <span class="math">\\Delta_X</span>  propagates after a certain number of rounds,  <span class="math">r_{\\Delta}</span> , to  <span class="math">\\Delta_Y</span>  is zero. The second step, called the key sieving phase, consists in the addition of some rounds to potentially both directions. These extra added rounds serve to verify which key candidates partially encrypt (resp. decrypt) data to the impossible differential. As this impossible differential is of probability zero, keys showing such behavior are clearly not the right encryption key and are thus removed from the candidate keys space.</p>

    <p class="text-gray-300">We start by introducing the notation that will be used in the rest of the paper. As in this work we are principally interested in the key sieving phase, we start our attack after a maximum impossible differential has been found for the target cipher.</p>

    <p class="text-gray-300">The differential  <span class="math">(\\varDelta_X\\rightarrow\\varDelta_{in})</span>  (resp.  <span class="math">(\\varDelta_Y\\rightarrow\\varDelta_{out})</span> ) occurs with probability 1 while the differential  <span class="math">(\\varDelta_X\\leftarrow\\varDelta_{in})</span>  (resp.  <span class="math">(\\varDelta_Y\\leftarrow\\varDelta_{out})</span> ) is verified with probability  <span class="math">\\frac{1}{2^{c_{in}}}</span>  (resp.  <span class="math">\\frac{1}{2^{c_{out}}}</span> ), where  <span class="math">c_{in}</span>  (resp.  <span class="math">c_{out}</span> ) is the number of bit-conditions that have to be verified to obtain  <span class="math">\\varDelta_X</span>  from  <span class="math">\\varDelta_{in}</span>  (resp.  <span class="math">\\varDelta_Y</span>  from  <span class="math">\\varDelta_{out}</span> ).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">It is important to correctly determine the number of key bits intervening during an attack. We call this quantity information key bits. In an impossible differential attack, one starts by determining all the subkey bits that are involved in the attack. We denote by  <span class="math">k_{in}</span>  the subset of subkey bits involved in the attack during the first  <span class="math">r_{in}</span>  rounds, and  <span class="math">k_{out}</span>  during the last  <span class="math">r_{out}</span>  ones. However, some of these subkey bits can be related between them. For example, two different subkey bits can actually be the same bit of the master key. Alternatively, a bit in the set can be some combination, or can be easily determined by some other bits of the set. The way that the different key bits in the target set are related is determined by the key schedule. The actual parameter that we need to determine for computing the complexity of the attacks is the information key bits intervening in total, that is from an information theoretical point of view, the log of the entropy of the involved key bits, that we denote by  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in} \\cup k_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\Delta_{X}, \\Delta_{Y}</span> : input (resp. output) differences of the impossible differential.</li>

      <li><span class="math">r_{\\Delta}</span> : number of rounds of the impossible differential.</li>

      <li><span class="math">\\Delta_{in}</span> ,  <span class="math">\\Delta_{out}</span> : set of all possible input (resp. output) differences of the cipher.</li>

      <li><span class="math">r_{in}</span> : number of rounds of the differential path  <span class="math">(\\Delta_X, \\Delta_{in})</span> .</li>

      <li><span class="math">r_{out}</span> : number of rounds of the differential path  <span class="math">(\\Delta_Y, \\Delta_{out})</span> .</li>

    </ul>

    <p class="text-gray-300">We continue now by describing our attack scenario on  <span class="math">(r_{in} + r_{\\Delta} + r_{out})</span>  rounds of a given cipher.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose that we are dealing with a block cipher of block size  <span class="math">n</span>  parametrized by a key  <span class="math">K</span>  of size  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Let the impossible differential be placed between the rounds  </span>(r_{in} + 1)<span class="math">  and  </span>(r_{in} + r_{\\Delta})<span class="math"> . As already said, the impossible differential implies that it is not feasible that an input difference  </span>\\Delta_X<span class="math">  at round  </span>(r_{in} + 1)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">propagates to an output difference <span class="math">\\Delta_{Y}</span> at the end of round <span class="math">(r_{in}+r_{\\Delta})</span>. Thus, the goal is, for each given pair of inputs (and their corresponding outputs), to discard the keys that generate a difference <span class="math">\\Delta_{X}</span> at the beginning of round <span class="math">(r_{in}+1)</span> and at the same time, a difference <span class="math">\\Delta_{Y}</span> at the output of round <span class="math">(r_{in}+r_{\\Delta})</span>. We need then enough pairs so that the number of non-discarded keys is significantly lower than the a priori total number of key candidates.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose that the first <span class="math">r_{in}</span> rounds have an input truncated difference in <span class="math">\\Delta_{in}</span> and an output difference <span class="math">\\Delta_{X}</span>, which is the input of the impossible differential. Suppose that there are <span class="math">c_{out}</span> bit-conditions that need to be verified so that <span class="math">\\Delta_{in}</span> propagates to <span class="math">\\Delta_{X}</span> and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ information key bits involved.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In a similar way, suppose that the last <span class="math">r_{out}</span> rounds have a truncated output difference in <span class="math">\\Delta_{out}</span> and an input difference <span class="math">\\Delta_{Y}</span>, which is the output of the impossible differential. Suppose that there are <span class="math">c_{out}</span> bit-conditions that need to be verified so that <span class="math">\\Delta_{out}</span> propagates to <span class="math">\\Delta_{Y}</span> in the backward direction and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ information key bits involved.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We show next how to determine the amount of data needed for an attack.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">2.2 Data complexity</h3>

    <p class="text-gray-300">The probability that for a given key, a pair of inputs already satisfying the differences <span class="math">\\Delta_{in}</span> and <span class="math">\\Delta_{out}</span> verifies all the <span class="math">(c_{in}+c_{out})</span> bit-conditions is <span class="math">2^{-(c_{in}+c_{out})}</span>. In other words, this is the probability that for a pair of inputs having a difference in <span class="math">\\Delta_{in}</span> and an output difference in <span class="math">\\Delta_{out}</span>, a key from the possible key set is discarded. Therefore, by repeating the procedure with <span class="math">N</span> different input (or output) pairs, the probability that a trial key is kept in the candidate keys set is <span class="math">P=(1-2^{-(c_{in}+c_{out})})^{N}</span>.</p>

    <p class="text-gray-300">There is not a unique strategy for choosing the amount of input (or output) pairs <span class="math">N</span>. This choice principally depends on the overall time complexity, which is influenced by <span class="math">N</span>, and the induced data complexity. Different trade-offs are therefore possible. A popular strategy, generally used by default is to choose <span class="math">N</span> such that only the right key is left after the sieving procedure. This amounts to choose <span class="math">P</span> as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$P=(1-2^{-(c_{in}+c_{out})})^{N}<\\frac{1}{2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in}\\cup k_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In this paper we adopt a different approach that can help reducing the number of pairs needed for the attack and offers better trade-offs between the data and time complexity. More precisely, we permit smaller values of <span class="math">N</span>. By proceeding like this, we will be probably left with more than one key in our candidate keys set and we will need to proceed to an exhaustive search among the remaining candidates, but the total time complexity of the attack will probably be much lower. In practice, we will start considering values of <span class="math">N</span> such that <span class="math">P</span> is slightly smaller than <span class="math">\\frac{1}{2}</span> so to reduce the exhaustive search by at least one bit. The smallest value of <span class="math">N</span>, denoted by <span class="math">N_{\\min}</span>, verifying</p>

    <p class="text-gray-300"><span class="math">P=(1-2^{-(c_{in}+c_{out})})^{N_{\\min}}\\simeq e^{-N_{\\min}\\times 2^{-(c_{in}+c_{out})}}&lt;\\frac{1}{2}</span></p>

    <p class="text-gray-300">is approximately <span class="math">N_{\\min}=2^{c_{in}+c_{out}}</span>. Then we have to choose <span class="math">N\\geq N_{\\min}</span>.</p>

    <p class="text-gray-300">We provide now a solution for determining the cost of obtaining <span class="math">N</span> pairs such that their input difference belongs to <span class="math">\\Delta_{in}</span> and their output difference belongs to <span class="math">\\Delta_{out}</span>. To the best of our knowledge, this is the first generic solution to this problem.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Finding <span class="math">N</span> pairs verifying a given truncated differential.</h4>

    <p class="text-gray-300">Gilbert and Peyrin gave in <em>[16]</em> a solution to the so-called limited birthday problem that searches for a pair of inputs whose difference lies in an input space <span class="math">\\Delta_{in}</span> and whose output (ciphertext) difference lies in an output space <span class="math">\\Delta_{out}</span> (see Figure 1). According to this solution, prooved in <em>[18]</em>, the cost for finding one such pair is given by</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$C_{1}=\\max\\left\\{\\min_{\\Delta\\in\\{\\Delta_{in},\\Delta_{out}\\}}\\left\\{\\sqrt{2^{n+1-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}\\right\\},2^{n+1-(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}\\right\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 1. A pair of inputs to the encryption function can differ in the subspace <span class="math">\\Delta_{in}</span> and the difference of the ciphertext values can lie in the subspace <span class="math">\\Delta_{out}</span>.</p>

    <p class="text-gray-300">In our attack we search for a solution to a generalization of this problem, i.e. we want to determine the cost of finding not just one but <span class="math">N</span> pairs lying in the given input and output spaces <span class="math">\\Delta_{in}</span> and <span class="math">\\Delta_{out}</span>. A direct way to treat this problem would be to estimate this cost by <span class="math">N \\times C_1</span>. However, this solution is not always optimal. In particular, as we will explain in a while, when the input space <span class="math">\\Delta_{in}</span> is relatively large, the number of inputs that we will need, which determines the data complexity of the attack and at the same time the cost for constructing <span class="math">N</span> pairs, can be lower than <span class="math">N \\times C_1</span>. We denote, the number of necessary inputs as <span class="math">C_N</span>, as this quantity corresponds equally to the cost of constructing <span class="math">N</span> pairs.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We can distinguish between two cases, depending on the dimension of the input space, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, the dimension of the output space, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and the value of </span>N<span class="math">. More precisely, the cost for constructing </span>N$ pairs will depend on the value of</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac {2 ^ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_ {i n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} 2 ^ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_ {i n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}}{2 ^ {n -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_ {o u t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">compared to <span class="math">N</span>. The quantity $2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}<span class="math"> corresponds to the number of pairs that can be constructed if the values in </span>\\Delta_{in}<span class="math"> can take all possible values. On the other hand, the quantity </span>n -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> stands for the size of the partial collision, as we permit the output of these pairs to vary only in the subspace </span>\\Delta_{out}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- If $N \\leq \\frac{2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} 2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}}{2^{n -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}<span class="math">, this means that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is large enough to allow us to build </span>C_N<span class="math"> inputs belonging to the same structure (</span>C_N \\leq 2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">). For the sake of clarity, we define a structure, as the set of inputs that can take all possible values in the subspace </span>\\Delta_{in}<span class="math"> and whose remaining </span>n -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> bits are fixed to a constant value. Therefore </span>N = \\frac{C_N \\cdot C_N / 2}{2^{n -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}<span class="math">, which means that we need </span>C_N = \\sqrt{N 2^{n -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1}}$ inputs.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Otherwise, if $N &gt; \\frac{2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} 2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}}{2^{n -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}<span class="math"> which means that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is not large enough, we will need to consider several structures of size </span>2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. Let </span>2^y<span class="math"> be the number of these extra structures chosen in a way that </span>N = 2^y \\frac{2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} 2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}}{2^{n -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}$. The number of inputs is in this case given by:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C _ {N} = 2 ^ {y} 2 ^ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_ {i n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} = N 2 ^ {n -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_ {o u t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_ {i n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">By taking all of this into account together with the fact that we are dealing with a permutation (having thus a symmetry in both directions) and by considering the attacker to be able to choose the ciphertexts as well as the plaintexts, we can conclude that the cost of obtaining the <span class="math">N</span> pairs will be:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C _ {N} = \\max  \\left\\{\\min  _ {\\Delta \\in \\left\\{\\Delta_ {i n}, \\Delta_ {o u t} \\right\\}} \\left\\{\\sqrt {N 2 ^ {n + 1 -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}} \\right\\}, N 2 ^ {n + 1 -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_ {i n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_ {o u t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\right\\}. \\tag {1}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We can observe thus that we gain a factor of <span class="math">\\sqrt{N}</span> in the first of the two above cases compared to the trivial solution of taking <span class="math">C_N = N \\times C_1</span>. As we've already mentioned the cost <span class="math">C_N</span> represents the amount of data needed for the attack. Obviously, as the size of the state is equal to <span class="math">n</span>, the following inequality, should hold:</p>

    <div class="my-4 text-center"><span class="math-block">C _ {N} \\leq 2 ^ {n}.</span></div>

    <p class="text-gray-300">This inequality simply states that the total amount of data used for the attack cannot exceed the codebook. These conditions are not verified in several cases from <em>[4]</em>, as well as in the corrected version of <em>[40]</em> which invalidates the corresponding attacks.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.3 Time and memory complexity</h3>

    <p class="text-gray-300">We are going to detail now the computation of the time complexity of the attack. Note that the formulas that we are presenting in this section are the first generic formulas given for estimating the complexity of impossible differential attacks.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By following the early abort technique <em>[24]</em>, the attack consists in storing the <span class="math">N</span> pairs and testing out step by step the key candidates, by reducing at each time the size of the remaining possible pairs. The time complexity is then determined by three quantities. The first term is the cost <span class="math">C_{N}</span>, that is the amount of needed data (see Formula (1)) for obtaining the <span class="math">N</span> pairs, where <span class="math">N</span> is such that <span class="math">P&lt;1/2</span>. The second term corresponds to the number of candidate keys $2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in}\\cup k_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">, multiplied by the average cost of testing the remaining pairs. For all the applications that we have studied, this cost can be very closely approximated by</span>\\big{(}N+2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in}\\cup k_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\frac{N}{2^{c_{in}+c_{out}}}\\big{)}\\,C_{E}^{\\prime}<span class="math">, where </span>C_{E}^{\\prime}<span class="math"> is the ratio of the cost of partial encryption to the full encryption. Finally, the third term is the cost of the exhaustive search for the key candidates still in the candidate keys set after the sieving. By taking into account the cost of one encryption </span>C_{E}$, we conclude that the time complexity of the attack is</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$T_{comp}=\\left(C_{N}+\\left(N+2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in}\\cup k_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\frac{N}{2^{c_{in}+c_{out}}}\\right)C_{E}^{\\prime}+2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}P\\right)C_{E},$ (2)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where $C_{N}=\\max\\left\\{\\min_{\\Delta\\in\\{\\Delta_{in},\\Delta_{out}\\}}\\left\\{\\sqrt{N2^{n+1-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}\\right\\},N2^{n+1-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right\\}<span class="math">, with </span>N<span class="math"> such that </span>P=(1-1/(2^{c_{in}+c_{out}}))^{N}<1/2<span class="math"> and where the last term corresponds to </span>2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in}\\cup k_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}P2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in}\\cup k_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. Obviously, as we want the attack complexity to be smaller than the exhaustive search complexity, the above quantity should be smaller than </span>2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}C_{E}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It must be noted here that this is a minimum estimation of the complexity, that, in practice, and thanks to the idea of Section 2.4, it approximates really well the actual time complexity, as it can be seen in the applications, and in particular, in the tight correspondance shown between the LBlock estimation that we detail in Appendix B and the exact calculation from <em>[13]</em>. The precise evaluation of <span class="math">C_{E}^{\\prime}</span> (that is always smaller than 1) can only be done once the attack parameters are known. However, <span class="math">C_{E}^{\\prime}</span> can be estimated quite easily by calculating the ratio between the active SBoxes during a partial encryption and the total number of SBoxes (thought it is not always the best approximation, it is a common practice).</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">Memory complexity.</h4>

    <p class="text-gray-300">By using the early abort technique <em>[24]</em>, the only elements that need to be stored are the <span class="math">N</span> pairs. Therefore, the memory complexity of the attack is determined by <span class="math">N</span>.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">2.4 Choosing <span class="math">\\bm{\\Delta_{in}},\\bm{\\Delta_{out}},c_{in}</span> and <span class="math">c_{out}</span>.</h3>

    <p class="text-gray-300">We explain now, the two possible ways for choosing <span class="math">\\Delta_{in},\\Delta_{out},c_{in}</span> and <span class="math">c_{out}</span>. For this, we introduce the following example that can be visualized in Figure 2 and where we consider an Sbox-based cipher. In this example, we will only talk about <span class="math">\\Delta_{in}</span> and <span class="math">c_{in}</span>, however the approach for <span class="math">\\Delta_{out}</span> and <span class="math">c_{out}</span> is identical.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose that the state is composed of two branches of four nibbles each. The round function is composed of a non-linear layer <span class="math">S</span>, seen as a concatenation of four Sboxes <span class="math">S_{0},S_{1},S_{2}</span> and <span class="math">S_{3}</span>, followed by a linear layer <span class="math">M</span>. There exist two different ways for choosing $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>c_{in}$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. The most intuitive way is to consider $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=4+4<span class="math"> and </span>c_{in}=4<span class="math">, as the size of </span>\\alpha<span class="math"> and of </span>\\beta<span class="math"> is 4 bits, and in the first round we want 4 bits to collide. In this case, for a certain key, the average probability that a pair taken out of the </span>2^{4+4}2^{4+4-1}<span class="math"> pairs belonging to </span>\\Delta_{in}<span class="math"> leads to </span>\\Delta_{X}<span class="math"> is </span>2^{-4}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 2. Choosing  <span class="math">\\Delta_{in}</span>  and  <span class="math">c_{in}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. In general, the difference  <span class="math">\\alpha</span>  can take  <span class="math">2^{4} - 1</span>  different values. However, each value can be associated by the differential distribution table of the Sbox  <span class="math">S_{0}</span>  to  <span class="math">2^{3}</span>  output differences on average <span class="math">^{5}</span> , so the possibilities for the difference  <span class="math">\\beta</span>  are limited to  <span class="math">2^{3}</span> . Therefore, we can consider that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx 4 + 3<span class="math"> . But, in this case  </span>c_{in} = 3<span class="math"> , as for each input pair belonging to the  </span>2^{4 + 3}2^{4 + 3 - 1}<span class="math">  possible ones, there exist on average 2 values that make the differential transition  </span>\\alpha \\rightarrow \\beta$  possible (instead of 1 in the previous case).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We can see, by using the generic formulas provided in Section 2.3, that both cases induce practically the same time complexity, as the difference in  <span class="math">N</span>  compensates with the difference in  <span class="math">c_{in} + c_{out}</span> . However, the memory complexity, given by  <span class="math">N</span> , is slightly better in case 2. Furthermore, case 2, in which a preliminary filtering of the pairs is done, allows to reduce the average cost of using the early abort technique [24].</p>

    <p class="text-gray-300">In several papers, for example in [37] and [24], the second case is followed. However, its application is partial (either for the input or the output part) and this with no apparent reason. Note however, that in these papers, the associated  <span class="math">c_{out}</span>  was not always correctly computed and sometimes, 8-bit conditions were considered when 7-bit conditions should have been accounted for. For reasons of simplicity, we will consider case 1 in our applications and check afterwards the actual memory needed.</p>

    <p class="text-gray-300">We explain in this section a method to reduce the data complexity of an attack. This method is inspired by the notion of multiple impossible differentials that was introduced by Tsunoo et al. [35] and applied to 12-round CLEFIA-128. The idea in this technique is to consider simultaneously several impossible differentials, instead of taking just one. We assume, as done in [16], that the differences in  <span class="math">\\Delta_{in}</span>  (and in  <span class="math">\\Delta_{out}</span> ) lie in a closed set. We can mention two ways in which this can be a priori done:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Take rotated versions of a certain impossible differential. We call  <span class="math">n_{in}</span>  the number of different input pattern differences generated by the rotated versions of the chosen impossible differential.</li>

      <li>When the middle conditions have several impossible combinations, we can consider the same first half of the differential path together with a rotated version of the second one, in a way to get a different impossible differential. We call  <span class="math">n_{out}</span>  the number of different output pattern differences generated by the rotated versions of the second part of the path that we will consider. For the sake of simplicity and without loss of generality we will only consider the case of rotating the second half of the path.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">It is important to point out that for our analysis to be valid, in both cases the number of conditions associated to the impossible differential attack should stay the same. Both cases can be translated into a higher amount of available data by redefining two quantities,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{out}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , that will take the previous roles of  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ ,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_ {i n} ^ {\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_ {i n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\log_ {2} (n _ {i n}) \\mathrm {a n d}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_ {o u t} ^ {\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_ {o u t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\log_ {2} (n _ {o u t}).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varDelta_{in}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is the log of the total size of the set of possible input differences, and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varDelta_{out}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  is the log of the total size of the set of possible output differences.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this case, the data complexity <span class="math">C_{N}</span> is computed with the corrected values for the input sizes and is, as can be easily seen, smaller than if only one path had been used. The time complexity remains the same, except for the <span class="math">C_{N}</span> term. Indeed, the middle term of Formula (2) remains the same, as for a given pair, the number of key bits involved stays $2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in}\\cup k_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. Equally, as the number of partial possible keys involved in the attack is </span>n_{in}n_{out}2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in}\\cup k_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$, the last term of Formula (2) is now</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\frac{2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}{n_{in}\\cdot n_{out}2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in}\\cup k_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}(P\\cdot n_{in}\\cdot n_{out}\\cdot 2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in}\\cup k_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})=2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}P$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and so also stays the same.</p>

    <p class="text-gray-300">In Section 3 we present our attacks on CLEFIA. In part of these attacks, we use multiple impossible differentials to reduce the data complexity. Besides, this technique shows particularly useful for mounting attacks on some versions of the Simon family for which there is not enough available data to mount a valid attack with the traditional method.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">2.6 Introducing the state-test technique</h3>

    <p class="text-gray-300">We introduce now a new method that consists in making a test for some part of the internal state instead of guessing the necessary key bits for computing it. This somewhat reminds the techniques presented in <em>[15, 17]</em> in the context of meet-in-the-middle attacks. However, the technique that we present in this section, and that we call the state-test technique is different since it consists in checking the values of the internal state to verify if we can discard all the involved candidates.</p>

    <p class="text-gray-300">Very often during the key filtering phase of impossible differential attacks, the size of the internal state that needs to be known is smaller than the number of key bits on which it depends. As we will see, focusing on the values that a part of the state can take permits to eliminate some key candidates without considering all the values for the involved key bits. The state-test technique works by fixing <span class="math">s</span> bits of the plaintexts, something which allows us to reduce the number of information key bits by <span class="math">s</span>. We will explain how this method works by a small example.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider a 32-bit Feistel construction, where each branch can be seen as a concatenation of four nibbles (see Figure 3). Suppose that the round function is composed of a non-linear layer <span class="math">S</span>, seen as a concatenation of four 4-bit invertible Sboxes <span class="math">(S_{0},S_{1},S_{2},S_{3})</span> and of a linear layer <span class="math">M</span> on <span class="math">\\mathbb{F}_{2^{4}}</span>. We suppose for this example that the branch number of <span class="math">M</span>, that is the minimal number of active Sboxes in any two consecutive rounds, is less than 5. Let $\\Delta_{X}=(\\alpha,0,0,0)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(0,0,0,0)<span class="math"> be the input difference of the impossible differential, placed at the end of the second round and let </span>\\Delta_{in}=(<em>,</em>,*,0)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(<em>,</em>,<em>,</em>)<span class="math"> be the difference at the input of the block cipher. Note however that in reality, the leftmost side of </span>\\Delta_{in}<span class="math"> only depends on a 4-bit non-zero difference </span>\\delta<span class="math">, i.e. </span>\\Delta_{in}=M(\\delta,0,0,0)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(<em>,</em>,<em>,</em>)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As can be seen in Figure 3, there are in total 4 active Sboxes and thus there are <span class="math">c_{in}=16</span> conditions that have to be verified in order to have a transition from <span class="math">\\Delta_{in}</span> to <span class="math">\\Delta_{X}</span>. Therefore, the first step is to collect <span class="math">N</span> pairs such that <span class="math">P=(1-2^{-(c_{in}+c_{out})})^{N}=(1-2^{-c_{in}})^{N}=(1-2^{-16})^{N}&lt;\\frac{1}{2}</span>. The exact value of <span class="math">N</span> will be chosen in a way to obtain the best trade-off for the complexities. Before describing the new method, we start by explaining how this attack would have worked in the classical way. As we can see in Figure 3, there are <span class="math">3\\times 4</span> bits that have to be guessed (<span class="math">K_{0,0}</span>, <span class="math">K_{0,1}</span> and <span class="math">K_{0,2}</span>) in order to verify the conditions on the first round and there are <span class="math">2\\times 4</span> bits that have to be guessed (<span class="math">K_{0,3}</span> and <span class="math">K_{1,0}</span>) in order to verify the conditions on the second round. Therefore, for all <span class="math">N</span> pairs, one starts by testing all the <span class="math">2^{4}</span> possible values for the first nibble of <span class="math">K_{0}</span>. After this first guess, <span class="math">N\\times 2^{-4}</span> pairs remain in average, as there are 4-bit conditions that need to be verified by the guess through the first round. Then one continues by testing the second and the third nibble of <span class="math">K_{0}</span> and finally the last nibble of <span class="math">K_{0}</span> and the first nibble of <span class="math">K_{1}</span>. At each step, the amount of data remaining is divided by <span class="math">2^{4}</span>. To summarize, we have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in}\\cup k_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=20<span class="math"> and </span>2^{c_{in}+c_{out}}=2^{c_{in}}=2^{4}2^{4}2^{4}2^{4}$. Then Formula (2) can be used to evaluate the time complexity of the attack as</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left(C_{N}+\\left(N+2^{20}\\frac{N}{2^{16}}\\right)C_{E}^{\\prime}+2^{20}P2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-20}\\right)C_{E}.$ (3)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Figure 3: Grey color stands for nibbles with non-zero difference. Hatched key nibbles correspond to the part of the subkeys that have to be guessed. The nibble <span class="math">x</span> is the part of the state on which we apply the state-test technique.</p>

    <p class="text-gray-300">We will see now how the state-test technique applies to this example and how it permits to decrease the time complexity. Consider the first nibble of the left part of the state after the addition of the subkey <span class="math">K_{1}</span>. We denote this nibble by <span class="math">x</span>. Note that mathematically, <span class="math">x</span> can be expressed as</p>

    <p class="text-gray-300"><span class="math">x=K_{1,0}\\oplus P_{1,0}\\oplus M(S(K_{0}\\oplus P_{0}))_{0}</span> <span class="math">x\\oplus P_{1,0}=K_{1,0}\\oplus m_{0}S_{0}(K_{0,0}\\oplus P_{0,0})\\oplus m_{1}S_{1}(K_{0,1}\\oplus P_{0,1})\\oplus m_{2}S_{2}(K_{0,2}\\oplus P_{0,2})\\oplus m_{3}S_{3}(K_{0,3}\\oplus P_{0,3}),</span> (4)</p>

    <p class="text-gray-300">where the <span class="math">m_{i}</span>’s are coefficients in <span class="math">\\mathbb{F}_{2}^{4}</span>.</p>

    <p class="text-gray-300">Suppose now that for all pairs, we fix the last <span class="math">s=4</span> bits of <span class="math">P_{0}</span> to the same constant value. One can verify that this is a reasonable assumption, as by fixing this part of the inputs we still have enough data to mount the attack. Then one starts as before, by guessing the first three nibbles of <span class="math">K_{0}</span>. After this 12-bit guess, approximately <span class="math">N\\times 2^{-12}</span> pairs remain. We know for each pair the input and output differences of the Sbox of the second round as the needed part of <span class="math">K_{0}</span> has been guessed. Therefore, by a simple lookup at the differential distribution table of the involved Sbox, we obtain one value for <span class="math">x</span> that verifies the second round conditions in average per pair (about half of the time the transition is not possible, whereas for the other half we find two values). Equation (4) becomes</p>

    <p class="text-gray-300"><span class="math">x\\oplus P_{1,0}\\oplus m_{0}S_{0}(K_{0,0}\\oplus P_{0,0})\\oplus m_{1}S_{1}(K_{0,1}\\oplus P_{0,1})\\oplus m_{2}S_{2}(K_{0,2}\\oplus P_{0,2})=K_{1,0}\\oplus m_{3}S_{3}(K_{0,3}\\oplus P_{0,3}),</span> (5)</p>

    <p class="text-gray-300">where the left side of Equation (5), that we denote by <span class="math">x^{\\prime}</span>, is known for each pair.</p>

    <p class="text-gray-300">Thus, for each guess of <span class="math">(K_{0,0},K_{0,1},K_{0,2})</span>, we construct a table of size <span class="math">N\\times 2^{-12}</span>, where we store these values of <span class="math">x^{\\prime}</span>. The last and more important step consists now in looking if all <span class="math">2^{4}</span> possible values of <span class="math">x^{\\prime}</span> appear in the table. Note here, that as <span class="math">N\\geq 2^{16}</span>, the size of the table is necessarily greater than or equal to <span class="math">2^{4}</span>.</p>

    <p class="text-gray-300">Since <span class="math">P_{0,3}</span> is fixed, the only unknown values in Equation (5) are <span class="math">K_{1,0}</span> and <span class="math">K_{0,3}</span>. If all values for <span class="math">x^{\\prime}</span> are in the table and since <span class="math">S_{3}</span> is a permutation, for any choice of <span class="math">K_{1,0}</span> and any choice of <span class="math">K_{0,3}</span>, there will always exist (at least) one pair such that <span class="math">K_{1,0}\\oplus m_{3}S_{3}(K_{0,3}\\oplus P_{0,3})</span> is in the table, leading thus to the impossible differential. As a conclusion, we know that if <span class="math">x^{\\prime}</span> takes all the possible values in the table, we can remove the keys composed by the guessed value <span class="math">(K_{0,0},K_{0,1},K_{0,3})</span> from the candidate keys set, as for all the values of <span class="math">(K_{1,0},K_{0,3})</span>, they would imply the impossible differential. If instead, <span class="math">x^{\\prime}</span> does not take all the possible values for a certain value of <span class="math">(K_{0,0},K_{0,1},K_{0,3})</span>, we can test this partial key combined to all the possibilities of the remaining key bits that verify Equation (5) for the missing <span class="math">x^{\\prime}</span>, as they belong to the remaining key candidates.</p>

    <p class="text-gray-300">The main gain of the state-test technique is that it decreases the number of information key bits and therefore the time complexity. For instance, in this example, the variable <span class="math">x^{\\prime}</span> can be seen as 4 information</p>

    <p class="text-gray-300">key bits instead of <span class="math">2\\times 4</span> key bits we had to guess in the classic approach (the bits of <span class="math">K_{0,3}</span> and of <span class="math">K_{1,0}</span>). We have <span class="math">s=4</span> less bits to guess thanks to the <span class="math">s=4</span> bits of the plaintext that we have fixed. Thus the time complexity in this case becomes</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left(C_{N}+\\left(N+2^{20-4}\\frac{N}{2^{16}}\\right)C_{E}^{\\prime}+2^{20-4}P2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-(20-4)}\\right)C_{E}.$ (6)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">One can see now by comparing Equations (6) and (3) that the time complexity is lower with the state-test technique, than with the trivial method. Indeed, the first and the third term of the Equations (6) and (3) remain the same, while the second term is lower in Equation (6). Finally, note that the probability <span class="math">P</span> for a key to be still in the candidate keys set remains the same as before. Indeed, during the attack we detect all and the same candidate keys for which none of the <span class="math">N</span> pairs implies the impossible differential, which are the same candidate keys that we would have detected in a classic attack.</p>

    <p class="text-gray-300">We would like to note here that we have implemented the state-test technique on a toy cipher, having a structure similar to the one that we introduced in this section, and we have verified its correcteness.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">Application of the state-test technique in parallel for decreasing the probability <span class="math">P</span>.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">An issue that could appear with this technique is that as we have to fix a part of the plaintexts, <span class="math">s</span> bits, the amount of data available for computing the <span class="math">N</span> pairs is reduced. The probability <span class="math">P</span> associated to an attack is the probability for a key to remain in the candidate keys set. When the amount of available data is small, the number of pairs <span class="math">N</span> that we can construct is equally small and thus the probability <span class="math">P</span> is high. In such a situation, the dominant term of the time complexity (Formula (2)), is in general the third one, i.e. $2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}P$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">More precisely, we need the sum of <span class="math">\\log_{2}(C_{N})</span> and <span class="math">s</span>, the number of plaintext bits that we fix, to be less than or equal to the block size. This limits the size of <span class="math">N</span> that we can consider, leading to higher probabilities <span class="math">P</span>, and could lead, sometimes, to higher time complexities. To avoid this, one can repeat the attack in parallel for several different values, say <span class="math">Y</span>, of the fixed part of the plaintext. In this case, the data and memory needed are multiplied by <span class="math">Y</span>. On the other hand, repeating the attack in parallel permits to detect more efficiently if a guessed key could be the right one. Indeed, for a guessed key, only if none of the tables constructed as described above contains all the values for <span class="math">x^{\\prime}</span>, one can test if this guessed key is the correct one.</p>

    <p class="text-gray-300">To summarize, by repeating the state-test technique in parallel, we multiply the available data by <span class="math">Y</span>, as well as the available pairs, and since the attack is done <span class="math">Y</span> times in parallel, the probability <span class="math">P</span> becomes <span class="math">P^{Y}</span>. The probability decreases much faster than the data or the other terms of the time complexity increase. Therefore, the Formula (2) becomes in this case:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left(C_{N}\\times Y+\\left(N\\times Y+2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in}\\cup k_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-s}\\frac{N\\times Y}{2^{c_{in}+c_{out}}}\\right)C_{E}^{\\prime}+2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}P^{Y}\\right)C_{E}.$ (7)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In Section 3, we are going to see an application of this technique to 13-round CLEFIA-128, and at the end of Section 4.1 we show an application on Camellia-256.</p>

    <h2 id="sec-13" class="text-2xl font-bold">3 Application to CLEFIA</h2>

    <p class="text-gray-300">CLEFIA is a lightweight 128-bit block cipher designed by Shirai et al. in 2007 <em>[29]</em> and based on a 4-branch generalized Feistel network. We provide here a short description of the algorithm specifications. See <em>[29]</em> for a more complete description.</p>

    <p class="text-gray-300">###</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Encryption algorithm. Denote by  $P = P_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_{3}<span class="math">  a 128-bit plaintext, where each  </span>P_{i}<span class="math"> ,  </span>i = 0,1,2,3<span class="math"> , is a 32-bit vector. Denote by  </span>C<span class="math">  be the corresponding ciphertext. CLEFIA supports keys of size 128, 192 or 256 bits and the total number of iterations, say  </span>R<span class="math"> , depends on the key size. More precisely,  </span>R = 18<span class="math">  for the 128-bit version, while  </span>R = 22<span class="math">  and  </span>R = 26<span class="math">  for the two following variants. A key-scheduling algorithm, whose description we omit, is used to generate  </span>2R<span class="math">  round keys  </span>RK_{0},\\ldots ,RK_{2R - 1}<span class="math">  and 4 whitening keys  </span>WK_{0},\\ldots ,WK_{3}$ . The encryption is performed as follows:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  $P_0^0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_1^0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_2^0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_3^0 = P_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_1\\oplus WK_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_3\\oplus WK_1$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">i = 1,2,\\ldots ,R</span>  do</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">P_0^i = F_0(P_0^{i - 1},RK_{2i - 2})\\oplus P_1^{i - 1}</span></li>

    </ul>

    <p class="text-gray-300"><span class="math">P_{1}^{i} = P_{2}^{i - 1}</span> <span class="math">P_{2}^{i} = F_{1}(P_{2}^{i - 1},RK_{2i - 1})\\oplus P_{3}^{i - 1}</span> <span class="math">P_{3}^{i} = P_{0}^{i - 1}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  $C = P_0^R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_1^R\\oplus WK_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_2^R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_3^R\\oplus WK_3.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Fig. 4. A round of CLEFIA.</p>

    <p class="text-gray-300">Round functions  <span class="math">F_0, F_1</span> . Each round of CLEFIA is composed of two 32-bit round functions  <span class="math">F_0</span>  and  <span class="math">F_1</span>  (see Figure 4) that have the same structure. The first step in the function  <span class="math">F_0</span>  (resp.  <span class="math">F_1</span> ) is an XOR between the 32-bit subkey  <span class="math">RK_{2i-2}</span>  (resp.  <span class="math">RK_{2i-1}</span> ) and  <span class="math">P_0^{i-1}</span>  (resp.  <span class="math">P_2^{i-1}</span> ). Then, two  <span class="math">8 \\times 8</span> -bit SBoxes  <span class="math">S_0</span>  and  <span class="math">S_1</span>  compose a layer which is applied to the result. Finally, the four obtained bytes are mixed by a  <span class="math">4 \\times 4</span> -byte matrix,  <span class="math">M_0</span>  (resp.  <span class="math">M_1</span> ) that has a maximal branch number, i.e. 5. A detailed description of the SBoxes  <span class="math">S_0, S_1</span>  while also the matrices  <span class="math">M_0, M_1</span>  can be found in [29].</p>

    <p class="text-gray-300">We are going to describe now an impossible differential cryptanalysis of 13-round CLEFIA-128.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The authors of [34] noticed that a difference on the internal state of CLEFIA of the form  $P^i = 0_{32}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0_{32}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0_{32}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A<span class="math">  cannot lead to a difference  </span>P^{i + 9} = 0_{32}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0_{32}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0_{32}<span class="math">  after 9 rounds, where  </span>A<span class="math">  and  </span>B<span class="math">  are 4-byte vectors for which only one byte in a different position is active (e.g.  </span>A = (\\alpha ,0_8,0_8,0_8)<span class="math">  and  </span>B = (0_{8},\\beta ,0_{8},0_{8})<span class="math"> ). We use this same 9-round impossible differential and place it between rounds 3 and 11. Therefore, for our attack,  </span>r_{in} = r_{out} = 2<span class="math">  and  </span>r_{\\Delta} = 9$ , as in [25].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Fig. 5. The attack on CLEFIA-128. Grey color stands for bytes with a non-zero difference, while hatched bytes are the subkey bytes that have to be guessed.</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a></p>

    <p class="text-gray-300">The differential placed on the top and at the bottom of the impossible differential are depicted in Figure 5. We describe now the parameters for our cryptanalysis of 13-round CLEFIA-128. As can be seen</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">in Figure 5 there are <span class="math">c_{in}+c_{out}=40+40</span> bit-conditions that need to be verified so that the difference in the plaintexts $\\Delta_{in}=0_{32}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(*_{8},0_{8},0_{8},0_{8})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M_{0}(*_{8},0_{8},0_{8},0_{8})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{*_{32}}<span class="math"> propagates to </span>\\Delta_{X}=0_{32}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0_{32}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0_{32}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\alpha,0_{8},0_{8},0_{8})<span class="math"> and the difference in the ciphertexts </span>\\Delta_{out}=0_{32}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(0_{8},*_{8},0_{8},0_{8})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M_{1}(0_{8},*_{8},0_{8},0_{8})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{*_{32}}<span class="math"> propagates to </span>\\Delta_{Y}=0_{32}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0_{32}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(0_{8},\\beta,0_{8},0_{8})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0_{32}<span class="math">. In this way, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=48$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Following the complexity analysis of Section 2, we need to construct at least <span class="math">N_{\\min}=2^{80}</span> pairs whose input difference is in <span class="math">\\Delta_{in}</span> and whose output difference is in <span class="math">\\Delta_{out}</span>. The cost to construct these pairs is</p>

    <p class="text-gray-300"><span class="math">C_{N_{\\min}}=\\max\\left\\{\\sqrt{2^{80}2^{129-48}},2^{80}2^{129-48-48}\\right\\}=2^{113}.</span></p>

    <h5 id="sec-16" class="text-base font-semibold mt-4">Using the state-test technique</h5>

    <p class="text-gray-300">We use now the state-test technique, described in Section 2.6 to test the 8 bits of the internal state denoted by <span class="math">x</span> in Figure 5, instead of guessing the whole subkey <span class="math">RK_{0}</span> and the XOR of the leftmost byte of <span class="math">RK_{2}</span> and <span class="math">WK_{0}</span>. For doing this, we need to fix part of the 32 leftmost bits of the plaintexts. As the number of needed data is <span class="math">C_{N_{\\min}}=2^{113}</span>, we can fix at most <span class="math">128-113=15</span> bits. However, as each Sbox is applied to 8 bits, we will only fix one byte of this part of the plaintexts. We will guess then 24 bits of the subkey <span class="math">RK_{0}</span> which are situated on the other bytes.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">During a classical attack procedure, we would need to guess 32 bits of <span class="math">RK_{1}</span>, 32 bits of <span class="math">RK_{0}</span> and 8 bits of <span class="math">RK_{2}\\oplus WK_{0}</span>, thus <span class="math">k_{in}=72</span>. We would also need to guess 8 bits of <span class="math">RK_{23}\\oplus WK_{2}</span>, 32 bits of <span class="math">RK_{24}</span> and 32 bits of <span class="math">RK_{25}</span>, therefore <span class="math">k_{out}=72</span>. However, the subkeys <span class="math">RK_{1}</span> and <span class="math">RK_{24}</span> share 22 bits in common. As a consequence, the number of information key bits would be $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in}\\cup k_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=72+72-22=122<span class="math">. As we will fix 8 bits of the plaintexts, with respect to Section 2 on the state-test technique, it is the same to say that there will be </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in}\\cup k_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-8=122-8=114$ bits to test. The time complexity of our attack, computed using Formula (2) is then</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\left(C_{N}+\\left(N+2^{114}\\frac{N}{2^{80}}\\right)\\frac{18}{104}+2^{128}P\\right)C_{E},</span></p>

    <p class="text-gray-300">where the fraction 18/104 is the ratio of the cost of partial encryption to the full encryption, that we noted <span class="math">C_{E}^{\\prime}</span>. Since our attack needs at least <span class="math">2^{113}</span> plaintexts and since we fixed 8 bits out of them, we have <span class="math">128-113-8=7</span> bits of freedom for building structures. Among all the possible trade-offs with respect to the amount of data, the best time complexity we obtained is <span class="math">2^{116.90}C_{E}</span> with <span class="math">2^{83.33}</span> pairs built from <span class="math">2^{116.33}</span> plaintexts.</p>

    <h5 id="sec-17" class="text-base font-semibold mt-4">Using multiple impossible differentials</h5>

    <p class="text-gray-300">The authors of <em>[34]</em> noticed that there exist several different 9-round impossible differentials, see <em>[34, Table 1]</em>. In <em>[35]</em>, the authors used these multiple impossible differentials to attack 12 rounds of CLEFIA-128. Here, we will apply our formalized approach of this idea presented in Section 2.5, to reduce the data complexity of the attack on 13 rounds of CLEFIA-128.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We use the <span class="math">n_{in}=2\\times 4</span> different inputs to the impossible differentials, that is $P^{i}=0_{32}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0_{32}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0_{32}<span class="math"> and </span>P^{i}=0_{32}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0_{32}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0_{32}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A<span class="math">, where </span>A<span class="math"> can take a difference on only one of the four possible bytes. For each one of them, there are </span>n_{out}=3<span class="math"> different output impossible differences </span>P^{i+9}=0_{32}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0_{32}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0_{32}<span class="math"> after 9 rounds, where </span>B<span class="math"> has only one byte active in a different position than the active byte in </span>A<span class="math">. We have now </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\log_{2}(8)=48+3<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{out}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\log_{2}(3)=48+1.58<span class="math">. Since the bit-conditions remain unchanged, </span>c_{in}+c_{out}=80<span class="math">, the minimal number of pairs needed for the attack to work is </span>N_{\\min}=2^{80}<span class="math">. For this number of pairs, we need </span>C_{N_{\\min}}=2^{113-4.58}=2^{108.42}<span class="math"> plaintexts. The number of information key bits is </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in}\\cup k_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=122<span class="math">. We have then </span>\\left(C_{N}+\\left(N+2^{122}\\frac{N}{2^{80}}\\right)\\frac{18}{104}+P2^{128}\\right)C_{E}<span class="math">. Among all the possible trade-offs with respect to the amount of data, the best time complexity we obtained is </span>2^{122.26}C_{E}<span class="math"> with </span>2^{82.6}<span class="math"> pairs built from </span>2^{111.02}$ plaintexts. Recall here that the aim of this approach was to reduce data complexity. Thus, in this attack the gain on the data complexity is the important part.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h5 id="sec-18" class="text-base font-semibold mt-4">Combining the state-test technique with multiple impossible differentials</h5>

    <p class="text-gray-300">We can combine now both previous approaches in order to reduce at the same time the time and the data complexity.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We consider here only 2 out of the 3 different <span class="math">n_{out}</span> presented in the previous paragraph for one fixed first half of the impossible differential. We have now $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{out}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\log_{2}(2)=48+1<span class="math"> while </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ remains</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Since the bit-conditions remain unchanged, i.e.  <span class="math">c_{in} + c_{out} = 80</span> , the minimal number of pairs needed for the attack to work is  <span class="math">N_{\\mathrm{min}} = 2^{80}</span> . For this number of pairs, we need  <span class="math">C_{N_{\\mathrm{min}}} = 2^{113 - 1} = 2^{112}</span>  plaintexts which allow us to fix 16 bits on the plaintexts in order to use the state-test technique. Fixing 16 bits on the plaintexts means that we only have to guess 16 bits of the subkey  <span class="math">RK_0</span> .</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As we are fixing  <span class="math">s = 16</span>  bits of the plaintexts, the number of information key bits is then  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in} \\cup k_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 122 - 16 = 106$ . Then, by combining multiple impossible differentials and the state-test technique we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\left(C _ {N} + \\left(N \\times 2 ^ {7} + 2 ^ {1 0 6} \\frac {N \\times 2 ^ {7}}{2 ^ {8 0}}\\right) \\frac {1 8}{1 0 4} + P 2 ^ {1 2 8}\\right) C _ {E},</span></div>

    <p class="text-gray-300">where the second term is multiplied by  <span class="math">2^{7}</span> , which is the cost for checking the table combinations of the different output impossible differentials. If we consider  <span class="math">N = 2^{80 + 3.16}</span>  pairs, we need  <span class="math">C_N = 2^{115}</span>  plaintexts to construct them and thus the time complexity is  <span class="math">2^{116.16}C_E</span> .</p>

    <p class="text-gray-300">Camellia is a 128-bit block cipher designed by Aoki et. al. in 2000 [5]. It is a Feistel-like construction where two key-dependent layers  <span class="math">FL</span>  and  <span class="math">FL^{-1}</span>  are applied every 6 rounds to each branch. There exist three different versions of the cipher, that we note Camellia-128, Camellia-192 and Camellia-256, depending on the key size used. The number of iterations, say  <span class="math">R</span> , is  <span class="math">R = 18</span>  for the 128-bit version and  <span class="math">R = 24</span>  rounds for the other two versions. We give here a brief description of the algorithm specifications. For more details, one can refer to [5].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We briefly describe the encryption process for Camellia. A 128-bit plaintext  <span class="math">P</span>  is first XORed with the prewhitening key  $kw_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">kw_{2}$ . The encryption process, is as follows:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  $L_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R_0 = P\\oplus (kw_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">kw_2)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">i = 1,2,\\ldots ,R</span>  and  <span class="math">i\\neq 6,12,18</span>  do</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">L_{r} = R_{r - 1}\\oplus F(L_{r - 1},k_{r})</span>  ，  <span class="math">R_{r} = L_{R - 1}</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">i = 6,12</span>  and 18 do</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">L_r&#x27; = R_{r-1} \\oplus F(L_{R-1}, k_r)</span> ,  <span class="math">R_r&#x27; = L_{r-1}</span> ;</li>

      <li><span class="math">L_{r} = FL(L_{r}^{\\prime},kl_{r / 3 - 1}),R_{r} = FL^{-1}(L_{r}^{\\prime},kl_{r / 3}).</span></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  $C = (R_{24}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{24})\\oplus kw_3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">kw_4,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> Fig. 6. Round function of Camellia.</p>

    <p class="text-gray-300">where  <span class="math">kw_{3}</span>  and  <span class="math">kw_{4}</span>  are the two postwhitening keys,  <span class="math">kl_{r}</span>  are the keys parametrizing the FL-layers and  <span class="math">k_{r}</span>  are the round subkeys. The round function  <span class="math">F</span>  can be visualized in Figure 6.</p>

    <p class="text-gray-300">Previous Cryptanalysis. Camellia is since 2005 an international ISO/IEC standard and has therefore attracted a lot of attention from the cryptographic community. Since Camellia has a particular design, involving the so-called  <span class="math">FL / FL^{-1}</span>  layers, its cryptanalysis can be classified in several categories. Some attacks consider the  <span class="math">FL / FL^{-1}</span>  functions, while others do not take them into consideration. Equally, some attacks take into account the whitening keys, whereas others don't and finally all attacks do not start from the same round. The best attacks on Camellia in terms of the number of rounds and the complexities are those presented in [23, Section 4.2]. In this section we first present improvements of the best attacks that include the  <span class="math">FL / FL^{-1}</span>  layers and the whitening keys. Next we build an attack using the state-test technique on 14-round Camellia-256 starting from the first round but without the  <span class="math">FL / FL^{-1}</span>  layers and the whitening keys.</p>

    <p class="text-gray-300">Improvements. We improve here the complexities of the previous attacks that take into account the  <span class="math">FL / FL^{-1}</span>  layers and the whitening keys on all three versions of Camellia. By using the complexity analysis introduced in Section 2, we can optimize the complexities of the corresponding attacks from [23]. Note that we use for this the same parameters as in [23]. The parameters of our attacks on 11-round Camellia-128, 12-round Camellia-192 and 13-round Camellia-256 are depicted in Table 3. As can be seen in Table 2, the time complexity of our improved attack on Camellia-128 is  <span class="math">2^{118.43}C_E</span> , with data complexity  <span class="math">2^{118.4}</span>  and memory complexity  <span class="math">2^{92.4}</span> . For Camellia-192, the time, data and memory complexities are  <span class="math">2^{161.06}C_E</span> ,  <span class="math">2^{119.7}</span>  and  <span class="math">2^{150.7}</span>  respectively, while for Camellia-256 the corresponding complexities are  <span class="math">2^{225.06}C_E</span> ,  <span class="math">2^{119.71}</span>  and  <span class="math">2^{198.71}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Δin</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Δout</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">rin</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">rout</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">rΔ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cin</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cout</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">kin ∪ kout</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Camellia-128</td>

            <td class="px-3 py-2 border-b border-gray-700">23</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">57</td>

            <td class="px-3 py-2 border-b border-gray-700">96</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Camellia-192</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">73</td>

            <td class="px-3 py-2 border-b border-gray-700">73</td>

            <td class="px-3 py-2 border-b border-gray-700">160</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Camellia-256</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">73</td>

            <td class="px-3 py-2 border-b border-gray-700">121</td>

            <td class="px-3 py-2 border-b border-gray-700">224</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3. Attack parameters against all versions of Camellia</p>

    <p class="text-gray-300">Using the state-test technique on Camellia-256. We provide here an impossible differential attack on Camellia-256 without  <span class="math">FL / FL^{-1}</span>  layers and without whitening keys by using the state-test technique. Note here, that unlike all previous attacks of this kind that do not start from the first round in order to take advantage of the key schedule asymmetry, our attack starts from the first round of the cipher. This attack covers 14 rounds of Camellia-256 which is, based on our knowledge, the highest number of rounds attacked for this version of the cipher. In [23] another attack on 14 rounds of Camellia-256 without  <span class="math">FL / FL^{-1}</span>  and whitening keys is presented, however, as said before, it does not start from the first round, and it equally uses a specific property of the key schedule in the rounds where it is applied.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this attack, we consider the same 8-round impossible differential as in [26] and we add  <span class="math">4 + 2</span>  rounds such that  <span class="math">r_{in} = 4</span> ,  <span class="math">r_{out} = 2</span>  and  <span class="math">r_{\\Delta} = 8</span> . We have  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 128<span class="math"> ,  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 56<span class="math"> ,  </span>c_{in} = 120<span class="math">  and  </span>c_{out} = 48<span class="math"> . Then we need at least  </span>N_{\\mathrm{min}} = 2^{168}<span class="math">  plaintext pairs for our attack to work. The amount of data needed to construct these pairs is  </span>C_{N_{\\mathrm{min}}} = \\max \\left\\{\\sqrt{2^{168}2^{129 - 128}}, 2^{168}2^{129 - 184}\\right\\} = 2^{113}<span class="math"> . There remain then  </span>128 - 113 = 15<span class="math">  bits of freedom. Thus, we can fix  </span>s = 8<span class="math">  bits on the ciphertexts to apply the state-test technique on the 8 bits of the internal state at the penultimate round. The number of information key bits is  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in} \\cup k_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 227 - 8 = 219<span class="math">  since there are 45 bits shared between the subkeys with respect to the key schedule of Camellia-256. The best attack is obtained with  </span>N = 2^{118}<span class="math">  pairs. In this case, the time complexity is  </span>2^{220}C_E<span class="math"> , the data complexity is  </span>2^{118}<span class="math">  plaintexts and the memory is  </span>2^{118}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To start with, we have proposed in this paper a generic vision of impossible differential attacks with the aim of simplifying and helping the construction and verification of this type of cryptanalysis. Until now, these attacks were very tedious to mount and even more to verify, and so, very often flaws appeared in the computations. We believe that our objective has been successfully reached, as it can be seen by the high amount of new improved attacks that we have been able to propose, as well as by all the different possible trade-offs for each one of them, something that would be near to unthinkable prior to our work.</p>

    <p class="text-gray-300">Next, the generic and clear vision of impossible differential attacks has allowed us to discover and propose new ideas for improving these attacks. In particular, we have proposed the state-test technique, that allows to reduce the number of key bits involved in the attack, and so to reduce the time complexity. We have also formalized and adapted to our generic scenario the notion introduced in [35] of multiple impossible differentials. This option allows reducing the data complexity. Finally, we have proposed several applications to different variants of the Feistel block ciphers CLEFIA, Camellia, LBlock and SIMON, providing in most of the cases, the best known attack on reduced-round versions of these ciphers.</p>

    <p class="text-gray-300">We hope that these results will simplify and improve future impossible attacks on Feistel ciphers, as well as their possible combination with other attacks. For instance, in <em>[39]</em> a combination of impossible differential with linear attacks is proposed. We have not been able to verify these results, but this direction could be promising.</p>

    <h2 id="sec-22" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] F. Abed, E. List, S. Lucks, and J. Wenzel. Differential and linear cryptanalysis of reduced-round SIMON. Cryptology ePrint Archive, Report 2013/526, 2013.</li>

      <li>[2] F. Abed, E. List, J. Wenzel, and S. Lucks. Differential Cryptanalysis of round-reduced Simon and Speck. In FSE 2014, LNCS. Springer, 2014. To appear.</li>

      <li>[3] J. Alizadeh, N. Bagheri, P. Gauravaram, A. Kumar, and S. K. Sanadhya. Linear Cryptanalysis of Round Reduced Variants of SIMON. Cryptology ePrint Archive, Report 2013/663, 2013.</li>

      <li>[4] H. A. Alkhzaimi and M. M. Lauridsen. Cryptanalysis of the SIMON Family of Block Ciphers. Cryptology ePrint Archive, Report 2013/543, 2013.</li>

      <li>[5] K. Aoki, T. Ichikawa, M. Kanda, M. Matsui, S. Moriai, J. Nakajima, and T. Tokita. Camellia: A 128-Bit Block Cipher Suitable for Multiple Platforms - Design and Analysis. In Selected Areas in Cryptography - SAC 2000, volume 2012 of LNCS, pages 39–56. Springer, 2000.</li>

      <li>[6] R. Beaulieu, D. Shors, J. Smith, S. Treatman-Clark, B. Weeks, and L. Wingers. The SIMON and SPECK Families of Lightweight Block Ciphers. Cryptology ePrint Archive, Report 2013/404, 2013.</li>

      <li>[7] E. Biham, A. Biryukov, and A. Shamir. Cryptanalysis of Skipjack Reduced to 31 Rounds Using Impossible Differentials. In EUROCRYPT 1999, volume 1592 of LNCS, pages 12–23. Springer, 1999.</li>

      <li>[8] E. Biham and A. Shamir. Differential Cryptanalysis of DES-like Cryptosystems. In CRYPTO 1990, volume 537 of LNCS, pages 2–21. Springer, 1990.</li>

      <li>[9] A. Biryukov, A. Roy, and V. Velichkov. Differential Analysis of Block Ciphers SIMON and SPECK. In FSE 2014, LNCS. Springer, 2014. To appear.</li>

      <li>[10] C. Blondeau. Improbable Differential from Impossible Differential: On the Validity of the Model. In INDOCRYPT, volume 8250 of LNCS, pages 149–160. Springer, 2013.</li>

      <li>[11] A. Bogdanov, H. Geng, M. Wang, L. Wen, and B. Collard. Zero-Correlation Linear Cryptanalysis with FFT and Improved Attacks on ISO Standards Camellia and CLEFIA. In Selected Areas in Cryptography - SAC 2013, volume 8282 of LNCS, pages 306–323. Springer, 2013.</li>

      <li>[12] C. Bouillaguet, O. Dunkelman, P-A. Fouque, and G. Leurent. New Insights on Impossible Differential Cryptanalysis. In Selected Areas in Cryptography-SAC 2011, volume 7118 of LNCS, pages 243–259. Springer, 2011.</li>

      <li>[13] C. Boura, M. Minier, M. Naya-Plasencia, and V. Suder. Improved Impossible Differential Attacks against Round-Reduced LBlock. Cryptology ePrint Archive, Report 2014/279, 2014.</li>

      <li>[14] J. Chen, Y. Futa, A. Miyaji, and C. Su. Impossible differential cryptanalysis of LBlock with concrete investigation of key scheduling algorithm. Cryptology ePrint Archive, Report 2014/272, 2014.</li>

      <li>[15] O. Dunkelman, G. Sekar, and B. Preneel. Improved Meet-in-the-Middle Attacks on Reduced-Round DES. In INDOCRYPT, volume 4859 of LNCS, pages 86–100. Springer, 2007.</li>

      <li>[16] H. Gilbert and T. Peyrin. Super-Sbox Cryptanalysis: Improved Attacks for AES-Like Permutations. In FSE 2010, volume 6147 of LNCS, pages 365–383. Springer, 2010.</li>

      <li>[17] T. Isobe and K. Shibutani. Generic Key Recovery Attack on Feistel Scheme. In ASIACRYPT (1), volume 8269 of LNCS, pages 464–485. Springer, 2013.</li>

      <li>[18] M. Iwamoto, T. Peyrin, and Y. Sasaki. Limited-Birthday Distinguishers for Hash Functions - Collisions beyond the Birthday Bound Can Be Meaningful. In ASIACRYPT (2), volume 8269 of LNCS, pages 504–523. Springer, 2013.</li>

      <li>[19] F. Karakoç, H. Demirci, and A. E. Harmanci. Impossible Differential Cryptanalysis of Reduced-Round LBlock. In WISTP 2012, volume 7322 of LNCS, pages 179–188. Springer, 2012.</li>

      <li>[20] J. Kim, S. Hong, and J. Lim. Impossible differential cryptanalysis using matrix method. Discrete Mathematics, 310(5):988–1002, 2010.</li>

      <li>[21] J. Kim, S. Hong, J. Sung, C. Lee, and S. Lee. Impossible Differential Cryptanalysis for Block Cipher Structures. In INDOCRYPT 2003, volume 2904 of LNCS, pages 82–96. Springer, 2003.</li>

      <li>[22] L. R. Knudsen. DEAL – A 128-bit cipher. Technical Report, Department of Informatics, University of Bergen, Norway, 1998.</li>

      <li>[23] Y. Liu, L. Li, D. Gu, X. Wang, Z. Liu, J. Chen, and W. Li. New Observations on Impossible Differential Cryptanalysis of Reduced-Round Camellia. In FSE 2012, volume 7549 of LNCS, pages 90–109. Springer, 2012.</li>

      <li>[24] J. Lu, J. Kim, N. Keller, and O. Dunkelman. Improving the Efficiency of Impossible Differential Cryptanalysis of Reduced Camellia and MISTY1. In CT-RSA, volume 4964 of LNCS, pages 370–386. Springer, 2008.</li>

      <li>[25] H. Mala, M. Dakhilalian, and M. Shakiba. Impossible Differential Attacks on 13-Round CLEFIA-128. J. Comput. Sci. Technol., 26(4):744–750, 2011.</li>

      <li>[26] H. Mala, M. Shakiba, M. Dakhilalian, and G. Bagherikaram. New Results on Impossible Differential Cryptanalysis of Reduced-Round Camellia-128. In Selected Areas in Cryptography-SAC 2009, volume 5867 of LNCS, pages 281–294. Springer, 2009.</li>

    </ul>

    <p class="text-gray-300">27] M. Minier and M. Naya-Plasencia. A Related Key Impossible Differential Attack Against 22 Rounds of the Lightweight Block Cipher LBlock. Inf. Process. Lett., 112(16):624–629, 2012.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[28] M. Minier and M. Naya-Plasencia. Private communication, May 2013.</li>

      <li>[29] T. Shirai, K. Shibutani, T. Akishita, S. Moriai, and T. Iwata. The 128-Bit Blockcipher CLEFIA (Extended Abstract). In Fast Software Encryption - FSE 2007, volume 4593 of LNCS, pages 181–195. Springer, 2007.</li>

      <li>[30] T. Shirai, K. Shibutani, T. Akishita, S. Moriai, and T. Iwata. Private communication, May 2014.</li>

      <li>[31] X. Tang, B. Sun, R. Li, and C. Li. Impossible differential cryptanalysis of 13-round CLEFIA-128. Journal of Systems and Software, 84(7):1191–1196, 2011.</li>

      <li>[32] CLEFIA Design Team. Comments on the impossible differential analysis of reduced round CLEFIA presented at Inscrypt 2008, Jan. 8, 2009.</li>

      <li>[33] C. Tezcan. The Improbable Differential Attack: Cryptanalysis of Reduced Round CLEFIA. In INDOCRYPT, volume 6498 of LNCS, pages 197–209. Springer, 2010.</li>

      <li>[34] Y. Tsunoo, E. Tsujihara, M. Shigeri, T. Saito, T. Suzaki, and H. Kubo. Impossible Differential Cryptanalysis of CLEFIA. In FSE, volume 5086 of LNCS, pages 398–411. Springer, 2008.</li>

      <li>[35] Y. Tsunoo, E. Tsujihara, M. Shigeri, T. Suzaki, and T. Kawabata. Cryptanalysis of CLEFIA using multiple impossible differentials. In Information Theory and Its Applications. ISITA 2008, pages 1–6, 2008.</li>

      <li>[36] W. Wu and L. Zhang. LBlock: A Lightweight Block Cipher. In ACNS 2011, volume 6715 of LNCS, pages 327–344. Springer, 2011.</li>

      <li>[37] W. Wu, L. Zhang, and W. Zhang. Improved Impossible Differential Cryptanalysis of Reduced-Round Camellia. In Selected Areas in Cryptography-SAC 2008, volume 5381 of LNCS, pages 442–456. Springer, 2008.</li>

      <li>[38] W. Wu, W. Zhang, and D. Feng. Impossible Differential Cryptanalysis of Reduced-Round ARIA and Camellia. J. Comput. Sci. Technol., 22(3):449–456, 2007.</li>

      <li>[39] Z. Yuan, X. Li, and H. Liu. Impossible Differential-Linear Cryptanalysis of Reduced-Round CLEFIA-128. Cryptology ePrint Archive, Report 2013/301, 2013.</li>

      <li>[40] W. Zhang and J. Han. Impossible Differential Analysis of Reduced Round CLEFIA. In Inscrypt, volume 5487 of LNCS, pages 181–191. Springer, 2008.</li>

    </ul>

    <h2 id="sec-23" class="text-2xl font-bold">Appendix A Application to the Simon family of block ciphers</h2>

    <p class="text-gray-300">Simon is a family of lightweight block ciphers, optimized for performance on hardware devices, recently proposed by the NSA <em>[6]</em>. Though its very recent appearance and the fact that nothing is said about its resistance against cryptanalysis in the description document, several results on reduced versions have already appeared <em>[4, 2, 3, 9]</em>. We apply here our method on Simon and come out with the best impossible differential attacks for all versions of the algorithm, as well as with the best known attacks on the smaller variants.</p>

    <h3 id="sec-24" class="text-xl font-semibold mt-8">A.1 Brief description of the Simon family</h3>

    <p class="text-gray-300">The Simon family of block ciphers is based on a classical Feistel construction operating on two <span class="math">n</span>-bit branches. Therefore, the total block size is equal to <span class="math">2n</span> bits. The round function is composed of very simple operations consisting of rotations, XORs and the AND operation. More precisely, at each round, a nonlinear function <span class="math">F:\\mathbb{F}_{2}^{n}\\rightarrow\\mathbb{F}_{2}^{n}</span> transforms the left branch in the following way:</p>

    <p class="text-gray-300"><span class="math">F(L_{i-1})=((L_{i-1}\\lll 8)\\&amp;(L_{i-1}\\lll 1))\\oplus(L_{i-1}\\lll 2).</span></p>

    <p class="text-gray-300">The output of <span class="math">F</span> is then XORed with the round subkey and with the right branch <span class="math">R_{i-1}</span> to form the left input of the next round. The round function is iterated <span class="math">r</span> times, where the exact number of iterations <span class="math">r</span> depends on the cipher’s version. There exist in total ten members of the Simon family, each one characterized by different block and key sizes. We denote a member of the Simon family by Simonx/x’, where x denotes the block size and x’ the key size. All versions can be seen in column 1 of Table 2. For the key schedule description, we refer to the description document <em>[6]</em>.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">A.2 Previous cryptanalysis and comparison to our results</h3>

    <p class="text-gray-300">Since its recent publication, Simon has received a remarkable amount of analysis from the community. Most of these works <em>[4, 2, 3, 9]</em> analyze the resistance of the cipher against differential, impossible differential, linear and rectangle attacks. The best current results are due to differential cryptanalysis <em>[2, 9]</em>, while</p>

    <p class="text-gray-300">the number of attacked rounds with impossible differential attacks is much lower for all versions. Also, proposed impossible differential attacks on SIMON present flaws. In [4], the data complexity is too high for the attack to work, while in [1, 2] the computed  <span class="math">c_{in}</span>  is not correct, as we can check from our Figure 7, where the input rounds are the same as in their case, and  <span class="math">c_{in}</span>  should be 22, instead of 10.</p>

    <p class="text-gray-300">We provide here impossible differential attacks for all members of the SIMON family. With these results we attack, for all versions, much more rounds than the previous best impossible differential attacks. Furthermore, our attacks constitute the best known cryptanalysis results for the three smaller versions.</p>

    <p class="text-gray-300">We provide here our attacks on the SIMON family. As the approach used in our analysis is the same for all the versions except of SIMON96/96 and 128/128, we will only present the details of the attack on SIMON32/64 and give briefly the attack parameters for the other versions.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Without using the improvements of Section 2.5, it would not have been possible to mount impossible differential attacks on any version of SIMON, as the data available from the obtained patterns would not have been enough. Indeed, for all versions of SIMON, it holds that  $c_{in} =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and  </span>c_{out} =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  implying that  </span>C_N \\geq 2^{n+1}<span class="math">  for all  </span>N \\geq 2^{c_{in} + c_{out}}<span class="math"> . This is why we mount our attacks by rotating the second part of the impossible differential while keeping the same first part (see Section 2.5) so that another impossibility in the middle is produced. If we rotate the output pattern by 2 bits (see Table 4), it is possible to generate a second impossible differential with the same first part of the differential. More precisely, for each version of SIMON, there exist at least two output patterns that give the longest impossible differential for a given input pattern. Therefore, for all versions  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{out}'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1$ . This method ensures enough data to attack all versions of the SIMON family except for SIMON96/96 and 128/128.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In Section A.5 we present an example of how to simultaneously apply both ideas from Section 2.5. This approach does not change the number of attacked rounds but it permits to improve the data complexity for all versions and to provide valid attacks against SIMON96/96 and 128/128.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Attack on SIMON32/64. By following the previous approach we found that the longest impossible differentials (32 in total) are covering 11 rounds. The impossible differentials that we used for our attack can be visualized in Table 4. However, we note here, that any other maximum-length differential would have led to an equivalent attack. This differential was placed between rounds 5 and 16 and extended by  <span class="math">r_{in} = 4</span>  rounds and  <span class="math">r_{out} = 4</span>  rounds to both directions. In such a way, the first  <span class="math">19 (= 4 + 11 + 4)</span>  rounds of the cipher were attacked. It can be seen in Figure 7 that the number of bit-conditions is  <span class="math">c_{in} + c_{out} = 44</span> , with  <span class="math">c_{in} = c_{out} = 22</span> . We can equally see that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 22<span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{out}'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 23<span class="math"> . Determining the number of information key bits  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in} \\cup k_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  in the case of SIMON is straightforward. Indeed, in this case, the number of information key bits is simply the sum of the different subkey bits intervening in the attack. These bits are marked in blue in Figure 7, from where we can easily verify that  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in} \\cup k_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2 * 27 = 54<span class="math"> . The complexity of our attack can be seen in Table 5. Notice that for this attack on SIMON32/64,  </span>C_E' = \\frac{54}{16 \\cdot 19} = 2^{-2 \\cdot 49}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Left branch Lr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Right branch Rr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 4. Impossible differential for the attack on SIMON32/64. 0 denotes a bit without difference, 1 denotes a bit with a difference, and * denotes a bit for which we do not know whether there is a difference or not.</p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a> Fig. 7. The initial rounds (on the left) and the final rounds (on the right) of the attack on SIMON32/64.</p>

    <p class="text-gray-300">!<a href="img-9.jpeg">img-9.jpeg</a></p>

    <p class="text-gray-300">We used the same strategy to attack the other versions of the SIMON family. The results for all versions except for SIMON96/96 and 128/128 are summarized in Table 5.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">SIMON 32/64</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">SIMON 48/72</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">SIMON 48/96</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">SIMON 64/96</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">SIMON 64/128</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">SIMON 96/144</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">SIMON 128/192</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">SIMON 128/256</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Rounds</td>

            <td class="px-3 py-2 border-b border-gray-700">19</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700">30</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Time</td>

            <td class="px-3 py-2 border-b border-gray-700">262.56</td>

            <td class="px-3 py-2 border-b border-gray-700">270.69</td>

            <td class="px-3 py-2 border-b border-gray-700">294.73</td>

            <td class="px-3 py-2 border-b border-gray-700">294.56</td>

            <td class="px-3 py-2 border-b border-gray-700">2126.56</td>

            <td class="px-3 py-2 border-b border-gray-700">2142.59</td>

            <td class="px-3 py-2 border-b border-gray-700">2190.56</td>

            <td class="px-3 py-2 border-b border-gray-700">2254.68</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Data</td>

            <td class="px-3 py-2 border-b border-gray-700">232</td>

            <td class="px-3 py-2 border-b border-gray-700">248</td>

            <td class="px-3 py-2 border-b border-gray-700">248</td>

            <td class="px-3 py-2 border-b border-gray-700">264</td>

            <td class="px-3 py-2 border-b border-gray-700">264</td>

            <td class="px-3 py-2 border-b border-gray-700">296</td>

            <td class="px-3 py-2 border-b border-gray-700">2128</td>

            <td class="px-3 py-2 border-b border-gray-700">2128</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Memory</td>

            <td class="px-3 py-2 border-b border-gray-700">244</td>

            <td class="px-3 py-2 border-b border-gray-700">258</td>

            <td class="px-3 py-2 border-b border-gray-700">270</td>

            <td class="px-3 py-2 border-b border-gray-700">260</td>

            <td class="px-3 py-2 border-b border-gray-700">275</td>

            <td class="px-3 py-2 border-b border-gray-700">277</td>

            <td class="px-3 py-2 border-b border-gray-700">277</td>

            <td class="px-3 py-2 border-b border-gray-700">2111</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 5. Complexity summary of our attacks on the majority of SIMON versions.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Example on SIMON32/64. When considering both possibilities from Section 2.5, we can easily find 4 rotated input patterns (by 0,7,8,31 to the left), independent one from another. We can then define  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 22 + \\log 4 = 24<span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{out}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 22 + \\log 2 = 23<span class="math"> . All the remaining parameters stay the same as in the attack described in Section A.3. The best complexities for the attack are given by considering  </span>N = 2^{45}<span class="math"> , with  </span>C_N = 2^{31}<span class="math">  and a time complexity of  </span>2^{61.12}C_E<span class="math"> , or by using the whole codebook giving a time complexity of  </span>2^{58.28}C_E$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Example on SIMON96/96 and 128/128. In the 96/96 case, we consider an attack on 24 rounds  <span class="math">(4 + 16 + 4)</span> , where we can find 8 independent input patterns generated by rotations of an original one (by 0,7,8,16,19,25,31,37 to the left). With  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 33<span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{out}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 31<span class="math"> , if we consider  </span>N = 2^{61}$ , we</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">have  <span class="math">C_N = 2^{94}</span>  and a time complexity of  <span class="math">2^{94.62}C_E</span> . The same can be done with 128/128 and 27 rounds (4+19+4), obtaining a time complexity of  <span class="math">2^{126.6}C_E</span> .</p>

    <p class="text-gray-300">LBlock is a lightweight block cipher designed by Wu and Zhang in 2011 [36]. It is an iterated construction that can be seen as a variant of a Feistel network. The total number of iterations is equal to 32. The cipher operates on a 64-bit state and encrypts messages by using a 80-bit key.</p>

    <p class="text-gray-300">We start by providing a short description of the algorithm specifications. For a more complete description one can refer to [36].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Encryption algorithm. Denote by  $P = L_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R_0<span class="math">  a 64-bit plaintext, where  </span>L_0<span class="math">  and  </span>R_0$  are 32-bit vectors. The encryption procedure is as follows.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">i = 1,2,\\ldots ,{31}</span>  do</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">R_{i} = L_{i - 1}</span></li>

      <li><span class="math">L_{i} = F(L_{i - 1},K_{i})\\oplus (R_{i - 1}\\ll 8).</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">L_{32} = L_{31}</span></li>

      <li><span class="math">R_{32} = F(L_{31},K_{32})\\oplus (R_{31}\\ll 8)</span></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Output the ciphertext  $C = L_{32}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R_{32}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-10.jpeg">img-10.jpeg</a> Fig. 8. A round of LBlock</p>

    <p class="text-gray-300">Round function  <span class="math">F</span> . A round of LBlock is depicted in Figure 8. The round function  <span class="math">F</span>  can be divided into three steps. First, the 32-bit subkey  <span class="math">K_{i}</span>  is added to  <span class="math">L_{i-1}</span>  by a simple XOR. Then, a nonlinear layer applies to the result. This nonlinear layer consists of the application nibble by nibble of eight different 4-bit Sboxes  <span class="math">S_{0}, \\ldots, S_{7}</span> . The description of these Sboxes can be found in [36]. Finally, the resulting nibbles are permuted as seen in Figure 8.</p>

    <p class="text-gray-300">We are going now to describe our attack against 23 rounds of LBlock. To our knowledge, this is so far the best known attack against this cipher. We will equally present an improved impossible differential attack of the one published so far on 22 rounds. Here, we show how to build the attack using the generic attack strategy and the time complexity estimation, and it can be seen in [13] how this generic estimation perfectly corresponds to the detailed and careful time complexity computation.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">First, we notice that a difference  $P^i = 0_{32}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(0_4, 0_4, 0_4, \\alpha, 0_4, 0_4, 0_4)<span class="math">  cannot lead to a difference  </span>P^{i+14} = (0_4, 0_4, 0_4, 0_4, \\alpha, \\beta, 0_4, 0_4)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0_{32}$  after 14 rounds. We set this impossible differential between the rounds 5 and 19 of the cipher. Note that this impossible differential is different from both impossible differentials used to attack 21 and 22 rounds of LBlock in [19].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We extend this impossible differential by adding  <span class="math">r_{in} = 5</span>  rounds to the input and  <span class="math">r_{out} = 4</span>  rounds to the output and attack therefore the 23 first rounds of the cipher. As can be seen in Figure 9, the number of input bit-conditions is  <span class="math">c_{in} = 4 \\times 11 = 44</span>  and the number of output bit-conditions  <span class="math">c_{out} = 4 \\times 7 = 28</span> . In the same way,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 12 \\times 4 = 48<span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 8 \\times 4 = 32$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As  <span class="math">c_{in} + c_{out} = 72</span> , we see that we need at least  <span class="math">N_{\\mathrm{min}} = 2^{72}</span>  pairs for the attack to work. By trying different values for  <span class="math">N</span> , we found out that the best time complexity is given when choosing  <span class="math">N = 2^{74}</span> . The amount of data we need to construct these pairs is</p>

    <div class="my-4 text-center"><span class="math-block">C _ {N} = \\max \\left\\{\\sqrt {2 ^ {7 4} 2 ^ {6 5 - 4 8}}, 2 ^ {7 4} 2 ^ {6 5 - 4 8 - 3 2} \\right\\} = 2 ^ {5 9}.</span></div>

    <p class="text-gray-300">!<a href="img-11.jpeg">img-11.jpeg</a> Fig. 9. The initial rounds (on the left) and the final rounds (on the right). Different colors stand for the round that these key bits intervene.</p>

    <p class="text-gray-300">!<a href="img-12.jpeg">img-12.jpeg</a> Fig. 10. Parameters of our impossible differential cryptanalysis of 23-round LBlock.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">When analyzing the key schedule of LBlock, whose detailed description can be found in [36], we noticed that the amount of information key bits in our attack is  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in} \\cup k_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 73$  bits.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We briefly recall in Figure 10 the parameters of our attack on 23 rounds.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Δin</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(<em>0</em>0<strong>0,</strong><em>0,***0</em>)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Δout</td>

            <td class="px-3 py-2 border-b border-gray-700">(<em>0<strong>0</strong>0,0**0000</em>)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ΔX</td>

            <td class="px-3 py-2 border-b border-gray-700">(00000000, 0000α000)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ΔY</td>

            <td class="px-3 py-2 border-b border-gray-700">(00000/00, 00000000)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Δin</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Δout</td>

            <td class="px-3 py-2 border-b border-gray-700">rin</td>

            <td class="px-3 py-2 border-b border-gray-700">rout</td>

            <td class="px-3 py-2 border-b border-gray-700">rΔ</td>

            <td class="px-3 py-2 border-b border-gray-700">cin</td>

            <td class="px-3 py-2 border-b border-gray-700">cout</td>

            <td class="px-3 py-2 border-b border-gray-700">kin ∪ kout</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">44</td>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By using the Formula (2) we compute the time complexity of our 23-round attack on LBlock with  <span class="math">2^{59}</span>  chosen plaintexts, to be  <span class="math">2^{75.36}C_{E}</span> . The memory complexity, determined by  <span class="math">N</span> , is  <span class="math">2^{74}</span> . It is important to point out that this estimated complexity perfectly corresponds to the carefully computed one that is detailed in [13], showing that our time complexity estimation is indeed very tight.</p>

    <p class="text-gray-300">The previous best known attack against LBlock was an impossible differential attack on 22 rounds [19], of time complexity  <span class="math">2^{79.28}C_{E}</span> . We show here that it is possible to mount an 22-round attack with an improved time complexity. More precisely, by applying the formulas of Section 2, we obtain an attack of data complexity  <span class="math">2^{60}</span> , time complexity  <span class="math">2^{71.53}C_{E}</span>  and memory complexity  <span class="math">2^{59}</span> . The parameters of our attack are depicted in Figure 11.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Δin</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(<em> </em> <em>00000, </em>0 <em> 0 </em> * 0)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Δout</td>

            <td class="px-3 py-2 border-b border-gray-700">(<em> </em> 0 <em> </em> <em> 00, 0 </em> <em>0000</em>)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ΔX</td>

            <td class="px-3 py-2 border-b border-gray-700">(00000000, 0000α000)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ΔY</td>

            <td class="px-3 py-2 border-b border-gray-700">(00000/00, 00000000)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Δin</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Δout</td>

            <td class="px-3 py-2 border-b border-gray-700">rin</td>

            <td class="px-3 py-2 border-b border-gray-700">rout</td>

            <td class="px-3 py-2 border-b border-gray-700">rΔ</td>

            <td class="px-3 py-2 border-b border-gray-700">cin</td>

            <td class="px-3 py-2 border-b border-gray-700">cout</td>

            <td class="px-3 py-2 border-b border-gray-700">#(kin ∪ kout)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700">71</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 11. Parameters of our impossible differential cryptanalysis of 22 rounds of LBlock.</p>`;
---

<BaseLayout title="Scrutinizing and Improving Impossible Differential Attacks: ... (2014/699)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2014 &middot; eprint 2014/699
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
