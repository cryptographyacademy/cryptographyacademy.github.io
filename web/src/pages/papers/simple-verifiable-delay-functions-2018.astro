---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2018/627';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Simple Verifiable Delay Functions';
const AUTHORS_HTML = 'Krzysztof Pietrzak';

const CONTENT = `    <h2 id="sec-1" class="text-2xl font-bold">Simple Verifiable Delay Functions</h2>

    <p class="text-gray-300">Krzysztof Pietrzak\\* pietrzak@ist.ac.at</p>

    <p class="text-gray-300">IST Austria</p>

    <p class="text-gray-300"><strong>Abstract.</strong> We construct a verifiable delay function (VDF) by showing how the Rivest-Shamir-Wagner time-lock puzzle can be made publicly verifiable.</p>

    <p class="text-gray-300">Concretely, we give a statistically sound public-coin protocol to prove that a tuple (N, x, T, y) satisfies  <span class="math">y = x^{2^{T}} \\pmod{N}</span>  where the prover doesn't know the factorization of N and its running time is dominated by solving the puzzle, that is, compute  <span class="math">x^{2^{T}}</span> , which is conjectured to require T sequential squarings. To get a VDF we make this protocol non-interactive using the Fiat-Shamir heuristic.</p>

    <p class="text-gray-300">The motivation for this work comes from the Chia blockchain design, which uses a VDF as a key ingredient. For typical parameters ( <span class="math">T \\leq 2^{40}, N = 2048</span> ), our proofs are of size around 10KB, verification cost around three RSA exponentiations and computing the proof is 8000 times faster than solving the puzzle even without any parallelism.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">1 introduction</h3>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.1 The RSW time-lock puzzle</h3>

    <p class="text-gray-300">Rivest, Shamir and Wagner [RSW96] introduced the concept of a timelock puzzle, and proposed the following elegant construction</p>

    <p class="text-gray-300">The puzzle is a tuple (N, x, T) where  <span class="math">N = p \\cdot q</span>  is an RSA modulus,  <span class="math">x \\in \\mathbb{Z}_N^*</span>  is random and  <span class="math">T \\in \\mathbb{N}</span>  is a time parameter.</p>

    <p class="text-gray-300">The solution of the puzzle is  <span class="math">y = x^{2^T} \\mod N</span> . It can be computed making two exponentiations by the party who generates the puzzle (and thus knows the group order  <span class="math">\\phi(N) = (p-1)(q-1)</span> ) as</p>

    <div class="my-4 text-center"><span class="math-block">e := 2^T \\mod \\phi(N) \\quad , \\quad y := x^e \\mod N \\tag{1}</span></div>

    <p class="text-gray-300">but is conjectured to require T sequential squarings if the group order (or equivalently, the factorization of N) is not known</p>

    <p class="text-gray-300"><span class="math-block">x \\to x^2 \\to x^{2^2} \\to x^{2^3} \\to \\dots \\to x^{2^T} \\mod N</span>  (2)</p>

    <p class="text-gray-300"><sup>\\*</sup> Supported by the European Research Council (ERC) consolidator grant 682815 -TOCNeT. This paper appeared at ITCS 2019 [Pie19] and was posted on eprint on June 20 2018, this is the eprint version complied on April 30, 2019.</p>

    <p class="text-gray-300">To be more precise, the conjecture here is that T sequential steps are necessary to compute x 2 (mod N) even if one can use large parallelism.</p>

    <p class="text-gray-300">As an application, [RSW96] show how to "encrypt to the future": sample a puzzle (N, x, T) together with its solution y, then derive a key k<sup>y</sup> from y and encrypt a message m into a ciphertext c = ENC(ky, m). Given (N, x, T) and c one can recover the message m in time required to compute T squarings sequentially, but (under the above conjecture) not faster.</p>

    <h2 id="sec-4" class="text-2xl font-bold">1.2 Proofs of sequential work (PoSW)</h2>

    <p class="text-gray-300">Proofs of sequential work (PoSW) are closely related to time-lock puzzles. PoSW were introduced in [MMV13], and informally are proof systems where on input a random challenge x and time parameter T one can compute a publicly verifiable proof making T sequential computations, but it's hard to come up with an accepting proof in significantly less than T sequential steps, even given access to massive parallelism.</p>

    <p class="text-gray-300">The PoSW constructed in [MMV13] is not very practical (at least for large T) as the prover needs not only T time, but also linear in T space to compute a proof. Recently [CP18] constructed a very simple and practical PoSW in the random oracle model. They were interested in PoSW as they serve as a key ingredient in the Chia blockchain design (chia.net).</p>

    <p class="text-gray-300">The main open problem left open in [CP18] was to construct PoSW that is unique, in the sense that one cannot compute two accepting proofs on the same challenge. The existing PoSW all allow to generate many accepting proofs at basically the same cost as honestly computing the proof. Unfortunately such PoSW cannot be used for the blockchain application just mentioned, as this would allow for so called grinding attacks. More precisely, the output of the PoSW is used to compute a challenge for generating the next block. If the PoSW is not unique, a malicious miner could compute many proofs, and then pick the one which results in a challenge that is most favourable for him.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.3 Verifable delay functions (VDF)</h3>

    <p class="text-gray-300">Boneh, Bonneau, B¨unz and Fisch [BBBF18] recently introduced the notion of a verifiable delay function (VDF). A VDF can be seen as a relaxation of unique PoSW which still suffices for all known applications of unique PoSW. We refer the reader to [BBBF18] for a thorough discussion on VDFs including many interesting applications. In a VDF the proof on challenge (x, T) has two parts (y, π), where y is a deterministic function of x that needs T sequential time to compute, and π is a proof that y was correctly computed (the reason this is not necessarily a unique PoSW is the fact that this π does not need to be unique). It must be possible to compute π with low parallelism and such that π can be output almost at the same time as y. In [BBBF18] this is achieved using incrementally verifiable computation [Val08]. The (very high level) idea is to compute a hash chain</p>

    <div class="my-4 text-center"><span class="math-block">y = \\underbrace{h(h(\\dots h(x)\\dots))}_{T \\text{ times}}</span></div>

    <p class="text-gray-300">and at the same time use incrementally verifiable computation to compute the proof π, so the proof will be ready shortly after y is computed. To make this generic approach actually practical the h used in [BBBF18] is a particular algebraic function (a permutation polynomial) which has the property that one can invert it significantly faster than compute in forward direction (so instead of verifying the evaluation of h(·), one can just verify the the much simpler computation of h −1 (·)), and also the proof system used to compute π is tailored so it can exploit the algebraic structure of h.</p>

    <h2 id="sec-6" class="text-2xl font-bold">1.4 A VDF from RSW</h2>

    <p class="text-gray-300">The RSW time-lock puzzle looks like a promising starting point for constructing a VDF. The main difficulty one needs to solve is achieving public verifiability: to efficiently verify y ?= x 2 T (mod N) one needs the group order of Z ∗ <sup>N</sup> (or equivalently, the factorization of N). But the factorization cannot be public as otherwise also computing y becomes easy.</p>

    <p class="text-gray-300">One idea to solve this issue is to somehow obfuscate the group order so it can only be used to efficiently verify if a given solution is correct, but not to speed up its computation. There currently is no known instantiation to this approach.</p>

    <p class="text-gray-300">In this work we give a different solution. We construct a protocol where a prover P can convince a verifier V it computed the correct solution y = x 2 T (mod N) without either party knowing the factorization (or any other hard to compute function) of N. Our interactive protocol is public-coin, but can be made non-interactive – and thus give a VDF – by the Fiat-Shamir transformation. Here the prover's messages are replaced by simply applying a random function to the transcript. The Fiat-Shamir transformation applied to any constant-round public-coin interactive proof systems results in a sound non-interactive proof system in the random oracle model. Although our proof is not constant-round, we can still show that this transformation works, i.e., gives a sound non-interactive proof system relative to a random function (i.e., in the random oracle model). In practice the random function is instantiated with an actual hash-function like SHA256, as then soundness only holds computationally, such systems are called arguments, not proofs.</p>

    <p class="text-gray-300">Our protocol is inspired by the sumcheck protocol [LFKN90,Sha90]. The key idea of the proof is very simple. Assume  <span class="math">\\mathcal{P}</span>  wants to convince  <span class="math">\\mathcal{V}</span>  that a tuple (x,y) satisfies  <span class="math">y=x^{2^T}</span> . For this,  <span class="math">\\mathcal{P}</span>  first sends  <span class="math">\\mu=x^{2^{T/2}}</span>  to  <span class="math">\\mathcal{V}</span> . Now  <span class="math">\\mu=x^{2^{T/2}}</span>  together with  <span class="math">y=\\mu^{2^{T/2}}</span>  imply  <span class="math">y=x^{2^T}</span> . The only thing we have achieved at this point is to reduce the time parameter from T to T/2 at the cost of having two instead just one statement to verify. We then show that the verifier can merge those two statements in a randomized way into a single statement  <span class="math">(x&#x27;,y&#x27;)=(x^r\\cdot\\mu,\\mu^r\\cdot y)</span>  that satisfies  <span class="math">y&#x27;=x&#x27;^{2^{T/2}}</span>  if the original statement  <span class="math">y=x^{2^T}</span>  was true (and  <span class="math">\\mathcal{P}</span>  sends the correct  <span class="math">\\mu</span> ), but is almost certainly wrong (over the choice of the random exponent r) if the original statement was wrong, no matter what  <span class="math">\\mu</span>  the malicious prover did send. This subprotocol is repeated  <span class="math">\\log(T)</span>  times – each time halving the time parameter T – until T=1, at which point  <span class="math">\\mathcal{V}</span>  can efficiently verify correctness of the claim itself.</p>

    <p class="text-gray-300">The VDF we get has short proofs and is efficiently verifiable. For typical parameters (2048 bit modulus and  <span class="math">\\log(T) \\leq 40</span> ) a proof is about 10KB large and the cost for verification is around three full exponentiations (for comparison, a standard RSA decryption or RSA signature computation requires one full exponentiation).</p>

    <p class="text-gray-300">The algebraic setting of our proof systems differs a bit from RSW, as we'll discuss in §2. In a nutshell, to prove statistical soundness, we need to assume that N is the product of two safe primes, i.e.,  <span class="math">N = p \\cdot q</span>  where p' = (p-1)/2 and q' = (q-1)/2 are prime, as then a random quadratic residue  <span class="math">x \\in QR_N</span>  almost certainly is a generator of  <span class="math">QR_N</span> . We'll actually preform all computations in the group of signed quadratic residues  <span class="math">QR_N^+</span> , as unlike for  <span class="math">QR_N</span> , one can efficiently decide if an element is in  <span class="math">QR_N^+</span> , which will make the protocol slightly simpler and more efficient. Using  <span class="math">QR_N^+</span>  instead of  <span class="math">QR_N</span>  will also make the proof unique, so our VDF is a unique PoSW.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">1.5 Wesolowski's VDF</h3>

    <p class="text-gray-300">A closely related result to our VDF is a concurrent paper by Wesolowski [Wes18]. A recent survey [BBF18] compares his construction with the one presented in this paper.</p>

    <p class="text-gray-300">We solowski also constructs a VDF by making the RSW time-lock puzzle publicly verifiable. The prover, who claims  <span class="math">y=x^{2^T}</span> , receives as challenge a large prime B, and must respond with the proof  <span class="math">\\pi=x^{\\lfloor \\frac{2^T}{B}\\rfloor}.</span>  To verify this proof one checks  <span class="math">\\pi^B\\cdot x^{2^T\\bmod B}\\stackrel{?}{=}y.^1</span>  To get a VDF one makes this protocol non-interactive using the Fiat-Shamir heuristic, i.e., B=hash(y) is computed as a hash of the first message.</p>

    <p class="text-gray-300">To prove soundness (i.e., that it's hard to come up with a  <span class="math">z \\neq x^{2^T}</span>  together with a  <span class="math">\\pi</span>  that passes verification) one needs a computational hardness assumption which basically states that for any  <span class="math">z \\neq 1</span>  it is hard to compute the B'th root of z (i.e. a y s.t.  <span class="math">z^B = y</span> ) in the underlying group when B is a large random prime (whereas soundness of our proof is unconditional).</p>

    <p class="text-gray-300">The main advantage of Wesolowski's construction over ours is that his proof is just a single group element, and thus about a  <span class="math">\\log(T)</span>  factor smaller than in our VDF, also verification time is about this factor smaller. A drawback of his construction is that the overhead for computing the proof  <span class="math">\\pi</span>  is larger, though it improved significantly in the latest writeup. It's currently at  <span class="math">O(T/\\log(T))</span>  multiplications (our construction just needs  <span class="math">O(\\sqrt{T} \\cdot \\log(T))</span> ). The computation of the proof can be parallelized to some extent in both constructions.</p>

    <p class="text-gray-300">Another potential advantage (communicated to us by Dan Boneh) of our proof system is that it can be applied for any underlying endomorphism, not just the squaring operation. This could be useful to construct new VDFs, potentially achieving post-quantum security, though currently we don't know of any such instantiations.</p>

    <p class="text-gray-300">In summary, Wesolowski's proof system has shorter proofs and faster verification time. Our proof system allows for more efficient computation of the proof, does not require any computational assumptions and seems to apply in a more general setting.</p>

    <p class="text-gray-300">We selowski and the survey [BBF18] also discuss how to instantiate those proof systems in other groups than  <span class="math">\\mathbb{Z}_N^*</span> , including groups that will not require trusted setup. We'll discuss this in more detail in §6.1, for now let us just mention that if instantiated in such groups the proof systems will rely on a computational assumption (for Wesolowski's construction, in addition the root assumption), which basically states that it must be hard to find group elements of small order.</p>

    <p class="text-gray-300"><sup>&</sup>lt;sup>1</sup> This construction appears in the 2nd version of the eprint paper [Wes18] from July 1st and improves over the construction in the first posting.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">1.6 Outline</h3>

    <p class="text-gray-300">In §2 we discuss the slightly different algebraic setting used here as compared to [RSW96]. We then present the protocol in §3 and the security proof in §4. In §5 we define VDFs, and in §6 we discuss how the protocol is turned into a VDF and discuss several efficiency and security issues.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">1.7 Notation</h3>

    <p class="text-gray-300">For a set  <span class="math">\\mathcal{X}</span> ,  <span class="math">x \\overset{\\</span>}{\\leftarrow} \\mathcal{X}<span class="math">  means x is assigned a random value from  </span>\\mathcal{X}<span class="math"> . For a randomized algorithm alg we denote with  </span>x \\overset{\\<span class="math">}{\\leftarrow}</span>  alg that x is assigned the output of alg on fresh random coins, if alg is deterministic we just write  <span class="math">x \\leftarrow \\mathsf{alg}</span> .</p>

    <h2 id="sec-10" class="text-2xl font-bold">2 The algebraic setting</h2>

    <p class="text-gray-300">The exact algebraic setting for our proof system differs slightly from the setting of the original RSW time-lock puzzle [RSW96]. First, we require that  <span class="math">N = p \\cdot q</span>  is the product of safe primes (a prime p is safe if (p-1)/2 is also prime), and moreover we perform the computation in the group of signed quadratic residues  <span class="math">QR_N^+</span> . In an earlier version of this paper we used "normal" quadratic residues  <span class="math">QR_N</span> .  <span class="math">QR_N^+</span>  is isomorphic to  <span class="math">QR_N</span> , but makes the protocol slightly simpler as unlike for  <span class="math">QR_N</span> , one can efficiently decide if an element is in  <span class="math">QR_N^+</span> . Moreover using  <span class="math">QR_N^+</span>  instead of  <span class="math">QR_N</span>  will make the proof unique, i.e., it's hard to come up with any proof other than the one generated by the honest prover, so we even get a unique PoSW. As working with  <span class="math">QR_N</span>  instead of  <span class="math">QR_N^+</span>  is more intuitive, in the proof we'll assume the proof is over  <span class="math">QR_N</span> .</p>

    <p class="text-gray-300">As we'll outline below, if computing  <span class="math">x^{2^T}</span>  is hard in the original RSW setting, it will remain hard in our setting (the other direction is not clear, it might be that our setting is more secure).</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">2.1 Signed quadratic residues</h3>

    <p class="text-gray-300">For two safe primes p and q, and  <span class="math">N:=p\\cdot q</span>  we denote the quadratic residues with  <span class="math">QR_N\\stackrel{def}{=}\\{z^2 \\bmod N: z\\in \\mathbb{Z}_N^*\\}</span> , and the signed quadratic residues [FS00,HK09] are defined as the group</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$QR_N^+ \\stackrel{def}{=} \\{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">: x \\in QR_N\\},\\$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">is the absolute value when representing the elements of  <span class="math">\\mathbb{Z}_N^<em></span>  as  <span class="math">\\{-(N-1)/2,\\ldots,(N-1)/2\\}</span> . Since  <span class="math">-1\\in\\mathbb{Z}_N^</em></span>  is a quadratic non-residue</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">with Jacobi symbol +1, the map  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  acts as an (efficiently-computable) isomorphism&lt;sup&gt;2&lt;/sup&gt; from  </span>QR_N<span class="math">  to  </span>QR_N^+<span class="math"> , and as a result  </span>QR_N^+$  is also a cyclic group, with the group operation defined as</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$a \\circ b \\stackrel{def}{=}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a \\cdot b \\bmod N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">However, unlike for  <span class="math">QR_N</span> , membership in  <span class="math">QR_N^+</span>  can be efficiently tested since  <span class="math">QR_N^+ = J_N^+</span>  where  <span class="math">J_N</span>  is the group of elements with Jacobi symbol +1 and</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$J_N^+ \\stackrel{def}{=} \\{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">: x \\in J_N\\} = J_N/\\{\\pm 1\\}.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In other words, to test whether a given  <span class="math">x \\in \\mathbb{Z}_N^*</span>  (represented as  <span class="math">\\{-(N-1)/2, \\ldots, (N-1)/2\\}</span> ) belongs also to  <span class="math">QR_N+</span> , ensure that  <span class="math">x \\geq 0</span>  and that its Jacobi symbol is +1.</p>

    <p class="text-gray-300">Recall that the assumption underlying the security of the RSW time-lock puzzle [RSW96] states that computing  <span class="math">x^{2^T}</span>  is hard in  <span class="math">(\\mathbb{Z}_N^*,\\cdot)</span> . We note that using  <span class="math">(QR_N^+,\\circ)</span>  instead (i.e., when  <span class="math">x\\in QR_N^+</span>  and squaring is defined as  <span class="math">x^2\\stackrel{def}{=} x\\circ x</span> ), as we require for our protocol, will not make this assumption any weaker. By the two reductions below, we'll lose at most a factor  <span class="math">4\\cdot 2=8</span>  in advantage.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">First, let us observe that using  <span class="math">(QR_N, \\cdot)</span>  instead of  <span class="math">(\\mathbb{Z}_N^*, \\cdot)</span>  can only make the problem harder: Because  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">QR_N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{Z}_N^*</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/4<span class="math"> , a random element in  </span>\\mathbb{Z}_N^<em><span class="math">  also belongs to  </span>QR_N<span class="math">  with probability 1/4. So if one can break the assumption with probability  </span>\\epsilon<span class="math">  over  </span>QR_N<span class="math"> , we still can break it with probability  </span>\\epsilon/4<span class="math">  over  </span>\\mathbb{Z}_N^</em>$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Second, we observe that using  <span class="math">(QR_N^+, \\circ)</span>  instead of  <span class="math">(QR_N, \\cdot)</span>  will not make computing  <span class="math">x^{2^T}</span>  significantly easier: Consider any  <span class="math">x \\in QR_N</span>  and let  <span class="math">y := x^{2^T} \\mod N</span>  in  <span class="math">(QR_N, \\cdot)</span> , and let x' =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and  <span class="math">y&#x27; := x&#x27;^{2^T}</span>  in  <span class="math">(QR_N^+, \\circ)</span> , as the groups are isomorphic, y' =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, so  $y =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-1}<span class="math"> , which means  </span>y \\in \\{y', N - y'\\}<span class="math"> . Although we can&#x27;t efficiently decide if y = y&#x27; or y = N - y&#x27; (as it would contradict the quadratic residuosity assumption), we can pick one of the two values at random and will get the right one with probability 1/2. This shows that given an algorithm that finds  </span>x^{2^T}<span class="math">  in  </span>QR_N^+<span class="math">  in time t with probability  </span>\\delta<span class="math"> , we get an algorithm that computes  </span>x^{2^T}<span class="math">  in  </span>QR_N^+<span class="math">  in basically the same time t and probability  </span>\\delta/2$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^{2}&lt;/sup&gt;</span>  Note, however, that the inverse of this isomorphism is hard to compute under the quadratic residuosity assumption.</p>

    <h2 id="sec-13" class="text-2xl font-bold">2.3 On using safe primes</h2>

    <p class="text-gray-300">Another difference to the setting of [RSW96] is that we assume that  <span class="math">N=p\\cdot q</span>  is the product of random safe primes, whereas [RSW96] just assume random primes. We do this to make sure that  <span class="math">QR_N</span>  (and thus also  <span class="math">QR_N^+</span> ) contains no sub-group of small order, this property is required to prove statistical soundness.</p>

    <p class="text-gray-300">It is conjectured that for some constant c, there are  <span class="math">c \\cdot 2^{\\lambda}/n^2</span>  safe  <span class="math">\\lambda</span> -bit primes (cf. [vzGS13]), so a random n bit prime is safe with probability  <span class="math">\\approx c/n</span> . Under this assumption, the product of two random n-bit primes will be the product of two safe primes with probability  <span class="math">c^2/n^2</span> .</p>

    <h2 id="sec-14" class="text-2xl font-bold">3 The protocol</h2>

    <p class="text-gray-300">Our protocol, where  <span class="math">\\mathcal P</span>  convinces  <span class="math">\\mathcal V</span>  it solved an RSW puzzle, goes as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier  <span class="math">\\mathcal{V}</span>  and prover  <span class="math">\\mathcal{P}</span>  have as common input an RSW puzzle (N, x, T) and a statistical security parameter  <span class="math">\\lambda</span> . Here  <span class="math">T \\in \\mathbb{N}</span> ,  <span class="math">N = p \\cdot q</span>  is the product of safe primes and  <span class="math">x \\in QR_N^+</span> .</li>

      <li><span class="math">-\\mathcal{P}</span>  solves the puzzle by computing  <span class="math">y=x^{2^T}</span>  (making T sequential squarings in  <span class="math">(QR_N^+,\\circ)</span> ), and sends y to  <span class="math">\\mathcal{V}</span> .</li>

      <li>Now  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  iterate the "halving protocol" below. In this subprotocol, on common input (N, x, T, y) the output is either of the form  <span class="math">(N, x&#x27;, \\lceil T/2 \\rceil, y&#x27;)</span> , in which case it is used as input to the next iteration of the halving subprotocol, or the protocol has stopped with verifier output in  <span class="math">\\{\\text{reject}, \\text{accept}\\}</span> .</li>

    </ul>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">3.1 The halving subprotocol</h3>

    <p class="text-gray-300">On common input (N, x, T, y)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. If T=1 then  <span class="math">\\mathcal V</span>  outputs accept if  <span class="math">y=x^{2^T}=x^2</span>  and reject otherwise. If T>1 go to the next step.</li>

      <li>If T > 1 go to the next step. 2. The prover  <span class="math">\\mathcal{P}</span>  sends  <span class="math">\\mu = x^{2^{T/2}}</span>  to  <span class="math">\\mathcal{V}</span> .</li>

      <li>3. If  <span class="math">\\mu \\notin QR_N^+</span>  then  <span class="math">\\mathcal{V}</span>  outputs reject, otherwise  <span class="math">\\mathcal{V}</span>  samples a random  <span class="math">r \\stackrel{\\</span>}{\\leftarrow} \\mathbb{Z}_{2^{\\lambda}}<span class="math">  and sends it to  </span>\\mathcal{P}$ .</li>

      <li>4. If T/2 is even,  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  output</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">(N, x&#x27;, T/2, y&#x27;)</span></div>

    <p class="text-gray-300">where</p>

    <div class="my-4 text-center"><span class="math-block">x&#x27; := x^r \\cdot \\mu \\quad \\left(= x^{r+2^{T/2}}\\right)$$ $$y&#x27; := \\mu^r \\cdot y \\quad \\left(= x^{r \\cdot 2^{T/2} + 2^T}\\right)</span></div>

    <p class="text-gray-300">(note that if  <span class="math">y = x^{2^T}</span>  then  <span class="math">y&#x27; = x&#x27;^{2^{T/2}}</span> ). If T/2 is odd, output</p>

    <p class="text-gray-300"><span class="math-block">(N, x&#x27;, (T+1)/2, y&#x27;^2)</span> .</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">3.2 Security statement</h4>

    <p class="text-gray-300"><strong>Theorem 1.</strong> If the input (N, x, T) to the protocol satisfies</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1.  <span class="math">N = p \\cdot q</span>  is the product of safe primes, i.e., p = 2p' + 1, q = 2q' + 1for primes p', q'. 2.  <span class="math">\\langle x \\rangle = QR_N^+</span> . 3.  <span class="math">2^{\\lambda} \\le \\min\\{p&#x27;, q&#x27;\\}</span></li>

    </ul>

    <p class="text-gray-300">Then for any malicious prover  <span class="math">\\widetilde{\\mathcal{P}}</span>  who sends as first message y anything else than the solution to the RSW time-lock puzzle, i.e.,</p>

    <div class="my-4 text-center"><span class="math-block">y \\neq x^{2^T}</span></div>

    <p class="text-gray-300">V will finally output accept with probability at most</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{3\\log(T)}{2^{\\lambda}} \\ .</span></div>

    <h2 id="sec-17" class="text-2xl font-bold">Security proof</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We'll prove Theorem 1 where the signed quadratic residues  <span class="math">(QR_N^+, \\circ)</span>  are replaced with regular quadratic residues  <span class="math">(QR_N, \\cdot)</span>  throughout. This will make the proof a bit more intuitive as multiplication modulo N as in  <span class="math">QR_N</span> is a more familiar and simpler operation than the  <span class="math">\\circ</span>  operation in  <span class="math">QR_N^+</span> (which additionally requires the  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  mapping after each multiplication). As discussed in §2, those two groups are isomorphic, so the proof for  </span>(QR_N, \\cdot)<span class="math">  implies the same security for  </span>(QR_N^+, \\circ)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">&lt;sup&gt;\\&lt;/sup&gt;overline{\\ }^3</span>  That is, x generates  <span class="math">QR_N^+</span> , the quadratic residues modulo N. For our choice of Nwe have  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">QR_N^+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">QR_N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=p'q',<span class="math">  so  </span>\\langle x\\rangle\\stackrel{def}{=}\\{x,x^2,\\dots,x^{p'q'}\\}=QR_N^+$  .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The main reason we don't use  <span class="math">(QR_N, \\cdot)</span>  in the actual protocol is only because in step 3. of the halving subprotocol  <span class="math">\\mathcal{V}</span>  needs to check if  <span class="math">\\mu \\in QR_N^+</span> , which would not be efficient if we used  <span class="math">QR_N</span>  (in an earlier version of the protocol we did use  <span class="math">QR_N</span> , and  <span class="math">\\mathcal{P}</span>  had to send  <span class="math">\\mu&#x27;</span>  s.t.  <span class="math">\\mu&#x27;^2 = \\mu</span> , the verifier would then compute  <span class="math">\\mu := \\mu&#x27;^2</span>  can thus could be sure that  <span class="math">\\mu \\in QR_N</span> . As here  <span class="math">\\mathcal{P}</span>  can send any of the 4 roots of  <span class="math">\\mu</span> , this protocol was not unique).</p>

    <h2 id="sec-19" class="text-2xl font-bold">4.2 The language <span class="math">\\mathcal{L}</span></h2>

    <p class="text-gray-300">It will be convenient to define the language</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{L} = \\{ (N, x, T, y) : y \\neq x^{2^T} \\bmod N \\text{ and } \\langle x \\rangle = QR_N \\}</span></div>

    <p class="text-gray-300">We'll establish the following lemma.</p>

    <p class="text-gray-300"><strong>Lemma 1.</strong> For  <span class="math">N, \\lambda</span>  as in Thm. 1, and any malicious prover  <span class="math">\\widetilde{\\mathcal{P}}</span>  the following holds. If the input to the halving protocol in §3.1 satisfies</p>

    <div class="my-4 text-center"><span class="math-block">(N, x, T, y) \\in \\mathcal{L}</span></div>

    <p class="text-gray-300">then with probability  <span class="math">\\geq 1-3/2^{\\lambda}</span>  (over the choice of r) V's output is either reject or satisfies</p>

    <div class="my-4 text-center"><span class="math-block">(N, x&#x27;, \\lceil T/2 \\rceil, y&#x27;) \\in \\mathcal{L}</span></div>

    <p class="text-gray-300">Before we prove the lemma, let's see how it implies Theorem 1.</p>

    <p class="text-gray-300">Proof (Proof of Theorem 1). In every iteration of the halving protocol the time parameter decreases from T to  <span class="math">\\lceil T/2 \\rceil</span>  and it stops once T=1, this means we iterate for at most  <span class="math">\\lceil \\log(T) \\rceil</span>  rounds. By assumption, the input (N,x,T,y) to the first iteration is in  <span class="math">\\mathcal{L}</span> , and by construction, the only case where  <span class="math">\\mathcal{V}</span>  outputs accept is on an input (N,x,1,y) where  <span class="math">y=x^{2^T}=x^2 \\mod N</span> , in particular, this input is not in  <span class="math">\\mathcal{L}</span> .</p>

    <p class="text-gray-300">So, if  <span class="math">\\mathcal V</span>  outputs accept, there must be one iteration of the halving protocol where the input is in  <span class="math">\\mathcal L</span>  but the output is not. By Lemma 1, for any particular iteration this happens with probability  <span class="math">\\leq 3/2^{\\lambda}</span> . By the union bound, the probability of this happening in any of the  <span class="math">\\lceil \\log(T) \\rceil - 1</span>  rounds can be upper bounded by  <span class="math">3\\log(T)/2^{\\lambda}</span>  as claimed.</p>

    <p class="text-gray-300">Proof (Proof of Lemma 1). We just consider the case where T is even, the odd T case is almost identical.</p>

    <p class="text-gray-300">Assuming the input to the halving protocol satisfies  <span class="math">(N, x, T, y) \\in \\mathcal{L}</span> , we must bound the probability that  <span class="math">\\mathcal{V}</span>  outputs reject or the output  <span class="math">(N, x&#x27;, T/2, y&#x27;) \\notin \\mathcal{L}</span> .</p>

    <p class="text-gray-300">If T=1 then  <span class="math">\\mathcal V</span>  outputs reject and we're done. Otherwise, if  <span class="math">\\widetilde{\\mathcal P}</span>  sends a  <span class="math">\\mu \\notin QR_N</span>  in step 2. then  <span class="math">\\mathcal V</span>  outputs reject in step 3. and we're done. So from now we assume  <span class="math">\\mu \\in QR_N</span> . We must bound</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_r[(y&#x27;={x&#x27;}^{2^{T/2}}) \\lor (\\langle x&#x27; \\rangle \\neq QR_N)] \\le 3/2^{\\lambda}</span></div>

    <p class="text-gray-300">using  <span class="math">\\Pr[a \\vee b] = \\Pr[a \\wedge \\overline{b}] + \\Pr[b]</span>  we rewrite this as</p>

    <p class="text-gray-300"><span class="math-block">\\Pr_{r}[y&#x27; = {x&#x27;}^{2^{T/2}} \\wedge \\langle x&#x27; \\rangle = QR_N] + \\Pr_{r}[\\langle x&#x27; \\rangle \\neq QR_N] \\le 3/2^{\\lambda}</span>  (3)</p>

    <p class="text-gray-300">Eq.(3) follows by the two claims below.</p>

    <p class="text-gray-300">Claim. <span class="math-block">\\Pr_r[\\langle x&#x27; \\rangle \\neq QR_N] \\leq 2/2^{\\lambda}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof (Proof of Claim). We'll denote with  <span class="math">e_{\\mu}</span>  the unique value in  <span class="math">\\mathbb{Z}_{p&#x27;q&#x27;}</span>  satisfying  <span class="math">x^{e_{\\mu}} = \\mu</span>  (it's unique as  <span class="math">\\mu \\in \\langle x \\rangle = QR_N</span>  and  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">QR_N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= p'q'<span class="math"> ). As  </span>x, \\mu \\in QR_N<span class="math"> , also  </span>x' = x^r \\cdot \\mu = x^{r+e_{\\mu}}<span class="math">  is in  </span>QR_N<span class="math"> , and  </span>\\langle x' \\rangle = QR_N<span class="math">  holds if ord(x&#x27;) = p&#x27;q&#x27;, which is the case except if  </span>(r + e_{\\mu}) = 0 \\mod p'<span class="math">  or  </span>(r + e_{\\mu}) = 0 \\mod q'<span class="math">  or equivalently (using that  </span>2^{\\lambda} < \\min(p', q')$ ) if</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">r \\in \\mathcal{B} \\stackrel{def}{=} \\left\\{ \\mathbb{Z}_{2^{\\lambda}} \\cap \\{ (-e_{\\mu} \\bmod p&#x27;), (-e_{\\mu} \\bmod q&#x27;) \\} \\right\\} . \\tag{4}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Clearly  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{B}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2$  and the claim follows.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Claim. <span class="math-block">\\Pr_r[y&#x27; = {x&#x27;}^{2^{T/2}} \\mod N \\wedge \\langle x&#x27; \\rangle = QR_N] \\le 1/2^{\\lambda}</span> .</p>

    <p class="text-gray-300">Proof (Proof of Claim). If  <span class="math">y \\notin QR_N</span> , then also  <span class="math">y&#x27; = \\mu^r \\cdot y \\notin QR_N</span>  (as  <span class="math">a \\in QR_N, b \\notin QR_N</span>  implies  <span class="math">a \\cdot b \\notin QR_N</span> ). As  <span class="math">\\langle x&#x27; \\rangle = QR_N</span>  and  <span class="math">y&#x27; \\neq {x&#x27;}^{2^{T/2}}</span>  can't hold simultaneously in this case the probability in the claim is 0. From now on we consider the case  <span class="math">y \\in QR_N</span> . We have</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_{r}[y&#x27; = {x&#x27;}^{2^{T/2}} \\wedge \\langle x&#x27; \\rangle = QR_{N}] =</span></div>

    <p class="text-gray-300"><span class="math-block">\\Pr_{r}[y&#x27; = {x&#x27;}^{2^{T/2}} \\mid \\langle x&#x27; \\rangle = QR_{N}] \\cdot \\Pr_{r}[\\langle x&#x27; \\rangle = QR_{N}]</span> (5)</p>

    <p class="text-gray-300">For the second factor in (5) we have with  <span class="math">\\mathcal{B}</span>  as in (4)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr_r[\\langle x' \\rangle = QR_N] = \\frac{2^{\\lambda} -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{B}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{2^{\\lambda}} \\ . \\tag{6}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Conditioned on  <span class="math">\\langle x&#x27; \\rangle = QR_N</span>  the r is uniform in  <span class="math">\\mathbb{Z}_{2^{\\lambda}} \\setminus \\mathcal{B}</span> , so the first factor in (5) is</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_{r}[y&#x27; = {x&#x27;}^{2^{T/2}} \\mid \\langle x&#x27; \\rangle = QR_{N}] = \\Pr_{r \\in \\mathbb{Z}_{2\\lambda} \\setminus \\mathcal{B}}[y&#x27; = {x&#x27;}^{2^{T/2}}] . \\tag{7}</span></div>

    <p class="text-gray-300">Let e<sup>y</sup> ∈ Z<sup>p</sup> 0q <sup>0</sup> be the unique value such that x <sup>e</sup><sup>y</sup> = y. Using hxi = QR<sup>N</sup> in the last step below we can rewirte</p>

    <div class="my-4 text-center"><span class="math-block">y&#x27; = {x&#x27;}^{2^{T/2}} \\mod N \\iff</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mu^r y = (x^r \\mu)^{2^{T/2}} \\mod N \\iff</span></div>

    <div class="my-4 text-center"><span class="math-block">x^{r \\cdot e_\\mu + e_y} = x^{(r + e_\\mu) \\cdot 2^{T/2}} \\mod N \\iff</span></div>

    <div class="my-4 text-center"><span class="math-block">r \\cdot e_\\mu + e_y = (r + e_\\mu) \\cdot 2^{T/2} \\mod p&#x27;q&#x27;</span></div>

    <p class="text-gray-300">rearranging terms</p>

    <p class="text-gray-300"><span class="math-block">r(e_{\\mu} - 2^{T/2}) + e_y - e_{\\mu} 2^{T/2} = 0 \\mod p&#x27;q&#x27;</span>  (8)</p>

    <p class="text-gray-300">If e<sup>µ</sup> = 2T /<sup>2</sup> this becomes</p>

    <div class="my-4 text-center"><span class="math-block">e_y - 2^T = 0 \\bmod p&#x27;q&#x27;</span></div>

    <p class="text-gray-300">which does not hold as by assumption we have y 6= x 2 T . So from now on we assume e<sup>µ</sup> 6= 2T /<sup>2</sup> mod p 0 q 0 . Then for a = e<sup>µ</sup> − 2 T /<sup>2</sup> 6= 0 mod p 0 q 0 (and b = e<sup>y</sup> − eµ2 T /2 ) eq.(8) becomes</p>

    <div class="my-4 text-center"><span class="math-block">r \\cdot a = b \\bmod p&#x27;q&#x27;</span></div>

    <p class="text-gray-300">which holds for at most one choice of r from its domain Z<sup>2</sup> <sup>λ</sup> \\ B, thus</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr_{r \\in \\mathbb{Z}_{2^{\\lambda}} \\setminus \\mathcal{B}}[y' = x'^{2^{T/2}}] \\le \\frac{1}{2^{\\lambda} -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{B}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and the claim follows from the above equation and (5)-(7) as</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_{r}[y&#x27; = {x&#x27;}^{2^{T/2}} \\wedge \\langle x&#x27; \\rangle = QR_{N}] =</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr_{r \\in \\mathbb{Z}_{2^{\\lambda}} \\setminus \\mathcal{B}}[y' = {x'}^{2^{T/2}}] \\cdot \\Pr_{r}[\\langle x' \\rangle = QR_{N}] \\le \\frac{1}{2^{\\lambda} -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{B}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\cdot \\frac{2^{\\lambda} -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{B}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{2^{\\lambda}} \\le \\frac{1}{2^{\\lambda}}.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-20" class="text-2xl font-bold">5 Verifiable delay functions</h2>

    <p class="text-gray-300">In this section we define verifiable delay functions (VDF) mostly following the definition from [BBBF18]. A VDF is defined by a four-tuple of algorithms:</p>

    <p class="text-gray-300">VDF.Setup(1<sup>λ</sup> ) → pp on input a statistical security parameter 1<sup>λ</sup> outputs public parameters pp.</p>

    <p class="text-gray-300"> <span class="math">\\mathsf{VDF}.\\mathsf{Gen}(\\mathbf{pp},T) \\to (x,T)</span>  on input a time parameter  <span class="math">T \\in \\mathbb{N}</span> , samples an input x.</p>

    <p class="text-gray-300"> <span class="math">\\mathsf{VDF}.\\mathsf{Sol}(\\mathbf{pp},(x,T)) \\to (y,\\pi)</span>  on input (x,T) outputs  <span class="math">(y,\\pi)</span> , where  <span class="math">\\pi</span>  is a proof that the output y has been correctly computed.</p>

    <p class="text-gray-300"> <span class="math">\\mathsf{VDF}.\\mathsf{Ver}(\\mathbf{pp},(x,T),(y,\\pi)) \\to \\{\\mathsf{accept/reject}\\} \\ \\ \\mathsf{given} \\ \\ \\mathsf{an input/output} \\ \\ \\mathsf{tuple} \\ (x,T),(y,\\pi) \\ \\mathsf{outputs} \\ \\mathsf{either accept} \\ \\mathsf{or reject}.</span></p>

    <p class="text-gray-300">The VDF.Setup and VDF.Gen algorithms are probabilistic, VDF.Sol and VDF.Ver are deterministic. They all run in time  <span class="math">poly(log(T), \\lambda)</span> .</p>

    <h2 id="sec-21" class="text-2xl font-bold">5.1 The statistical security parameter</h2>

    <p class="text-gray-300"> <span class="math">\\lambda</span>  measures the bit-security we expect from our protocol, i.e., an adversary of complexity  <span class="math">\\tau</span>  should have advantage no more than  <span class="math">\\approx \\tau/2^{\\lambda}</span>  in breaking the scheme. It only makes sense to consider time parameters T that are much smaller than  <span class="math">2^{\\lambda}</span>  (say we require  <span class="math">T \\leq 2^{\\lambda/2}</span> ) so the sequential running time of the honest prover is much smaller than what is required to break the underlying hardness assumptions.</p>

    <h2 id="sec-22" class="text-2xl font-bold">5.2 Efficiency of solving</h2>

    <p class="text-gray-300">The VDF.Sol algorithm can compute the output y in T sequential steps (in this work a "sequential step" is the  <span class="math">\\circ</span>  operation, which basically is a multiplication modulo N). Moreover we require that  <span class="math">\\pi</span>  can be computed with in much fewer than T steps. As we'll discuss in §6.2, we'll achieve  <span class="math">O(\\sqrt{T}\\log(T))</span>  sequential steps, and less if parallelism is available. In [BBBF18] the requirement is more relaxed, they compute  <span class="math">\\pi</span>  in parallel with y using bounded  <span class="math">\\operatorname{poly}(\\log(T), \\lambda)</span>  parallelism, so the  <span class="math">\\pi</span>  is available shortly after y is computed, but overall the computation is much larger than T. As discussed in the introduction, Wesolowski's VDF [Wes18] requires  <span class="math">O(T/\\log(T))</span>  steps to compute  <span class="math">\\pi</span> .</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">5.3 Completeness</h3>

    <p class="text-gray-300">The completeness property simply requires that correctly generated proofs will always accept, that is, for any  <span class="math">\\lambda, T</span></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\begin{bmatrix} \\mathsf{VDF.Ver}(\\mathbf{pp},(x,T),(y,\\pi)) = \\mathsf{accept} \\\\ \\mathsf{where} \\\\ \\mathbf{pp} \\xleftarrow{\\$} \\mathsf{VDF.Setup}(1^{\\lambda}) \\\\ (x,T) \\xleftarrow{\\$} \\mathsf{VDF.Gen}(\\mathbf{pp},T) \\\\ (y,\\pi) \\leftarrow \\mathsf{VDF.Sol}(\\mathbf{pp},(x,T)) \\end{bmatrix} = 1</span></div>

    <h2 id="sec-24" class="text-2xl font-bold">5.4 Security (sequentiality)</h2>

    <p class="text-gray-300">The first security property is sequentiality. For this we consider a two part adversary  <span class="math">\\mathcal{A} = (\\mathcal{A}_1, \\mathcal{A}_2)</span> , where  <span class="math">\\mathcal{A}_1</span>  can run a pre-computation and choose T. Then  <span class="math">\\mathcal{A}_2</span>  gets a random challenge for time T together with the output state of the precomputation, we require that whenever</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\begin{bmatrix} \\mathsf{VDF}.\\mathsf{Ver}(\\mathbf{pp},(x,T),(\\tilde{y},\\widetilde{\\pi})) = \\mathsf{accept} \\\\ \\mathsf{where} \\\\ \\mathbf{pp} \\overset{\\$}{\\leftarrow} \\mathsf{VDF}.\\mathsf{Setup}(1^{\\lambda}) \\\\ (T,\\mathsf{state}) \\overset{\\$}{\\leftarrow} \\mathcal{A}_1(\\mathbf{pp}) \\\\ (x,T) \\overset{\\$}{\\leftarrow} \\mathsf{VDF}.\\mathsf{Gen}(\\mathbf{pp},T) \\\\ (\\tilde{y},\\widetilde{\\pi}) \\overset{\\$}{\\leftarrow} \\mathcal{A}_2(\\mathbf{pp},(x,T),\\mathsf{state}) \\end{bmatrix} \\neq \\mathsf{negl}(\\lambda)</span></div>

    <p class="text-gray-300">the  <span class="math">\\mathcal{A}_2</span>  adversary must use almost the same sequential time T as required by an honest execution of VDF.Sol( <span class="math">\\mathbf{pp}, (\\pi, T)</span> ), and this even holds if  <span class="math">\\mathcal{A}</span>  is allowed massive parallel computation (say we just bound the total computation to  <span class="math">2^{\\lambda/2}</span> ). This means there's no possible speedup to compute the VDF output by using parallelism. Let us stress that by this we mean any parallelism that goes beyond what can be used to speed up a single sequential step, which here is a multiplication in  <span class="math">\\mathbb{Z}_N^*</span> , and we assume the honest prover can use such bounded parallelism.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">5.5 Security (soundness)</h3>

    <p class="text-gray-300">The second security property is soundness, which means that one cannot come up with an accepting proof  <span class="math">\\tilde{\\pi}</span>  for a wrong statement. Formally, for an adversary  <span class="math">\\mathcal{A} = (\\mathcal{A}_1, \\mathcal{A}_2)</span>  we have (unlike in the previous definition, here we don't make any assumption about  <span class="math">\\mathcal{A}_2</span> 's sequential running time, just the total running time of  <span class="math">\\mathcal{A}</span>  must be bounded to, say  <span class="math">2^{\\lambda/2}</span> )</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\begin{bmatrix} \\mathsf{VDF.Ver}(\\mathbf{pp},(x,T),(\\tilde{y},\\tilde{\\pi})) = \\mathsf{accept} \\\\ \\mathsf{and} \\ \\tilde{y} \\neq y \\\\ \\mathsf{where} \\\\ \\mathbf{pp} \\overset{\\$}{\\leftarrow} \\mathsf{VDF.Setup}(1^{\\lambda}) \\\\ (T,\\mathsf{state}) \\overset{\\$}{\\leftarrow} \\mathcal{A}_1(\\mathbf{pp}) \\\\ (x,T) \\overset{\\$}{\\leftarrow} \\mathsf{VDF.Gen}(\\mathbf{pp},T) \\\\ (y,\\pi) \\leftarrow \\mathsf{VDF.Sol}(\\mathbf{pp},(x,T)) \\\\ (\\tilde{y},\\tilde{\\pi}) \\overset{\\$}{\\leftarrow} \\mathcal{A}_2(\\mathbf{pp},(x,T),\\mathsf{state}) \\end{bmatrix} = \\mathsf{negl}(\\lambda)</span></div>

    <p class="text-gray-300">In this section we explain the simple transformation of the protocol from  <span class="math">\\S 3</span>  into a VDF and then discuss the efficiency, security and some other issues of this construction.</p>

    <p class="text-gray-300">To keep things simple we'll assume that the time parameter  <span class="math">T=2^t</span>  is a power of two. The four algorithms from §5 are instantiated as</p>

    <p class="text-gray-300">VDF.Setup(1 <span class="math">^{\\lambda}</span> ) The statistical security parameter  <span class="math">\\lambda</span>  defines another security parameter  <span class="math">\\lambda_{\\mathsf{RSA}}</span>  specifying the bitlength of an RSA modulus, where  <span class="math">\\lambda_{\\mathsf{RSA}}</span>  should be at least as large so that an  <span class="math">\\lambda_{\\mathsf{RSA}}</span>  bit RSA modulus offers  <span class="math">\\lambda</span>  bits of security (e.g.  <span class="math">\\lambda=100</span>  and  <span class="math">\\lambda_{\\mathsf{RSA}}=2048</span> ). As hardness of factoring is subexponential, while the soundness of our protocol is exponentially small in  <span class="math">\\lambda</span>  (in the random oracle model), we can without loss of generality assume that  <span class="math">\\lambda \\leq \\lambda_{\\mathsf{RSA}}/2</span> , so point 3. in the statement of Theorem 1 is satisfied.</p>

    <p class="text-gray-300">The setup algorithm samples two random  <span class="math">\\lambda_{\\mathsf{RSA}}/2</span>  bit safe primes p,q and output as public parameters the single  <span class="math">\\lambda_{\\mathsf{RSA}}</span>  bit RSA modulus  <span class="math">N := p \\cdot q</span> .</p>

    <p class="text-gray-300"> <span class="math">\\mathsf{VDF}.\\mathsf{Gen}(N,T)</span>  samples a random  <span class="math">x \\in QR_N^+</span>  and outputs (x,T).</p>

    <p class="text-gray-300">VDF.Sol(N,(x,T)) outputs  <span class="math">(y,\\pi)</span>  where  <span class="math">y=x^{2^T}</span>  is the solution of the RSW time-lock puzzle (but over  <span class="math">(QR_N^+,\\circ)</span>  not  <span class="math">(\\mathbb{Z}_N^*,\\cdot)</span> ) and  <span class="math">\\pi=\\{\\mu_i\\}_{i\\in[t]}</span>  is a proof that y has been correctly computed. It is derived by applying the Fiat-Shamir heuristic to the protocol in §3. Recall that in this heuristic the public-coin challenges  <span class="math">r_i\\in\\mathbb{Z}_{2^\\lambda}</span>  of the verifier are replaced with a hash of the last prover message. Concretely, we fix a hash function  <span class="math">hash: \\mathbb{Z}\\times\\mathbb{Z}_N^4\\to\\mathbb{Z}_{2^\\lambda}</span> , let  <span class="math">(x_1,y_1):=(x,y)</span>  and for  <span class="math">i=1\\dots t</span>  let<sup>4</sup></p>

    <p class="text-gray-300">Note that in the Fiat-Shamir heuristic, we not just hash the first prover message  <span class="math">\\mu_i</span>  in eq.(9), but also the statement  <span class="math">(x_i, T/2^{i-1}, y_i)</span>  of the halving subprotocol. It has been observed that this is necessary in a setting like ours, where the prover has some influence on the statement to be proven [BPW12]. There exists an easy attack (communicated to us by Benjamin Wesolowski) on uniqueness of the VDF if the y's are not included in the hash: for  <span class="math">(x,T)=(x_1,T_1)</span> , pick  <span class="math">\\mu_1</span>  at random, let  <span class="math">r_1=hash((x,T),\\mu_1),y=(x^{2^{T/2}}/\\mu_1)^{r_1}\\mu_1^{2^{T/2}},x_2=x_1^{r_1}\\mu_1,y_2=\\mu_1^{r_1}y</span> . The above y is almost certainly wrong, i.e.,  <span class="math">y\\neq x^{2^T}</span> , but by construction  <span class="math">y_2=x_2^{2^{T/2}}</span> , so one can continue with the honest proof.</p>

    <div class="my-4 text-center"><span class="math-block">\\mu_{i} := x_{i}^{2^{T/2^{i}}} \\in QR_{N}^{+}</span></div>

    <div class="my-4 text-center"><span class="math-block">r_{i} := hash((x_{i}, T/2^{i-1}, y_{i}), \\mu_{i}) \\in \\mathbb{Z}_{2^{\\lambda}}</span></div>

    <div class="my-4 text-center"><span class="math-block">x_{i+1} := x_{i}^{r_{i}} \\circ \\mu_{i}</span></div>

    <p class="text-gray-300"><span class="math-block">y_{i+1} := \\mu_{i}^{r_{i}} \\circ y_{i}</span> (9)</p>

    <p class="text-gray-300">VDF.Ver <span class="math">(N,(x,T),(y,\\pi))</span>  parses  <span class="math">\\pi = \\{\\mu_i\\}_{i \\in [t]}</span>  and checks if x,y and all  <span class="math">\\mu_i</span>  are in  <span class="math">QR_N^+</span> , if this is not the case output reject. Otherwise set  <span class="math">(x_1,y_1) := (x,y)</span>  and then for  <span class="math">i=1\\ldots t</span>  compute</p>

    <div class="my-4 text-center"><span class="math-block">r_i := hash((x_i, T/2^{i-1}, y_i), \\mu_i)</span></div>

    <p class="text-gray-300"> <span class="math">x_{i+1} := x_i^{r_i} \\circ \\mu_i</span>  (10)</p>

    <div class="my-4 text-center"><span class="math-block">y_{i+1} := \\mu_i^{r_i} \\circ y_i \\tag{11}</span></div>

    <p class="text-gray-300">Finally check whether</p>

    <div class="my-4 text-center"><span class="math-block">y_{t+1} \\stackrel{?}{=} x_{t+1}^2 \\tag{12}</span></div>

    <p class="text-gray-300">and output accept if this holds, otherwise output reject.</p>

    <h2 id="sec-26" class="text-2xl font-bold">6.1 Public parameters for the VDF</h2>

    <p class="text-gray-300">For the security of the VDF it's crucial that a prover does not know the factorization of the public parameter N, as otherwise he could compute  <span class="math">x^{2^T}</span>  in just two exponentiations as in eq.(1). Thus one either has to rely on a trusted party, or use multiparty-computation to sample N. In particular, it's possible to sample N securely as long as not all the participants in the multiparty computation are malicious. Such an "MPC ceremony" has been done before, e.g. to set up the common random string for Zcash. This is in contrast to the random-oracle based PoSW [MMV13,CP18] which don't require a setup procedure at all.</p>

    <p class="text-gray-300">To avoid trusted setup, Boneh et al. [BBF18] and Wesolowski [Wes18] suggested to use class groups of an imaginary quadratic field [BBHM02] instead of an RSA group. Recall that the statistical soundness of our proof systems relies on the fact that the underlying group (the quadratic residues of  <span class="math">\\mathbb{Z}_N^<em></span>  where N is the product of safe primes) has no subgroups of small order. If the underlying group does have groups of small order, then </em>computational* soundness holds under the assumption that it's hard to find elements of small order, which is conjectured to hold for the class groups mentioned above.</p>

    <p class="text-gray-300"><sup>&</sup>lt;sup>5</sup> https://z.cash/technology/paramgen.html</p>

    <h2 id="sec-27" class="text-2xl font-bold">6.2 Efficiency of the VDF</h2>

    <p class="text-gray-300">Cost of verification The cost of running the verification VDF.Ver <span class="math">(N, (x, T = 2^t), (y, \\pi))</span>  is dominated by the 2t exponentiations (with  <span class="math">\\lambda</span>  bit long exponents) in eq.(10-11). As exponentiation with a random  <span class="math">\\lambda</span>  bit exponent costs about  <span class="math">1.5\\lambda</span>  multiplications, the cost of verification is around  <span class="math">3 \\cdot \\lambda \\cdot t</span>  multiplications. For concreteness, consider an implementation where  <span class="math">\\lambda = 100, \\lambda_{\\mathsf{RSA}} = 2048</span>  and assume t = 40, this gives a cost of about  <span class="math">3 \\cdot \\lambda \\cdot t = 12000</span>  multiplications, which corresponds to  <span class="math">12000/(2048 \\cdot 1.5) \\approx 4</span>  full exponentiations in  <span class="math">\\mathbb{Z}_N^*</span> .</p>

    <p class="text-gray-300">A minor efficiency improvement There's a simple way to save on verification time and proof size. Currently, for  <span class="math">T=2^t</span>  we run the halving protocol for t rounds, and then in eq.(12) check if  <span class="math">y_{t+1} \\stackrel{?}{=} x_{t+1}^2</span> . For any integer  <span class="math">\\Delta \\geq 0</span>  we could run the protocol for just  <span class="math">t-\\Delta</span>  rounds, but then the verifier must check if  <span class="math">y_{t+1-\\Delta} \\stackrel{?}{=} x_{t+1-\\Delta}^{2^2}</span> , which requires  <span class="math">2^\\Delta</span>  squarings (more generally, if T is not a power of 2 then the check becomes  <span class="math">y_{t+1-\\Delta} \\stackrel{?}{=} x_{t+1-\\Delta}^{2^{T}t+1-\\Delta} \\mod N</span>  where  <span class="math">T_1 = T, T_i = \\lceil T_{i-1}/2 \\rceil</span> ).</p>

    <p class="text-gray-300">If we set, say  <span class="math">\\Delta = 10</span> , this saves 10 rounds and thus reduces the proof size by 25% from 40 to 30 elements. The verification time decreases by around 15% (we save 20 short exponentiations as in eq.(10,11) at the price of 1024 extra squarings).</p>

    <p class="text-gray-300">Cost of computing the proof Computing the proof  <span class="math">(y, \\pi) \\leftarrow \\mathsf{VDF}.\\mathsf{Sol}(N, (x, T))</span>  requires one to solve the underlying RSW puzzle  <span class="math">y = x^{2^T}</span> , which is done by squaring x sequentially T times (the security of the RSW puzzle and thus also our VDF relies on the assumption that there's no shortcut to this computation).</p>

    <p class="text-gray-300">On top of that, for the VDF we also must compute the proof  <span class="math">\\pi = \\{\\mu_i\\}_{i \\in [t]}</span>  where  <span class="math">\\mu_i = x_i^{2^{T/2^i}}</span> . But we still assume that  <span class="math">T = 2^t</span>  is a power of 2.</p>

    <p class="text-gray-300">If naïvely implemented, computing the  <span class="math">\\mu_i</span>  will require T/2 squarings for  <span class="math">\\mu_1</span> , T/4 for  <span class="math">\\mu_2</span>  etc., adding up to a total of  <span class="math">T \\approx T/2 + T/4 + T/8 \\dots + 1</span></p>

    <p class="text-gray-300"><sup>&</sup>lt;sup>6</sup> Exponentiation is typically done via "square and multiply", which for a z bit exponent with hamming weight h(z) requires z + h(z) multiplications, or about  <span class="math">1.5 \\cdot z</span>  multiplication for a random exponent (where  <span class="math">h(z) \\approx z/2</span> ).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><sup>&</sup>lt;sup>7</sup> Here multiplication means the  <span class="math">\\circ</span>  operation, which requires one multiplication modulo N, followed by the map  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ . As the cost of this map is marginal compared to the multiplication we just ignore it.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">sequential steps. Fortunately we don't have to compute  <span class="math">\\mu_1 = x^{2^{T/2}}</span>  as we already did so while computing  <span class="math">y = x^{2^T}</span>  by repeated squaring (cf. eq.(2)). This observation already saves us half the overhead. We can also compute the remaining  <span class="math">\\mu_2, \\mu_3, \\ldots</span>  using stored values, but it becomes increasingly costly, as we discuss below.</p>

    <p class="text-gray-300">In general, for some  <span class="math">s \\in [t]</span>  the prover can compute  <span class="math">\\mu_1, \\ldots, \\mu_s</span>  using stored values, and then fully recompute the remaining  <span class="math">\\mu_{s+1} = x_{s+1}^{2^{T/2^{s+1}}}, \\mu_{s+2}, \\ldots, \\mu_t</span>  which will only require  <span class="math">T/2^{s+1} + T/2^{s+2} \\ldots &lt; T/2^s</span>  squarings.</p>

    <p class="text-gray-300">To see how the  <span class="math">\\mu_i</span> 's can be efficiently computed for small i, for  <span class="math">z \\in QR_N^+</span>  let  <span class="math">\\overline{z}</span>  denote z's log to basis x, i.e.,  <span class="math">x^{\\overline{z}} = z</span> . We have  <span class="math">\\overline{x}_1 = 1</span> ,  <span class="math">\\overline{y}_1 = 2^T</span>  and</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\overline{\\mu}_i &amp;:= \\overline{x}_i \\cdot 2^{T/2^i} \\\\ \\overline{x}_{i+1} &amp;:= r_i \\cdot \\overline{x}_i + \\overline{\\mu}_i \\\\ \\overline{y}_{i+1} &amp;:= r_i \\cdot \\overline{\\mu}_i + \\overline{y}_i \\end{split}</span></div>

    <p class="text-gray-300">How those exponents concretely develop for i=1 to 3 is illustrated in Figure 1. For example, we can compute  <span class="math">\\mu_3</span>  assuming we stored the  <span class="math">x^{2^{T/8}}, x^{2^{T3/8}}, x^{2^{T5/8}}, x^{2^{T7/8}}</span>  values as</p>

    <div class="my-4 text-center"><span class="math-block">\\mu_3 = (x^{2^{T/8}})^{r_1 \\cdot r_2} \\cdot (x^{2^{T5/8}})^{r_2} \\cdot (x^{2^{T3/8}})^{r_1} \\cdot x^{2^{T7/8}}</span></div>

    <p class="text-gray-300">In general, computing  <span class="math">\\mu_1, \\ldots, \\mu_s</span>  will require to store  <span class="math">2^s</span>  values  <span class="math">\\{x^{2^{T \\cdot i/2^s}}\\}_{i \\in [2^s]}</span> , and then compute  <span class="math">2^s</span>  exponentiations with exponents of bitlength at most  <span class="math">\\lambda \\cdot (s-1)</span>  (and half that on average). We can't speed this up by first taking the exponents modulo the group order p'q' as it is not know, but if we have bounded parallelism  <span class="math">2^p</span> ,  <span class="math">p \\le (s-2)</span>  this can be done in  <span class="math">2^{s-p} \\cdot \\lambda \\cdot (s-1) \\cdot \\frac{3}{4}</span>  sequential steps. Summing up, with sufficient space to store  <span class="math">2^s</span>  elements in  <span class="math">\\mathbb{Z}_N</span>  and  <span class="math">2^p \\le 2^s</span>  parallelism the proof  <span class="math">\\pi</span>  can be computed in roughly</p>

    <p class="text-gray-300"><span class="math-block">2^{s-\\mathsf{p}} \\cdot \\lambda \\cdot (s-1) \\cdot \\frac{3}{4} + 2^{t-s}</span>  sequential steps and  <span class="math">2^s \\cdot \\log(N)</span>  bits of storage</p>

    <p class="text-gray-300">after y has been computed. For example with a single core p = 0 and  <span class="math">s = t/2 - \\log(t \\cdot \\lambda)/2</span>  the number of steps (i.e.,  <span class="math">\\circ</span>  operations) becomes</p>

    <div class="my-4 text-center"><span class="math-block">2^{t/2 - \\log(t \\cdot \\lambda)/2} \\cdot \\lambda \\cdot (s-1) \\cdot \\frac{3}{4} + 2^{t/2 + \\log(t \\cdot \\lambda)/2} = 2^{t/2} \\left( \\frac{\\lambda(s-1)}{\\sqrt{t\\lambda}} \\cdot \\frac{3}{4} + \\sqrt{t\\lambda} \\right) &lt; \\sqrt{T} \\cdot \\frac{11}{8} \\cdot \\sqrt{\\log(T) \\cdot \\lambda}</span></div>

    <p class="text-gray-300">For our typical values  <span class="math">t=40, \\lambda=100</span>  this is  <span class="math">\\leq 2^{27}</span> , and thus over  <span class="math">2^{40-27}=2^{13}</span>  times faster than computing y, e.g. if computing y takes 1h, computing  <span class="math">\\pi</span>  just takes half a second on top. The memory required (to store intermediate values) is around  <span class="math">2^s \\cdot \\log N = 2^{t/2 - \\log(t \\cdot \\lambda)/2} \\cdot 1024 \\leq 2^{27}</span>  bits, or 8MB.</p>

    <p class="text-gray-300"><img src="_page_18_Figure_0.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300"><strong>Fig. 1.</strong> Exponents of the values in the protocol, here  <span class="math">z = x^{\\overline{z}}</span> .</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">6.3 Security of the VDF</h3>

    <p class="text-gray-300"><strong>Soundness</strong> If we model <em>hash</em> as a random oracle, then by Lemma 1 (which is used in the proof of Theorem 1) we are guaranteed that a malicious prover will not find an accepting proof  <span class="math">(\\tilde{y}, \\tilde{\\pi})</span>  for a wrong statement  <span class="math">\\tilde{y} \\neq x^{2^T}</span>  except with exponentially small probability. We can even let the malicious prover choose the challenge (x, T) for which it must forge such a proof itself, the only restriction being that x must be a generator  <span class="math">\\langle x \\rangle = QR_N^+</span>  (a random  <span class="math">x \\in QR_N^+</span>  satisfies this almost certainly, but we can't efficiently verify if a given x is such a generator).</p>

    <p class="text-gray-300">The well known Fiat-Shamir heuristic states that replacing the prover's queries with the output of a random oracle in a sound public-coin interactive proof system results in a sound non-interactive proof system, but this only applies for protocols with a constant number of rounds.</p>

    <p class="text-gray-300">Even though our protocol has logarithmically many rounds, we can directly conclude that our non-interactive proof is sound as follows: if we are given a valid proof for a wrong statement, then, during the execution of the verification algorithm for this proof, we must make a query  <span class="math">hash(x_i, T/2^{i-1}, y_i, \\mu_i)</span>  where  <span class="math">(N, x_i, T/2^{i-1}, y_i) \\in \\mathcal{L}</span>  ( <span class="math">\\mathcal{L}</span>  as defined in §4) but for the next query made  <span class="math">hash(x_{i+1}, T/2^i, y_{i+1}, \\mu_{i+1})</span>  we have  <span class="math">(N, x_{i+1}, T/2^i, y_{i+1}) \\notin \\mathcal{L}</span> . By Lemma 1, every random oracle query will correspond to such a query with probability at most  <span class="math">3/2^{\\lambda}</span> . Thus, by the union bound, the probability that a malicious prover that makes up to q queries to hash will find such a query (which as outlined is necessary to find an accepting proof for a wrong statement) is at most  <span class="math">q \\cdot 3/2^{\\lambda}</span> .</p>

    <p class="text-gray-300"><strong>Sequentiality</strong> To break sequentiality means computing y faster than in T sequential computations. We rely on the same assumption as [RSW96], which simply states that such a shortcut does not exist. As outlined in  <span class="math">\\S 2</span> , the fact that we work over  <span class="math">(QR_N^+, \\circ)</span>  not  <span class="math">(\\mathbb{Z}_N, \\cdot)</span>  only makes the assumption on which we rely weaker, and the fact that in our case N is the product of safe primes doesn't affect the assumption assuming that safe primes are not too sparse.</p>

    <h2 id="sec-29" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BBBF18] Dan Boneh, Joseph Bonneau, Benedikt B¨unz, and Ben Fisch. Verifiable delay functions. In Hovav Shacham and Alexandra Boldyreva, editors, CRYPTO 2018, Part I, volume 10991 of LNCS, pages 757–788. Springer, Heidelberg, August 2018.</li>

      <li>[BBF18] Dan Boneh, Benedikt B¨unz, and Ben Fisch. A survey of two verifiable delay functions. Cryptology ePrint Archive, Report 2018/712, 2018. https://eprint.iacr.org/2018/712.</li>

      <li>[BBHM02] Ingrid Biehl, Johannes A. Buchmann, Safuat Hamdy, and Andreas Meyer. A signature scheme based on the intractability of computing roots. Des. Codes Cryptography, 25(3):223–236, 2002.</li>

      <li>[BPW12] David Bernhard, Olivier Pereira, and Bogdan Warinschi. How not to prove yourself: Pitfalls of the Fiat-Shamir heuristic and applications to Helios. In Xiaoyun Wang and Kazue Sako, editors, ASIACRYPT 2012, volume 7658 of LNCS, pages 626–643. Springer, Heidelberg, December 2012.</li>

      <li>[CP18] Bram Cohen and Krzysztof Pietrzak. Simple proofs of sequential work. In Jesper Buus Nielsen and Vincent Rijmen, editors, EUROCRYPT 2018, Part II, volume 10821 of LNCS, pages 451–467. Springer, Heidelberg, April / May 2018.</li>

      <li>[FS00] Roger Fischlin and Claus-Peter Schnorr. Stronger security proofs for RSA and Rabin bits. Journal of Cryptology, 13(2):221–244, March 2000.</li>

      <li>[HK09] Dennis Hofheinz and Eike Kiltz. The group of signed quadratic residues and applications. In Shai Halevi, editor, CRYPTO 2009, volume 5677 of LNCS, pages 637–653. Springer, Heidelberg, August 2009.</li>

      <li>[LFKN90] Carsten Lund, Lance Fortnow, Howard J. Karloff, and Noam Nisan. Algebraic methods for interactive proof systems. In 31st FOCS, pages 2–10. IEEE Computer Society Press, October 1990.</li>

      <li>[MMV13] Mohammad Mahmoody, Tal Moran, and Salil P. Vadhan. Publicly verifiable proofs of sequential work. In Robert D. Kleinberg, editor, ITCS 2013, pages 373–388. ACM, January 2013.</li>

      <li>[Pie19] Krzysztof Pietrzak. Simple verifiable delay functions. In 10th Innovations in Theoretical Computer Science Conference, ITCS 2019, January 10-12, 2019, San Diego, California, USA, pages 60:1–60:15, 2019.</li>

      <li>[RSW96] R. L. Rivest, A. Shamir, and D. A. Wagner. Time-lock puzzles and timedrelease crypto. Technical report, Cambridge, MA, USA, 1996.</li>

      <li>[Sha90] Adi Shamir. IP=PSPACE. In 31st FOCS, pages 11–15. IEEE Computer Society Press, October 1990.</li>

      <li>[Val08] Paul Valiant. Incrementally verifiable computation or proofs of knowledge imply time/space efficiency. In Ran Canetti, editor, TCC 2008, volume 4948 of LNCS, pages 1–18. Springer, Heidelberg, March 2008.</li>

      <li>[vzGS13] Joachim von zur Gathen and Igor E. Shparlinski. Generating safe primes. J. Mathematical Cryptology, 7(4):333–365, 2013.</li>

      <li>[Wes18] Benjamin Wesolowski. Efficient verifiable delay functions. Cryptology ePrint Archive, Report 2018/623, 2018. https://eprint.iacr.org/2018/623.</li>

    </ul>`;
---

<BaseLayout title="Simple Verifiable Delay Functions (2018/627)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2018 &middot; eprint 2018/627
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
