---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2012/515';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-18';
const TITLE_HTML = 'Semantically-Secure Functional Encryption: Possibility Results, Impossibility Results and the Quest for a General Definition';
const AUTHORS_HTML = 'Mihir Bellare&lt;sup&gt;1&lt;/sup&gt; Adam O&#x27;Neill&lt;sup&gt;2&lt;/sup&gt;';

const CONTENT = `    <p class="text-gray-300">Mihir Bellare&lt;sup&gt;1&lt;/sup&gt; Adam O'Neill&lt;sup&gt;2&lt;/sup&gt;</p>

    <p class="text-gray-300">August 2012</p>

    <h4 id="sec-1" class="text-lg font-semibold mt-6">Abstract</h4>

    <p class="text-gray-300">This paper explains that SS1-secure functional encryption (FE) as defined by Boneh, Sahai and Waters implicitly incorporates security under key-revealing selective opening attacks (SOA-K). This connection helps intuitively explain their impossibility results and also allows us to prove stronger ones. To fill this gap and move us closer to the (laudable) goal of a general and achievable notion of FE security, we seek and provide two &quot;sans SOA-K&quot; definitions of FE security that we call SS2 and SS3. We prove various possibility results about these definitions. We view our work as a first step towards the challenging goal of a general, meaningful and achievable notion of FE security.</p>

    <p class="text-gray-300">&lt;sup&gt;1&lt;/sup&gt; Department of Computer Science &amp; Engineering, University of California San Diego, 9500 Gilman Drive, La Jolla, California 92093, USA. Email: mihir@cs.ucsd.edu. URL: http://www.cs.ucsd.edu/users/mihir. Supported in part by NSF grants CNS-0627779 and CCF-0915675.</p>

    <p class="text-gray-300">&lt;sup&gt;2&lt;/sup&gt; Department of Computer Computer Science, Boston University, 111 Cummington St., Boston, MA 02215. Email: amoneill@bu.edu. URL: http://cs-people.bu.edu/amoneill. Supported in part by NSF grants 0546614, 0831281, 1012910, and 1012798.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-1-0&quot;&gt;&lt;/span&gt;1 Introduction</h3>

    <p class="text-gray-300">BACKGROUND. Functional encryption (FE) was introduced by Boneh, Sahai and Waters (BSW) [14]. A FE-scheme for a functionality  <span class="math">\\mathcal{F}</span> :  <span class="math">\\mathbb{N} \\times \\{0,1\\}^* \\times \\{0,1\\}^* \\to \\{0,1\\}^* \\cup \\{\\bot\\}</span>  is a tuple of algorithms  <span class="math">\\mathsf{FE} = (\\mathsf{Setup}, \\mathsf{KDer}, \\mathsf{Enc}, \\mathsf{Dec})</span> . An authority lets  <span class="math">(pk, sk) \\leftarrow \\mathsf{s} \\, \\mathsf{Setup}(\\lambda)</span> , where  <span class="math">\\lambda</span>  is the security parameter, and publishes pk. Anyone may now encrypt an input x via  <span class="math">c \\leftarrow \\mathsf{s} \\, \\mathsf{Enc}(pk, x)</span> . A user may provide the authority with a functionality index a and receive a secret key  <span class="math">sk_a \\leftarrow \\mathsf{s} \\, \\mathsf{KDer}(sk, a)</span> . If the user now applies the decryption algorithm to  <span class="math">sk_a</span>  and any encryption c of x, the result  <span class="math">\\mathsf{Dec}(sk_a, c)</span>  will equal  <span class="math">\\mathcal{F}(\\lambda, a, x)</span> . Security requires that the user learns nothing more.</p>

    <p class="text-gray-300">The intent was to generalize and unify many forms of encryption including IBE (Identity-based encryption) [32, 13], ABE (Attribute-based encryption) [31, 20] and PE (Predicate encryption) [22]. An existing form <strong>E</strong> of encryption would correspond to a functionality  <span class="math">\\mathcal{F}_{\\mathbf{e}}</span> . IBE for example corresponds to the functionality  <span class="math">\\mathcal{F}_{\\text{ibe}}</span>  which regards a as an identity and parses x as a pair (a', m) consisting of another identity a' and a message m, returning m if a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and</p>

    <p class="text-gray-300">BSW [14] sought a general definition of security that applied to an arbitrary functionality. They first provide an indistinguishability-based one (IND). It had the attractive feature of coinciding, for the IBE and PE functionalities, with the existing definitions of these notions from the literature. But both BSW [14] and O'Neill [29] point to inherent deficiencies of IND when it comes to capturing security of general functionalities. The &quot;main&quot; definition of BSW was accordingly a simulation-based semantic-security one that we call SS1. We may now speak of the SS1-security of an FE scheme FE for any functionality  <span class="math">\\mathcal{F}</span> .</p>

    <p class="text-gray-300">The FE framework is elegant and the goals are laudable. A proliferating number of notions of encryption are now put under a single umbrella, seen as special cases of a single primitive. Ad hoc, notion-specific security definitions need not be given. One only has to specify the functionality and SS1 security would return a suitable definition.</p>

    <p class="text-gray-300">IMPOSSIBILITY OF SS1 IN THE NPROM. However, having introduced SS1, BSW [14] claim that it can't be achieved in the standard model, even for IBE, which is the most basic functionality in this area. This is a strong and disappointing claim. Before we delve into its implications, we take a closer look at it. We point out that BSW don't actually prove this. What they prove is that SS1-secure IBE cannot be achieved in the NPROM (Non-Programmable Random Oracle Model). At a first glance, this only sounds like a stronger claim. Every standard model scheme is a NPROM scheme and every standard-model adversary is a NPROM one, so if NPROM achievability is ruled out, isn't standard model achievability ruled out as well? The answer is no. BSW [14] establish their claim by providing an adversary for which they prove that there is no simulator. But their adversary makes calls to the RO, and this is exploited crucially in the proof of non-existence of a simulator. Their proof does not rule out the existence of a simulator for adversaries that do not call the RO, meaning for standard-model adversaries, and thus it does not rule out standard-model achievability of SS1, even for IBE.</p>

    <p class="text-gray-300">This gives a ray of hope. Perhaps SS1-security can be achieved in the standard model after all. This would be interesting even for IBE and certainly beyond. This hope is fueled by a look at the technique underlying the negative result of BSW [14]. It is not a priori clear how to extend this technique to rule out simulators for standard-model adversaries.</p>

    <p class="text-gray-300">A NEW IMPOSSIBILITY RESULT FOR SS1. We fill the gap by showing that SS1-secure IBE is not achievable even in the standard model. The result is actually more general, ruling out SS1-security for <em>any non-trivial functionality</em>, IBE being covered as a special case. Non-triviality essentially means the functionality is not a constant function. The only assumption made is the existence of collision-resistant hash functions.</p>

    <p class="text-gray-300">Our result exploits the recent technique of Bellare, Dowsley, Waters and Yilek (BDWY) [5], used to prove the impossibility of SOA-secure commitment, in combination with techniques from Nielsen's</p>

    <p class="text-gray-300">&lt;span id=&quot;page-2-1&quot;&gt;&lt;/span&gt;proof of impossibility of non-committing encryption (NCE) <a href="#page-21-4">[26]</a>. We are able to present a standard model adversary for which we can prove that there is no simulator.</p>

    <p class="text-gray-300">Taking a closer look, our result, as is the case with those of Nielsen and BSW, is actually a trade-off. It shows that SS1-security requires long keys, this meaning that the total number of bits in messages securely encrypted must be bounded by the length of a secret key. However, it does this in the standard model.</p>

    <p class="text-gray-300">An explanation. This paper offers an explanation for this anamoly that seeds further contributions in a natural way. We contend that SS1 does not capture &quot;plain&quot; FE security. Instead, it captures FE security in the presence of key-revealing selective-opening attacks (SOA-Ks). These are attacks where the adversary may adaptively corrupt some users and obtain their decryption keys without restrictions. <a href="#page-2-0">1</a> The revealing fact is that, if we were to write down a definition of SOA-K-security for IBE, what emanates is exactly SS1-secure IBE. We now have a natural explanation of why SS1 is subject to such broad unachievability and also why SS1-secure IBE is not the same as the classical IND-secure IBE from <a href="#page-21-1">[13]</a>. Namely, the former incorporates SOA-K security and the latter does not.</p>

    <p class="text-gray-300">Why is SOA-K-security part of SS1? BSW <a href="#page-21-0">[14]</a> did not throw it in &quot;on purpose.&quot; (Their work has no explicit recognition of the fact that their definition incorporates security against SOA-K. They do however comment on the relation to NCE and <a href="#page-21-4">[26]</a>, which is only a step removed.) Rather, the natural approach to defining semantic security for a general functionality, which is the one followed by BSW <a href="#page-21-0">[14]</a>, leads to the inadvertent incorporation of SOA-K security.</p>

    <p class="text-gray-300">While it is usually easier to define &quot;plain&quot; security than security against SOA-K, with FE, it seems to be the opposite. It is not clear how to define semantically-secure FE in a way that &quot;decouples&quot; basic and SOA-K security. This, in our view, is rather interesting.</p>

    <p class="text-gray-300">SS2 and SS3. As indicated above, we believe that unifying different existing forms of encryption under a general definition for FE is a highly worthwhile goal. SS1 has not achieved this, capturing instead the SOA-K-secure versions of these goals and thence being subject to strong impossibility results. We move towards the just-stated goal with two new notions that we call SS2 and SS3. Definining &quot;sans SOA-K&quot; FE security in forms of varying strength, they are able to meet many of the broad goals in this domain and open the door to further efforts.</p>

    <p class="text-gray-300">Our main result about SS2 is that it is equivalent to IND for all functionalities. This equivalence has its plusses and its minuses. Let us begin with the former. IND-secure IBE as per <a href="#page-21-1">[13]</a> is a well established definition, targeted in thousands of papers and proven to work for applications, and INDsecure PE as per <a href="#page-21-3">[22]</a> is also accepted. The SS2=IND equivalence provides a semantic-security based backing for this IND definition which has so far been absent. Conceptually, it mirrors in the FE setting the classic equivalence between semantic-security and indistinguishability in the PKE setting <a href="#page-21-5">[18]</a> that is a cornerstone of our understanding of, and faith in, these definitions. More pragmatically, it immediately yields possibility results for semantically-secure FE which were absent under SS1. This is because INDsecure IBE is well-known to be achievable in the standard model <a href="#page-21-6">[11,</a> <a href="#page-22-3">36,</a> <a href="#page-22-4">34]</a>, and various possibility results for ABE and PE are known as well <a href="#page-21-2">[20,</a> <a href="#page-22-5">30,</a> <a href="#page-21-3">22,</a> <a href="#page-22-6">27,</a> <a href="#page-22-7">33,</a> <a href="#page-21-7">23,</a> <a href="#page-20-1">2,</a> <a href="#page-21-8">25,</a> <a href="#page-21-9">24,</a> <a href="#page-22-8">28]</a>.</p>

    <p class="text-gray-300">We believe this is progress towards bringing semantically-secure FE closer. But, while the equivalence of SS2 with IND is a plus for common functionalities like ABE, PE and IBE, it is a minus when looking further, for we already know that IND is not a good definition of FE security in general <a href="#page-22-2">[29]</a>. Thus, we would like another definition to complement SS2. We suggest SS3, a strengthening of SS2. We believe SS3 is a good candidate for a general definition of FE for arbitrary functionalties. One reason is that it does not appear to have the drawbacks of IND for beyond-PE functionalities. (BSW <a href="#page-21-0">[14]</a> and O'Neill <a href="#page-22-2">[29]</a> present IND-secure FE schemes that are intuitively insecure. However, their schemes will correctly be</p>

    <p class="text-gray-300">&lt;span id=&quot;page-2-0&quot;&gt;&lt;/span&gt;&lt;sup&gt;1&lt;/sup&gt; In the standard formulation of IBE, the adversary has a key-derivation oracle via which it may obtain decryption keys for identities of its choice, but use of the oracle is restricted to identities not underlying challenge ciphertexts. An SOA-K results when there are many challenge ciphertexts and this restriction is dropped. This is exactly what happens in SS1-secure FE. The interesting thing is that in the context of semantic security for general FE it is not clear how to make appropriate restrictions to exclude the SOA-K. We will elaborate in a bit.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-3-0&quot;&gt;&lt;/span&gt;SS3-insecure.) Another reason is that our impossibility result for SS1 does not extend to SS3. (So in particular, SS3-secure IBE is not ruled out.)</p>

    <p class="text-gray-300">In support of SS3 we show that it is equivalent to IND for &quot;re-sampleable&quot; functionalities. Unfortunately, re-sampleable functionalities does not seem to include common functionalities of interest such as IBE. Indeed, we have not been able to either prove or disprove the equivalence of SS3 with IND for PE functionalities. We suggest that IBE and PE schemes may be directly proven to meet SS3 and leave this as an interesting subject for future work. We note that recent independent and concurrent results of Agrawal et al. <a href="#page-20-2">[3]</a> (discussed further below) imply that there exists a functionality that cannot meet SS3. However, this situation is very different from that of SS1, for which we show that no non-trivial functionality can meet it. Indeed, we expect that there do exist IBE and PE schemes that meet SS3.</p>

    <p class="text-gray-300">A closer look. Recall that in IBE, the adversary is given a key-derivation oracle, allowing it to obtain a secret key for any identity of its choice. This does not by itself constitute a SOA-K because the adversary is not allowed to call this oracle for the identities underlying challenge ciphertexts. In the SS1 definition, the adversary also gets a key-derivation oracle to obtain a secret key for any functionality index a of its choice. But there seems no simple or natural way to make a rule disallowing querying this oracle on &quot;challenge&quot; ciphertexts because there is no general way to &quot;match&quot; indexes with ciphertexts. Indeed, any key allows the adversary to learn, in principle, something from all challenge ciphertexts and we can hardly disallow all queries. Instead, SS1 allows unrestricted key-derivation queries and gives a compensating ability to the simulator. But now it incorporates SOA-K and is thus rarely achievable.</p>

    <p class="text-gray-300">Roughly, the idea for SS2 is to run in parallel to the real game a &quot;shadow&quot; game where the inputs are independently generated as per the adversary-provided distributions. Key-derivation queries remain unrestricted. But at the end of the game, we check that the revealed keys don't &quot;differentiate&quot; the real and shadow games. We disallow adversaries who create such differentiation. In essence, this means that we require that the functionality take predictable values on the challenge messages when evaluated with the adversary's key derivation queries. One can compare this to the IND definition where the adversary is required to make key derivation queries that take the same value on the (known) challenge messages, so the adversary knows these values. Our definition may be written quite modularly relative to SS1, by adding appropriate boxed statements and checks in the games for the latter.</p>

    <p class="text-gray-300">Our SS3 definition strengthens SS2 by dropping the restriction put by SS2 on key-derivation queries made by an adversary before seeing a challenge ciphertext. As such, we believe the SS3 definition is an essentially as-strong-as-possible security definition for FE subject to the constraint that it be achievable without any unnatural restrictions on the adversary or message space. To see why, note the definition of &quot;unpredictable functionalities&quot; used for our impossibility result in Section <a href="#page-8-0">4</a> and the fact that the latter crucially uses the adversary's ability to make &quot;adaptive&quot; key-derivation queriesâ€”i.e., depending on a challenge ciphertext. In essence, the SS3 definition demands that the functionality restricted to the adversary's adaptive key derivation queries be predictable wrt. the message space.</p>

    <p class="text-gray-300">Standard-model possibility of SS1. Returning to SS1, the negative results discussed above imply that we will need long keys, but we do not know that this is sufficient. There exists only one positive result, and this is in the PROM. Namely, BSW <a href="#page-21-0">[14]</a> provide a long-key, SS1-secure FE scheme for any functionality F where the space of functionality indexes on which F is non-trivial has polynomial size. We extend their result to the standard model. We do this by (again) exploiting the SOA-K connection. Namely we establish the same conclusion as BSW but assuming only the existence of a SOA-K-secure PKE scheme, which we know exists in the standard model because we are allowing keys to be long <a href="#page-21-10">[15,</a> <a href="#page-21-11">16]</a>.</p>

    <p class="text-gray-300">Summary of contributions. We make a connection between selective-opening attacks (SOA-K) and FE by observing the implicit presence of the former in SS1, an observation that seeds all the further contributions of this paper, summarized as follows. (1) We show impossibility of SS1-secure FE in the standard model by exploiting techniques underlying negative results for SOA-K <a href="#page-20-0">[5]</a>. (2) We present the SS2 definition for sans-SOA-K FE and prove it equivalent to IND for all functionalties, thus obtaining a slew of possibility results for SS2 via known possibility results for IBE and PE. (3) We present the stronger &lt;span id=&quot;page-4-0&quot;&gt;&lt;/span&gt;SS3 definition to function as a potential target for functionalites beyond PE and prove a possibility result for it. (4) We extend the only known positive result for a general functionality, namely one from BSW <a href="#page-21-0">[14]</a> for the case that the the set of indexes on which the functionality is non-trivial has polynomial size, from the PROM (Programmable Random Oracle Model) to the standard model, by using as starting point a SOA-K-secure PKE scheme with large keys, which exists in the standard model <a href="#page-21-10">[15,</a> <a href="#page-21-11">16]</a>.</p>

    <p class="text-gray-300">Discussion and Related work. The observation underlying BSW's impossibility proof is that SS1 secure IBE must achieve something similar to NCE. O'Neill <a href="#page-22-2">[29]</a> had the same intuitive observation but did not take it to a result or proof. Our work can be viewed as taking this intuition further to say that SS1-secure IBE must be exactly SOA-K-secure IBE, and similarly for other functionalities.</p>

    <p class="text-gray-300">The difference between NCE and SOA-K is subtle but important, and under-recognized by the community. For example, some works say (for the PKE case) that SOA-K security is impossible with short keys, citing <a href="#page-21-4">[26]</a>. But, in ruling out NCE, the latter does not rule out SOA-K-security because there are potentially non-NCE ways to achieve SOA-K-security. Our techniques, however, rule out SOA-K-secure PKE with short keys. Although we have known an impossibility result for NCE for a decade, one for SOA-K has only emerged now.</p>

    <p class="text-gray-300">SOAs have so far mainly been considered in the public-key setting. The adversary gets a number of challenge ciphertexts, &quot;opens&quot; a subset of them, and aims to discover something about the messages underlying the rest. There are two kinds of SOAs. In a coin-revealing SOA (SOA-C) the ciphertexts are encrypted under a single public key and opening reveals the coins. Achieving security is challenging but has been done <a href="#page-20-3">[6,</a> <a href="#page-21-12">17,</a> <a href="#page-21-13">21]</a>. SOA-C-security was also considered and achieved for IBE <a href="#page-21-14">[9]</a>. SOA-C is not relevant to our present concerns. In a key-revealing SOA (SOA-K) for PKE, the ciphertexts are encrypted under different public keys and opening reveals the corresponding decryption keys. But SOA-K has not been defined or considered for IBE, let alone for FE. We claim SS1 is, implicitly, defining SOA-K secure FE.</p>

    <p class="text-gray-300">O'Neill <a href="#page-22-2">[29]</a> considers non-adaptive adversaries (meaning ones that don't make any key-derivation queries after seeing the challenge ciphertexts). He provides a non-adaptive version of SS1 and shows it equivalent to a non-adaptive version of IND for preimage sampleable functionalities. Most PE functionalities considered in the literature have this property.</p>

    <p class="text-gray-300">Independently, a recent breakthrough work of Gorbunov, Vaikuntanathan and Wee <a href="#page-21-15">[19]</a> shows that FE for all polynomial-time functionalities can be achieved, subject to the caveat that the adversary in the security experiment make up to q key-derivation queries, where q is fixed ahead of time. Interestingly, they make crucial use of the brute force scheme in their construction, instantiating it with a specific non-committing encryption scheme. (Since the construction only needs to be non-committing wrt. the receiver's secret key and not the sender's randomness, they use a simple construction from <a href="#page-21-11">[16]</a>.) Our result on the brute force scheme generalizes theirs as well as BSW's. Another recent breakthrough work of Waters <a href="#page-22-9">[35]</a> contructs public-index PE for regular languages. We believe this recent progress on FE constructions for broader classes of functionalities underscores the importance of our efforts on the definitional front.</p>

    <p class="text-gray-300">Also, interesting works on definitions of FE have emerged on eprint concurrently and independently of our work, namely Agrawal, Gorbunov, Vaikuntanathan and Wee (AGVW) <a href="#page-20-2">[3]</a> and Barbosa and Farshim (BF) <a href="#page-20-4">[4]</a>. AGVW present impossibility results for a wPRF based functionality for notions weaker than SS1. As discussed above, their results apply to SS3 and show that SS3 will not be met by all functionalities. They also propose a variant of SS1 that allows an unbounded simulator they call USIM. Interestingly, while they claim BSW's proof also applies to rule out USIM, this impossibility result inherits the same weaknesses we point out above for the basic impossibility result of BSW. Moreover, our improved impossibility result for SS1 assumes collision-resistant hash functions so does not to rule out USIM (because an unbounded simulator can break collision-resistance). Thus, to the best of our knowledge, whether USIM can be achieved is still open. On the other hand BF point to weaknesses in the BSW definition having to do with &quot;set-up&quot; security. Our definition of SS1 and its variants do not appear to inherit these weaknesses because the simulator is not allowed to choose the auxilliary input. (See the body of the &lt;span id=&quot;page-5-0&quot;&gt;&lt;/span&gt;paper for further explanation.) BF also propose variants of the definition that seem similar in spirit to our SS3 and show various possibility and impossibility results about them. We have not yet had a chance to do a detailed comparison to our results.</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">2 Notation and conventions</h4>

    <p class="text-gray-300">If A is an algorithm then  <span class="math">y \\leftarrow A(x_1, \\ldots, x_n; r)</span>  means we run A on inputs  <span class="math">x_1, \\ldots, x_n</span>  and coins r and denote the output by y. By  <span class="math">y \\leftarrow A(x_1, \\ldots, x_n)</span>  we denote the operation of picking r at random and letting  <span class="math">y \\leftarrow A(x_1, \\ldots, x_n; r)</span> . By  <span class="math">[A(x_1, \\ldots, x_n)]</span>  we denote the set of all y that have positive probability of being output by A on inputs  <span class="math">x_1, \\ldots, x_n</span> . Unless otherwise indicated, an algorithm may be randomized. &quot;PT&quot; stands for &quot;polynomial time.&quot; The security parameter is denoted  <span class="math">\\lambda \\in \\mathbb{N}</span>  and whenever  <span class="math">\\lambda</span>  is input to an algorithm it is understood that it is encoded in unary.</p>

    <p class="text-gray-300">If s is a string then |s| denotes its length, s[i] denotes its ith bit, and  <span class="math">s[i \\dots j]</span>  denotes the substring consisting of its ith through jth bits. If  <span class="math">\\mathbf{x}</span>  is a vector then  <span class="math">|\\mathbf{x}|</span>  denotes the number of its components,  <span class="math">\\mathbf{x}[i]</span>  denotes its ith component, and  <span class="math">\\mathbf{x}[i \\dots j]</span>  denotes the subvector consisting of its ith through jth components. We write  <span class="math">\\mathsf{El}(\\mathbf{x})</span>  to mean  <span class="math">\\{\\mathbf{x}[i]:1\\leq i\\leq |\\mathbf{x}|\\}</span> . If f is a function and  <span class="math">\\mathbf{x}</span>  is a vector then  <span class="math">f(x_1,\\dots,x_{i-1},\\mathbf{x},x_{i+1},\\dots,x_n)</span>  denotes the vector whose i-th component is  <span class="math">f(x_1,\\dots,x_{i-1},\\mathbf{x}[i],x_{i+1},\\dots,x_n)</span>  for  <span class="math">1\\leq i\\leq |\\mathbf{x}|</span> . A predicate is a function with boolean output.</p>

    <p class="text-gray-300">Games. We use the language of code-based game-playing [8]. A game has an Initialize procedure, procedures to respond to adversary oracle queries, and a Finalize procedure. A game G is executed with an adversary A and security parameter  <span class="math">\\lambda</span>  as follows. A is given input  <span class="math">\\lambda</span>  and can then call game procedures. Its first oracle query must be Initialize( <span class="math">\\lambda</span> ) and its last oracle query must be to Finalize, and it must make exactly one query to each of these oracles. In between it can query the other procedures as oracles as it wishes. The output of Finalize, denoted  <span class="math">G^A(\\lambda)</span> , is called the output of the game. Let  <span class="math">A^G(\\lambda)</span>  denote the output of the adversary and  <span class="math">T(G,A,\\lambda)</span>  denote  <span class="math">Pr[G^A(\\lambda)]</span>  outputs true.</p>

    <p class="text-gray-300">STANDARD PRIMITIVES. In Appendix A we recall the standard notions of public-key encryption and collision-resistant hashing.</p>

    <h2 id="sec-4" class="text-2xl font-bold">3 Functional Encryption and its Security</h2>

    <p class="text-gray-300">Functionalities and FE schemes. A functionality  <span class="math">\\mathcal{F}: \\mathbb{N} \\times \\{0,1\\}^* \\times \\{0,1\\}^* \\to \\{0,1\\}^* \\cup \\{\\bot\\}</span>  is a deterministic PT algorithm. The first input is the security parameter. The second input is called the index and the third input is called the payload. A functional encryption (FE) scheme is a tuple of algorithms  <span class="math">\\mathsf{FE} = (\\mathsf{Setup}, \\mathsf{KDer}, \\mathsf{Enc}, \\mathsf{Dec})</span> . The setup algorithm  <span class="math">\\mathsf{Setup}</span>  on input  <span class="math">\\lambda</span>  returns a key-pair (pk, sk), the master public and secret keys. The key-derivation algorithm  <span class="math">\\mathsf{KDer}</span>  on inputs sk, a returns a secret key dk for a. The encryption algorithm  <span class="math">\\mathsf{Enc}</span>  on inputs pk, x returns a ciphertext c. The deterministic decryption algorithm  <span class="math">\\mathsf{Dec}</span>  on inputs dk, c returns a string y. We say that an  <span class="math">\\mathsf{FE}</span>  scheme  <span class="math">\\mathsf{FE} = (\\mathsf{Setup}, \\mathsf{KDer}, \\mathsf{Enc}, \\mathsf{Dec})</span>  is  <span class="math">\\mathcal{F}</span> -correct, or simply an  <span class="math">\\mathcal{F}</span> - <span class="math">\\mathsf{FE}</span>  scheme, if  <span class="math">\\mathsf{Dec}(dk, \\mathsf{Enc}(pk, x; r)) = \\mathcal{F}(\\lambda, a, x)</span>  for all  <span class="math">\\lambda, a, x, r</span>  satisfying  <span class="math">\\mathcal{F}(\\lambda, a, x) \\neq \\bot</span> , all  <span class="math">(pk, sk) \\in [\\mathsf{Setup}(\\lambda)]</span>  and all  <span class="math">dk \\in [\\mathsf{KDer}(sk, a)]</span> . We stress that correctness makes no requirements when  <span class="math">\\mathcal{F}(\\lambda, a, x) = \\bot</span> . (We do not mandate that  <span class="math">\\mathsf{Dec}(dk, \\mathsf{Enc}(pk, x; r)) = \\mathcal{F}(\\lambda, a, x)</span>  in this case, but we do not disallow it either.)</p>

    <p class="text-gray-300">SYNTAX AND CORRECTNESS IN BSW. The range of a functionality in the formal definition of BSW [14] does not include  <span class="math">\\bot</span> , and correctness asks that  <span class="math">\\mathsf{Dec}(dk,\\mathsf{Enc}(pk,x;r)) = \\mathcal{F}(\\lambda,a,x)</span>  for all  <span class="math">\\lambda,a,x,r</span> , all  <span class="math">(pk,sk) \\in [\\mathsf{Setup}(\\lambda)]</span>  and all  <span class="math">dk \\in [\\mathsf{KDer}(sk,a)]</span> . However, specific functionalites given in BSW (such as that for IBE,  <span class="math">\\mathcal{F}^{\\mathsf{P},\\mathsf{p}}_{\\mathrm{ibe}}</span>  in our notation) do return  <span class="math">\\bot</span> . So it would appear that the formal syntax ought to be amended to add  <span class="math">\\bot</span>  to the range of  <span class="math">\\mathcal{F}</span> . Once this is done, the correctness condition of BSW must be revisited. If left unchanged, it would be asking that  <span class="math">\\mathsf{Dec}(dk,\\mathsf{Enc}(pk,x;r)) = \\mathcal{F}(\\lambda,a,x)</span>  even when  <span class="math">\\mathcal{F}(\\lambda,a,x) = \\bot</span> . This, however, would be incorrect. Attacks from [1] show that BB-style IBE schemes [10],</p>

    <p class="text-gray-300">&lt;span id=&quot;page-6-1&quot;&gt;&lt;/span&gt;including the BB IBE scheme [10] and Waters's IBE scheme [36], fail to meet this correctness condition relative to  <span class="math">\\mathcal{F}^{\\mathsf{P},\\mathsf{p}}_{\\mathrm{ibe}}</span> . It was not clear to us exactly what BSW intended but we expect they did intend for existing IBE schemes to meet the correctness condition, and accordingly we have relaxed it to only hold when  <span class="math">\\mathcal{F}(\\lambda,a,x)\\neq \\bot</span> .</p>

    <p class="text-gray-300">PARTICULAR FUNCTIONALITIES. The most important special case of FE in the literature is predicate encryption (PE). We say that  <span class="math">\\mathcal{F}</span>  is a predicate encryption functionality if there is a predicate  <span class="math">\\mathcal{P}</span>  such that  <span class="math">\\mathcal{F}</span>  is  <span class="math">\\mathcal{P}</span> -induced. This means that for all  <span class="math">\\lambda</span> , all  <span class="math">a \\neq \\varepsilon</span>  and all (a',m) we have  <span class="math">\\mathcal{F}(\\lambda,a,(a&#x27;,m)) = m</span>  if  <span class="math">\\mathcal{P}(\\lambda,a,a&#x27;)</span>  = true and  <span class="math">\\bot</span>  otherwise. (We also require that  <span class="math">\\mathcal{F}(\\lambda,a,x)</span>  returns  <span class="math">\\bot</span>  if x is not a pair. Note that no requirement is made on  <span class="math">\\mathcal{F}(\\lambda,\\varepsilon,(a&#x27;,m))</span> , so a single predicate could induce many different functionalities which vary in what is revealed under  <span class="math">a = \\varepsilon</span> .) We call m the message. The IBE predicate  <span class="math">\\mathcal{P}_{\\text{ibe}}</span>  is defined by  <span class="math">\\mathcal{P}_{\\text{ibe}}(\\lambda,a,a&#x27;) = (a=a&#x27;)</span> , and we say that  <span class="math">\\mathcal{F}</span>  is an IBE functionality if it is  <span class="math">\\mathcal{P}_{\\text{ibe}}</span> -induced. (So, again, there may be many different IBE functionalities.) Within the class of PE functionalities, we distinguish whether the index, the message, or both are to be kept private, with corresponding IBE functionalities as canonical examples:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Public index, private message: We say that  <span class="math">\\mathcal{F}</span>  is a  <span class="math">(\\mathsf{P},\\mathsf{p})</span> -PE functionality if  <span class="math">\\mathcal{F}(\\lambda,\\varepsilon,(a&#x27;,m))=(a&#x27;,|m|)</span> . Called PE with public index in the literature. The canonical example is the IBE functionality  <span class="math">\\mathcal{F}^{\\mathsf{P},\\mathsf{p}}_{\\mathrm{ibe}}</span>  which sets  <span class="math">\\mathcal{F}^{\\mathsf{P},\\mathsf{p}}_{\\mathrm{ibe}}(\\lambda,\\varepsilon,(a&#x27;,m))=(a&#x27;,|m|)</span> , corresponding to IBE that hides the message but not necessarily the identity.</li>
      <li>Private index, private message: We say that  <span class="math">\\mathcal{F}</span>  is a (p,p)-PE functionality if  <span class="math">\\mathcal{F}(\\lambda,\\varepsilon,(a&#x27;,m))=|m|</span> . Called PE with private index in the literature. The canonical example is the IBE functionality  <span class="math">\\mathcal{F}_{ibe}^{p,p}</span>  which sets  <span class="math">\\mathcal{F}_{ibe}^{p,p}(\\lambda,\\varepsilon,(a&#x27;,m))=|m|</span> , corresponding to IBE that hides both the message and the identity (i.e. is anonymous).</li>
      <li>Private index, public message: We say that  <span class="math">\\mathcal{F}</span>  is a (p, P)-PE functionality if  <span class="math">\\mathcal{F}(\\lambda, \\varepsilon, (a&#x27;, m)) = m</span> . Called predicate-only PE in the literature. The canonical example is the IBE functionality  <span class="math">\\mathcal{F}_{ibe}^{p,P}</span>  which sets  <span class="math">\\mathcal{F}_{ibe}^{p,P}(\\lambda, \\varepsilon, (a&#x27;, m)) = m</span> , corresponding to IBE that hides the identity but not necessarily the message. PEKS [12] is a (p, P)-PE functionality that additionally satisfies robustness [1].</li>
    </ul>

    <p class="text-gray-300">We don't discuss (P, P)-PE because it reveals everything and is uninteresting.</p>

    <p class="text-gray-300">SS1 DEFINITION. The following definition is adapted from [14]. Let  <span class="math">\\mathsf{FE} = (\\mathsf{Setup}, \\mathsf{KDer}, \\mathsf{Enc}, \\mathsf{Dec})</span>  be an  <span class="math">\\mathcal{F}\\text{-FE}</span>  scheme. The definition uses games  <span class="math">\\mathsf{RSS1}_{\\mathsf{FE},\\mathcal{F},Z,D,R}</span>  and  <span class="math">\\mathsf{ISS1}_{\\mathcal{F},Z,D,R}</span>  of Figure 1. We provide some intuition for these games below. We say that  <span class="math">\\mathsf{FE}</span>  is  <span class="math">\\mathsf{SS1}\\text{-}\\mathsf{secure}</span>  if for every auxiliary input generator Z, every PT message sampler D, every PT relation R and every PT adversary A, there is a PT simulator S such that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\mathrm{ss1}}_{\\mathsf{FE},\\mathcal{F},A,S,Z,D,R}(\\cdot) \\ = \\ T(\\mathrm{RSS1}_{\\mathsf{FE},\\mathcal{F},Z,D,R},A,\\cdot) - T(\\mathrm{ISS1}_{\\mathcal{F},Z,D,R},S,\\cdot)</span>$</p>

    <p class="text-gray-300">is negligible. We note that the auxiliary input will be used in our impossibility result in Section 4 (where it contains a key for a collision-resistant hash function). Although we omit to do this for simplicity because it does not affect our results, it can also be given as an additional argument to a functionality itself. For example, in the case of the inner-product functionality introduced in [22] it can then contain the modulus N of unknown factorization.</p>

    <p class="text-gray-300">Intuitive overview of the definition. To gain some intuition for the games, let us first look at the &quot;real world&quot; game with the adversary. It has access to two main oracles, an encryption oracle Enc and key-derivation oracle Kd. The former takes input  <span class="math">\\alpha</span> , which describes a message-space from which to sample, and outputs the encryption of a sampled message x. The latter takes as input a functionality index a and returns a corresponding secret key. Note that the game records the queries made to these oracles, in order, and provides this as input to the relation R. Now let us look at the &quot;ideal world&quot; game</p>

    <p class="text-gray-300">&lt;span id=&quot;page-6-0&quot;&gt;&lt;/span&gt;The difficulty is that correctness is required for all x, a and thus when x = (a', m) with  <span class="math">a&#x27; \\neq a</span> , it is required that  <span class="math">\\mathsf{Dec}(dk, \\mathsf{Enc}(pk, (a&#x27;, m); r)) = \\bot</span>  when  <span class="math">dk \\in [\\mathsf{KDer}(sk, a)]</span> . This is a form of robustness as defined in [1] and, as indicated there, often useful, but it is not a standard requirement for IBE schemes and most don't meet it.</p>

    <pre><code class="language-text">PROC INITIALIZE(\\lambda):
PROC INITIALIZE(\\lambda):
                                                                                                                                   PROC INITIALIZE(\\lambda):
                                                              i, j \\leftarrow 0 \\; ; \\; St \\leftarrow \\varepsilon
                                                                                                                                   (pk, sk) \\leftarrow \\$ \\operatorname{\\mathsf{Setup}}(\\lambda) \\; ; \\; i, j \\leftarrow 0
(pk, sk) \\leftarrow s Setup(\\lambda)
                                                              z \\leftarrow s Z(\\lambda)
z \\leftarrow s Z(\\lambda)
                                                                                                                                  Return pk
                                                              Return z
i, j \\leftarrow 0; St \\leftarrow \\varepsilon
                                                                                                                                  PROC LR(x_0, x_1)
Return (pk, z)
                                                              PROC Msg(\\alpha):
                                                                                                                                  i \\leftarrow i + 1; (\\mathbf{x}_0[i], \\mathbf{x}_1[i]) \\leftarrow (x_0, x_1)
                                                              i \\leftarrow i + 1
PROC ENC(\\alpha):
                                                                                                                                  \\mathbf{c}[i] \\leftarrow \\$ \\operatorname{Enc}(pk, x_b)
                                                              \\mathbf{q}[i] \\leftarrow \\alpha \\; ; \\; \\mathbf{t}[i] \\leftarrow \\mathsf{enc}
i \\leftarrow i+1
                                                                                                                                  Return \\mathbf{c}[i]
                                                              (St, \\mathbf{x}[i]) \\leftarrow D(St, \\alpha)
\\mathbf{q}[i] \\leftarrow \\alpha \\; ; \\; \\mathbf{t}[i] \\leftarrow \\mathsf{enc}
                                                                                                                                  PROC KD(a):
                                                              Return \\mathcal{F}(\\lambda, \\varepsilon, \\mathbf{x}[i])
(St, \\mathbf{x}[i]) \\leftarrow s D(St, \\alpha)
                                                                                                                                  j \\leftarrow j + 1; \\mathbf{a}[j] \\leftarrow a
\\mathbf{c}[i] \\leftarrow \\$ \\mathsf{Enc}(pk, \\mathbf{x}[i])
                                                              PROC OP(a):
                                                                                                                                  dk \\leftarrow s \\mathsf{KDer}(sk, a)
Return (\\mathbf{c}[i], \\mathcal{F}(\\lambda, \\varepsilon, \\mathbf{x}[i]))
                                                              i \\leftarrow i + 1
                                                                                                                                  Return dk
                                                              \\mathbf{q}[i] \\leftarrow a \\; ; \\; \\mathbf{t}[i] \\leftarrow \\mathsf{kd}
PROC KD(a):
                                                                                                                                  PROC FINALIZE(b&#x27;):
                                                              Return \\varepsilon
i \\leftarrow i + 1
                                                                                                                                  \\mathbf{a}[j+1] \\leftarrow \\varepsilon
\\mathbf{q}[i] \\leftarrow a \\; ; \\; \\mathbf{t}[i] \\leftarrow \\mathsf{kd}
                                                              PROC F(a, s):
                                                                                                                                  For j&#x27; = 1, ..., j + 1 do
dk \\leftarrow * \\mathsf{KDer}(sk, a)
                                                              If a \\in \\mathsf{El}(\\mathbf{a}) and 1 \\le s \\le i then
                                                                                                                                         If \\mathcal{F}(\\lambda, \\mathbf{a}[j&#x27;], \\mathbf{x}_0) \\neq \\mathcal{F}(\\lambda, \\mathbf{a}[j&#x27;], \\mathbf{x}_1) then
Return dk
                                                                     Return \\mathcal{F}(\\lambda, a, \\mathbf{x}[s])
                                                                                                                                                return false
                                                              Else return \\perp
PROC FINALIZE(w):
                                                                                                                                  Return (b&#x27;=1)
Return R(\\lambda, z, \\mathbf{x}, \\mathbf{q}, \\mathbf{t}, St, w)
                                                             PROC FINALIZE(w):
                                                             Return R(\\lambda, z, \\mathbf{x}, \\mathbf{q}, \\mathbf{t}, St, w)
</code></pre>

    <p class="text-gray-300">&lt;span id=&quot;page-7-0&quot;&gt;&lt;/span&gt;Figure 1: Left: &quot;Real world&quot; game  <span class="math">RSS1_{\\mathsf{FE},\\mathcal{F},Z,D,R}</span>  for the SS1 definition. Middle: &quot;Ideal world&quot; game  <span class="math">ISS1_{\\mathcal{F},Z,D,R}</span>  for the SS1 definition. Right: game  <span class="math">IND_{\\mathsf{FE},\\mathcal{F},b}</span>  for the IND definition.</p>

    <p class="text-gray-300">with the simulator. The simulator has access to not two but three main oracles, a message sampling oracle Msg, an operation oracle OP, and a functionality oracle F. The first on input  <span class="math">\\alpha</span> , which again describes a message-space from which to sample, samples a message x but simply returns  <span class="math">\\mathcal{F}(\\lambda, \\varepsilon, x)</span> . (We follow BSW [14] in using the value under index  <span class="math">\\varepsilon</span>  to describe what information about the message is publicly computable from a ciphertext.) The second records that an input functionality index a is &quot;legal to be used&quot; by the last oracle. The last oracle takes such an index a and a position s to return  <span class="math">\\mathcal{F}(\\lambda, a, x_s)</span>  where  <span class="math">x_s</span>  is the sth sampled message by Msg. Intuitively, OP queries of the simulator correspond to KD queries of the adversary, and indeed they are input to the relation R in the analogous manner. F queries can always be made &quot;for free&quot; by the simulator (they are not input to R).</p>

    <p class="text-gray-300">DISCUSSION OF SS1. We have discussed SS1 as being the BSW [14] definition, which it is in spirit, but there are some differences in detail. BSW indicate that there are several dimensions of choice. They choose to formalize a non-adaptive version with blackbox simulators, saying that variants may be formalized similarly. We have chosen to formalize the variant with adaptive security and non-blackbox simulation. BSW give pk as input to the relation and we do not, but this choice does not matter. However, a novelty of our definition is the introduction of auxiliary inputs. Besides what is noted above in their regard, we note that our use of auxiliary inputs rescues our definitions from the weaknesses of the BSW definition pointed out in BF [4]. The issue raised by the latter arises with a functionality, such as inner-product PE [22], that depends on a parameter, such as a hard-to-factor modulus, that must be generated in a setup phase. Under BSW [14] and O'Neill [29], this would have to be done by the Setup algorithm of the FE scheme and the modulus would be part of pk. The problem raised by BF [4] then occurs because the simulator can pick pk. We, however, do not give pk as input to  <span class="math">\\mathcal{F}</span>  and would capture setup-based functionalities by having the setup done by the auxiliary input generator algorithm Z, so that the modulus, in our example, would be part of the output z of this algorithm. However, the simulator is not allowed to pick z, and thus the attack of BF [4] would not appear to apply.</p>

    <p class="text-gray-300">IND DEFINITION. Let FE = (Setup, KDer, Enc, Dec) be an  <span class="math">\\mathcal{F}</span> -FE scheme. The definition uses game</p>

    <pre><code class="language-text">PROC INITIALIZE(\\lambda):
                                                                  z \\leftarrow s Z(\\lambda)
z \\leftarrow s Z(\\lambda)
                                                                  Return z
i, j \\leftarrow 0; St \\leftarrow \\varepsilon; St \\leftarrow St
Return (pk, z)
                                                                                                                                             PROC FINALIZE(w):
PROC ENC(\\alpha):
                                                                  \\mathbf{q}[i] \\leftarrow \\alpha \\; ; \\; \\mathbf{t}[i] \\leftarrow \\mathsf{enc}
                                                                                                                                              \\mathbf{q}[j+1]
i \\leftarrow i + 1
                                                                  (St, \\mathbf{x}[i]) \\leftarrow *D(St, \\alpha)
                                                                                                                                              For j&#x27; = 1, ..., j + 1 do
\\mathbf{q}[i] \\leftarrow \\alpha \\; ; \\; \\mathbf{t}[i] \\leftarrow \\mathsf{enc}
                                                                                                                                                     If \\mathbf{t}[i&#x27;] = \\mathsf{kd} then
(St, \\mathbf{x}[i]) \\leftarrow D(St, \\alpha)
                                                                                                                                                             If \\mathcal{F}(\\lambda, \\mathbf{q}[j&#x27;], \\mathbf{x}) \\neq \\mathcal{F}(\\lambda, \\mathbf{q}[j&#x27;], \\mathbf{x}&#x27;) then
(St&#x27;, \\mathbf{x}&#x27;[i]) \\leftarrow s D(St&#x27;, \\alpha)
                                                                                                                                                                     bad \\leftarrow true
                                                                  PROC OP(a):
\\mathbf{c}[i] \\leftarrow \\operatorname{sEnc}(pk, \\mathbf{x}[i])
                                                                  i \\leftarrow i + 1
                                                                                                                                             Return R(\\lambda, z, \\mathbf{x}, \\mathbf{q}, \\mathbf{t}, St, w)
Return (\\mathbf{c}[i], \\mathcal{F}(\\lambda, \\varepsilon, \\mathbf{x}[i]))
                                                                  \\mathbf{q}[i] \\leftarrow a \\; ; \\; \\mathbf{t}[i] \\leftarrow \\mathsf{kd}
PROC KD(a):
                                                                  Return \\varepsilon
i \\leftarrow i + 1
                                                                  PROC F(a, s):
\\mathbf{q}[i] \\leftarrow a \\; ; \\; \\mathbf{t}[i] \\leftarrow \\mathsf{kd}
                                                                  If a \\in \\mathsf{El}(\\mathbf{a}) and 1 \\le s \\le i then
dk \\leftarrow \\text{\\$} \\mathsf{KDer}(sk, a)
                                                                          Return \\mathcal{F}(\\lambda, a, \\mathbf{x}[s])
Return dk
</code></pre>

    <p class="text-gray-300">&lt;span id=&quot;page-8-1&quot;&gt;&lt;/span&gt;Figure 2: Left: &quot;Real world&quot; game  <span class="math">RSS2_{\\mathsf{FE},\\mathcal{F},Z,D,R}</span>  for the SS2 definition. Middle: &quot;Ideal world&quot; game  <span class="math">ISS2_{\\mathcal{F},Z,D,R}</span>  for the SS2 definition. Right: FINALIZE procedure, common to the two games.</p>

    <p class="text-gray-300"><span class="math">IND_{\\mathsf{FE},\\mathcal{F},b}</span>  of Figure 1 for  <span class="math">b \\in \\{0,1\\}</span> . We say that  <span class="math">\\mathsf{FE}</span>  is IND-secure if for every adversary B,</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\mathrm{ind}}_{\\mathsf{FE},\\mathcal{F},B}(\\cdot) \\ = \\ T(\\mathrm{IND}_{\\mathsf{FE},\\mathcal{F},1},B,\\cdot) - T(\\mathrm{IND}_{\\mathsf{FE},\\mathcal{F},0},B,\\cdot)</span>$</p>

    <p class="text-gray-300">is negligible.</p>

    <p class="text-gray-300">ROBUSTNESS. Robustness, introduced for IBE and PKE in [1], seems important more generally for FE, particularly for predicate-only predicate encryption. To explain the issue, recall that correctness was mute in the case that  <span class="math">\\mathcal{F}(\\lambda, a, x) = \\bot</span> , meaning in this case no requirement was put on the output of  <span class="math">\\mathsf{Dec}(dk, \\mathsf{Enc}(pk, x))</span>  when  <span class="math">dk \\in [\\mathsf{KDer}(sk, a)]</span> . Roughly, robustness asks that  <span class="math">\\mathsf{Dec}(dk, \\mathsf{Enc}(pk, x)) = \\bot</span>  in this case. In the case of PEKS this is important to avoid false positives in the testing.</p>

    <p class="text-gray-300">The reason it is not quite so simple is that asking for the above condition globally and unconditionally seems to yield something that is hard to achieve. Instead, one can ask for various computational relaxations in the style of [1]. To exemplify, here is one that is very strong but attractive due to its simplicity: procedure Initialize( <span class="math">\\lambda</span> ) of game ROB&lt;sub&gt;FE,F&lt;/sub&gt; lets  <span class="math">(pk, sk) \\leftarrow s</span>  Setup( <span class="math">\\lambda</span> ) and returns both keys, meaning the adversary gets sk. Finalize(a, x) returns  <span class="math">((\\mathcal{F}(\\lambda, a, x) = \\bot) \\land (\\mathsf{Dec}(\\mathsf{KDer}(sk, a), \\mathsf{Enc}(pk, x)) \\neq \\bot)</span> .</p>

    <h2 id="sec-5" class="text-2xl font-bold">&lt;span id=&quot;page-8-0&quot;&gt;&lt;/span&gt;4 Impossibility Results</h2>

    <p class="text-gray-300">We show that the SS1 notion is <em>impossible</em> to achieve in the <em>standard model</em>, so long as the functionality is reasonably likely to take more than one possible value on a challenge message. This result only assumes the existence of a collision-resistant hash function.</p>

    <p class="text-gray-300">Following [14] we also consider a relaxation of the SS1 notion where vectors  <span class="math">\\mathbf{a}</span> ,  <span class="math">\\boldsymbol{\\alpha}</span>  are replaced by unordered sets, thus giving the simulator more power (since it can make its queries in a different order than the adversary). We obtain a similar but more restrictive impossibility result in this case. Here we present the ordered case. The unordered one is in Appendix B.</p>

    <p class="text-gray-300">UNPREDICTABLE FUNCTIONALITIES. In the ordered case our result applies to any unpredictable functionality. Let  <span class="math">\\mathcal{F}</span>  be a functionality,  <span class="math">\\mathcal{A} = \\{a_{\\lambda}\\}_{{\\lambda} \\in \\mathbb{N}}</span>  be a family of functionality indices (strings), and  <span class="math">\\mathcal{X} = \\{X_{\\lambda}\\}_{{\\lambda} \\in \\mathbb{N}}</span>  be a family of payload distributions. We say that  <span class="math">\\mathcal{F}</span>  is  <span class="math">p(\\cdot)</span> -unpredictable wrt.  <span class="math">\\mathcal{A}, \\mathcal{X}</span>  if for</p>

    <pre><code class="language-text">PROC INITIALIZE(\\lambda):
z \\leftarrow s Z(\\lambda)
                                                                Return z
i, j \\leftarrow 0; St \\leftarrow \\varepsilon; St&#x27; \\leftarrow \\varepsilon
                                                                PROC Msg(\\alpha):
Return (pk, z)
PROC ENC(\\alpha):
                                                                \\mathbf{q}[i] \\leftarrow \\alpha \\; ; \\; \\mathbf{t}[i] \\leftarrow \\mathsf{enc}
i \\leftarrow i + 1
                                                                (St, \\mathbf{x}[i]) \\leftarrow D(St, \\alpha)
\\mathbf{q}[i] \\leftarrow \\alpha \\; ; \\; \\mathbf{t}[i] \\leftarrow \\mathsf{enc}
                                                                (St&#x27;, \\mathbf{x}&#x27;[i]) \\leftarrow *D(St&#x27;, \\alpha)
(St, \\mathbf{x}[i]) \\leftarrow s D(St, \\alpha)
                                                                Return \\mathcal{F}(\\lambda, \\varepsilon, \\mathbf{x}[i])
(St&#x27;, \\mathbf{x}&#x27;[i]) \\leftarrow s D(St&#x27;, \\alpha)
                                                                PROC OP(a):
\\mathbf{c}[i] \\leftarrow \\$ \\operatorname{Enc}(pk, \\mathbf{x}[i])
                                                                i \\leftarrow i + 1
Return (\\mathbf{c}[i], \\mathcal{F}(\\lambda, \\varepsilon, \\mathbf{x}[i]))
                                                                \\mathbf{q}[i] \\leftarrow a \\; ; \\; \\mathbf{t}[i] \\leftarrow \\mathsf{kd}
PROC KD(a):
                                                                Return \\varepsilon
i \\leftarrow i + 1
                                                                PROC F(a, s):
\\mathbf{q}[i] \\leftarrow a \\; ; \\; \\mathbf{t}[i] \\leftarrow \\mathsf{kd}
                                                                If a \\in \\mathsf{El}(\\mathbf{a}) and 1 \\le s \\le i then
dk \\leftarrow s \\mathsf{KDer}(sk, a)
                                                                        Return \\mathcal{F}(\\lambda, a, \\mathbf{x}[s])
Return dk
                                                                Else return \\perp
</code></pre>

    <p class="text-gray-300">PROC FINALIZE(w)</p>

    <pre><code class="language-text">|\\mathbf{q}[i+1] \\leftarrow \\varepsilon \\; ; \\; \\mathbf{t}[i+1] \\leftarrow \\mathsf{kd}
For i&#x27; = 1, ..., i + 1 and j&#x27; = i&#x27; + 1, ..., i + 1 do
       If \\mathbf{t}[i&#x27;] = \\mathsf{enc} \\ \\land \\ \\mathbf{t}[j&#x27;] = \\mathsf{kd} \\ \\mathsf{then}
               If \\mathcal{F}(\\lambda, \\mathbf{q}[j&#x27;], \\mathbf{x}[i&#x27;]) \\neq \\mathcal{F}(\\lambda, \\mathbf{q}[j&#x27;], \\mathbf{x}&#x27;[i&#x27;]) then
                       bad â† true
</code></pre>

    <p class="text-gray-300">Return  <span class="math">R(\\lambda, z, \\mathbf{x}, \\mathbf{q}, \\mathbf{t}, St, w)</span></p>

    <p class="text-gray-300">&lt;span id=&quot;page-9-1&quot;&gt;&lt;/span&gt;Figure 3: Left: &quot;Real world&quot; game  <span class="math">RSS3_{FE,\\mathcal{F},Z,D,R}</span>  for the SS3 definition. Middle: &quot;Ideal world&quot; game ISS3&lt;sub&gt; <span class="math">\\mathcal{F},Z,D,R</span> &lt;/sub&gt; for the SS3 definition. Right: FINALIZE procedure, common to the two games.</p>

    <p class="text-gray-300">all  <span class="math">\\lambda \\in \\mathbb{N}</span>  and all  <span class="math">y \\in \\{0,1\\}^* \\cup \\{\\bot\\}</span> ,  <span class="math">\\Pr[x \\leftarrow X_\\lambda : y = \\mathcal{F}(\\lambda, a_\\lambda, x)] \\leq 1 - 1/p(\\lambda)</span> . For example, the functionality  <span class="math">\\mathcal{F}^{\\mathsf{P},\\mathsf{p}}_{\\mathsf{bit-ibe}}</span>  for a one-bit IBE scheme, which parses x as (a',b), and returns b if a = a' and  <span class="math">\\perp</span>  otherwise, is a 2-unpredictable function wrt.  <span class="math">\\mathcal{A}, \\mathcal{X}</span>  where, for all  <span class="math">\\lambda \\in \\mathbb{N}</span> , we let  <span class="math">a_{\\lambda}</span>  be a fixed but arbitrary identity and  <span class="math">\\mathcal{X}_{\\lambda}</span>  return  <span class="math">(a_{\\lambda}, d)</span>  where the message  <span class="math">d \\in \\{0, 1\\}</span>  is random. As another example, the functionality  <span class="math">\\mathcal{F}_{\\text{peks}}^{\\mathsf{p},\\mathsf{P}}</span>  for a PEKS scheme, which returns 1 if a=x and  <span class="math">\\perp</span>  otherwise, is a 2-unpredictable function wrt.  <span class="math">\\mathcal{A}, \\mathcal{X}</span>  where for all  <span class="math">\\lambda \\in \\mathbb{N}</span> , we again let  <span class="math">a_{\\lambda}</span>  be fixed but arbitrary keyword and  <span class="math">\\mathcal{X}_{\\lambda}</span>  return a random keyword  <span class="math">x \\in \\{a_{\\lambda}, a&#x27;_{\\lambda}\\}</span>  for some also fixed but arbitrary  <span class="math">a&#x27;_{\\lambda} \\neq a_{\\lambda}</span> . Indeed, unpredictability with respect to some family of input distributions and functionality indices is a minimal requirement for a functionality to be interesting; otherwise, it is trivial to build an FE scheme for it because anyone can decrypt correctly without even using the ciphertext. In this sense, our result below rules out an SS1-secure FE scheme for any non-trivial functionality.</p>

    <p class="text-gray-300">SECRET-KEY LENGTH. we say that an FE scheme FE = (Setup, KDer, Enc, Dec) has secret-key length  <span class="math">\\ell(\\cdot)</span> if  <span class="math">|dk| &lt; \\ell(\\lambda) = \\mathcal{F}(\\lambda, a, x)</span>  for all  <span class="math">\\lambda, a, x, r</span> , all  <span class="math">(pk, sk) \\in [\\mathsf{Setup}(\\lambda)]</span> , and all  <span class="math">dk \\in [\\mathsf{KDer}(sk, a)]</span> . Note that every FE scheme must have some polynomial  <span class="math">\\ell(\\cdot)</span>  secret-key length in order to be efficient.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-9-0&quot;&gt;&lt;/span&gt;<strong>Theorem 4.1</strong> Let  <span class="math">p(\\cdot) &gt; 1</span>  be a polynomial. Suppose  <span class="math">\\mathcal{F}</span>  is a  <span class="math">p(\\cdot)</span> -unpredictable functionality wrt.  <span class="math">\\mathcal{A} = \\mathbf{1}</span>  <span class="math">\\{a_{\\lambda}\\}_{{\\lambda}\\in\\mathbb{N}}, \\mathcal{X}=\\{X_{\\lambda}\\}_{{\\lambda}\\in\\mathbb{N}},</span>  Furthermore, suppose that for every  <span class="math">{\\lambda}\\in N</span> ,  <span class="math">\\mathcal{F}({\\lambda},{\\varepsilon},x)</span>  is the same for all  <span class="math">x \\in [X_{\\lambda}]</span> . Let  <span class="math">\\mathcal{H} = (K, H)</span>  be a collision-resistant hash function. Then there does not exist an SS1-secure  <span class="math">\\mathcal{F}</span> -FE scheme. More precisely, suppose FE is a  <span class="math">\\mathcal{F}</span> -FE scheme with secret-key length  <span class="math">\\ell(\\cdot)</span> . Then for any function  <span class="math">\\mu(\\cdot)</span>  there exists a PT auxiliary input generator Z, message sampler D, PT adversary A, PT relation R, and CR-adversary C such that for every simulator S</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\mathrm{ss}}_{\\mathsf{FE},\\mathcal{F},A,S,Z,D,R}(\\cdot) \\geq 1 - \\sqrt{\\mathbf{Adv}^{\\mathrm{col}}_{\\mathcal{H},C}(\\cdot) + 1/\\mu(\\cdot)}</span>$</p>

    <p class="text-gray-300">Adversary A makes  <span class="math">p(\\cdot)(\\ell(\\cdot) + \\log \\mu(\\cdot))</span>  encryption queries and two key-derivation queries.</p>

    <p class="text-gray-300">To compare, BSW [14] ruled out SS1-secure IBE against adversaries with access to a non-programmable random oracle, so our result improves theirs in two respects: to applies to any non-trivial functionality and standard-model adversaries. It also reveals a trade-off between secret-key length and the total number of bits encrypted. Namely, when the difference is even one bit (i.e., the total number of bits encrypted is one</p>

    <pre><code class="language-text">Alg R(\\lambda, \\mathbf{x}, \\mathbf{a}, \\boldsymbol{\\alpha}, St, w):
Alg A(pk, hk):
                                                   (pk, \\mathbf{c}, h, f, sk_h, sk_a) \\leftarrow w
For i = 1, \\ldots, n(\\lambda) do:
                                                  If h \\neq H(hk, pk||\\mathbf{c}) then return false
      \\mathbf{c}[i] \\leftarrow s \\operatorname{Enc}(\\lambda)
                                                  If |sk_h| \\neq \\ell or |sk_a| \\neq \\ell then return false
h \\leftarrow H(hk, pk || \\mathbf{c})
                                                   If |\\alpha| \\neq n \\lor \\alpha \\neq (\\lambda, \\ldots, \\lambda) then return false
sk_h \\leftarrow s KD(h)
                                                  If |\\mathbf{a}| \\neq 2 \\lor \\mathbf{a}[1] \\neq h \\lor \\mathbf{a}[2] \\neq a_{\\lambda} then return false
sk_a \\leftarrow s KD(a_\\lambda)
                                                   If Dec(sk_a, \\mathbf{c}) \\neq \\mathcal{F}(\\lambda, a_\\lambda, \\mathbf{x}) then return false
w \\leftarrow (pk, \\mathbf{c}, h, f, sk_h, sk_a)
                                                  Return true
Return w
</code></pre>

    <p class="text-gray-300">&lt;span id=&quot;page-10-0&quot;&gt;&lt;/span&gt;Figure 4: Algorithms A and R for proof of Theorem 4.1.</p>

    <pre><code class="language-text">Alg S_2(\\overline{St}):
                                                                                                                                                Adversary C(\\lambda):
Alg S_1(\\lambda):
                                                                                                                                                hk \\leftarrow \\text{sInitialize}(\\lambda)
i \\leftarrow 0
z \\leftarrow \\text{$&quot;s$ Initialize}(\\lambda)
                                                                           For i = 1, \\dots, n(\\lambda) do \\mathbf{x}[i] \\leftarrow X_{\\lambda}
                                                                                                                                               Run S_1 on \\lambda,
                                                                                                                                                      replying to Initialize with hk
Run S(z):
                                                                           Run S at state St:
                                                                                                                                                Let \\overline{St} be the output of S_1
On message-query \\alpha do:
                                                                           On message-query \\alpha do:
                                                                                                                                               w^1, w^2 \\leftarrow S_2(\\overline{St})
     i \\leftarrow i + 1; Return \\overline{\\varepsilon}
                                                                                 i \\leftarrow i + 1; Return \\overline{\\varepsilon}
                                                                                                                                               \\begin{array}{l} (pk^1, \\mathbf{c}^1, h^1, f^1, sk_h^1, sk_a^1) \\leftarrow w^1 \\\\ (pk^2, \\mathbf{c}^2, h^2, f^2, sk_h^2, sk_a^2) \\leftarrow w^2 \\end{array}
On op-query a do:
                                                                           On op-query a do:
     Halt computation of S_1 with state St
                                                                                 A \\leftarrow A \\cup \\{a\\}; Return \\varepsilon
\\overline{St} \\leftarrow St || i ; \\text{ Return } \\overline{St}
                                                                           On F-query (a, s) do:
                                                                                                                                                Return (pk^1||\\mathbf{c}^1, pk^2||\\mathbf{c}^2)
                                                                                 If 1 \\le s \\le i and a \\in A do:
                                                                                 Return \\mathcal{F}(\\lambda, a, \\mathbf{x}[s])
                                                                                 Else return \\perp
                                                                          Let w be the output of S; Return w
</code></pre>

    <p class="text-gray-300">&lt;span id=&quot;page-10-2&quot;&gt;&lt;/span&gt;Figure 5: Algorithms  <span class="math">S_1, S_2</span>  and C for proof of Theorem 4.1.</p>

    <p class="text-gray-300">more than the secret-key length) our adversary's advantage is non-negligible. We also note that, while for technical reasons we require  <span class="math">\\mathcal{F}(\\lambda, \\varepsilon, x)</span>  to take the same value on every possible challenge payload x, this is not a major restriction in practice since typically  <span class="math">\\mathcal{F}(\\lambda, \\varepsilon, x) = |x|</span> ; then we are just requiring as usual that possible challenge messages have the same length.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-10-1&quot;&gt;&lt;/span&gt;The proof combines and extends ideas of [14] and [5]. As in [5] will make use of a version of the Reset Lemma of [7].</p>

    <p class="text-gray-300"><strong>Lemma 4.2</strong> Let  <span class="math">P_1, P_2</span>  be algorithms, the second with boolean output. The single-execution acceptance probability  <span class="math">\\mathbf{AP}_1(P_1, P_2, \\lambda)</span>  is defined as the probability that  <span class="math">d = \\mathsf{true}</span>  in the single execution experiment  <span class="math">\\overline{St} \\leftarrow \\</span> P_1(\\lambda)$ ;  <span class="math">d \\leftarrow \\</span> P_2(\\overline{St})$ . The double-execution acceptance probability  <span class="math">\\mathbf{AP}_2(P_1, P_2, \\lambda)</span>  is defined as the probability that  <span class="math">d_1 = d_2 = \\mathsf{true}</span>  in the double execution experiment  <span class="math">\\overline{St} \\leftarrow \\</span> P_1(\\lambda)$ ;  <span class="math">d_0, d_1 \\leftarrow \\</span> P_2(\\overline{St})$ . Then  <span class="math">\\mathbf{AP}_1(P_1, P_2, \\lambda) \\leq \\sqrt{\\mathbf{AP}_2(P_1, P_2, \\lambda)}</span>  for all  <span class="math">\\lambda \\in \\mathbb{N}</span> .</p>

    <p class="text-gray-300"><strong>Proof of Theorem 4.1:</strong> For  <span class="math">\\lambda \\in \\mathbb{N}</span>  denote by  <span class="math">\\overline{\\varepsilon}_{\\lambda}</span>  the value such that  <span class="math">\\mathcal{F}(\\lambda, \\varepsilon, x) = \\overline{\\varepsilon}_{\\lambda}</span>  for all  <span class="math">x \\in [X_{\\lambda}]</span> . Let  <span class="math">n(\\cdot) = p(\\cdot)(\\ell(\\cdot) + \\log \\mu(\\cdot))</span> . Define Z on input  <span class="math">\\lambda</span>  to return  <span class="math">hk \\leftarrow K(\\lambda)</span> . Define message sampler D on inputs St,  <span class="math">\\alpha</span>  to (ignore St and) return  <span class="math">x \\leftarrow X(\\alpha)</span> . Define adversary A and relation R as in Figure 4.</p>

    <p class="text-gray-300">By construction  <span class="math">\\Pr\\left[\\mathrm{RSS}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^A(\\cdot)\\right] = 1</span> . Let S be any simulator. Wlog assume that it makes no F-query preceding its first Op-query (the response to such a query would be  <span class="math">\\bot</span> ). Furthermore, parsing the output of S as  <span class="math">(pk, \\mathbf{c}, h, f, sk_h, sk_a, hk) \\leftarrow w</span> , we assume it holds that  <span class="math">h = H(hk, pk||\\mathbf{c})</span> ,  <span class="math">|sk_h| = |sk_a| = \\ell</span> ,  <span class="math">|\\alpha| = n</span> ,  <span class="math">\\alpha = (\\lambda, \\ldots, \\lambda)</span> ,  <span class="math">|\\mathbf{a}| = 2</span> ,  <span class="math">\\mathbf{a}[1] = h</span> , and  <span class="math">\\mathbf{a}[2] = a_{\\lambda}</span> , since otherwise the relation R returns false. Towards applying Lemma 4.2, we write execution of S in Game ISS1 as a composition of two algorithms  <span class="math">S_1, S_2</span>  as in Figure 5.</p>

    <p class="text-gray-300">Namely,  <span class="math">S_1</span>  runs S up to the point that it makes its first OP query, and  <span class="math">S_2</span>  runs S following this OP query. It also samples  <span class="math">\\mathbf{x}</span>  all at once instead of defining its individual components when responding to</p>

    <p class="text-gray-300">each message query, but this is equivalent and makes the analysis more transparent. Below we justify the following sequence of inequalities, for C, Y defined below:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\text{ISS1}_{\\mathcal{F},Z,D,R}^{S}(\\cdot)\\right] = \\mathbf{AP}_{1}(S_{1}, S_{2}, \\lambda) \\leq \\sqrt{\\mathbf{AP}_{2}(S_{1}, S_{2}, \\lambda)} \\leq \\sqrt{\\mathbf{Adv}_{\\mathcal{H},C}^{\\text{col}}(\\lambda) + \\Pr\\left[\\mathcal{F}(\\lambda, a_{\\lambda}, \\mathbf{x}) \\in Y\\right]}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq \\sqrt{\\mathbf{Adv}_{\\mathcal{H},C}^{\\text{col}}(\\lambda) + 2^{\\ell}(1 - 1/p)^{n}} &lt; \\sqrt{\\mathbf{Adv}_{\\mathcal{H},C}^{\\text{col}}(\\lambda) + 2^{\\ell}2^{-(\\ell + \\log \\mu(\\lambda))}}</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\sqrt{\\mathbf{Adv}_{\\mathcal{H},C}^{\\text{col}}(\\lambda) + 1/\\mu(\\lambda)}.</span>$</p>

    <p class="text-gray-300">Above, the first inequality is by construction and the second is by Lemma 4.2. For the third, consider the CR-adversary C against  <span class="math">\\mathcal{H}</span>  also defined in Figure 5. Note that C simply mimics the double execution experiment with  <span class="math">S_1, S_2</span> . Let us also denote the two outputs of  <span class="math">S_2</span>  in that experiment as  <span class="math">w^1 = (pk^1, \\mathbf{c}^1, h^1, f^1, sk_h^1, sk_a^1)</span>  and  <span class="math">w^2 = (pk^2, \\mathbf{c}^2, h^2, f^2, sk_h^2, sk_a^2)</span> . Now, unless C finds a collision we have  <span class="math">\\mathbf{c}^1 = \\mathbf{c}^2</span> , denote by  <span class="math">\\mathbf{c}^*</span>  this common value. Then define the set  <span class="math">Y := \\{y \\in \\{0,1\\}^* : \\exists s \\in \\{0,1\\}^\\ell \\text{ s.t. Dec}(s,\\mathbf{c}^*) = y\\}</span> . If it is not the case that  <span class="math">\\mathcal{F}(\\lambda,a_\\lambda,\\mathbf{x}) \\in Y</span>  when  <span class="math">\\mathbf{x}</span>  is sampled by  <span class="math">S_2</span>  then the relation R must reject, as no  <span class="math">sk_a^2</span>  will satisfy  <span class="math">\\mathrm{Dec}(sk_a^2,\\mathbf{c}) = \\mathcal{F}(\\lambda,a_\\lambda,\\mathbf{x})</span>  (recall we assume  <span class="math">|sk_a^2| = \\ell</span>  here as otherwise R rejects), justifying the third inequality above. The fourth equality above uses the unpredictability of  <span class="math">\\mathcal{F}</span>  and a union bound. For the fifth we substitute  <span class="math">n(\\lambda) = p(\\lambda)(\\ell(\\lambda) + \\log(\\mu(\\lambda)))</span>  and use the inequality  <span class="math">(1 - 1/x)^x \\le 1/e &lt; 1/2</span>  for any real number  <span class="math">x \\ge 1</span>  (here e is Euler's constant).</p>

    <h2 id="sec-6" class="text-2xl font-bold">&lt;span id=&quot;page-11-2&quot;&gt;&lt;/span&gt;5 Equivalence for Restricted Definitions of Semantic Security</h2>

    <p class="text-gray-300">Motivated by the impossibility results of Section 4, take up the direction of providing variants of the SS definition that are <em>achievable</em>.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">5.1 SS2 and its Equivalence to IND for All Functionalities</h3>

    <p class="text-gray-300">We start by providing our SS2 definition that we show is <em>equivalent</em> to IND, thus demonstrating that the IND definition targeted in the literature is indeed equivalent to some form of semantic security.</p>

    <p class="text-gray-300">SS2 DEFINITION. Let FE = (Setup, KDer, Enc, Dec) be an  <span class="math">\\mathcal{F}</span> -FE scheme. The definition uses games  <span class="math">\\mathrm{RSS2}_{\\mathsf{FE},\\mathcal{F},Z,D,R}</span>  and  <span class="math">\\mathrm{ISS2}_{\\mathcal{F},Z,D,R}</span>  of Figure 2, with the boxed code indicating the differences from the corresponding games in Figure 1, i.e., removing the boxed code recovers the SS1 games. Let D be a message sampler and A an adversary. We say that (D,A) is SS2-valid with failure probability  <span class="math">\\nu(\\cdot)</span>  if  <span class="math">\\mathrm{Pr}\\left[\\mathrm{RSS2}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^A(\\cdot)\\right] \\leq \\nu(\\cdot)</span> . When  <span class="math">\\nu(\\cdot)</span>  is negligible we say (D,A) is SS2-valid. (Note that this probability does not depend on the relation R, so it can be anything.) We say that FE is SS2-secure if for every PT auxiliary input generator Z, every message sampler D and PT adversary A such that (D,A) is SS2-valid, and every PT relation R, there is a PT simulator S such that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\mathrm{ss2}}_{\\mathsf{FE},\\mathcal{F},A,S,Z,D,R}(\\cdot) \\ = \\ T(\\mathrm{RSS2}_{\\mathsf{FE},\\mathcal{F},Z,D,R},A,\\cdot) - T(\\mathrm{ISS2}_{\\mathcal{F},Z,D,R},S,\\cdot)</span>$</p>

    <p class="text-gray-300">is negligible. Intuitively, the definition mandates that an adversary only make key-derivation queries for functions under which any possible challenge message takes the same value. For example, for IBE this corresponds to mandating that any key-derivation query made by the adversary never makes a key-derivation query for a key that decrypts a challenge ciphertext (or decrypts it to a predictable value), which is a natural restriction. The following theorem follows from the claims below.</p>

    <p class="text-gray-300"><strong>Theorem 5.1</strong> Let  <span class="math">\\mathcal{F}</span>  be a functionality and let FE = (Setup, KDer, Enc, Dec) be an  <span class="math">\\mathcal{F}</span> -FE scheme. Then FE is SS2-secure if and only if it is IND-secure.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-11-0&quot;&gt;&lt;/span&gt;Claim 5.2 (SS2  <span class="math">\\Rightarrow</span>  IND) Let B be an IND-adversary. Then there is a message sampler D, relation R, and adversary A such that for every simulator S</p>

    <p class="text-gray-300">&lt;span id=&quot;page-11-1&quot;&gt;&lt;/span&gt;
<span class="math">$\\mathbf{Adv}^{\\mathrm{ind}}_{\\mathsf{FE},\\mathcal{F},B}(\\cdot) \\leq 2 \\cdot \\mathbf{Adv}^{\\mathrm{ss2}}_{\\mathsf{FE},\\mathcal{F},A,S,Z,D,R}(\\cdot)</span>$
(1)</p>

    <pre><code class="language-text">Alg R(1^k, \\mathbf{x}, \\mathbf{a}, \\boldsymbol{\\alpha}, St, w):
Alg D(St, \\alpha):
                                                   Alg A(pk):
If St = \\varepsilon then St \\leftarrow \\$\\{0, 1\\}
                                                                                                                        \\mathbf{x}_0 \\| \\mathbf{x}_1 \\leftarrow \\boldsymbol{\\alpha}
                                                   Run B(pk):
                                                                                                                        \\mathbf{a}[|\\mathbf{a}|+1] \\leftarrow \\varepsilon
x_0 || x_1 \\leftarrow \\alpha
                                                         On left-or-right query (x_0, x_1):
Return (St, x_{St})
                                                                                                                        For j = 1, ..., |\\mathbf{a}| + 1 do
                                                               c \\leftarrow s \\operatorname{Enc}(x_0 || x_1)
                                                                                                                               If \\mathcal{F}(1^k, \\mathbf{a}[j], \\mathbf{x}_0) \\neq \\mathcal{F}(1^k, \\mathbf{a}[j], \\mathbf{x}_1)
                                                               Return c
                                                                                                                                     then return false
                                                          On query key-derivation query a:
                                                                                                                        Return (\\mathbf{x} = \\mathbf{x}_w)
                                                               dk \\leftarrow s KD(a)
                                                               Return dk
                                                   Let b&#x27; be the output of A
                                                   Return b&#x27;
</code></pre>

    <p class="text-gray-300">&lt;span id=&quot;page-12-0&quot;&gt;&lt;/span&gt;Figure 6: Algorithms for proof of Claim 5.2.</p>

    <p class="text-gray-300">Furthermore, (D, A) is SS2-valid and the running-time of D, R, A is that of B.</p>

    <p class="text-gray-300"><strong>Proof:</strong> Define the message sampler D, adversary A, and relation R as in Figure 6. Then by construction  <span class="math">T(\\text{RSS2}_{\\mathsf{FE},\\mathcal{F},Z,D,R},A,\\cdot) = T(\\text{IND}_{\\mathsf{FE},\\mathcal{F}},B,\\cdot)</span> . Moreover, we claim that for every simulator S we have  <span class="math">T(\\text{ISS2}_{\\mathcal{F},Z,D,R,S},\\cdot) \\leq 1/2</span> . This is because we can assume wlog that S's queries are such that  <span class="math">\\mathcal{F}(1^k,a,\\mathbf{x}_0) = \\mathcal{F}(1^k,a,\\mathbf{x}_1)</span>  for all  <span class="math">\\mathsf{El}(a) \\in \\mathbf{a} \\cup \\varepsilon</span>  (since otherwise R returns false), so S gets no information about the bit b. Subtracting, we get</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}_{\\mathsf{FE},\\mathcal{F},A,S,Z,D,R}^{\\mathrm{ss2}}(\\cdot) = T(\\mathrm{RSS2}_{\\mathsf{FE},\\mathcal{F},Z,D,R},A,\\cdot) - T(\\mathrm{ISS2}_{\\mathcal{F},Z,D,R},S,\\cdot) \\ge T(\\mathrm{IND}_{\\mathsf{FE},\\mathcal{F}},B,\\cdot) - 1/2</span>$
<span class="math">$= 1/2 \\cdot \\mathbf{Adv}_{\\mathsf{FE},\\mathcal{F},B}^{\\mathrm{ind}}(\\cdot)</span>$</p>

    <p class="text-gray-300">which implies Equation (1). To complete the proof we note that (D, A) is SS2-valid because we may assume wlog that B's queries are such that  <span class="math">\\mathcal{F}(1^k, a, \\mathbf{x}_0) = \\mathcal{F}(1^k, a, \\mathbf{x}_1)</span>  for all  <span class="math">a \\in \\mathsf{El}(\\mathbf{a}) \\cup \\varepsilon</span>  (otherwise its advantage can only go down).</p>

    <p class="text-gray-300">&lt;span id=&quot;page-12-1&quot;&gt;&lt;/span&gt;Claim 5.3 (IND  <span class="math">\\Rightarrow</span>  SS2) Let D be a message sampler, A be an SS2-adversary, and R be a relation such that (D,A) is SS2-valid with failure probability  <span class="math">\\nu(\\cdot)</span> . Then there is a simulator S and an IND-adversary B such that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\mathrm{ss2}}_{\\mathsf{FE},\\mathcal{F},A,S,Z,D,R}(\\cdot) \\ \\leq \\ \\mathbf{Adv}^{\\mathrm{ind}}_{\\mathsf{FE},\\mathcal{F},B}(\\cdot) + 2\\nu(\\cdot) \\ .</span>$</p>

    <p class="text-gray-300">The running-time of S is that of D, R, A and the running-time of B is at most twice that of R, A plus twice that of D.</p>

    <p class="text-gray-300"><strong>Proof:</strong> Define S and B as in Figure 7. Without affecting the output of the game, we may have the Finalize procedure of Game  <span class="math">\\text{IND}_{\\mathsf{FE},\\mathcal{F},0}^B(\\cdot)</span>  set a flag bad when the &quot;return false&quot; statement is executed. Then, viewing Games  <span class="math">\\text{IND}_{\\mathsf{FE},\\mathcal{F},0}^B(\\cdot)</span>  and  <span class="math">\\text{RSS2}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^A(\\cdot)</span>  as executed over a common finite space of coins, we have that in the language of [8] they are identical-until-bad. Therefore, by the Fundamental Lemma of [8]</p>

    <p class="text-gray-300"><span class="math">$T(\\mathrm{RSS2}_{\\mathsf{FE},\\mathcal{F},Z,D,R},A,\\cdot) \\leq T(\\mathrm{IND}_{\\mathsf{FE},\\mathcal{F},1},B,\\cdot) + \\Pr\\left[\\,\\mathrm{RSS2}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^A(\\cdot) \\text{ sets bad}\\,\\right]\\,.</span>$</p>

    <p class="text-gray-300">By an analogous argument</p>

    <p class="text-gray-300"><span class="math">$T(\\mathrm{ISS2}_{\\mathcal{F},Z,D,R},S,\\cdot) \\geq T(\\mathrm{IND}_{\\mathsf{FE},\\mathcal{F},0},B,\\cdot) - \\Pr\\left[\\,\\mathrm{ISS2}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^S(\\cdot) \\text{ sets bad}\\,\\right]\\,.</span>$</p>

    <p class="text-gray-300">Subtracting yields Equation (5.3).</p>

    <p class="text-gray-300">It is worth pointing out in the proof of the second claim above that the constructed simulator S needs not ever query its oracles. This is because we are guaranteed that, since (D, A) is SS2-valid, the &quot;dummy&quot; messages sampled independently from the challenge ones have the same value under any function queried by A to its key-derivation oracle.</p>

    <pre><code class="language-text">Alg S(1^k):
                                                      Alg B(pk):
St \\leftarrow \\varepsilon
                                                      i, j \\leftarrow 0
(pk, sk) \\leftarrow s \\mathsf{Setup}(1^k)
                                                       St_0, St_1 \\leftarrow \\varepsilon
                                                      Run A(pk):
Run A(pk):
                                                            On encryption query \\alpha:
     On encryption query \\alpha:
           y \\leftarrow s \\operatorname{Msg}(\\alpha)
                                                                  i \\leftarrow i + 1; \\alpha[i] \\leftarrow \\alpha
           (St, x) \\leftarrow D(St, \\alpha)
                                                                  (St_0, \\mathbf{x}_0[i]) \\leftarrow D(St_0, \\alpha)
                                                                  (St_1, \\mathbf{x}_1[i]) \\leftarrow s D(St_1, \\alpha)
           c \\leftarrow s \\operatorname{Enc}(pk, x)
           Return (c, y)
                                                                  Return LR(\\mathbf{x}_0[i], \\mathbf{x}_1[i])
                                                            On key-derivation query a:
     On key-derivation query a:
                                                                  j \\leftarrow j + 1; \\mathbf{a}[j] \\leftarrow a
           dk \\leftarrow s \\mathsf{KDer}(sk, a)
           Return dk
                                                                  dk \\leftarrow \\$ KD(a)
                                                                 Return dk
Let w be the output of A
                                                      Let w be the output of A
Return w
                                                      Return R(1^k, \\mathbf{x}_1, \\mathbf{a}, \\boldsymbol{\\alpha}, St_1, w)
</code></pre>

    <p class="text-gray-300">&lt;span id=&quot;page-13-0&quot;&gt;&lt;/span&gt;Figure 7: Algorithms for proof of Claim 5.3.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">5.2 SS3 and its Equivalence to IND for Resampleable Functionalities</h3>

    <p class="text-gray-300">The SS2 definition is not as strong as one would like because for some functionalities IND (which we showed equivalent to SS2) is a &quot;bad&quot; definition. To address this we now introduce the SS3 definition, which strengthens SS2 by dropping the restriction put by SS2 on key-derivation queries made by an adversary before seeing a challenge ciphertext. Indeed, we believe the SS3 definition is an essentially asstrong-as-possible security definition for FE subject to the constraint that it be achievable without any unnatural restrictions on the adversary or message space. To see why, note the definition of &quot;unpredictable functionalities&quot; used for our impossibility result in Section 4 and the fact that the latter crucially uses the adversary's ability to make &quot;adaptive&quot; key-derivation queriesâ€”i.e., depending on a challenge ciphertext. In some sense, the SS3 definition demands that the functionality restricted to the adversary's adaptive key derivation queries be predictable wrt. the message space.</p>

    <p class="text-gray-300">SS3 DEFINITION. Let FE = (Setup, KDer, Enc, Dec) be an  <span class="math">\\mathcal{F}</span> -FE scheme. The definition uses games  <span class="math">\\mathrm{RSS3_{FE}}, \\mathcal{F}, \\mathcal{Z}, \\mathcal{D}, \\mathcal{R}</span>  and  <span class="math">\\mathrm{ISS3_{\\mathcal{F}}}, \\mathcal{Z}, \\mathcal{D}, \\mathcal{R}</span>  of Figure 3, with the boxed code indicating the differences from the corresponding games in Figure 2, i.e., the games differ from SS2 only in the Finalize procedure. Let D be a message sampler and A an adversary. We say that (D,A) is SS3-valid with failure probability  <span class="math">\\nu(\\cdot)</span>  if  <span class="math">\\Pr\\left[\\mathrm{RSS3_{FE}^{A}}, \\mathcal{F}, \\mathcal{Z}, \\mathcal{D}, \\mathcal{R}(\\cdot) \\text{ sets bad}\\right] \\leq \\nu(\\cdot)</span> . When  <span class="math">\\nu(\\cdot)</span>  is negligible we say (D,A) is SS3-valid. (Note that this probability does not depend on the relation R, so it can be arbitrary.) We say that FE is SS3-secure if for every PT auxiliary input generator Z, every message sampler D and PT adversary A such that (D,A) is valid, and every PT relation R, there is a PT simulator S such that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}_{\\mathsf{FE},\\mathcal{F},A,S,Z,D,R}^{\\mathrm{ss3}}(\\cdot) \\ = \\ T(\\mathrm{RSS3}_{\\mathsf{FE},\\mathcal{F},Z,D,R},A,\\cdot) - T(\\mathrm{ISS3}_{\\mathcal{F},Z,D,R},S,\\cdot)</span>$</p>

    <p class="text-gray-300">is negligible.</p>

    <p class="text-gray-300">RESAMPLEABILITY. Let  <span class="math">\\mathcal{F}</span>  be a functionality,  <span class="math">\\overline{D}</span> , D be algorithms. For an adversary B we let</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\mathrm{rs}}_{\\overline{D},D,\\mathcal{F},B}(\\cdot) \\ = \\ T(\\mathrm{Rsmp}_{\\overline{D},D,\\mathcal{F},1},B,\\cdot) - T(\\mathrm{Rsmp}_{\\overline{D},D,\\mathcal{F},0},B,\\cdot)</span>$</p>

    <p class="text-gray-300">where the game is in Figure 10. Furthermore, let  <span class="math">\\mathbf{Adv}_{\\overline{D},D,\\mathcal{F}}^{\\mathrm{rs}}(\\cdot) = \\max_{B} \\{\\mathbf{Adv}_{\\overline{D},D,\\mathcal{F},B}^{\\mathrm{rs}}(\\cdot)\\}</span>  where the maximum is over all PT B making one challenge query.</p>

    <p class="text-gray-300">We say that an algorithm  <span class="math">\\overline{D}</span>  is a  <span class="math">\\mu(\\cdot)</span> -accurate resampler for  <span class="math">\\mathcal F</span>  relative to algorithm D if  <span class="math">\\mathbf{Adv}^{\\mathrm{rs}}_{\\overline{D},D,\\mathcal F}(\\cdot) \\leq \\mu(\\cdot)</span> . We say that  <span class="math">\\mathcal F</span>  is  <span class="math">\\mu(\\cdot)</span> -accurately reampleable if for all PPT D there exists a PPT  <span class="math">\\overline{D}</span>  such that  <span class="math">\\overline{D}</span>  is a  <span class="math">\\mu(\\cdot)</span> -accurate resampler for  <span class="math">\\mathcal F</span>  relative to D. When  <span class="math">\\mu(\\cdot)</span>  is negligible we say that  <span class="math">\\mathcal F</span>  is accurately resampleable.</p>

    <p class="text-gray-300">THE EQUIVALENCE. The following says that the SS3 notion is equivalent to IND for any accurately</p>

    <p class="text-gray-300">&lt;span id=&quot;page-14-1&quot;&gt;&lt;/span&gt;resampleable functionality  <span class="math">\\mathcal{F}</span> .</p>

    <p class="text-gray-300"><strong>Theorem 5.4</strong> Let  <span class="math">\\mathcal{F}</span>  be an accurately resampleable functionality and let FE = (Setup, KDer, Enc, Dec) be an  <span class="math">\\mathcal{F}</span> -FE scheme. Then FE is SS3-secure if and only if it is IND-secure.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-14-0&quot;&gt;&lt;/span&gt;Since SS3 is clearly stronger than SS2, it is immediate from Claim 5.2 that SS3 implies IND. Below we show the converse, which proves the theorem.</p>

    <p class="text-gray-300">Claim 5.5 (IND  <span class="math">\\Rightarrow</span>  SS3) Let D be a message sampler, A be an SS2-adversary making at most  <span class="math">q_e</span>  encryption queries, and R be a relation such that (D,A) is SS3-valid with failure probability  <span class="math">\\nu(\\cdot)</span> . Suppose  <span class="math">\\mathcal{F}</span>  is  <span class="math">\\mu(\\cdot)</span> -accurately resampleable, and let  <span class="math">\\overline{D}</span>  denote the corresponding  <span class="math">\\mu(\\cdot)</span> -accurate resampler. Then there is a simulator S and an IND-adversary B such that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\mathrm{ss3}}_{\\mathsf{FE},\\mathcal{F},A,S,Z,D,R}(\\cdot) \\ \\leq \\ \\mathbf{Adv}^{\\mathrm{ind}}_{\\mathsf{FE},\\mathcal{F},B}(\\cdot) + 2\\nu(\\cdot) + 2q_e\\mu(\\cdot) \\ .</span>$</p>

    <p class="text-gray-300">The running-time of S is that of D, R, A and the running-time of B is at most twice that of R, A plus the time for  <span class="math">q_e</span>  executions of  <span class="math">\\overline{D}</span> .</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6"><strong>Proof:</strong></h4>

    <p class="text-gray-300">Define S and B as in Figure 9. Furthermore, define hybrid games RSS3-H1&lt;sub&gt;FE, <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{Z}</span> , <span class="math">\\mathcal{D}</span> , <span class="math">\\mathcal{R}</span>  and RSS3-H2&lt;sub&gt;FE, <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{Z}</span> , <span class="math">\\mathcal{D}</span> , <span class="math">\\mathcal{R}</span>  as in Figure 8. Below we justify the following sequence of inequalities:&lt;/sub&gt;&lt;/sub&gt;</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} T(\\mathrm{RSS3_{FE},}_{\\mathcal{F},Z,D,R},A,\\cdot) &amp; \\leq &amp; T(\\mathrm{RSS3-H1_{FE},}_{\\mathcal{F},Z,D,R},A,\\cdot) + \\Pr\\left[\\mathrm{RSS3_{FE},}_{\\mathcal{F},Z,D,R}(\\cdot) \\text{ sets bad}_1\\right] \\\\ &amp; \\leq &amp; T(\\mathrm{RSS3-H2_{FE},}_{\\mathcal{F},Z,D,R},A,\\cdot) + \\Pr\\left[\\mathrm{RSS3-H1_{FE}^{A},}_{\\mathcal{F},Z,D,R}(\\cdot) \\text{ sets bad}_2\\right] \\\\ &amp; &amp; + \\Pr\\left[\\mathrm{RSS3_{FE},}_{\\mathcal{F},Z,D,R}(\\cdot) \\text{ sets bad}_1\\right] \\\\ &amp; = &amp; T(\\mathrm{IND_{FE},}_{\\mathcal{F},1},B,\\cdot) + \\Pr\\left[\\mathrm{RSS3-H1_{FE}^{A},}_{\\mathcal{F},Z,D,R}(\\cdot) \\text{ sets bad}\\right] \\\\ &amp; &amp; + \\Pr\\left[\\mathrm{RSS3_{FE},}_{\\mathcal{F},Z,D,R}(\\cdot) \\text{ sets bad}_1\\right] \\\\ &amp; \\leq &amp; T(\\mathrm{IND_{FE},}_{\\mathcal{F},1},B,\\cdot) + \\Pr\\left[\\mathrm{RSS3-H1_{FE}^{A},}_{\\mathcal{F},Z,D,R}(\\cdot) \\text{ sets bad}_2\\right] + \\nu(\\cdot) \\\\ &amp; \\leq &amp; T(\\mathrm{IND_{FE},}_{\\mathcal{F},1},B,\\cdot) + q_e(\\cdot)\\mu(\\cdot) + \\nu(\\cdot) \\;. \\end{split}</span>$</p>

    <p class="text-gray-300">Above, the first two inequalities are by the Fundamental Lemma of [8] (by a slight abuse of notation we identify bad in RSS3&lt;sub&gt;FE, <span class="math">\\mathcal{F}</span> ,Z,D,R with bad&lt;sub&gt;1&lt;/sub&gt; in RSS3-H1&lt;sub&gt;FE, <span class="math">\\mathcal{F}</span> ,Z,D,R, and third equality is by construction. The fourth uses the assumption that (D,A) is SS3-valid with failure probability  <span class="math">\\nu(\\cdot)</span> .&lt;/sub&gt;&lt;/sub&gt;</p>

    <p class="text-gray-300">Finally, the last inequality follows by considering a run of Games  <span class="math">\\operatorname{Rsmp}_{\\overline{D},D,\\mathcal{F},b}^{B^*}(\\lambda)</span>  for  <span class="math">b \\in \\{0,1\\}</span>  and  <span class="math">B^*</span>  given in Figure 9, and of Game RSS3- <span class="math">\\operatorname{H1}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^A(\\lambda)</span>  over some fixed coin sequence drawn from a common finite set of coins, but not including the coins used to draw  <span class="math">i^*</span>  in RSS3- <span class="math">\\operatorname{H1}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^A(\\lambda)</span> . Suppose bad is set by the latter for the <em>first</em> time (i.e., changed from false to true) on the q-th query to ENC made by A when executed by RSS3- <span class="math">\\operatorname{H1}_{\\mathsf{FE},\\mathcal{F},Z,D,R}</span>  using these coins. Then with probability  <span class="math">1/q_e</span>  in the execution of  <span class="math">\\operatorname{Rsmp}_{\\overline{D},D,\\mathcal{F},b}^{B^*}(\\lambda)</span>  it will be the case that  <span class="math">i^*=q</span> . In this case  <span class="math">\\operatorname{Rsmp}_{\\overline{D},D,\\mathcal{F},b}^{B^*}(\\cdot)</span>  outputs 1 just when b=1. Using the assumption that  <span class="math">\\mathcal{F}</span>  is  <span class="math">\\mu(\\cdot)</span> -accurately resampleable and re-arranging yields the last inequality above.</p>

    <p class="text-gray-300">A symmetric sequence of inequalities to the above yields</p>

    <p class="text-gray-300"><span class="math">$T(\\mathrm{ISS2}_{\\mathcal{F},Z,D,R},S,\\cdot) \\quad \\geq \\quad T(\\mathrm{IND}_{\\mathsf{FE},\\mathcal{F},0},B,\\cdot) - \\nu(\\cdot) - q_e\\mu(\\cdot) \\; .</span>$</p>

    <p class="text-gray-300">Re-arranging and subtracting yields Equation (5.5).</p>

    <pre><code class="language-text">PROC INITIALIZE(\\lambda):
(pk, sk) \\leftarrow \\$ \\mathsf{Setup}(\\lambda)
i, j \\leftarrow 0; St \\leftarrow \\varepsilon; Return (pk, z)
PROC ENC(\\alpha):
                                                                                               PROC FINALIZE(w):
                                                                                               \\overline{\\mathbf{q}[i+1]} \\leftarrow \\varepsilon \\; ; \\; \\mathbf{t}[i+1] \\leftarrow \\mathsf{kd}
\\mathbf{q}[i] \\leftarrow \\alpha \\; ; \\; \\mathbf{t}[i] \\leftarrow \\mathsf{enc}
                                                                                               For i&#x27; = 1, ..., i + 1 and j&#x27; = i&#x27; + 1, ..., i + 1 do
(St, \\mathbf{x}[i]) \\leftarrow D(St, \\alpha)
                                                                                                      If \\mathbf{t}[i&#x27;] = \\text{enc } \\wedge \\mathbf{t}[j&#x27;] = \\text{kd then}
For j&#x27; = 1 to j do:
                                                                                                              If \\mathcal{F}(\\lambda, \\mathbf{q}[j&#x27;], \\mathbf{x}[i&#x27;]) \\neq \\mathcal{F}(\\lambda, \\mathbf{q}[j&#x27;], \\mathbf{x}&#x27;[i&#x27;]) then
       \\mathbf{f}[j&#x27;] \\leftarrow \\mathrm{F}(\\mathbf{a}[j&#x27;], i)
                                                                                                                      \\mathsf{bad}_1 \\leftarrow \\mathsf{true}; Return false
       (St, \\mathbf{x}[i]) \\leftarrow s D(\\lambda, St, \\alpha, \\mathbf{a}, \\mathbf{f})
                                                                                               If bad_2 = true then
If \\mathsf{Test}(\\lambda, \\mathbf{x}[i], \\mathbf{a}, \\mathbf{f}) = 0 then \\mathsf{bad}_2 \\leftarrow \\mathsf{true}
                                                                                                             Return false
\\mathbf{c}[i] \\leftarrow \\mathbf{s} \\, \\mathsf{Enc}(pk, \\mathbf{x}[i])
                                                                                               Else return R(\\lambda, z, \\mathbf{x}, \\mathbf{q}, \\mathbf{t}, St, w)
Return (\\mathbf{c}[i], \\mathcal{F}(\\lambda, \\varepsilon, \\mathbf{x}[i]))
PROC KD(a):
\\mathbf{q}[i] \\leftarrow a \\; ; \\; \\mathbf{t}[i] \\leftarrow \\mathsf{kd}
dk \\leftarrow s \\mathsf{KDer}(sk, a)
Return dk
</code></pre>

    <p class="text-gray-300">&lt;span id=&quot;page-15-0&quot;&gt;&lt;/span&gt;Figure 8: Hybrid games RSS3-H2&lt;sub&gt;FE, <span class="math">\\mathcal{F}</span> ,Z,D,R and RSS3-H2&lt;sub&gt;FE, <span class="math">\\mathcal{F}</span> ,Z,D,R for the proof of Claim 5.5. The latter includes the boxed code while in the former it is removed.&lt;/sub&gt;&lt;/sub&gt;</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">5.3 Resampleability of Some Functionalities</h3>

    <p class="text-gray-300">We show resampleability of the following type of functionality.</p>

    <p class="text-gray-300">FUNCTIONALITIES WITH POLYNOMIAL-SIZE RANGE. Let  <span class="math">\\mathcal{F}</span>  be a functionality. We say that  <span class="math">\\mathcal{F}</span>  has polynomial-size range if there is a polynomial  <span class="math">w(\\cdot)</span>  such that  <span class="math">\\mathcal{F}(\\lambda, \\mathbf{a}, x) \\in F_{\\lambda}</span>  for all  <span class="math">\\lambda \\in \\mathbb{N}</span> ,  <span class="math">x \\in \\{0, 1\\}^*</span>  and  <span class="math">\\mathbf{a} \\in (\\{0, 1\\}^*)^*</span>  where  <span class="math">F_{\\lambda} = \\{\\mathbf{f}_1, \\mathbf{f}_2, \\dots, \\mathbf{f}_{w(\\cdot)}\\}</span> .</p>

    <p class="text-gray-300">EXAMPLES AND DISCUSSION. An example of a functionality with polynomial-size range is PEKS [12] with a polynomial number of keywords. Although as shown by [12] this can be constructed from any IND-CPA public-key encryption scheme, the construction is inefficient for large polynomials, and more efficient constructions may be of interest to practitioners. These would be SS3 secure by our results.</p>

    <p class="text-gray-300">We compare our notion of resampleability to that of preimage sampleability defined by O'Neill [29]. Our notion of resampleability appears to be much more restrictive, in the sense that showing it requires sampling a preimage that lies in the message space of the adversary rather than an arbitrary preimage. Since in general we cannot hope to &quot;reverse engineer&quot; the adversary's message space, it is unclear what we can do with it besides sample it in a black-box way. Indeed, the proof of our result does this and does not exploit any properties of the functionality itself as in [29], who showed that most functionalities considered in the literature have preimage sampleability. On the other hand, we show how to achieve a much stronger security definition than [29] who considered only non-adaptive security, meaning the adversary makes no key-derivation queries after seeing the challenge ciphertext.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-15-2&quot;&gt;&lt;/span&gt;<strong>Proposition 5.6</strong> Let  <span class="math">\\mathcal{F}</span>  be a functionality with polynomial-size range. Then  <span class="math">\\mathcal{F}</span>  is accurately resampleable. More precisely, for any PPT D there is a PPT  <span class="math">\\overline{D}</span>  such that for every  <span class="math">\\lambda \\in \\mathbb{N}</span></p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}_{\\overline{D},D,\\mathcal{F}}^{\\mathrm{rs}}(\\lambda) \\leq \\frac{1}{2^{\\lambda}}</span>$
.</p>

    <p class="text-gray-300">Furthermore, the running-time of  <span class="math">\\overline{D}</span>  is that for at most  <span class="math">\\lambda w(\\lambda)</span>  executions of D.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-15-1&quot;&gt;&lt;/span&gt;The proof will use the following mathematical lemma.</p>

    <pre><code class="language-text">Alg B^*(\\lambda):
Alg S(1^k):
                                                                  Alg B(pk):
                                                                                                                                             i, j \\leftarrow 0
i, j \\leftarrow 0
                                                                 i, j \\leftarrow 0
                                                                                                                                             St \\leftarrow \\varepsilon
St \\leftarrow \\varepsilon
                                                                 St_0, St_1 \\leftarrow \\varepsilon
                                                                                                                                             (pk, sk) \\leftarrow s \\mathsf{Setup}(\\lambda)
(pk, sk) \\leftarrow s \\mathsf{Setup}(1^k)
                                                                 Run A(pk):
                                                                                                                                             Run A(pk):
Run A(pk):
                                                                        On encryption query \\alpha:
                                                                                                                                                   On encryption query \\alpha:
      On encryption query \\alpha:
                                                                              i \\leftarrow i + 1 ; \\alpha[i] \\leftarrow \\alpha
                                                                                                                                                          i \\leftarrow i + 1 ; \\alpha[i] \\leftarrow \\alpha
            i \\leftarrow i + 1 ; \\alpha[i] \\leftarrow \\alpha
                                                                               (St_0, \\mathbf{x}_0[i]) \\leftarrow D(St_0, \\alpha)
                                                                                                                                                          For j&#x27; = 1 to j do:
            For j&#x27; = 1 to j do:
                                                                              For j&#x27; = 1 to j do:
                                                                                                                                                                \\mathbf{f}[j&#x27;] \\leftarrow \\mathrm{F}(\\mathbf{a}[j&#x27;], i)
                                                                                     \\mathbf{f}[j&#x27;] \\leftarrow \\mathcal{F}(\\lambda, \\mathbf{a}[j&#x27;], \\mathbf{x}_0[i])
                   \\mathbf{f}[j&#x27;] \\leftarrow \\mathrm{F}(\\mathbf{a}[j&#x27;], i)
                                                                                                                                                          If i = i^* then
            (St, x) \\leftarrow \\overline{D}(\\lambda, St, \\alpha, \\mathbf{a}, \\mathbf{f})
                                                                               (St_1, \\mathbf{x}_1[i]) \\leftarrow \\overline{D}(\\lambda, St_1, \\alpha, \\mathbf{a}, \\mathbf{f})
                                                                                                                                                                (St, x) \\leftarrow s \\text{ CHALLENGE}(St, \\alpha, \\mathbf{a})
                                                                              Return LR(\\mathbf{x}_0[i], \\mathbf{x}_1[i])
            c \\leftarrow s \\operatorname{Enc}(pk, x)
                                                                                                                                                                Halt execution of A
            Return c, y
                                                                        On key-derivation query a:
                                                                                                                                                          (St, x) \\leftarrow s \\overline{D}(\\lambda, St, \\alpha, \\mathbf{a}, \\mathbf{f})
      On key-derivation query a:
                                                                              j \\leftarrow j + 1; \\mathbf{a}[j] \\leftarrow a
                                                                                                                                                          c \\leftarrow \\operatorname{sEnc}(pk, x)
            j \\leftarrow j + 1; \\mathbf{a}[j] \\leftarrow a
                                                                              Return KD(a)
                                                                                                                                                          Return c, y
            OP(a)
                                                                 Let w be the output of A
                                                                                                                                                   On key-derivation query a:
                                                                 Return R(1^k, \\mathbf{x}_1, \\mathbf{a}, \\boldsymbol{\\alpha}, St, w)
            Return \\mathsf{KDer}(sk, a)
                                                                                                                                                          j \\leftarrow j + 1; \\mathbf{a}[j] \\leftarrow a
Let w be the output of A
                                                                                                                                                          Return \\mathsf{KDer}(sk, a)
Return R(1^k, \\mathbf{x}, \\mathbf{a}, \\boldsymbol{\\alpha}, St, w)
                                                                                                                                            Return \\mathsf{Test}(\\lambda, x, \\mathbf{a}, \\mathbf{f})
</code></pre>

    <p class="text-gray-300">&lt;span id=&quot;page-16-0&quot;&gt;&lt;/span&gt;Figure 9: Algorithms for proof of Claim 5.5.</p>

    <p class="text-gray-300"><strong>Lemma 5.7</strong> Fix integers  <span class="math">n, k \\ge 1</span> . For  <span class="math">\\mathbf{x} \\in \\mathbb{R}^n</span>  define the function  <span class="math">f(\\mathbf{x}) = \\sum_{i=1}^n x_i (1 - x_i)^k</span> . Subject to constraints  <span class="math">\\sum_{i=1}^n x_i = 1</span>  and  <span class="math">0 \\le x_i \\le 1</span>  for all  <span class="math">1 \\le i \\le n</span> ,  <span class="math">f(\\cdot)</span>  is maximum at  <span class="math">x_1 = \\ldots = x_n = 1/n</span> .</p>

    <p class="text-gray-300"><strong>Proof:</strong> (Of Lemma 5.7) We use a change of variables: let  <span class="math">y_i = (1 - x_i)</span>  for all  <span class="math">1 \\le i \\le n</span> . Then we equivalently seek to maximize</p>

    <p class="text-gray-300"><span class="math">$f&#x27;(\\mathbf{y}) = \\sum_{i=1}^{n} (1 - y_i) y_i^k</span>$</p>

    <p class="text-gray-300">subject to  <span class="math">\\sum_{i=1}^{n} y_i = n-1</span>  and  <span class="math">0 \\le y_i \\le 1</span>  for all  <span class="math">1 \\le i \\le n</span> . Now use Lagrange multipliers: we seek a constant  <span class="math">\\lambda</span>  such that</p>

    <p class="text-gray-300">&lt;span id=&quot;page-16-1&quot;&gt;&lt;/span&gt;
<span class="math">$\\nabla f&#x27; = \\lambda \\nabla g \\tag{2}</span>$</p>

    <p class="text-gray-300">where  <span class="math">g(\\mathbf{x}) = \\sum_{i=1}^{n} y_i</span> . Fix any  <span class="math">1 \\le i \\le n</span> . Since</p>

    <p class="text-gray-300"><span class="math">$\\frac{\\partial f&#x27;}{\\partial y_i} = 1 - (k+1)y_i^k</span>$
and  <span class="math">\\frac{\\partial g}{\\partial y_i} = 1</span></p>

    <p class="text-gray-300">by Equation (2) we have</p>

    <p class="text-gray-300">&lt;span id=&quot;page-16-2&quot;&gt;&lt;/span&gt;
<span class="math">$1 - (k+1)y_i^k = \\lambda \\implies y_i = \\left(\\frac{1-\\lambda}{k+1}\\right)^{1/k} . \\tag{3}</span>$</p>

    <p class="text-gray-300">Using the constraint  <span class="math">\\sum_{i=1}^{n} y_i = n-1</span>  we have</p>

    <p class="text-gray-300"><span class="math">$n\\left(\\frac{1-\\lambda}{k+1}\\right)^{1/k} = n-1 \\implies \\lambda = 1 - (k+1)\\left(1 - \\frac{1}{n}\\right)^k.</span>$</p>

    <p class="text-gray-300">Substituting this into Equation (3) we get  <span class="math">y_i = 1 - 1/n</span>  and so  <span class="math">x_i = -(y_i - 1) = 1/n</span>  as desired. Note that this must be a maximum (rather than minimum) since f vanishes when  <span class="math">x_i = 1</span>  for some i.</p>

    <p class="text-gray-300">We now prove the proposition.</p>

    <p class="text-gray-300"><strong>Proof:</strong> (Of Proposition 5.6) Given any D, define the corresponding resampler  <span class="math">\\overline{D}</span>  as follows:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathbf{Alg} \\ \\overline{D}(\\lambda, St, \\alpha, \\mathbf{a}, \\mathbf{f}) \\colon \\\\ \\text{For } i &amp;= 1 \\text{ to } \\lambda w(\\lambda) \\text{ do: } \\\\ x&#x27; &amp;\\leftarrow \\mbox{\\</span>} D(St, \\alpha) \\ \\text{If } \\mathsf{Test}(\\lambda, x', \\mathbf{a}, \\mathbf{f}) = 1 \\text{ then return } x' \\end{split}$$
Return  <span class="math">\\bot</span></p>

    <p class="text-gray-300">&lt;span id=&quot;page-17-0&quot;&gt;&lt;/span&gt;We need to show that for any B</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\mathrm{rs}}_{\\overline{D},D,\\mathcal{F},B}(\\cdot) \\leq \\frac{1}{2^{\\lambda}}</span>$
.</p>

    <p class="text-gray-300">To this end define game RsmpD,D,&lt;sup&gt;F&lt;/sup&gt; to pick a bit b at random and run the first experiment if b = 1 and the second if b = 0; also, have it set bad to true if D ever returns âŠ¥. Define Rsmp-HD,D,&lt;sup&gt;F&lt;/sup&gt; to be like the former but return ResampleD(Î», St, Î±, a,f) if bad is set. Then using a standard conditioning argument and the Fundamental Lemma <a href="#page-21-16">[8]</a>:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\frac{1}{2} + \\frac{1}{2}\\mathbf{A}\\mathbf{d}\\mathbf{v}^{\\mathrm{rs}}_{\\overline{D},D,\\mathcal{F},B}(\\cdot) &amp;= T(\\mathrm{Rsmp}_{\\overline{D},D,\\mathcal{F}},B,\\cdot) \\\\ &amp;\\leq T(\\mathrm{Rsmp-H}_{\\overline{D},D,\\mathcal{F}},B,\\cdot) + \\Pr\\left[\\,\\mathrm{Rsmp}_{\\overline{D},D,\\mathcal{F}}^B(\\cdot) \\text{ sets bad}\\,\\right] \\\\ &amp;= \\frac{1}{2} + \\Pr\\left[\\,\\mathrm{Rsmp}_{\\overline{D},D,\\mathcal{F}}^B(\\cdot) \\text{ sets bad}\\,\\right] \\,. \\end{split}</span>$</p>

    <p class="text-gray-300">Finally, we claim</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\,\\mathrm{Rsmp}_{\\overline{D},D,\\mathcal{F}}^B(\\cdot)\\,\\,\\mathrm{sets}\\,\\,\\mathrm{bad}\\,\\right]\\,\\,\\leq\\,\\,\\frac{1}{2^\\lambda}\\,\\,.</span>$</p>

    <p class="text-gray-300">To see this, fix any inputs Î», St, Î±, a,f and for all 1 â‰¤ i â‰¤ w(Î») let</p>

    <p class="text-gray-300"><span class="math">$p_i = \\Pr[\\mathcal{F}(\\lambda, \\mathbf{a}, x) = \\mathbf{f}_i : x \\leftarrow \\</span>D(St, \\alpha)].$$</p>

    <p class="text-gray-300">Then</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\overline{D}(\\lambda, St, \\alpha, \\mathbf{a}, \\mathbf{f}) \\text{ outputs } \\bot\\right] = \\sum_{i} p_{i} \\cdot (1 - p_{i})^{\\lambda w(\\lambda)}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq \\sum_{i} \\frac{1}{w(\\lambda)} \\cdot \\left(1 - \\frac{1}{w(\\lambda)}\\right)^{\\lambda \\cdot w(\\lambda)}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq \\frac{1}{2^{\\lambda}}.</span>$</p>

    <p class="text-gray-300">The second line above is justified by Lemma <a href="#page-15-1">5.7.</a> The third line uses the inequality (1âˆ’1/x) &lt;sup&gt;x&lt;/sup&gt; â‰¤ 1/e &lt; 1/2 for any real number x â‰¥ 1 (here e is Euler's constant).</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">6 Brute-Force Construction Revisited</h3>

    <p class="text-gray-300">We now revisit the &quot;brute-force&quot; scheme defined by BSW <a href="#page-21-0">[14]</a>, which provides a way to construct FE for any functionality with a polynomially-sized index space.</p>

    <p class="text-gray-300">Let F be a functionality. We say that F has polynomially-sized index space if F(Î», a, x) = âŠ¥ if a /âˆˆ A&lt;sup&gt;Î»&lt;/sup&gt; where A&lt;sup&gt;Î»&lt;/sup&gt; = {Îµ, a1, a2, . . . , ap(Î»)} for a polynomial p(Â·). Let (G, E, D) be a PKE scheme. Then we define a the brute-force FE scheme for F as follows:</p>

    <pre><code class="language-text">PROC INITIALIZE(\\lambda):
                                                                                     Alg Resample&lt;sub&gt;D&lt;/sub&gt;(\\lambda, St, \\alpha, \\mathbf{a}, \\mathbf{f}):
                                                                                     If CS_D(\\lambda, St, \\alpha, \\mathbf{a}, \\mathbf{f}) = \\emptyset then return \\perp
Return \\lambda
                                                                                     w \\leftarrow s \\mathsf{CS}_D(\\lambda, St, \\alpha, \\mathbf{a}, \\mathbf{f})
PROC CHALLENGE(St, \\alpha, \\mathbf{a}):
                                                                                     x&#x27; \\leftarrow D(St, \\alpha; w)
x \\leftarrow s D(St, \\alpha)
                                                                                     Return x&#x27;
\\mathbf{f} \\leftarrow (\\mathcal{F}(\\lambda, \\mathbf{a}, x), \\mathcal{F}(\\lambda, \\varepsilon, x))
                                                                                     Alg Test(\\lambda, x, \\mathbf{a}, \\mathbf{f}):
If b = 1 then x&#x27; \\leftarrow \\overline{D}(\\lambda, St, \\alpha, \\mathbf{a}, \\mathbf{f})
                                                                                     \\mathbf{f}&#x27; \\leftarrow (\\mathcal{F}(\\lambda, \\mathbf{a}, x), \\mathcal{F}(\\lambda, \\varepsilon, x))
Else x&#x27; \\leftarrow s Resample (\\lambda, St, \\alpha, \\mathbf{a}, \\mathbf{f})
                                                                                     Return (\\mathbf{f} = \\mathbf{f}&#x27;)
Return x&#x27;
\\frac{\\text{PROC FINALIZE}(b&#x27;)}{\\text{Return } (b&#x27;=1)}:
                                                                                     Set CS_D(\\lambda, St, \\alpha, \\mathbf{a}, \\mathbf{f}) := \\{w : Test(\\lambda, D(St, \\alpha; w), \\mathbf{a}, \\mathbf{f}) = true\\}
</code></pre>

    <p class="text-gray-300">Figure 10: Left: Game Resamp <span class="math">_{\\overline{D},D,\\mathcal{F},b}</span>  for the resampleability definition. Right: Associated algorithms and definitions used by the game's procedures.</p>

    <pre><code class="language-text">\\frac{\\text{SETUP}(\\lambda)}{\\text{For } i = 1, \\dots, p(\\lambda) \\text{ do}} \\\\ (\\mathbf{pk}[i], \\mathbf{sk}[i]) \\leftarrow \\mathcal{G}(\\lambda) \\\\ \\text{Return } (\\mathbf{pk}, \\mathbf{sk}) \\\\ \\overline{\\text{For } i = 1, \\dots, p(\\lambda) \\text{ do}} \\\\ \\frac{\\text{KDER}(sk, a)}{\\text{For } i = 1, \\dots, p(\\lambda) \\text{ do}} \\\\ \\text{If } a_i = a \\text{ then return } (i, \\mathbf{sk}[i]) \\\\ \\hline \\\\ \\frac{\\text{ENC}(\\mathbf{pk}, m)}{\\text{For } i = 1, \\dots, p(\\lambda) \\text{ do}} \\\\ \\overline{\\text{C}[i]} \\leftarrow \\mathcal{E}(\\mathbf{pk}[i], \\mathcal{F}(\\lambda, a_i, m)) \\\\ \\overline{\\text{Return } \\mathbf{c}} \\\\ \\overline{\\text{DEC}((i, \\mathbf{sk}[i]), \\mathbf{c}))} \\\\ \\overline{\\text{If } (\\mathbf{sk}[i] = \\varepsilon) \\text{ then return } |m|} \\\\ \\overline{\\text{Return } \\mathcal{D}(\\mathbf{sk}[i], \\mathbf{c}[i])}
</code></pre>

    <p class="text-gray-300">BSW [14] show that this construction is IND-secure (and hence, by our results in Section 5, SS2-secure) provided that the underlying PKE scheme is semantically secure. Moreover, they show a slightly decorated construction which is SS1-secure in the random oracle model. What we show is that it suffices for the underlying PKE scheme to be secure against <em>key-revealing SOAs</em> (SOA-K) for this FE scheme to be SS1-secure. In fact, for their result BSW implicitly use the non-committing (which implies SOA-K) PKE scheme of Nielsen [26] in the random oracle model as the underlying PKE scheme, so our result is a generalization of theirs. In particular, it allows us to obtain instantiations in the standard model by (necessarily) allowing long keys, meaning longer than the total number of bits encrypted; SOA-K secure PKE is known to exist in this setting [15, 16].</p>

    <p class="text-gray-300">The intuition is that opening a particular  <span class="math">\\mathcal{F}(\\lambda, a_i, m)</span>  is equivalent to giving away  <span class="math">\\mathbf{sk}[i]</span> . Therefore, it should be the case that if some  <span class="math">\\mathcal{F}</span>  values for a particular set  <span class="math">I = \\{a_{j_1}, a_{j_2}, \\dots, a_{j_{|I|}}\\} \\subseteq \\mathcal{A}</span>  of indices are revealed, it is equivalent to opening up  <span class="math">\\mathbf{sk}[j_1], \\mathbf{sk}[j_2], \\dots, \\mathbf{sk}[j_{|I|}]</span>  and should therefore, by SOA security, not make it any easier to obtain decryptions under any other secret key, i.e. to evaluate  <span class="math">\\mathcal{F}</span>  on any other index.</p>

    <p class="text-gray-300">SOA-K DEFINITION. To formalize our result we will need an explicit notion of SOA-K security, as described in BDWY [5]. Here we need to extend the BDWY definition to allow the adversary and simulator to ask for encryptions and secret keys adaptively (as in our SS notions for FE) rather than asking for an initial vector of ciphertexts and then afterwards a subset of the secret keys in one shot.</p>

    <p class="text-gray-300">Let  <span class="math">\\Pi</span>  be a PKE scheme. The definition uses games  <span class="math">\\mathrm{RSOAK}_{\\Pi,Z,D,R,n}</span>  and  <span class="math">\\mathrm{SSOAK}_{\\Pi,Z,D,R,n}</span>  of Figure 11. We say that  <span class="math">\\Pi</span>  is SOAK-secure if for every auxiliary input generator Z, every PT message sampler D, every PT relation R, every PT adversary A, and every polynomial  <span class="math">n(\\cdot)</span>  there is a PT simulator S such that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\mathrm{soa-k}}_{\\Pi,A,S,Z,D,R,n}(\\cdot) \\ = \\ \\Pr\\left[ \\, \\mathrm{RSOAK}^{A}_{\\Pi,Z,D,R,n}(\\cdot) \\, \\right] - \\Pr\\left[ \\, \\mathrm{SSOAK}^{S}_{\\Pi,Z,D,R,n}(\\cdot) \\, \\right]</span>$</p>

    <p class="text-gray-300">&lt;span id=&quot;page-18-1&quot;&gt;&lt;/span&gt;is negligible.</p>

    <p class="text-gray-300"><strong>Theorem 6.1</strong> Let  <span class="math">\\Pi = (\\mathcal{G}, \\mathcal{E}, \\mathcal{D})</span>  be a SOA-K secure PKE scheme. Then the corresponding brute-force FE scheme for any functionality  <span class="math">\\mathcal{F}</span>  with a polynomially-sized index space is SS1-secure.</p>

    <pre><code class="language-text">Initialize(\\lambda)
i&#x27;, j \\leftarrow 0
St \\leftarrow \\varepsilon
                                                                                                                                                                                   CORRUPT(i)
                                                               Corrupt(i)
For j&#x27; = 1, \\ldots, n(\\lambda) do
                                                                                                                               i&#x27;, j \\leftarrow 0
                                                                                                                                                                                   j \\leftarrow j + 1
       (\\mathbf{pk}[j&#x27;], \\mathbf{sk}[j&#x27;]) \\leftarrow \\mathcal{G}(\\lambda)
                                                                                                                               z \\leftarrow *Z(\\lambda)
z \\leftarrow s Z(\\lambda)
                                                              \\mathbf{i}[j] \\leftarrow i
                                                                                                                               St \\leftarrow \\varepsilon
                                                                                                                                                                                  \\mathbf{i}[j] \\leftarrow i
                                                                                                                                                                                  For j&#x27;=1,\\ldots,i&#x27; do
                                                              For j&#x27; = 1, \\ldots, i&#x27; do
                                                                                                                               Return z
Return (\\mathbf{pk}, z)
                                                                     \\mathbf{m}[j&#x27;] \\leftarrow \\mathbf{x}[j&#x27;][i]
                                                                                                                                                                                         \\mathbf{m}[j&#x27;] \\leftarrow \\mathbf{x}[j&#x27;][i]
Enc(\\alpha)
                                                                                                                               Msg(\\alpha)
                                                              Return (\\mathbf{m}, \\mathbf{sk}[i])
                                                                                                                                                                                  Return m
(St, \\mathbf{m}) \\leftarrow s D(St, \\alpha)
                                                                                                                               (St, \\mathbf{m}) \\leftarrow s D(St, \\alpha)
                                                                                                                                                                                  FINALIZE(w)
i&#x27; \\leftarrow i&#x27; + 1
                                                                                                                              i&#x27; \\leftarrow i&#x27; + 1
                                                              Return R(\\lambda, z, \\mathbf{x}, \\mathbf{i}, \\boldsymbol{\\alpha}, St, w)
                                                                                                                                                                                  Return R(\\lambda, z, \\mathbf{x}, \\mathbf{i}, \\boldsymbol{\\alpha}, St, w)
\\alpha[i&#x27;] \\leftarrow \\alpha \\; ; \\; \\mathbf{x}[i&#x27;] \\leftarrow \\mathbf{m}
                                                                                                                              \\alpha[i&#x27;] \\leftarrow \\alpha \\; ; \\; \\mathbf{x}[i&#x27;] \\leftarrow \\mathbf{m}
For j&#x27; = 1, \\ldots, n(\\lambda) do
      \\mathbf{c}[j&#x27;] \\leftarrow \\mathcal{E}(\\mathbf{pk}[j&#x27;], \\mathbf{m}[j&#x27;])
Return c
</code></pre>

    <p class="text-gray-300">&lt;span id=&quot;page-19-0&quot;&gt;&lt;/span&gt;Figure 11: Left: &quot;Real world&quot; game  <span class="math">RSOAK_{\\Pi,Z,D,R,n}</span>  for the SOA-K definition. Right: &quot;Ideal world&quot; game  <span class="math">SSOAK_{\\Pi,Z,D,R,n}</span>  for the SOA-K definition.</p>

    <pre><code class="language-text">Alg A&#x27;(\\lambda):
Alg R&#x27;(\\lambda, z, \\mathbf{x}&#x27;, \\mathbf{i}, \\boldsymbol{\\alpha}, St, w):
                                                          Alg D&#x27;(St, \\alpha):
                                                                                                    (\\mathbf{pk}, z) \\leftarrow \\$ Initialize(\\lambda)
For j&#x27; = 1, \\ldots, |\\mathbf{x}&#x27;|
                                                          x \\leftarrow D(St, \\alpha)
                                                                                                    Run A on input \\lambda:
     \\mathbf{x}[j&#x27;] \\leftarrow \\mathbf{x}&#x27;[j&#x27;][p(\\lambda) + 1]
                                                          For i = 1, \\ldots, p(\\lambda) do
                                                                                                          On initialize query \\lambda return (\\mathbf{pk}, z)
                                                                \\mathbf{m}[i] \\leftarrow \\mathcal{F}(\\lambda, a_i, x)
For j&#x27; = 1, ..., |\\mathbf{i}|
                                                                                                          On encryption query \\alpha
     Let i be such that a_i = \\mathbf{i}[j&#x27;]
                                                          \\mathbf{m}[p(\\lambda) + 1] \\leftarrow x
                                                                                                                \\mathbf{c} \\leftarrow \\mathbf{s} \\operatorname{Enc}(\\alpha)
      \\mathbf{a}[j&#x27;] \\leftarrow a_i
                                                          Return m
                                                                                                                Return (\\mathbf{c}[1 \\dots p(\\lambda)], msglen(\\mathbf{c}[p(\\lambda) + 1]))
Return R(\\lambda, z, \\mathbf{x}, \\mathbf{a}, \\boldsymbol{\\alpha}, St, w)
                                                                                                          On key-derivation query a
                                                                                                                Let i be such that a_i = a
                                                                                                                Return CORRUPT(i)
                                                                                                    Let w be the output of A
</code></pre>

    <p class="text-gray-300">&lt;span id=&quot;page-19-1&quot;&gt;&lt;/span&gt;Figure 12: Algorithms for proof of security of brute-force scheme.</p>

    <p class="text-gray-300"><strong>Proof of Theorem 6.1:</strong> Denote by  <span class="math">A_{\\lambda} = \\{\\varepsilon, a_1, a_2, \\dots, a_{p(\\lambda)}\\}</span>  the family of sets satisfying the definition of polynomially-sized index space for  <span class="math">\\mathcal{F}</span> . Let Z be an auxiliary input generator, D be a message sampler, R be a relation, and A be a SS1 adversary. Consider the auxiliary input generator Z' = Z, and then the relation R', message sampler D' and SOA-K adversary A' defined as in Figure 12.</p>

    <p class="text-gray-300">Above, for a ciphertext c,  <span class="math">\\mathsf{msglen}(c)</span>  returns the length of the decryption of c (which we assume is efficiently computable from a ciphertext, or else that D always outputs messages of some known length). Also note that we set  <span class="math">n(\\cdot) = p(\\cdot) + 1</span>  in the SOAK games; this allows A' to pass the length of the &quot;actual&quot; payload x to A and similarly A' to pass the &quot;actual&quot; payload vector  <span class="math">\\mathbf{x}</span>  to A. Since A is SOA-K secure, we know that there exists a PT simulator A' such that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\text{soa-k}}_{\\Pi,A&#x27;,S&#x27;,Z&#x27;,D&#x27;,R&#x27;}(\\cdot) = \\Pr\\left[ \\, \\text{RSOAK}^{A&#x27;}_{\\Pi,Z&#x27;,D&#x27;,R&#x27;}(\\cdot) \\, \\right] - \\Pr\\left[ \\, \\text{SSOAK}^{S&#x27;}_{\\Pi,Z&#x27;,D&#x27;,R&#x27;}(\\cdot) \\, \\right]</span>$</p>

    <p class="text-gray-300">is negligible. Now we use S' to construct S, a simulator for the ISS game, in a similar way we adapted A to get A':</p>

    <pre><code class="language-text">Alg S(\\lambda):

z \\leftarrow s Initialize(\\lambda)

Run S&#x27; on input \\lambda:

i&#x27; \\leftarrow 0

On initialize query \\lambda return z

On message query \\alpha:

i&#x27; \\leftarrow i&#x27; + 1; Msg(\\alpha)

Return \\varepsilon

On corrupt query i:

OP(a_i)

For j = 1, \\ldots, i&#x27;

\\mathbf{x}[j] \\leftarrow F(a_i, j)

Return \\mathbf{x}

Let w be the output of S&#x27;

Return w
</code></pre>

    <p class="text-gray-300">By construction, we now have</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp; \\Pr \\left[ \\, \\mathrm{RSOAK}_{\\Pi,Z&#x27;,D&#x27;,R&#x27;,p+1}^{A&#x27;}(\\cdot) \\, \\right] = \\Pr \\left[ \\, \\mathrm{RSS}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^{A}(\\cdot) \\, \\right] \\\\ &amp; \\Pr \\left[ \\, \\mathrm{SSOAK}_{\\Pi,Z&#x27;,D&#x27;,R&#x27;,p+1}^{S&#x27;}(\\cdot) \\, \\right] = \\Pr \\left[ \\, \\mathrm{ISS}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^{S}(\\cdot) \\, \\right] \\end{split}</span>$</p>

    <p class="text-gray-300">Therefore,</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathbf{Adv}_{\\mathsf{FE},\\mathcal{F},A,S,Z,D,R}^{\\mathsf{ss1}}(\\cdot) &amp;= \\Pr\\left[ \\, \\mathsf{RSS}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^{A}(\\cdot) \\, \\right] - \\Pr\\left[ \\, \\mathsf{ISS}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^{S}(\\cdot) \\, \\right] \\\\ &amp;= \\Pr\\left[ \\, \\mathsf{RSOAK}_{\\Pi,Z&#x27;,D&#x27;,R&#x27;}^{A&#x27;}(\\cdot) \\, \\right] - \\Pr\\left[ \\, \\mathsf{SSOAK}_{\\Pi,Z&#x27;,D&#x27;,R&#x27;,p+1}^{S&#x27;}(\\cdot) \\, \\right] \\\\ &amp;= \\mathbf{Adv}_{\\Pi,A&#x27;,S&#x27;,Z&#x27;,D&#x27;,R&#x27;,p+1}^{\\mathsf{soa-k}}(\\cdot) \\end{split}</span>$</p>

    <p class="text-gray-300">which is negligible by assumption.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-20-5&quot;&gt;&lt;/span&gt;References</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">[1] M. Abdalla, M. Bellare, and G. Neven. Robust encryption. In D. Micciancio, editor, <em>TCC 2010</em>, volume 5978 of <em>LNCS</em>, pages 480â€“497. Springer, Feb. 2010. 5, 6, 8</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-20-1&quot;&gt;&lt;/span&gt;[2] S. Agrawal, D. M. Freeman, and V. Vaikuntanathan. Functional encryption for inner product predicates from learning with errors. In D. H. Lee and X. Wang, editors, <em>ASIACRYPT 2011</em>, volume 7073 of <em>LNCS</em>, pages 21â€“40. Springer, Dec. 2011. 2</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-20-2&quot;&gt;&lt;/span&gt;[3] S. Agrawal, S. Gorbunov, V. Vaikuntanathan, and H. Wee. Functional encryption: New perspectives and lower bound. Cryptology ePrint Archive, Report 2012/468, 2012. http://eprint.iacr.org/. 3, 4</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-20-4&quot;&gt;&lt;/span&gt;[4] M. Barbosa and P. Farshim. Semantically secure functional encryption revisited. Cryptology ePrint Archive, Report 2012/474, 2012. http://eprint.iacr.org/. 4, 7</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-20-0&quot;&gt;&lt;/span&gt;[5] M. Bellare, R. Dowsley, B. Waters, and S. Yilek. Standard security does not imply security against selective-opening. In D. Pointcheval, editor, <em>EUROCRYPT 2012</em>, LNCS. Springer, 2012. 1, 3, 10, 18</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-20-3&quot;&gt;&lt;/span&gt;[6] M. Bellare, D. Hofheinz, and S. Yilek. Possibility and impossibility results for encryption and commitment secure under selective opening. In A. Joux, editor, EUROCRYPT 2009, volume 5479 of LNCS, pages 1â€“35. Springer, Apr. 2009. 4</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-20-6&quot;&gt;&lt;/span&gt;[7] M. Bellare and A. Palacio. GQ and Schnorr identification schemes: Proofs of security against impersonation under active and concurrent attacks. In M. Yung, editor, <em>CRYPTO 2002</em>, volume 2442 of <em>LNCS</em>, pages 162â€“177. Springer, Aug. 2002. 10</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-21-16&quot;&gt;&lt;/span&gt;[8] M. Bellare and P. Rogaway. The security of triple encryption and a framework for code-based gameplaying proofs. In S. Vaudenay, editor, EUROCRYPT 2006, volume 4004 of LNCS, pages 409â€“426. Springer, May / June 2006. <a href="#page-5-0">5,</a> <a href="#page-12-2">12,</a> <a href="#page-14-1">14,</a> <a href="#page-17-0">17</a></p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-21-17&quot;&gt;&lt;/span&gt;&lt;span id=&quot;page-21-14&quot;&gt;&lt;/span&gt;[9] M. Bellare, B. Waters, and S. Yilek. Identity-based encryption secure against selective opening attack. In Y. Ishai, editor, TCC 2011, volume 6597 of LNCS, pages 235â€“252. Springer, Mar. 2011. <a href="#page-4-0">4</a></p></li>
      <li><p class="text-gray-300">[10] D. Boneh and X. Boyen. Efficient selective-ID secure identity based encryption without random oracles. In C. Cachin and J. Camenisch, editors, EUROCRYPT 2004, volume 3027 of LNCS, pages 223â€“238. Springer, May 2004. <a href="#page-5-0">5,</a> <a href="#page-6-1">6</a></p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-21-6&quot;&gt;&lt;/span&gt;[11] D. Boneh and X. Boyen. Secure identity based encryption without random oracles. In M. Franklin, editor, CRYPTO 2004, volume 3152 of LNCS, pages 443â€“459. Springer, Aug. 2004. <a href="#page-2-1">2</a></p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-21-18&quot;&gt;&lt;/span&gt;[12] D. Boneh, G. Di Crescenzo, R. Ostrovsky, and G. Persiano. Public key encryption with keyword search. In C. Cachin and J. Camenisch, editors, EUROCRYPT 2004, volume 3027 of LNCS, pages 506â€“522. Springer, May 2004. <a href="#page-6-1">6,</a> <a href="#page-15-3">15</a></p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-21-1&quot;&gt;&lt;/span&gt;[13] D. Boneh and M. K. Franklin. Identity based encryption from the Weil pairing. SIAM Journal on Computing, 32(3):586â€“615, 2003. <a href="#page-1-0">1,</a> <a href="#page-2-1">2</a></p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-21-0&quot;&gt;&lt;/span&gt;[14] D. Boneh, A. Sahai, and B. Waters. Functional encryption: Definitions and challenges. In Y. Ishai, editor, TCC 2011, volume 6597 of LNCS, pages 253â€“273. Springer, Mar. 2011. <a href="#page-1-0">1,</a> <a href="#page-2-1">2,</a> <a href="#page-3-0">3,</a> <a href="#page-4-0">4,</a> <a href="#page-5-0">5,</a> <a href="#page-6-1">6,</a> <a href="#page-7-1">7,</a> <a href="#page-8-2">8,</a> <a href="#page-9-2">9,</a> <a href="#page-10-3">10,</a> <a href="#page-17-0">17,</a> <a href="#page-18-2">18</a></p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-21-10&quot;&gt;&lt;/span&gt;[15] R. Canetti, U. Feige, O. Goldreich, and M. Naor. Adaptively secure multi-party computation. In 28th ACM STOC, pages 639â€“648. ACM Press, May 1996. <a href="#page-3-0">3,</a> <a href="#page-4-0">4,</a> <a href="#page-18-2">18</a></p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-21-11&quot;&gt;&lt;/span&gt;[16] I. DamgËšard and J. B. Nielsen. Improved non-committing encryption schemes based on a general complexity assumption. In M. Bellare, editor, CRYPTO 2000, volume 1880 of LNCS, pages 432â€“450. Springer, Aug. 2000. <a href="#page-3-0">3,</a> <a href="#page-4-0">4,</a> <a href="#page-18-2">18</a></p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-21-12&quot;&gt;&lt;/span&gt;[17] S. Fehr, D. Hofheinz, E. Kiltz, and H. Wee. Encryption schemes secure against chosen-ciphertext selective opening attacks. In H. Gilbert, editor, EUROCRYPT 2010, volume 6110 of LNCS, pages 381â€“402. Springer, May 2010. <a href="#page-4-0">4</a></p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-21-5&quot;&gt;&lt;/span&gt;[18] S. Goldwasser and S. Micali. Probabilistic encryption. Journal of Computer and System Sciences, 28(2):270â€“ 299, 1984. <a href="#page-2-1">2</a></p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-21-15&quot;&gt;&lt;/span&gt;[19] S. Gorbunov, V. Vaikuntanathan, and H. Wee. Functional encryption with bounded collusions via multi-party computation. In CRYPTO, pages 162â€“179, 2012. <a href="#page-4-0">4</a></p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-21-2&quot;&gt;&lt;/span&gt;[20] V. Goyal, O. Pandey, A. Sahai, and B. Waters. Attribute-based encryption for fine-grained access control of encrypted data. In A. Juels, R. N. Wright, and S. Vimercati, editors, ACM CCS 06, pages 89â€“98. ACM Press, Oct. / Nov. 2006. Available as Cryptology ePrint Archive Report 2006/309. <a href="#page-1-0">1,</a> <a href="#page-2-1">2</a></p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-21-13&quot;&gt;&lt;/span&gt;[21] B. Hemenway, B. Libert, R. Ostrovsky, and D. Vergnaud. Lossy encryption: Constructions from general assumptions and efficient selective opening chosen ciphertext security. In D. H. Lee and X. Wang, editors, ASIACRYPT 2011, volume 7073 of LNCS, pages 70â€“88. Springer, Dec. 2011. <a href="#page-4-0">4</a></p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-21-3&quot;&gt;&lt;/span&gt;[22] J. Katz, A. Sahai, and B. Waters. Predicate encryption supporting disjunctions, polynomial equations, and inner products. In N. P. Smart, editor, EUROCRYPT 2008, volume 4965 of LNCS, pages 146â€“162. Springer, Apr. 2008. <a href="#page-1-0">1,</a> <a href="#page-2-1">2,</a> <a href="#page-6-1">6,</a> <a href="#page-7-1">7,</a> <a href="#page-23-0">23</a></p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-21-7&quot;&gt;&lt;/span&gt;[23] A. B. Lewko, T. Okamoto, A. Sahai, K. Takashima, and B. Waters. Fully secure functional encryption: Attribute-based encryption and (hierarchical) inner product encryption. In H. Gilbert, editor, EURO-CRYPT 2010, volume 6110 of LNCS, pages 62â€“91. Springer, May 2010. <a href="#page-2-1">2</a></p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-21-9&quot;&gt;&lt;/span&gt;[24] A. B. Lewko and B. Waters. Decentralizing attribute-based encryption. In K. G. Paterson, editor, EURO-CRYPT 2011, volume 6632 of LNCS, pages 568â€“588. Springer, May 2011. <a href="#page-2-1">2</a></p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-21-8&quot;&gt;&lt;/span&gt;[25] A. B. Lewko and B. Waters. Unbounded HIBE and attribute-based encryption. In K. G. Paterson, editor, EUROCRYPT 2011, volume 6632 of LNCS, pages 547â€“567. Springer, May 2011. <a href="#page-2-1">2</a></p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-21-4&quot;&gt;&lt;/span&gt;[26] J. B. Nielsen. Separating random oracle proofs from complexity theoretic proofs: The non-committing encryption case. In M. Yung, editor, CRYPTO 2002, volume 2442 of LNCS, pages 111â€“126. Springer, Aug. 2002. <a href="#page-2-1">2,</a> <a href="#page-4-0">4,</a> <a href="#page-18-2">18</a></p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-22-8&quot;&gt;&lt;/span&gt;&lt;span id=&quot;page-22-6&quot;&gt;&lt;/span&gt;[27] T. Okamoto and K. Takashima. Hierarchical predicate encryption for inner-products. In M. Matsui, editor, ASIACRYPT 2009, volume 5912 of LNCS, pages 214â€“231. Springer, Dec. 2009. <a href="#page-2-1">2</a></p></li>
      <li><p class="text-gray-300">[28] T. Okamoto and K. Takashima. Efficient attribute-based signatures for non-monotone predicates in the standard model. In D. Catalano, N. Fazio, R. Gennaro, and A. Nicolosi, editors, PKC 2011, volume 6571 of LNCS, pages 35â€“52. Springer, Mar. 2011. <a href="#page-2-1">2</a></p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-22-2&quot;&gt;&lt;/span&gt;[29] A. O'Neill. Definitional issues in functional encryption. Cryptology ePrint Archive, Report 2010/556, 2010. <a href="http://eprint.iacr.org/">http://eprint.iacr.org/</a>. <a href="#page-1-0">1,</a> <a href="#page-2-1">2,</a> <a href="#page-4-0">4,</a> <a href="#page-7-1">7,</a> <a href="#page-15-3">15</a></p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-22-5&quot;&gt;&lt;/span&gt;[30] R. Ostrovsky, A. Sahai, and B. Waters. Attribute-based encryption with non-monotonic access structures. In P. Ning, S. D. C. di Vimercati, and P. F. Syverson, editors, ACM CCS 07, pages 195â€“203. ACM Press, Oct. 2007. <a href="#page-2-1">2</a></p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-22-1&quot;&gt;&lt;/span&gt;[31] A. Sahai and B. R. Waters. Fuzzy identity-based encryption. In R. Cramer, editor, EUROCRYPT 2005, volume 3494 of LNCS, pages 457â€“473. Springer, May 2005. <a href="#page-1-0">1</a></p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-22-0&quot;&gt;&lt;/span&gt;[32] A. Shamir. Identity-based cryptosystems and signature schemes. In G. R. Blakley and D. Chaum, editors, CRYPTO'84, volume 196 of LNCS, pages 47â€“53. Springer, Aug. 1985. <a href="#page-1-0">1</a></p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-22-7&quot;&gt;&lt;/span&gt;[33] E. Shen, E. Shi, and B. Waters. Predicate privacy in encryption systems. In O. Reingold, editor, TCC 2009, volume 5444 of LNCS, pages 457â€“473. Springer, Mar. 2009. <a href="#page-2-1">2</a></p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-22-4&quot;&gt;&lt;/span&gt;[34] B. Waters. Dual system encryption: Realizing fully secure IBE and HIBE under simple assumptions. In S. Halevi, editor, CRYPTO 2009, volume 5677 of LNCS, pages 619â€“636. Springer, Aug. 2009. <a href="#page-2-1">2</a></p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-22-9&quot;&gt;&lt;/span&gt;&lt;span id=&quot;page-22-3&quot;&gt;&lt;/span&gt;[35] B. Waters. Functional encryption for regular languages. In CRYPTO, pages 218â€“235, 2012. <a href="#page-4-0">4</a></p></li>
      <li><p class="text-gray-300">[36] B. R. Waters. Efficient identity-based encryption without random oracles. In R. Cramer, editor, EURO-CRYPT 2005, volume 3494 of LNCS, pages 114â€“127. Springer, May 2005. <a href="#page-2-1">2,</a> <a href="#page-6-1">6</a></p></li>
    </ul>

    <h2 id="sec-13" class="text-2xl font-bold">&lt;span id=&quot;page-22-10&quot;&gt;&lt;/span&gt;A Standard Primitives</h2>

    <p class="text-gray-300">Public-key encryption schemes. An public-key encryption scheme Î  = (G, E, D) is specified by three PT algorithms. Via (pk,sk)â†$ G(Î») the key-generation algorithm G generates a public key and matching secret key. Via câ†$ E(pk, m) the encryption algorithm E takes pk and message m and returns a ciphertext c âˆˆ {0, 1} &lt;sup&gt;âˆ—&lt;/sup&gt; âˆª {âŠ¥}. Via m â† D(sk, c), the deterministic decryption algorithm V returns a message m. We require that D(sk, E(pk, m)) = m for all Î» âˆˆ N, all (pk,sk) âˆˆ [G(Î»)], and all m âˆˆ {0, 1} âˆ—</p>

    <p class="text-gray-300">Hash Functions. A hash function H = (K, H) is a tuple of PT algorithms. Via hk â†$ K(Î») the key-generation algorithm K produces a key hk. Via y â† H(hk, x) the deterministic hashing algorithm H produces the hash of a string x under key hk. Collision-resistance is defined via game CR&lt;sup&gt;Î“&lt;/sup&gt; whose Initialize(Î») procedure returns hk â†$ K(Î») and whose Finalize procedure on input (x, xâ€² ) returns (x 6= x â€² ) âˆ§ (H(hk, x) = H(hk, xâ€² )). There are no other procedures. The advantage of an adversary C is defined by Advcol &lt;sup&gt;H&lt;/sup&gt;,C(Î») = Pr -CR&lt;sup&gt;C&lt;/sup&gt; &lt;sup&gt;H&lt;/sup&gt;(Î») . We say that H is collision-resistant (CR) if Advcol &lt;sup&gt;H&lt;/sup&gt;,C(Â·) is negligible for every PT C.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-22-11&quot;&gt;&lt;/span&gt;B The Unordered Case</h3>

    <p class="text-gray-300">Unordered SS1. We start by formalizing the definition. Let FE = (Setup,KDer, Enc, Dec) be a F-FE scheme. The definition uses games RSS1-UFE,F,Z,D,R and ISS1-UF,Z,D,R of Figure <a href="#page-23-1">13.</a> (&quot;U&quot; for unordered.) We say that FE is SS1-U-secure if for every auxiliary input generator Z, every PT message sampler D, every PT relation R and every PT adversary A there is a PT simulator S such that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\text{ss-u}}_{\\mathsf{FE},\\mathcal{F},A,S,Z,D,R}(\\cdot) \\ = \\ \\Pr\\left[ \\ \\mathrm{RSS1-U}^{A}_{\\mathsf{FE},\\mathcal{F},Z,D,R}(\\cdot) \\ \\right] - \\Pr\\left[ \\ \\mathrm{ISS1-U}^{S}_{\\mathcal{F},Z,D,R}(\\cdot) \\ \\right]</span>$</p>

    <p class="text-gray-300">is negligible.</p>

    <pre><code class="language-text">PROC INITIALIZE(\\lambda):
                                                                                i, j \\leftarrow 0 : St \\leftarrow \\varepsilon
(pk, sk) \\leftarrow \\$ \\mathsf{Setup}(\\lambda)
                                                                                z \\leftarrow s Z(\\lambda) : A \\leftarrow \\emptyset
z \\leftarrow s Z(\\lambda)
                                                                                Return z
i, j \\leftarrow 0; St \\leftarrow \\varepsilon
                                                                               \\frac{\\text{PROC MSG}(\\alpha):}{Q_{\\alpha} \\leftarrow Q_{\\alpha} \\cup \\{\\alpha\\}}
Return (pk, z)
PROC ENC(\\alpha):
                                                                                (St, \\mathbf{x}[i]) \\leftarrow s D(St, \\alpha)
\\overline{Q_{\\alpha} \\leftarrow Q_{\\alpha} \\cup \\{\\alpha\\}}
                                                                                Return \\mathcal{F}(\\lambda, \\varepsilon, \\mathbf{x}[i])
 (St, \\mathbf{x}[i]) \\leftarrow D(St, \\alpha)
                                                                                PROC OP(a):
\\mathbf{c}[i] \\leftarrow \\mathbf{s} \\, \\mathsf{Enc}(pk, \\mathbf{x}[i])
                                                                                Q_a \\leftarrow Q_a \\cup \\{a\\}
Return (\\mathbf{c}[i], \\mathcal{F}(\\lambda, \\varepsilon, \\mathbf{x}[i]))
                                                                                Return \\varepsilon
PROC KD(a):
                                                                                PROC F(a, s):
Q_a \\leftarrow Q_a \\cup \\{a\\}
                                                                                If a \\in \\mathsf{El}(\\mathbf{a}) and 1 \\le s \\le i then
dk \\leftarrow s \\mathsf{KDer}(sk, a)
                                                                                        Return \\mathcal{F}(\\lambda, a, \\mathbf{x}[s])
Return dk
                                                                                Else return \\perp
\\frac{\\text{PROC FINALIZE}(w):}{\\text{Return } R(\\lambda, z, \\mathbf{x}, Q_a, Q_\\alpha, St, w)} \\; \\left| \\; \\frac{\\text{PROC FINALIZE}(w):}{\\text{Return } R(\\lambda, z, \\mathbf{x}, Q_a, Q_\\alpha, St, w)} \\right|
</code></pre>

    <p class="text-gray-300">&lt;span id=&quot;page-23-1&quot;&gt;&lt;/span&gt;Figure 13: Left: &quot;Real world&quot; game RSS1-U&lt;sub&gt;FE, <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}&lt;/sub&gt;</span></p>

    <p class="text-gray-300">IDENTITY-EMBEDDABLE PE. In the unordered case our result applies to what we call <em>identity-embeddable</em> predicate encryption schemes. Intuitively, these are predicate encryption schemes whose decryption policy embeds an identity matrix. Let  <span class="math">\\mathcal{F}</span>  be a predicate encryption functionality for predicate  <span class="math">\\mathcal{P}</span> . We say that  <span class="math">\\mathcal{F}</span>  is  <span class="math">n(\\cdot)</span> -identity embeddable if there are  <span class="math">\\{(a_{1,\\lambda},\\ldots,a_{n(\\lambda),\\lambda})\\}_{\\lambda\\in\\mathbb{N}}</span>  and  <span class="math">\\{(w_{1,\\lambda},\\ldots,w_{n(\\lambda),\\lambda})\\}_{\\lambda\\in\\mathbb{N}}</span>  such that for all  <span class="math">\\lambda\\in\\mathbb{N}</span>  and all  <span class="math">1\\leq i,j\\leq n(\\lambda)</span> ,  <span class="math">\\mathcal{P}(\\lambda,a_i,w_j)=1</span>  if i=j and  <span class="math">\\perp</span>  otherwise.</p>

    <p class="text-gray-300">Note that the decryption policy described by an identity matrix is exactly that of IBE. Thus, any PE functionality that &quot;contains&quot; the functionality for an IBE scheme with n identities is n-identity embeddable. PE functionalities considered in the literature typically satisfy this requirement. For example, the inner-product functionality over  <span class="math">\\mathbb{Z}_N</span>  introduced by [22] was shown to implement IBE by restricting a to the form (id,1) and w to the form (-1,id') for id, id'  <span class="math">\\in \\mathbb{Z}_N</span> . Thus any inner-product functionality with vectors of dimension 2 is |N|-identity embeddable. Note that in [22] |N| is exponential in  <span class="math">\\lambda</span> , whereas for our application we just need it to be polynomial in  <span class="math">\\lambda</span>  (namely, the output length of a collision-resistant hash function).</p>

    <p class="text-gray-300">&lt;span id=&quot;page-23-2&quot;&gt;&lt;/span&gt;<strong>Theorem B.1</strong> Let  <span class="math">\\mathcal{F}</span>  be a predicate encryption functionality for predicate  <span class="math">\\mathcal{P}</span> . Let  <span class="math">\\mathcal{H} = (K, H)</span>  be a collision-resistant hash function with output length  <span class="math">\\ell_{\\mathcal{H}}(\\cdot)</span> . Suppose that for every  <span class="math">\\lambda \\in N</span> ,  <span class="math">\\mathcal{F}(\\lambda, \\varepsilon, x)</span>  is the same for all  <span class="math">x \\in [X_{\\lambda}]</span> . Furthermore, suppose that  <span class="math">\\mathcal{F}</span>  is  <span class="math">2\\ell_{\\mathcal{H}}(\\cdot)</span> -identity embeddable. Then there does not exist an SS1-U-secure  <span class="math">\\mathcal{F}</span> -FE scheme. More precisely, suppose FE is a  <span class="math">\\mathcal{F}</span> -FE scheme with secret-key length  <span class="math">\\ell_{sk}(\\cdot)</span> . Then for any function  <span class="math">\\mu(\\cdot)</span>  there exists a PT auxiliary input generator Z, message sampler D, PT adversary A, PT relation B, and B CR-adversary B such that for every simulator B</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\mathrm{ss}}_{\\mathsf{FE},\\mathcal{F},A,S,D,R}(\\cdot) \\ \\leq \\ 1 - \\sqrt{\\mathbf{Adv}^{\\mathrm{col}}_{\\mathcal{H},C}(\\cdot) + 1/\\mu(\\cdot)} \\ .</span>$</p>

    <p class="text-gray-300">Adversary A makes  <span class="math">\\ell_{sk}(\\cdot) + \\log \\mu(\\cdot)</span>  encryption queries and  <span class="math">\\ell_{\\mathcal{H}}(\\cdot)</span>  key-derivation queries.</p>

    <p class="text-gray-300">We remark that our theorem and proof treat the case of (P,p), (p,p), and (p,P) PE functionalities in a unified way. However, in the case of (P,p)-PE the condition in the theorem that  <span class="math">\\mathcal{F}</span>  be  <span class="math">2\\ell_{\\mathcal{H}}(\\cdot)</span> -identity embeddable can be improved to  <span class="math">\\ell_{\\mathcal{H}}(\\cdot)</span> -identity embeddable. We also stress that, unlike Theorem 4.1, our result here does not apply to any &quot;non-trivial&quot; functionality but only those of a certain form. Better understanding the nature of the gap between the two results or closing it remains an interesting open problem. It is also interesting to note that our result here uses an adversary that makes  <span class="math">\\ell_{\\mathcal{H}}(\\cdot)</span>  keyderivation queries as opposed to the constant 2 of Theorem 4.1. It would be interesting to know if this is</p>

    <p class="text-gray-300">tight, meaning whether SS1-U can be achieved against adversaries making some small bounded number of key derivation queries.</p>

    <p class="text-gray-300"><strong>Proof of Theorem B.1:</strong> Denote by  <span class="math">\\{(a_{1,\\lambda},\\ldots,a_{2\\ell_{\\mathcal{H}}(\\lambda),\\lambda})\\}_{\\lambda\\in\\mathbb{N}}</span>  and  <span class="math">\\{(w_{1,\\lambda},\\ldots,w_{2\\ell_{\\mathcal{H}}(\\lambda),\\lambda})\\}_{\\lambda\\in\\mathbb{N}}</span>  the values that satisfy  <span class="math">2\\ell_{\\mathcal{H}}(\\lambda)</span> -identity embeddability for  <span class="math">\\mathcal{F}</span> . For  <span class="math">\\lambda\\in\\mathbb{N}</span>  denote by  <span class="math">\\overline{\\varepsilon}_{\\lambda}</span>  the value such that  <span class="math">\\mathcal{F}(\\lambda,\\varepsilon,x)=\\overline{\\varepsilon}_{\\lambda}</span>  for all  <span class="math">x\\in[X_{\\lambda}]</span> . Let  <span class="math">n(\\cdot):=\\ell(\\cdot)+\\log\\mu(\\cdot)</span> . Define auxiliary input generator Z on input  <span class="math">\\lambda</span>  to return  <span class="math">hk\\leftarrow sK(\\lambda)</span> . For  <span class="math">\\lambda\\in\\mathbb{N}</span>  denote by  <span class="math">M_{\\lambda}</span>  a distribution on messages for FE so that if FE is private message then  <span class="math">M_{\\lambda}=\\{0,1\\}</span>  and otherwise is trivial. Then define message sampler D on input  <span class="math">St,\\alpha</span>  to set  <span class="math">St\\leftarrow 1</span>  if  <span class="math">St=\\varepsilon</span>  and  <span class="math">St\\leftarrow St+1</span>  otherwise, and to return  <span class="math">(St,(w_{2(\\lfloor St/n\\rfloor+1)-b,\\lambda},m))</span>  where  <span class="math">b\\leftarrow s\\{0,1\\}</span>  and  <span class="math">m\\leftarrow sM</span> . Define adversary A and relation R as follows:</p>

    <pre><code class="language-text">Alg R(\\lambda, \\mathbf{x}, Q_a, Q_\\alpha, St, w):
Alg A(pk, hk):
                                                            (pk, hk, \\mathbf{c}, h, \\mathbf{sk}) \\leftarrow w
For i = 1, ..., \\ell_{\\mathcal{H}}(\\lambda) n(\\lambda) do:
                                                            If h \\neq H(hk, pk||\\mathbf{c}) then return false
      \\mathbf{c}[i] \\leftarrow \\$ \\operatorname{Enc}(\\lambda)
                                                            If |\\mathbf{sk}| \\neq \\ell_{\\mathcal{H}}(\\lambda) then return false
h \\leftarrow H(hk, pk || \\mathbf{c})
                                                            For i = 1, \\ldots, \\ell_{\\mathcal{H}}(\\lambda) do:
For i = 1 to \\ell_{\\mathcal{H}}(\\lambda) do:
                                                                  If |\\mathbf{sk}[i]| \\neq \\ell_{sk}(\\lambda) then return false
      \\mathbf{sk}[i] \\leftarrow \\$ \\operatorname{KD}(a_{2i-h[i]})
                                                            If Q_a \\neq \\{a_{2i-h[i],\\lambda} : 1 \\leq i \\leq \\ell_{\\mathcal{H}}(\\lambda)\\} then return false
w \\leftarrow (pk, \\mathbf{c}, h, \\mathbf{sk})
                                                            If \\mathbf{x} \\neq \\ell_{\\mathcal{H}}(\\lambda) n(\\lambda) \\vee Q_{\\alpha} \\neq \\{\\lambda\\} then return false
Return w
                                                            For i = 1, \\ldots, \\ell_{\\mathcal{H}}(\\lambda) do:
                                                                  If Dec(\\mathbf{sk}[i], \\mathbf{c}[i \\dots i + n - 1]) \\neq \\mathcal{F}(\\lambda, a_{2i-h[i]}, \\mathbf{x}[i \\dots i + n - 1])
                                                                          Then return false
                                                            Return true
</code></pre>

    <p class="text-gray-300">By construction  <span class="math">\\Pr\\left[\\text{RSS1-U}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^A(\\cdot)\\right] = 1</span> . Let S be any simulator. Furthermore, parsing the output of S as  <span class="math">(pk,\\mathbf{c},h,\\mathbf{sk}) \\leftarrow w</span> , we assume it holds that  <span class="math">h = H(hk,pk\\|\\mathbf{c}), |\\mathbf{sk}| = \\ell_{\\mathcal{H}}(\\lambda)</span>  and  <span class="math">|\\mathbf{sk}[i]| = \\ell_{sk}(\\lambda)</span>  for  <span class="math">1 \\leq i \\leq \\ell_{\\mathcal{H}}(\\lambda), \\ Q_a = \\{a_{2n-h[i],\\lambda} : 1 \\leq i \\leq \\ell_{\\mathcal{H}}\\}</span> , and  <span class="math">|\\alpha| = \\ell_{\\mathcal{H}}(\\lambda)n(\\lambda)</span>  and  <span class="math">Q_\\alpha = \\{\\lambda\\}</span> , since otherwise the relation R returns false. Towards applying Lemma 4.2, we write the execution of S in the ISS-U game as a composition of two algorithms  <span class="math">S_1, S_2</span>  as follows:</p>

    <pre><code class="language-text">\\begin{array}{l} \\mathbf{Alg} \\ S_2(\\overline{St}) \\colon \\\\ St\\|i\\|j\\|\\mathbf{x}\\| \\|A\\|a^* \\leftarrow \\overline{St} \\end{array}
Alg S_1(\\lambda):
i \\leftarrow 0; z \\leftarrow \\text{$} Initialize(\\lambda)
                                                                                         Let i^* be such that a^* \\in \\{a_{2i^*,\\lambda}, a_{2i^*-1,\\lambda}\\}
Run S(z):
                                                                                         For q = 1, \\ldots, n do:
On message-query \\alpha do:
                                                                                                b \\leftarrow \\$ \\{0,1\\} ; m \\leftarrow \\$ M_{\\lambda}
      i \\leftarrow i + 1
      b \\mathop{\\leftarrow} \\mathop{\\$} \\left\\{ 0,1 \\right\\} \\; ; \\; m \\mathop{\\longleftarrow} \\mathop{\\$} M_{\\lambda}
                                                                                               \\mathbf{x}[i^* \\cdot n + q - 1] \\leftarrow (w_{2i^* - b, \\lambda}, m)
      \\mathbf{x}[i] \\leftarrow (w_{2(|i/n|+1)-b,\\lambda}, m)
                                                                                         Run S at state St:
      Return \\overline{\\varepsilon}
                                                                                         On message-query \\alpha do:
                                                                                               i \\leftarrow i + 1
On op-query a do:
      j \\leftarrow j + 1 ; A \\leftarrow A \\cup \\{a\\}
                                                                                                If i \\notin \\{i^* \\cdot n, \\dots, i^* \\cdot n + n - 1\\} do:
                                                                                                      b \\leftarrow \\$ \\{0,1\\} ; m \\leftarrow \\$ M_{\\lambda}
      If j = \\ell_{\\mathcal{H}}(\\lambda) then
            a^* \\leftarrow a
                                                                                                      \\mathbf{x}[i] \\leftarrow (w_{2|\\alpha/n|-b,\\lambda}, m)
            Halt computation of S_1 with state St
                                                                                                Return \\overline{\\varepsilon}
      Else return \\varepsilon
                                                                                          On F-query (a, s) do:
On F-query (a, s) do:
                                                                                                If 1 \\le s \\le i and a \\in \\mathsf{El}(\\mathbf{a}) do:
      If 1 \\le s \\le i and a \\in A do:
                                                                                                Return \\mathcal{F}(\\lambda, a, \\mathbf{x}[s])
      Return \\mathcal{F}(\\lambda, a, \\mathbf{x}[s])
                                                                                                Else return \\perp
                                                                                         Let w be the output of S
      Else return \\perp
\\overline{St} \\leftarrow St \\|i\\|j\\|\\mathbf{x}\\|A\\|a^*
                                                                                         Return w
Return \\overline{St}
</code></pre>

    <p class="text-gray-300">Namely,  <span class="math">S_1</span>  runs S up to the point that it makes its <em>last</em> OP query (namely the  <span class="math">\\ell_{\\mathcal{H}}(\\lambda)</span> -th one), and  <span class="math">S_2</span>  runs S following this OP query. Below we justify the following sequence of inequalities:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\text{ISS1-U}_{\\mathcal{F},Z,D,R}^{S}(\\cdot)\\right] = \\mathbf{AP}_{1}(P_{1}, P_{2}, \\lambda)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq \\sqrt{\\mathbf{AP}_{2}(S_{1}, S_{2}, \\lambda)}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq \\sqrt{\\mathbf{Adv}_{\\mathcal{H},C}^{\\text{col}}(\\lambda) + \\Pr\\left[\\mathcal{F}(\\lambda, a_{\\lambda}, \\mathbf{x}) \\in Y\\right]}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq \\sqrt{\\mathbf{Adv}_{\\mathcal{H},C}^{\\text{col}}(\\lambda) + 2^{\\ell}(1/2)^{n}}</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\sqrt{\\mathbf{Adv}_{\\mathcal{H},C}^{\\text{col}}(\\lambda) + 1/\\mu(\\lambda)}</span>$</p>

    <p class="text-gray-300">Above, the first line is by construction; note that while  <span class="math">S_2</span>  chooses  <span class="math">\\mathbf{x}^*</span>  and hence some components of  <span class="math">\\mathbf{x}</span>  differently than S, this is equivalent due to the 2n-identity embeddability of  <span class="math">\\mathcal{F}</span>  and is only used to make the analysis more transparent. The second is by Lemma 4.2. For the third, we can define C analogously to the proof of Theorem 4.1 (namely, C simply mimics the double execution experiment with  <span class="math">S_1, S_2</span> ). Let us denote the two outputs of  <span class="math">S_2</span>  in that experiment as  <span class="math">w^1 = (pk^1, \\mathbf{c}^1, h^1, \\mathbf{sk}^1)</span>  and  <span class="math">w^2 = (pk^2, \\mathbf{c}^2, h^2, \\mathbf{sk}^2)</span> . Now, unless C finds a collision we have  <span class="math">\\mathbf{c}^1 = \\mathbf{c}^2</span> , denote by  <span class="math">\\mathbf{c}^*</span>  this common value. Then define the set  <span class="math">Y := \\{y \\in \\{0,1\\}^* : \\exists s \\in \\{0,1\\}^\\ell \\text{ s.t. } \\operatorname{Dec}(s, \\mathbf{c}^*[i^*n \\dots i^*n + n - 1]) = y\\}</span> . If it is not the case that  <span class="math">\\mathcal{F}(\\lambda, a_{i^*,\\lambda}, \\mathbf{x}[i^*n \\dots i^*n + n - 1]) \\in Y</span>  when  <span class="math">\\mathbf{x}[i^*n \\dots i^*n + n - 1]</span>  is (re-)sampled by  <span class="math">S_2</span>  then the relation R must reject, as no  <span class="math">\\mathbf{sk}^2</span>  will satisfy  <span class="math">\\operatorname{Dec}(\\mathbf{sk}^2[i^*], \\mathbf{c}^*[i^*n \\dots i^*n + n - 1]) = \\mathcal{F}(\\lambda, a_{i^*n - h[i^*]}, \\mathbf{x}[i^*n \\dots i^*n + n - 1])</span> , justifying the third line above. To see the fourth line, fix  <span class="math">s \\in \\{0,1\\}^\\ell</span>  and denote  <span class="math">\\operatorname{Dec}(s, \\mathbf{c}^*[i^*n \\dots i^*n + n - 1])</span>  by  <span class="math">\\mathbf{x}^*</span> . As  <span class="math">\\mathbf{x}[i^* \\cdot n]</span>  is defined as  <span class="math">(w_{2\\lfloor\\alpha/n\\rfloor - b,\\lambda}, m)</span>  for random  <span class="math">b \\in \\{0,1\\}</span>  and  <span class="math">m \\in M_\\lambda</span> ,  <span class="math">\\mathbf{x}[i^*n \\dots i^*n + n - 1]</span> , which are sampled independently. Taking a union bound over all possible  <span class="math">s \\in \\{0,1\\}^\\ell</span>  yields the fourth line. Finally, for the fifth line above we just substitute  <span class="math">n(\\lambda) = \\ell(\\lambda) + \\log(\\mu(\\lambda))</span> .</p>

`;
---

<BaseLayout title="Semantically-Secure Functional Encryption: Possibility Resul... (2012/515)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2012 &middot; eprint 2012/515
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="semantically-secure-functional-encryption-possibility-2012" />
  </article>
</BaseLayout>
