---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2012/515';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Semantically-Secure Functional Encryption: Possibility Results, Impossibility Results and the Quest for a General Definition';
const AUTHORS_HTML = 'Mihir Bellare, Adam O&#x27;Neill';

const CONTENT = `    <p class="text-gray-300">Semantically-Secure Functional Encryption: Possibility Results, Impossibility Results and the Quest for a General Definition</p>

    <p class="text-gray-300">MIHIR BELLARE¹ ADAM O'NEILL²</p>

    <p class="text-gray-300">August 2012</p>

    <h2 id="sec-1" class="text-2xl font-bold">Abstract</h2>

    <p class="text-gray-300">This paper explains that SS1-secure functional encryption (FE) as defined by Boneh, Sahai and Waters implicitly incorporates security under key-revealing selective opening attacks (SOA-K). This connection helps intuitively explain their impossibility results and also allows us to prove stronger ones. To fill this gap and move us closer to the (laudable) goal of a general and achievable notion of FE security, we seek and provide two “sans SOA-K” definitions of FE security that we call SS2 and SS3. We prove various possibility results about these definitions. We view our work as a first step towards the challenging goal of a general, meaningful and achievable notion of FE security.</p>

    <p class="text-gray-300">¹ Department of Computer Science &amp; Engineering, University of California San Diego, 9500 Gilman Drive, La Jolla, California 92093, USA. Email: mihir@cs.ucsd.edu. URL: http://www.cs.ucsd.edu/users/mihir. Supported in part by NSF grants CNS-0627779 and CCF-0915675.</p>

    <p class="text-gray-300">² Department of Computer Science, Boston University, 111 Cummington St., Boston, MA 02215. Email: amoneill@bu.edu. URL: http://cs-people.bu.edu/amoneill. Supported in part by NSF grants 0546614, 0831281, 1012910, and 1012798.</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Background. Functional encryption (FE) was introduced by Boneh, Sahai and Waters (BSW) <em>[14]</em>. A FE-scheme for a functionality <span class="math">\\mathcal{F}</span>: <span class="math">\\mathbb{N}\\times\\{0,1\\}^{<em>}\\times\\{0,1\\}^{</em>}\\rightarrow\\{0,1\\}^{<em>}\\cup\\{\\bot\\}</span> is a tuple of algorithms <span class="math">\\mathsf{FE}=(\\mathsf{Setup},\\mathsf{KDer},\\mathsf{Enc},\\mathsf{Dec})</span>. An authority lets <span class="math">(pk,sk)\\leftarrow\\mathbin{\\!\\ast\\!}\\mathsf{Setup}(\\lambda)</span>, where <span class="math">\\lambda</span> is the security parameter, and publishes <span class="math">pk</span>. Anyone may now encrypt an input <span class="math">x</span> via <span class="math">c\\leftarrow\\mathbin{\\!\\ast\\!}\\mathsf{Enc}(pk,x)</span>. A user may provide the authority with a </em>functionality index* <span class="math">a</span> and receive a secret key <span class="math">sk_{a}\\leftarrow\\mathbin{\\!\\ast\\!}\\mathsf{KDer}(sk,a)</span>. If the user now applies the decryption algorithm to <span class="math">sk_{a}</span> and any encryption <span class="math">c</span> of <span class="math">x</span>, the result <span class="math">\\mathsf{Dec}(sk_{a},c)</span> will equal <span class="math">\\mathcal{F}(\\lambda,a,x)</span>. Security requires that the user learns nothing more.</p>

    <p class="text-gray-300">The intent was to generalize and unify many forms of encryption including IBE (Identity-based encryption) <em>[32, 13]</em>, ABE (Attribute-based encryption) <em>[31, 20]</em> and PE (Predicate encryption) <em>[22]</em>. An existing form <span class="math">\\mathbf{E}</span> of encryption would correspond to a functionality <span class="math">\\mathcal{F}_{\\mathbf{e}}</span>. IBE for example corresponds to the functionality <span class="math">\\mathcal{F}_{\\text{ibe}}</span> which regards <span class="math">a</span> as an identity and parses <span class="math">x</span> as a pair <span class="math">(a^{\\prime},m)</span> consisting of another identity <span class="math">a^{\\prime}</span> and a message <span class="math">m</span>, returning <span class="math">m</span> if <span class="math">a=a^{\\prime}</span> and <span class="math">\\bot</span> otherwise. PE generalizes to functionalities <span class="math">\\mathcal{F}</span> for which there is a relation <span class="math">\\mathcal{P}</span> such that <span class="math">\\mathcal{F}</span>, given <span class="math">a</span> and <span class="math">x=(a^{\\prime},m)</span>, returns <span class="math">m</span> if <span class="math">\\mathcal{P}(a,a^{\\prime})</span> is true and <span class="math">\\bot</span> otherwise, IBE being the case where <span class="math">\\mathcal{P}(a,a^{\\prime})</span> is true iff <span class="math">a=a^{\\prime}</span>. ABE schemes are a subclass of PE schemes.</p>

    <p class="text-gray-300">BSW <em>[14]</em> sought a general definition of security that applied to an arbitrary functionality. They first provide an indistinguishability-based one (IND). It had the attractive feature of coinciding, for the IBE and PE functionalities, with the the existing definitions of these notions from the literature. But both BSW <em>[14]</em> and O’Neill <em>[29]</em> point to inherent deficiencies of IND when it comes to capturing security of general functionalities. The “main” definition of BSW was accordingly a simulation-based semantic-security one that we call SS1. We may now speak of the SS1-security of an FE scheme <span class="math">\\mathsf{FE}</span> for <em>any</em> functionality <span class="math">\\mathcal{F}</span>.</p>

    <p class="text-gray-300">The FE framework is elegant and the goals are laudable. A proliferating number of notions of encryption are now put under a single umbrella, seen as special cases of a single primitive. Ad hoc, notion-specific security definitions need not be given. One only has to specify the functionality and SS1 security would return a suitable definition.</p>

    <p class="text-gray-300">Impossibility of SS1 in the NPROM. However, having introduced SS1, BSW <em>[14]</em> claim that it can’t be achieved in the standard model, even for IBE, which is the most basic functionality in this area. This is a strong and disappointing claim. Before we delve into its implications, we take a closer look at it. We point out that BSW don’t actually prove this. What they prove is that SS1-secure IBE cannot be achieved in the NPROM (Non-Programmable Random Oracle Model). At a first glance, this only sounds like a stronger claim. Every standard model scheme is a NPROM scheme and every standard-model adversary is a NPROM one, so if NPROM achievability is ruled out, isn’t standard model achievability ruled out as well? The answer is no. BSW <em>[14]</em> establish their claim by providing an adversary for which they prove that there is no simulator. But their adversary makes calls to the RO, and this is exploited crucially in the proof of non-existence of a simulator. Their proof does not rule out the existence of a simulator for adversaries that do not call the RO, meaning for standard-model adversaries, and thus it does not rule out standard-model achievability of SS1, even for IBE.</p>

    <p class="text-gray-300">This gives a ray of hope. Perhaps SS1-security can be achieved in the standard model after all. This would be interesting even for IBE and certainly beyond. This hope is fueled by a look at the technique underlying the negative result of BSW <em>[14]</em>. It is not a priori clear how to extend this technique to rule out simulators for standard-model adversaries.</p>

    <p class="text-gray-300">A new impossibility result for SS1. We fill the gap by showing that SS1-secure IBE is not achievable even in the standard model. The result is actually more general, ruling out SS1-security for <em>any non-trivial functionality</em>, IBE being covered as a special case. Non-triviality essentially means the functionality is not a constant function. The only assumption made is the existence of collision-resistant hash functions.</p>

    <p class="text-gray-300">Our result exploits the recent technique of Bellare, Dowsley, Waters and Yilek (BDWY) <em>[5]</em>, used to prove the impossibility of SOA-secure commitment, in combination with techniques from Nielsen’s</p>

    <p class="text-gray-300">proof of impossibility of non-committing encryption (NCE) <em>[26]</em>. We are able to present a <em>standard model</em> adversary for which we can prove that there is no simulator.</p>

    <p class="text-gray-300">Taking a closer look, our result, as is the case with those of Nielsen and BSW, is actually a trade-off. It shows that SS1-security requires long keys, this meaning that the total number of bits in messages securely encrypted must be bounded by the length of a secret key. However, it does this in the standard model.</p>

    <p class="text-gray-300">An explanation. This paper offers an explanation for this anamoly that seeds further contributions in a natural way. We contend that SS1 does not capture “plain” FE security. Instead, it captures FE security in the presence of key-revealing selective-opening attacks (SOA-Ks). These are attacks where the adversary may adaptively corrupt some users and obtain their decryption keys <em>without restrictions</em>. The revealing fact is that, if we were to write down a definition of SOA-K-security for IBE, what emanates is <em>exactly</em> SS1-secure IBE. We now have a natural explanation of why SS1 is subject to such broad unachievability and also why SS1-secure IBE is not the same as the classical IND-secure IBE from <em>[13]</em>. Namely, the former incorporates SOA-K security and the latter does not.</p>

    <p class="text-gray-300">Why is SOA-K-security part of SS1? BSW <em>[14]</em> did not throw it in “on purpose.” (Their work has no explicit recognition of the fact that their definition incorporates security against SOA-K. They do however comment on the relation to NCE and <em>[26]</em>, which is only a step removed.) Rather, the natural approach to defining semantic security for a general functionality, which is the one followed by BSW <em>[14]</em>, leads to the inadvertent incorporation of SOA-K security.</p>

    <p class="text-gray-300">While it is usually easier to define “plain” security than security against SOA-K, with FE, it seems to be the opposite. It is not clear how to define semantically-secure FE in a way that “decouples” basic and SOA-K security. This, in our view, is rather interesting.</p>

    <p class="text-gray-300">SS2 and SS3. As indicated above, we believe that unifying different existing forms of encryption under a general definition for FE is a highly worthwhile goal. SS1 has not achieved this, capturing instead the SOA-K-secure versions of these goals and thence being subject to strong impossibility results. We move towards the just-stated goal with two new notions that we call SS2 and SS3. Definining “sans SOA-K” FE security in forms of varying strength, they are able to meet many of the broad goals in this domain and open the door to further efforts.</p>

    <p class="text-gray-300">Our main result about SS2 is that it is equivalent to IND for <em>all</em> functionalities. This equivalence has its plusses and its minuses. Let us begin with the former. IND-secure IBE as per <em>[13]</em> is a well established definition, targeted in thousands of papers and proven to work for applications, and IND-secure PE as per <em>[22]</em> is also accepted. The SS2=IND equivalence provides a semantic-security based backing for this IND definition which has so far been absent. Conceptually, it mirrors in the FE setting the classic equivalence between semantic-security and indistinguishability in the PKE setting <em>[18]</em> that is a cornerstone of our understanding of, and faith in, these definitions. More pragmatically, it immediately yields possibility results for semantically-secure FE which were absent under SS1. This is because IND-secure IBE is well-known to be achievable in the standard model <em>[11, 36, 34]</em>, and various possibility results for ABE and PE are known as well <em>[20, 30, 22, 27, 33, 23, 2, 25, 24, 28]</em>.</p>

    <p class="text-gray-300">We believe this is progress towards bringing semantically-secure FE closer. But, while the equivalence of SS2 with IND is a plus for common functionalities like ABE, PE and IBE, it is a minus when looking further, for we already know that IND is <em>not</em> a good definition of FE security in general <em>[29]</em>. Thus, we would like another definition to complement SS2. We suggest SS3, a strengthening of SS2. We believe SS3 is a good candidate for a general definition of FE for arbitrary functionalities. One reason is that it does not appear to have the drawbacks of IND for beyond-PE functionalities. (BSW <em>[14]</em> and O’Neill <em>[29]</em> present IND-secure FE schemes that are intuitively insecure. However, their schemes will correctly be</p>

    <p class="text-gray-300">SS3-insecure.) Another reason is that our impossibility result for SS1 does not extend to SS3. (So in particular, SS3-secure IBE is not ruled out.)</p>

    <p class="text-gray-300">In support of SS3 we show that it is equivalent to IND for “re-sampleable” functionalities. Unfortunately, re-sampleable functionalities does not seem to include common functionalities of interest such as IBE. Indeed, we have not been able to either prove or disprove the equivalence of SS3 with IND for PE functionalities. We suggest that IBE and PE schemes may be directly proven to meet SS3 and leave this as an interesting subject for future work. We note that recent independent and concurrent results of Agrawal et al. <em>[3]</em> (discussed further below) imply that there exists a functionality that cannot meet SS3. However, this situation is very different from that of SS1, for which we show that no non-trivial functionality can meet it. Indeed, we expect that there do exist IBE and PE schemes that meet SS3.</p>

    <p class="text-gray-300">A closer look. Recall that in IBE, the adversary is given a key-derivation oracle, allowing it to obtain a secret key for any identity of its choice. This does <em>not</em> by itself constitute a SOA-K because the adversary is not allowed to call this oracle for the identities underlying challenge ciphertexts. In the SS1 definition, the adversary also gets a key-derivation oracle to obtain a secret key for any functionality index <span class="math">a</span> of its choice. But there seems no simple or natural way to make a rule disallowing querying this oracle on “challenge” ciphertexts because there is no general way to “match” indexes with ciphertexts. Indeed, any key allows the adversary to learn, in principle, something from <em>all</em> challenge ciphertexts and we can hardly disallow all queries. Instead, SS1 allows unrestricted key-derivation queries and gives a compensating ability to the simulator. But now it incorporates SOA-K and is thus rarely achievable.</p>

    <p class="text-gray-300">Roughly, the idea for SS2 is to run in parallel to the real game a “shadow” game where the inputs are independently generated as per the adversary-provided distributions. Key-derivation queries remain unrestricted. But at the end of the game, we check that the revealed keys don’t “differentiate” the real and shadow games. We disallow adversaries who create such differentiation. In essence, this means that we require that the functionality take <em>predictable</em> values on the challenge messages when evaluated with the adversary’s key derivation queries. One can compare this to the IND definition where the adversary is required to make key derivation queries that take the same value on the (known) challenge messages, so the adversary knows these values. Our definition may be written quite modularly relative to SS1, by adding appropriate boxed statements and checks in the games for the latter.</p>

    <p class="text-gray-300">Our SS3 definition strengthens SS2 by dropping the restriction put by SS2 on key-derivation queries made by an adversary <em>before</em> seeing a challenge ciphertext. As such, we believe the SS3 definition is an essentially as-strong-as-possible security definition for FE subject to the constraint that it be achievable without any unnatural restrictions on the adversary or message space. To see why, note the definition of “unpredictable functionalities” used for our impossibility result in Section 4 and the fact that the latter crucially uses the adversary’s ability to make “adaptive” key-derivation queries—i.e., depending on a challenge ciphertext. In essence, the SS3 definition demands that the functionality restricted to the adversary’s adaptive key derivation queries be <em>predictable</em> wrt. the message space.</p>

    <p class="text-gray-300">Standard-model possibility of SS1. Returning to SS1, the negative results discussed above imply that we will need long keys, but we do not know that this is sufficient. There exists only one positive result, and this is in the PROM. Namely, BSW <em>[14]</em> provide a long-key, SS1-secure FE scheme for any functionality <span class="math">\\mathcal{F}</span> where the space of functionality indexes on which <span class="math">\\mathcal{F}</span> is non-trivial has polynomial size. We extend their result to the standard model. We do this by (again) exploiting the SOA-K connection. Namely we establish the same conclusion as BSW but assuming only the existence of a SOA-K-secure PKE scheme, which we know exists in the standard model because we are allowing keys to be long <em>[15, 16]</em>.</p>

    <p class="text-gray-300">Summary of contributions. We make a connection between selective-opening attacks (SOA-K) and FE by observing the implicit presence of the former in SS1, an observation that seeds all the further contributions of this paper, summarized as follows. (1) We show impossibility of SS1-secure FE in the standard model by exploiting techniques underlying negative results for SOA-K <em>[5]</em>. (2) We present the SS2 definition for sans-SOA-K FE and prove it equivalent to IND for all functionalities, thus obtaining a slew of possibility results for SS2 via known possibility results for IBE and PE. (3) We present the stronger</p>

    <p class="text-gray-300">SS3 definition to function as a potential target for functionalites beyond PE and prove a possibility result for it. (4) We extend the only known positive result for a general functionality, namely one from BSW <em>[14]</em> for the case that the the set of indexes on which the functionality is non-trivial has polynomial size, from the PROM (Programmable Random Oracle Model) to the standard model, by using as starting point a SOA-K-secure PKE scheme with large keys, which exists in the standard model <em>[15, 16]</em>.</p>

    <p class="text-gray-300">Discussion and Related work. The observation underlying BSW’s impossibility proof is that SS1-secure IBE must achieve something similar to NCE. O’Neill <em>[29]</em> had the same intuitive observation but did not take it to a result or proof. Our work can be viewed as taking this intuition further to say that SS1-secure IBE must be exactly SOA-K-secure IBE, and similarly for other functionalities.</p>

    <p class="text-gray-300">The difference between NCE and SOA-K is subtle but important, and under-recognized by the community. For example, some works say (for the PKE case) that SOA-K security is impossible with short keys, citing <em>[26]</em>. But, in ruling out NCE, the latter does not rule out SOA-K-security because there are potentially non-NCE ways to achieve SOA-K-security. Our techniques, however, rule out SOA-K-secure PKE with short keys. Although we have known an impossibility result for NCE for a decade, one for SOA-K has only emerged now.</p>

    <p class="text-gray-300">SOAs have so far mainly been considered in the public-key setting. The adversary gets a number of challenge ciphertexts, “opens” a subset of them, and aims to discover something about the messages underlying the rest. There are two kinds of SOAs. In a coin-revealing SOA (SOA-C) the ciphertexts are encrypted under a single public key and opening reveals the coins. Achieving security is challenging but has been done <em>[6, 17, 21]</em>. SOA-C-security was also considered and achieved for IBE <em>[9]</em>. SOA-C is not relevant to our present concerns. In a key-revealing SOA (SOA-K) for PKE, the ciphertexts are encrypted under different public keys and opening reveals the corresponding decryption keys. But SOA-K has not been defined or considered for IBE, let alone for FE. We claim SS1 is, implicitly, defining SOA-K secure FE.</p>

    <p class="text-gray-300">O’Neill <em>[29]</em> considers non-adaptive adversaries (meaning ones that don’t make any key-derivation queries after seeing the challenge ciphertexts). He provides a non-adaptive version of SS1 and shows it equivalent to a non-adaptive version of IND for preimage sampleable functionalities. Most PE functionalities considered in the literature have this property.</p>

    <p class="text-gray-300">Independently, a recent breakthrough work of Gorbunov, Vaikuntanathan and Wee <em>[19]</em> shows that FE for <em>all polynomial-time functionalities</em> can be achieved, subject to the caveat that the adversary in the security experiment make up to <span class="math">q</span> key-derivation queries, where <span class="math">q</span> is fixed ahead of time. Interestingly, they make crucial use of the brute force scheme in their construction, instantiating it with a specific non-committing encryption scheme. (Since the construction only needs to be non-committing wrt. the receiver’s secret key and not the sender’s randomness, they use a simple construction from <em>[16]</em>.) Our result on the brute force scheme generalizes theirs as well as BSW’s. Another recent breakthrough work of Waters <em>[35]</em> contructs public-index PE for regular languages. We believe this recent progress on FE constructions for broader classes of functionalities underscores the importance of our efforts on the definitional front.</p>

    <p class="text-gray-300">Also, interesting works on definitions of FE have emerged on eprint concurrently and independently of our work, namely Agrawal, Gorbunov, Vaikuntanathan and Wee (AGVW) <em>[3]</em> and Barbosa and Farshim (BF) <em>[4]</em>. AGVW present impossibility results for a wPRF based functionality for notions weaker than SS1. As discussed above, their results apply to SS3 and show that SS3 will not be met by all functionalities. They also propose a variant of SS1 that allows an <em>unbounded simulator</em> they call USIM. Interestingly, while they claim BSW’s proof also applies to rule out USIM, this impossibility result inherits the same weaknesses we point out above for the basic impossibility result of BSW. Moreover, our improved impossibility result for SS1 assumes collision-resistant hash functions so does not to rule out USIM (because an unbounded simulator can break collision-resistance). Thus, to the best of our knowledge, whether USIM can be achieved is still open. On the other hand BF point to weaknesses in the BSW definition having to do with “set-up” security. Our definition of SS1 and its variants do not appear to inherit these weaknesses because the simulator is not allowed to choose the auxilliary input. (See the body of the</p>

    <p class="text-gray-300">paper for further explanation.) BF also propose variants of the definition that seem similar in spirit to our SS3 and show various possiblity and impossibility results about them. We have not yet had a chance to do a detailed comparison to our results.</p>

    <h2 id="sec-2" class="text-2xl font-bold">2 Notation and conventions</h2>

    <p class="text-gray-300">If <span class="math">A</span> is an algorithm then <span class="math">y \\leftarrow A(x_1, \\ldots, x_n; r)</span> means we run <span class="math">A</span> on inputs <span class="math">x_1, \\ldots, x_n</span> and coins <span class="math">r</span> and denote the output by <span class="math">y</span>. By <span class="math">y \\leftrightarrow A(x_1, \\ldots, x_n)</span> we denote the operation of picking <span class="math">r</span> at random and letting <span class="math">y \\leftarrow A(x_1, \\ldots, x_n; r)</span>. By <span class="math">[A(x_1, \\ldots, x_n)]</span> we denote the set of all <span class="math">y</span> that have positive probability of being output by <span class="math">A</span> on inputs <span class="math">x_1, \\ldots, x_n</span>. Unless otherwise indicated, an algorithm may be randomized. “PT” stands for “polynomial time.” The security parameter is denoted <span class="math">\\lambda \\in \\mathbb{N}</span> and whenever <span class="math">\\lambda</span> is input to an algorithm it is understood that it is encoded in unary.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">s</span> is a string then $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denotes its length, </span>s[i]<span class="math"> denotes its </span>i<span class="math">th bit, and </span>s[i\\ldots j]<span class="math"> denotes the substring consisting of its </span>i<span class="math">th through </span>j<span class="math">th bits. If </span>\\mathbf{x}<span class="math"> is a vector then </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denotes the number of its components, </span>\\mathbf{x}[i]<span class="math"> denotes its </span>i<span class="math">th component, and </span>\\mathbf{x}[i\\ldots j]<span class="math"> denotes the subvector consisting of its </span>i<span class="math">th through </span>j<span class="math">th components. We write </span>\\mathsf{El}(\\mathbf{x})<span class="math"> to mean </span>\\{\\mathbf{x}[i]: 1 \\leq i \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}<span class="math">. If </span>f<span class="math"> is a function and </span>\\mathbf{x}<span class="math"> is a vector then </span>f(x_1, \\ldots, x_{i-1}, \\mathbf{x}, x_{i+1}, \\ldots, x_n)<span class="math"> denotes the vector whose </span>i<span class="math">-th component is </span>f(x_1, \\ldots, x_{i-1}, \\mathbf{x}[i], x_{i+1}, \\ldots, x_n)<span class="math"> for </span>1 \\leq i \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. A predicate is a function with boolean output.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Games. We use the language of code-based game-playing [8]. A game has an Initialize procedure, procedures to respond to adversary oracle queries, and a Finalize procedure. A game G is executed with an adversary <span class="math">A</span> and security parameter <span class="math">\\lambda</span> as follows. <span class="math">A</span> is given input <span class="math">\\lambda</span> and can then call game procedures. Its first oracle query must be Initialize<span class="math">(\\lambda)</span> and its last oracle query must be to Finalize, and it must make exactly one query to each of these oracles. In between it can query the other procedures as oracles as it wishes. The output of Finalize, denoted <span class="math">\\mathrm{G}^A(\\lambda)</span>, is called the output of the game. Let <span class="math">A^{\\mathrm{G}}(\\lambda)</span> denote the output of the adversary and <span class="math">T(\\mathrm{G}, A, \\lambda)</span> denote <span class="math">\\operatorname*{Pr}\\left[\\mathrm{G}^A(\\lambda)\\right.</span> outputs true].</p>

    <p class="text-gray-300">STANDARD PRINITIVES. In Appendix A we recall the standard notions of public-key encryption and collision-resistant hashing.</p>

    <h2 id="sec-3" class="text-2xl font-bold">3 Functional Encryption and its Security</h2>

    <p class="text-gray-300">FUNCTIONALITIES AND FE SCHEMES. A functionality <span class="math">\\mathcal{F}</span>: <span class="math">\\mathbb{N} \\times \\{0,1\\}^<em> \\times \\{0,1\\}^</em> \\to \\{0,1\\}^* \\cup \\{\\bot\\}</span> is a deterministic PT algorithm. The first input is the security parameter. The second input is called the index and the third input is called the payload. A functional encryption (FE) scheme is a tuple of algorithms <span class="math">\\mathsf{FE} = (\\mathsf{Setup}, \\mathsf{KDer}, \\mathsf{Enc}, \\mathsf{Dec})</span>. The setup algorithm Setup on input <span class="math">\\lambda</span> returns a key-pair <span class="math">(pk, sk)</span>, the master public and secret keys. The key-derivation algorithm KDer on inputs <span class="math">sk, a</span> returns a secret key <span class="math">dk</span> for <span class="math">a</span>. The encryption algorithm Enc on inputs <span class="math">pk, x</span> returns a ciphertext <span class="math">c</span>. The deterministic decryption algorithm Dec on inputs <span class="math">dk, c</span> returns a string <span class="math">y</span>. We say that an FE scheme <span class="math">\\mathsf{FE} = (\\mathsf{Setup}, \\mathsf{KDer}, \\mathsf{Enc}, \\mathsf{Dec})</span> is <span class="math">\\mathcal{F}</span>-correct, or simply an <span class="math">\\mathcal{F}</span>-FE scheme, if <span class="math">\\mathsf{Dec}(dk, \\mathsf{Enc}(pk, x; r)) = \\mathcal{F}(\\lambda, a, x)</span> for all <span class="math">\\lambda, a, x, r</span> satisfying <span class="math">\\mathcal{F}(\\lambda, a, x) \\neq \\bot</span>, all <span class="math">(pk, sk) \\in [\\mathsf{Setup}(\\lambda)]</span> and all <span class="math">dk \\in [\\mathsf{KDer}(sk, a)]</span>. We stress that correctness makes no requirements when <span class="math">\\mathcal{F}(\\lambda, a, x) = \\bot</span>. (We do not mandate that <span class="math">\\mathsf{Dec}(dk, \\mathsf{Enc}(pk, x; r)) = \\mathcal{F}(\\lambda, a, x)</span> in this case, but we do not disallow it either.)</p>

    <p class="text-gray-300">SYNTAX AND CORRECTNESS IN BSW. The range of a functionality in the formal definition of BSW [14] does not include <span class="math">\\bot</span>, and correctness asks that <span class="math">\\mathsf{Dec}(dk, \\mathsf{Enc}(pk, x; r)) = \\mathcal{F}(\\lambda, a, x)</span> for all <span class="math">\\lambda, a, x, r</span>, all <span class="math">(pk, sk) \\in [\\mathsf{Setup}(\\lambda)]</span> and all <span class="math">dk \\in [\\mathsf{KDer}(sk, a)]</span>. However, specific functionalities given in BSW (such as that for IBE, <span class="math">\\mathcal{F}_{\\mathrm{ibe}}^{\\mathsf{P}, \\mathsf{p}}</span> in our notation) do return <span class="math">\\bot</span>. So it would appear that the formal syntax ought to be amended to add <span class="math">\\bot</span> to the range of <span class="math">\\mathcal{F}</span>. Once this is done, the correctness condition of BSW must be revisited. If left unchanged, it would be asking that <span class="math">\\mathsf{Dec}(dk, \\mathsf{Enc}(pk, x; r)) = \\mathcal{F}(\\lambda, a, x)</span> even when <span class="math">\\mathcal{F}(\\lambda, a, x) = \\bot</span>. This, however, would be incorrect. Attacks from [1] show that BB-style IBE schemes [10],</p>

    <p class="text-gray-300">including the BB IBE scheme [10] and Waters's IBE scheme [36], fail to meet this correctness condition relative to  <span class="math">\\mathcal{F}_{\\mathrm{ibe}}^{\\mathsf{P},\\mathsf{p}}</span> . It was not clear to us exactly what BSW intended but we expect they did intend for existing IBE schemes to meet the correctness condition, and accordingly we have relaxed it to only hold when  <span class="math">\\mathcal{F}(\\lambda ,a,x)\\neq \\bot</span> .</p>

    <p class="text-gray-300">PARTICULAR FUNCTIONALITIES. The most important special case of FE in the literature is predicate encryption (PE). We say that  <span class="math">\\mathcal{F}</span>  is a predicate encryption functionality if there is a predicate  <span class="math">\\mathcal{P}</span>  such that  <span class="math">\\mathcal{F}</span>  is  <span class="math">\\mathcal{P}</span> -induced. This means that for all  <span class="math">\\lambda</span> , all  <span class="math">a \\neq \\varepsilon</span>  and all  <span class="math">(a&#x27;, m)</span>  we have  <span class="math">\\mathcal{F}(\\lambda, a, (a&#x27;, m)) = m</span>  if  <span class="math">\\mathcal{P}(\\lambda, a, a&#x27;) = \\text{true}</span>  and  <span class="math">\\bot</span>  otherwise. (We also require that  <span class="math">\\mathcal{F}(\\lambda, a, x)</span>  returns  <span class="math">\\bot</span>  if  <span class="math">x</span>  is not a pair. Note that no requirement is made on  <span class="math">\\mathcal{F}(\\lambda, \\varepsilon, (a&#x27;, m))</span> , so a single predicate could induce many different functionalities which vary in what is revealed under  <span class="math">a = \\varepsilon</span> .) We call  <span class="math">m</span>  the message. The IBE predicate  <span class="math">\\mathcal{P}_{\\mathrm{ibe}}</span>  is defined by  <span class="math">\\mathcal{P}_{\\mathrm{ibe}}(\\lambda, a, a&#x27;) = (a = a&#x27;)</span> , and we say that  <span class="math">\\mathcal{F}</span>  is an IBE functionality if it is  <span class="math">\\mathcal{P}_{\\mathrm{ibe}}</span> -induced. (So, again, there may be many different IBE functionalities.) Within the class of PE functionalities, we distinguish whether the index, the message, or both are to be kept private, with corresponding IBE functionalities as canonical examples:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Public index, private message: We say that  <span class="math">\\mathcal{F}</span>  is a  <span class="math">(\\mathsf{P},\\mathsf{p})</span> -PE functionality if  $\\mathcal{F}(\\lambda ,\\varepsilon ,(a^{\\prime},m)) = (a^{\\prime},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> . Called PE with public index in the literature. The canonical example is the IBE functionality  </span>\\mathcal{F}_{\\mathrm{ibe}}^{\\mathsf{P},\\mathsf{p}}<span class="math">  which sets  </span>\\mathcal{F}_{\\mathrm{ibe}}^{\\mathsf{P},\\mathsf{p}}(\\lambda ,\\varepsilon ,(a^{\\prime},m)) = (a^{\\prime},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ , corresponding to IBE that hides the message but not necessarily the identity.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Private index, public message: We say that  <span class="math">\\mathcal{F}</span>  is a  <span class="math">(\\mathsf{p},\\mathsf{P})</span> -PE functionality if  <span class="math">\\mathcal{F}(\\lambda ,\\varepsilon ,(a^{\\prime},m)) = m</span> . Called predicate-only PE in the literature. The canonical example is the IBE functionality  <span class="math">\\mathcal{F}_{\\mathrm{ibe}}^{\\mathsf{p},\\mathsf{P}}</span>  which sets  <span class="math">\\mathcal{F}_{\\mathrm{ibe}}^{\\mathsf{p},\\mathsf{P}}(\\lambda ,\\varepsilon ,(a^{\\prime},m)) = m</span> , corresponding to IBE that hides the identity but not necessarily the message. PEKS [12] is a  <span class="math">(\\mathsf{p},\\mathsf{P})</span> -PE functionality that additionally satisfies robustness [1].</li>

    </ul>

    <p class="text-gray-300">We don't discuss  <span class="math">(\\mathsf{P},\\mathsf{P})</span> -PE because it reveals everything and is uninteresting.</p>

    <p class="text-gray-300">SS1 DEFINITION. The following definition is adapted from [14]. Let  <span class="math">\\mathsf{FE} = (\\mathsf{Setup},\\mathsf{KDer},\\mathsf{Enc},\\mathsf{Dec})</span>  be an  <span class="math">\\mathcal{F}</span> -FE scheme. The definition uses games  <span class="math">\\mathrm{RSS1}_{\\mathsf{FE},\\mathcal{F},Z,D,R}</span>  and  <span class="math">\\mathrm{ISS1}_{\\mathcal{F},Z,D,R}</span>  of Figure 1. We provide some intuition for these games below. We say that  <span class="math">\\mathsf{FE}</span>  is SS1-secure if for every auxiliary input generator  <span class="math">Z</span> , every PT message sampler  <span class="math">D</span> , every PT relation  <span class="math">R</span>  and every PT adversary  <span class="math">A</span> , there is a PT simulator  <span class="math">S</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {\\mathsf {F E}, \\mathcal {F}, A, S, Z, D, R} ^ {\\mathrm {s s 1}} (\\cdot) = T (\\mathrm {R S S 1} _ {\\mathsf {F E}, \\mathcal {F}, Z, D, R}, A, \\cdot) - T (\\mathrm {I S S 1} _ {\\mathcal {F}, Z, D, R}, S, \\cdot)</span></div>

    <p class="text-gray-300">is negligible. We note that the auxiliary input will be used in our impossibility result in Section 4 (where it contains a key for a collision-resistant hash function). Although we omit to do this for simplicity because it does not affect our results, it can also be given as an additional argument to a functionality itself. For example, in the case of the inner-product functionality introduced in [22] it can then contain the modulus  <span class="math">N</span>  of unknown factorization.</p>

    <p class="text-gray-300">INITIATIVE OVERVIEW OF THE DEFINITION. To gain some intuition for the games, let us first look at the "real world" game with the adversary. It has access to two main oracles, an encryption oracle Enc and key-derivation oracle Kd. The former takes input  <span class="math">\\alpha</span> , which describes a message-space from which to sample, and outputs the encryption of a sampled message  <span class="math">x</span> . The latter takes as input a functionality index  <span class="math">a</span>  and returns a corresponding secret key. Note that the game records the queries made to these oracles, in order, and provides this as input to the relation  <span class="math">R</span> . Now let us look at the "ideal world" game</p>

    <p class="text-gray-300">2 The difficulty is that correctness is required for all x, a and thus when x = (a', m) with a' \\neq a , it is required that \\mathsf{Dec}(dk, \\mathsf{Enc}(pk, (a', m); r)) = \\bot when dk \\in [\\mathsf{KDer}(sk, a)] . This is a form of robustness as defined in [1] and, as indicated there, often useful, but it is not a standard requirement for IBE schemes and most don't meet it.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PROC INITIALIZE(λ):</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PROC INITIALIZE(λ):</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PROC INITIALIZE(λ):</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(pk,sk)←*Setup(λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">i,j←0; St←ε</td>

            <td class="px-3 py-2 border-b border-gray-700">(pk,sk)←*Setup(λ); i,j←0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">z←*Z(λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">z←*Z(λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">Return pk</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">i,j←0; St←ε</td>

            <td class="px-3 py-2 border-b border-gray-700">Return z</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Return (pk,z)</td>

            <td class="px-3 py-2 border-b border-gray-700">PROC MSG(α):</td>

            <td class="px-3 py-2 border-b border-gray-700">PROC LR(x0,x1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PROC ENC(α):</td>

            <td class="px-3 py-2 border-b border-gray-700">i←i+1</td>

            <td class="px-3 py-2 border-b border-gray-700">i←i+1; (x0[i],x1[i])←(x0,x1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">i←i+1</td>

            <td class="px-3 py-2 border-b border-gray-700">q[i]←α; t[i]←enc</td>

            <td class="px-3 py-2 border-b border-gray-700">c[i]←*Enc(pk,xb)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">q[i]←α; t[i]←enc</td>

            <td class="px-3 py-2 border-b border-gray-700">(St,x[i])←*D(St,α)</td>

            <td class="px-3 py-2 border-b border-gray-700">Return c[i]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(St,x[i])←*D(St,α)</td>

            <td class="px-3 py-2 border-b border-gray-700">Return F(λ,ε,x[i])</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">c[i]←*Enc(pk,x[i])</td>

            <td class="px-3 py-2 border-b border-gray-700">PROC OP(a):</td>

            <td class="px-3 py-2 border-b border-gray-700">PROC KD(a):</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Return (c[i],F(λ,ε,x[i]))</td>

            <td class="px-3 py-2 border-b border-gray-700">i←i+1</td>

            <td class="px-3 py-2 border-b border-gray-700">j←j+1; a[j]←a</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PROC KD(a):</td>

            <td class="px-3 py-2 border-b border-gray-700">q[i]←a; t[i]←kd</td>

            <td class="px-3 py-2 border-b border-gray-700">dk←*KDer(sk,a)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">i←i+1</td>

            <td class="px-3 py-2 border-b border-gray-700">Return ε</td>

            <td class="px-3 py-2 border-b border-gray-700">Return dk</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">q[i]←a; t[i]←kd</td>

            <td class="px-3 py-2 border-b border-gray-700">PROC F(a,s):</td>

            <td class="px-3 py-2 border-b border-gray-700">PROC FINALIZE(b'):</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">dk←*KDer(sk,a)</td>

            <td class="px-3 py-2 border-b border-gray-700">If a∈El(a) and 1≤s≤i then</td>

            <td class="px-3 py-2 border-b border-gray-700">a[j+1]←ε</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Return dk</td>

            <td class="px-3 py-2 border-b border-gray-700">Return F(λ,a,x[s])</td>

            <td class="px-3 py-2 border-b border-gray-700">For j'=1,...,j+1 do</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PROC FINALIZE(w):</td>

            <td class="px-3 py-2 border-b border-gray-700">Else return ⊥</td>

            <td class="px-3 py-2 border-b border-gray-700">If F(λ,a[j'],x0)≠F(λ,a[j'],x1) then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Return R(λ,z,x,q,t,St,w)</td>

            <td class="px-3 py-2 border-b border-gray-700">PROC FINALIZE(w):</td>

            <td class="px-3 py-2 border-b border-gray-700">return false</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | Return R(λ,z,x,q,t,St,w) |   |</p>

    <p class="text-gray-300">Figure 1: Left: "Real world" game RSS1 <span class="math">_{\\mathsf{FE},\\mathcal{F},Z,D,R}</span>  for the SS1 definition. Middle: "Ideal world" game ISS1 <span class="math">_{\\mathcal{F},Z,D,R}</span>  for the SS1 definition. Right: game IND <span class="math">_{\\mathsf{FE},\\mathcal{F},b}</span>  for the IND definition.</p>

    <p class="text-gray-300">with the simulator. The simulator has access to not two but three main oracles, a message sampling oracle MSG, an operation oracle OP, and a functionality oracle F. The first on input  <span class="math">\\alpha</span> , which again describes a message-space from which to sample, samples a message  <span class="math">x</span>  but simply returns  <span class="math">\\mathcal{F}(\\lambda, \\varepsilon, x)</span> . (We follow BSW [14] in using the value under index  <span class="math">\\varepsilon</span>  to describe what information about the message is publicly computable from a ciphertext.) The second records that an input functionality index  <span class="math">a</span>  is "legal to be used" by the last oracle. The last oracle takes such an index  <span class="math">a</span>  and a position  <span class="math">s</span>  to return  <span class="math">\\mathcal{F}(\\lambda, a, x_s)</span>  where  <span class="math">x_s</span>  is the  <span class="math">s</span> th sampled message by MSG. Intuitively, OP queries of the simulator correspond to KD queries of the adversary, and indeed they are input to the relation  <span class="math">R</span>  in the analogous manner. F queries can always be made "for free" by the simulator (they are not input to  <span class="math">R</span> ).</p>

    <p class="text-gray-300">DISCUSSION OF SS1. We have discussed SS1 as being the BSW [14] definition, which it is in spirit, but there are some differences in detail. BSW indicate that there are several dimensions of choice. They choose to formalize a non-adaptive version with blackbox simulators, saying that variants may be formalized similarly. We have chosen to formalize the variant with adaptive security and non-blackbox simulation. BSW give  <span class="math">pk</span>  as input to the relation and we do not, but this choice does not matter. However, a novelty of our definition is the introduction of auxiliary inputs. Besides what is noted above in their regard, we note that our use of auxiliary inputs rescues our definitions from the weaknesses of the BSW definition pointed out in BF [4]. The issue raised by the latter arises with a functionality, such as inner-product PE [22], that depends on a parameter, such as a hard-to-factor modulus, that must be generated in a setup phase. Under BSW [14] and O'Neill [29], this would have to be done by the Setup algorithm of the FE scheme and the modulus would be part of  <span class="math">pk</span> . The problem raised by BF [4] then occurs because the simulator can pick  <span class="math">pk</span> . We, however, do not give  <span class="math">pk</span>  as input to  <span class="math">\\mathcal{F}</span>  and would capture setup-based functionalities by having the setup done by the auxiliary input generator algorithm  <span class="math">Z</span> , so that the modulus, in our example, would be part of the output  <span class="math">z</span>  of this algorithm. However, the simulator is not allowed to pick  <span class="math">z</span> , and thus the attack of BF [4] would not appear to apply.</p>

    <p class="text-gray-300">IND DEFINITION. Let  <span class="math">\\mathsf{FE} = (\\mathsf{Setup},\\mathsf{KDer},\\mathsf{Enc},\\mathsf{Dec})</span>  be an  <span class="math">\\mathcal{F}</span> -FE scheme. The definition uses game</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 2: Left: "Real world" game RSS2 <span class="math">_{FE, \\mathcal{F}, Z, D, R}</span>  for the SS2 definition. Middle: "Ideal world" game ISS2 <span class="math">_{\\mathcal{F}, Z, D, R}</span>  for the SS2 definition. Right: FINALIZE procedure, common to the two games.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a></p>

    <p class="text-gray-300"><span class="math">\\mathrm{IND}_{\\mathsf{FE},\\mathcal{F},b}</span>  of Figure 1 for  <span class="math">b \\in \\{0,1\\}</span> . We say that FE is IND-secure if for every adversary  <span class="math">B</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {\\mathsf {F E}, \\mathcal {F}, B} ^ {\\mathrm {i n d}} (\\cdot) = T (\\mathrm {I N D} _ {\\mathsf {F E}, \\mathcal {F}, 1}, B, \\cdot) - T (\\mathrm {I N D} _ {\\mathsf {F E}, \\mathcal {F}, 0}, B, \\cdot)</span></div>

    <p class="text-gray-300">is negligible.</p>

    <p class="text-gray-300">ROBUSTNESS. Robustness, introduced for IBE and PKE in [1], seems important more generally for FE, particularly for predicate-only predicate encryption. To explain the issue, recall that correctness was mute in the case that  <span class="math">\\mathcal{F}(\\lambda, a, x) = \\bot</span> , meaning in this case no requirement was put on the output of  <span class="math">\\mathrm{Dec}(dk, \\mathrm{Enc}(pk, x))</span>  when  <span class="math">dk \\in [\\mathrm{KDer}(sk, a)]</span> . Roughly, robustness asks that  <span class="math">\\mathrm{Dec}(dk, \\mathrm{Enc}(pk, x)) = \\bot</span>  in this case. In the case of PEKS this is important to avoid false positives in the testing.</p>

    <p class="text-gray-300">The reason it is not quite so simple is that asking for the above condition globally and unconditionally seems to yield something that is hard to achieve. Instead, one can ask for various computational relaxations in the style of [1]. To exemplify, here is one that is very strong but attractive due to its simplicity: procedure INITIALIZE(λ) of game ROB <span class="math">_{\\mathsf{FE},\\mathcal{F}}</span>  lets  <span class="math">(pk,sk)\\gets *\\mathsf{Setup}(\\lambda)</span>  and returns both keys, meaning the adversary gets  <span class="math">sk</span> . FINALIZE(a,x) returns  <span class="math">((\\mathcal{F}(\\lambda ,a,x) = \\bot)\\wedge (\\mathsf{Dec}(\\mathsf{KDer}(sk,a),\\mathsf{Enc}(pk,x))\\neq \\bot)</span> .</p>

    <p class="text-gray-300">We show that the SS1 notion is impossible to achieve in the standard model, so long as the functionality is reasonably likely to take more than one possible value on a challenge message. This result only assumes the existence of a collision-resistant hash function.</p>

    <p class="text-gray-300">Following [14] we also consider a relaxation of the SS1 notion where vectors  <span class="math">\\mathbf{a},\\pmb{\\alpha}</span>  are replaced by unordered sets, thus giving the simulator more power (since it can make its queries in a different order than the adversary). We obtain a similar but more restrictive impossibility result in this case. Here we present the ordered case. The unordered one is in Appendix B.</p>

    <p class="text-gray-300">UNPREDICTABLE FUNCTIONALITIES. In the ordered case our result applies to any unpredictable functionality. Let  <span class="math">\\mathcal{F}</span>  be a functionality,  <span class="math">\\mathcal{A} = \\{a_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}}</span>  be a family of functionality indices (strings), and  <span class="math">\\mathcal{X} = \\{X_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}}</span>  be a family of payload distributions. We say that  <span class="math">\\mathcal{F}</span>  is  <span class="math">p(\\cdot)</span> -unpredictable wrt.  <span class="math">\\mathcal{A},\\mathcal{X}</span>  if for</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 3: Left: "Real world" game RSS3FE,  <span class="math">\\mathcal{F},Z,D,R</span>  for the SS3 definition. Middle: "Ideal world" game ISS3F,Z,D,R for the SS3 definition. Right: FINALIZE procedure, common to the two games.</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a></p>

    <p class="text-gray-300">all  <span class="math">\\lambda \\in \\mathbb{N}</span>  and all  <span class="math">y\\in \\{0,1\\} ^<em>\\cup \\{\\bot \\}</span> ,  <span class="math">\\operatorname </em>{Pr}[x\\gets \\circ X_{\\lambda}:y = \\mathcal{F}(\\lambda ,a_{\\lambda},x)]\\leq 1 - 1 / p(\\lambda)</span> .</p>

    <p class="text-gray-300">For example, the functionality  <span class="math">\\mathcal{F}_{\\mathrm{bit - ibe}}^{\\mathsf{P},\\mathsf{p}}</span>  for a one-bit IBE scheme, which parses  <span class="math">x</span>  as  <span class="math">(a&#x27;, b)</span> , and returns  <span class="math">b</span>  if  <span class="math">a = a&#x27;</span>  and  <span class="math">\\perp</span>  otherwise, is a 2-unpredictable function wrt.  <span class="math">\\mathcal{A}, \\mathcal{X}</span>  where, for all  <span class="math">\\lambda \\in \\mathbb{N}</span> , we let  <span class="math">a_{\\lambda}</span>  be a fixed but arbitrary identity and  <span class="math">\\mathcal{X}_{\\lambda}</span>  return  <span class="math">(a_{\\lambda}, d)</span>  where the message  <span class="math">d \\in \\{0,1\\}</span>  is random. As another example, the functionality  <span class="math">\\mathcal{F}_{\\mathrm{peks}}^{\\mathsf{p},\\mathsf{p}}</span>  for a PEKS scheme, which returns 1 if  <span class="math">a = x</span>  and  <span class="math">\\perp</span>  otherwise, is a 2-unpredictable function wrt.  <span class="math">\\mathcal{A}, \\mathcal{X}</span>  where for all  <span class="math">\\lambda \\in \\mathbb{N}</span> , we again let  <span class="math">a_{\\lambda}</span>  be fixed but arbitrary keyword and  <span class="math">\\mathcal{X}_{\\lambda}</span>  return a random keyword  <span class="math">x \\in \\{a_{\\lambda}, a_{\\lambda}&#x27;\\}</span>  for some also fixed but arbitrary  <span class="math">a_{\\lambda}&#x27; \\neq a_{\\lambda}</span> . Indeed, unpredictability with respect to some family of input distributions and functionality indices is a minimal requirement for a functionality to be interesting; otherwise, it is trivial to build an FE scheme for it because anyone can decrypt correctly without even using the ciphertext. In this sense, our result below rules out an SS1-secure FE scheme for any non-trivial functionality.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">SECRET-KEY LENGTH. we say that an FE scheme  <span class="math">\\mathsf{FE} = (\\mathsf{Setup},\\mathsf{KDer},\\mathsf{Enc},\\mathsf{Dec})</span>  has secret-key length  <span class="math">\\ell (\\cdot)</span>  if  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">dk</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\ell (\\lambda) = \\mathcal{F}(\\lambda ,a,x)<span class="math">  for all  </span>\\lambda ,a,x,r<span class="math"> , all  </span>(pk,sk)\\in [\\mathsf{Setup}(\\lambda)]<span class="math"> , and all  </span>dk\\in [\\mathsf{KDer}(sk,a)]<span class="math"> . Note that every FE scheme must have some polynomial  </span>\\ell (\\cdot)$  secret-key length in order to be efficient.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Theorem 4.1 Let  <span class="math">p(\\cdot) &amp;gt; 1</span>  be a polynomial. Suppose  <span class="math">\\mathcal{F}</span>  is a  <span class="math">p(\\cdot)</span> -unpredictable functionality wrt.  <span class="math">\\mathcal{A} = \\{a_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}}, \\mathcal{X} = \\{X_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}}</span> . Furthermore, suppose that for every  <span class="math">\\lambda \\in N</span> ,  <span class="math">\\mathcal{F}(\\lambda, \\varepsilon, x)</span>  is the same for all  <span class="math">x \\in [X_{\\lambda}]</span> . Let  <span class="math">\\mathcal{H} = (K, H)</span>  be a collision-resistant hash function. Then there does not exist an SS1-secure  <span class="math">\\mathcal{F}</span> -FE scheme. More precisely, suppose FE is a  <span class="math">\\mathcal{F}</span> -FE scheme with secret-key length  <span class="math">\\ell(\\cdot)</span> . Then for any function  <span class="math">\\mu(\\cdot)</span>  there exists a PT auxiliary input generator  <span class="math">Z</span> , message sampler  <span class="math">D</span> , PT adversary  <span class="math">A</span> , PT relation  <span class="math">R</span> , and CR-adversary  <span class="math">C</span>  such that for every simulator  <span class="math">S</span></p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {\\mathsf {F E}, \\mathcal {F}, A, S, Z, D, R} ^ {\\mathrm {P S}} (\\cdot) \\geq 1 - \\sqrt {\\mathbf {A d v} _ {\\mathcal {H} , C} ^ {\\mathrm {c o l}} (\\cdot) + 1 / \\mu (\\cdot)}.</span></div>

    <p class="text-gray-300">Adversary  <span class="math">A</span>  makes  <span class="math">p(\\cdot)(\\ell(\\cdot) + \\log \\mu(\\cdot))</span>  encryption queries and two key-derivation queries.</p>

    <p class="text-gray-300">To compare, BSW [14] ruled out SS1-secure IBE against adversaries with access to a non-programmable random oracle, so our result improves theirs in two respects: to apply to any non-trivial functionality and standard-model adversaries. It also reveals a trade-off between secret-key length and the total number of bits encrypted. Namely, when the difference is even one bit (i.e., the total number of bits encrypted is one</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Alg A(pk,hk): For i = 1, ..., n(λ) do: c[i] ←→ ENC(λ) h ← H(hk,pk</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c) skh ←→ KD(h) ska ←→ KD(aλ) w ← (pk, c, h, f, skh, ska) Return w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Alg R(λ, x, a, α, St, w): (pk, c, h, f, skh, ska) ← w If h ≠ H(hk, pk</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c) then return false If</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">skh</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">≠ ℓ or</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ska</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">≠ ℓ then return false If</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">α</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">≠ n ∨ α ≠ (λ, ..., λ) then return false If</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">≠ 2 ∨ a[1] ≠ h ∨ a[2] ≠ aλ then return false If Dec(ska, c) ≠ F(λ, aλ, x) then return false Return true</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 4: Algorithms  <span class="math">A</span>  and  <span class="math">R</span>  for proof of Theorem 4.1.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Alg S1(λ): i←0 z←*INITIALIZE(λ) Run S(z): On message-query α do: i←i+1; Return π On op-query a do: Halt computation of S1 with state St St←St</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i; Return St</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Alg S2(St): St</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i←St; A←∅ For i=1,...,n(λ) do x[i]←*Xλ Run S at state St: On message-query α do: i←i+1; Return π On op-query a do: A←A∪{a}; Return ε On F-query (a,s) do: If 1≤s≤i and a∈A do: Return F(λ,a,x[s]) Else return ⊥ Let w be the output of S; Return w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Adversary C(λ): hk←<em>INITIALIZE(λ) Run S1 on λ, replying to INITIALIZE with hk Let St be the output of S1 w1,w2←</em>S2(St) (pk1,c1,h1,f1,skh1,skh1)←w1 (pk2,c2,h2,f2,skh2,skh2)←w2 Return (pk1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c1,pk2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c2)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 5: Algorithms  <span class="math">S_{1}, S_{2}</span>  and  <span class="math">C</span>  for proof of Theorem 4.1.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">more than the secret-key length) our adversary's advantage is non-negligible. We also note that, while for technical reasons we require  <span class="math">\\mathcal{F}(\\lambda, \\varepsilon, x)</span>  to take the same value on every possible challenge payload  <span class="math">x</span> , this is not a major restriction in practice since typically  $\\mathcal{F}(\\lambda, \\varepsilon, x) =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ ; then we are just requiring as usual that possible challenge messages have the same length.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The proof combines and extends ideas of [14] and [5]. As in [5] will make use of a version of the Reset Lemma of [7].</p>

    <p class="text-gray-300">Lemma 4.2 Let  <span class="math">P_{1}, P_{2}</span>  be algorithms, the second with boolean output. The single-execution acceptance probability  <span class="math">\\mathbf{AP}_1(P_1, P_2, \\lambda)</span>  is defined as the probability that  <span class="math">d = \\text{true}</span>  in the single execution experiment  <span class="math">\\overline{St} \\gets {}^s P_1(\\lambda)</span> ;  <span class="math">d \\gets {}^s P_2(\\overline{St})</span> . The double-execution acceptance probability  <span class="math">\\mathbf{AP}_2(P_1, P_2, \\lambda)</span>  is defined as the probability that  <span class="math">d_1 = d_2 = \\text{true}</span>  in the double execution experiment  <span class="math">\\overline{St} \\gets {}^s P_1(\\lambda)</span> ;  <span class="math">d_0, d_1 \\gets {}^s P_2(\\overline{St})</span> . Then  <span class="math">\\mathbf{AP}_1(P_1, P_2, \\lambda) \\leq \\sqrt{\\mathbf{AP}_2(P_1, P_2, \\lambda)}</span>  for all  <span class="math">\\lambda \\in \\mathbb{N}</span> .</p>

    <p class="text-gray-300">Proof of Theorem 4.1: For  <span class="math">\\lambda \\in \\mathbb{N}</span>  denote by  <span class="math">\\overline{\\varepsilon}_{\\lambda}</span>  the value such that  <span class="math">\\mathcal{F}(\\lambda, \\varepsilon, x) = \\overline{\\varepsilon}_{\\lambda}</span>  for all  <span class="math">x \\in [X_{\\lambda}]</span> . Let  <span class="math">n(\\cdot) = p(\\cdot)(\\ell(\\cdot) + \\log \\mu(\\cdot))</span> . Define  <span class="math">Z</span>  on input  <span class="math">\\lambda</span>  to return  <span class="math">hk \\gets {}^s K(\\lambda)</span> . Define message sampler  <span class="math">D</span>  on inputs  <span class="math">St, \\alpha</span>  to (ignore  <span class="math">St</span>  and) return  <span class="math">x \\gets {}^s X(\\alpha)</span> . Define adversary  <span class="math">A</span>  and relation  <span class="math">R</span>  as in Figure 4.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By construction  <span class="math">\\operatorname*{Pr}\\left[\\mathrm{RSS}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^{A}(\\cdot)\\right] = 1</span> . Let  <span class="math">S</span>  be any simulator. Wlog assume that it makes no  <span class="math">F</span> -query preceding its first Op-query (the response to such a query would be  <span class="math">\\perp</span> ). Furthermore, parsing the output of  <span class="math">S</span>  as  <span class="math">(pk,\\mathbf{c},h,f,sk_h,sk_a,hk)\\gets w</span> , we assume it holds that  $h = H(hk,pk\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{c})<span class="math"> ,  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{sk}_h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{sk}_a</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\ell<span class="math"> ,  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n<span class="math"> ,  </span>\\alpha = (\\lambda ,\\ldots ,\\lambda)<span class="math"> ,  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{a}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2<span class="math"> ,  </span>\\mathbf{a}[1] = h<span class="math"> , and  </span>\\mathbf{a}[2] = a_{\\lambda}<span class="math"> , since otherwise the relation  </span>R<span class="math">  returns false. Towards applying Lemma 4.2, we write execution of  </span>S<span class="math">  in Game ISS1 as a composition of two algorithms  </span>S_{1},S_{2}$  as in Figure 5.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Namely,  <span class="math">S_{1}</span>  runs  <span class="math">S</span>  up to the point that it makes its first OP query, and  <span class="math">S_{2}</span>  runs  <span class="math">S</span>  following this OP query. It also samples  <span class="math">\\mathbf{x}</span>  all at once instead of defining its individual components when responding to</p>

    <p class="text-gray-300">each message query, but this is equivalent and makes the analysis more transparent. Below we justify the following sequence of inequalities, for <span class="math">C,Y</span> defined below:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\operatorname{Pr}\\left[\\operatorname{ISS1}_{\\mathcal{F},Z,D,R}^{S}(\\cdot)\\right] = \\mathbf{A}\\mathbf{P}_{1}(S_{1},S_{2},\\lambda) \\leq \\sqrt{\\mathbf{A}\\mathbf{P}_{2}(S_{1},S_{2},\\lambda)} \\leq \\sqrt{\\mathbf{A}\\mathbf{d}\\mathbf{v}_{\\mathcal{H},C}^{\\operatorname{col}}(\\lambda) + \\operatorname{Pr}\\left[\\mathcal{F}(\\lambda,a_{\\lambda},\\mathbf{x}) \\in Y\\right]} \\\\ \\leq \\sqrt{\\mathbf{A}\\mathbf{d}\\mathbf{v}_{\\mathcal{H},C}^{\\operatorname{col}}(\\lambda) + 2^{\\ell}(1 - 1/p)^{n}} &amp;lt; \\sqrt{\\mathbf{A}\\mathbf{d}\\mathbf{v}_{\\mathcal{H},C}^{\\operatorname{col}}(\\lambda) + 2^{\\ell}2^{-(\\ell + \\log\\mu(\\lambda))}} \\\\ = \\sqrt{\\mathbf{A}\\mathbf{d}\\mathbf{v}_{\\mathcal{H},C}^{\\operatorname{col}}(\\lambda) + 1/\\mu(\\lambda)}. \\end{array}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Above, the first inequality is by construction and the second is by Lemma 4.2. For the third, consider the CR-adversary <span class="math">C</span> against <span class="math">\\mathcal{H}</span> also defined in Figure 5. Note that <span class="math">C</span> simply mimics the double execution experiment with <span class="math">S_{1}, S_{2}</span>. Let us also denote the two outputs of <span class="math">S_{2}</span> in that experiment as <span class="math">w^{1} = (pk^{1}, \\mathbf{c}^{1}, h^{1}, f^{1}, sk_{h}^{1}, sk_{a}^{1})</span> and <span class="math">w^{2} = (pk^{2}, \\mathbf{c}^{2}, h^{2}, f^{2}, sk_{h}^{2}, sk_{a}^{2})</span>. Now, unless <span class="math">C</span> finds a collision we have <span class="math">\\mathbf{c}^{1} = \\mathbf{c}^{2}</span>, denote by <span class="math">\\mathbf{c}^{<em>}</span> this common value. Then define the set <span class="math">Y := \\{y \\in \\{0,1\\}^{</em>} : \\exists s \\in \\{0,1\\}^{\\ell} \\text{ s.t. } \\mathsf{Dec}(s, \\mathbf{c}^{*}) = y\\}</span>. If it is not the case that <span class="math">\\mathcal{F}(\\lambda, a_{\\lambda}, \\mathbf{x}) \\in Y</span> when <span class="math">\\mathbf{x}</span> is sampled by <span class="math">S_{2}</span> then the relation <span class="math">R</span> must reject, as no <span class="math">sk_{a}^{2}</span> will satisfy <span class="math">\\mathsf{Dec}(sk_{a}^{2}, \\mathbf{c}) = \\mathcal{F}(\\lambda, a_{\\lambda}, \\mathbf{x})</span> (recall we assume $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">sk_{a}^{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\ell<span class="math"> here as otherwise </span>R<span class="math"> rejects), justifying the third inequality above. The fourth equality above uses the unpredictability of </span>\\mathcal{F}<span class="math"> and a union bound. For the fifth we substitute </span>n(\\lambda) = p(\\lambda)(\\ell(\\lambda) + \\log(\\mu(\\lambda)))<span class="math"> and use the inequality </span>(1 - 1/x)^{x} \\leq 1/e &lt; 1/2<span class="math"> for any real number </span>x \\geq 1<span class="math"> (here </span>e$ is Euler's constant).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Motivated by the impossibility results of Section 4, take up the direction of providing variants of the SS definition that are achievable.</p>

    <p class="text-gray-300">We start by providing our SS2 definition that we show is equivalent to IND, thus demonstrating that the IND definition targeted in the literature is indeed equivalent to some form of semantic security.</p>

    <p class="text-gray-300">SS2 DEFINITION. Let <span class="math">\\mathsf{FE} = (\\mathsf{Setup},\\mathsf{KDer},\\mathsf{Enc},\\mathsf{Dec})</span> be an <span class="math">\\mathcal{F}</span>-FE scheme. The definition uses games <span class="math">\\mathrm{RSS2}_{\\mathsf{FE},\\mathcal{F},Z,D,R}</span> and <span class="math">\\mathrm{ISS2}_{\\mathcal{F},Z,D,R}</span> of Figure 2, with the boxed code indicating the differences from the corresponding games in Figure 1, i.e., removing the boxed code recovers the SS1 games. Let <span class="math">D</span> be a message sampler and <span class="math">A</span> an adversary. We say that <span class="math">(D,A)</span> is SS2-valid with failure probability <span class="math">\\nu(\\cdot)</span> if <span class="math">\\operatorname{Pr}\\left[\\mathrm{RSS2}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^{A}(\\cdot) \\text{ sets } \\mathsf{bad}\\right] \\leq \\nu(\\cdot)</span>. When <span class="math">\\nu(\\cdot)</span> is negligible we say <span class="math">(D,A)</span> is SS2-valid. (Note that this probability does not depend on the relation <span class="math">R</span>, so it can be anything.) We say that <span class="math">\\mathsf{FE}</span> is SS2-secure if for every PT auxiliary input generator <span class="math">Z</span>, every message sampler <span class="math">D</span> and PT adversary <span class="math">A</span> such that <span class="math">(D,A)</span> is SS2-valid, and every PT relation <span class="math">R</span>, there is a PT simulator <span class="math">S</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{A}\\mathbf{d}\\mathbf{v}_{\\mathsf{FE},\\mathcal{F},A,S,Z,D,R}^{\\mathrm{ss2}}(\\cdot) = T(\\mathrm{RSS2}_{\\mathsf{FE},\\mathcal{F},Z,D,R}, A, \\cdot) - T(\\mathrm{ISS2}_{\\mathcal{F},Z,D,R}, S, \\cdot)</span></div>

    <p class="text-gray-300">is negligible. Intuitively, the definition mandates that an adversary only make key-derivation queries for functions under which any possible challenge message takes the same value. For example, for IBE this corresponds to mandating that any key-derivation query made by the adversary never makes a key-derivation query for a key that decrypts a challenge ciphertext (or decrypts it to a predictable value), which is a natural restriction. The following theorem follows from the claims below.</p>

    <p class="text-gray-300">Theorem 5.1 Let <span class="math">\\mathcal{F}</span> be a functionality and let <span class="math">\\mathsf{FE} = (\\mathsf{Setup},\\mathsf{KDer},\\mathsf{Enc},\\mathsf{Dec})</span> be an <span class="math">\\mathcal{F}</span>-FE scheme. Then <span class="math">\\mathsf{FE}</span> is SS2-secure if and only if it is IND-secure.</p>

    <p class="text-gray-300">Claim 5.2 (SS2 <span class="math">\\Rightarrow</span> IND) Let <span class="math">B</span> be an IND-adversary. Then there is a message sampler <span class="math">D</span>, relation <span class="math">R</span>, and adversary <span class="math">A</span> such that for every simulator <span class="math">S</span></p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{A}\\mathbf{d}\\mathbf{v}_{\\mathsf{FE},\\mathcal{F},B}^{\\mathrm{ind}}(\\cdot) \\leq 2 \\cdot \\mathbf{A}\\mathbf{d}\\mathbf{v}_{\\mathsf{FE},\\mathcal{F},A,S,Z,D,R}^{\\mathrm{ss2}}(\\cdot). \\tag{1}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Alg D(St,α): If St = ε then St←* {0,1} x0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x1← α Return (St, xSt)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Alg A(pk): Run B(pk): On left-or-right query (x0, x1): c←* ENC(x0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x1) Return c On query key-derivation query a: dk←* KD(a) Return dk Let b' be the output of A Return b'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Alg R(1^k, x, a, α, St, w): x0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x1← α a</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1] ← ε For j = 1, ...,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1 do If F(1^k, a[j], x0) ≠ F(1^k, a[j], x1) then return false Return (x = xw)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 6: Algorithms for proof of Claim 5.2.</p>

    <p class="text-gray-300">Furthermore,  <span class="math">(D,A)</span>  is SS2-valid and the running-time of  <span class="math">D,R,A</span>  is that of  <span class="math">B</span> .</p>

    <p class="text-gray-300">Proof: Define the message sampler  <span class="math">D</span> , adversary  <span class="math">A</span> , and relation  <span class="math">R</span>  as in Figure 6. Then by construction  <span class="math">T(\\mathrm{RSS2}_{\\mathsf{FE},\\mathcal{F},Z,D,R},A,\\cdot) = T(\\mathrm{IND}_{\\mathsf{FE},\\mathcal{F}},B,\\cdot)</span> . Moreover, we claim that for every simulator  <span class="math">S</span>  we have  <span class="math">T(\\mathrm{ISS2}_{\\mathcal{F},Z,D,R,S},\\cdot) \\leq 1/2</span> . This is because we can assume wlog that  <span class="math">S</span> 's queries are such that  <span class="math">\\mathcal{F}(1^k,a,\\mathbf{x}_0) = \\mathcal{F}(1^k,a,\\mathbf{x}_1)</span>  for all  <span class="math">\\mathsf{El}(a) \\in \\mathbf{a} \\cup \\varepsilon</span>  (since otherwise  <span class="math">R</span>  returns false), so  <span class="math">S</span>  gets no information about the bit  <span class="math">b</span> . Subtracting, we get</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf {A d v} _ {\\mathsf {F E}, \\mathcal {F}, A, S, Z, D, R} ^ {\\mathrm {s e 2}} (\\cdot) = T (\\mathrm {R S S 2} _ {\\mathsf {F E}, \\mathcal {F}, Z, D, R}, A, \\cdot) - T (\\mathrm {I S S 2} _ {\\mathcal {F}, Z, D, R}, S, \\cdot) \\geq T (\\mathrm {I N D} _ {\\mathsf {F E}, \\mathcal {F}}, B, \\cdot) - 1 / 2 \\\\ = 1 / 2 \\cdot \\mathbf {A d v} _ {\\mathsf {F E}, \\mathcal {F}, B} ^ {\\mathrm {i n d}} (\\cdot) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">which implies Equation (1). To complete the proof we note that  <span class="math">(D,A)</span>  is SS2-valid because we may assume wlog that  <span class="math">B</span> 's queries are such that  <span class="math">\\mathcal{F}(1^k,a,\\mathbf{x}_0) = \\mathcal{F}(1^k,a,\\mathbf{x}_1)</span>  for all  <span class="math">a\\in \\mathsf{El}(\\mathbf{a})\\cup \\varepsilon</span>  (otherwise its advantage can only go down).</p>

    <p class="text-gray-300">Claim 5.3 (IND  <span class="math">\\Rightarrow</span>  SS2) Let  <span class="math">D</span>  be a message sampler,  <span class="math">A</span>  be an SS2-adversary, and  <span class="math">R</span>  be a relation such that  <span class="math">(D,A)</span>  is SS2-valid with failure probability  <span class="math">\\nu (\\cdot)</span> . Then there is a simulator  <span class="math">S</span>  and an IND-adversary  <span class="math">B</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {\\mathsf {F E}, \\mathcal {F}, A, S, Z, D, R} ^ {\\mathrm {s e 2}} (\\cdot) \\leq \\mathbf {A d v} _ {\\mathsf {F E}, \\mathcal {F}, B} ^ {\\mathrm {i n d}} (\\cdot) + 2 \\nu (\\cdot).</span></div>

    <p class="text-gray-300">The running-time of  <span class="math">S</span>  is that of  <span class="math">D, R, A</span>  and the running-time of  <span class="math">B</span>  is at most twice that of  <span class="math">R, A</span>  plus twice that of  <span class="math">D</span> .</p>

    <p class="text-gray-300">Proof: Define  <span class="math">S</span>  and  <span class="math">B</span>  as in Figure 7. Without affecting the output of the game, we may have the FINALIZE procedure of Game  <span class="math">\\mathrm{IND}_{\\mathsf{FE},\\mathcal{F},0}^{B}(\\cdot)</span>  set a flag bad when the "return false" statement is executed. Then, viewing Games  <span class="math">\\mathrm{IND}_{\\mathsf{FE},\\mathcal{F},0}^{B}(\\cdot)</span>  and  <span class="math">\\mathrm{RSS2}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^{A}(\\cdot)</span>  as executed over a common finite space of coins, we have that in the language of [8] they are identical-until-bad. Therefore, by the Fundamental Lemma of [8]</p>

    <div class="my-4 text-center"><span class="math-block">T (\\mathrm {R S S 2} _ {\\mathsf {F E}, \\mathcal {F}, Z, D, R}, A, \\cdot) \\leq T (\\mathrm {I N D} _ {\\mathsf {F E}, \\mathcal {F}, 1}, B, \\cdot) + \\Pr \\left[ \\mathrm {R S S 2} _ {\\mathsf {F E}, \\mathcal {F}, Z, D, R} ^ {A} (\\cdot) \\text {s e t s} \\mathsf {b a d} \\right].</span></div>

    <p class="text-gray-300">By an analogous argument</p>

    <div class="my-4 text-center"><span class="math-block">T (\\mathrm {I S S 2} _ {\\mathcal {F}, Z, D, R}, S, \\cdot) \\geq T (\\mathrm {I N D} _ {\\mathsf {F E}, \\mathcal {F}, 0}, B, \\cdot) - \\Pr \\left[ \\mathrm {I S S 2} _ {\\mathsf {F E}, \\mathcal {F}, Z, D, R} ^ {S} (\\cdot) \\text {s e t s} \\mathsf {b a d} \\right].</span></div>

    <p class="text-gray-300">Subtracting yields Equation (5.3).</p>

    <p class="text-gray-300">It is worth pointing out in the proof of the second claim above that the constructed simulator  <span class="math">S</span>  needs not ever query its oracles. This is because we are guaranteed that, since  <span class="math">(D, A)</span>  is SS2-valid, the "dummy" messages sampled independently from the challenge ones have the same value under any function queried by  <span class="math">A</span>  to its key-derivation oracle.</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Figure 7: Algorithms for proof of Claim 5.3.</p>

    <p class="text-gray-300">The SS2 definition is not as strong as one would like because for some functionalities IND (which we showed equivalent to SS2) is a "bad" definition. To address this we now introduce the SS3 definition, which strengthens SS2 by dropping the restriction put by SS2 on key-derivation queries made by an adversary before seeing a challenge ciphertext. Indeed, we believe the SS3 definition is an essentially as-strong-as-possible security definition for FE subject to the constraint that it be achievable without any unnatural restrictions on the adversary or message space. To see why, note the definition of "unpredictable functionalities" used for our impossibility result in Section 4 and the fact that the latter crucially uses the adversary's ability to make "adaptive" key-derivation queries—i.e., depending on a challenge ciphertext. In some sense, the SS3 definition demands that the functionality restricted to the adversary's adaptive key derivation queries be predictable wrt. the message space.</p>

    <p class="text-gray-300">SS3 DEFINITION. Let  <span class="math">\\mathsf{FE} = (\\mathsf{Setup},\\mathsf{KDer},\\mathsf{Enc},\\mathsf{Dec})</span>  be an  <span class="math">\\mathcal{F}</span> -FE scheme. The definition uses games  <span class="math">\\mathrm{RSS3}_{\\mathsf{FE},\\mathcal{F},Z,D,R}</span>  and  <span class="math">\\mathrm{ISS3}_{\\mathcal{F},Z,D,R}</span>  of Figure 3, with the boxed code indicating the differences from the corresponding games in Figure 2, i.e., the games differ from SS2 only in the Finalize procedure. Let  <span class="math">D</span>  be a message sampler and  <span class="math">A</span>  an adversary. We say that  <span class="math">(D,A)</span>  is SS3-valid with failure probability  <span class="math">\\nu(\\cdot)</span>  if  <span class="math">\\operatorname*{Pr}\\left[\\mathrm{RSS3}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^{A}(\\cdot)\\right.</span>  sets bad  <span class="math">\\left.\\right] \\leq \\nu(\\cdot)</span> . When  <span class="math">\\nu(\\cdot)</span>  is negligible we say  <span class="math">(D,A)</span>  is SS3-valid. (Note that this probability does not depend on the relation  <span class="math">R</span> , so it can be arbitrary.) We say that FE is SS3-secure if for every PT auxiliary input generator  <span class="math">Z</span> , every message sampler  <span class="math">D</span>  and PT adversary  <span class="math">A</span>  such that  <span class="math">(D,A)</span>  is valid, and every PT relation  <span class="math">R</span> , there is a PT simulator  <span class="math">S</span>  such that</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}_{\\mathsf{FE},\\mathcal{F},A,S,Z,D,R}^{\\mathrm{ss3}}(\\cdot) = T(\\mathrm{RSS3}_{\\mathsf{FE},\\mathcal{F},Z,D,R},A,\\cdot) - T(\\mathrm{ISS3}_{\\mathcal{F},Z,D,R},S,\\cdot)</span></p>

    <p class="text-gray-300">is negligible.</p>

    <p class="text-gray-300">RESAMPLEABILITY. Let  <span class="math">\\mathcal{F}</span>  be a functionality,  <span class="math">\\overline{D}, D</span>  be algorithms. For an adversary  <span class="math">B</span>  we let</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}_{\\overline{D},D,\\mathcal{F},B}^{\\mathrm{rs}}(\\cdot) = T(\\mathrm{Rsmp}_{\\overline{D},D,\\mathcal{F},1},B,\\cdot) - T(\\mathrm{Rsmp}_{\\overline{D},D,\\mathcal{F},0},B,\\cdot)</span></p>

    <p class="text-gray-300">where the game is in Figure 10. Furthermore, let  <span class="math">\\mathbf{Adv}_{\\overline{D},D,\\mathcal{F}}^{\\mathrm{rs}}(\\cdot) = \\max_B\\{\\mathbf{Adv}_{\\overline{D},D,\\mathcal{F},B}^{\\mathrm{rs}}(\\cdot)\\}</span>  where the maximum is over all PT  <span class="math">B</span>  making one challenge query.</p>

    <p class="text-gray-300">We say that an algorithm  <span class="math">\\overline{D}</span>  is a  <span class="math">\\mu(\\cdot)</span> -accurate resampler for  <span class="math">\\mathcal{F}</span>  relative to algorithm  <span class="math">D</span>  if  <span class="math">\\mathbf{Adv}_{\\overline{D},D,\\mathcal{F}}^{\\mathrm{rs}}(\\cdot) \\leq \\mu(\\cdot)</span> . We say that  <span class="math">\\mathcal{F}</span>  is  <span class="math">\\mu(\\cdot)</span> -accurately reampleable if for all PPT  <span class="math">D</span>  there exists a PPT  <span class="math">\\overline{D}</span>  such that  <span class="math">\\overline{D}</span>  is a  <span class="math">\\mu(\\cdot)</span> -accurate resampler for  <span class="math">\\mathcal{F}</span>  relative to  <span class="math">D</span> . When  <span class="math">\\mu(\\cdot)</span>  is negligible we say that  <span class="math">\\mathcal{F}</span>  is accurately resampleable.</p>

    <p class="text-gray-300">THE EQUIVALENCE. The following says that the SS3 notion is equivalent to IND for any accurately</p>

    <p class="text-gray-300">resampleable functionality <span class="math">\\mathcal{F}</span>.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Theorem 5.4</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{F}</span> be an accurately resampleable functionality and let <span class="math">\\mathsf{FE}=(\\mathsf{Setup},\\mathsf{KDer},\\mathsf{Enc},\\mathsf{Dec})</span> be an <span class="math">\\mathcal{F}</span>-FE scheme. Then <span class="math">\\mathsf{FE}</span> is SS3-secure if and only if it is IND-secure.</p>

    <p class="text-gray-300">Since SS3 is clearly stronger than SS2, it is immediate from Claim 5.2 that SS3 implies IND. Below we show the converse, which proves the theorem.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Claim 5.5</h6>

    <p class="text-gray-300">(IND <span class="math">\\Rightarrow</span> SS3) Let <span class="math">D</span> be a message sampler, <span class="math">A</span> be an SS2-adversary making at most <span class="math">q_{e}</span> encryption queries, and <span class="math">R</span> be a relation such that <span class="math">(D,A)</span> is SS3-valid with failure probability <span class="math">\\nu(\\cdot)</span>. Suppose <span class="math">\\mathcal{F}</span> is <span class="math">\\mu(\\cdot)</span>-accurately resampleable, and let <span class="math">\\overline{D}</span> denote the corresponding <span class="math">\\mu(\\cdot)</span>-accurate resampler. Then there is a simulator <span class="math">S</span> and an IND-adversary <span class="math">B</span> such that</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}^{\\mathrm{ss3}}_{\\mathsf{FE},\\mathcal{F},A,S,Z,D,R}(\\cdot)\\ \\leq\\ \\mathbf{Adv}^{\\mathrm{ind}}_{\\mathsf{FE},\\mathcal{F},B}(\\cdot)+2\\nu(\\cdot)+2q_{e}\\mu(\\cdot)\\;.</span></p>

    <p class="text-gray-300">The running-time of <span class="math">S</span> is that of <span class="math">D,R,A</span> and the running-time of <span class="math">B</span> is at most twice that of <span class="math">R,A</span> plus the time for <span class="math">q_{e}</span> executions of <span class="math">\\overline{D}</span>.</p>

    <p class="text-gray-300">Proof:</p>

    <p class="text-gray-300">Define <span class="math">S</span> and <span class="math">B</span> as in Figure 9. Furthermore, define hybrid games RSS3-H1<span class="math">{}_{\\mathsf{FE},\\mathcal{F},Z,D,R}</span> and RSS3-H2<span class="math">{}_{\\mathsf{FE},\\mathcal{F},Z,D,R}</span> as in Figure 8. Below we justify the following sequence of inequalities:</p>

    <p class="text-gray-300"><span class="math">T(\\mathrm{RSS3}_{\\mathsf{FE},\\mathcal{F},Z,D,R},A,\\cdot)</span> <span class="math">\\leq</span> <span class="math">T(\\mathrm{RSS3}\\text{-}\\mathrm{H1}_{\\mathsf{FE},\\mathcal{F},Z,D,R},A,\\cdot)+\\Pr\\big{[}\\,\\mathrm{RSS3}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^{A}(\\cdot)\\ \\mathrm{sets\\ bad}_{1}\\,\\big{]}</span> <span class="math">\\leq</span> <span class="math">T(\\mathrm{RSS3}\\text{-}\\mathrm{H2}_{\\mathsf{FE},\\mathcal{F},Z,D,R},A,\\cdot)+\\Pr\\big{[}\\,\\mathrm{RSS3}\\text{-}\\mathrm{H1}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^{A}(\\cdot)\\ \\mathrm{sets\\ bad}_{2}\\,\\big{]}</span> <span class="math">\\qquad\\qquad+\\Pr\\big{[}\\,\\mathrm{RSS3}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^{A}(\\cdot)\\ \\mathrm{sets\\ bad}_{1}\\,\\big{]}</span> <span class="math">=</span> <span class="math">T(\\mathrm{IND}_{\\mathsf{FE},\\mathcal{F},1},B,\\cdot)+\\Pr\\big{[}\\,\\mathrm{RSS3}\\text{-}\\mathrm{H1}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^{A}(\\cdot)\\ \\mathrm{sets\\ bad}\\,\\big{]}</span> <span class="math">\\qquad\\qquad+\\Pr\\big{[}\\,\\mathrm{RSS3}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^{A}(\\cdot)\\ \\mathrm{sets\\ bad}_{1}\\,\\big{]}</span> <span class="math">\\leq</span> <span class="math">T(\\mathrm{IND}_{\\mathsf{FE},\\mathcal{F},1},B,\\cdot)+\\Pr\\big{[}\\,\\mathrm{RSS3}\\text{-}\\mathrm{H1}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^{A}(\\cdot)\\ \\mathrm{sets\\ bad}_{2}\\,\\big{]}+\\nu(\\cdot)</span> <span class="math">\\leq</span> <span class="math">T(\\mathrm{IND}_{\\mathsf{FE},\\mathcal{F},1},B,\\cdot)+q_{e}(\\cdot)\\mu(\\cdot)+\\nu(\\cdot)\\;.</span></p>

    <p class="text-gray-300">Above, the first two inequalities are by the Fundamental Lemma of <em>[8]</em> (by a slight abuse of notation we identify <span class="math">\\mathsf{bad}</span> in RSS3<span class="math">{}_{\\mathsf{FE},\\mathcal{F},Z,D,R}</span> with <span class="math">\\mathsf{bad}_{1}</span> in RSS3-H1<span class="math">{}_{\\mathsf{FE},\\mathcal{F},Z,D,R}</span>, and third equality is by construction. The fourth uses the assumption that <span class="math">(D,A)</span> is SS3-valid with failure probability <span class="math">\\nu(\\cdot)</span>.</p>

    <p class="text-gray-300">Finally, the last inequality follows by considering a run of Games <span class="math">\\mathrm{Rsmp}_{\\overline{D},D,\\mathcal{F},b}^{B^{<em>}}(\\lambda)</span> for <span class="math">b\\in\\{0,1\\}</span> and <span class="math">B^{</em>}</span> given in Figure 9, and of Game RSS3-H1<span class="math">{}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^{A}(\\lambda)</span> over some fixed coin sequence drawn from a common finite set of coins, but not including the coins used to draw <span class="math">i^{<em>}</span> in RSS3-H1<span class="math">{}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^{A}(\\lambda)</span>. Suppose <span class="math">\\mathsf{bad}</span> is set by the latter for the </em>first<em> time (i.e., changed from false to true) on the <span class="math">q</span>-th query to Enc made by <span class="math">A</span> when executed by RSS3-H1<span class="math">{}_{\\mathsf{FE},\\mathcal{F},Z,D,R}</span> using these coins. Then with probability <span class="math">1/q_{e}</span> in the execution of <span class="math">\\mathrm{Rsmp}_{\\overline{D},D,\\mathcal{F},b}^{B^{</em>}}(\\lambda)</span> it will be the case that <span class="math">i^{<em>}=q</span>. In this case <span class="math">\\mathrm{Rsmp}_{\\overline{D},D,\\mathcal{F},b}^{B^{</em>}}(\\cdot)</span> outputs <span class="math">1</span> just when <span class="math">b=1</span>. Using the assumption that <span class="math">\\mathcal{F}</span> is <span class="math">\\mu(\\cdot)</span>-accurately resampleable and re-arranging yields the last inequality above.</p>

    <p class="text-gray-300">A symmetric sequence of inequalities to the above yields</p>

    <p class="text-gray-300"><span class="math">T(\\mathrm{ISS2}_{\\mathcal{F},Z,D,R},S,\\cdot)</span> <span class="math">\\geq</span> <span class="math">T(\\mathrm{IND}_{\\mathsf{FE},\\mathcal{F},0},B,\\cdot)-\\nu(\\cdot)-q_{e}\\mu(\\cdot)\\;.</span></p>

    <p class="text-gray-300">Re-arranging and subtracting yields Equation (5.5).</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Figure 8: Hybrid games RSS3-H2FE,  <span class="math">\\mathcal{F}, Z, D, R</span>  and RSS3-H2FE,  <span class="math">\\mathcal{F}, Z, D, R</span>  for the proof of Claim 5.5. The latter includes the boxed code while in the former it is removed.</p>

    <p class="text-gray-300">We show resampleability of the following type of functionality.</p>

    <p class="text-gray-300">FUNCTIONALITIES WITH POLYNOMIAL-SIZE RANGE. Let  <span class="math">\\mathcal{F}</span>  be a functionality. We say that  <span class="math">\\mathcal{F}</span>  has polynomial-size range if there is a polynomial  <span class="math">w(\\cdot)</span>  such that  <span class="math">\\mathcal{F}(\\lambda, \\mathbf{a}, x) \\in F_{\\lambda}</span>  for all  <span class="math">\\lambda \\in \\mathbb{N}</span> ,  <span class="math">x \\in \\{0,1\\}^<em></span>  and  <span class="math">\\mathbf{a} \\in (\\{0,1\\}^</em>)^*</span>  where  <span class="math">F_{\\lambda} = \\{\\mathbf{f}_1, \\mathbf{f}_2, \\ldots, \\mathbf{f}_{w(\\cdot)}\\}</span> .</p>

    <p class="text-gray-300">EXAMPLES AND DISCUSSION. An example of a functionality with polynomial-size range is PEKS [12] with a polynomial number of keywords. Although as shown by [12] this can be constructed from any IND-CPA public-key encryption scheme, the construction is inefficient for large polynomials, and more efficient constructions may be of interest to practitioners. These would be SS3 secure by our results.</p>

    <p class="text-gray-300">We compare our notion of resampleability to that of preimage sampleability defined by O'Neill [29]. Our notion of resampleability appears to be much more restrictive, in the sense that showing it requires sampling a preimage that lies in the message space of the adversary rather than an arbitrary preimage. Since in general we cannot hope to "reverse engineer" the adversary's message space, it is unclear what we can do with it besides sample it in a black-box way. Indeed, the proof of our result does this and does not exploit any properties of the functionality itself as in [29], who showed that most functionalities considered in the literature have preimage sampleability. On the other hand, we show how to achieve a much stronger security definition than [29] who considered only non-adaptive security, meaning the adversary makes no key-derivation queries after seeing the challenge ciphertext.</p>

    <p class="text-gray-300">Proposition 5.6 Let  <span class="math">\\mathcal{F}</span>  be a functionality with polynomial-size range. Then  <span class="math">\\mathcal{F}</span>  is accurately resampleable. More precisely, for any PPT  <span class="math">D</span>  there is a PPT  <span class="math">\\overline{D}</span>  such that for every  <span class="math">\\lambda \\in \\mathbb{N}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {\\overline {{D}}, D, \\mathcal {F}} ^ {\\mathrm {r s}} (\\lambda) \\leq \\frac {1}{2 ^ {\\lambda}}.</span></div>

    <p class="text-gray-300">Furthermore, the running-time of  <span class="math">\\overline{D}</span>  is that for at most  <span class="math">\\lambda w(\\lambda)</span>  executions of  <span class="math">D</span> .</p>

    <p class="text-gray-300">The proof will use the following mathematical lemma.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Alg S(1k):</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Alg B(pk):</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Alg B*(λ):</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">i, j←0</td>

            <td class="px-3 py-2 border-b border-gray-700">i, j←0</td>

            <td class="px-3 py-2 border-b border-gray-700">i, j←0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">St←ε</td>

            <td class="px-3 py-2 border-b border-gray-700">St0, St1←ε</td>

            <td class="px-3 py-2 border-b border-gray-700">St←ε</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(pk, sk)←*Setup(1k)</td>

            <td class="px-3 py-2 border-b border-gray-700">Run A(pk):</td>

            <td class="px-3 py-2 border-b border-gray-700">(pk, sk)←*Setup(λ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Run A(pk):</td>

            <td class="px-3 py-2 border-b border-gray-700">On encryption query α:</td>

            <td class="px-3 py-2 border-b border-gray-700">Run A(pk):</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">On encryption query α:</td>

            <td class="px-3 py-2 border-b border-gray-700">i←i+1; α[i]←α</td>

            <td class="px-3 py-2 border-b border-gray-700">On encryption query α:</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">i←i+1; α[i]←α</td>

            <td class="px-3 py-2 border-b border-gray-700">(St0, x0[i])←*D(St0,α)</td>

            <td class="px-3 py-2 border-b border-gray-700">i←i+1; α[i]←α</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">For j' = 1 to j do:</td>

            <td class="px-3 py-2 border-b border-gray-700">For j' = 1 to j do:</td>

            <td class="px-3 py-2 border-b border-gray-700">For j' = 1 to j do:</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">f[j'] ← F(a[j'], i)</td>

            <td class="px-3 py-2 border-b border-gray-700">f[j'] ← F(λ, a[j'], x0[i])</td>

            <td class="px-3 py-2 border-b border-gray-700">f[j'] ← F(a[j'], i)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(St, x)←*D(λ, St, α, a, f)</td>

            <td class="px-3 py-2 border-b border-gray-700">(St1, x1[i])←*D(λ, St1, α, a, f)</td>

            <td class="px-3 py-2 border-b border-gray-700">If i = i* then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">c←*Enc(pk, x)</td>

            <td class="px-3 py-2 border-b border-gray-700">Return LR(x0[i], x1[i])</td>

            <td class="px-3 py-2 border-b border-gray-700">(St, x)←*CHALLENGE(St, α, a)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Return c, y</td>

            <td class="px-3 py-2 border-b border-gray-700">On key-derivation query a:</td>

            <td class="px-3 py-2 border-b border-gray-700">Halt execution of A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">On key-derivation query a:</td>

            <td class="px-3 py-2 border-b border-gray-700">j←j+1; a[j]←a</td>

            <td class="px-3 py-2 border-b border-gray-700">(St, x)←*D(λ, St, α, a, f)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">j←j+1; a[j]←a</td>

            <td class="px-3 py-2 border-b border-gray-700">Return KD(a)</td>

            <td class="px-3 py-2 border-b border-gray-700">c←*Enc(pk, x)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">OP(a)</td>

            <td class="px-3 py-2 border-b border-gray-700">Let w be the output of A</td>

            <td class="px-3 py-2 border-b border-gray-700">Return c, y</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Return R(1k, x, a, α, St, w)</td>

            <td class="px-3 py-2 border-b border-gray-700">Return R(1k, x1, a, α, St, w)</td>

            <td class="px-3 py-2 border-b border-gray-700">On key-derivation query a:</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  | j←j+1; a[j]←a  |</p>

    <p class="text-gray-300">|   |  | Return KDer(sk, a)  |</p>

    <p class="text-gray-300">|   |  | Return Test(λ, x, a, f)  |</p>

    <p class="text-gray-300">Figure 9: Algorithms for proof of Claim 5.5.</p>

    <p class="text-gray-300">Lemma 5.7 Fix integers  <span class="math">n, k \\geq 1</span> . For  <span class="math">\\mathbf{x} \\in \\mathbb{R}^n</span>  define the function  <span class="math">f(\\mathbf{x}) = \\sum_{i=1}^{n} x_i (1 - x_i)^k</span> . Subject to constraints  <span class="math">\\sum_{i=1}^{n} x_i = 1</span>  and  <span class="math">0 \\leq x_i \\leq 1</span>  for all  <span class="math">1 \\leq i \\leq n</span> ,  <span class="math">f(\\cdot)</span>  is maximum at  <span class="math">x_1 = \\ldots = x_n = 1/n</span> .</p>

    <p class="text-gray-300">Proof: (Of Lemma 5.7) We use a change of variables: let  <span class="math">y_{i} = (1 - x_{i})</span>  for all  <span class="math">1 \\leq i \\leq n</span> . Then we equivalently seek to maximize</p>

    <div class="my-4 text-center"><span class="math-block">f ^ {\\prime} (\\mathbf {y}) = \\sum_ {i = 1} ^ {n} (1 - y _ {i}) y _ {i} ^ {k}</span></div>

    <p class="text-gray-300">subject to  <span class="math">\\sum_{i=1}^{n} y_i = n - 1</span>  and  <span class="math">0 \\leq y_i \\leq 1</span>  for all  <span class="math">1 \\leq i \\leq n</span> . Now use Lagrange multipliers: we seek a constant  <span class="math">\\lambda</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\nabla f ^ {\\prime} = \\lambda \\nabla g \\tag {2}</span></div>

    <p class="text-gray-300">where  <span class="math">g(\\mathbf{x}) = \\sum_{i=1}^{n} y_i</span> . Fix any  <span class="math">1 \\leq i \\leq n</span> . Since</p>

    <div class="my-4 text-center"><span class="math-block">\\frac {\\partial f ^ {\\prime}}{\\partial y _ {i}} = 1 - (k + 1) y _ {i} ^ {k} \\text { and } \\frac {\\partial g}{\\partial y _ {i}} = 1</span></div>

    <p class="text-gray-300">by Equation (2) we have</p>

    <div class="my-4 text-center"><span class="math-block">1 - (k + 1) y _ {i} ^ {k} = \\lambda \\Longrightarrow y _ {i} = \\left(\\frac {1 - \\lambda}{k + 1}\\right) ^ {1 / k}. \\tag {3}</span></div>

    <p class="text-gray-300">Using the constraint  <span class="math">\\sum_{i=1}^{n} y_i = n - 1</span>  we have</p>

    <div class="my-4 text-center"><span class="math-block">n \\left(\\frac {1 - \\lambda}{k + 1}\\right) ^ {1 / k} = n - 1 \\Longrightarrow \\lambda = 1 - (k + 1) \\left(1 - \\frac {1}{n}\\right) ^ {k}.</span></div>

    <p class="text-gray-300">Substituting this into Equation (3) we get  <span class="math">y_{i} = 1 - 1 / n</span>  and so  <span class="math">x_{i} = -(y_{i} - 1) = 1 / n</span>  as desired. Note that this must be a maximum (rather than minimum) since  <span class="math">f</span>  vanishes when  <span class="math">x_{i} = 1</span>  for some  <span class="math">i</span> .</p>

    <p class="text-gray-300">We now prove the proposition.</p>

    <p class="text-gray-300">Proof: (Of Proposition 5.6) Given any  <span class="math">D</span> , define the corresponding resampler  <span class="math">\\overline{D}</span>  as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Alg}\\ \\overline{D}(\\lambda,St,\\alpha,\\mathbf{a},\\mathbf{f})</span>:</p>

    <p class="text-gray-300">For <span class="math">i=1</span> to <span class="math">\\lambda w(\\lambda)</span> do:</p>

    <p class="text-gray-300"><span class="math">x^{\\prime}\\mathop{\\leftarrow s}D(St,\\alpha)</span></p>

    <p class="text-gray-300">If <span class="math">\\mathsf{Test}(\\lambda,x^{\\prime},\\mathbf{a},\\mathbf{f})=1</span> then return <span class="math">x^{\\prime}</span></p>

    <p class="text-gray-300">Return <span class="math">\\perp</span></p>

    <p class="text-gray-300">We need to show that for any <span class="math">B</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}^{\\mathrm{rs}}_{\\overline{D},D,\\mathcal{F},B}(\\cdot)\\ \\leq\\ \\frac{1}{2^{\\lambda}}\\;.</span></p>

    <p class="text-gray-300">To this end define game <span class="math">\\mathrm{Rsmp}_{\\overline{D},D,\\mathcal{F}}</span> to pick a bit <span class="math">b</span> at random and run the first experiment if <span class="math">b=1</span> and the second if <span class="math">b=0</span>; also, have it set <span class="math">\\mathsf{bad}</span> to true if <span class="math">\\overline{D}</span> ever returns <span class="math">\\perp</span>. Define <span class="math">\\mathrm{Rsmp-H}_{\\overline{D},D,\\mathcal{F}}</span> to be like the former but return <span class="math">\\mathsf{Resample}_{D}(\\lambda,St,\\alpha,\\mathbf{a},\\mathbf{f})</span> if <span class="math">\\mathsf{bad}</span> is set. Then using a standard conditioning argument and the Fundamental Lemma <em>[8]</em>:</p>

    <p class="text-gray-300"><span class="math">\\frac{1}{2}+\\frac{1}{2}\\mathbf{Adv}^{\\mathrm{rs}}_{\\overline{D},D,\\mathcal{F},B}(\\cdot)</span> <span class="math">=</span> <span class="math">T(\\mathrm{Rsmp}_{\\overline{D},D,\\mathcal{F}},B,\\cdot)</span> <span class="math">\\leq</span> <span class="math">T(\\mathrm{Rsmp-H}_{\\overline{D},D,\\mathcal{F}},B,\\cdot)+\\Pr\\left[\\mathrm{Rsmp}_{\\overline{D},D,\\mathcal{F}}^{B}(\\cdot)\\ \\mathrm{sets\\ bad}\\right]</span> <span class="math">=</span> <span class="math">\\frac{1}{2}+\\Pr\\left[\\mathrm{Rsmp}_{\\overline{D},D,\\mathcal{F}}^{B}(\\cdot)\\ \\mathrm{sets\\ bad}\\right].</span></p>

    <p class="text-gray-300">Finally, we claim</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathrm{Rsmp}_{\\overline{D},D,\\mathcal{F}}^{B}(\\cdot)\\ \\mathrm{sets\\ bad}\\right]\\ \\leq\\ \\frac{1}{2^{\\lambda}}\\;.</span></p>

    <p class="text-gray-300">To see this, fix any inputs <span class="math">\\lambda,St,\\alpha,\\mathbf{a},\\mathbf{f}</span> and for all <span class="math">1\\leq i\\leq w(\\lambda)</span> let</p>

    <p class="text-gray-300"><span class="math">p_{i}\\ =\\ \\Pr[\\mathcal{F}(\\lambda,\\mathbf{a},x)=\\mathbf{f}_{i}\\,:\\,x\\mathop{\\leftarrow s}D(St,\\alpha)]\\;.</span></p>

    <p class="text-gray-300">Then</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\ \\overline{D}(\\lambda,St,\\alpha,\\mathbf{a},\\mathbf{f})\\ \\mathrm{outputs}\\ \\perp\\right]</span> <span class="math">=</span> <span class="math">\\sum_{i}p_{i}\\cdot(1-p_{i})^{\\lambda w(\\lambda)}</span> <span class="math">\\leq</span> <span class="math">\\sum_{i}\\frac{1}{w(\\lambda)}\\cdot\\left(1-\\frac{1}{w(\\lambda)}\\right)^{\\lambda\\cdot w(\\lambda)}</span> <span class="math">\\leq</span> <span class="math">\\frac{1}{2^{\\lambda}}\\;.</span></p>

    <p class="text-gray-300">The second line above is justified by Lemma 5.7. The third line uses the inequality <span class="math">(1-1/x)^{x}\\leq 1/e&lt;1/2</span> for any real number <span class="math">x\\geq 1</span> (here <span class="math">e</span> is Euler’s constant).</p>

    <h2 id="sec-11" class="text-2xl font-bold">6 Brute-Force Construction Revisited</h2>

    <p class="text-gray-300">We now revisit the “brute-force” scheme defined by BSW <em>[14]</em>, which provides a way to construct FE for any functionality with a polynomially-sized index space.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{F}</span> be a functionality. We say that <span class="math">\\mathcal{F}</span> has <em>polynomially-sized index space</em> if <span class="math">\\mathcal{F}(\\lambda,a,x)=\\perp</span> if <span class="math">a\\notin\\mathcal{A}_{\\lambda}</span> where <span class="math">\\mathcal{A}_{\\lambda}=\\{\\varepsilon,a_{1},a_{2},\\ldots,a_{p(\\lambda)}\\}</span> for a polynomial <span class="math">p(\\cdot)</span>. Let <span class="math">(\\mathcal{G},\\mathcal{E},\\mathcal{D})</span> be a PKE scheme. Then we define a the <em>brute-force FE scheme</em> for <span class="math">\\mathcal{F}</span> as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PROC INITIALIZE(λ):</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Alg ResampleD(λ, St, α, a, f):</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Return λ</td>

            <td class="px-3 py-2 border-b border-gray-700">If CSD(λ, St, α, a, f) = ∅ then return ⊥</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PROC CHALLENGE(St, α, a):</td>

            <td class="px-3 py-2 border-b border-gray-700">w ↔ CSD(λ, St, α, a, f)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">x ↔ D(St, α)</td>

            <td class="px-3 py-2 border-b border-gray-700">x' ← D(St, α; w)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">f ← (F(λ, a, x), F(λ, ε, x))</td>

            <td class="px-3 py-2 border-b border-gray-700">Return x'</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">If b = 1 then x' ↔ D(λ, St, α, a, f)</td>

            <td class="px-3 py-2 border-b border-gray-700">Alg Test(λ, x, a, f):</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Else x' ↔ ResampleD(λ, St, α, a, f)</td>

            <td class="px-3 py-2 border-b border-gray-700">f' ← (F(λ, a, x), F(λ, ε, x))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Return x'</td>

            <td class="px-3 py-2 border-b border-gray-700">Return (f = f')</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PROC FINALIZE(b'):</td>

            <td class="px-3 py-2 border-b border-gray-700">Set CSD(λ, St, α, a, f) := {w : Test(λ, D(St, α; w), a, f) = true}</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Return (b' = 1) |   |</p>

    <p class="text-gray-300">Figure 10: Left: Game Resamp  <span class="math">\\overline{D}_{,D,\\mathcal{F},b}</span>  for the resampleability definition. Right: Associated algorithms and definitions used by the game's procedures.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">SETUP(λ)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ENC(pk,m)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">For i=1,...,p(λ) do (pk[i],sk[i])←G(λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">For i=1,...,p(λ) do c[i]←$E(pk[i],F(λ,ai,m))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Return (pk,sk)</td>

            <td class="px-3 py-2 border-b border-gray-700">Return c</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KDER(sk,a)</td>

            <td class="px-3 py-2 border-b border-gray-700">DEC((i,sk[i]),c))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">For i=1,...,p(λ) do If ai=a then return (i,sk[i])</td>

            <td class="px-3 py-2 border-b border-gray-700">If (sk[i] = ε) then return</td>

            <td class="px-3 py-2 border-b border-gray-700">m</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | Return D(sk[i],c[i])  |</p>

    <p class="text-gray-300">BSW [14] show that this construction is IND-secure (and hence, by our results in Section 5, SS2-secure) provided that the underlying PKE scheme is semantically secure. Moreover, they show a slightly decorated construction which is SS1-secure in the random oracle model. What we show is that it suffices for the underlying PKE scheme to be secure against key-revealing SOAs (SOA-K) for this FE scheme to be SS1-secure. In fact, for their result BSW implicitly use the non-committing (which implies SOA-K) PKE scheme of Nielsen [26] in the random oracle model as the underlying PKE scheme, so our result is a generalization of theirs. In particular, it allows us to obtain instantiations in the standard model by (necessarily) allowing long keys, meaning longer than the total number of bits encrypted; SOA-K secure PKE is known to exist in this setting [15, 16].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The intuition is that opening a particular  <span class="math">\\mathcal{F}(\\lambda, a_i, m)</span>  is equivalent to giving away  <span class="math">\\mathbf{sk}[i]</span> . Therefore, it should be the case that if some  <span class="math">\\mathcal{F}</span>  values for a particular set  $I = \\{a_{j_1}, a_{j_2}, \\ldots, a_{j_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}\\} \\subseteq \\mathcal{A}<span class="math">  of indices are revealed, it is equivalent to opening up  </span>\\mathbf{sk}[j_1], \\mathbf{sk}[j_2], \\ldots, \\mathbf{sk}[j_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]<span class="math">  and should therefore, by SOA security, not make it any easier to obtain decryptions under any other secret key, i.e. to evaluate  </span>\\mathcal{F}$  on any other index.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">SOA-K DEFINITION. To formalize our result we will need an explicit notion of SOA-K security, as described in BDWY [5]. Here we need to extend the BDWY definition to allow the adversary and simulator to ask for encryptions and secret keys adaptively (as in our SS notions for FE) rather than asking for an initial vector of ciphertexts and then afterwards a subset of the secret keys in one shot.</p>

    <p class="text-gray-300">Let  <span class="math">\\Pi</span>  be a PKE scheme. The definition uses games  <span class="math">\\mathrm{RSOAK}_{\\Pi,Z,D,R,n}</span>  and  <span class="math">\\mathrm{SSOAK}_{\\Pi,Z,D,R,n}</span>  of Figure 11. We say that  <span class="math">\\Pi</span>  is SOAK-secure if for every auxiliary input generator  <span class="math">Z</span> , every PT message sampler  <span class="math">D</span> , every PT relation  <span class="math">R</span> , every PT adversary  <span class="math">A</span> , and every polynomial  <span class="math">n(\\cdot)</span>  there is a PT simulator  <span class="math">S</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {\\Pi , A, S, Z, D, R, n} ^ {\\mathrm {s o a - k}} (\\cdot) = \\Pr \\left[ \\mathrm {R S O A K} _ {\\Pi , Z, D, R, n} ^ {A} (\\cdot) \\right] - \\Pr \\left[ \\mathrm {S S O A K} _ {\\Pi , Z, D, R, n} ^ {S} (\\cdot) \\right]</span></div>

    <p class="text-gray-300">is negligible.</p>

    <p class="text-gray-300">Theorem 6.1 Let  <span class="math">\\Pi = (\\mathcal{G},\\mathcal{E},\\mathcal{D})</span>  be a SOA-  <span class="math">K</span>  secure PKE scheme. Then the corresponding brute-force FE scheme for any functionality  <span class="math">\\mathcal{F}</span>  with a polynomially-sized index space is SS1-secure.</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> Figure 11: Left: "Real world" game  <span class="math">\\mathrm{RSOAK}_{\\Pi,Z,D,R,n}</span>  for the SOA-K definition. Right: "Ideal world" game  <span class="math">\\mathrm{SSOAK}_{\\Pi,Z,D,R,n}</span>  for the SOA-K definition.</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> Figure 12: Algorithms for proof of security of brute-force scheme.</p>

    <p class="text-gray-300">Proof of Theorem 6.1: Denote by  <span class="math">\\mathcal{A}_{\\lambda} = \\{\\varepsilon, a_1, a_2, \\ldots, a_{p(\\lambda)}\\}</span>  the family of sets satisfying the definition of polynomially-sized index space for  <span class="math">\\mathcal{F}</span> . Let  <span class="math">Z</span>  be an auxiliary input generator,  <span class="math">D</span>  be a message sampler,  <span class="math">R</span>  be a relation, and  <span class="math">A</span>  be a SS1 adversary. Consider the auxiliary input generator  <span class="math">Z&#x27; = Z</span> , and then the relation  <span class="math">R&#x27;</span> , message sampler  <span class="math">D&#x27;</span>  and SOA-K adversary  <span class="math">A&#x27;</span>  defined as in Figure 12.</p>

    <p class="text-gray-300">Above, for a ciphertext  <span class="math">c</span> ,  <span class="math">\\mathsf{msglen}(c)</span>  returns the length of the decryption of  <span class="math">c</span>  (which we assume is efficiently computable from a ciphertext, or else that  <span class="math">D</span>  always outputs messages of some known length). Also note that we set  <span class="math">n(\\cdot) = p(\\cdot) + 1</span>  in the SOAK games; this allows  <span class="math">A&#x27;</span>  to pass the length of the "actual" payload  <span class="math">x</span>  to  <span class="math">A</span>  and similarly  <span class="math">R&#x27;</span>  to pass the "actual" payload vector  <span class="math">\\mathbf{x}</span>  to  <span class="math">R</span> . Since  <span class="math">\\Pi</span>  is SOA-K secure, we know that there exists a PT simulator  <span class="math">S&#x27;</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {\\Pi , A ^ {\\prime}, S ^ {\\prime}, Z ^ {\\prime}, D ^ {\\prime}, R ^ {\\prime}} ^ {\\mathrm {S O A - k}} (\\cdot) = \\Pr \\left[ \\operatorname {R S O A K} _ {\\Pi , Z ^ {\\prime}, D ^ {\\prime}, R ^ {\\prime}} ^ {A ^ {\\prime}} (\\cdot) \\right] - \\Pr \\left[ \\operatorname {S S O A K} _ {\\Pi , Z ^ {\\prime}, D ^ {\\prime}, R ^ {\\prime}} ^ {S ^ {\\prime}} (\\cdot) \\right]</span></div>

    <p class="text-gray-300">is negligible. Now we use  <span class="math">S&#x27;</span>  to construct  <span class="math">S</span> , a simulator for the ISS game, in a similar way we adapted  <span class="math">A</span>  to get  <span class="math">A&#x27;</span> :</p>

    <p class="text-gray-300">Alg <span class="math">S(\\lambda)</span>: <span class="math">z\\leftarrow</span>s Initialize<span class="math">(\\lambda)</span> Run <span class="math">S^{\\prime}</span> on input <span class="math">\\lambda</span>: <span class="math">i^{\\prime}\\leftarrow 0</span> On initialize query <span class="math">\\lambda</span> return <span class="math">z</span> On message query <span class="math">\\alpha</span>: <span class="math">i^{\\prime}\\leftarrow i^{\\prime}+1\\&gt;;\\&gt;\\textsc{Msg}(\\alpha)</span> Return <span class="math">\\varepsilon</span> On corrupt query <span class="math">i</span>: <span class="math">\\textsc{Op}(a_{i})</span> For <span class="math">j=1,\\ldots,i^{\\prime}</span> <span class="math">\\mathbf{x}[j]\\leftarrow\\textsc{F}(a_{i},j)</span> Return <span class="math">\\mathbf{x}</span> Let <span class="math">w</span> be the output of <span class="math">S^{\\prime}</span> Return <span class="math">w</span></p>

    <p class="text-gray-300">By construction, we now have</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\&gt;\\textsc{RSOAK}^{A^{\\prime}}_{{\\rm II},Z^{\\prime},D^{\\prime},R^{\\prime},p+1}(\\cdot)\\&gt;\\right]</span> <span class="math">=\\Pr\\left[\\&gt;\\textsc{RSS}^{A}_{{\\sf FE},{\\cal F},Z,D,R}(\\cdot)\\&gt;\\right]</span> <span class="math">\\Pr\\left[\\&gt;\\textsc{SSOAK}^{S^{\\prime}}_{{\\rm II},Z^{\\prime},D^{\\prime},R^{\\prime},p+1}(\\cdot)\\&gt;\\right]</span> <span class="math">=\\Pr\\left[\\&gt;\\textsc{ISS}^{S}_{{\\sf FE},{\\cal F},Z,D,R}(\\cdot)\\&gt;\\right]</span></p>

    <p class="text-gray-300">Therefore,</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}^{\\rm ss1}_{{\\sf FE},{\\cal F},A,S,Z,D,R}(\\cdot)</span> <span class="math">=\\Pr\\left[\\&gt;\\textsc{RSS}^{A}_{{\\sf FE},{\\cal F},Z,D,R}(\\cdot)\\&gt;\\right]-\\Pr\\left[\\&gt;\\textsc{ISS}^{S}_{{\\sf FE},{\\cal F},Z,D,R}(\\cdot)\\&gt;\\right]</span> <span class="math">=\\Pr\\left[\\&gt;\\textsc{RSOAK}^{A^{\\prime}}_{{\\rm II},Z^{\\prime},D^{\\prime},R^{\\prime}}(\\cdot)\\&gt;\\right]-\\Pr\\left[\\&gt;\\textsc{SSOAK}^{S^{\\prime}}_{{\\rm II},Z^{\\prime},D^{\\prime},R^{\\prime},p+1}(\\cdot)\\&gt;\\right]</span> <span class="math">=\\mathbf{Adv}^{\\rm soa-k}_{{\\rm II},A^{\\prime},S^{\\prime},Z^{\\prime},D^{\\prime},R^{\\prime},p+1}(\\cdot)</span></p>

    <p class="text-gray-300">which is negligible by assumption.</p>

    <h2 id="sec-12" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] M. Abdalla, M. Bellare, and G. Neven. Robust encryption. In D. Micciancio, editor, TCC 2010, volume 5978 of LNCS, pages 480–497. Springer, Feb. 2010. 5, 6, 8</li>

      <li>[2] S. Agrawal, D. M. Freeman, and V. Vaikuntanathan. Functional encryption for inner product predicates from learning with errors. In D. H. Lee and X. Wang, editors, ASIACRYPT 2011, volume 7073 of LNCS, pages 21–40. Springer, Dec. 2011. 2</li>

      <li>[3] S. Agrawal, S. Gorbunov, V. Vaikuntanathan, and H. Wee. Functional encryption: New perspectives and lower bound. Cryptology ePrint Archive, Report 2012/468, 2012. http://eprint.iacr.org/. 3, 4</li>

      <li>[4] M. Barbosa and P. Farshim. Semantically secure functional encryption revisited. Cryptology ePrint Archive, Report 2012/474, 2012. http://eprint.iacr.org/. 4, 7</li>

      <li>[5] M. Bellare, R. Dowsley, B. Waters, and S. Yilek. Standard security does not imply security against selective-opening. In D. Pointcheval, editor, EUROCRYPT 2012, LNCS. Springer, 2012. 1, 3, 10, 18</li>

      <li>[6] M. Bellare, D. Hofheinz, and S. Yilek. Possibility and impossibility results for encryption and commitment secure under selective opening. In A. Joux, editor, EUROCRYPT 2009, volume 5479 of LNCS, pages 1–35. Springer, Apr. 2009. 4</li>

      <li>[7] M. Bellare and A. Palacio. GQ and Schnorr identification schemes: Proofs of security against impersonation under active and concurrent attacks. In M. Yung, editor, CRYPTO 2002, volume 2442 of LNCS, pages 162–177. Springer, Aug. 2002. 10</li>

    </ul>

    <p class="text-gray-300">[8] M. Bellare and P. Rogaway. The security of triple encryption and a framework for code-based game-playing proofs. In S. Vaudenay, editor, EUROCRYPT 2006, volume 4004 of LNCS, pages 409–426. Springer, May / June 2006.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[9] M. Bellare, B. Waters, and S. Yilek. Identity-based encryption secure against selective opening attack. In Y. Ishai, editor, TCC 2011, volume 6597 of LNCS, pages 235–252. Springer, Mar. 2011.</li>

      <li>[10] D. Boneh and X. Boyen. Efficient selective-ID secure identity based encryption without random oracles. In C. Cachin and J. Camenisch, editors, EUROCRYPT 2004, volume 3027 of LNCS, pages 223–238. Springer, May 2004.</li>

      <li>[11] D. Boneh and X. Boyen. Secure identity based encryption without random oracles. In M. Franklin, editor, CRYPTO 2004, volume 3152 of LNCS, pages 443–459. Springer, Aug. 2004.</li>

      <li>[12] D. Boneh, G. Di Crescenzo, R. Ostrovsky, and G. Persiano. Public key encryption with keyword search. In C. Cachin and J. Camenisch, editors, EUROCRYPT 2004, volume 3027 of LNCS, pages 506–522. Springer, May 2004.</li>

      <li>[13] D. Boneh and M. K. Franklin. Identity based encryption from the Weil pairing. SIAM Journal on Computing, 32(3):586–615, 2003.</li>

      <li>[14] D. Boneh, A. Sahai, and B. Waters. Functional encryption: Definitions and challenges. In Y. Ishai, editor, TCC 2011, volume 6597 of LNCS, pages 253–273. Springer, Mar. 2011.</li>

      <li>[15] R. Canetti, U. Feige, O. Goldreich, and M. Naor. Adaptively secure multi-party computation. In 28th ACM STOC, pages 639–648. ACM Press, May 1996.</li>

      <li>[16] I. Damgård and J. B. Nielsen. Improved non-committing encryption schemes based on a general complexity assumption. In M. Bellare, editor, CRYPTO 2000, volume 1880 of LNCS, pages 432–450. Springer, Aug. 2000.</li>

      <li>[17] S. Fehr, D. Hofheinz, E. Kiltz, and H. Wee. Encryption schemes secure against chosen-ciphertext selective opening attacks. In H. Gilbert, editor, EUROCRYPT 2010, volume 6110 of LNCS, pages 381–402. Springer, May 2010.</li>

      <li>[18] S. Goldwasser and S. Micali. Probabilistic encryption. Journal of Computer and System Sciences, 28(2):270–299, 1984.</li>

      <li>[19] S. Gorbunov, V. Vaikuntanathan, and H. Wee. Functional encryption with bounded collusions via multi-party computation. In CRYPTO, pages 162–179, 2012.</li>

      <li>[20] V. Goyal, O. Pandey, A. Sahai, and B. Waters. Attribute-based encryption for fine-grained access control of encrypted data. In A. Juels, R. N. Wright, and S. Vimercati, editors, ACM CCS 06, pages 89–98. ACM Press, Oct. / Nov. 2006. Available as Cryptology ePrint Archive Report 2006/309.</li>

      <li>[21] B. Hemenway, B. Libert, R. Ostrovsky, and D. Vergnaud. Lossy encryption: Constructions from general assumptions and efficient selective opening chosen ciphertext security. In D. H. Lee and X. Wang, editors, ASIACRYPT 2011, volume 7073 of LNCS, pages 70–88. Springer, Dec. 2011.</li>

      <li>[22] J. Katz, A. Sahai, and B. Waters. Predicate encryption supporting disjunctions, polynomial equations, and inner products. In N. P. Smart, editor, EUROCRYPT 2008, volume 4965 of LNCS, pages 146–162. Springer, Apr. 2008.</li>

      <li>[23] A. B. Lewko, T. Okamoto, A. Sahai, K. Takashima, and B. Waters. Fully secure functional encryption: Attribute-based encryption and (hierarchical) inner product encryption. In H. Gilbert, editor, EUROCRYPT 2010, volume 6110 of LNCS, pages 62–91. Springer, May 2010.</li>

      <li>[24] A. B. Lewko and B. Waters. Decentralizing attribute-based encryption. In K. G. Paterson, editor, EUROCRYPT 2011, volume 6632 of LNCS, pages 568–588. Springer, May 2011.</li>

      <li>[25] A. B. Lewko and B. Waters. Unbounded HIBE and attribute-based encryption. In K. G. Paterson, editor, EUROCRYPT 2011, volume 6632 of LNCS, pages 547–567. Springer, May 2011.</li>

      <li>[26] J. B. Nielsen. Separating random oracle proofs from complexity theoretic proofs: The non-committing encryption case. In M. Yung, editor, CRYPTO 2002, volume 2442 of LNCS, pages 111–126. Springer, Aug. 2002.</li>

    </ul>

    <p class="text-gray-300">[27] T. Okamoto and K. Takashima. Hierarchical predicate encryption for inner-products. In M. Matsui, editor, ASIACRYPT 2009, volume 5912 of LNCS, pages 214–231. Springer, Dec. 2009.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[28] T. Okamoto and K. Takashima. Efficient attribute-based signatures for non-monotone predicates in the standard model. In D. Catalano, N. Fazio, R. Gennaro, and A. Nicolosi, editors, PKC 2011, volume 6571 of LNCS, pages 35–52. Springer, Mar. 2011.</li>

      <li>[29] A. O’Neill. Definitional issues in functional encryption. Cryptology ePrint Archive, Report 2010/556, 2010. http://eprint.iacr.org/. 1, 2, 4, 7, 15</li>

      <li>[30] R. Ostrovsky, A. Sahai, and B. Waters. Attribute-based encryption with non-monotonic access structures. In P. Ning, S. D. C. di Vimercati, and P. F. Syverson, editors, ACM CCS 07, pages 195–203. ACM Press, Oct. 2007.</li>

      <li>[31] A. Sahai and B. R. Waters. Fuzzy identity-based encryption. In R. Cramer, editor, EUROCRYPT 2005, volume 3494 of LNCS, pages 457–473. Springer, May 2005.</li>

      <li>[32] A. Shamir. Identity-based cryptosystems and signature schemes. In G. R. Blakley and D. Chaum, editors, CRYPTO’84, volume 196 of LNCS, pages 47–53. Springer, Aug. 1985.</li>

      <li>[33] E. Shen, E. Shi, and B. Waters. Predicate privacy in encryption systems. In O. Reingold, editor, TCC 2009, volume 5444 of LNCS, pages 457–473. Springer, Mar. 2009.</li>

      <li>[34] B. Waters. Dual system encryption: Realizing fully secure IBE and HIBE under simple assumptions. In S. Halevi, editor, CRYPTO 2009, volume 5677 of LNCS, pages 619–636. Springer, Aug. 2009.</li>

      <li>[35] B. Waters. Functional encryption for regular languages. In CRYPTO, pages 218–235, 2012.</li>

      <li>[36] B. R. Waters. Efficient identity-based encryption without random oracles. In R. Cramer, editor, EUROCRYPT 2005, volume 3494 of LNCS, pages 114–127. Springer, May 2005.</li>

    </ul>

    <h2 id="sec-13" class="text-2xl font-bold">Appendix A Standard Primitives</h2>

    <p class="text-gray-300">Public-key encryption schemes. An public-key encryption scheme <span class="math">\\Pi=(\\mathcal{G},\\mathcal{E},\\mathcal{D})</span> is specified by three PT algorithms. Via <span class="math">(pk,sk)\\mathop{\\leftarrow}\\nolimits\\mathop{\\circ}\\nolimits\\mathcal{G}(\\lambda)</span> the key-generation algorithm <span class="math">\\mathcal{G}</span> generates a public key and matching secret key. Via <span class="math">c\\mathop{\\leftarrow}\\nolimits\\mathop{\\circ}\\nolimits\\mathcal{E}(pk,m)</span> the encryption algorithm <span class="math">\\mathcal{E}</span> takes <span class="math">pk</span> and message <span class="math">m</span> and returns a ciphertext <span class="math">c\\in\\{0,1\\}^{<em>}\\cup\\{\\bot\\}</span>. Via <span class="math">m\\mathop{\\leftarrow}\\mathcal{D}(sk,c)</span>, the deterministic decryption algorithm <span class="math">\\mathcal{V}</span> returns a message <span class="math">m</span>. We require that <span class="math">\\mathcal{D}(sk,\\mathcal{E}(pk,m))=m</span> for all <span class="math">\\lambda\\in\\mathbb{N}</span>, all <span class="math">(pk,sk)\\in[\\mathcal{G}(\\lambda)]</span>, and all <span class="math">m\\in\\{0,1\\}^{</em>}</span></p>

    <p class="text-gray-300">Hash Functions. A hash function <span class="math">\\mathcal{H}=(K,H)</span> is a tuple of PT algorithms. Via <span class="math">hk\\mathop{\\leftarrow}\\nolimits\\mathop{\\circ}\\nolimits K(\\lambda)</span> the key-generation algorithm <span class="math">K</span> produces a key <span class="math">hk</span>. Via <span class="math">y\\mathop{\\leftarrow}H(hk,x)</span> the deterministic hashing algorithm <span class="math">H</span> produces the hash of a string <span class="math">x</span> under key <span class="math">hk</span>. Collision-resistance is defined via game <span class="math">\\mathrm{CR}_{\\Gamma}</span> whose Initialize<span class="math">(\\lambda)</span> procedure returns <span class="math">hk\\mathop{\\leftarrow}\\nolimits\\mathop{\\circ}\\nolimits K(\\lambda)</span> and whose Finalize procedure on input <span class="math">(x,x^{\\prime})</span> returns <span class="math">(x\\neq x^{\\prime})\\wedge(H(hk,x)=H(hk,x^{\\prime}))</span>. There are no other procedures. The advantage of an adversary <span class="math">C</span> is defined by <span class="math">\\mathbf{Adv}^{\\mathrm{col}}_{\\mathcal{H},C}(\\lambda)=\\Pr\\big{[}\\operatorname{CR}_{\\mathcal{H}}^{C}(\\lambda)\\big{]}</span>. We say that <span class="math">\\mathcal{H}</span> is collision-resistant (CR) if <span class="math">\\mathbf{Adv}^{\\mathrm{col}}_{\\mathcal{H},C}(\\cdot)</span> is negligible for every PT <span class="math">C</span>.</p>

    <h2 id="sec-14" class="text-2xl font-bold">Appendix B The Unordered Case</h2>

    <p class="text-gray-300">Unordered SS1. We start by formalizing the definition. Let <span class="math">\\mathsf{FE}=(\\mathsf{Setup},\\mathsf{KDer},\\mathsf{Enc},\\mathsf{Dec})</span> be a <span class="math">\\mathcal{F}</span>-FE scheme. The definition uses games <span class="math">\\mathrm{RSS1}\\text{-}\\mathrm{U}_{\\mathsf{FE},\\mathcal{F},Z,D,R}</span> and <span class="math">\\mathrm{ISS1}\\text{-}\\mathrm{U}_{\\mathcal{F},Z,D,R}</span> of Figure 13. (“U” for unordered.) We say that <span class="math">\\mathsf{FE}</span> is SS1-U-secure if for every auxiliary input generator <span class="math">Z</span>, every PT message sampler <span class="math">D</span>, every PT relation <span class="math">R</span> and every PT adversary <span class="math">A</span> there is a PT simulator <span class="math">S</span> such that</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}^{\\mathrm{gecu}}_{\\mathsf{FE},\\mathcal{F},A,S,Z,D,R}(\\cdot)\\ =\\ \\Pr\\big{[}\\operatorname{RSS1}\\text{-}\\mathrm{U}^{A}_{\\mathsf{FE},\\mathcal{F},Z,D,R}(\\cdot)\\big{]}-\\Pr\\big{[}\\operatorname{ISS1}\\text{-}\\mathrm{U}^{S}_{\\mathcal{F},Z,D,R}(\\cdot)\\big{]}</span></p>

    <p class="text-gray-300">is negligible.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PROC INITIALIZE(λ): (pk,sk)←<em> Setup(λ) z←</em> Z(λ) i,j←0; St←ε Return (pk,z)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PROC INITIALIZE(λ): i,j←0; St←ε z←* Z(λ); A←∅ Return z</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PROC ENC(α): Qα←Qα∪{α} (St,x[i])←<em> D(St,α) c[i]←</em> Enc(pk,x[i]) Return (c[i],F(λ,ε,x[i]))</td>

            <td class="px-3 py-2 border-b border-gray-700">PROC MSG(α): Qα←Qα∪{α} (St,x[i])←* D(St,α) Return F(λ,ε,x[i])</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PROC KD(a): Qa←Qa∪{a} dk←* KDer(sk,a) Return dk</td>

            <td class="px-3 py-2 border-b border-gray-700">PROC OP(a): Qa←Qa∪{a} Return ε</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PROC FINALIZE(w): Return R(λ,z,x,Qa,Qα,St,w)</td>

            <td class="px-3 py-2 border-b border-gray-700">PROC F(a,s): If a∈El(a) and 1≤s≤i then Return F(λ,a,x[s]) Else return ⊥</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | PROC FINALIZE(w): Return R(λ,z,x,Qa,Qα,St,w)  |</p>

    <p class="text-gray-300">Figure 13: Left: "Real world" game RSS1- <span class="math">\\mathrm{U}_{\\mathsf{FE},\\mathcal{F},Z,D,R}</span>  for the SS1-U definition. Right: "Ideal world" game ISS1- <span class="math">\\mathrm{U}_{\\mathcal{F},Z,D,R}</span>  for the SS1-U definition.</p>

    <p class="text-gray-300">IDENTITY-EMBEDDABLE PE. In the unordered case our result applies to what we call identity-embeddable predicate encryption schemes. Intuitively, these are predicate encryption schemes whose decryption policy embeds an identity matrix. Let  <span class="math">\\mathcal{F}</span>  be a predicate encryption functionality for predicate  <span class="math">\\mathcal{P}</span> . We say that  <span class="math">\\mathcal{F}</span>  is  <span class="math">n(\\cdot)</span> -identity embeddable if there are  <span class="math">\\{(a_{1,\\lambda},\\ldots ,a_{n(\\lambda),\\lambda})\\}_{\\lambda \\in \\mathbb{N}}</span>  and  <span class="math">\\{(w_{1,\\lambda},\\ldots ,w_{n(\\lambda),\\lambda})\\}_{\\lambda \\in \\mathbb{N}}</span>  such that for all  <span class="math">\\lambda \\in \\mathbb{N}</span>  and all  <span class="math">1\\leq i,j\\leq n(\\lambda)</span> ,  <span class="math">\\mathcal{P}(\\lambda ,a_i,w_j) = 1</span>  if  <span class="math">i = j</span>  and  <span class="math">\\perp</span>  otherwise.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that the decryption policy described by an identity matrix is exactly that of IBE. Thus, any PE functionality that "contains" the functionality for an IBE scheme with  <span class="math">n</span>  identities is  <span class="math">n</span> -identity embeddable. PE functionalities considered in the literature typically satisfy this requirement. For example, the inner-product functionality over  <span class="math">\\mathbb{Z}_N</span>  introduced by [22] was shown to implement IBE by restricting  <span class="math">a</span>  to the form (id, 1) and  <span class="math">w</span>  to the form  <span class="math">(-1, \\mathrm{id}&#x27;)</span>  for  <span class="math">\\mathrm{id}, \\mathrm{id}&#x27; \\in \\mathbb{Z}_N</span> . Thus any inner-product functionality with vectors of dimension 2 is  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> -identity embeddable. Note that in [22]  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is exponential in  </span>\\lambda<span class="math"> , whereas for our application we just need it to be polynomial in  </span>\\lambda$  (namely, the output length of a collision-resistant hash function).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Theorem B.1 Let  <span class="math">\\mathcal{F}</span>  be a predicate encryption functionality for predicate  <span class="math">\\mathcal{P}</span> . Let  <span class="math">\\mathcal{H} = (K, H)</span>  be a collision-resistant hash function with output length  <span class="math">\\ell_{\\mathcal{H}}(\\cdot)</span> . Suppose that for every  <span class="math">\\lambda \\in N</span> ,  <span class="math">\\mathcal{F}(\\lambda, \\varepsilon, x)</span>  is the same for all  <span class="math">x \\in [X_{\\lambda}]</span> . Furthermore, suppose that  <span class="math">\\mathcal{F}</span>  is  <span class="math">2\\ell_{\\mathcal{H}}(\\cdot)</span> -identity embeddable. Then there does not exist an SS1-U-secure  <span class="math">\\mathcal{F}</span> -FE scheme. More precisely, suppose FE is a  <span class="math">\\mathcal{F}</span> -FE scheme with secret-key length  <span class="math">\\ell_{sk}(\\cdot)</span> . Then for any function  <span class="math">\\mu(\\cdot)</span>  there exists a PT auxiliary input generator  <span class="math">Z</span> , message sampler  <span class="math">D</span> , PT adversary  <span class="math">A</span> , PT relation  <span class="math">R</span> , and CR-adversary  <span class="math">C</span>  such that for every simulator  <span class="math">S</span></p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {\\mathsf {F E}, \\mathcal {F}, A, S, D, R} ^ {\\mathrm {s s}} (\\cdot) \\leq 1 - \\sqrt {\\mathbf {A d v} _ {\\mathcal {H} , C} ^ {\\mathrm {c o l}} (\\cdot) + 1 / \\mu (\\cdot)}.</span></div>

    <p class="text-gray-300">Adversary  <span class="math">A</span>  makes  <span class="math">\\ell_{sk}(\\cdot) + \\log \\mu (\\cdot)</span>  encryption queries and  <span class="math">\\ell_{\\mathcal{H}}(\\cdot)</span>  key-derivation queries.</p>

    <p class="text-gray-300">We remark that our theorem and proof treat the case of  <span class="math">(\\mathsf{P},\\mathsf{p})</span> ,  <span class="math">(\\mathsf{p},\\mathsf{p})</span> , and  <span class="math">(\\mathsf{p},\\mathsf{P})</span>  PE functionalities in a unified way. However, in the case of  <span class="math">(\\mathsf{P},\\mathsf{p})</span> -PE the condition in the theorem that  <span class="math">\\mathcal{F}</span>  be  <span class="math">2\\ell_{\\mathcal{H}}(\\cdot)</span> -identity embeddable can be improved to  <span class="math">\\ell_{\\mathcal{H}}(\\cdot)</span> -identity embeddable. We also stress that, unlike Theorem 4.1, our result here does not apply to any "non-trivial" functionality but only those of a certain form. Better understanding the nature of the gap between the two results or closing it remains an interesting open problem. It is also interesting to note that our result here uses an adversary that makes  <span class="math">\\ell_{\\mathcal{H}}(\\cdot)</span>  key-derivation queries as opposed to the constant 2 of Theorem 4.1. It would be interesting to know if this is</p>

    <p class="text-gray-300">tight, meaning whether SS1-U can be achieved against adversaries making some small bounded number of key derivation queries.</p>

    <p class="text-gray-300">Proof of Theorem B.1: Denote by  <span class="math">\\{(a_{1,\\lambda},\\ldots ,a_{2\\ell_{\\mathcal{H}}(\\lambda),\\lambda})\\}_{\\lambda \\in \\mathbb{N}}</span>  and  <span class="math">\\{(w_{1,\\lambda},\\dots ,w_{2\\ell_{\\mathcal{H}}(\\lambda),\\lambda})\\}_{\\lambda \\in \\mathbb{N}}</span>  the values that satisfy  <span class="math">2\\ell_{\\mathcal{H}}(\\lambda)</span> -identity embeddability for  <span class="math">\\mathcal{F}</span> . For  <span class="math">\\lambda \\in \\mathbb{N}</span>  denote by  <span class="math">\\overline{\\varepsilon}_{\\lambda}</span>  the value such that  <span class="math">\\mathcal{F}(\\lambda ,\\varepsilon ,x) = \\overline{\\varepsilon}_{\\lambda}</span>  for all  <span class="math">x\\in [X_{\\lambda}]</span> . Let  <span class="math">n(\\cdot)\\coloneqq \\ell (\\cdot) + \\log \\mu (\\cdot)</span> . Define auxiliary input generator  <span class="math">Z</span>  on input  <span class="math">\\lambda</span>  to return  <span class="math">hk\\gets \\mathbb{S}K(\\lambda)</span> . For  <span class="math">\\lambda \\in \\mathbb{N}</span>  denote by  <span class="math">M_{\\lambda}</span>  a distribution on messages for FE so that if FE is private message then  <span class="math">M_{\\lambda} = \\{0,1\\}</span>  and otherwise is trivial. Then define message sampler  <span class="math">D</span>  on input  <span class="math">St,\\alpha</span>  to set  <span class="math">St\\gets 1</span>  if  <span class="math">St = \\varepsilon</span>  and  <span class="math">St\\gets St + 1</span>  otherwise, and to return  <span class="math">(St,(w_{2(\\lfloor St / n\\rfloor +1) - b,\\lambda},m))</span>  where  <span class="math">b\\gets \\mathbb{S}\\{0,1\\}</span>  and  <span class="math">m\\gets \\mathbb{S}M</span> . Define adversary  <span class="math">A</span>  and relation  <span class="math">R</span>  as follows:</p>

    <p class="text-gray-300">Alg  <span class="math">A(pk,hk)</span>  ..</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For  <span class="math">i = 1,\\dots ,\\ell_{\\mathcal{H}}(\\lambda)n(\\lambda)</span>  do:  <span class="math">\\mathbf{c}[i]\\gets \\mathbb{S}\\mathrm{ENC}(\\lambda)</span> $h\\gets H(hk,pk\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{c})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For  <span class="math">i = 1</span>  to  <span class="math">\\ell_{\\mathcal{H}}(\\lambda)</span>  do:  <span class="math">\\mathbf{sk}[i]\\gets \\mathbb{S}\\mathrm{KD}(a_{2i - h[i]})</span> <span class="math">w\\gets (pk,\\mathbf{c},h,\\mathbf{sk})</span>  Return  <span class="math">w</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Alg  <span class="math">R(\\lambda ,\\mathbf{x},Q_a,Q_\\alpha ,St,w)</span>  ..  <span class="math">(pk,hk,\\mathbf{c},h,\\mathbf{sk})\\gets w</span>  If  $h\\neq H(hk,pk\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{c})$  then return false</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">For  <span class="math">i = 1,\\dots ,\\ell_{\\mathcal{H}}(\\lambda)</span>  do: If  $</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbf{sk}[i]</td>

            <td class="px-3 py-2 border-b border-gray-700">\\neq \\ell_{sk}(\\lambda)$  then return false</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If  <span class="math">Q_{a}\\neq \\{a_{2i - h[i],\\lambda}:1\\leq i\\leq \\ell_{\\mathcal{H}}(\\lambda)\\}</span>  then return false</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If  $\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\neq \\ell_{\\mathcal{H}}(\\lambda)n(\\lambda)\\lor Q_{\\alpha}\\neq \\{\\lambda \\}$  then return false</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For  <span class="math">i = 1,\\ldots ,\\ell_{\\mathcal{H}}(\\lambda)</span>  do: If  <span class="math">\\mathrm{Dec}(\\mathbf{sk}[i],\\mathbf{c}[i\\dots i + n - 1])\\neq \\mathcal{F}(\\lambda ,a_{2i - h[i]},\\mathbf{x}[i\\dots i + n - 1])</span>  Then return false Return true</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By construction  <span class="math">\\operatorname*{Pr}\\left[\\mathrm{RSS1 - U}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^{A}(\\cdot)\\right] = 1</span> . Let  <span class="math">S</span>  be any simulator. Furthermore, parsing the output of  <span class="math">S</span>  as  <span class="math">(pk,\\mathbf{c},h,\\mathbf{sk})\\gets w</span> , we assume it holds that  $h = H(hk,pk\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{c})<span class="math"> ,  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{sk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\ell_{\\mathcal{H}}(\\lambda)<span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{sk}[i]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\ell_{sk}(\\lambda)<span class="math">  for  </span>1\\leq i\\leq \\ell_{\\mathcal{H}}(\\lambda)<span class="math"> ,  </span>Q_{a} = \\{a_{2n - h[i],\\lambda}:1\\leq i\\leq \\ell_{\\mathcal{H}}\\}<span class="math"> , and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pmb {\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\ell_{\\mathcal{H}}(\\lambda)n(\\lambda)<span class="math">  and  </span>Q_{\\alpha} = \\{\\lambda \\}<span class="math"> , since otherwise the relation  </span>R<span class="math">  returns false. Towards applying Lemma 4.2, we write the execution of  </span>S<span class="math">  in the ISS-U game as a composition of two algorithms  </span>S_{1},S_{2}$  as follows:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Alg  <span class="math">S_{1}(\\lambda)</span>  .. <span class="math">i\\gets 0</span>  .  <span class="math">z\\gets \\mathbb{S}</span>  INITIALIZER  <span class="math">(\\lambda)</span> Run  <span class="math">S(z)</span> On message-query  <span class="math">\\alpha</span>  do:  <span class="math">i\\gets i + 1</span> <span class="math">b\\gets \\mathbb{S}\\{0,1\\} ;m\\gets \\mathbb{S}M_{\\lambda}</span> <span class="math">\\mathbf{x}[i]\\gets (w_{2(\\lfloor i / n\\rfloor +1) - b,\\lambda},m)</span>  Return  <span class="math">\\overline{z}</span> On op-query  <span class="math">a</span>  do:  <span class="math">j\\gets j + 1;A\\gets A\\cup \\{a\\}</span>  If  <span class="math">j = \\ell_{\\mathcal{H}}(\\lambda)</span>  then  <span class="math">a^*\\gets a</span>  Halt computation of  <span class="math">S_{1}</span>  with state St Else return  <span class="math">\\varepsilon</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">On  <span class="math">F</span>  -query  <span class="math">(a,s)</span>  do: If  <span class="math">1\\leq s\\leq i</span>  and  <span class="math">a\\in A</span>  do: Return  <span class="math">\\mathcal{F}(\\lambda ,a,\\mathbf{x}[s])</span>  Else return  <span class="math">\\perp</span> $\\overline{St}\\gets St\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a^{*}<span class="math">  Return  </span>\\overline{St}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Alg  <span class="math">S_{2}(\\overline{St})</span>  ..</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$St\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a^{*}\\gets \\overline{St}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let  <span class="math">i^{<em>}</span>  be such that  <span class="math">a^</em>\\in \\{a_{2i^<em>,\\lambda},a_{2i^</em> -1,\\lambda}\\}</span> For  <span class="math">q = 1,\\ldots ,n</span>  do:  <span class="math">b\\gets \\mathbb{S}\\{0,1\\} ;m\\gets \\mathbb{S}M_{\\lambda}</span> <span class="math">\\mathbf{x}[i^{<em>}\\cdot n + q - 1]\\gets (w_{2i^{</em>} - b,\\lambda},m)</span> Run  <span class="math">S</span>  at state  <span class="math">St</span>  .. On message-query  <span class="math">\\alpha</span>  do:  <span class="math">i\\gets i + 1</span>  If  <span class="math">i\\notin \\{i^{<em>}\\cdot n,\\dots ,i^{</em>}\\cdot n + n - 1\\}</span>  do:  <span class="math">b\\gets \\mathbb{S}\\{0,1\\} ;m\\gets \\mathbb{S}M_{\\lambda}</span> <span class="math">\\mathbf{x}[i]\\gets (w_{2\\lfloor \\alpha /n\\rfloor -b,\\lambda},m)</span>  Return  <span class="math">\\overline{z}</span> On  <span class="math">F</span>  -query  <span class="math">(a,s)</span>  do: If  <span class="math">1\\leq s\\leq i</span>  and  <span class="math">a\\in \\mathsf{El}(\\mathbf{a})</span>  do: Return  <span class="math">\\mathcal{F}(\\lambda ,a,\\mathbf{x}[s])</span>  Else return  <span class="math">\\perp</span> Let  <span class="math">w</span>  be the output of  <span class="math">S</span> Return  <span class="math">w</span></p>

    <p class="text-gray-300"><span class="math">S_{1}</span> runs <span class="math">S</span> up to the point that it makes its <em>last</em> Op query (namely the <span class="math">\\ell_{\\mathcal{H}}(\\lambda)</span>-th one), and <span class="math">S_{2}</span> runs <span class="math">S</span> following this Op query. Below we justify the following sequence of inequalities:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\text{ ISS1-U}_{\\mathcal{F},Z,D,R}^{S}(\\cdot)\\,\\right]</span> <span class="math">=</span> <span class="math">\\mathbf{A}\\mathbf{P}_{1}(P_{1},P_{2},\\lambda)</span> <span class="math">\\leq</span> <span class="math">\\sqrt{\\mathbf{A}\\mathbf{P}_{2}(S_{1},S_{2},\\lambda)}</span> <span class="math">\\leq</span> <span class="math">\\sqrt{\\mathbf{A}\\mathbf{d}\\mathbf{v}_{\\mathcal{H},C}^{\\mathrm{col}}(\\lambda)+\\Pr\\left[\\,\\mathcal{F}(\\lambda,a_{\\lambda},\\mathbf{x})\\in Y\\,\\right]}</span> <span class="math">\\leq</span> <span class="math">\\sqrt{\\mathbf{A}\\mathbf{d}\\mathbf{v}_{\\mathcal{H},C}^{\\mathrm{col}}(\\lambda)+2^{\\ell}(1/2)^{n}}</span> <span class="math">=</span> <span class="math">\\sqrt{\\mathbf{A}\\mathbf{d}\\mathbf{v}_{\\mathcal{H},C}^{\\mathrm{col}}(\\lambda)+1/\\mu(\\lambda)}</span></p>

    <p class="text-gray-300">Above, the first line is by construction; note that while <span class="math">S_{2}</span> chooses <span class="math">\\mathbf{x}^{<em>}</span> and hence some components of <span class="math">\\mathbf{x}</span> differently than <span class="math">S</span>, this is equivalent due to the <span class="math">2n</span>-identity embeddability of <span class="math">\\mathcal{F}</span> and is only used to make the analysis more transparent. The second is by Lemma 4.2. For the third, we can define <span class="math">C</span> analogously to the proof of Theorem 4.1 (namely, <span class="math">C</span> simply mimics the double execution experiment with <span class="math">S_{1},S_{2}</span>). Let us denote the two outputs of <span class="math">S_{2}</span> in that experiment as <span class="math">w^{1}=(pk^{1},\\mathbf{c}^{1},h^{1},\\mathbf{sk}^{1})</span> and <span class="math">w^{2}=(pk^{2},\\mathbf{c}^{2},h^{2},\\mathbf{sk}^{2})</span>. Now, unless <span class="math">C</span> finds a collision we have <span class="math">\\mathbf{c}^{1}=\\mathbf{c}^{2}</span>, denote by <span class="math">\\mathbf{c}^{</em>}</span> this common value. Then define the set <span class="math">Y:=\\{y\\in\\{0,1\\}^{<em>}\\ :\\ \\exists s\\in\\{0,1\\}^{\\ell}\\text{ s.t. }\\mathsf{Dec}(s,\\mathbf{c}^{</em>}[i^{<em>}n\\ldots i^{</em>}n+n-1])=y\\}</span>. If it is not the case that <span class="math">\\mathcal{F}(\\lambda,a_{i^{<em>},\\lambda},\\mathbf{x}[i^{</em>}n\\ldots i^{<em>}n+n-1])\\in Y</span> when <span class="math">\\mathbf{x}[i^{</em>}n\\ldots i^{<em>}n+n-1]</span> is (re-)sampled by <span class="math">S_{2}</span> then the relation <span class="math">R</span> must reject, as no <span class="math">\\mathbf{sk}^{2}</span> will satisfy <span class="math">\\mathsf{Dec}(\\mathbf{sk}^{2}[i^{</em>}],\\mathbf{c}^{<em>}[i^{</em>}n\\ldots i^{<em>}\\cdot n+n-1])=\\mathcal{F}(\\lambda,a_{i^{</em>}n-h[i^{<em>}]},\\mathbf{x}[i^{</em>}n\\ldots i^{<em>}n+n-1])</span>, justifying the third line above. To see the fourth line, fix <span class="math">s\\in\\{0,1\\}^{\\ell}</span> and denote <span class="math">\\mathsf{Dec}(s,\\mathbf{c}^{</em>}[i^{<em>}n\\ldots i^{</em>}n+n-1])</span> by <span class="math">\\mathbf{x}^{<em>}</span>. As <span class="math">\\mathbf{x}[i^{</em>}\\cdot n]</span> is defined as <span class="math">(w_{2\\lfloor\\alpha/n\\rfloor-b,\\lambda},m)</span> for random <span class="math">b\\in\\{0,1\\}</span> and <span class="math">m\\in M_{\\lambda}</span>, <span class="math">\\mathbf{x}[i^{<em>}\\cdot n]=\\mathbf{x}^{</em>}[1]</span> with probability at most <span class="math">1/2</span>, and similarly for the remaining components of <span class="math">\\mathbf{x}[i^{<em>}\\cdot n\\ldots i^{</em>}\\cdot n+n-1]</span>, which are sampled independently. Taking a union bound over all possible <span class="math">s\\in\\{0,1\\}^{\\ell}</span> yields the fourth line. Finally, for the fifth line above we just substitute <span class="math">n(\\lambda)=\\ell(\\lambda)+\\log(\\mu(\\lambda))</span>.</p>

    <p class="text-gray-300">##</p>`;
---

<BaseLayout title="Semantically-Secure Functional Encryption: Possibility Resul... (2012/515)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2012 &middot; eprint 2012/515
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
