---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2012/515';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-18';
const TITLE_HTML = 'Semantically-Secure Functional Encryption: Possibility Results, Impossibility Results and the Quest for a General Definition';
const AUTHORS_HTML = 'Mihir Bellare, Adam O&#x27;Neill';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">This paper explains that SS1-secure functional encryption (FE) as defined by Boneh, Sahai and Waters implicitly incorporates security under key-revealing selective opening attacks (SOA-K). This connection helps intuitively explain their impossibility results and also allows us to prove stronger ones. To fill this gap and move us closer to the (laudable) goal of a general and achievable notion of FE security, we seek and provide two \`\`sans SOA-K&#x27;&#x27; definitions of FE security that we call SS2 and SS3. We prove various possibility results about these definitions. We view our work as a first step towards the challenging goal of a general, meaningful and achievable notion of FE security.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> Functional encryption &middot; semantic-security &middot; identity-based encryption</p>
    </section>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 Notation and conventions</h2>

    <p class="text-gray-300">If A is an algorithm then  <span class="math">y \\leftarrow A(x_1, \\ldots, x_n; r)</span>  means we run A on inputs  <span class="math">x_1, \\ldots, x_n</span>  and coins r and denote the output by y. By  <span class="math">y \\leftarrow A(x_1, \\ldots, x_n)</span>  we denote the operation of picking r at random and letting  <span class="math">y \\leftarrow A(x_1, \\ldots, x_n; r)</span> . By  <span class="math">[A(x_1, \\ldots, x_n)]</span>  we denote the set of all y that have positive probability of being output by A on inputs  <span class="math">x_1, \\ldots, x_n</span> . Unless otherwise indicated, an algorithm may be randomized. &quot;PT&quot; stands for &quot;polynomial time.&quot; The security parameter is denoted  <span class="math">\\lambda \\in \\mathbb{N}</span>  and whenever  <span class="math">\\lambda</span>  is input to an algorithm it is understood that it is encoded in unary.</p>

    <p class="text-gray-300">If s is a string then |s| denotes its length, s[i] denotes its ith bit, and  <span class="math">s[i \\dots j]</span>  denotes the substring consisting of its ith through jth bits. If  <span class="math">\\mathbf{x}</span>  is a vector then  <span class="math">|\\mathbf{x}|</span>  denotes the number of its components,  <span class="math">\\mathbf{x}[i]</span>  denotes its ith component, and  <span class="math">\\mathbf{x}[i \\dots j]</span>  denotes the subvector consisting of its ith through jth components. We write  <span class="math">\\mathsf{El}(\\mathbf{x})</span>  to mean  <span class="math">\\{\\mathbf{x}[i]:1\\leq i\\leq |\\mathbf{x}|\\}</span> . If f is a function and  <span class="math">\\mathbf{x}</span>  is a vector then  <span class="math">f(x_1,\\dots,x_{i-1},\\mathbf{x},x_{i+1},\\dots,x_n)</span>  denotes the vector whose i-th component is  <span class="math">f(x_1,\\dots,x_{i-1},\\mathbf{x}[i],x_{i+1},\\dots,x_n)</span>  for  <span class="math">1\\leq i\\leq |\\mathbf{x}|</span> . A predicate is a function with boolean output.</p>

    <p class="text-gray-300">Games. We use the language of code-based game-playing [8]. A game has an Initialize procedure, procedures to respond to adversary oracle queries, and a Finalize procedure. A game G is executed with an adversary A and security parameter  <span class="math">\\lambda</span>  as follows. A is given input  <span class="math">\\lambda</span>  and can then call game procedures. Its first oracle query must be Initialize( <span class="math">\\lambda</span> ) and its last oracle query must be to Finalize, and it must make exactly one query to each of these oracles. In between it can query the other procedures as oracles as it wishes. The output of Finalize, denoted  <span class="math">G^A(\\lambda)</span> , is called the output of the game. Let  <span class="math">A^G(\\lambda)</span>  denote the output of the adversary and  <span class="math">T(G,A,\\lambda)</span>  denote  <span class="math">Pr[G^A(\\lambda)]</span>  outputs true.</p>

    <p class="text-gray-300">STANDARD PRIMITIVES. In Appendix A we recall the standard notions of public-key encryption and collision-resistant hashing.</p>

    </section>

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3 Functional Encryption and its Security</h2>

    <p class="text-gray-300">Functionalities and FE schemes. A functionality  <span class="math">\\mathcal{F}: \\mathbb{N} \\times \\{0,1\\}^* \\times \\{0,1\\}^* \\to \\{0,1\\}^* \\cup \\{\\bot\\}</span>  is a deterministic PT algorithm. The first input is the security parameter. The second input is called the index and the third input is called the payload. A functional encryption (FE) scheme is a tuple of algorithms  <span class="math">\\mathsf{FE} = (\\mathsf{Setup}, \\mathsf{KDer}, \\mathsf{Enc}, \\mathsf{Dec})</span> . The setup algorithm  <span class="math">\\mathsf{Setup}</span>  on input  <span class="math">\\lambda</span>  returns a key-pair (pk, sk), the master public and secret keys. The key-derivation algorithm  <span class="math">\\mathsf{KDer}</span>  on inputs sk, a returns a secret key dk for a. The encryption algorithm  <span class="math">\\mathsf{Enc}</span>  on inputs pk, x returns a ciphertext c. The deterministic decryption algorithm  <span class="math">\\mathsf{Dec}</span>  on inputs dk, c returns a string y. We say that an  <span class="math">\\mathsf{FE}</span>  scheme  <span class="math">\\mathsf{FE} = (\\mathsf{Setup}, \\mathsf{KDer}, \\mathsf{Enc}, \\mathsf{Dec})</span>  is  <span class="math">\\mathcal{F}</span> -correct, or simply an  <span class="math">\\mathcal{F}</span> - <span class="math">\\mathsf{FE}</span>  scheme, if  <span class="math">\\mathsf{Dec}(dk, \\mathsf{Enc}(pk, x; r)) = \\mathcal{F}(\\lambda, a, x)</span>  for all  <span class="math">\\lambda, a, x, r</span>  satisfying  <span class="math">\\mathcal{F}(\\lambda, a, x) \\neq \\bot</span> , all  <span class="math">(pk, sk) \\in [\\mathsf{Setup}(\\lambda)]</span>  and all  <span class="math">dk \\in [\\mathsf{KDer}(sk, a)]</span> . We stress that correctness makes no requirements when  <span class="math">\\mathcal{F}(\\lambda, a, x) = \\bot</span> . (We do not mandate that  <span class="math">\\mathsf{Dec}(dk, \\mathsf{Enc}(pk, x; r)) = \\mathcal{F}(\\lambda, a, x)</span>  in this case, but we do not disallow it either.)</p>

    <p class="text-gray-300">SYNTAX AND CORRECTNESS IN BSW. The range of a functionality in the formal definition of BSW [14] does not include  <span class="math">\\bot</span> , and correctness asks that  <span class="math">\\mathsf{Dec}(dk,\\mathsf{Enc}(pk,x;r)) = \\mathcal{F}(\\lambda,a,x)</span>  for all  <span class="math">\\lambda,a,x,r</span> , all  <span class="math">(pk,sk) \\in [\\mathsf{Setup}(\\lambda)]</span>  and all  <span class="math">dk \\in [\\mathsf{KDer}(sk,a)]</span> . However, specific functionalites given in BSW (such as that for IBE,  <span class="math">\\mathcal{F}^{\\mathsf{P},\\mathsf{p}}_{\\mathrm{ibe}}</span>  in our notation) do return  <span class="math">\\bot</span> . So it would appear that the formal syntax ought to be amended to add  <span class="math">\\bot</span>  to the range of  <span class="math">\\mathcal{F}</span> . Once this is done, the correctness condition of BSW must be revisited. If left unchanged, it would be asking that  <span class="math">\\mathsf{Dec}(dk,\\mathsf{Enc}(pk,x;r)) = \\mathcal{F}(\\lambda,a,x)</span>  even when  <span class="math">\\mathcal{F}(\\lambda,a,x) = \\bot</span> . This, however, would be incorrect. Attacks from [1] show that BB-style IBE schemes [10],</p>

    <p class="text-gray-300">including the BB IBE scheme [10] and Waters's IBE scheme [36], fail to meet this correctness condition relative to  <span class="math">\\mathcal{F}^{\\mathsf{P},\\mathsf{p}}_{\\mathrm{ibe}}</span> . It was not clear to us exactly what BSW intended but we expect they did intend for existing IBE schemes to meet the correctness condition, and accordingly we have relaxed it to only hold when  <span class="math">\\mathcal{F}(\\lambda,a,x)\\neq \\bot</span> .</p>

    <p class="text-gray-300">PARTICULAR FUNCTIONALITIES. The most important special case of FE in the literature is predicate encryption (PE). We say that  <span class="math">\\mathcal{F}</span>  is a predicate encryption functionality if there is a predicate  <span class="math">\\mathcal{P}</span>  such that  <span class="math">\\mathcal{F}</span>  is  <span class="math">\\mathcal{P}</span> -induced. This means that for all  <span class="math">\\lambda</span> , all  <span class="math">a \\neq \\varepsilon</span>  and all (a',m) we have  <span class="math">\\mathcal{F}(\\lambda,a,(a&#x27;,m)) = m</span>  if  <span class="math">\\mathcal{P}(\\lambda,a,a&#x27;)</span>  = true and  <span class="math">\\bot</span>  otherwise. (We also require that  <span class="math">\\mathcal{F}(\\lambda,a,x)</span>  returns  <span class="math">\\bot</span>  if x is not a pair. Note that no requirement is made on  <span class="math">\\mathcal{F}(\\lambda,\\varepsilon,(a&#x27;,m))</span> , so a single predicate could induce many different functionalities which vary in what is revealed under  <span class="math">a = \\varepsilon</span> .) We call m the message. The IBE predicate  <span class="math">\\mathcal{P}_{\\text{ibe}}</span>  is defined by  <span class="math">\\mathcal{P}_{\\text{ibe}}(\\lambda,a,a&#x27;) = (a=a&#x27;)</span> , and we say that  <span class="math">\\mathcal{F}</span>  is an IBE functionality if it is  <span class="math">\\mathcal{P}_{\\text{ibe}}</span> -induced. (So, again, there may be many different IBE functionalities.) Within the class of PE functionalities, we distinguish whether the index, the message, or both are to be kept private, with corresponding IBE functionalities as canonical examples:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Public index, private message: We say that  <span class="math">\\mathcal{F}</span>  is a  <span class="math">(\\mathsf{P},\\mathsf{p})</span> -PE functionality if  <span class="math">\\mathcal{F}(\\lambda,\\varepsilon,(a&#x27;,m))=(a&#x27;,|m|)</span> . Called PE with public index in the literature. The canonical example is the IBE functionality  <span class="math">\\mathcal{F}^{\\mathsf{P},\\mathsf{p}}_{\\mathrm{ibe}}</span>  which sets  <span class="math">\\mathcal{F}^{\\mathsf{P},\\mathsf{p}}_{\\mathrm{ibe}}(\\lambda,\\varepsilon,(a&#x27;,m))=(a&#x27;,|m|)</span> , corresponding to IBE that hides the message but not necessarily the identity.</li>
      <li>Private index, private message: We say that  <span class="math">\\mathcal{F}</span>  is a (p,p)-PE functionality if  <span class="math">\\mathcal{F}(\\lambda,\\varepsilon,(a&#x27;,m))=|m|</span> . Called PE with private index in the literature. The canonical example is the IBE functionality  <span class="math">\\mathcal{F}_{ibe}^{p,p}</span>  which sets  <span class="math">\\mathcal{F}_{ibe}^{p,p}(\\lambda,\\varepsilon,(a&#x27;,m))=|m|</span> , corresponding to IBE that hides both the message and the identity (i.e. is anonymous).</li>
      <li>Private index, public message: We say that  <span class="math">\\mathcal{F}</span>  is a (p, P)-PE functionality if  <span class="math">\\mathcal{F}(\\lambda, \\varepsilon, (a&#x27;, m)) = m</span> . Called predicate-only PE in the literature. The canonical example is the IBE functionality  <span class="math">\\mathcal{F}_{ibe}^{p,P}</span>  which sets  <span class="math">\\mathcal{F}_{ibe}^{p,P}(\\lambda, \\varepsilon, (a&#x27;, m)) = m</span> , corresponding to IBE that hides the identity but not necessarily the message. PEKS [12] is a (p, P)-PE functionality that additionally satisfies robustness [1].</li>
    </ul>

    <p class="text-gray-300">We don't discuss (P, P)-PE because it reveals everything and is uninteresting.</p>

    <p class="text-gray-300">SS1 DEFINITION. The following definition is adapted from [14]. Let  <span class="math">\\mathsf{FE} = (\\mathsf{Setup}, \\mathsf{KDer}, \\mathsf{Enc}, \\mathsf{Dec})</span>  be an  <span class="math">\\mathcal{F}\\text{-FE}</span>  scheme. The definition uses games  <span class="math">\\mathsf{RSS1}_{\\mathsf{FE},\\mathcal{F},Z,D,R}</span>  and  <span class="math">\\mathsf{ISS1}_{\\mathcal{F},Z,D,R}</span>  of Figure 1. We provide some intuition for these games below. We say that  <span class="math">\\mathsf{FE}</span>  is  <span class="math">\\mathsf{SS1}\\text{-}\\mathsf{secure}</span>  if for every auxiliary input generator Z, every PT message sampler D, every PT relation R and every PT adversary A, there is a PT simulator S such that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\mathrm{ss1}}_{\\mathsf{FE},\\mathcal{F},A,S,Z,D,R}(\\cdot) \\ = \\ T(\\mathrm{RSS1}_{\\mathsf{FE},\\mathcal{F},Z,D,R},A,\\cdot) - T(\\mathrm{ISS1}_{\\mathcal{F},Z,D,R},S,\\cdot)</span>$</p>

    <p class="text-gray-300">is negligible. We note that the auxiliary input will be used in our impossibility result in Section 4 (where it contains a key for a collision-resistant hash function). Although we omit to do this for simplicity because it does not affect our results, it can also be given as an additional argument to a functionality itself. For example, in the case of the inner-product functionality introduced in [22] it can then contain the modulus N of unknown factorization.</p>

    <p class="text-gray-300">Intuitive overview of the definition. To gain some intuition for the games, let us first look at the &quot;real world&quot; game with the adversary. It has access to two main oracles, an encryption oracle Enc and key-derivation oracle Kd. The former takes input  <span class="math">\\alpha</span> , which describes a message-space from which to sample, and outputs the encryption of a sampled message x. The latter takes as input a functionality index a and returns a corresponding secret key. Note that the game records the queries made to these oracles, in order, and provides this as input to the relation R. Now let us look at the &quot;ideal world&quot; game</p>

    <p class="text-gray-300">The difficulty is that correctness is required for all x, a and thus when x = (a', m) with  <span class="math">a&#x27; \\neq a</span> , it is required that  <span class="math">\\mathsf{Dec}(dk, \\mathsf{Enc}(pk, (a&#x27;, m); r)) = \\bot</span>  when  <span class="math">dk \\in [\\mathsf{KDer}(sk, a)]</span> . This is a form of robustness as defined in [1] and, as indicated there, often useful, but it is not a standard requirement for IBE schemes and most don't meet it.</p>

    <pre><code class="language-text">PROC INITIALIZE(\\lambda):
PROC INITIALIZE(\\lambda):
                                                                                                                                   PROC INITIALIZE(\\lambda):
                                                              i, j \\leftarrow 0 \\; ; \\; St \\leftarrow \\varepsilon
                                                                                                                                   (pk, sk) \\leftarrow \\$ \\operatorname{\\mathsf{Setup}}(\\lambda) \\; ; \\; i, j \\leftarrow 0
(pk, sk) \\leftarrow s Setup(\\lambda)
                                                              z \\leftarrow s Z(\\lambda)
z \\leftarrow s Z(\\lambda)
                                                                                                                                  Return pk
                                                              Return z
i, j \\leftarrow 0; St \\leftarrow \\varepsilon
                                                                                                                                  PROC LR(x_0, x_1)
Return (pk, z)
                                                              PROC Msg(\\alpha):
                                                                                                                                  i \\leftarrow i + 1; (\\mathbf{x}_0[i], \\mathbf{x}_1[i]) \\leftarrow (x_0, x_1)
                                                              i \\leftarrow i + 1
PROC ENC(\\alpha):
                                                                                                                                  \\mathbf{c}[i] \\leftarrow \\$ \\operatorname{Enc}(pk, x_b)
                                                              \\mathbf{q}[i] \\leftarrow \\alpha \\; ; \\; \\mathbf{t}[i] \\leftarrow \\mathsf{enc}
i \\leftarrow i+1
                                                                                                                                  Return \\mathbf{c}[i]
                                                              (St, \\mathbf{x}[i]) \\leftarrow D(St, \\alpha)
\\mathbf{q}[i] \\leftarrow \\alpha \\; ; \\; \\mathbf{t}[i] \\leftarrow \\mathsf{enc}
                                                                                                                                  PROC KD(a):
                                                              Return \\mathcal{F}(\\lambda, \\varepsilon, \\mathbf{x}[i])
(St, \\mathbf{x}[i]) \\leftarrow s D(St, \\alpha)
                                                                                                                                  j \\leftarrow j + 1; \\mathbf{a}[j] \\leftarrow a
\\mathbf{c}[i] \\leftarrow \\$ \\mathsf{Enc}(pk, \\mathbf{x}[i])
                                                              PROC OP(a):
                                                                                                                                  dk \\leftarrow s \\mathsf{KDer}(sk, a)
Return (\\mathbf{c}[i], \\mathcal{F}(\\lambda, \\varepsilon, \\mathbf{x}[i]))
                                                              i \\leftarrow i + 1
                                                                                                                                  Return dk
                                                              \\mathbf{q}[i] \\leftarrow a \\; ; \\; \\mathbf{t}[i] \\leftarrow \\mathsf{kd}
PROC KD(a):
                                                                                                                                  PROC FINALIZE(b&#x27;):
                                                              Return \\varepsilon
i \\leftarrow i + 1
                                                                                                                                  \\mathbf{a}[j+1] \\leftarrow \\varepsilon
\\mathbf{q}[i] \\leftarrow a \\; ; \\; \\mathbf{t}[i] \\leftarrow \\mathsf{kd}
                                                              PROC F(a, s):
                                                                                                                                  For j&#x27; = 1, ..., j + 1 do
dk \\leftarrow * \\mathsf{KDer}(sk, a)
                                                              If a \\in \\mathsf{El}(\\mathbf{a}) and 1 \\le s \\le i then
                                                                                                                                         If \\mathcal{F}(\\lambda, \\mathbf{a}[j&#x27;], \\mathbf{x}_0) \\neq \\mathcal{F}(\\lambda, \\mathbf{a}[j&#x27;], \\mathbf{x}_1) then
Return dk
                                                                     Return \\mathcal{F}(\\lambda, a, \\mathbf{x}[s])
                                                                                                                                                return false
                                                              Else return \\perp
PROC FINALIZE(w):
                                                                                                                                  Return (b&#x27;=1)
Return R(\\lambda, z, \\mathbf{x}, \\mathbf{q}, \\mathbf{t}, St, w)
                                                             PROC FINALIZE(w):
                                                             Return R(\\lambda, z, \\mathbf{x}, \\mathbf{q}, \\mathbf{t}, St, w)
</code></pre>

    <p class="text-gray-300">Figure 1: Left: &quot;Real world&quot; game  <span class="math">RSS1_{\\mathsf{FE},\\mathcal{F},Z,D,R}</span>  for the SS1 definition. Middle: &quot;Ideal world&quot; game  <span class="math">ISS1_{\\mathcal{F},Z,D,R}</span>  for the SS1 definition. Right: game  <span class="math">IND_{\\mathsf{FE},\\mathcal{F},b}</span>  for the IND definition.</p>

    <p class="text-gray-300">with the simulator. The simulator has access to not two but three main oracles, a message sampling oracle Msg, an operation oracle OP, and a functionality oracle F. The first on input  <span class="math">\\alpha</span> , which again describes a message-space from which to sample, samples a message x but simply returns  <span class="math">\\mathcal{F}(\\lambda, \\varepsilon, x)</span> . (We follow BSW [14] in using the value under index  <span class="math">\\varepsilon</span>  to describe what information about the message is publicly computable from a ciphertext.) The second records that an input functionality index a is &quot;legal to be used&quot; by the last oracle. The last oracle takes such an index a and a position s to return  <span class="math">\\mathcal{F}(\\lambda, a, x_s)</span>  where  <span class="math">x_s</span>  is the sth sampled message by Msg. Intuitively, OP queries of the simulator correspond to KD queries of the adversary, and indeed they are input to the relation R in the analogous manner. F queries can always be made &quot;for free&quot; by the simulator (they are not input to R).</p>

    <p class="text-gray-300">DISCUSSION OF SS1. We have discussed SS1 as being the BSW [14] definition, which it is in spirit, but there are some differences in detail. BSW indicate that there are several dimensions of choice. They choose to formalize a non-adaptive version with blackbox simulators, saying that variants may be formalized similarly. We have chosen to formalize the variant with adaptive security and non-blackbox simulation. BSW give pk as input to the relation and we do not, but this choice does not matter. However, a novelty of our definition is the introduction of auxiliary inputs. Besides what is noted above in their regard, we note that our use of auxiliary inputs rescues our definitions from the weaknesses of the BSW definition pointed out in BF [4]. The issue raised by the latter arises with a functionality, such as inner-product PE [22], that depends on a parameter, such as a hard-to-factor modulus, that must be generated in a setup phase. Under BSW [14] and O'Neill [29], this would have to be done by the Setup algorithm of the FE scheme and the modulus would be part of pk. The problem raised by BF [4] then occurs because the simulator can pick pk. We, however, do not give pk as input to  <span class="math">\\mathcal{F}</span>  and would capture setup-based functionalities by having the setup done by the auxiliary input generator algorithm Z, so that the modulus, in our example, would be part of the output z of this algorithm. However, the simulator is not allowed to pick z, and thus the attack of BF [4] would not appear to apply.</p>

    <p class="text-gray-300">IND DEFINITION. Let FE = (Setup, KDer, Enc, Dec) be an  <span class="math">\\mathcal{F}</span> -FE scheme. The definition uses game</p>

    <pre><code class="language-text">PROC INITIALIZE(\\lambda):
                                                                  z \\leftarrow s Z(\\lambda)
z \\leftarrow s Z(\\lambda)
                                                                  Return z
i, j \\leftarrow 0; St \\leftarrow \\varepsilon; St \\leftarrow St
Return (pk, z)
                                                                                                                                             PROC FINALIZE(w):
PROC ENC(\\alpha):
                                                                  \\mathbf{q}[i] \\leftarrow \\alpha \\; ; \\; \\mathbf{t}[i] \\leftarrow \\mathsf{enc}
                                                                                                                                              \\mathbf{q}[j+1]
i \\leftarrow i + 1
                                                                  (St, \\mathbf{x}[i]) \\leftarrow *D(St, \\alpha)
                                                                                                                                              For j&#x27; = 1, ..., j + 1 do
\\mathbf{q}[i] \\leftarrow \\alpha \\; ; \\; \\mathbf{t}[i] \\leftarrow \\mathsf{enc}
                                                                                                                                                     If \\mathbf{t}[i&#x27;] = \\mathsf{kd} then
(St, \\mathbf{x}[i]) \\leftarrow D(St, \\alpha)
                                                                                                                                                             If \\mathcal{F}(\\lambda, \\mathbf{q}[j&#x27;], \\mathbf{x}) \\neq \\mathcal{F}(\\lambda, \\mathbf{q}[j&#x27;], \\mathbf{x}&#x27;) then
(St&#x27;, \\mathbf{x}&#x27;[i]) \\leftarrow s D(St&#x27;, \\alpha)
                                                                                                                                                                     bad \\leftarrow true
                                                                  PROC OP(a):
\\mathbf{c}[i] \\leftarrow \\operatorname{sEnc}(pk, \\mathbf{x}[i])
                                                                  i \\leftarrow i + 1
                                                                                                                                             Return R(\\lambda, z, \\mathbf{x}, \\mathbf{q}, \\mathbf{t}, St, w)
Return (\\mathbf{c}[i], \\mathcal{F}(\\lambda, \\varepsilon, \\mathbf{x}[i]))
                                                                  \\mathbf{q}[i] \\leftarrow a \\; ; \\; \\mathbf{t}[i] \\leftarrow \\mathsf{kd}
PROC KD(a):
                                                                  Return \\varepsilon
i \\leftarrow i + 1
                                                                  PROC F(a, s):
\\mathbf{q}[i] \\leftarrow a \\; ; \\; \\mathbf{t}[i] \\leftarrow \\mathsf{kd}
                                                                  If a \\in \\mathsf{El}(\\mathbf{a}) and 1 \\le s \\le i then
dk \\leftarrow \\text{\\$} \\mathsf{KDer}(sk, a)
                                                                          Return \\mathcal{F}(\\lambda, a, \\mathbf{x}[s])
Return dk
</code></pre>

    <p class="text-gray-300">Figure 2: Left: &quot;Real world&quot; game  <span class="math">RSS2_{\\mathsf{FE},\\mathcal{F},Z,D,R}</span>  for the SS2 definition. Middle: &quot;Ideal world&quot; game  <span class="math">ISS2_{\\mathcal{F},Z,D,R}</span>  for the SS2 definition. Right: FINALIZE procedure, common to the two games.</p>

    <p class="text-gray-300"><span class="math">IND_{\\mathsf{FE},\\mathcal{F},b}</span>  of Figure 1 for  <span class="math">b \\in \\{0,1\\}</span> . We say that  <span class="math">\\mathsf{FE}</span>  is IND-secure if for every adversary B,</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\mathrm{ind}}_{\\mathsf{FE},\\mathcal{F},B}(\\cdot) \\ = \\ T(\\mathrm{IND}_{\\mathsf{FE},\\mathcal{F},1},B,\\cdot) - T(\\mathrm{IND}_{\\mathsf{FE},\\mathcal{F},0},B,\\cdot)</span>$</p>

    <p class="text-gray-300">is negligible.</p>

    <p class="text-gray-300">ROBUSTNESS. Robustness, introduced for IBE and PKE in [1], seems important more generally for FE, particularly for predicate-only predicate encryption. To explain the issue, recall that correctness was mute in the case that  <span class="math">\\mathcal{F}(\\lambda, a, x) = \\bot</span> , meaning in this case no requirement was put on the output of  <span class="math">\\mathsf{Dec}(dk, \\mathsf{Enc}(pk, x))</span>  when  <span class="math">dk \\in [\\mathsf{KDer}(sk, a)]</span> . Roughly, robustness asks that  <span class="math">\\mathsf{Dec}(dk, \\mathsf{Enc}(pk, x)) = \\bot</span>  in this case. In the case of PEKS this is important to avoid false positives in the testing.</p>

    <p class="text-gray-300">The reason it is not quite so simple is that asking for the above condition globally and unconditionally seems to yield something that is hard to achieve. Instead, one can ask for various computational relaxations in the style of [1]. To exemplify, here is one that is very strong but attractive due to its simplicity: procedure Initialize( <span class="math">\\lambda</span> ) of game ROB<sub>FE,F</sub> lets  <span class="math">(pk, sk) \\leftarrow s</span>  Setup( <span class="math">\\lambda</span> ) and returns both keys, meaning the adversary gets sk. Finalize(a, x) returns  <span class="math">((\\mathcal{F}(\\lambda, a, x) = \\bot) \\land (\\mathsf{Dec}(\\mathsf{KDer}(sk, a), \\mathsf{Enc}(pk, x)) \\neq \\bot)</span> .</p>

    </section>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 Impossibility Results</h2>

    <p class="text-gray-300">We show that the SS1 notion is <em>impossible</em> to achieve in the <em>standard model</em>, so long as the functionality is reasonably likely to take more than one possible value on a challenge message. This result only assumes the existence of a collision-resistant hash function.</p>

    <p class="text-gray-300">Following [14] we also consider a relaxation of the SS1 notion where vectors  <span class="math">\\mathbf{a}</span> ,  <span class="math">\\boldsymbol{\\alpha}</span>  are replaced by unordered sets, thus giving the simulator more power (since it can make its queries in a different order than the adversary). We obtain a similar but more restrictive impossibility result in this case. Here we present the ordered case. The unordered one is in Appendix B.</p>

    <p class="text-gray-300">UNPREDICTABLE FUNCTIONALITIES. In the ordered case our result applies to any unpredictable functionality. Let  <span class="math">\\mathcal{F}</span>  be a functionality,  <span class="math">\\mathcal{A} = \\{a_{\\lambda}\\}_{{\\lambda} \\in \\mathbb{N}}</span>  be a family of functionality indices (strings), and  <span class="math">\\mathcal{X} = \\{X_{\\lambda}\\}_{{\\lambda} \\in \\mathbb{N}}</span>  be a family of payload distributions. We say that  <span class="math">\\mathcal{F}</span>  is  <span class="math">p(\\cdot)</span> -unpredictable wrt.  <span class="math">\\mathcal{A}, \\mathcal{X}</span>  if for</p>

    <pre><code class="language-text">PROC INITIALIZE(\\lambda):
z \\leftarrow s Z(\\lambda)
                                                                Return z
i, j \\leftarrow 0; St \\leftarrow \\varepsilon; St&#x27; \\leftarrow \\varepsilon
                                                                PROC Msg(\\alpha):
Return (pk, z)
PROC ENC(\\alpha):
                                                                \\mathbf{q}[i] \\leftarrow \\alpha \\; ; \\; \\mathbf{t}[i] \\leftarrow \\mathsf{enc}
i \\leftarrow i + 1
                                                                (St, \\mathbf{x}[i]) \\leftarrow D(St, \\alpha)
\\mathbf{q}[i] \\leftarrow \\alpha \\; ; \\; \\mathbf{t}[i] \\leftarrow \\mathsf{enc}
                                                                (St&#x27;, \\mathbf{x}&#x27;[i]) \\leftarrow *D(St&#x27;, \\alpha)
(St, \\mathbf{x}[i]) \\leftarrow s D(St, \\alpha)
                                                                Return \\mathcal{F}(\\lambda, \\varepsilon, \\mathbf{x}[i])
(St&#x27;, \\mathbf{x}&#x27;[i]) \\leftarrow s D(St&#x27;, \\alpha)
                                                                PROC OP(a):
\\mathbf{c}[i] \\leftarrow \\$ \\operatorname{Enc}(pk, \\mathbf{x}[i])
                                                                i \\leftarrow i + 1
Return (\\mathbf{c}[i], \\mathcal{F}(\\lambda, \\varepsilon, \\mathbf{x}[i]))
                                                                \\mathbf{q}[i] \\leftarrow a \\; ; \\; \\mathbf{t}[i] \\leftarrow \\mathsf{kd}
PROC KD(a):
                                                                Return \\varepsilon
i \\leftarrow i + 1
                                                                PROC F(a, s):
\\mathbf{q}[i] \\leftarrow a \\; ; \\; \\mathbf{t}[i] \\leftarrow \\mathsf{kd}
                                                                If a \\in \\mathsf{El}(\\mathbf{a}) and 1 \\le s \\le i then
dk \\leftarrow s \\mathsf{KDer}(sk, a)
                                                                        Return \\mathcal{F}(\\lambda, a, \\mathbf{x}[s])
Return dk
                                                                Else return \\perp
</code></pre>

    <p class="text-gray-300">PROC FINALIZE(w)</p>

    <pre><code class="language-text">|\\mathbf{q}[i+1] \\leftarrow \\varepsilon \\; ; \\; \\mathbf{t}[i+1] \\leftarrow \\mathsf{kd}
For i&#x27; = 1, ..., i + 1 and j&#x27; = i&#x27; + 1, ..., i + 1 do
       If \\mathbf{t}[i&#x27;] = \\mathsf{enc} \\ \\land \\ \\mathbf{t}[j&#x27;] = \\mathsf{kd} \\ \\mathsf{then}
               If \\mathcal{F}(\\lambda, \\mathbf{q}[j&#x27;], \\mathbf{x}[i&#x27;]) \\neq \\mathcal{F}(\\lambda, \\mathbf{q}[j&#x27;], \\mathbf{x}&#x27;[i&#x27;]) then
                       bad &larr; true
</code></pre>

    <p class="text-gray-300">Return  <span class="math">R(\\lambda, z, \\mathbf{x}, \\mathbf{q}, \\mathbf{t}, St, w)</span></p>

    <p class="text-gray-300">Figure 3: Left: &quot;Real world&quot; game  <span class="math">RSS3_{FE,\\mathcal{F},Z,D,R}</span>  for the SS3 definition. Middle: &quot;Ideal world&quot; game ISS3<sub> <span class="math">\\mathcal{F},Z,D,R</span> </sub> for the SS3 definition. Right: FINALIZE procedure, common to the two games.</p>

    <p class="text-gray-300">all  <span class="math">\\lambda \\in \\mathbb{N}</span>  and all  <span class="math">y \\in \\{0,1\\}^* \\cup \\{\\bot\\}</span> ,  <span class="math">\\Pr[x \\leftarrow X_\\lambda : y = \\mathcal{F}(\\lambda, a_\\lambda, x)] \\leq 1 - 1/p(\\lambda)</span> . For example, the functionality  <span class="math">\\mathcal{F}^{\\mathsf{P},\\mathsf{p}}_{\\mathsf{bit-ibe}}</span>  for a one-bit IBE scheme, which parses x as (a',b), and returns b if a = a' and  <span class="math">\\perp</span>  otherwise, is a 2-unpredictable function wrt.  <span class="math">\\mathcal{A}, \\mathcal{X}</span>  where, for all  <span class="math">\\lambda \\in \\mathbb{N}</span> , we let  <span class="math">a_{\\lambda}</span>  be a fixed but arbitrary identity and  <span class="math">\\mathcal{X}_{\\lambda}</span>  return  <span class="math">(a_{\\lambda}, d)</span>  where the message  <span class="math">d \\in \\{0, 1\\}</span>  is random. As another example, the functionality  <span class="math">\\mathcal{F}_{\\text{peks}}^{\\mathsf{p},\\mathsf{P}}</span>  for a PEKS scheme, which returns 1 if a=x and  <span class="math">\\perp</span>  otherwise, is a 2-unpredictable function wrt.  <span class="math">\\mathcal{A}, \\mathcal{X}</span>  where for all  <span class="math">\\lambda \\in \\mathbb{N}</span> , we again let  <span class="math">a_{\\lambda}</span>  be fixed but arbitrary keyword and  <span class="math">\\mathcal{X}_{\\lambda}</span>  return a random keyword  <span class="math">x \\in \\{a_{\\lambda}, a&#x27;_{\\lambda}\\}</span>  for some also fixed but arbitrary  <span class="math">a&#x27;_{\\lambda} \\neq a_{\\lambda}</span> . Indeed, unpredictability with respect to some family of input distributions and functionality indices is a minimal requirement for a functionality to be interesting; otherwise, it is trivial to build an FE scheme for it because anyone can decrypt correctly without even using the ciphertext. In this sense, our result below rules out an SS1-secure FE scheme for any non-trivial functionality.</p>

    <p class="text-gray-300">SECRET-KEY LENGTH. we say that an FE scheme FE = (Setup, KDer, Enc, Dec) has secret-key length  <span class="math">\\ell(\\cdot)</span> if  <span class="math">|dk| &lt; \\ell(\\lambda) = \\mathcal{F}(\\lambda, a, x)</span>  for all  <span class="math">\\lambda, a, x, r</span> , all  <span class="math">(pk, sk) \\in [\\mathsf{Setup}(\\lambda)]</span> , and all  <span class="math">dk \\in [\\mathsf{KDer}(sk, a)]</span> . Note that every FE scheme must have some polynomial  <span class="math">\\ell(\\cdot)</span>  secret-key length in order to be efficient.</p>

    <p class="text-gray-300"><strong>Theorem 4.1</strong> Let  <span class="math">p(\\cdot) &gt; 1</span>  be a polynomial. Suppose  <span class="math">\\mathcal{F}</span>  is a  <span class="math">p(\\cdot)</span> -unpredictable functionality wrt.  <span class="math">\\mathcal{A} = \\mathbf{1}</span>  <span class="math">\\{a_{\\lambda}\\}_{{\\lambda}\\in\\mathbb{N}}, \\mathcal{X}=\\{X_{\\lambda}\\}_{{\\lambda}\\in\\mathbb{N}},</span>  Furthermore, suppose that for every  <span class="math">{\\lambda}\\in N</span> ,  <span class="math">\\mathcal{F}({\\lambda},{\\varepsilon},x)</span>  is the same for all  <span class="math">x \\in [X_{\\lambda}]</span> . Let  <span class="math">\\mathcal{H} = (K, H)</span>  be a collision-resistant hash function. Then there does not exist an SS1-secure  <span class="math">\\mathcal{F}</span> -FE scheme. More precisely, suppose FE is a  <span class="math">\\mathcal{F}</span> -FE scheme with secret-key length  <span class="math">\\ell(\\cdot)</span> . Then for any function  <span class="math">\\mu(\\cdot)</span>  there exists a PT auxiliary input generator Z, message sampler D, PT adversary A, PT relation R, and CR-adversary C such that for every simulator S</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\mathrm{ss}}_{\\mathsf{FE},\\mathcal{F},A,S,Z,D,R}(\\cdot) \\geq 1 - \\sqrt{\\mathbf{Adv}^{\\mathrm{col}}_{\\mathcal{H},C}(\\cdot) + 1/\\mu(\\cdot)}</span>$</p>

    <p class="text-gray-300">Adversary A makes  <span class="math">p(\\cdot)(\\ell(\\cdot) + \\log \\mu(\\cdot))</span>  encryption queries and two key-derivation queries.</p>

    <p class="text-gray-300">To compare, BSW [14] ruled out SS1-secure IBE against adversaries with access to a non-programmable random oracle, so our result improves theirs in two respects: to applies to any non-trivial functionality and standard-model adversaries. It also reveals a trade-off between secret-key length and the total number of bits encrypted. Namely, when the difference is even one bit (i.e., the total number of bits encrypted is one</p>

    <pre><code class="language-text">Alg R(\\lambda, \\mathbf{x}, \\mathbf{a}, \\boldsymbol{\\alpha}, St, w):
Alg A(pk, hk):
                                                   (pk, \\mathbf{c}, h, f, sk_h, sk_a) \\leftarrow w
For i = 1, \\ldots, n(\\lambda) do:
                                                  If h \\neq H(hk, pk||\\mathbf{c}) then return false
      \\mathbf{c}[i] \\leftarrow s \\operatorname{Enc}(\\lambda)
                                                  If |sk_h| \\neq \\ell or |sk_a| \\neq \\ell then return false
h \\leftarrow H(hk, pk || \\mathbf{c})
                                                   If |\\alpha| \\neq n \\lor \\alpha \\neq (\\lambda, \\ldots, \\lambda) then return false
sk_h \\leftarrow s KD(h)
                                                  If |\\mathbf{a}| \\neq 2 \\lor \\mathbf{a}[1] \\neq h \\lor \\mathbf{a}[2] \\neq a_{\\lambda} then return false
sk_a \\leftarrow s KD(a_\\lambda)
                                                   If Dec(sk_a, \\mathbf{c}) \\neq \\mathcal{F}(\\lambda, a_\\lambda, \\mathbf{x}) then return false
w \\leftarrow (pk, \\mathbf{c}, h, f, sk_h, sk_a)
                                                  Return true
Return w
</code></pre>

    <p class="text-gray-300">Figure 4: Algorithms A and R for proof of Theorem 4.1.</p>

    <pre><code class="language-text">Alg S_2(\\overline{St}):
                                                                                                                                                Adversary C(\\lambda):
Alg S_1(\\lambda):
                                                                                                                                                hk \\leftarrow \\text{sInitialize}(\\lambda)
i \\leftarrow 0
z \\leftarrow \\text{$&quot;s$ Initialize}(\\lambda)
                                                                           For i = 1, \\dots, n(\\lambda) do \\mathbf{x}[i] \\leftarrow X_{\\lambda}
                                                                                                                                               Run S_1 on \\lambda,
                                                                                                                                                      replying to Initialize with hk
Run S(z):
                                                                           Run S at state St:
                                                                                                                                                Let \\overline{St} be the output of S_1
On message-query \\alpha do:
                                                                           On message-query \\alpha do:
                                                                                                                                               w^1, w^2 \\leftarrow S_2(\\overline{St})
     i \\leftarrow i + 1; Return \\overline{\\varepsilon}
                                                                                 i \\leftarrow i + 1; Return \\overline{\\varepsilon}
                                                                                                                                               \\begin{array}{l} (pk^1, \\mathbf{c}^1, h^1, f^1, sk_h^1, sk_a^1) \\leftarrow w^1 \\\\ (pk^2, \\mathbf{c}^2, h^2, f^2, sk_h^2, sk_a^2) \\leftarrow w^2 \\end{array}
On op-query a do:
                                                                           On op-query a do:
     Halt computation of S_1 with state St
                                                                                 A \\leftarrow A \\cup \\{a\\}; Return \\varepsilon
\\overline{St} \\leftarrow St || i ; \\text{ Return } \\overline{St}
                                                                           On F-query (a, s) do:
                                                                                                                                                Return (pk^1||\\mathbf{c}^1, pk^2||\\mathbf{c}^2)
                                                                                 If 1 \\le s \\le i and a \\in A do:
                                                                                 Return \\mathcal{F}(\\lambda, a, \\mathbf{x}[s])
                                                                                 Else return \\perp
                                                                          Let w be the output of S; Return w
</code></pre>

    <p class="text-gray-300">Figure 5: Algorithms  <span class="math">S_1, S_2</span>  and C for proof of Theorem 4.1.</p>

    <p class="text-gray-300">more than the secret-key length) our adversary's advantage is non-negligible. We also note that, while for technical reasons we require  <span class="math">\\mathcal{F}(\\lambda, \\varepsilon, x)</span>  to take the same value on every possible challenge payload x, this is not a major restriction in practice since typically  <span class="math">\\mathcal{F}(\\lambda, \\varepsilon, x) = |x|</span> ; then we are just requiring as usual that possible challenge messages have the same length.</p>

    <p class="text-gray-300">The proof combines and extends ideas of [14] and [5]. As in [5] will make use of a version of the Reset Lemma of [7].</p>

    <p class="text-gray-300"><strong>Lemma 4.2</strong> Let  <span class="math">P_1, P_2</span>  be algorithms, the second with boolean output. The single-execution acceptance probability  <span class="math">\\mathbf{AP}_1(P_1, P_2, \\lambda)</span>  is defined as the probability that  <span class="math">d = \\mathsf{true}</span>  in the single execution experiment  <span class="math">\\overline{St} \\leftarrow \\</span> P_1(\\lambda)$ ;  <span class="math">d \\leftarrow \\</span> P_2(\\overline{St})$ . The double-execution acceptance probability  <span class="math">\\mathbf{AP}_2(P_1, P_2, \\lambda)</span>  is defined as the probability that  <span class="math">d_1 = d_2 = \\mathsf{true}</span>  in the double execution experiment  <span class="math">\\overline{St} \\leftarrow \\</span> P_1(\\lambda)$ ;  <span class="math">d_0, d_1 \\leftarrow \\</span> P_2(\\overline{St})$ . Then  <span class="math">\\mathbf{AP}_1(P_1, P_2, \\lambda) \\leq \\sqrt{\\mathbf{AP}_2(P_1, P_2, \\lambda)}</span>  for all  <span class="math">\\lambda \\in \\mathbb{N}</span> .</p>

    <p class="text-gray-300"><strong>Proof of Theorem 4.1:</strong> For  <span class="math">\\lambda \\in \\mathbb{N}</span>  denote by  <span class="math">\\overline{\\varepsilon}_{\\lambda}</span>  the value such that  <span class="math">\\mathcal{F}(\\lambda, \\varepsilon, x) = \\overline{\\varepsilon}_{\\lambda}</span>  for all  <span class="math">x \\in [X_{\\lambda}]</span> . Let  <span class="math">n(\\cdot) = p(\\cdot)(\\ell(\\cdot) + \\log \\mu(\\cdot))</span> . Define Z on input  <span class="math">\\lambda</span>  to return  <span class="math">hk \\leftarrow K(\\lambda)</span> . Define message sampler D on inputs St,  <span class="math">\\alpha</span>  to (ignore St and) return  <span class="math">x \\leftarrow X(\\alpha)</span> . Define adversary A and relation R as in Figure 4.</p>

    <p class="text-gray-300">By construction  <span class="math">\\Pr\\left[\\mathrm{RSS}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^A(\\cdot)\\right] = 1</span> . Let S be any simulator. Wlog assume that it makes no F-query preceding its first Op-query (the response to such a query would be  <span class="math">\\bot</span> ). Furthermore, parsing the output of S as  <span class="math">(pk, \\mathbf{c}, h, f, sk_h, sk_a, hk) \\leftarrow w</span> , we assume it holds that  <span class="math">h = H(hk, pk||\\mathbf{c})</span> ,  <span class="math">|sk_h| = |sk_a| = \\ell</span> ,  <span class="math">|\\alpha| = n</span> ,  <span class="math">\\alpha = (\\lambda, \\ldots, \\lambda)</span> ,  <span class="math">|\\mathbf{a}| = 2</span> ,  <span class="math">\\mathbf{a}[1] = h</span> , and  <span class="math">\\mathbf{a}[2] = a_{\\lambda}</span> , since otherwise the relation R returns false. Towards applying Lemma 4.2, we write execution of S in Game ISS1 as a composition of two algorithms  <span class="math">S_1, S_2</span>  as in Figure 5.</p>

    <p class="text-gray-300">Namely,  <span class="math">S_1</span>  runs S up to the point that it makes its first OP query, and  <span class="math">S_2</span>  runs S following this OP query. It also samples  <span class="math">\\mathbf{x}</span>  all at once instead of defining its individual components when responding to</p>

    <p class="text-gray-300">each message query, but this is equivalent and makes the analysis more transparent. Below we justify the following sequence of inequalities, for C, Y defined below:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\text{ISS1}_{\\mathcal{F},Z,D,R}^{S}(\\cdot)\\right] = \\mathbf{AP}_{1}(S_{1}, S_{2}, \\lambda) \\leq \\sqrt{\\mathbf{AP}_{2}(S_{1}, S_{2}, \\lambda)} \\leq \\sqrt{\\mathbf{Adv}_{\\mathcal{H},C}^{\\text{col}}(\\lambda) + \\Pr\\left[\\mathcal{F}(\\lambda, a_{\\lambda}, \\mathbf{x}) \\in Y\\right]}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq \\sqrt{\\mathbf{Adv}_{\\mathcal{H},C}^{\\text{col}}(\\lambda) + 2^{\\ell}(1 - 1/p)^{n}} &lt; \\sqrt{\\mathbf{Adv}_{\\mathcal{H},C}^{\\text{col}}(\\lambda) + 2^{\\ell}2^{-(\\ell + \\log \\mu(\\lambda))}}</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\sqrt{\\mathbf{Adv}_{\\mathcal{H},C}^{\\text{col}}(\\lambda) + 1/\\mu(\\lambda)}.</span>$</p>

    <p class="text-gray-300">Above, the first inequality is by construction and the second is by Lemma 4.2. For the third, consider the CR-adversary C against  <span class="math">\\mathcal{H}</span>  also defined in Figure 5. Note that C simply mimics the double execution experiment with  <span class="math">S_1, S_2</span> . Let us also denote the two outputs of  <span class="math">S_2</span>  in that experiment as  <span class="math">w^1 = (pk^1, \\mathbf{c}^1, h^1, f^1, sk_h^1, sk_a^1)</span>  and  <span class="math">w^2 = (pk^2, \\mathbf{c}^2, h^2, f^2, sk_h^2, sk_a^2)</span> . Now, unless C finds a collision we have  <span class="math">\\mathbf{c}^1 = \\mathbf{c}^2</span> , denote by  <span class="math">\\mathbf{c}^*</span>  this common value. Then define the set  <span class="math">Y := \\{y \\in \\{0,1\\}^* : \\exists s \\in \\{0,1\\}^\\ell \\text{ s.t. Dec}(s,\\mathbf{c}^*) = y\\}</span> . If it is not the case that  <span class="math">\\mathcal{F}(\\lambda,a_\\lambda,\\mathbf{x}) \\in Y</span>  when  <span class="math">\\mathbf{x}</span>  is sampled by  <span class="math">S_2</span>  then the relation R must reject, as no  <span class="math">sk_a^2</span>  will satisfy  <span class="math">\\mathrm{Dec}(sk_a^2,\\mathbf{c}) = \\mathcal{F}(\\lambda,a_\\lambda,\\mathbf{x})</span>  (recall we assume  <span class="math">|sk_a^2| = \\ell</span>  here as otherwise R rejects), justifying the third inequality above. The fourth equality above uses the unpredictability of  <span class="math">\\mathcal{F}</span>  and a union bound. For the fifth we substitute  <span class="math">n(\\lambda) = p(\\lambda)(\\ell(\\lambda) + \\log(\\mu(\\lambda)))</span>  and use the inequality  <span class="math">(1 - 1/x)^x \\le 1/e &lt; 1/2</span>  for any real number  <span class="math">x \\ge 1</span>  (here e is Euler's constant).</p>

    </section>

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5 Equivalence for Restricted Definitions of Semantic Security</h2>

    <p class="text-gray-300">Motivated by the impossibility results of Section 4, take up the direction of providing variants of the SS definition that are <em>achievable</em>.</p>

      <h3 id="sec-5.1" class="text-xl font-semibold mt-8">5.1 SS2 and its Equivalence to IND for All Functionalities</h3>

    <p class="text-gray-300">We start by providing our SS2 definition that we show is <em>equivalent</em> to IND, thus demonstrating that the IND definition targeted in the literature is indeed equivalent to some form of semantic security.</p>

    <p class="text-gray-300">SS2 DEFINITION. Let FE = (Setup, KDer, Enc, Dec) be an  <span class="math">\\mathcal{F}</span> -FE scheme. The definition uses games  <span class="math">\\mathrm{RSS2}_{\\mathsf{FE},\\mathcal{F},Z,D,R}</span>  and  <span class="math">\\mathrm{ISS2}_{\\mathcal{F},Z,D,R}</span>  of Figure 2, with the boxed code indicating the differences from the corresponding games in Figure 1, i.e., removing the boxed code recovers the SS1 games. Let D be a message sampler and A an adversary. We say that (D,A) is SS2-valid with failure probability  <span class="math">\\nu(\\cdot)</span>  if  <span class="math">\\mathrm{Pr}\\left[\\mathrm{RSS2}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^A(\\cdot)\\right] \\leq \\nu(\\cdot)</span> . When  <span class="math">\\nu(\\cdot)</span>  is negligible we say (D,A) is SS2-valid. (Note that this probability does not depend on the relation R, so it can be anything.) We say that FE is SS2-secure if for every PT auxiliary input generator Z, every message sampler D and PT adversary A such that (D,A) is SS2-valid, and every PT relation R, there is a PT simulator S such that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\mathrm{ss2}}_{\\mathsf{FE},\\mathcal{F},A,S,Z,D,R}(\\cdot) \\ = \\ T(\\mathrm{RSS2}_{\\mathsf{FE},\\mathcal{F},Z,D,R},A,\\cdot) - T(\\mathrm{ISS2}_{\\mathcal{F},Z,D,R},S,\\cdot)</span>$</p>

    <p class="text-gray-300">is negligible. Intuitively, the definition mandates that an adversary only make key-derivation queries for functions under which any possible challenge message takes the same value. For example, for IBE this corresponds to mandating that any key-derivation query made by the adversary never makes a key-derivation query for a key that decrypts a challenge ciphertext (or decrypts it to a predictable value), which is a natural restriction. The following theorem follows from the claims below.</p>

    <p class="text-gray-300"><strong>Theorem 5.1</strong> Let  <span class="math">\\mathcal{F}</span>  be a functionality and let FE = (Setup, KDer, Enc, Dec) be an  <span class="math">\\mathcal{F}</span> -FE scheme. Then FE is SS2-secure if and only if it is IND-secure.</p>

    <p class="text-gray-300">Claim 5.2 (SS2  <span class="math">\\Rightarrow</span>  IND) Let B be an IND-adversary. Then there is a message sampler D, relation R, and adversary A such that for every simulator S</p>

    <p class="text-gray-300">
<span class="math">$\\mathbf{Adv}^{\\mathrm{ind}}_{\\mathsf{FE},\\mathcal{F},B}(\\cdot) \\leq 2 \\cdot \\mathbf{Adv}^{\\mathrm{ss2}}_{\\mathsf{FE},\\mathcal{F},A,S,Z,D,R}(\\cdot)</span>$
(1)</p>

    <pre><code class="language-text">Alg R(1^k, \\mathbf{x}, \\mathbf{a}, \\boldsymbol{\\alpha}, St, w):
Alg D(St, \\alpha):
                                                   Alg A(pk):
If St = \\varepsilon then St \\leftarrow \\$\\{0, 1\\}
                                                                                                                        \\mathbf{x}_0 \\| \\mathbf{x}_1 \\leftarrow \\boldsymbol{\\alpha}
                                                   Run B(pk):
                                                                                                                        \\mathbf{a}[|\\mathbf{a}|+1] \\leftarrow \\varepsilon
x_0 || x_1 \\leftarrow \\alpha
                                                         On left-or-right query (x_0, x_1):
Return (St, x_{St})
                                                                                                                        For j = 1, ..., |\\mathbf{a}| + 1 do
                                                               c \\leftarrow s \\operatorname{Enc}(x_0 || x_1)
                                                                                                                               If \\mathcal{F}(1^k, \\mathbf{a}[j], \\mathbf{x}_0) \\neq \\mathcal{F}(1^k, \\mathbf{a}[j], \\mathbf{x}_1)
                                                               Return c
                                                                                                                                     then return false
                                                          On query key-derivation query a:
                                                                                                                        Return (\\mathbf{x} = \\mathbf{x}_w)
                                                               dk \\leftarrow s KD(a)
                                                               Return dk
                                                   Let b&#x27; be the output of A
                                                   Return b&#x27;
</code></pre>

    <p class="text-gray-300">Figure 6: Algorithms for proof of Claim 5.2.</p>

    <p class="text-gray-300">Furthermore, (D, A) is SS2-valid and the running-time of D, R, A is that of B.</p>

    <p class="text-gray-300"><strong>Proof:</strong> Define the message sampler D, adversary A, and relation R as in Figure 6. Then by construction  <span class="math">T(\\text{RSS2}_{\\mathsf{FE},\\mathcal{F},Z,D,R},A,\\cdot) = T(\\text{IND}_{\\mathsf{FE},\\mathcal{F}},B,\\cdot)</span> . Moreover, we claim that for every simulator S we have  <span class="math">T(\\text{ISS2}_{\\mathcal{F},Z,D,R,S},\\cdot) \\leq 1/2</span> . This is because we can assume wlog that S's queries are such that  <span class="math">\\mathcal{F}(1^k,a,\\mathbf{x}_0) = \\mathcal{F}(1^k,a,\\mathbf{x}_1)</span>  for all  <span class="math">\\mathsf{El}(a) \\in \\mathbf{a} \\cup \\varepsilon</span>  (since otherwise R returns false), so S gets no information about the bit b. Subtracting, we get</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}_{\\mathsf{FE},\\mathcal{F},A,S,Z,D,R}^{\\mathrm{ss2}}(\\cdot) = T(\\mathrm{RSS2}_{\\mathsf{FE},\\mathcal{F},Z,D,R},A,\\cdot) - T(\\mathrm{ISS2}_{\\mathcal{F},Z,D,R},S,\\cdot) \\ge T(\\mathrm{IND}_{\\mathsf{FE},\\mathcal{F}},B,\\cdot) - 1/2</span>$
<span class="math">$= 1/2 \\cdot \\mathbf{Adv}_{\\mathsf{FE},\\mathcal{F},B}^{\\mathrm{ind}}(\\cdot)</span>$</p>

    <p class="text-gray-300">which implies Equation (1). To complete the proof we note that (D, A) is SS2-valid because we may assume wlog that B's queries are such that  <span class="math">\\mathcal{F}(1^k, a, \\mathbf{x}_0) = \\mathcal{F}(1^k, a, \\mathbf{x}_1)</span>  for all  <span class="math">a \\in \\mathsf{El}(\\mathbf{a}) \\cup \\varepsilon</span>  (otherwise its advantage can only go down).</p>

    <p class="text-gray-300">Claim 5.3 (IND  <span class="math">\\Rightarrow</span>  SS2) Let D be a message sampler, A be an SS2-adversary, and R be a relation such that (D,A) is SS2-valid with failure probability  <span class="math">\\nu(\\cdot)</span> . Then there is a simulator S and an IND-adversary B such that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\mathrm{ss2}}_{\\mathsf{FE},\\mathcal{F},A,S,Z,D,R}(\\cdot) \\ \\leq \\ \\mathbf{Adv}^{\\mathrm{ind}}_{\\mathsf{FE},\\mathcal{F},B}(\\cdot) + 2\\nu(\\cdot) \\ .</span>$</p>

    <p class="text-gray-300">The running-time of S is that of D, R, A and the running-time of B is at most twice that of R, A plus twice that of D.</p>

    <p class="text-gray-300"><strong>Proof:</strong> Define S and B as in Figure 7. Without affecting the output of the game, we may have the Finalize procedure of Game  <span class="math">\\text{IND}_{\\mathsf{FE},\\mathcal{F},0}^B(\\cdot)</span>  set a flag bad when the &quot;return false&quot; statement is executed. Then, viewing Games  <span class="math">\\text{IND}_{\\mathsf{FE},\\mathcal{F},0}^B(\\cdot)</span>  and  <span class="math">\\text{RSS2}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^A(\\cdot)</span>  as executed over a common finite space of coins, we have that in the language of [8] they are identical-until-bad. Therefore, by the Fundamental Lemma of [8]</p>

    <p class="text-gray-300"><span class="math">$T(\\mathrm{RSS2}_{\\mathsf{FE},\\mathcal{F},Z,D,R},A,\\cdot) \\leq T(\\mathrm{IND}_{\\mathsf{FE},\\mathcal{F},1},B,\\cdot) + \\Pr\\left[\\,\\mathrm{RSS2}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^A(\\cdot) \\text{ sets bad}\\,\\right]\\,.</span>$</p>

    <p class="text-gray-300">By an analogous argument</p>

    <p class="text-gray-300"><span class="math">$T(\\mathrm{ISS2}_{\\mathcal{F},Z,D,R},S,\\cdot) \\geq T(\\mathrm{IND}_{\\mathsf{FE},\\mathcal{F},0},B,\\cdot) - \\Pr\\left[\\,\\mathrm{ISS2}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^S(\\cdot) \\text{ sets bad}\\,\\right]\\,.</span>$</p>

    <p class="text-gray-300">Subtracting yields Equation (5.3).</p>

    <p class="text-gray-300">It is worth pointing out in the proof of the second claim above that the constructed simulator S needs not ever query its oracles. This is because we are guaranteed that, since (D, A) is SS2-valid, the &quot;dummy&quot; messages sampled independently from the challenge ones have the same value under any function queried by A to its key-derivation oracle.</p>

    <pre><code class="language-text">Alg S(1^k):
                                                      Alg B(pk):
St \\leftarrow \\varepsilon
                                                      i, j \\leftarrow 0
(pk, sk) \\leftarrow s \\mathsf{Setup}(1^k)
                                                       St_0, St_1 \\leftarrow \\varepsilon
                                                      Run A(pk):
Run A(pk):
                                                            On encryption query \\alpha:
     On encryption query \\alpha:
           y \\leftarrow s \\operatorname{Msg}(\\alpha)
                                                                  i \\leftarrow i + 1; \\alpha[i] \\leftarrow \\alpha
           (St, x) \\leftarrow D(St, \\alpha)
                                                                  (St_0, \\mathbf{x}_0[i]) \\leftarrow D(St_0, \\alpha)
                                                                  (St_1, \\mathbf{x}_1[i]) \\leftarrow s D(St_1, \\alpha)
           c \\leftarrow s \\operatorname{Enc}(pk, x)
           Return (c, y)
                                                                  Return LR(\\mathbf{x}_0[i], \\mathbf{x}_1[i])
                                                            On key-derivation query a:
     On key-derivation query a:
                                                                  j \\leftarrow j + 1; \\mathbf{a}[j] \\leftarrow a
           dk \\leftarrow s \\mathsf{KDer}(sk, a)
           Return dk
                                                                  dk \\leftarrow \\$ KD(a)
                                                                 Return dk
Let w be the output of A
                                                      Let w be the output of A
Return w
                                                      Return R(1^k, \\mathbf{x}_1, \\mathbf{a}, \\boldsymbol{\\alpha}, St_1, w)
</code></pre>

    <p class="text-gray-300">Figure 7: Algorithms for proof of Claim 5.3.</p>

      <h3 id="sec-5.2" class="text-xl font-semibold mt-8">5.2 SS3 and its Equivalence to IND for Resampleable Functionalities</h3>

    <p class="text-gray-300">The SS2 definition is not as strong as one would like because for some functionalities IND (which we showed equivalent to SS2) is a &quot;bad&quot; definition. To address this we now introduce the SS3 definition, which strengthens SS2 by dropping the restriction put by SS2 on key-derivation queries made by an adversary before seeing a challenge ciphertext. Indeed, we believe the SS3 definition is an essentially asstrong-as-possible security definition for FE subject to the constraint that it be achievable without any unnatural restrictions on the adversary or message space. To see why, note the definition of &quot;unpredictable functionalities&quot; used for our impossibility result in Section 4 and the fact that the latter crucially uses the adversary's ability to make &quot;adaptive&quot; key-derivation queries&mdash;i.e., depending on a challenge ciphertext. In some sense, the SS3 definition demands that the functionality restricted to the adversary's adaptive key derivation queries be predictable wrt. the message space.</p>

    <p class="text-gray-300">SS3 DEFINITION. Let FE = (Setup, KDer, Enc, Dec) be an  <span class="math">\\mathcal{F}</span> -FE scheme. The definition uses games  <span class="math">\\mathrm{RSS3_{FE}}, \\mathcal{F}, \\mathcal{Z}, \\mathcal{D}, \\mathcal{R}</span>  and  <span class="math">\\mathrm{ISS3_{\\mathcal{F}}}, \\mathcal{Z}, \\mathcal{D}, \\mathcal{R}</span>  of Figure 3, with the boxed code indicating the differences from the corresponding games in Figure 2, i.e., the games differ from SS2 only in the Finalize procedure. Let D be a message sampler and A an adversary. We say that (D,A) is SS3-valid with failure probability  <span class="math">\\nu(\\cdot)</span>  if  <span class="math">\\Pr\\left[\\mathrm{RSS3_{FE}^{A}}, \\mathcal{F}, \\mathcal{Z}, \\mathcal{D}, \\mathcal{R}(\\cdot) \\text{ sets bad}\\right] \\leq \\nu(\\cdot)</span> . When  <span class="math">\\nu(\\cdot)</span>  is negligible we say (D,A) is SS3-valid. (Note that this probability does not depend on the relation R, so it can be arbitrary.) We say that FE is SS3-secure if for every PT auxiliary input generator Z, every message sampler D and PT adversary A such that (D,A) is valid, and every PT relation R, there is a PT simulator S such that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}_{\\mathsf{FE},\\mathcal{F},A,S,Z,D,R}^{\\mathrm{ss3}}(\\cdot) \\ = \\ T(\\mathrm{RSS3}_{\\mathsf{FE},\\mathcal{F},Z,D,R},A,\\cdot) - T(\\mathrm{ISS3}_{\\mathcal{F},Z,D,R},S,\\cdot)</span>$</p>

    <p class="text-gray-300">is negligible.</p>

    <p class="text-gray-300">RESAMPLEABILITY. Let  <span class="math">\\mathcal{F}</span>  be a functionality,  <span class="math">\\overline{D}</span> , D be algorithms. For an adversary B we let</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\mathrm{rs}}_{\\overline{D},D,\\mathcal{F},B}(\\cdot) \\ = \\ T(\\mathrm{Rsmp}_{\\overline{D},D,\\mathcal{F},1},B,\\cdot) - T(\\mathrm{Rsmp}_{\\overline{D},D,\\mathcal{F},0},B,\\cdot)</span>$</p>

    <p class="text-gray-300">where the game is in Figure 10. Furthermore, let  <span class="math">\\mathbf{Adv}_{\\overline{D},D,\\mathcal{F}}^{\\mathrm{rs}}(\\cdot) = \\max_{B} \\{\\mathbf{Adv}_{\\overline{D},D,\\mathcal{F},B}^{\\mathrm{rs}}(\\cdot)\\}</span>  where the maximum is over all PT B making one challenge query.</p>

    <p class="text-gray-300">We say that an algorithm  <span class="math">\\overline{D}</span>  is a  <span class="math">\\mu(\\cdot)</span> -accurate resampler for  <span class="math">\\mathcal F</span>  relative to algorithm D if  <span class="math">\\mathbf{Adv}^{\\mathrm{rs}}_{\\overline{D},D,\\mathcal F}(\\cdot) \\leq \\mu(\\cdot)</span> . We say that  <span class="math">\\mathcal F</span>  is  <span class="math">\\mu(\\cdot)</span> -accurately reampleable if for all PPT D there exists a PPT  <span class="math">\\overline{D}</span>  such that  <span class="math">\\overline{D}</span>  is a  <span class="math">\\mu(\\cdot)</span> -accurate resampler for  <span class="math">\\mathcal F</span>  relative to D. When  <span class="math">\\mu(\\cdot)</span>  is negligible we say that  <span class="math">\\mathcal F</span>  is accurately resampleable.</p>

    <p class="text-gray-300">THE EQUIVALENCE. The following says that the SS3 notion is equivalent to IND for any accurately</p>

    <p class="text-gray-300">resampleable functionality  <span class="math">\\mathcal{F}</span> .</p>

    <p class="text-gray-300"><strong>Theorem 5.4</strong> Let  <span class="math">\\mathcal{F}</span>  be an accurately resampleable functionality and let FE = (Setup, KDer, Enc, Dec) be an  <span class="math">\\mathcal{F}</span> -FE scheme. Then FE is SS3-secure if and only if it is IND-secure.</p>

    <p class="text-gray-300">Since SS3 is clearly stronger than SS2, it is immediate from Claim 5.2 that SS3 implies IND. Below we show the converse, which proves the theorem.</p>

    <p class="text-gray-300">Claim 5.5 (IND  <span class="math">\\Rightarrow</span>  SS3) Let D be a message sampler, A be an SS2-adversary making at most  <span class="math">q_e</span>  encryption queries, and R be a relation such that (D,A) is SS3-valid with failure probability  <span class="math">\\nu(\\cdot)</span> . Suppose  <span class="math">\\mathcal{F}</span>  is  <span class="math">\\mu(\\cdot)</span> -accurately resampleable, and let  <span class="math">\\overline{D}</span>  denote the corresponding  <span class="math">\\mu(\\cdot)</span> -accurate resampler. Then there is a simulator S and an IND-adversary B such that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\mathrm{ss3}}_{\\mathsf{FE},\\mathcal{F},A,S,Z,D,R}(\\cdot) \\ \\leq \\ \\mathbf{Adv}^{\\mathrm{ind}}_{\\mathsf{FE},\\mathcal{F},B}(\\cdot) + 2\\nu(\\cdot) + 2q_e\\mu(\\cdot) \\ .</span>$</p>

    <p class="text-gray-300">The running-time of S is that of D, R, A and the running-time of B is at most twice that of R, A plus the time for  <span class="math">q_e</span>  executions of  <span class="math">\\overline{D}</span> .</p>

    <h4 id="sec-misc-1" class="text-lg font-semibold mt-6"><strong>Proof:</strong></h4>

    <p class="text-gray-300">Define S and B as in Figure 9. Furthermore, define hybrid games RSS3-H1<sub>FE, <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{Z}</span> , <span class="math">\\mathcal{D}</span> , <span class="math">\\mathcal{R}</span>  and RSS3-H2<sub>FE, <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{Z}</span> , <span class="math">\\mathcal{D}</span> , <span class="math">\\mathcal{R}</span>  as in Figure 8. Below we justify the following sequence of inequalities:</sub></sub></p>

    <p class="text-gray-300"><span class="math">$\\begin{split} T(\\mathrm{RSS3_{FE},}_{\\mathcal{F},Z,D,R},A,\\cdot) &amp; \\leq &amp; T(\\mathrm{RSS3-H1_{FE},}_{\\mathcal{F},Z,D,R},A,\\cdot) + \\Pr\\left[\\mathrm{RSS3_{FE},}_{\\mathcal{F},Z,D,R}(\\cdot) \\text{ sets bad}_1\\right] \\\\ &amp; \\leq &amp; T(\\mathrm{RSS3-H2_{FE},}_{\\mathcal{F},Z,D,R},A,\\cdot) + \\Pr\\left[\\mathrm{RSS3-H1_{FE}^{A},}_{\\mathcal{F},Z,D,R}(\\cdot) \\text{ sets bad}_2\\right] \\\\ &amp; &amp; + \\Pr\\left[\\mathrm{RSS3_{FE},}_{\\mathcal{F},Z,D,R}(\\cdot) \\text{ sets bad}_1\\right] \\\\ &amp; = &amp; T(\\mathrm{IND_{FE},}_{\\mathcal{F},1},B,\\cdot) + \\Pr\\left[\\mathrm{RSS3-H1_{FE}^{A},}_{\\mathcal{F},Z,D,R}(\\cdot) \\text{ sets bad}\\right] \\\\ &amp; &amp; + \\Pr\\left[\\mathrm{RSS3_{FE},}_{\\mathcal{F},Z,D,R}(\\cdot) \\text{ sets bad}_1\\right] \\\\ &amp; \\leq &amp; T(\\mathrm{IND_{FE},}_{\\mathcal{F},1},B,\\cdot) + \\Pr\\left[\\mathrm{RSS3-H1_{FE}^{A},}_{\\mathcal{F},Z,D,R}(\\cdot) \\text{ sets bad}_2\\right] + \\nu(\\cdot) \\\\ &amp; \\leq &amp; T(\\mathrm{IND_{FE},}_{\\mathcal{F},1},B,\\cdot) + q_e(\\cdot)\\mu(\\cdot) + \\nu(\\cdot) \\;. \\end{split}</span>$</p>

    <p class="text-gray-300">Above, the first two inequalities are by the Fundamental Lemma of [8] (by a slight abuse of notation we identify bad in RSS3<sub>FE, <span class="math">\\mathcal{F}</span> ,Z,D,R with bad<sub>1</sub> in RSS3-H1<sub>FE, <span class="math">\\mathcal{F}</span> ,Z,D,R, and third equality is by construction. The fourth uses the assumption that (D,A) is SS3-valid with failure probability  <span class="math">\\nu(\\cdot)</span> .</sub></sub></p>

    <p class="text-gray-300">Finally, the last inequality follows by considering a run of Games  <span class="math">\\operatorname{Rsmp}_{\\overline{D},D,\\mathcal{F},b}^{B^*}(\\lambda)</span>  for  <span class="math">b \\in \\{0,1\\}</span>  and  <span class="math">B^*</span>  given in Figure 9, and of Game RSS3- <span class="math">\\operatorname{H1}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^A(\\lambda)</span>  over some fixed coin sequence drawn from a common finite set of coins, but not including the coins used to draw  <span class="math">i^*</span>  in RSS3- <span class="math">\\operatorname{H1}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^A(\\lambda)</span> . Suppose bad is set by the latter for the <em>first</em> time (i.e., changed from false to true) on the q-th query to ENC made by A when executed by RSS3- <span class="math">\\operatorname{H1}_{\\mathsf{FE},\\mathcal{F},Z,D,R}</span>  using these coins. Then with probability  <span class="math">1/q_e</span>  in the execution of  <span class="math">\\operatorname{Rsmp}_{\\overline{D},D,\\mathcal{F},b}^{B^*}(\\lambda)</span>  it will be the case that  <span class="math">i^*=q</span> . In this case  <span class="math">\\operatorname{Rsmp}_{\\overline{D},D,\\mathcal{F},b}^{B^*}(\\cdot)</span>  outputs 1 just when b=1. Using the assumption that  <span class="math">\\mathcal{F}</span>  is  <span class="math">\\mu(\\cdot)</span> -accurately resampleable and re-arranging yields the last inequality above.</p>

    <p class="text-gray-300">A symmetric sequence of inequalities to the above yields</p>

    <p class="text-gray-300"><span class="math">$T(\\mathrm{ISS2}_{\\mathcal{F},Z,D,R},S,\\cdot) \\quad \\geq \\quad T(\\mathrm{IND}_{\\mathsf{FE},\\mathcal{F},0},B,\\cdot) - \\nu(\\cdot) - q_e\\mu(\\cdot) \\; .</span>$</p>

    <p class="text-gray-300">Re-arranging and subtracting yields Equation (5.5).</p>

    <pre><code class="language-text">PROC INITIALIZE(\\lambda):
(pk, sk) \\leftarrow \\$ \\mathsf{Setup}(\\lambda)
i, j \\leftarrow 0; St \\leftarrow \\varepsilon; Return (pk, z)
PROC ENC(\\alpha):
                                                                                               PROC FINALIZE(w):
                                                                                               \\overline{\\mathbf{q}[i+1]} \\leftarrow \\varepsilon \\; ; \\; \\mathbf{t}[i+1] \\leftarrow \\mathsf{kd}
\\mathbf{q}[i] \\leftarrow \\alpha \\; ; \\; \\mathbf{t}[i] \\leftarrow \\mathsf{enc}
                                                                                               For i&#x27; = 1, ..., i + 1 and j&#x27; = i&#x27; + 1, ..., i + 1 do
(St, \\mathbf{x}[i]) \\leftarrow D(St, \\alpha)
                                                                                                      If \\mathbf{t}[i&#x27;] = \\text{enc } \\wedge \\mathbf{t}[j&#x27;] = \\text{kd then}
For j&#x27; = 1 to j do:
                                                                                                              If \\mathcal{F}(\\lambda, \\mathbf{q}[j&#x27;], \\mathbf{x}[i&#x27;]) \\neq \\mathcal{F}(\\lambda, \\mathbf{q}[j&#x27;], \\mathbf{x}&#x27;[i&#x27;]) then
       \\mathbf{f}[j&#x27;] \\leftarrow \\mathrm{F}(\\mathbf{a}[j&#x27;], i)
                                                                                                                      \\mathsf{bad}_1 \\leftarrow \\mathsf{true}; Return false
       (St, \\mathbf{x}[i]) \\leftarrow s D(\\lambda, St, \\alpha, \\mathbf{a}, \\mathbf{f})
                                                                                               If bad_2 = true then
If \\mathsf{Test}(\\lambda, \\mathbf{x}[i], \\mathbf{a}, \\mathbf{f}) = 0 then \\mathsf{bad}_2 \\leftarrow \\mathsf{true}
                                                                                                             Return false
\\mathbf{c}[i] \\leftarrow \\mathbf{s} \\, \\mathsf{Enc}(pk, \\mathbf{x}[i])
                                                                                               Else return R(\\lambda, z, \\mathbf{x}, \\mathbf{q}, \\mathbf{t}, St, w)
Return (\\mathbf{c}[i], \\mathcal{F}(\\lambda, \\varepsilon, \\mathbf{x}[i]))
PROC KD(a):
\\mathbf{q}[i] \\leftarrow a \\; ; \\; \\mathbf{t}[i] \\leftarrow \\mathsf{kd}
dk \\leftarrow s \\mathsf{KDer}(sk, a)
Return dk
</code></pre>

    <p class="text-gray-300">Figure 8: Hybrid games RSS3-H2<sub>FE, <span class="math">\\mathcal{F}</span> ,Z,D,R and RSS3-H2<sub>FE, <span class="math">\\mathcal{F}</span> ,Z,D,R for the proof of Claim 5.5. The latter includes the boxed code while in the former it is removed.</sub></sub></p>

      <h3 id="sec-5.3" class="text-xl font-semibold mt-8">5.3 Resampleability of Some Functionalities</h3>

    <p class="text-gray-300">We show resampleability of the following type of functionality.</p>

    <p class="text-gray-300">FUNCTIONALITIES WITH POLYNOMIAL-SIZE RANGE. Let  <span class="math">\\mathcal{F}</span>  be a functionality. We say that  <span class="math">\\mathcal{F}</span>  has polynomial-size range if there is a polynomial  <span class="math">w(\\cdot)</span>  such that  <span class="math">\\mathcal{F}(\\lambda, \\mathbf{a}, x) \\in F_{\\lambda}</span>  for all  <span class="math">\\lambda \\in \\mathbb{N}</span> ,  <span class="math">x \\in \\{0, 1\\}^*</span>  and  <span class="math">\\mathbf{a} \\in (\\{0, 1\\}^*)^*</span>  where  <span class="math">F_{\\lambda} = \\{\\mathbf{f}_1, \\mathbf{f}_2, \\dots, \\mathbf{f}_{w(\\cdot)}\\}</span> .</p>

    <p class="text-gray-300">EXAMPLES AND DISCUSSION. An example of a functionality with polynomial-size range is PEKS [12] with a polynomial number of keywords. Although as shown by [12] this can be constructed from any IND-CPA public-key encryption scheme, the construction is inefficient for large polynomials, and more efficient constructions may be of interest to practitioners. These would be SS3 secure by our results.</p>

    <p class="text-gray-300">We compare our notion of resampleability to that of preimage sampleability defined by O'Neill [29]. Our notion of resampleability appears to be much more restrictive, in the sense that showing it requires sampling a preimage that lies in the message space of the adversary rather than an arbitrary preimage. Since in general we cannot hope to &quot;reverse engineer&quot; the adversary's message space, it is unclear what we can do with it besides sample it in a black-box way. Indeed, the proof of our result does this and does not exploit any properties of the functionality itself as in [29], who showed that most functionalities considered in the literature have preimage sampleability. On the other hand, we show how to achieve a much stronger security definition than [29] who considered only non-adaptive security, meaning the adversary makes no key-derivation queries after seeing the challenge ciphertext.</p>

    <p class="text-gray-300"><strong>Proposition 5.6</strong> Let  <span class="math">\\mathcal{F}</span>  be a functionality with polynomial-size range. Then  <span class="math">\\mathcal{F}</span>  is accurately resampleable. More precisely, for any PPT D there is a PPT  <span class="math">\\overline{D}</span>  such that for every  <span class="math">\\lambda \\in \\mathbb{N}</span></p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}_{\\overline{D},D,\\mathcal{F}}^{\\mathrm{rs}}(\\lambda) \\leq \\frac{1}{2^{\\lambda}}</span>$
.</p>

    <p class="text-gray-300">Furthermore, the running-time of  <span class="math">\\overline{D}</span>  is that for at most  <span class="math">\\lambda w(\\lambda)</span>  executions of D.</p>

    <p class="text-gray-300">The proof will use the following mathematical lemma.</p>

    <pre><code class="language-text">Alg B^*(\\lambda):
Alg S(1^k):
                                                                  Alg B(pk):
                                                                                                                                             i, j \\leftarrow 0
i, j \\leftarrow 0
                                                                 i, j \\leftarrow 0
                                                                                                                                             St \\leftarrow \\varepsilon
St \\leftarrow \\varepsilon
                                                                 St_0, St_1 \\leftarrow \\varepsilon
                                                                                                                                             (pk, sk) \\leftarrow s \\mathsf{Setup}(\\lambda)
(pk, sk) \\leftarrow s \\mathsf{Setup}(1^k)
                                                                 Run A(pk):
                                                                                                                                             Run A(pk):
Run A(pk):
                                                                        On encryption query \\alpha:
                                                                                                                                                   On encryption query \\alpha:
      On encryption query \\alpha:
                                                                              i \\leftarrow i + 1 ; \\alpha[i] \\leftarrow \\alpha
                                                                                                                                                          i \\leftarrow i + 1 ; \\alpha[i] \\leftarrow \\alpha
            i \\leftarrow i + 1 ; \\alpha[i] \\leftarrow \\alpha
                                                                               (St_0, \\mathbf{x}_0[i]) \\leftarrow D(St_0, \\alpha)
                                                                                                                                                          For j&#x27; = 1 to j do:
            For j&#x27; = 1 to j do:
                                                                              For j&#x27; = 1 to j do:
                                                                                                                                                                \\mathbf{f}[j&#x27;] \\leftarrow \\mathrm{F}(\\mathbf{a}[j&#x27;], i)
                                                                                     \\mathbf{f}[j&#x27;] \\leftarrow \\mathcal{F}(\\lambda, \\mathbf{a}[j&#x27;], \\mathbf{x}_0[i])
                   \\mathbf{f}[j&#x27;] \\leftarrow \\mathrm{F}(\\mathbf{a}[j&#x27;], i)
                                                                                                                                                          If i = i^* then
            (St, x) \\leftarrow \\overline{D}(\\lambda, St, \\alpha, \\mathbf{a}, \\mathbf{f})
                                                                               (St_1, \\mathbf{x}_1[i]) \\leftarrow \\overline{D}(\\lambda, St_1, \\alpha, \\mathbf{a}, \\mathbf{f})
                                                                                                                                                                (St, x) \\leftarrow s \\text{ CHALLENGE}(St, \\alpha, \\mathbf{a})
                                                                              Return LR(\\mathbf{x}_0[i], \\mathbf{x}_1[i])
            c \\leftarrow s \\operatorname{Enc}(pk, x)
                                                                                                                                                                Halt execution of A
            Return c, y
                                                                        On key-derivation query a:
                                                                                                                                                          (St, x) \\leftarrow s \\overline{D}(\\lambda, St, \\alpha, \\mathbf{a}, \\mathbf{f})
      On key-derivation query a:
                                                                              j \\leftarrow j + 1; \\mathbf{a}[j] \\leftarrow a
                                                                                                                                                          c \\leftarrow \\operatorname{sEnc}(pk, x)
            j \\leftarrow j + 1; \\mathbf{a}[j] \\leftarrow a
                                                                              Return KD(a)
                                                                                                                                                          Return c, y
            OP(a)
                                                                 Let w be the output of A
                                                                                                                                                   On key-derivation query a:
                                                                 Return R(1^k, \\mathbf{x}_1, \\mathbf{a}, \\boldsymbol{\\alpha}, St, w)
            Return \\mathsf{KDer}(sk, a)
                                                                                                                                                          j \\leftarrow j + 1; \\mathbf{a}[j] \\leftarrow a
Let w be the output of A
                                                                                                                                                          Return \\mathsf{KDer}(sk, a)
Return R(1^k, \\mathbf{x}, \\mathbf{a}, \\boldsymbol{\\alpha}, St, w)
                                                                                                                                            Return \\mathsf{Test}(\\lambda, x, \\mathbf{a}, \\mathbf{f})
</code></pre>

    <p class="text-gray-300">Figure 9: Algorithms for proof of Claim 5.5.</p>

    <p class="text-gray-300"><strong>Lemma 5.7</strong> Fix integers  <span class="math">n, k \\ge 1</span> . For  <span class="math">\\mathbf{x} \\in \\mathbb{R}^n</span>  define the function  <span class="math">f(\\mathbf{x}) = \\sum_{i=1}^n x_i (1 - x_i)^k</span> . Subject to constraints  <span class="math">\\sum_{i=1}^n x_i = 1</span>  and  <span class="math">0 \\le x_i \\le 1</span>  for all  <span class="math">1 \\le i \\le n</span> ,  <span class="math">f(\\cdot)</span>  is maximum at  <span class="math">x_1 = \\ldots = x_n = 1/n</span> .</p>

    <p class="text-gray-300"><strong>Proof:</strong> (Of Lemma 5.7) We use a change of variables: let  <span class="math">y_i = (1 - x_i)</span>  for all  <span class="math">1 \\le i \\le n</span> . Then we equivalently seek to maximize</p>

    <p class="text-gray-300"><span class="math">$f&#x27;(\\mathbf{y}) = \\sum_{i=1}^{n} (1 - y_i) y_i^k</span>$</p>

    <p class="text-gray-300">subject to  <span class="math">\\sum_{i=1}^{n} y_i = n-1</span>  and  <span class="math">0 \\le y_i \\le 1</span>  for all  <span class="math">1 \\le i \\le n</span> . Now use Lagrange multipliers: we seek a constant  <span class="math">\\lambda</span>  such that</p>

    <p class="text-gray-300">
<span class="math">$\\nabla f&#x27; = \\lambda \\nabla g \\tag{2}</span>$</p>

    <p class="text-gray-300">where  <span class="math">g(\\mathbf{x}) = \\sum_{i=1}^{n} y_i</span> . Fix any  <span class="math">1 \\le i \\le n</span> . Since</p>

    <p class="text-gray-300"><span class="math">$\\frac{\\partial f&#x27;}{\\partial y_i} = 1 - (k+1)y_i^k</span>$
and  <span class="math">\\frac{\\partial g}{\\partial y_i} = 1</span></p>

    <p class="text-gray-300">by Equation (2) we have</p>

    <p class="text-gray-300">
<span class="math">$1 - (k+1)y_i^k = \\lambda \\implies y_i = \\left(\\frac{1-\\lambda}{k+1}\\right)^{1/k} . \\tag{3}</span>$</p>

    <p class="text-gray-300">Using the constraint  <span class="math">\\sum_{i=1}^{n} y_i = n-1</span>  we have</p>

    <p class="text-gray-300"><span class="math">$n\\left(\\frac{1-\\lambda}{k+1}\\right)^{1/k} = n-1 \\implies \\lambda = 1 - (k+1)\\left(1 - \\frac{1}{n}\\right)^k.</span>$</p>

    <p class="text-gray-300">Substituting this into Equation (3) we get  <span class="math">y_i = 1 - 1/n</span>  and so  <span class="math">x_i = -(y_i - 1) = 1/n</span>  as desired. Note that this must be a maximum (rather than minimum) since f vanishes when  <span class="math">x_i = 1</span>  for some i.</p>

    <p class="text-gray-300">We now prove the proposition.</p>

    <p class="text-gray-300"><strong>Proof:</strong> (Of Proposition 5.6) Given any D, define the corresponding resampler  <span class="math">\\overline{D}</span>  as follows:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathbf{Alg} \\ \\overline{D}(\\lambda, St, \\alpha, \\mathbf{a}, \\mathbf{f}) \\colon \\\\ \\text{For } i &amp;= 1 \\text{ to } \\lambda w(\\lambda) \\text{ do: } \\\\ x&#x27; &amp;\\leftarrow \\mbox{\\</span>} D(St, \\alpha) \\ \\text{If } \\mathsf{Test}(\\lambda, x', \\mathbf{a}, \\mathbf{f}) = 1 \\text{ then return } x' \\end{split}$$
Return  <span class="math">\\bot</span></p>

    <p class="text-gray-300">We need to show that for any B</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\mathrm{rs}}_{\\overline{D},D,\\mathcal{F},B}(\\cdot) \\leq \\frac{1}{2^{\\lambda}}</span>$
.</p>

    <p class="text-gray-300">To this end define game RsmpD,D,<sup>F</sup> to pick a bit b at random and run the first experiment if b = 1 and the second if b = 0; also, have it set bad to true if D ever returns &perp;. Define Rsmp-HD,D,<sup>F</sup> to be like the former but return ResampleD(&lambda;, St, &alpha;, a,f) if bad is set. Then using a standard conditioning argument and the Fundamental Lemma <a href="#page-21-16">[8]</a>:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\frac{1}{2} + \\frac{1}{2}\\mathbf{A}\\mathbf{d}\\mathbf{v}^{\\mathrm{rs}}_{\\overline{D},D,\\mathcal{F},B}(\\cdot) &amp;= T(\\mathrm{Rsmp}_{\\overline{D},D,\\mathcal{F}},B,\\cdot) \\\\ &amp;\\leq T(\\mathrm{Rsmp-H}_{\\overline{D},D,\\mathcal{F}},B,\\cdot) + \\Pr\\left[\\,\\mathrm{Rsmp}_{\\overline{D},D,\\mathcal{F}}^B(\\cdot) \\text{ sets bad}\\,\\right] \\\\ &amp;= \\frac{1}{2} + \\Pr\\left[\\,\\mathrm{Rsmp}_{\\overline{D},D,\\mathcal{F}}^B(\\cdot) \\text{ sets bad}\\,\\right] \\,. \\end{split}</span>$</p>

    <p class="text-gray-300">Finally, we claim</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\,\\mathrm{Rsmp}_{\\overline{D},D,\\mathcal{F}}^B(\\cdot)\\,\\,\\mathrm{sets}\\,\\,\\mathrm{bad}\\,\\right]\\,\\,\\leq\\,\\,\\frac{1}{2^\\lambda}\\,\\,.</span>$</p>

    <p class="text-gray-300">To see this, fix any inputs &lambda;, St, &alpha;, a,f and for all 1 &le; i &le; w(&lambda;) let</p>

    <p class="text-gray-300"><span class="math">$p_i = \\Pr[\\mathcal{F}(\\lambda, \\mathbf{a}, x) = \\mathbf{f}_i : x \\leftarrow \\</span>D(St, \\alpha)].$$</p>

    <p class="text-gray-300">Then</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\overline{D}(\\lambda, St, \\alpha, \\mathbf{a}, \\mathbf{f}) \\text{ outputs } \\bot\\right] = \\sum_{i} p_{i} \\cdot (1 - p_{i})^{\\lambda w(\\lambda)}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq \\sum_{i} \\frac{1}{w(\\lambda)} \\cdot \\left(1 - \\frac{1}{w(\\lambda)}\\right)^{\\lambda \\cdot w(\\lambda)}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq \\frac{1}{2^{\\lambda}}.</span>$</p>

    <p class="text-gray-300">The second line above is justified by Lemma <a href="#page-15-1">5.7.</a> The third line uses the inequality (1&minus;1/x) <sup>x</sup> &le; 1/e &lt; 1/2 for any real number x &ge; 1 (here e is Euler's constant).</p>

    </section>

    <section id="sec-6" class="mb-10">
      <h2 class="text-2xl font-bold">6 Brute-Force Construction Revisited</h2>

    <p class="text-gray-300">We now revisit the &quot;brute-force&quot; scheme defined by BSW <a href="#page-21-0">[14]</a>, which provides a way to construct FE for any functionality with a polynomially-sized index space.</p>

    <p class="text-gray-300">Let F be a functionality. We say that F has polynomially-sized index space if F(&lambda;, a, x) = &perp; if a /&isin; A<sup>&lambda;</sup> where A<sup>&lambda;</sup> = {&epsilon;, a1, a2, . . . , ap(&lambda;)} for a polynomial p(&middot;). Let (G, E, D) be a PKE scheme. Then we define a the brute-force FE scheme for F as follows:</p>

    <pre><code class="language-text">PROC INITIALIZE(\\lambda):
                                                                                     Alg Resample&lt;sub&gt;D&lt;/sub&gt;(\\lambda, St, \\alpha, \\mathbf{a}, \\mathbf{f}):
                                                                                     If CS_D(\\lambda, St, \\alpha, \\mathbf{a}, \\mathbf{f}) = \\emptyset then return \\perp
Return \\lambda
                                                                                     w \\leftarrow s \\mathsf{CS}_D(\\lambda, St, \\alpha, \\mathbf{a}, \\mathbf{f})
PROC CHALLENGE(St, \\alpha, \\mathbf{a}):
                                                                                     x&#x27; \\leftarrow D(St, \\alpha; w)
x \\leftarrow s D(St, \\alpha)
                                                                                     Return x&#x27;
\\mathbf{f} \\leftarrow (\\mathcal{F}(\\lambda, \\mathbf{a}, x), \\mathcal{F}(\\lambda, \\varepsilon, x))
                                                                                     Alg Test(\\lambda, x, \\mathbf{a}, \\mathbf{f}):
If b = 1 then x&#x27; \\leftarrow \\overline{D}(\\lambda, St, \\alpha, \\mathbf{a}, \\mathbf{f})
                                                                                     \\mathbf{f}&#x27; \\leftarrow (\\mathcal{F}(\\lambda, \\mathbf{a}, x), \\mathcal{F}(\\lambda, \\varepsilon, x))
Else x&#x27; \\leftarrow s Resample (\\lambda, St, \\alpha, \\mathbf{a}, \\mathbf{f})
                                                                                     Return (\\mathbf{f} = \\mathbf{f}&#x27;)
Return x&#x27;
\\frac{\\text{PROC FINALIZE}(b&#x27;)}{\\text{Return } (b&#x27;=1)}:
                                                                                     Set CS_D(\\lambda, St, \\alpha, \\mathbf{a}, \\mathbf{f}) := \\{w : Test(\\lambda, D(St, \\alpha; w), \\mathbf{a}, \\mathbf{f}) = true\\}
</code></pre>

    <p class="text-gray-300">Figure 10: Left: Game Resamp <span class="math">_{\\overline{D},D,\\mathcal{F},b}</span>  for the resampleability definition. Right: Associated algorithms and definitions used by the game's procedures.</p>

    <pre><code class="language-text">\\frac{\\text{SETUP}(\\lambda)}{\\text{For } i = 1, \\dots, p(\\lambda) \\text{ do}} \\\\ (\\mathbf{pk}[i], \\mathbf{sk}[i]) \\leftarrow \\mathcal{G}(\\lambda) \\\\ \\text{Return } (\\mathbf{pk}, \\mathbf{sk}) \\\\ \\overline{\\text{For } i = 1, \\dots, p(\\lambda) \\text{ do}} \\\\ \\frac{\\text{KDER}(sk, a)}{\\text{For } i = 1, \\dots, p(\\lambda) \\text{ do}} \\\\ \\text{If } a_i = a \\text{ then return } (i, \\mathbf{sk}[i]) \\\\ \\hline \\\\ \\frac{\\text{ENC}(\\mathbf{pk}, m)}{\\text{For } i = 1, \\dots, p(\\lambda) \\text{ do}} \\\\ \\overline{\\text{C}[i]} \\leftarrow \\mathcal{E}(\\mathbf{pk}[i], \\mathcal{F}(\\lambda, a_i, m)) \\\\ \\overline{\\text{Return } \\mathbf{c}} \\\\ \\overline{\\text{DEC}((i, \\mathbf{sk}[i]), \\mathbf{c}))} \\\\ \\overline{\\text{If } (\\mathbf{sk}[i] = \\varepsilon) \\text{ then return } |m|} \\\\ \\overline{\\text{Return } \\mathcal{D}(\\mathbf{sk}[i], \\mathbf{c}[i])}
</code></pre>

    <p class="text-gray-300">BSW [14] show that this construction is IND-secure (and hence, by our results in Section 5, SS2-secure) provided that the underlying PKE scheme is semantically secure. Moreover, they show a slightly decorated construction which is SS1-secure in the random oracle model. What we show is that it suffices for the underlying PKE scheme to be secure against <em>key-revealing SOAs</em> (SOA-K) for this FE scheme to be SS1-secure. In fact, for their result BSW implicitly use the non-committing (which implies SOA-K) PKE scheme of Nielsen [26] in the random oracle model as the underlying PKE scheme, so our result is a generalization of theirs. In particular, it allows us to obtain instantiations in the standard model by (necessarily) allowing long keys, meaning longer than the total number of bits encrypted; SOA-K secure PKE is known to exist in this setting [15, 16].</p>

    <p class="text-gray-300">The intuition is that opening a particular  <span class="math">\\mathcal{F}(\\lambda, a_i, m)</span>  is equivalent to giving away  <span class="math">\\mathbf{sk}[i]</span> . Therefore, it should be the case that if some  <span class="math">\\mathcal{F}</span>  values for a particular set  <span class="math">I = \\{a_{j_1}, a_{j_2}, \\dots, a_{j_{|I|}}\\} \\subseteq \\mathcal{A}</span>  of indices are revealed, it is equivalent to opening up  <span class="math">\\mathbf{sk}[j_1], \\mathbf{sk}[j_2], \\dots, \\mathbf{sk}[j_{|I|}]</span>  and should therefore, by SOA security, not make it any easier to obtain decryptions under any other secret key, i.e. to evaluate  <span class="math">\\mathcal{F}</span>  on any other index.</p>

    <p class="text-gray-300">SOA-K DEFINITION. To formalize our result we will need an explicit notion of SOA-K security, as described in BDWY [5]. Here we need to extend the BDWY definition to allow the adversary and simulator to ask for encryptions and secret keys adaptively (as in our SS notions for FE) rather than asking for an initial vector of ciphertexts and then afterwards a subset of the secret keys in one shot.</p>

    <p class="text-gray-300">Let  <span class="math">\\Pi</span>  be a PKE scheme. The definition uses games  <span class="math">\\mathrm{RSOAK}_{\\Pi,Z,D,R,n}</span>  and  <span class="math">\\mathrm{SSOAK}_{\\Pi,Z,D,R,n}</span>  of Figure 11. We say that  <span class="math">\\Pi</span>  is SOAK-secure if for every auxiliary input generator Z, every PT message sampler D, every PT relation R, every PT adversary A, and every polynomial  <span class="math">n(\\cdot)</span>  there is a PT simulator S such that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\mathrm{soa-k}}_{\\Pi,A,S,Z,D,R,n}(\\cdot) \\ = \\ \\Pr\\left[ \\, \\mathrm{RSOAK}^{A}_{\\Pi,Z,D,R,n}(\\cdot) \\, \\right] - \\Pr\\left[ \\, \\mathrm{SSOAK}^{S}_{\\Pi,Z,D,R,n}(\\cdot) \\, \\right]</span>$</p>

    <p class="text-gray-300">is negligible.</p>

    <p class="text-gray-300"><strong>Theorem 6.1</strong> Let  <span class="math">\\Pi = (\\mathcal{G}, \\mathcal{E}, \\mathcal{D})</span>  be a SOA-K secure PKE scheme. Then the corresponding brute-force FE scheme for any functionality  <span class="math">\\mathcal{F}</span>  with a polynomially-sized index space is SS1-secure.</p>

    <pre><code class="language-text">Initialize(\\lambda)
i&#x27;, j \\leftarrow 0
St \\leftarrow \\varepsilon
                                                                                                                                                                                   CORRUPT(i)
                                                               Corrupt(i)
For j&#x27; = 1, \\ldots, n(\\lambda) do
                                                                                                                               i&#x27;, j \\leftarrow 0
                                                                                                                                                                                   j \\leftarrow j + 1
       (\\mathbf{pk}[j&#x27;], \\mathbf{sk}[j&#x27;]) \\leftarrow \\mathcal{G}(\\lambda)
                                                                                                                               z \\leftarrow *Z(\\lambda)
z \\leftarrow s Z(\\lambda)
                                                              \\mathbf{i}[j] \\leftarrow i
                                                                                                                               St \\leftarrow \\varepsilon
                                                                                                                                                                                  \\mathbf{i}[j] \\leftarrow i
                                                                                                                                                                                  For j&#x27;=1,\\ldots,i&#x27; do
                                                              For j&#x27; = 1, \\ldots, i&#x27; do
                                                                                                                               Return z
Return (\\mathbf{pk}, z)
                                                                     \\mathbf{m}[j&#x27;] \\leftarrow \\mathbf{x}[j&#x27;][i]
                                                                                                                                                                                         \\mathbf{m}[j&#x27;] \\leftarrow \\mathbf{x}[j&#x27;][i]
Enc(\\alpha)
                                                                                                                               Msg(\\alpha)
                                                              Return (\\mathbf{m}, \\mathbf{sk}[i])
                                                                                                                                                                                  Return m
(St, \\mathbf{m}) \\leftarrow s D(St, \\alpha)
                                                                                                                               (St, \\mathbf{m}) \\leftarrow s D(St, \\alpha)
                                                                                                                                                                                  FINALIZE(w)
i&#x27; \\leftarrow i&#x27; + 1
                                                                                                                              i&#x27; \\leftarrow i&#x27; + 1
                                                              Return R(\\lambda, z, \\mathbf{x}, \\mathbf{i}, \\boldsymbol{\\alpha}, St, w)
                                                                                                                                                                                  Return R(\\lambda, z, \\mathbf{x}, \\mathbf{i}, \\boldsymbol{\\alpha}, St, w)
\\alpha[i&#x27;] \\leftarrow \\alpha \\; ; \\; \\mathbf{x}[i&#x27;] \\leftarrow \\mathbf{m}
                                                                                                                              \\alpha[i&#x27;] \\leftarrow \\alpha \\; ; \\; \\mathbf{x}[i&#x27;] \\leftarrow \\mathbf{m}
For j&#x27; = 1, \\ldots, n(\\lambda) do
      \\mathbf{c}[j&#x27;] \\leftarrow \\mathcal{E}(\\mathbf{pk}[j&#x27;], \\mathbf{m}[j&#x27;])
Return c
</code></pre>

    <p class="text-gray-300">Figure 11: Left: &quot;Real world&quot; game  <span class="math">RSOAK_{\\Pi,Z,D,R,n}</span>  for the SOA-K definition. Right: &quot;Ideal world&quot; game  <span class="math">SSOAK_{\\Pi,Z,D,R,n}</span>  for the SOA-K definition.</p>

    <pre><code class="language-text">Alg A&#x27;(\\lambda):
Alg R&#x27;(\\lambda, z, \\mathbf{x}&#x27;, \\mathbf{i}, \\boldsymbol{\\alpha}, St, w):
                                                          Alg D&#x27;(St, \\alpha):
                                                                                                    (\\mathbf{pk}, z) \\leftarrow \\$ Initialize(\\lambda)
For j&#x27; = 1, \\ldots, |\\mathbf{x}&#x27;|
                                                          x \\leftarrow D(St, \\alpha)
                                                                                                    Run A on input \\lambda:
     \\mathbf{x}[j&#x27;] \\leftarrow \\mathbf{x}&#x27;[j&#x27;][p(\\lambda) + 1]
                                                          For i = 1, \\ldots, p(\\lambda) do
                                                                                                          On initialize query \\lambda return (\\mathbf{pk}, z)
                                                                \\mathbf{m}[i] \\leftarrow \\mathcal{F}(\\lambda, a_i, x)
For j&#x27; = 1, ..., |\\mathbf{i}|
                                                                                                          On encryption query \\alpha
     Let i be such that a_i = \\mathbf{i}[j&#x27;]
                                                          \\mathbf{m}[p(\\lambda) + 1] \\leftarrow x
                                                                                                                \\mathbf{c} \\leftarrow \\mathbf{s} \\operatorname{Enc}(\\alpha)
      \\mathbf{a}[j&#x27;] \\leftarrow a_i
                                                          Return m
                                                                                                                Return (\\mathbf{c}[1 \\dots p(\\lambda)], msglen(\\mathbf{c}[p(\\lambda) + 1]))
Return R(\\lambda, z, \\mathbf{x}, \\mathbf{a}, \\boldsymbol{\\alpha}, St, w)
                                                                                                          On key-derivation query a
                                                                                                                Let i be such that a_i = a
                                                                                                                Return CORRUPT(i)
                                                                                                    Let w be the output of A
</code></pre>

    <p class="text-gray-300">Figure 12: Algorithms for proof of security of brute-force scheme.</p>

    <p class="text-gray-300"><strong>Proof of Theorem 6.1:</strong> Denote by  <span class="math">A_{\\lambda} = \\{\\varepsilon, a_1, a_2, \\dots, a_{p(\\lambda)}\\}</span>  the family of sets satisfying the definition of polynomially-sized index space for  <span class="math">\\mathcal{F}</span> . Let Z be an auxiliary input generator, D be a message sampler, R be a relation, and A be a SS1 adversary. Consider the auxiliary input generator Z' = Z, and then the relation R', message sampler D' and SOA-K adversary A' defined as in Figure 12.</p>

    <p class="text-gray-300">Above, for a ciphertext c,  <span class="math">\\mathsf{msglen}(c)</span>  returns the length of the decryption of c (which we assume is efficiently computable from a ciphertext, or else that D always outputs messages of some known length). Also note that we set  <span class="math">n(\\cdot) = p(\\cdot) + 1</span>  in the SOAK games; this allows A' to pass the length of the &quot;actual&quot; payload x to A and similarly A' to pass the &quot;actual&quot; payload vector  <span class="math">\\mathbf{x}</span>  to A. Since A is SOA-K secure, we know that there exists a PT simulator A' such that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\text{soa-k}}_{\\Pi,A&#x27;,S&#x27;,Z&#x27;,D&#x27;,R&#x27;}(\\cdot) = \\Pr\\left[ \\, \\text{RSOAK}^{A&#x27;}_{\\Pi,Z&#x27;,D&#x27;,R&#x27;}(\\cdot) \\, \\right] - \\Pr\\left[ \\, \\text{SSOAK}^{S&#x27;}_{\\Pi,Z&#x27;,D&#x27;,R&#x27;}(\\cdot) \\, \\right]</span>$</p>

    <p class="text-gray-300">is negligible. Now we use S' to construct S, a simulator for the ISS game, in a similar way we adapted A to get A':</p>

    <pre><code class="language-text">Alg S(\\lambda):

z \\leftarrow s Initialize(\\lambda)

Run S&#x27; on input \\lambda:

i&#x27; \\leftarrow 0

On initialize query \\lambda return z

On message query \\alpha:

i&#x27; \\leftarrow i&#x27; + 1; Msg(\\alpha)

Return \\varepsilon

On corrupt query i:

OP(a_i)

For j = 1, \\ldots, i&#x27;

\\mathbf{x}[j] \\leftarrow F(a_i, j)

Return \\mathbf{x}

Let w be the output of S&#x27;

Return w
</code></pre>

    <p class="text-gray-300">By construction, we now have</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp; \\Pr \\left[ \\, \\mathrm{RSOAK}_{\\Pi,Z&#x27;,D&#x27;,R&#x27;,p+1}^{A&#x27;}(\\cdot) \\, \\right] = \\Pr \\left[ \\, \\mathrm{RSS}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^{A}(\\cdot) \\, \\right] \\\\ &amp; \\Pr \\left[ \\, \\mathrm{SSOAK}_{\\Pi,Z&#x27;,D&#x27;,R&#x27;,p+1}^{S&#x27;}(\\cdot) \\, \\right] = \\Pr \\left[ \\, \\mathrm{ISS}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^{S}(\\cdot) \\, \\right] \\end{split}</span>$</p>

    <p class="text-gray-300">Therefore,</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathbf{Adv}_{\\mathsf{FE},\\mathcal{F},A,S,Z,D,R}^{\\mathsf{ss1}}(\\cdot) &amp;= \\Pr\\left[ \\, \\mathsf{RSS}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^{A}(\\cdot) \\, \\right] - \\Pr\\left[ \\, \\mathsf{ISS}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^{S}(\\cdot) \\, \\right] \\\\ &amp;= \\Pr\\left[ \\, \\mathsf{RSOAK}_{\\Pi,Z&#x27;,D&#x27;,R&#x27;}^{A&#x27;}(\\cdot) \\, \\right] - \\Pr\\left[ \\, \\mathsf{SSOAK}_{\\Pi,Z&#x27;,D&#x27;,R&#x27;,p+1}^{S&#x27;}(\\cdot) \\, \\right] \\\\ &amp;= \\mathbf{Adv}_{\\Pi,A&#x27;,S&#x27;,Z&#x27;,D&#x27;,R&#x27;,p+1}^{\\mathsf{soa-k}}(\\cdot) \\end{split}</span>$</p>

    <p class="text-gray-300">which is negligible by assumption.</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><p class="text-gray-300">[1] M. Abdalla, M. Bellare, and G. Neven. Robust encryption. In D. Micciancio, editor, <em>TCC 2010</em>, volume 5978 of <em>LNCS</em>, pages 480&ndash;497. Springer, Feb. 2010. 5, 6, 8</p></li>
      <li><p class="text-gray-300">[2] S. Agrawal, D. M. Freeman, and V. Vaikuntanathan. Functional encryption for inner product predicates from learning with errors. In D. H. Lee and X. Wang, editors, <em>ASIACRYPT 2011</em>, volume 7073 of <em>LNCS</em>, pages 21&ndash;40. Springer, Dec. 2011. 2</p></li>
      <li><p class="text-gray-300">[3] S. Agrawal, S. Gorbunov, V. Vaikuntanathan, and H. Wee. Functional encryption: New perspectives and lower bound. Cryptology ePrint Archive, Report 2012/468, 2012. http://eprint.iacr.org/. 3, 4</p></li>
      <li><p class="text-gray-300">[4] M. Barbosa and P. Farshim. Semantically secure functional encryption revisited. Cryptology ePrint Archive, Report 2012/474, 2012. http://eprint.iacr.org/. 4, 7</p></li>
      <li><p class="text-gray-300">[5] M. Bellare, R. Dowsley, B. Waters, and S. Yilek. Standard security does not imply security against selective-opening. In D. Pointcheval, editor, <em>EUROCRYPT 2012</em>, LNCS. Springer, 2012. 1, 3, 10, 18</p></li>
      <li><p class="text-gray-300">[6] M. Bellare, D. Hofheinz, and S. Yilek. Possibility and impossibility results for encryption and commitment secure under selective opening. In A. Joux, editor, EUROCRYPT 2009, volume 5479 of LNCS, pages 1&ndash;35. Springer, Apr. 2009. 4</p></li>
      <li><p class="text-gray-300">[7] M. Bellare and A. Palacio. GQ and Schnorr identification schemes: Proofs of security against impersonation under active and concurrent attacks. In M. Yung, editor, <em>CRYPTO 2002</em>, volume 2442 of <em>LNCS</em>, pages 162&ndash;177. Springer, Aug. 2002. 10</p></li>
      <li><p class="text-gray-300">[8] M. Bellare and P. Rogaway. The security of triple encryption and a framework for code-based gameplaying proofs. In S. Vaudenay, editor, EUROCRYPT 2006, volume 4004 of LNCS, pages 409&ndash;426. Springer, May / June 2006. <a href="#page-5-0">5,</a> <a href="#page-12-2">12,</a> <a href="#page-14-1">14,</a> <a href="#page-17-0">17</a></p></li>
      <li><p class="text-gray-300">[9] M. Bellare, B. Waters, and S. Yilek. Identity-based encryption secure against selective opening attack. In Y. Ishai, editor, TCC 2011, volume 6597 of LNCS, pages 235&ndash;252. Springer, Mar. 2011. <a href="#page-4-0">4</a></p></li>
      <li><p class="text-gray-300">[10] D. Boneh and X. Boyen. Efficient selective-ID secure identity based encryption without random oracles. In C. Cachin and J. Camenisch, editors, EUROCRYPT 2004, volume 3027 of LNCS, pages 223&ndash;238. Springer, May 2004. <a href="#page-5-0">5,</a> <a href="#page-6-1">6</a></p></li>
      <li><p class="text-gray-300">[11] D. Boneh and X. Boyen. Secure identity based encryption without random oracles. In M. Franklin, editor, CRYPTO 2004, volume 3152 of LNCS, pages 443&ndash;459. Springer, Aug. 2004. <a href="#page-2-1">2</a></p></li>
      <li><p class="text-gray-300">[12] D. Boneh, G. Di Crescenzo, R. Ostrovsky, and G. Persiano. Public key encryption with keyword search. In C. Cachin and J. Camenisch, editors, EUROCRYPT 2004, volume 3027 of LNCS, pages 506&ndash;522. Springer, May 2004. <a href="#page-6-1">6,</a> <a href="#page-15-3">15</a></p></li>
      <li><p class="text-gray-300">[13] D. Boneh and M. K. Franklin. Identity based encryption from the Weil pairing. SIAM Journal on Computing, 32(3):586&ndash;615, 2003. <a href="#page-1-0">1,</a> <a href="#page-2-1">2</a></p></li>
      <li><p class="text-gray-300">[14] D. Boneh, A. Sahai, and B. Waters. Functional encryption: Definitions and challenges. In Y. Ishai, editor, TCC 2011, volume 6597 of LNCS, pages 253&ndash;273. Springer, Mar. 2011. <a href="#page-1-0">1,</a> <a href="#page-2-1">2,</a> <a href="#page-3-0">3,</a> <a href="#page-4-0">4,</a> <a href="#page-5-0">5,</a> <a href="#page-6-1">6,</a> <a href="#page-7-1">7,</a> <a href="#page-8-2">8,</a> <a href="#page-9-2">9,</a> <a href="#page-10-3">10,</a> <a href="#page-17-0">17,</a> <a href="#page-18-2">18</a></p></li>
      <li><p class="text-gray-300">[15] R. Canetti, U. Feige, O. Goldreich, and M. Naor. Adaptively secure multi-party computation. In 28th ACM STOC, pages 639&ndash;648. ACM Press, May 1996. <a href="#page-3-0">3,</a> <a href="#page-4-0">4,</a> <a href="#page-18-2">18</a></p></li>
      <li><p class="text-gray-300">[16] I. Damg&#730;ard and J. B. Nielsen. Improved non-committing encryption schemes based on a general complexity assumption. In M. Bellare, editor, CRYPTO 2000, volume 1880 of LNCS, pages 432&ndash;450. Springer, Aug. 2000. <a href="#page-3-0">3,</a> <a href="#page-4-0">4,</a> <a href="#page-18-2">18</a></p></li>
      <li><p class="text-gray-300">[17] S. Fehr, D. Hofheinz, E. Kiltz, and H. Wee. Encryption schemes secure against chosen-ciphertext selective opening attacks. In H. Gilbert, editor, EUROCRYPT 2010, volume 6110 of LNCS, pages 381&ndash;402. Springer, May 2010. <a href="#page-4-0">4</a></p></li>
      <li><p class="text-gray-300">[18] S. Goldwasser and S. Micali. Probabilistic encryption. Journal of Computer and System Sciences, 28(2):270&ndash; 299, 1984. <a href="#page-2-1">2</a></p></li>
      <li><p class="text-gray-300">[19] S. Gorbunov, V. Vaikuntanathan, and H. Wee. Functional encryption with bounded collusions via multi-party computation. In CRYPTO, pages 162&ndash;179, 2012. <a href="#page-4-0">4</a></p></li>
      <li><p class="text-gray-300">[20] V. Goyal, O. Pandey, A. Sahai, and B. Waters. Attribute-based encryption for fine-grained access control of encrypted data. In A. Juels, R. N. Wright, and S. Vimercati, editors, ACM CCS 06, pages 89&ndash;98. ACM Press, Oct. / Nov. 2006. Available as Cryptology ePrint Archive Report 2006/309. <a href="#page-1-0">1,</a> <a href="#page-2-1">2</a></p></li>
      <li><p class="text-gray-300">[21] B. Hemenway, B. Libert, R. Ostrovsky, and D. Vergnaud. Lossy encryption: Constructions from general assumptions and efficient selective opening chosen ciphertext security. In D. H. Lee and X. Wang, editors, ASIACRYPT 2011, volume 7073 of LNCS, pages 70&ndash;88. Springer, Dec. 2011. <a href="#page-4-0">4</a></p></li>
      <li><p class="text-gray-300">[22] J. Katz, A. Sahai, and B. Waters. Predicate encryption supporting disjunctions, polynomial equations, and inner products. In N. P. Smart, editor, EUROCRYPT 2008, volume 4965 of LNCS, pages 146&ndash;162. Springer, Apr. 2008. <a href="#page-1-0">1,</a> <a href="#page-2-1">2,</a> <a href="#page-6-1">6,</a> <a href="#page-7-1">7,</a> <a href="#page-23-0">23</a></p></li>
      <li><p class="text-gray-300">[23] A. B. Lewko, T. Okamoto, A. Sahai, K. Takashima, and B. Waters. Fully secure functional encryption: Attribute-based encryption and (hierarchical) inner product encryption. In H. Gilbert, editor, EURO-CRYPT 2010, volume 6110 of LNCS, pages 62&ndash;91. Springer, May 2010. <a href="#page-2-1">2</a></p></li>
      <li><p class="text-gray-300">[24] A. B. Lewko and B. Waters. Decentralizing attribute-based encryption. In K. G. Paterson, editor, EURO-CRYPT 2011, volume 6632 of LNCS, pages 568&ndash;588. Springer, May 2011. <a href="#page-2-1">2</a></p></li>
      <li><p class="text-gray-300">[25] A. B. Lewko and B. Waters. Unbounded HIBE and attribute-based encryption. In K. G. Paterson, editor, EUROCRYPT 2011, volume 6632 of LNCS, pages 547&ndash;567. Springer, May 2011. <a href="#page-2-1">2</a></p></li>
      <li><p class="text-gray-300">[26] J. B. Nielsen. Separating random oracle proofs from complexity theoretic proofs: The non-committing encryption case. In M. Yung, editor, CRYPTO 2002, volume 2442 of LNCS, pages 111&ndash;126. Springer, Aug. 2002. <a href="#page-2-1">2,</a> <a href="#page-4-0">4,</a> <a href="#page-18-2">18</a></p></li>
      <li><p class="text-gray-300">[27] T. Okamoto and K. Takashima. Hierarchical predicate encryption for inner-products. In M. Matsui, editor, ASIACRYPT 2009, volume 5912 of LNCS, pages 214&ndash;231. Springer, Dec. 2009. <a href="#page-2-1">2</a></p></li>
      <li><p class="text-gray-300">[28] T. Okamoto and K. Takashima. Efficient attribute-based signatures for non-monotone predicates in the standard model. In D. Catalano, N. Fazio, R. Gennaro, and A. Nicolosi, editors, PKC 2011, volume 6571 of LNCS, pages 35&ndash;52. Springer, Mar. 2011. <a href="#page-2-1">2</a></p></li>
      <li><p class="text-gray-300">[29] A. O'Neill. Definitional issues in functional encryption. Cryptology ePrint Archive, Report 2010/556, 2010. <a href="http://eprint.iacr.org/" target="_blank" rel="noopener noreferrer">http://eprint.iacr.org/</a>. <a href="#page-1-0">1,</a> <a href="#page-2-1">2,</a> <a href="#page-4-0">4,</a> <a href="#page-7-1">7,</a> <a href="#page-15-3">15</a></p></li>
      <li><p class="text-gray-300">[30] R. Ostrovsky, A. Sahai, and B. Waters. Attribute-based encryption with non-monotonic access structures. In P. Ning, S. D. C. di Vimercati, and P. F. Syverson, editors, ACM CCS 07, pages 195&ndash;203. ACM Press, Oct. 2007. <a href="#page-2-1">2</a></p></li>
      <li><p class="text-gray-300">[31] A. Sahai and B. R. Waters. Fuzzy identity-based encryption. In R. Cramer, editor, EUROCRYPT 2005, volume 3494 of LNCS, pages 457&ndash;473. Springer, May 2005. <a href="#page-1-0">1</a></p></li>
      <li><p class="text-gray-300">[32] A. Shamir. Identity-based cryptosystems and signature schemes. In G. R. Blakley and D. Chaum, editors, CRYPTO'84, volume 196 of LNCS, pages 47&ndash;53. Springer, Aug. 1985. <a href="#page-1-0">1</a></p></li>
      <li><p class="text-gray-300">[33] E. Shen, E. Shi, and B. Waters. Predicate privacy in encryption systems. In O. Reingold, editor, TCC 2009, volume 5444 of LNCS, pages 457&ndash;473. Springer, Mar. 2009. <a href="#page-2-1">2</a></p></li>
      <li><p class="text-gray-300">[34] B. Waters. Dual system encryption: Realizing fully secure IBE and HIBE under simple assumptions. In S. Halevi, editor, CRYPTO 2009, volume 5677 of LNCS, pages 619&ndash;636. Springer, Aug. 2009. <a href="#page-2-1">2</a></p></li>
      <li><p class="text-gray-300">[35] B. Waters. Functional encryption for regular languages. In CRYPTO, pages 218&ndash;235, 2012. <a href="#page-4-0">4</a></p></li>
      <li><p class="text-gray-300">[36] B. R. Waters. Efficient identity-based encryption without random oracles. In R. Cramer, editor, EURO-CRYPT 2005, volume 3494 of LNCS, pages 114&ndash;127. Springer, May 2005. <a href="#page-2-1">2,</a> <a href="#page-6-1">6</a></p></li>
    </ul>

    </section>

    <section id="app-a" class="mb-10">
      <h2 class="text-2xl font-bold">A Standard Primitives</h2>

    <p class="text-gray-300">Public-key encryption schemes. An public-key encryption scheme &Pi; = (G, E, D) is specified by three PT algorithms. Via (pk,sk)&larr;$ G(&lambda;) the key-generation algorithm G generates a public key and matching secret key. Via c&larr;$ E(pk, m) the encryption algorithm E takes pk and message m and returns a ciphertext c &isin; {0, 1} <sup>&lowast;</sup> &cup; {&perp;}. Via m &larr; D(sk, c), the deterministic decryption algorithm V returns a message m. We require that D(sk, E(pk, m)) = m for all &lambda; &isin; N, all (pk,sk) &isin; [G(&lambda;)], and all m &isin; {0, 1} &lowast;</p>

    <p class="text-gray-300">Hash Functions. A hash function H = (K, H) is a tuple of PT algorithms. Via hk &larr;$ K(&lambda;) the key-generation algorithm K produces a key hk. Via y &larr; H(hk, x) the deterministic hashing algorithm H produces the hash of a string x under key hk. Collision-resistance is defined via game CR<sup>&Gamma;</sup> whose Initialize(&lambda;) procedure returns hk &larr;$ K(&lambda;) and whose Finalize procedure on input (x, x&prime; ) returns (x 6= x &prime; ) &and; (H(hk, x) = H(hk, x&prime; )). There are no other procedures. The advantage of an adversary C is defined by Advcol <sup>H</sup>,C(&lambda;) = Pr -CR<sup>C</sup> <sup>H</sup>(&lambda;) . We say that H is collision-resistant (CR) if Advcol <sup>H</sup>,C(&middot;) is negligible for every PT C.</p>

    </section>

    <section id="app-b" class="mb-10">
      <h2 class="text-2xl font-bold">B The Unordered Case</h2>

    <p class="text-gray-300">Unordered SS1. We start by formalizing the definition. Let FE = (Setup,KDer, Enc, Dec) be a F-FE scheme. The definition uses games RSS1-UFE,F,Z,D,R and ISS1-UF,Z,D,R of Figure <a href="#page-23-1">13.</a> (&quot;U&quot; for unordered.) We say that FE is SS1-U-secure if for every auxiliary input generator Z, every PT message sampler D, every PT relation R and every PT adversary A there is a PT simulator S such that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\text{ss-u}}_{\\mathsf{FE},\\mathcal{F},A,S,Z,D,R}(\\cdot) \\ = \\ \\Pr\\left[ \\ \\mathrm{RSS1-U}^{A}_{\\mathsf{FE},\\mathcal{F},Z,D,R}(\\cdot) \\ \\right] - \\Pr\\left[ \\ \\mathrm{ISS1-U}^{S}_{\\mathcal{F},Z,D,R}(\\cdot) \\ \\right]</span>$</p>

    <p class="text-gray-300">is negligible.</p>

    <pre><code class="language-text">PROC INITIALIZE(\\lambda):
                                                                                i, j \\leftarrow 0 : St \\leftarrow \\varepsilon
(pk, sk) \\leftarrow \\$ \\mathsf{Setup}(\\lambda)
                                                                                z \\leftarrow s Z(\\lambda) : A \\leftarrow \\emptyset
z \\leftarrow s Z(\\lambda)
                                                                                Return z
i, j \\leftarrow 0; St \\leftarrow \\varepsilon
                                                                               \\frac{\\text{PROC MSG}(\\alpha):}{Q_{\\alpha} \\leftarrow Q_{\\alpha} \\cup \\{\\alpha\\}}
Return (pk, z)
PROC ENC(\\alpha):
                                                                                (St, \\mathbf{x}[i]) \\leftarrow s D(St, \\alpha)
\\overline{Q_{\\alpha} \\leftarrow Q_{\\alpha} \\cup \\{\\alpha\\}}
                                                                                Return \\mathcal{F}(\\lambda, \\varepsilon, \\mathbf{x}[i])
 (St, \\mathbf{x}[i]) \\leftarrow D(St, \\alpha)
                                                                                PROC OP(a):
\\mathbf{c}[i] \\leftarrow \\mathbf{s} \\, \\mathsf{Enc}(pk, \\mathbf{x}[i])
                                                                                Q_a \\leftarrow Q_a \\cup \\{a\\}
Return (\\mathbf{c}[i], \\mathcal{F}(\\lambda, \\varepsilon, \\mathbf{x}[i]))
                                                                                Return \\varepsilon
PROC KD(a):
                                                                                PROC F(a, s):
Q_a \\leftarrow Q_a \\cup \\{a\\}
                                                                                If a \\in \\mathsf{El}(\\mathbf{a}) and 1 \\le s \\le i then
dk \\leftarrow s \\mathsf{KDer}(sk, a)
                                                                                        Return \\mathcal{F}(\\lambda, a, \\mathbf{x}[s])
Return dk
                                                                                Else return \\perp
\\frac{\\text{PROC FINALIZE}(w):}{\\text{Return } R(\\lambda, z, \\mathbf{x}, Q_a, Q_\\alpha, St, w)} \\; \\left| \\; \\frac{\\text{PROC FINALIZE}(w):}{\\text{Return } R(\\lambda, z, \\mathbf{x}, Q_a, Q_\\alpha, St, w)} \\right|
</code></pre>

    <p class="text-gray-300">Figure 13: Left: &quot;Real world&quot; game RSS1-U<sub>FE, <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}</span> , <span class="math">\\mathcal{F}&lt;/sub&gt;</span></p>

    <p class="text-gray-300">IDENTITY-EMBEDDABLE PE. In the unordered case our result applies to what we call <em>identity-embeddable</em> predicate encryption schemes. Intuitively, these are predicate encryption schemes whose decryption policy embeds an identity matrix. Let  <span class="math">\\mathcal{F}</span>  be a predicate encryption functionality for predicate  <span class="math">\\mathcal{P}</span> . We say that  <span class="math">\\mathcal{F}</span>  is  <span class="math">n(\\cdot)</span> -identity embeddable if there are  <span class="math">\\{(a_{1,\\lambda},\\ldots,a_{n(\\lambda),\\lambda})\\}_{\\lambda\\in\\mathbb{N}}</span>  and  <span class="math">\\{(w_{1,\\lambda},\\ldots,w_{n(\\lambda),\\lambda})\\}_{\\lambda\\in\\mathbb{N}}</span>  such that for all  <span class="math">\\lambda\\in\\mathbb{N}</span>  and all  <span class="math">1\\leq i,j\\leq n(\\lambda)</span> ,  <span class="math">\\mathcal{P}(\\lambda,a_i,w_j)=1</span>  if i=j and  <span class="math">\\perp</span>  otherwise.</p>

    <p class="text-gray-300">Note that the decryption policy described by an identity matrix is exactly that of IBE. Thus, any PE functionality that &quot;contains&quot; the functionality for an IBE scheme with n identities is n-identity embeddable. PE functionalities considered in the literature typically satisfy this requirement. For example, the inner-product functionality over  <span class="math">\\mathbb{Z}_N</span>  introduced by [22] was shown to implement IBE by restricting a to the form (id,1) and w to the form (-1,id') for id, id'  <span class="math">\\in \\mathbb{Z}_N</span> . Thus any inner-product functionality with vectors of dimension 2 is |N|-identity embeddable. Note that in [22] |N| is exponential in  <span class="math">\\lambda</span> , whereas for our application we just need it to be polynomial in  <span class="math">\\lambda</span>  (namely, the output length of a collision-resistant hash function).</p>

    <p class="text-gray-300"><strong>Theorem B.1</strong> Let  <span class="math">\\mathcal{F}</span>  be a predicate encryption functionality for predicate  <span class="math">\\mathcal{P}</span> . Let  <span class="math">\\mathcal{H} = (K, H)</span>  be a collision-resistant hash function with output length  <span class="math">\\ell_{\\mathcal{H}}(\\cdot)</span> . Suppose that for every  <span class="math">\\lambda \\in N</span> ,  <span class="math">\\mathcal{F}(\\lambda, \\varepsilon, x)</span>  is the same for all  <span class="math">x \\in [X_{\\lambda}]</span> . Furthermore, suppose that  <span class="math">\\mathcal{F}</span>  is  <span class="math">2\\ell_{\\mathcal{H}}(\\cdot)</span> -identity embeddable. Then there does not exist an SS1-U-secure  <span class="math">\\mathcal{F}</span> -FE scheme. More precisely, suppose FE is a  <span class="math">\\mathcal{F}</span> -FE scheme with secret-key length  <span class="math">\\ell_{sk}(\\cdot)</span> . Then for any function  <span class="math">\\mu(\\cdot)</span>  there exists a PT auxiliary input generator Z, message sampler D, PT adversary A, PT relation B, and B CR-adversary B such that for every simulator B</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\mathrm{ss}}_{\\mathsf{FE},\\mathcal{F},A,S,D,R}(\\cdot) \\ \\leq \\ 1 - \\sqrt{\\mathbf{Adv}^{\\mathrm{col}}_{\\mathcal{H},C}(\\cdot) + 1/\\mu(\\cdot)} \\ .</span>$</p>

    <p class="text-gray-300">Adversary A makes  <span class="math">\\ell_{sk}(\\cdot) + \\log \\mu(\\cdot)</span>  encryption queries and  <span class="math">\\ell_{\\mathcal{H}}(\\cdot)</span>  key-derivation queries.</p>

    <p class="text-gray-300">We remark that our theorem and proof treat the case of (P,p), (p,p), and (p,P) PE functionalities in a unified way. However, in the case of (P,p)-PE the condition in the theorem that  <span class="math">\\mathcal{F}</span>  be  <span class="math">2\\ell_{\\mathcal{H}}(\\cdot)</span> -identity embeddable can be improved to  <span class="math">\\ell_{\\mathcal{H}}(\\cdot)</span> -identity embeddable. We also stress that, unlike Theorem 4.1, our result here does not apply to any &quot;non-trivial&quot; functionality but only those of a certain form. Better understanding the nature of the gap between the two results or closing it remains an interesting open problem. It is also interesting to note that our result here uses an adversary that makes  <span class="math">\\ell_{\\mathcal{H}}(\\cdot)</span>  keyderivation queries as opposed to the constant 2 of Theorem 4.1. It would be interesting to know if this is</p>

    <p class="text-gray-300">tight, meaning whether SS1-U can be achieved against adversaries making some small bounded number of key derivation queries.</p>

    <p class="text-gray-300"><strong>Proof of Theorem B.1:</strong> Denote by  <span class="math">\\{(a_{1,\\lambda},\\ldots,a_{2\\ell_{\\mathcal{H}}(\\lambda),\\lambda})\\}_{\\lambda\\in\\mathbb{N}}</span>  and  <span class="math">\\{(w_{1,\\lambda},\\ldots,w_{2\\ell_{\\mathcal{H}}(\\lambda),\\lambda})\\}_{\\lambda\\in\\mathbb{N}}</span>  the values that satisfy  <span class="math">2\\ell_{\\mathcal{H}}(\\lambda)</span> -identity embeddability for  <span class="math">\\mathcal{F}</span> . For  <span class="math">\\lambda\\in\\mathbb{N}</span>  denote by  <span class="math">\\overline{\\varepsilon}_{\\lambda}</span>  the value such that  <span class="math">\\mathcal{F}(\\lambda,\\varepsilon,x)=\\overline{\\varepsilon}_{\\lambda}</span>  for all  <span class="math">x\\in[X_{\\lambda}]</span> . Let  <span class="math">n(\\cdot):=\\ell(\\cdot)+\\log\\mu(\\cdot)</span> . Define auxiliary input generator Z on input  <span class="math">\\lambda</span>  to return  <span class="math">hk\\leftarrow sK(\\lambda)</span> . For  <span class="math">\\lambda\\in\\mathbb{N}</span>  denote by  <span class="math">M_{\\lambda}</span>  a distribution on messages for FE so that if FE is private message then  <span class="math">M_{\\lambda}=\\{0,1\\}</span>  and otherwise is trivial. Then define message sampler D on input  <span class="math">St,\\alpha</span>  to set  <span class="math">St\\leftarrow 1</span>  if  <span class="math">St=\\varepsilon</span>  and  <span class="math">St\\leftarrow St+1</span>  otherwise, and to return  <span class="math">(St,(w_{2(\\lfloor St/n\\rfloor+1)-b,\\lambda},m))</span>  where  <span class="math">b\\leftarrow s\\{0,1\\}</span>  and  <span class="math">m\\leftarrow sM</span> . Define adversary A and relation R as follows:</p>

    <pre><code class="language-text">Alg R(\\lambda, \\mathbf{x}, Q_a, Q_\\alpha, St, w):
Alg A(pk, hk):
                                                            (pk, hk, \\mathbf{c}, h, \\mathbf{sk}) \\leftarrow w
For i = 1, ..., \\ell_{\\mathcal{H}}(\\lambda) n(\\lambda) do:
                                                            If h \\neq H(hk, pk||\\mathbf{c}) then return false
      \\mathbf{c}[i] \\leftarrow \\$ \\operatorname{Enc}(\\lambda)
                                                            If |\\mathbf{sk}| \\neq \\ell_{\\mathcal{H}}(\\lambda) then return false
h \\leftarrow H(hk, pk || \\mathbf{c})
                                                            For i = 1, \\ldots, \\ell_{\\mathcal{H}}(\\lambda) do:
For i = 1 to \\ell_{\\mathcal{H}}(\\lambda) do:
                                                                  If |\\mathbf{sk}[i]| \\neq \\ell_{sk}(\\lambda) then return false
      \\mathbf{sk}[i] \\leftarrow \\$ \\operatorname{KD}(a_{2i-h[i]})
                                                            If Q_a \\neq \\{a_{2i-h[i],\\lambda} : 1 \\leq i \\leq \\ell_{\\mathcal{H}}(\\lambda)\\} then return false
w \\leftarrow (pk, \\mathbf{c}, h, \\mathbf{sk})
                                                            If \\mathbf{x} \\neq \\ell_{\\mathcal{H}}(\\lambda) n(\\lambda) \\vee Q_{\\alpha} \\neq \\{\\lambda\\} then return false
Return w
                                                            For i = 1, \\ldots, \\ell_{\\mathcal{H}}(\\lambda) do:
                                                                  If Dec(\\mathbf{sk}[i], \\mathbf{c}[i \\dots i + n - 1]) \\neq \\mathcal{F}(\\lambda, a_{2i-h[i]}, \\mathbf{x}[i \\dots i + n - 1])
                                                                          Then return false
                                                            Return true
</code></pre>

    <p class="text-gray-300">By construction  <span class="math">\\Pr\\left[\\text{RSS1-U}_{\\mathsf{FE},\\mathcal{F},Z,D,R}^A(\\cdot)\\right] = 1</span> . Let S be any simulator. Furthermore, parsing the output of S as  <span class="math">(pk,\\mathbf{c},h,\\mathbf{sk}) \\leftarrow w</span> , we assume it holds that  <span class="math">h = H(hk,pk\\|\\mathbf{c}), |\\mathbf{sk}| = \\ell_{\\mathcal{H}}(\\lambda)</span>  and  <span class="math">|\\mathbf{sk}[i]| = \\ell_{sk}(\\lambda)</span>  for  <span class="math">1 \\leq i \\leq \\ell_{\\mathcal{H}}(\\lambda), \\ Q_a = \\{a_{2n-h[i],\\lambda} : 1 \\leq i \\leq \\ell_{\\mathcal{H}}\\}</span> , and  <span class="math">|\\alpha| = \\ell_{\\mathcal{H}}(\\lambda)n(\\lambda)</span>  and  <span class="math">Q_\\alpha = \\{\\lambda\\}</span> , since otherwise the relation R returns false. Towards applying Lemma 4.2, we write the execution of S in the ISS-U game as a composition of two algorithms  <span class="math">S_1, S_2</span>  as follows:</p>

    <pre><code class="language-text">\\begin{array}{l} \\mathbf{Alg} \\ S_2(\\overline{St}) \\colon \\\\ St\\|i\\|j\\|\\mathbf{x}\\| \\|A\\|a^* \\leftarrow \\overline{St} \\end{array}
Alg S_1(\\lambda):
i \\leftarrow 0; z \\leftarrow \\text{$} Initialize(\\lambda)
                                                                                         Let i^* be such that a^* \\in \\{a_{2i^*,\\lambda}, a_{2i^*-1,\\lambda}\\}
Run S(z):
                                                                                         For q = 1, \\ldots, n do:
On message-query \\alpha do:
                                                                                                b \\leftarrow \\$ \\{0,1\\} ; m \\leftarrow \\$ M_{\\lambda}
      i \\leftarrow i + 1
      b \\mathop{\\leftarrow} \\mathop{\\$} \\left\\{ 0,1 \\right\\} \\; ; \\; m \\mathop{\\longleftarrow} \\mathop{\\$} M_{\\lambda}
                                                                                               \\mathbf{x}[i^* \\cdot n + q - 1] \\leftarrow (w_{2i^* - b, \\lambda}, m)
      \\mathbf{x}[i] \\leftarrow (w_{2(|i/n|+1)-b,\\lambda}, m)
                                                                                         Run S at state St:
      Return \\overline{\\varepsilon}
                                                                                         On message-query \\alpha do:
                                                                                               i \\leftarrow i + 1
On op-query a do:
      j \\leftarrow j + 1 ; A \\leftarrow A \\cup \\{a\\}
                                                                                                If i \\notin \\{i^* \\cdot n, \\dots, i^* \\cdot n + n - 1\\} do:
                                                                                                      b \\leftarrow \\$ \\{0,1\\} ; m \\leftarrow \\$ M_{\\lambda}
      If j = \\ell_{\\mathcal{H}}(\\lambda) then
            a^* \\leftarrow a
                                                                                                      \\mathbf{x}[i] \\leftarrow (w_{2|\\alpha/n|-b,\\lambda}, m)
            Halt computation of S_1 with state St
                                                                                                Return \\overline{\\varepsilon}
      Else return \\varepsilon
                                                                                          On F-query (a, s) do:
On F-query (a, s) do:
                                                                                                If 1 \\le s \\le i and a \\in \\mathsf{El}(\\mathbf{a}) do:
      If 1 \\le s \\le i and a \\in A do:
                                                                                                Return \\mathcal{F}(\\lambda, a, \\mathbf{x}[s])
      Return \\mathcal{F}(\\lambda, a, \\mathbf{x}[s])
                                                                                                Else return \\perp
                                                                                         Let w be the output of S
      Else return \\perp
\\overline{St} \\leftarrow St \\|i\\|j\\|\\mathbf{x}\\|A\\|a^*
                                                                                         Return w
Return \\overline{St}
</code></pre>

    <p class="text-gray-300">Namely,  <span class="math">S_1</span>  runs S up to the point that it makes its <em>last</em> OP query (namely the  <span class="math">\\ell_{\\mathcal{H}}(\\lambda)</span> -th one), and  <span class="math">S_2</span>  runs S following this OP query. Below we justify the following sequence of inequalities:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\text{ISS1-U}_{\\mathcal{F},Z,D,R}^{S}(\\cdot)\\right] = \\mathbf{AP}_{1}(P_{1}, P_{2}, \\lambda)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq \\sqrt{\\mathbf{AP}_{2}(S_{1}, S_{2}, \\lambda)}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq \\sqrt{\\mathbf{Adv}_{\\mathcal{H},C}^{\\text{col}}(\\lambda) + \\Pr\\left[\\mathcal{F}(\\lambda, a_{\\lambda}, \\mathbf{x}) \\in Y\\right]}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq \\sqrt{\\mathbf{Adv}_{\\mathcal{H},C}^{\\text{col}}(\\lambda) + 2^{\\ell}(1/2)^{n}}</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\sqrt{\\mathbf{Adv}_{\\mathcal{H},C}^{\\text{col}}(\\lambda) + 1/\\mu(\\lambda)}</span>$</p>

    <p class="text-gray-300">Above, the first line is by construction; note that while  <span class="math">S_2</span>  chooses  <span class="math">\\mathbf{x}^*</span>  and hence some components of  <span class="math">\\mathbf{x}</span>  differently than S, this is equivalent due to the 2n-identity embeddability of  <span class="math">\\mathcal{F}</span>  and is only used to make the analysis more transparent. The second is by Lemma 4.2. For the third, we can define C analogously to the proof of Theorem 4.1 (namely, C simply mimics the double execution experiment with  <span class="math">S_1, S_2</span> ). Let us denote the two outputs of  <span class="math">S_2</span>  in that experiment as  <span class="math">w^1 = (pk^1, \\mathbf{c}^1, h^1, \\mathbf{sk}^1)</span>  and  <span class="math">w^2 = (pk^2, \\mathbf{c}^2, h^2, \\mathbf{sk}^2)</span> . Now, unless C finds a collision we have  <span class="math">\\mathbf{c}^1 = \\mathbf{c}^2</span> , denote by  <span class="math">\\mathbf{c}^*</span>  this common value. Then define the set  <span class="math">Y := \\{y \\in \\{0,1\\}^* : \\exists s \\in \\{0,1\\}^\\ell \\text{ s.t. } \\operatorname{Dec}(s, \\mathbf{c}^*[i^*n \\dots i^*n + n - 1]) = y\\}</span> . If it is not the case that  <span class="math">\\mathcal{F}(\\lambda, a_{i^*,\\lambda}, \\mathbf{x}[i^*n \\dots i^*n + n - 1]) \\in Y</span>  when  <span class="math">\\mathbf{x}[i^*n \\dots i^*n + n - 1]</span>  is (re-)sampled by  <span class="math">S_2</span>  then the relation R must reject, as no  <span class="math">\\mathbf{sk}^2</span>  will satisfy  <span class="math">\\operatorname{Dec}(\\mathbf{sk}^2[i^*], \\mathbf{c}^*[i^*n \\dots i^*n + n - 1]) = \\mathcal{F}(\\lambda, a_{i^*n - h[i^*]}, \\mathbf{x}[i^*n \\dots i^*n + n - 1])</span> , justifying the third line above. To see the fourth line, fix  <span class="math">s \\in \\{0,1\\}^\\ell</span>  and denote  <span class="math">\\operatorname{Dec}(s, \\mathbf{c}^*[i^*n \\dots i^*n + n - 1])</span>  by  <span class="math">\\mathbf{x}^*</span> . As  <span class="math">\\mathbf{x}[i^* \\cdot n]</span>  is defined as  <span class="math">(w_{2\\lfloor\\alpha/n\\rfloor - b,\\lambda}, m)</span>  for random  <span class="math">b \\in \\{0,1\\}</span>  and  <span class="math">m \\in M_\\lambda</span> ,  <span class="math">\\mathbf{x}[i^*n \\dots i^*n + n - 1]</span> , which are sampled independently. Taking a union bound over all possible  <span class="math">s \\in \\{0,1\\}^\\ell</span>  yields the fourth line. Finally, for the fifth line above we just substitute  <span class="math">n(\\lambda) = \\ell(\\lambda) + \\log(\\mu(\\lambda))</span> .</p>

    </section>
`;
---

<BaseLayout title="Semantically-Secure Functional Encryption: Possibility Resul... (2012/515)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2012 &middot; eprint 2012/515
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#abstract" class="hover:text-white">Abstract</a></li>
        <li><a href="#sec-1" class="hover:text-white">Introduction</a></li>
        <li><a href="#sec-2" class="hover:text-white">Notation and conventions</a></li>
        <li><a href="#sec-3" class="hover:text-white">Functional Encryption and its Security</a></li>
        <li><a href="#sec-4" class="hover:text-white">Impossibility Results</a></li>
        <li>
          <a href="#sec-5" class="hover:text-white">Equivalence for Restricted Definitions of Semantic Security</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-5.1" class="hover:text-white">SS2 and its Equivalence to IND for All Functionalities</a></li>
            <li><a href="#sec-5.2" class="hover:text-white">SS3 and its Equivalence to IND for Resampleable Functionalities</a></li>
            <li><a href="#sec-5.3" class="hover:text-white">Resampleability of Some Functionalities</a></li>
          </ol>
        </li>
        <li><a href="#sec-6" class="hover:text-white">Brute-Force Construction Revisited</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li><a href="#app-a" class="hover:text-white">Standard Primitives</a></li>
        <li><a href="#app-b" class="hover:text-white">The Unordered Case</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="semantically-secure-functional-encryption-possibility-2012" />
  </article>
</BaseLayout>
