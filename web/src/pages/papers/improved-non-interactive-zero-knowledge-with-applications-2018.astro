---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2018/475';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Improved Non-Interactive Zero Knowledge with Applications to Post-Quantum Signatures';
const AUTHORS_HTML = 'Jonathan Katz, Vladimir Kolesnikov, Xiao Wang';

const CONTENT = `    <p class="text-gray-300">Jonathan Katz University of Maryland jkatz@cs.umd.edu Vladimir Kolesnikov Georgia Tech kolesnikov@gatech.edu Xiao Wang University of Maryland wangxiao@cs.umd.edu</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Recent work, including ZKBoo, ZKB++, and Ligero, has developed efficient non-interactive zero-knowledge proofs of knowledge (NIZKPoKs) for Boolean circuits based on symmetric-key primitives alone, using the “MPC-in-the-head” paradigm of Ishai et al. We show how to instantiate this paradigm with MPC protocols in the <em>preprocessing</em> model; once optimized, this results in an NIZKPoK with shorter proofs (and comparable computation) as in prior work for circuits containing roughly 300–100,000 AND gates. In contrast to prior work, our NIZKPoK also supports witness-independent preprocessing, which allows the prover to shift most of its work to an offline phase before the witness is known.</p>

    <p class="text-gray-300">We apply our ideas to construct a signature scheme based only on symmetric-key primitives (and hence with “post-quantum” security). The resulting scheme has shorter signatures than the scheme built using ZKB++ (and comparable signing/verification time), and is even competitive with hash-based signature schemes.</p>

    <p class="text-gray-300">To further highlight the flexibility and power of our ideas, we also build efficient ring and group signatures based on symmetric-key primitives alone. To our knowledge, the resulting schemes are the most efficient constructions of these primitives that offer post-quantum security.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Zero-knowledge (ZK) proofs <em>[29, 28]</em> and non-interactive zero-knowledge (NIZK) proofs <em>[11, 10, 22]</em> are among the most fundamental and versatile cryptographic primitives. In the present context, (NI)ZK proofs of knowledge (PoKs) <em>[29, 5, 20]</em> allow a prover to convince a verifier, who holds a circuit <span class="math">C</span>, that the prover knows an input (or “witness”) <span class="math">w</span> for which <span class="math">C(w)=1</span>. Historically, research on (NI)ZK proofs has followed two largely independent paths: some work gave asymptotic improvements for <em>generic</em> proofs that can be used for arbitrary circuits (by reducing a circuit to an NP-complete problem) but had poor concrete efficiency; other work explored <em>efficient</em> proofs tailored to specific, “algebraic” computations (e.g., group exponentiation).</p>

    <p class="text-gray-300">More recently, researchers have merged these two directions and have developed (NI)ZKPoKs for general circuits with good concrete efficiency. We highlight in particular recent constructions of succinct non-interactive arguments of knowledge (SNARKs) <em>[25, 40, 7, 19, 30]</em>, which can be used to generate proofs for arbitrary circuits that are shorter than the input <span class="math">w</span> itself. (Prior work showing ZK proofs with size sublinear in the input <em>[35, 38]</em> demonstrated feasibility, but was concretely inefficient.) Unfortunately, existing SNARKs suffer from several disadvantages. First,</p>

    <p class="text-gray-300">although they have excellent proof size and verification time, the computational efficiency of the prover is poor. Second, most constructions require public parameters generated and published by some semi-trusted party. Security of existing SNARKs is based on non-standard and poorly understood knowledge assumptions, and to some extent this is inherent <em>[26]</em>. Finally, most existing constructions of SNARKs rely on bilinear maps and are thus insecure against quantum attackers. (One exception is the recent work of Boneh et al. <em>[13]</em>. This scheme still has the other drawbacks, and its concrete efficiency is unclear.)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In another recent line of work, researchers have shown how to use protocols for secure multi-party computation (MPC) to obtain (NI)ZKPoKs with excellent concrete performance (even if the communication is no longer sublinear in the circuit size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">). Jawurek et al. <em>[33]</em> (see also <em>[24]</em>) showed that two-party protocols based on garbled circuits could be used to construct efficient ZKPoKs; their approach requires interaction as well as the use of public-key primitives. Hazay and Venkitasubramaniam <em>[31]</em> show a public-coin protocol based on garbled circuits that avoids public-key primitives; its practical performance is likely worse than the approaches we discuss next. Ishai et al. (IKOS) <em>[32]</em>, using the so-called “MPC-in-the-head” approach, showed how to use MPC protocols to obtain ZKPoKs whose security can be based entirely on symmetric-key primitives; their approach yields public-coin protocols, and so can be made non-interactive via the Fiat-Shamir transform <em>[23]</em>. Based on the IKOS approach, Giacomelli et al. <em>[27]</em> developed and implemented a protocol called ZKBoo that supports efficient NIZKPoKs for arbitrary circuits. (Concurrently, Ranellucci et al. <em>[43]</em> proposed an NIZKPoK with similar asymptotic performance.) Chase et al. <em>[16]</em> introduced ZKB++, which improves the performance of ZKBoo; they also showed that ZKB++ could be used to construct an efficient signature scheme based on symmetric-key primitives alone. (A version of their scheme called Picnic <em>[15]</em> was submitted to the NIST post-quantum standardization effort.) Ames et al. <em>[4]</em> subsequently proposed Ligero, which offers proofs that are sublinear in </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ and so asymptotically outperforms ZKBoo and ZKB++; see further discussion in Section 3.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 Our Contributions</h3>

    <p class="text-gray-300">We show here a novel way to instantiate the “MPC-in-the-head” approach that leads to NIZKPoKs with shorter proofs than (and comparable computation to) the best prior work <em>[27, 43, 16, 4]</em> for “medium-size” circuits with roughly 300–100,000 gates. (Although we focus on Boolean circuits, our ideas can be extended to arithmetic circuits as well.) As we show, this range covers many “cryptographically interesting” circuits that incorporate hashing, block-cipher evaluations, etc.</p>

    <p class="text-gray-300">Our main insight leading to improved performance is that the “MPC-in-the-head” paradigm can be instantiated using MPC protocols designed in the preprocessing model. (A detailed overview of our approach is given in Section 1.2.) This greatly increases the space of MPC protocols that can be used, and in particular makes it competitive to use protocols designed for a large number of parties (in contrast to prior work) and hence achieve better efficiency for the same level of security.</p>

    <p class="text-gray-300">As in the work of Chase et al. <em>[16]</em>, we may apply our NIZKPoK to construct an efficient signature scheme based on symmetric-key primitives alone and thus offering “post-quantum” security. Our resulting scheme has signatures roughly <span class="math">3.2\\times</span> shorter than those of Chase et al.; in fact, we can achieve signatures that are even shorter than some leading constructions of (stateless) hash-based signature schemes <em>[9]</em>. We can also trade off signature length and computation, giving some flexibility in the design. We are currently working with the Picnic team to incorporate our work in their submission to NIST.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">As an additional application highlighting the power of our new NIZKPoK, we show how to use it to build efficient ring and group signatures based on symmetric-key primitives alone. (Similar ideas, but using ZKB++, have been pursued in concurrent work <em>[21, 12]</em>.) The main challenge here is to build schemes in which signing corresponds to generating an NIZKPoK for a circuit that is not too large; we defer additional details to Section 4. Our resulting schemes are, to the best of our knowledge, the most efficient constructions of ring/group signatures with post-quantum security.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.2 Overview of Our Techniques</h3>

    <p class="text-gray-300">We provide the high-level intuition for our improved NIZKPoK. Here (and in Section 2.2) we describe a 5-round, public-coin proof of knowledge that is honest-verifier zero knowledge (HVZK). In Section 2.4 we then show how it can be “compressed” to three rounds (while remaining public-coin and HVZK). Either of these proofs can, in turn, be compiled to achieve zero knowledge against a malicious verifier using standard techniques. Alternatively—and of most interest to us—the 3-round version can be made non-interactive in the random-oracle model using the Fiat-Shamir transform <em>[23]</em>.</p>

    <p class="text-gray-300">Our starting point is the “MPC-in-the-head” paradigm of Ishai et al. <em>[32]</em> for constructing public-coin HVZK proofs of knowledge based on protocols for secure computation. Roughly speaking, the main idea is for the prover to simulate an execution of an <span class="math">n</span>-party secure-computation protocol <span class="math">\\Pi</span> that evaluates a given circuit <span class="math">C</span> on the prover’s input <span class="math">w</span>, and then for the prover to commit to the views of the parties in the protocol. The verifier chooses a random subset of those parties (we call those parties “opened”), and the prover opens their corresponding views. The verifier then checks that the views of the opened parties are consistent with each other and with an honest execution of <span class="math">\\Pi</span> that yields output 1.</p>

    <p class="text-gray-300">As observed in prior work <em>[27]</em>, efficiency considerations for the protocol <span class="math">\\Pi</span> used in the “MPC-in-the-head” paradigm differ from efficiency considerations for standard applications of MPC. For example, in this context <span class="math">\\Pi</span> can freely rely on “oblivious-transfer channels” in addition to standard point-to-point channels; in fact, <span class="math">\\Pi</span> can freely use any (deterministic) two-party functionality as a building block, since such functionalities incur no additional cost for the prover to simulate them, and consistency between pairs of opened parties can still be checked. We stress that this does not immediately extend to using <span class="math">t</span>-party functionalities for <span class="math">t&gt;2</span>, since it may no longer be possible to verify consistent execution unless all <span class="math">t</span> parties using the functionality are opened.</p>

    <p class="text-gray-300">Giacomelli et al. <em>[27]</em> and Chase et al. <em>[16]</em> gave concrete instantiations of the “MPC-in-the-head” approach, and determined that using a 3-party protocol <span class="math">\\Pi</span> resulted in optimal performance for the space of protocols they considered. Since the number of parties is small, the soundness of the resulting HVZK proof is poor; a large number of parallel repetitions is thus needed to obtain negligible soundness. (We discuss the work of Ames et al. <em>[4]</em> in Section 3.1.)</p>

    <p class="text-gray-300">Our main conceptual insight is that the “MPC-in-the-head” approach can be modified so the underlying <span class="math">n</span>-party protocol <span class="math">\\Pi</span> can rely on any <span class="math">n</span>-party functionality, <em>as long as that functionality is used during preprocessing</em>. At first glance, using an <span class="math">n</span>-party functionality does not seem compatible with the IKOS paradigm: the only way to verify that the functionality was run honestly is to open <em>all</em> parties, but then privacy (which translates to zero-knowledge) cannot possibly hold. We overcome this difficulty by having the verifier issue its challenges in <em>two</em> phases, thus giving a 5-round HVZK proof. Roughly, the HVZK proof works as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover commits to multiple (independent) executions of the preprocessing phase, where</li>

    </ol>

    <p class="text-gray-300">each commitment also commits to the state of each party at the end of that phase.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier challenges the prover to open some of the executions of the preprocessing phase. For each challenged execution, the prover opens the state of <em>all</em> parties, thus allowing the verifier to check those executions.</li>

      <li>Using each of the remaining (unchallenged) executions of the preprocessing phase, the prover simulates an execution of <span class="math">\\Pi</span> that evaluates <span class="math">C</span> on input <span class="math">w</span>. It then commits to each party’s view in the protocol, including its state from the preprocessing phase.</li>

      <li>As in the original IKOS approach, for each execution of <span class="math">\\Pi</span> the verifier chooses a random subset of the parties to open. Now, however, opening a party involves opening the commitment to that party’s state following the preprocessing phase (from step 1) as well as its view in the online execution of the protocol (from step 3). The verifier then checks that all the opened parties are consistent with each other and with an honest execution of <span class="math">\\Pi</span> (using the state from the preprocessing phase) that yields output 1.</li>

    </ol>

    <p class="text-gray-300">The fact that the <span class="math">n</span>-party functionality is executed during a preprocessing phase is essential here; the execution of that functionality is independent of the parties’ inputs, and so opening the views of all parties from the preprocessing phase does not reveal any information about <span class="math">w</span>.</p>

    <p class="text-gray-300">As a consequence of being able to rely on preprocessing, the space of possible protocols <span class="math">\\Pi</span> we can use is greatly expanded. In particular, we find that we obtain much shorter proofs by using an <span class="math">n</span>-party protocol (secure against semi-honest corruption of all-but-one of the parties) with <span class="math">n</span> as high as 64. The ability to rely on preprocessing is critical here: the communication complexity of traditional MPC protocols (that do not rely on preprocessing) with security against all-but-one corruption is quadratic in the number of parties, but by relying on preprocessing and broadcast we can obtain proof size independent of <span class="math">n</span>.</p>

    <p class="text-gray-300">Further optimizations and specific parameter choices for the above proof are discussed in the remainder of the paper.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.3 Outline of the Paper</h3>

    <p class="text-gray-300">In Section 2, we present the details of the MPC protocol <span class="math">\\Pi</span> we use, and describe more fully how to convert it into a 3-round, public-coin HVZK proof whose security relies on symmetric-key primitives alone. By applying the Fiat-Shamir transform to our 3-round proof, we obtain an NIZKPoK; the resulting construction is analyzed and compared to prior work in Section 3.1, where we show that it yields shorter proofs than prior work for a large range of circuit sizes. As in prior work, we can use our NIZKPoK to build a signature scheme based only on symmetric-key primitives (and hence offering “post-quantum” security); performance of this scheme is discussed in Section 3.2. We explore the applicability of our work to constructing “post-quantum” ring and group signatures in Section 4.</p>

    <h2 id="sec-7" class="text-2xl font-bold">2 HVZK Proofs of Knowledge</h2>

    <p class="text-gray-300">We construct our HVZK proofs by instantiating the “MPC-in-the-head” paradigm using an MPC protocol <span class="math">\\Pi</span> designed in the preprocessing model. We first describe the MPC protocol we rely on, and then discuss how to build HVZK proofs based on it.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Notation. We denote the <span class="math">n</span>-out-of-<span class="math">n</span> (XOR-based) secret sharing of a bit <span class="math">x</span> by <span class="math">[x]</span>. Throughout, <span class="math">\\kappa</span> and <span class="math">\\rho</span> denote computational and statistical security parameters, respectively. We let $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denote the number of AND gates in a circuit </span>C$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">2.1 A Suitable MPC protocol</h3>

    <p class="text-gray-300">In this section we describe an <span class="math">n</span>-party protocol <span class="math">\\Pi</span> run by parties <span class="math">S_{1},\\ldots,S_{n}</span> in the preprocessing model, secure against semi-honest corruption of all-but-one of the parties. The protocol is inspired by recent work of Wang et al. <em>[48]</em>.</p>

    <p class="text-gray-300">Recall that our goal is to use this protocol to instantiate the “MPC-in-the-head” approach efficiently, and so in particular we are interested in minimizing the communication needed to verify consistency and correct computation for any <span class="math">n-1</span> parties chosen by the verifier. As explained in more detail in the next section, our protocol <span class="math">\\Pi</span> ends up having communication comparable to the 3-party MPC protocols used by ZKBoo and ZKB++, but because we set <span class="math">n&gt;3</span> we are able to achieve much lower soundness error per protocol execution and thus better communication complexity overall for our resulting interactive proof system.</p>

    <p class="text-gray-300">Our protocol <span class="math">\\Pi</span> maintains the invariant that, for each wire in the circuit, the parties hold an <span class="math">n</span>-out-of-<span class="math">n</span> secret sharing of a random mask along with the (public) masked value of the wire. Specifically, if we let <span class="math">z_{\\alpha}</span> denote the value of wire <span class="math">\\alpha</span> in the circuit <span class="math">C</span> when evaluated on input <span class="math">w</span>, then the parties will hold <span class="math">[\\lambda_{\\alpha}]</span> (for uniform <span class="math">\\lambda_{\\alpha}\\in\\{0,1\\}</span>) along with the value <span class="math">\\hat{z}_{\\alpha}\\stackrel{{\\scriptstyle\\text{def}}}{{=}}z_{\\alpha}\\oplus\\lambda_{\\alpha}</span>.</p>

    <p class="text-gray-300">Preprocessing phase. In the preprocessing phase, shares are set up among the parties as follows. For each wire <span class="math">\\alpha</span> that is either an input wire of the circuit or the output wire of an AND gate, the parties are given <span class="math">[\\lambda_{\\alpha}]</span>, where <span class="math">\\lambda_{\\alpha}\\in\\{0,1\\}</span> is uniform. For an XOR gate with input wires <span class="math">\\alpha,\\beta</span> and output wire <span class="math">\\gamma</span>, define <span class="math">\\lambda_{\\gamma}\\stackrel{{\\scriptstyle\\text{def}}}{{=}}\\lambda_{\\alpha}\\oplus\\lambda_{\\beta}</span>; note the parties can compute <span class="math">[\\lambda_{\\gamma}]</span> locally. Finally, for each AND gate with input wires <span class="math">\\alpha,\\beta</span>, the parties are given <span class="math">[\\lambda_{\\alpha,\\beta}]</span>, where <span class="math">\\lambda_{\\alpha,\\beta}\\stackrel{{\\scriptstyle\\text{def}}}{{=}}\\lambda_{\\alpha}\\cdot\\lambda_{\\beta}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A key observation is that the shares of the <span class="math">\\{\\lambda_{\\alpha}\\}</span> are uniform, and so can be generated by having each party <span class="math">S_{i}</span> apply a pseudorandom generator to a short, random seed <span class="math">\\mathsf{seed}_{i}</span> given to that party, and then (implicitly) defining the <span class="math">\\{\\lambda_{\\alpha}\\}</span> based on the resulting shares. All-but-one of the shares of the <span class="math">\\{\\lambda_{\\alpha,\\beta}\\}</span> can also be generated in this way, but the final share is constrained by the values of <span class="math">\\lambda_{\\alpha},\\lambda_{\\beta}</span>. To ensure that the shares of the <span class="math">\\{\\lambda_{\\alpha,\\beta}\\}</span> are correct, <span class="math">S_{n}</span> can be given an additional $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> “correction bits” that determine its share of </span>\\lambda_{\\alpha,\\beta}<span class="math"> for each AND gate with input wires </span>\\alpha,\\beta$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To summarize: each <span class="math">S_{i}</span> is given a <span class="math">\\kappa</span>-bit seed <span class="math">\\mathsf{seed}_{i}\\in\\{0,1\\}^{\\kappa}</span>, and <span class="math">S_{n}</span> is additionally given $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> bits denoted by </span>\\mathsf{aux}_{n}<span class="math">. We refer to this information as the <em>state</em> of the parties, and denote the state of </span>S_{i}<span class="math"> by </span>\\mathsf{state}_{i}<span class="math">. In the online phase of the protocol, each party </span>S_{i}<span class="math"> uses </span>\\mathsf{seed}_{i}<span class="math"> to generate its shares of the </span>\\{\\lambda_{\\alpha}\\}<span class="math">; for </span>1\\leq i\\leq n-1<span class="math">, party </span>S_{i}<span class="math"> also uses </span>\\mathsf{seed}_{i}<span class="math"> to generate its shares of the </span>\\{\\lambda_{\\alpha,\\beta}\\}<span class="math">. Party </span>S_{n}<span class="math"> uses </span>\\mathsf{aux}_{n}<span class="math"> as its shares of the </span>\\{\\lambda_{\\alpha,\\beta}\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Protocol execution. Note that in our setting, where all parties are semi-honest, we can perform public reconstruction of a shared value <span class="math">[x]</span> by simply having each party broadcast its share.</p>

    <p class="text-gray-300">We assume the parties begin the protocol holding a masked value <span class="math">\\hat{z}_{\\alpha}</span> for each input wire <span class="math">\\alpha</span>. (In our context these masked values will be provided to the parties by the prover who is simulating execution of the protocol.) These masked values, along with the corresponding <span class="math">\\{\\lambda_{\\alpha}\\}</span>, define an effective input to the protocol. During the online phase of the protocol, the parties inductively compute <span class="math">\\hat{z}_{\\alpha}</span> for all wires in the circuit. Specifically, for each gate of the circuit with input wires <span class="math">\\alpha,\\beta</span> and output wire <span class="math">\\gamma</span>, where the parties already hold <span class="math">\\hat{z}_{\\alpha},\\hat{z}_{\\beta}</span>, the parties do:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If the gate is an XOR gate, then the parties locally compute <span class="math">\\hat{z}_{\\gamma}:=\\hat{z}_{\\alpha}\\oplus\\hat{z}_{\\beta}</span>.</li>

      <li>If the gate is an AND gate, the parties locally compute</li>

    </ul>

    <p class="text-gray-300"><span class="math">[s]:=\\hat{z}_{\\alpha}[\\lambda_{\\beta}]\\oplus\\hat{z}_{\\beta}[\\lambda_{\\alpha}]\\oplus[\\lambda_{\\alpha,\\beta}]\\oplus[\\lambda_{\\gamma}],</span></p>

    <p class="text-gray-300">and then publicly reconstruct <span class="math">s</span>. Finally, they compute <span class="math">\\hat{z}_{\\gamma}:=s\\oplus\\hat{z}_{\\alpha}\\hat{z}_{\\beta}</span>. One can verify that <span class="math">\\hat{z}_{\\gamma}=z_{\\gamma}\\oplus\\lambda_{\\gamma}</span>.</p>

    <p class="text-gray-300">Once the parties have computed <span class="math">\\hat{z}_{\\alpha}</span> for the output wire <span class="math">\\alpha</span>, the output value <span class="math">z_{\\alpha}</span> is computed by publicly reconstructing <span class="math">\\lambda_{\\alpha}</span> and then setting <span class="math">z_{\\alpha}:=\\hat{z}_{\\alpha}\\oplus\\lambda_{\\alpha}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We remark that the online phase of this protocol is deterministic. Also observe that all communication is due to share reconstruction: for a circuit with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> AND gates, at most </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+1$ share reconstructions are needed. We will see in the following sections that these properties are advantageous for our application.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">2.2 Our Basic HVZK Proof</h3>

    <p class="text-gray-300">In this section we describe a basic, 5-round HVZK proof based on the MPC protocol from the previous section. We defer discussion of further optimizations to the following section, and a description of a 3-round variant to Section 2.4.</p>

    <p class="text-gray-300">Notation. In this section, <span class="math">H</span> is a collision-resistant hash function. (Later in the paper, we will model <span class="math">H</span> as a random oracle.) We let <span class="math">\\mathsf{Com}</span> denote a non-interactive commitment scheme, where a commitment to a value <span class="math">x</span> is generated by choosing a uniform <span class="math">r\\in\\{0,1\\}^{\\kappa}</span> and computing <span class="math">\\mathsf{com}:=\\mathsf{Com}(x;r)</span>; decommitment is done by simply revealing <span class="math">x</span> and <span class="math">r</span>. Computational binding and hiding suffices.</p>

    <p class="text-gray-300">Overview. Recall from Section 1.2 that, because we rely on an MPC protocol <span class="math">\\Pi</span> designed in the preprocessing model, we modify the “MPC-in-the-head” approach and construct a 5-round proof of the following format: First, the prover commits to <span class="math">m</span> executions of the preprocessing phase, where each such commitment includes a commitment to the state of each party. The verifier then challenges the prover to open all-but-one of those executions, and verifies that all the state information given to the parties in the opened executions is correct. The remaining (unopened) execution of the preprocessing phase is then used by the prover to simulate the online phase of the <span class="math">n</span>-party protocol <span class="math">\\Pi</span> on a shared input <span class="math">w</span>, and the prover commits to the view of each party in this execution. The verifier then chooses all-but-one of the parties to be opened; for each opened party, the prover opens that party’s state from the preprocessing phase as well as its view from the online phase. The verifier then checks consistency of the parties’ views as well as correct behavior. We provide details about each of these steps next.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Checking the preprocessing phase. Recall from the previous section that, following the preprocessing phase, the state of party <span class="math">S_{i}</span> for <span class="math">1\\leq i\\leq n-1</span> is a seed <span class="math">\\mathsf{seed}_{i}</span>, while the state of party <span class="math">S_{n}</span> is a seed <span class="math">\\mathsf{seed}_{n}</span> along with a $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">-bit string </span>\\mathsf{aux}_{n}<span class="math">. Thus, in a naive implementation of the idea outlined above, for each execution of the preprocessing phase the prover would send </span>(\\mathsf{com}_{1},\\ldots,\\mathsf{com}_{n})<span class="math">, where </span>\\mathsf{com}_{i}<span class="math"> is a commitment to the state of </span>S_{i}<span class="math">. Then, for each challenged execution of the preprocessing phase, the prover would send </span>\\mathsf{seed}_{1},\\ldots,\\mathsf{seed}_{n},\\mathsf{aux}_{n},r_{1},\\ldots,r_{n}<span class="math">, where </span>r_{i}$ denotes the randomness</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Inputs: Both parties have a circuit  <span class="math">C</span> ; the prover also holds  <span class="math">w</span>  with  <span class="math">C(w) = 1</span> . Values  <span class="math">m, n</span>  are parameters of the protocol.</p>

    <p class="text-gray-300">Round 1 For each  <span class="math">j \\in [m]</span> , the prover emulates the preprocessing phase as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Choose uniform  <span class="math">\\mathsf{seed}_j^* \\in \\{0,1\\}^\\kappa</span>  and use it to generate values  <span class="math">\\mathsf{seed}_{j,1}</span> ,  <span class="math">r_{j,1}</span> , ...,  <span class="math">\\mathsf{seed}_{j,n}, r_{j,n}</span> . Also compute  $\\mathsf{aux}_{j,n} \\in \\{0,1\\}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  as described in the text. For  </span>i = 1, \\ldots, n-1<span class="math"> , let  </span>\\mathsf{state}_{j,i} := \\mathsf{seed}_{j,i}<span class="math"> ; let  </span>\\mathsf{state}_{j,n} := \\mathsf{seed}_{j,n} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{aux}_{j,n}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">i\\in [n]</span>  , compute  <span class="math">\\mathsf{com}_{j,i}\\coloneqq \\mathsf{Com}(\\mathsf{state}_{j,i};r_{j,i})</span></li>

      <li>Compute  <span class="math">h_j \\coloneqq H(\\mathsf{com}_{j,1}, \\ldots, \\mathsf{com}_{j,n})</span> .</li>

    </ol>

    <p class="text-gray-300">Compute  <span class="math">h \\coloneqq H(h_1, \\ldots, h_m)</span>  and send  <span class="math">h</span>  to the verifier.</p>

    <p class="text-gray-300">Round 2 The verifier chooses uniform  <span class="math">c \\in [m]</span>  and sends it to the prover.</p>

    <p class="text-gray-300">Round 3 The prover sends  <span class="math">\\{\\mathsf{seed}_j^*\\}_{j\\neq c}</span>  to the verifier.</p>

    <p class="text-gray-300">The prover simulates the online phase of the  <span class="math">n</span> -party protocol  <span class="math">\\Pi</span>  (as described in the text) using the state generated by the  <span class="math">c</span> th preprocessing phase, beginning by computing the masked values  <span class="math">\\{\\hat{z}_{\\alpha}\\}</span>  for the input wires (based on  <span class="math">w</span>  and the  <span class="math">\\{\\lambda_{\\alpha}\\}</span>  defined by the  <span class="math">c</span> th preprocessing phase). Let  <span class="math">\\mathsf{msgs}_i</span>  denote the messages broadcast by  <span class="math">S_i</span>  in the protocol execution. The prover sends the initial masked values  <span class="math">\\{\\hat{z}_{\\alpha}\\}</span>  as well as  <span class="math">h&#x27; := H(\\mathsf{msgs}_1, \\ldots, \\mathsf{msgs}_n)</span>  to the verifier.</p>

    <p class="text-gray-300">Round 4 The verifier chooses uniform  <span class="math">p \\in [n]</span>  and sends it to the prover.</p>

    <p class="text-gray-300">Round 5 The prover sends  <span class="math">\\{\\mathsf{state}_{c,i}, r_{c,i}\\}_{i \\neq p}</span> ,  <span class="math">\\mathsf{com}_{c,p}</span> , and  <span class="math">\\mathsf{msgs}_p</span> .</p>

    <p class="text-gray-300">Verification The verifier accepts iff all the following checks succeed:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">i \\neq p</span> , the verifier uses  <span class="math">\\mathsf{state}_{c,i}</span>  and  <span class="math">r_{c,i}</span>  to compute  <span class="math">\\mathsf{com}_{c,i}</span> . It then computes  <span class="math">h_c := H(\\mathsf{com}_{c,1}, \\ldots, \\mathsf{com}_{c,n})</span> .</li>

      <li>For  <span class="math">j \\neq c</span> , the verifier uses  <span class="math">\\mathsf{seed}_j^*</span>  to compute  <span class="math">h_j</span>  as an honest prover would. It then checks that  <span class="math">h \\stackrel{?}{=} H(h_1, \\ldots, h_m)</span> .</li>

      <li>The verifier simulates the online phase of  <span class="math">\\Pi</span>  among the  <span class="math">\\{S_i\\}_{i \\neq p}</span>  using  <span class="math">\\{\\mathsf{state}_{c,i}\\}_{i \\neq p}</span> , masked input-wire values  <span class="math">\\{\\hat{z}_\\alpha\\}</span> , and  <span class="math">\\mathsf{msgs}_p</span> . This yields  <span class="math">\\{\\mathsf{msgs}_i\\}_{i \\neq p}</span>  and an output bit  <span class="math">b</span> . The verifier checks that  <span class="math">b \\stackrel{?}{=} 1</span> .</li>

      <li>The verifier checks that  <span class="math">h&#x27; \\stackrel{?}{=} H(\\mathsf{msgs}_1, \\ldots, \\mathsf{msgs}_n)</span> .</li>

    </ol>

    <p class="text-gray-300">Figure 1: Our basic HVZK proof.</p>

    <p class="text-gray-300">used for the  <span class="math">i</span> th commitment. For the unchallenged execution (used for the subsequent execution of  <span class="math">\\Pi</span> ), the prover will be able to decommit to the states of any subset of the parties. The</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">communication complexity of this approach is $O(m\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+mn\\kappa)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We improve the communication complexity in several ways (cf. Round 1 and steps (1) and (2) of verification in Figure 1):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover computes <span class="math">H(\\mathsf{com}_{1},\\ldots,\\mathsf{com}_{n})</span>, and then sends the hash of the results from all <span class="math">m</span> executions; thus, it sends just a single hash value to the verifier.</li>

      <li>When opening a challenged execution, it is unnecessary for the prover to send <span class="math">\\mathsf{aux}_{n}</span> since the correct value of <span class="math">\\mathsf{aux}_{n}</span> can be computed from <span class="math">\\mathsf{seed}_{1},\\ldots,\\mathsf{seed}_{n}</span>. This gives an asymptotic improvement in the communication in this step.</li>

      <li>By generating the <span class="math">\\{\\mathsf{seed}_{i}\\}</span> and the <span class="math">\\{r_{i}\\}</span> from a “master” seed <span class="math">\\mathsf{seed}^{<em>}\\in\\{0,1\\}^{\\kappa}</span>, the prover can open a challenged execution of the preprocessing phase by simply sending <span class="math">\\mathsf{seed}^{</em>}</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The overall communication complexity of the initial checking phase can thus be reduced to <span class="math">O(m\\kappa)</span>, which is independent of $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>n$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Checking the online execution. An execution of our protocol proceeds gate-by-gate, with the processing of each AND gate requiring reconstruction of one shared value. Although the communication complexity of share reconstruction in our protocol is <span class="math">n</span> bits (one bit per party), for our purposes we do not need the prover to send <span class="math">n</span> bits per gate in order to prove consistent execution. This is because the verifier only needs to obtain the protocol messages sent by the (single) <em>unopened</em> party in order to check the execution of the <span class="math">n-1</span> opened parties. Thus, it suffices for the prover to send just a single bit per AND gate.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In addition to the protocol messages sent by the unopened party, the prover also needs to reveal the state (from the preprocessing phase) of every opened party. For each opened party <span class="math">S_{i}</span>, <span class="math">i\\neq n</span>, this involves just <span class="math">O(\\kappa)</span> bits; if <span class="math">S_{n}</span> is opened then this requires $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+O(\\kappa)<span class="math"> bits due to </span>\\mathsf{aux}_{n}<span class="math">. In either case the marginal communication complexity per AND gate is <em>independent</em> of the number of parties </span>n$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The above ideas (with a few optimizations) are encapsulated in Figure 1. Security of the scheme is given by the following theorem.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Theorem 2.1.</h6>

    <p class="text-gray-300">Let <span class="math">H</span> be collision-resistant, and <span class="math">\\mathsf{Com}</span> be a secure commitment scheme. The protocol in Figure 1 is an honest-verifier ZKPoK with soundness/knowledge error <span class="math">\\max\\{\\frac{1}{m},\\frac{1}{n}\\}</span>.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Completeness of the protocol is immediate, and we thus focus on proving honest-verifier zero knowledge and soundness.</p>

    <p class="text-gray-300">Honest-verifier zero knowledge follows easily from semi-honest security of <span class="math">\\Pi</span> (for corruption of any <span class="math">n-1</span> parties) and hiding of the commitment scheme. Specifically, if we let <span class="math">\\mathsf{Sim}_{\\Pi}</span> denote a simulator for <span class="math">\\Pi</span>, then we can construct an honest-verifier zero-knowledge simulator for our protocol as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Choose uniform <span class="math">c\\in[m]</span> and <span class="math">p\\in[n]</span>.</li>

      <li>Run <span class="math">\\mathsf{Sim}_{\\Pi}</span> to simulate the views of parties <span class="math">\\{S_{i}\\}_{i\\neq p}</span> in an execution of <span class="math">\\Pi</span> when evaluating <span class="math">C</span> with output <span class="math">1</span>. This results in values <span class="math">\\{\\mathsf{state}_{i}\\}_{i\\neq p}</span>, masked input-wire values <span class="math">\\{\\hat{z}_{\\alpha}\\}</span>, and <span class="math">\\mathsf{msgs}_{p}</span>. From the respective views, <span class="math">\\{\\mathsf{msgs}_{i}\\}_{i\\neq p}</span> can be computed. The simulator computes <span class="math">h^{\\prime}</span> as the honest prover would.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">j\\neq c</span>, the simulator computes <span class="math">h_{j}</span> exactly as the honest prover would. For <span class="math">i\\neq p</span>, the simulator sets <span class="math">\\mathsf{state}_{c,i}:=\\mathsf{state}_{i}</span>, chooses uniform <span class="math">r_{c,i}</span>, and computes <span class="math">\\mathsf{com}_{c,i}</span> as the honest prover would. It computes <span class="math">\\mathsf{com}_{c,p}</span> as a commitment to a 0-string of the appropriate length. It then computes <span class="math">h_{c}</span> and <span class="math">h</span> as the honest prover would.</li>

      <li>The simulator outputs the transcript with <span class="math">h</span>, <span class="math">c</span>, <span class="math">\\{\\mathsf{seed}_{j}^{*}\\}_{j\\neq c}</span>, <span class="math">\\{\\hat{z}_{\\alpha}\\}</span>, <span class="math">h^{\\prime}</span>, <span class="math">p</span>, <span class="math">\\{\\mathsf{state}_{c,i},r_{c,i}\\}_{i\\neq p}</span>, <span class="math">\\mathsf{com}_{c,p}</span>, and <span class="math">\\mathsf{msgs}_{p}</span>.</li>

    </ul>

    <p class="text-gray-300">A straightforward hybrid argument shows that transcripts output by the simulator are computationally indistinguishable from transcripts of real executions of the protocol with an honest verifier.</p>

    <p class="text-gray-300">We next show that given accepting transcripts for challenges <span class="math">(c,p)</span>, <span class="math">(c^{\\prime},\\star)</span>, and <span class="math">(c,p^{\\prime})</span>, with <span class="math">c\\neq c^{\\prime}</span> and <span class="math">p\\neq p^{\\prime}</span>, it is possible to extract a witness <span class="math">w</span> for which <span class="math">C(w)=1</span> unless there is a hash collision or binding of the commitment scheme fails. It follows using standard techniques that the protocol has soundness/knowledge error <span class="math">\\max\\{\\frac{1}{m},\\frac{1}{n}\\}</span>.</p>

    <p class="text-gray-300">In the discussion that follows we assume for simplicity that no hash collisions occur and that binding of the commitment scheme never fails. From the accepting transcript with challenges <span class="math">(c^{\\prime},\\star)</span>, we can compute for any <span class="math">c\\neq c^{\\prime}</span> values <span class="math">\\mathsf{state}_{c,1},\\ldots,\\mathsf{state}_{c,n}</span> that are mutually consistent (i.e., are a correct outcome of the preprocessing phase); moreover, those values are equal to the corresponding values sent in round 5 of the other two accepting transcripts (with initial challenge <span class="math">c</span>). These values of the state define a value <span class="math">\\lambda_{\\alpha}</span> for each input wire <span class="math">\\alpha</span>; from these and the masked inputs <span class="math">\\{\\hat{z}_{\\alpha}\\}</span> used in either of the other accepting transcripts we may compute an effective input <span class="math">w</span>.</p>

    <p class="text-gray-300">We now show that <span class="math">C(w)=1</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>From the transcript with challenges <span class="math">(c,p)</span>, we obtain the state of all parties besides <span class="math">S_{p}</span>; these will be exactly equal to the values <span class="math">\\{\\mathsf{state}_{c,i}\\}_{i\\neq p}</span> computed above. We also derive <span class="math">\\{\\mathsf{msgs}_{i}\\}_{i\\in[n]}</span>. Moreover, these values are all consistent with an honest execution of <span class="math">\\Pi</span> by parties <span class="math">\\{S_{i}\\}_{i\\neq p}</span> resulting in output 1.</li>

      <li>From the transcript with challenges <span class="math">(c,p^{\\prime})</span>, we can obtain <span class="math">\\{\\mathsf{state}_{c,i}\\}_{i\\neq p^{\\prime}}</span> along with protocol messages <span class="math">\\{\\mathsf{msgs}_{i}\\}_{i\\in[n]}</span> that must be equal to those obtained above. These values are consistent with an honest execution of <span class="math">\\Pi</span> by parties <span class="math">\\{S_{i}\\}_{i\\neq p^{\\prime}}</span> resulting in output 1.</li>

    </ul>

    <p class="text-gray-300">Since the masked input-wire values <span class="math">\\{\\hat{z}_{\\alpha}\\}</span> are fixed in the above, the <span class="math">\\{\\mathsf{state}_{c,i}\\}_{i\\in[n]}</span> and the <span class="math">\\{\\mathsf{msgs}_{i}\\}_{i\\in[n]}</span> must all be mutually consistent with an honest execution of <span class="math">\\Pi</span>, beginning with correct state and effective input <span class="math">w</span>, resulting in output 1. This implies <span class="math">C(w)=1</span>. ∎</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">2.3 Additional Optimizations</h3>

    <p class="text-gray-300">Here we describe some additional optimizations that can be used to further improve the concrete performance of our protocol.</p>

    <p class="text-gray-300">Reducing the number of random seeds. In the <span class="math">c</span>th emulation of the preprocessing phase, the prover generates <span class="math">n</span> seeds <span class="math">\\mathsf{seed}_{c,1}</span>, <span class="math">\\ldots</span>, <span class="math">\\mathsf{seed}_{c,n}</span> from a master seed <span class="math">\\mathsf{seed}_{c}^{*}</span>, commits to the <span class="math">n</span> generated seeds, and then sends <span class="math">n-1</span> of those seeds to the verifier. The second step requires <span class="math">(n-1)\\cdot\\kappa</span> bits of communication.</p>

    <p class="text-gray-300">Motivated by the NNL scheme for stateless revocation <em>[39]</em>, we observe that we can reduce the communication by generating the seeds in a more structured way. Namely, imagine labeling the root of a binary tree of depth <span class="math">\\log n</span> with <span class="math">\\mathsf{seed}_{c}^{*}</span>, and then inductively labeling the children</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 128</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 256</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700">218</td>

            <td class="px-3 py-2 border-b border-gray-700">252</td>

            <td class="px-3 py-2 border-b border-gray-700">352</td>

            <td class="px-3 py-2 border-b border-gray-700">462</td>

            <td class="px-3 py-2 border-b border-gray-700">631</td>

            <td class="px-3 py-2 border-b border-gray-700">916</td>

            <td class="px-3 py-2 border-b border-gray-700">456</td>

            <td class="px-3 py-2 border-b border-gray-700">533</td>

            <td class="px-3 py-2 border-b border-gray-700">781</td>

            <td class="px-3 py-2 border-b border-gray-700">1024</td>

            <td class="px-3 py-2 border-b border-gray-700">1662</td>

            <td class="px-3 py-2 border-b border-gray-700">2540</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">τ</td>

            <td class="px-3 py-2 border-b border-gray-700">65</td>

            <td class="px-3 py-2 border-b border-gray-700">44</td>

            <td class="px-3 py-2 border-b border-gray-700">33</td>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700">23</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">129</td>

            <td class="px-3 py-2 border-b border-gray-700">87</td>

            <td class="px-3 py-2 border-b border-gray-700">65</td>

            <td class="px-3 py-2 border-b border-gray-700">53</td>

            <td class="px-3 py-2 border-b border-gray-700">44</td>

            <td class="px-3 py-2 border-b border-gray-700">38</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Sample values of  <span class="math">M</span> ,  <span class="math">n</span> , and  <span class="math">\\tau</span>  to achieve statistical security  <span class="math">\\rho \\in \\{128, 256\\}</span> .  <span class="math">M</span>  is the number of executions simulated by the prover;  <span class="math">n</span>  is number of parties in the MPC protocol;  <span class="math">\\tau</span>  is the number of executions of the online phase of the MPC protocol.</p>

    <p class="text-gray-300">of each node with the output of a pseudorandom generator applied to the node's label. The  <span class="math">\\{\\mathrm{seed}_{c,i}\\}_{i\\in [n]}</span>  will be the labels of the  <span class="math">n</span>  leaves of the tree. To reveal  <span class="math">\\{\\mathrm{seed}_{c,i}\\}_{i\\neq p}</span> , it suffices to reveal the labels on the siblings of the path from the root of the tree to leaf  <span class="math">p</span> . Those labels allow the verifier to reconstruct  <span class="math">\\{\\mathrm{seed}_{c,i}\\}_{i\\neq p}</span>  while still hiding  <span class="math">\\mathrm{seed}_{c,p}</span> . Applying this optimization reduces the communication complexity to  <span class="math">\\kappa \\cdot \\log n</span>  for revealing the seeds used by the  <span class="math">n - 1</span>  opened parties.</p>

    <p class="text-gray-300">We can, in fact, apply the same idea to the master seeds  <span class="math">\\{\\mathrm{seed}_j^*\\}_{j=1}^m</span>  used for the different emulations of the preprocessing phase; this reduces the communication required to reveal all-but-one of those seeds in Round 3 from  <span class="math">(m-1) \\cdot \\kappa</span>  bits to  <span class="math">\\kappa \\cdot \\log m</span>  bits. Looking ahead to the next optimization, we remark that we are not limited to revealing all-but-one of the leaf labels; more generally, the scheme just described supports revealing all-but- <span class="math">\\tau</span>  of the leaf labels using communication at most  <span class="math">\\kappa \\cdot \\tau \\log \\frac{m}{\\tau}</span>  bits (cf. [39]).</p>

    <p class="text-gray-300">Beating parallel repetition. The basic protocol analyzed in the previous section has soundness error  <span class="math">\\max \\left\\{\\frac{1}{m}, \\frac{1}{n}\\right\\}</span> ; we can achieve soundness error  <span class="math">2^{-\\rho}</span>  by running  <span class="math">\\tau = \\frac{\\rho}{\\log \\min\\{m, n\\}}</span>  independent, parallel repetitions of the basic protocol. This would require  <span class="math">\\tau m</span>  emulations of the preprocessing phase, followed by  <span class="math">\\tau</span>  executions of an  <span class="math">n</span> -party protocol.</p>

    <p class="text-gray-300">We can do better by performing a more general cut-and-choose over the emulations of the preprocessing phase. That is, the prover now runs  <span class="math">M</span>  emulations of the preprocessing phase and the verifier selects  <span class="math">M - \\tau</span>  of those to check; the remaining  <span class="math">\\tau</span>  executions of the preprocessing phase are then used to run  <span class="math">\\tau</span>  (independent) instances of  <span class="math">\\Pi</span> . Each of those instances of  <span class="math">\\Pi</span>  is then verified by revealing the view of all-but-one party as before. If a cheating prover generates  <span class="math">k \\geq M - \\tau</span>  correct emulations of the preprocessing phase and  <span class="math">M - k</span>  incorrect emulations, then its probability of successfully passing the first phase of the proof is at most  <span class="math">\\binom{k}{M-\\tau} \\cdot \\binom{M}{M-\\tau}^{-1}</span> ; conditioned on passing the first phase, its probability of passing the second phase is at most  <span class="math">1/n^{k-M+\\tau}</span> . The soundness error is therefore</p>

    <div class="my-4 text-center"><span class="math-block">\\epsilon (M, n, \\tau) \\stackrel {\\text {d e f}} {=} \\max  _ {M - \\tau \\leq k \\leq M} \\left\\{\\frac {\\binom {k} {M - \\tau}}{\\binom {M} {M - \\tau} \\cdot n ^ {k - M + \\tau}} \\right\\}. \\tag {1}</span></div>

    <p class="text-gray-300">In Table 1 we show some values of  <span class="math">M, n</span> , and  <span class="math">\\tau</span>  that give soundness  <span class="math">2^{-128}</span>  or  <span class="math">2^{-256}</span> . (In each case, for fixed choice of  <span class="math">n</span>  we find  <span class="math">M, \\tau</span>  with minimum  <span class="math">\\tau</span>  for which  <span class="math">\\epsilon(M, n, \\tau)</span>  is below the desired soundness error.) For an interactive protocol, soundness  <span class="math">2^{-40}</span>  may be sufficient; however, for our later applications to non-interactive protocols better soundness is needed.</p>

    <p class="text-gray-300">Inputs: Both parties have a circuit  <span class="math">C</span> ; the prover also holds  <span class="math">w</span>  with  <span class="math">C(w) = 1</span> . Values  <span class="math">M, n, \\tau</span>  are parameters of the protocol.</p>

    <p class="text-gray-300">Round 1 For each  <span class="math">j \\in [M]</span> , the prover does:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Choose uniform  <span class="math">\\mathsf{seed}_j^* \\in \\{0,1\\}^\\kappa</span>  and use it to generate values  <span class="math">\\mathsf{seed}_{j,1}</span> ,  <span class="math">r_{j,1}</span> , ...,  <span class="math">\\mathsf{seed}_{j,n}, r_{j,n}</span> . Also compute  $\\mathsf{aux}_j \\in \\{0,1\\}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  as described in the text. For  </span>i = 1,\\dots,n-1<span class="math"> , let  </span>\\mathsf{state}_{j,i} := \\mathsf{seed}_{j,i}<span class="math"> ; let  </span>\\mathsf{state}_{j,n} := \\mathsf{seed}_{j,n} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{aux}_j$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">i\\in [n]</span>  , compute  <span class="math">\\mathsf{com}_{j,i}\\coloneqq \\mathsf{Com}(\\mathsf{state}_{j,i};r_{j,i})</span></li>

      <li>The prover simulates the online phase of the  <span class="math">n</span> -party protocol  <span class="math">\\Pi</span>  (as described in the text) using  <span class="math">\\{\\mathsf{state}_{j,i}\\}_{i}</span> , beginning by computing the masked inputs  <span class="math">\\{\\hat{z}_{j,\\alpha}\\}</span>  (based on  <span class="math">w</span>  and the  <span class="math">\\{\\lambda_{j,\\alpha}\\}</span>  defined by the preprocessing). Let  <span class="math">\\mathsf{msgs}_{j,i}</span>  denote the messages broadcast by  <span class="math">S_{i}</span>  in this protocol execution.</li>

      <li>Let  <span class="math">h_j \\coloneqq H(\\mathsf{com}_{j,1}, \\ldots, \\mathsf{com}_{j,n})</span>  and  <span class="math">h_j&#x27; \\coloneqq H(\\{\\hat{z}_{j,\\alpha}\\}, \\mathsf{msgs}_{j,1}, \\ldots, \\mathsf{msgs}_{j,n}, r_j)</span> , where  <span class="math">r_j \\in \\{0,1\\}^\\kappa</span>  is uniform.</li>

    </ol>

    <p class="text-gray-300">Compute  <span class="math">h \\coloneqq H(h_1, \\ldots, h_M)</span>  and  <span class="math">h&#x27; \\coloneqq H(h_1&#x27;, \\ldots, h_M&#x27;)</span>  and send  <span class="math">h^* \\coloneqq H(h, h&#x27;)</span>  to the verifier.</p>

    <p class="text-gray-300">Round 2 The verifier chooses a uniform  <span class="math">\\tau</span> -sized set  <span class="math">\\mathcal{C} \\subset [M]</span>  and  <span class="math">\\mathcal{P} = \\{p_j\\}_{j \\in \\mathcal{C}}</span>  where each  <span class="math">p_j \\in [n]</span>  is uniform. Send  <span class="math">(\\mathcal{C}, \\mathcal{P})</span>  to the prover.</p>

    <p class="text-gray-300">Round 3 For each  <span class="math">j \\in [M] \\setminus \\mathcal{C}</span> , the prover sends  <span class="math">\\operatorname{seed}_j^*, h_j&#x27;</span>  to the verifier.</p>

    <p class="text-gray-300">For each  <span class="math">j \\in \\mathcal{C}</span> , the prover sends  <span class="math">\\{\\mathsf{state}_{j,i}, r_{j,i}\\}_{i \\neq p_j}</span> ,  <span class="math">\\mathsf{com}_{j,p_j}</span> ,  <span class="math">\\{\\hat{z}_{j,\\alpha}\\}</span> ,  <span class="math">r_j</span> , and  <span class="math">\\mathsf{msgs}_{j,p_j}</span>  to the verifier.</p>

    <p class="text-gray-300">Verification The verifier accepts iff all the following checks succeed:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every  <span class="math">j \\in \\mathcal{C}</span> ,  <span class="math">i \\neq p_j</span> , the verifier uses  <span class="math">\\mathsf{state}_{j,i}</span>  and  <span class="math">r_{j,i}</span>  to compute  <span class="math">\\mathsf{com}_{j,i}</span> . It then computes  <span class="math">h_j := H(\\mathsf{com}_{j,1}, \\ldots, \\mathsf{com}_{j,n})</span> .</li>

      <li>For  <span class="math">j \\in [M] \\setminus \\mathcal{C}</span> , the verifier uses  <span class="math">\\mathsf{seed}_j^*</span>  to compute  <span class="math">h_j</span>  as an honest prover would. It then computes  <span class="math">h := H(h_1, \\ldots, h_M)</span> .</li>

      <li>For each  <span class="math">j \\in \\mathcal{C}</span> , the verifier simulates an execution of  <span class="math">\\Pi</span>  among the  <span class="math">\\{S_i\\}_{i \\neq p_j}</span>  using  <span class="math">\\{\\mathsf{state}_{j,i}\\}_{i \\neq p_j}</span> , masked input-wire values  <span class="math">\\{\\hat{z}_{j,\\alpha}\\}</span> , and  <span class="math">\\mathsf{msgs}_{j,p_j}</span> . This yields  <span class="math">\\{\\mathsf{msgs}_i\\}_{i \\neq p_j}</span>  and an output bit  <span class="math">b</span> . The verifier checks that  <span class="math">b = 1</span>  and computes  <span class="math">h_j&#x27; := H(\\{\\hat{z}_{j,\\alpha}\\}, \\mathsf{msgs}_{j,1}, \\ldots, \\mathsf{msgs}_{j,n}, r_j)</span>  as well as  <span class="math">h&#x27; := H(h_1&#x27;, \\ldots, h_m&#x27;)</span> .</li>

      <li>The verifier checks that  <span class="math">H(h, h&#x27;) \\stackrel{?}{=} h^*</span> .</li>

    </ol>

    <p class="text-gray-300">Figure 2: Our 3-round HVZK proof.</p>

    <p class="text-gray-300">2.4 A 3-Round Protocol</p>

    <p class="text-gray-300">For applications where an interactive proof suffices, the 5-round protocol described previously can be used. If a non-interactive proof is needed, however, then it is easier to start with a 3-round protocol. (Although it is possible to apply the Fiat-Shamir transform to any constant-round, public-coin, HVZK protocol <em>[1]</em>, we obtain better efficiency for a given security level by starting with a 3-round protocol.) We present a 3-round version of our proof here.</p>

    <p class="text-gray-300">The high-level idea of our 3-round variant is to have the prover now simulate the online phase of <span class="math">\\Pi</span> for every emulation of the preprocessing phase, and then commit to all the resulting executions. The verifier then challenges the prover to open some of the preprocessing phases, as well as all-but-one party from each of the unopened preprocessing phases, as before. The modified protocol is shown in Figure 2. In that figure, we also incorporate the cut-and-choose optimization discussed in the previous section. A proof of the following theorem relies on the same ideas as in the proof of Theorem 2.1, and so is omitted.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Theorem 2.2.</h6>

    <p class="text-gray-300">Let <span class="math">H</span> be collision-resistant, and let <span class="math">\\mathsf{Com}</span> be a secure commitment scheme. Then the protocol in Figure 2 is an honest-verifier ZK proof of knowledge with soundness/knowledge error <span class="math">\\epsilon(M,n,\\tau)</span>.</p>

    <p class="text-gray-300">As mentioned in the previous section, instead of computing <span class="math">h^{\\prime}:=H(h^{\\prime}_{1},\\ldots,h^{\\prime}_{M})</span> the prover can compute <span class="math">h^{\\prime}</span> as the root of a Merkle tree with the <span class="math">\\{h^{\\prime}_{j}\\}</span> as leaves. Then, in the third round it suffices for the prover to send at most <span class="math">\\tau\\log\\frac{M}{\\tau}</span> values instead of sending the <span class="math">M-\\tau</span> values <span class="math">\\{h^{\\prime}_{j}\\}_{j\\notin\\mathcal{C}}</span>. Applying this optimization, assuming commitment is done using a random oracle as described in the next section, and assuming the output length of <span class="math">H</span> is <span class="math">2\\kappa</span> bits, the communication complexity of our protocol is at most</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$2\\kappa+\\tau\\cdot\\log\\frac{M}{\\tau}\\cdot 3\\kappa+\\tau\\cdot(\\kappa\\log n+2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+3\\kappa)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">bits.</p>

    <h2 id="sec-16" class="text-2xl font-bold">3 Removing Interaction</h2>

    <p class="text-gray-300">In this section we describe how our 3-round protocol can be converted into a general NIZKPoK as well as a signature scheme. We also report on implementations of the resulting schemes. We implemented our protocol in C++ and will make the code available as open-source. All experiments (here and in Section 4) were carried out using a single core of an Intel Xeon E5-2666v3 CPU running at 2.9 GHz.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">3.1 An NIZKPoK</h3>

    <p class="text-gray-300">We can apply the Fiat-Shamir transform <em>[23]</em> to our 3-round protocol to obtain a non-interactive ZKPoK. In more detail, in this modified proof system the prover will compute the first-round message as before, and then derive a challenge by hashing the first message using a hash function <span class="math">G</span> modeled as a random oracle. The proof then consists of the first-round message plus the response to that challenge; it can be verified in the standard way.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Circuit size:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1,000</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">10,000</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">100,000</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">σ</td>

            <td class="px-3 py-2 border-b border-gray-700">ttotal</td>

            <td class="px-3 py-2 border-b border-gray-700">tonline</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">σ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ttotal</td>

            <td class="px-3 py-2 border-b border-gray-700">tonline</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">σ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ttotal</td>

            <td class="px-3 py-2 border-b border-gray-700">tonline</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">n = 64</td>

            <td class="px-3 py-2 border-b border-gray-700">37 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">128 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">10 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">136 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">851 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">220 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">1126 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">7865 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">2207 ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">n = 32</td>

            <td class="px-3 py-2 border-b border-gray-700">39 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">51 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">7 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">159 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">420 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">149 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">1351 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">4015 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">1498 ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">n = 16</td>

            <td class="px-3 py-2 border-b border-gray-700">44 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">28 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">7 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">190 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">250 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">105 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">1652 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">2408 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">1039 ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">n = 8</td>

            <td class="px-3 py-2 border-b border-gray-700">50 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">16 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">4 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">246KB</td>

            <td class="px-3 py-2 border-b border-gray-700">190 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">87 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">2203 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">1886 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">883 ms</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Table 2: Performance of our NIZKPoK. Parameters of all schemes were set to achieve 128-bit quantum security, as discussed in the text.  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is the proof size;  </span>t_{\\mathrm{total}}<span class="math">  is the total computation time;  </span>t_{\\mathrm{online}}$  is the online time.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Zero-knowledge of the resulting non-interactive proof system (in the random-oracle model) follows immediately from the fact that the 3-round interactive protocol is honest-verifier zero knowledge. Soundness—or, equivalently, the fact that the proof system is a proof of knowledge—can be proved using standard results about the Fiat-Shamir transform [42]. Directly applying those results unfortunately results in a relatively loose concrete-security bound due to use of the "forking lemma." We discuss later how we can obtain a better concrete-security reduction.</p>

    <p class="text-gray-300">Security against quantum algorithms. The preceding analysis assumes a classical attacker. We are not aware of any quantum attacks on our NIZKPoK that perform better than classical attacks, other than for quantum attacks on the underlying primitives (e.g., preimage attacks using Grover's algorithm, or better collision-finding attacks) that can be handled by simply increasing parameters. It is in this sense that we claim "post-quantum" security for our NIZKPoK. Nevertheless, we note that there are no known proofs of security for the Fiat-Shamir transform against quantum adversaries, except in some special cases [46, 18].</p>

    <p class="text-gray-300">It is possible to apply Unruh's transformation [45] to our 3-round proof to obtain a noninteractive scheme with provable security against quantum attacks (in the quantum random-oracle model); this was done in the Picnic submission [15]. We are currently exploring the impact of this on the efficiency of our scheme.</p>

    <p class="text-gray-300">Implementation optimizations. One potential source of overhead in our scheme is the large number of parties in the underlying MPC protocol. To reduce the impact of this, we utilize bit-level parallelization by packing all parties' shares into one word. This is efficient because most of the computations on parties' shares are identical, and therefore SIMD-friendly. This optimization works regardless of the topology of the circuit  <span class="math">C</span> .</p>

    <p class="text-gray-300">Note, however, that each party's share is generated from a different seed, and so that step is not compatible with bit-packing. To address this, our implementation uses efficient bit-matrix transposition based on SSE instructions [47, 34]: namely, we first generate a matrix of random bits contiguously aligned in memory, where each row is generated from one random seed, and then apply bit-level matrix transposition such that each column is a word containing one share of each party. Now, operating on shares of all parties takes only one instruction.</p>

    <p class="text-gray-300">Our MPC protocol is designed in the preprocessing model. We can leverage this feature in our resulting proof system so as to allow the prover to perform most of its computation in an offline phase before the witness is known: specifically, the prover can compute  <span class="math">h</span>  (cf. Figure 2) without knowledge of  <span class="math">w</span> . Note that for other MPC-in-the-head proof systems where the underlying MPC protocol does not use preprocessing, most of the prover's computation cannot be done before the</p>

    <p class="text-gray-300">witness is known because the prover cannot begin emulating the MPC protocol without knowing the witness.</p>

    <p class="text-gray-300">Improved commitments. In our protocol we use a commitment scheme to hide the states of the parties following the preprocessing phase. If we are willing to model <span class="math">H</span> as a random oracle, we can streamline things by observing that all committed values have min-entropy at least <span class="math">\\kappa</span> (see further discussion below) and can thus be committed by direct evaluation of <span class="math">H</span> (i.e., we may set <span class="math">\\mathsf{com}_{j,i}:=H(\\mathsf{state}_{j,i})</span>). For the same reason, we can also omit <span class="math">r_{j}</span>. These optimizations reduce communication since no additional randomness is needed for decommitment. We use these optimizations for the performance results reported in this paper.</p>

    <p class="text-gray-300">We stress that implementing commitments in this way is no longer zero knowledge: in particular, it is possible to verify a guess for <span class="math">w</span> given <span class="math">n-1</span> of the parties’ states, a deterministic commitment to the remaining party’s state, and the transcript of the online execution of the protocol. Nevertheless, for our primary application to signatures (where <span class="math">w</span> is hard for the attacker to compute), this form of commitment suffices.</p>

    <p class="text-gray-300">Interestingly, we observe that once commitments are done in this way, then it is possible to extract (with high probability) a valid witness <span class="math">w</span> from a successful forgery without any rewinding at all; by avoiding the forking lemma, we thus obtain a tighter security reduction. In a bit more detail: consider some attacker <span class="math">\\mathcal{A}</span> making <span class="math">q_{G}</span> queries to the hash function <span class="math">G</span>. (Recall <span class="math">G</span> is the hash used for the Fiat-Shamir transform.) Each time <span class="math">\\mathcal{A}</span> makes a query of the form <span class="math">G(h^{<em>})</span>, where <span class="math">h^{</em>}</span> represents a first-round message in the 3-round protocol, the previous <span class="math">H</span>-queries made by <span class="math">\\mathcal{A}</span> define values corresponding to <span class="math">M</span> executions of the entire protocol <span class="math">\\Pi</span> (i.e., both the preprocessing phase and the online phase). If any of those <span class="math">M</span> executions is “correct,” then that execution defines a value <span class="math">w</span> such that <span class="math">C(w)=1</span>, i.e., a witness is extracted. Otherwise, the probability that the response to that <span class="math">G</span>-query allows <span class="math">\\mathcal{A}</span> to generate a valid proof is bounded by <span class="math">\\epsilon(M,n,\\tau)</span>. The overall probability that <span class="math">\\mathcal{A}</span> can generate a valid proof, yet a witness cannot be extracted, is thus dominated by <span class="math">q_{G}\\cdot\\epsilon(M,n,\\tau)</span>. (A full analysis would also take into account the negligible-probability events from footnote 3. Details will be given in the full version.) Chase et al. do not claim tight security for the non-interactive version of ZKB++, and this observation is, to the best of our knowledge, new to our work.</p>

    <p class="text-gray-300">Computation/communication trade off. In Table 2 we show the proof size and running time of the prover for circuits of various sizes. (A comparison to prior work is given below.) For computation time, we show both the total time (<span class="math">t_{\\mathsf{total}}</span>) to compute a proof, as well as the online time (<span class="math">t_{\\mathsf{online}}</span>), assuming all witness-independent work is done by the prover during an offline phase. The running time of the verifier is always roughly the same as the (total) running time of the prover, and so we do not report it. In all cases we set the parameters of the protocols so as to achieve 128-bit security against known quantum attacks; in particular, we use SHA-256 as the hash function and AES-256 for pseudorandom number generation, and set <span class="math">M,n,\\tau</span> so that <span class="math">\\epsilon(M,n,\\tau)\\leq 2^{-256}</span>.</p>

    <p class="text-gray-300">Interestingly, our protocol offers the ability to trade off communication and computation by varying <span class="math">n</span>. We show the effect of this in Table 2. By increasing <span class="math">n</span> from 8 to 64, we can reduce the proof size almost by half; however, this results in a <span class="math">4\\times</span> slowdown in the computation. Nevertheless, there may be applications that prefer to optimize proof length vs. computation time, or vice versa.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 3: Proof size of  <span class="math">\\mathrm{ZKB}++</span> , Ligero, and our protocols. Observe that our protocol yields the smallest proof size for circuits containing  <span class="math">\\approx 300 - 100,000</span>  AND gates.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">σ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Gen</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Sign</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Vrfy</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">sk</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pk</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Assumption</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This paper (n = 64)</td>

            <td class="px-3 py-2 border-b border-gray-700">38.5 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">129 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">129 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">32 B</td>

            <td class="px-3 py-2 border-b border-gray-700">64 B</td>

            <td class="px-3 py-2 border-b border-gray-700">random-oracle model</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This paper (n = 16)</td>

            <td class="px-3 py-2 border-b border-gray-700">45.9 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">28 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">28 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">32 B</td>

            <td class="px-3 py-2 border-b border-gray-700">64 B</td>

            <td class="px-3 py-2 border-b border-gray-700">random-oracle model</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ZKB++ [16]</td>

            <td class="px-3 py-2 border-b border-gray-700">118.5 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">25 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">17 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">32 B</td>

            <td class="px-3 py-2 border-b border-gray-700">64 B</td>

            <td class="px-3 py-2 border-b border-gray-700">random-oracle model</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SPHINCS-256 [9]</td>

            <td class="px-3 py-2 border-b border-gray-700">41 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">0.82 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">13 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">0.58 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">1088 B</td>

            <td class="px-3 py-2 border-b border-gray-700">1056 B</td>

            <td class="px-3 py-2 border-b border-gray-700">collision-resistant hashing</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3: Performance of signature schemes with 128-bit quantum security. We report times for key generation, signing, and verification, as well as the lengths of the signature  <span class="math">\\sigma</span> , private key  <span class="math">\\mathsf{sk}</span> , and public key  <span class="math">\\mathsf{pk}</span> .</p>

    <p class="text-gray-300">Comparison to prior work. We compare the performance of our scheme to the most relevant prior work, namely,  <span class="math">\\mathrm{ZKB}++</span>  and Ligero. As in those works, we view the size of the resulting proofs as the primary metric of interest and so focus on that.</p>

    <p class="text-gray-300">At the time of this writing, neither  <span class="math">\\mathrm{ZKB}++</span>  nor Ligero is available as an open-source implementation:  <span class="math">\\mathrm{ZKB}++</span>  (and Picnic) is only available as a signature scheme rather than as a full-fledged NIZKPoK, and code for Ligero is not available. We calculate communication complexity based on equations provided in the original papers [16, 4], but are unable to report on the computational time required by the other protocols.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For a circuit having  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  AND gates, the proofs in our NIZKPoK have length  </span>O(\\kappa \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ \\log n)<span class="math">  whereas those in ZKB++ have length  </span>O(\\kappa \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> . Since in our scheme  </span>n<span class="math">  can vary (in contrast to ZKB++ which fixes  </span>n = 3$ ), we can obtain asymptotically shorter proofs. More importantly, as discussed below, we obtain concretely shorter proofs than in ZKB++ for medium-size circuits even</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">when we fix <span class="math">n\\in\\{16,64\\}</span> as we do in our experiments.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The communication complexity of our scheme is asymptotically worse than that of Ligero, which has proofs of size $O(\\kappa\\cdot\\sqrt{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math">. However, the computational complexity of the prover in Ligero is </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log^{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, which is significant for large circuits. In contrast, the computational complexity of the prover in our protocol (after applying all the optimizations described in the text) is </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$. Concretely, we note that in our protocol all operations can use hardware acceleration, whereas Ligero requires field operations that are expected to be much slower.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Notwithstanding the fact that the communication complexity in Ligero is asymptotically better than in ours, there is a range of circuit sizes for which the concrete communication of our protocol is best. This is demonstrated in Figure 3, where we plot the communication complexity of ZKB++, Ligero, and our protocol (for two different values of <span class="math">n</span>) as the circuit size varies, for a fixed input length $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=256<span class="math">. (In all cases, parameters were set so as to achieve 128-bit quantum security.) Figure 3 shows that for very small circuits (below </span>\\approx 300<span class="math"> AND gates), ZKB++ offers the lowest communication complexity; for very large circuits (above </span>\\approx 100,000$ AND gates), Ligero is best. But in the range of 300–100,000 AND gates, our protocol outperforms both of those. This range captures many circuits of cryptographic interest, including those used in our signature scheme and the more advanced schemes introduced in Section 4.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">3.2 A Post-Quantum Signature Scheme</h3>

    <p class="text-gray-300">As in the work of Chase et al. <em>[16, 15]</em>, we can use our NIZKPoK to obtain a signature scheme whose security is based on symmetric-key primitives only. Specifically, the private key is a uniform value <span class="math">k\\in\\{0,1\\}^{\\kappa}</span>; the public key is <span class="math">y:=\\text{PRF}_{k}(0^{\\kappa})</span>, where PRF is a block cipher; and a signature is an NIZKPoK of <span class="math">k</span>, where the message being signed is included as input to the hash function <span class="math">G</span> used to compute the challenge. For 128-bit quantum security, we use a block cipher with 256-bit key and block length.</p>

    <p class="text-gray-300">We implemented the resulting signature scheme, instantiating PRF with the LowMC block cipher <em>[3]</em> that was designed to be efficient for MPC applications. Our implementation was meant to enable an “apples-to-apples” comparison to the signature scheme of Chase et al. <em>[16]</em> at a 128-bit quantum security level. In particular, we use the same hash function, pseudorandom generator, and instantiation of PRF as they do.</p>

    <p class="text-gray-300">In Table 3 we display the performance of our scheme and compare it to other post-quantum signatures based on symmetric-key primitives. Performance numbers for the ZKB++ signature scheme were obtained from a most recent technical report <em>[41]</em> that is slightly better than what is reported in <em>[16]</em>. For our scheme, we report performance for <span class="math">n=16</span> and <span class="math">n=64</span>. We find that both versions of our scheme achieve better signature length compared to the scheme of Chase et al., with an improvement of 2.6–3<span class="math">\\times</span>. The running time of our scheme is comparable to their scheme when <span class="math">n=16</span>. When <span class="math">n=64</span>, our running time is noticeably worse, but nevertheless still practical. Interestingly, the signature length of our scheme is even competitive with hash-based signature schemes (not constructed using NIZKPoKs); in particular, when <span class="math">n=64</span> our signatures are 6% shorter than those of SPHINCS-256 *[9]</p>

    <p class="text-gray-300">4 Constructing Ring and Group Signatures</p>

    <p class="text-gray-300">To highlight the flexibility and power of our NIZKPoK, we also use it to build efficient ring/group signatures based on symmetric-key primitives alone. To the best of our knowledge, the resulting schemes are the most efficient constructions of these primitives that can claim to offer post-quantum security.</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">4.1 Ring Signatures</h3>

    <p class="text-gray-300">Ring signatures were introduced by Rivest, Shamir, and Tauman <em>[44]</em>. Roughly, they allow a user to adaptively define a <em>ring</em> <span class="math">R</span> of users (of which it is a member), and then generate a signature that can be verified as having been generated by some user in that ring (without revealing precisely which one). Importantly, this can be done without the involvement of the other users in the ring.</p>

    <p class="text-gray-300">Formally, a ring signature scheme consists of three probabilistic polynomial-time algorithms (<span class="math">\\mathsf{Gen},\\mathsf{Sign},\\mathsf{Vrfy}</span>) defined as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The key-generation algorithm <span class="math">\\mathsf{Gen}</span> takes as input the security parameter <span class="math">\\kappa</span> and generates public key <span class="math">\\mathsf{pk}</span> and associated private key <span class="math">\\mathsf{sk}</span>.</li>

      <li>The signing algorithm <span class="math">\\mathsf{Sign}</span> takes as input a set (or “ring”) <span class="math">R=\\{\\mathsf{pk}_{i}\\}</span> of distinct public keys, a secret key <span class="math">\\mathsf{sk}</span> corresponding to one of the public keys in <span class="math">R</span>, and a message <span class="math">M</span>. It outputs a signature <span class="math">\\sigma</span>.</li>

      <li>The verification algorithm <span class="math">\\mathsf{Vrfy}</span> takes as input a ring <span class="math">R</span> of distinct public keys, a message <span class="math">M</span>, and a signature <span class="math">\\sigma</span>. It outputs a single bit indicating acceptance or rejection.</li>

    </ul>

    <p class="text-gray-300">Correctness requires that for any collection of keys <span class="math">\\{(\\mathsf{pk}_{i},\\mathsf{sk}_{i})\\}_{i\\in[\\ell]}</span> output by <span class="math">\\mathsf{Gen}</span>, any message <span class="math">M</span>, and any <span class="math">j\\in[\\ell]</span>, we have</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Vrfy}(\\{\\mathsf{pk}_{i}\\},M,\\mathsf{Sign}(\\{\\mathsf{pk}_{i}\\},\\mathsf{sk}_{j},M))=1.</span></p>

    <p class="text-gray-300">Ring signatures have two security requirements: unforgeability and anonymity. We present formal definitions below, following Bender et al. <em>[8]</em>.</p>

    <p class="text-gray-300">Unforgeability. Intuitively, unforgeability means that an adversary not in <span class="math">R</span> should not be able to generate a valid signature <span class="math">\\sigma</span> on a message <span class="math">M</span> relative to a ring <span class="math">R</span> unless some honest user in <span class="math">R</span> had previously signed <span class="math">M</span> (relative to the same ring) <em>[8, Definition 8]</em>.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Definition 4.1.</h6>

    <p class="text-gray-300">Ring signature scheme (<span class="math">\\mathsf{Gen}</span>, <span class="math">\\mathsf{Sign}</span>, <span class="math">\\mathsf{Vrfy}</span>) is <em>unforgeable</em> if, for any ppt adversary <span class="math">\\mathcal{A}</span> and any polynomial <span class="math">\\ell</span>, the probability that <span class="math">\\mathcal{A}</span> succeeds in the following experiment is negligible in <span class="math">\\kappa</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Keys <span class="math">\\{(\\mathsf{pk}_{i},\\mathsf{sk}_{i})\\}_{i=1}^{\\ell}</span> are generated by <span class="math">\\mathsf{Gen}(1^{\\kappa})</span>. The public keys <span class="math">S\\stackrel{{\\scriptstyle\\text{def}}}{{=}}\\{\\mathsf{pk}_{i}\\}_{i=1}^{\\ell}</span> are given to <span class="math">\\mathcal{A}</span>.</li>

      <li><span class="math">\\mathcal{A}</span> may query an oracle <span class="math">\\mathsf{Sign}^{\\prime}(\\cdot,\\cdot,\\cdot)</span>, where <span class="math">\\mathsf{Sign}^{\\prime}(R,i,M)</span> (with <span class="math">\\mathsf{pk}_{i}\\in R</span>) outputs <span class="math">\\mathsf{Sign}(R,\\mathsf{sk}_{i},M)</span>. (Note that we do not require <span class="math">R\\subseteq S</span>.)</li>

      <li><span class="math">\\mathcal{A}</span> may also query a corruption oracle <span class="math">\\mathsf{Corrupt}</span> that on input <span class="math">i</span> returns <span class="math">\\mathsf{sk}_{i}</span>. If <span class="math">\\mathcal{A}</span> queries <span class="math">\\mathsf{Corrupt}(i)</span> then we say that <span class="math">\\mathsf{pk}_{i}</span> is corrupted. We let <span class="math">\\mathcal{C}</span> be the set of corrupted public keys at the end of the experiment.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{A}</span> outputs <span class="math">M^{<em>},R^{</em>},\\sigma^{<em>}</span>. It succeeds if (1) <span class="math">\\mathsf{Vrfy}(R^{</em>},M^{<em>},\\sigma^{</em>})=1</span>; (2) <span class="math">R^{<em>}\\subseteq S\\setminus\\mathcal{C}</span>; and (3) <span class="math">\\mathcal{A}</span> never queried <span class="math">\\mathsf{Sign}^{\\prime}(R^{</em>},\\star,M^{*})</span>.</li>

    </ol>

    <h5 id="sec-21" class="text-base font-semibold mt-4">Anonymity.</h5>

    <p class="text-gray-300">Intuitively, anonymity ensures that a valid signature with respect to a ring <span class="math">R</span> does not reveal which secret key (corresponding to some public key in <span class="math">R</span>) was used to generate the signature. Our definition is based on <em>[8, Definition 5]</em>, slightly simplified for our context.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Definition 4.2.</h6>

    <p class="text-gray-300">Ring signature scheme (<span class="math">\\mathsf{Gen}</span>, <span class="math">\\mathsf{Sign}</span>, <span class="math">\\mathsf{Vrfy}</span>) is <em>anonymous</em> if, for any ppt adversary <span class="math">\\mathcal{A}</span> and any polynomial <span class="math">\\ell</span>, the probability that <span class="math">\\mathcal{A}</span> succeeds in the following experiment is at most <span class="math">1/2+\\mathsf{negl}(\\kappa)</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Keys <span class="math">\\{(\\mathsf{pk}_{i},\\mathsf{sk}_{i})\\}_{i=1}^{\\ell}</span> are generated by <span class="math">\\mathsf{Gen}(1^{\\kappa})</span> and all keys (both public and private) are given to <span class="math">\\mathcal{A}</span>.</li>

      <li><span class="math">\\mathcal{A}</span> outputs a message <span class="math">M</span>, a ring <span class="math">R</span>, and <span class="math">i_{0},i_{1}\\in[\\ell]</span>. A uniform <span class="math">b\\in\\{0,1\\}</span> is chosen, and <span class="math">\\mathcal{A}</span> is given <span class="math">\\mathsf{Sign}(R^{\\prime},sk_{i_{b}},M)</span>, where <span class="math">R^{\\prime}=R\\cup\\{\\mathsf{pk}_{i_{0}},\\mathsf{pk}_{i_{1}}\\}</span>.</li>

      <li><span class="math">\\mathcal{A}</span> outputs a bit <span class="math">b^{\\prime}</span>, and succeeds if <span class="math">b^{\\prime}=b</span>.</li>

    </ol>

    <h5 id="sec-23" class="text-base font-semibold mt-4">Constructing a ring signature scheme.</h5>

    <p class="text-gray-300">The main idea is to generate a ring signature with respect to a ring <span class="math">R</span> by generating an NIZKPoK of the secret key corresponding to one of the public keys in <span class="math">R</span>. The main question is how to do so while reducing the size of the proof as much as possible.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A naive solution to building a ring signature scheme, based on the signature scheme from the previous section, is as follows. As before, key generation chooses a uniform key <span class="math">k\\in\\{0,1\\}^{\\kappa}</span>; the corresponding public key is <span class="math">y:=\\mathrm{PRF}_{k}(0^{\\kappa})</span>. Given a ring <span class="math">R=\\{y_{i}\\}_{i=1}^{\\ell}</span> of public keys, let <span class="math">C</span> be the circuit that takes as input a key <span class="math">k</span> and outputs <span class="math">1</span> iff <span class="math">\\mathrm{PRF}_{k}(0^{\\kappa})=y_{i}</span> for some <span class="math">i</span>. (Alternately, it can take as input <span class="math">k,i</span> and output <span class="math">1</span> iff <span class="math">\\mathrm{PRF}_{k}(0^{\\kappa})=y_{i}</span>. This does not materially affect the parameters.) A signature will then be an NIZKPoK of an input <span class="math">k_{i}</span> such that <span class="math">C(k_{i})=1</span>. The size of <span class="math">C</span> (and hence the size of a signature) grows linearly in $\\ell=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Efficiency can be improved using a Merkle tree. Given a ring <span class="math">R</span> as before, we define a (public) mechanism for computing a Merkle root <span class="math">h^{<em>}</span> starting from values <span class="math">y_{1},\\ldots,y_{\\ell}</span> at the leaves; assume for simplicity that <span class="math">\\ell=2^{q}</span> for some integer <span class="math">q</span>. Let <span class="math">C</span> be a circuit that takes as input <span class="math">k</span>, <span class="math">i</span>, and an auxiliary value <span class="math">\\mathsf{path}</span>; computes <span class="math">y:=\\mathrm{PRF}_{k}(0^{\\kappa})</span>; and then outputs <span class="math">1</span> if <span class="math">\\mathsf{path}</span> is a valid Merkle proof (with respect to root <span class="math">h^{</em>}</span>) for value <span class="math">y</span> at leaf <span class="math">i</span>. As before, a signature is an NIZKPoK of an input for which <span class="math">C</span> evaluates to <span class="math">1</span>. Importantly, the size of <span class="math">C</span> (and hence the signature length) is now only logarithmic in <span class="math">\\ell</span>.</p>

    <p class="text-gray-300">Anonymity of the scheme is ensured by the zero-knowledge property of the NIZKPoK. Given an adversary who forges a signature for some ring <span class="math">R^{*}</span> of uncorrupted keys (and assuming the hash function used for the Merkle tree is collision-resistant), we can use the knowledge extractor of the NIZKPoK to extract <span class="math">k,i</span> such that <span class="math">\\mathrm{PRF}_{k}(0^{\\kappa})=y_{i}</span> for some uncorrupted party <span class="math">i</span>. That is, the adversary is able to find a private key for some uncorrupted party, which happens with negligible probability. As in the previous section, since the scheme relies on symmetric-key primitives alone it can be said to offer post-quantum security. We refer to Section 4.3 for a performance evaluation of the scheme.</p>

    <p class="text-gray-300">##</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ring/group size:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">27</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">210</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">213</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">σ</td>

            <td class="px-3 py-2 border-b border-gray-700">t</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">σ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">t</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">σ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">t</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Derler et al. [21]</td>

            <td class="px-3 py-2 border-b border-gray-700">982 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">1.35 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">1.72 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Here</td>

            <td class="px-3 py-2 border-b border-gray-700">285 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">2.0 s</td>

            <td class="px-3 py-2 border-b border-gray-700">388 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">2.8 s</td>

            <td class="px-3 py-2 border-b border-gray-700">492 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">3.6 s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Boneh et al. [12]</td>

            <td class="px-3 py-2 border-b border-gray-700">1.37 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">1.85 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Here</td>

            <td class="px-3 py-2 border-b border-gray-700">315 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">2.3 s</td>

            <td class="px-3 py-2 border-b border-gray-700">418 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">3.0 s</td>

            <td class="px-3 py-2 border-b border-gray-700">532 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">3.8 s</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Table 4: Performance of our ring/group signature schemes, and comparison to prior work.  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is the signature size, and  </span>t$  is the signing/verification time. The top two schemes are ring signatures; the bottom two are group signatures.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">A group signature scheme [17] also allows users in a group to sign messages without revealing their identity (beyond the fact that they belong to the group). The main differences between group signatures and ring signatures are that (1) in the context of group signatures, a group manager determines membership in the group; and (2) the group manager has the ability to violate anonymity by tracing the user who generated a given signature.</p>

    <p class="text-gray-300">We focus on the case of static groups for simplicity. Formally, a group signature scheme consists of four probabilistic polynomial-time algorithms (Gen, Sign, Vrfy, Open) with the following functionality:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The key-generation algorithm Gen takes as input the security parameter  <span class="math">\\kappa</span>  and the number of group members  <span class="math">\\ell</span> , and generates a master public key  <span class="math">\\mathbf{gpk}</span> , master private key  <span class="math">\\mathbf{gmsk}</span> , and signing keys  <span class="math">\\mathbf{gsk}_1, \\ldots, \\mathbf{gsk}_\\ell</span> .</li>

      <li>The signing algorithm Sign takes as input a signing key  <span class="math">\\mathbf{gsk}_i</span>  and a message  <span class="math">M</span> , and outputs a signature  <span class="math">\\sigma</span> .</li>

      <li>The verification algorithm Vrfy takes as input the master public key  <span class="math">\\mathbf{gpk}</span> , a message  <span class="math">M</span> , and a signature  <span class="math">\\sigma</span> . It outputs a bit indicating acceptance or rejection.</li>

      <li>The tracing algorithm Open takes as input the master private key  <span class="math">\\mathbf{gmsk}</span> , a message  <span class="math">M</span> , and a signature  <span class="math">\\sigma</span> . It outputs an index  <span class="math">i \\in [\\ell]</span>  or a failure symbol  <span class="math">\\perp</span> .</li>

    </ul>

    <p class="text-gray-300">Correctness requires that for any  <span class="math">\\mathsf{gpk},\\mathsf{gmsk},\\mathsf{gsk}_1,\\ldots ,\\mathsf{gsk}_{\\ell}</span>  output by Gen, any message  <span class="math">M</span>  , and any  <span class="math">i\\in [\\ell ]</span>  , we have</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {V r f y} (\\mathsf {g p k}, M, \\mathsf {S i g n} (\\mathsf {g s k} _ {i}, M)) = 1</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {O p e n} (\\operatorname {g m s k}, M, \\operatorname {S i g n} (\\operatorname {g s k} _ {i}, M)) = i.</span></div>

    <p class="text-gray-300">Bellare et al. [6] define two security requirements for group signatures: traceability and anonymity. We follow their definitions here with some differences described below.</p>

    <p class="text-gray-300">Traceability. The traceability property requires that an attacker who colludes with some set  <span class="math">\\mathcal{C}</span>  of group members cannot output a valid signature that fails to be traced by the group manager to some member of  <span class="math">\\mathcal{C}</span> .</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Definition 4.3.</h6>

    <p class="text-gray-300">Group signature scheme <span class="math">(\\mathsf{Gen},\\mathsf{Sign},\\mathsf{Vrfy},\\mathsf{Open})</span> is <em>traceable</em> if, for any ppt adversary <span class="math">\\mathcal{A}</span> and any polynomial <span class="math">\\ell</span>, the probability that <span class="math">\\mathcal{A}</span> succeeds in the following experiment is negligible in <span class="math">\\kappa</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Keys <span class="math">\\mathsf{gpk},\\mathsf{gmsk},\\mathsf{gsk}_{1},\\ldots,\\mathsf{gsk}_{\\ell}</span> are output by <span class="math">\\mathsf{Gen}(1^{\\kappa},1^{\\ell})</span>, and <span class="math">\\mathsf{gpk},\\mathsf{gmsk}</span> are given to <span class="math">\\mathcal{A}</span>.</li>

      <li><span class="math">\\mathcal{A}</span> may query an oracle <span class="math">\\mathsf{Sign}^{\\prime}(\\cdot,\\cdot)</span>, where <span class="math">\\mathsf{Sign}^{\\prime}(i,M,)</span> outputs <span class="math">\\mathsf{Sign}(\\mathsf{gsk}_{i},M)</span>.</li>

      <li><span class="math">\\mathcal{A}</span> may also query a corruption oracle <span class="math">\\mathsf{Corrupt}</span> that on input <span class="math">i</span> returns <span class="math">\\mathsf{gsk}_{i}</span>; in this case we say that user <span class="math">i</span> is corrupted. We let <span class="math">\\mathcal{C}</span> denote the set of corrupted users at the end of the experiment.</li>

      <li><span class="math">\\mathcal{A}</span> outputs <span class="math">M,\\sigma</span>, and succeeds if: (1) <span class="math">\\mathsf{Vrfy}(\\mathsf{gpk},M,\\sigma)=1</span>; (2) <span class="math">\\mathsf{Open}(\\mathsf{gmsk},M,\\sigma)\\not\\in\\mathcal{C}</span>; and (3) the adversary never made a query <span class="math">\\mathsf{Sign}^{\\prime}(\\star,M)</span>.</li>

    </ol>

    <p class="text-gray-300">As shown by Bellare et al. <em>[6]</em>, traceability implies unforgeability (simply consider <span class="math">\\mathcal{C}=\\emptyset</span> in the above definition). One could also consider a weaker definition of traceability (that still implies unforgeability) in which <span class="math">\\mathsf{gmsk}</span> is not given to the adversary. Our scheme can be made more efficient if that weaker definition suffices.</p>

    <h5 id="sec-26" class="text-base font-semibold mt-4">Anonymity.</h5>

    <p class="text-gray-300">As in the case of ring signatures, anonymity implies that a valid signature does not reveal the user who generated that signature (except to the group manager who holds <span class="math">\\mathsf{gmsk}</span>); this should hold even if the adversary is given access to a tracing oracle to which it can submit any other signature. The notion of full anonymity considered by Bellare et al. <em>[6]</em> requires signatures produced by a user <span class="math">i</span> to remain anonymous even if the secret key <span class="math">\\mathsf{gsk}_{i}</span> of that user is known to the adversary. A weaker notion <em>[14]</em> requires anonymity only for uncorrupted users. Previous work <em>[2]</em> shows that fully anonymous group signatures imply public-key encryption. Since our goal is to construct a scheme based on symmetric-key primitives alone, we consider the weaker notion of anonymity here.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Definition 4.4.</h6>

    <p class="text-gray-300">Group signature scheme <span class="math">(\\mathsf{Gen},\\mathsf{Sign},\\mathsf{Vrfy},\\mathsf{Open})</span> satisfies <em>weak anonymity</em> if, for any ppt adversary <span class="math">\\mathcal{A}</span> and any polynomial <span class="math">\\ell</span>, the probability that <span class="math">\\mathcal{A}</span> succeeds in the following experiment is at most <span class="math">1/2+\\mathsf{negl}(\\kappa)</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Keys <span class="math">\\mathsf{gpk},\\mathsf{gmsk},\\mathsf{gsk}_{1},\\ldots,\\mathsf{gsk}_{\\ell}</span> are output by <span class="math">\\mathsf{Gen}(1^{\\kappa},1^{\\ell})</span>, and <span class="math">\\mathsf{gpk}</span> is given to <span class="math">\\mathcal{A}</span>.</li>

      <li><span class="math">\\mathcal{A}</span> is given access to the following oracles:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A signing oracle that on input <span class="math">M,i</span> outputs <span class="math">\\mathsf{Sign}(\\mathsf{gsk}_{i},M)</span>.</li>

      <li>A corruption oracle that on input <span class="math">i</span> outputs <span class="math">\\mathsf{gsk}_{i}</span>. We let <span class="math">\\mathcal{C}</span> denote the set of queries made by <span class="math">\\mathcal{A}</span> to this oracle at the end of the experiment.</li>

      <li>A tracing oracle that outputs <span class="math">\\mathsf{Open}(\\mathsf{gmsk},M,\\sigma)</span>.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At some point, <span class="math">\\mathcal{A}</span> outputs a message <span class="math">M^{<em>}</span> and <span class="math">i_{0},i_{1}\\in[\\ell]</span>. Then a uniform <span class="math">b\\in\\{0,1\\}</span> is chosen, <span class="math">\\sigma^{</em>}\\leftarrow\\mathsf{Sign}(\\mathsf{gsk}_{i_{b}},M)</span> is computed, and <span class="math">\\mathcal{A}</span> is given <span class="math">\\sigma^{*}</span>.</li>

      <li><span class="math">\\mathcal{A}</span> may continue to query all the oracles above, except that it may not query its tracing oracle on <span class="math">M^{<em>},\\sigma^{</em>}</span>.</li>

      <li><span class="math">\\mathcal{A}</span> outputs a bit <span class="math">b^{\\prime}</span>, and succeeds if <span class="math">i_{0},i_{1}\\not\\in\\mathcal{C}</span> and <span class="math">b^{\\prime}=b</span>.</li>

    </ol>

    <p class="text-gray-300">Constructing a group signature scheme. Analogous to our construction of a ring signature scheme, the basic idea here is for a user to generate a signature by generating an NIZKPoK of a secret key corresponding to the group public key. Here, however, we must also ensure traceability, which adds additional complications.</p>

    <p class="text-gray-300">Assume for simplicity that <span class="math">\\ell=2^{q}</span> for some integer <span class="math">q</span>. In our scheme, the private key <span class="math">\\mathsf{gsk}_{i}</span> of a user now includes two uniform and independent keys <span class="math">k_{i}^{0},k_{i}^{1}</span>; we set <span class="math">y_{i}^{b}:=\\mathrm{PRF}_{k_{i}^{b}}(0^{\\kappa})</span>. The master private key <span class="math">\\mathsf{gmsk}</span> consists of the <span class="math">\\{k_{i}^{0}\\}</span> but, importantly, does not include the <span class="math">\\{k_{i}^{1}\\}</span>. A Merkle root <span class="math">h^{<em>}</span> is then computed for the Merkle tree with values <span class="math">(y_{1}^{0},y_{1}^{1}),\\ldots,(y_{\\ell}^{0},y_{\\ell}^{1})</span> at the <span class="math">\\ell</span> leaves of the tree. The master public key is <span class="math">h^{</em>}</span>, and the private key <span class="math">\\mathsf{gsk}_{i}</span> of a user includes the Merkle proof (with respect to <span class="math">h^{*}</span>) for <span class="math">(y_{i}^{0},y_{i}^{1})</span>.</p>

    <p class="text-gray-300">Let <span class="math">C_{x,y}</span> be a circuit that has values <span class="math">x,y</span> hardcoded; takes as input <span class="math">k^{0},k^{1}</span>, <span class="math">i</span>, and an auxiliary value <span class="math">\\mathsf{path}</span>; computes <span class="math">y^{0}:=\\mathrm{PRF}_{k^{0}}(0^{\\kappa})</span> and <span class="math">y^{1}:=\\mathrm{PRF}_{k^{1}}(0^{\\kappa})</span>; and then outputs <span class="math">1</span> iff <span class="math">y=\\mathrm{PRF}_{k^{0}}(x)</span> and <span class="math">\\mathsf{path}</span> is a valid Merkle proof (with respect to <span class="math">h^{*}</span>) for the value <span class="math">(y^{0},y^{1})</span> at leaf <span class="math">i</span>. To sign a message <span class="math">M</span>, a user <span class="math">i</span> holding <span class="math">k_{i}^{0},k_{i}^{1}</span> computes <span class="math">y=\\mathrm{PRF}_{k_{i}^{0}}(H(M))</span> and then generates an NIZKPoK of an input for which the circuit <span class="math">C_{H(M),y}</span> outputs <span class="math">1</span>; the signature includes both <span class="math">y</span> and the resulting proof. Tracing is done by finding the key <span class="math">k_{i}^{0}</span> for which <span class="math">\\mathrm{PRF}_{k_{i}^{0}}(H(M))=y</span>. We refer to Section 4.3 for a performance evaluation of the scheme.</p>

    <p class="text-gray-300">Traceability and weak anonymity of the above construction follows using standard techniques; we omit the details.</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">4.3 Implementation and Performance</h3>

    <p class="text-gray-300">We implemented the ring and group signature schemes described in the previous sections, using our NIZKPoK from Section 3.1 with <span class="math">n=64</span> so as to optimize the signature length. As previously, we target 128-bit quantum security. Both of our schemes involving constructing a circuit that can verify a Merkle path, which requires several hash-function computations. To minimize the circuit size, we derived a fixed-length hash function mapping 512-bit inputs to 256-bit outputs by applying the Davies-Meyer construction to the LowMC cipher with 256-bit key/block size. (This matches what was done in concurrent work <em>[21, 12]</em> mentioned below.) We summarize the performance of our schemes in Table 4.</p>

    <p class="text-gray-300">The signature length in our ring signature scheme asymptotically matches what is achieved by the state-of-the-art, lattice-based ring signature scheme by <em>Libert et al. [36]</em>, but the concrete efficiency of our scheme (both in terms of communication and computation) appears to be significantly better. (Libert et al. do not provide an implementation of their scheme.) As compared to their scheme, ours has the advantage of not having to rely on trusted public parameters.</p>

    <p class="text-gray-300">Recent work by <em>Ling et al. [37]</em> gives a group signature scheme based on lattices for which the signature size is independent of the number of users in the group. However, they do not investigate the concrete efficiency of their scheme, and it appears that our scheme will out-perform theirs for practical settings of the parameters.</p>

    <p class="text-gray-300">Some concurrent works <em>[21, 12]</em> have proposed constructions of ring and group signature schemes based on ideas similar to ours, but using ZKB++ as the underlying NIZKPoK. As shown in Table 4, by using our NIZKPoK in place of ZKB++ we are able to generate signatures roughly 3.5–4.4<span class="math">\\times</span> shorter than in their work. (They do not provide implementations, so we are unable to determine the running times for their schemes.)</p>

    <p class="text-gray-300">5 Conclusion</p>

    <p class="text-gray-300">We show here a new construction of a “post-quantum” NIZKPoK with shorter proof size than in prior work. We also explored applications of our work in the context of various signature schemes. It remains interesting to explore other applications of our work, e.g., to smart contracts and/or verification of arithmetic circuits.</p>

    <h2 id="sec-29" class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">We thank Claudio Orlandi, Akira Takahashi, and Greg Zaverucha for pointing out a bug in Figure 2. This material is based on work supported by NSF awards #1111599 and #1563722. Work of the second and third authors was done in part while at Bell Labs, and was supported in part by the Office of Naval Research (ONR) under contract number N00014-14-C0113. The U.S. Government is authorized to reproduce and distribute reprints for Governmental purposes not withstanding any copyright notation thereon. The views, opinions, and/or findings expressed are those of the authors and should not be interpreted as representing the official views or policies of the Department of Defense or the U.S. Government.</p>

    <h2 id="sec-30" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Michel Abdalla, Jee Hea An, Mihir Bellare, and Chanathip Namprempre. From identification to signatures via the Fiat-Shamir transform: Minimizing assumptions for security and forward-security. In Lars R. Knudsen, editor, EUROCRYPT 2002, volume 2332 of LNCS, pages 418–433, Amsterdam, The Netherlands, April 28 – May 2, 2002. Springer, Heidelberg, Germany.</li>

      <li>[2] Michel Abdalla and Bogdan Warinschi. On the minimal assumptions of group signature schemes. In Javier López, Sihan Qing, and Eiji Okamoto, editors, ICICS 04, volume 3269 of LNCS, pages 1–13, Malaga, Spain, October 27–29, 2004. Springer, Heidelberg, Germany.</li>

      <li>[3] Martin R. Albrecht, Christian Rechberger, Thomas Schneider, Tyge Tiessen, and Michael Zohner. Ciphers for MPC and FHE. In Elisabeth Oswald and Marc Fischlin, editors, EUROCRYPT 2015, Part I, volume 9056 of LNCS, pages 430–454, Sofia, Bulgaria, April 26–30, 2015. Springer, Heidelberg, Germany.</li>

      <li>[4] Scott Ames, Carmit Hazay, Yuval Ishai, and Muthuramakrishnan Venkitasubramaniam. Ligero: Lightweight sublinear arguments without a trusted setup. In ACM CCS 2017, pages 2087–2104. ACM Press, 2017.</li>

      <li>[5] Mihir Bellare and Oded Goldreich. On defining proofs of knowledge. In Ernest F. Brickell, editor, CRYPTO’92, volume 740 of LNCS, pages 390–420, Santa Barbara, CA, USA, August 16–20, 1993. Springer, Heidelberg, Germany.</li>

      <li>[6] Mihir Bellare, Daniele Micciancio, and Bogdan Warinschi. Foundations of group signatures: Formal definitions, simplified requirements, and a construction based on general assumptions. In Eli Biham, editor, EUROCRYPT 2003, volume 2656 of LNCS, pages 614–629, Warsaw, Poland, May 4–8, 2003. Springer, Heidelberg, Germany.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[7] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza. SNARKs for C: Verifying program executions succinctly and in zero knowledge. In Ran Canetti and Juan A. Garay, editors, CRYPTO 2013, Part II, volume 8043 of LNCS, pages 90–108, Santa Barbara, CA, USA, August 18–22, 2013. Springer, Heidelberg, Germany.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[8] Adam Bender, Jonathan Katz, and Ruggero Morselli. Ring signatures: Stronger definitions, and constructions without random oracles. Journal of Cryptology, 22(1):114–138, January 2009.</li>

      <li>[9] Daniel J. Bernstein, Daira Hopwood, Andreas Hülsing, Tanja Lange, Ruben Niederhagen, Louiza Papachristodoulou, Michael Schneider, Peter Schwabe, and Zooko Wilcox-O’Hearn. SPHINCS: Practical stateless hash-based signatures. In Elisabeth Oswald and Marc Fischlin, editors, EUROCRYPT 2015, Part I, volume 9056 of LNCS, pages 368–397, Sofia, Bulgaria, April 26–30, 2015. Springer, Heidelberg, Germany.</li>

      <li>[10] Manuel Blum, Alfredo De Santis, Silvio Micali, and Giuseppe Persiano. Noninteractive zero-knowledge. SIAM Journal on Computing, 20(6):1084–1118, 1991.</li>

      <li>[11] Manuel Blum, Paul Feldman, and Silvio Micali. Non-interactive zero-knowledge and its applications. In 20th ACM STOC, pages 103–112, Chicago, IL, USA, May 2–4, 1988. ACM Press.</li>

      <li>[12] Dan Boneh, Saba Eskandarian, and Ben Fisch. Post-quantum EPID group signatures from symmetric primitives. Cryptology ePrint Archive, Report 2018/261, 2018.</li>

      <li>[13] Dan Boneh, Yuval Ishai, Amit Sahai, and David J. Wu. Lattice-based SNARGs and their application to more efficient obfuscation. In Jean-Sébastien Coron and Jesper Buus Nielsen, editors, EUROCRYPT 2017, Part III, volume 10212 of LNCS, pages 247–277, Paris, France, April 30 – May 4, 2017. Springer, Heidelberg, Germany.</li>

      <li>[14] Jan Camenisch and Jens Groth. Group signatures: Better efficiency and new theoretical aspects. In Carlo Blundo and Stelvio Cimato, editors, SCN 04, volume 3352 of LNCS, pages 120–133, Amalfi, Italy, September 8–10, 2005. Springer, Heidelberg, Germany.</li>

      <li>[15] Melissa Chase, David Derler, Steven Goldfeder, Claudio Orlandi, Sebastian Ramacher, Christian Rechberger, Daniel Slamanig, and Greg Zaverucha. The picnic signature scheme design document (version 1.0), 2017. Available at https://microsoft.github.io/Picnic.</li>

      <li>[16] Melissa Chase, David Derler, Steven Goldfeder, Claudio Orlandi, Sebastian Ramacher, Christian Rechberger, Daniel Slamanig, and Greg Zaverucha. Post-quantum zero-knowledge and signatures from symmetric-key primitives. In Bhavani M. Thuraisingham, David Evans, Tal Malkin, and Dongyan Xu, editors, ACM CCS 2017, pages 1825–1842, Dallas, TX, USA, October 31 – November 2, 2017. ACM Press.</li>

      <li>[17] David Chaum and Eugène van Heyst. Group signatures. In Donald W. Davies, editor, EUROCRYPT’91, volume 547 of LNCS, pages 257–265, Brighton, UK, April 8–11, 1991. Springer, Heidelberg, Germany.</li>

    </ul>

    <p class="text-gray-300">[18] Ming-Shing Chen, Andreas Hülsing, Joost Rijneveld, Simona Samardjiska, and Peter Schwabe. SOFIA: <span class="math">\\mathcal{MQ}</span>-based signatures in the QROM. In Michel Abdalla and Ricardo Dahab, editors, PKC 2018, Part II, volume 10770 of LNCS, pages 3–33, Rio de Janeiro, Brazil, March 25–29, 2018. Springer, Heidelberg, Germany.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[19] Craig Costello, Cédric Fournet, Jon Howell, Markulf Kohlweiss, Benjamin Kreuter, Michael Naehrig, Bryan Parno, and Samee Zahur. Geppetto: Versatile verifiable computation. In 2015 IEEE Symposium on Security and Privacy, pages 253–270, San Jose, CA, USA, May 17–21, 2015. IEEE Computer Society Press.</li>

      <li>[20] Alfredo De Santis and Giuseppe Persiano. Zero-knowledge proofs of knowledge without interaction. In 33rd FOCS, pages 427–436, Pittsburgh, PA, USA, October 24–27, 1992. IEEE Computer Society Press.</li>

      <li>[21] David Derler, Sebastian Ramacher, and Daniel Slamanig. Post-quantum zero-knowledge proofs for accumulators with applications to ring signatures from symmetric-key primitives. Cryptology ePrint Archive, Report 2017/1154, 2017.</li>

      <li>[22] Uriel Feige, Dror Lapidot, and Adi Shamir. Multiple non-interactive zero knowledge proofs based on a single random string. In 31st FOCS, pages 308–317, St. Louis, MO, USA, October 22–24, 1990. IEEE Computer Society Press.</li>

      <li>[23] Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identification and signature problems. In Andrew M. Odlyzko, editor, CRYPTO’86, volume 263 of LNCS, pages 186–194, Santa Barbara, CA, USA, August 1987. Springer, Heidelberg, Germany.</li>

      <li>[24] Tore Kasper Frederiksen, Jesper Buus Nielsen, and Claudio Orlandi. Privacy-free garbled circuits with applications to efficient zero-knowledge. In Elisabeth Oswald and Marc Fischlin, editors, EUROCRYPT 2015, Part II, volume 9057 of LNCS, pages 191–219, Sofia, Bulgaria, April 26–30, 2015. Springer, Heidelberg, Germany.</li>

      <li>[25] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct NIZKs without PCPs. In Thomas Johansson and Phong Q. Nguyen, editors, EUROCRYPT 2013, volume 7881 of LNCS, pages 626–645, Athens, Greece, May 26–30, 2013. Springer, Heidelberg, Germany.</li>

      <li>[26] Craig Gentry and Daniel Wichs. Separating succinct non-interactive arguments from all falsifiable assumptions. In Lance Fortnow and Salil P. Vadhan, editors, 43rd ACM STOC, pages 99–108, San Jose, CA, USA, June 6–8, 2011. ACM Press.</li>

      <li>[27] Irene Giacomelli, Jesper Madsen, and Claudio Orlandi. ZKBoo: Faster zero-knowledge for boolean circuits. In USENIX Security Symposium, 2016.</li>

      <li>[28] Oded Goldreich, Silvio Micali, and Avi Wigderson. Proofs that yield nothing but their validity or all languages in NP have zero-knowledge proof systems. Journal of the ACM, 38(3):691–729, 1991.</li>

      <li>[29] Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of interactive proof systems. In 17th ACM STOC, pages 291–304, Providence, RI, USA, May 6–8, 1985. ACM Press.</li>

    </ul>

    <p class="text-gray-300">[30] Jens Groth. On the size of pairing-based non-interactive arguments. In Marc Fischlin and Jean-Sébastien Coron, editors, EUROCRYPT 2016, Part II, volume 9666 of LNCS, pages 305–326, Vienna, Austria, May 8–12, 2016. Springer, Heidelberg, Germany.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[31] Carmit Hazay and Muthuramakrishnan Venkitasubramaniam. On the power of secure two-party computation. In Matthew Robshaw and Jonathan Katz, editors, CRYPTO 2016, Part II, volume 9815 of LNCS, pages 397–429, Santa Barbara, CA, USA, August 14–18, 2016. Springer, Heidelberg, Germany.</li>

      <li>[32] Yuval Ishai, Eyal Kushilevitz, Rafail Ostrovsky, and Amit Sahai. Zero-knowledge from secure multiparty computation. In David S. Johnson and Uriel Feige, editors, 39th ACM STOC, pages 21–30, San Diego, CA, USA, June 11–13, 2007. ACM Press.</li>

      <li>[33] Marek Jawurek, Florian Kerschbaum, and Claudio Orlandi. Zero-knowledge using garbled circuits: How to prove non-algebraic statements efficiently. In Ahmad-Reza Sadeghi, Virgil D. Gligor, and Moti Yung, editors, ACM CCS 2013, pages 955–966, Berlin, Germany, November 4–8, 2013. ACM Press.</li>

      <li>[34] Marcel Keller, Emmanuela Orsini, and Peter Scholl. MASCOT: Faster malicious arithmetic secure computation with oblivious transfer. In Edgar R. Weippl, Stefan Katzenbeisser, Christopher Kruegel, Andrew C. Myers, and Shai Halevi, editors, ACM CCS 2016, pages 830–842, Vienna, Austria, October 24–28, 2016. ACM Press.</li>

      <li>[35] Joe Kilian. A note on efficient zero-knowledge proofs and arguments. In 24th ACM STOC, pages 723–732, Victoria, BC, Canada, May 4–6, 1992. ACM Press.</li>

      <li>[36] Benoît Libert, San Ling, Khoa Nguyen, and Huaxiong Wang. Zero-knowledge arguments for lattice-based accumulators: Logarithmic-size ring signatures and group signatures without trapdoors. In Marc Fischlin and Jean-Sébastien Coron, editors, EUROCRYPT 2016, Part II, volume 9666 of LNCS, pages 1–31, Vienna, Austria, May 8–12, 2016. Springer, Heidelberg, Germany.</li>

      <li>[37] San Ling, Khoa Nguyen, Huaxiong Wang, and Yanhong Xu. Constant-size group signatures from lattices. In Michel Abdalla and Ricardo Dahab, editors, PKC 2018, Part II, volume 10770 of LNCS, pages 58–88, Rio de Janeiro, Brazil, March 25–29, 2018. Springer, Heidelberg, Germany.</li>

      <li>[38] Silvio Micali. Computationally sound proofs. SIAM Journal on Computing, 30(4):1253–1298, 2000.</li>

      <li>[39] Dalit Naor, Moni Naor, and Jeffery Lotspiech. Revocation and tracing schemes for stateless receivers. In Joe Kilian, editor, CRYPTO 2001, volume 2139 of LNCS, pages 41–62, Santa Barbara, CA, USA, August 19–23, 2001. Springer, Heidelberg, Germany.</li>

      <li>[40] Bryan Parno, Jon Howell, Craig Gentry, and Mariana Raykova. Pinocchio: Nearly practical verifiable computation. In 2013 IEEE Symposium on Security and Privacy, pages 238–252, Berkeley, CA, USA, May 19–22, 2013. IEEE Computer Society Press.</li>

    </ul>

    <p class="text-gray-300">[41] L Perrin, Angela Promitzer, Sebastian Ramacher, and Christian Rechberger. Improvements to the linear layer of LowMC: A faster picnic. Cryptology ePrint Archive, Report 2017/1148, 2017.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[42] David Pointcheval and Jacques Stern. Security arguments for digital signatures and blind signatures. Journal of Cryptology, 13(3):361–396, 2000.</li>

      <li>[43] Samuel Ranellucci, Alain Tapp, and Rasmus Winther Zakarias. Efficient generic zero-knowledge proofs from commitments. In Anderson C. A. Nascimento and Paulo Barreto, editors, ICITS 16, volume 10015 of LNCS, pages 190–212, Tacoma, WA, USA, August 9–12, 2016. Springer, Heidelberg, Germany.</li>

      <li>[44] Ronald L. Rivest, Adi Shamir, and Yael Tauman. How to leak a secret. In Colin Boyd, editor, ASIACRYPT 2001, volume 2248 of LNCS, pages 552–565, Gold Coast, Australia, December 9–13, 2001. Springer, Heidelberg, Germany.</li>

      <li>[45] Dominique Unruh. Non-interactive zero-knowledge proofs in the quantum random oracle model. In Elisabeth Oswald and Marc Fischlin, editors, EUROCRYPT 2015, Part II, volume 9057 of LNCS, pages 755–784, Sofia, Bulgaria, April 26–30, 2015. Springer, Heidelberg, Germany.</li>

      <li>[46] Dominique Unruh. Post-quantum security of Fiat-Shamir. In Tsuyoshi Takagi and Thomas Peyrin, editors, ASIACRYPT 2017, Part I, volume 10624 of LNCS, pages 65–95, Hong Kong, China, December 3–7, 2017. Springer, Heidelberg, Germany.</li>

      <li>[47] Xiao Wang, Alex J. Malozemoff, and Jonathan Katz. Faster secure two-party computation in the single-execution setting. In Jean-Sébastien Coron and Jesper Buus Nielsen, editors, EUROCRYPT 2017, Part III, volume 10212 of LNCS, pages 399–424, Paris, France, April 30 – May 4, 2017. Springer, Heidelberg, Germany.</li>

      <li>[48] Xiao Wang, Samuel Ranellucci, and Jonathan Katz. Authenticated garbling and efficient maliciously secure two-party computation. In Bhavani M. Thuraisingham, David Evans, Tal Malkin, and Dongyan Xu, editors, ACM CCS 2017, pages 21–37, Dallas, TX, USA, October 31 – November 2, 2017. ACM Press.</li>

    </ul>

    <h2 id="sec-31" class="text-2xl font-bold">Appendix A Proof of Security for the Signature Scheme</h2>

    <p class="text-gray-300">In this section, we give a dedicated proof of security for the signature scheme constructed using our ideas. In doing so, our goals are both to give a complete proof (taking into account certain optimizations mentioned in the text), as well as to highlight the concrete-security bound we obtain.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We abstract our scheme by assuming that the key-generation algorithm <span class="math">\\mathsf{Gen}</span> outputs a pair <span class="math">(C,w)</span> with <span class="math">C(w)=1</span>, where we view <span class="math">C</span> as the public key and <span class="math">w</span> as the private key. We assume $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\kappa<span class="math"> and </span>w\\in\\{0,1\\}^{\\kappa}<span class="math">. Our hardness assumption is that, given </span>C<span class="math"> as output by </span>\\mathsf{Gen}<span class="math">, it is hard to find </span>w^{\\prime}<span class="math"> for which </span>C(w^{\\prime})=1<span class="math">. More formally, we say that </span>\\mathsf{Gen}<span class="math"> is <em></span>(t,\\epsilon)<span class="math">-one way</em> if for all adversaries </span>\\mathcal{A}<span class="math"> running in time at most </span>t$ we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\Pr[(C,w)\\leftarrow\\mathsf{Gen};w^{\\prime}\\leftarrow\\mathcal{A}(C):C(w^{\\prime})=1]\\leq\\epsilon.</span></p>

    <p class="text-gray-300">Keys: The public key is a circuit  <span class="math">C</span> ; the private key is a value  <span class="math">w</span>  for which  <span class="math">C(w) = 1</span> . Values  <span class="math">M, n, \\tau</span>  are parameters of the protocol.</p>

    <p class="text-gray-300">To sign message  <span class="math">m</span> , the signer does the following.</p>

    <p class="text-gray-300">Step 1 For each  <span class="math">j \\in [M]</span> :</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Choose uniform  <span class="math">\\mathsf{seed}_j^* \\in \\{0,1\\}^\\kappa</span>  and use it to generate values  <span class="math">\\mathsf{seed}_{j,1}</span> , ...,  <span class="math">\\mathsf{seed}_{j,n}</span>  with a PRG. Also compute  $\\mathsf{aux}_j \\in \\{0,1\\}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  as described in the text. For  </span>i = 1,\\dots ,n - 1<span class="math"> , let  </span>\\mathsf{state}_{j,i} := \\mathsf{seed}_{j,i}<span class="math"> ; let  </span>\\mathsf{state}_{j,n} := \\mathsf{seed}_{j,n} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{aux}_j$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">i\\in [n]</span>  , compute  <span class="math">\\mathsf{com}_{j,i}\\coloneqq H_0(\\mathsf{state}_{j,i})</span></li>

      <li>The signer runs the online phase of the  <span class="math">n</span> -party protocol  <span class="math">\\Pi</span>  (as described in the text) using  <span class="math">\\{\\mathsf{state}_{j,i}\\}_{i}</span> , beginning by computing the masked inputs  <span class="math">\\{\\hat{z}_{j,\\alpha}\\}</span>  (based on  <span class="math">w</span>  and the  <span class="math">\\{\\lambda_{j,\\alpha}\\}</span>  defined by the preprocessing). Let  <span class="math">\\mathsf{msgs}_{j,i}</span>  denote the messages broadcast by  <span class="math">S_{i}</span>  in this protocol execution.</li>

      <li>Let  <span class="math">h_j \\coloneqq H_1(\\mathsf{com}_{j,1}, \\ldots, \\mathsf{com}_{j,n})</span>  and  <span class="math">h_j&#x27; \\coloneqq H_2(\\{\\hat{z}_{j,\\alpha}\\}, \\mathsf{msgs}_{j,1}, \\ldots, \\mathsf{msgs}_{j,n})</span> .</li>

    </ol>

    <p class="text-gray-300">Step 2 Compute  <span class="math">(\\mathcal{C},\\mathcal{P})\\coloneqq G(m,h_1,h_1&#x27;,\\ldots ,h_M,h_M&#x27;)</span>  , where  <span class="math">\\mathcal{C}\\subset [M]</span>  is a set of size  <span class="math">\\tau</span>  , and  <span class="math">\\mathcal{P} = \\{p_j\\}_{j\\in \\mathcal{C}}</span>  with  <span class="math">p_j\\in [n]</span>  . The signature includes  <span class="math">(\\mathcal{C},\\mathcal{P})</span></p>

    <p class="text-gray-300">Step 3 For each  <span class="math">j \\in [M] \\setminus \\mathcal{C}</span> , the signer includes  <span class="math">\\mathsf{seed}_j^*</span> ,  <span class="math">h_j&#x27;</span>  in the signature. Also, for each  <span class="math">j \\in \\mathcal{C}</span> , the signer includes  <span class="math">\\{\\mathsf{state}_{j,i}\\}_{i \\neq p_j}</span> ,  <span class="math">\\mathsf{com}_{j,p_j}</span> ,  <span class="math">\\{\\hat{z}_{j,\\alpha}\\}</span> , and  <span class="math">\\mathsf{msgs}_{j,p_j}</span>  in the signature.</p>

    <p class="text-gray-300">Figure 4: The signing algorithm in our signature scheme.</p>

    <p class="text-gray-300">Theorem A.1. Suppose the PRG used is  <span class="math">(t,\\epsilon_{PRG})</span> -secure, Gen is  <span class="math">(t,\\epsilon_{OW})</span> -one-way. and that the MPC protocol described in the next section is  <span class="math">(t,\\epsilon_{\\Pi})</span> -secure. Model  <span class="math">H_0,H_1,H_2</span> , and  <span class="math">G</span>  as random oracles where  <span class="math">H_0,H_1,H_2</span>  have  <span class="math">2\\kappa</span> -bit output length. Then any attacker carrying out an adaptive chosen-message attack on the scheme of Figure 4, running in time  <span class="math">t</span> , making  <span class="math">q_s</span>  signing queries, and making  <span class="math">q_0,q_1,q_2,q_G</span>  queries, respectively, to the random oracles, succeeds in outputting a valid forgery with probability at most</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr [\\text{Forge}] \\leq q _ {s} \\cdot \\tau \\cdot \\epsilon_ {P R G} + O \\left(\\frac {(q _ {0} + q _ {1} + q _ {2} + M n q _ {s}) ^ {2}}{2 ^ {2 \\kappa}}\\right) + \\epsilon_ {O W} + q _ {G} \\cdot \\epsilon (M, n, \\tau) + \\epsilon_ {\\Pi},</span></div>

    <p class="text-gray-300">where</p>

    <div class="my-4 text-center"><span class="math-block">\\epsilon (M, n, \\tau) = \\max _ {M - \\tau \\leq k \\leq M} \\left\\{\\frac {\\binom {k} {M - \\tau}}{\\binom {M} {M - \\tau}} \\cdot n ^ {k - M + \\tau} \\right\\}.</span></div>

    <p class="text-gray-300">Proof. Fix some attacker  <span class="math">\\mathcal{A}</span> . Let  <span class="math">q_{s}</span>  denote the number of signing queries made by  <span class="math">\\mathcal{A}</span> ; let  <span class="math">q_{0}, q_{1}, q_{2}</span> , respectively, denote the number of queries to  <span class="math">H_{0}, H_{1}, H_{2}</span>  made by  <span class="math">\\mathcal{A}</span> , and let  <span class="math">q_{G}</span>  denote the number of queries to  <span class="math">G</span>  made by  <span class="math">\\mathcal{A}</span> . To prove security we define a sequence of experiments involving  <span class="math">\\mathcal{A}</span> , where the first corresponds to the experiment in which  <span class="math">\\mathcal{A}</span>  interacts with the real signature scheme. We let  <span class="math">\\operatorname{Pr}_{i}[\\cdot]</span>  refer to the probability of an event in experiment  <span class="math">i</span> . We let  <span class="math">t</span>  denote the running time</p>

    <p class="text-gray-300">A signature  <span class="math">(\\mathcal{C},\\mathcal{P},\\{\\mathrm{seed}_j^*,h_j&#x27;\\}_{j\\notin \\mathcal{C}},\\{\\{\\mathrm{state}_{j,i}\\}_{i\\neq p_j},\\mathrm{com}_{j,p_j},\\{\\hat{z}_{j,\\alpha}\\},\\mathrm{msg}_{j,p_j}\\}_{j\\in \\mathcal{C}})</span>  on a message  <span class="math">m</span>  is verified as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every  <span class="math">j \\in \\mathcal{C}</span>  and  <span class="math">i \\neq p_j</span> , set  <span class="math">\\mathsf{com}_{j,i} := H_0(\\mathsf{state}_{j,i})</span> ; then compute the value  <span class="math">h_j := H_1(\\mathsf{com}_{j,1}, \\ldots, \\mathsf{com}_{j,n})</span> .</li>

      <li>For  <span class="math">j \\notin \\mathcal{C}</span> , use  <span class="math">\\text{seed}_j^*</span>  to compute  <span class="math">h_j</span>  as the signer would.</li>

      <li>For each  <span class="math">j \\in \\mathcal{C}</span> , run an execution of  <span class="math">\\Pi</span>  among the parties  <span class="math">\\{S_i\\}_{i \\neq p_j}</span>  using  <span class="math">\\{\\text{state}_{j,i}\\}_{i \\neq p_j}</span> ,  <span class="math">\\{\\hat{z}_\\alpha\\}</span> , and  <span class="math">\\text{msg}_j, p_j</span> ; this yields  <span class="math">\\{\\text{msg}_i\\}_{i \\neq p_j}</span>  and an output bit  <span class="math">b</span> . Check that  <span class="math">b \\stackrel{?}{=} 1</span> . Then compute  <span class="math">h_j&#x27; := H_2(\\{\\hat{z}_{j,\\alpha}\\}, \\text{msg}_j, 1, \\ldots, \\text{msg}_j, n)</span> .</li>

      <li>Check that  <span class="math">(\\mathcal{C},\\mathcal{P})\\stackrel {?}{=}G(m,h_1,h_1&#x27;,\\ldots ,h_M,h_M&#x27;)</span></li>

    </ol>

    <p class="text-gray-300">Figure 5: The verification algorithm in our signature scheme.</p>

    <p class="text-gray-300">of the entire experiment, i.e., including both  <span class="math">\\mathcal{A}</span> 's running time and the time required to answer signing queries and to verify  <span class="math">\\mathcal{A}</span> 's output.</p>

    <p class="text-gray-300">Experiment 1. This corresponds to the interaction of  <span class="math">\\mathcal{A}</span>  with the real signature scheme. In more detail: first Gen is run to obtain  <span class="math">(C, w)</span> , and  <span class="math">\\mathcal{A}</span>  is given the public key  <span class="math">C</span> . In addition, we assume the random oracles  <span class="math">H_0, H_1, H_2</span> , and  <span class="math">G</span>  are chosen uniformly from the appropriate spaces.  <span class="math">\\mathcal{A}</span>  may make signing queries, which will be answered as in Figure 4;  <span class="math">\\mathcal{A}</span>  may also query any of the random oracles. Finally,  <span class="math">\\mathcal{A}</span>  outputs a message/signature pair; we let Forge denote the event that the message was not previously queried by  <span class="math">\\mathcal{A}</span>  to its signing oracle, and the signature is valid. We are interested in upper-bounding  <span class="math">\\operatorname{Pr}_1[\\text{Forge}]</span> .</p>

    <p class="text-gray-300">Experiment 2. We abort the experiment if, during the course of the experiment, a collision in  <span class="math">H_0</span> ,  <span class="math">H_1</span> , or  <span class="math">H_2</span>  is found. Suppose  <span class="math">q = \\max \\{q_0, q_1, q_2\\}</span> , then the number of queries to any oracle throughout the experiment (by either the adversary or the signing algorithm) is at most  <span class="math">(q + Mnq_s)</span> . Thus,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr_ {1} [ \\text {F o r g e} ] - \\Pr_ {2} [ \\text {F o r g e} ]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\frac {3 (q + M n q _ {s}) ^ {2}}{2 ^ {2 \\kappa}}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Experiment 3. Here we modify the way signing is done. Specifically, when signing a message  <span class="math">m</span>  we begin by choosing  <span class="math">(\\mathcal{C},\\mathcal{P})</span>  uniformly. Steps 1 and 3 of the signing algorithm are computed as before, but in step 2 we simply set the output of  <span class="math">G</span>  equal to  <span class="math">(\\mathcal{C},\\mathcal{P})</span> . Formally, a signature on a message  <span class="math">m</span>  is now computed as follows:</p>

    <p class="text-gray-300">Step 0 Choose uniform  <span class="math">(\\mathcal{C},\\mathcal{P})</span> , where  <span class="math">\\mathcal{C}\\subset [M]</span>  is a set of size  <span class="math">\\tau</span> , and  <span class="math">\\mathcal{P} = \\{p_j\\}_{j\\in \\mathcal{C}}</span>  with  <span class="math">p_j\\in [n]</span> .</p>

    <p class="text-gray-300">Step 1 For each  <span class="math">j \\in [M]</span> :</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Choose uniform  <span class="math">\\mathsf{seed}_j^* \\in \\{0,1\\}^\\kappa</span>  and use it to generate values  <span class="math">\\mathsf{seed}_{j,1}</span> , ...,  <span class="math">\\mathsf{seed}_{j,n}</span>  and  $\\mathsf{aux}_j \\in \\{0,1\\}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> . For  </span>i = 1,\\dots,n-1<span class="math"> , let  </span>\\mathsf{state}_{j,i} := \\mathsf{seed}_{j,i}<span class="math"> ; let  </span>\\mathsf{state}_{j,n} := \\mathsf{seed}_{j,n} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{aux}_j$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">i \\in [n]</span>, compute <span class="math">\\mathsf{com}_{j,i} := H_0(\\mathsf{state}_{j,i})</span>.</li>

      <li>Run the online phase of the <span class="math">n</span>-party protocol <span class="math">\\Pi</span> using <span class="math">\\{\\mathsf{state}_{j,i}\\}_i</span>, beginning by computing the masked inputs <span class="math">\\{\\hat{z}_{j,\\alpha}\\}</span> (based on <span class="math">w</span> and the <span class="math">\\{\\lambda_{j,\\alpha}\\}</span> defined by the preprocessing). Let <span class="math">\\mathsf{msgs}_{j,i}</span> denote the messages broadcast by <span class="math">S_i</span> in this protocol execution.</li>

      <li>Let <span class="math">h_j := H_1(\\mathsf{com}_{j,1}, \\ldots, \\mathsf{com}_{j,n})</span> and <span class="math">h_j&#x27; := H_2(\\{\\hat{z}_{j,\\alpha}\\}, \\mathsf{msgs}_{j,1}, \\ldots, \\mathsf{msgs}_{j,n})</span>.</li>

    </ol>

    <p class="text-gray-300"><strong>Step 2</strong> Set <span class="math">G(m, h_1, h_1&#x27;, \\ldots, h_M, h_M&#x27;)</span> equal to <span class="math">(\\mathcal{C}, \\mathcal{P})</span>. (I.e., if <span class="math">\\mathcal{A}</span> subsequently makes the query <span class="math">G(m, h_1, h_1&#x27;, \\ldots, h_M, h_M&#x27;)</span>, return <span class="math">(\\mathcal{C}, \\mathcal{P})</span> as the output.) Include <span class="math">(\\mathcal{C}, \\mathcal{P})</span> in the signature.</p>

    <p class="text-gray-300"><strong>Step 3</strong> For each <span class="math">j \\in [M] \\setminus \\mathcal{C}</span>, the signer includes <span class="math">\\mathsf{seed}_j^*, h_j&#x27;</span> in the signature. Also, for each <span class="math">j \\in \\mathcal{C}</span>, the signer includes <span class="math">\\{\\mathsf{state}_{j,i}\\}_{i \\neq p_j}</span>, <span class="math">\\mathsf{com}_{j,p_j}</span>, <span class="math">\\{\\hat{z}_{j,\\alpha}\\}</span>, and <span class="math">\\mathsf{msgs}_{j,p_j}</span> in the signature.</p>

    <p class="text-gray-300">The only difference between this experiment and the previous one occurs if, in the course of answering a signing query, the query to <span class="math">G</span> in step 2 was ever made before (by either the adversary or as part of answering some other signing query). Letting <span class="math">\\mathsf{InputColl}_G</span> denote this event, we have</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr_3[\\text{Forge}] - \\Pr_2[\\text{Forge}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\Pr_3[\\text{InputColl}_G].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><strong>Experiment 4.</strong> Here we again modify the way signing is done. Now, the signer chooses uniform <span class="math">\\{\\mathsf{seed}_{j,i}\\}_{i=1}^n</span> for all <span class="math">j \\in \\mathcal{C}</span>. That is, signatures are now computed as follows:</p>

    <p class="text-gray-300"><strong>Step 0</strong> Choose uniform <span class="math">(\\mathcal{C},\\mathcal{P})</span>, where <span class="math">\\mathcal{C} \\subset [M]</span> is a set of size <span class="math">\\tau</span>, and <span class="math">\\mathcal{P} = \\{p_j\\}_{j \\in \\mathcal{C}}</span> with <span class="math">p_j \\in [n]</span>.</p>

    <p class="text-gray-300"><strong>Step 1</strong> For each <span class="math">j \\in [M]</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">j \\notin \\mathcal{C}</span>, choose uniform <span class="math">\\mathsf{seed}_j^* \\in \\{0,1\\}^\\kappa</span> and use it to generate values <span class="math">\\mathsf{seed}_{j,1}, \\ldots, \\mathsf{seed}_{j,n}</span>. If <span class="math">j \\in \\mathcal{C}</span>, choose uniform <span class="math">\\mathsf{seed}_{j,1}, \\ldots, \\mathsf{seed}_{j,n} \\in \\{0,1\\}^\\kappa</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. Compute $\\mathsf{aux}_j \\in \\{0,1\\}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> based on </span>\\{\\mathsf{seed}_{j,i}\\}_i<span class="math">. For </span>i = 1,\\dots,n-1<span class="math">, let </span>\\mathsf{state}_{j,i} := \\mathsf{seed}_{j,i}<span class="math">; let </span>\\mathsf{state}_{j,n} := \\mathsf{seed}_{j,n} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{aux}_j$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">i \\in [n]</span>, compute <span class="math">\\mathsf{com}_{j,i} := H_0(\\mathsf{state}_{j,i})</span>.</li>

      <li>Run the online phase of the <span class="math">n</span>-party protocol <span class="math">\\Pi</span> using <span class="math">\\{\\mathsf{state}_{j,i}\\}_i</span>, beginning by computing the masked inputs <span class="math">\\{\\hat{z}_{j,\\alpha}\\}</span> (based on <span class="math">w</span> and the <span class="math">\\{\\lambda_{j,\\alpha}\\}</span> defined by the preprocessing). Let <span class="math">\\mathsf{msgs}_{j,i}</span> denote the messages broadcast by <span class="math">S_i</span> in this protocol execution.</li>

      <li>Let <span class="math">h_j := H_1(\\mathsf{com}_{j,1}, \\ldots, \\mathsf{com}_{j,n})</span> and <span class="math">h_j&#x27; := H_2(\\{\\hat{z}_{j,\\alpha}\\}, \\mathsf{msgs}_{j,1}, \\ldots, \\mathsf{msgs}_{j,n})</span>.</li>

    </ol>

    <p class="text-gray-300"><strong>Step 2</strong> Set <span class="math">G(m, h_1, h_1&#x27;, \\ldots, h_M, h_M&#x27;)</span> equal to <span class="math">(\\mathcal{C}, \\mathcal{P})</span>. (I.e., if <span class="math">\\mathcal{A}</span> subsequently makes the query <span class="math">G(m, h_1, h_1&#x27;, \\ldots, h_M, h_M&#x27;)</span>, return <span class="math">(\\mathcal{C}, \\mathcal{P})</span> as the output.) Include <span class="math">(\\mathcal{C}, \\mathcal{P})</span> in the signature.</p>

    <p class="text-gray-300"><strong>Step 3</strong> For each <span class="math">j \\notin \\mathcal{C}</span>, include <span class="math">\\mathsf{seed}_j^*, h_j&#x27;</span> in the signature. For each <span class="math">j \\in \\mathcal{C}</span>, include <span class="math">\\{\\mathsf{state}_{j,i}\\}_{i \\neq p_j}</span>, <span class="math">\\mathsf{com}_{j,p_j}</span>, <span class="math">\\{\\hat{z}_{j,\\alpha}\\}</span>, and <span class="math">\\mathsf{msgs}_{j,p_j}</span> in the signature.</p>

    <p class="text-gray-300">It is easy to see that if the pseudorandom generator is <span class="math">(t, \\epsilon_{PRG})</span>-secure, then</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr_4[\\text{Forge}] - \\Pr_3[\\text{Forge}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq q_s \\cdot \\tau \\cdot \\epsilon_{PRG} \\quad \\text{and} \\quad</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr_4[\\text{InputColl}_G] - \\Pr_3[\\text{InputColl}_G]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq q_s \\cdot \\tau \\cdot \\epsilon_{PRG}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We now bound <span class="math">\\operatorname{Pr}_4[\\mathsf{InputColl}_G]</span>. Fix some previous query <span class="math">(m, h_1, h_1&#x27;, \\ldots, h_M, h_M&#x27;)</span> to <span class="math">G</span>, and look at a query <span class="math">G(\\hat{m}, \\hat{h}_1, \\hat{h}_1&#x27;, \\ldots, \\hat{h}_M, \\hat{h}_M&#x27;)</span> made while responding to some signing query. (In the rest of</p>

    <p class="text-gray-300">29</p>

    <p class="text-gray-300">this discussion, we will use <span class="math">\\hat{\\cdot}</span> to represent values computed as part of answering that signing query.) For some fixed <span class="math">j\\in\\hat{\\mathcal{C}}</span>, it is not hard to see that the probability of the event <span class="math">\\hat{h}_j = h_j</span> is maximized if <span class="math">h_j</span> was output by a previous query <span class="math">H_{1}(\\mathsf{com}_{1},\\ldots ,\\mathsf{com}_{n})</span>, and each <span class="math">\\mathsf{com}_i</span> was output by a previous query <span class="math">H_0(\\mathsf{state}_i)</span>. (In all cases, the relevant prior query must be unique since the experiment is aborted if there is a collision in <span class="math">H_0</span> or <span class="math">H_{1}</span>.) In that case, the probability that <span class="math">\\hat{h}_j = h_j</span> is at most</p>

    <div class="my-4 text-center"><span class="math-block">(2 ^ {- \\kappa} + 2 ^ {- 2 \\kappa}) ^ {n} + 2 ^ {- 2 \\kappa} \\leq 2 \\cdot 2 ^ {- 2 \\kappa}</span></div>

    <p class="text-gray-300">(assuming <span class="math">n \\geq 3</span>), and thus the probability that <span class="math">\\hat{h}_j = h_j</span> for all <span class="math">j \\in \\hat{\\mathcal{C}}</span> is at most <span class="math">2^{-\\tau \\cdot (2\\kappa - 1)}</span>. Taking a union bound over all signing queries and all queries made to <span class="math">G</span> (including those made during the course of answering signing queries), we conclude that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_ {4} [ \\text {InputColl} _ {G} ] \\leq q _ {s} \\cdot \\left(q _ {s} + q _ {G}\\right) \\cdot 2 ^ {- \\tau \\cdot (2 \\kappa - 1)}.</span></div>

    <p class="text-gray-300">Experiment 5. Here we again modify the way signing is done. Now:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">j \\in \\mathcal{C}</span>, choose uniform <span class="math">\\operatorname{com}_{j,p_j}</span> (i.e., without making the corresponding query to <span class="math">H_0</span>).</li>

      <li>For each <span class="math">j \\notin \\mathcal{C}</span>, choose uniform <span class="math">h_j&#x27;</span> (i.e., without making the corresponding query to <span class="math">H_2</span>).</li>

    </ul>

    <p class="text-gray-300">So, signatures are now computed as follows:</p>

    <p class="text-gray-300"><strong>Step 0</strong> Choose uniform <span class="math">(\\mathcal{C},\\mathcal{P})</span>, where <span class="math">\\mathcal{C} \\subset [M]</span> is a set of size <span class="math">\\tau</span>, and <span class="math">\\mathcal{P} = \\{p_j\\}_{j \\in \\mathcal{C}}</span> with <span class="math">p_j \\in [n]</span>.</p>

    <p class="text-gray-300"><strong>Step 1</strong> For each <span class="math">j \\in [M]</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">j \\notin \\mathcal{C}</span>, choose uniform <span class="math">\\operatorname{seed}_j^* \\in \\{0, 1\\}^\\kappa</span> and use it to generate values <span class="math">\\operatorname{seed}_{j,1}</span>, ..., <span class="math">\\operatorname{seed}_{j,n}</span>. If <span class="math">j \\in \\mathcal{C}</span>, choose uniform <span class="math">\\operatorname{seed}_{j,1}</span>, ..., <span class="math">\\operatorname{seed}_{j,n} \\in \\{0, 1\\}^\\kappa</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. Compute $\\mathsf{aux}_j\\in \\{0,1\\}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> based on </span>\\{\\mathsf{seed}_{j,i}\\}_{i}<span class="math">. For </span>i = 1,\\dots ,n - 1<span class="math">, let </span>\\mathsf{state}_{j,i}\\coloneqq \\mathsf{seed}_{j,i}<span class="math">; let </span>\\mathsf{state}_{j,n}\\coloneqq \\mathsf{seed}_{j,n}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{aux}_j$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">j \\in \\mathcal{C}</span>, choose uniform <span class="math">\\operatorname{com}_{j,p_j} \\in \\{0,1\\}^{2\\kappa}</span>. For all other <span class="math">j,i</span>, set <span class="math">\\operatorname{com}_{j,i} := H_0(\\mathsf{state}_{j,i})</span>.</li>

      <li>Run the online phase of the <span class="math">n</span>-party protocol <span class="math">\\Pi</span> using <span class="math">\\{\\mathsf{state}_{j,i}\\}_{i}</span>, beginning by computing the masked inputs <span class="math">\\{\\hat{z}_{j,\\alpha}\\}</span> (based on <span class="math">w</span> and the <span class="math">\\{\\lambda_{j,\\alpha}\\}</span> defined by the preprocessing). Let <span class="math">\\mathsf{msgs}_{j,i}</span> denote the messages broadcast by <span class="math">S_{i}</span> in this protocol execution.</li>

      <li>Let <span class="math">h_j \\coloneqq H_1(\\mathsf{com}_{j,1}, \\ldots, \\mathsf{com}_{j,n})</span>. If <span class="math">j \\in \\mathcal{C}</span>, set <span class="math">h_j&#x27; \\coloneqq H_2(\\{\\hat{z}_{j,\\alpha}\\}, \\mathsf{msgs}_{j,1}, \\ldots, \\mathsf{msgs}_{j,n})</span>; otherwise, choose uniform <span class="math">h_j&#x27; \\in \\{0, 1\\}^{2\\kappa}</span>.</li>

    </ol>

    <p class="text-gray-300"><strong>Step 2</strong> Set <span class="math">G(m, h_1, h_1&#x27;, \\ldots, h_M, h_M&#x27;)</span> equal to <span class="math">(\\mathcal{C}, \\mathcal{P})</span>. (I.e., if <span class="math">\\mathcal{A}</span> subsequently makes the query <span class="math">G(m, h_1, h_1&#x27;, \\ldots, h_M, h_M&#x27;)</span>, return <span class="math">(\\mathcal{C}, \\mathcal{P})</span> as the output.) Include <span class="math">(\\mathcal{C}, \\mathcal{P})</span> in the signature.</p>

    <p class="text-gray-300"><strong>Step 3</strong> For each <span class="math">j \\notin \\mathcal{C}</span>, include <span class="math">\\operatorname{seed}_j^*, h_j&#x27;</span> in the signature. For each <span class="math">j \\in \\mathcal{C}</span>, include <span class="math">\\{\\mathsf{state}_{j,i}\\}_{i \\neq p_j}</span>, <span class="math">\\mathsf{com}_{j,p_j}</span>, <span class="math">\\{\\hat{z}_{j,\\alpha}\\}</span>, and <span class="math">\\mathsf{msgs}_{j,p_j}</span> in the signature.</p>

    <p class="text-gray-300">The only difference between this experiment and the previous one occurs if, during the course of answering a signing query, <span class="math">\\mathsf{state}_{j,p_j}</span> (for some <span class="math">j\\in \\mathcal{C}</span>) is queried to <span class="math">H_0</span> at some other point in the experiment, or <span class="math">(\\{\\hat{z}_{j,\\alpha}\\},\\mathsf{msgs}_{j,1},\\ldots ,\\mathsf{msgs}_{j,n})</span> (for some <span class="math">j\\notin \\mathcal{C}</span>) is ever queried to <span class="math">H_{2}</span> at some other point in the experiment. Denoting this event by <span class="math">\\mathsf{InputColl}_H</span>, we thus have</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname <em> {P r} _ {5} [ \\text {F o r g e} ] - \\operatorname </em> {P r} _ {4} [ \\text {F o r g e} ]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\operatorname * {P r} _ {5} [ \\text {I n p u t C o l l} _ {H} ].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Experiment 6. We again modify the signing algorithm. Now, for <span class="math">j \\in \\mathcal{C}</span> the signer uses the simulator for <span class="math">\\Pi</span> (namely, <span class="math">\\mathsf{Sim}_{\\Pi}</span>) to generate the views of the parties <span class="math">\\{S_i\\}_{i \\neq p_j}</span> in an execution of <span class="math">\\Pi</span> when evaluating <span class="math">C</span> with output 1. This results in values <span class="math">\\{\\mathsf{state}_{j,i}\\}_{i \\neq p_j}</span>, masked input-wire values <span class="math">\\{\\hat{z}_{j,\\alpha}\\}</span>, and <span class="math">\\mathsf{msgs}_{j,p_j}</span>. From the respective views, <span class="math">\\{\\mathsf{msgs}_{j,i}\\}_{i \\neq p_j}</span> can be computed, and <span class="math">h_j, h_j&#x27;</span> can be computed as well. Thus, signatures are now computed as follows:</p>

    <p class="text-gray-300"><strong>Step 0</strong> Choose uniform <span class="math">(\\mathcal{C},\\mathcal{P})</span>, where <span class="math">\\mathcal{C} \\subset [M]</span> is a set of size <span class="math">\\tau</span>, and <span class="math">\\mathcal{P} = \\{p_j\\}_{j \\in \\mathcal{C}}</span> with <span class="math">p_j \\in [n]</span>.</p>

    <p class="text-gray-300"><strong>Step 1</strong> For <span class="math">j \\notin \\mathcal{C}</span>:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Choose uniform <span class="math">\\mathsf{seed}_j^* \\in \\{0,1\\}^\\kappa</span> and use it to generate values <span class="math">\\mathsf{seed}_{j,1}</span>, ..., <span class="math">\\mathsf{seed}_{j,n}</span>. Compute $\\mathsf{aux}_j \\in \\{0,1\\}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> based on </span>\\{\\mathsf{seed}_{j,i}\\}_i<span class="math">. For </span>i = 1,\\dots ,n - 1<span class="math">, let </span>\\mathsf{state}_{j,i} := \\mathsf{seed}_{j,i}<span class="math">; let </span>\\mathsf{state}_{j,n} := \\mathsf{seed}_{j,n} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{aux}_j$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For all <span class="math">i</span>, set <span class="math">\\mathsf{com}_{j,i} := H_0(\\mathsf{state}_{j,i})</span>.</li>

      <li>Let <span class="math">h_j \\coloneqq H_1(\\mathsf{com}_{j,1}, \\ldots, \\mathsf{com}_{j,n})</span>. Choose uniform <span class="math">h_j&#x27; \\in \\{0, 1\\}^{2\\kappa}</span>.</li>

    </ol>

    <p class="text-gray-300">For each <span class="math">j \\in \\mathcal{C}</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">(\\{\\mathsf{state}_{j,i}\\}_{i \\neq p_j}, \\{\\hat{z}_{j,\\alpha}\\}, \\mathsf{msgs}_{j,p_j}) \\gets \\mathsf{Sim}_{\\Pi}(p_j)</span>. Compute <span class="math">\\{\\mathsf{msgs}_{j,i}\\}_{i \\neq p_j}</span> based on this information.</li>

      <li>Choose uniform <span class="math">\\mathsf{com}_{j,p_j} \\in \\{0,1\\}^{2\\kappa}</span>. For all other <span class="math">i</span>, set <span class="math">\\mathsf{com}_{j,i} := H_0(\\mathsf{state}_{j,i})</span>.</li>

      <li>Let <span class="math">h_j \\coloneqq H_1(\\mathsf{com}_{j,1}, \\ldots, \\mathsf{com}_{j,n})</span> and <span class="math">h_j&#x27; \\coloneqq H_2(\\{\\hat{z}_{j,\\alpha}\\}, \\mathsf{msgs}_{j,1}, \\ldots, \\mathsf{msgs}_{j,n})</span>.</li>

    </ol>

    <p class="text-gray-300"><strong>Step 2</strong> Set <span class="math">G(m, h_1, h_1&#x27;, \\ldots, h_M, h_M&#x27;)</span> equal to <span class="math">(\\mathcal{C}, \\mathcal{P})</span>. (I.e., if <span class="math">\\mathcal{A}</span> subsequently makes the query <span class="math">G(m, h_1, h_1&#x27;, \\ldots, h_M, h_M&#x27;)</span>, return <span class="math">(\\mathcal{C}, \\mathcal{P})</span> as the output.) Include <span class="math">(\\mathcal{C}, \\mathcal{P})</span> in the signature.</p>

    <p class="text-gray-300"><strong>Step 3</strong> For each <span class="math">j \\notin \\mathcal{C}</span>, the signer includes <span class="math">\\mathsf{seed}_j^*, h_j&#x27;</span> in the signature. Also, for each <span class="math">j \\in \\mathcal{C}</span>, the signer includes <span class="math">\\{\\mathsf{state}_{j,i}\\}_{i \\neq p_j}</span>, <span class="math">\\mathsf{com}_{j,p_j}</span>, <span class="math">\\{\\hat{z}_{j,\\alpha}\\}</span>, and <span class="math">\\mathsf{msgs}_{j,p_j}</span> in the signature.</p>

    <p class="text-gray-300">Observe that <span class="math">w</span> is no longer used for generating signatures. It is immediate that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr_ {6} [ \\text {F o r g e} ] - \\Pr_ {5} [ \\text {F o r g e} ]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\tau \\cdot q _ {s} \\cdot \\epsilon_ {\\Pi} \\text{ and }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr_ {6} [ \\text {I n p u t C o l l} _ {H} ] - \\Pr_ {5} [ \\text {I n p u t C o l l} _ {H} ]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\tau \\cdot q _ {s} \\cdot \\epsilon_ {\\Pi}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We now bound <span class="math">\\operatorname{Pr}_6[\\mathsf{InputColl}_H]</span>. For any particular signing query and any <span class="math">j \\in \\mathcal{C}</span>, the value <span class="math">\\mathsf{state}_{j,p_j}</span> has min-entropy at least <span class="math">\\kappa</span> and is not used anywhere else in the experiment. Similarly, for any <span class="math">j \\notin \\mathcal{C}</span>, the value <span class="math">\\{\\hat{z}_{j,\\alpha}\\}</span> has min-entropy at least <span class="math">\\kappa</span>, since the input is <span class="math">\\kappa</span>-bit and they are all uniform according to the simulator defined in the next section. and is not used anywhere else in the experiment. Thus,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_ {6} [ \\text {I n p u t C o l l} _ {H} ] \\leq M \\cdot q _ {s} \\cdot (M q _ {s} + q _ {0} + q _ {2}) \\cdot 2 ^ {- \\kappa}.</span></div>

    <p class="text-gray-300"><strong>Experiment 7.</strong> We first define some notation. At any point during the experiment, we classify a pair <span class="math">(h,h^{\\prime})</span> in one of the following ways:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">h</span> was output by a previous query <span class="math">H_{1}(\\mathsf{com}_{1},\\ldots ,\\mathsf{com}_{n})</span>, and each <span class="math">\\mathsf{com}_i</span> was output by a previous query <span class="math">H_0(\\mathsf{state}_i)</span> where the <span class="math">\\{\\mathsf{state}_i\\}</span> form a valid preprocessing, then say <span class="math">(h,h^{\\prime})</span> defines correct preprocessing.</li>

    </ol>

    <p class="text-gray-300">31</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">h</span> was output by a previous query <span class="math">H_{1}(\\mathsf{com}_{1},\\ldots,\\mathsf{com}_{n})</span>, and each <span class="math">\\mathsf{com}_{i}</span> was output by a previous query <span class="math">H_{0}(\\mathsf{state}_{i})</span>, and <span class="math">h^{\\prime}</span> was output by a previous query <span class="math">H_{2}(\\{\\hat{z}_{\\alpha}\\},\\mathsf{msgs}_{1},\\ldots,\\mathsf{msgs}_{n})</span> where <span class="math">\\{\\mathsf{state}_{i}\\},\\{\\hat{z}_{\\alpha}\\},\\{\\mathsf{msgs}_{i}\\}</span> are consistent with an online execution of <span class="math">\\Pi</span> among all parties with output 1 (but the <span class="math">\\{\\mathsf{state}_{i}\\}</span> may not form a valid preprocessing), then say <span class="math">(h,h^{\\prime})</span> defines correct execution.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In any other case, say <span class="math">(h,h^{\\prime})</span> is bad.</li>

    </ol>

    <p class="text-gray-300">(Note that in all cases the relevant prior query, if it exists, must be unique since the experiment is aborted if there is ever a collision in <span class="math">H_{0},H_{1}</span>, or <span class="math">H_{2}</span>.)</p>

    <p class="text-gray-300">In Experiment 7, for each query <span class="math">G(m,h_{1},h_{1}^{\\prime},\\ldots,h_{M},h_{M}^{\\prime})</span> made by the adversary (where <span class="math">m</span> was not previously queried to the signing oracle ), check if there exists an index <span class="math">j</span> for which <span class="math">(h_{j},h_{j}^{\\prime})</span> defines correct preprocessing and correct execution. We let Invert be the event that this occurs for some query to <span class="math">G</span>. Note that if that event occurs, the <span class="math">\\{\\mathsf{state}_{i}\\},\\{\\hat{z}_{\\alpha}\\}</span> (which can be determined from the oracle queries of the adversary) allow computation of <span class="math">w^{\\prime}</span> for which <span class="math">C(w^{\\prime})=1</span>. Thus, <span class="math">\\Pr_{7}[\\mathsf{Invert}]\\leq\\epsilon_{OW}</span>.</p>

    <p class="text-gray-300">We claim that</p>

    <p class="text-gray-300"><span class="math">\\Pr_{7}[\\mathsf{Forge}\\wedge\\overline{\\mathsf{Invert}}]\\leq q_{G}\\cdot\\epsilon(M,n,\\tau).</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To see this, assume Invert does not occur. For any query <span class="math">G(m,h_{1},h_{1}^{\\prime},\\ldots,h_{M},h_{M}^{\\prime})</span> made during the experiment (where <span class="math">m</span> was not previously queried to the signing oracle), let <span class="math">\\mathsf{Pre}</span> denote the set of indices for which <span class="math">(h_{j},h_{j}^{\\prime})</span> defines correct preprocessing (but not correct execution), and let $k=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Pre}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Let </span>(\\mathcal{C},\\mathcal{P})<span class="math"> be the (random) answer from this query to </span>G<span class="math">. The attacker can only possibly generate a forgery (using this </span>G<span class="math">-query) if (1) </span>[M]\\setminus\\mathcal{C}\\subseteq\\mathsf{Pre}<span class="math">, and (2) for all </span>j\\in\\mathsf{Pre}\\cap\\mathcal{C}<span class="math">, the value </span>p_{j}<span class="math"> is chosen to be the unique party such that the views of the remaining parties </span>\\{S_{i}\\}_{i\\neq p_{j}}<span class="math"> are consistent . Since </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M\\setminus\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=M-\\tau<span class="math">, the number of ways the first event can occur is </span>\\binom{k}{M-\\tau}<span class="math">; given this, there are </span>k-(M-\\tau)<span class="math"> elements remaining </span>\\mathsf{Pre}\\cap\\mathcal{C}<span class="math">. Thus, the overall probability with which the attacker can generate a forgery using this </span>G$-query is</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\epsilon(M,n,\\tau,k)</span> <span class="math">=</span> <span class="math">\\frac{\\binom{k}{M-\\tau}\\cdot n^{M-k}}{\\binom{M}{M-\\tau}\\cdot n^{\\tau}}</span> <span class="math">=</span> <span class="math">\\frac{\\binom{k}{M-\\tau}}{\\binom{M}{M-\\tau}\\cdot n^{k-M+\\tau}}</span> <span class="math">\\leq</span> <span class="math">\\epsilon(M,n,\\tau)=\\max_{k}\\left\\{\\epsilon(M,n,\\tau,k)\\right\\}.</span></p>

    <p class="text-gray-300">The final bound is obtained by taking a union bound over all queries to <span class="math">G</span>.</p>

    <p class="text-gray-300">∎</p>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">A.1 Proof of Security of the Underlying MPC Protocol</h3>

    <p class="text-gray-300">Our protocol <span class="math">\\Pi</span>, simulated in the Prover’s head, maintains the invariant that, for each wire in the circuit, the parties hold the (public) masked value of the wire and an <span class="math">n</span>-out-of-<span class="math">n</span> secret sharing of the corresponding random mask. Specifically, if we let <span class="math">z_{\\alpha}</span> denote the value of wire <span class="math">\\alpha</span> in the circuit <span class="math">C</span> when evaluated on input <span class="math">w</span>, then the parties will hold <span class="math">[\\lambda_{\\alpha}]</span> (for uniform <span class="math">\\lambda_{\\alpha}\\in\\{0,1\\}</span>) along with the value <span class="math">\\hat{z}_{\\alpha}\\stackrel{{\\scriptstyle\\rm def}}{{=}}z_{\\alpha}\\oplus\\lambda_{\\alpha}</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">A.2 Summary of the MPC Protocol</p>

    <p class="text-gray-300">Preprocessing phase. The preprocessing phase outputs a seed <span class="math">\\mathsf{seed}_{i}</span> to each party <span class="math">i\\in[n]</span>, which will be used to derive longer randomness. In addition, the preprocessing sends <span class="math">\\mathsf{aux}</span>, a <span class="math">n</span>-bit string to <span class="math">P_{n}</span>.</p>

    <p class="text-gray-300">In more detail, for each wire <span class="math">\\alpha</span> that is either an input wire of the circuit or the output wire of an AND gate, the parties are given <span class="math">[\\lambda_{\\alpha}]</span> which is derived from their own seeds. For an XOR gate with input wires <span class="math">\\alpha,\\beta</span> and output wire <span class="math">\\gamma</span>, define <span class="math">\\lambda_{\\gamma}\\stackrel{{\\scriptstyle\\rm def}}{{=}}\\lambda_{\\alpha}\\oplus\\lambda_{\\beta}</span>; note the parties can compute <span class="math">[\\lambda_{\\gamma}]</span> locally. Finally, for each AND gate with input wires <span class="math">\\alpha,\\beta</span>, the parties are given <span class="math">[\\lambda_{\\alpha,\\beta}]</span>, where <span class="math">\\lambda_{\\alpha,\\beta}\\stackrel{{\\scriptstyle\\rm def}}{{=}}\\lambda_{\\alpha}\\cdot\\lambda_{\\beta}</span>. All shares are derived from the seed, except that for party <span class="math">n</span>, its share of <span class="math">[\\lambda_{\\alpha,\\beta}]</span> is explicitly included in <span class="math">\\mathsf{aux}</span>.</p>

    <p class="text-gray-300">Protocol execution. Note that in our setting, where all parties are semi-honest, we can perform public reconstruction of a shared value <span class="math">[x]</span> by letting each party send its share to a designated party (e.g., party <span class="math">n</span>) who will reconstruct and broadcast the value.</p>

    <p class="text-gray-300">We assume the parties begin the protocol holding a masked value <span class="math">\\hat{z}_{\\alpha}</span> for each input wire <span class="math">\\alpha</span>. These masked values, along with the corresponding <span class="math">\\{\\lambda_{\\alpha}\\}</span>, define an effective input to the protocol. During the online phase of the protocol, the parties inductively compute <span class="math">\\hat{z}_{\\alpha}</span> for all wires in the circuit. Specifically, for each gate of the circuit with input wires <span class="math">\\alpha,\\beta</span> and output wire <span class="math">\\gamma</span>, where the parties already hold <span class="math">\\hat{z}_{\\alpha},\\hat{z}_{\\beta}</span>, the parties do:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If the gate is an XOR gate, then the parties locally compute <span class="math">\\hat{z}_{\\gamma}:=\\hat{z}_{\\alpha}\\oplus\\hat{z}_{\\beta}</span>.</li>

      <li>If the gate is an AND gate, the parties locally compute</li>

    </ul>

    <p class="text-gray-300"><span class="math">[s]:=\\hat{z}_{\\alpha}[\\lambda_{\\beta}]\\oplus\\hat{z}_{\\beta}[\\lambda_{\\alpha}]\\oplus[\\lambda_{\\alpha,\\beta}]\\oplus[\\lambda_{\\gamma}],</span></p>

    <p class="text-gray-300">and then publicly reconstruct <span class="math">s</span>. Finally, they compute <span class="math">\\hat{z}_{\\gamma}:=s\\oplus\\hat{z}_{\\alpha}\\hat{z}_{\\beta}</span>. One can verify that <span class="math">\\hat{z}_{\\gamma}=z_{\\gamma}\\oplus\\lambda_{\\gamma}</span>.</p>

    <p class="text-gray-300">Once the parties have computed <span class="math">\\hat{z}_{\\alpha}</span> for the output wire <span class="math">\\alpha</span>, the output value <span class="math">z_{\\alpha}</span> is computed by publicly reconstructing <span class="math">\\lambda_{\\alpha}</span> and then setting <span class="math">z_{\\alpha}:=\\hat{z}_{\\alpha}\\oplus\\lambda_{\\alpha}</span>.</p>

    <h3 id="sec-35" class="text-xl font-semibold mt-8">A.3 Proof of Security</h3>

    <p class="text-gray-300">The above protocol is secure against an all-but-one corruption in the semi-honest model.</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Lemma A.1.</h6>

    <p class="text-gray-300">Suppose there exists a <span class="math">(t,\\epsilon_{PRG})</span>-PRG. Then there exists a simulator for the above MPC protocol such that no distinguisher running in time <span class="math">t</span> can distinguish between the real-world execution and ideal-world execution defined by this simulator with better than <span class="math">\\epsilon_{PRG}</span> probability.</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We first describe a simulator <span class="math">\\mathcal{S}_{P}(1^{\\kappa},y,C)</span> that outputs the view of all parties except for <span class="math">P</span>. Denote the input and output sizes of <span class="math">C</span> are <span class="math">m</span> and <span class="math">l</span> respectively. The simulator works as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. If <span class="math">P=n</span>, set <span class="math">\\mathsf{state}_{i}\\leftarrow\\{0,1\\}^{k}</span> for all <span class="math">i\\neq P</span>. Otherwise, set <span class="math">\\mathsf{state}_{i}\\leftarrow\\{0,1\\}^{k}</span>, for <span class="math">i\\not\\in\\{n,P\\}</span> and set $\\mathsf{state}_{n}\\leftarrow\\{0,1\\}^{k+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Use <span class="math">\\{\\mathsf{state}_i\\}_{i\\neq P}</span>, <span class="math">\\hat{z}</span> and <span class="math">\\mathsf{msgs}_P</span> to simulate the online phase of the MPC protocol until the output reconstruction step, such that the simulator obtains share of outputs <span class="math">[y]</span> for <span class="math">i\\neq P</span>. Compute <span class="math">[y]_P\\coloneqq \\bigoplus_{i\\neq P}[y]_i\\oplus y</span>. Append <span class="math">[y]_P</span> to <span class="math">\\mathsf{msgs}_P</span>.</li>

    </ol>

    <p class="text-gray-300"><strong>Hybrid₁.</strong> Same as the real-world protocol, except use true randomness, instead of seed-derived, for party <span class="math">P</span>. String aux is computed as described in the protocol, based on true randomness.</p>

    <p class="text-gray-300">It is easy to see that the probability of distinguishing Hybrid₁ and the real-world protocol in running time <span class="math">t</span> is no more than <span class="math">\\epsilon_{PRG}</span>.</p>

    <p class="text-gray-300"><strong>Hybrid₂.</strong> Replace aux in Hybrid₁ by uniformly random string of the same length.</p>

    <p class="text-gray-300">If <span class="math">P = n</span>, then aux is not part of the view of the adversary; if <span class="math">P \\neq n</span>, then bits of aux are computed by XORing one bit of randomness from each seed from party <span class="math">i \\neq P</span>, then XORing one bit of randomness from party <span class="math">P</span> (which is uniformly random in Hybrid₁). Therefore aux is uniformly random in Hybrid₁.</p>

    <p class="text-gray-300">Therefore, Hybrid₁ and Hybrid₂ are identical.</p>

    <p class="text-gray-300"><strong>Hybrid₃.</strong> Same as Hybrid₂, except that <span class="math">\\hat{z}</span> is changed to uniform string; The last message from party <span class="math">P</span> is replaced by a message computed from the output as defined in the simulator. In more detail, use <span class="math">\\{\\mathsf{state}_i\\}_{i\\neq P}</span>, <span class="math">\\hat{z}</span> and <span class="math">\\mathsf{msgs}_P</span> to simulate the online phase of the MPC protocol locally, such that in the end, the simulator obtains share of outputs <span class="math">[y]_i</span> for <span class="math">i\\neq P</span>. Compute <span class="math">[y]_P\\coloneqq \\bigoplus_{i\\neq P}\\oplus y</span>. Replace the last message from party <span class="math">P</span> for reconstructing the output to <span class="math">[y]_P</span>.</p>

    <p class="text-gray-300">It is easy to see that <span class="math">\\hat{z}</span> is uniformly random in both hybrids since the share of the mask held by party <span class="math">P</span> is uniformly random. <span class="math">[y]_P</span> is identically distributed in two hybrids given the perfect correctness of the protocol: in both worlds, <span class="math">[y]_P</span> is a deterministic function of the output <span class="math">y</span> and the messages send by parties other than <span class="math">P</span>.</p>

    <p class="text-gray-300">Therefore, Hybrid₃ and Hybrid₂ are identical.</p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300">34</p>`;
---

<BaseLayout title="Improved Non-Interactive Zero Knowledge with Applications to... (2018/475)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2018 &middot; eprint 2018/475
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
