---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2017/587';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-21';
const TITLE_HTML = 'Subversion-zero-knowledge SNARKs';
const AUTHORS_HTML = 'Georg Fuchsbauer';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">Subversion zero knowledge for non-interactive proof systems demands that zero knowledge (ZK) be maintained even when the common reference string (CRS) is chosen maliciously. SNARKs are proof systems with succinct proofs, which are at the core of the cryptocurrency Zcash, whose anonymity relies on ZK-SNARKs; they are also used for ZK contingent payments in Bitcoin.

We show that under a plausible hardness assumption, the most efficient SNARK schemes proposed in the literature, including the one underlying Zcash and contingent payments, satisfy subversion ZK or can be made to at very little cost. In particular, we prove subversion ZK of the original SNARKs by Gennaro et al. and the almost optimal construction by Groth; for the Pinocchio scheme implemented in libsnark we show that it suffices to add 4 group elements to the CRS. We also argue informally that Zcash is anonymous even if its parameters were set up maliciously.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> SNARKs &middot; subversion-resistance &middot; zero knowledge &middot; Zcash</p>
    </section>

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">One of the primary motivations for succinct non-interactive arguments (SNARG) was verifiable computation. Consider a client that outsources resource-intensive computation to a powerful server, which attaches a proof to the result, so the client is convinced that it was computed correctly. For this to be meaningful, verification of such a proof must be considerably more efficient than performing the computation in the first place. SNARG systems provide such proofs and an impressive line of research has led to more and more efficient systems with proofs of size less than a kilobyte that can be verified in milliseconds. The reason why SNARGs are not used in outsourcing of computation is that computing a proof for complex computations is still not practical. (For example, a proof in Zcash, which is for a very simple statement, takes minutes to compute on a PC.)</p>

    <p class="text-gray-300">Zero-knowledge (ZK) SNARGs are used when some inputs to the computation come from the prover (the server in our example), who wants to keep its inputs private. ZK systems guarantee that a proof does not reveal more about private inputs than what can be inferred from the result of the computation. If the proofs prove knowledge of the private inputs, they are called SNARKs. ZK-SNARKs are already deployed, for example in Zcash <a href="#page-31-0">[Zca]</a>, which is a cryptocurrency like Bitcoin <a href="#page-31-1">[Nak09]</a>, based on the Zerocash protocol <a href="#page-29-1">[BCG</a>+14a]. As opposed to Bitcoin, where all transactions are public, Zcash payments are fully anonymous and protect the users' privacy. Zcash achieves this by using SNARK proofs that are zero-knowledge.</p>

    <p class="text-gray-300"><sup>1</sup> Inria, Ecole normale sup&acute;erieure, CNRS, PSL Research University, France. &acute; georg.fuchsbauer@ens.fr, www.di.ens.fr/~fuchsbau.</p>

    <p class="text-gray-300">Zero-knowledge contingent payments use SNARKs for fair exchange of information against payments over the Bitcoin network, assuming that the information can be verified (in the sense that it can be formalized as the witness of an NP statement), e.g. solutions to a Sudoku puzzle. Bitcoin's scripting language defines Pay-to-PubkeyHash transactions, which are bound to a hash value y and can be redeemed by exhibiting a preimage, i.e., some x s.t. H(x) = y. In a contingent payment Alice, the seller, chooses a key k, encrypts the information she is offering as c under k and sends c together with y := H(k) to Bob, the buyer. Bob makes a transaction to y. To redeem it, Alice must publish the preimage k, which then allows Bob to decrypt c and obtain the purchased information. To prevent Alice from cheating, she must prove that c encrypts the desired information under a preimage of y, for which she can use SNARKs. Zero-knowledge guarantees that no information is leaked before being paid.</p>

    <p class="text-gray-300">The main drawback of SNARKs is that they require system parameters that must be generated in a trusted way. In particular, whoever knows the randomness used when setting them up can convince verifiers of false statements (violating soundness of the system), which for Zerocash translates to counterfeiting money. The authors of Zerocash write: &quot;[D]ue to the zk-SNARK, our construction requires a one-time trusted setup of public parameters. The trust affects soundness of the proofs, though anonymity continues to hold even if the setup is corrupted by a malicious party.&quot; <a href="#page-29-1">[BCG</a>+14a]. The last statement is then not elaborated any further.</p>

    <p class="text-gray-300">For ZK contingent payments (ZKCP) the parameters are generated by the buyer, which prevents the seller from cheating. However, Campanelli, Gennaro, Goldfeder and Nizzardo <a href="#page-30-1">[CGGN17]</a> recently showed that the buyer can cheat in the reference implementation of ZKCP, which allows for selling the solution to a Sudoku puzzle. By maliciously setting up the parameters, the buyer can learn information about the solution from the SNARK proof sent by the seller before paying. This shows that not only soundness but also zero knowledge of SNARKs breaks down in the face of parameter subversion.</p>

    <p class="text-gray-300">In this work we look at whether zero knowledge can be salvaged when the parameters are set up maliciously and analyze the most efficient SNARK constructions in the literature, including the one <a href="#page-29-0">[BCTV14]</a> that underlies Zcash and ZKCP. We base our analyses on the theoretical framework introduced by Bellare et al. <a href="#page-29-2">[BFS16]</a>, who formalized the notion of subversion zero knowledge.</p>

    <p class="text-gray-300">Zero-knowledge proofs. A zero-knowledge proof <a href="#page-30-2">[GMR89]</a> is a protocol between a prover and a verifier that allows the former to convince the latter of the validity of a statement without revealing anything else. ZK proofs are an important building block for cryptographic schemes as they allow to assert that computations were done correctly while respecting the user's privacy. The three main properties of a ZK proof system are that a proof for a valid statement computed according to the protocol should convince a verifier (completeness); but there is no way that a malicious prover can convince a verifier of false statements (soundness); and nothing but the truth of the statement is revealed (zero knowledge).</p>

    <p class="text-gray-300">In non-interactive ZK proofs <a href="#page-29-3">[BFM88]</a>, the prover only sends one message (the proof) to the verifier. NIZK systems rely on a common reference string (CRS) to which both prover and verifier have access and which must be set up in a trusted way (for SNARKs the CRS is often called parameters). Without such a CRS, NIZK systems are not possible <a href="#page-30-3">[GO94]</a>.</p>

    <p class="text-gray-300">NIZK proof systems exist for every NP language <a href="#page-29-3">[BFM88,</a> <a href="#page-29-4">BDMP91]</a>. A language L is an NP language if it can be defined via a polynomial-time computable relation R: a statement x is in L iff there exists a witness w of length polynomial in the length of x such that R(x, w) = true. In verifiable computation a server's private input would be a witness. For ZK contingent payments, the ciphertext c, the hash value y and the Sudoku challenge are the statement. The witness is the plaintext of c (the Sudoku solution) and the encryption key k.</p>

    <p class="text-gray-300">Zero knowledge is formalized via a simulator that generates a CRS in which it can embed a trapdoor. The trapdoor must allow the simulator to produce proofs without a witness for the proven statement. ZK requires that there exists a simulator whose simulated CRSs and proofs are computationally indistinguishable from real ones. If both types are distributed equivalently then we have perfect ZK. Groth, Ostrovsky and Sahai <a href="#page-30-4">[GOS06b,</a> <a href="#page-30-5">GOS06a,</a> <a href="#page-30-6">Gro06,</a> <a href="#page-31-2">GS08]</a> constructed NIZK proof systems based on groups equipped with a pairing, i.e., an efficiently computable bilinear map. They gave the first perfect ZK system for all NP languages and very efficient schemes for specific languages based on standard cryptographic hardness assumptions.</p>

    <p class="text-gray-300">SNARKs. Another line of work considered the size of proofs from a theoretical point of view, leading to schemes with a proof size that is sublinear in the length of the proved statement <a href="#page-31-3">[Mic00]</a>. SNARGs are succinct non-interactive arguments, where succinct means that the proof length only depends (polynomially) on the security parameter. They are arguments (as opposed to proofs) because soundness only holds against efficient provers. This is the best achievable notion, since SNARGs are perfect-ZK, which implies that every CRS has a trapdoor. SNARKs are succinct non-interactive arguments of knowledge, for which a valid proofs implies that the prover knows the witness.</p>

    <p class="text-gray-300">The first NIZK system with proofs whose size is independent of the proven statement (and its witness) was given by Groth <a href="#page-30-7">[Gro10]</a> using bilinear groups; it was later improved by Lipmaa <a href="#page-31-4">[Lip12]</a>. Gennaro, Gentry, Parno and Raykova <a href="#page-30-8">[GGPR13]</a> introduced the notion of a quadratic span program (QSP), showed how to efficiently convert any boolean circuit into a QSP and then constructed a SNARK system for QSPs whose proofs consist of 8 elements of a bilinear group. They gave another construction based on quadratic arithmetic programs (QAP), which represent arithmetic circuits, whose inputs are elements from a finite field F and whose gates add or multiply F elements. QAPs are preferred in practice due to their greater efficiency. As circuit satisfiability is NP-complete, SNARKs exist for all NP languages.</p>

    <p class="text-gray-300">Parno, Howell, Gentry and Raykova <a href="#page-31-5">[PHGR13]</a> improved on <a href="#page-30-8">[GGPR13]</a>, making the conversion from circuits to QAPs more efficient and reducing the proof size by one group element. They implemented their scheme and named it &quot;Pinocchio&quot;. Ben-Sasson et al. <a href="#page-28-0">[BCG</a>+13, <a href="#page-29-0">BCTV14]</a> improve the conversion of actual program code to QAPs, reduce the size of SNARK parameters and implement their results as libsnark <a href="#page-29-5">[BCG</a>+14b]. The size of SNARK proofs for boolean circuits was then further reduced by Danezis, Fournet, Groth and Kohlweiss <a href="#page-30-9">[DFGK14]</a>, who modified QSP to square span programs (SSP) and built a system for them whose proofs consist of only 4 group elements.</p>

    <p class="text-gray-300">Recently, Groth <a href="#page-31-6">[Gro16]</a> presented the most efficient SNARK construction to date, which is for arithmetic circuits and whose proofs consist of only 3 group elements (and require 3 pairings to verify). All previous bilinear-group-based SNARKs are proven under strong cryptographic assumptions (knowledge assumptions), for which there is evidence that they might be unavoidable <a href="#page-31-7">[GW11,</a> <a href="#page-28-1">BCCT12]</a>. Starting from Bitansky et al.'s <a href="#page-29-6">[BCI</a>+13] linear interactive proof framework, Groth <a href="#page-31-6">[Gro16]</a> achieves his result by proving security directly in the generic-group model <a href="#page-31-8">[Sho97]</a> (which implies all previously considered assumptions).</p>

    <p class="text-gray-300">He also shows that SNARKs over asymmetric bilinear groups must contain elements from both source groups, meaning that the proof size of his construction is only one element short of the optimal size. Recently, Fuchsbauer, Kiltz and Loss <a href="#page-30-10">[FKL17]</a> proved Groth's scheme secure under a &quot;q-type&quot; variant of the discrete log assumption in the algebraic group model. In this model adversaries can only output group elements if they were obtained by applying the group operation to previously received group elements.</p>

    <p class="text-gray-300">Subversion-resistance. The Snowden revelations documented the NSA's efforts to subvert standards, for which an illustrative example is the NSA-designed and ISO-standardized <em>Dual EC</em> random number generator. Its parameters include two elliptic-curve points, whose respective discrete logarithms can act as a backdoor that can be exploited to break TLS [CNE<sup>+</sup>14]. NIZK systems are particularly prone to parameter subversion, since their CRS must be subvertible <em>by design</em>: zero knowledge requires that an honest CRS is indistinguishable from a backdoored CRS, where the backdoor is the trapdoor used to simulate proofs. For SNARKs the parameters always contain a backdoor and anyone knowing it can simulate proofs for false statements, which means breaking soundness.</p>

    <p class="text-gray-300">Motivated by this, Bellare, Fuchsbauer and Scafuro [BFS16] ask what security can be maintained for NIZKs when its trusted parameters are subverted. They formalize different notions of resistance to CRS subversion and investigate their achievability. They define <em>subversion soundness</em> (S-SND), meaning that no adversary can generate a (malicious) CRS together with a valid proof  <span class="math">\\pi</span>  for a false statement x.</p>

    <p class="text-gray-300">They also give a subversion-resistant analogue for zero knowledge. Recall that ZK assumes that there exists a CRS simulator Sim.crs, which returns a simulated CRS crs' and an associated simulation trapdoor td, and a proof simulator Sim.pf that outputs proofs on input a valid instance x and td, such that no efficient adversary can distinguish the following: being given crs' and an oracle implementing Sim.pf, or an honest crs and an oracle returning honestly computed proofs. Subversion ZK (S-ZK) requires that for any adversary X creating a malicious CRS crs in any way it likes using randomness (coins) r, there exists a simulator  <span class="math">sim_X.crs</span>  returning a simulated CRS crs' with trapdoor td together with simulated coins r', as well as a proof simulator  <span class="math">sim_X.pf</span> , such that no adversary can distinguish the following: being given crs' and r' and a  <span class="math">sim_X.pf</span>  oracle, or a crs output by X, together with the used coins r and an honest proof oracle. The authors also define a subversion-resistant notion (S-WI) of witness-indistinguishability [FLS90] (see Sections 2.3 and 2.4).</p>

    <p class="text-gray-300">Following [GO94], Bellare et al. [BFS16] first show that S-SND cannot be achieved together with (standard) ZK for non-trivial languages (for trivial ones the verifier needs no proof to check validity of statements). This is because ZK allows breaking soundness by subverting the CRS. They then show that S-SND can be achieved together with S-WI. Their main result is a construction that achieves both S-ZK (and thus S-WI) and SND.</p>

    <p class="text-gray-300">BFS's S-ZK scheme. To achieve S-ZK, a simulator must be able to simulate proofs under a CRS output by a subvertor, so it cannot simply embed a trapdoor as in standard ZK. Bellare et al. [BFS16] base S-ZK on a knowledge assumption, which is the type of assumption on which security (in particular, knowledge soundness) of SNARKs relies. It states that an algorithm can only produce an output of a certain form if it knows some underlying information. This is formalized by requiring the existence of an extractor that extracts this information from the algorithm. In their scheme this information acts as the simulation trapdoor, which under their knowledge assumption can be obtained from a subvertor outputting a CRS.</p>

    <p class="text-gray-300">Concretely, they assume that for a bilinear group  <span class="math">(\\mathbb{G}, +)</span>  with a generator P any algorithm that outputs a Diffie-Hellman tuple  <span class="math">(P, s_1P, s_2P, s_1s_2P)</span>  for some  <span class="math">s_1, s_2</span> , must know either  <span class="math">s_1</span>  or  <span class="math">s_2</span> . They call their assumption Diffie-Hellman knowledge-of-exponent assumption (DH-KEA) and note that a tuple  <span class="math">(P, S_1, S_2, S_3)</span>  of this form can be verified via a (symmetric) bilinear map e by checking  <span class="math">e(S_3, P) = e(S_1, S_2)</span> . A question that arises is: who chooses the group  <span class="math">\\mathbb{G}</span>  in their scheme? Bellare et al. address this by making the group  <span class="math">\\mathbb{G}</span>  part of the scheme specification. This begs the question whether the subversion risk has not simply been shifted from the CRS to the choice of the group. They argue that the group generation algorithm is deterministic and public, so users can create the group themselves, and it is thus reproducible, whereas the CRS is inherently not.</p>

    <p class="text-gray-300">Parameter setup in practice. A way to avoid the problem of generating a trusted CRS for NIZK systems is by proving its security in the random-oracle model (ROM) <a href="#page-29-7">[BR93]</a>. Instead of a CRS, all parties are assumed to have access to a truly random function (which is modeled as an oracle returning random values). In practice the random oracle is replaced by a cryptographic hash function and a proof in the ROM can be viewed as a security heuristic for the resulting scheme.</p>

    <p class="text-gray-300">For NIZK systems whose CRS is a uniform random string, e.g. PCP-based constructions like <a href="#page-29-8">[BSBC</a>+17] recently, one can in practice set the CRS to a common random-looking public value such as the digits of &pi; or the output of a standardized hash function on a fixed input. This intuitively guarantees that no one has embedded a trapdoor. For the Groth-Sahai proof system <a href="#page-31-2">[GS08]</a> the CRS consists of random elements of an elliptic-curve group; they can be set up by hashing a common random string directly into the elliptic curve <a href="#page-29-9">[BF01,</a> <a href="#page-29-10">BCI</a>+10].</p>

    <p class="text-gray-300">For practical SNARKs the situation is different: there are no CRS-less constructions in the random-oracle model and the CRS is highly structured. The parameters typically contain elements of the form (P, &tau;P, &tau; <sup>2</sup>P), where P is a generator of a group G and &tau; is a random value. Soundness completely breaks down if the value &tau; is known to anyone. Unfortunately, there is no known way of creating such a triple obliviously, that is, without knowing the value &tau; .</p>

    <p class="text-gray-300">Our techniques. In order to show subversion zero knowledge of SNARK schemes, we assume that computing elements (P, &tau;P, &tau; <sup>2</sup>P) cannot be done without knowing &tau; . (Looking ahead, we actually make a weaker assumption in asymmetric bilinear groups by requiring the adversary to return (P1, &tau;P1, &tau; <sup>2</sup>P1) &isin; G<sup>3</sup> 1 as well as (P2, &tau;P2) &isin; G<sup>2</sup> 2 , which makes the structure of the triple verifiable using the bilinear map.) Under this assumption, which we call square knowledge of exponent (SKE) assumption (Definition <a href="#page-12-0">2.14)</a>, we then prove subversion ZK of five relevant SNARK constructions from the literature or slight variants of them.</p>

    <p class="text-gray-300">As an additional sanity check, we prove that SKE holds in the generic group model (Theorem <a href="#page-14-0">2.16)</a>. Following Groth <a href="#page-31-6">[Gro16]</a>, we assume that the bilinear group description is part of the specification of the language for which the proof system is defined (and not part of the CRS as in <a href="#page-29-2">[BFS16]</a>). Following his previous work <a href="#page-30-9">[DFGK14]</a>, we let the CRS generation algorithm sample random group generators (in contrast to <a href="#page-29-2">[BFS16]</a>, which assumes a fixed group generator). This intuitively leads to weaker assumptions required to prove soundness.</p>

    <p class="text-gray-300">To show subversion zero knowledge of existing SNARK schemes, we proceed as follows. Standard zero knowledge holds because the randomness used to compute the CRS allows the simulator to produce proofs that are distributed equivalently to honestly generated proofs under the (honestly computed) CRS. However, for S-ZK this must hold even for a CRS that was computed in any arbitrary way. While we cannot guarantee that the CRS subvertor used random values when computing the CRS, we first show how to verify that the structure of the CRS is as prescribed. (For the asymmetric Pinocchio scheme <a href="#page-29-0">[BCTV14]</a> this requires us to extend the CRS slightly.)</p>

    <p class="text-gray-300">Another difference between standard and subversion ZK is that in the former the simulator creates the CRS and thus knows the simulation trapdoor, whereas for S-ZK the CRS is produced by the subvertor, so it might not be clear how proofs can be simulated at all. Now if the CRS contains elements (P, &tau;P, &tau; <sup>2</sup>P), whose correct structure can be verified via the pairing, then under our SKE assumption we can extract the value &tau; . SKE thus allows the simulator to obtain parts of the randomness even from a maliciously generated CRS. Unfortunately, the simulation trapdoor typically contains other values that the S-ZK simulator cannot extract.</p>

    <p class="text-gray-300">Our next step is then to demonstrate that proofs can be simulated using &tau; only, or to show how under our assumption more values can be extracted that then enable simulation. Our final step is to show that if a CRS passes the verification procedure we define, then proofs that were simulated using the partial trapdoor are distributed like real proofs. This shows that the analyzed scheme is S-ZK under our SKE assumption. While knowledge assumptions are strong assumptions, they seem unavoidable since S-ZK implies 2-move interactive ZK by letting the verifier create the CRS. And such schemes require extractability assumptions <a href="#page-29-11">[BCPR14]</a>.</p>

    <p class="text-gray-300">Since simulated proofs are by definition independent of a witness, our results imply that under a verified, but possibly malicious, CRS, proofs for different witnesses are equally distributed. As a corollary we thereby obtain that all SNARKs we consider satisfy subversion witness indistinguishability unconditionally (i.e., no assumptions required).</p>

    <p class="text-gray-300">We note that Ben-Sasson et al. <a href="#page-29-12">[BCG</a>+15] also consider making a CRS verifiable. Their goal is to protect soundness against subversion by sampling the secret values underlying a CRS in a distributed way. Only if all participants in the CRS-creation protocol collude can they break soundness. To guarantee a correctly distributed CRS, the participant(s) must prove adherence to the protocol via NIZK proofs <a href="#page-31-9">[Sch91,</a> <a href="#page-30-13">FS87]</a> secure in the random-oracle model. The protocol thus returns verifiable SNARK parameters. The parameters used for Zcash were set up using this multiparty protocol, which was recently detailed by Bowe, Gabizon and Green <a href="#page-29-13">[BGG17]</a>.</p>

    <h3 id="sec-misc-1" class="text-xl font-semibold mt-8">Our Results</h3>

    <p class="text-gray-300">As already discussed, SNARKs are not subversion-sound because their CRS contains the simulation trapdoor. In this work we look at subversion resistance of their zero-knowledge property and investigate several SNARK constructions from the literature that are based on bilinear groups. In particular,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the first QSP-based and 2. QAP-based constructions <a href="#page-30-8">[GGPR13]</a>;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>optimized Pinocchio <a href="#page-29-0">[BCTV14]</a> as implemented in libsnark <a href="#page-29-5">[BCG</a>+14b]; and</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>and 5. the two most efficient (SSP- and QAP-based) constructions by Groth et al. <a href="#page-30-9">[DFGK14,</a> <a href="#page-31-6">Gro16]</a>.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">We make the (reasonable) assumption that a privacy-conscious prover (whose protection is the goal of zero knowledge) first checks whether the CRS looks plausible (to whatever extent this is possible) before publishing a proof with respect to it. All of our results implicitly make this assumption.</p>

    <p class="text-gray-300">We start with the first SNARK construction for QAPs by Gennaro, Gentry, Parno and Raykova <a href="#page-30-8">[GGPR13]</a> and show how to verify that the CRS is correctly formed. We then show that under the square knowledge of exponent (SKE) assumption their construction satisfies subversion zero knowledge as defined in <a href="#page-29-2">[BFS16]</a>. The same holds for their QSP-based SNARK.</p>

    <p class="text-gray-300">We next turn to the optimized version of Pinocchio over asymmetric bilinear groups due to Ben-Sasson, Chiesa, Tromer and Virza <a href="#page-29-0">[BCTV14]</a>. For this construction we show that adding 4 group elements to the CRS makes it efficiently checkable. We then prove that the scheme with this slightly extended CRS satisfies subversion zero knowledge under SKE, whereas the original scheme, which is implemented in libsnark <a href="#page-29-5">[BCG</a>+14b], succumbs to a parameter-subversion attack <a href="#page-30-1">[CGGN17]</a>. For the SNARK by Danezis, Fournet, Groth and Kohlweiss <a href="#page-30-9">[DFGK14]</a>, we show that CRS well-formedness can be efficiently verified without modifying the CRS and that S-ZK holds analogously to Pinocchio.</p>

    <p class="text-gray-300">Finally, we consider the most efficient SNARK scheme by Groth <a href="#page-31-6">[Gro16]</a> and again show that the scheme is already subversion-zero-knowledge under SKE. Proving this is more involved than for the previous schemes, since the value &tau; , for which P, &tau;P, &tau; <sup>2</sup>P, . . . are contained in the CRS does not suffice to simulate proofs, as for the previous schemes. We show that, using SKE twice, another value can be extracted, which together with &tau; then enables proof simulation. As corollaries, we get that S-WI holds unconditionally for all considered schemes.</p>

    <p class="text-gray-300">Concurrent work. Campanelli, Gennaro, Goldfeder and Nizzardo <a href="#page-30-1">[CGGN17]</a> show that Pinocchio as implemented in libsnark <a href="#page-29-5">[BCG</a>+14b] is not subversion-zero-knowledge by exhibiting an attack. As countermeasures they propose to instead use one of the older SNARKs by Gennaro et al. <a href="#page-30-8">[GGPR13]</a>, as they allow verification of CRS well-formedness, which yields witness indistinguishability. They admit that for applications for which there is only one witness, like selling a Sudoku solution, WI is vacuous (as any protocol satisfies WI).</p>

    <p class="text-gray-300">They refer to Bellare et al.'s <a href="#page-29-2">[BFS16]</a> S-ZK system and conjecture that &quot;the techniques extend to the original QSP/QAP protocol in <a href="#page-30-8">[GGPR13]</a>&quot; (which we proved rigorously). Moreover, &quot;[i]t is however not clear if those techniques extend to Pinocchio&quot; and &quot;it would require major changes in the current implementation of ZKCP protocols&quot;. (We show that it suffices to add 4 group elements to the CRS and perform the checks of well-formedness.) They recommend following the Zcash approach <a href="#page-29-12">[BCG</a>+15, <a href="#page-29-13">BGG17]</a> and using an interactive protocol that lets the prover and verifier compute the CRS together.</p>

    <p class="text-gray-300">In other concurrent work Abdolmaleki, Baghery, Lipmaa and Zajac <a href="#page-28-2">[ABLZ17]</a> present a S-ZK variant of Groth's SNARK <a href="#page-31-6">[Gro16]</a>. They need to modify the scheme, thereby reducing efficiency, and they prove their result under a stronger assumption. In particular, they extend the CRS by 2d group elements (where d is the number of multiplication gates in the circuit that represents the relation). Their assumption states that any adversary that for generators P<sup>1</sup> &isin; G<sup>&lowast;</sup> 1 and P<sup>2</sup> &isin; G<sup>&lowast;</sup> 2 outputs a pair of the form (sP1, sP2) must know s. As they note, their assumption is false in groups with a symmetric (&quot;Type-1&quot;) bilinear map as well as in asymmetric groups of Type 2, whereas our SKE assumption holds generically in all bilinear group settings. They claim security of their scheme under their own definition of S-ZK, which is a statistical notion, in contrast to original computational S-ZK notion <a href="#page-29-2">[BFS16]</a>, which we consider.<a href="#page-6-0">1</a></p>

    <p class="text-gray-300">Practical implications of our results. We show that for all analyzed schemes except asymmetric Pinocchio, it suffices to verify the parameters once in order to guarantee subversion zero knowledge. Any already deployed parameters can thus be continued to be used after verification. Subversion-ZK of Pinocchio can be obtained by adding 4 group elements to the CRS.</p>

    <p class="text-gray-300">For Pinocchio-based ZK contingent payments this means that the scheme can be made secure by slightly augmenting the size of the parameters and having the seller verify them. No additional interaction between seller and buyer (as recommended by Campanelli et al. <a href="#page-30-1">[CGGN17]</a>) is thus required. Of course, admitting additional interaction could lead to more efficient schemes than using the (costly) CRS verification.</p>

    <p class="text-gray-300">The SNARK parameters used in Zcash have been computed by running the multi-party protocol from <a href="#page-29-12">[BCG</a>+15, <a href="#page-29-13">BGG17]</a> and verifiability of this process is achieved via random-oracle NIZK proofs. Let us define a CRS subvertor that runs this protocol, playing the roles of all parties, and outputs the resulting CRS which includes the ROM proofs. Since the latter guarantee well-formedness of the CRS, under SKE there exists an efficient extractor that can extract the simulation trapdoor from this CRS subvertor. Using the trapdoor, proofs can be simulated (as specified in Section <a href="#page-21-0">5)</a>. We thus conclude that, assuming users verify the consistency of the CRS, Zcash provides a subversionresistant form of anonymity in the random-oracle model under the SKE assumption with respect to the bilinear group used by Zcash. Thus, even if all parties involved in creating the parameters were malicious, Zcash is still anonymous.</p>

    <p class="text-gray-300">We content ourselves with the above argument, as a formal proof would be beyond the scope</p>

    <p class="text-gray-300"><sup>1</sup> It is not clear how their scheme can achieve statistical S-ZK, considering that the success of the simulator relies on a computational assumption. They also claim that their notion is stronger because they let the subvertor X pass &quot;extra information&quot; to the adversary A, whereas A &quot;only&quot; receives X's coins r in <a href="#page-29-2">[BFS16]</a>. But A can itself compute any such information from r.</p>

    <p class="text-gray-300">of this paper. Subsequently to our results Bowe et al. <a href="#page-29-13">[BGG17]</a> proved that their protocol is S-ZK with a polynomially small (not negligible) simulation error in the random-oracle model without making knowledge assumptions.</p>

    </section>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 Definitions</h2>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8">2.1 Notation</h3>

    <p class="text-gray-300">If x is a (binary) string then |x| is its length. If S is a finite set then |S| denotes its size and s &larr;$ S denotes picking an element uniformly from S and assigning it to s. We denote by &lambda; &isin; N the security parameter and by 1<sup>&lambda;</sup> its unary representation.</p>

    <p class="text-gray-300">Algorithms are randomized unless otherwise indicated. &quot;PT&quot; stands for &quot;polynomial time&quot;, whether for randomized or deterministic algorithms. By y &larr; A(x1, . . . ; r) we denote the operation of running algorithm A on inputs x1, . . . and coins r and letting y denote the output. By y &larr;$ A(x1, . . .), we denote letting y &larr; A(x1, . . . ; r) for random r. We denote by [A(x1, . . .)] the set of points that have positive probability of being output by A on inputs x1, . . .</p>

    <p class="text-gray-300">For our security definitions we use the code-based game playing framework <a href="#page-29-14">[BR06]</a>. A game G (e.g. Figure <a href="#page-9-0">1)</a> usually depends on a scheme and executes one or more adversaries. It defines oracles for the adversaries as procedures. The game eventually returns a boolean. We let Pr[G] denote the probability that G returns true.</p>

    <p class="text-gray-300">We recall the standard notions of soundness, knowledge-soundness, witness-indistinguishability and zero knowledge for NIZKs, which assume the CRS is trusted and then give their subversionresistant counterparts that were introduced in <a href="#page-29-2">[BFS16]</a>. We mainly follow their exposition and start with the syntax.</p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8">2.2 NP Relations and NI Systems</h3>

    <p class="text-gray-300">NP relations. Consider R: {0, 1} <sup>&lowast;</sup> &times; {0, 1} <sup>&lowast;</sup> &rarr; {true, false}. For x &isin; {0, 1} <sup>&lowast;</sup> we let R(x) = { w | R(x, w) = true } be the witness set of x. R is an NP relation if it is PT and there is a polynomial P<sup>R</sup> such that every w in R(x) has length at most PR(|x|) for all x. We let L(R) = { x | R(x) 6= &empty; } be the language associated to R. We will consider relations output by a PT relation generator Rg (which may also output some auxiliary information z that is given to the adversary). We assume &lambda; can be deduced from R &isin; [Rg(1<sup>&lambda;</sup> )] and note that definitions from <a href="#page-29-2">[BFS16]</a>, which are for one fixed relation R, are easily recovered by defining Rg(1<sup>&lambda;</sup> ) := (1<sup>&lambda;</sup> , R).</p>

    <p class="text-gray-300">NI systems. A non-interactive (NI) system &Pi; for relation generator Rg specifies the following PT algorithms. Via crs &larr;$ &Pi;.Pg(R) one generates a common reference string crs. Via &pi; &larr;$ &Pi;.P(R, crs, x, w) the honest prover, given x and w &isin; R(x), generates a proof &pi; that x &isin; L(R). Via d &larr; &Pi;.V(R, crs, x, &pi;) a verifier can produce a decision d &isin; {true, false} indicating whether &pi; is a valid proof that x &isin; L(R). We require (perfect) completeness, that is, for all &lambda; &isin; N, all R &isin; [Rg(1<sup>&lambda;</sup> )], all crs &isin; [&Pi;.Pg(R)], all x &isin; L(R), all w &isin; R(x) and all &pi; &isin; [&Pi;.P(R, crs, x, w)] we have &Pi;.V(R, crs, x, &pi;) = true. We also assume that &Pi;.V returns false if any of its arguments is &perp;.</p>

      <h3 id="sec-2.3" class="text-xl font-semibold mt-8">2.3 Standard Notions: SND, KSND, WI and ZK</h3>

    <p class="text-gray-300">Soundness. Soundness means that it is hard to create a valid proof for any x 6&isin; L(R). We consider computational soundness as opposed to a statistical one, which is usually sufficient for applications, and which is the notion achieved by SNARGs.</p>

    <p class="text-gray-300">Definition 2.1 (SND) An NI system &Pi; for relation generator Rg is sound if Advsnd &Pi;,Rg,A (&middot;) is negligible for all PT adversaries A, where Advsnd &Pi;,Rg,A (&lambda;) = Pr[SND&Pi;,Rg,A(&lambda;)] and game SND is specified in Figure <a href="#page-9-0">1.</a></p>

    <p class="text-gray-300">Knowledge soundness. This strengthening of soundness <a href="#page-29-15">[BG93]</a> means that a prover that outputs a valid proof must know the witness. Formally, there exists an extractor that can extract the witness from the prover. The notion implies soundness, since for a proof of a wrong statement there exists no witness.</p>

    <p class="text-gray-300">Definition 2.2 (KSND) An NI system &Pi; for relation generator Rg is knowledge-sound if for all PT adversaries A there exists a PT extractor E such that Advksnd &Pi;,Rg,A,E (&middot;) is negligible, where Advksnd &Pi;,Rg,A,E (&lambda;) = Pr[KSND&Pi;,Rg,A,E(&lambda;)] and game KSND is specified in Figure <a href="#page-9-0">1.</a></p>

    <p class="text-gray-300">Note that (as for the following two notions) the output of game KSND is efficiently computable, which is not the case for SND, since membership in L(R) may not be efficiently decidable. This can be an issue when proving security of more complex systems that use a system &Pi; as a building block.</p>

    <p class="text-gray-300">WI. Witness-indistinguishability <a href="#page-30-12">[FLS90]</a> requires that proofs for the same statement using different witnesses are indistinguishable. The adversary can adaptively request multiple proofs for statements x under one of two witnesses w0, w1; it receives proofs under w<sup>b</sup> for a challenge bit b which it must guess.</p>

    <p class="text-gray-300">Definition 2.3 (WI) An NI system &Pi; for Rg is witness-indistinguishable if Advwi &Pi;,Rg,A (&middot;) is negligible for all PT adversaries A, where Advwi &Pi;,Rg,A (&lambda;) = 2 Pr[WI&Pi;,Rg,A(&lambda;)] &minus; 1 and game WI is specified in Figure <a href="#page-9-0">1.</a></p>

    <p class="text-gray-300">ZK. Zero knowledge <a href="#page-30-2">[GMR89]</a> means that no information apart from the fact that x &isin; L(R) is leaked by the proof. It is formalized by requiring that a simulator, who can create the CRS, can compute proofs without being given a witness, so that CRS and proofs are indistinguishable from real ones. In particular, the distinguisher A can adaptively request proofs by supplying an instance and a valid witness for it. The proof is produced either by the honest prover using the witness, or by the simulator. The adversary outputs a guess b <sup>0</sup> as to whether the proofs were real or simulated.</p>

    <p class="text-gray-300">Definition 2.4 (ZK) An NI system &Pi; for Rg is zero-knowledge if &Pi; specifies additional PT algorithms &Pi;.Sim.crs and &Pi;.Sim.pf such that Advzk &Pi;,Rg,A (&middot;) is negligible for all PT adversaries A, where Advzk &Pi;,Rg,A (&lambda;) = 2 Pr[ZK&Pi;,Rg,A(&lambda;)] &minus; 1 and game ZK is specified in Figure <a href="#page-9-0">1.</a></p>

    <p class="text-gray-300">An NI system &Pi; is statistical zero-knowledge if the above holds for all (not necessarily PT) adversaries A. It is perfect zero-knowledge if Advzk &Pi;,Rg,A (&middot;) &equiv; 0.</p>

      <h3 id="sec-2.4" class="text-xl font-semibold mt-8">2.4 Notions for Subverted CRS: S-SND, S-KSND, S-WI and S-ZK</h3>

    <p class="text-gray-300">For all notions considered in the previous section the CRS is assumed to be honestly generated. Bellare et al. <a href="#page-29-2">[BFS16]</a> ask what happens when the CRS is maliciously generated and define subversionresistant analogues S-SND, S-WI and S-ZK, in which the adversary chooses the CRS. The following three definitions are from <a href="#page-29-2">[BFS16]</a>.</p>

    <p class="text-gray-300">Subversion soundness. Subversion soundness asks that if the adversary creates a CRS in any way it likes, it is still unable to prove false statements under it. We accordingly modify the soundness game SND by letting the adversary choose crs in addition to x and &pi;.</p>

    <pre><code class="language-text">Game SND&Pi;,Rg,A(&lambda;)
R &larr;$ Rg(1&lambda;
            )
crs &larr;$ &Pi;.Pg(R)
(x, &pi;) &larr;$ A(R, crs)
Return
         x 6&isin; L(R) and &Pi;.V(R, crs, x, &pi;)

                                                         Game S-SND&Pi;,Rg,A(&lambda;)
                                                         R &larr;$ Rg(R)
                                                         (crs, x, &pi;) &larr;$ A(R)
                                                         Return
                                                                  x 6&isin; L(R) and &Pi;.V(R, crs, x, &pi;)

Game KSND&Pi;,Rg,A,E(&lambda;)
R &larr;$ Rg(1&lambda;
            )
crs &larr;$ &Pi;.Pg(R) ; r &larr;$ {0, 1}
                             A.rl(&lambda;)
(x, &pi;) &larr; A(R, crs; r)
w &larr;$ E(R, crs, r)
Return
         R(x, w) = false and &Pi;.V(R, crs, x, &pi;)

                                                         Game S-KSND&Pi;,Rg,A,E(&lambda;)
                                                         R &larr;$ Rg(1&lambda;
                                                                     )
                                                         r &larr;$ {0, 1}
                                                                    A.rl(&lambda;)
                                                         (crs, x, &pi;) &larr; A(R; r)
                                                         w &larr;$ E(R, r)
                                                         Return
                                                                  R(x, w) = false and &Pi;.V(R, crs, x, &pi;)

Game WI&Pi;,Rg,A(&lambda;)
b &larr;$ {0, 1} ; R &larr;$ Rg(1&lambda;
                         )
crs &larr;$ &Pi;.Pg(R)
b
 0 &larr;$ A
       Prove(R, crs)
Return (b = b
              0
              )
Prove(x, w0, w1)
If R(x, w0) = false or R(x, w1) = false
  then return &perp;
&pi; &larr;$ &Pi;.P(R, crs, x, wb)
Return &pi;
                                                         Game S-WI&Pi;,Rg,A(&lambda;)
                                                         b &larr;$ {0, 1} ; R &larr;$ Rg(1&lambda;
                                                                                  )
                                                         (crs,st) &larr;$ A(R)
                                                         b
                                                          0 &larr;$ A
                                                                Prove(R, crs,st)
                                                         Return (b = b
                                                                       0
                                                                        )
                                                         Prove(x, w0, w1)
                                                         If R(x, w0) = false or R(x, w1) = false
                                                           then return &perp;
                                                         &pi; &larr;$ &Pi;.P(R, crs, x, wb)
                                                         Return &pi;
Game ZK&Pi;,Rg,A(&lambda;)
b &larr;$ {0, 1} ; R &larr;$ Rg(1&lambda;
                         )
crs1 &larr;$ &Pi;.Pg(R)
(crs0,td) &larr;$ &Pi;.Sim.crs(R)
b
 0 &larr;$ A
       Prove(R, crsb)
Return (b = b
              0
              )
Prove(x, w)
If R(x, w) = false then return &perp;
If b = 1 then &pi; &larr;$ &Pi;.P(R, crs1, x, w)
Else &pi; &larr;$ &Pi;.Sim.pf(R, crs0,td, x)
Return &pi;
                                                         Game S-ZK&Pi;,Rg,X,S,A(&lambda;)
                                                         b &larr;$ {0, 1} ; R &larr;$ Rg(1&lambda;
                                                                                  )
                                                         r1 &larr;$ {0, 1}
                                                                     X.rl(&lambda;)
                                                                           ; crs1 &larr; X(R; r1)
                                                         (crs0, r0,td) &larr;$ S.crs(R)
                                                         b
                                                          0 &larr;$ A
                                                                Prove(R, crsb, rb)
                                                         Return (b = b
                                                                       0
                                                                        )
                                                         Prove(x, w)
                                                         If R(x, w) = false then return &perp;
                                                         If b = 1 then &pi; &larr;$ &Pi;.P(R, crs1, x, w)
                                                         Else &pi; &larr;$ S.pf(R, crs0,td, x)
                                                         Return &pi;
</code></pre>

    <p class="text-gray-300">Figure 1: Games defining soundness, knowledge-soundness, witness-indistinguishability and zero knowledge (left) and their subversion-resistant counterparts (right) for an NI system &Pi;.</p>

    <p class="text-gray-300">Definition 2.5 (S-SND) An NI system &Pi; for generator Rg is subversion-sound if Advs-snd &Pi;,Rg,A (&middot;) is negligible for all PT adversaries A, where Advs-snd &Pi;,Rg,A (&lambda;) = Pr[S-SND&Pi;,Rg,A(&lambda;)] and game S-SND is specified in Figure <a href="#page-9-0">1.</a></p>

    <p class="text-gray-300"><u>Subversion WI.</u> Subversion WI demands that even when the subvertor creates a CRS in any way it likes, it can still not decide which of two witnesses of its choice were used to create a proof. The adversary is modeled as a two-stage algorithm: it first outputs a CRS crs along with state information (which could e.g. contain a trapdoor associated to crs) passed to the second stage. The second stage is then defined like for the honest-CRS game WI, where via its PROVE oracle, the adversary can adaptively query proofs for instances under one of two witnesses.</p>

    <p class="text-gray-300"><strong>Definition 2.6 (S-WI)</strong> An NI system  <span class="math">\\Pi</span>  for generator Rg is subversion-witness-indistinguishable if  <span class="math">\\mathbf{Adv}_{\\Pi,\\mathsf{Rg},\\mathsf{A}}^{\\mathrm{s-wi}}(\\cdot)</span>  is negligible for all PT adversaries A, where  <span class="math">\\mathbf{Adv}_{\\Pi,\\mathsf{Rg},\\mathsf{A}}^{\\mathrm{s-wi}}(\\lambda) = 2\\Pr[\\mathrm{S-WI}_{\\Pi,\\mathsf{Rg},\\mathsf{A}}(\\lambda)] - 1</span>  and game S-WI is specified in Figure 1. An NI system  <span class="math">\\Pi</span>  is perfect S-WI if  <span class="math">\\mathbf{Adv}_{\\Pi,\\mathsf{Rg},\\mathsf{A}}^{\\mathrm{s-wi}}(\\cdot) \\equiv 0</span> .</p>

    <p class="text-gray-300">Subversion ZK. This notion considers a CRS subvertor X that returns an arbitrarily formed CRS. Subversion ZK now asks that for any such X there exists a simulator that is able to simulate (1) the full view of the CRS subvertor, <em>including its coins</em>, and (2) proofs for adaptively chosen instances without knowing the witnesses. The simulator consists of S.crs, which returns a CRS, coins for X and a trapdoor which is then used by its second stage S.pf to simulate proofs. The adversary's task is to decide whether it is given a real CRS and the coins used to produce it, and real proofs (case b = 1); or whether it is given a simulated CRS and coins, and simulated proofs (case b = 0).</p>

    <p class="text-gray-300"><strong>Definition 2.7 (S-ZK)</strong> An NI system  <span class="math">\\Pi</span>  for generator Rg is subversion-zero-knowledge if for all PT CRS subvertors X there exists a PT simulator S = (S.crs, S.pf) such that for all PT adversaries A the function  <span class="math">\\mathbf{Adv}^{s-zk}_{\\Pi,Rg,X,S,A}(\\cdot)</span>  is negligible, where  <span class="math">\\mathbf{Adv}^{s-zk}_{\\Pi,Rg,X,S,A}(\\lambda) = 2\\Pr[S-ZK_{\\Pi,Rg,X,S,A}(\\lambda)] - 1</span>  and game S-ZK is specified in Figure 1.</p>

    <p class="text-gray-300">The definition is akin to zero knowledge for interactive proof systems [GMR89], when interpreting the CRS as the verifier's first message. The simulator must produce a full view of the verifier (including coins and a transcript of its interaction with the Prove oracle). On the other hand, to imply ZK of NI systems, the simulator needs to produce the CRS before learning the statements for which it must simulate proofs. Moreover, the simulator can depend on X but not on A.</p>

    <p class="text-gray-300">Subversion KSND. For completeness we give a subversion-resistant analogue for knowledge soundness (not considered in [BFS16]), as this is the relevant notion for SNARKs. We modify game KSND and let the adversary choose crs in addition to x and  <span class="math">\\pi</span> . We are not aware of any construction that achieves S-KSND and some form of WI.</p>

    <p class="text-gray-300"><strong>Definition 2.8 (S-KSND)</strong> An NI system  <span class="math">\\Pi</span>  for relation generator Rg is subversion-knowledge-sound if for all PT adversaries A there exists a PT extractor E such that  <span class="math">\\mathbf{Adv}_{\\Pi,Rg,A,E}^{s-ksnd}(\\cdot)</span>  is negligible, where  <span class="math">\\mathbf{Adv}_{\\Pi,Rg,A,E}^{s-ksnd}(\\lambda) = \\Pr[S-KSND_{\\Pi,Rg,A,E}(\\lambda)]</span>  and game S-KSND is specified in Figure 1.</p>

      <h3 id="sec-2.5" class="text-xl font-semibold mt-8">2.5 Bilinear Groups and Assumptions</h3>

    <p class="text-gray-300"><u>BILINEAR GROUPS.</u> The SNARK constructions we consider are based on bilinear groups, for which we introduce a new type of knowledge-of-exponent assumption. We distinguish between asymmetric and symmetric groups.</p>

    <p class="text-gray-300"><strong>Definition 2.9</strong> An asymmetric-bilinear-group generator aGen is a PT algorithm that takes input a security parameter  <span class="math">1^{\\lambda}</span>  and outputs a description of a bilinear group  <span class="math">(p, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, \\mathbf{e})</span>  with the following properties:</p>

    <pre><code class="language-text">\\overline{G_{AME \\ PDH_{q,aGen,A}(\\lambda)}}
\\overline{G_{T} = (p, \\mathbb{G}_{1}, \\mathbb{G}_{2}, \\mathbb{G}_{T}, \\mathbf{e})} \\leftarrow \\operatorname{s} \\operatorname{aGen}(1^{\\lambda}) ; P_{1} \\leftarrow \\operatorname{s} \\mathbb{G}_{1}^{*} ; P_{2} \\leftarrow \\operatorname{s} \\mathbb{G}_{2}^{*} ; s \\leftarrow \\operatorname{s} \\mathbb{Z}_{p}^{*}
Y \\leftarrow \\operatorname{s} \\mathsf{A} \\left(Gr, P_{1}, P_{2}, sP_{1}, sP_{2}, \\dots, s^{q}P_{1}, s^{q}P_{2}, s^{q+2}P_{1}, s^{q+2}P_{2}, \\dots, s^{2q}P_{1}, s^{2q}P_{2}\\right)
\\operatorname{Return} \\left(Y = s^{q+1}P_{1}\\right)
\\overline{G_{AME \\ TSDH_{q,aGen,A}(\\lambda)}}
\\overline{G_{T} = (p, \\mathbb{G}_{1}, \\mathbb{G}_{2}, \\mathbb{G}_{T}, \\mathbf{e})} \\leftarrow \\operatorname{s} \\operatorname{aGen}(1^{\\lambda}) ; P_{1} \\leftarrow \\operatorname{s} \\mathbb{G}_{1}^{*} ; P_{2} \\leftarrow \\operatorname{s} \\mathbb{G}_{2}^{*} ; s \\leftarrow \\operatorname{s} \\mathbb{Z}_{p}^{*}
(r, Y) \\leftarrow \\operatorname{s} \\mathsf{A} \\left(Gr, P_{1}, P_{2}, sP_{1}, sP_{2}, \\dots, s^{q}P_{1}, s^{q}P_{2}, \\right)
\\operatorname{Return} \\left(r \\in \\mathbb{Z}_{p} \\setminus \\{s\\} \\text{ and } Y = \\operatorname{e}(P_{1}, P_{2})^{1/(s-r)}\\right)
\\overline{G_{AME \\ PKE_{q,aGen,Z,A,E}(\\lambda)}}
\\overline{G_{T} = (p, \\mathbb{G}_{1}, \\mathbb{G}_{2}, \\mathbb{G}_{T}, \\mathbf{e})} \\leftarrow \\operatorname{s} \\operatorname{aGen}(1^{\\lambda}) ; P_{1} \\leftarrow \\operatorname{s} \\mathbb{G}_{1}^{*} ; P_{2} \\leftarrow \\operatorname{s} \\mathbb{G}_{2}^{*} ; s \\leftarrow \\operatorname{s} \\mathbb{Z}_{p}^{*}
r \\leftarrow \\operatorname{s} \\{0, 1\\}^{A.rl(\\lambda)}
z \\leftarrow \\operatorname{s} \\mathsf{Z}(Gr, P_{1}, sP_{1}, \\dots, s^{q}P_{1})
(V, W) \\leftarrow \\mathsf{A} \\left(Gr, P_{1}, P_{2}, sP_{1}, sP_{2}, \\dots, s^{q}P_{1}, s^{q}P_{2}, z; r\\right)
(a_{0}, \\dots, a_{q}) \\leftarrow \\operatorname{s} \\mathsf{E} \\left(Gr, P_{1}, P_{2}, sP_{1}, sP_{2}, \\dots, s^{q}P_{1}, s^{q}P_{2}, z; r\\right)
\\operatorname{Return} \\left(\\operatorname{e}(V, P_{2}) = \\operatorname{e}(P_{1}, W) \\text{ and } V \\neq \\left(\\sum_{i=0}^{q} a_{i} s^{i}\\right) P_{1}\\right)
</code></pre>

    <p class="text-gray-300">Figure 2: Games defining assumptions q-PDH, q-TSDH and q-PKE</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>p is a prime of length  <span class="math">\\lambda</span> ;</li>
      <li><span class="math">(\\mathbb{G}_1,+)</span> ,  <span class="math">(\\mathbb{G}_2,+)</span>  and  <span class="math">(\\mathbb{G}_T,\\cdot)</span>  are groups of order p;</li>
      <li><span class="math">\\mathbf{e}: \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T</span>  is a bilinear map, that is, for all  <span class="math">a, b \\in \\mathbb{Z}_p</span>  and  <span class="math">S \\in \\mathbb{G}_1</span> ,  <span class="math">T \\in \\mathbb{G}_2</span>  we have:  <span class="math">\\mathbf{e}(aS, bT) = \\mathbf{e}(S, T)^{ab}</span> ;</li>
      <li><span class="math">\\mathbf{e}</span>  is non-degenerate, that is, for  <span class="math">P_1 \\in \\mathbb{G}_1^*</span>  and  <span class="math">P_2 \\in \\mathbb{G}_2^*</span>  (i.e.,  <span class="math">P_1</span>  and  <span class="math">P_2</span>  are generators)  <span class="math">\\mathbf{e}(P_1, P_2)</span>  generates  <span class="math">\\mathbb{G}_T</span> .</li>
    </ul>

    <p class="text-gray-300">Moreover, we assume that group operations and the bilinear map can be computed efficiently, membership of the groups and equality of group elements can be decided efficiently, and group generators can be sampled efficiently.</p>

    <p class="text-gray-300">A symmetric-bilinear-group generator sGen returns a bilinear group with  <span class="math">\\mathbb{G}_1 = \\mathbb{G}_2</span> , which we denote by  <span class="math">\\mathbb{G}</span> , and with a symmetric non-degenerate bilinear map  <span class="math">\\mathbf{e} \\colon \\mathbb{G} \\times \\mathbb{G} \\to \\mathbb{G}_T</span> .</p>

    <p class="text-gray-300"><u>ASSUMPTIONS.</u> We recall the assumptions under which SNARKs in the literature were proven sound. The following assumptions are from [DFGK14], who adapted PDH from [Gro10] to asymmetric groups, and TSDH from [BB04, Gen04].</p>

    <p class="text-gray-300"><strong>Definition 2.10</strong> (q-PDH) The  <span class="math">q(\\lambda)</span> -power Diffie-Hellman assumption holds for an asymmetric group generator aGen if  <span class="math">\\mathbf{Adv}^{\\mathrm{pdh}}_{q,\\mathsf{aGen},\\mathsf{A}}(\\cdot)</span>  is negligible for all PT adversaries A, where  <span class="math">\\mathbf{Adv}^{\\mathrm{pdh}}_{q,\\mathsf{aGen},\\mathsf{A}}(\\lambda)</span>  =  <span class="math">\\Pr[\\mathrm{PDH}_{q,\\mathsf{aGen},\\mathsf{A}}(\\lambda)]</span>  and PDH is defined in Figure 2.</p>

    <p class="text-gray-300">The q-PDH assumption for symmetric group generators sGen is defined analogously by letting  <span class="math">\\mathbb{G}_1 = \\mathbb{G}_2</span>  and  <span class="math">P_1 = P_2</span>  (A thus only receives 2q group elements).</p>

    <p class="text-gray-300"><strong>Definition 2.11</strong> (q-TSDH) The  <span class="math">q(\\lambda)</span> -target-group strong Diffie-Hellman assumption holds for an asymmetric group generator aGen if  <span class="math">\\mathbf{Adv}_{q,\\mathsf{aGen},\\mathsf{A}}^{\\mathrm{tsdh}}(\\cdot)</span>  is negligible for all PT adversaries A, where  <span class="math">\\mathbf{Adv}_{q,\\mathsf{aGen},\\mathsf{A}}^{\\mathrm{tsdh}}(\\lambda) = \\Pr[\\mathrm{TSDH}_{q,\\mathsf{aGen},\\mathsf{A}}(\\lambda)]</span>  and TSDH is defined in Figure 2.</p>

    <p class="text-gray-300">The q-TSDH assumption for symmetric group generators sGen is defined analogously by letting  <span class="math">\\mathbb{G}_1 = \\mathbb{G}_2</span>  and  <span class="math">P_1 = P_2</span>  (A thus only receives q + 1 group elements).</p>

    <p class="text-gray-300"><u>KEA.</u> The knowledge-of-exponent assumption [Dam92, HT98, BP04] in a group  <span class="math">\\mathbb G</span>  states that an algorithm A that is given two random generators  <span class="math">P,Q\\in\\mathbb G^*</span>  and outputs (cP,cQ) must know c. This is formalized by requiring that there exists an extractor for A which given A's coins outputs c. This has been considered in the bilinear-group setting [AF07] where A's output (cP,cQ) can be verified by using the bilinear map. Generalizations of KEA were made by Groth [Gro10], who assumes that for every A that on input  <span class="math">(P,Q,sP,sQ,s^2P,s^2Q,\\ldots,s^qP,s^qQ)</span>  returns (cP,cQ) an extractor can extract  <span class="math">(a_0,\\ldots,a_q)</span>  such that  <span class="math">c=\\sum_{i=0}^q a_i s^i</span> . Danezis et al. [DFGK14] port Groth's assumption to asymmetric groups as follows.</p>

    <p class="text-gray-300"><strong>Definition 2.12</strong> (q-PKE) The  <span class="math">q(\\lambda)</span> -power knowledge of exponent assumption holds for aGen w.r.t. the class  <span class="math">\\mathcal{A}ux</span>  of auxiliary input generators if for every PT  <span class="math">\\mathsf{Z} \\in \\mathcal{A}ux</span>  and PT adversary  <span class="math">\\mathsf{A}</span>  there exists a PT extractor  <span class="math">\\mathsf{E}</span>  s.t.  <span class="math">\\mathbf{Adv}^{\\mathrm{pke}}_{q,\\mathsf{aGen},\\mathsf{Z},\\mathsf{A},\\mathsf{E}}(\\cdot)</span>  is negligible, where  <span class="math">\\mathbf{Adv}^{\\mathrm{pke}}_{q,\\mathsf{aGen},\\mathsf{Z},\\mathsf{A},\\mathsf{E}}(\\lambda) = \\Pr[\\mathrm{PKE}_{q,\\mathsf{aGen},\\mathsf{Z},\\mathsf{A},\\mathsf{E}}(\\lambda)]</span>  and  <span class="math">\\mathrm{PKE}</span>  is defined in Figure 2.</p>

    <p class="text-gray-300">The q-PKE assumption for symmetric generators sGen is defined by letting  <span class="math">\\mathbb{G}_1 = \\mathbb{G}_2</span>  but again choosing  <span class="math">P_1, P_2 \\leftarrow \\mathbb{G}^*</span>  (A thus again receives 2q + 2 group elements).</p>

    <p class="text-gray-300">Bellare et al. [BFS16] consider deterministically generated groups (whereas for SNARK systems the group will be part of the relation R output by a relation generator Rg). They therefore need to define all other assumptions, such as DLin [BBS04], with respect to this fixed group. BFS introduce a new type of KEA, called DH-KEA, which assumes that if A outputs a Diffie-Hellman (DH) tuple (sP, tP, stP) w.r.t. the fixed P, then A must know either s or t. The auxiliary input given to A are two additional random generators  <span class="math">H_0, H_1</span> . The intuition is that while an adversary may produce one group element without knowing its discrete logarithm by hashing into the elliptic curve [BF01, SvdW06, BCI<sup>+</sup>10], it seems hard to produce a DH tuple without knowing at least one of the logarithms.</p>

    <p class="text-gray-300"><strong>Definition 2.13 (DH-KEA)</strong> Let detSGen be a deterministic group generator. The Diffie-Hellman knowledge of exponent assumption holds for detSGen if for every PT A there exists a PT E s.t.  <span class="math">\\mathbf{Adv}^{\\mathrm{dhke}}_{\\mathsf{detSGen},\\mathsf{A},\\mathsf{E}}(\\cdot)</span>  is negligible, where  <span class="math">\\mathbf{Adv}^{\\mathrm{dhke}}_{\\mathsf{detSGen},\\mathsf{A},\\mathsf{E}}(\\lambda) = \\Pr[\\mathrm{DHKE}_{\\mathsf{detSGen},\\mathsf{A},\\mathsf{E}}(\\lambda)]</span>  and  <span class="math">\\mathrm{DHKE}</span>  defined in Figure 3.</p>

    <p class="text-gray-300"><u>SKE</u>. We now consider a weakening of DH-KEA where we prescribe s=t; that is, if A on input P outputs a pair  <span class="math">(sP,s^2P)</span>  then E extracts s. This assumption is weaker than (i.e., implied by) DH-KEA. As we consider groups with randomly sampled generators, we let A choose the generator P itself and assume that there exists an extractor that extracts s when A outputs a tuple  <span class="math">(P,sP,s^2P)</span> . This allows us to choose a random generator when setting up parameters of a scheme. The security of such schemes then follows from assumptions such as PDH, as defined above, where the generators are chosen randomly.</p>

    <p class="text-gray-300"><strong>Definition 2.14 (SKE)</strong> Let sGen be a symmetric-group generator. The square knowledge of exponent assumption holds for sGen if for every PT A there exists a PT E s.t.  <span class="math">\\mathbf{Adv}^{\\mathrm{ske}}_{\\mathsf{sGen},\\mathsf{A},\\mathsf{E}}(\\cdot)</span>  is negligible, where  <span class="math">\\mathbf{Adv}^{\\mathrm{ske}}_{\\mathsf{sGen},\\mathsf{A},\\mathsf{E}}(\\lambda) = \\Pr[\\mathrm{SKE}_{\\mathsf{sGen},\\mathsf{A},\\mathsf{E}}(\\lambda)]</span>  with SKE is defined in Figure 3.</p>

    <pre><code class="language-text">\\frac{\\operatorname{GAME} \\operatorname{DHKE}_{\\operatorname{detSGen},A,E}(\\lambda)}{(p,\\mathbb{G},\\mathbb{G}_T,\\mathbf{e},P) \\leftarrow \\operatorname{detSGen}(1^{\\lambda}) \\; ; \\; H_0, H_1 \\leftarrow \\mathbb{s} \\; \\mathbb{G} \\; ; \\; r \\leftarrow \\mathbb{s} \\; \\{0,1\\}^{\\operatorname{A.rl}(\\lambda)}} \\\\ (S_0,S_1,S_2) \\leftarrow \\operatorname{A}(1^{\\lambda},H_0,H_1;r) \\; ; \\; s \\leftarrow \\mathbb{s} \\; \\operatorname{E}(1^{\\lambda},H_0,H_1,r) \\\\ \\operatorname{Return} \\; \\left( \\mathbf{e}(S_0,S_1) = \\mathbf{e}(P,S_2) \\; \\operatorname{and} \\; sP \\neq S_0 \\; \\operatorname{and} \\; sP \\neq S_1 \\right) \\\\ \\frac{\\operatorname{GAME} \\; \\operatorname{SKE}_{\\mathbb{sGen},A,E}(\\lambda)}{\\operatorname{Gr} \\; \\; (p,\\mathbb{G},\\mathbb{G}_T,\\mathbf{e}) \\leftarrow \\mathbb{s} \\; \\operatorname{sGen}(1^{\\lambda}) \\; ; \\; r \\leftarrow \\mathbb{s} \\; \\{0,1\\}^{\\operatorname{A.rl}(\\lambda)}} \\\\ (S_0,S_1,S_2) \\leftarrow \\operatorname{A}(Gr;r) \\\\ s \\leftarrow \\mathbb{s} \\; \\operatorname{E}(Gr,r) \\\\ \\operatorname{Return} \\; \\left( \\mathbf{e}(S_1,S_1) = \\mathbf{e}(S_0,S_2) \\; \\operatorname{and} \\; sS_0 \\neq S_1 \\right) \\\\ \\frac{\\operatorname{GAME} \\; \\operatorname{SKE}_{\\mathbb{aGen},A,E}(\\lambda)}{\\operatorname{Gr} \\; \\; (p,\\mathbb{G}_1,\\mathbb{G}_2,\\mathbb{G}_T,\\mathbf{e}) \\leftarrow \\mathbb{s} \\; \\operatorname{aGen}(1^{\\lambda}) \\; ; \\; r \\leftarrow \\mathbb{s} \\; \\{0,1\\}^{\\operatorname{A.rl}(\\lambda)}} \\\\ (S_0,S_1,S_2,T_0,T_1) \\leftarrow \\operatorname{A}(Gr;r) \\\\ s \\leftarrow \\mathbb{s} \\; \\operatorname{E}(Gr,r) \\\\ \\operatorname{Return} \\; \\left( \\mathbf{e}(S_1,T_0) = \\mathbf{e}(S_0,T_1) \\; \\operatorname{and} \\; \\mathbf{e}(S_1,T_1) = \\mathbf{e}(S_2,T_0) \\; \\operatorname{and} \\; sS_0 \\neq S_1 \\right)
</code></pre>

    <p class="text-gray-300">Figure 3: Games defining knowledge-of-exponent assumptions</p>

    <p class="text-gray-300">SKE FOR ASYMMETRIC GROUPS. For asymmetric bilinear-group generators, we make assumption SKE in the first source group  <span class="math">\\mathbb{G}_1</span> . Unlike for symmetric groups, a tuple  <span class="math">(S_0, sS_0, s^2S_0) \\in \\mathbb{G}_1^3</span>  is not verifiable via an asymmetric pairing. To make it verifiable, we weaken the assumption and require A to additionally output a  <span class="math">\\mathbb{G}_2</span> -element  <span class="math">T_0</span>  as well as  <span class="math">T_1 = sT_0</span> , which enables verification (as done in game SKE<sub>aGen</sub>).</p>

    <p class="text-gray-300"><strong>Definition 2.15 (SKE)</strong> Let a Gen be an asymmetric-group generator. The SKE assumption holds for a Gen in the first source group if for every PT A there exists a PT E s.t.  <span class="math">\\mathbf{Adv}^{\\mathrm{ske}}_{\\mathsf{aGen},\\mathsf{A,E}}(\\cdot)</span>  is negligible, where  <span class="math">\\mathbf{Adv}^{\\mathrm{ske}}_{\\mathsf{aGen},\\mathsf{A,E}}(\\lambda) = \\Pr[\\mathrm{SKE}_{\\mathsf{aGen},\\mathsf{A,E}}(\\lambda)]</span>  and SKE is defined in Figure 3.</p>

    <p class="text-gray-300">We note that in addition to verifiability these additional elements  <span class="math">T_0</span>  and  <span class="math">T_1</span>  actually add to the plausibility of the assumption for asymmetric groups. Even if outputting  <span class="math">S_2</span>  was not required, one could argue that the following stronger assumption holds in Type-3 bilinear groups, in which DDH holds in  <span class="math">\\mathbb{G}_1</span>  and in  <span class="math">\\mathbb{G}_2</span> : it is hard to compute  <span class="math">(S_0, S_1, T_0, T_1) \\in \\mathbb{G}_1^2 \\times \\mathbb{G}_2^2</span>  with  <span class="math">\\mathbf{e}(S_1, T_0) = \\mathbf{e}(S_0, T_1)</span>  without knowing the logarithms of  <span class="math">S_1</span>  to base  <span class="math">S_0</span>  (or equivalently  <span class="math">T_1</span>  to base  <span class="math">T_0</span> ): an adversary might choose  <span class="math">S_0</span>  and  <span class="math">S_1</span>  obliviously by hashing into the group; but if it was able to compute from them the respective  <span class="math">T_0</span>  and  <span class="math">T_1</span>  then this would break DDH in  <span class="math">\\mathbb{G}_1</span> . (Given a DDH challenge  <span class="math">(S_0, S_1 = s_1 S_0, S_2 = s_2 S_0, R)</span> , compute  <span class="math">T_0</span>  and  <span class="math">T_1</span>  as above; then we have  <span class="math">R = s_1 s_2 S_0</span>  iff  <span class="math">\\mathbf{e}(R, T_0) = \\mathbf{e}(S_2, T_1)</span> .) Of course, this argument breaks down if there is an efficiently computable homomorphism from  <span class="math">\\mathbb{G}_1</span>  to  <span class="math">\\mathbb{G}_2</span>  or vice versa.</p>

    <p class="text-gray-300">Finally, we note that q-PKE with q = 0 does not imply SKE, since a PKE adversary must return (V, W) which is a multiple of the received  <span class="math">(P_1, P_2)</span> , while an SKE adversary can choose the &quot;basis&quot;  <span class="math">(S_0, T_0)</span>  itself. The converse does not hold either (SKE <span class="math">\\not\\Rightarrow</span> PKE), since an SKE adversary must return  <span class="math">S_2 = s^2S_0</span> .</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;2</sup>When fixing the generators  <span class="math">S_0</span>  and  <span class="math">T_0</span> , this corresponds to the assumption made by Abdolmaleki et al. [ABLZ17] to show S-ZK of their SNARK.</p>

      <h3 id="sec-2.6" class="text-xl font-semibold mt-8">2.6 SKE in the Generic-Group Model</h3>

    <p class="text-gray-300">We show that SKE holds in the generic-group model. We show it for symmetric generic groups, which implies the result for asymmetric groups (where the adversary has less power). As [BFS16] did for DH-KEA, we reflect hashing into elliptic curves by providing the adversary with an additional generic operation: it can create new group elements without knowing their discrete logarithms (which are not known to the extractor either).</p>

    <p class="text-gray-300"><strong>Theorem 2.16</strong> SKE, as defined in Definition 2.14, holds in the generic-group model with hashing into the group.</p>

    <p class="text-gray-300">In the proof of the theorem we will use the following lemma, which we prove first.</p>

    <p class="text-gray-300"><strong>Lemma 2.17</strong> Let  <span class="math">\\mathbb{F}</span>  be a field and let  <span class="math">A, B, C \\in \\mathbb{F}[X_1, \\dots, X_k]</span> , with degree of A, B and C at most 1. If  <span class="math">A \\cdot C = B^2</span>  then for some  <span class="math">s \\in \\mathbb{F}</span> :  <span class="math">B = s \\cdot A</span> .</p>

    <p class="text-gray-300"><strong>Proof.</strong> Let  <span class="math">\\alpha_i, \\beta_i, \\gamma_i</span> , for  <span class="math">0 \\le i \\le k</span> , denote the coefficients of  <span class="math">X_i</span>  (where  <span class="math">X_0 := 1</span> ) in A, B, C, respectively. If A = 0 then B = 0 and the theorem follows. Assume thus  <span class="math">A \\ne 0</span> ; Define  <span class="math">j := \\min\\{i \\in [0,k] : \\alpha_j \\ne 0\\}</span>  and  <span class="math">s := \\beta_j \\cdot \\alpha_j^{-1}</span> .</p>

    <p class="text-gray-300">To prove the lemma, we will now show that for all  <span class="math">i \\in [0, k]</span> :</p>

    <p class="text-gray-300">
<span class="math">$\\beta_i = s \\cdot \\alpha_i \\ . \\tag{1}</span>$</p>

    <p class="text-gray-300">From  <span class="math">A \\cdot C = B^2</span>  we have</p>

    <p class="text-gray-300"><span class="math">$L(\\vec{X}) := \\left(\\beta_0 + \\sum_{i=1}^k \\beta_i X_i\\right)^2 - \\left(\\alpha_0 + \\sum_{i=1}^k \\alpha_i X_i\\right) \\left(\\gamma_0 + \\sum_{i=1}^k \\gamma_i X_i\\right) = 0 .</span>$
(2)</p>

    <p class="text-gray-300">From  <span class="math">L(0,\\ldots,0)=0</span> , we get: (I)  <span class="math">\\beta_0^2=\\alpha_0\\gamma_0</span> , which implies that Eq. (1) holds for i=0: either  <span class="math">\\alpha_0=0</span> , then from (I):  <span class="math">\\beta_0=0</span> ; or  <span class="math">\\alpha_0\\neq 0</span> , then j=0 and Eq. (1) holds as well.</p>

    <p class="text-gray-300">Let now  <span class="math">i \\in [1, k]</span>  be arbitrarily fixed and let  <span class="math">e_i</span>  denote the vector  <span class="math">(0, \\dots, 0, 1, 0, \\dots, 0)</span>  with 1 at position i. Consider  <span class="math">L(e_i) = 0</span> , which together with (I) yields</p>

    <p class="text-gray-300">
<span class="math">$2\\beta_0\\beta_i + \\beta_i^2 - \\alpha_0\\gamma_i - \\alpha_i\\gamma_0 - \\alpha_i\\gamma_i = 0.</span>$
(3)</p>

    <p class="text-gray-300">Similarly, from  <span class="math">L(2e_i) = 0</span> , we have  <span class="math">4\\beta_0\\beta_i + 4\\beta_i^2 - 2\\alpha_0\\gamma_i - 2\\alpha_i\\gamma_0 - 4\\alpha_i\\gamma_i = 0</span> , which after subtracting Eq. (3) twice yields: (II)  <span class="math">\\beta_i^2 = \\alpha_i\\gamma_i</span> . If  <span class="math">\\alpha_i = 0</span>  then  <span class="math">\\beta_i = 0</span> , which shows Eq. (1). For the remainder let us assume  <span class="math">\\alpha_i \\neq 0</span> .</p>

    <p class="text-gray-300">Plugging (II) into Eq. (3) yields: (III)  <span class="math">2\\beta_0\\beta_i = \\alpha_0\\gamma_i - \\alpha_i\\gamma_0</span> .</p>

    <p class="text-gray-300">If  <span class="math">\\alpha_0 \\neq 0</span>  then j = 0 and plugging (I) and (II) into (III) yields</p>

    <p class="text-gray-300"><span class="math">$2\\beta_0\\beta_i - \\alpha_0\\alpha_i^{-1}\\beta_i^2 - \\alpha_i\\alpha_0^{-1}\\beta_0^2 = 0.</span>$</p>

    <p class="text-gray-300">Solving for  <span class="math">\\beta_i</span>  yields the unique solution  <span class="math">\\beta_i = \\beta_0 \\alpha_0^{-1} \\alpha_i</span> , which shows Eq. (1) for the case  <span class="math">\\alpha_0 \\neq 0</span> .</p>

    <p class="text-gray-300">Let us now assume  <span class="math">\\alpha_0 = 0</span> . By (I) we have  <span class="math">\\beta_0 = 0</span> . If i = j then Eq. (1) holds by definition of s. Assume  <span class="math">i \\neq j</span> . From  <span class="math">L(e_i + e_j)</span>  we have (since  <span class="math">\\alpha_0 = \\beta_0 = 0</span> ):</p>

    <p class="text-gray-300"><span class="math">$0 = \\beta_i^2 + \\beta_j^2 + 2\\beta_i\\beta_j - \\alpha_i\\gamma_0 - \\alpha_i\\gamma_i - \\alpha_i\\gamma_j - \\alpha_j\\gamma_0 - \\alpha_j\\gamma_i - \\alpha_j\\gamma_j = 2\\beta_i\\beta_j - \\alpha_i\\gamma_j - \\alpha_j\\gamma_i ,</span>$</p>

    <p class="text-gray-300">where we used (II) and  <span class="math">\\alpha_i \\gamma_0 = \\alpha_j \\gamma_0 = 0</span>  (which follows from (III) and  <span class="math">\\alpha_0 = \\beta_0 = 0</span> ). Together with (II) the latter yields  <span class="math">2\\beta_i \\beta_j - \\alpha_i \\alpha_j^{-1} \\beta_j^2 - \\alpha_j \\alpha_i^{-1} \\beta_i^2 = 0</span> . Solving for  <span class="math">\\beta_i</span>  yields the unique solution  <span class="math">\\beta_i = \\beta_j \\alpha_j^{-1} \\alpha_i</span> , which concludes the proof.</p>

    <p class="text-gray-300">Proof of Theorem <a href="#page-14-0">2.16.</a> In the &quot;traditional&quot; generic-group model, group elements are represented by random strings and an adversary A only has access to operations on them (addition of elements in G, multiplication of elements in G<sup>T</sup> and pairing of elements in G) via oracles. In particular, A can only produce new G elements by adding received elements.</p>

    <p class="text-gray-300">We also need to reflect the fact that by &quot;hashing into the group&quot;, A can create a new group element without knowing its discrete logarithm w.r.t. one of the received elements. We extend the genericgroup model and provide the adversary with an additional operation, namely to request a new group element &quot;independently of the received ones&quot;. (And neither the adversary nor the extractor we construct knows its discrete logarithm.)</p>

    <p class="text-gray-300">For SKE the adversary A receives the group element P and needs to output (S0, S1, S2) where for some s, t: S<sup>0</sup> = tP, S<sup>1</sup> = sS<sup>0</sup> = stP and S<sup>2</sup> = s <sup>2</sup>S<sup>0</sup> = s 2 tP. The adversary can produce these group elements by combining the received generator P with newly generated (&quot;hashed&quot;) group elements that it has requested. We represent the latter as xiP, for i = 1, . . . k, for some k. The extractor keeps track of the group operations performed by A and thus knows</p>

    <p class="text-gray-300">
<span class="math">$\\alpha_0, \\dots, \\alpha_k, \\beta_0, \\dots, \\beta_k, \\gamma_0, \\dots, \\gamma_k \\in \\mathbb{Z}_p</span>$
(4)</p>

    <p class="text-gray-300">such that A's output (S0, S1, S2) is of the form</p>

    <p class="text-gray-300"><span class="math">$S_0 = \\alpha_0 P + \\sum_{i=1}^k \\alpha_i(x_i P)</span>$
<span class="math">S_1 = \\beta_0 P + \\sum_{i=1}^k \\beta_i(x_i P)</span>   <span class="math">S_2 = \\gamma_0 P + \\sum_{i=1}^k \\gamma_i(x_i P)</span></p>

    <p class="text-gray-300">Note that the extractor does however not know x := (x1, . . . , xk).</p>

    <p class="text-gray-300">Assume the adversary wins and e(S1, S1) = e(S0, S2). Taking the logarithms of the latter yields</p>

    <p class="text-gray-300"><span class="math">$(\\beta_0 + \\sum_{i=1}^k \\beta_i x_i)^2 - (\\alpha_0 + \\sum_{i=1}^k \\alpha_i x_i) (\\gamma_0 + \\sum_{i=1}^k \\gamma_i x_i) = 0 .</span>$
(5)</p>

    <p class="text-gray-300">Since the adversary has no information about x1, . . . , x<sup>k</sup> (except for a negligible information leak by comparing group elements, which we ignore), the values in Eq. <a href="#page-15-0">(4)</a> are generated independently of x1, . . . , xk. By the Schwartz-Zippel lemma the probability that Eq. <a href="#page-15-1">(5)</a> holds when x1, . . . , x<sup>k</sup> are randomly chosen is negligible, except if the left-hand side corresponds to the zero polynomial. With overwhelming probability we thus have</p>

    <p class="text-gray-300">
<span class="math">$B(\\vec{X})^2 - A(\\vec{X}) \\cdot C(\\vec{X}) = 0</span>$</p>

    <p class="text-gray-300">with</p>

    <p class="text-gray-300"><span class="math">$A(\\vec{X}) = \\alpha_0 + \\sum_{i=1}^k \\alpha_i X_i</span>$
<span class="math">B(\\vec{X}) = \\beta_0 + \\sum_{i=1}^k \\beta_i X_i</span>   <span class="math">C(\\vec{X}) = \\gamma_0 + \\sum_{i=1}^k \\gamma_i X_i</span></p>

    <p class="text-gray-300">By Lemma <a href="#page-14-3">2.17</a> we have that B = s A for some s &isin; F. The extractor computes and returns s, which is correct since S<sup>1</sup> = B(~x)P = sA(~x)P = s S0.</p>

    </section>

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3 SNARKs</h2>

    <p class="text-gray-300">We start with a formal definition of SNARGs and SNARKs.</p>

    <p class="text-gray-300">Definition 3.1 (SNARG) An NI system &Pi; = (&Pi;.Pg, &Pi;.P, &Pi;.V) is a succinct non-interactive argument for relation generator Rg if it is complete and sound, as in Definition <a href="#page-7-1">2.1,</a> and moreover succinct, meaning that for all &lambda; &isin; N, all R &isin; [Rg(1<sup>&lambda;</sup> )], all crs &isin; [&Pi;.Pg(R)], all x &isin; L(R), all w &isin; R(x) and all &pi; &isin; [&Pi;.P(1<sup>&lambda;</sup> , crs, x, w)] we have |&pi;| = poly(&lambda;) and &Pi;.V(1<sup>&lambda;</sup> , crs, x, &pi;) runs in time poly(&lambda; + |x|).</p>

    <p class="text-gray-300"><strong>Definition 3.2 (SNARK)</strong> A SNARG  <span class="math">\\Pi</span>  is a succinct non-interactive argument of knowledge if it satisfies knowledge soundness, as in Definition 2.2.</p>

    <p class="text-gray-300">Gennaro, Gentry, Parno and Raykova [GGPR13] base their SNARK constructions on <em>quadratic</em> programs. In particular, they show how to convert any boolean circuit into a quadratic span program and any arithmetic circuit into a quadratic arithmetic program (QAP).</p>

    <p class="text-gray-300"><strong>Definition 3.3 (QAP)</strong> A quadratic arithmetic program over a field  <span class="math">\\mathbb{F}</span>  is a tuple of the form</p>

    <p class="text-gray-300"><span class="math">$(\\mathbb{F}, n, \\{A_i(X), B_i(X), C_i(X)\\}_{i=0}^m, Z(X))</span>$
,</p>

    <p class="text-gray-300">where  <span class="math">A_i(X), B_i(X), C_i(X), Z(X) \\in \\mathbb{F}[X]</span> , which define a language of statements  <span class="math">(s_1, \\ldots, s_n) \\in \\mathbb{F}^n</span>  and witnesses  <span class="math">(s_{n+1}, \\ldots, s_m) \\in \\mathbb{F}^{m-n}</span>  such that</p>

    <p class="text-gray-300">
<span class="math">$\\left(A_0(X) + \\sum_{i=1}^m s_i A_i(X)\\right) \\cdot \\left(B_0(X) + \\sum_{i=1}^m s_i B_i(X)\\right) = C_0(X) + \\sum_{i=1}^m s_i C_i(X) + H(X) \\cdot Z(X) , \\quad (6)</span>$</p>

    <p class="text-gray-300">for some degree-(d-2) quotient polynomial H(X), where d is the degree of Z(X) (we assume the degrees of all  <span class="math">A_i(X), B_i(X), C_i(X)</span>  are at most d-1).</p>

    <p class="text-gray-300"><strong>Definition 3.4 (Strong QAP)</strong> A strong QAP is a QAP such that for any  <span class="math">(r_1, \\ldots, r_m, s_1, \\ldots, s_m, t_1, \\ldots, t_m) \\in \\mathbb{F}^{3m}</span>  for which Z(X) divides</p>

    <p class="text-gray-300">
<span class="math">$(A_0(X) + \\sum_{i=1}^m r_i A_i(X)) \\cdot (B_0(X) + \\sum_{i=1}^m s_i B_i(X)) - C_0(X) + \\sum_{i=1}^m t_i C_i(X) ,</span>$
(7)</p>

    <p class="text-gray-300">it must be the case that  <span class="math">(r_1, \\ldots, r_m) = (s_1, \\ldots, s_m) = (t_1, \\ldots, t_m)</span> .</p>

    <p class="text-gray-300">All of the discussed SNARK constructions are for QAPs defined over a bilinear group. We will thus consider relation generators Rg of the following form:</p>

    <p class="text-gray-300"><strong>Definition 3.5 (QAP relation)</strong> A QAP relation generator Rg is a PT algorithm that on input  <span class="math">1^{\\lambda}</span>  returns a relation description of the following form:</p>

    <p class="text-gray-300"><span class="math">$R = \\left(Gr, n, \\vec{A}, \\vec{B}, \\vec{C}, Z\\right) \\quad \\text{where } Gr \\text{ is a bilinear group whose order } p \\text{ defines } \\mathbb{F} := \\mathbb{Z}_p \\text{ and}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\vec{A}, \\vec{B}, \\vec{C} \\in \\left(\\mathbb{F}^{(d-1)}[X]\\right)^{(m+1)}, \\ Z \\in \\mathbb{F}^{(d)}[X], \\ n \\leq m \\ . \\tag{8}</span>$</p>

    <p class="text-gray-300">For  <span class="math">x \\in \\mathbb{F}^n</span>  and  <span class="math">w \\in \\mathbb{F}^{m-n}</span>  we define R(x,w) = true iff there exists  <span class="math">H(X) \\in \\mathbb{F}[X]</span>  so that Eq. (6) holds for  <span class="math">s := x \\parallel w</span>  (where &quot; <span class="math">\\parallel</span> &quot; denotes concatenation).</p>

    <p class="text-gray-300">Gennaro et al. [GGPR13] presented the first zero-knowledge SNARK construction for arithmetic circuits that are expressed as quadratic arithmetic programs. They separate the CRS into a (long) part pk, used to compute proofs, and a (short) part vk, used to verify them. Their construction is detailed in Figure 4. As it is defined over symmetric bilinear groups, we assume that Gr returned by Rg is symmetric.</p>

    <p class="text-gray-300">We define procedure CRS VERIFICATION, which a prover runs on a CRS before using it the first time, as follows:</p>

    <p class="text-gray-300"><u>CRS VERIFICATION.</u> On input (R, vk, pk), let  <span class="math">\\{a_{i,j}\\}</span> ,  <span class="math">\\{b_{i,j}\\}</span> ,  <span class="math">\\{c_{i,j}\\}</span> ,  <span class="math">\\{z_k\\}</span>  denote the coefficients of  <span class="math">A_i(X)</span> ,  <span class="math">B_i(X)</span> ,  <span class="math">C_i(X)</span>  and Z(X), respectively, that are contained in R, for  <span class="math">0 \\le i \\le m</span>  and  <span class="math">0 \\le j \\le d-1</span>  and  <span class="math">0 \\le k \\le d</span> .</p>

    <p class="text-gray-300"> <span class="math">\\overline{\\text{KEY GENERATION.}}</span>  On input R as in Eq. (8) representing a QAP for a symmetric group Gr do the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Sample  <span class="math">P \\leftarrow \\mathbb{S} \\mathbb{G}^*</span>  and  <span class="math">\\tau, \\alpha, \\beta_A, \\beta_B, \\beta_C \\leftarrow \\mathbb{F}</span> , conditioned on  <span class="math">Z(\\tau) \\neq 0</span>  and  <span class="math">\\gamma \\leftarrow \\mathbb{F}^*</span> .</li>
    </ol></li>
      <li>2. Set  <span class="math">vk = (P_1, P_2, vk_A, vk_{B,0}, vk_{C,0}, vk_Z, vk_{\\alpha}, vk_{\\gamma}, vk_{A,\\gamma}&#x27;&#x27;, vk_{B,\\gamma}&#x27;&#x27;, vk_{C,\\gamma}&#x27;&#x27;)</span>  where</li>
    </ul>

    <p class="text-gray-300">3. Set  <span class="math">pk = (pk_A, pk&#x27;_A, pk&#x27;&#x27;_A, pk&#x27;&#x27;_{Z,A}, pk_B, pk&#x27;_B, pk&#x27;&#x27;_B, pk&#x27;&#x27;_{Z,B}, pk_C, pk&#x27;_C, pk&#x27;&#x27;_C, pk&#x27;&#x27;_C, pk&#x27;&#x27;_H, pk&#x27;_H, pk&#x27;_L, pk&#x27;_Z)</span> ,</p>

    <p class="text-gray-300">where for
<span class="math">$i=n+1,\\ldots,m</span>$
:  <span class="math">pk_{A,i}:=A_i(\\tau)P</span>   <span class="math">pk&#x27;_{A,i}:=A_i(\\tau)\\alpha P</span>   <span class="math">pk&#x27;&#x27;_{A,i}:=A_i(\\tau)\\beta_A P</span>  for  <span class="math">i=1,\\ldots,m</span> :  <span class="math">pk_{B,i}:=B_i(\\tau)P</span>   <span class="math">pk&#x27;_{B,i}:=B_i(\\tau)\\alpha P</span>   <span class="math">pk&#x27;&#x27;_{B,i}:=B_i(\\tau)\\beta_B P</span>   <span class="math">pk_{C,i}:=C_i(\\tau)P</span>   <span class="math">pk&#x27;_{C,i}:=C_i(\\tau)\\alpha P</span>   <span class="math">pk&#x27;&#x27;_{C,i}:=C_i(\\tau)\\beta_C P</span>  for  <span class="math">i=0,\\ldots,d</span> :  <span class="math">pk_{H,i}:=\\tau^i P</span>   <span class="math">pk&#x27;_{H,i}:=\\tau^i \\alpha P</span>  and moreover  <span class="math">pk_Z:=Z(\\tau)P</span>   <span class="math">pk&#x27;_{Z,i}:=Z(\\tau)\\alpha P</span>   <span class="math">pk&#x27;_{Z,i}:=Z(\\tau)\\beta_A P</span>   <span class="math">pk_{B,0}:=B_0(\\tau)P</span>   <span class="math">pk&#x27;_{B,0}:=B_0(\\tau)\\alpha P</span>   <span class="math">pk&#x27;&#x27;_{Z,B}:=Z(\\tau)\\beta_B P</span>   <span class="math">pk_{C,0}:=C_0(\\tau)P</span>   <span class="math">pk&#x27;_{C,0}:=C_0(\\tau)\\alpha P</span>   <span class="math">pk&#x27;&#x27;_{Z,C}:=Z(\\tau)\\beta_C P</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Return crs := (vk, pk).</li>
    </ol>

    <p class="text-gray-300">PROVE. On input R, (vk, pk) and  <span class="math">\\vec{s} \\in \\mathbb{F}^m</span>  s.t. Eq. (6) is satisfied for some  <span class="math">H&#x27;(X) \\in \\mathbb{F}[X]</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If (R, vk, pk) does not pass CRS verification then return  <span class="math">\\perp</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Sample  <span class="math">\\delta_A, \\delta_B, \\delta_C \\leftarrow \\mathbb{F}</span>  and define  <span class="math">A(X) := A_0(X) + \\sum_{i=1}^m s_i A_i(X) + \\delta_A Z(X)</span>   <span class="math">B(X) := B_0(X) + \\sum_{i=1}^m s_i B_i(X) + \\delta_B Z(X)</span>   <span class="math">C(X) := C_0(X) + \\sum_{i=1}^m s_i C_i(X) + \\delta_C Z(X)</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute H(X) s.t. A(X)B(X) C(X) = H(X)Z(X) and let  <span class="math">(h_0, \\ldots, h_d) \\in \\mathbb{F}^{d+1}</span>  be its coefficients. (If H'(X) satisfies Eq. (6) then  <span class="math">H(X) = H&#x27;(X) + \\delta_A B(X) + \\delta_B A(X) \\delta_A \\delta_B Z(X) \\delta_C</span> .)</li>
    </ol></li>
    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">Define
<span class="math">$\\pi_{A} := \\sum_{i=n+1}^{m} s_{i}pk_{A,i} + \\delta_{A} pk_{Z}</span>$
<span class="math">\\pi&#x27;_{A} := \\sum_{i=n+1}^{m} s_{i}pk&#x27;_{A,i} + \\delta_{A} pk&#x27;_{Z}</span>   <span class="math">\\pi&#x27;_{B} := \\sum_{i=1}^{m} s_{i}pk_{B,i} + \\delta_{B} pk_{Z}</span>   <span class="math">\\pi&#x27;_{B} := \\sum_{i=1}^{m} s_{i}pk&#x27;_{B,i} + \\delta_{B} pk&#x27;_{Z}</span>   <span class="math">\\pi&#x27;_{C} := \\sum_{i=1}^{m} s_{i}pk&#x27;_{C,i} + \\delta_{C} pk_{Z}</span>   <span class="math">\\pi&#x27;_{C} := \\sum_{i=1}^{m} s_{i}pk&#x27;_{C,i} + \\delta_{C} pk&#x27;_{Z}</span>   <span class="math">\\pi&#x27;_{H} := \\sum_{i=1}^{d} h_{i}pk_{H,i}</span>   <span class="math">\\pi&#x27;_{H} := \\sum_{i=1}^{d} h_{i}pk&#x27;_{H,i}</span>   <span class="math">\\pi&#x27;_{K} := \\sum_{i=n+1}^{m} s_{i}pk&#x27;&#x27;_{A,i} + \\delta_{A}pk&#x27;&#x27;_{A,i} + \\sum_{i=1}^{m} s_{i}pk&#x27;&#x27;_{B,i} + \\delta_{B}pk&#x27;&#x27;_{A,i} + \\sum_{i=1}^{m} s_{i}pk&#x27;&#x27;_{C,i} + \\delta_{C}pk&#x27;&#x27;_{A,i}</span></p></li>
      <li><p class="text-gray-300">Return  <span class="math">\\pi := (\\pi_A, \\pi&#x27;_A, \\pi_B, \\pi&#x27;_B, \\pi_C, \\pi&#x27;_C, \\pi_H, \\pi&#x27;_H, \\pi_K)</span> .</p></li>
    </ol>

    <p class="text-gray-300">VERIFY. On input R, vk,  <span class="math">\\vec{x} \\in \\mathbb{F}^n</span>  and proof  <span class="math">\\pi \\in \\mathbb{G}^9</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">vk_x := vk_{A,0} + \\sum_{i=1}^n x_i vk_{A,i}</span> .</li>
    </ol></li>
      <li>2. Check validity of  <span class="math">\\pi&#x27;_A</span> ,  <span class="math">\\pi&#x27;_B</span> ,  <span class="math">\\pi&#x27;_C</span>  and  <span class="math">\\pi&#x27;_H</span> :  <span class="math">\\mathbf{e}(\\pi&#x27;_H, P) = \\mathbf{e}(\\pi_H, vk_\\alpha)</span>   <span class="math">\\mathbf{e}(\\pi&#x27;_A, P) = \\mathbf{e}(\\pi_A, vk_\\alpha) \\qquad \\mathbf{e}(\\pi&#x27;_B, P) = \\mathbf{e}(\\pi_B, vk_\\alpha) \\qquad \\mathbf{e}(\\pi&#x27;_C, P) = \\mathbf{e}(\\pi_C, vk_\\alpha)</span></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check same coefficients were used via  <span class="math">\\pi_K</span> :  <span class="math">\\mathbf{e}(\\pi_K, vk_{\\gamma}) = \\mathbf{e}(\\pi_A, vk_{A,\\gamma}&#x27;&#x27;) \\cdot \\mathbf{e}(\\pi_B, vk_{B,\\gamma}&#x27;&#x27;) \\cdot \\mathbf{e}(\\pi_C, vk_{C,\\gamma}&#x27;&#x27;)</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check QAP is satisfied:  <span class="math">\\mathbf{e}(vk_x + \\pi_A, vk_{B,0} + \\pi_B) = \\mathbf{e}(\\pi_H, vk_Z) \\cdot \\mathbf{e}(vk_{C,0} + \\pi_C, P)</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If all checks in 2.&ndash;4. succeeded then return true and otherwise false.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Figure 4: The original QAP-based SNARK [GGPR13] with CRS verification (in bold)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check  <span class="math">P \\neq 0_{\\mathbb{G}}</span> .</li>
    </ol></li>
      <li>2. Check correct choice of  <span class="math">\\tau, \\gamma</span> :  <span class="math">vk_Z \\neq 0_{\\mathbb{G}}</span>  and  <span class="math">vk_{\\gamma} \\neq 0_{\\mathbb{G}}</span> .</li>
      <li>3. Check consistency of  <span class="math">pk_H</span>  and  <span class="math">pk&#x27;_H</span> :  <span class="math">P = pk_{H,0}</span>  and</li>
    </ul>

    <p class="text-gray-300">for
<span class="math">$i = 1, ..., d</span>$
:  <span class="math">\\mathbf{e}(pk_{H,i}, P) = \\mathbf{e}(pk_{H,i-1}, pk_{H,1})</span>
for  <span class="math">i = 0, ..., d</span> :  <span class="math">\\mathbf{e}(pk&#x27;_{H,i}, P) = \\mathbf{e}(pk_{H,i}, vk_{\\alpha})</span></p>

    <p class="text-gray-300">4. Check consistency of vk:</p>

    <p class="text-gray-300"><span class="math">$\\text{for } i = 0, \\dots, n: \\ \\ vk_{A,i} = \\sum_{j=0}^{d-1} a_{i,j} pk_{H,j}</span>$</p>

    <p class="text-gray-300"><span class="math">$vk_{B,0} = \\sum_{j=0}^{d-1} b_{0,j} pk_{H,j} \\qquad vk_{C,0} = \\sum_{j=0}^{d-1} c_{0,j} pk_{H,j} \\qquad vk_Z = \\sum_{j=0}^{d} z_j pk_{H,j}</span>$</p>

    <p class="text-gray-300">5. Check consistency of the remaining pk elements: for i = n + 1, ..., m:</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} pk_{A,i} &amp;= \\sum_{j=0}^{d-1} a_{i,j} pk_{H,j} &amp; \\mathbf{e}(pk&#x27;_{A,i}, P) &amp;= \\mathbf{e}(pk_{A,i}, vk_{\\alpha}) &amp; \\mathbf{e}(pk&#x27;&#x27;_{A,i}, vk_{\\gamma}) &amp;= \\mathbf{e}(pk_{A,i}, vk&#x27;&#x27;_{A,\\gamma}) \\\\ \\text{for } i &amp;= 1, \\dots, m; \\\\ pk_{B,i} &amp;= \\sum_{j=0}^{d-1} b_{i,j} pk_{H,j} &amp; \\mathbf{e}(pk&#x27;_{B,i}, P) &amp;= \\mathbf{e}(pk_{B,i}, vk_{\\alpha}) &amp; \\mathbf{e}(pk&#x27;&#x27;_{B,i}, vk_{\\gamma}) &amp;= \\mathbf{e}(pk_{B,i}, vk&#x27;&#x27;_{B,\\gamma}) \\\\ pk_{C,i} &amp;= \\sum_{j=0}^{d-1} c_{i,j} pk_{H,j} &amp; \\mathbf{e}(pk&#x27;_{C,i}, P) &amp;= \\mathbf{e}(pk_{C,i}, vk_{\\alpha}) &amp; \\mathbf{e}(pk&#x27;&#x27;_{C,i}, vk_{\\gamma}) &amp;= \\mathbf{e}(pk_{C,i}, vk&#x27;&#x27;_{C,\\gamma}) \\end{aligned}</span>$</p>

    <p class="text-gray-300">and moreover:</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{ll} pk_Z = \\sum_{j=0}^d z_i pk_{H,j} &amp; \\mathbf{e}(pk_Z&#x27;,P) = \\mathbf{e}(pk_Z,vk_\\alpha) \\\\ pk_{A,0} = vk_{A,0} &amp; \\mathbf{e}(pk_{A,0}&#x27;,P) = \\mathbf{e}(pk_{A,0},vk_\\alpha) &amp; \\mathbf{e}(pk_{Z,A}&#x27;&#x27;,vk_\\gamma) = \\mathbf{e}(pk_Z,vk_{A,\\gamma}&#x27;&#x27;) \\\\ pk_{B,0} = vk_{B,0} &amp; \\mathbf{e}(pk_{B,0}&#x27;,P) = \\mathbf{e}(pk_{B,0},vk_\\alpha) &amp; \\mathbf{e}(pk_{Z,B}&#x27;&#x27;,vk_\\gamma) = \\mathbf{e}(pk_Z,vk_{B,\\gamma}&#x27;&#x27;) \\\\ pk_{C,0} = vk_{C,0} &amp; \\mathbf{e}(pk_{C,0}&#x27;,P) = \\mathbf{e}(pk_{C,0},vk_\\alpha) &amp; \\mathbf{e}(pk_{Z,C}&#x27;&#x27;,vk_\\gamma) = \\mathbf{e}(pk_Z,vk_{C,\\gamma}&#x27;&#x27;) \\end{array}</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If all checks in 2.&ndash;5. succeeded then return true and otherwise false.</li>
    </ol>

    <p class="text-gray-300">Standard security. Adding CRS verification to Gennaro et al.'s scheme does not alter its security as proved in [GGPR13]. In fact, knowledge soundness is a notion that is independent of the prove algorithm  <span class="math">\\Pi.P</span>  and it follows by inspection that an honestly computed CRS satisfies verification.</p>

    <p class="text-gray-300"><strong>Theorem 4.1</strong> ([GGPR13]) Let Rg be a relation generator that on input  <span class="math">1^{\\lambda}</span>  returns a QAP of degree at most  <span class="math">d(\\lambda)</span>  over a symmetric group Gr. Define a group generator sGen that returns the first output Gr of Rg and let  <span class="math">q := \\max\\{2d-1, d+2\\}</span> . If the q-PDH and the d-PKE assumptions hold for sGen then the scheme in Figure 4 for Rg is knowledge-sound. Moreover, it is statistical zero-knowledge.</p>

    <p class="text-gray-300">CRS verifiability. We show that a CRS that passes verification is constructed as in KEY GENERATION, that is, that exist values  <span class="math">\\tau, \\alpha, \\beta_A, \\beta_B, \\beta_C \\in \\mathbb{F}</span>  such that the conditions in Item 1. of KEY GENERATION are satisfied and vk and pk are as in Items 2. and 3. Let  <span class="math">\\tau, \\alpha, \\xi_A, \\xi_B, \\xi_C, \\gamma \\in \\mathbb{F}</span>  be the discrete logarithms of the elements  <span class="math">pk_{H,1}</span> ,  <span class="math">vk_{\\alpha}</span> ,  <span class="math">vk&#x27;&#x27;_{A,\\gamma}</span> ,  <span class="math">vk&#x27;&#x27;_{B,\\gamma}</span> ,  <span class="math">vk&#x27;&#x27;_{C,\\gamma}</span>  and  <span class="math">vk_{\\gamma}</span> , respectively. By Check 2. in CRS VERIFICATION we have that  <span class="math">\\gamma \\neq 0</span> . Define  <span class="math">\\beta_A := x_A \\gamma^{-1}</span> ,  <span class="math">\\beta_B := x_B \\gamma^{-1}</span> ,  <span class="math">\\beta_C := x_C \\gamma^{-1}</span> .</p>

    <p class="text-gray-300">Check 3. ensures that  <span class="math">pk_H</span>  and  <span class="math">pk_H</span>  are correctly computed w.r.t.  <span class="math">\\tau</span>  and  <span class="math">\\alpha</span>  and Check 4. ensures that  <span class="math">\\{vk_{A,i}\\}_{i=0}^n</span> ,  <span class="math">vk_{B,0}</span>  and  <span class="math">vk_{C,0}</span>  are correctly computed w.r.t.  <span class="math">\\tau</span> .</p>

    <p class="text-gray-300">Check 5. ensures that  <span class="math">\\{pk_{A,i}, pk&#x27;_{A,i}, pk&#x27;&#x27;_{A,i}\\}_{i=n+1}^m</span>  are correctly computed w.r.t.  <span class="math">\\tau</span> ,  <span class="math">\\alpha</span>  and  <span class="math">\\beta_A</span> ; and  <span class="math">\\{pk_{B,i}, pk&#x27;_{B,i}, pk&#x27;&#x27;_{B,i}, pk&#x27;_{C,i}, pk&#x27;_{C,i}, pk&#x27;&#x27;_{C,i}, pk&#x27;&#x27;_{C,i}\\}_{i=1}^m</span>  are correctly computed w.r.t.  <span class="math">\\tau</span> ,  <span class="math">\\alpha</span> ,  <span class="math">\\beta_B</span>  and  <span class="math">\\beta_C</span> . Moreover, it checks that  <span class="math">pk_Z</span> ,  <span class="math">pk&#x27;_Z</span> ,  <span class="math">pk_{A,0}</span> ,  <span class="math">pk&#x27;&#x27;_{A,0}</span> ,  <span class="math">pk&#x27;&#x27;_{Z,A}</span> ,  <span class="math">pk_{B,0}</span> ,  <span class="math">pk&#x27;&#x27;_{B,0}</span> ,  <span class="math">pk&#x27;&#x27;_{Z,B}</span> ,  <span class="math">pk_{C,0}</span> ,  <span class="math">pk&#x27;_{C,0}</span>  and  <span class="math">pk&#x27;&#x27;_{Z,C}</span>  are also of the correct form.</p>

    <p class="text-gray-300"><strong>Trapdoor extraction.</strong> In order to prove subversion zero knowledge, we construct a simulator ( <span class="math">\\Pi</span> .Sim.crs,  <span class="math">\\Pi</span> .Sim.pf) for any CRS subvertor. Let X be a CRS subvertor that returns (vk, pk). Define  <span class="math">\\mathsf{X}&#x27;(1^\\lambda;r)</span>  that runs  <span class="math">(vk,pk) \\leftarrow \\mathsf{X}(1^\\lambda;r)</span> , parses vk and pk as in Figure 4 and returns  <span class="math">(pk_{H,0},pk_{H,1},pk_{H,2})</span> . By SKE (Definition 2.14) there exists a PT algorithm  <span class="math">\\mathsf{E}_{\\mathsf{X}&#x27;}</span>  such that if for some  <span class="math">P \\in \\mathbb{G}</span> ,  <span class="math">\\tau \\in \\mathbb{F}</span> :  <span class="math">pk_{H,0} = P</span> ,  <span class="math">pk_{H,1} = \\tau P</span> ,  <span class="math">pk_{H,2} = \\tau^2 P</span>  then with overwhelming probability  <span class="math">\\mathsf{E}_{\\mathsf{X}&#x27;}</span>  extracts  <span class="math">\\tau</span> . Using  <span class="math">\\mathsf{E}_{\\mathsf{X}&#x27;}</span>  we define the CRS simulator S.crs as follows: On input  <span class="math">1^\\lambda</span>  do the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Sample randomness for X:  <span class="math">r \\leftarrow \\</span> {0, 1}^{\\mathsf{X.rl}(\\lambda)}$ .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Run  <span class="math">(vk, pk) \\leftarrow \\mathsf{X}(1^{\\lambda}; r)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If (R, vk, pk) passes verification then  <span class="math">\\tau \\leftarrow \\</span> \\mathsf{E}_{\\mathsf{X}'}(1^{\\lambda}, r)$ ; else  <span class="math">\\tau \\leftarrow \\bot</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Return  <span class="math">((vk, pk), r, \\tau)</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><strong>Proof simulation.</strong> Given (vk, pk), trapdoor  <span class="math">\\tau</span>  and a statement  <span class="math">x \\in \\mathbb{F}^n</span> , the proof simulator S.pf is defined as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">\\tau = \\bot</span>  then return  <span class="math">\\bot</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Use  <span class="math">\\tau</span>  to compute  <span class="math">Z(\\tau)</span>  (which in a verified CRS is non-zero). Compute the following &quot;simulation keys&quot;:</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$sk_A := Z(\\tau)^{-1} pk_{Z,A}^{&quot;}</span>$
<span class="math">sk_B := Z(\\tau)^{-1} pk_{Z,B}^{&quot;}</span>   <span class="math">sk_C := Z(\\tau)^{-1} pk_{Z,C}^{&quot;}</span></p>

    <p class="text-gray-300">(For a valid CRS, we have  <span class="math">sk_A = \\beta_A P</span>  and  <span class="math">sk_B = \\beta_B P</span>  and  <span class="math">sk_C = \\beta_C P</span> .)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Define  <span class="math">v_x := \\sum_{j=0}^{d-1} a_{0,j} \\tau^j + \\sum_{i=1}^n x_i \\sum_{j=0}^{d-1} a_{i,j} \\tau^j</span> . Set  <span class="math">vk_x := v_x P</span>  and  <span class="math">vk_x&#x27; := v_x vk_\\alpha</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Choose  <span class="math">a,b,c \\leftarrow \\mathbb{F}</span>  and define the proof  <span class="math">\\pi := (\\pi_A, \\pi_A&#x27;, \\pi_B, \\pi_B&#x27;, \\pi_C, \\pi_C&#x27;, \\pi_K, \\pi_H)</span>  as follows:</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\pi_A &amp;:= (a - v_x)P = aP - vk_x &amp; \\pi&#x27;_A &amp;:= (a - v_x)vk_\\alpha \\\\ \\pi_B &amp;:= (b - B_0(\\tau))P = bP - vk_{B,0} &amp; \\pi&#x27;_B &amp;:= (b - B_0(\\tau))vk_\\alpha \\\\ \\pi_C &amp;:= (c - C_0(\\tau))P = cP - vk_{C,0} &amp; \\pi&#x27;_C &amp;:= (c - C_0(\\tau))vk_\\alpha \\\\ \\pi_H &amp;:= Z(\\tau)^{-1}(ab - c)P &amp; \\pi&#x27;_H &amp;:= Z(\\tau)^{-1}(ab - c)vk_\\alpha \\\\ \\pi_K &amp;:= (a - v_x)sk_A + (b - B_0(\\tau))sk_B + (c - C_0(\\tau))sk_C \\end{split}</span>$</p>

    <p class="text-gray-300"><strong>Theorem 4.2</strong> Let Rg be a relation generator that outputs strong QAPs and implicitly defines a symmetric bilinear-group generator sGen. If SKE holds for sGen then the GGPR QAP-based SNARK [GGPR13] with CRS verification given in Figure 4 for Rg satisfies subversion zero knowledge.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Consider  <span class="math">(vk, pk) \\leftarrow \\mathsf{X}(1^\\lambda; r)</span>  and let E denote the event that (R, vk, pk) passes CRS VERIFICATION (in which case  <span class="math">\\mathsf{X}</span>  returns  <span class="math">(P, \\tau P, \\tau^2 P)</span> ) but  <span class="math">\\mathsf{E}_{\\mathsf{X}&#x27;}</span>  fails to extract  <span class="math">\\tau</span> . Since a correct (vk, pk) satisfies  <span class="math">\\mathbf{e}(pk_{H,1}, pk_{H,1}) = \\mathbf{e}(pk_{H,0}, pk_{H,2})</span> , by assumption SKE the probability of E is</p>

    <p class="text-gray-300">negligible. It suffices thus to show that, conditioned on E not happening, the probability that A outputs 1 in game S-ZK when b=0 is the same as when b=1.</p>

    <p class="text-gray-300">If (vk, pk) does not pass verification then  <span class="math">\\tau = \\bot</span>  and both prover and proof simulator return  <span class="math">\\bot</span> .</p>

    <p class="text-gray-300">If (vk, pk) verifies then (because of  <span class="math">\\neg E</span> )  <span class="math">\\mathsf{E}_{\\mathsf{X}&#x27;}</span>  extracts  <span class="math">\\tau</span> . We show that the outputs of the prover and the proof simulator are distributed equivalently. Above we showed that if the CRS verifies then there exist  <span class="math">\\tau, \\alpha, \\beta_A, \\beta_B, \\beta_C, \\gamma \\in \\mathbb{F}</span>  with  <span class="math">Z(\\tau) \\neq 0</span>  and  <span class="math">\\gamma \\neq 0</span>  such that vk and pk are defined as in Items 2. and 3. in KEY GENERATION.</p>

    <p class="text-gray-300">Moreover, in a real proof the elements  <span class="math">\\delta_A Z(\\tau)P</span>  in  <span class="math">\\pi_A</span>  and  <span class="math">\\delta_B Z(\\tau)P</span>  in  <span class="math">\\pi_B</span>  and  <span class="math">\\delta_C Z(\\tau)P</span>  in  <span class="math">\\pi_C</span>  make  <span class="math">\\pi_A</span> ,  <span class="math">\\pi_B</span>  and  <span class="math">\\pi_C</span>  uniformly random. For a fixed vk and  <span class="math">\\pi_A</span> ,  <span class="math">\\pi_B</span>  and  <span class="math">\\pi_C</span> , the equations in 2. of VERIFY uniquely determine  <span class="math">\\pi&#x27;_A</span> ,  <span class="math">\\pi&#x27;_B</span>  and  <span class="math">\\pi&#x27;_C</span> , and the equations in 3. and 4. uniquely determine  <span class="math">\\pi_K</span>  and  <span class="math">\\pi_H</span>  (since  <span class="math">vk_{\\gamma} \\neq 0_{\\mathbb{G}}</span>  and  <span class="math">vk_{Z} \\neq 0_{\\mathbb{G}}</span> ).</p>

    <p class="text-gray-300">In a simulated proof  <span class="math">\\pi_A</span> ,  <span class="math">\\pi_B</span>  and  <span class="math">\\pi_C</span>  are also uniformly random, so it suffices to show that the remaining proof elements satisfy the verification equations:</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} \\mathbf{e}(\\pi&#x27;_{A}, P) &amp;= \\mathbf{e}\\big((a - v_{x})\\alpha P, \\ P\\big) = \\mathbf{e}(\\pi_{A}, vk_{\\alpha}) \\\\ \\mathbf{e}(\\pi&#x27;_{B}, P) &amp;= \\mathbf{e}\\big((b - B_{0}(\\tau))\\alpha P, \\ P\\big) = \\mathbf{e}(\\pi_{B}, vk_{\\alpha}) \\\\ \\mathbf{e}(\\pi&#x27;_{C}, P) &amp;= \\mathbf{e}\\big((c - C_{0}(\\tau))\\alpha P, \\ P\\big) = \\mathbf{e}(\\pi_{C}, vk_{\\alpha}) \\\\ \\mathbf{e}(\\pi_{K}, vk_{\\gamma}) &amp;= \\mathbf{e}\\big((a - v_{x})\\beta_{A}P + (b - B_{0}(\\tau))\\beta_{B}P + (c - C_{0}(\\tau))\\beta_{C}P, \\ \\gamma P\\big) \\\\ &amp;= \\mathbf{e}(\\pi_{A}, vk&#x27;&#x27;_{A,\\gamma}) \\cdot \\mathbf{e}(\\pi_{B}, vk&#x27;&#x27;_{B,\\gamma}) \\cdot \\mathbf{e}(\\pi_{C}, vk&#x27;&#x27;_{C,\\gamma}) \\\\ \\mathbf{e}(\\pi_{H}, vk_{Z}) &amp;= \\mathbf{e}\\big(Z(\\tau)^{-1}(ab - c)P, Z(\\tau)P\\big) = \\mathbf{e}\\big(aP, bP\\big) \\cdot \\mathbf{e}\\big(cP, P\\big)^{-1} \\\\ &amp;= \\mathbf{e}(vk_{x} + \\pi_{A}, vk_{B,0} + \\pi_{B}) \\cdot \\mathbf{e}(vk_{C,0} + \\pi_{C}, P)^{-1} \\end{aligned}</span>$</p>

    <p class="text-gray-300">This concludes the proof.</p>

    <p class="text-gray-300">Corollary 4.3 Let Rg be a relation generator that outputs strong QAPs. The GGPR QAP-based SNARK [GGPR13] with CRS verification (Figure 4) for Rg satisfies perfect subversion witness indistinguishability.</p>

    <p class="text-gray-300"><strong>Proof.</strong> In Theorem 4.2 we showed that proofs under a (possibly maliciously generated but) valid CRS are uniform group elements subject to satisfying the verification equation. Proofs using different witnesses are thus equally distributed.</p>

    <h4 id="sec-misc-2" class="text-lg font-semibold mt-6">GGPR's QSP-Based SNARK</h4>

    <p class="text-gray-300">Gennaro et al. [GGPR13] also introduced (strong) quadratic span programs (QSP) and show how to efficiently convert any boolean circuit into an equivalent strong QSP. Strong QSPs are defined similarly to QAPs (Definition 3.3) except that there are no polynomials  <span class="math">C_i(X)</span>  and the coefficients can be different (like  <span class="math">(r_1, \\ldots, r_m)</span>  and  <span class="math">(s_1, \\ldots, s_m)</span>  in Eq. (7)). Moreover the statement  <span class="math">x \\in \\{0, 1\\}^{n&#x27;}</span>  with n = 2n' is mapped to  <span class="math">\\vec{r}</span>  and  <span class="math">\\vec{s}</span>  as follows: for  <span class="math">i \\in \\{1, \\ldots, n&#x27;\\}</span> :  <span class="math">r_{2i} = s_{2i} := x_i</span>  and  <span class="math">r_{2i-1} = s_{2i-1} := 1 - x_i</span> .</p>

    <p class="text-gray-300">The first SNARK construction in [GGPR13] is based on strong QSPs and is obtained by setting  <span class="math">C_i(X) :\\equiv 0</span>  for all i in the QAP-based one above. It is straightforward to verify that all our results for the QAP-based construction carry over to the QSP-based SNARK.</p>

    </section>

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5 Asymmetric Pinocchio</h2>

    <p class="text-gray-300">Pinocchio [PHGR13] is one of the central SNARK systems. Ben-Sasson, Chiesa, Tromer and Virza [BCTV14] proposed a variant in asymmetric groups for which they also shorten the verification key. Their system is implemented in libsnark [BCG<sup>+</sup>14b] and underlies Zcash.</p>

    <p class="text-gray-300">Campanelli et al. [CGGN17] show that the protocol is not subversion-zero-knowledge and expect major changes to make it secure. In the following we show that by adding merely 4 group elements to the CRS (which we denote by ck for &quot;checking key&quot;), we can enable verification of well-formedness of (vk, pk) by using the pairing available in the bilinear group. We then show that under SKE (Definition 2.15), our modification of the scheme from [BCTV14] achieves subversion zero knowledge. The protocol is given in Figure 5, where we underlined our modifications. Below we define procedure CRS VERIFICATION, which a prover runs on a CRS before first using it.</p>

    <p class="text-gray-300"><strong>Theorem 5.1</strong> ([PHGR13, BCTV14]) Let Rg be a relation generator that on input  <span class="math">1^{\\lambda}</span>  returns a QAP of degree at most  <span class="math">d(\\lambda)</span>  over an asymmetric group Gr such that  <span class="math">A_0, \\ldots, A_n</span>  are linearly independent and  <span class="math">\\operatorname{span}(A_0, \\ldots, A_n) \\cap \\operatorname{span}(A_{n+1}, \\ldots, A_m) = \\{0\\}</span> . Define a group generator aGen that returns the first output Gr of Rg and let q := 4d + 4. If the q-PDH, the q-PKE and the 2q-SDH assumptions hold for aGen then the scheme in Figure 5 without including ck in the CRS is knowledge-sound. Moreover, it is statistical zero-knowledge.</p>

    <p class="text-gray-300"><strong>Standard security.</strong> Inspecting the proof of the theorem in [PHGR13], it is easily seen that the additional elements contained in ck can be produced by the reduction. Moreover, knowledge soundness is independent of the prove algorithm  <span class="math">\\Pi.P</span> , and a correctly generated CRS passes CRS verification. This yields the following.</p>

    <p class="text-gray-300">Corollary 5.2 (to Theorem 5.1) Let Rg and aGen be as in Theorem 5.1. If the q-PDH, the q-PKE and the 2q-SDH assumptions hold for aGen for q := 4d + 4 then the scheme in Figure 5 is knowledge-sound. Moreover, it is statistical zero-knowledge.</p>

    <p class="text-gray-300">CRS VERIFICATION. On input (R, vk, pk, ck), let  <span class="math">\\{a_{i,j}\\}</span> ,  <span class="math">\\{b_{i,j}\\}</span> ,  <span class="math">\\{c_{i,j}\\}</span> ,  <span class="math">\\{z_k\\}</span>  denote the coefficients of  <span class="math">A_i(X)</span> ,  <span class="math">B_i(X)</span> ,  <span class="math">C_i(X)</span>  and Z(X), respectively, for  <span class="math">0 \\le i \\le m</span>  and  <span class="math">0 \\le j \\le d-1</span>  and  <span class="math">0 \\le k \\le d</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>1. Check  <span class="math">P_1 \\neq 0_{\\mathbb{G}_1}</span>  and  <span class="math">P_2 \\neq 0_{\\mathbb{G}_2}</span> .</li>
      <li>2. Check choice of secret values:  <span class="math">ck_A \\neq 0_{\\mathbb{G}_2}</span> ,  <span class="math">ck_B \\neq 0_{\\mathbb{G}_2}</span> ,  <span class="math">vk_{\\gamma} \\neq 0_{\\mathbb{G}_2}</span> ,  <span class="math">vk_{\\beta\\gamma} \\neq 0_{\\mathbb{G}_1}</span>  and  <span class="math">vk_Z \\neq 0_{\\mathbb{G}_2}</span> .</li>
      <li>3. Check consistency of  <span class="math">pk_H</span> : Check  <span class="math">pk_{H,0} = P_1</span> ; and for  <span class="math">i = 1, \\ldots, d</span> :</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\mathbf{e}(pk_{H,i}, P_2) = \\mathbf{e}(pk_{H,i-1}, ck_H)</span>$</p>

    <p class="text-gray-300">4. Check consistency of  <span class="math">pk_A</span> ,  <span class="math">pk&#x27;_A</span> ,  <span class="math">pk_B</span> ,  <span class="math">pk&#x27;_B</span> : for  <span class="math">i=n+1,\\ldots,m+3</span> :</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{e}(pk_{A,i}, P_2) = \\mathbf{e}(\\sum_{j=0}^{d-1} a_{i,j} pk_{H,j}, ck_A)</span>$
<span class="math">\\mathbf{e}(pk&#x27;_{A,i}, P_2) = \\mathbf{e}(pk_{A,i}, vk_A)</span></p>

    <p class="text-gray-300">and for i = 0, ..., m + 3:</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{e}(P_1, pk_{B,i}) = \\mathbf{e}(\\sum_{j=0}^{d-1} b_{i,j} pk_{H,j}, ck_B) \\qquad \\quad \\mathbf{e}(pk&#x27;_{B,i}, P_2) = \\mathbf{e}(vk_B, pk_{B,i})</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>5. Check consistency of  <span class="math">ck_C</span> :  <span class="math">\\mathbf{e}(pk_{A,m+1},ck_B) = \\mathbf{e}(\\sum_{j=0}^d z_j pk_{H,j},ck_C)</span>  (Note that for an honest CRS we have  <span class="math">pk_{A,m+1} = Z(\\tau)\\rho_A P_1 \\neq 0</span> .)</li>
      <li>6. Check consistency of vk: for  <span class="math">i=0,\\ldots,n</span> :  <span class="math">\\mathbf{e}(vk_{IC,i},P_2)=\\mathbf{e}(\\sum_{j=0}^{d-1}a_{i,j}pk_{H,j},ck_A)</span>  and</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\mathbf{e}(\\mathbf{v}k_{\\beta\\gamma},P_2) = \\mathbf{e}(P_1,\\widehat{\\mathbf{v}k}_{\\beta\\gamma}) \\qquad \\qquad \\mathbf{e}(P_1,\\mathbf{v}k_Z) = \\mathbf{e}\\left(\\sum_{j=0}^d z_j p k_{H,j}, c k_C\\right)</span>$</p>

    <p class="text-gray-300">KEY GENERATION. On input R as in Eq. (8) representing a QAP for an asymmetric group Gr do the following:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Sample  <span class="math">P_1 \\leftarrow \\mathbb{G}_1^*</span>  and  <span class="math">P_2 \\leftarrow \\mathbb{G}_2^*</span></li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set  <span class="math">\\begin{bmatrix} A_{m+1} &amp; B_{m+1} &amp; C_{m+1} \\\\ A_{m+2} &amp; B_{m+2} &amp; C_{m+2} \\\\ A_{m+3} &amp; B_{m+3} &amp; C_{m+3} \\end{bmatrix} := \\begin{bmatrix} Z &amp; 0 &amp; 0 \\\\ 0 &amp; Z &amp; 0 \\\\ 0 &amp; 0 &amp; Z \\end{bmatrix}</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Sample random  <span class="math">\\rho_A, \\rho_B, \\beta, \\gamma \\leftarrow \\mathbb{F}^*</span>  and  <span class="math">\\tau, \\alpha_A, \\alpha_B, \\alpha_C, \\leftarrow \\mathbb{F}</span> , conditioned on  <span class="math">Z(\\tau) \\neq 0</span> .</li>
    </ol></li>
      <li>4. Set  <span class="math">vk = (P_1, P_2, vk_A, vk_B, vk_C, vk_{\\gamma}, vk_{\\beta\\gamma}, \\widehat{vk}_{\\beta\\gamma}, vk_Z, vk_{IC})</span> , where  <span class="math">vk_A := \\alpha_A P_2</span>   <span class="math">vk_B := \\alpha_B P_1</span></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} \\mathbf{v}k_A &amp;:= \\alpha_A P_2 &amp; \\mathbf{v}k_B &amp;:= \\alpha_B P_1 &amp; \\mathbf{v}k_C &amp;:= \\alpha_C P_2 \\\\ \\mathbf{v}k_\\gamma &amp;:= \\gamma P_2 &amp; \\mathbf{v}k_{\\beta\\gamma} &amp;:= \\gamma \\beta P_1 &amp; \\widehat{\\mathbf{v}k}_{\\beta\\gamma} &amp;:= \\gamma \\beta P_2 \\\\ \\mathbf{v}k_Z &amp;:= Z(\\tau)\\rho_A \\rho_B P_2 &amp; \\left\\{ \\mathbf{v}k_{IC,i} \\right\\}_{i=0}^n &amp;:= \\left\\{ A_i(\\tau)\\rho_A P_1 \\right\\}_{i=0}^n \\end{aligned}</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set  <span class="math">pk = (pk_A, pk&#x27;_A, pk_B, pk&#x27;_B, pk_C, pk&#x27;_C, pk_K, pk_H)</span>  where</li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\begin{array}{ll} \\text{for } i = n+1, \\ldots, m+3: &amp; pk_{A,i} := A_i(\\tau)\\rho_A P_1 &amp; pk_{A,i}&#x27; := A_i(\\tau)\\alpha_A \\rho_A P_1 \\\\ \\text{for } i = 0, \\ldots, m+3: &amp; pk_{B,i} := B_i(\\tau)\\rho_B P_2 &amp; pk_{B,i}&#x27; := B_i(\\tau)\\alpha_B \\rho_B P_1 \\\\ &amp; pk_{C,i} := C_i(\\tau)\\rho_A \\rho_B P_1 &amp; pk_{C,i}&#x27; := C_i(\\tau)\\alpha_C \\rho_A \\rho_B P_1 \\\\ &amp; pk_{K,i} := \\beta(A_i(\\tau)\\rho_A + B_i(\\tau)\\rho_B + C_i(\\tau)\\rho_A \\rho_B) P_1 \\\\ \\text{for } i = 0, \\ldots, d: &amp; pk_{H,i} := \\tau^i P_1 \\end{array}</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set  <span class="math">ck := (ck_A, ck_B, ck_C, ck_H)</span>  where  <span class="math">ck_A := \\rho_A P_2</span> ,  <span class="math">ck_B := \\rho_B P_2</span> ,  <span class="math">ck_C := \\rho_A \\rho_B P_2</span> ,  <span class="math">ck_H := \\tau P_2</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Return crs := (vk, pk, ck).</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">PROVE. On input R, (vk, pk, ck) and  <span class="math">\\vec{s} \\in \\mathbb{F}^m</span>  s.t. Eq. (6) is satisfied for some  <span class="math">H&#x27;(X) \\in \\mathbb{F}[X]</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If (R, vk, pk, ck) does not pass CRS VERIFICATION then return  <span class="math">\\perp</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Sample  <span class="math">\\delta_A, \\delta_B, \\delta_C \\leftarrow \\mathbb{F}</span>  and define  <span class="math">A(X) := A_0(X) + \\sum_{i=1}^m s_i A_i(X) + \\delta_A Z(X)</span>  <span class="math">B(X) := B_0(X) + \\sum_{i=1}^m s_i B_i(X) + \\delta_B Z(X)</span>   <span class="math">C(X) := C_0(X) + \\sum_{i=1}^m s_i C_i(X) + \\delta_C Z(X)</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute H(X) such that A(X)B(X)-C(X)=H(X)Z(X); let  <span class="math">(h_0,\\ldots,h_d)\\in\\mathbb{F}^{d+1}</span>  be its coefficients.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For  <span class="math">i=0,\\ldots,n</span>  let  <span class="math">pk_{A,i}:=0</span>  and  <span class="math">pk&#x27;_{A,i}:=0</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let  <span class="math">\\vec{c} := 1 \\parallel \\vec{s} \\parallel \\delta_A \\parallel \\delta_B \\parallel \\delta_C \\in \\mathbb{F}^{m+4}</span>  and compute  <span class="math">(&quot;\\langle \\cdot, \\cdot \\rangle&quot;)</span>  denotes the scalar product)</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\pi_A &amp;:= \\left&lt; \\vec{c}, pk_A \\right&gt; &amp; \\pi_A&#x27; := \\left&lt; \\vec{c}, pk_A&#x27; \\right&gt; &amp; \\pi_B := \\left&lt; \\vec{c}, pk_B \\right&gt; &amp; \\pi_B&#x27; := \\left&lt; \\vec{c}, pk_B&#x27; \\right&gt; \\\\ \\pi_C &amp;:= \\left&lt; \\vec{c}, pk_C \\right&gt; &amp; \\pi_C&#x27; := \\left&lt; \\vec{c}, pk_C&#x27; \\right&gt; &amp; \\pi_K := \\left&lt; \\vec{c}, pk_K \\right&gt; &amp; \\pi_H := \\left&lt; \\vec{h}, pk_H \\right&gt; \\end{split}</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Return  <span class="math">\\pi := (\\pi_A, \\pi&#x27;_A, \\pi_B, \\pi&#x27;_B, \\pi_C, \\pi&#x27;_C, \\pi_K, \\pi_H)</span> .</li>
    </ol>

    <p class="text-gray-300">VERIFY. On input R, vk,  <span class="math">\\vec{x} \\in \\mathbb{F}^n</span>  and proof  <span class="math">\\pi \\in \\mathbb{G}_1^7 \\times \\mathbb{G}_2</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">vk_x := vk_{IC,0} + \\sum_{i=1}^n x_i vk_{IC,i}</span> .</li>
    </ol></li>
      <li>2. Check validity of  <span class="math">\\pi_A&#x27;,\\,\\pi_B&#x27;,\\,\\text{and}\\ \\pi_C&#x27;\\colon</span></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\mathbf{e}(\\pi_A&#x27;, P_2) = \\mathbf{e}(\\pi_A, vk_A) \\qquad \\qquad \\mathbf{e}(\\pi_B&#x27;, P_2) = \\mathbf{e}(vk_B, \\pi_B) \\qquad \\qquad \\mathbf{e}(\\pi_C&#x27;, P_2) = \\mathbf{e}(\\pi_C, vk_C)</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>3. Check same coefficients were used via  <span class="math">\\pi_K</span> :  <span class="math">\\mathbf{e}(\\pi_K, vk_\\gamma) = \\mathbf{e}(vk_x + \\pi_A + \\pi_C, \\widehat{vk}_{\\beta\\gamma}) \\cdot \\mathbf{e}(vk_{\\beta\\gamma}, \\pi_B)</span></li>
      <li>4. Check QAP is satisfied via  <span class="math">\\pi_H</span> :  <span class="math">\\mathbf{e}(\\mathbf{v}k_x + \\pi_A, \\pi_B) = \\mathbf{e}(\\pi_H, \\mathbf{v}k_Z) \\cdot \\mathbf{e}(\\pi_C, P_2)</span></li>
      <li>5. If all checks in 2.-4. succeeded then return true and otherwise false.</li>
    </ul>

    <p class="text-gray-300">Figure 5: S-ZK Asymmetric Pinocchio, adapted from [BCTV14]; the changes from the original scheme, shown not to be sound [Gab19], are highlighted.</p>

    <p class="text-gray-300">7. Check consistency of  <span class="math">pk_C</span> ,  <span class="math">pk_C&#x27;</span> ,  <span class="math">pk_K</span> : for i = 0, ..., m + 3:</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{e}(pk_{C,i}, P_2) = \\mathbf{e}(\\sum_{j=0}^{d-1} c_{i,j} pk_{H,j}, ck_C) \\qquad \\mathbf{e}(pk_{C,i}&#x27;, P_2) = \\mathbf{e}(pk_{C,i}, vk_C)</span>$
for  <span class="math">i = 0, \\dots, n</span> :
<span class="math">$\\mathbf{e}(pk_{K,i}, vk_\\gamma) = \\mathbf{e}(vk_{IC,i} + pk_{C,i}, \\widehat{vk}_{\\beta\\gamma}) \\cdot \\mathbf{e}(vk_{\\beta\\gamma}, pk_{B,i})</span>$
for  <span class="math">i = n+1, \\dots, m+3</span> :
<span class="math">$\\mathbf{e}(pk_{K,i}, vk_\\gamma) = \\mathbf{e}(pk_{A,i} + pk_{C,i}, \\widehat{vk}_{\\beta\\gamma}) \\cdot \\mathbf{e}(vk_{\\beta\\gamma}, pk_{B,i})</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If all checks in 1.&ndash;7. succeeded then return true and otherwise false.</li>
    </ol>

    <p class="text-gray-300"><strong>Remark 5.3</strong> The condition that in KEY GENERATION  <span class="math">\\rho_A, \\rho_B, \\beta, \\gamma</span>  and  <span class="math">Z(\\tau)</span>  must be non-zero is not made explicit in [BCTV14]. However if  <span class="math">\\gamma = 0</span>  then any  <span class="math">\\pi_K</span>  satisfies the verification equation in 3; and if  <span class="math">\\beta = 0</span>  and  <span class="math">\\gamma \\neq 0</span>  then no  <span class="math">\\pi_K</span>  satisfies it. If  <span class="math">Z(\\tau) = 0</span>  or  <span class="math">\\rho_A = 0</span>  or  <span class="math">\\rho_B = 0</span>  then  <span class="math">vk_Z = 0_{\\mathbb{G}_2}</span>  and setting  <span class="math">\\pi_B</span>  and  <span class="math">\\pi_C</span>  to zero always satisfies the equation in 4 in verification.</p>

    <p class="text-gray-300"><strong>CRS</strong> verifiability. We show that a CRS (vk, pk, ck) that passes verification is constructed as in Key generation; in particular, there exist  <span class="math">\\tau, \\alpha_A, \\alpha_B, \\alpha_C \\in \\mathbb{F}</span>  and  <span class="math">\\rho_A, \\rho_B, \\beta, \\gamma, \\in \\mathbb{F}^*</span>  such that (vk, pk, ck) is computed as in Key generation. Let  <span class="math">\\tau, \\alpha_A, \\alpha_B, \\alpha_C, \\rho_A, \\rho_B, \\gamma, \\xi \\in \\mathbb{F}</span>  be the values defined by the logarithms of the elements  <span class="math">ck_H</span> ,  <span class="math">vk_A</span> ,  <span class="math">vk_B</span> ,  <span class="math">vk_C</span> ,  <span class="math">ck_A</span> ,  <span class="math">ck_B</span> ,  <span class="math">vk_\\gamma</span>  and  <span class="math">vk_{\\beta\\gamma}</span> , respectively. Check 2. ensures that  <span class="math">\\rho_A, \\rho_B, \\gamma, \\xi</span>  and  <span class="math">Z(\\tau)</span>  are all non-zero. Set  <span class="math">\\beta := \\xi \\gamma^{-1} \\neq 0</span> .</p>

    <p class="text-gray-300">Check 3. ensures that  <span class="math">pk_H</span>  is correctly computed w.r.t.  <span class="math">\\tau</span> . Check 4. ensures that  <span class="math">pk_A</span> ,  <span class="math">pk&#x27;_A</span> ,  <span class="math">pk_B</span>  and  <span class="math">pk&#x27;_B</span>  are correctly computed w.r.t.  <span class="math">\\tau</span> ,  <span class="math">\\rho_A</span> ,  <span class="math">\\rho_B</span> ,  <span class="math">\\alpha_A</span>  and  <span class="math">\\alpha_B</span> . Check 5. ensures that  <span class="math">ck_C</span>  is correctly computed: since by 4.,  <span class="math">pk_{A,m+1} = Z(\\tau)\\rho_A P_1</span>  and  <span class="math">Z(\\tau) \\neq 0</span> , we have  <span class="math">ck_C = \\rho_A \\rho_B P_2</span> . Check 6. ensures that  <span class="math">vk_{IC}</span> ,  <span class="math">vk_{\\beta\\gamma}</span>  and  <span class="math">vk_Z</span>  are correct and Check 7. does the same for  <span class="math">pk_C</span> ,  <span class="math">pk&#x27;_C</span>  and  <span class="math">pk_K</span> . This shows that with respect to  <span class="math">ck_H</span> ,  <span class="math">vk_A</span> ,  <span class="math">vk_B</span> ,  <span class="math">vk_C</span> ,  <span class="math">ck_A</span> ,  <span class="math">ck_B</span> ,  <span class="math">vk_\\gamma</span>  and  <span class="math">vk_{\\beta\\gamma}</span>  (which implicitly define the randomness used in a CRS), all remaining elements  <span class="math">pk_A</span> ,  <span class="math">pk&#x27;_A</span> ,  <span class="math">pk_B</span> ,  <span class="math">pk&#x27;_B</span> ,  <span class="math">pk_C</span> ,  <span class="math">pk&#x27;_C</span> ,  <span class="math">pk_K</span> ,  <span class="math">pk_H</span> , as well as  <span class="math">vk_{\\beta\\gamma}</span> ,  <span class="math">vk_Z</span> ,  <span class="math">vk_{IC}</span>  and  <span class="math">vk_C</span>  are defined as prescribed by KEY GENERATION.</p>

    <p class="text-gray-300"><strong>Trapdoor extraction.</strong> This is done exactly as for the scheme in Section 4. Let X be a CRS subvertor that outputs (vk, pk, ck). Define  <span class="math">\\mathsf{X}&#x27;(1^\\lambda; r)</span>  that runs  <span class="math">(vk, pk, ck) \\leftarrow \\mathsf{X}(1^\\lambda; r)</span> , parses the output as above and returns  <span class="math">(pk_{H,0}, pk_{H,1}, pk_{H,2}, P_2, ck_H)</span> . By SKE for aGen (Definition 2.15) there exists a PT algorithm  <span class="math">\\mathsf{E}_{\\mathsf{X}&#x27;}</span>  such that if for some  <span class="math">\\tau \\in \\mathbb{F}</span> :  <span class="math">pk_{H,1} = \\tau \\, pk_{H,0}</span> ,  <span class="math">pk_{H,2} = \\tau^2 pk_{H,0}</span>  and  <span class="math">ck_H = \\tau P_2</span>  then with overwhelming probability  <span class="math">\\mathsf{E}_{\\mathsf{X}&#x27;}</span>  extracts  <span class="math">\\tau</span> . Using  <span class="math">\\mathsf{E}_{\\mathsf{X}&#x27;}</span>  we define the CRS simulator S.crs which computes (crs, r, td) as follows: On input  <span class="math">1^\\lambda</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Sample randomness for X:  <span class="math">r \\leftarrow \\</span> {0, 1}^{\\mathsf{X.rl}(\\lambda)}$ .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Run  <span class="math">(vk, pk, ck) \\leftarrow \\mathsf{X}(1^{\\lambda}; r)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If (R, vk, pk, ck) passes CRS verification then  <span class="math">\\tau \\leftarrow \\</span> \\mathsf{E}_{\\mathsf{X}'}(1^{\\lambda}, r)$ ; else  <span class="math">\\tau \\leftarrow \\bot</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Return  <span class="math">((vk, pk, ck), r, \\tau)</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><strong>Proof simulation.</strong> Given (vk, pk, ck), trapdoor  <span class="math">\\tau</span>  and a statement  <span class="math">x \\in \\mathbb{F}^n</span> , the proof simulator S.pf is defined as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">\\tau = \\bot</span>  then return  <span class="math">\\bot</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Use  <span class="math">\\tau</span>  to compute  <span class="math">Z(\\tau)</span>  (which in a verified CRS is non-zero). Compute the following &quot;simulation keys&quot;:</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$sk_{A} := Z(\\tau)^{-1}pk_{A,m+1} = \\rho_{A}P_{1} \\qquad sk&#x27;_{A} := Z(\\tau)^{-1}pk&#x27;_{A,m+1} = \\alpha_{A}\\rho_{A}P_{1}</span>$</p>

    <p class="text-gray-300"><span class="math">$sk_{B} := Z(\\tau)^{-1}pk_{B,m+2} = \\rho_{B}P_{2} \\qquad sk&#x27;_{B} := Z(\\tau)^{-1}pk&#x27;_{B,m+2} = \\alpha_{B}\\rho_{B}P_{1}</span>$</p>

    <p class="text-gray-300"><span class="math">$sk_{C} := Z(\\tau)^{-1}pk_{C,m+3} = \\rho_{A}\\rho_{B}P_{1} \\qquad sk&#x27;_{C} := Z(\\tau)^{-1}pk&#x27;_{C,m+3} = \\alpha_{C}\\rho_{A}\\rho_{B}P_{1}</span>$</p>

    <p class="text-gray-300"><span class="math">$sk&#x27;&#x27;_{A} = Z(\\tau)^{-1}pk_{K,m+1} = \\beta\\rho_{A}P_{1}</span>$</p>

    <p class="text-gray-300"><span class="math">$sk&#x27;&#x27;_{B} = Z(\\tau)^{-1}pk_{K,m+2} = \\beta\\rho_{B}P_{1} \\qquad sk&#x27;&#x27;_{C} = Z(\\tau)^{-1}pk_{K,m+3} = \\beta\\rho_{A}\\rho_{B}P_{1}</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">vk_x := vk_{IC,0} + \\sum_{i=1}^n x_i \\, vk_{IC,i} = (A_0(\\tau) + \\sum_{i=1}^n x_i \\, A_i(\\tau)) \\, sk_A</span>  and  <span class="math">vk_x&#x27; := (A_0(\\tau) + \\sum_{i=1}^n x_i \\, A_i(\\tau)) \\, sk_A&#x27;</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Choose  <span class="math">a, b, c \\leftarrow \\mathbb{F}</span>  and define the proof  <span class="math">\\pi := (\\pi_A, \\pi&#x27;_A, \\pi_B, \\pi&#x27;_B, \\pi_C, \\pi&#x27;_C, \\pi_K, \\pi_H)</span>  with:  <span class="math">\\pi_A := a \\operatorname{sk}_A - \\operatorname{vk}_x = a \\rho_A P_1 - \\operatorname{vk}_x \\qquad \\pi&#x27;_A := a \\operatorname{sk}&#x27;_A - \\operatorname{vk}&#x27;_x = a \\alpha_A \\rho_A P_1 - \\alpha_A \\operatorname{vk}_x</span>   <span class="math">\\pi_B := b \\operatorname{sk}_B = b \\rho_B P_2 \\qquad \\pi&#x27;_B := b \\operatorname{sk}&#x27;_B = b \\alpha_B \\rho_B P_1</span>   <span class="math">\\pi_C := c \\operatorname{sk}_C = c \\rho_A \\rho_B P_1 \\qquad \\pi&#x27;_C := c \\operatorname{sk}&#x27;_C = c \\alpha_C \\rho_A \\rho_B P_1</span>   <span class="math">\\pi_K := a \\operatorname{sk}&#x27;&#x27;_A + b \\operatorname{sk}&#x27;&#x27;_B + c \\operatorname{sk}&#x27;&#x27;_C \\qquad \\pi_H := Z(\\tau)^{-1} (ab - c) P_1</span></li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><strong>Theorem 5.4</strong> Let Rg be a QAP generator defining a bilinear-group generator aGen for which SKE holds. Then the scheme in Figure 5 for Rg satisfies subversion zero knowledge.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Consider  <span class="math">(vk, pk, ck) \\leftarrow \\mathsf{X}(1^\\lambda; r)</span>  and let E denote the event that (R, vk, pk, ck) passes CRS VERIFICATION but  <span class="math">\\mathsf{E}_{\\mathsf{X}&#x27;}</span>  fails to extract  <span class="math">\\tau</span> . From Check 3 in CRS VERIFICATION, we have  <span class="math">\\mathbf{e}(pk_{H,1}, P_2) = \\mathbf{e}(pk_{H,0}, ck_H)</span>  and  <span class="math">\\mathbf{e}(pk_{H,2}, P_2) = \\mathbf{e}(pk_{H,1}, ck_H)</span> ; thus  <span class="math">(pk_{H,0}, pk_{H,1}, pk_{H,2}, P_2, ck_H)</span>  is a valid SKE tuple. By the SKE assumption the probability of E is thus negligible. It now suffices to show that, conditioned on E not happening, the probability that A outputs 1 in game S-ZK when b=0 is the same as when b=1.</p>

    <p class="text-gray-300">If (vk, pk, ck) fails CRS VERIFICATION then  <span class="math">\\tau = \\bot</span>  and both prover and proof simulator return  <span class="math">\\bot</span> . If (vk, pk, ck) verifies then (because of  <span class="math">\\neg E</span> )  <span class="math">\\mathsf{E}_{\\mathsf{X}&#x27;}</span>  extracts  <span class="math">\\tau</span> .</p>

    <p class="text-gray-300">We show that the outputs of the prover and the proof simulator are distributed equivalently. Above we showed that for a valid CRS there exist  <span class="math">\\tau, \\rho_A, \\rho_B, \\beta, \\gamma, \\alpha_A, \\alpha_B, \\alpha_C \\in \\mathbb{F}</span>  with  <span class="math">\\rho_A \\neq 0</span> ,  <span class="math">\\rho_B \\neq 0</span> ,  <span class="math">\\beta \\neq 0</span> ,  <span class="math">\\gamma \\neq 0</span>  and  <span class="math">Z(\\tau) \\neq 0</span>  such that vk and pk are defined as in Items 4. and 5. in Key GENERATION.</p>

    <p class="text-gray-300">Because of this,  <span class="math">\\delta_A Z(\\tau) \\rho_A P_1</span> , the (m+2)-th summand in  <span class="math">\\pi_A</span>  is uniformly random. And so are the (m+3)-th summand  <span class="math">\\delta_B Z(\\tau) \\rho_B P_1</span>  of  <span class="math">\\pi_B</span>  and the (m+4)-th summand  <span class="math">\\delta_C Z(\\tau) \\rho_A \\rho_B P_1</span>  in  <span class="math">\\pi_C</span> . But this means that  <span class="math">\\pi_A</span> ,  <span class="math">\\pi_B</span>  and  <span class="math">\\pi_C</span>  are uniformly random group elements. For fixed vk,  <span class="math">\\pi_A</span> ,  <span class="math">\\pi_B</span>  and  <span class="math">\\pi_C</span>  the equations in 2. of VERIFY uniquely determine  <span class="math">\\pi&#x27;_A</span> ,  <span class="math">\\pi&#x27;_B</span>  and  <span class="math">\\pi&#x27;_C</span> , while the equations in 3. and 4. uniquely determine  <span class="math">\\pi_K</span>  and  <span class="math">\\pi_H</span>  (since  <span class="math">vk_\\gamma \\neq 0_{\\mathbb{G}_2}</span>  and  <span class="math">vk_Z \\neq 0_{\\mathbb{G}_2}</span> ).</p>

    <p class="text-gray-300">Since for a valid CRS the values  <span class="math">\\rho_A</span>  and  <span class="math">\\rho_B</span>  are non-zero, the simulated proof elements  <span class="math">\\pi_A</span> ,  <span class="math">\\pi_B</span>  and  <span class="math">\\pi_C</span>  are also uniformly random. Thus, it suffices to show that the remaining proof elements satisfy the verification equations:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathbf{e}(\\pi_A&#x27;,P_2) &amp;= \\mathbf{e}\\big(a\\,\\alpha_A\\rho_AP_1 - \\alpha_Avk_x,P_2\\big) = \\mathbf{e}(\\pi_A,vk_A) \\\\ \\mathbf{e}\\big(\\pi_B&#x27;,P_2\\big) &amp;= \\mathbf{e}\\big(b\\,\\alpha_B\\rho_BP_1,P_2\\big) = \\mathbf{e}(vk_B,\\pi_B) \\\\ \\mathbf{e}\\big(\\pi_C&#x27;,P_2\\big) &amp;= \\mathbf{e}\\big(c\\,\\alpha_C\\rho_A\\rho_BP_1,P_2\\big) = \\mathbf{e}(\\pi_C,vk_C) \\\\ \\mathbf{e}(\\pi_K,vk_\\gamma) &amp;= \\mathbf{e}\\big(\\beta(a\\rho_AP_1+b\\rho_BP_1+c\\,\\rho_A\\rho_BP_1),\\gamma P_2\\big) = \\mathbf{e}(vk_x+\\pi_A+\\pi_C,\\widehat{vk}_{\\beta\\gamma}) \\cdot \\mathbf{e}(vk_{\\beta\\gamma},\\pi_B) \\\\ \\mathbf{e}(\\pi_H,vk_Z) &amp;= \\mathbf{e}\\big(Z(\\tau)^{-1}(ab-c)P_1,Z(\\tau)\\rho_A\\rho_BP_2\\big) = \\\\ &amp;= \\mathbf{e}\\big(a\\rho_AP_1,b\\rho_BP_2\\big) \\cdot \\mathbf{e}\\big(c\\rho_A\\rho_BP_1,P_2\\big)^{-1} = \\mathbf{e}(vk_x+\\pi_A,\\pi_B) \\cdot \\mathbf{e}(\\pi_C,P_2)^{-1} \\end{split}</span>$</p>

    <p class="text-gray-300">This concludes the proof.</p>

    <p class="text-gray-300"><strong>Corollary 5.5</strong> The scheme in Figure 5 for a QAP generator Rg satisfies perfect subversion witness indistinguishability.</p>

    <p class="text-gray-300"><strong>Proof.</strong> The corollary follows analogously to Corollary 4.3.</p>

    <h4 id="sec-misc-3" class="text-lg font-semibold mt-6">DFGK's SSP-Based SNARK</h4>

    <p class="text-gray-300">Danezis, Fournet, Groth and Kohlweiss [DFGK14] define square span programs, which are described by only one set  <span class="math">\\{A_i(X)\\}_i</span>  of polynomials (cf. Definition 3.3). They show how to convert any boolean circuit into an SSP. They construct a zk-SNARK for SSPs with proofs only consisting of 4 elements of an asymmetric bilinear group. Analogously to the SNARK from [BCTV14], their scheme is shown to satisfy subversion zero knowledge by observing that (1) the structure of a CRS can be verified via the bilinear map; (2) the trapdoor  <span class="math">\\tau</span>  (which is s in their notation) can be extracted analogously to the SNARK analyzed above; and (3) proofs can be simulated using s by simply following the simulation procedure described in [DFGK14]. (When s is known, the element  <span class="math">G^{\\beta}</span>  (in their multiplicative notation) can be obtained from the CRS element  <span class="math">G^{\\beta t(s)}</span>  since  <span class="math">t(s) \\neq 0</span> .)</p>

    </section>

    <section id="sec-6" class="mb-10">
      <h2 class="text-2xl font-bold">6 Groth's Near-Optimal SNARK</h2>

    <p class="text-gray-300">Groth [Gro16] proposed the most efficient zk-SNARK system to date. He drastically reduced the proof size for QAP-based SNARKs to 3 group elements and verification to one equation using 3 pairings. He achieves this by proving soundness directly in the generic-group model. His system is given in Figure 6, to which we added a procedure CRS VERIFICATION defined below.</p>

    <p class="text-gray-300"><strong>Theorem 6.1</strong> ([Gro16]) The scheme in Figure 6 is knowledge-sound against adversaries that only use a polynomial number of generic bilinear group operations. It also has perfect zero knowledge.</p>

    <p class="text-gray-300">CRS VERIFICATION. On input (R, vk, pk), let  <span class="math">\\{a_{i,j}\\}</span> ,  <span class="math">\\{b_{i,j}\\}</span> ,  <span class="math">\\{c_{i,j}\\}</span> ,  <span class="math">\\{z_k\\}</span>  denote the coefficients of  <span class="math">A_i(X)</span> ,  <span class="math">B_i(X)</span> ,  <span class="math">C_i(X)</span>  and Z(X), respectively, for  <span class="math">0 \\le i \\le m</span>  and  <span class="math">0 \\le j \\le d-1</span>  and  <span class="math">0 \\le k \\le d</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>1. Check  <span class="math">P_1 \\neq 0_{\\mathbb{G}_1}</span>  and  <span class="math">P_2 \\neq 0_{\\mathbb{G}_2}</span> .</li>
      <li>2. Check that  <span class="math">\\alpha, \\beta, \\gamma, \\delta</span>  and  <span class="math">Z(\\tau)</span>  are non-zero:  <span class="math">pk_{\\alpha} \\neq 0_{\\mathbb{G}_1}, \\ pk_{\\beta} \\neq 0_{\\mathbb{G}_1}, \\ vk&#x27;_{\\gamma} \\neq 0_{\\mathbb{G}_2}, \\ pk_{\\delta} \\neq 0_{\\mathbb{G}_1}, \\ pk_{Z,0} \\neq 0_{\\mathbb{G}_1}</span></li>
      <li>3. Check consistency of  <span class="math">pk_H</span>  and  <span class="math">pk&#x27;_H</span> : check  <span class="math">pk_{H,0} = P_1</span>  and  <span class="math">pk&#x27;_{H,0} = P_2</span> . For  <span class="math">i = 1, \\ldots, d-1</span> :</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\mathbf{e}(pk_{H,i}, P_2) = \\mathbf{e}(pk_{H,i-1}, pk&#x27;_{H,1}) \\qquad \\qquad \\mathbf{e}(P_1, pk&#x27;_{H,i}) = \\mathbf{e}(pk_{H,i}, P_2)</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check consistency of the remaining pk elements:</li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\mathbf{e}(P_1, pk&#x27;_{\\beta}) = \\mathbf{e}(pk_{\\beta}, P_2) \\qquad \\qquad \\mathbf{e}(P_1, pk&#x27;_{\\delta}) = \\mathbf{e}(pk_{\\delta}, P_2)</span>$</p>

    <p class="text-gray-300">for i = n + 1, ..., m:</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{e}(pk_{K,i}, pk&#x27;_{\\delta}) = \\mathbf{e}\\left(\\sum_{j=0}^{d-1} a_{i,j} pk_{H,j}, pk&#x27;_{\\beta}\\right) \\cdot \\mathbf{e}\\left(pk_{\\alpha}, \\sum_{j=0}^{d-1} b_{i,j} pk&#x27;_{H,j}\\right) \\cdot \\mathbf{e}\\left(\\sum_{j=0}^{d-1} c_{i,j} pk_{H,j}, P_{2}\\right)</span>$
for  <span class="math">i = 0, \\dots, d-2</span> :  <span class="math">\\mathbf{e}(pk_{Z,i}, pk&#x27;_{\\delta}) = \\mathbf{e}\\left(\\sum_{j=0}^{d-1} z_{j} pk_{H,j}, pk&#x27;_{H,i}\\right) \\cdot \\mathbf{e}\\left(z_{d} pk_{H,d-1}, pk&#x27;_{H,i+1}\\right)</span></p>

    <p class="text-gray-300">5. Check consistency of the remaining vk elements: for  <span class="math">i = 0, \\ldots, n</span> :</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{e}(vk_{L,i}, vk&#x27;_{\\gamma}) = \\mathbf{e}\\left(\\sum_{j=0}^{d-1} a_{i,j} pk_{H,j}, pk&#x27;_{\\beta}\\right) \\cdot \\mathbf{e}\\left(pk_{\\alpha}, \\sum_{j=0}^{d-1} b_{i,j} pk&#x27;_{H,j}\\right) \\cdot \\mathbf{e}\\left(\\sum_{j=0}^{d-1} c_{i,j} pk_{H,j}, P_{2}\\right)</span>$
<span class="math">$vk_{T} = \\mathbf{e}(pk_{\\alpha}, pk&#x27;_{\\beta}) \\qquad vk&#x27;_{\\delta} = pk&#x27;_{\\delta}</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If all checks in 1.&ndash;5. succeeded then return true and otherwise false.</li>
    </ol>

    <p class="text-gray-300">KEY GENERATION. On input R as in Eq. (8) representing a QAP for an asymmetric group Gr:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Sample random group generators  <span class="math">P_1 \\leftarrow \\mathbb{G}_1^*</span>  and  <span class="math">P_2 \\leftarrow \\mathbb{G}_2^*</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Sample random  <span class="math">\\alpha, \\beta, \\gamma, \\delta \\leftarrow \\mathbb{F}^*</span>  and  <span class="math">\\tau \\leftarrow \\mathbb{F}</span>  conditioned on  <span class="math">Z(\\tau) \\neq 0</span> .</li>
    </ol></li>
      <li>3. Set  <span class="math">vk = (P_1, P_2, vk_T, vk&#x27;_{\\gamma}, vk&#x27;_{\\delta}, vk_L)</span> , where</li>
    </ul>

    <p class="text-gray-300"><span class="math">$vk_T := \\mathbf{e}(P_1, P_2)^{\\alpha\\beta} \\qquad vk&#x27;_{\\gamma} := \\gamma P_2 \\qquad vk&#x27;_{\\delta} := \\delta P_2</span>$</p>

    <p class="text-gray-300">for  <span class="math">i = 0, \\dots, n</span> :
<span class="math">$vk_{I,i} := \\gamma^{-1} (\\beta A_i(\\tau) + \\alpha B_i(\\tau) + C_i(\\tau)) P_1</span>$</p>

    <p class="text-gray-300">4. Set  <span class="math">pk=(pk_\\alpha,pk_\\beta,pk_\\beta&#x27;,pk_\\delta,pk_\\delta&#x27;,pk_H,pk_H&#x27;,pk_K,pk_Z),</span>  where</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{lll} pk_{\\alpha}:=\\alpha P_1 &amp; pk_{\\beta}:=\\beta P_1 &amp; pk_{\\beta}&#x27;:=\\beta P_2 &amp; pk_{\\delta}:=\\delta P_1 &amp; pk_{\\delta}&#x27;:=\\delta P_2 \\\\ \\text{for } i=0,\\ldots,d-1: &amp; pk_{H,i}:=\\tau^i P_1 &amp; pk_{H,i}&#x27;:=\\tau^i P_2 \\\\ \\text{for } i=n+1,\\ldots,m: &amp; pk_{K,i}:=\\delta^{-1} \\left(\\beta A_i(\\tau)+\\alpha B_i(\\tau)+C_i(\\tau)\\right)P_1 \\\\ \\text{for } i=0,\\ldots,d-2: &amp; pk_{Z,i}:=\\delta^{-1}\\tau^i Z(\\tau)P_1 \\end{array}</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Return crs := (vk, pk).</li>
    </ol>

    <p class="text-gray-300">PROVE. On input R, (vk, pk) and  <span class="math">\\vec{s} \\in \\mathbb{F}^m</span>  s.t. Eq. (6) is satisfied for some  <span class="math">H(X) \\in \\mathbb{F}[X]</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If (R, vk, pk) does not pass CRS VERIFICATION then return  <span class="math">\\perp</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute H(X) such that Eq. (6) is satisfied and let  <span class="math">(h_0, \\ldots, h_{d-2}) \\in \\mathbb{F}^{d-1}</span>  be its coefficients.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Sample  <span class="math">r_A, r_B \\leftarrow \\mathbb{F}</span>  and define</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\pi_A &amp;:= pk_\\alpha + \\sum_{j=0}^{d-1} \\left(a_{0,j} + \\sum_{i=1}^m s_i \\, a_{i,j}\\right) pk_{H,j} + r_A \\, pk_\\delta \\\\ \\pi&#x27;_B &amp;:= pk&#x27;_\\beta + \\sum_{j=0}^{d-1} \\left(b_{0,j} + \\sum_{i=1}^m s_i \\, b_{i,j}\\right) pk&#x27;_{H,j} + r_B \\, pk&#x27;_\\delta \\\\ \\pi_{B,\\mathrm{aux}} &amp;:= pk_\\beta + \\sum_{j=0}^{d-1} \\left(b_{0,j} + \\sum_{i=1}^m s_i \\, b_{i,j}\\right) pk_{H,j} \\\\ \\pi_C &amp;:= \\sum_{i=n+1}^m s_i \\, pk_{K,i} + \\sum_{j=0}^{d-2} h_j \\, pk_{Z,j} + r_B \\, \\pi_A + r_A \\, \\pi_{B,\\mathrm{aux}} \\end{split}</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Return  <span class="math">\\pi := (\\pi_A, \\pi&#x27;_B, \\pi_C)</span> .</li>
    </ol>

    <p class="text-gray-300">VERIFY. On input R, vk,  <span class="math">\\vec{x} \\in \\mathbb{F}^n</span>  and proof  <span class="math">\\pi \\in \\mathbb{G}_1^2 \\times \\mathbb{G}_2</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">vk_x := vk_{L,0} + \\sum_{i=1}^{n} x_i vk_{L,i}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Return true if and only if the following holds:  <span class="math">\\mathbf{e}(\\pi_A, \\pi_B&#x27;) = vk_T + \\mathbf{e}(vk_x, vk_\\gamma&#x27;) + \\mathbf{e}(\\pi_C, vk_\\delta&#x27;)</span></li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Figure 6: Groth's SNARK [Gro16] with CRS verification (in bold)</p>

    <p class="text-gray-300"><strong>CRS verifiability.</strong> Let  <span class="math">\\tau, \\alpha, \\beta, \\gamma, \\delta</span>  denote the logarithms of  <span class="math">pk_{H,1}</span> ,  <span class="math">pk_{\\alpha}</span> ,  <span class="math">pk_{\\beta}</span> ,  <span class="math">vk&#x27;_{\\gamma}</span> ,  <span class="math">pk_{\\delta}</span> . By Check 2. in CRS VERIFICATION,  <span class="math">\\alpha, \\beta, \\gamma, \\delta, Z(\\tau)</span>  are non-zero. It follows by inspection that if all checks in 3.&ndash;5. pass then the remaining elements of pk and vk are correctly computed.</p>

    <p class="text-gray-300"><strong>Trapdoor extraction.</strong> Let X be a CRS subvertor that outputs (vk, pk). Define  <span class="math">X&#x27;(1^{\\lambda}; r)</span>  that runs  <span class="math">(vk, pk) \\leftarrow X(1^{\\lambda}; r)</span> , parses the output as above and returns  <span class="math">(P_1, pk_{H,1}, pk_{H,2}, P_2, pk&#x27;_{H,1})</span> . For a valid CRS this corresponds to  <span class="math">(P_1, \\tau P_1, \\tau^2 P_1, P_2, \\tau P_2)</span>  for some  <span class="math">P_1 \\in \\mathbb{G}_1</span> ,  <span class="math">P_2 \\in \\mathbb{G}_2</span>  and  <span class="math">\\tau \\in \\mathbb{F}</span> . By SKE there exists a PT algorithm  <span class="math">\\mathsf{E}_{\\mathsf{X}&#x27;}</span>  which from a valid tuple extracts  <span class="math">\\tau</span>  with overwhelming probability.</p>

    <p class="text-gray-300">Define another algorithm  <span class="math">\\mathsf{X}&#x27;&#x27;(1^{\\lambda};(r,r&#x27;))</span>  that runs  <span class="math">(vk,pk)\\leftarrow \\mathsf{X}(1^{\\lambda};r)</span>  and then extracts  <span class="math">\\tau\\leftarrow</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{E}_{\\mathsf{X}&#x27;}(1^\\lambda,r;r&#x27;)</span> , computes  <span class="math">Z(\\tau)</span>  (which is non-zero in a valid CRS) and sets  <span class="math">P_1&#x27;:=Z(\\tau)^{-1}\\,pk_{Z,0}</span>  (which for a valid CRS yields  <span class="math">P_1&#x27;=\\delta^{-1}P_1</span> ). Finally,  <span class="math">\\mathsf{X}&#x27;&#x27;</span>  returns  <span class="math">(P_1&#x27;,P_1,pk_\\delta,P_2,pk_\\delta&#x27;)</span> . For a valid CRS this corresponds to  <span class="math">(P_1&#x27;,\\delta P_1&#x27;,\\delta^2 P_1&#x27;,P_2,\\delta P_2)</span> . By SKE there exist a PT algorithm  <span class="math">\\mathsf{E}_{\\mathsf{X}&#x27;&#x27;}</span>  that on input r''=(r,r') returns  <span class="math">\\delta</span>  with overwhelming probability.</p>

    <p class="text-gray-300">Using  <span class="math">E_{X&#x27;}</span>  and  <span class="math">E_{X&#x27;&#x27;}</span> , we define the CRS simulator S.crs as follows: On input  <span class="math">1^{\\lambda}</span>  do the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Sample randomness for X and  <span class="math">\\mathsf{E}_{\\mathsf{X}&#x27;}</span> :  <span class="math">r \\leftarrow \\</span> {0,1}^{\\mathsf{X}.\\mathsf{rl}(\\lambda)}; \\ r' \\leftarrow $ {0,1}^{\\mathsf{E}_{\\mathsf{X}'}.\\mathsf{rl}(\\lambda)}$</li>
      <li>Run  <span class="math">(vk, pk) \\leftarrow \\mathsf{X}(1^{\\lambda}; r)</span></li>
      <li>If (R, vk, pk) verifies then  <span class="math">\\tau \\leftarrow \\mathsf{E}_{\\mathsf{X}&#x27;}(1^{\\lambda}, r; r&#x27;)</span>  and  <span class="math">\\delta \\leftarrow \\mathsf{s} \\, \\mathsf{E}_{\\mathsf{X}&#x27;&#x27;}(1^{\\lambda}, (r, r&#x27;))</span> , else  <span class="math">(\\tau, \\delta) \\leftarrow (\\bot, \\bot)</span></li>
      <li>Return  <span class="math">((vk, pk), r, (\\tau, \\delta))</span></li>
    </ul>

    <p class="text-gray-300"><strong>Remark 6.2</strong> Proof simulation is defined in [Gro16] using the full randomness of the CRS and does not work with the trapdoor  <span class="math">(\\tau, \\delta)</span> , as the simulator requires  <span class="math">\\alpha</span>  and  <span class="math">\\beta</span> , which SKE does not allow to extract. Note that it is impossible to extract  <span class="math">\\alpha</span> , since a valid CRS can be computed without knowing  <span class="math">\\alpha</span> : obliviously sample a random generator  <span class="math">pk_{\\alpha} \\leftarrow \\mathfrak{s} \\mathbb{G}_1^*</span>  and then compute  <span class="math">vk_T</span>  and, for all i,  <span class="math">vk_{L,i}</span>  and  <span class="math">pk_{K,i}</span>  from  <span class="math">pk_{\\alpha}</span> . In the following we show how to simulate a proof without knowledge of  <span class="math">\\alpha</span>  and  <span class="math">\\beta</span> .</p>

    <p class="text-gray-300"><strong>Proof simulation.</strong> Given (vk, pk), trapdoor  <span class="math">(\\tau, \\delta)</span>  and a statement  <span class="math">x \\in \\mathbb{F}^n</span> , the proof simulator S.pf does the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">(\\tau, \\delta) = (\\bot, \\bot)</span>  then return  <span class="math">\\bot</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Choose  <span class="math">a, b \\leftarrow \\mathbb{F}</span>  and define the proof  <span class="math">\\pi := (\\pi_A, \\pi&#x27;_B, \\pi_C)</span>  as follows</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\pi_{A} := aP_{1} + pk_{\\alpha} \\qquad \\qquad \\pi&#x27;_{B} := bP_{2} + pk&#x27;_{\\beta}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\pi_{C} := \\delta^{-1} \\left( ab - C_{0}(\\tau) - \\sum_{i=1}^{n} x_{i}C_{i}(\\tau) \\right) P_{1} + \\delta^{-1} \\left( b - B_{0}(\\tau) - \\sum_{i=1}^{n} x_{i}B_{i}(\\tau) \\right) pk_{\\alpha}</span>$</p>

    <p class="text-gray-300"><span class="math">$+ \\delta^{-1} \\left( a - A_{0}(\\tau) - \\sum_{i=1}^{n} x_{i}A_{i}(\\tau) \\right) pk_{\\beta}</span>$</p>

    <p class="text-gray-300"><strong>Theorem 6.3</strong> Let Rg be a QAP generator defining a bilinear-group generator aGen for which SKE holds. Then Groth's SNARK [Gro16] with CRS verification (Figure 6) for Rg satisfies subversion zero knowledge.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Let E denote the event that (R, vk, pk) passes CRS verification but either  <span class="math">\\mathsf{E}_{\\mathsf{X}&#x27;}</span>  or  <span class="math">\\mathsf{E}_{\\mathsf{X}&#x27;&#x27;}</span>  fails to extract  <span class="math">\\tau</span>  and  <span class="math">\\delta</span> . Since a correct (vk, pk) satisfies  <span class="math">\\mathsf{e}(pk_{H,1}, P_2) = \\mathsf{e}(P_1, pk&#x27;_{H,1})</span>  as well as  <span class="math">\\mathsf{e}(pk_{H,2}, P_2) = \\mathsf{e}(pk_{H,1}, pk&#x27;_{H,1})</span> , by SKE (Definition 2.15), the probability that  <span class="math">\\mathsf{E}_{\\mathsf{X}&#x27;}</span>  fails when  <span class="math">\\mathsf{X}&#x27;</span>  outputs  <span class="math">(P_1, pk_{H,1}, pk_{H,2}, P_2, pk&#x27;_{H,1})</span>  is negligible. A correct CRS also satisfies both  <span class="math">\\mathsf{e}(P_1, P_2) = \\mathsf{e}(Z(\\tau)^{-1}pk_{Z,0}, pk&#x27;_{\\delta})</span>  and  <span class="math">\\mathsf{e}(pk_{\\delta}, P_2) = \\mathsf{e}(P_1, pk&#x27;_{\\delta})</span> , thus again by SKE, the probability that  <span class="math">\\mathsf{E}_{\\mathsf{X}&#x27;&#x27;}</span>  fails when  <span class="math">\\mathsf{X}&#x27;&#x27;</span>  outputs  <span class="math">(Z(\\tau)^{-1}pk_{Z,0}, P_1, pk_{\\delta}, P_2, pk&#x27;_{\\delta})</span>  is also negligible. By a union bound, the probability of E is thus negligible.</p>

    <p class="text-gray-300">It now suffices to show that, conditioned on E not happening, game S-ZK when b=0 is distributed as game S-ZK when b=1. If (vk,pk) fails verification then  <span class="math">(\\tau,\\delta)=(\\bot,\\bot)</span>  and both the prover and the proof simulator return  <span class="math">\\bot</span> .</p>

    <p class="text-gray-300">If (vk, pk) verifies then we show that the outputs of the prover and the proof simulator are distributed equivalently. Above we argued that for some non-zero  <span class="math">\\alpha, \\beta, \\gamma, \\delta</span>  and  <span class="math">\\tau</span>  with  <span class="math">Z(\\tau) \\neq 0</span>  we have that vk and pk are defined as in 3. and 4. in Key generation.</p>

    <p class="text-gray-300">Since for a valid CRS both  <span class="math">pk_{\\delta}</span>  and  <span class="math">pk&#x27;_{\\delta}</span>  are non-zero, for honestly generated proofs the elements  <span class="math">r_A pk_{\\delta}</span>  in  <span class="math">\\pi_A</span> , and  <span class="math">r_B pk&#x27;_{\\delta}</span>  in  <span class="math">\\pi&#x27;_B</span> , make  <span class="math">\\pi_A</span>  and  <span class="math">\\pi&#x27;_B</span>  uniformly random. For fixed vk,  <span class="math">\\pi_A</span>  and  <span class="math">\\pi&#x27;_B</span> , the verification equation uniquely determines  <span class="math">\\pi_C</span> , since  <span class="math">vk&#x27;_{\\delta} \\neq 0</span> .</p>

    <p class="text-gray-300">In a simulated proof  <span class="math">\\pi_A</span>  and  <span class="math">\\pi&#x27;_B</span>  are also uniformly random, so it suffices to show that the simulated  <span class="math">\\pi_C</span>  satisfies the verification equation:</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{e}(\\pi_C, \\mathbf{v}k&#x27;_{\\delta}) =</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\mathbf{e}\\left(\\left(ab - C_0(\\tau) - \\sum x_i C_i(\\tau) + \\alpha(b - B_0(\\tau) - \\sum x_i B_i(\\tau)) + \\beta(a - A_0(\\tau) - \\sum x_i A_i(\\tau))\\right)P_1, P_2\\right)</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\mathbf{e}(abP_1, P_2) + \\mathbf{e}(a\\beta P_1, P_2) + \\mathbf{e}(\\alpha bP_1, P_2) + \\mathbf{e}(\\alpha\\beta P_1, P_2) - \\mathbf{e}(\\alpha\\beta P_1, P_2)</span>$</p>

    <p class="text-gray-300"><span class="math">$- \\mathbf{e}\\left(\\left(\\beta A_0(\\tau) + \\sum x_i \\beta A_i(\\tau) + \\alpha B_0(\\tau) + \\sum x_i \\alpha B_i(\\tau) + C_0(\\tau) + \\sum x_i C_i(\\tau)\\right)P_1, P_2\\right)</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\mathbf{e}(\\pi_A, \\pi&#x27;_B) - \\mathbf{v}k_T - \\mathbf{e}(\\mathbf{v}k_X, \\mathbf{v}k&#x27;_{\\gamma})</span>$</p>

    <p class="text-gray-300">This concludes the proof.</p>

    <p class="text-gray-300">Corollary 6.4 Groth's SNARK [Gro16] with CRS verification for a QAP generator Rg (Figure 6) satisfies perfect subversion witness indistinguishability.</p>

    <p class="text-gray-300"><strong>Proof.</strong> The corollary follows analogously to Corollary 5.5.</p>

    </section>

    <section id="acknowledgements" class="mb-10">
      <h2 class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">The author would like to thank Mihir Bellare and Rosario Gennaro for helpful discussions and the anonymous reviewers for PKC'18 for their valuable comments. The author is supported by the French ANR EfTrEC project (ANR-16-CE39-0002).</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><p class="text-gray-300">[ABLZ17] Behzad Abdolmaleki, Karim Baghery, Helger Lipmaa, and Michal Zajac. A subversion-resistant SNARK. In Tsuyoshi Takagi and Thomas Peyrin, editors, ASIACRYPT 2017, Part III, volume 10626 of LNCS, pages 3&ndash;33. Springer, 2017.</p></li>
      <li><p class="text-gray-300">[AF07] Masayuki Abe and Serge Fehr. Perfect NIZK with adaptive soundness. In Salil P. Vadhan, editor, TCC 2007, volume 4392 of LNCS, pages 118&ndash;136. Springer, 2007.</p></li>
      <li><p class="text-gray-300">[BB04] Dan Boneh and Xavier Boyen. Short signatures without random oracles. In Christian Cachin and Jan Camenisch, editors, <em>EUROCRYPT 2004</em>, volume 3027 of <em>LNCS</em>, pages 56&ndash;73. Springer, 2004.</p></li>
      <li><p class="text-gray-300">[BBS04] Dan Boneh, Xavier Boyen, and Hovav Shacham. Short group signatures. In Matthew Franklin, editor, CRYPTO 2004, volume 3152 of LNCS, pages 41&ndash;55. Springer, 2004.</p></li>
      <li><p class="text-gray-300">[BCCT12] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In Shafi Goldwasser, editor, <em>ITCS 2012</em>, pages 326&ndash;349. ACM, 2012.</p></li>
      <li><p class="text-gray-300">[BCG<sup>+</sup>13] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza. SNARKs for C: Verifying program executions succinctly and in zero knowledge. In Ran Canetti and Juan A. Garay, editors, <em>CRYPTO 2013, Part II</em>, volume 8043 of <em>LNCS</em>, pages 90&ndash;108. Springer, 2013.</p></li>
      <li><p class="text-gray-300">[BCG+14a] Eli Ben-Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers, Eran Tromer, and Madars Virza. Zerocash: Decentralized anonymous payments from bitcoin. In 2014 IEEE Symposium on Security and Privacy, pages 459&ndash;474. IEEE Computer Society Press, 2014.</p></li>
      <li><p class="text-gray-300">[BCG+14b] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza. libsnark, 2014. Available at <a href="https://github.com/scipr-lab/libsnark" target="_blank" rel="noopener noreferrer">https://github.com/scipr-lab/libsnark</a>.</p></li>
      <li><p class="text-gray-300">[BCG+15] Eli Ben-Sasson, Alessandro Chiesa, Matthew Green, Eran Tromer, and Madars Virza. Secure sampling of public parameters for succinct zero knowledge proofs. In 2015 IEEE Symposium on Security and Privacy, pages 287&ndash;304. IEEE Computer Society Press, 2015.</p></li>
      <li><p class="text-gray-300">[BCI+10] Eric Brier, Jean-S&acute;ebastien Coron, Thomas Icart, David Madore, Hugues Randriam, and Mehdi Tibouchi. Efficient indifferentiable hashing into ordinary elliptic curves. In Tal Rabin, editor, CRYPTO 2010, volume 6223 of LNCS, pages 237&ndash;254. Springer, 2010.</p></li>
      <li><p class="text-gray-300">[BCI+13] Nir Bitansky, Alessandro Chiesa, Yuval Ishai, Rafail Ostrovsky, and Omer Paneth. Succinct noninteractive arguments via linear interactive proofs. In Amit Sahai, editor, TCC 2013, volume 7785 of LNCS, pages 315&ndash;333. Springer, 2013.</p></li>
      <li><p class="text-gray-300">[BCPR14] Nir Bitansky, Ran Canetti, Omer Paneth, and Alon Rosen. On the existence of extractable one-way functions. In David B. Shmoys, editor, 46th ACM STOC, pages 505&ndash;514. ACM Press, 2014.</p></li>
      <li><p class="text-gray-300">[BCTV14] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Succinct non-interactive zero knowledge for a von Neumann architecture. In Kevin Fu and Jaeyeon Jung, editors, USENIX Security Symposium, pages 781&ndash;796. USENIX Association, 2014.</p></li>
      <li><p class="text-gray-300">[BDMP91] Manuel Blum, Alfredo De Santis, Silvio Micali, and Giuseppe Persiano. Noninteractive zeroknowledge. SIAM Journal on Computing, 20(6):1084&ndash;1118, 1991.</p></li>
      <li><p class="text-gray-300">[BF01] Dan Boneh and Matthew K. Franklin. Identity-based encryption from the Weil pairing. In Joe Kilian, editor, CRYPTO 2001, volume 2139 of LNCS, pages 213&ndash;229. Springer, 2001.</p></li>
      <li><p class="text-gray-300">[BFM88] Manuel Blum, Paul Feldman, and Silvio Micali. Non-interactive zero-knowledge and its applications (extended abstract). In 20th ACM STOC, pages 103&ndash;112. ACM Press, 1988.</p></li>
      <li><p class="text-gray-300">[BFS16] Mihir Bellare, Georg Fuchsbauer, and Alessandra Scafuro. NIZKs with an untrusted CRS: Security in the face of parameter subversion. In Jung Hee Cheon and Tsuyoshi Takagi, editors, ASIACRYPT 2016, Part II, volume 10032 of LNCS, pages 777&ndash;804. Springer, 2016.</p></li>
      <li><p class="text-gray-300">[BG93] Mihir Bellare and Oded Goldreich. On defining proofs of knowledge. In Ernest F. Brickell, editor, CRYPTO'92, volume 740 of LNCS, pages 390&ndash;420. Springer, 1993.</p></li>
      <li><p class="text-gray-300">[BGG17] Sean Bowe, Ariel Gabizon, and Matthew D. Green. A multi-party protocol for constructing the public parameters of the pinocchio zk-SNARK. Cryptology ePrint Archive, Report 2017/602, 2017. <a href="http://eprint.iacr.org/2017/602" target="_blank" rel="noopener noreferrer">http://eprint.iacr.org/2017/602</a>.</p></li>
      <li><p class="text-gray-300">[BP04] Mihir Bellare and Adriana Palacio. The knowledge-of-exponent assumptions and 3-round zeroknowledge protocols. In Matthew Franklin, editor, CRYPTO 2004, volume 3152 of LNCS, pages 273&ndash;289. Springer, 2004.</p></li>
      <li><p class="text-gray-300">[BR93] Mihir Bellare and Phillip Rogaway. Random oracles are practical: A paradigm for designing efficient protocols. In V. Ashby, editor, ACM CCS 93, pages 62&ndash;73. ACM Press, 1993.</p></li>
      <li><p class="text-gray-300">[BR06] Mihir Bellare and Phillip Rogaway. The security of triple encryption and a framework for codebased game-playing proofs. In Serge Vaudenay, editor, EUROCRYPT 2006, volume 4004 of LNCS, pages 409&ndash;426. Springer, 2006.</p></li>
      <li><p class="text-gray-300">[BSBC<sup>+</sup>17] Eli Ben-Sasson, Iddo Bentov, Alessandro Chiesa, Ariel Gabizon, Daniel Genkin, Matan Hamilis, Evgenya Pergament, Michael Riabzev, Mark Silberstein, Eran Tromer, and Madars Virza. Computational integrity with a public random string from quasi-linear PCPs. In Jean-S&acute;ebastien Coron and Jesper Buus Nielsen, editors, EUROCRYPT 2017, Part II, volume 10211 of LNCS, pages 551&ndash;579. Springer, 2017.</p></li>
      <li><p class="text-gray-300">[CGGN17] Matteo Campanelli, Rosario Gennaro, Steven Goldfeder, and Luca Nizzardo. Zero-knowledge contingent payments revisited: Attacks and payments for services. In Bhavani M. Thuraisingham, David Evans, Tal Malkin, and Dongyan Xu, editors, ACM CCS 17, pages 229&ndash;243. ACM Press, 2017.</p></li>
      <li><p class="text-gray-300">[CNE+14] Stephen Checkoway, Ruben Niederhagen, Adam Everspaugh, Matthew Green, Tanja Lange, Thomas Ristenpart, Daniel J. Bernstein, Jake Maskiewicz, Hovav Shacham, and Matthew Fredrikson. On the practical exploitability of Dual EC in TLS implementations. In Kevin Fu and Jaeyeon Jung, editors, USENIX Security Symposium, pages 319&ndash;335. USENIX Association, 2014.</p></li>
      <li><p class="text-gray-300">[Dam92] Ivan Damg&#730;ard. Towards practical public key systems secure against chosen ciphertext attacks. In Joan Feigenbaum, editor, CRYPTO'91, volume 576 of LNCS, pages 445&ndash;456. Springer, 1992.</p></li>
      <li><p class="text-gray-300">[DFGK14] George Danezis, C&acute;edric Fournet, Jens Groth, and Markulf Kohlweiss. Square span programs with applications to succinct NIZK arguments. In Palash Sarkar and Tetsu Iwata, editors, ASIACRYPT 2014, Part I, volume 8873 of LNCS, pages 532&ndash;550. Springer, 2014.</p></li>
      <li><p class="text-gray-300">[FKL17] Georg Fuchsbauer, Eike Kiltz, and Julian Loss. The algebraic group model and its applications. Cryptology ePrint Archive, Report 2017/620, 2017. <a href="http://eprint.iacr.org/2017/620" target="_blank" rel="noopener noreferrer">http://eprint.iacr.org/2017/620</a>.</p></li>
      <li><p class="text-gray-300">[FLS90] Uriel Feige, Dror Lapidot, and Adi Shamir. Multiple non-interactive zero knowledge proofs based on a single random string (extended abstract). In 31st FOCS, pages 308&ndash;317. IEEE Computer Society Press, 1990.</p></li>
      <li><p class="text-gray-300">[FS87] Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identification and signature problems. In Andrew M. Odlyzko, editor, CRYPTO'86, volume 263 of LNCS, pages 186&ndash;194. Springer, 1987.</p></li>
      <li><p class="text-gray-300">[Gab19] Ariel Gabizon. On the security of the BCTV Pinocchio zk-SNARK variant. Cryptology ePrint Archive, Report 2019/119, 2019. <a href="http://eprint.iacr.org/2019/119" target="_blank" rel="noopener noreferrer">http://eprint.iacr.org/2019/119</a>.</p></li>
      <li><p class="text-gray-300">[Gen04] Rosario Gennaro. Multi-trapdoor commitments and their applications to proofs of knowledge secure under concurrent man-in-the-middle attacks. In Matthew Franklin, editor, CRYPTO 2004, volume 3152 of LNCS, pages 220&ndash;236. Springer, 2004.</p></li>
      <li><p class="text-gray-300">[GGPR13] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct NIZKs without PCPs. In Thomas Johansson and Phong Q. Nguyen, editors, EUROCRYPT 2013, volume 7881 of LNCS, pages 626&ndash;645. Springer, 2013.</p></li>
      <li><p class="text-gray-300">[GMR89] Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of interactive proof systems. SIAM Journal on Computing, 18(1):186&ndash;208, 1989.</p></li>
      <li><p class="text-gray-300">[GO94] Oded Goldreich and Yair Oren. Definitions and properties of zero-knowledge proof systems. Journal of Cryptology, 7(1):1&ndash;32, 1994.</p></li>
      <li><p class="text-gray-300">[GOS06a] Jens Groth, Rafail Ostrovsky, and Amit Sahai. Non-interactive zaps and new techniques for NIZK. In Cynthia Dwork, editor, CRYPTO 2006, volume 4117 of LNCS, pages 97&ndash;111. Springer, 2006.</p></li>
      <li><p class="text-gray-300">[GOS06b] Jens Groth, Rafail Ostrovsky, and Amit Sahai. Perfect non-interactive zero knowledge for NP. In Serge Vaudenay, editor, EUROCRYPT 2006, volume 4004 of LNCS, pages 339&ndash;358. Springer, 2006.</p></li>
      <li><p class="text-gray-300">[Gro06] Jens Groth. Simulation-sound NIZK proofs for a practical language and constant size group signatures. In Xuejia Lai and Kefei Chen, editors, ASIACRYPT 2006, volume 4284 of LNCS, pages 444&ndash;459. Springer, 2006.</p></li>
      <li><p class="text-gray-300">[Gro10] Jens Groth. Short pairing-based non-interactive zero-knowledge arguments. In Masayuki Abe, editor, ASIACRYPT 2010, volume 6477 of LNCS, pages 321&ndash;340. Springer, 2010.</p></li>
      <li><p class="text-gray-300">[Gro16] Jens Groth. On the size of pairing-based non-interactive arguments. In Marc Fischlin and Jean-S&acute;ebastien Coron, editors, EUROCRYPT 2016, Part II, volume 9666 of LNCS, pages 305&ndash;326. Springer, 2016.</p></li>
      <li><p class="text-gray-300">[GS08] Jens Groth and Amit Sahai. Efficient non-interactive proof systems for bilinear groups. In Nigel P. Smart, editor, EUROCRYPT 2008, volume 4965 of LNCS, pages 415&ndash;432. Springer, 2008.</p></li>
      <li><p class="text-gray-300">[GW11] Craig Gentry and Daniel Wichs. Separating succinct non-interactive arguments from all falsifiable assumptions. In Lance Fortnow and Salil P. Vadhan, editors, 43rd ACM STOC, pages 99&ndash;108. ACM Press, 2011.</p></li>
      <li><p class="text-gray-300">[HT98] Satoshi Hada and Toshiaki Tanaka. On the existence of 3-round zero-knowledge protocols. In Hugo Krawczyk, editor, CRYPTO'98, volume 1462 of LNCS, pages 408&ndash;423. Springer, 1998.</p></li>
      <li><p class="text-gray-300">[Lip12] Helger Lipmaa. Progression-free sets and sublinear pairing-based non-interactive zero-knowledge arguments. In Ronald Cramer, editor, TCC 2012, volume 7194 of LNCS, pages 169&ndash;189. Springer, 2012.</p></li>
      <li><p class="text-gray-300">[Mic00] Silvio Micali. Computationally sound proofs. SIAM J. Comput., 30(4):1253&ndash;1298, 2000.</p></li>
      <li><p class="text-gray-300">[Nak09] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system, 2009. <a href="http://bitcoin.org/bitcoin.pdf" target="_blank" rel="noopener noreferrer">http://bitcoin.</a> <a href="http://bitcoin.org/bitcoin.pdf" target="_blank" rel="noopener noreferrer">org/bitcoin.pdf</a>.</p></li>
      <li><p class="text-gray-300">[PHGR13] Bryan Parno, Jon Howell, Craig Gentry, and Mariana Raykova. Pinocchio: Nearly practical verifiable computation. In 2013 IEEE Symposium on Security and Privacy, pages 238&ndash;252. IEEE Computer Society Press, May 2013.</p></li>
      <li><p class="text-gray-300">[Sch91] Claus-Peter Schnorr. Efficient signature generation by smart cards. Journal of Cryptology, 4(3):161&ndash;174, 1991.</p></li>
      <li><p class="text-gray-300">[Sho97] Victor Shoup. Lower bounds for discrete logarithms and related problems. In Walter Fumy, editor, EUROCRYPT'97, volume 1233 of LNCS, pages 256&ndash;266. Springer, 1997.</p></li>
      <li><p class="text-gray-300">[SvdW06] Andrew Shallue and Christiaan van de Woestijne. Construction of rational points on elliptic curves over finite fields. In Florian Hess, Sebastian Pauli, and Michael E. Pohst, editors, ANTS-VII, volume 4076 of LNCS, pages 510&ndash;524. Springer, 2006.</p></li>
      <li><p class="text-gray-300">[Zca] Zcash. <a href="http://z.cash" target="_blank" rel="noopener noreferrer">http://z.cash</a>.</p></li>
    </ul>

    </section>
`;
---

<BaseLayout title="Subversion-zero-knowledge SNARKs (2017/587)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2017 &middot; eprint 2017/587
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#abstract" class="hover:text-white">Abstract</a></li>
        <li><a href="#sec-1" class="hover:text-white">Introduction</a></li>
        <li>
          <a href="#sec-2" class="hover:text-white">Definitions</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-2.1" class="hover:text-white">Notation</a></li>
            <li><a href="#sec-2.2" class="hover:text-white">NP Relations and NI Systems</a></li>
            <li><a href="#sec-2.3" class="hover:text-white">Standard Notions: SND, KSND, WI and ZK</a></li>
            <li><a href="#sec-2.4" class="hover:text-white">Notions for Subverted CRS: S-SND, S-KSND, S-WI and S-ZK</a></li>
            <li><a href="#sec-2.5" class="hover:text-white">Bilinear Groups and Assumptions</a></li>
            <li><a href="#sec-2.6" class="hover:text-white">SKE in the Generic-Group Model</a></li>
          </ol>
        </li>
        <li><a href="#sec-3" class="hover:text-white">SNARKs</a></li>
        <li><a href="#sec-4" class="hover:text-white">GGPR&#x27;s QAP-Based SNARK</a></li>
        <li><a href="#sec-5" class="hover:text-white">Asymmetric Pinocchio</a></li>
        <li><a href="#sec-6" class="hover:text-white">Groth&#x27;s Near-Optimal SNARK</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#acknowledgements" class="hover:text-white">Acknowledgements</a></li>
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="subversion-zero-knowledge-snarks-2017" />
  </article>
</BaseLayout>
