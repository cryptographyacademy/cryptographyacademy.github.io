---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2017/587';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Subversion-zero-knowledge SNARKs';
const AUTHORS_HTML = 'Georg Fuchsbauer';

const CONTENT = `    <p class="text-gray-300">An extended abstract of this work appears in <em>PKC’18</em>. This is the full version, adapted to the corrected version of the scheme from <em>[x1]</em> (Figure 5), which had been shown not to be sound <em>[x10]</em> (our results are not affected).</p>

    <p class="text-gray-300">Subversion-zero-knowledge SNARKs</p>

    <p class="text-gray-300">Georg Fuchsbauer</p>

    <h6 id="sec-1" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Subversion zero knowledge for non-interactive proof systems demands that zero knowledge (ZK) be maintained even when the common reference string (CRS) is chosen maliciously. SNARKs are proof systems with succinct proofs, which are at the core of the cryptocurrency Zcash, whose anonymity relies on ZK-SNARKs; they are also used for ZK contingent payments in Bitcoin.</p>

    <p class="text-gray-300">We show that under a plausible hardness assumption, the most efficient SNARK schemes proposed in the literature, including the one underlying Zcash and contingent payments, satisfy subversion ZK or can be made to at very little cost. In particular, we prove subversion ZK of the original SNARKs by Gennaro et al. and the almost optimal construction by Groth; for the Pinocchio scheme implemented in libsnark we show that it suffices to add 4 group elements to the CRS. We also argue informally that Zcash is anonymous even if its parameters were set up maliciously.</p>

    <p class="text-gray-300">Keywords: Zero knowledge, SNARKs, parameter subversion, Zcash, Bitcoin contingent payments.</p>

    <h2 id="sec-2" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">One of the primary motivations for succinct non-interactive arguments (SNARG) was verifiable computation. Consider a client that outsources resource-intensive computation to a powerful server, which attaches a <em>proof</em> to the result, so the client is convinced that it was computed correctly. For this to be meaningful, verification of such a proof must be considerably more efficient than performing the computation in the first place. SNARG systems provide such proofs and an impressive line of research has led to more and more efficient systems with proofs of size less than a kilobyte that can be verified in milliseconds. The reason why SNARGs are not used in outsourcing of computation is that computing a proof for complex computations is still not practical. (For example, a proof in Zcash, which is for a very simple statement, takes minutes to compute on a PC.)</p>

    <p class="text-gray-300">Zero-knowledge (ZK) SNARGs are used when some inputs to the computation come from the prover (the server in our example), who wants to keep its inputs private. ZK systems guarantee that a proof does not reveal more about private inputs than what can be inferred from the result of the computation. If the proofs prove knowledge of the private inputs, they are called SNARKs. ZK-SNARKs are already deployed, for example in Zcash <em>[x23]</em>, which is a cryptocurrency like Bitcoin <em>[x20]</em>, based on the Zerocash protocol <em>[BCG^{+}14a]</em>. As opposed to Bitcoin, where all transactions are public, Zcash payments are fully anonymous and protect the users’ privacy. Zcash achieves this by using SNARK proofs that are zero-knowledge.</p>

    <p class="text-gray-300">Zero-knowledge contingent payments use SNARKs for fair exchange of information against payments over the Bitcoin network, assuming that the information can be verified (in the sense that it can be formalized as the witness of an NP statement), e.g. solutions to a Sudoku puzzle. Bitcoin’s scripting language defines Pay-to-PubkeyHash transactions, which are bound to a hash value <span class="math">y</span> and can be redeemed by exhibiting a preimage, i.e., some <span class="math">x</span> s.t. <span class="math">H(x)=y</span>. In a contingent payment Alice, the seller, chooses a key <span class="math">k</span>, encrypts the information she is offering as <span class="math">c</span> under <span class="math">k</span> and sends <span class="math">c</span> together with <span class="math">y:=H(k)</span> to Bob, the buyer. Bob makes a transaction to <span class="math">y</span>. To redeem it, Alice must publish the preimage <span class="math">k</span>, which then allows Bob to decrypt <span class="math">c</span> and obtain the purchased information. To prevent Alice from cheating, she must prove that <span class="math">c</span> encrypts the desired information under a preimage of <span class="math">y</span>, for which she can use SNARKs. Zero-knowledge guarantees that no information is leaked before being paid.</p>

    <p class="text-gray-300">The main drawback of SNARKs is that they require system parameters that must be generated in a trusted way. In particular, whoever knows the randomness used when setting them up can convince verifiers of false statements (violating soundness of the system), which for Zerocash translates to counterfeiting money. The authors of Zerocash write: “[D]ue to the zk-SNARK, our construction requires a one-time trusted setup of public parameters. The trust affects soundness of the proofs, though anonymity continues to hold even if the setup is corrupted by a malicious party.” <em>[BCG^{+}14a]</em>. The last statement is then not elaborated any further.</p>

    <p class="text-gray-300">For ZK contingent payments (ZKCP) the parameters are generated by the buyer, which prevents the seller from cheating. However, Campanelli, Gennaro, Goldfeder and Nizzardo <em>[x10]</em> recently showed that the buyer can cheat in the reference implementation of ZKCP, which allows for selling the solution to a Sudoku puzzle. By maliciously setting up the parameters, the buyer can learn information about the solution from the SNARK proof sent by the seller before paying. This shows that not only soundness but also zero knowledge of SNARKs breaks down in the face of parameter subversion.</p>

    <p class="text-gray-300">In this work we look at whether zero knowledge can be salvaged when the parameters are set up maliciously and analyze the most efficient SNARK constructions in the literature, including the one <em>[x2]</em> that underlies Zcash and ZKCP. We base our analyses on the theoretical framework introduced by Bellare et al. <em>[x3]</em>, who formalized the notion of subversion zero knowledge.</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">Zero-knowledge proofs.</h4>

    <p class="text-gray-300">A zero-knowledge proof <em>[x14]</em> is a protocol between a prover and a verifier that allows the former to convince the latter of the validity of a statement without revealing anything else. ZK proofs are an important building block for cryptographic schemes as they allow to assert that computations were done correctly while respecting the user’s privacy. The three main properties of a ZK proof system are that a proof for a valid statement computed according to the protocol should convince a verifier (completeness); but there is no way that a malicious prover can convince a verifier of false statements (soundness); and nothing but the truth of the statement is revealed (zero knowledge).</p>

    <p class="text-gray-300">In non-interactive ZK proofs <em>[x4]</em>, the prover only sends one message (the proof) to the verifier. NIZK systems rely on a common reference string (CRS) to which both prover and verifier have access and which must be set up in a trusted way (for SNARKs the CRS is often called parameters). Without such a CRS, NIZK systems are not possible <em>[x11]</em>.</p>

    <p class="text-gray-300">NIZK proof systems exist for every NP language <em>[x4, x5]</em>. A language <span class="math">L</span> is an NP language if it can be defined via a polynomial-time computable relation <span class="math">R</span>: a statement <span class="math">x</span> is in <span class="math">L</span> iff there exists a witness <span class="math">w</span> of length polynomial in the length of <span class="math">x</span> such that <span class="math">R(x,w)=\\textsf{true}</span>. In verifiable computation a server’s private input would be a witness. For ZK contingent payments, the ciphertext <span class="math">c</span>, the hash value <span class="math">y</span> and the Sudoku challenge are the statement. The witness is the plaintext of <span class="math">c</span> (the Sudoku solution) and the encryption key <span class="math">k</span>.</p>

    <p class="text-gray-300">Zero knowledge is formalized via a <em>simulator</em> that generates a CRS in which it can embed a <em>trapdoor</em>. The trapdoor must allow the simulator to produce proofs without a witness for the proven statement. ZK requires that there exists a simulator whose simulated CRSs and proofs are computationally indistinguishable from real ones. If both types are distributed equivalently then we have <em>perfect</em> ZK. Groth, Ostrovsky and Sahai <em>[x13, x14, x15, x16]</em> constructed NIZK proof systems based on groups equipped with a <em>pairing</em>, i.e., an efficiently computable bilinear map. They gave the first perfect ZK system for all NP languages and very efficient schemes for specific languages based on standard cryptographic hardness assumptions.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">SNARKs.</h4>

    <p class="text-gray-300">Another line of work considered the size of proofs from a theoretical point of view, leading to schemes with a proof size that is sublinear in the length of the proved statement <em>[x20]</em>. SNARGs are succinct non-interactive arguments, where <em>succinct</em> means that the proof length only depends (polynomially) on the security parameter. They are <em>arguments</em> (as opposed to proofs) because soundness only holds against efficient provers. This is the best achievable notion, since SNARGs are perfect-ZK, which implies that every CRS has a trapdoor. SNARKs are succinct non-interactive arguments <em>of knowledge</em>, for which a valid proofs implies that the prover knows the witness.</p>

    <p class="text-gray-300">The first NIZK system with proofs whose size is independent of the proven statement (and its witness) was given by Groth <em>[x13]</em> using bilinear groups; it was later improved by Lipmaa <em>[x21]</em>. Gennaro, Gentry, Parno and Raykova <em>[x12]</em> introduced the notion of a quadratic span program (QSP), showed how to efficiently convert any boolean circuit into a QSP and then constructed a SNARK system for QSPs whose proofs consist of 8 elements of a bilinear group. They gave another construction based on quadratic arithmetic programs (QAP), which represent <em>arithmetic</em> circuits, whose inputs are elements from a finite field <span class="math">\\mathbb{F}</span> and whose gates add or multiply <span class="math">\\mathbb{F}</span> elements. QAPs are preferred in practice due to their greater efficiency. As circuit satisfiability is NP-complete, SNARKs exist for all NP languages.</p>

    <p class="text-gray-300">Parno, Howell, Gentry and Raykova <em>[x22]</em> improved on <em>[x12]</em>, making the conversion from circuits to QAPs more efficient and reducing the proof size by one group element. They implemented their scheme and named it “Pinocchio”. Ben-Sasson et al. <em>[BCG^{+}13, x2]</em> improve the conversion of actual program code to QAPs, reduce the size of SNARK parameters and implement their results as <em>libsnark</em> <em>[BCG^{+}14b]</em>. The size of SNARK proofs for boolean circuits was then further reduced by Danezis, Fournet, Groth and Kohlweiss <em>[x10]</em>, who modified QSP to <em>square</em> span programs (SSP) and built a system for them whose proofs consist of only 4 group elements.</p>

    <p class="text-gray-300">Recently, Groth <em>[x14]</em> presented the most efficient SNARK construction to date, which is for arithmetic circuits and whose proofs consist of only 3 group elements (and require 3 pairings to verify). All previous bilinear-group-based SNARKs are proven under strong cryptographic assumptions (<em>knowledge</em> assumptions), for which there is evidence that they might be unavoidable <em>[x15, x3]</em>. Starting from Bitansky et al.’s <em>[BCI^{+}13]</em> <em>linear interactive proof</em> framework, Groth <em>[x14]</em> achieves his result by proving security directly in the generic-group model <em>[x23]</em> (which implies all previously considered assumptions).</p>

    <p class="text-gray-300">He also shows that SNARKs over asymmetric bilinear groups must contain elements from both source groups, meaning that the proof size of his construction is only one element short of the optimal size. Recently, Fuchsbauer, Kiltz and Loss <em>[x11]</em> proved Groth’s scheme secure under a “<span class="math">q</span>-type” variant of the discrete log assumption in the <em>algebraic group model</em>. In this model adversaries can only output group elements if they were obtained by applying the group operation to previously received group elements.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Subversion-resistance.</h4>

    <p class="text-gray-300">The Snowden revelations documented the NSA’s efforts to subvert standards, for which an illustrative example is the NSA-designed and ISO-standardized Dual EC random number generator. Its parameters include two elliptic-curve points, whose respective discrete logarithms can act as a backdoor that can be exploited to break TLS <em>[CNE+14]</em>. NIZK systems are particularly prone to parameter subversion, since their CRS must be subvertible by design: zero knowledge requires that an honest CRS is indistinguishable from a backdoored CRS, where the backdoor is the trapdoor used to simulate proofs. For SNARKs the parameters always contain a backdoor and anyone knowing it can simulate proofs for false statements, which means breaking soundness.</p>

    <p class="text-gray-300">Motivated by this, Bellare, Fuchsbauer and Scafuro <em>[x1]</em> ask what security can be maintained for NIZKs when its trusted parameters are subverted. They formalize different notions of resistance to CRS subversion and investigate their achievability. They define subversion soundness (S-SND), meaning that no adversary can generate a (malicious) CRS together with a valid proof <span class="math">\\pi</span> for a false statement <span class="math">x</span>.</p>

    <p class="text-gray-300">They also give a subversion-resistant analogue for zero knowledge. Recall that ZK assumes that there exists a CRS simulator Sim.crs, which returns a simulated CRS crs^{′} and an associated simulation trapdoor <span class="math">td</span>, and a proof simulator Sim.pf that outputs proofs on input a valid instance <span class="math">x</span> and <span class="math">td</span>, such that no efficient adversary can distinguish the following: being given crs^{′} and an oracle implementing Sim.pf, or an honest crs and an oracle returning honestly computed proofs. Subversion ZK (S-ZK) requires that for any adversary X creating a malicious CRS crs in any way it likes using randomness (coins) <span class="math">r</span>, there exists a simulator Sim_{X}.crs returning a simulated CRS crs^{′} with trapdoor <span class="math">td</span> together with simulated coins <span class="math">r^{\\prime}</span>, as well as a proof simulator Sim_{X}.pf, such that no adversary can distinguish the following: being given crs^{′} and <span class="math">r^{\\prime}</span> and a Sim_{X}.pf oracle, or a crs output by X, together with the used coins <span class="math">r</span> and an honest proof oracle. The authors also define a subversion-resistant notion (S-WI) of witness-indistinguishability <em>[x10]</em> (see Sections 2.3 and 2.4).</p>

    <p class="text-gray-300">Following <em>[x12]</em>, Bellare et al. <em>[x1]</em> first show that S-SND cannot be achieved together with (standard) ZK for non-trivial languages (for trivial ones the verifier needs no proof to check validity of statements). This is because ZK allows breaking soundness by subverting the CRS. They then show that S-SND can be achieved together with S-WI. Their main result is a construction that achieves both S-ZK (and thus S-WI) and SND.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">BFS’s S-ZK scheme.</h4>

    <p class="text-gray-300">To achieve S-ZK, a simulator must be able to simulate proofs under a CRS output by a subvertor, so it cannot simply embed a trapdoor as in standard ZK. Bellare et al. <em>[x1]</em> base S-ZK on a knowledge assumption, which is the type of assumption on which security (in particular, knowledge soundness) of SNARKs relies. It states that an algorithm can only produce an output of a certain form if it knows some underlying information. This is formalized by requiring the existence of an extractor that extracts this information from the algorithm. In their scheme this information acts as the simulation trapdoor, which under their knowledge assumption can be obtained from a subvertor outputting a CRS.</p>

    <p class="text-gray-300">Concretely, they assume that for a bilinear group <span class="math">(\\mathbb{G},+)</span> with a generator <span class="math">P</span> any algorithm that outputs a Diffie-Hellman tuple <span class="math">(P,s_{1}P,s_{2}P,s_{1}s_{2}P)</span> for some <span class="math">s_{1},s_{2}</span>, must know either <span class="math">s_{1}</span> or <span class="math">s_{2}</span>. They call their assumption Diffie-Hellman knowledge-of-exponent assumption (DH-KEA) and note that a tuple <span class="math">(P,S_{1},S_{2},S_{3})</span> of this form can be verified via a (symmetric) bilinear map <span class="math">\\mathbf{e}</span> by checking <span class="math">\\mathbf{e}(S_{3},P)=\\mathbf{e}(S_{1},S_{2})</span>. A question that arises is: who chooses the group <span class="math">\\mathbb{G}</span> in their scheme? Bellare et al. address this by making the group <span class="math">\\mathbb{G}</span> part of the scheme specification. This begs the question whether the subversion risk has not simply been shifted from the CRS to the choice of the group. They argue that the group generation algorithm is deterministic and public, so users can create the group themselves, and it is thus reproducible, whereas the CRS is inherently not.</p>

    <p class="text-gray-300">Parameter setup in practice.</p>

    <p class="text-gray-300">A way to avoid the problem of generating a trusted CRS for NIZK systems is by proving its security in the <em>random-oracle model</em> (ROM) <em>[x10]</em>. Instead of a CRS, all parties are assumed to have access to a truly random function (which is modeled as an oracle returning random values). In practice the random oracle is replaced by a cryptographic hash function and a proof in the ROM can be viewed as a security heuristic for the resulting scheme.</p>

    <p class="text-gray-300">For NIZK systems whose CRS is a uniform random string, e.g. PCP-based constructions like <em>[BSBC^{+}17]</em> recently, one can in practice set the CRS to a common random-looking public value such as the digits of <span class="math">\\pi</span> or the output of a standardized hash function on a fixed input. This intuitively guarantees that no one has embedded a trapdoor. For the Groth-Sahai proof system <em>[x15]</em> the CRS consists of random elements of an elliptic-curve group; they can be set up by hashing a common random string directly into the elliptic curve <em>[x3, BCI^{+}10]</em>.</p>

    <p class="text-gray-300">For practical SNARKs the situation is different: there are no CRS-less constructions in the random-oracle model and the CRS is highly structured. The parameters typically contain elements of the form <span class="math">(P,\\tau P,\\tau^{2}P)</span>, where <span class="math">P</span> is a generator of a group <span class="math">\\mathbb{G}</span> and <span class="math">\\tau</span> is a random value. Soundness completely breaks down if the value <span class="math">\\tau</span> is known to anyone. Unfortunately, there is no known way of creating such a triple obliviously, that is, without knowing the value <span class="math">\\tau</span>.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Our techniques.</h4>

    <p class="text-gray-300">In order to show subversion zero knowledge of SNARK schemes, we assume that computing elements <span class="math">(P,\\tau P,\\tau^{2}P)</span> cannot be done without knowing <span class="math">\\tau</span>. (Looking ahead, we actually make a weaker assumption in asymmetric bilinear groups by requiring the adversary to return <span class="math">(P_{1},\\tau P_{1},\\tau^{2}P_{1})\\in\\mathbb{G}_{1}^{3}</span> as well as <span class="math">(P_{2},\\tau P_{2})\\in\\mathbb{G}_{2}^{2}</span>, which makes the structure of the triple verifiable using the bilinear map.) Under this assumption, which we call square knowledge of exponent (SKE) assumption (Definition 2.14), we then prove subversion ZK of five relevant SNARK constructions from the literature or slight variants of them.</p>

    <p class="text-gray-300">As an additional sanity check, we prove that SKE holds in the generic group model (Theorem 2.16). Following Groth <em>[x16]</em>, we assume that the bilinear group description is part of the specification of the language for which the proof system is defined (and not part of the CRS as in <em>[x4]</em>). Following his previous work <em>[x12]</em>, we let the CRS generation algorithm sample <em>random</em> group generators (in contrast to <em>[x4]</em>, which assumes a fixed group generator). This intuitively leads to weaker assumptions required to prove soundness.</p>

    <p class="text-gray-300">To show subversion zero knowledge of existing SNARK schemes, we proceed as follows. Standard zero knowledge holds because the randomness used to compute the CRS allows the simulator to produce proofs that are distributed equivalently to honestly generated proofs under the (honestly computed) CRS. However, for S-ZK this must hold even for a CRS that was computed in any arbitrary way. While we cannot guarantee that the CRS subvertor used random values when computing the CRS, we first show how to verify that the <em>structure</em> of the CRS is as prescribed. (For the asymmetric Pinocchio scheme <em>[x5]</em> this requires us to extend the CRS slightly.)</p>

    <p class="text-gray-300">Another difference between standard and subversion ZK is that in the former the simulator creates the CRS and thus knows the simulation trapdoor, whereas for S-ZK the CRS is produced by the subvertor, so it might not be clear how proofs can be simulated at all. Now if the CRS contains elements <span class="math">(P,\\tau P,\\tau^{2}P)</span>, whose correct structure can be verified via the pairing, then under our SKE assumption we can extract the value <span class="math">\\tau</span>. SKE thus allows the simulator to obtain parts of the randomness even from a maliciously generated CRS. Unfortunately, the simulation trapdoor typically contains <em>other</em> values that the S-ZK simulator cannot extract.</p>

    <p class="text-gray-300">Our next step is then to demonstrate that proofs can be simulated using <span class="math">\\tau</span> only, or to show how under our assumption more values can be extracted that then enable simulation. Our final step is to show that if a CRS passes the verification procedure we define, then proofs that were simulated using the partial trapdoor are distributed like real proofs. This shows that the analyzed scheme</p>

    <p class="text-gray-300">is S-ZK under our SKE assumption. While knowledge assumptions are strong assumptions, they seem unavoidable since S-ZK implies 2-move interactive ZK by letting the verifier create the CRS. And such schemes require extractability assumptions <em>[x1]</em>.</p>

    <p class="text-gray-300">Since simulated proofs are by definition independent of a witness, our results imply that under a verified, but possibly malicious, CRS, proofs for different witnesses are equally distributed. As a corollary we thereby obtain that all SNARKs we consider satisfy subversion witness indistinguishability <em>unconditionally</em> (i.e., no assumptions required).</p>

    <p class="text-gray-300">We note that Ben-Sasson et al. <em>[BCG^{+}15]</em> also consider making a CRS verifiable. Their goal is to protect <em>soundness</em> against subversion by sampling the secret values underlying a CRS in a distributed way. Only if all participants in the CRS-creation protocol collude can they break soundness. To guarantee a correctly distributed CRS, the participant(s) must prove adherence to the protocol via NIZK proofs <em>[x29, x15]</em> secure in the random-oracle model. The protocol thus returns <em>verifiable</em> SNARK parameters. The parameters used for Zcash were set up using this multiparty protocol, which was recently detailed by Bowe, Gabizon and Green <em>[x2]</em>.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">Our Results</h3>

    <p class="text-gray-300">As already discussed, SNARKs are not subversion-sound because their CRS contains the simulation trapdoor. In this work we look at subversion resistance of their zero-knowledge property and investigate several SNARK constructions from the literature that are based on bilinear groups. In particular,</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the first QSP-based and 2. QAP-based constructions <em>[x12]</em>;</li>

      <li>optimized Pinocchio <em>[x3]</em> as implemented in libsnark <em>[BCG^{+}14b]</em>; and</li>

      <li>and 5. the two most efficient (SSP- and QAP-based) constructions by Groth et al. <em>[x10, x13]</em>.</li>

    </ol>

    <p class="text-gray-300">We make the (reasonable) assumption that a privacy-conscious prover (whose protection is the goal of zero knowledge) first checks whether the CRS looks plausible (to whatever extent this is possible) before publishing a proof with respect to it. All of our results implicitly make this assumption.</p>

    <p class="text-gray-300">We start with the first SNARK construction for QAPs by Gennaro, Gentry, Parno and Raykova <em>[x12]</em> and show how to verify that the CRS is correctly formed. We then show that under the square knowledge of exponent (SKE) assumption their construction satisfies subversion zero knowledge as defined in <em>[x5]</em>. The same holds for their QSP-based SNARK.</p>

    <p class="text-gray-300">We next turn to the optimized version of Pinocchio over asymmetric bilinear groups due to Ben-Sasson, Chiesa, Tromer and Virza <em>[x3]</em>. For this construction we show that adding 4 group elements to the CRS makes it efficiently checkable. We then prove that the scheme with this slightly extended CRS satisfies subversion zero knowledge under SKE, whereas the original scheme, which is implemented in libsnark <em>[BCG^{+}14b]</em>, succumbs to a parameter-subversion attack <em>[x11]</em>. For the SNARK by Danezis, Fournet, Groth and Kohlweiss <em>[x10]</em>, we show that CRS well-formedness can be efficiently verified without modifying the CRS and that S-ZK holds analogously to Pinocchio.</p>

    <p class="text-gray-300">Finally, we consider the most efficient SNARK scheme by Groth <em>[x13]</em> and again show that the scheme is <em>already</em> subversion-zero-knowledge under SKE. Proving this is more involved than for the previous schemes, since the value <span class="math">\\tau</span>, for which <span class="math">P,\\tau P,\\tau^{2}P,\\ldots</span> are contained in the CRS does not suffice to simulate proofs, as for the previous schemes. We show that, using SKE twice, another value can be extracted, which together with <span class="math">\\tau</span> then enables proof simulation. As corollaries, we get that S-WI holds unconditionally for all considered schemes.</p>

    <p class="text-gray-300">Concurrent work. Campanelli, Gennaro, Goldfeder and Nizzardo <em>[x10]</em> show that Pinocchio as implemented in libsnark <em>[BCG^{+}14b]</em> is not subversion-zero-knowledge by exhibiting an attack. As countermeasures they propose to instead use one of the older SNARKs by Gennaro et al. <em>[x14]</em>, as they allow verification of CRS well-formedness, which yields witness indistinguishability. They admit that for applications for which there is only <em>one</em> witness, like selling a Sudoku solution, WI is vacuous (as any protocol satisfies WI).</p>

    <p class="text-gray-300">They refer to Bellare et al.’s <em>[x12]</em> S-ZK system and conjecture that “the techniques extend to the original QSP/QAP protocol in <em>[x14]</em>” (which we proved rigorously). Moreover, “[i]t is however not clear if those techniques extend to Pinocchio” and “it would require major changes in the current implementation of ZKCP protocols”. (We show that it suffices to add 4 group elements to the CRS and perform the checks of well-formedness.) They recommend following the Zcash approach <em>[BCG^{+}15, x2]</em> and using an interactive protocol that lets the prover and verifier compute the CRS together.</p>

    <p class="text-gray-300">In other concurrent work Abdolmaleki, Baghery, Lipmaa and Zajac <em>[x1]</em> present a S-ZK variant of Groth’s SNARK <em>[x16]</em>. They need to modify the scheme, thereby reducing efficiency, and they prove their result under a stronger assumption. In particular, they extend the CRS by <span class="math">2d</span> group elements (where <span class="math">d</span> is the number of multiplication gates in the circuit that represents the relation). Their assumption states that any adversary that for generators <span class="math">P_{1}\\in\\mathbb{G}_{1}^{<em>}</span> and <span class="math">P_{2}\\in\\mathbb{G}_{2}^{</em>}</span> outputs a pair of the form <span class="math">(sP_{1},sP_{2})</span> must know <span class="math">s</span>. As they note, their assumption is false in groups with a symmetric (“Type-1”) bilinear map as well as in asymmetric groups of Type 2, whereas our SKE assumption holds generically in all bilinear group settings. They claim security of their scheme under their own definition of S-ZK, which is a statistical notion, in contrast to original computational S-ZK notion <em>[x12]</em>, which we consider.</p>

    <p class="text-gray-300">Practical implications of our results. We show that for all analyzed schemes except asymmetric Pinocchio, it suffices to verify the parameters once in order to guarantee subversion zero knowledge. Any already deployed parameters can thus be continued to be used after verification. Subversion-ZK of Pinocchio can be obtained by adding 4 group elements to the CRS.</p>

    <p class="text-gray-300">For Pinocchio-based ZK contingent payments this means that the scheme can be made secure by slightly augmenting the size of the parameters and having the seller verify them. No additional interaction between seller and buyer (as recommended by Campanelli et al. <em>[x10]</em>) is thus required. Of course, admitting additional interaction could lead to more efficient schemes than using the (costly) CRS verification.</p>

    <p class="text-gray-300">The SNARK parameters used in Zcash have been computed by running the multi-party protocol from <em>[BCG^{+}15, x2]</em> and verifiability of this process is achieved via random-oracle NIZK proofs. Let us define a CRS subvertor that runs this protocol, playing the roles of all parties, and outputs the resulting CRS which includes the ROM proofs. Since the latter guarantee well-formedness of the CRS, under SKE there exists an efficient extractor that can extract the simulation trapdoor from this CRS subvertor. Using the trapdoor, proofs can be simulated (as specified in Section 5). We thus conclude that, assuming users verify the consistency of the CRS, Zcash provides a subversion-resistant form of anonymity in the random-oracle model under the SKE assumption with respect to the bilinear group used by Zcash. Thus, even if all parties involved in creating the parameters were malicious, Zcash is still anonymous.</p>

    <p class="text-gray-300">We content ourselves with the above argument, as a formal proof would be beyond the scope</p>

    <p class="text-gray-300">of this paper. Subsequently to our results Bowe et al. <em>[x1]</em> proved that their protocol is S-ZK with a polynomially small (not negligible) simulation error in the random-oracle model without making knowledge assumptions.</p>

    <h2 id="sec-9" class="text-2xl font-bold">2 Definitions</h2>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">2.1 Notation</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">x</span> is a (binary) string then $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is its length. If </span>S<span class="math"> is a finite set then </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denotes its size and </span>s\\leftarrow\\mathbin{\\mathchar 22\\relax}S<span class="math"> denotes picking an element uniformly from </span>S<span class="math"> and assigning it to </span>s<span class="math">. We denote by </span>\\lambda\\in\\mathbb{N}<span class="math"> the security parameter and by </span>1^{\\lambda}$ its unary representation.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Algorithms are randomized unless otherwise indicated. “PT” stands for “polynomial time”, whether for randomized or deterministic algorithms. By <span class="math">y\\leftarrow A(x_{1},\\ldots;r)</span> we denote the operation of running algorithm <span class="math">A</span> on inputs <span class="math">x_{1},\\ldots</span> and coins <span class="math">r</span> and letting <span class="math">y</span> denote the output. By <span class="math">y\\leftarrow\\mathbin{\\mathchar 22\\relax}A(x_{1},\\ldots)</span>, we denote letting <span class="math">y\\leftarrow A(x_{1},\\ldots;r)</span> for random <span class="math">r</span>. We denote by <span class="math">[A(x_{1},\\ldots)]</span> the set of points that have positive probability of being output by <span class="math">A</span> on inputs <span class="math">x_{1},\\ldots</span></p>

    <p class="text-gray-300">For our security definitions we use the code-based game playing framework <em>[x2]</em>. A game G (e.g. Figure 1) usually depends on a scheme and executes one or more adversaries. It defines oracles for the adversaries as procedures. The game eventually returns a boolean. We let <span class="math">\\Pr[\\text{G}]</span> denote the probability that G returns true.</p>

    <p class="text-gray-300">We recall the standard notions of soundness, knowledge-soundness, witness-indistinguishability and zero knowledge for NIZKs, which assume the CRS is trusted and then give their subversion-resistant counterparts that were introduced in <em>[x3]</em>. We mainly follow their exposition and start with the syntax.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">2.2 NP Relations and NI Systems</h3>

    <h5 id="sec-12" class="text-base font-semibold mt-4">NP relations.</h5>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider <span class="math">R\\colon\\{0,1\\}^{<em>}\\times\\{0,1\\}^{</em>}\\to\\{\\textsf{true},\\textsf{false}\\}</span>. For <span class="math">x\\in\\{0,1\\}^{*}</span> we let $R(x)=\\{\\,w\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,R(x,w)=\\textsf{true}\\,\\}<span class="math"> be the <em>witness set</em> of </span>x<span class="math">. </span>R<span class="math"> is an NP relation if it is PT and there is a polynomial </span>P_{R}<span class="math"> such that every </span>w<span class="math"> in </span>R(x)<span class="math"> has length at most </span>P_{R}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> for all </span>x<span class="math">. We let </span>L(R)=\\{\\,x\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,R(x)\\neq\\emptyset\\,\\}<span class="math"> be the <em>language</em> associated to </span>R<span class="math">. We will consider relations output by a PT <em>relation generator</em> </span>\\mathsf{Rg}<span class="math"> (which may also output some auxiliary information </span>z<span class="math"> that is given to the adversary). We assume </span>\\lambda<span class="math"> can be deduced from </span>R\\in[\\mathsf{Rg}(1^{\\lambda})]<span class="math"> and note that definitions from <em>[x3]</em>, which are for one <em>fixed</em> relation </span>R<span class="math">, are easily recovered by defining </span>\\mathsf{Rg}(1^{\\lambda}):=(1^{\\lambda},R)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h5 id="sec-13" class="text-base font-semibold mt-4">NI systems.</h5>

    <p class="text-gray-300">A non-interactive (NI) system <span class="math">\\mathsf{\\Pi}</span> for relation generator <span class="math">\\mathsf{Rg}</span> specifies the following PT algorithms. Via <span class="math">\\textsf{crs}\\leftarrow\\mathbin{\\mathchar 22\\relax}\\mathsf{\\Pi}.\\mathsf{Pg}(R)</span> one generates a common reference string <span class="math">\\textsf{crs}</span>. Via <span class="math">\\pi\\leftarrow\\mathbin{\\mathchar 22\\relax}\\mathsf{\\Pi}.\\mathsf{P}(R,\\textsf{crs},x,w)</span> the honest prover, given <span class="math">x</span> and <span class="math">w\\in R(x)</span>, generates a proof <span class="math">\\pi</span> that <span class="math">x\\in L(R)</span>. Via <span class="math">d\\leftarrow\\mathsf{\\Pi}.\\mathsf{V}(R,\\textsf{crs},x,\\pi)</span> a verifier can produce a decision <span class="math">d\\in\\{\\textsf{true},\\textsf{false}\\}</span> indicating whether <span class="math">\\pi</span> is a valid proof that <span class="math">x\\in L(R)</span>. We require (perfect) completeness, that is, for all <span class="math">\\lambda\\in\\mathbb{N}</span>, all <span class="math">R\\in[\\mathsf{Rg}(1^{\\lambda})]</span>, all <span class="math">\\textsf{crs}\\in[\\mathsf{\\Pi}.\\mathsf{Pg}(R)]</span>, all <span class="math">x\\in L(R)</span>, all <span class="math">w\\in R(x)</span> and all <span class="math">\\pi\\in[\\mathsf{\\Pi}.\\mathsf{P}(R,\\textsf{crs},x,w)]</span> we have <span class="math">\\mathsf{\\Pi}.\\mathsf{V}(R,\\textsf{crs},x,\\pi)=\\textsf{true}</span>. We also assume that <span class="math">\\mathsf{\\Pi}.\\mathsf{V}</span> returns false if any of its arguments is <span class="math">\\bot</span>.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">2.3 Standard Notions: SND, KSND, WI and ZK</h3>

    <h5 id="sec-15" class="text-base font-semibold mt-4">Soundness.</h5>

    <p class="text-gray-300">Soundness means that it is hard to create a valid proof for any <span class="math">x\\not\\in L(R)</span>. We consider computational soundness as opposed to a statistical one, which is usually sufficient for applications, and which is the notion achieved by SNARGs.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Definition 2.1 (SND)</h6>

    <p class="text-gray-300">An NI system <span class="math">\\mathsf{\\Pi}</span> for relation generator <span class="math">\\mathsf{Rg}</span> is <em>sound</em> if <span class="math">\\mathbf{Adv}_{\\mathsf{\\Pi},\\mathsf{Rg},\\mathsf{A}}^{\\mathrm{and}}(\\cdot)</span> is negligible for all PT adversaries <span class="math">\\mathsf{A}</span>, where <span class="math">\\mathbf{Adv}_{\\mathsf{\\Pi},\\mathsf{Rg},\\mathsf{A}}^{\\mathrm{and}}(\\lambda)=\\Pr[\\mathrm{SND}_{\\mathsf{\\Pi},\\mathsf{Rg},\\mathsf{A}}(\\lambda)]</span> and game <em>SND</em> is specified in Figure 1.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">Knowledge soundness.</h4>

    <p class="text-gray-300">This strengthening of soundness <em>[x1]</em> means that a prover that outputs a valid proof must know the witness. Formally, there exists an extractor that can extract the witness from the prover. The notion implies soundness, since for a proof of a wrong statement there exists no witness.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Definition 2.2 (KSND)</h6>

    <p class="text-gray-300">An NI system <span class="math">\\mathsf{\\Pi}</span> for relation generator <span class="math">\\mathsf{Rg}</span> is <em>knowledge-sound</em> if for all PT adversaries <span class="math">\\mathsf{A}</span> there exists a PT extractor <span class="math">\\mathsf{E}</span> such that <span class="math">\\mathbf{Adv}_{\\mathsf{\\Pi},\\mathsf{Rg},\\mathsf{A},\\mathsf{E}}^{\\mathrm{ksnd}}(\\cdot)</span> is negligible, where <span class="math">\\mathbf{Adv}_{\\mathsf{\\Pi},\\mathsf{Rg},\\mathsf{A},\\mathsf{E}}^{\\mathrm{ksnd}}(\\lambda)=\\Pr[\\mathrm{KSND}_{\\mathsf{\\Pi},\\mathsf{Rg},\\mathsf{A},\\mathsf{E}}(\\lambda)]</span> and game <em>KSND</em> is specified in Figure 1.</p>

    <p class="text-gray-300">Note that (as for the following two notions) the output of game KSND is <em>efficiently computable</em>, which is not the case for SND, since membership in <span class="math">L(R)</span> may not be efficiently decidable. This can be an issue when proving security of more complex systems that use a system <span class="math">\\mathsf{\\Pi}</span> as a building block.</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">WI.</h4>

    <p class="text-gray-300">Witness-indistinguishability <em>[x10]</em> requires that proofs for the same statement using different witnesses are indistinguishable. The adversary can adaptively request multiple proofs for statements <span class="math">x</span> under one of two witnesses <span class="math">w_{0},w_{1}</span>; it receives proofs under <span class="math">w_{b}</span> for a challenge bit <span class="math">b</span> which it must guess.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Definition 2.3 (WI)</h6>

    <p class="text-gray-300">An NI system <span class="math">\\mathsf{\\Pi}</span> for <span class="math">\\mathsf{Rg}</span> is <em>witness-indistinguishable</em> if <span class="math">\\mathbf{Adv}_{\\mathsf{\\Pi},\\mathsf{Rg},\\mathsf{A}}^{\\mathrm{wi}}(\\cdot)</span> is negligible for all PT adversaries <span class="math">\\mathsf{A}</span>, where <span class="math">\\mathbf{Adv}_{\\mathsf{\\Pi},\\mathsf{Rg},\\mathsf{A}}^{\\mathrm{wi}}(\\lambda)=2\\Pr[\\mathrm{WI}_{\\mathsf{\\Pi},\\mathsf{Rg},\\mathsf{A}}(\\lambda)]-1</span> and game <em>WI</em> is specified in Figure 1.</p>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">ZK.</h4>

    <p class="text-gray-300">Zero knowledge <em>[x12]</em> means that no information apart from the fact that <span class="math">x\\in L(R)</span> is leaked by the proof. It is formalized by requiring that a simulator, who can create the CRS, can compute proofs without being given a witness, so that CRS and proofs are indistinguishable from real ones. In particular, the distinguisher <span class="math">\\mathsf{A}</span> can adaptively request proofs by supplying an instance and a valid witness for it. The proof is produced either by the honest prover using the witness, or by the simulator. The adversary outputs a guess <span class="math">b^{\\prime}</span> as to whether the proofs were real or simulated.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Definition 2.4 (ZK)</h6>

    <p class="text-gray-300">An NI system <span class="math">\\mathsf{\\Pi}</span> for <span class="math">\\mathsf{Rg}</span> is <em>zero-knowledge</em> if <span class="math">\\mathsf{\\Pi}</span> specifies additional PT algorithms <span class="math">\\mathsf{\\Pi}.\\mathsf{Sim.crs}</span> and <span class="math">\\mathsf{\\Pi}.\\mathsf{Sim.pf}</span> such that <span class="math">\\mathbf{Adv}_{\\mathsf{\\Pi},\\mathsf{Rg},\\mathsf{A}}^{\\mathrm{zk}}(\\cdot)</span> is negligible for all PT adversaries <span class="math">\\mathsf{A}</span>, where <span class="math">\\mathbf{Adv}_{\\mathsf{\\Pi},\\mathsf{Rg},\\mathsf{A}}^{\\mathrm{sk}}(\\lambda)=2\\Pr[\\mathrm{ZK}_{\\mathsf{\\Pi},\\mathsf{Rg},\\mathsf{A}}(\\lambda)]-1</span> and game <em>ZK</em> is specified in Figure 1.</p>

    <p class="text-gray-300">An NI system <span class="math">\\mathsf{\\Pi}</span> is <em>statistical</em> zero-knowledge if the above holds for all (not necessarily PT) adversaries <span class="math">\\mathsf{A}</span>. It is <em>perfect</em> zero-knowledge if <span class="math">\\mathbf{Adv}_{\\mathsf{\\Pi},\\mathsf{Rg},\\mathsf{A}}^{\\mathrm{zk}}(\\cdot)\\equiv 0</span>.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">2.4 Notions for Subverted CRS: S-SND, S-KSND, S-WI and S-ZK</h3>

    <p class="text-gray-300">For all notions considered in the previous section the CRS is assumed to be honestly generated. Bellare et al. <em>[x3]</em> ask what happens when the CRS is maliciously generated and define subversion-resistant analogues S-SND, S-WI and S-ZK, in which the adversary chooses the CRS. The following three definitions are from <em>[x3]</em>.</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">Subversion soundness.</h4>

    <p class="text-gray-300">Subversion soundness asks that if the adversary creates a CRS in any way it likes, it is still unable to prove false statements under it. We accordingly modify the soundness game SND by letting the adversary choose crs in addition to <span class="math">x</span> and <span class="math">\\pi</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">GAME SNDΠ,Rg,A(λ) R←<em>Rg(1λ) crs←</em>Π.Pg(R) (x,π)←*A(R, crs) Return (x∉L(R) and Π.V(R, crs, x, π))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">GAME S-SNDΠ,Rg,A(λ) R←<em>Rg(R) (crs, x, π)←</em>A(R) Return (x∉L(R) and Π.V(R, crs, x, π))</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">GAME KSNDΠ,Rg,A,E(λ) R←<em>Rg(1λ) crs←</em>Π.Pg(R); r←<em>{0,1}A.rl(λ) (x,π)←A(R, crs; r) w←</em>E(R, crs, r) Return (R(x, w) = false and Π.V(R, crs, x, π))</td>

            <td class="px-3 py-2 border-b border-gray-700">GAME S-KSNDΠ,Rg,A,E(λ) R←<em>Rg(1λ) r←</em>{0,1}A.rl(λ) (crs, x, π)←A(R; r) w←*E(R, r) Return (R(x, w) = false and Π.V(R, crs, x, π))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">GAME WIΠ,Rg,A(λ) b←<em>{0,1}; R←</em>Rg(1λ) crs←<em>Π.Pg(R) b'←</em>AProve(R, crs) Return (b = b') PROVE(x, w0, w1) If R(x, w0) = false or R(x, w1) = false then return ⊥ π←*Π.P(R, crs, x, wb) Return π</td>

            <td class="px-3 py-2 border-b border-gray-700">GAME S-WIΠ,Rg,A(λ) b←<em>{0,1}; R←</em>Rg(1λ) (crs, st)←<em>A(R) b'←</em>AProve(R, crs, st) Return (b = b') PROVE(x, w0, w1) If R(x, w0) = false or R(x, w1) = false then return ⊥ π←*Π.P(R, crs, x, wb) Return π</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">GAME ZKΠ,Rg,A(λ) b←<em>{0,1}; R←</em>Rg(1λ) crs1←<em>Π.Pg(R) (crs0, td)←</em>Π.Sim.crs(R) b'←<em>AProve(R, crsb) Return (b = b') PROVE(x, w) If R(x, w) = false then return ⊥ If b = 1 then π←</em>Π.P(R, crs1, x, w) Else π←*Π.Sim.pf(R, crs0, td, x) Return π</td>

            <td class="px-3 py-2 border-b border-gray-700">GAME S-ZKΠ,Rg,X,S,A(λ) b←<em>{0,1}; R←</em>Rg(1λ) r1←<em>{0,1}X.rl(λ); crs1←X(R; r1) (crs0, r0, td)←</em>S.crs(R) b'←<em>AProve(R, crsb, rb) Return (b = b') PROVE(x, w) If R(x, w) = false then return ⊥ If b = 1 then π←</em>Π.P(R, crs1, x, w) Else π←*S.pf(R, crs0, td, x) Return π</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 1: Games defining soundness, knowledge-soundness, witness-indistinguishability and zero knowledge (left) and their subversion-resistant counterparts (right) for an NI system  <span class="math">\\Pi</span> .</p>

    <p class="text-gray-300">Definition 2.5 (S-SND) An  <span class="math">NI</span>  system  <span class="math">\\Pi</span>  for generator  <span class="math">\\mathsf{Rg}</span>  is subversion-sound if  <span class="math">\\mathbf{Adv}_{\\Pi, \\mathsf{Rg}, \\mathsf{A}}^{\\mathrm{s - snd}}(\\cdot)</span>  is negligible for all  <span class="math">PT</span>  adversaries  <span class="math">\\mathsf{A}</span> , where  <span class="math">\\mathbf{Adv}_{\\Pi, \\mathsf{Rg}, \\mathsf{A}}^{\\mathrm{s - snd}}(\\lambda) = \\operatorname*{Pr}[\\mathrm{S - SND}_{\\Pi, \\mathsf{Rg}, \\mathsf{A}}(\\lambda)]</span>  and game S-SND is specified in Figure 1.</p>

    <p class="text-gray-300">Subversion WI. Subversion WI demands that even when the subvertor creates a CRS in any way it likes, it can still not decide which of two witnesses of its choice were used to create a proof. The adversary is modeled as a two-stage algorithm: it first outputs a CRS crs along with state information (which could e.g. contain a trapdoor associated to crs) passed to the second stage. The second stage is then defined like for the honest-CRS game WI, where via its Prove oracle, the adversary can adaptively query proofs for instances under one of two witnesses.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Definition 2.6 (S-WI)</h6>

    <p class="text-gray-300">An NI system <span class="math">\\mathsf{\\Pi}</span> for generator <span class="math">\\mathsf{Rg}</span> is <em>subversion-witness-indistinguishable</em> if <span class="math">\\mathbf{Adv}^{\\text{s-wi}}_{\\mathsf{\\Pi},\\mathsf{Rg},\\mathsf{A}}(\\cdot)</span> is negligible for all PT adversaries <span class="math">\\mathsf{A}</span>, where <span class="math">\\mathbf{Adv}^{\\text{s-wi}}_{\\mathsf{\\Pi},\\mathsf{Rg},\\mathsf{A}}(\\lambda)=2\\operatorname<em>{Pr}[\\text{S-WI}_{\\mathsf{\\Pi},\\mathsf{Rg},\\mathsf{A}}(\\lambda)]-1</span> and game </em>S-WI<em> is specified in Figure 1. An NI system <span class="math">\\mathsf{\\Pi}</span> is </em>perfect* S-WI if <span class="math">\\mathbf{Adv}^{\\text{s-wi}}_{\\mathsf{\\Pi},\\mathsf{Rg},\\mathsf{A}}(\\cdot)\\equiv 0</span>.</p>

    <p class="text-gray-300">Subversion ZK. This notion considers a CRS subvertor <span class="math">\\mathsf{X}</span> that returns an arbitrarily formed CRS. Subversion ZK now asks that for any such <span class="math">\\mathsf{X}</span> there exists a simulator that is able to simulate (1) the full view of the CRS subvertor, <em>including its coins</em>, and (2) proofs for adaptively chosen instances without knowing the witnesses. The simulator consists of <span class="math">\\mathsf{S.crs}</span>, which returns a CRS, coins for <span class="math">\\mathsf{X}</span> and a trapdoor which is then used by its second stage <span class="math">\\mathsf{S.pf}</span> to simulate proofs. The adversary’s task is to decide whether it is given a real CRS and the coins used to produce it, and real proofs (case <span class="math">b=1</span>); or whether it is given a simulated CRS and coins, and simulated proofs (case <span class="math">b=0</span>).</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Definition 2.7 (S-ZK)</h6>

    <p class="text-gray-300">An NI system <span class="math">\\mathsf{\\Pi}</span> for generator <span class="math">\\mathsf{Rg}</span> is <em>subversion-zero-knowledge</em> if for all PT CRS subvertors <span class="math">\\mathsf{X}</span> there exists a PT simulator <span class="math">\\mathsf{S}=(\\mathsf{S.crs},\\mathsf{S.pf})</span> such that for all PT adversaries <span class="math">\\mathsf{A}</span> the function <span class="math">\\mathbf{Adv}^{\\text{s-zk}}_{\\mathsf{\\Pi},\\mathsf{Rg},\\mathsf{X},\\mathsf{S},\\mathsf{A}}(\\cdot)</span> is negligible, where <span class="math">\\mathbf{Adv}^{\\text{s-zk}}_{\\mathsf{\\Pi},\\mathsf{Rg},\\mathsf{X},\\mathsf{S},\\mathsf{A}}(\\lambda)=2\\operatorname<em>{Pr}[\\text{S-ZK}_{\\mathsf{\\Pi},\\mathsf{Rg},\\mathsf{X},\\mathsf{S},\\mathsf{A}}(\\lambda)]-1</span> and game </em>S-ZK* is specified in Figure 1.</p>

    <p class="text-gray-300">The definition is akin to zero knowledge for interactive proof systems <em>[x10]</em>, when interpreting the CRS as the verifier’s first message. The simulator must produce a full view of the verifier (including coins and a transcript of its interaction with the Prove oracle). On the other hand, to imply ZK of NI systems, the simulator needs to produce the CRS <em>before</em> learning the statements for which it must simulate proofs. Moreover, the simulator can depend on <span class="math">\\mathsf{X}</span> but not on <span class="math">\\mathsf{A}</span>.</p>

    <p class="text-gray-300">Subversion KSND. For completeness we give a subversion-resistant analogue for knowledge soundness (not considered in <em>[x2]</em>), as this is the relevant notion for SNARKs. We modify game KSND and let the adversary choose crs in addition to <span class="math">x</span> and <span class="math">\\pi</span>. We are not aware of any construction that achieves S-KSND and some form of WI.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Definition 2.8 (S-KSND)</h6>

    <p class="text-gray-300">An NI system <span class="math">\\mathsf{\\Pi}</span> for relation generator <span class="math">\\mathsf{Rg}</span> is <em>subversion-knowledge-sound</em> if for all PT adversaries <span class="math">\\mathsf{A}</span> there exists a PT extractor <span class="math">\\mathsf{E}</span> such that <span class="math">\\mathbf{Adv}^{\\text{s-ksnd}}_{\\mathsf{\\Pi},\\mathsf{Rg},\\mathsf{A},\\mathsf{E}}(\\cdot)</span> is negligible, where <span class="math">\\mathbf{Adv}^{\\text{s-ksnd}}_{\\mathsf{\\Pi},\\mathsf{Rg},\\mathsf{A},\\mathsf{E}}(\\lambda)=\\operatorname<em>{Pr}[\\text{S-KSND}_{\\mathsf{\\Pi},\\mathsf{Rg},\\mathsf{A},\\mathsf{E}}(\\lambda)]</span> and game </em>S-KSND* is specified in Figure 1.</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">2.5 Bilinear Groups and Assumptions</h3>

    <p class="text-gray-300">Bilinear groups. The SNARK constructions we consider are based on bilinear groups, for which we introduce a new type of knowledge-of-exponent assumption. We distinguish between asymmetric and symmetric groups.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Definition 2.9</h6>

    <p class="text-gray-300">An asymmetric-bilinear-group generator <span class="math">\\mathsf{aGen}</span> is a PT algorithm that takes input a security parameter <span class="math">1^{\\lambda}</span> and outputs a description of a bilinear group <span class="math">(p,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},\\mathsf{e})</span> with the following properties:</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 2: Games defining assumptions  <span class="math">q</span> -PDH,  <span class="math">q</span> -TSDH and  <span class="math">q</span> -PKE</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">p</span>  is a prime of length  <span class="math">\\lambda</span> ;</li>

      <li><span class="math">(\\mathbb{G}_1, +)</span> ,  <span class="math">(\\mathbb{G}_2, +)</span>  and  <span class="math">(\\mathbb{G}_T, \\cdot)</span>  are groups of order  <span class="math">p</span> ;</li>

      <li><span class="math">\\mathbf{e} \\colon \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T</span>  is a bilinear map, that is, for all  <span class="math">a, b \\in \\mathbb{Z}_p</span>  and  <span class="math">S \\in \\mathbb{G}_1</span> ,  <span class="math">T \\in \\mathbb{G}_2</span>  we have:  <span class="math">\\mathbf{e}(aS, bT) = \\mathbf{e}(S, T)^{ab}</span> ;</li>

      <li><span class="math">\\mathbf{e}</span>  is non-degenerate, that is, for  <span class="math">P_{1} \\in \\mathbb{G}_{1}^{<em>}</span>  and  <span class="math">P_{2} \\in \\mathbb{G}_{2}^{</em>}</span>  (i.e.,  <span class="math">P_{1}</span>  and  <span class="math">P_{2}</span>  are generators)  <span class="math">\\mathbf{e}(P_{1}, P_{2})</span>  generates  <span class="math">\\mathbb{G}_{T}</span> .</li>

    </ul>

    <p class="text-gray-300">Moreover, we assume that group operations and the bilinear map can be computed efficiently, membership of the groups and equality of group elements can be decided efficiently, and group generators can be sampled efficiently.</p>

    <p class="text-gray-300">A symmetric-bilinear-group generator sGen returns a bilinear group with  <span class="math">\\mathbb{G}_1 = \\mathbb{G}_2</span> , which we denote by  <span class="math">\\mathbb{G}</span> , and with a symmetric non-degenerate bilinear map  <span class="math">\\mathbf{e} \\colon \\mathbb{G} \\times \\mathbb{G} \\to \\mathbb{G}_T</span> .</p>

    <p class="text-gray-300">ASSUMPTIONS. We recall the assumptions under which SNARKs in the literature were proven sound. The following assumptions are from [DFGK14], who adapted PDH from [Gro10] to asymmetric groups, and TSDH from [BB04, Gen04].</p>

    <p class="text-gray-300">Definition 2.10 (q-PDH) The  <span class="math">q(\\lambda)</span> -power Diffie-Hellman assumption holds for an asymmetric group generator  <span class="math">\\mathsf{aGen}</span>  if  <span class="math">\\mathbf{Adv}_{q,\\mathsf{aGen},\\mathsf{A}}^{\\mathrm{pdh}}(\\cdot)</span>  is negligible for all PT adversaries  <span class="math">\\mathsf{A}</span> , where  <span class="math">\\mathbf{Adv}_{q,\\mathsf{aGen},\\mathsf{A}}^{\\mathrm{pdh}}(\\lambda) = \\operatorname*{Pr}[\\mathrm{PDH}_{q,\\mathsf{aGen},\\mathsf{A}}(\\lambda)]</span>  and  <span class="math">\\mathrm{PDH}</span>  is defined in Figure 2.</p>

    <p class="text-gray-300">The  <span class="math">q</span> -PDH assumption for symmetric group generators  <span class="math">\\mathsf{sGen}</span>  is defined analogously by letting  <span class="math">\\mathbb{G}_1 = \\mathbb{G}_2</span>  and  <span class="math">P_1 = P_2</span>  (A thus only receives  <span class="math">2q</span>  group elements).</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Definition 2.11 (<span class="math">q</span>-TSDH)</h6>

    <p class="text-gray-300">The <span class="math">q(\\lambda)</span>-target-group strong Diffie-Hellman assumption holds for an asymmetric group generator <span class="math">\\mathsf{aGen}</span> if <span class="math">\\mathbf{Adv}^{\\text{\\rm tsdh}}_{q,\\mathsf{aGen},\\mathsf{A}}(\\cdot)</span> is negligible for all PT adversaries <span class="math">\\mathsf{A}</span>, where <span class="math">\\mathbf{Adv}^{\\text{\\rm tsdh}}_{q,\\mathsf{aGen},\\mathsf{A}}(\\lambda)=\\Pr[\\text{\\rm TSDH}_{q,\\mathsf{aGen},\\mathsf{A}}(\\lambda)]</span> and TSDH is defined in Figure 2.</p>

    <p class="text-gray-300">The <span class="math">q</span>-TSDH assumption for symmetric group generators <span class="math">\\mathsf{sGen}</span> is defined analogously by letting <span class="math">\\mathbb{G}_{1}=\\mathbb{G}_{2}</span> and <span class="math">P_{1}=P_{2}</span> (<span class="math">\\mathsf{A}</span> thus only receives <span class="math">q+1</span> group elements).</p>

    <h5 id="sec-31" class="text-base font-semibold mt-4">KEA.</h5>

    <p class="text-gray-300">The knowledge-of-exponent assumption <em>[x10, x13, x3]</em> in a group <span class="math">\\mathbb{G}</span> states that an algorithm <span class="math">\\mathsf{A}</span> that is given two random generators <span class="math">P,Q\\in\\mathbb{G}^{<em>}</span> and outputs <span class="math">(cP,cQ)</span> must know <span class="math">c</span>. This is formalized by requiring that there exists an extractor for <span class="math">\\mathsf{A}</span> which given <span class="math">\\mathsf{A}</span>’s coins outputs <span class="math">c</span>. This has been considered in the bilinear-group setting </em>[x1]<em> where <span class="math">\\mathsf{A}</span>’s output <span class="math">(cP,cQ)</span> can be verified by using the bilinear map. Generalizations of KEA were made by Groth </em>[x16]<em>, who assumes that for every <span class="math">\\mathsf{A}</span> that on input <span class="math">(P,Q,sP,sQ,s^{2}P,s^{2}Q,\\ldots,s^{q}P,s^{q}Q)</span> returns <span class="math">(cP,cQ)</span> an extractor can extract <span class="math">(a_{0},\\ldots,a_{q})</span> such that <span class="math">c=\\sum_{i=0}^{q}a_{i}s^{i}</span>. Danezis et al. </em>[x12]* port Groth’s assumption to asymmetric groups as follows.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Definition 2.12 (<span class="math">q</span>-PKE)</h6>

    <p class="text-gray-300">The <span class="math">q(\\lambda)</span>-power knowledge of exponent assumption holds for <span class="math">\\mathsf{aGen}</span> w.r.t. the class <span class="math">\\mathcal{A}</span>ux of auxiliary input generators if for every PT <span class="math">\\mathsf{Z}\\in\\mathcal{A}</span>ux and PT adversary <span class="math">\\mathsf{A}</span> there exists a PT extractor <span class="math">\\mathsf{E}</span> s.t. <span class="math">\\mathbf{Adv}^{\\text{\\rm hke}}_{q,\\mathsf{aGen},\\mathsf{Z},\\mathsf{A},\\mathsf{E}}(\\cdot)</span> is negligible, where <span class="math">\\mathbf{Adv}^{\\text{\\rm hke}}_{q,\\mathsf{aGen},\\mathsf{Z},\\mathsf{A},\\mathsf{E}}(\\lambda)=\\Pr[\\text{\\rm PKE}_{q,\\mathsf{aGen},\\mathsf{Z},\\mathsf{A},\\mathsf{E}}(\\lambda)]</span> and PKE is defined in Figure 2.</p>

    <p class="text-gray-300">The <span class="math">q</span>-PKE assumption for symmetric generators <span class="math">\\mathsf{sGen}</span> is defined by letting <span class="math">\\mathbb{G}_{1}=\\mathbb{G}_{2}</span> but again choosing <span class="math">P_{1},P_{2}\\longleftarrow\\mathbb{G}^{*}</span> (<span class="math">\\mathsf{A}</span> thus again receives <span class="math">2q+2</span> group elements).</p>

    <p class="text-gray-300">Bellare et al. <em>[x2]</em> consider deterministically generated groups (whereas for SNARK systems the group will be part of the relation <span class="math">R</span> output by a relation generator <span class="math">\\mathsf{Rg}</span>). They therefore need to define all other assumptions, such as DLin <em>[x4]</em>, with respect to this fixed group. BFS introduce a new type of KEA, called DH-KEA, which assumes that if <span class="math">\\mathsf{A}</span> outputs a Diffie-Hellman (DH) tuple <span class="math">(sP,tP,stP)</span> w.r.t. the fixed <span class="math">P</span>, then <span class="math">\\mathsf{A}</span> must know either <span class="math">s</span> or <span class="math">t</span>. The auxiliary input given to <span class="math">\\mathsf{A}</span> are two additional random generators <span class="math">H_{0},H_{1}</span>. The intuition is that while an adversary may produce one group element without knowing its discrete logarithm by hashing into the elliptic curve <em>[x1, SvdW06, BCI^{+}10]</em>, it seems hard to produce a DH tuple without knowing at least one of the logarithms.</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Definition 2.13 (DH-KEA)</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{detSGen}</span> be a deterministic group generator. The <em>Diffie-Hellman knowledge of exponent</em> assumption holds for <span class="math">\\mathsf{detSGen}</span> if for every PT <span class="math">\\mathsf{A}</span> there exists a PT <span class="math">\\mathsf{E}</span> s.t. <span class="math">\\mathbf{Adv}^{\\text{\\rm dhke}}_{\\mathsf{detSGen},\\mathsf{A},\\mathsf{E}}(\\cdot)</span> is negligible, where <span class="math">\\mathbf{Adv}^{\\text{\\rm dhke}}_{\\mathsf{detSGen},\\mathsf{A},\\mathsf{E}}(\\lambda)=\\Pr[\\text{\\rm DHKE}_{\\mathsf{detSGen},\\mathsf{A},\\mathsf{E}}(\\lambda)]</span> and DHKE defined in Figure 3.</p>

    <h5 id="sec-34" class="text-base font-semibold mt-4">SKE.</h5>

    <p class="text-gray-300">We now consider a weakening of DH-KEA where we prescribe <span class="math">s=t</span>; that is, if <span class="math">\\mathsf{A}</span> on input <span class="math">P</span> outputs a pair <span class="math">(sP,s^{2}P)</span> then <span class="math">\\mathsf{E}</span> extracts <span class="math">s</span>. This assumption is weaker than (i.e., implied by) DH-KEA. As we consider groups with randomly sampled generators, we let <span class="math">\\mathsf{A}</span> choose the generator <span class="math">P</span> itself and assume that there exists an extractor that extracts <span class="math">s</span> when <span class="math">\\mathsf{A}</span> outputs a tuple <span class="math">(P,sP,s^{2}P)</span>. This allows us to choose a random generator when setting up parameters of a scheme. The security of such schemes then follows from assumptions such as PDH, as defined above, where the generators are chosen randomly.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Definition 2.14 (SKE)</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{sGen}</span> be a symmetric-group generator. The <em>square knowledge of exponent</em> assumption holds for <span class="math">\\mathsf{sGen}</span> if for every PT <span class="math">\\mathsf{A}</span> there exists a PT <span class="math">\\mathsf{E}</span> s.t. <span class="math">\\mathbf{Adv}^{\\text{\\rm ske}}_{\\mathsf{sGen},\\mathsf{A},\\mathsf{E}}(\\cdot)</span> is negligible, where <span class="math">\\mathbf{Adv}^{\\text{\\rm ske}}_{\\mathsf{sGen},\\mathsf{A},\\mathsf{E}}(\\lambda)=\\Pr[\\text{\\rm SKE}_{\\mathsf{sGen},\\mathsf{A},\\mathsf{E}}(\\lambda)]</span> with SKE is defined in Figure 3.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 3: Games defining knowledge-of-exponent assumptions</p>

    <p class="text-gray-300">SKE FOR ASYMMETRIC GROUPS. For asymmetric bilinear-group generators, we make assumption SKE in the first source group  <span class="math">\\mathbb{G}_1</span> . Unlike for symmetric groups, a tuple  <span class="math">(S_0,sS_0,s^2 S_0)\\in \\mathbb{G}_1^3</span>  is not verifiable via an asymmetric pairing. To make it verifiable, we weaken the assumption and require A to additionally output a  <span class="math">\\mathbb{G}_2</span> -element  <span class="math">T_{0}</span>  as well as  <span class="math">T_{1} = sT_{0}</span> , which enables verification (as done in game  <span class="math">\\mathrm{SKE}_{\\mathrm{aGen}}</span> ).</p>

    <p class="text-gray-300">Definition 2.15 (SKE) Let aGen be an asymmetric-group generator. The SKE assumption holds for aGen in the first source group if for every  <span class="math">PT</span>  A there exists a  <span class="math">PT</span>  E s.t.  <span class="math">\\mathbf{Adv}_{\\mathrm{aGen,A,E}}^{\\mathrm{ske}}(\\cdot)</span>  is negligible, where  <span class="math">\\mathbf{Adv}_{\\mathrm{aGen,A,E}}^{\\mathrm{ske}}(\\lambda) = \\operatorname*{Pr}[\\mathrm{SKE}_{\\mathrm{aGen,A,E}}(\\lambda)]</span>  and SKE is defined in Figure 3.</p>

    <p class="text-gray-300">We note that in addition to verifiability these additional elements  <span class="math">T_0</span>  and  <span class="math">T_1</span>  actually add to the plausibility of the assumption for asymmetric groups. Even if outputting  <span class="math">S_2</span>  was not required, one could argue that the following stronger assumption holds in Type-3 bilinear groups, in which DDH holds in  <span class="math">\\mathbb{G}_1</span>  and in  <span class="math">\\mathbb{G}_2</span> : it is hard to compute  <span class="math">(S_0, S_1, T_0, T_1) \\in \\mathbb{G}_1^2 \\times \\mathbb{G}_2^2</span>  with  <span class="math">\\mathbf{e}(S_1, T_0) = \\mathbf{e}(S_0, T_1)</span>  without knowing the logarithms of  <span class="math">S_1</span>  to base  <span class="math">S_0</span>  (or equivalently  <span class="math">T_1</span>  to base  <span class="math">T_0</span> ): an adversary might choose  <span class="math">S_0</span>  and  <span class="math">S_1</span>  obliviously by hashing into the group; but if it was able to compute from them the respective  <span class="math">T_0</span>  and  <span class="math">T_1</span>  then this would break DDH in  <span class="math">\\mathbb{G}_1</span> . (Given a DDH challenge  <span class="math">(S_0, S_1 = s_1S_0, S_2 = s_2S_0, R)</span> , compute  <span class="math">T_0</span>  and  <span class="math">T_1</span>  as above; then we have  <span class="math">R = s_1s_2S_0</span>  iff  <span class="math">\\mathbf{e}(R, T_0) = \\mathbf{e}(S_2, T_1)</span> .) Of course, this argument breaks down if there is an efficiently computable homomorphism from  <span class="math">\\mathbb{G}_1</span>  to  <span class="math">\\mathbb{G}_2</span>  or vice versa.</p>

    <p class="text-gray-300">Finally, we note that  <span class="math">q</span> -PKE with  <span class="math">q = 0</span>  does not imply SKE, since a PKE adversary must return  <span class="math">(V, W)</span>  which is a multiple of the received  <span class="math">(P_1, P_2)</span> , while an SKE adversary can choose the "basis"  <span class="math">(S_0, T_0)</span>  itself. The converse does not hold either (SKE  <span class="math">\\neq</span>  PKE), since an SKE adversary must return  <span class="math">S_2 = s^2 S_0</span> .</p>

    <p class="text-gray-300">2.6 SKE in the Generic-Group Model</p>

    <p class="text-gray-300">We show that SKE holds in the generic-group model. We show it for symmetric generic groups, which implies the result for asymmetric groups (where the adversary has less power). As <em>[x1]</em> did for DH-KEA, we reflect hashing into elliptic curves by providing the adversary with an additional generic operation: it can create new group elements without knowing their discrete logarithms (which are not known to the extractor either).</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Theorem 2.16</h6>

    <p class="text-gray-300">SKE, as defined in Definition 2.14, holds in the generic-group model with hashing into the group.</p>

    <p class="text-gray-300">In the proof of the theorem we will use the following lemma, which we prove first.</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Lemma 2.17</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}</span> be a field and let <span class="math">A,B,C\\in\\mathbb{F}[X_{1},\\ldots,X_{k}]</span>, with degree of <span class="math">A</span>, <span class="math">B</span> and <span class="math">C</span> at most 1. If <span class="math">A\\cdot C=B^{2}</span> then for some <span class="math">s\\in\\mathbb{F}</span>: <span class="math">B=s\\cdot A</span>.</p>

    <p class="text-gray-300">Proof. Let <span class="math">\\alpha_{i},\\beta_{i},\\gamma_{i}</span>, for <span class="math">0\\leq i\\leq k</span>, denote the coefficients of <span class="math">X_{i}</span> (where <span class="math">X_{0}:=1</span>) in <span class="math">A,B,C</span>, respectively. If <span class="math">A=0</span> then <span class="math">B=0</span> and the theorem follows. Assume thus <span class="math">A\\neq 0</span>; Define <span class="math">j:=\\min\\{i\\in[0,k]:\\alpha_{j}\\neq 0\\}</span> and <span class="math">s:=\\beta_{j}\\cdot\\alpha_{j}^{-1}</span>.</p>

    <p class="text-gray-300">To prove the lemma, we will now show that for all <span class="math">i\\in[0,k]</span>:</p>

    <p class="text-gray-300"><span class="math">\\beta_{i}=s\\cdot\\alpha_{i}\\ .</span> (1)</p>

    <p class="text-gray-300">From <span class="math">A\\cdot C=B^{2}</span> we have</p>

    <p class="text-gray-300"><span class="math">L(\\vec{X}):=\\left(\\beta_{0}+\\textstyle\\sum_{i=1}^{k}\\beta_{i}X_{i}\\right)^{2}-\\left(\\alpha_{0}+\\textstyle\\sum_{i=1}^{k}\\alpha_{i}X_{i}\\right)\\left(\\gamma_{0}+\\textstyle\\sum_{i=1}^{k}\\gamma_{i}X_{i}\\right)=0\\ .</span> (2)</p>

    <p class="text-gray-300">From <span class="math">L(0,\\ldots,0)=0</span>, we get: (I) <span class="math">\\beta_{0}^{2}=\\alpha_{0}\\gamma_{0}</span>, which implies that Eq. (1) holds for <span class="math">i=0</span>: either <span class="math">\\alpha_{0}=0</span>, then from (I): <span class="math">\\beta_{0}=0</span>; or <span class="math">\\alpha_{0}\\neq 0</span>, then <span class="math">j=0</span> and Eq. (1) holds as well.</p>

    <p class="text-gray-300">Let now <span class="math">i\\in[1,k]</span> be arbitrarily fixed and let <span class="math">e_{i}</span> denote the vector <span class="math">(0,\\ldots,0,1,0,\\ldots,0)</span> with <span class="math">1</span> at position <span class="math">i</span>. Consider <span class="math">L(e_{i})=0</span>, which together with (I) yields</p>

    <p class="text-gray-300"><span class="math">2\\beta_{0}\\beta_{i}+\\beta_{i}^{2}-\\alpha_{0}\\gamma_{i}-\\alpha_{i}\\gamma_{0}-\\alpha_{i}\\gamma_{i}=0\\ .</span> (3)</p>

    <p class="text-gray-300">Similarly, from <span class="math">L(2e_{i})=0</span>, we have <span class="math">\\ 4\\beta_{0}\\beta_{i}+4\\beta_{i}^{2}-2\\alpha_{0}\\gamma_{i}-2\\alpha_{i}\\gamma_{0}-4\\alpha_{i}\\gamma_{i}=0\\</span>, which after subtracting Eq. (3) twice yields: (II) <span class="math">\\beta_{i}^{2}=\\alpha_{i}\\gamma_{i}</span>. If <span class="math">\\alpha_{i}=0</span> then <span class="math">\\beta_{i}=0</span>, which shows Eq. (1). For the remainder let us assume <span class="math">\\alpha_{i}\\neq 0</span>.</p>

    <p class="text-gray-300">Plugging (II) into Eq. (3) yields: (III) <span class="math">2\\beta_{0}\\beta_{i}=\\alpha_{0}\\gamma_{i}-\\alpha_{i}\\gamma_{0}</span>.</p>

    <p class="text-gray-300">If <span class="math">\\alpha_{0}\\neq 0</span> then <span class="math">j=0</span> and plugging (I) and (II) into (III) yields</p>

    <p class="text-gray-300"><span class="math">2\\beta_{0}\\beta_{i}-\\alpha_{0}\\alpha_{i}^{-1}\\beta_{i}^{2}-\\alpha_{i}\\alpha_{0}^{-1}\\beta_{0}^{2}=0\\ .</span></p>

    <p class="text-gray-300">Solving for <span class="math">\\beta_{i}</span> yields the unique solution <span class="math">\\beta_{i}=\\beta_{0}\\alpha_{0}^{-1}\\alpha_{i}</span>, which shows Eq. (1) for the case <span class="math">\\alpha_{0}\\neq 0</span>.</p>

    <p class="text-gray-300">Let us now assume <span class="math">\\alpha_{0}=0</span>. By (I) we have <span class="math">\\beta_{0}=0</span>. If <span class="math">i=j</span> then Eq. (1) holds by definition of <span class="math">s</span>. Assume <span class="math">i\\neq j</span>. From <span class="math">L(e_{i}+e_{j})</span> we have (since <span class="math">\\alpha_{0}=\\beta_{0}=0</span>):</p>

    <p class="text-gray-300"><span class="math">0\\ =\\ \\beta_{i}^{2}+\\beta_{j}^{2}+2\\beta_{i}\\beta_{j}-\\alpha_{i}\\gamma_{0}-\\alpha_{i}\\gamma_{i}-\\alpha_{i}\\gamma_{j}-\\alpha_{j}\\gamma_{0}-\\alpha_{j}\\gamma_{i}-\\alpha_{j}\\gamma_{j}\\ =\\ 2\\beta_{i}\\beta_{j}-\\alpha_{i}\\gamma_{j}-\\alpha_{j}\\gamma_{i}\\ ,</span></p>

    <p class="text-gray-300">where we used (II) and <span class="math">\\alpha_{i}\\gamma_{0}=\\alpha_{j}\\gamma_{0}=0</span> (which follows from (III) and <span class="math">\\alpha_{0}=\\beta_{0}=0</span>). Together with (II) the latter yields <span class="math">\\ 2\\beta_{i}\\beta_{j}-\\alpha_{i}\\alpha_{j}^{-1}\\beta_{j}^{2}-\\alpha_{j}\\alpha_{i}^{-1}\\beta_{i}^{2}=0</span>. Solving for <span class="math">\\beta_{i}</span> yields the unique solution <span class="math">\\beta_{i}=\\beta_{j}\\alpha_{j}^{-1}\\alpha_{i}</span>, which concludes the proof.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Proof of Theorem 2.16. In the “traditional” generic-group model, group elements are represented by random strings and an adversary <span class="math">\\mathsf{A}</span> only has access to operations on them (addition of elements in <span class="math">\\mathbb{G}</span>, multiplication of elements in <span class="math">\\mathbb{G}_{T}</span> and pairing of elements in <span class="math">\\mathbb{G}</span>) via oracles. In particular, <span class="math">\\mathsf{A}</span> can only produce new <span class="math">\\mathbb{G}</span> elements by adding received elements.</p>

    <p class="text-gray-300">We also need to reflect the fact that by “hashing into the group”, <span class="math">\\mathsf{A}</span> can create a new group element without knowing its discrete logarithm w.r.t. one of the received elements. We extend the generic-group model and provide the adversary with an additional operation, namely to request a new group element “independently of the received ones”. (And neither the adversary nor the extractor we construct knows its discrete logarithm.)</p>

    <p class="text-gray-300">For SKE the adversary <span class="math">\\mathsf{A}</span> receives the group element <span class="math">P</span> and needs to output <span class="math">(S_{0},S_{1},S_{2})</span> where for some <span class="math">s,t</span>: <span class="math">S_{0}=tP</span>, <span class="math">S_{1}=sS_{0}=stP</span> and <span class="math">S_{2}=s^{2}S_{0}=s^{2}tP</span>. The adversary can produce these group elements by combining the received generator <span class="math">P</span> with newly generated (“hashed”) group elements that it has requested. We represent the latter as <span class="math">x_{i}P</span>, for <span class="math">i=1,\\ldots k</span>, for some <span class="math">k</span>. The extractor keeps track of the group operations performed by <span class="math">\\mathsf{A}</span> and thus knows</p>

    <p class="text-gray-300"><span class="math">\\alpha_{0},\\ldots,\\alpha_{k},\\beta_{0},\\ldots,\\beta_{k},\\gamma_{0},\\ldots,\\gamma_{k}\\in\\mathbb{Z}_{p}</span> (4)</p>

    <p class="text-gray-300">such that <span class="math">\\mathsf{A}</span>’s output <span class="math">(S_{0},S_{1},S_{2})</span> is of the form</p>

    <p class="text-gray-300"><span class="math">S_{0}=\\alpha_{0}P+\\sum_{i=1}^{k}\\alpha_{i}(x_{i}P)\\qquad S_{1}=\\beta_{0}P+\\sum_{i=1}^{k}\\beta_{i}(x_{i}P)\\qquad S_{2}=\\gamma_{0}P+\\sum_{i=1}^{k}\\gamma_{i}(x_{i}P)</span></p>

    <p class="text-gray-300">Note that the extractor does however not know <span class="math">x:=(x_{1},\\ldots,x_{k})</span>.</p>

    <p class="text-gray-300">Assume the adversary wins and <span class="math">\\mathbf{e}(S_{1},S_{1})=\\mathbf{e}(S_{0},S_{2})</span>. Taking the logarithms of the latter yields</p>

    <p class="text-gray-300"><span class="math">\\big{(}\\beta_{0}+\\sum_{i=1}^{k}\\beta_{i}x_{i}\\big{)}^{2}-\\big{(}\\alpha_{0}+\\sum_{i=1}^{k}\\alpha_{i}x_{i}\\big{)}\\big{(}\\gamma_{0}+\\sum_{i=1}^{k}\\gamma_{i}x_{i}\\big{)}=0\\;\\;.</span> (5)</p>

    <p class="text-gray-300">Since the adversary has no information about <span class="math">x_{1},\\ldots,x_{k}</span> (except for a negligible information leak by comparing group elements, which we ignore), the values in Eq. (4) are generated independently of <span class="math">x_{1},\\ldots,x_{k}</span>. By the Schwartz-Zippel lemma the probability that Eq. (5) holds when <span class="math">x_{1},\\ldots,x_{k}</span> are randomly chosen is negligible, except if the left-hand side corresponds to the zero polynomial. With overwhelming probability we thus have</p>

    <p class="text-gray-300"><span class="math">B(\\vec{X})^{2}-A(\\vec{X})\\cdot C(\\vec{X})=0</span></p>

    <p class="text-gray-300">with</p>

    <p class="text-gray-300"><span class="math">A(\\vec{X})=\\alpha_{0}+\\sum_{i=1}^{k}\\alpha_{i}X_{i}\\qquad\\quad B(\\vec{X})=\\beta_{0}+\\sum_{i=1}^{k}\\beta_{i}X_{i}\\qquad\\quad C(\\vec{X})=\\gamma_{0}+\\sum_{i=1}^{k}\\gamma_{i}X_{i}</span></p>

    <p class="text-gray-300">By Lemma 2.17 we have that <span class="math">B=s\\,A</span> for some <span class="math">s\\in\\mathbb{F}</span>. The extractor computes and returns <span class="math">s</span>, which is correct since <span class="math">S_{1}=B(\\vec{x})P=sA(\\vec{x})P=s\\,S_{0}</span>.</p>

    <h2 id="sec-38" class="text-2xl font-bold">3 SNARKs</h2>

    <p class="text-gray-300">We start with a formal definition of SNARGs and SNARKs.</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Definition 3.1 (SNARG)</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">An NI system <span class="math">\\mathsf{\\Pi}=(\\mathsf{\\Pi.Pg},\\mathsf{\\Pi.P},\\mathsf{\\Pi.V})</span> is a <em>succinct non-interactive argument</em> for relation generator <span class="math">\\mathsf{Rg}</span> if it is complete and sound, as in Definition 2.1, and moreover succinct, meaning that for all <span class="math">\\lambda\\in\\mathbb{N}</span>, all <span class="math">R\\in[\\mathsf{Rg}(1^{\\lambda})]</span>, all <span class="math">\\operatorname{crs}\\in[\\mathsf{\\Pi.Pg}(R)]</span>, all <span class="math">x\\in L(R)</span>, all <span class="math">w\\in R(x)</span> and all <span class="math">\\pi\\in[\\mathsf{\\Pi.P}(1^{\\lambda},\\operatorname{crs},x,w)]</span> we have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\operatorname{poly}(\\lambda)<span class="math"> and </span>\\mathsf{\\Pi.V}(1^{\\lambda},\\operatorname{crs},x,\\pi)<span class="math"> runs in time </span>\\operatorname{poly}(\\lambda+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">######</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Definition 3.2 (SNARK)</h6>

    <p class="text-gray-300">A SNARG <span class="math">\\Pi</span> is a <em>succinct non-interactive argument of knowledge</em> if it satisfies knowledge soundness, as in Definition 2.2.</p>

    <p class="text-gray-300"><em>Gennaro, Gentry, Parno and Raykova [GGP+13]</em> base their SNARK constructions on <em>quadratic programs</em>. In particular, they show how to convert any boolean circuit into a quadratic span program and any arithmetic circuit into a quadratic arithmetic program (QAP).</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Definition 3.3 (QAP)</h6>

    <p class="text-gray-300">A <em>quadratic arithmetic program</em> over a field <span class="math">\\mathbb{F}</span> is a tuple of the form</p>

    <p class="text-gray-300"><span class="math">\\left(\\mathbb{F},n,\\{A_{i}(X),B_{i}(X),C_{i}(X)\\}_{i=0}^{m},Z(X)\\right)\\;,</span></p>

    <p class="text-gray-300">where <span class="math">A_{i}(X),B_{i}(X),C_{i}(X),Z(X)\\in\\mathbb{F}[X]</span>, which define a language of statements <span class="math">(s_{1},\\ldots,s_{n})\\in\\mathbb{F}^{n}</span> and witnesses <span class="math">(s_{n+1},\\ldots,s_{m})\\in\\mathbb{F}^{m-n}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\Big{(}A_{0}(X)+\\sum_{i=1}^{m}s_{i}A_{i}(X)\\Big{)}\\cdot\\Big{(}B_{0}(X)+\\sum_{i=1}^{m}s_{i}B_{i}(X)\\Big{)}=C_{0}(X)+\\sum_{i=1}^{m}s_{i}C_{i}(X)+H(X)\\cdot Z(X)\\;,</span> (6)</p>

    <p class="text-gray-300">for some degree-<span class="math">(d-2)</span> quotient polynomial <span class="math">H(X)</span>, where <span class="math">d</span> is the degree of <span class="math">Z(X)</span> (we assume the degrees of all <span class="math">A_{i}(X),B_{i}(X),C_{i}(X)</span> are at most <span class="math">d-1</span>).</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Definition 3.4 (Strong QAP)</h6>

    <p class="text-gray-300">A <em>strong QAP</em> is a QAP such that for any <span class="math">(r_{1},\\ldots,r_{m},s_{1},\\ldots,s_{m}</span>, <span class="math">t_{1},\\ldots,t_{m})\\in\\mathbb{F}^{3m}</span> for which <span class="math">Z(X)</span> divides</p>

    <p class="text-gray-300"><span class="math">\\big{(}A_{0}(X)+\\sum_{i=1}^{m}r_{i}A_{i}(X)\\big{)}\\cdot\\big{(}B_{0}(X)+\\sum_{i=1}^{m}s_{i}B_{i}(X)\\big{)}-C_{0}(X)+\\sum_{i=1}^{m}t_{i}C_{i}(X)\\;,</span> (7)</p>

    <p class="text-gray-300">it must be the case that <span class="math">(r_{1},\\ldots,r_{m})=(s_{1},\\ldots,s_{m})=(t_{1},\\ldots,t_{m})</span>.</p>

    <p class="text-gray-300">All of the discussed SNARK constructions are for QAPs defined over a bilinear group. We will thus consider relation generators <span class="math">\\mathsf{Rg}</span> of the following form:</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Definition 3.5 (QAP relation)</h6>

    <p class="text-gray-300">A QAP relation generator <span class="math">\\mathsf{Rg}</span> is a PT algorithm that on input <span class="math">1^{\\lambda}</span> returns a relation description of the following form:</p>

    <p class="text-gray-300"><span class="math">R=\\big{(}Gr,n,\\vec{A},\\vec{B},\\vec{C},Z\\big{)}</span> where Gr is a bilinear group whose order <span class="math">p</span> defines <span class="math">\\mathbb{F}:=\\mathbb{Z}_{p}</span> and</p>

    <p class="text-gray-300"><span class="math">\\vec{A},\\vec{B},\\vec{C}\\in\\big{(}\\mathbb{F}^{(d-1)}[X]\\big{)}^{(m+1)},\\ Z\\in\\mathbb{F}^{(d)}[X],\\ n\\leq m\\ .</span> (8)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For <span class="math">x\\in\\mathbb{F}^{n}</span> and <span class="math">w\\in\\mathbb{F}^{m-n}</span> we define <span class="math">R(x,w)=\\mathsf{true}</span> iff there exists <span class="math">H(X)\\in\\mathbb{F}[X]</span> so that Eq. (6) holds for $s:=x\\,\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,w<span class="math"> (where “</span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$” denotes concatenation).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-44" class="text-2xl font-bold">4 GGPR’s QAP-Based SNARK</h2>

    <p class="text-gray-300"><em>Gennaro et al. [GGP+13]</em> presented the first zero-knowledge SNARK construction for arithmetic circuits that are expressed as quadratic arithmetic programs. They separate the CRS into a (long) part <span class="math">pk</span>, used to compute proofs, and a (short) part <span class="math">vk</span>, used to verify them. Their construction is detailed in Figure 4. As it is defined over symmetric bilinear groups, we assume that <span class="math">Gr</span> returned by <span class="math">\\mathsf{Rg}</span> is symmetric.</p>

    <p class="text-gray-300">We define procedure CRS verification, which a prover runs on a CRS before using it the first time, as follows:</p>

    <p class="text-gray-300">CRS verification. On input <span class="math">(R,vk,pk)</span>, let <span class="math">\\{a_{i,j}\\}</span>, <span class="math">\\{b_{i,j}\\}</span>, <span class="math">\\{c_{i,j}\\}</span>, <span class="math">\\{z_{k}\\}</span> denote the coefficients of <span class="math">A_{i}(X)</span>, <span class="math">B_{i}(X)</span>, <span class="math">C_{i}(X)</span> and <span class="math">Z(X)</span>, respectively, that are contained in <span class="math">R</span>, for <span class="math">0\\leq i\\leq m</span> and <span class="math">0\\leq j\\leq d-1</span> and <span class="math">0\\leq k\\leq d</span>.</p>

    <p class="text-gray-300">KEY GENERATION. On input  <span class="math">R</span>  as in Eq. (8) representing a QAP for a symmetric group  <span class="math">Gr</span>  do the following:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample  <span class="math">P \\gets \\mathbb{G}^<em></span>  and  <span class="math">\\tau, \\alpha, \\beta_A, \\beta_B, \\beta_C \\gets \\mathbb{F}</span> , conditioned on  <span class="math">Z(\\tau) \\neq 0</span>  and  <span class="math">\\gamma \\gets \\mathbb{F}^</em></span> .</li>

      <li>Set  <span class="math">vk = (P_{1}, P_{2}, vk_{A}, vk_{B,0}, vk_{C,0}, vk_{Z}, vk_{\\alpha}, vk_{\\gamma}, vk_{A,\\gamma}^{\\prime \\prime}, vk_{B,\\gamma}^{\\prime \\prime}, vk_{C,\\gamma}^{\\prime \\prime})</span>  where</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\{vk_{A,i}\\}_{i = 0}^{n}:= \\left\\{A_{i}(\\tau)P\\right\\}_{i = 0}^{n}</span> <span class="math">vk_{B,0}:= B_0(\\tau)P</span> <span class="math">vk_{C,0}:= C_0(\\tau)P</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{vk}_Z\\coloneqq Z(\\tau)P</span> <span class="math">\\mathsf{vk}_{\\alpha}\\coloneqq \\alpha P</span> <span class="math">\\mathsf{vk}_{\\gamma}\\coloneqq \\gamma P</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{vk}_{A,\\gamma}^{\\prime \\prime}:= \\beta_{A}\\gamma P</span> <span class="math">\\mathsf{vk}_{B,\\gamma}^{\\prime \\prime}:= \\beta_{B}\\gamma P</span> <span class="math">\\mathsf{vk}_{C,\\gamma}^{\\prime \\prime}:= \\beta_{C}\\gamma P</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">pk = (pk_A, pk&#x27;_A, pk&#x27;_A, pk&#x27;_Z_A, pk_B, pk&#x27;_B, pk&#x27;_B, pk&#x27;_Z_B, pk_C, pk&#x27;_C, pk&#x27;_C, pk&#x27;_C, pk&#x27;_C, pk&#x27;_H, pk&#x27;_H, pk&#x27;_Z, pk&#x27;_Z)</span> ,</li>

    </ol>

    <p class="text-gray-300">where for  <span class="math">i = n + 1,\\ldots ,m</span>  ..  <span class="math">pk_{A,i}\\coloneqq A_i(\\tau)P</span> <span class="math">pk_{A,i}^{\\prime}\\coloneqq A_i(\\tau)\\alpha P</span> <span class="math">pk_{A,i}^{\\prime \\prime}\\coloneqq A_i(\\tau)\\beta_{A}P</span></p>

    <p class="text-gray-300">for  <span class="math">i = 1,\\ldots ,m</span>  ..  <span class="math">pk_{B,i}\\coloneqq B_i(\\tau)P</span> <span class="math">pk_{B,i}^{\\prime}\\coloneqq B_i(\\tau)\\alpha P</span> <span class="math">pk_{B,i}^{\\prime \\prime}\\coloneqq B_i(\\tau)\\beta_B P</span></p>

    <p class="text-gray-300"><span class="math">pk_{C,i}\\coloneqq C_i(\\tau)P</span> <span class="math">pk_{C,i}^{\\prime}\\coloneqq C_i(\\tau)\\alpha P</span> <span class="math">pk_{C,i}^{\\prime \\prime}\\coloneqq C_i(\\tau)\\beta_{C}P</span></p>

    <p class="text-gray-300">for  <span class="math">i = 0,\\ldots ,d</span>  ..  <span class="math">pk_{H,i}\\coloneqq \\tau^i P</span> <span class="math">pk_{H,i}^{\\prime}\\coloneqq \\tau^{i}\\alpha P</span></p>

    <p class="text-gray-300">and moreover  <span class="math">pk_{Z}\\coloneqq Z(\\tau)P</span> <span class="math">pk_{Z}^{\\prime}\\coloneqq Z(\\tau)\\alpha P</span></p>

    <p class="text-gray-300"><span class="math">pk_{A,0}\\coloneqq A_0(\\tau)P</span> <span class="math">pk_{A,0}^{\\prime}\\coloneqq A_0(\\tau)\\alpha P</span> <span class="math">pk_{Z,A}^{\\prime \\prime}\\coloneqq Z(\\tau)\\beta_{A}P</span></p>

    <p class="text-gray-300"><span class="math">pk_{B,0}\\coloneqq B_0(\\tau)P</span> <span class="math">pk_{B,0}^{\\prime}\\coloneqq B_0(\\tau)\\alpha P</span> <span class="math">pk_{Z,B}^{\\prime \\prime}\\coloneqq Z(\\tau)\\beta_{B}P</span></p>

    <p class="text-gray-300"><span class="math">pk_{C,0}\\coloneqq C_0(\\tau)P</span> <span class="math">pk_{C,0}^{\\prime}\\coloneqq C_0(\\tau)\\alpha P</span> <span class="math">pk_{Z,C}^{\\prime \\prime}\\coloneqq Z(\\tau)\\beta_{C}P</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Return  <span class="math">crs \\coloneqq (vk, pk)</span> .</li>

    </ol>

    <p class="text-gray-300">PROVE. On input  <span class="math">R</span> ,  <span class="math">(vk, pk)</span>  and  <span class="math">\\vec{s} \\in \\mathbb{F}^m</span>  s.t. Eq. (6) is satisfied for some  <span class="math">H&#x27;(X) \\in \\mathbb{F}[X]</span> :</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If  <span class="math">(R, vk, pk)</span>  does not pass CRS VERIFICATION then return  <span class="math">\\perp</span> .</li>

      <li>Sample  <span class="math">\\delta_A, \\delta_B, \\delta_C \\gets \\mathbb{F}</span>  and define  <span class="math">A(X) := A_0(X) + \\sum_{i=1}^{m} s_i A_i(X) + \\delta_A Z(X)</span> .</li>

    </ol>

    <p class="text-gray-300"><span class="math">B(X)\\coloneqq B_0(X) + \\sum_{i = 1}^{m}s_iB_i(X) + \\delta_BZ(X)</span></p>

    <p class="text-gray-300"><span class="math">C(X)\\coloneqq C_0(X) + \\sum_{i = 1}^{m}s_iC_i(X) + \\delta_CZ(X)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">H(X)</span>  s.t.  <span class="math">A(X)B(X) - C(X) = H(X)Z(X)</span>  and let  <span class="math">(h_0, \\ldots, h_d) \\in \\mathbb{F}^{d+1}</span>  be its coefficients. (If  <span class="math">H&#x27;(X)</span>  satisfies Eq. (6) then  <span class="math">H(X) = H&#x27;(X) + \\delta_A B(X) + \\delta_B A(X) - \\delta_A \\delta_B Z(X) - \\delta_C</span> .)</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define  <span class="math">\\pi_A\\coloneqq \\sum_{i = n + 1}^m s_i p k_{A,i} + \\delta_A p k_Z</span> <span class="math">\\pi_A^\\prime \\coloneqq \\sum_{i = n + 1}^m s_i p k_{A,i}^\\prime +\\delta_A p k_Z^\\prime</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">\\pi_B\\coloneqq \\sum_{i = 1}^m s_i p k_{B,i} + \\delta_B p k_Z</span> <span class="math">\\pi_B^\\prime \\coloneqq \\sum_{i = 1}^m s_i p k_{B,i}^\\prime +\\delta_B p k_Z^\\prime</span></p>

    <p class="text-gray-300"><span class="math">\\pi_C\\coloneqq \\sum_{i = 1}^m s_i p k_{C,i} + \\delta_C p k_Z</span> <span class="math">\\pi_C^\\prime \\coloneqq \\sum_{i = 1}^m s_i p k_{C,i}^\\prime +\\delta_C p k_Z^\\prime</span></p>

    <p class="text-gray-300"><span class="math">\\pi_H\\coloneqq \\sum_{i = 1}^d h_i p k_{H,i}</span> <span class="math">\\pi_H^\\prime \\coloneqq \\sum_{i = 1}^d h_i p k_{H,i}^\\prime</span></p>

    <p class="text-gray-300"><span class="math">\\pi_K\\coloneqq \\sum_{i = n + 1}^m s_i p k_{A,i}&#x27;&#x27; + \\delta_A p k_{Z,A}&#x27;&#x27; + \\sum_{i = 1}^m s_i p k_{B,i}&#x27;&#x27; + \\delta_B p k_{Z,B}&#x27;&#x27; + \\sum_{i = 1}^m s_i p k_{C,i}&#x27;&#x27; + \\delta_C p k_{Z,C}&#x27;&#x27;</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Return  <span class="math">\\pi \\coloneqq (\\pi_A, \\pi_A&#x27;, \\pi_B, \\pi_B&#x27;, \\pi_C, \\pi_C&#x27;, \\pi_H, \\pi_H&#x27;, \\pi_K)</span> .</li>

    </ol>

    <p class="text-gray-300">VERIFY. On input  <span class="math">R</span> ,  <span class="math">\\nu k</span> ,  <span class="math">\\vec{x} \\in \\mathbb{F}^n</span>  and proof  <span class="math">\\pi \\in \\mathbb{G}^9</span> :</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">\\mathsf{vk}_x\\coloneqq \\mathsf{vk}_{A,0} + \\sum_{i = 1}^n x_i\\mathsf{vk}_{A,i}</span></li>

      <li>Check validity of  <span class="math">\\pi_A^\\prime</span> ,  <span class="math">\\pi_B^\\prime</span> ,  <span class="math">\\pi_C^\\prime</span>  and  <span class="math">\\pi_H^\\prime</span> :  <span class="math">\\mathbf{e}(\\pi_H^\\prime, P) = \\mathbf{e}(\\pi_H, vk_\\alpha)</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathbf{e}(\\pi_A&#x27;,P) = \\mathbf{e}(\\pi_A,vk_\\alpha)</span> <span class="math">\\mathbf{e}(\\pi_B&#x27;,P) = \\mathbf{e}(\\pi_B,vk_\\alpha)</span> <span class="math">\\mathbf{e}(\\pi_C&#x27;,P) = \\mathbf{e}(\\pi_C,vk_\\alpha)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check same coefficients were used via  <span class="math">\\pi_K</span> :  <span class="math">\\mathbf{e}(\\pi_K, vk_\\gamma) = \\mathbf{e}(\\pi_A, vk_{A,\\gamma}&#x27;&#x27;&#x27;) \\cdot \\mathbf{e}(\\pi_B, vk_{B,\\gamma}&#x27;&#x27;&#x27;) \\cdot \\mathbf{e}(\\pi_C, vk_{C,\\gamma}&#x27;&#x27;&#x27;)</span></li>

      <li>Check QAP is satisfied:  <span class="math">\\mathbf{e}(\\mathrm{vk}_x + \\pi_A,\\mathrm{vk}_{B,0} + \\pi_B) = \\mathbf{e}(\\pi_H,\\mathrm{vk}_Z)\\cdot \\mathbf{e}(\\mathrm{vk}_{C,0} + \\pi_C,P)</span></li>

      <li>If all checks in 2.-4. succeeded then return true and otherwise false.</li>

    </ol>

    <p class="text-gray-300">Figure 4: The original QAP-based SNARK [GGPR13] with CRS verification (in bold)</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check <span class="math">P \\neq 0_{\\mathbb{G}}</span>.</li>

      <li>Check correct choice of <span class="math">\\tau, \\gamma</span>: <span class="math">vk_Z \\neq 0_{\\mathbb{G}}</span> and <span class="math">vk_{\\gamma} \\neq 0_{\\mathbb{G}}</span>.</li>

      <li>Check consistency of <span class="math">pk_H</span> and <span class="math">pk_H&#x27;</span>: <span class="math">P = pk_{H,0}</span> and</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\text{for } i = 1, \\dots , d: \\quad \\mathbf{e}(p k_{H,i}, P) = \\mathbf{e}(p k_{H,i-1}, p k_{H,1}) \\\\ \\text{for } i = 0, \\dots , d: \\quad \\mathbf{e}(p k_{H,i}^{\\prime}, P) = \\mathbf{e}(p k_{H,i}, v k_{\\alpha}) \\end{array}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check consistency of <span class="math">vk</span>:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\text{for } i = 0, \\dots , n: v k_{A,i} = \\sum_{j=0}^{d-1} a_{i,j} p k_{H,j} \\\\ v k_{B,0} = \\sum_{j=0}^{d-1} b_{0,j} p k_{H,j} \\quad v k_{C,0} = \\sum_{j=0}^{d-1} c_{0,j} p k_{H,j} \\quad v k_{Z} = \\sum_{j=0}^{d} z_{j} p k_{H,j} \\end{array}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check consistency of the remaining <span class="math">pk</span> elements: for <span class="math">i = n + 1, \\ldots, m</span>:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">p k_{A,i} = \\sum_{j=0}^{d-1} a_{i,j} p k_{H,j} \\quad \\mathbf{e}(p k_{A,i}^{\\prime}, P) = \\mathbf{e}(p k_{A,i}, v k_{\\alpha}) \\quad \\mathbf{e}(p k_{A,i}^{\\prime \\prime}, v k_{\\gamma}) = \\mathbf{e}(p k_{A,i}, v k_{A,\\gamma}^{\\prime \\prime})</span></div>

    <p class="text-gray-300">for <span class="math">i = 1,\\ldots ,m</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} p k_{B,i} = \\sum_{j=0}^{d-1} b_{i,j} p k_{H,j} \\quad \\mathbf{e}(p k_{B,i}^{\\prime}, P) = \\mathbf{e}(p k_{B,i}, v k_{\\alpha}) \\quad \\mathbf{e}(p k_{B,i}^{\\prime \\prime}, v k_{\\gamma}) = \\mathbf{e}(p k_{B,i}, v k_{B,\\gamma}^{\\prime \\prime}) \\\\ p k_{C,i} = \\sum_{j=0}^{d-1} c_{i,j} p k_{H,j} \\quad \\mathbf{e}(p k_{C,i}^{\\prime}, P) = \\mathbf{e}(p k_{C,i}, v k_{\\alpha}) \\quad \\mathbf{e}(p k_{C,i}^{\\prime \\prime}, v k_{\\gamma}) = \\mathbf{e}(p k_{C,i}, v k_{C,\\gamma}^{\\prime \\prime}) \\end{array}</span></div>

    <p class="text-gray-300">and moreover:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} p k_{Z} = \\sum_{j=0}^{d} z_{i} p k_{H,j} \\quad \\mathbf{e}(p k_{Z}^{\\prime}, P) = \\mathbf{e}(p k_{Z}, v k_{\\alpha}) \\\\ p k_{A,0} = v k_{A,0} \\quad \\mathbf{e}(p k_{A,0}^{\\prime}, P) = \\mathbf{e}(p k_{A,0}, v k_{\\alpha}) \\quad \\mathbf{e}(p k_{Z,A}^{\\prime \\prime}, v k_{\\gamma}) = \\mathbf{e}(p k_{Z}, v k_{A,\\gamma}^{\\prime \\prime}) \\\\ p k_{B,0} = v k_{B,0} \\quad \\mathbf{e}(p k_{B,0}^{\\prime}, P) = \\mathbf{e}(p k_{B,0}, v k_{\\alpha}) \\quad \\mathbf{e}(p k_{Z,B}^{\\prime \\prime}, v k_{\\gamma}) = \\mathbf{e}(p k_{Z}, v k_{B,\\gamma}^{\\prime \\prime}) \\\\ p k_{C,0} = v k_{C,0} \\quad \\mathbf{e}(p k_{C,0}^{\\prime}, P) = \\mathbf{e}(p k_{C,0}, v k_{\\alpha}) \\quad \\mathbf{e}(p k_{Z,C}^{\\prime \\prime}, v k_{\\gamma}) = \\mathbf{e}(p k_{Z}, v k_{C,\\gamma}^{\\prime \\prime}) \\end{array}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If all checks in 2.–5. succeeded then return true and otherwise false.</li>

    </ol>

    <p class="text-gray-300"><strong>Standard security.</strong> Adding CRS verification to Gennaro et al.’s scheme does not alter its security as proved in [GGPR13]. In fact, knowledge soundness is a notion that is independent of the prove algorithm <span class="math">\\Pi.P</span> and it follows by inspection that an honestly computed CRS satisfies verification.</p>

    <p class="text-gray-300"><strong>Theorem 4.1</strong> ([GGPR13]) Let <span class="math">\\mathsf{Rg}</span> be a relation generator that on input <span class="math">1^{\\lambda}</span> returns a QAP of degree at most <span class="math">d(\\lambda)</span> over a symmetric group <span class="math">\\mathrm{Gr}</span>. Define a group generator <span class="math">\\mathsf{sGen}</span> that returns the first output <span class="math">\\mathrm{Gr}</span> of <span class="math">\\mathsf{Rg}</span> and let <span class="math">q := \\max\\{2d - 1, d + 2\\}</span>. If the <span class="math">q</span>-PDH and the <span class="math">d</span>-PKE assumptions hold for <span class="math">\\mathsf{sGen}</span> then the scheme in Figure 4 for <span class="math">\\mathsf{Rg}</span> is knowledge-sound. Moreover, it is statistical zero-knowledge.</p>

    <p class="text-gray-300"><strong>CRS verifiability.</strong> We show that a CRS that passes verification is constructed as in KEY GENERATION, that is, that exist values <span class="math">\\tau, \\alpha, \\beta_A, \\beta_B, \\beta_C \\in \\mathbb{F}</span> such that the conditions in Item 1. of KEY GENERATION are satisfied and <span class="math">vk</span> and <span class="math">pk</span> are as in Items 2. and 3. Let <span class="math">\\tau, \\alpha, \\xi_A, \\xi_B, \\xi_C, \\gamma \\in \\mathbb{F}</span> be the discrete logarithms of the elements <span class="math">pk_{H,1}</span>, <span class="math">vk_{\\alpha}</span>, <span class="math">vk_{A,\\gamma}^{\\prime \\prime}</span>, <span class="math">vk_{B,\\gamma}^{\\prime \\prime}</span>, <span class="math">vk_{C,\\gamma}^{\\prime \\prime}</span> and <span class="math">vk_{\\gamma}</span>, respectively. By Check 2. in CRS VERIFICATION we have that <span class="math">\\gamma \\neq 0</span>. Define <span class="math">\\beta_A := x_A \\gamma^{-1}</span>, <span class="math">\\beta_B := x_B \\gamma^{-1}</span>, <span class="math">\\beta_C := x_C \\gamma^{-1}</span>.</p>

    <p class="text-gray-300">19</p>

    <p class="text-gray-300">Check 3. ensures that  <span class="math">pk_{H}</span>  and  <span class="math">pk_{H}</span>  are correctly computed w.r.t.  <span class="math">\\tau</span>  and  <span class="math">\\alpha</span>  and Check 4. ensures that  <span class="math">\\{\\nu k_{A,i}\\}_{i=0}^{n}</span> ,  <span class="math">\\nu k_{B,0}</span>  and  <span class="math">\\nu k_{C,0}</span>  are correctly computed w.r.t.  <span class="math">\\tau</span> .</p>

    <p class="text-gray-300">Check 5. ensures that  <span class="math">\\{pk_{A,i}, pk_{A,i}^{\\prime}, pk_{A,i}^{\\prime \\prime}\\}_{i = n + 1}^{m}</span>  are correctly computed w.r.t.  <span class="math">\\tau</span> ,  <span class="math">\\alpha</span>  and  <span class="math">\\beta_{A}</span> ; and  <span class="math">\\{pk_{B,i}, pk_{B,i}^{\\prime}, pk_{B,i}^{\\prime \\prime}, pk_{C,i}, pk_{C,i}^{\\prime}, pk_{C,i}^{\\prime \\prime}\\}_{i = 1}^{m}</span>  are correctly computed w.r.t.  <span class="math">\\tau</span> ,  <span class="math">\\alpha</span> ,  <span class="math">\\beta_{B}</span>  and  <span class="math">\\beta_{C}</span> . Moreover, it checks that  <span class="math">pk_{Z}, pk_{Z}^{\\prime}, pk_{A,0}, pk_{A,0}^{\\prime}, pk_{Z,A}^{\\prime \\prime}, pk_{B,0}, pk_{B,0}^{\\prime}, pk_{Z,B}^{\\prime \\prime}, pk_{C,0}, pk_{C,0}^{\\prime}</span>  and  <span class="math">pk_{Z,C}^{\\prime \\prime}</span>  are also of the correct form.</p>

    <p class="text-gray-300">Trapdoor extraction. In order to prove subversion zero knowledge, we construct a simulator (Π.Sim.crs, Π.Sim.pf) for any CRS subvertor. Let X be a CRS subvertor that returns  <span class="math">(\\nu k, pk)</span> . Define  <span class="math">X&#x27;(1^{\\lambda}; r)</span>  that runs  <span class="math">(\\nu k, pk) \\gets X(1^{\\lambda}; r)</span> , parses  <span class="math">\\nu k</span>  and  <span class="math">pk</span>  as in Figure 4 and returns  <span class="math">(pk_{H,0}, pk_{H,1}, pk_{H,2})</span> . By SKE (Definition 2.14) there exists a PT algorithm  <span class="math">\\mathsf{E}_{\\mathsf{X}&#x27;}</span>  such that if for some  <span class="math">P \\in \\mathbb{G}</span> ,  <span class="math">\\tau \\in \\mathbb{F}</span> :  <span class="math">pk_{H,0} = P</span> ,  <span class="math">pk_{H,1} = \\tau P</span> ,  <span class="math">pk_{H,2} = \\tau^2 P</span>  then with overwhelming probability  <span class="math">\\mathsf{E}_{\\mathsf{X}&#x27;}</span>  extracts  <span class="math">\\tau</span> . Using  <span class="math">\\mathsf{E}_{\\mathsf{X}&#x27;}</span>  we define the CRS simulator S.crs as follows: On input  <span class="math">1^{\\lambda}</span>  do the following:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample randomness for  <span class="math">\\mathsf{X}</span> :  <span class="math">r\\gets \\mathfrak{s}\\{0,1\\}^{\\mathsf{X},\\mathsf{r}(\\lambda)}</span></li>

      <li>Run  <span class="math">(\\nu k, pk) \\gets X(1^{\\lambda}; r)</span> .</li>

      <li>If  <span class="math">(R, vk, pk)</span>  passes verification then  <span class="math">\\tau \\gets \\mathfrak{s} \\mathsf{E}_{\\mathsf{X}&#x27;}(1^{\\lambda}, r)</span> ; else  <span class="math">\\tau \\gets \\bot</span></li>

      <li>Return  <span class="math">((vk, pk), r, \\tau)</span> .</li>

    </ol>

    <p class="text-gray-300">Proof simulation. Given  <span class="math">(\\nu k, pk)</span> , trapdoor  <span class="math">\\tau</span>  and a statement  <span class="math">x \\in \\mathbb{F}^n</span> , the proof simulator S.pf is defined as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If  <span class="math">\\tau = \\bot</span>  then return  <span class="math">\\bot</span> .</li>

      <li>Use  <span class="math">\\tau</span>  to compute  <span class="math">Z(\\tau)</span>  (which in a verified CRS is non-zero). Compute the following "simulation keys":</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">s k _ {A} := Z (\\tau) ^ {- 1} p k _ {Z, A} ^ {\\prime \\prime} \\quad s k _ {B} := Z (\\tau) ^ {- 1} p k _ {Z, B} ^ {\\prime \\prime} \\quad s k _ {C} := Z (\\tau) ^ {- 1} p k _ {Z, C} ^ {\\prime \\prime}</span></div>

    <p class="text-gray-300">(For a valid CRS, we have  <span class="math">sk_A = \\beta_A P</span>  and  <span class="math">sk_B = \\beta_B P</span>  and  <span class="math">sk_C = \\beta_C P</span> .)</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define  <span class="math">v_{x} \\coloneqq \\sum_{j=0}^{d-1} a_{0,j} \\tau^{j} + \\sum_{i=1}^{n} x_{i} \\sum_{j=0}^{d-1} a_{i,j} \\tau^{j}</span> . Set  <span class="math">vk_{x} \\coloneqq v_{x} P</span>  and  <span class="math">vk_{x}&#x27; \\coloneqq v_{x} vk_{\\alpha}</span> .</li>

      <li>Choose  <span class="math">a, b, c \\gets \\mathbb{F}</span>  and define the proof  <span class="math">\\pi := (\\pi_A, \\pi_A&#x27;, \\pi_B, \\pi_B&#x27;, \\pi_C, \\pi_C&#x27;, \\pi_K, \\pi_H)</span>  as follows:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\pi_A \\coloneqq (a - v_x)P = aP - vk_x</span> <span class="math">\\pi_A&#x27; \\coloneqq (a - v_x)vk_\\alpha</span></p>

    <p class="text-gray-300"><span class="math">\\pi_B\\coloneqq (b - B_0(\\tau))P = bP - vk_{B,0}</span> <span class="math">\\pi_B^\\prime \\coloneqq (b - B_0(\\tau))vk_\\alpha</span></p>

    <p class="text-gray-300"><span class="math">\\pi_C \\coloneqq (c - C_0(\\tau))P = cP - vk_{C,0}</span> <span class="math">\\pi_C^\\prime \\coloneqq (c - C_0(\\tau))vk_\\alpha</span></p>

    <p class="text-gray-300"><span class="math">\\pi_H\\coloneqq Z(\\tau)^{-1}(ab - c)P</span> <span class="math">\\pi_H^\\prime \\coloneqq Z(\\tau)^{-1}(ab - c)vk_\\alpha</span></p>

    <p class="text-gray-300"><span class="math">\\pi_K \\coloneqq (a - v_x)sk_A + (b - B_0(\\tau))sk_B + (c - C_0(\\tau))sk_C</span></p>

    <p class="text-gray-300">Theorem 4.2 Let  <span class="math">\\mathsf{Rg}</span>  be a relation generator that outputs strong QAPs and implicitly defines a symmetric bilinear-group generator sGen. If SKE holds for sGen then the GGPR QAP-based SNARK [GGPR13] with CRS verification given in Figure 4 for  <span class="math">\\mathsf{Rg}</span>  satisfies subversion zero knowledge.</p>

    <p class="text-gray-300">Proof. Consider  <span class="math">(\\nu k, pk) \\gets X(1^{\\lambda}; r)</span>  and let  <span class="math">E</span>  denote the event that  <span class="math">(R, \\nu k, pk)</span>  passes CRS verification (in which case  <span class="math">X</span>  returns  <span class="math">(P, \\tau P, \\tau^{2}P)</span> ) but  <span class="math">\\mathsf{E}_{\\mathsf{X}&#x27;}</span>  fails to extract  <span class="math">\\tau</span> . Since a correct  <span class="math">(\\nu k, pk)</span>  satisfies  <span class="math">\\mathbf{e}(pk_{H,1}, pk_{H,1}) = \\mathbf{e}(pk_{H,0}, pk_{H,2})</span> , by assumption SKE the probability of  <span class="math">E</span>  is</p>

    <p class="text-gray-300">egligible. It suffices thus to show that, conditioned on <span class="math">E</span> not happening, the probability that <span class="math">\\mathsf{A}</span> outputs <span class="math">1</span> in game S-ZK when <span class="math">b=0</span> is the same as when <span class="math">b=1</span>.</p>

    <p class="text-gray-300">If <span class="math">(vk,pk)</span> does not pass verification then <span class="math">\\tau=\\bot</span> and both prover and proof simulator return <span class="math">\\bot</span>.</p>

    <p class="text-gray-300">If <span class="math">(vk,pk)</span> verifies then (because of <span class="math">\\neg E</span>) <span class="math">\\mathsf{E}_{\\mathsf{X}^{\\prime}}</span> extracts <span class="math">\\tau</span>. We show that the outputs of the prover and the proof simulator are distributed equivalently. Above we showed that if the CRS verifies then there exist <span class="math">\\tau,\\alpha,\\beta_{A},\\beta_{B},\\beta_{C},\\gamma\\in\\mathbb{F}</span> with <span class="math">Z(\\tau)\\neq 0</span> and <span class="math">\\gamma\\neq 0</span> such that <span class="math">vk</span> and <span class="math">pk</span> are defined as in Items 2. and 3. in Key generation.</p>

    <p class="text-gray-300">Moreover, in a real proof the elements <span class="math">\\delta_{A}Z(\\tau)P</span> in <span class="math">\\pi_{A}</span> and <span class="math">\\delta_{B}Z(\\tau)P</span> in <span class="math">\\pi_{B}</span> and <span class="math">\\delta_{C}Z(\\tau)P</span> in <span class="math">\\pi_{C}</span> make <span class="math">\\pi_{A}</span>, <span class="math">\\pi_{B}</span> and <span class="math">\\pi_{C}</span> uniformly random. For a fixed <span class="math">vk</span> and <span class="math">\\pi_{A}</span>, <span class="math">\\pi_{B}</span> and <span class="math">\\pi_{C}</span>, the equations in 2. of Verify uniquely determine <span class="math">\\pi_{A}^{\\prime}</span>, <span class="math">\\pi_{B}^{\\prime}</span> and <span class="math">\\pi_{C}^{\\prime}</span>, and the equations in 3. and 4. uniquely determine <span class="math">\\pi_{K}</span> and <span class="math">\\pi_{H}</span> (since <span class="math">vk_{\\gamma}\\neq 0_{\\mathbb{G}}</span> and <span class="math">vk_{Z}\\neq 0_{\\mathbb{G}}</span>).</p>

    <p class="text-gray-300">In a simulated proof <span class="math">\\pi_{A}</span>, <span class="math">\\pi_{B}</span> and <span class="math">\\pi_{C}</span> are also uniformly random, so it suffices to show that the remaining proof elements satisfy the verification equations:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{e}(\\pi_{A}^{\\prime},P)</span> <span class="math">=\\mathbf{e}\\big{(}(a-v_{x})\\alpha P,\\,P\\big{)}=\\mathbf{e}(\\pi_{A},vk_{\\alpha})</span> <span class="math">\\mathbf{e}(\\pi_{B}^{\\prime},P)</span> <span class="math">=\\mathbf{e}\\big{(}(b-B_{0}(\\tau))\\alpha P,\\,P\\big{)}=\\mathbf{e}(\\pi_{B},vk_{\\alpha})</span> <span class="math">\\mathbf{e}(\\pi_{C}^{\\prime},P)</span> <span class="math">=\\mathbf{e}\\big{(}(c-C_{0}(\\tau))\\alpha P,\\,P\\big{)}=\\mathbf{e}(\\pi_{C},vk_{\\alpha})</span> <span class="math">\\mathbf{e}(\\pi_{K},vk_{\\gamma})</span> <span class="math">=\\mathbf{e}\\big{(}(a-v_{x})\\beta_{A}P+(b-B_{0}(\\tau))\\beta_{B}P+(c-C_{0}(\\tau))\\beta_{C}P,\\,\\gamma P\\big{)}</span> <span class="math">=\\mathbf{e}(\\pi_{A},vk_{A,\\gamma}^{\\prime\\prime})\\cdot\\mathbf{e}(\\pi_{B},vk_{B,\\gamma}^{\\prime\\prime})\\cdot\\mathbf{e}(\\pi_{C},vk_{C,\\gamma}^{\\prime\\prime})</span> <span class="math">\\mathbf{e}(\\pi_{H},vk_{Z})</span> <span class="math">=\\mathbf{e}\\big{(}Z(\\tau)^{-1}(ab-c)P,Z(\\tau)P\\big{)}=\\mathbf{e}\\big{(}aP,bP\\big{)}\\cdot\\mathbf{e}\\big{(}cP,P\\big{)}^{-1}</span> <span class="math">=\\mathbf{e}(vk_{x}+\\pi_{A},vk_{B,0}+\\pi_{B})\\cdot\\mathbf{e}(vk_{C,0}+\\pi_{C},P)^{-1}</span></p>

    <p class="text-gray-300">This concludes the proof.</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Corollary 4.3</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{Rg}</span> be a relation generator that outputs strong QAPs. The GGPR QAP-based SNARK <em>[x10]</em> with CRS verification (Figure 4) for <span class="math">\\mathsf{Rg}</span> satisfies perfect subversion witness indistinguishability.</p>

    <p class="text-gray-300">Proof. In Theorem 4.2 we showed that proofs under a (possibly maliciously generated but) valid CRS are uniform group elements subject to satisfying the verification equation. Proofs using different witnesses are thus equally distributed.</p>

    <h3 id="sec-46" class="text-xl font-semibold mt-8">GGPR’s QSP-Based SNARK</h3>

    <p class="text-gray-300">Gennaro et al. <em>[x10]</em> also introduced (strong) quadratic span programs (QSP) and show how to efficiently convert any <em>boolean</em> circuit into an equivalent strong QSP. Strong QSPs are defined similarly to QAPs (Definition 3.3) except that there are no polynomials <span class="math">C_{i}(X)</span> and the coefficients can be different (like <span class="math">(r_{1},\\ldots,r_{m})</span> and <span class="math">(s_{1},\\ldots,s_{m})</span> in Eq. (7)). Moreover the statement <span class="math">x\\in\\{0,1\\}^{n^{\\prime}}</span> with <span class="math">n=2n^{\\prime}</span> is mapped to <span class="math">\\vec{r}</span> and <span class="math">\\vec{s}</span> as follows: for <span class="math">i\\in\\{1,\\ldots,n^{\\prime}\\}</span>: <span class="math">r_{2i}=s_{2i}:=x_{i}</span> and <span class="math">r_{2i-1}=s_{2i-1}:=1-x_{i}</span>.</p>

    <p class="text-gray-300">The first SNARK construction in <em>[x10]</em> is based on strong QSPs and is obtained by setting <span class="math">C_{i}(X):\\equiv 0</span> for all <span class="math">i</span> in the QAP-based one above. It is straightforward to verify that all our results for the QAP-based construction carry over to the QSP-based SNARK.</p>

    <p class="text-gray-300">5 Asymmetric Pinocchio</p>

    <p class="text-gray-300">Pinocchio <em>[x20]</em> is one of the central SNARK systems. Ben-Sasson, Chiesa, Tromer and Virza <em>[x1]</em> proposed a variant in asymmetric groups for which they also shorten the verification key. Their system is implemented in libsnark <em>[BCG^{+}14b]</em> and underlies Zcash.</p>

    <p class="text-gray-300">Campanelli et al. <em>[x11]</em> show that the protocol is not subversion-zero-knowledge and expect major changes to make it secure. In the following we show that by adding merely 4 group elements to the CRS (which we denote by <span class="math">ck</span> for “checking key”), we can enable verification of well-formedness of <span class="math">(vk,pk)</span> by using the pairing available in the bilinear group. We then show that under SKE (Definition 2.15), our modification of the scheme from <em>[x1]</em> achieves subversion zero knowledge. The protocol is given in Figure 5, where we underlined our modifications. Below we define procedure CRS verification, which a prover runs on a CRS before first using it.</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Theorem 5.1 (<em>[x20, x1]</em>)</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{Rg}</span> be a relation generator that on input <span class="math">1^{\\lambda}</span> returns a QAP of degree at most <span class="math">d(\\lambda)</span> over an asymmetric group <span class="math">\\mathsf{Gr}</span> such that <span class="math">A_{0},\\ldots,A_{n}</span> are linearly independent and <span class="math">\\mathrm{span}(A_{0},\\ldots,A_{n})\\cap\\mathrm{span}(A_{n+1},\\ldots,A_{m})=\\{0\\}</span>. Define a group generator <span class="math">\\mathsf{aGen}</span> that returns the first output <span class="math">\\mathsf{Gr}</span> of <span class="math">\\mathsf{Rg}</span> and let <span class="math">q:=4d+4</span>. If the <span class="math">q</span>-PDH, the <span class="math">q</span>-PKE and the <span class="math">2q</span>-SDH assumptions hold for <span class="math">\\mathsf{aGen}</span> then the scheme in Figure 5 without including <span class="math">ck</span> in the CRS is knowledge-sound. Moreover, it is statistical zero-knowledge.</p>

    <h4 id="sec-48" class="text-lg font-semibold mt-6">Standard security.</h4>

    <p class="text-gray-300">Inspecting the proof of the theorem in <em>[x20]</em>, it is easily seen that the additional elements contained in <span class="math">ck</span> can be produced by the reduction. Moreover, knowledge soundness is independent of the prove algorithm <span class="math">\\mathsf{\\Pi.P}</span>, and a correctly generated CRS passes CRS verification. This yields the following.</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Corollary 5.2 (to Theorem 5.1)</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{Rg}</span> and <span class="math">\\mathsf{aGen}</span> be as in Theorem 5.1. If the <span class="math">q</span>-PDH, the <span class="math">q</span>-PKE and the <span class="math">2q</span>-SDH assumptions hold for <span class="math">\\mathsf{aGen}</span> for <span class="math">q:=4d+4</span> then the scheme in Figure 5 is knowledge-sound. Moreover, it is statistical zero-knowledge.</p>

    <h4 id="sec-50" class="text-lg font-semibold mt-6">CRS verification.</h4>

    <p class="text-gray-300">On input <span class="math">(R,vk,pk,ck)</span>, let <span class="math">\\{a_{i,j}\\}</span>, <span class="math">\\{b_{i,j}\\}</span>, <span class="math">\\{c_{i,j}\\}</span>, <span class="math">\\{z_{k}\\}</span> denote the coefficients of <span class="math">A_{i}(X)</span>, <span class="math">B_{i}(X)</span>, <span class="math">C_{i}(X)</span> and <span class="math">Z(X)</span>, respectively, for <span class="math">0\\leq i\\leq m</span> and <span class="math">0\\leq j\\leq d-1</span> and <span class="math">0\\leq k\\leq d</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check <span class="math">P_{1}\\neq 0_{\\mathbb{G}_{1}}</span> and <span class="math">P_{2}\\neq 0_{\\mathbb{G}_{2}}</span>.</li>

      <li>Check choice of secret values: <span class="math">ck_{A}\\neq 0_{\\mathbb{G}_{2}},\\;ck_{B}\\neq 0_{\\mathbb{G}_{2}},\\;vk_{\\gamma}\\neq 0_{\\mathbb{G}_{2}},\\;vk_{\\beta\\gamma}\\neq 0_{\\mathbb{G}_{1}}</span> and <span class="math">vk_{Z}\\neq 0_{\\mathbb{G}_{2}}</span>.</li>

      <li>Check consistency of <span class="math">pk_{H}</span>: Check <span class="math">pk_{H,0}=P_{1}</span>; and for <span class="math">i=1,\\ldots,d</span>:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathbf{e}(pk_{H,i},P_{2})=\\mathbf{e}(pk_{H,i-1},ck_{H})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check consistency of <span class="math">pk_{A},pk^{\\prime}_{A},pk_{B},pk^{\\prime}_{B}</span>: for <span class="math">i=n+1,\\ldots,m+3</span>:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathbf{e}(pk_{A,i},P_{2})=\\mathbf{e}(\\sum_{j=0}^{d-1}a_{i,j}pk_{H,j},ck_{A})\\qquad</span> <span class="math">\\mathbf{e}(pk^{\\prime}_{A,i},P_{2})=\\mathbf{e}(pk_{A,i},vk_{A})</span></p>

    <p class="text-gray-300">and for <span class="math">i=0,\\ldots,m+3</span>:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{e}(P_{1},pk_{B,i})=\\mathbf{e}(\\sum_{j=0}^{d-1}b_{i,j}pk_{H,j},ck_{B})\\qquad</span> <span class="math">\\mathbf{e}(pk^{\\prime}_{B,i},P_{2})=\\mathbf{e}(vk_{B},pk_{B,i})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check consistency of <span class="math">ck_{C}</span>: <span class="math">\\mathbf{e}\\big{(}pk_{A,m+1},ck_{B})=\\mathbf{e}\\big{(}\\sum_{j=0}^{d}z_{j}pk_{H,j},ck_{C}\\big{)}</span></li>

    </ol>

    <p class="text-gray-300">(Note that for an honest CRS we have <span class="math">pk_{A,m+1}=Z(\\tau)\\rho_{A}P_{1}\\neq 0</span>.)</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check consistency of <span class="math">vk</span>: for <span class="math">i=0,\\ldots,n</span>: <span class="math">\\mathbf{e}(vk_{IC,i},P_{2})=\\mathbf{e}(\\sum_{j=0}^{d-1}a_{i,j}pk_{H,j},ck_{A})</span> and</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathbf{e}(vk_{\\beta\\gamma},P_{2})=\\mathbf{e}(P_{1},\\widehat{vk}_{\\beta\\gamma})\\qquad\\qquad\\mathbf{e}(P_{1},vk_{Z})=\\mathbf{e}\\big{(}\\sum_{j=0}^{d}z_{j}pk_{H,j},ck_{C}\\big{)}</span></p>

    <p class="text-gray-300">KEY GENERATION. On input  <span class="math">R</span>  as in Eq. (8) representing a QAP for an asymmetric group  <span class="math">Gr</span>  do the following:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample  <span class="math">P_{1}\\leftrightarrow \\mathbb{G}_{1}^{<em>}</span>  and  <span class="math">P_{2}\\leftrightarrow \\mathbb{G}_{2}^{</em>}</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">\\begin{bmatrix} A_{m+1} &amp;amp; B_{m+1} &amp;amp; C_{m+1} \\\\ A_{m+2} &amp;amp; B_{m+2} &amp;amp; C_{m+2} \\\\ A_{m+3} &amp;amp; B_{m+3} &amp;amp; C_{m+3} \\end{bmatrix} := \\begin{bmatrix} Z &amp;amp; 0 &amp;amp; 0 \\\\ 0 &amp;amp; Z &amp;amp; 0 \\\\ 0 &amp;amp; 0 &amp;amp; Z \\end{bmatrix}</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample random  <span class="math">\\rho_A, \\rho_B, \\beta, \\gamma \\gets \\mathbb{F}^*</span>  and  <span class="math">\\tau, \\alpha_A, \\alpha_B, \\alpha_C, \\gets \\mathbb{F}</span> , conditioned on  <span class="math">Z(\\tau) \\neq 0</span> .</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">\\nu k = (P_{1}, P_{2}, \\nu k_{A}, \\nu k_{B}, \\nu k_{C}, \\nu k_{\\gamma}, \\nu k_{\\beta \\gamma}, \\widehat{\\nu k_{\\beta \\gamma}}, \\nu k_{Z}, \\nu k_{IC})</span> , where</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\nu k_{A}\\coloneqq \\alpha_{A}P_{2}</span></p>

    <p class="text-gray-300"><span class="math">\\nu k_{B}\\coloneqq \\alpha_{B}P_{1}</span></p>

    <p class="text-gray-300"><span class="math">\\nu k_{C}\\coloneqq \\alpha_{C}P_{2}</span></p>

    <p class="text-gray-300"><span class="math">\\nu k_{\\gamma}\\coloneqq \\gamma P_2</span></p>

    <p class="text-gray-300"><span class="math">\\nu k_{\\beta \\gamma}\\coloneqq \\gamma \\beta P_1</span></p>

    <p class="text-gray-300"><span class="math">\\widehat{\\nu k}_{\\beta \\gamma}\\coloneqq \\gamma \\beta P_2</span></p>

    <p class="text-gray-300"><span class="math">\\nu k_{Z}:= Z(\\tau)\\rho_{A}\\rho_{B}P_{2}</span></p>

    <p class="text-gray-300"><span class="math">\\{v k_{IC,i}\\}_{i = 0}^{n}:= \\{A_{i}(\\tau)\\rho_{A}P_{1}\\}_{i = 0}^{n}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">pk = (pk_A, pk&#x27;_A, pk_B, pk&#x27;_B, pk_C, pk&#x27;_C, pk_K, pk_H)</span>  where</li>

    </ol>

    <p class="text-gray-300">for  <span class="math">i = n + 1,\\ldots ,m + 3</span>  .  <span class="math">pk_{A,i}\\coloneqq A_i(\\tau)\\rho_A P_1</span> <span class="math">pk_{A,i}^{\\prime}\\coloneqq A_{i}(\\tau)\\alpha_{A}\\rho_{A}P_{1}</span></p>

    <p class="text-gray-300">for  <span class="math">i = 0,\\ldots ,m + 3</span>  .  <span class="math">pk_{B,i}\\coloneqq B_i(\\tau)\\rho_BP_2</span> <span class="math">pk_{B,i}^{\\prime}\\coloneqq B_{i}(\\tau)\\alpha_{B}\\rho_{B}P_{1}</span></p>

    <p class="text-gray-300"><span class="math">pk_{C,i}\\coloneqq C_i(\\tau)\\rho_A\\rho_BP_1</span> <span class="math">pk_{C,i}^{\\prime}\\coloneqq C_{i}(\\tau)\\alpha_{C}\\rho_{A}\\rho_{B}P_{1}</span></p>

    <p class="text-gray-300"><span class="math">pk_{K,i}\\coloneqq \\beta (A_i(\\tau)\\rho_A + B_i(\\tau)\\rho_B + C_i(\\tau)\\rho_A\\rho_B)P_1</span></p>

    <p class="text-gray-300">for  <span class="math">i = 0,\\ldots ,d</span>  .  <span class="math">pk_{H,i}\\coloneqq \\tau^i P_1</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">ck \\coloneqq (ck_A, ck_B, ck_C, ck_H)</span>  where  <span class="math">ck_A \\coloneqq \\rho_A P_2</span> ,  <span class="math">ck_B \\coloneqq \\rho_B P_2</span> ,  <span class="math">ck_C \\coloneqq \\rho_A \\rho_B P_2</span> ,  <span class="math">ck_H \\coloneqq \\tau P_2</span> .</li>

      <li>Return  <span class="math">crs \\coloneqq (\\nu k, pk, ck)</span> .</li>

    </ol>

    <p class="text-gray-300">PROVE. On input  <span class="math">R</span> ,  <span class="math">(\\nu k, pk, ck)</span>  and  <span class="math">\\vec{s} \\in \\mathbb{F}^m</span>  s.t. Eq. (6) is satisfied for some  <span class="math">H&#x27;(X) \\in \\mathbb{F}[X]</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If  <span class="math">(R, vk, pk, ck)</span>  does not pass CRS VERIFICATION then return  <span class="math">\\perp</span> .</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample  <span class="math">\\delta_A, \\delta_B, \\delta_C \\gets \\mathbb{F}</span>  and define  <span class="math">A(X) := A_0(X) + \\sum_{i=1}^{m} s_i A_i(X) + \\delta_A Z(X)</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">B(X)\\coloneqq B_0(X) + \\sum_{i = 1}^{m}s_iB_i(X) + \\delta_BZ(X)</span></p>

    <p class="text-gray-300"><span class="math">C(X)\\coloneqq C_0(X) + \\sum_{i = 1}^{m}s_iC_i(X) + \\delta_CZ(X)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">H(X)</span>  such that  <span class="math">A(X)B(X) - C(X) = H(X)Z(X)</span> ; let  <span class="math">(h_0, \\ldots, h_d) \\in \\mathbb{F}^{d+1}</span>  be its coefficients.</li>

      <li>For  <span class="math">i = 0, \\dots, n</span>  let  <span class="math">pk_{A,i} := 0</span>  and  <span class="math">pk_{A,i}&#x27; := 0</span></li>

      <li>Let  <span class="math">\\vec{c} := 1 \\parallel \\vec{s} \\parallel \\delta_A \\parallel \\delta_B \\parallel \\delta_C \\in \\mathbb{F}^{m+4}</span>  and compute (" <span class="math">\\langle \\cdot, \\cdot \\rangle</span> " denotes the scalar product)</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\pi_A\\coloneqq \\langle \\vec{c},pk_A\\rangle</span></p>

    <p class="text-gray-300"><span class="math">\\pi_A^{\\prime}:= \\langle \\vec{c},\\overline{pk_{A}^{\\prime}}\\rangle</span></p>

    <p class="text-gray-300"><span class="math">\\pi_B\\coloneqq \\langle \\vec{c},pk_B\\rangle</span></p>

    <p class="text-gray-300"><span class="math">\\pi_B^{\\prime}:= \\langle \\vec{c},pk_{B^{\\prime}}\\rangle</span></p>

    <p class="text-gray-300"><span class="math">\\pi_C\\coloneqq \\langle \\vec{c},pk_C\\rangle</span></p>

    <p class="text-gray-300"><span class="math">\\pi_C^{\\prime}:= \\langle \\vec{c},pk_C^{\\prime}\\rangle</span></p>

    <p class="text-gray-300"><span class="math">\\pi_K\\coloneqq \\langle \\vec{c},pk_K\\rangle</span></p>

    <p class="text-gray-300"><span class="math">\\pi_H\\coloneqq \\langle \\vec{h},pk_H\\rangle</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Return  <span class="math">\\pi \\coloneqq (\\pi_A,\\pi_A&#x27;,\\pi_B,\\pi_B&#x27;,\\pi_C,\\pi_C&#x27;,\\pi_K,\\pi_H)</span></li>

    </ol>

    <p class="text-gray-300">VERIFY. On input  <span class="math">R</span> ,  <span class="math">\\nu k</span> ,  <span class="math">\\vec{x} \\in \\mathbb{F}^n</span>  and proof  <span class="math">\\pi \\in \\mathbb{G}_1^7 \\times \\mathbb{G}_2</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">\\nu k_{x} := \\nu k_{IC,0} + \\sum_{i=1}^{n} x_{i} \\nu k_{IC,i}</span> .</li>

      <li>Check validity of  <span class="math">\\pi_A^\\prime</span> ,  <span class="math">\\pi_B^\\prime</span> , and  <span class="math">\\pi_C^\\prime</span> :</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathbf{e}(\\pi_A&#x27;,P_2) = \\mathbf{e}(\\pi_A,vk_A)</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{e}(\\pi_B&#x27;,P_2) = \\mathbf{e}(\\nu k_B,\\pi_B)</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{e}(\\pi_C&#x27;,P_2) = \\mathbf{e}(\\pi_C,vk_C)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check same coefficients were used via  <span class="math">\\pi_K</span> :  <span class="math">\\mathbf{e}(\\pi_K, vk_\\gamma) = \\mathbf{e}(vk_x + \\pi_A + \\pi_C, \\widehat{vk}_{\\beta \\gamma}) \\cdot \\mathbf{e}(vk_{\\beta \\gamma}, \\pi_B)</span></li>

      <li>Check QAP is satisfied via  <span class="math">\\pi_H</span> :</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathbf{e}(\\nu k_x + \\pi_A,\\pi_B) = \\mathbf{e}(\\pi_H,\\nu k_Z)\\cdot \\mathbf{e}(\\pi_C,P_2)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If all checks in 2.-4. succeeded then return true and otherwise false.</li>

    </ol>

    <p class="text-gray-300">Figure 5: S-ZK Asymmetric Pinocchio, adapted from [BCTV14]; the changes from the original scheme, shown not to be sound [Gab19], are highlighted.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check consistency of <span class="math">pk_{C},pk_{C}^{\\prime},pk_{K}</span>: for <span class="math">i = 0,\\ldots ,m + 3</span>:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {e} \\left(p k _ {C, i}, P _ {2}\\right) = \\mathbf {e} \\left(\\sum_ {j = 0} ^ {d - 1} c _ {i, j} p k _ {H, j}, c k _ {C}\\right) \\quad \\mathbf {e} \\left(p k _ {C, i} ^ {\\prime}, P _ {2}\\right) = \\mathbf {e} \\left(p k _ {C, i}, v k _ {C}\\right)</span></div>

    <p class="text-gray-300">for <span class="math">i = 0,\\ldots ,n</span> : <span class="math">\\mathbf{e}(pk_{K,i},vk_{\\gamma}) = \\mathbf{e}(vk_{IC,i} + pk_{C,i},\\widehat{vk}_{\\beta \\gamma})\\cdot \\mathbf{e}(vk_{\\beta \\gamma},pk_{B,i})</span></p>

    <p class="text-gray-300">for <span class="math">i = n + 1,\\ldots ,m + 3</span> : <span class="math">\\mathbf{e}(pk_{K,i},vk_{\\gamma}) = \\mathbf{e}(pk_{A,i} + pk_{C,i},\\widehat{vk}_{\\beta \\gamma})\\cdot \\mathbf{e}(vk_{\\beta \\gamma},pk_{B,i})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If all checks in 1.-7. succeeded then return true and otherwise false.</li>

    </ol>

    <p class="text-gray-300"><strong>Remark 5.3</strong> The condition that in KEY GENERATION <span class="math">\\rho_{A},\\rho_{B},\\beta ,\\gamma</span> and <span class="math">Z(\\tau)</span> must be non-zero is not made explicit in [BCTV14]. However if <span class="math">\\gamma = 0</span> then any <span class="math">\\pi_K</span> satisfies the verification equation in 3; and if <span class="math">\\beta = 0</span> and <span class="math">\\gamma \\neq 0</span> then no <span class="math">\\pi_K</span> satisfies it. If <span class="math">Z(\\tau) = 0</span> or <span class="math">\\rho_{A} = 0</span> or <span class="math">\\rho_B = 0</span> then <span class="math">vk_{Z} = 0_{\\mathbb{G}_{2}}</span> and setting <span class="math">\\pi_B</span> and <span class="math">\\pi_C</span> to zero always satisfies the equation in 4 in verification.</p>

    <p class="text-gray-300"><strong>CRS verifiability.</strong> We show that a CRS <span class="math">(vk, pk, ck)</span> that passes verification is constructed as in KEY GENERATION; in particular, there exist <span class="math">\\tau, \\alpha_A, \\alpha_B, \\alpha_C \\in \\mathbb{F}</span> and <span class="math">\\rho_A, \\rho_B, \\beta, \\gamma, \\in \\mathbb{F}^*</span> such that <span class="math">(vk, pk, ck)</span> is computed as in KEY GENERATION. Let <span class="math">\\tau, \\alpha_A, \\alpha_B, \\alpha_C, \\rho_A, \\rho_B, \\gamma, \\xi \\in \\mathbb{F}</span> be the values defined by the logarithms of the elements <span class="math">ck_H</span>, <span class="math">vk_A</span>, <span class="math">vk_B</span>, <span class="math">vk_C</span>, <span class="math">ck_A</span>, <span class="math">ck_B</span>, <span class="math">vk_\\gamma</span> and <span class="math">vk_{\\beta \\gamma}</span>, respectively. Check 2. ensures that <span class="math">\\rho_A</span>, <span class="math">\\rho_B</span>, <span class="math">\\gamma</span>, <span class="math">\\xi</span> and <span class="math">Z(\\tau)</span> are all non-zero. Set <span class="math">\\beta := \\xi \\gamma^{-1} \\neq 0</span>.</p>

    <p class="text-gray-300">Check 3. ensures that <span class="math">pk_{H}</span> is correctly computed w.r.t. <span class="math">\\tau</span>. Check 4. ensures that <span class="math">pk_{A}, pk_{A}^{\\prime}, pk_{B}</span> and <span class="math">pk_{B}^{\\prime}</span> are correctly computed w.r.t. <span class="math">\\tau</span>, <span class="math">\\rho_{A}, \\rho_{B}, \\alpha_{A}</span> and <span class="math">\\alpha_{B}</span>. Check 5. ensures that <span class="math">ck_{C}</span> is correctly computed: since by 4., <span class="math">pk_{A,m+1} = Z(\\tau)\\rho_{A}P_{1}</span> and <span class="math">Z(\\tau) \\neq 0</span>, we have <span class="math">ck_{C} = \\rho_{A}\\rho_{B}P_{2}</span>. Check 6. ensures that <span class="math">vk_{IC}, \\widehat{vk}_{\\beta\\gamma}</span> and <span class="math">vk_{Z}</span> are correct and Check 7. does the same for <span class="math">pk_{C}, pk_{C}^{\\prime}</span> and <span class="math">pk_{K}</span>. This shows that with respect to <span class="math">ck_{H}, vk_{A}, vk_{B}, vk_{C}, ck_{A}, ck_{B}, vk_{\\gamma}</span> and <span class="math">vk_{\\beta\\gamma}</span> (which implicitly define the randomness used in a CRS), all remaining elements <span class="math">pk_{A}, pk_{A}^{\\prime}, pk_{B}, pk_{B}^{\\prime}, pk_{C}, pk_{C}^{\\prime}, pk_{K}, pk_{H}</span>, as well as <span class="math">\\widehat{vk}_{\\beta\\gamma}, vk_{Z}, vk_{IC}</span> and <span class="math">ck_{C}</span> are defined as prescribed by KEY GENERATION.</p>

    <p class="text-gray-300"><strong>Trapdoor extraction.</strong> This is done exactly as for the scheme in Section 4. Let <span class="math">\\mathsf{X}</span> be a CRS subvector that outputs <span class="math">(vk, pk, ck)</span>. Define <span class="math">\\mathsf{X}&#x27;(1^{\\lambda}; r)</span> that runs <span class="math">(vk, pk, ck) \\gets \\mathsf{X}(1^{\\lambda}; r)</span>, parses the output as above and returns <span class="math">(pk_{H,0}, pk_{H,1}, pk_{H,2}, P_2, ck_H)</span>. By SKE for aGen (Definition 2.15) there exists a PT algorithm <span class="math">\\mathsf{E}_{\\mathsf{X}&#x27;}</span> such that if for some <span class="math">\\tau \\in \\mathbb{F}</span>: <span class="math">pk_{H,1} = \\tau pk_{H,0}</span>, <span class="math">pk_{H,2} = \\tau^2 pk_{H,0}</span> and <span class="math">ck_H = \\tau P_2</span> then with overwhelming probability <span class="math">\\mathsf{E}_{\\mathsf{X}&#x27;}</span> extracts <span class="math">\\tau</span>. Using <span class="math">\\mathsf{E}_{\\mathsf{X}&#x27;}</span> we define the CRS simulator S.crs which computes <span class="math">(crs, r, td)</span> as follows: On input <span class="math">1^{\\lambda}</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample randomness for <span class="math">\\mathsf{X}</span>: <span class="math">r\\gets \\mathfrak{s}\\{0,1\\}^{\\mathsf{X},\\mathsf{r}(\\lambda)}</span>.</li>

      <li>Run <span class="math">(vk, pk, ck) \\gets X(1^{\\lambda}; r)</span>.</li>

      <li>If <span class="math">(R, vk, pk, ck)</span> passes CRS verification then <span class="math">\\tau \\gets \\mathfrak{s} \\mathsf{E}_{\\mathsf{X}&#x27;}(1^{\\lambda}, r)</span>; else <span class="math">\\tau \\gets \\bot</span>.</li>

      <li>Return <span class="math">((vk, pk, ck), r, \\tau)</span>.</li>

    </ol>

    <p class="text-gray-300"><strong>Proof simulation.</strong> Given <span class="math">(vk, pk, ck)</span>, trapdoor <span class="math">\\tau</span> and a statement <span class="math">x \\in \\mathbb{F}^n</span>, the proof simulator S.pf is defined as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\tau = \\bot</span> then return <span class="math">\\bot</span>.</li>

      <li>Use <span class="math">\\tau</span> to compute <span class="math">Z(\\tau)</span> (which in a verified CRS is non-zero). Compute the following "simulation keys":</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">s k _ {A} := Z (\\tau) ^ {- 1} p k _ {A, m + 1} = \\rho_ {A} P _ {1} \\quad s k _ {A} ^ {\\prime} := Z (\\tau) ^ {- 1} p k _ {A, m + 1} ^ {\\prime} = \\alpha_ {A} \\rho_ {A} P _ {1}</span></div>

    <div class="my-4 text-center"><span class="math-block">s k _ {B} := Z (\\tau) ^ {- 1} p k _ {B, m + 2} = \\rho_ {B} P _ {2} \\quad s k _ {B} ^ {\\prime} := Z (\\tau) ^ {- 1} p k _ {B, m + 2} ^ {\\prime} = \\alpha_ {B} \\rho_ {B} P _ {1}</span></div>

    <div class="my-4 text-center"><span class="math-block">s k _ {C} := Z (\\tau) ^ {- 1} p k _ {C, m + 3} = \\rho_ {A} \\rho_ {B} P _ {1} \\quad s k _ {C} ^ {\\prime} := Z (\\tau) ^ {- 1} p k _ {C, m + 3} ^ {\\prime} = \\alpha_ {C} \\rho_ {A} \\rho_ {B} P _ {1}</span></div>

    <div class="my-4 text-center"><span class="math-block">s k _ {A} ^ {\\prime \\prime} = Z (\\tau) ^ {- 1} p k _ {K, m + 1} = \\beta \\rho_ {A} P _ {1}</span></div>

    <div class="my-4 text-center"><span class="math-block">s k _ {B} ^ {\\prime \\prime} = Z (\\tau) ^ {- 1} p k _ {K, m + 2} = \\beta \\rho_ {B} P _ {1} \\quad s k _ {C} ^ {\\prime \\prime} = Z (\\tau) ^ {- 1} p k _ {K, m + 3} = \\beta \\rho_ {A} \\rho_ {B} P _ {1}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">vk_{x} := vk_{IC,0} + \\sum_{i=1}^{n} x_{i} vk_{IC,i} = (A_{0}(\\tau) + \\sum_{i=1}^{n} x_{i} A_{i}(\\tau)) sk_{A}</span> and <span class="math">vk_{x}&#x27; := (A_{0}(\\tau) + \\sum_{i=1}^{n} x_{i} A_{i}(\\tau)) sk_{A}&#x27;</span></li>

      <li>Choose <span class="math">a, b, c \\gets \\S \\mathbb{F}</span> and define the proof <span class="math">\\pi := (\\pi_A, \\pi_A&#x27;, \\pi_B, \\pi_B&#x27;, \\pi_C, \\pi_C&#x27;, \\pi_K, \\pi_H)</span> with:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\pi_{A} := a sk_{A} - vk_{x} = a \\rho_{A} P_{1} - vk_{x} \\quad \\pi_{A}&#x27; := a sk_{A}&#x27; - vk_{x}&#x27; = a \\alpha_{A} \\rho_{A} P_{1} - \\alpha_{A} vk_{x}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\pi_{B} := b sk_{B} = b \\rho_{B} P_{2} \\quad \\pi_{B}&#x27; := b sk_{B}&#x27; = b \\alpha_{B} \\rho_{B} P_{1}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\pi_{C} := c sk_{C} = c \\rho_{A} \\rho_{B} P_{1} \\quad \\pi_{C}&#x27; := c sk_{C}&#x27; = c \\alpha_{C} \\rho_{A} \\rho_{B} P_{1}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\pi_{K} := a sk_{A}&#x27;&#x27; + b sk_{B}&#x27;&#x27; + c sk_{C}&#x27;&#x27; \\quad \\pi_{H} := Z(\\tau)^{-1}(ab - c) P_{1}</span></div>

    <p class="text-gray-300">Theorem 5.4 Let <span class="math">\\mathsf{Rg}</span> be a QAP generator defining a bilinear-group generator aGen for which SKE holds. Then the scheme in Figure 5 for <span class="math">\\mathsf{Rg}</span> satisfies subversion zero knowledge.</p>

    <p class="text-gray-300">Proof. Consider <span class="math">(vk, pk, ck) \\gets X(1^{\\lambda}; r)</span> and let <span class="math">E</span> denote the event that <span class="math">(R, vk, pk, ck)</span> passes CRS verification but <span class="math">\\mathsf{E}_{\\mathsf{X}&#x27;}</span> fails to extract <span class="math">\\tau</span>. From Check 3 in CRS verification, we have <span class="math">\\mathsf{e}(pk_{H,1}, P_2) = \\mathsf{e}(pk_{H,0}, ck_H)</span> and <span class="math">\\mathsf{e}(pk_{H,2}, P_2) = \\mathsf{e}(pk_{H,1}, ck_H)</span>; thus <span class="math">(pk_{H,0}, pk_{H,1}, pk_{H,2}, P_2, ck_H)</span> is a valid SKE tuple. By the SKE assumption the probability of <span class="math">E</span> is thus negligible. It now suffices to show that, conditioned on <span class="math">E</span> not happening, the probability that A outputs 1 in game S-ZK when <span class="math">b = 0</span> is the same as when <span class="math">b = 1</span>.</p>

    <p class="text-gray-300">If <span class="math">(vk, pk, ck)</span> fails CRS verification then <span class="math">\\tau = \\bot</span> and both prover and proof simulator return <span class="math">\\bot</span>. If <span class="math">(vk, pk, ck)</span> verifies then (because of <span class="math">\\neg E</span>) <span class="math">\\mathsf{E}_{\\mathsf{X}&#x27;}</span> extracts <span class="math">\\tau</span>.</p>

    <p class="text-gray-300">We show that the outputs of the prover and the proof simulator are distributed equivalently. Above we showed that for a valid CRS there exist <span class="math">\\tau, \\rho_A, \\rho_B, \\beta, \\gamma, \\alpha_A, \\alpha_B, \\alpha_C \\in \\mathbb{F}</span> with <span class="math">\\rho_A \\neq 0</span>, <span class="math">\\rho_B \\neq 0</span>, <span class="math">\\beta \\neq 0</span>, <span class="math">\\gamma \\neq 0</span> and <span class="math">Z(\\tau) \\neq 0</span> such that <span class="math">vk</span> and <span class="math">pk</span> are defined as in Items 4. and 5. in KEY GENERATION.</p>

    <p class="text-gray-300">Because of this, <span class="math">\\delta_A Z(\\tau) \\rho_A P_1</span>, the <span class="math">(m + 2)</span>-th summand in <span class="math">\\pi_A</span> is uniformly random. And so are the <span class="math">(m + 3)</span>-th summand <span class="math">\\delta_B Z(\\tau) \\rho_B P_1</span> of <span class="math">\\pi_B</span> and the <span class="math">(m + 4)</span>-th summand <span class="math">\\delta_C Z(\\tau) \\rho_A \\rho_B P_1</span> in <span class="math">\\pi_C</span>. But this means that <span class="math">\\pi_A, \\pi_B</span> and <span class="math">\\pi_C</span> are uniformly random group elements. For fixed <span class="math">vk, \\pi_A, \\pi_B</span> and <span class="math">\\pi_C</span> the equations in 2. of VERIFY uniquely determine <span class="math">\\pi_A&#x27;, \\pi_B&#x27;</span> and <span class="math">\\pi_C&#x27;</span>, while the equations in 3. and 4. uniquely determine <span class="math">\\pi_K</span> and <span class="math">\\pi_H</span> (since <span class="math">vk_\\gamma \\neq 0_{\\mathbb{G}_2}</span> and <span class="math">vk_Z \\neq 0_{\\mathbb{G}_2}</span>).</p>

    <p class="text-gray-300">Since for a valid CRS the values <span class="math">\\rho_{A}</span> and <span class="math">\\rho_{B}</span> are non-zero, the simulated proof elements <span class="math">\\pi_{A}, \\pi_{B}</span> and <span class="math">\\pi_{C}</span> are also uniformly random. Thus, it suffices to show that the remaining proof elements satisfy the verification equations:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{e}(\\pi_{A}&#x27;, P_{2}) = \\mathsf{e}\\left(a \\alpha_{A} \\rho_{A} P_{1} - \\alpha_{A} vk_{x}, P_{2}\\right) = \\mathsf{e}(\\pi_{A}, vk_{A})</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{e}\\left(\\pi_{B}&#x27;, P_{2}\\right) = \\mathsf{e}\\left(b \\alpha_{B} \\rho_{B} P_{1}, P_{2}\\right) = \\mathsf{e}(vk_{B}, \\pi_{B})</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{e}\\left(\\pi_{C}&#x27;, P_{2}\\right) = \\mathsf{e}\\left(c \\alpha_{C} \\rho_{A} \\rho_{B} P_{1}, P_{2}\\right) = \\mathsf{e}(\\pi_{C}, vk_{C})</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{e}(\\pi_{K}, vk_{\\gamma}) = \\mathsf{e}\\left(\\beta(a \\rho_{A} P_{1} + b \\rho_{B} P_{1} + c \\rho_{A} \\rho_{B} P_{1}), \\gamma P_{2}\\right) = \\mathsf{e}(vk_{x} + \\pi_{A} + \\pi_{C}, \\widehat{vk}_{\\beta\\gamma}) \\cdot \\mathsf{e}(vk_{\\beta\\gamma}, \\pi_{B})</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathsf{e}(\\pi_{H}, vk_{Z}) = \\mathsf{e}\\left(Z(\\tau)^{-1}(ab - c) P_{1}, Z(\\tau) \\rho_{A} \\rho_{B} P_{2}\\right) = \\\\ = \\mathsf{e}\\left(a \\rho_{A} P_{1}, b \\rho_{B} P_{2}\\right) \\cdot \\mathsf{e}\\left(c \\rho_{A} \\rho_{B} P_{1}, P_{2}\\right)^{-1} = \\mathsf{e}(vk_{x} + \\pi_{A}, \\pi_{B}) \\cdot \\mathsf{e}(\\pi_{C}, P_{2})^{-1} \\end{array}</span></div>

    <p class="text-gray-300">This concludes the proof.</p>

    <p class="text-gray-300">Corollary 5.5 The scheme in Figure 5 for a QAP generator <span class="math">\\mathsf{Rg}</span> satisfies perfect subversion witness indistinguishability.</p>

    <p class="text-gray-300">Proof. The corollary follows analogously to Corollary 4.3.</p>

    <p class="text-gray-300">DFGK’s SSP-Based SNARK</p>

    <p class="text-gray-300">Danezis, Fournet, Groth and Kohlweiss <em>[x10]</em> define <em>square</em> span programs, which are described by only one set <span class="math">\\{A_{i}(X)\\}_{i}</span> of polynomials (cf. Definition 3.3). They show how to convert any boolean circuit into an SSP. They construct a zk-SNARK for SSPs with proofs only consisting of 4 elements of an asymmetric bilinear group. Analogously to the SNARK from <em>[x3]</em>, their scheme is shown to satisfy subversion zero knowledge by observing that (1) the structure of a CRS can be verified via the bilinear map; (2) the trapdoor <span class="math">\\tau</span> (which is <span class="math">s</span> in their notation) can be extracted analogously to the SNARK analyzed above; and (3) proofs can be simulated using <span class="math">s</span> by simply following the simulation procedure described in <em>[x10]</em>. (When <span class="math">s</span> is known, the element <span class="math">G^{\\beta}</span> (in their multiplicative notation) can be obtained from the CRS element <span class="math">G^{\\beta t(s)}</span> since <span class="math">t(s)\\neq 0</span>.)</p>

    <h2 id="sec-51" class="text-2xl font-bold">6 Groth’s Near-Optimal SNARK</h2>

    <p class="text-gray-300">Groth <em>[x16]</em> proposed the most efficient zk-SNARK system to date. He drastically reduced the proof size for QAP-based SNARKs to 3 group elements and verification to one equation using 3 pairings. He achieves this by proving soundness directly in the generic-group model. His system is given in Figure 6, to which we added a procedure CRS verification defined below.</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Theorem 6.1 (<em>[x16]</em>)</h6>

    <p class="text-gray-300">The scheme in Figure 6 is knowledge-sound against adversaries that only use a polynomial number of generic bilinear group operations. It also has perfect zero knowledge.</p>

    <h4 id="sec-53" class="text-lg font-semibold mt-6">CRS verification.</h4>

    <p class="text-gray-300">On input <span class="math">(R,\\text{\\,}\\nu k,pk)</span>, let <span class="math">\\{a_{i,j}\\}</span>, <span class="math">\\{b_{i,j}\\}</span>, <span class="math">\\{c_{i,j}\\}</span>, <span class="math">\\{z_{k}\\}</span> denote the coefficients of <span class="math">A_{i}(X)</span>, <span class="math">B_{i}(X)</span>, <span class="math">C_{i}(X)</span> and <span class="math">Z(X)</span>, respectively, for <span class="math">0\\leq i\\leq m</span> and <span class="math">0\\leq j\\leq d-1</span> and <span class="math">0\\leq k\\leq d</span>. .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check <span class="math">P_{1}\\neq 0_{\\mathbb{G}_{1}}</span> and <span class="math">P_{2}\\neq 0_{\\mathbb{G}_{2}}</span>.</li>

      <li>Check that <span class="math">\\alpha,\\beta,\\gamma,\\delta</span> and <span class="math">Z(\\tau)</span> are non-zero: <span class="math">pk_{\\alpha}\\neq 0_{\\mathbb{G}_{1}},\\;pk_{\\beta}\\neq 0_{\\mathbb{G}_{1}},\\;\\text{\\,}\\nu k^{\\prime}_{\\gamma}\\neq 0_{\\mathbb{G}_{2}},\\;pk_{\\delta}\\neq 0_{\\mathbb{G}_{1}}</span>, <span class="math">pk_{Z,0}\\neq 0_{\\mathbb{G}_{1}}</span></li>

      <li>Check consistency of <span class="math">pk_{H}</span> and <span class="math">pk^{\\prime}_{H}</span>: check <span class="math">pk_{H,0}=P_{1}</span> and <span class="math">pk^{\\prime}_{H,0}=P_{2}</span>. For <span class="math">i=1,\\ldots,d-1</span>:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathbf{e}(pk_{H,i},\\,P_{2})=\\mathbf{e}(pk_{H,i-1},\\,pk^{\\prime}_{H,1})\\qquad\\qquad\\mathbf{e}(P_{1},\\,pk^{\\prime}_{H,i})=\\mathbf{e}(pk_{H,i},\\,P_{2})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check consistency of the remaining <span class="math">pk</span> elements:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathbf{e}(P_{1},\\,pk^{\\prime}_{\\beta})=\\mathbf{e}(pk_{\\beta},\\,P_{2})\\qquad\\qquad\\mathbf{e}(P_{1},\\,pk^{\\prime}_{\\delta})=\\mathbf{e}(pk_{\\delta},\\,P_{2})</span></p>

    <p class="text-gray-300">for <span class="math">i=n+1,\\ldots,m</span> :</p>

    <p class="text-gray-300"><span class="math">\\mathbf{e}(pk_{K,i},\\,pk^{\\prime}_{\\delta})=\\mathbf{e}\\big{(}\\sum_{j=0}^{d-1}a_{i,j}pk_{H,j},\\,pk^{\\prime}_{\\beta}\\big{)}\\cdot\\mathbf{e}\\big{(}pk_{\\alpha},\\,\\sum_{j=0}^{d-1}b_{i,j}pk^{\\prime}_{H,j}\\big{)}\\cdot\\mathbf{e}\\big{(}\\sum_{j=0}^{d-1}c_{i,j}pk_{H,j},\\,P_{2}\\big{)}</span></p>

    <p class="text-gray-300">for <span class="math">i=0,\\ldots,d-2</span> : <span class="math">\\mathbf{e}(pk_{Z,i},\\,pk^{\\prime}_{\\delta})=\\mathbf{e}\\big{(}\\sum_{j=0}^{d-1}z_{j}pk_{H,j},\\,pk^{\\prime}_{H,i}\\big{)}\\cdot\\mathbf{e}\\big{(}z_{d}pk_{H,d-1},\\,pk^{\\prime}_{H,i+1}\\big{)}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check consistency of the remaining <span class="math">\\nu k</span> elements: for <span class="math">i=0,\\ldots,n</span>:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathbf{e}(\\text{\\,}\\nu k_{L,i},\\,vk^{\\prime}_{\\gamma})=\\mathbf{e}\\big{(}\\sum_{j=0}^{d-1}a_{i,j}pk_{H,j},\\,pk^{\\prime}_{\\beta}\\big{)}\\cdot\\mathbf{e}\\big{(}pk_{\\alpha},\\,\\sum_{j=0}^{d-1}b_{i,j}pk^{\\prime}_{H,j}\\big{)}\\cdot\\mathbf{e}\\big{(}\\sum_{j=0}^{d-1}c_{i,j}pk_{H,j},\\,P_{2}\\big{)}</span> <span class="math">\\text{\\,}\\nu k_{T}=\\mathbf{e}(pk_{\\alpha},\\,pk^{\\prime}_{\\beta})\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad vk^{\\prime}_{\\delta}=pk^{\\prime}_{\\delta}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If all checks in 1.–5. succeeded then return true and otherwise false.</li>

    </ol>

    <p class="text-gray-300">KEY GENERATION. On input  <span class="math">R</span>  as in Eq. (8) representing a QAP for an asymmetric group  <span class="math">Gr</span> :</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample random group generators  <span class="math">P_{1}\\gets \\mathbb{S}_{1}^{<em>}</span>  and  <span class="math">P_{2}\\gets \\mathbb{S}_{2}^{</em>}</span> .</li>

      <li>Sample random  <span class="math">\\alpha, \\beta, \\gamma, \\delta \\gets \\mathbb{F}^*</span>  and  <span class="math">\\tau \\gets \\mathbb{F}</span>  conditioned on  <span class="math">Z(\\tau) \\neq 0</span> .</li>

      <li>Set  <span class="math">vk = (P_1, P_2, vk_T, vk_\\gamma&#x27;, vk_\\delta&#x27;, vk_L)</span> , where</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\begin{array}{rlr}{vk_{T}} &amp;amp; {= \\mathbf{e}(P_{1},P_{2})^{\\alpha \\beta}} &amp;amp; {\\qquad vk_{\\gamma}^{\\prime} := \\gamma P_{2}}\\\\ &amp;amp; {\\qquad \\mathrm{for} i = 0,\\ldots ,n:} &amp;amp; {\\qquad vk_{L,i} := \\gamma^{-1}\\big(\\beta A_{i}(\\tau) + \\alpha B_{i}(\\tau) + C_{i}(\\tau)\\big)P_{1}}\\end{array}</span> <span class="math">\\begin{array}{r}\\mathrm{vk}_{\\delta}^{\\prime} := \\delta P_{2} \\end{array}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">pk = (pk_{\\alpha}, pk_{\\beta}, pk_{\\beta}^{\\prime}, pk_{\\delta}, pk_{\\delta}^{\\prime}, pk_{H}, pk_{H}^{\\prime}, pk_{K}, pk_{Z})</span> , where</li>

    </ol>

    <p class="text-gray-300"><span class="math">pk_{\\alpha}\\coloneqq \\alpha P_1</span> <span class="math">pk_{\\beta}\\coloneqq \\beta P_1</span> <span class="math">pk_{\\beta}^{\\prime}\\coloneqq \\beta P_{2}</span> <span class="math">pk_{\\delta}\\coloneqq \\delta P_{1}</span> <span class="math">pk_{\\delta}^{\\prime}\\coloneqq \\delta P_{2}</span></p>

    <p class="text-gray-300">for  <span class="math">i = 0,\\dots ,d - 1</span>  ..  <span class="math">pk_{H,i}\\coloneqq \\tau^i P_1</span> <span class="math">pk_{H,i}^{\\prime}\\coloneqq \\tau^{i}P_{2}</span></p>

    <p class="text-gray-300">for  <span class="math">i = n + 1,\\ldots ,m</span>  ..  <span class="math">pk_{K,i}\\coloneqq \\delta^{-1}\\bigl (\\beta A_i(\\tau) + \\alpha B_i(\\tau) + C_i(\\tau)\\bigr)P_1</span></p>

    <p class="text-gray-300">for  <span class="math">i = 0,\\dots ,d - 2</span>  ..  <span class="math">pk_{Z,i}\\coloneqq \\delta^{-1}\\tau^i Z(\\tau)P_1</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Return  <span class="math">crs \\coloneqq (vk, pk)</span> .</li>

    </ol>

    <p class="text-gray-300">PROVE. On input  <span class="math">R</span> ,  <span class="math">(vk, pk)</span>  and  <span class="math">\\vec{s} \\in \\mathbb{F}^m</span>  s.t. Eq. (6) is satisfied for some  <span class="math">H(X) \\in \\mathbb{F}[X]</span> :</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If  <span class="math">(R, vk, pk)</span>  does not pass CRS VERIFICATION then return  <span class="math">\\perp</span> .</li>

      <li>Compute  <span class="math">H(X)</span>  such that Eq. (6) is satisfied and let  <span class="math">(h_0, \\ldots, h_{d-2}) \\in \\mathbb{F}^{d-1}</span>  be its coefficients.</li>

      <li>Sample  <span class="math">r_A, r_B \\gets \\mathbb{F}</span>  and define</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\pi_A \\coloneqq pk_\\alpha + \\sum_{j=0}^{d-1} \\left(a_{0,j} + \\sum_{i=1}^m s_i a_{i,j}\\right) pk_{H,j} + r_A pk_\\delta</span></p>

    <p class="text-gray-300"><span class="math">\\pi_B^\\prime \\coloneqq pk_\\beta^\\prime +\\sum_{j = 0}^{d - 1}\\big(b_{0,j} + \\sum_{i = 1}^m s_i b_{i,j}\\big)pk_H^\\prime , + r_Bpk_\\delta^\\prime</span></p>

    <p class="text-gray-300"><span class="math">\\pi_{B,\\mathrm{aux}}\\coloneqq pk_{\\beta} + \\sum_{j = 0}^{d - 1}\\big(b_{0,j} + \\sum_{i = 1}^{m}s_{i}b_{i,j}\\big)pk_{H,j}</span></p>

    <p class="text-gray-300"><span class="math">\\pi_C \\coloneqq \\sum_{i=n+1}^m s_i pk_{K,i} + \\sum_{j=0}^{d-2} h_j pk_{Z,j} + r_B \\pi_A + r_A \\pi_{B,\\mathrm{aux}}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Return  <span class="math">\\pi \\coloneqq (\\pi_A,\\pi_B&#x27;,\\pi_C)</span></li>

    </ol>

    <p class="text-gray-300">VERIFY. On input  <span class="math">R</span> ,  <span class="math">vk</span> ,  <span class="math">\\vec{x} \\in \\mathbb{F}^n</span>  and proof  <span class="math">\\pi \\in \\mathbb{G}_1^2 \\times \\mathbb{G}_2</span> :</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">vk_{x} \\coloneqq vk_{L,0} + \\sum_{i=1}^{n} x_{i} vk_{L,i}</span> .</li>

      <li>Return true if and only if the following holds:  <span class="math">\\mathbf{e}(\\pi_A,\\pi_B^{\\prime}) = vk_T + \\mathbf{e}(vk_x,vk_\\gamma^{\\prime}) + \\mathbf{e}(\\pi_C,vk_\\delta^{\\prime})</span></li>

    </ol>

    <p class="text-gray-300">Figure 6: Groth's SNARK [Gro16] with CRS verification (in bold)</p>

    <p class="text-gray-300">CRS verifiability. Let  <span class="math">\\tau, \\alpha, \\beta, \\gamma, \\delta</span>  denote the logarithms of  <span class="math">pk_{H,1}</span> ,  <span class="math">pk_{\\alpha}</span> ,  <span class="math">pk_{\\beta}</span> ,  <span class="math">vk_{\\gamma}&#x27;</span> ,  <span class="math">pk_{\\delta}</span> . By Check 2. in CRS VERIFICATION,  <span class="math">\\alpha, \\beta, \\gamma, \\delta, Z(\\tau)</span>  are non-zero. It follows by inspection that if all checks in 3.-5. pass then the remaining elements of  <span class="math">pk</span>  and  <span class="math">vk</span>  are correctly computed.</p>

    <p class="text-gray-300">Trapdoor extraction. Let  <span class="math">\\mathsf{X}</span>  be a CRS subvector that outputs  <span class="math">(vk, pk)</span> . Define  <span class="math">\\mathsf{X}&#x27;(1^{\\lambda}; r)</span>  that runs  <span class="math">(vk, pk) \\gets \\mathsf{X}(1^{\\lambda}; r)</span> , parses the output as above and returns  <span class="math">(P_1, pk_{H,1}, pk_{H,2}, P_2, pk_{H,1}&#x27;)</span> . For a valid CRS this corresponds to  <span class="math">(P_1, \\tau P_1, \\tau^2 P_1, P_2, \\tau P_2)</span>  for some  <span class="math">P_1 \\in \\mathbb{G}_1</span> ,  <span class="math">P_2 \\in \\mathbb{G}_2</span>  and  <span class="math">\\tau \\in \\mathbb{F}</span> . By SKE there exists a PT algorithm  <span class="math">\\mathsf{E}_{\\mathsf{X}&#x27;}</span>  which from a valid tuple extracts  <span class="math">\\tau</span>  with overwhelming probability.</p>

    <p class="text-gray-300">Define another algorithm  <span class="math">\\mathsf{X}&#x27;&#x27;(1^{\\lambda};(r,r&#x27;))</span>  that runs  <span class="math">(vk,pk)\\gets \\mathsf{X}(1^{\\lambda};r)</span>  and then extracts  <span class="math">\\tau \\gets</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{E}_{\\mathsf{X}^{\\prime}}(1^{\\lambda},r;r^{\\prime})</span>, computes <span class="math">Z(\\tau)</span> (which is non-zero in a valid CRS) and sets <span class="math">P_{1}^{\\prime}:=Z(\\tau)^{-1}\\,pk_{Z,0}</span> (which for a valid CRS yields <span class="math">P_{1}^{\\prime}=\\delta^{-1}P_{1}</span>). Finally, <span class="math">\\mathsf{X}^{\\prime\\prime}</span> returns <span class="math">(P_{1}^{\\prime},P_{1},pk_{\\delta},P_{2},pk_{\\delta}^{\\prime})</span>. For a valid CRS this corresponds to <span class="math">\\big{(}P_{1}^{\\prime},\\delta P_{1}^{\\prime},\\delta^{2}P_{1}^{\\prime},P_{2},\\delta P_{2}\\big{)}</span>. By SKE there exist a PT algorithm <span class="math">\\mathsf{E}_{\\mathsf{X}^{\\prime\\prime}}</span> that on input <span class="math">r^{\\prime\\prime}=(r,r^{\\prime})</span> returns <span class="math">\\delta</span> with overwhelming probability.</p>

    <p class="text-gray-300">Using <span class="math">\\mathsf{E}_{\\mathsf{X}^{\\prime}}</span> and <span class="math">\\mathsf{E}_{\\mathsf{X}^{\\prime\\prime}}</span>, we define the CRS simulator <span class="math">\\mathsf{S.crs}</span> as follows: On input <span class="math">1^{\\lambda}</span> do the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample randomness for <span class="math">\\mathsf{X}</span> and <span class="math">\\mathsf{E}_{\\mathsf{X}^{\\prime}}</span>: <span class="math">r\\leftarrow\\S\\{0,1\\}^{\\mathsf{X.rl}(\\lambda)}</span>; <span class="math">r^{\\prime}\\leftarrow\\S\\{0,1\\}^{\\mathsf{E}_{\\mathsf{X}^{\\prime}}.\\mathsf{rl}(\\lambda)}</span></li>

      <li>Run <span class="math">(vk,pk)\\leftarrow\\mathsf{X}(1^{\\lambda};r)</span></li>

      <li>If <span class="math">(R,vk,pk)</span> verifies then <span class="math">\\tau\\leftarrow\\mathsf{E}_{\\mathsf{X}^{\\prime}}(1^{\\lambda},r;r^{\\prime})</span> and <span class="math">\\delta\\leftarrow\\S\\mathsf{E}_{\\mathsf{X}^{\\prime\\prime}}(1^{\\lambda},(r,r^{\\prime}))</span>,</li>

    </ul>

    <p class="text-gray-300">else <span class="math">(\\tau,\\delta)\\leftarrow(\\bot,\\bot)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Return <span class="math">((vk,pk),r,(\\tau,\\delta))</span></li>

    </ul>

    <h6 id="sec-54" class="text-base font-medium mt-4">Remark 6.2</h6>

    <p class="text-gray-300">Proof simulation is defined in <em>[x13]</em> using the full randomness of the CRS and does not work with the trapdoor <span class="math">(\\tau,\\delta)</span>, as the simulator requires <span class="math">\\alpha</span> and <span class="math">\\beta</span>, which SKE does not allow to extract. Note that it is impossible to extract <span class="math">\\alpha</span>, since a valid CRS can be computed without knowing <span class="math">\\alpha</span>: obliviously sample a random generator <span class="math">pk_{\\alpha}\\leftarrow\\S\\mathbb{G}_{1}^{*}</span> and then compute <span class="math">vk_{T}</span> and, for all <span class="math">i</span>, <span class="math">vk_{L,i}</span> and <span class="math">pk_{K,i}</span> from <span class="math">pk_{\\alpha}</span>. In the following we show how to simulate a proof without knowledge of <span class="math">\\alpha</span> and <span class="math">\\beta</span>.</p>

    <h4 id="sec-55" class="text-lg font-semibold mt-6">Proof simulation.</h4>

    <p class="text-gray-300">Given <span class="math">(vk,pk)</span>, trapdoor <span class="math">(\\tau,\\delta)</span> and a statement <span class="math">x\\in\\mathbb{F}^{n}</span>, the proof simulator <span class="math">\\mathsf{S.pf}</span> does the following:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">(\\tau,\\delta)=(\\bot,\\bot)</span> then return <span class="math">\\bot</span>.</li>

      <li>Choose <span class="math">a,b\\leftarrow\\S\\mathbb{F}</span> and define the proof <span class="math">\\pi:=(\\pi_{A},\\pi_{B}^{\\prime},\\pi_{C})</span> as follows</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\pi_{A}</span> <span class="math">:=aP_{1}+pk_{\\alpha}</span> <span class="math">\\pi_{B}^{\\prime}:=bP_{2}+pk_{\\beta}^{\\prime}</span> <span class="math">\\pi_{C}</span> <span class="math">:=\\delta^{-1}\\big{(}ab-C_{0}(\\tau)-\\sum_{i=1}^{n}x_{i}C_{i}(\\tau)\\big{)}P_{1}+\\delta^{-1}\\big{(}b-B_{0}(\\tau)-\\sum_{i=1}^{n}x_{i}B_{i}(\\tau)\\big{)}pk_{\\alpha}</span> <span class="math">\\qquad+\\delta^{-1}\\big{(}a-A_{0}(\\tau)-\\sum_{i=1}^{n}x_{i}A_{i}(\\tau)\\big{)}pk_{\\beta}</span></p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Theorem 6.3</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{Rg}</span> be a QAP generator defining a bilinear-group generator <span class="math">\\mathsf{aGen}</span> for which SKE holds. Then Groth’s SNARK <em>[x13]</em> with CRS verification (Figure 6) for <span class="math">\\mathsf{Rg}</span> satisfies subversion zero knowledge.</p>

    <p class="text-gray-300">Proof. Let <span class="math">E</span> denote the event that <span class="math">(R,vk,pk)</span> passes CRS verification but either <span class="math">\\mathsf{E}_{\\mathsf{X}^{\\prime}}</span> or <span class="math">\\mathsf{E}_{\\mathsf{X}^{\\prime\\prime}}</span> fails to extract <span class="math">\\tau</span> and <span class="math">\\delta</span>. Since a correct <span class="math">(vk,pk)</span> satisfies <span class="math">\\mathbf{e}(pk_{H,1},P_{2})=\\mathbf{e}(P_{1},pk_{H,1}^{\\prime})</span> as well as <span class="math">\\mathbf{e}(pk_{H,2},P_{2})=\\mathbf{e}(pk_{H,1},pk_{H,1}^{\\prime})</span>, by SKE (Definition 2.15), the probability that <span class="math">\\mathsf{E}_{\\mathsf{X}^{\\prime}}</span> fails when <span class="math">\\mathsf{X}^{\\prime}</span> outputs <span class="math">(P_{1},pk_{H,1},pk_{H,2},P_{2},pk_{H,1}^{\\prime})</span> is negligible. A correct CRS also satisfies both <span class="math">\\mathbf{e}(P_{1},P_{2})=\\mathbf{e}(Z(\\tau)^{-1}pk_{Z,0},pk_{\\delta}^{\\prime})</span> and <span class="math">\\mathbf{e}(pk_{\\delta},P_{2})=\\mathbf{e}(P_{1},pk_{\\delta}^{\\prime})</span>, thus again by SKE, the probability that <span class="math">\\mathsf{E}_{\\mathsf{X}^{\\prime\\prime}}</span> fails when <span class="math">\\mathsf{X}^{\\prime\\prime}</span> outputs <span class="math">\\big{(}Z(\\tau)^{-1}\\,pk_{Z,0},P_{1},pk_{\\delta},P_{2},pk_{\\delta}^{\\prime}\\big{)}</span> is also negligible. By a union bound, the probability of <span class="math">E</span> is thus negligible.</p>

    <p class="text-gray-300">It now suffices to show that, conditioned on <span class="math">E</span> not happening, game S-ZK when <span class="math">b=0</span> is distributed as game S-ZK when <span class="math">b=1</span>. If <span class="math">(vk,pk)</span> fails verification then <span class="math">(\\tau,\\delta)=(\\bot,\\bot)</span> and both the prover and the proof simulator return <span class="math">\\bot</span>.</p>

    <p class="text-gray-300">If <span class="math">(vk,pk)</span> verifies then we show that the outputs of the prover and the proof simulator are distributed equivalently. Above we argued that for some non-zero <span class="math">\\alpha,\\beta,\\gamma,\\delta</span> and <span class="math">\\tau</span> with <span class="math">Z(\\tau)\\neq 0</span> we have that <span class="math">vk</span> and <span class="math">pk</span> are defined as in 3. and 4. in Key generation.</p>

    <p class="text-gray-300">Since for a valid CRS both <span class="math">pk_{\\delta}</span> and <span class="math">pk^{\\prime}_{\\delta}</span> are non-zero, for honestly generated proofs the elements <span class="math">r_{A}\\,pk_{\\delta}</span> in <span class="math">\\pi_{A}</span>, and <span class="math">r_{B}\\,pk^{\\prime}_{\\delta}</span> in <span class="math">\\pi^{\\prime}_{B}</span>, make <span class="math">\\pi_{A}</span> and <span class="math">\\pi^{\\prime}_{B}</span> uniformly random. For fixed <span class="math">vk</span>, <span class="math">\\pi_{A}</span> and <span class="math">\\pi^{\\prime}_{B}</span>, the verification equation uniquely determines <span class="math">\\pi_{C}</span>, since <span class="math">vk^{\\prime}_{\\delta}\\neq 0</span>.</p>

    <p class="text-gray-300">In a simulated proof <span class="math">\\pi_{A}</span> and <span class="math">\\pi^{\\prime}_{B}</span> are also uniformly random, so it suffices to show that the simulated <span class="math">\\pi_{C}</span> satisfies the verification equation:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{e}(\\pi_{C},vk^{\\prime}_{\\delta})=</span> <span class="math">=\\mathbf{e}\\Big{(}\\Big{(}ab-C_{0}(\\tau)-\\sum x_{i}C_{i}(\\tau)+\\alpha\\big{(}b-B_{0}(\\tau)-\\sum x_{i}B_{i}(\\tau)\\big{)}+\\beta\\big{(}a-A_{0}(\\tau)-\\sum x_{i}A_{i}(\\tau)\\big{)}\\Big{)}P_{1},\\,P_{2}\\Big{)}</span> <span class="math">=\\mathbf{e}(abP_{1},P_{2})+\\mathbf{e}(a\\beta P_{1},P_{2})+\\mathbf{e}(\\alpha bP_{1},P_{2})+\\mathbf{e}(\\alpha\\beta P_{1},P_{2})-\\mathbf{e}(\\alpha\\beta P_{1},P_{2})</span> <span class="math">\\qquad-\\mathbf{e}\\big{(}\\big{(}\\beta A_{0}(\\tau)+\\sum x_{i}\\beta A_{i}(\\tau)+\\alpha B_{0}(\\tau)+\\sum x_{i}\\alpha B_{i}(\\tau)+C_{0}(\\tau)+\\sum x_{i}C_{i}(\\tau)\\big{)}P_{1},\\,P_{2}\\big{)}</span> <span class="math">=\\mathbf{e}(\\pi_{A},\\pi^{\\prime}_{B})-vk_{T}-\\mathbf{e}(vk_{x},vk^{\\prime}_{\\gamma})</span></p>

    <p class="text-gray-300">This concludes the proof.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Corollary 6.4</h6>

    <p class="text-gray-300">Groth’s SNARK <em>[x13]</em> with CRS verification for a QAP generator <span class="math">\\mathsf{Rg}</span> (Figure 6) satisfies perfect subversion witness indistinguishability.</p>

    <p class="text-gray-300">Proof. The corollary follows analogously to Corollary 5.5.</p>

    <h3 id="sec-58" class="text-xl font-semibold mt-8">Acknowledgments</h3>

    <p class="text-gray-300">The author would like to thank Mihir Bellare and Rosario Gennaro for helpful discussions and the anonymous reviewers for PKC’18 for their valuable comments. The author is supported by the French ANR EfTrEC project (ANR-16-CE39-0002).</p>

    <h2 id="sec-59" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[ABLZ17] Behzad Abdolmaleki, Karim Baghery, Helger Lipmaa, and Michal Zajac. A subversion-resistant SNARK. In Tsuyoshi Takagi and Thomas Peyrin, editors, ASIACRYPT 2017, Part III, volume 10626 of LNCS, pages 3–33. Springer, 2017.</li>

      <li>[AF07] Masayuki Abe and Serge Fehr. Perfect NIZK with adaptive soundness. In Salil P. Vadhan, editor, TCC 2007, volume 4392 of LNCS, pages 118–136. Springer, 2007.</li>

      <li>[BB04] Dan Boneh and Xavier Boyen. Short signatures without random oracles. In Christian Cachin and Jan Camenisch, editors, EUROCRYPT 2004, volume 3027 of LNCS, pages 56–73. Springer, 2004.</li>

      <li>[BBS04] Dan Boneh, Xavier Boyen, and Hovav Shacham. Short group signatures. In Matthew Franklin, editor, CRYPTO 2004, volume 3152 of LNCS, pages 41–55. Springer, 2004.</li>

      <li>[BCCT12] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In Shafi Goldwasser, editor, ITCS 2012, pages 326–349. ACM, 2012.</li>

      <li>[BCG^{+}13] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza. SNARKs for C: Verifying program executions succinctly and in zero knowledge. In Ran Canetti and Juan A. Garay, editors, CRYPTO 2013, Part II, volume 8043 of LNCS, pages 90–108. Springer, 2013.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BCG^{+}14a] Eli Ben-Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers, Eran Tromer, and Madars Virza. Zerocash: Decentralized anonymous payments from bitcoin. In 2014 IEEE Symposium on Security and Privacy, pages 459–474. IEEE Computer Society Press, 2014.</li>

      <li>[BCG^{+}14b] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza. libsnark, 2014. Available at https://github.com/scipr-lab/libsnark.</li>

      <li>[BCG^{+}15] Eli Ben-Sasson, Alessandro Chiesa, Matthew Green, Eran Tromer, and Madars Virza. Secure sampling of public parameters for succinct zero knowledge proofs. In 2015 IEEE Symposium on Security and Privacy, pages 287–304. IEEE Computer Society Press, 2015.</li>

      <li>[BCI^{+}10] Eric Brier, Jean-Sébastien Coron, Thomas Icart, David Madore, Hugues Randriam, and Mehdi Tibouchi. Efficient indifferentiable hashing into ordinary elliptic curves. In Tal Rabin, editor, CRYPTO 2010, volume 6223 of LNCS, pages 237–254. Springer, 2010.</li>

      <li>[BCI^{+}13] Nir Bitansky, Alessandro Chiesa, Yuval Ishai, Rafail Ostrovsky, and Omer Paneth. Succinct non-interactive arguments via linear interactive proofs. In Amit Sahai, editor, TCC 2013, volume 7785 of LNCS, pages 315–333. Springer, 2013.</li>

      <li>[BCPR14] Nir Bitansky, Ran Canetti, Omer Paneth, and Alon Rosen. On the existence of extractable one-way functions. In David B. Shmoys, editor, 46th ACM STOC, pages 505–514. ACM Press, 2014.</li>

      <li>[BCTV14] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Succinct non-interactive zero knowledge for a von Neumann architecture. In Kevin Fu and Jaeyeon Jung, editors, USENIX Security Symposium, pages 781–796. USENIX Association, 2014.</li>

      <li>[BDMP91] Manuel Blum, Alfredo De Santis, Silvio Micali, and Giuseppe Persiano. Noninteractive zero-knowledge. SIAM Journal on Computing, 20(6):1084–1118, 1991.</li>

      <li>[BF01] Dan Boneh and Matthew K. Franklin. Identity-based encryption from the Weil pairing. In Joe Kilian, editor, CRYPTO 2001, volume 2139 of LNCS, pages 213–229. Springer, 2001.</li>

      <li>[BFM88] Manuel Blum, Paul Feldman, and Silvio Micali. Non-interactive zero-knowledge and its applications (extended abstract). In 20th ACM STOC, pages 103–112. ACM Press, 1988.</li>

      <li>[BFS16] Mihir Bellare, Georg Fuchsbauer, and Alessandra Scafuro. NIZKs with an untrusted CRS: Security in the face of parameter subversion. In Jung Hee Cheon and Tsuyoshi Takagi, editors, ASIACRYPT 2016, Part II, volume 10032 of LNCS, pages 777–804. Springer, 2016.</li>

      <li>[BG93] Mihir Bellare and Oded Goldreich. On defining proofs of knowledge. In Ernest F. Brickell, editor, CRYPTO’92, volume 740 of LNCS, pages 390–420. Springer, 1993.</li>

      <li>[BGG17] Sean Bowe, Ariel Gabizon, and Matthew D. Green. A multi-party protocol for constructing the public parameters of the pinocchio zk-SNARK. Cryptology ePrint Archive, Report 2017/602, 2017. http://eprint.iacr.org/2017/602.</li>

      <li>[BP04] Mihir Bellare and Adriana Palacio. The knowledge-of-exponent assumptions and 3-round zero-knowledge protocols. In Matthew Franklin, editor, CRYPTO 2004, volume 3152 of LNCS, pages 273–289. Springer, 2004.</li>

      <li>[BR93] Mihir Bellare and Phillip Rogaway. Random oracles are practical: A paradigm for designing efficient protocols. In V. Ashby, editor, ACM CCS 93, pages 62–73. ACM Press, 1993.</li>

      <li>[BR06] Mihir Bellare and Phillip Rogaway. The security of triple encryption and a framework for code-based game-playing proofs. In Serge Vaudenay, editor, EUROCRYPT 2006, volume 4004 of LNCS, pages 409–426. Springer, 2006.</li>

      <li>[BSBC^{+}17] Eli Ben-Sasson, Iddo Bentov, Alessandro Chiesa, Ariel Gabizon, Daniel Genkin, Matan Hamilis, Evgenya Pergament, Michael Riabzev, Mark Silberstein, Eran Tromer, and Madars Virza. Computational integrity with a public random string from quasi-linear PCPs. In Jean-Sébastien Coron and Jesper Buus Nielsen, editors, EUROCRYPT 2017, Part II, volume 10211 of LNCS, pages 551–579. Springer, 2017.</li>

    </ul>

    <p class="text-gray-300">[CGGN17] Matteo Campanelli, Rosario Gennaro, Steven Goldfeder, and Luca Nizzardo. Zero-knowledge contingent payments revisited: Attacks and payments for services. In Bhavani M. Thuraisingham, David Evans, Tal Malkin, and Dongyan Xu, editors, ACM CCS 17, pages 229–243. ACM Press, 2017.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[CNE^{+}14] Stephen Checkoway, Ruben Niederhagen, Adam Everspaugh, Matthew Green, Tanja Lange, Thomas Ristenpart, Daniel J. Bernstein, Jake Maskiewicz, Hovav Shacham, and Matthew Fredrikson. On the practical exploitability of Dual EC in TLS implementations. In Kevin Fu and Jaeyeon Jung, editors, USENIX Security Symposium, pages 319–335. USENIX Association, 2014.</li>

      <li>[Dam92] Ivan Damgård. Towards practical public key systems secure against chosen ciphertext attacks. In Joan Feigenbaum, editor, CRYPTO’91, volume 576 of LNCS, pages 445–456. Springer, 1992.</li>

      <li>[DFGK14] George Danezis, Cédric Fournet, Jens Groth, and Markulf Kohlweiss. Square span programs with applications to succinct NIZK arguments. In Palash Sarkar and Tetsu Iwata, editors, ASIACRYPT 2014, Part I, volume 8873 of LNCS, pages 532–550. Springer, 2014.</li>

      <li>[FKL17] Georg Fuchsbauer, Eike Kiltz, and Julian Loss. The algebraic group model and its applications. Cryptology ePrint Archive, Report 2017/620, 2017. http://eprint.iacr.org/2017/620.</li>

      <li>[FLS90] Uriel Feige, Dror Lapidot, and Adi Shamir. Multiple non-interactive zero knowledge proofs based on a single random string (extended abstract). In 31st FOCS, pages 308–317. IEEE Computer Society Press, 1990.</li>

      <li>[FS87] Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identification and signature problems. In Andrew M. Odlyzko, editor, CRYPTO’86, volume 263 of LNCS, pages 186–194. Springer, 1987.</li>

      <li>[Gab19] Ariel Gabizon. On the security of the BCTV Pinocchio zk-SNARK variant. Cryptology ePrint Archive, Report 2019/119, 2019. http://eprint.iacr.org/2019/119.</li>

      <li>[Gen04] Rosario Gennaro. Multi-trapdoor commitments and their applications to proofs of knowledge secure under concurrent man-in-the-middle attacks. In Matthew Franklin, editor, CRYPTO 2004, volume 3152 of LNCS, pages 220–236. Springer, 2004.</li>

      <li>[GGPR13] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct NIZKs without PCPs. In Thomas Johansson and Phong Q. Nguyen, editors, EUROCRYPT 2013, volume 7881 of LNCS, pages 626–645. Springer, 2013.</li>

      <li>[GMR89] Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of interactive proof systems. SIAM Journal on Computing, 18(1):186–208, 1989.</li>

      <li>[GO94] Oded Goldreich and Yair Oren. Definitions and properties of zero-knowledge proof systems. Journal of Cryptology, 7(1):1–32, 1994.</li>

      <li>[GOS06a] Jens Groth, Rafail Ostrovsky, and Amit Sahai. Non-interactive zaps and new techniques for NIZK. In Cynthia Dwork, editor, CRYPTO 2006, volume 4117 of LNCS, pages 97–111. Springer, 2006.</li>

      <li>[GOS06b] Jens Groth, Rafail Ostrovsky, and Amit Sahai. Perfect non-interactive zero knowledge for NP. In Serge Vaudenay, editor, EUROCRYPT 2006, volume 4004 of LNCS, pages 339–358. Springer, 2006.</li>

      <li>[Gro06] Jens Groth. Simulation-sound NIZK proofs for a practical language and constant size group signatures. In Xuejia Lai and Kefei Chen, editors, ASIACRYPT 2006, volume 4284 of LNCS, pages 444–459. Springer, 2006.</li>

      <li>[Gro10] Jens Groth. Short pairing-based non-interactive zero-knowledge arguments. In Masayuki Abe, editor, ASIACRYPT 2010, volume 6477 of LNCS, pages 321–340. Springer, 2010.</li>

    </ul>

    <p class="text-gray-300">[Gro16] Jens Groth. On the size of pairing-based non-interactive arguments. In Marc Fischlin and Jean-Sébastien Coron, editors, EUROCRYPT 2016, Part II, volume 9666 of LNCS, pages 305–326. Springer, 2016.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[GS08] Jens Groth and Amit Sahai. Efficient non-interactive proof systems for bilinear groups. In Nigel P. Smart, editor, EUROCRYPT 2008, volume 4965 of LNCS, pages 415–432. Springer, 2008.</li>

      <li>[GW11] Craig Gentry and Daniel Wichs. Separating succinct non-interactive arguments from all falsifiable assumptions. In Lance Fortnow and Salil P. Vadhan, editors, 43rd ACM STOC, pages 99–108. ACM Press, 2011.</li>

      <li>[HT98] Satoshi Hada and Toshiaki Tanaka. On the existence of 3-round zero-knowledge protocols. In Hugo Krawczyk, editor, CRYPTO’98, volume 1462 of LNCS, pages 408–423. Springer, 1998.</li>

      <li>[Lip12] Helger Lipmaa. Progression-free sets and sublinear pairing-based non-interactive zero-knowledge arguments. In Ronald Cramer, editor, TCC 2012, volume 7194 of LNCS, pages 169–189. Springer, 2012.</li>

      <li>[Mic00] Silvio Micali. Computationally sound proofs. SIAM J. Comput., 30(4):1253–1298, 2000.</li>

      <li>[Nak09] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system, 2009. http://bitcoin.org/bitcoin.pdf.</li>

      <li>[PHGR13] Bryan Parno, Jon Howell, Craig Gentry, and Mariana Raykova. Pinocchio: Nearly practical verifiable computation. In 2013 IEEE Symposium on Security and Privacy, pages 238–252. IEEE Computer Society Press, May 2013.</li>

      <li>[Sch91] Claus-Peter Schnorr. Efficient signature generation by smart cards. Journal of Cryptology, 4(3):161–174, 1991.</li>

      <li>[Sho97] Victor Shoup. Lower bounds for discrete logarithms and related problems. In Walter Fumy, editor, EUROCRYPT’97, volume 1233 of LNCS, pages 256–266. Springer, 1997.</li>

      <li>[SvdW06] Andrew Shallue and Christiaan van de Woestijne. Construction of rational points on elliptic curves over finite fields. In Florian Hess, Sebastian Pauli, and Michael E. Pohst, editors, ANTS-VII, volume 4076 of LNCS, pages 510–524. Springer, 2006.</li>

      <li>[Zca] Zcash. http://z.cash.</li>

    </ul>`;
---

<BaseLayout title="Subversion-zero-knowledge SNARKs (2017/587)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2017 &middot; eprint 2017/587
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
