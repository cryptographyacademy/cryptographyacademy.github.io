---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2023/273';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Derecho: Privacy Pools with Proof-Carrying Disclosures';
const AUTHORS_HTML = 'Josh Beal, Ben Fisch';

const CONTENT = `    <p class="text-gray-300">Josh Beal [ josh.beal@yale.edu Yale University New Haven, CT, United States ] , Ben Fisch [ ben.fisch@yale.edu Yale University New Haven, CT, United States ]</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract.</h6>

    <p class="text-gray-300">A <em>privacy pool</em> enables clients to deposit units of a cryptocurrency into a shared pool where ownership of deposited currency is tracked via a system of cryptographically hidden records. Clients may later withdraw from the pool without linkage to previous deposits. Some privacy pools also support hidden transfer of currency ownership within the pool. In August 2022, the U.S. Department of Treasury sanctioned Tornado Cash, the largest Ethereum privacy pool, on the premise that it enables illicit actors to hide the origin of funds, citing its usage by the DPRK-sponsored Lazarus Group to launder over $455 million dollars worth of stolen cryptocurrency. This ruling effectively made it illegal for U.S. persons/institutions to use or accept funds that went through Tornado Cash, sparking a global debate among privacy rights activists and lawmakers. Against this backdrop, we present <em>Derecho</em>, a system that institutions could use to request cryptographic attestations of fund origins rather than naively rejecting all funds coming from privacy pools. Derecho is a novel application of <em>proof-carrying data</em>, which allows users to propagate allowlist membership proofs through a privacy pool’s transaction graph. Derecho is backwards-compatible with existing Ethereum privacy pool designs, adds no overhead in gas costs, and costs users only a few seconds to produce attestations.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1. Introduction</h2>

    <p class="text-gray-300">Bitcoin, Ethereum, and other cryptocurrencies have achieved significant market capitalization and adoption over the past decade, yet the privacy guarantees of many popular blockchains remain lacking. The traceability of transactions in blockchains such as Bitcoin and Ethereum has been well-studied <em>(1; 33)</em>, and even privacy-focused blockchains are subject to deanonymization attacks <em>(29; 34; 45)</em>. Privacy solutions can be designed as add-on components to an existing blockchain or as independent blockchains.</p>

    <p class="text-gray-300">In this work, we focus on privacy pools that use <em>zero-knowledge proofs</em> to enable anonymous transfers of assets on account-based smart contract platforms such as Ethereum. These pools are based on the design of <em>Zerocash</em> <em>(4)</em>, which is also the basis for the cryptocurrency Zcash <em>(26)</em>. In a nutshell, these privacy pools enable users to deposit funds into a shared pool, anonymously transfer funds within the pool, and later withdraw funds without linkage to their previous transactions.</p>

    <p class="text-gray-300">Tornado Cash (Nova) was the most widely used Ethereum privacy pool until U.S. regulators took action against the service in August 2022. The Office of Foreign Assets Control (OFAC) added the Tornado Cash smart contract addresses to the Specially Designated Nationals (SDN) list, due to its purported usage for laundering more than $9 billion worth of cryptocurrency since 2019, including by the DPRK state-sponsored Lazarus Group that was also sanctioned in 2019. This designation forbids U.S. users, including individuals and institutions, from interacting with the service <em>(42)</em>. It has resulted in locked funds for U.S. users of the service and has limited the options for law-abiding users that seek to improve the privacy of their transactions on Ethereum. These sanctions have brought renewed attention to the clash between privacy and regulatory oversight on smart contract platforms. In October 2022, Coin Center filed a lawsuit arguing that OFAC exceeded its statutory authority in designating Tornado Cash <em>(17)</em>. It also sparked discussion among researchers and privacy advocates <em>(11; 12; 21)</em>, questioning both the efficacy and necessity of privacy pool sanctions in addressing illicit finance, and seeking alternative solutions.</p>

    <p class="text-gray-300">A simple solution would restrict deposits into and withdrawals from the privacy pool to accounts on a specific allowlist. For example, the allowlist might be the set of all public Ethereum addresses that are not on the U.S. Treasury’s SDN list. However, allowlists are expected to vary by jurisdiction and may be updated dynamically. In practice, there are widely used “compliance-as-a-service” providers, such as Chainalysis and TRM Labs, that assess the risk of public Ethereum addresses, incorporating multiple risk factors such as interactions with government-sanctioned addresses and exploited smart contracts, and continuously update their risk assessments. Today, U.S. regulated exchanges utilize these risk scores for risk management, e.g., to decide whether or not to accept deposits from a given address. Allowlists can be viewed as binary risk scores.</p>

    <p class="text-gray-300">An alternative solution to restricting deposits and withdrawals is for users of privacy pools to generate attestations when necessary, selectively disclosing information about the provenance of funds withdrawn from the pool. When cryptocurrency is deposited into a privacy pool like Tornado Cash, a digital receipt in the form of a cryptographic commitment is generated, and the depositor retains a secret key required to use this receipt later. A user withdraws <span class="math">x</span> units of cryptocurrency from the pool by presenting a zero-knowledge proof that it knows the secret key of an unused receipt for this exact amount of cryptocurrency, and a keyed hash of the receipt called a <em>nullifier</em>. The nullifier still hides the receipt but prevents it from being used twice. While this zero-knowledge proof reveals little information by default (other than transaction validity), a user may choose to reveal more information about the origin of a withdrawal to an interested party (e.g., an exchange). In fact, zero-knowledge proofs can be used to selectively disclose information about the unique deposit receipt, such as membership of the depositing address on an allowlist or a risk score that a provider has assigned to that public address. Similar solutions were proposed more than a decade ago in the context of Tor and blocklisting of IP-addresses <em>(3; 28; 39)</em>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">However, this system of user-generated disclosures becomes more challenging in pools that support in-pool transfers. The recipient of funds must retain the ability to prove facts about its provenance, in particular, that the funds originated via deposits from accounts on a given set of allowlists. We solve this problem using <em>proof-carrying data</em> [(Koch et al., 2016)], a generalization of incrementally verifiable computation [(Koch et al., 2016)] that offers a powerful approach to recursive proof composition. When a user makes their first transaction within the privacy pool, the user generates membership proofs for a set of allowlists. Subsequent transactions within the privacy pool generate new membership proofs that are derived from (i.e., prove knowledge of) the previous membership proofs of the transaction inputs and the details of the current transaction. These membership proofs, which we call <em>proof-carrying disclosures</em>, can be verified efficiently and may be communicated directly to the recipient. While our solution focuses on allowlists, it can easily be generalized to handle non-binary risk scores.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1. Our Contributions</h3>

    <p class="text-gray-300">To summarize, our main contributions are as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We formalize and present Derecho, a system for cryptographic attestation of funds originating from privacy pools. Our system addresses the key legal challenges of privacy pools through the usage of <em>proof-carrying disclosures</em>, a novel application of proof-carrying data.</li>

      <li>We show that our disclosure system achieves practical proving and verification times for a range of system parameters. For a typical configuration, the proving time was 3.4 seconds, and the verification time was 1.9 seconds. Since membership proofs are verified off-chain by the recipient, our system adds no overhead in gas costs.</li>

    </ul>

    <h2 id="sec-5" class="text-2xl font-bold">2. Technical Overview</h2>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">2.1. Design Goals</h3>

    <p class="text-gray-300">A key goal in the system design was to develop a solution that can be introduced as an add-on component to existing privacy pools on Ethereum and other smart contract platforms. To facilitate adoption of the system, the design should not require changes to the functionality of the privacy pool or introduce any gas costs to users. Furthermore, it should maintain the existing security properties of the privacy pool while optionally allowing for attestations of allowlist membership.</p>

    <p class="text-gray-300">We rule out solutions that involve changes to the privacy pool or limitations on the number of allowlists. For instance, a naive solution to this problem would involve augmenting the coin commitment openings with a field storing the allowlist identifier and enforcing membership consistency in the transfer proofs of the privacy pool. However, this solution would not be backwards-compatible with existing privacy pools. Furthermore, if an arbitrary number of allowlists is supported, the increase in gas costs would be substantial. To support an unbounded number of allowlists in the naive solution, the privacy pool would need to let the allowlist field have unbounded size or restrict the size and make use of an on-chain set accumulator. While such a solution is appealing in its simplicity, it would face barriers to adoption due to the costs to users and the required changes to existing systems.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.2. Initial Approach</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Derecho assumes the existence of a set of allowlists that are maintained external to the system, where each allowlist contains a list of public Ethereum addresses, along with a dynamic accumulator <span class="math">A</span> (e.g., a Merkle tree) which aggregates the allowlists. That is, for each address <span class="math">\\mathrm{pk}</span> on allowlist with identifier <span class="math">\\mathrm{al}</span> the element $H(\\mathrm{al}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{pk})<span class="math"> is inserted into </span>A<span class="math">, where </span>H<span class="math"> is a collision-resistant hash function. For simplicity, we restrict to privacy pools that manage only one cryptocurrency asset at a time, but the system easily generalizes to pools that manage multiple types of assets. The pool contract maintains an accumulator </span>R<span class="math"> of records, where each record is a hash digest (i.e., cryptographic commitment). When a user first deposits </span>x<span class="math"> units of cryptocurrency into the privacy pool from a public Ethereum address </span>\\mathrm{pk}_{x}<span class="math">, a record of the form </span>H(x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{pk}_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r_{1})<span class="math"> is added to the accumulator </span>R<span class="math">, where </span>\\mathrm{pk}_{1}<span class="math"> is the user’s public key and </span>r_{1}<span class="math"> is a nonce that will later be used to nullify the record upon a transfer or withdrawal. A transfer transaction may create a new record </span>H(x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{pk}_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r_{2})<span class="math">, a nullifier </span>n=H(r_{1})<span class="math">, and a zero-knowledge proof that a record </span>c=H(x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{pk}_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r_{1})<span class="math"> exists in </span>R<span class="math"> such that </span>n=H(r_{1})<span class="math">. The transfer may also create multiple output records of the form </span>H(x_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{pk}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r_{i})<span class="math"> for </span>i\\in[2,k]<span class="math">, and the zero-knowledge proof would additionally attest that </span>\\sum_{i}x_{i}=x<span class="math">. A withdrawal contains a similar zero-knowledge proof, but publicly reveals the output amount </span>y<span class="math"> and a destination Ethereum address </span>\\mathrm{pk}_{d}<span class="math">, at which point </span>y<span class="math"> units are withdrawn from the pool and delivered to </span>\\mathrm{pk}_{d}$. While this example references a concrete implementation of a privacy pool for illustrative purposes, the disclosure system does not assume a specific record format or nullifier creation algorithm.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We define membership of records on allowlists recursively as follows. The initial record created upon deposit is a member of allowlist <span class="math">\\mathrm{al}</span> if and only if its source Ethereum address <span class="math">\\mathrm{pk}_{s}</span> is a member of <span class="math">\\mathrm{al}</span>. A record created as the output of a transfer transaction is a member of <span class="math">\\mathrm{al}</span> if and only if all the input records to the transfer are members of <span class="math">\\mathrm{al}</span>. Similarly, we say that a withdrawal transaction is a member of <span class="math">\\mathrm{al}</span> if and only if all the input records to this withdrawal are members of <span class="math">\\mathrm{al}</span>. This final attestation refers to the withdrawal transaction itself rather than the Ethereum destination address <span class="math">\\mathrm{pk}_{d}</span>, which may or may not be on the allowlist for other reasons.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since the initial record created upon deposit is publicly linked to the Ethereum source address <span class="math">\\mathrm{pk}_{s}</span> via the on-chain deposit transaction, it is straightforward for a user to produce a membership proof of the deposit record on a list <span class="math">\\mathrm{al}</span> by providing a membership proof for <span class="math">\\mathrm{pk}_{s}</span> using the accumulator <span class="math">A</span>, which could be verified given the transaction log. Producing membership disclosure proofs for the output records of in-pool transactions is more subtle. If a user already has membership proofs for all the input records to a transfer transaction with respect to a list <span class="math">\\mathrm{al}</span>, then it can create a membership proof for an output record of this transaction by proving its knowledge of valid <span class="math">\\mathrm{al}</span> membership proofs for all the input records to the transaction. The same could be done for a withdrawal transaction. In more detail, since neither the output record nor the transaction log contains explicit references linking it to transaction inputs, but only nullifiers <span class="math">n_{i}</span> for each input record, the zero-knowledge disclosure proof repeats the logic of the transfer proof: for each <span class="math">n_{i}</span>, it proves knowledge of an input record $c_{i}=H(x_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{pk}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r_{i})$ such that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: Illustration of the proposed disclosure system and an example workflow.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a></p>

    <p class="text-gray-300"><span class="math">n_i = H(r_i)</span>  and additionally proves knowledge of a valid membership proof  <span class="math">\\pi_i</span>  for  <span class="math">c_i</span> . This recursive proof of knowledge is possible via a proof-carrying data (PCD) scheme.</p>

    <p class="text-gray-300">With this initial approach, a problem immediately arises: the validity of the membership proof  <span class="math">\\pi_{i}</span>  is not actually verifiable against the record commitment  <span class="math">c_{i}</span>  alone. For example, verifying the initial membership proof of a deposit record  <span class="math">c</span>  required checking against the blockchain transaction log to obtain the link between the record  <span class="math">c</span>  and a source Ethereum address  <span class="math">\\mathsf{pk}_s</span> . Naively, if the public input required to verify allowlist membership includes the entire transaction log of the privacy pool then the recursive zero-knowledge proof statement would become impractically large.</p>

    <p class="text-gray-300">The standard trick around this problem is to replace the transaction log public input with an accumulator digest  <span class="math">T</span> : the membership disclosure proof for a deposit record  <span class="math">c</span>  now includes both an accumulator membership proof for  <span class="math">T</span>  of a transaction linking  <span class="math">c</span>  to  <span class="math">\\mathsf{pk}_s</span>  and an accumulator membership proof for  <span class="math">A</span>  showing that  <span class="math">\\mathsf{pk}_s</span>  is on the list at the time of the deposit.</p>

    <p class="text-gray-300">However, yet another subtle complication arises when attempting to produce recursive membership proofs for the output records of transfers. Suppose the user has a membership proof  <span class="math">\\pi</span>  for an input record  <span class="math">c</span>  to a transfer creating an output record  <span class="math">c&#x27;</span> . Suppose further that the accumulator digest  <span class="math">T</span>  commits to the transaction log state at the time  <span class="math">t</span>  that  <span class="math">\\pi</span>  was created, and that the accumulator state  <span class="math">T&#x27;</span>  commits to the transaction log state at the time  <span class="math">t&#x27;</span>  that the new transfer is occurring. The value  <span class="math">T</span>  is required as input to verify  <span class="math">\\pi</span> , but is unknown to the recipient of the transfer at the time  <span class="math">t&#x27;</span> . Thus,  <span class="math">T</span>  is not available as a public input to verify the recursive disclosure created for  <span class="math">c&#x27;</span> , rather, the disclosure must prove knowledge of both</p>

    <p class="text-gray-300"><span class="math">\\pi, c</span>  and  <span class="math">T</span>  against which  <span class="math">\\pi</span>  is valid. Moreover, without additional restrictions, the prover would be free to invent a malicious proof  <span class="math">\\pi^{<em>}</span>  valid against a  <span class="math">T^{</em>}</span>  unrelated to the true blockchain state at any point in history.</p>

    <p class="text-gray-300">To resolve this problem, we use history accumulators, which commit not only to the current state of a set but also to all historical states. History accumulators provide an efficient mechanism to prove that a digest  <span class="math">T</span>  represents a valid historical state  <span class="math">\\sigma</span> , which can be verified against the current digest  <span class="math">T&#x27;</span>  of the history accumulator. In Section 4.2, we provide precise definitions of the disclosure system's three key data structures: membership declarations, deposit records, and transfer records. Each of these data structures has a corresponding history accumulator as illustrated above.</p>

    <p class="text-gray-300">Altogether, these techniques result in a system that only requires a few seconds to produce attestations on a consumer-grade laptop. These attestations can be efficiently verified by the recipient of funds with respect to the current blockchain state. Due to the fact that these proofs do not need to be posted on-chain or verified by the smart contract, we were able to leverage recent developments in PCD that trade a larger proof size for faster proving times [9]. The membership proofs that are exchanged between users are large, but the final proof presented to an exchange can be compressed by a general-purpose SNARK as discussed in prior work [8, 31].</p>

    <p class="text-gray-300">To highlight the main ideas of our construction, we describe a typical system workflow, which is illustrated in Figure 1. We consider a user named Alice, who has generated key pairs and registered these key pairs with the privacy pool. The manager for allowlist  <span class="math">\\mathrm{al}_1</span>  authorizes membership for Alice's address  <span class="math">\\mathrm{pk}_{\\mathrm{sl}}</span> . As a result, Alice</p>

    <p class="text-gray-300">has an account with membership on allowlist <span class="math">\\mathsf{al}_1</span>, and a membership declaration will be created and accumulated. The manager can revoke the membership of Alice's account at any point. However, since disclosure creation is optional, Alice cannot be prevented from using the privacy pool. Funds may always be spent without producing an accompanying membership proof. Next, we will see an example of how these membership proofs are generated.</p>

    <p class="text-gray-300">First, Alice deposits 1 ETH into the privacy pool. Based on the details of the deposit transaction, a deposit record <span class="math">\\mathrm{rec}_{\\mathrm{dep}}</span> will be created and accumulated. Second, Alice transfers 1 ETH to Bob using the anonymous transfer functionality of the pool. Asynchronously, Alice can create a membership proof for this transfer. This initial membership proof <span class="math">\\pi_1</span> will attest to the existence of a deposit record <span class="math">\\mathrm{rec}_{\\mathrm{dep}}</span> for the transaction input and the existence of a membership declaration <span class="math">\\mathrm{decl}_a</span> for Alice's address <span class="math">\\mathrm{pk}_a</span> with respect to allowlist <span class="math">\\mathsf{al}_1</span>. The proof ensures correspondence to a true blockchain state by attesting to the existence of an appropriate transfer record <span class="math">\\mathrm{rec}_{\\mathrm{tr}}^1</span>. Alice sends the proof <span class="math">\\pi_1</span> to Bob shortly after the transfer occurs. Subsequently, Bob withdraws 1 ETH from the privacy pool. Asynchronously, Bob can create a membership proof for this withdrawal. This proof <span class="math">\\pi_2</span> will attest to the existence of a proof <span class="math">\\pi_1</span> for the transaction input. As before, the proof also ensures correspondence to a true blockchain state by attesting to the existence of an appropriate transfer record <span class="math">\\mathrm{rec}_{\\mathrm{tr}}^2</span>. If Bob wishes to deposit the withdrawn funds with origin attestation at a regulated institution, he can present the final membership proof <span class="math">\\pi_2</span> directly to the recipient for verification.</p>

    <h2 id="sec-11" class="text-2xl font-bold">3.1 Preliminaries</h2>

    <p class="text-gray-300"><strong>Notation.</strong> We let <span class="math">\\lambda \\in \\mathbb{N}</span> denote the security parameter with unary representation <span class="math">1^{\\lambda}</span>. We let <span class="math">\\mathrm{negl}</span> denote the class of negligible functions. We let PPT denote probabilistic polynomial time. We let <span class="math">\\mathcal{A}</span> denote a computationally-bounded adversary modeled as a PPT algorithm. We let <span class="math">[l]</span> denote the set of integers <span class="math">\\{0, \\dots, l-1\\}</span>. We let <span class="math">x \\leftarrow S</span> denote that <span class="math">x</span> is sampled uniformly at random from a set <span class="math">S</span>. We let <span class="math">\\mathbb{F}_q</span> denote a finite field of order <span class="math">q</span>. We consider collision-resistant hash functions of the form <span class="math">H_q: \\{0, 1\\}^* \\to \\mathbb{F}_q</span>.</p>

    <p class="text-gray-300"><strong>History accumulator schemes.</strong> A history accumulator is an authenticated data structure that commits to a current set state <span class="math">\\sigma_{n}</span> and also to all previous set states <span class="math">\\sigma_{1},\\ldots,\\sigma_{n-1}</span>. When the accumulator digest <span class="math">\\mathrm{rt}_{n}</span> for <span class="math">\\sigma_{n}</span> is incrementally updated for a new state <span class="math">\\sigma_{n+1}</span>, the new digest <span class="math">\\mathrm{rt}_{n+1}</span> is a commitment to <span class="math">\\sigma_{n+1}</span> and all prior states accumulated by <span class="math">\\mathrm{rt}_{n}</span>. Some history accumulators support history proofs of additional invariants, e.g., that the current state <span class="math">\\sigma&#x27;</span> of a history accumulator with digest <span class="math">\\mathrm{rt}&#x27;</span> is a superset of all historical states. Specifically, a history accumulator scheme consists of a tuple of efficient algorithms <span class="math">\\mathsf{HA} = (\\mathsf{Init}, \\mathsf{Update}, \\mathsf{Remove}, \\mathsf{PrvMem}, \\mathsf{VfyMem}, \\mathsf{PrvHist}, \\mathsf{VfyHist})</span> where the algorithms work as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathrm{rt}, \\sigma) \\leftarrow \\mathrm{Init}(1^{\\lambda})</span> sets up the initial state <span class="math">\\sigma</span> and digest <span class="math">\\mathrm{rt}</span> of the history accumulator.</li>

      <li><span class="math">(\\mathrm{rt}&#x27;, \\sigma&#x27;) \\leftarrow \\mathrm{Update}(\\mathrm{rt}, \\sigma, \\mathrm{elem})</span> inserts element elem into the set and outputs an updated state <span class="math">\\sigma&#x27;</span> and digest <span class="math">\\mathrm{rt}&#x27;</span>.</li>

      <li><span class="math">\\pi \\leftarrow \\operatorname{PrvMem}(\\sigma, \\operatorname{elem})</span> outputs a set membership proof <span class="math">\\pi</span> for the element elem in the set.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b \\leftarrow \\mathsf{VfyMem}(\\mathrm{rt}, \\pi, \\mathrm{elem})</span> outputs a bit <span class="math">b \\in \\{0, 1\\}</span> verifying whether <span class="math">\\pi</span> is a valid proof for the accumulation of elem in rt. The output is <span class="math">b = 1</span> if the proof is accepted as valid and <span class="math">b = 0</span> otherwise.</li>

      <li><span class="math">(\\mathrm{rt}&#x27;, \\sigma&#x27;) \\leftarrow \\mathrm{Remove}(\\mathrm{rt}, \\sigma, \\mathrm{elem})</span> removes element elem from the set and outputs updated state <span class="math">\\sigma&#x27;</span> and digest <span class="math">\\mathrm{rt}&#x27;</span>.</li>

      <li><span class="math">\\pi \\leftarrow \\operatorname{PrvHist}(\\mathrm{rt}, \\sigma&#x27;)</span> given the current state <span class="math">\\sigma&#x27;</span> (which has a current digest <span class="math">\\mathrm{rt}&#x27;</span>) outputs a proof <span class="math">\\pi</span> that rt is a historical state of the history accumulator.</li>

      <li><span class="math">b \\leftarrow \\mathsf{VfyHist}(\\mathrm{rt}, \\mathrm{rt}&#x27;, \\pi)</span> outputs a bit <span class="math">b \\in \\{0, 1\\}</span> verifying whether <span class="math">\\pi</span> is a valid proof that rt is a digest of a historical state with respect to <span class="math">\\mathrm{rt}&#x27;</span>. The output is <span class="math">b = 1</span> if the proof is accepted as valid and <span class="math">b = 0</span> otherwise.</li>

    </ul>

    <p class="text-gray-300">Informally, a history accumulator scheme should also be correct and sound. Correctness ensures that for every element in the set, it should be easy to generate a membership proof, and for every historical state, it should be easy to generate a history proof. Soundness ensures that for every element not in the set, it should be infeasible to generate a membership proof, and for every state that is not a historical state, it should be infeasible to generate a history proof. This scheme can be instantiated by Merkle history trees [10, 19, 40], which are known to support efficient membership proofs and history proofs [18, 32].</p>

    <p class="text-gray-300"><strong>Proof-Carrying Data.</strong> Proof-carrying data (PCD) [16] enables a set of parties to carry out an arbitrarily long distributed computation where every step is accompanied by a proof of correctness.</p>

    <p class="text-gray-300">Let <span class="math">V(\\mathbf{G})</span> and <span class="math">E(\\mathbf{G})</span> denote the vertices and edges of a graph <span class="math">\\mathbf{G}</span>. A transcript <span class="math">\\mathsf{T}</span> is a directed acyclic graph where each vertex <span class="math">u \\in V(\\mathsf{T})</span> is labeled by local data <span class="math">z_{\\mathrm{loc}}^{(u)}</span> and each edge <span class="math">e \\in E(\\mathsf{T})</span> is labeled by a message <span class="math">z^{(e)} \\neq \\bot</span>. The output of a transcript <span class="math">\\mathsf{T}</span>, denoted <span class="math">\\mathsf{o}(\\mathsf{T})</span>, is <span class="math">z^{(e&#x27;)}</span> where <span class="math">e&#x27; = (u, v)</span> is the lexicographically-first edge such that <span class="math">v</span> is a sink.</p>

    <p class="text-gray-300">A vertex <span class="math">u \\in V(\\mathsf{T})</span> is <span class="math">\\varphi</span>-compliant for a predicate <span class="math">\\varphi \\in \\mathsf{F}</span> if for all outgoing edges <span class="math">e = (u, v) \\in E(\\mathsf{T})</span> either: (1) if <span class="math">u</span> has no incoming edges, <span class="math">\\varphi(z^{(e)}, z_{\\mathrm{loc}}^{(u)}, \\bot, \\ldots, \\bot)</span> evaluates to true or (2) if <span class="math">u</span> has <span class="math">m</span> incoming edges <span class="math">e_1, \\ldots, e_m</span>, <span class="math">\\varphi(z^{(e)}, z_{\\mathrm{loc}}^{(u)}, z^{(e_1)}, \\ldots, z^{(e_m)})</span> evaluates to true. A transcript <span class="math">\\mathsf{T}</span> is <span class="math">\\varphi</span>-compliant if all of its vertices are <span class="math">\\varphi</span>-compliant.</p>

    <p class="text-gray-300">A proof-carrying data system PCD for a class of compliance predicates <span class="math">\\mathsf{F}</span> consists of a tuple of efficient algorithms <span class="math">(\\mathbb{G}, \\mathbb{I}, \\mathbb{P}, \\mathbb{V})</span>, known as the generator, indexer, prover, and verifier algorithms, for which the properties of completeness, knowledge soundness, and zero knowledge hold.</p>

    <p class="text-gray-300"><strong>Completeness.</strong> PCD has perfect completeness if for every adversary <span class="math">\\mathcal{A}</span>, equation (1) holds under the following conditions: <span class="math">\\mathrm{pp} \\leftarrow \\mathbb{G}(1^{\\lambda}); (\\varphi, z, z_{\\mathrm{loc}}, [z_i, \\pi_i]_{i=1}^m) \\leftarrow \\mathcal{A}(\\mathrm{pp}); (\\mathrm{ipk}, \\mathrm{ivk}) \\leftarrow \\mathbb{I}(\\mathrm{pp}, \\varphi); \\pi \\leftarrow \\mathbb{P}(\\mathrm{ipk}, z, z_{\\mathrm{loc}}, [z_i, \\pi_i]_{i=1}^m)</span>.</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\begin{array}{c} \\varphi \\in \\mathsf {F} \\\\ \\wedge \\varphi (z, z _ {\\mathrm {l o c}}, z _ {1}, \\dots , z _ {m}) = 1 \\\\ \\wedge (\\forall i, z _ {i} = \\bot \\vee \\forall i, \\mathbb {V} (\\mathrm {i v k}, z _ {i}, \\pi_ {i}) = 1) \\\\ \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\\\ \\mathbb {V} (\\mathrm {i v k}, z, \\pi) = 1 \\end{array} \\right] = 1 \\tag {1}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><strong>Knowledge soundness.</strong> PCD has knowledge soundness with respect to an auxiliary input distribution <span class="math">\\mathcal{D}</span> if for every expected</p>

    <p class="text-gray-300">polynomial-time adversary  <span class="math">\\tilde{\\mathbb{F}}</span>  there exists an expected polynomial-time extractor  <span class="math">\\mathbb{E}_{\\tilde{\\mathbb{F}}}</span>  such that for every set  <span class="math">Z</span> , the following two probabilities are negligibly close in probability:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\begin{array}{c c} \\varphi \\in \\mathsf {F} &amp;amp; \\mathrm {p p} \\leftarrow \\mathbb {O} (1 ^ {\\lambda}) \\\\ \\wedge (\\mathrm {p p}, \\mathrm {a i}, \\varphi , \\mathrm {o} (\\mathrm {T}), \\mathrm {a o}) \\in Z &amp;amp; \\mathrm {a i} \\leftarrow \\mathcal {D} (\\mathrm {p p}) \\\\ \\wedge \\mathrm {T} \\text {i s} \\varphi \\text {- c o m p l i a n t} &amp;amp; (\\varphi , \\mathrm {T}, \\mathrm {a o}) \\leftarrow \\mathbb {E} _ {\\tilde {\\mathrm {p}}} (\\mathrm {p p}, \\mathrm {a i}) \\end{array} \\right] \\\\ \\Pr \\left[ \\begin{array}{c c} \\varphi \\in \\mathsf {F} &amp;amp; \\mathrm {p p} \\leftarrow \\mathbb {O} (1 ^ {\\lambda}) \\\\ \\wedge (\\mathrm {p p}, \\mathrm {a i}, \\varphi , \\mathrm {o}, \\mathrm {a o}) \\in Z &amp;amp; \\mathrm {a i} \\leftarrow \\mathcal {D} (\\mathrm {p p}) \\\\ \\wedge \\mathbb {V} (\\mathrm {i v k}, \\mathrm {o}, \\pi) = 1 &amp;amp; (\\varphi , \\mathrm {o}, \\pi , \\mathrm {a o}) \\leftarrow \\tilde {\\mathbb {F}} (\\mathrm {p p}, \\mathrm {a i}) \\\\ &amp;amp; (\\mathrm {i p k}, \\mathrm {i v k}) \\leftarrow \\mathbb {I} (\\mathrm {p p}, \\varphi) \\end{array} \\right] \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Zero knowledge. PCD has (statistical) zero knowledge if there exists a PPT simulator  <span class="math">\\mathbb{S}</span>  such that for every honest adversary  <span class="math">\\mathcal{A}</span>  the distributions below are statistically close:</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{c c} &amp;amp; \\mathrm {p p} \\leftarrow \\mathbb {O} (1 ^ {\\lambda}) \\\\ (\\mathrm {p p}, \\varphi , z, \\pi) &amp;amp; (\\varphi , z, z _ {\\mathrm {l o c}}, [ z _ {i}, \\pi_ {i} ] _ {i = 1} ^ {m}) \\leftarrow \\mathcal {A} (\\mathrm {p p}) \\\\ &amp;amp; (\\mathrm {i p k}, \\mathrm {i v k}) \\leftarrow \\mathbb {I} (\\mathrm {p p}, \\varphi) \\\\ &amp;amp; \\pi \\leftarrow \\mathbb {P} (\\mathrm {i p k}, z, z _ {\\mathrm {l o c}}, [ z _ {i}, \\pi_ {i} ] _ {i = 1} ^ {m}) \\end{array} \\right\\}</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{ \\begin{array}{c c} &amp; (\\mathrm {p p}, \\varphi , z, \\pi) \\quad \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} (\\mathrm {p p}, \\tau) \\leftarrow \\mathbb {S} (1 ^ {\\lambda}) \\\\ (\\varphi , z, z _ {\\mathrm {l o c}}, [ z _ {i}, \\pi_ {i} ] _ {i = 1} ^ {m}) \\leftarrow \\mathcal {A} (\\mathrm {p p}) \\\\ \\pi \\leftarrow \\mathbb {S} (\\tau , \\varphi , z) \\end{array} \\right. \\end{array} \\right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">An adversary is honest if their output results in the implicant of the completeness condition being satisfied with probability 1, i.e.,  <span class="math">\\varphi \\in \\mathsf{F}</span> ,  <span class="math">\\varphi(z, z_{\\mathrm{loc}}, z_1, \\ldots, z_m) = 1</span> , and either  <span class="math">z_i = \\bot</span>  or  <span class="math">\\mathbb{V}(\\mathrm{ivk}, z_i, \\pi_i) = 1</span>  for each incoming edge  <span class="math">z_i</span> . A proof  <span class="math">\\pi</span>  has size poly  $(\\lambda,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varphi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> ; that is, the proof size is not allowed to grow with each application of the prover algorithm  </span>\\mathbb{P}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Our system uses the PCD construction of [9], which is based on split accumulation schemes. Nova [31] is a recent IVC construction based on folding schemes, however we require the more general notion of PCD to support multiple transaction inputs.</p>

    <p class="text-gray-300">The disclosure system consists of accounts, allowlists, clients, managers, and the registry. The system references the state of the privacy pool and user transactions, however it does not change the functionality of the privacy pool. Hence it is backwards-compatible with existing privacy pool designs.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Account. An externally-owned account controls units of a cryptocurrency and has a corresponding public/private key pair. For simplicity, we refer to externally-owned accounts as accounts.</li>

      <li>Allowlist. A list of accounts that are not prohibited from financial interactions in certain settings, such as a geographical jurisdiction. Each list is managed by a trusted party and updated regularly.</li>

      <li>Client. A client operates one or more accounts and interacts with the privacy pool through deposits, transfers, and withdrawals. The client generates membership proofs on a set of allowlists when transferring or withdrawing funds.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Manager. An allowlist manager is responsible for specifying the members of the allowlist. The manager may update the list over time by adding or removing members.</li>

      <li>Registry. The registry stores the current members of each of the allowlists in order to support generation of membership proofs by the clients.</li>

      <li>Privacy Pool Contract. The privacy pool contract supports deposits and withdrawals of coins from the pool and anonymous transfers of coins within the pool.</li>

    </ul>

    <p class="text-gray-300">The following data structures are introduced to support the disclosure system functionality. In Section 2.4, we described an example of how membership declarations, deposit records, and transfer records are produced in a typical workflow. These objects are managed by history accumulators.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Public Parameters. In the setup of the disclosure system, a trusted party generates public parameters  <span class="math">\\mathrm{pp}_{\\mathrm{disc}}</span>  that are available to all participants in the system.</li>

      <li>Allowlists. An allowlist consists of a unique identifier  <span class="math">\\mathsf{a}</span>  and a set of authorized addresses.</li>

      <li>Membership Proof Lists. A membership proof list  <span class="math">\\pi</span>  is a set of membership proofs for a coin commitment. Each membership proof asserts membership on a specific allowlist in the system.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Membership Declarations. An allowlist membership declaration  $\\mathrm{decl} \\coloneqq H_q(\\mathsf{al}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{pk}_s)<span class="math">  is a public reference to an allowlist identifier  </span>\\mathsf{al}<span class="math">  and a user&#x27;s Ethereum address  </span>\\mathsf{pk}_s$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Deposit Records. A deposit record  <span class="math">\\mathrm{rec}_{\\mathrm{dep}}</span>  is a public record for a deposit into the privacy pool that is derived from the value amount amt, the user's Ethereum address  <span class="math">\\mathrm{pk}_s</span> , the coin commitment cm generated upon deposit, the unique identifier uid of the deposit, and the current digest of the membership declaration history accumulator  <span class="math">\\mathrm{rt}_{\\mathrm{id}}</span> .</li>

      <li>Transfer Records. A transfer record  <span class="math">\\mathrm{rec}_{\\mathrm{tfr}}</span>  is a public record for a pool transfer that is derived from the nullifier  <span class="math">\\mathsf{nf}</span>  for a transaction input and the coin commitment  <span class="math">\\mathsf{cm}</span>  for a transaction output. A transfer record is generated for each input-output pair in a given transaction.</li>

      <li>History Accumulators. The disclosure system uses sparse Merkle history trees to efficiently prove set membership and ensure historical consistency. There are three history accumulators: the membership declaration history accumulator with digest  <span class="math">\\mathrm{rt}_{\\mathrm{id}}</span> , the deposit record history accumulator with digest  <span class="math">\\mathrm{rt}_{\\mathrm{dep}}</span> , and the transfer record history accumulator with digest  <span class="math">\\mathrm{rt}_{\\mathrm{tfr}}</span> . These history accumulators are maintained off-chain using public data derived from the blockchain state.</li>

    </ul>

    <p class="text-gray-300">The following definitions will be helpful for specifying the system's interface:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Asset. An asset  <span class="math">A = (\\mathrm{cm}, I)</span>  consists of a coin commitment cm and auxiliary input  <span class="math">I \\in \\mathcal{I}</span>  containing details of the system's public state, where  <span class="math">\\mathcal{I} = \\{0, 1\\}^*</span>  is the auxiliary input distribution. We let  <span class="math">A = (A_i)_{i=1}^n</span>  denote a list of  <span class="math">n</span>  assets where  <span class="math">n</span>  is the number of transaction inputs.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Transaction Parameter. A transaction parameter <span class="math">\\gamma\\in\\{0,1\\}^{*}</span> consists of details of a deposit, transfer, or withdrawal transaction that are defined by the privacy pool construction and auxiliary information that is needed to prove asset membership. In our construction, this string contains information related to the membership declarations, deposit records, and history accumulators.</li>

    </ul>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">4.3. System Operations</h3>

    <p class="text-gray-300">The disclosure system supports the operations below, including an initial setup and transaction processing methods to update the history accumulators. The update operations reference transactions that are produced by the privacy pool, whose interface is described in Appendix A.2.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>DisclosureSystemSetup(<span class="math">1^{\\lambda}</span>) <span class="math">\\rightarrow</span> pp_{disc}. This algorithm sets up the initial state of the disclosure system, including history accumulators and account lists. Returns the public parameters pp_{disc}.</li>

      <li>ProcessDepositTx(pp_{disc}, tx_{dep}) <span class="math">\\rightarrow</span> (<span class="math">b</span>, rec_{dep}, uid). This algorithm creates and accumulates the deposit record and generates a unique identifier for the deposit transaction. Returns accept/reject bit <span class="math">b</span>, deposit record rec_{dep}, and unique identifier uid for the deposit transaction.</li>

      <li>ProcessTransferTx_{n,m}(pp_{disc}, tx_{tfr}) <span class="math">\\rightarrow</span> (<span class="math">b</span>, rec_{tfr}). This algorithm creates and accumulates transfer records for in-pool transfers. Returns accept/reject bit <span class="math">b</span> and a list of transfer records rec_{tfr}.</li>

      <li>ProcessWithdrawalTx_{n}(pp_{disc}, tx_{wdr}) <span class="math">\\rightarrow</span> (<span class="math">b</span>, rec_{tfr}). This algorithm creates and accumulates transfer records for pool withdrawals. Returns accept/reject bit <span class="math">b</span> and a list of transfer records rec_{tfr}.</li>

    </ul>

    <p class="text-gray-300">The client supports the following operations for interacting with the disclosure system. When a client transfers funds within the privacy pool, the client will separately create a membership proof list for each of the output coin commitments. When a client withdraws from the privacy pool, the client generates a final membership proof list. The privacy pool contract checks for transaction validity, but the contract does not have access to the membership proofs. These proofs can be communicated through a direct channel to the recipient rather than being posted on the blockchain.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>CreateMembershipProof_{n,m}(pp_{disc}, A, <span class="math">\\gamma</span>, <span class="math">A_{\\text{in}}</span>, <span class="math">\\pi_{\\text{in}}</span>, al) <span class="math">\\rightarrow</span> (<span class="math">A_{\\text{out}}</span>, <span class="math">\\pi_{\\text{out}}</span>). Given public parameters pp_{disc}, a list of assets A, a list of transaction parameters <span class="math">\\gamma</span>, a list of input assets <span class="math">A_{\\text{in}}</span>, a list of input membership proof lists <span class="math">\\pi_{\\text{in}}</span>, and a list of allowlists al, output a list of assets <span class="math">A_{\\text{out}}</span> and a list of membership proof lists <span class="math">\\pi_{\\text{out}}</span>. A membership proof list is generated for each transaction output with respect to the allowlists al. This algorithm is run by the sender and parametrized by the number of transaction inputs <span class="math">n</span> and the number of transaction outputs <span class="math">m</span>.</li>

      <li>VerifyMembershipProof(pp_{disc}, A, <span class="math">\\pi</span>, al) <span class="math">\\rightarrow</span> <span class="math">b</span>. Given public parameters pp_{disc}, an asset <span class="math">A</span>, a membership proof <span class="math">\\pi</span>, and an allowlist al, return <span class="math">b\\in\\{0,1\\}</span>. This algorithm is run by the recipient.</li>

    </ul>

    <p class="text-gray-300">The manager supports the following operations for interacting with the disclosure system. These operations result in the addition or removal of an address from the specified allowlists.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>AuthorizeAccount(pp_{disc}, pk_{s}, al) <span class="math">\\rightarrow</span> (<span class="math">b</span>, decl). Given public parameters pp, a user address pk_{s}, and a set of allowlists al, the registry updates the user’s membership on allowlists al if the user is not already a member of each allowlist. Membership declarations are created and added to the history accumulator. Returns accept/reject bit <span class="math">b</span> and membership declaration list decl.</li>

      <li>RevokeMembership(pp_{disc}, pk_{v}, al) <span class="math">\\rightarrow</span> <span class="math">b</span>. Given public parameters pp, a user address pk_{s}, and a set of allowlists al, the registry revokes the user’s membership on allowlists al if the user is currently a member of each allowlist. Membership declarations are removed from the history accumulator. Returns accept/reject bit <span class="math">b</span>.</li>

    </ul>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">4.4. Security Goals</h3>

    <p class="text-gray-300">The security goals of privacy pools consist of correctness, availability, confidentiality, and unlinkability.</p>

    <p class="text-gray-300">Correctness ensures that a pool does not allow clients to spend coins that have already been spent or that they do not own. Availability ensures that clients cannot be prevented from using the privacy pool. Once coin commitments have been added to the contract state, clients cannot be prevented from spending coins that they own and have not previously spent. Confidentiality and unlinkability are the key privacy considerations. A pool ensures confidentiality of transactions if only the sender and recipient learn the value amount associated with each transaction. A pool ensures unlinkability of transfers and withdrawals if an adversary has a negligible advantage in guessing an input coin commitment associated with a given transfer or withdrawal transaction.</p>

    <p class="text-gray-300">Derecho does not alter the functionality of the privacy pool and thus preserves these correctness and privacy properties. However, we also need to define additional correctness and privacy goals for <em>proof-carrying disclosures</em>. Correctness ensures that a client cannot attest membership of a transaction output on a given allowlist unless each of the transaction inputs has an attestation of membership on this allowlist or is a deposit from an address that is registered on this allowlist. Privacy ensures that the allowlist membership proof does not reveal anything besides the allowlist membership of the transaction output (e.g., it does not reveal the private transaction details such as the value amount and the sender/recipient).</p>

    <p class="text-gray-300">In our construction, correctness will follow from the definition of the compliance predicate and privacy from the zero-knowledge property of the underlying PCD scheme. These properties are formalized below and are adapted from the general definition of PCD that is presented in Section 3.1.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">4.5. Private Asset Membership</h3>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">Definitions</h4>

    <p class="text-gray-300">We require the following definitions to discuss the security of our construction.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Historical State. The state of the system is represented with history accumulators <span class="math">S_{T}</span> for transactions in the privacy</li>

    </ul>

    <p class="text-gray-300">pool and a history accumulator <span class="math">S_{M}</span> for membership declarations. These history accumulators are managed offline and computed from the blockchain state.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Transaction Validation. Let <span class="math">D_{T}</span> be a decider for transaction correctness and acceptance. Let <span class="math">D_{T}(\\mathbf{S_{T}},A,\\gamma,(A_{i})_{i=1}^{n})=1</span> if there is a corresponding well-formed <span class="math">\\mathrm{tx}_{\\mathrm{th}}</span> or <span class="math">\\mathrm{tx}_{\\mathrm{wd}}</span>, object that has been accepted by the privacy pool operation ProcessTransferTx or ProcessWithdrawalTx, respectively, and has <span class="math">(A_{i})_{i=1}^{n}</span> corresponding to its inputs and has <span class="math">A</span> corresponding to one of its outputs. Let <span class="math">D_{T}(\\mathbf{S_{T}},A,\\gamma,\\bot)=1</span> if there is a corresponding well-formed <span class="math">\\mathrm{tx}_{\\mathrm{dep}}</span> object that has been accepted by the privacy pool deposit operation ProcessDepositTx and has <span class="math">A</span> as its output.</li>

      <li>Membership Validation. We let <span class="math">D_{M}(S_{M},A,\\gamma,\\mathrm{al})</span> be a decider that checks if the sender is a member of allowlist <span class="math">\\mathrm{al}</span> at the time of deposit.</li>

      <li>Membership-Preserving Transaction. A membership-preserving transaction is one that satisfies the following rule. For a non-empty set of assets <span class="math">\\bm{A}</span> and asset <span class="math">B</span> such that <span class="math">\\bm{A}</span> are inputs to the transaction and <span class="math">B</span> is an output of the transaction, the asset <span class="math">B</span> has membership on allowlist <span class="math">\\mathrm{al}</span> if and only if for each <span class="math">A\\in\\bm{A}</span>, <span class="math">A</span> has membership on allowlist <span class="math">\\mathrm{al}</span>. We also consider a deposit transaction to be membership-preserving.</li>

      <li>Transaction Graph. A transaction graph <span class="math">G</span> is a directed acyclic graph that consists of a set of vertices <span class="math">V(G)</span> and a set of edges <span class="math">E(G)</span> where each vertex <span class="math">v\\in V(G)</span> corresponds to a deposit, transfer, or withdrawal transaction and each edge <span class="math">e\\in E(G)</span> corresponds to a transaction output.</li>

      <li>Provenance Transcript. A provenance transcript PT is a transaction graph where each vertex <span class="math">u\\in V(\\mathrm{PT})</span> is labeled by a transaction parameter <span class="math">\\gamma^{(u)}</span> and each edge <span class="math">e\\in E(\\mathrm{PT})</span> is labeled by an asset <span class="math">A^{(e)}\\neq\\bot</span>. The output of the provenance transcript, denoted <span class="math">o(\\mathrm{PT})</span>, is <span class="math">A^{(e^{\\prime})}</span> where <span class="math">e^{\\prime}=(u,v)</span> is the first edge such that <span class="math">v</span> is a sink in the lexicographic ordering of the edges. We say that a provenance transcript is <em>compliant</em> if all of the transactions corresponding to the labels are correctly-formed, accepted by the privacy pool, and membership-preserving. We let <span class="math">D_{C}(\\mathbf{S_{T}},S_{M},\\mathrm{PT})</span> be a decider for whether a provenance transcript is compliant according to the labels and the historical state.</li>

    </ul>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">Algorithms</h4>

    <p class="text-gray-300">Given a privacy pool POOL, a disclosure system DISC, and a security parameter <span class="math">\\lambda</span>, a <em>Private Asset Membership</em> scheme is a tuple <span class="math">\\mathrm{PAM}=(\\mathbb{G},\\mathbb{P},\\mathbb{V})</span>, where <span class="math">\\mathbb{G}</span> is called the generator, <span class="math">\\mathbb{P}</span> is called the prover, and <span class="math">\\mathbb{V}</span> is called the verifier. These algorithms work as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The generator <span class="math">\\mathbb{G}(1^{\\lambda})\\to\\mathrm{pp}</span>, given a security parameter <span class="math">\\lambda</span>, generates the public parameters <span class="math">\\mathrm{pp}</span>. The public parameters contain global information such as the history accumulators <span class="math">\\mathbf{S_{T}}</span> and <span class="math">S_{M}</span>.</li>

      <li>The prover <span class="math">\\mathbb{P}(\\mathrm{pp},A,\\gamma,\\bm{A_{in}},\\bm{\\pi_{in}},\\mathrm{al})\\to\\pi</span>, given asset <span class="math">A</span>, a transaction parameter <span class="math">\\gamma</span>, input assets <span class="math">\\bm{A_{in}}=(A_{i})_{i\\in[n]}</span>, input proofs <span class="math">\\bm{\\pi_{in}}=(\\pi_{i})_{i\\in[n]}</span>, and allowlist <span class="math">\\mathrm{al}</span>, returns membership proof <span class="math">\\pi</span>.</li>

      <li>The verifier <span class="math">\\mathbb{V}(\\mathrm{pp},A,\\pi,\\mathrm{al})\\to b</span>, given asset <span class="math">A</span>, membership proof <span class="math">\\pi</span>, and allowlist <span class="math">\\mathrm{al}</span>, returns a decision <span class="math">b\\in\\{0,1\\}</span> for whether asset <span class="math">A</span> has membership on allowlist <span class="math">\\mathrm{al}</span>.</li>

    </ul>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">Properties</h4>

    <p class="text-gray-300">The completeness, knowledge soundness, and zero knowledge properties must hold for <span class="math">\\mathbb{G}</span>, <span class="math">\\mathbb{P}</span>, and <span class="math">\\mathbb{V}</span>. These properties are defined below.</p>

    <p class="text-gray-300">Completeness. It must always be possible to prove the membership of an asset with membership on allowlist <span class="math">\\mathrm{al}</span>. For every adversary <span class="math">\\mathcal{A}</span>, equation (2) holds under the conditions: <span class="math">\\mathrm{pp}\\leftarrow\\mathbb{G}(1^{\\lambda});(A,\\gamma,[A_{i},\\pi_{i}]_{i=1}^{n},\\mathrm{al})\\leftarrow\\mathcal{A}(\\mathrm{pp});\\pi\\leftarrow\\mathbb{P}(\\mathrm{pp},A,\\gamma,[A_{i},\\pi_{i}]_{i=1}^{n},\\mathrm{al})</span>.</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{c}(D_{T}(\\mathbf{S_{T}},A,\\gamma,\\bot)=1\\wedge D_{M}(S_{M},A,\\gamma,\\mathrm{al})=1)\\\\ \\vee(D_{T}(\\mathbf{S_{T}},A,\\gamma,(A_{i})_{i=1}^{n})=1\\wedge\\forall i,\\mathbb{V}(\\mathrm{pp},A_{i},\\pi_{i},\\mathrm{al}))\\\\ \\Downarrow\\\\ \\mathbb{V}(\\mathrm{pp},A,\\pi,\\mathrm{al})=1\\end{array}\\right]=1 \\] (2)</p>

    <p class="text-gray-300">Knowledge soundness. If the verifier accepts a proof <span class="math">\\pi</span> for an asset generated by some adversary, then the asset has membership on allowlist <span class="math">\\mathrm{al}</span>, and moreover, the adversary “knows” a compliant provenance transcript <span class="math">\\mathrm{PT}</span> with output <span class="math">A</span>.</p>

    <p class="text-gray-300">Formally, a PAM scheme <span class="math">\\mathrm{PAM}</span> has the knowledge soundness property if, for every expected polynomial-time adversary <span class="math">\\mathcal{A}</span>, there exists an expected polynomial-time knowledge extractor <span class="math">\\mathcal{E}</span> that can output a provenance transcript <span class="math">\\mathrm{PT}</span> such that, for every sufficiently large security parameter <span class="math">\\lambda</span>, the following value is negligibly small:</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{c}\\mathbb{V}(\\mathrm{pp},A,\\pi,\\mathrm{al})=1\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\wedge(o(\\mathrm{PT})\\neq A\\vee D_{C}(\\mathbf{S_{T}},S_{M},\\mathrm{PT})=0)\\end{array}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{c}\\mathrm{pp}\\leftarrow\\mathbb{G}(1^{\\lambda})\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(A,\\pi,\\mathrm{al})\\leftarrow\\mathcal{A}(\\mathrm{pp})\\\\ \\mathrm{PT}\\leftarrow\\mathcal{E}(\\mathrm{pp})\\end{array} \\]</p>

    <p class="text-gray-300">Zero knowledge. The PAM proofs reveal nothing besides the allowlist membership of the assets. Formally, the proofs are (statistical) zero knowledge if there exists a PPT simulator <span class="math">\\mathcal{S}</span> such that for every honest adversary <span class="math">\\mathcal{A}</span> the distributions below are statistically indistinguishable.</p>

    <p class="text-gray-300">\\[ \\left\\{\\begin{array}[]{c}\\mathrm{pp}\\leftarrow\\mathbb{G}(1^{\\lambda})\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\mathrm{pp},A,\\pi,\\mathrm{al})\\end{array}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{c}(A,\\gamma,[A_{i},\\pi_{i}]_{i=1}^{n},\\mathrm{al})\\leftarrow\\mathcal{A}(\\mathrm{pp})\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\pi\\leftarrow\\mathbb{P}(\\mathrm{pp},A,\\gamma,[A_{i},\\pi_{i}]_{i=1}^{n},\\mathrm{al})\\end{array}\\Bigg{\\}} \\]</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\left\\{\\begin{array}[]{c}\\mathrm{pp},A,\\pi,\\mathrm{al})\\end{array}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{c}(\\mathrm{pp},\\tau)\\leftarrow\\mathcal{S}(1^{\\lambda})\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(A,\\gamma,[A_{i},\\pi_{i}]_{i=1}^{m},\\mathrm{al})\\leftarrow\\mathcal{A}(\\mathrm{pp})\\\\ \\pi\\leftarrow\\mathcal{S}(\\tau,A,\\mathrm{al})\\end{array}\\Bigg{\\}} \\]</p>

    <h2 id="sec-21" class="text-2xl font-bold">5. Construction</h2>

    <p class="text-gray-300">We now present the details of our construction. After outlining the building blocks of the system in Section 5.1, we precisely define the membership proof statement in Section 5.2. We include a detailed specification of the disclosure system algorithms in Appendix E and the formal construction of the Derecho Private Asset Membership scheme in Appendix F. We establish the security properties of our disclosure system in Section 5.4. Since our system does not involve any changes to the functionality of the privacy pool, we defer a detailed discussion of the privacy pool algorithms to Appendix D.</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">5.1. Building Block Algorithms</h3>

    <p class="text-gray-300">Below we describe how to compute each of the key objects of the disclosure system. These algorithms are used in updating the history accumulators and producing the membership proofs.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Membership Declaration Creation. For an allowlist <span class="math">\\mathsf{al}</span> and address <span class="math">\\mathsf{pk}_{s}</span>, the membership declaration is computed by $\\text{decl}\\coloneqq H_{q}(\\mathsf{al}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{pk}_{s})$.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Transfer Record Creation. A transfer record is computed using a hash function that is applied to an input nullifier <span class="math">\\mathsf{nf}</span> and an output coin commitment <span class="math">\\mathsf{cm}</span>. The transfer record is computed by $\\text{rec}_{\\text{fr}}\\coloneqq H_{q}(\\mathsf{nf}\\</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathsf{cm})$ without reference to any private values associated with the transaction.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">5.2. Recursive Membership Proofs</h3>

    <p class="text-gray-300">This section defines the PCD system for attestations of allowlist membership for a transaction output. Let <span class="math">n</span> be the number of transaction inputs, <span class="math">m</span> be the number of transaction outputs, and <span class="math">l</span> be the number of allowlists. For simplicity, we fix the set of allowlists <span class="math">(\\mathsf{al}_{j})_{j\\in[l]}</span> to yield a set of compliance predicates <span class="math">(\\varphi_{j})_{j\\in[l]}</span>. We refer to Section 3.1 for a complete description of proof-carrying data.</p>

    <p class="text-gray-300">The compliance predicate <span class="math">\\varphi_{j}</span> is a function of the message <span class="math">z</span>, the local data <span class="math">z_{\\text{loc}}</span>, and the incoming messages <span class="math">(z_{i})_{i\\in[n]}</span>. Each compliance predicate <span class="math">\\varphi_{j}</span> is defined with respect to a specific allowlist <span class="math">\\mathsf{al}_{j}</span>. A message <span class="math">z</span> consists of public data associated with the transaction output: the input nullifiers, the output coin commitment, and additional data related to the transfer records and history accumulators. The local data <span class="math">z_{\\text{loc}}</span> consists of private data associated with the transaction output: input and output coin commitment openings, auxiliary inputs for the nullifier computation, membership declarations, deposit information, membership witnesses for the accumulated elements (i.e., deposit records, transfer records, and membership declarations), and history proofs for these elements.</p>

    <p class="text-gray-300">Each transfer transaction corresponds to a vertex in the proof-carrying data graph <span class="math">\\mathsf{G}</span>. This vertex typically has <span class="math">n</span> incoming edges and <span class="math">m</span> outgoing edges. However, this vertex has no incoming edges when all transaction inputs consist of fresh deposits to the privacy pool. For a node with incoming edges, each message <span class="math">z_{i}</span> corresponds to a message that was generated as the output of a previous transaction. If the node has no incoming edges, <span class="math">z_{i}=\\bot</span>. A vertex <span class="math">u</span> is <span class="math">\\varphi_{j}</span>-compliant if for all outgoing edges with message <span class="math">z</span> either: (1) if <span class="math">u</span> has no incoming edges, <span class="math">\\varphi_{j}(z,z_{\\text{loc}},\\bot,\\ldots,\\bot)</span> evaluates to true or (2) if <span class="math">u</span> has <span class="math">n</span> incoming edges, <span class="math">\\varphi_{j}(z,z_{\\text{loc}},z_{1},\\ldots,z_{n})</span> evaluates to true. Note that <span class="math">z_{i}=\\bot</span> or <span class="math">\\mathbb{V}(\\mathsf{ivk}_{j},z_{i},\\pi_{i})=1</span> for each incoming edge <span class="math">z_{i}</span>. The prover generates an output proof <span class="math">\\pi=\\mathbb{P}(\\mathsf{ipk}_{j},z,z_{\\text{loc}},[z_{i},\\pi_{i}]_{i=1}^{m})</span>.</p>

    <p class="text-gray-300">If a vertex has no incoming edges, this indicates that each transaction input is a coin that was generated upon deposit to the pool. This is the base case of the compliance predicate. In this case, the predicate performs a series of checks for each transaction input. The predicate checks that the deposit record is correctly computed from the public data (i.e, the value amount, the user’s address, the deposit coin commitment, the unique identifier of the deposit transaction, and the current digest of the membership declaration history accumulator) and verifies that the deposit record is accumulated. The predicate checks that the membership declaration is correctly computed from the allowlist identifier and the user’s address and verifies that the membership declaration is accumulated. In this case, the prover is computing an attestation from public information in such a way that the initial attestation can be reused in subsequent attestations.</p>

    <p class="text-gray-300">If a vertex has <span class="math">n</span> incoming edges, this indicates that each transaction input is a coin that was the output of a previous transfer transaction. In this case, the membership proof for this transaction will attest to the validity of previous membership proofs with respect to previous messages. However, a problem arises where the history accumulator digests of previous messages may be stale with respect to the current state of the history accumulator for the current message. We thus additionally need to prove that the prior history accumulator digests represent correct historical states with respect to the current history accumulator digest. Otherwise, there is no guarantee that the prior history accumulator digests correspond to valid prior contract states. The predicate will ensure consistency by verifying that the prior history accumulator digest of message <span class="math">z_{i}</span> is a valid historical digest according to the current history accumulator digest of message <span class="math">z</span>. The predicate will verify history proofs for three history accumulators: the membership declaration history accumulator, the deposit record history accumulator, and the transfer record history accumulator. The history accumulators store public information derived from the blockchain state that is useful for ensuring that the membership proofs are consistent with the current state of the blockchain.</p>

    <p class="text-gray-300">In both cases, the predicate computes nullifiers for the transaction inputs based on the input coin commitment openings and auxiliary data. The predicate computes the output coin commitment from its opening. The details of this logic are determined by the privacy pool. The predicate ensures the consistency of the output coin commitments of the previous messages with the input coin commitment openings of the current local data. Finally, the predicate computes the transfer record for each pair of input nullifier and output coin commitment and verifies that the transfer record is accumulated.</p>

    <p class="text-gray-300">While these computations reference the (private) local data, the resulting proofs can be verified with respect to the corresponding (public) message. Each transaction output corresponds to an outgoing edge in the PCD graph, so each transaction output has a corresponding membership proof.</p>

    <p class="text-gray-300">From the recipient’s perspective, it is important to check the validity of the public information in the message <span class="math">z</span> with respect to the privacy pool contract state, in addition to verifying the proof <span class="math">\\pi</span></p>

    <p class="text-gray-300">with respect to the message <span class="math">z</span>. Otherwise, it is not guaranteed that the membership proof is meaningful. The recipient should be able to perform this check at any time with access to the current state.</p>

    <p class="text-gray-300">Our design offers flexibility in combining coins with membership proofs on distinct sets of allowlists that have a non-empty intersection. For instance, a coin with membership proofs on allowlists <span class="math">\\mathrm{al}_{1}</span> and <span class="math">\\mathrm{al}_{2}</span> may be spent along with a coin with a membership proof on allowlist <span class="math">\\mathrm{al}_{1}</span> to produce a new coin with a membership proof on allowlist <span class="math">\\mathrm{al}_{1}</span> only.</p>

    <p class="text-gray-300">Recall that membership proof generation does not require changes to the functionality of the privacy pool. Membership proofs are generated alongside the privacy pool transactions and provided directly to recipients. There is no increase in the gas costs of these transactions, since membership proofs are not posted on the blockchain and the history accumulators are managed offline.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Message <span class="math">z\\coloneqq(\\mathbf{nf},\\mathrm{cm},\\mathrm{rt}_{\\mathrm{id}},\\mathrm{rt}_{\\mathrm{dep}},\\mathrm{rt}_{\\mathrm{tfr}},\\mathbf{rec}_{\\mathbf{tfr}})</span>:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{nf}\\coloneqq(\\mathrm{nf}_{i})_{i\\in[n]}</span>: Nullifiers for transaction inputs.</li>

      <li>cm: Output coin commitment.</li>

      <li><span class="math">\\mathrm{rt}_{\\mathrm{id}}</span>: Digest of membership declaration history accumulator.</li>

      <li><span class="math">\\mathrm{rt}_{\\mathrm{dep}}</span>: Digest of deposit record history accumulator.</li>

      <li><span class="math">\\mathrm{rt}_{\\mathrm{tfr}}</span>: Digest of transfer record history accumulator.</li>

      <li><span class="math">\\mathbf{rec}_{\\mathbf{tfr}}\\coloneqq(\\mathrm{rec}_{i}^{\\mathrm{tfr}})_{i\\in[n]}</span>: Transfer records derived from public information.</li>

      <li>Local data <span class="math">z_{\\mathrm{loc}}\\coloneqq(\\mathbf{open}_{\\mathbf{in}},\\mathrm{open}_{\\mathrm{out}},\\mathbf{aux}_{\\mathbf{in}},\\mathbf{decl},\\mathbf{rec}_{\\mathbf{dep}},\\mathbf{pk},\\mathbf{uid},\\mathbf{w}_{\\mathbf{id}},\\mathbf{c}_{\\mathbf{id}},\\mathbf{w}_{\\mathbf{dep}},\\mathbf{c}_{\\mathbf{dep}},\\mathbf{w}_{\\mathbf{tfr}},\\mathbf{c}_{\\mathbf{tfr}})</span>:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{open}_{\\mathbf{in}}\\coloneqq(\\mathrm{open}_{i}^{\\mathrm{in}})_{i\\in[n]}</span>: Input coin commitment openings.</li>

      <li><span class="math">\\mathrm{open}_{\\mathrm{out}}</span>: Output coin commitment opening.</li>

      <li><span class="math">\\mathbf{aux}_{\\mathbf{in}}\\coloneqq(\\mathrm{aux}_{\\mathbf{i}}^{\\mathrm{in}})_{i\\in[n]}</span>: Auxiliary inputs for nullifier computation.</li>

      <li><span class="math">\\mathbf{decl}\\coloneqq(\\mathrm{decl}_{i})_{i\\in[n]}</span>: Membership declarations for the allowlist <span class="math">\\mathrm{al}_{j}</span>.</li>

      <li><span class="math">\\mathbf{rec}_{\\mathbf{dep}}\\coloneqq(\\mathrm{rec}_{i}^{\\mathrm{dep}})_{i\\in[n]}</span>: Deposit records for the deposit transactions.</li>

      <li><span class="math">\\mathbf{pk}\\coloneqq(\\mathrm{pk}_{i})_{i\\in[n]}</span>: Source addresses for the deposit transactions.</li>

      <li><span class="math">\\mathbf{uid}\\coloneqq(\\mathrm{uid}_{i})_{i\\in[n]}</span>: Unique identifiers for the deposit transactions.</li>

      <li><span class="math">\\mathbf{w}_{\\mathbf{id}}\\coloneqq(\\mathbf{w}_{i}^{\\mathrm{id}})_{i\\in[n]}</span>: Membership witnesses for membership declarations <span class="math">\\mathbf{decl}</span> and digest <span class="math">\\mathrm{rt}_{\\mathrm{id}}</span>.</li>

      <li><span class="math">\\mathbf{c}_{\\mathbf{id}}\\coloneqq(\\mathbf{c}_{i}^{\\mathrm{id}})_{i\\in[n]}</span>: History proofs for digest <span class="math">\\mathrm{rt}_{\\mathrm{id}}</span> with respect to previous digests <span class="math">\\hat{\\mathbf{\\alpha}}_{i}^{\\mathrm{id}}</span>.</li>

      <li><span class="math">\\mathbf{w}_{\\mathbf{dep}}\\coloneqq(\\mathbf{w}_{i}^{\\mathrm{dep}})_{i\\in[n]}</span>: Membership witnesses for deposit records <span class="math">\\mathbf{rec}_{\\mathbf{dep}}</span> and digest <span class="math">\\mathrm{rt}_{\\mathrm{dep}}</span>.</li>

      <li><span class="math">\\mathbf{c}_{\\mathbf{dep}}\\coloneqq(\\mathbf{c}_{i}^{\\mathrm{dep}})_{i\\in[n]}</span>: History proofs for digest <span class="math">\\mathrm{rt}_{\\mathrm{dep}}</span> with respect to previous digests <span class="math">\\hat{\\mathbf{\\alpha}}_{i}^{\\mathrm{dep}}</span>.</li>

      <li><span class="math">\\mathbf{w}_{\\mathbf{tfr}}\\coloneqq(\\mathbf{w}_{i}^{\\mathrm{tfr}})_{i\\in[n]}</span>: Membership witnesses for transfer records <span class="math">\\mathbf{rec}_{\\mathbf{tfr}}</span> and digest <span class="math">\\mathrm{rt}_{\\mathrm{tfr}}</span>.</li>

      <li><span class="math">\\mathbf{c}_{\\mathbf{tfr}}\\coloneqq(\\mathbf{c}_{i}^{\\mathrm{tfr}})_{i\\in[n]}</span>: History proofs for digest <span class="math">\\mathrm{rt}_{\\mathrm{tfr}}</span> with respect to previous digests <span class="math">\\hat{\\mathbf{\\alpha}}_{i}^{\\mathrm{tfr}}</span>.</li>

      <li>Previous messages <span class="math">(z_{i})_{i\\in[n]}</span>:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">z_{i}\\coloneqq(\\mathbf{\\hat{nf}}_{i},\\mathrm{cm}_{i},\\hat{\\mathbf{\\alpha}}_{i}^{\\mathrm{id}},\\hat{\\mathbf{\\alpha}}_{i}^{\\mathrm{dep}},\\hat{\\mathbf{\\alpha}}_{i}^{\\mathrm{tfr}},\\mathbf{r}\\hat{\\mathbf{ec}}_{\\mathbf{tfr}})</span></li>

      <li><span class="math">z_{i}</span> is a message for the <span class="math">i</span>-th transaction input.</li>

      <li>Each message <span class="math">z_{i}</span> has the same format as <span class="math">z</span>.</li>

      <li>Previous proofs <span class="math">(\\pi_{i})_{i\\in[n]}</span>:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\pi_{i}</span> is a proof for the <span class="math">i</span>-th transaction input.</li>

      <li>Each proof <span class="math">\\pi_{i}</span> can be verified with respect to <span class="math">z_{i}</span>.</li>

      <li>Compliance predicate <span class="math">\\varphi_{j}(z,z_{\\mathrm{loc}},z_{1},\\ldots,z_{n})</span> for allowlist <span class="math">\\mathrm{al}_{j}</span>:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">i\\in[n]</span>:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For base case (<span class="math">z_{i}=\\bot</span>), check the following:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $\\mathrm{decl}_{i}=H_{q}(\\mathrm{al}_{j}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{pk}_{i})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{HA.VfyMem}(\\mathrm{rt}_{\\mathrm{id}},\\mathbf{w}_{i}^{\\mathrm{id}},\\mathrm{decl}_{i})</span></li>

      <li><span class="math">\\mathrm{rec}_{i}^{\\mathrm{dep}}=\\mathrm{DepositRecord}(\\mathrm{open}_{i}^{\\mathrm{in}},\\mathrm{pk}_{i},\\mathrm{uid}_{i},\\mathrm{rt}_{\\mathrm{id}})</span></li>

      <li><span class="math">\\mathrm{HA.VfyMem}(\\mathrm{rt}_{\\mathrm{dep}},\\mathbf{w}_{i}^{\\mathrm{dep}},\\mathbf{rec}_{i}^{\\mathrm{dep}})</span></li>

      <li>Otherwise, check the consistency of messages:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{cm}_{i}=\\mathrm{Com}(\\mathrm{open}_{i}^{\\mathrm{in}})</span></li>

      <li><span class="math">\\mathrm{HA.VfyHist}(\\hat{\\mathbf{\\alpha}}_{i}^{\\mathrm{id}},\\mathrm{rt}_{\\mathrm{id}},\\mathbf{c}_{i}^{\\mathrm{id}})</span></li>

      <li><span class="math">\\mathrm{HA.VfyHist}(\\hat{\\mathbf{\\alpha}}_{i}^{\\mathrm{dep}},\\mathrm{rt}_{\\mathrm{dep}},\\mathbf{c}_{i}^{\\mathrm{dep}})</span></li>

      <li><span class="math">\\mathrm{HA.VfyHist}(\\hat{\\mathbf{\\alpha}}_{i}^{\\mathrm{tfr}},\\mathrm{rt}_{\\mathrm{tfr}},\\mathbf{c}_{i}^{\\mathrm{tfr}})</span></li>

      <li>For <span class="math">i\\in[n]</span>:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{nf}_{i}=\\mathrm{Nullify}(\\mathrm{open}_{i}^{\\mathrm{in}},\\mathrm{aux}_{i}^{\\mathrm{in}})</span></li>

      <li><span class="math">\\mathrm{cm}=\\mathrm{Com}(\\mathrm{open}_{\\mathrm{out}})</span></li>

      <li>For <span class="math">i\\in[n]</span>:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $\\mathrm{rec}_{i}^{\\mathrm{tfr}}=H_{q}(\\mathrm{nf}_{i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{cm})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{HA.VfyMem}(\\mathrm{rt}_{\\mathrm{tfr}},\\mathbf{w}_{i}^{\\mathrm{tfr}},\\mathbf{rec}_{i}^{\\mathrm{tfr}})</span></li>

    </ul>

    <h3 id="sec-24" class="text-xl font-semibold mt-8">5.3. Disclosure System Algorithms</h3>

    <p class="text-gray-300">We present a detailed specification of the disclosure system algorithms in Figure 5 of Appendix E. An example implementation of the privacy pool interface is contained in Appendix D.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">5.4. Disclosure System Security</h3>

    <p class="text-gray-300">We present our formal construction of the Derecho Private Asset Membership (PAM) scheme in Appendix F . Below we present a security proof for the properties of proof-carrying disclosures that were discussed in Section 4.4.</p>

    <p class="text-gray-300">Correctness of proof-carrying disclosures follows from the completeness and knowledge soundness of the PAM scheme. For privacy, we must show that the asset <span class="math">A</span> and membership proof <span class="math">\\pi</span> do not reveal anything about the private transaction details. First, note that the corresponding message <span class="math">z</span> for the asset <span class="math">A</span> consists of public information that is already known by the recipient of the message. The nullifiers <span class="math">\\mathbf{nf}</span> and output coin commitment <span class="math">\\mathrm{cm}</span> are contained in the public state and linked by the corresponding transaction. The history accumulator digests (<span class="math">\\mathrm{rt}_{\\mathrm{id}},\\mathrm{rt}_{\\mathrm{dep}},\\mathrm{rt}_{\\mathrm{tfr}}</span>) are part of the public state. The transfer records <span class="math">\\mathbf{rec}_{\\mathbf{tfr}}</span> are determined by the nullifiers and output coin commitment. Hence, the asset <span class="math">A</span> does not reveal private transaction details. The membership proof <span class="math">\\pi</span> does not reveal anything about these details according to the zero knowledge property of the PAM scheme.</p>

    <p class="text-gray-300">We now sketch the proof that the Derecho PAM scheme satisfies the desired properties. Recall that a PAM scheme <span class="math">\\mathsf{PAM}=(\\mathbb{G},\\mathbb{P},\\mathbb{V})</span> consists of generator, prover, and verifier algorithms with properties of completeness, knowledge soundness, and zero knowledge as defined in Section 4.5.</p>

    <h4 id="sec-26" class="text-lg font-semibold mt-6">Completeness</h4>

    <p class="text-gray-300">We prove correctness of the compliance predicate in two parts. These parts correspond to the base case (deposit) and</p>

    <p class="text-gray-300">the regular case (transfer/withdrawal) of the compliance predicate. To simplify the analysis, we let <span class="math">n=1</span>, where <span class="math">n</span> is the number of transaction inputs. It is easy to see that the case of <span class="math">n&gt;1</span> follows directly from the proofs in these two parts.</p>

    <p class="text-gray-300">First, let <span class="math">z</span> be a message with local data <span class="math">z_{\\text{loc}}</span> that corresponds to an accepted transaction that spends a deposit originating from an address <span class="math">\\text{pk}^{\\text{in}}_{1}</span> on allowlist <span class="math">\\mathsf{al}</span>. The correctness of the computation of membership declaration <span class="math">\\text{decl}_{1}</span> and deposit record <span class="math">\\text{rec}^{\\text{dep}}_{1}</span> follows from the logic of the ProcessDepositTx and AuthorizeAccount algorithms. Furthermore, the correctness of set membership verification follows from the correctness of the history accumulator scheme. The correctness of nullifier computation and output coin commitment computation follows from the acceptance of the transaction by the privacy pool. In particular, these computations are verified in the CreateTransferTx and ProcessTransferTx algorithms of the privacy pool, and the compliance predicate repeats this logic. The correctness of the computation of transfer record <span class="math">\\text{rec}_{\\text{trf}}</span> follows from the logic of the ProcessTransferTx algorithm.</p>

    <p class="text-gray-300">Second, let <span class="math">z</span> be a message with local data <span class="math">z_{\\text{loc}}</span> that corresponds to an accepted transaction that spends the output of a previous transfer transaction with membership on allowlist <span class="math">\\mathsf{al}</span>. The correctness of historical state verification follows from the correctness of the history accumulator scheme. The correctness of the computation of the previous output coin commitment follows from the completeness of the PCD scheme. The correctness of the computation of the nullifier, the current output coin commitment, and the transfer record follows as above. Likewise, the correctness of set membership verification follows from the correctness of the history accumulator scheme.</p>

    <p class="text-gray-300">The successful verification of the previous membership proof follows from the completeness of the PCD scheme. Hence the final proof will be convincing with probability 1.</p>

    <h4 id="sec-27" class="text-lg font-semibold mt-6">Knowledge Soundness</h4>

    <p class="text-gray-300">The compliant provenance transcript can be viewed as a transcript in the PCD scheme, where the assets are the messages on the edges, and the transaction parameters are the local data at the nodes. The knowledge soundness of the PAM scheme then follows from the knowledge soundness of the PCD scheme.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{A}</span> be an adversary that is attacking the Derecho PAM scheme. To show knowledge soundness, we must find a polynomial-time extractor <span class="math">\\mathcal{E}</span> such that whenever a convincing proof <span class="math">\\pi</span> is found that <span class="math">A</span> is an asset with membership on the allowlist <span class="math">\\mathsf{al}</span>, <span class="math">\\mathcal{E}</span> produces the evidence <span class="math">\\gamma</span>.</p>

    <p class="text-gray-300">Using <span class="math">\\mathcal{A}</span>, we construct <span class="math">\\mathcal{A}_{\\text{PCD}}</span>, an adversary attacking the PCD scheme. Given the public parameters of the PAM scheme (including system state) as auxiliary input, the adversary <span class="math">\\mathcal{A}_{\\text{PCD}}</span> will run the adversary <span class="math">\\mathcal{A}</span> to produce a PCD message <span class="math">\\mathsf{o}</span> and a proof <span class="math">\\pi</span> corresponding to the output of <span class="math">\\mathcal{A}</span>. From an equivalent formulation of the PCD knowledge soundness property, there is an extractor <span class="math">\\widehat{\\mathbb{P}}</span> such that (for sufficiently large <span class="math">\\lambda</span>) and every (polynomial-length) auxiliary input <span class="math">\\mathsf{ai}</span>, the following probability is negligibly small:</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{c c}\\varphi\\in\\mathsf{F}&amp;\\text{pp}_{\\text{pcd}}\\leftarrow\\mathbb{G}(1^{\\lambda})\\\\ \\text{ai}\\leftarrow\\mathcal{D}(\\text{pp}_{\\text{pcd}})\\\\ \\wedge\\bigvee(\\text{ivk},\\mathsf{o},\\pi)=1&amp;(\\varphi,\\mathsf{o},\\pi,\\mathsf{ao})\\leftarrow\\widehat{\\mathbb{P}}(\\text{pp}_{\\text{pcd}},\\mathsf{ai})\\\\ \\text{(ipk},\\text{ivk})\\leftarrow\\mathbb{I}(\\text{pp}_{\\text{pcd}},\\varphi)\\end{array}\\right] \\]</p>

    <p class="text-gray-300">The extractor <span class="math">\\mathcal{E}</span> works as follows. When <span class="math">\\mathcal{A}</span> outputs an asset <span class="math">A</span> and a proof <span class="math">\\pi</span>, invoke the extractor <span class="math">\\widehat{\\mathbb{P}}</span> and read off the compliant provenance transcript from the output transcript’s labels. Since <span class="math">\\mathcal{A}</span> outputs a PCD proof, it follows that <span class="math">\\mathbb{V}(A,\\pi,\\mathsf{al})=1</span> if the difference in the probability that <span class="math">\\mathsf{T}</span> is <span class="math">\\varphi</span>-compliant and the probability that <span class="math">\\mathsf{PT}</span> is compliant is negligible. Recall that a transcript <span class="math">\\mathsf{T}</span> is <span class="math">\\varphi</span>-compliant if all of its vertices are <span class="math">\\varphi</span>-compliant. A vertex is <span class="math">\\varphi</span>-compliant for a predicate <span class="math">\\varphi\\in\\mathsf{F}</span> if for all outgoing edges <span class="math">e=(u,v)\\in E(\\mathsf{T})</span> in the transcript, either: (1) if <span class="math">u</span> has no incoming edges, <span class="math">\\varphi(z^{(e)},z^{(u)}_{\\text{loc}},\\bot,\\ldots,\\bot)=1</span> or (2) if <span class="math">u</span> has <span class="math">m</span> incoming edges <span class="math">e_{1},...,e_{m},\\varphi(z^{(e)},z^{(u)}_{\\text{loc}},z^{(e_{1})},\\ldots,z^{(e_{m})})=1</span>. Similarly, a provenance transcript <span class="math">\\mathsf{PT}</span> is compliant if all of its vertices are compliant, i.e., all of the transactions that correspond to to the labels of the provenance transcript are correctly-formed, accepted by the pool, and membership-preserving. If <span class="math">\\mathsf{T}</span> is <span class="math">\\varphi</span>-compliant but <span class="math">\\mathsf{PT}</span> is not compliant, then the compliance predicate <span class="math">\\varphi</span> has not captured the desired security properties, i.e., an asset has an invalid attestation of allowlist membership.</p>

    <p class="text-gray-300">To show these probabilities are negligibly close, we need to consider two cases for the transaction input logic in the compliance predicate. In the base case (<span class="math">z_{i}=\\bot</span>), the difference in these probabilities is negligible according to the soundness of the history accumulator scheme, the collision-resistance of the hash function, and the binding property of the commitment scheme. Specifically, it is hard to find an invalid membership witness <span class="math">w</span> that causes the VfyMem algorithm of the history accumulator to accept, and it is hard to find an invalid history proof <span class="math">e</span> that causes the VfyHist algorithm of the history accumulator to accept. Likewise, it is hard to find a collision for the hash function or open the commitment to an invalid value. In the regular case (<span class="math">z_{i}\\neq\\bot</span>), the difference in these probabilities is negligible according to the soundness of the history accumulator scheme and the binding property of the commitment scheme. The transaction logic is sound as it simply repeats the transaction logic that is defined by the privacy pool. The transfer record logic is sound according to the collision-resistance of the hash function and the soundness of the history accumulator scheme.</p>

    <h4 id="sec-28" class="text-lg font-semibold mt-6">Zero Knowledge</h4>

    <p class="text-gray-300">The (statistical) zero knowledge property of the PAM scheme follows directly from the zero knowledge property of the PCD scheme. In particular, the PCD simulator <span class="math">\\mathbb{S}</span> can be used to construct the PAM simulator <span class="math">\\mathcal{S}</span> needed to show that the PAM scheme is zero knowledge.</p>

    <h2 id="sec-29" class="text-2xl font-bold">6. Evaluation</h2>

    <p class="text-gray-300">We implement our construction of proof-carrying disclosures using Rust and the Arkworks ecosystem <em>(2)</em>. Our implementation consists of <span class="math">\\approx 5500</span> lines of code and is available open source. The implementation consists of the compliance predicate circuit and a system for generating proof-carrying disclosures for example transactions. The constraints and proof-carrying data primitives are implemented using Arkworks. We instantiate the PCD scheme</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Component</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Sub-component</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Constraints</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Membership</td>

            <td class="px-3 py-2 border-b border-gray-700">Value Computation</td>

            <td class="px-3 py-2 border-b border-gray-700">1,258</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Membership Proof</td>

            <td class="px-3 py-2 border-b border-gray-700">6,161</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">History Proof</td>

            <td class="px-3 py-2 border-b border-gray-700">6,161</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Deposit Record</td>

            <td class="px-3 py-2 border-b border-gray-700">Value Computation</td>

            <td class="px-3 py-2 border-b border-gray-700">7,142</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Membership Proof</td>

            <td class="px-3 py-2 border-b border-gray-700">6,161</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">History Proof</td>

            <td class="px-3 py-2 border-b border-gray-700">6,161</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Transfer Record</td>

            <td class="px-3 py-2 border-b border-gray-700">Value Computation</td>

            <td class="px-3 py-2 border-b border-gray-700">1,990</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Membership Proof</td>

            <td class="px-3 py-2 border-b border-gray-700">6,161</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">History Proof</td>

            <td class="px-3 py-2 border-b border-gray-700">6,161</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Transaction</td>

            <td class="px-3 py-2 border-b border-gray-700">Value Computation</td>

            <td class="px-3 py-2 border-b border-gray-700">3,705</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Value Consistency</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Total</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">51,062</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Component-wise breakdown of R1CS constraints for the predicate in the recursive membership proof.</p>

    <p class="text-gray-300">of [9] with the Pasta cycle of elliptic curves [25]. This scheme optimizes for prover efficiency and uses a transparent setup.</p>

    <p class="text-gray-300">The compliance predicate circuit consists of 51,062 constraints. A component-wise breakdown of the constraints is provided in Table 1. The verification of the membership proofs and history proofs accounts for the majority of the constraints in the compliance predicate. The constraint count has been optimized by using the Poseidon [23] hash function.</p>

    <p class="text-gray-300">We evaluated the performance on a laptop with an Apple M1 Max processor. Figure 2 contains proving/verification times for a range of Merkle tree depth values. For a Merkle tree depth of 20 and single-threaded execution, the setup time was 5.5 seconds, the proving time was 19.5 seconds, and the verification time was 13.0 seconds. With multi-threaded execution, the setup time was 2.0 seconds, the proving time was 3.4 seconds, and the verification time was 1.9 seconds. The proof size was  <span class="math">6.3\\mathrm{MB}</span>  for a tree depth of 20. For our application, it is beneficial to leverage a proof system that optimizes for proving time at the expense of proof size, since the resulting proofs are not posted on-chain. Other PCD schemes such as [5] could be used, resulting in different tradeoffs in the setup type, proving/verification time, and proof size. The scheme of [5] results in short proofs but yields a significantly higher proving time. As discussed in Section 2.3 and prior work [8, 31], the final membership proof upon withdrawal from the pool can be compressed. Since the proof no longer needs to be used by any party to continue running PCD, the proof can be compressed using a SNARK. For example, applying Groth16 [24] would result in short proofs ( <span class="math">\\approx</span>  200 bytes).</p>

    <p class="text-gray-300">Our design does not introduce additional gas costs and does not change the functionality of the privacy pool contract. The registry containing the allowlists and the history accumulators can be maintained offline based on the blockchain state.</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Figure 2: Recursive membership proof generation time and verification time for a range of system parameters.</p>

    <p class="text-gray-300">Extensions. Derecho supports attestations of membership on allowlists. Allowlists can also be used to implement blocklists by simply including every unblocked address on the allowlist. This is an appropriate solution in the context of our construction, but there are a couple caveats. First, the size of an allowlist could grow to include millions of Ethereum addresses. Since the scheme costs are logarithmic in the total size of the allowlists, this is still a practical solution, but efficiency is impacted. Second, an allowlist manager may be uncomfortable explicitly endorsing addresses that are freshly created due to regulatory reasons, though implicitly this approach is equivalent to a blocklist. As a result, one might wish to support blocklists more directly.</p>

    <p class="text-gray-300">The key challenge with this approach is that a user can easily transfer funds from a blocklisted address  <span class="math">\\mathsf{pk}_s</span>  to a fresh Ethereum address  <span class="math">\\mathsf{pk}_s&#x27;</span>  before depositing into the privacy pool. The funds might then be transferred several hops within the pool before the blocklist could be updated to include  <span class="math">\\mathsf{pk}_s&#x27;</span> . At this stage, the output records of these hops would include valid proofs of non-membership. It would be infeasible to require these proofs to be updated relative to the newer states of the blocklists because the holders of those records do not have knowledge of the records' origin, only the non-membership attestations that were valid against the previous blocklist states. In the case of allowlists, users can be required to register new addresses on the allowlists so that freshly created addresses are not automatically included, preventing users from undermining the disclosure proof system by creating a fresh Ethereum address before depositing into the pool.</p>

    <p class="text-gray-300">Given these considerations, it would be interesting to develop alternative constructions that more directly support blocklist non-membership proofs, while preventing attacks of the nature described above. One solution is to require a proof of account age to avoid the issue with freshly created addresses. There are known solutions to efficiently proving account age using historical Ethereum</p>

    <p class="text-gray-300">blockchain data <em>(27)</em>. Furthermore, there are circuit-friendly accumulators such as indexed Merkle trees <em>(41)</em> that support relatively efficient non-membership proofs.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Derecho addresses the common scenario where a sanctioned organization exploits a smart contract to steal cryptocurrency and launders the stolen funds through a privacy pool. However, a potential concern is that an entity who had funds in the pool before becoming sanctioned or receives funds through an in-pool transfer might subsequently transfer those funds to another person/entity. One solution to this problem, requiring minimal changes to the compliance predicate, is as follows. Users can additionally register their shielded addresses on allowlists. The shielded address pk can be computed by rerandomizing the public Ethereum address pk_{s} (e.g., pk = $H_{q}(\\text{sk}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{pk}_{s})<span class="math"> where sk is the secret key). When creating a disclosure, the sender can additionally prove that its current shielded address is allowed. In this extension, the transfer record should reference the current state of the membership declaration accumulator </span>\\text{rt}_{\\text{id}}$ to enforce that the current state of the allowlist is used at each step. While it may be difficult to sanction an entity based on its actions inside a privacy pool, this is an independent concern. The allowlist manager may rely on other information for authorization.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h5 id="sec-31" class="text-base font-semibold mt-4">Limitations</h5>

    <p class="text-gray-300">Under stricter circumstances, an exchange may wish to know that certain funds did not recently pass through newly sanctioned entities in the pool (even if they were allowed at the time of transfer). For instance, a user may be sanctioned immediately after transferring funds to a new recipient. While Derecho supports removal of addresses from allowlists to facilitate sanctions on previously approved entities, it may be desirable to additionally support <em>revocation</em> of allowlist membership proofs for existing transaction outputs. However, this would conflict with the privacy goals. Suppose there exists a construction where a single address may be removed from an allowlist <span class="math">\\mathsf{al}</span> to create a new allowlist <span class="math">\\mathsf{al}^{\\prime}</span> such that old membership proofs for <span class="math">\\mathsf{al}</span> can be updated to support verification against <span class="math">\\mathsf{al}^{\\prime}</span>. Then a membership proof that was previously valid against the old allowlist <span class="math">\\mathsf{al}</span> but not the new allowlist <span class="math">\\mathsf{al}^{\\prime}</span> can be used to break the privacy guarantee of unlinkability. More precisely, this implies that the party who is able to compute <span class="math">\\mathsf{al}^{\\prime}</span> and the party who is able to update a membership proof <span class="math">\\pi</span> for funds stored at a given record within the privacy pool would be able to collude at any time to discover all addresses on <span class="math">\\mathsf{al}</span> from which the funds originated. We leave exploration of relaxed privacy models that might be compatible with proof revocation for future work.</p>

    <h2 id="sec-32" class="text-2xl font-bold">8. Related Work</h2>

    <p class="text-gray-300">Sander and Ta-Shma <em>(37)</em> and Camenisch et al. <em>(13)</em> established the foundations of accountable privacy for ecash systems. With the growing popularity of cryptocurrencies, several works have examined trade-offs between privacy and accountability/auditability in the design of decentralized payment systems. Garman et al. <em>(22)</em> demonstrates how to add privacy-preserving policy enforcement mechanisms to the Zerocash design. UTT <em>(38)</em> designs a decentralized payment system that limits the the amount of currency sent per month using the notion of an anonymity budget. Platypus <em>(44)</em> and PEReDi <em>(30)</em> explore the design of central bank digital currencies (CBDCs) with privacy-preserving regulatory functionality. Platypus focuses on enforcement of anonymity budgets and total balance limits. PEReDi supports compliance with regulations such as Know Your Customer (KYC), Anti Money Laundering (AML), and Combating Financing of Terrorism (CFT). Their system aims to avoid a single point of failure by distributing the policy enforcement mechanism. CAP <em>(20)</em> introduces Configurable Asset Privacy schemes, which support private transfers of heterogeneous assets with custom viewing and freezing policies. ZEBRA <em>(36)</em> develops anonymous credentials that support auditability and revocation while enabling efficient on-chain verification. We refer to <em>(14)</em> for a more detailed study of these research challenges.</p>

    <p class="text-gray-300">ZEXE <em>(7)</em> provides a general framework for privacy-preserving blockchain applications in which the application state is a system of records, transactions create and nullify records, and all records have birth and death predicates defining the conditions under which they can be created or nullified. Transactions contain zero-knowledge proofs that these predicates are satisfied. As the authors note, this captures membership proofs of records on allowlists/blocklists as a special case (described in detail through a “regulation-friendly private stablecoin” example). In terms of comparison to <em>Derecho</em>, the ZEXE regulation-friendly stablecoin example restricts users of the stablecoin to a single allowlist (or blocks users on a single blocklist), represented as a credential assigned to the public key of a user, while Derecho does not alter the functionality of privacy-preserving cryptocurrencies, enabling users to separately disclose allowlist provenance off-chain. Unlike Derecho, ZEXE does not address how users can prove statements about the origin of records within a hidden transaction graph, nor the added challenge that the users themselves cannot see the full details of transaction history aside from membership proofs of their existing records.</p>

    <p class="text-gray-300">Proof-carrying data <em>(16)</em> (PCD) generalizes the notion of incrementally verifiable computation <em>(43)</em> (IVC) from sequential computation to distributed computation over a directed acyclic graph. The initial paper proposing PCD proposed several applications to the integrity of distributed computations, including distributed program analysis, type safety, IT supply chains, and conjectured applications to financial systems. Naveh and Tromer <em>(35)</em> proposed an application of PCD to image authentication, i.e., proving the authenticity of photos even after they have been edited according to a permissible set of transformations. PCD (and IVC as a special case) has been used to construct authenticated data structures with richer invariants, such as append-only dictionaries <em>(40)</em> and incrementally verifiable ledger systems <em>(6; 15)</em>.</p>

    <p class="text-gray-300">The Privacy Pools <em>(12)</em> protocol enables membership and non-membership proofs for withdrawals from privacy pools that do not support in-pool transfers, such as Tornado Cash (Classic). Membership is defined with respect to association sets (i.e., collections of records), and the disclosure system is based on zk-SNARKs. The paper outlines extensions to support arbitrary denominations and in-pool transfers. To support arbitrary denominations, changes to the privacy pool are proposed (i.e., transfers must propagate commitments through transactions). To handle in-pool transfers, the sender must reveal secret information about the spent record to the recipient, who may be required to transmit this information to other parties. This weakens the privacy guarantees of the pool. On the other hand, our disclosure system requires no changes to the privacy pool or its security guarantees.</p>

    <p class="text-gray-300">Acknowledgments</p>

    <p class="text-gray-300">This work was supported by the Algorand Centres of Excellence programme managed by Algorand Foundation. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of Algorand Foundation.</p>

    <h2 id="sec-33" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Elli Androulaki, Ghassan Karame, Marc Roeschlin, Tobias Scherer, and Srdjan Capkun. 2013. Evaluating User Privacy in Bitcoin. In FC 2013 (LNCS, Vol. 7859), Ahmad-Reza Sadeghi (Ed.). Springer, Heidelberg, 34–51. https://doi.org/10.1007/978-3-642-39884-1_4</li>

      <li>[2] arkworks contributors. 2022. arkworks zkSNARK ecosystem. https://arkworks.rs</li>

      <li>[3] Stephanie Bayer and Jens Groth. 2013. Zero-Knowledge Argument for Polynomial Evaluation with Application to Blacklists. In EUROCRYPT 2013 (LNCS, Vol. 7881), Thomas Johansson and Phong Q. Nguyen (Eds.). Springer, Heidelberg, 646–663. https://doi.org/10.1007/978-3-642-38348-9_38</li>

      <li>[4] Eli Ben-Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers, Eran Tromer, and Madars Virza. 2014. Zerocash: Decentralized Anonymous Payments from Bitcoin. In 2014 IEEE Symposium on Security and Privacy. IEEE Computer Society Press, 459–474. https://doi.org/10.1109/SP.2014.36</li>

      <li>[5] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. 2014. Scalable Zero Knowledge via Cycles of Elliptic Curves. In CRYPTO 2014, Part II (LNCS, Vol. 8617), Juan A. Garay and Rosario Gennaro (Eds.). Springer, Heidelberg, 276–294. https://doi.org/10.1007/978-3-662-44381-1_16</li>

      <li>[6] Joseph Bonneau, Izaak Meckler, Vanishree Rao, and Evan Shapiro. 2020. Coda: Decentralized Cryptocurrency at Scale. Cryptology ePrint Archive, Report 2020/352. https://eprint.iacr.org/2020/352.</li>

      <li>[7] Sean Bowe, Alessandro Chiesa, Matthew Green, Ian Miers, Pratyush Mishra, and Howard Wu. 2020. ZEXE: Enabling Decentralized Private Computation. In 2020 IEEE Symposium on Security and Privacy. IEEE Computer Society Press, 947–964. https://doi.org/10.1109/SP40000.2020.00050</li>

      <li>[8] Benedikt Bünz and Binyi Chen. 2023. Protostar: Generic Efficient Accumulation/Folding for Special-Sound Protocols. In ASIACRYPT 2023, Part II (LNCS, Vol. 14439), Jian Guo and Ron Steinfeld (Eds.). Springer, Heidelberg, 77–110. https://doi.org/10.1007/978-981-99-8724-5_3</li>

      <li>[9] Benedikt Bünz, Alessandro Chiesa, William Lin, Pratyush Mishra, and Nicholas Spooner. 2021. Proof-Carrying Data Without Succinct Arguments. In CRYPTO 2021, Part I (LNCS, Vol. 12825), Tal Malkin and Chris Peikert (Eds.). Springer, Heidelberg, Virtual Event, 681–710. https://doi.org/10.1007/978-3-030-84242-0_24</li>

      <li>[10] Benedikt Bünz, Lucianna Kiffer, Loi Luu, and Mahdi Zamani. 2020. FlyClient: Super-Light Clients for Cryptocurrencies. In 2020 IEEE Symposium on Security and Privacy. IEEE Computer Society Press, 928–946. https://doi.org/10.1109/SP40000.2020.00049</li>

      <li>[11] Joseph Burleson, Michele Korver, and Dan Boneh. 2022. Privacy-Protecting Regulatory Solutions Using Zero-Knowledge Proofs. (2022). https://a16zcrypto.com/wp-content/uploads/2022/11/ZKPs-and-Regulatory-Compliant-Privacy.pdf.</li>

      <li>[12] Vitalik Buterin, Jacob Illum, Matthias Nadler, Fabian Schär, and Ameen Soleimani. 2023. Blockchain privacy and regulatory compliance: Towards a practical equilibrium. Blockchain: Research and Applications (2023), 100176.</li>

      <li>[13] Jan Camenisch, Susan Hohenberger, and Anna Lysyanskaya. 2006. Balancing Accountability and Privacy Using E-Cash (Extended Abstract). In SCN 06 (LNCS, Vol. 4116), Roberto De Prisco and Moti Yung (Eds.). Springer, Heidelberg, 141–155. https://doi.org/10.1007/11832072_10</li>

      <li>[14] Panagiotis Chatzigiannis, Foteini Baldimtsi, and Konstantinos Chalkias. 2021. SoK: Auditability and Accountability in Distributed Payment Systems. In ACNS 21, Part II (LNCS, Vol. 12727), Kazue Sako and Nils Ole Tippenhauer (Eds.). Springer, Heidelberg, 311–337. https://doi.org/10.1007/978-3-030-78375-4_13</li>

      <li>[15] Weikeng Chen, Alessandro Chiesa, Emma Dauterman, and Nicholas P. Ward. 2020. Reducing Participation Costs via Incremental Verification for Ledger Systems. Cryptology ePrint Archive, Report 2020/1522. https://eprint.iacr.org/2020/1522.</li>

      <li>[16] Alessandro Chiesa and Eran Tromer. 2010. Proof-Carrying Data and Hearsay Arguments from Signature Cards. In ICS 2010, Andrew Chi-Chih Yao (Ed.). Tsinghua University Press, 310–331.</li>

      <li>[17] Coin Center. 2022. Tornado Cash complaint. https://www.coincenter.org/app/uploads/2022/10/1-Complaint-Coin-Center-10-12-22.pdf.</li>

      <li>[18] Scott Alexander Crosby. 2010. Efficient tamper-evident data structures for untrusted servers. Rice University.</li>

      <li>[19] Scott A. Crosby and Dan S. Wallach. 2009. Efficient Data Structures For Tamper-Evident Logging. In USENIX Security 2009, Fabian Monrose (Ed.). USENIX Association, 317–334.</li>

      <li>[20] Espresso Systems. 2022. Configurable Asset Privacy. (2022). https://github.com/EspressoSystems/cap/blob/main/cap-specification.pdf.</li>

      <li>[21] Ben Fisch. 2022. Privacy-Protecting Regulatory Solutions Using Zero-Knowledge Proofs. (2022). https://www.espressosys.com/blog/configurable-privacy-case-study-partitioned-privacy-pools.</li>

      <li>[22] Christina Garman, Matthew Green, and Ian Miers. 2016. Accountable Privacy for Decentralized Anonymous Payments. In FC 2016 (LNCS, Vol. 9603), Jens Grossklags and Bart Preneel (Eds.). Springer, Heidelberg, 81–98.</li>

      <li>[23] Lorenzo Grassi, Dmitry Khovratovich, Christian Rechberger, Arnab Roy, and Markus Schofnegger. 2021. Poseidon: A New Hash Function for Zero-Knowledge Proof Systems. In USENIX Security 2021, Michael Bailey and Rachel Greenstadt (Eds.). USENIX Association, 519–535.</li>

      <li>[24] Jens Groth. 2016. On the Size of Pairing-Based Non-interactive Arguments. In EUROCRYPT 2016, Part II (LNCS, Vol. 9666), Marc Fischlin and Jean-Sébastien Coron (Eds.). Springer, Heidelberg, 305–326. https://doi.org/10.1007/978-3-662-49896-5_11</li>

      <li>[25] Daira Hopwood. 2020. The pasta curves for halo 2 and beyond. https://electriccoin.co/blog/the-pasta-curves-for-halo-2-and-beyond/.</li>

      <li>[26] Daira Hopwood, Sean Bowe, Taylor Hornby, and Nathan Wilcox. 2022. Zcash protocol specification. (2022). https://zips.z.cash/protocol/protocol.pdf.</li>

      <li>[27] Intrinsic Technologies. 2024. Axiom Documentation. (2024). https://docs.axiom.xyz/.</li>

      <li>[28] Peter C. Johnson, Apu Kapadia, Patrick P. Tsang, and Sean W. Smith. 2007. Nymble: Anonymous IP-Address Blocking. In PET 2007 (LNCS, Vol. 4776), Nikita Borisov and Philippe Golle (Eds.). Springer, Heidelberg, 113–133. https://doi.org/10.1007/978-3-540-75551-7_8</li>

      <li>[29] George Kappos, Haaroon Yousaf, Mary Maller, and Sarah Meiklejohn. 2018. An Empirical Analysis of Anonymity in Zcash. In USENIX Security 2018, William Enck and Adrienne Porter Felt (Eds.). USENIX Association, 463–477.</li>

      <li>[30] Aggelos Kiayias, Markulf Kohlweiss, and Amirreza Sarencheh. 2022. PEReDi: Privacy-Enhanced, Regulated and Distributed Central Bank Digital Currencies. In ACM CCS 2022, Heng Yin, Angelos Stavrou, Cas Cremers, and Elaine Shi (Eds.). ACM Press, 1739–1752. https://doi.org/10.1145/3548606.3560707</li>

      <li>[31] Abhiram Kothapalli, Srinath Setty, and Ioanna Tzialla. 2022. Nova: Recursive Zero-Knowledge Arguments from Folding Schemes. In CRYPTO 2022, Part IV (LNCS, Vol. 13510), Yevgeniy Dodis and Thomas Shrimpton (Eds.). Springer, Heidelberg, 359–388. https://doi.org/10.1007/978-3-031-15985-5_13</li>

      <li>[32] Ben Laurie, Adam Langley, and Emilia Kasper. 2013. RFC 6962: Certificate transparency. https://www.rfc-editor.org/rfc/rfc6962.</li>

      <li>[33] Sarah Meiklejohn, Marjori Pomarole, Grant Jordan, Kirill Levchenko, Damon McCoy, Geoffrey M Voelker, and Stefan Savage. 2013. A fistful of bitcoins: characterizing payments among men with no names. In Proceedings of the 2013 conference on Internet measurement conference. 127–140.</li>

      <li>[34] Malte Möser, Kyle Soska, Ethan Heilman, Kevin Lee, Henry Heffan, Shashvat Srivastava, Kyle Hogan, Jason Hennessey, Andrew Miller, Arvind Narayanan, and Nicolas Christin. 2018. An Empirical Analysis of Traceability in the Monero Blockchain. PoPETs 2018, 3 (July 2018), 143–163. https://doi.org/10.1515/popets-2018-0025</li>

      <li>[35] Assa Naveh and Eran Tromer. 2016. PhotoProof: Cryptographic Image Authentication for Any Set of Permissible Transformations. In 2016 IEEE Symposium on Security and Privacy. IEEE Computer Society Press, 255–271. https://doi.org/10.1109/SP.2016.23</li>

      <li>[36] Deevashwer Rathee, Guru Vamsi Policharla, Tiancheng Xie, Ryan Cottone, and Dawn Song. 2022. ZEBRA: Anonymous Credentials with Practical On-chain Verification and Applications to KYC in DeFi. Cryptology ePrint Archive, Report 2022/1286. https://eprint.iacr.org/2022/1286.</li>

      <li>[37] Tomas Sander and Amnon Ta-Shma. 1999. Flow Control: A New Approach for Anonymity Control in Electronic Cash Systems. In FC’99 (LNCS, Vol. 1648), Matthew Franklin (Ed.). Springer, Heidelberg, 46–61.</li>

      <li>[38] Alin Tomescu, Adithya Bhat, Benny Applebaum, Ittai Abraham, Guy Gueta, Benny Pinkas, and Avishay Yanai. 2022. UTT: Decentralized Ecash with Accountable Privacy. Cryptology ePrint Archive, Report 2022/452. https://eprint.iacr.org/2022/452.</li>

      <li>[39] Patrick P Tsang, Apu Kapadia, Cory Cornelius, and Sean W Smith. 2009. Nymble: Blocking misbehaving users in anonymizing networks. IEEE Transactions on Dependable and Secure Computing 8, 2 (2009), 256–269.</li>

      <li>[40] Nirvan Tyagi, Ben Fisch, Andrew Zitek, Joseph Bonneau, and Stefano Tessaro. 2022. VeRSA: Verifiable Registries with Efficient Client Audits from RSA Authenticated Dictionaries. In ACM CCS 2022, Heng Yin, Angelos Stavrou, Cas Cremers, and Elaine Shi (Eds.). ACM Press, 2793–2807. https://doi.org/10.1145/3548606.3560605</li>

      <li>[41] Ioanna Tzialla, Abhiram Kothapalli, Bryan Parno, and Srinath Setty. 2021. Transparency Dictionaries with Succinct Proofs of Correct Operation. Cryptology ePrint Archive, Report 2021/1263. https://eprint.iacr.org/2021/1263.</li>

      <li>[42] United States Department of the Treasury. 2022. U.S. Treasury Sanctions Notorious Virtual Currency Mixer Tornado Cash. (2022). https://home.treasury.gov/news/press-releases/jy0916.</li>

    </ul>

    <p class="text-gray-300">[43] Paul Valiant. 2008. Incrementally Verifiable Computation or Proofs of Knowledge Imply Time/Space Efficiency. In TCC 2008 (LNCS, Vol. 4948), Ran Canetti (Ed.). Springer, Heidelberg, 1–18. https://doi.org/10.1007/978-3-540-78524-8_1 [44] Karl Wüst, Kari Kostiainen, Noah Delius, and Sedjan Capkun. 2022. Platypus: A Central Bank Digital Currency with Unlinkable Transactions and Privacy-Preserving Regulation. In ACM CCS 2022, Heng Yin, Angelos Stavrou, Cas Cremers, and Elaine Shi (Eds.). ACM Press, 2947–2960. https://doi.org/10.1145/3548606.3560617 [45] Zuoxia Yu, Man Ho Au, Jiangshan Yu, Rupeng Yang, Qiuliang Xu, and Wang Fat Lau. 2019. New Empirical Traceability Analysis of CryptoNote-Style Blockchains. In FC 2019 (LNCS, Vol. 11598), Ian Goldberg and Tyler Moore (Eds.). Springer, Heidelberg, 133–149. https://doi.org/10.1007/978-3-030-32101-7_9</p>

    <h2 id="sec-35" class="text-2xl font-bold">A.1. Cryptographic Primitives</h2>

    <p class="text-gray-300"><strong>Hash functions.</strong> We use hash functions satisfying the standard collision resistance property. Our system samples hash functions of the form <span class="math">H_{q}:\\{0,1\\}^{*}\\to \\mathbb{P}_{q}</span>. We use the arithmetic hash function Poseidon [23], which is commonly used in blockchain applications. Our disclosure system can be instantiated with any efficient construction of collision-resistant hash functions.</p>

    <p class="text-gray-300"><strong>Commitment schemes.</strong> A commitment scheme <span class="math">\\mathcal{C} = (\\mathrm{Com},\\mathrm{Vfy})</span> is a pair of efficient algorithms defined over a message space <span class="math">\\mathcal{M}</span> and a randomness space <span class="math">\\mathcal{R}</span> where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{cm} \\leftarrow \\operatorname{Com}(m; r)</span> is a commit algorithm that produces a commitment <span class="math">\\operatorname{cm}</span> given the message <span class="math">m \\in \\mathcal{M}</span> to be committed and the randomness <span class="math">r \\leftrightarrows \\mathcal{R}</span>.</li>

      <li><span class="math">b \\leftarrow \\operatorname{Vfy}(\\operatorname{cm}, m, r)</span> is a verification algorithm that checks whether <span class="math">(m, r)</span> is the correct opening of the commitment <span class="math">\\operatorname{cm}</span> and outputs a bit <span class="math">b \\in \\{0, 1\\}</span> representing accept if <span class="math">b = 1</span> and reject otherwise.</li>

    </ul>

    <p class="text-gray-300">Informally, a commitment scheme is called binding if it is infeasible to open a commitment to a different message. It is called hiding if the commitments of any two messages are indistinguishable. Commitment schemes can be built from collision-resistant hash functions.</p>

    <p class="text-gray-300"><strong>Accumulator schemes.</strong> An accumulator scheme consists of a tuple of efficient algorithms <span class="math">\\mathrm{Acc} = (\\mathrm{Init}, \\mathrm{Update}, \\mathrm{PrvMem}, \\mathrm{VfyMem})</span> where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathrm{rt}, \\sigma) \\leftarrow \\mathrm{Init}(1^{\\lambda})</span> sets up the initial state <span class="math">\\sigma</span> and digest rt of the accumulator.</li>

      <li><span class="math">(\\mathrm{rt}&#x27;, \\sigma&#x27;) \\leftarrow \\mathrm{Update}(\\mathrm{rt}, \\sigma, \\mathrm{elem})</span> inserts element elem into the set and outputs an updated state <span class="math">\\sigma&#x27;</span> and digest <span class="math">\\mathrm{rt}&#x27;</span>.</li>

      <li><span class="math">\\pi \\leftarrow \\operatorname{PrvMem}(\\sigma, \\operatorname{elem})</span> outputs a set membership proof <span class="math">\\pi</span> for the element elem in the set.</li>

      <li><span class="math">b \\leftarrow \\operatorname{VfyMem}(\\mathrm{rt}, \\pi, \\operatorname{elem})</span> outputs a bit <span class="math">b \\in \\{0, 1\\}</span> verifying whether <span class="math">\\pi</span> is a valid proof for the accumulation of elem in rt. The output is <span class="math">b = 1</span> if the proof is accepted as valid and <span class="math">b = 0</span> otherwise.</li>

    </ul>

    <p class="text-gray-300">Informally, an accumulator scheme should be correct and sound. Correctness ensures that for every element in the set, it should be easy to prove membership. Soundness ensures that for every element not in the set, it should not be feasible to prove membership.</p>

    <p class="text-gray-300"><strong>Public-key encryption schemes.</strong> A public-key encryption scheme is of a triple of efficient algorithms <span class="math">\\mathcal{E} = (\\mathrm{Gen}, \\mathrm{Enc}, \\mathrm{Dec})</span> where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathrm{pk}, \\mathrm{sk}) \\leftarrow \\mathrm{Gen}(1^{\\lambda})</span> is a PPT key generation algorithm that outputs a key pair consisting of a public key pk and a private key sk. The public key defines a message space <span class="math">\\mathcal{M}_{\\mathrm{pk}}</span>.</li>

      <li>ct <span class="math">\\leftarrow</span> Enc(pk, msg) is a PPT encryption algorithm that outputs a ciphertext ct when given a public key pk and a message msg <span class="math">\\in \\mathcal{M}_{\\mathrm{pk}}</span>.</li>

      <li>msg <span class="math">\\leftarrow</span> Dec(sk, ct) is a polynomial-time decryption algorithm that given a ciphertext ct and the secret key sk whose corresponding public key pk was used to generate the ciphertext, outputs the encrypted message in plaintext. The output msg is a special reject value if decryption failed.</li>

    </ul>

    <p class="text-gray-300">We require that <span class="math">\\operatorname{Pr}[\\operatorname{Dec}(\\operatorname{sk}, \\operatorname{Enc}(\\operatorname{pk}, \\operatorname{msg})) = \\operatorname{msg}] = 1</span> for all key pairs and messages. We require that the scheme has the IND-CPA and IK-CPA properties. The ElGamal scheme has these properties.</p>

    <p class="text-gray-300"><strong>zk-SNARKs.</strong> A preprocessing zk-SNARK (zero-knowledge succinct non-interactive argument of knowledge) with universal SRS (structured reference string) consists of a tuple of efficient algorithms <span class="math">\\mathrm{ARG} = (\\mathcal{G}, \\mathcal{I}, \\mathcal{P}, \\mathcal{V})</span> where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{srs} \\leftarrow \\mathcal{G}(1^{\\lambda}, N)</span> is a PPT generation algorithm that samples an SRS that supports indices of size up to <span class="math">N</span>. This is the universal setup, which is carried out once and used across all future circuits.</li>

      <li><span class="math">(\\mathrm{ek}, \\mathrm{vk}) \\leftarrow \\mathcal{I}_{\\mathrm{srs}}(i)</span> is a polynomial-time indexing algorithm that outputs the proving key ek and verification key vk for a circuit with description <span class="math">i</span>. This algorithm has oracle access to the SRS.</li>

      <li><span class="math">\\pi \\leftarrow \\mathcal{P}(\\mathrm{ek}, x, w)</span> is a PPT proving algorithm that outputs the proof given the instance <span class="math">x</span> and the witness <span class="math">w</span>.</li>

      <li><span class="math">b \\leftarrow \\mathcal{V}(\\mathrm{vk}, x, \\pi)</span> is a polynomial-time verification algorithm that outputs an accepting bit <span class="math">b \\in \\{0, 1\\}</span> given the verification key vk, the instance <span class="math">x</span>, and a proof <span class="math">\\pi</span>. The bit <span class="math">b = 1</span> denotes acceptance of the proof for the instance, while <span class="math">b = 0</span> denotes rejection of the proof.</li>

    </ul>

    <p class="text-gray-300">We require the standard security properties of completeness, knowledge soundness, zero knowledge, and succinctness.</p>

    <h2 id="sec-36" class="text-2xl font-bold">A.2. Privacy Pools</h2>

    <p class="text-gray-300">The privacy pool needs to keep track of the shielded addresses, the created records, and the nullifiers that correspond to spent records. SNARK-friendly accumulators are used to support the privacy-preserving transaction functionality. Specifically, the following data structures are used:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Public Parameters.</strong> In the setup of the privacy pool, a trusted party generates public parameters <span class="math">\\mathrm{pp}_{\\mathrm{pool}}</span> that are available to all participants in the system.</li>

      <li><strong>User Key Pairs.</strong> A user generates a key pair (sk, pk) when joining the privacy pool. The public key pk is used for receiving coins and the secret key sk is used for creating transactions. The public key is typically derived from the user's Ethereum address addr and the generated secret key. The user generates a key pair <span class="math">(\\mathrm{sk}&#x27;, \\mathrm{pk}&#x27;)</span> for encryption and decryption of owner memos.</li>

      <li><strong>Account List.</strong> The user's public keys are stored in the account list of the privacy pool contract upon registration. This list supports the anonymous transfer functionality of the privacy pool.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Coin Commitments. A coin commitment cm is a commitment to details of a transaction output, including the value amount amt and the recipient’s public key pk. The opening of the coin commitment open is used in transaction creation and membership proof generation.</li>

      <li>Nullifier Sets. The privacy pool typically maintains a nullifier set to prevent double-spending attacks. A nullifier nf can be constructed from an opening of a coin commitment cm and auxiliary information aux.</li>

      <li>Owner Memos. An owner memo memo is used by the coin owner to create the coin commitment from the encryption of the opening of the commitment. The memo can be shared with the recipient directly. Alternatively, the memo can be posted on the public ledger as part of the transaction.</li>

      <li>Accumulators. The privacy pool typically uses sparse Merkle trees to efficiently prove set membership. For example, an on-chain accumulator rt_{c} can maintain the set of coin commitments.</li>

    </ul>

    <p class="text-gray-300">Some of these data structures may also be referenced by the disclosure system. For instance, it is necessary to reference the nullifiers and the coin commitments in creating the membership proof. The privacy pool interface is described below. The privacy pool supports an initial setup, account registration, and financial transactions. The initial setup is run by a trusted party, and the transaction processing is typically executed by a smart contract. Each of the transaction objects are created by the client. We provide a specific implementation of the privacy pool interface in Appendix D.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>PrivacyPoolSetup(<span class="math">1^{\\lambda}</span>) <span class="math">\\rightarrow</span> pp<span class="math">{}_{\\text{pool}}</span>. This algorithm sets up the initial state of the privacy pool, including the accumulator and configurable parameters. Returns the public parameters pp<span class="math">{}_{\\text{pool}}</span>.</li>

      <li>ProcessDepositTx(pp<span class="math">{}_{\\text{pool}},\\text{tx}_{\\text{dep}}</span>) <span class="math">\\rightarrow</span> <span class="math">b</span>. This algorithm validates the deposit amount and transfers funds from the sender address to the privacy pool contract address. Returns accept/reject bit <span class="math">b</span>.</li>

      <li>ProcessTransferTx_{n,m}(pp<span class="math">{}_{\\text{pool}},\\text{tx}_{\\text{tfr}}</span>) <span class="math">\\rightarrow</span> <span class="math">b</span>. This algorithm verifies the transfer proof and checks the value invariant. If the transaction is valid, input nullifiers are added to the nullifier set and output coin commitments are accumulated. Returns accept/reject bit <span class="math">b</span>.</li>

      <li>ProcessWithdrawalTx_{n}(pp<span class="math">{}_{\\text{pool}},\\text{tx}_{\\text{wdr}}</span>) <span class="math">\\rightarrow</span> <span class="math">b</span>. This algorithm verifies the withdrawal proof and validates the input coin commitments. If the transaction is valid, input nullifiers are added to the nullifier set and funds are sent to the recipient. Returns accept/reject bit <span class="math">b</span>.</li>

      <li>ProcessRegistrationTx(pp<span class="math">{}_{\\text{pool}},\\text{tx}_{\\text{reg}}</span>) <span class="math">\\rightarrow</span> <span class="math">b</span>. The pool will store the public keys (pk, pk^{′}) for the user in the account list. Returns accept/reject bit <span class="math">b</span>.</li>

    </ul>

    <p class="text-gray-300">The client supports the following operations for interacting with the privacy pool:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>GenerateKeyPair(pp<span class="math">{}_{\\text{pool}},\\text{addr}</span>) <span class="math">\\rightarrow</span> (sk, pk, sk^{′}, pk^{′}). Given public parameters pp<span class="math">{}_{\\text{pool}}</span> and an address addr, output a user key pair (sk, pk) and an encryption key pair (sk^{′}, pk^{′}).</li>

      <li>CreateRegistrationTx(pp<span class="math">{}_{\\text{pool}},\\text{pk}</span>) <span class="math">\\rightarrow</span> tx<span class="math">{}_{\\text{reg}}</span>. Given public parameters pp<span class="math">{}_{\\text{pool}}</span> and the user’s public keys (pk, pk^{′}), output a registration transaction tx<span class="math">{}_{\\text{reg}}=</span> (pk, pk^{′}). This transaction registers the public keys, which enables other users to send funds to the account using the key pk and encrypt the owner memos using the encryption key pk^{′}.</li>

      <li>CreateDepositTx(pp<span class="math">{}_{\\text{pool}},\\text{amt},\\text{pk}</span>) <span class="math">\\rightarrow</span> tx<span class="math">{}_{\\text{dep}}</span>. Given public parameters pp, a value amount amt, and a user public key pk, output a deposit transaction tx<span class="math">{}_{\\text{dep}}=</span> (cm, amt). The deposit transaction will transfer amt units of value from the sender to the privacy pool contract address.</li>

      <li>CreateTransferTx_{n,m}(…) <span class="math">\\rightarrow</span> tx<span class="math">{}_{\\text{tfr}}</span>. Given public parameters pp<span class="math">{}_{\\text{pool}}</span>, a list of input user secret keys sk_{in}, a list of openings of input coin commitments open_{in}, a list of input addresses addr_{in}, a list of openings of output coin commitments open<span class="math">{}_{\\text{out}}</span>, and a list of encryption public keys pk^{′}, output a transaction tx<span class="math">{}_{\\text{tfr}}=</span> (nf, cm, memo, rt_{c}, <span class="math">\\pi_{t}</span>) where <span class="math">\\pi_{t}</span> is the transfer proof. This transaction will transfer value from the input coin owners to the output coin owners. This algorithm is parametrized by the number of transaction inputs <span class="math">n</span> and the number of transaction outputs <span class="math">m</span>.</li>

      <li>CreateWithdrawalTx_{n}(…) <span class="math">\\rightarrow</span> tx<span class="math">{}_{\\text{wdr}}</span>. Given public parameters pp<span class="math">{}_{\\text{pool}}</span>, a list of sender secret keys sk_{in}, a list of openings of input coin commitments open_{in}, a list of input addresses addr_{in}, an opening of a placeholder output coin commitment open<span class="math">{}_{\\text{out}}</span>, and an output address addr<span class="math">{}_{\\text{out}}</span>, output a transaction tx<span class="math">{}_{\\text{wdr}}=</span> (amt, addr<span class="math">{}_{\\text{out}}</span>, nf, cm, rt_{c}, <span class="math">\\pi_{w}</span>) where <span class="math">\\pi_{w}</span> is the withdrawal proof. The withdrawal transaction will transfer amt units of value from the input coins to the output address addr<span class="math">{}_{\\text{out}}</span>. This algorithm is parametrized by the number of transaction inputs <span class="math">n</span>.</li>

    </ul>

    <p class="text-gray-300">The building blocks of the privacy pool must support the following interface:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Coin Commitment Creation. A coin commitment cm is computed from its opening open. This operation is denoted by cm <span class="math">\\coloneqq</span> Com(open).</li>

      <li>Nullifier Creation. A nullifier is computed from the opening of the coin commitment open and the auxiliary input aux. This operation is denoted by nf <span class="math">\\coloneqq</span> Nullify(open, aux). Nullifiers must be binding and hiding. This is typically achieved by using commitment schemes.</li>

      <li>Amount Extraction. The coin commitment opening must support the field extraction operation amt <span class="math">\\coloneqq</span> Value(open), which yields the value amount.</li>

    </ul>

    <h2 id="sec-37" class="text-2xl font-bold">Appendix B Building Block Algorithms</h2>

    <p class="text-gray-300">We provide a specific implementation of the building block algorithms of the privacy pool below. This is a basic implementation of the algorithms that illustrates the key ideas. Some minor changes, such as including a function of the secret key in the nullifier computation, may be needed for a production-ready implementation of the privacy pool. These algorithms may be generalized to support multiple types of assets.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Coin Commitment Creation. A coin commitment is computed using a hash function that is applied to the input elements and randomness. For a coin with value amt owned</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">by public key pk, the coin commitment cm is computed by $\\text{Com}(\\text{amt},\\text{pk};r)\\coloneqq H_{q}(\\text{amt}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{pk}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r)<span class="math">. We may also write </span>\\text{cm}\\coloneqq\\text{Com}(\\text{open})<span class="math"> for the opening </span>\\text{open}=(\\text{amt},\\text{pk},r)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Nullifier Creation. A nullifier is computed using a hash function that is applied to the randomness in the opening of the coin commitment. The nullifier for opening <span class="math">\\text{open}=(\\text{amt},\\text{pk},r)</span> and auxiliary input <span class="math">\\text{aux}=\\bot</span> is computed by <span class="math">\\text{Nullify}(\\text{open},\\text{aux})\\coloneqq H_{q}(r)</span>.</li>

      <li>Memo Encryption. <span class="math">\\text{ct}\\leftarrow\\text{Enc}_{\\text{pk}}(m;r)</span> denotes an ElGamal encryption algorithm that computes ciphertext ct from public key pk, message <span class="math">m</span>, and randomness <span class="math">r</span>.</li>

    </ul>

    <h2 id="sec-38" class="text-2xl font-bold">Appendix C Privacy Pool Proofs</h2>

    <p class="text-gray-300">For completeness, we provide a recap of the zk-SNARK statements for transactions within privacy pools. Unlike the recursive membership proofs, the proofs of these statements are verified by the smart contract, so it is more important to reduce verification costs.</p>

    <h4 id="sec-39" class="text-lg font-semibold mt-6">Transfer Proofs</h4>

    <p class="text-gray-300">This is the zk-SNARK statement for the validity of an anonymous transfer in the privacy pool. The proof shows that the value amount is preserved in the transfer, the sender knows the secret keys for each of the input coin commitments, the input coin commitments are accumulated, the owner memo of each output is correctly encrypted, the nullifiers for the input coin commitments are correctly computed, and the output coin commitments are correctly computed. Let <span class="math">n</span> be the number of transaction inputs and <span class="math">m</span> be the number of transaction outputs. We allow placeholder coins with a placeholder public key and a zero amount.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Statement:</li>

      <li>For <span class="math">i\\in[n]</span>:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $\\text{pk}^{in}_{i}=H_{q}(\\text{sk}^{in}_{i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{addr}^{in}_{i})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\text{null}_{i}=H_{q}(r^{in}_{i})</span></li>

      <li><span class="math">\\text{Acc.VfyMem}(\\text{rt}_{c},\\text{w}^{in}_{i},\\text{Com}(\\text{amt}^{in}_{i},\\text{pk}^{in}_{i};r^{in}_{i}))</span></li>

      <li><span class="math">\\sum_{i\\in[n]}\\text{amt}^{in}_{i}=\\sum_{i\\in[m]}\\text{amt}^{out}_{i}</span></li>

      <li>For <span class="math">i\\in[m]</span>:</li>

      <li><span class="math">\\text{cm}_{i}=\\text{Com}(\\text{amt}^{out}_{i},\\text{pk}^{out}_{i};r^{out}_{i})</span></li>

      <li><span class="math">\\text{memo}_{i}=\\text{Enc}_{\\text{pk}^{\\prime}_{i}}\\langle(\\text{amt}^{out}_{i},\\text{pk}^{out}_{i},r^{out}_{i}),\\gamma_{i})</span></li>

      <li>Public inputs:</li>

      <li><span class="math">(\\text{null}_{i})_{i\\in[n]}</span>: List of nullifiers for the transaction inputs.</li>

      <li><span class="math">(\\text{cm}_{i})_{i\\in[m]}</span>: List of output coin commitments.</li>

      <li><span class="math">(\\text{memo}_{i})_{i\\in[m]}</span>: List of output owner memos.</li>

      <li><span class="math">\\text{rt}_{c}</span>: Digest of coin commitment accumulator.</li>

      <li>Private inputs:</li>

      <li><span class="math">(\\text{amt}^{in}_{i},\\text{pk}^{in}_{i},r^{in}_{i})_{i\\in[n]}</span>: List of openings of input coin commitments.</li>

      <li><span class="math">(\\text{addr}^{in}_{i})_{i\\in[n]}</span>: List of owner addresses for transaction inputs.</li>

      <li><span class="math">(\\text{sk}^{in}_{i})_{i\\in[n]}</span>: List of user secret keys for transaction inputs.</li>

      <li><span class="math">(\\text{w}^{in}_{i})_{i\\in[n]}</span>: List of membership witnesses for transaction inputs.</li>

      <li><span class="math">(\\text{amt}^{out}_{i},\\text{pk}^{out}_{i},r^{out}_{i})_{i\\in[m]}</span>: List of openings of output coin commitments.</li>

      <li><span class="math">(\\text{pk}^{\\prime}_{i})_{i\\in[m]}</span>: Public keys for encryption of transaction outputs.</li>

      <li><span class="math">(\\gamma_{i})_{i\\in[m]}</span>: Encryption randomness values for transaction outputs.</li>

    </ul>

    <h4 id="sec-40" class="text-lg font-semibold mt-6">Withdrawal Proofs</h4>

    <p class="text-gray-300">This is the zk-SNARK statement for the validity of a withdrawal from the privacy pool. The proof shows that the value amount is preserved in the withdrawal, the sender knows the secret keys for each of the input coin commitments, the input coin commitments are accumulated, and the nullifiers are correctly computed. Let <span class="math">n</span> be the number of transaction inputs. As in the case of the transfer statement, we allow placeholder coins to support transaction padding. We include the recipient address in the public inputs to ensure that a front-running adversary cannot change the address in the withdrawal transaction.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Statement:</li>

      <li>For <span class="math">i\\in[n]</span>:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $\\text{pk}^{in}_{i}=H_{q}(\\text{sk}^{in}_{i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{addr}^{in}_{i})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\text{null}_{i}=H_{q}(r^{in}_{i})</span></li>

      <li><span class="math">\\text{Acc.VfyMem}(\\text{rt}_{c},\\text{w}^{in}_{i},\\text{Com}(\\text{amt}^{in}_{i},\\text{pk}^{in}_{i};r^{in}_{i}))</span></li>

      <li><span class="math">\\sum_{i\\in[n]}\\text{amt}^{in}_{i}=\\text{amt}_{\\text{out}}</span></li>

      <li>Public inputs:</li>

      <li><span class="math">(\\text{null}_{i})_{i\\in[n]}</span>: List of nullifiers for the transaction inputs.</li>

      <li><span class="math">\\text{addr}_{\\text{out}}</span>: Output recipient address.</li>

      <li><span class="math">\\text{amt}_{\\text{out}}</span>: Output value amount.</li>

      <li><span class="math">\\text{rt}_{c}</span>: Digest of coin commitment accumulator.</li>

      <li>Private inputs:</li>

      <li><span class="math">(\\text{amt}^{in}_{i},\\text{pk}^{in}_{i},r^{in}_{i})_{i\\in[n]}</span>: List of openings of input coin commitments.</li>

      <li><span class="math">(\\text{addr}^{in}_{i})_{i\\in[n]}</span>: List of owner addresses for transaction inputs.</li>

      <li><span class="math">(\\text{sk}^{in}_{i})_{i\\in[n]}</span>: List of user secret keys for transaction inputs.</li>

      <li><span class="math">(\\text{w}^{in}_{i})_{i\\in[n]}</span>: List of membership witnesses for transaction inputs.</li>

    </ul>

    <h2 id="sec-41" class="text-2xl font-bold">Appendix D Privacy Pool Algorithms</h2>

    <p class="text-gray-300">We present an example specification of the privacy pool algorithms in Figures 3 and 4.</p>

    <h2 id="sec-42" class="text-2xl font-bold">Appendix E Disclosure System Algorithms</h2>

    <p class="text-gray-300">We present the disclosure system algorithms in Figure 5. Recall that the client may create deposit, transfer transactions and withdrawal transactions to the pool. Membership proofs are produced alongside transfer and withdrawal transactions.</p>

    <h2 id="sec-43" class="text-2xl font-bold">Appendix F Private Asset Membership</h2>

    <p class="text-gray-300">We present our formal construction of the Derecho Private Asset Membership (PAM) scheme in Algorithms 1, 2 and 3. Recall that a PAM scheme <span class="math">\\text{PAM}=(\\mathbb{G},\\mathbb{P},\\mathbb{V})</span> consists of generator, prover, and verifier algorithms as defined in Section 4.5. We present a security proof for the properties of this construction in Section 5.4.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">GENERATEKEYPAIR(pppool, addr)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CREATEDEPOSITTx(pppool, amt, pk)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Generate encryption keys (pk', sk') ← E.Gen(1^λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">Sample r ←{0,1}^λ</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Generate secret key sk ←{0,1}^λ</td>

            <td class="px-3 py-2 border-b border-gray-700">Compute coin commitment cm = Hq(amt</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">pk</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">r)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Generate public key pk = Hq(sk</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">addr)</td>

            <td class="px-3 py-2 border-b border-gray-700">Set open = (amt, pk, r)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">return (sk, pk, sk', pk')</td>

            <td class="px-3 py-2 border-b border-gray-700">Set txdep = (cm, amt, pk)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | return txdep  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CREATETRANSFERTxn,m(...)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CREATEWITHDRAWALTxn(...)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Set null = [] and win = []</td>

            <td class="px-3 py-2 border-b border-gray-700">Set null = [] and win = []</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">for i ∈ [n] do</td>

            <td class="px-3 py-2 border-b border-gray-700">for i ∈ [n] do</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Set sk = skin[i]</td>

            <td class="px-3 py-2 border-b border-gray-700">Set sk = skin[i]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Parse (amt, pk, r) = openin[i]</td>

            <td class="px-3 py-2 border-b border-gray-700">Parse (amt, pk, r) = openin[i]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Compute coin commitment cm = Hq(amt</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">pk</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">r)</td>

            <td class="px-3 py-2 border-b border-gray-700">Compute coin commitment cm = Hq(amt</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">pk</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">r)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Compute nullifier null = Hq(r)</td>

            <td class="px-3 py-2 border-b border-gray-700">Compute nullifier null = Hq(r)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Compute w = Acc.PrvMem(σc, cm)</td>

            <td class="px-3 py-2 border-b border-gray-700">Compute w = Acc.PrvMem(σc, cm)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Add null to null, w to win</td>

            <td class="px-3 py-2 border-b border-gray-700">Add null to null, w to win</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">endfor</td>

            <td class="px-3 py-2 border-b border-gray-700">endfor</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Set cm = [], memo = [], and γ = []</td>

            <td class="px-3 py-2 border-b border-gray-700">Set cm = []</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">for i ∈ [m] do</td>

            <td class="px-3 py-2 border-b border-gray-700">Parse (amt, pk, r) = openout</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Parse (amt, pk, r) = openout[i]</td>

            <td class="px-3 py-2 border-b border-gray-700">Compute coin commitment cm = Hq(amt</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">pk</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">r)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Compute coin commitment cm = Hq(amt</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">pk</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">r)</td>

            <td class="px-3 py-2 border-b border-gray-700">Add cm to cm</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Sample γ ←{0,1}^λ</td>

            <td class="px-3 py-2 border-b border-gray-700">Set instance x = (null, amt, addrout, rtc)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Set pk' = pk'[i]</td>

            <td class="px-3 py-2 border-b border-gray-700">Set witness w = (openin, addrin, skin, win)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Compute owner memo memo = Encpk'(amt</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">pk</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">r;γ)</td>

            <td class="px-3 py-2 border-b border-gray-700">Generate withdrawal proof πw = ARG.P(ekw, x, w)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Add cm to cm, memo to memo, γ to γ</td>

            <td class="px-3 py-2 border-b border-gray-700">Set txwdr = (amt, addrout, null, cm, rtc, πw)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">endfor</td>

            <td class="px-3 py-2 border-b border-gray-700">return txwdr</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Set instance x = (null, cm, memo, rtc) |   |</p>

    <p class="text-gray-300">|  Set witness w = (openin, addrin, skin, win, openout, pk', γ) |   |</p>

    <p class="text-gray-300">|  Generate transfer proof πt = ARG.P(ekt, x, w) |   |</p>

    <p class="text-gray-300">|  Set txtfr = (null, cm, memo, rtc, πt) |   |</p>

    <p class="text-gray-300">|  return txtfr |   |</p>

    <p class="text-gray-300">Figure 3: Privacy Pool Client Algorithms.</p>

    <p class="text-gray-300">|  PRIVACYPOOLSETUP(1^λ)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Sample hash function H_q: {0,1}^* → P_q  |   |</p>

    <p class="text-gray-300">|  Specify the maximum deposit amount amt_max ∈ N and the Merkle tree depth d ∈ N  |   |</p>

    <p class="text-gray-300">|  Run universal setup for zk-SNARK: srs = ARG.G(1^λ)  |   |</p>

    <p class="text-gray-300">|  Construct circuit descriptions t for transfer proof and w for withdrawal proof  |   |</p>

    <p class="text-gray-300">|  Generate keys for circuit: eki, vk1 ← ARG.Isrs(t) and ekw, vkw ← ARG.Isrs(w)  |   |</p>

    <p class="text-gray-300">|  Create (rtc, σc) = Acc.Init(1^λ)  |   |</p>

    <p class="text-gray-300">|  Set NullifierList = ∅, DigestList = ∅, and AccountList = {}  |   |</p>

    <p class="text-gray-300">|  Set pppool = {H_q, amt_max, d, rtc, σc, eki, vk1, ekw, vkw, NullifierList, DigestList, AccountList}  |   |</p>

    <p class="text-gray-300">|  return pppool  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PROCESSREGISTRATIONTx(pppool, txreg)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PROCESSDEPOSITTx(pppool, txdep)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Set AccountList[txreg sender] = (pk, pk')</td>

            <td class="px-3 py-2 border-b border-gray-700">Check amt is less than or equal to amt_max</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">return 1</td>

            <td class="px-3 py-2 border-b border-gray-700">Update rtc = Acc.Update(rtc, σc, cm)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | Add rtc to DigestList  |</p>

    <p class="text-gray-300">|   | Transfer amt units from txdep sender to contract address  |</p>

    <p class="text-gray-300">|   | return 1  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PROCESSTRANSFERTxn,m(pppool, txfr)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PROCESSWITHDRAWALTxn(pppool, txwdr)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Require rt' ∈ DigestList</td>

            <td class="px-3 py-2 border-b border-gray-700">Require rt' ∈ DigestList</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">for i ∈ [n] do</td>

            <td class="px-3 py-2 border-b border-gray-700">for i ∈ [n] do</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Set null = null[i]</td>

            <td class="px-3 py-2 border-b border-gray-700">Set null = null[i]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Require null∉ NullifierList</td>

            <td class="px-3 py-2 border-b border-gray-700">Require null∉ NullifierList</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Add null to NullifierList</td>

            <td class="px-3 py-2 border-b border-gray-700">Add null to NullifierList</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">endfor</td>

            <td class="px-3 py-2 border-b border-gray-700">endfor</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">for i ∈ [m] do</td>

            <td class="px-3 py-2 border-b border-gray-700">Require ARG.∇(vkw, [null, amt, addr, rt', πw)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Set cm = cm[i]</td>

            <td class="px-3 py-2 border-b border-gray-700">Transfer amt units from contract address to recipient addr</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Update rtc = Acc.Update(rtc, σc, cm)</td>

            <td class="px-3 py-2 border-b border-gray-700">return 1</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  for j ∈ [n] do |   |</p>

    <p class="text-gray-300">|  Set null = null[j] |   |</p>

    <p class="text-gray-300">|  endfor |   |</p>

    <p class="text-gray-300">|  endfor |   |</p>

    <p class="text-gray-300">|  Add rtc to DigestList |   |</p>

    <p class="text-gray-300">|  Require ARG.∇(vkt, [null, cm, memo, rt', πt) |   |</p>

    <p class="text-gray-300">|  return 1 |   |</p>

    <p class="text-gray-300">Figure 4: Privacy Pool Contract Algorithms.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">DISCLOSURESYSTEMSETUP(1λ)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PROCESSDEPOSITTx(pp_disc, tx_dep)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Sample hash function Hq: {0,1} → Pq</td>

            <td class="px-3 py-2 border-b border-gray-700">Parse (cm, amt) = tx_dep</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Create (rt_id, σ_id) = HA.Init(1λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">Set pk_x = tx_dep sender</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Create (rt_dep, σ_dep) = HA.Init(1λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">Compute unique identifier uid for deposit</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Create (rt_fr, σ_fr) = HA.Init(1λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">Compute rec_dep = Hq(amt</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">pk_x</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">cm</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">uid</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">rt_id)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Construct PCD compliance predicates (φ_j) j∈[I]</td>

            <td class="px-3 py-2 border-b border-gray-700">Update rt_dep = HA.Update(rt_dep, σ_dep, rec_dep)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Perform PCD setup: pp_pcd = PCD.Θ(1λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">return (1, rec_dep, uid)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  for j ∈ [I] do |   |</p>

    <p class="text-gray-300">|  Generate keys: ipk_j, vpk_j ← PCD.Σ(pp_pcd, φ_j) |   |</p>

    <p class="text-gray-300">|  endfor |   |</p>

    <p class="text-gray-300">|  Populate AuthAccountList for each allowlist al_j |   |</p>

    <p class="text-gray-300">|  Set pp_disc = {Hq, rt_id, σ_id, rt_dep, σ_dep, rt_fr, σ_fr, (ipk_j, vpk_j) j∈[I]}, AuthAccountList} |   |</p>

    <p class="text-gray-300">|  return pp_disc |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PROCESSTRANSFERTxn,m(pp_disc, tx_fr)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PROCESSWITHDRAWALTxn(pp_disc, tx_wdr)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Set rec_fr = []</td>

            <td class="px-3 py-2 border-b border-gray-700">Set rec_fr = []</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">for i ∈ [m] do</td>

            <td class="px-3 py-2 border-b border-gray-700">for i ∈ [n] do</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">for j ∈ [n] do</td>

            <td class="px-3 py-2 border-b border-gray-700">Set nf = nf[i]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Create transfer record rec_fr = Hq(nf[j]</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">cm[i])</td>

            <td class="px-3 py-2 border-b border-gray-700">Create transfer record rec_fr = Hq(nf</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">cm)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Update rt_fr = HA.Update(rt_fr, σ_fr, rec_fr)</td>

            <td class="px-3 py-2 border-b border-gray-700">Update rt_fr = HA.Update(rt_fr, σ_fr, rec_fr)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Add rec_fr to rec_fr</td>

            <td class="px-3 py-2 border-b border-gray-700">Add rec_fr to rec_fr</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">endfor</td>

            <td class="px-3 py-2 border-b border-gray-700">endfor</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">endfor</td>

            <td class="px-3 py-2 border-b border-gray-700">return (1, rec_fr)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  return (1, rec_fr) |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CREATEMEMBERSHIPPROOFn,m(pp_disc, A, γ, A_in, π_in, al)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">VERIFYMEMBERSHIPPROOF(pp_disc, A, π, al_j)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Parse z from A, zloc from γ, and z_in from A_in</td>

            <td class="px-3 py-2 border-b border-gray-700">Compute verification result b = PCD.∇(ivk_j, z, π)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">for al_j ∈ al do</td>

            <td class="px-3 py-2 border-b border-gray-700">return b</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  for i ∈ [m] do |   |</p>

    <p class="text-gray-300">|  Compute πout = PCD.P(ipk_j, z_j, zloc, [z_ijk, π_ijk]k=1) |   |</p>

    <p class="text-gray-300">|  Set A_out[j][i] = A and πout[j][i] = πout |   |</p>

    <p class="text-gray-300">|  endfor |   |</p>

    <p class="text-gray-300">|  endfor |   |</p>

    <p class="text-gray-300">|  return (A_out, π_out) |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">AUTHORIZEACCOUNT(pp_disc, pk_x, al)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">REVOKEMEMBERSHIP(pp_disc, pk_x, al)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">for al ∈ al do</td>

            <td class="px-3 py-2 border-b border-gray-700">Require pk_x is in AuthAccountList[al]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Require pk_x is not in AuthAccountList[al]</td>

            <td class="px-3 py-2 border-b border-gray-700">Compute decl = Hq(al</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">pk_x)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Add pk_x to AuthAccountList[al]</td>

            <td class="px-3 py-2 border-b border-gray-700">Update rt_id = HA.Remove(rt_id, σ_id, decl)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Compute decl = Hq(al</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">pk_x)</td>

            <td class="px-3 py-2 border-b border-gray-700">endfor</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Add decl to decl</td>

            <td class="px-3 py-2 border-b border-gray-700">return 1</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Update rt_id = HA.Update(rt_id, σ_id, decl) |   |</p>

    <p class="text-gray-300">|  endfor |   |</p>

    <p class="text-gray-300">|  return (1, decl) |   |</p>

    <p class="text-gray-300">Figure 5: Disclosure System Algorithms.</p>

    <p class="text-gray-300">|  Algorithm 1 DERECHO generator G(1λ)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Input: security parameter λ  |   |</p>

    <p class="text-gray-300">|  Output: public parameters pp  |   |</p>

    <p class="text-gray-300">|  1: pppool← POOL.PrIVACYPOOLSETUP(λ)  |   |</p>

    <p class="text-gray-300">|  2: ppdisc← DISC.DISCLOSURESYSTEMSETUP(λ)  |   |</p>

    <p class="text-gray-300">|  3: return (pppool, ppdisc)  |   |</p>

    <p class="text-gray-300">|  Algorithm 2 DERECHO prover P(pp, A, γ, Ain, πin, al)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Input: asset A, transaction parameter γ, input assets Ain, membership proofs πin, allowlist al  |   |</p>

    <p class="text-gray-300">|  Output: membership proof π  |   |</p>

    <p class="text-gray-300">|  1: (Aout, πout) ← DISC.CREATEMEMBERSHIPPROOF(  |   |</p>

    <p class="text-gray-300">|  2: ppdisc, [[A]], [[γ]], [Ain], [πin], [al])  |   |</p>

    <p class="text-gray-300">|  3: Check A = Aout[0][0]  |   |</p>

    <p class="text-gray-300">|  4: return πout[0][0]  |   |</p>

    <p class="text-gray-300">|  Algorithm 3 DERECHO verifier V(pp, A, π, al)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Input: asset A, membership proof π, allowlist al  |   |</p>

    <p class="text-gray-300">|  Output: verification result b ∈ {0,1}  |   |</p>

    <p class="text-gray-300">|  1: b ← DISC.VERIFYMEMBERSHIPPROOF(pp_disc, A, π, [al])  |   |</p>

    <p class="text-gray-300">|  2: return b  |   |</p>`;
---

<BaseLayout title="Derecho: Privacy Pools with Proof-Carrying Disclosures (2023/273)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2023 &middot; eprint 2023/273
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
