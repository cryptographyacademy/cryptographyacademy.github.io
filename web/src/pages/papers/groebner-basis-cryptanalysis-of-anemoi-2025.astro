---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2025/814';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Groebner Basis Cryptanalysis of Anemoi';
const AUTHORS_HTML = 'Luca Campa, Arnab Roy';

const CONTENT = `    <p class="text-gray-300">Luca Campa<a href="https://orcid.org/0009-0004-6916-1918">1</a> and Arnab Roy<a href="https://orcid.org/0000-0002-3284-7076">2</a></p>

    <p class="text-gray-300">University of Innsbruck luca.campa@uibk.ac.at, arnab.roy@uibk.ac.at</p>

    <p class="text-gray-300">Abstract. Arithmetization-Oriented (AO) symmetric primitives play an important role in the efficiency and security of zero-knowledge (ZK) proof systems. The design and cryptanalysis of AO symmetric-key primitives is a new topic particularly focusing on algebraic aspects. An efficient AO hash function aims at lowering the multiplicative complexity in the arithmetic circuit of the hash function over a suitable finite field. The AO hash function Anemoiwas proposed in CRYPTO 2023.</p>

    <p class="text-gray-300">In this work we present an in-depth Gröbner basis (GB) cryptanalysis of Anemoiover Fp. The main aim of any GB cryptanalysis is to obtain a well-structured set of polynomials representing the target primitive, and finally solve this system of polynomials using an efficient algorithm.</p>

    <p class="text-gray-300">We propose a new polynomial modelling for Anemoithat we call ACICO. We show that using ACICO one can obtain a GB defined by a wellstructured set of polynomials. Moreover, by utilising ACICO we can prove the exact complexity of the Gröbner basis computation (w.r.t Buchberger's algorithm) in the cryptanalysis of AnemoiThe structured GB ˙ further allows us to prove the dimension of the quotient space<a href="#page-0-0">1</a> which was conjectured in a recently published work.</p>

    <p class="text-gray-300">Afterwards, we provide the complexity analysis for computing the variety (or the solutions) of the GB polynomial system (corresponding to Anemoi) which is the final step in GB cryptanalysis, by using known approaches. In particular, we show that GB polynomial structure allows us to use the Wiedemann algorithm and improve the efficiency of cryptanalysis compared to previous works.</p>

    <p class="text-gray-300">Our GB cryptanalysis is applicable to more than two branches (a parameter in Anemoi ), while the previously published results showed cryptanalysis only for two branches. Our complexity analysis implies that the security of Anemoishould not rely upon the GB computation.</p>

    <p class="text-gray-300">We also address an important mathematical question in GB cryptanalysis of Anemoinamely, does the Anemoi polynomial system has a Shape form?, positively. By proving this we guarantee that upon application of basis conversion method like FGLM one can obtain a convenient system of polynomials that are easy to solve.</p>

    <p class="text-gray-300"><span id="page-0-0"></span><sup>1</sup> The quotient space dimension implicitly decides the complexity of the polynomial system solving step.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Introduction</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">Preliminaries</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">Gröbner Basis Cryptanalysis</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">Polynomial Representation of Anemoi</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">On the shape form of some zero-dimensional ideals</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">Gröbner basis cryptanalysis of Anemoi</td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">Anemoi cryptanalysis results</td>

            <td class="px-3 py-2 border-b border-gray-700">29</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">References<br></td>

            <td class="px-3 py-2 border-b border-gray-700">35</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700">Mathematical background</td>

            <td class="px-3 py-2 border-b border-gray-700">38</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">B</td>

            <td class="px-3 py-2 border-b border-gray-700">A brief description of Anemoi</td>

            <td class="px-3 py-2 border-b border-gray-700">38</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">Buchberger Gröbner basis algorithm</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">D</td>

            <td class="px-3 py-2 border-b border-gray-700">Wiedemann algorithms</td>

            <td class="px-3 py-2 border-b border-gray-700">41</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">E</td>

            <td class="px-3 py-2 border-b border-gray-700">Gröbner basis proofs</td>

            <td class="px-3 py-2 border-b border-gray-700">42</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">SparseFGLM vs. Wiedemann algorithm: a brief comparison</td>

            <td class="px-3 py-2 border-b border-gray-700">52</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">Fast variety finding</td>

            <td class="px-3 py-2 border-b border-gray-700">52</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">H</td>

            <td class="px-3 py-2 border-b border-gray-700">Experimental results</td>

            <td class="px-3 py-2 border-b border-gray-700">55</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Cryptanalysis of a cipher based on "solving a system of simultaneous equations" in a number of unknowns was considered by Claude E. Shannon [\\[34\\]](#page-36-0). For modern block ciphers like AES the idea of using system solving strategies was explored in a number of works <a href="#page-34-1">\\[8,</a> <a href="#page-34-2">9,</a> [41\\]](#page-37-2). However, these analysis did not pose any security threat to AES, and the cryptanalytic impact of such a system-solving approach on block ciphers and hash functions remained unclear possibly due to much less exploration of the topic after the initial ineffectiveness against AES, until recently.</p>

    <p class="text-gray-300">The main aim of Gröbner basis (GB) cryptanalysis is to solve a system of polynomials for obtaining the values of a set of target variables. For example, in case of a hash function H the target variables can be the input to H. Thus, obtaining the value of these variables means finding a pre-image of H. Typically, a system of polynomials, say F, over a suitable finite field K is obtained from the description of a cryptographic function e.g. permutation. Next, a Gröbner basis G w.r.t a suitable monomial ordering is computed for the ideal I = ⟨F ⟩, generated by F. Then, one can obtain the values of the target variables by solving the polynomial system defining the GB G. Computing a GB particularly facilitates the process of solving the system of polynomials in it. For example, one can employ basis conversion techniques to obtain a favourable set of polynomials that are easy to solve, or eigenvalue method to obtain univariate polynomial (possibly for each target variable).</p>

    <p class="text-gray-300">An important outcome that emerges from the GB analysis (in both previous and our results) of the AO primitives is that their security against GB analysis is not due to the high computational complexity of Gröbner basis computation step. AO primitives like MiMC [\\[2\\]](#page-34-3), GMiMC [\\[2\\]](#page-34-3), Poseidon [\\[22\\]](#page-35-0) etc. do not provide useful bound on the complexity of the GB computation step. Giving the exact complexity of Gröbner basis computation is a non-trivial problem. Previous works rely on the row reduction complexity bound of Macaulay matrices (and is a function of solving degree). It is well known that the bound is loose and often the experimental complexity turns out to be better than the bound. Thus, from both cryptanalytic and design perspectives it is not meaningful. Steiner [\\[38\\]](#page-36-1) tried to tighten the GB computation complexity by proving the solving degree bound for iterated polynomial systems, and in particular for the attacks on MiMC, Hades [\\[23\\]](#page-35-1) and GMiMC, showing the relation between the fall degree and the Castelnuovo-Mumford regularity. Moreover, as shown by [\\[1\\]](#page-34-4), the designers should pay particular attention to the algebraic structure of a cipher and its components, becasue a clever representation of those components can lead to experimental complexities far better than the theoretical estimates. An example of how the algebraic structure of a cipher can be exploited is given again in [\\[1\\]](#page-34-4), where the authors show how the modelling choices matter e.g. the choice of the variables and the field to operate with. In this paper we show similar issue namely, we provide a new algebraic model for Anemoi and utilising it compute the exact complexity of the GB computation w.r.t. the Buchberger's algorithm.</p>

    <h2 id="sec-4" class="text-2xl font-bold">4 Luca Camp<a href="https://orcid.org/0009-0004-6916-1918">a</a> and Arnab Ro<a href="https://orcid.org/0000-0002-3284-7076">y</a></h2>

    <p class="text-gray-300">One of the components in GB cryptanalysis is to obtain a "nice" set of polynomials (from the GB G of I) that is convenient to solve. This step has a significant complexity and an important role in GB cryptanalysis. After computing the Gröbner basis G, one may choose to employ basis conversion technique like FGLM to obtain a GB G′ w.r.t lexicographic monomial ordering. The only requirement is that I is a zero-dimensional ideal. The main advantage of this basis conversion is that, if I meets some conditions, G′ consists of one univariate polynomial, say g(x), and other polynomials which are of the form y<sup>i</sup> −fi(x) for each variable y<sup>i</sup> . This means that the solutions of the variables y<sup>i</sup> can be obtained by substituting the solutions of g(x) = 0. Usually, obtaining such form, which is commonly referred to as shape form, requires the condition that the ideal I = ⟨F ⟩ is a radical ideal. Alternatively, if the radicality condition is not met, one has to show that the GB G′ of I w.r.t lexicographic monomial ordering consists of polynomials in such nice form. Checking the condition for proving the shape form for the Gröbner basis of I is often omitted or concluded from experimental results in GB cryptanalysis of AO primitives. In this paper we tackle this problem for the GB cryptanalysis of Anemoi.</p>

    <p class="text-gray-300">When it is not possible to confirm the conditions for applying basis conversion techniques like FGLM one can resort to eigenvalue method. The main objective of this technique is to obtain a univariate polynomial corresponding to each target variable and find at least one solution to the polynomial (if it is not irreducible). An additional advantage of this technique is that it can sometimes be more efficient than the basis conversion technique. We will show that using probabilistic version of the eigenvalue method is more efficient than the technique used in <a href="#page-34-5">\\[3,</a> [29\\]](#page-36-2).</p>

    <h2 id="sec-5" class="text-2xl font-bold">1.1 Our Result</h2>

    <p class="text-gray-300">In this paper we provide an in-depth Gröbner basis cryptanalysis of Anemoi. The main aim of any GB cryptanalysis is to obtain a well-structured set of polynomials representing the target primitive, and finally solve this system of polynomials using an efficient algorithm.</p>

    <p class="text-gray-300">In this work we propose a new polynomial modelling of Anemoi permutation and construct a polynomial system that we call ACICO corresponding to the Anemoi hash function (Section <a href="#page-10-0">4\\)</a>. We prove structural properties of the polynomials defining the Gröbner basis corresponding to the ideal generated by ACICO (Section <a href="#page-17-1">6.1\\)</a>. Providing the exact complexity of GB computation is a non-trivial problem. Our ACICO modeling allows us to prove the complexity of GB computation by following the steps of Buchberger's algorithm. Note that our complexity analysis for the GB computation is applicable to any number of branches of Anemoi.</p>

    <p class="text-gray-300">Additionally, the structural property (that we prove in Section <a href="#page-17-1">6.1\\)</a> of the polynomials constituting the Gröbner basis (for Anemoi) allows us to prove the conjectured (in [\\[29\\]](#page-36-2)) dimension of the quotient space K[x1, x2, . . . , xn]/I (Section <a href="#page-25-0">6.3\\)</a>. By establishing the dimension of the quotient space, we can define the complexity of obtaining univariate polynomials which is one of the main steps towards solving the polynomial system corresponding to Anemoi (Section 6.3).</p>

    <p class="text-gray-300">A common approach in using GB method in cryptanalysis is to apply the basis conversion technique which converts the GB polynomial system to an easily solvable polynomial system. However, without assuring the existence of such easily solvable form e.g. Shape form, application of existing conversion algorithms such as FGLM is meaningless. We prove, for the first time, the Shape form for the GB of Anemoi and in general for constrained zero-dimensional ideals which does not satisfy the radicality condition (Sections 5 and 6.2). This result guarantees that we can apply FGLM algorithm for converting the GB of Anemoi to a system of polynomials that is easy to solve.</p>

    <p class="text-gray-300">Although this is the standard approach, we use efficient eigenvalue method for obtaining univariate polynomials. In an eigenvalue method the aim is to obtain a set of univariate polynomials from the GB polynomial system of Anemoi. More specifically, we use Wiedemann algorithm to obtain these univariate polynomials (Section 6.3), and improve (Section 7, Table 2) the efficiency of GB cryptanalysis w.r.t existing works [3, 29].</p>

    <p class="text-gray-300">Our GB cryptanalysis is applicable to <em>more than two branches</em> (a parameter in Anemoi), while the previously published results showed cryptanalysis only for two branches. Our complexity analysis (for GB computation) implies that the security of Anemoi should not be relied upon the GB computation.</p>

    <h2 id="sec-6" class="text-2xl font-bold">2 Preliminaries</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this section we give a brief and necessary algebraic background. We use  <span class="math">\\mathbb{K}</span>  to denote a field and  <span class="math">R := \\mathbb{K}[x_1,\\ldots,x_n]</span>  to denote the polynomial ring over  <span class="math">\\mathbb{K}</span>  in the variables  <span class="math">x_1,\\ldots,x_n</span> . When  <span class="math">\\mathbb{K}=\\mathbb{F}_p</span>  the ring is denoted as  <span class="math">R_p</span> . Due to ease of notation, at times we use the notation  <span class="math">\\mathbb{K}[\\mathbf{x}]</span>  to denote the ring where the variables  <span class="math">x_i</span>  are made clear in the corresponding context. We use  <span class="math">\\mathsf{LM}_k(g)</span>  for k>1 to denote the k-th leading monomial of the polynomial g with respect to a monomial order (which will be specified). For the first leading monomial, we simply use  <span class="math">\\mathsf{LM}(g)</span> .  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{B}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  denotes the cardinality of the set  </span>\\mathcal{B}$ . Throughout the paper, we will use deg to denote both the degree of a variable x and a polynomial g. The correct interpretation will be clear from the context.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The following definitions and results are mainly taken from [14, 15].</p>

    <p class="text-gray-300"><strong>Definition 1 (Affine Variety).</strong> Let  <span class="math">f_1, \\ldots, f_s \\in \\mathbb{K}[x_1, \\ldots, x_n]</span> . Then, the set</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb{V}(f_1, \\dots, f_s) = \\{(a_1, \\dots, a_n) \\in \\mathbb{K}^n \\mid f_i(a_1, \\dots, a_n) = 0, 1 \\le i \\le s\\}</span></div>

    <p class="text-gray-300">is called the <strong>affine variety</strong> defined by the polynomials  <span class="math">f_1, \\ldots, f_s</span> .</p>

    <p class="text-gray-300"><strong>Definition 2</strong> (Ideal). A subset  <span class="math">I \\subseteq R</span>  is an ideal if it satisfies the following conditions:</p>

    <p class="text-gray-300">•  <span class="math">0 \\in I</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if  <span class="math">f, g \\in I</span> , then  <span class="math">f + g \\in I</span></li>

      <li>if  <span class="math">f \\in I</span>  and  <span class="math">h \\in R</span> , then  <span class="math">hf \\in I</span></li>

    </ul>

    <p class="text-gray-300">Let  <span class="math">f_1, \\ldots, f_s</span>  be polynomials in R, then the set</p>

    <div class="my-4 text-center"><span class="math-block">\\langle f_1, \\dots, f_s \\rangle = \\left\\{ \\sum_{i=1}^s h_i f_i \\mid h_1, \\dots, h_s \\in R \\right\\}</span></div>

    <p class="text-gray-300">is an ideal in R generated by  <span class="math">f_i</span>  for  <span class="math">1 \\le i \\le s</span> .</p>

    <p class="text-gray-300"><strong>Definition 3 (Variety of ideal).</strong> Let  <span class="math">s, n \\in \\mathbb{N}</span>  and let  <span class="math">I = \\langle f_1, \\dots, f_s \\rangle \\in R</span>  be an ideal. Then, the set</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb{V}(I) = \\mathbb{V}(f_1, \\dots, f_s) := \\{(a_1, \\dots, a_n) \\in \\mathbb{K}^n \\mid f_i(a_1, \\dots, a_n) = 0, 1 \\le i \\le s\\}</span></div>

    <p class="text-gray-300">is called the affine variety of the ideal I. Moreover, for any field  <span class="math">\\mathbb{K} \\subset \\mathbb{K}&#x27;</span> ,  <span class="math">\\mathbb{V}_{\\mathbb{K}&#x27;}(I)</span>  denotes the set of solutions  <span class="math">(a_1,\\ldots,a_n)</span>  over the n-dimensional affine space  <span class="math">A^n(\\mathbb{K}&#x27;)</span> . In particular,  <span class="math">\\mathbb{V}_{\\bar{\\mathbb{K}}}(I)</span>  denotes the variety of I over the algebraic closure  <span class="math">\\mathbb{K}</span>  of  <span class="math">\\mathbb{K}</span> .</p>

    <p class="text-gray-300">The variety of an ideal is independent of the generating set of polynomials. There could be multiple sets of polynomials which define the same set of solutions. One important class of these sets is the class of Gröbner Basis.</p>

    <p class="text-gray-300"><strong>Definition 4 (Monomial Ordering).</strong> A monomial ordering  <span class="math">\\prec</span>  on  <span class="math">\\mathbb{K}[x_1,\\ldots,x_n]</span> is a relation  <span class="math">\\prec</span>  on  <span class="math">\\mathbb{Z}^n_{\\geq 0}</span> , or rather a relation on the set of monomials  <span class="math">x^{\\alpha}</span>  where  <span class="math">\\alpha \\in \\mathbb{Z}_{\\geq 0}^n</span> , satisfying  <span class="math">t\\bar{h}e</span>  following conditions:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\prec</span>  is a total (or linear) order on  <span class="math">\\mathbb{Z}^n_{\\geq 0}</span>  if  <span class="math">\\alpha \\prec \\beta</span>  and  <span class="math">\\gamma \\in \\mathbb{Z}^n_{\\geq 0}</span> , then  <span class="math">\\alpha + \\gamma \\prec \\beta + \\gamma</span>   <span class="math">\\prec</span>  is a well-ordering on  <span class="math">\\mathbb{Z}^n_{\\geq 0}</span> , meaning that every non-empty subset of  <span class="math">\\mathbb{Z}^n_{\\geq 0}</span> has a smallest element under the relation  <span class="math">\\prec</span> .</li>

    </ul>

    <p class="text-gray-300">The well-known ordering Lexicographic (LEX), Degree reverse lexicographic (DRL) are of particular interest in the context of GB analysis.</p>

    <p class="text-gray-300"><strong>Definition 5 (Lexicographic Order).</strong> Let  <span class="math">\\alpha = (\\alpha_1, \\dots, \\alpha_n)</span>  and  <span class="math">\\beta = (\\beta_1, \\dots, \\beta_n)</span> be in  <span class="math">\\mathbb{Z}^n_{\\geq 0}</span> . We say  <span class="math">\\alpha &gt;_{\\mathsf{LEX}} \\beta</span>  if the leftmost nonzero entry of the vector difference  <span class="math">\\alpha - \\beta \\in \\mathbb{Z}^n</span>  is positive. We say  <span class="math">x^{\\alpha} &gt;_{\\mathsf{LEX}} x^{\\beta}</span>  if  <span class="math">\\alpha &gt;_{\\mathsf{LEX}} \\beta</span> .</p>

    <p class="text-gray-300">Definition 6 (Reverse Lexicographic Order). Let  <span class="math">\\alpha = (\\alpha_1, \\dots, \\alpha_n)</span>  and  <span class="math">\\beta = (\\beta_1, \\dots, \\beta_n)</span>  be in  <span class="math">\\mathbb{Z}_{\\geq 0}^n</span> . We say  <span class="math">\\alpha &gt;_{\\mathsf{RLEX}} \\beta</span>  if the rightmost nonzero entry of the vector difference  <span class="math">\\alpha - \\beta \\in \\mathbb{Z}^n</span>  is negative. We say  <span class="math">x^{\\alpha} &gt;_{\\mathsf{RLEX}} x^{\\beta}</span>  if  <span class="math">\\alpha &gt;_{\\mathsf{RLEX}} \\beta</span> .</p>

    <p class="text-gray-300">Definition 7 (Degree Reverse Lexicographic Order). Let  <span class="math">\\alpha, \\beta \\in \\mathbb{Z}_{&gt;0}^n</span> . We  <span class="math">say \\alpha &gt;_{DRL} \\beta if</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\sum_{i=1}^n \\alpha_i ></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\sum_{i=1}^n \\beta_i, \\ \\ or \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ \\ and \\ \\alpha >_{\\mathit{RLEX}} \\beta.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We say  <span class="math">x^{\\alpha} &gt;_{DRL} x^{\\beta}</span>  if  <span class="math">\\alpha &gt;_{DRL} \\beta</span> .</p>

    <p class="text-gray-300"><strong>Definition 8 (Gröbner Basis).</strong> Let  <span class="math">I = \\langle f_1, \\ldots, f_s \\rangle</span>  be an ideal in  <span class="math">\\mathbb{K}[x_1, \\ldots, x_n]</span>  and let  <span class="math">\\prec</span>  be a valid monomial ordering. A finite subset  <span class="math">G = \\{g_1, \\ldots, g_t\\}</span>  of I different from  <span class="math">\\{0\\}</span>  is said to be a <strong>Gröbner Basis</strong> (or Standard Basis) w.r.t.  <span class="math">\\prec</span>  if</p>

    <p class="text-gray-300"><span id="page-6-0"></span> <span class="math-block">\\langle \\mathsf{LM}(g_1), \\dots, \\mathsf{LM}(g_t) \\rangle = \\langle \\mathsf{LM}(I) \\rangle</span></p>

    <p class="text-gray-300">where LM() denotes the leading monomial of a polynomial with respect to  <span class="math">\\prec</span> .</p>

    <p class="text-gray-300">To keep in mind the ordering we will often denote a Gröbner basis w.r.t to a monomial ordering  <span class="math">\\prec</span>  as  <span class="math">G_{\\prec}</span> .</p>

    <p class="text-gray-300">Every monomial ordering can be defined by a series of weights. Moreover, different monomial orderings can be combined to exploit different properties. The following definition will be useful in the next sections:</p>

    <p class="text-gray-300"><strong>Definition 9.</strong> Given a weight vector  <span class="math">w = (w_1, ..., w_n) \\in \\mathbb{R}^n_{\\geq 0}</span> , where  <span class="math">w_1 \\neq 0</span> . We say that w is associated with the monomial ordering  <span class="math">\\prec</span> , defined by:</p>

    <div class="my-4 text-center"><span class="math-block">\\prod_{i=1}^n x_i^{\\alpha_i} \\prec \\prod_{i=1}^n x_i^{\\beta_i} \\iff \\begin{cases} \\sum_{i=1}^n w_i \\alpha_i &gt; \\sum_{i=1}^n w_i \\beta_i \\\\ \\sum_{i=1}^n w_i \\alpha_i = \\sum_{i=1}^n w_i \\beta_i, \\alpha \\prec_M \\beta \\end{cases}</span></div>

    <p class="text-gray-300">where M is another monomial order like LEX, RLEX.</p>

    <p class="text-gray-300">For a fixed a monomial ordering, there exist a unique <strong>reduced Gröbner</strong> basis.</p>

    <p class="text-gray-300"><strong>Definition 10 (Reduced Gröbner Basis).</strong> Let G be a Gröbner basis for the ideal  <span class="math">I \\subset \\mathbb{K}[x_1, \\ldots, x_n]</span>  with respect to a monomial ordering  <span class="math">\\prec</span> , if</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>LC(g) = 1 for all  <span class="math">g \\in G</span></li>

      <li>for all  <span class="math">g \\in G</span> , no monomial of g lies in  <span class="math">\\langle \\mathsf{LT}(G \\setminus \\{g\\}) \\rangle</span></li>

    </ul>

    <p class="text-gray-300">(where LC and LT denote the leading coefficient and the leading term respectively  <span class="math">w.r.t \\prec</span> ) G is said to be a <strong>reduced Gröbner basis</strong>.</p>

    <p class="text-gray-300">An important property of reduced Gröbner basis is that the polynomial division modulo a Gröbner basis yields unique division remainders. Then, if G is a reduced Gröbner basis for the ideal I we are able to uniquely represent residue classes in the quotient ring R/I. The quotient ring R/I is a  <span class="math">\\mathbb{K}</span> -vector space, called the quotient space. The basis which defines that quotient space can be finite of infinite-dimensional. In particular, a standard basis for  <span class="math">\\mathbb{K}[x_1,\\ldots,x_n]/I</span>  is given by the set of monomials</p>

    <div class="my-4 text-center"><span class="math-block">B_I := \\left\\{ X^\\alpha \\mid X^\\alpha \\notin \\langle \\mathsf{LM}(I) \\rangle \\right\\} = \\left\\{ X^\\alpha = \\prod_{i=1}^n x_i^{\\alpha_i} \\mid X^\\alpha \\notin \\langle \\mathsf{LM}(G) \\rangle \\right\\}.</span></div>

    <p class="text-gray-300"><strong>Definition 11 (Zero-dimensional Ideal).</strong> Let  <span class="math">I \\subset R</span>  be a non-zero ideal, let  <span class="math">\\prec</span>  a valid monomial ordering and let G be a reduced Gröbner basis for I with respect to  <span class="math">\\prec</span> . If the quotient space R/I is finite-dimensional, that is</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$d_I = dim_{\\mathbb{K}}(R/I) =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B_I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">< \\infty$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">then I is called zero-dimensional ideal.</p>

    <p class="text-gray-300">An ideal I is zero-dimensional if the associated variety  <span class="math">\\mathbb{V}(I)</span>  is a finite set.</p>

    <p class="text-gray-300"><strong>Lemma 1.</strong> Let G be a Gröbner basis for the ideal  <span class="math">I \\subset R = \\mathbb{K}[x_1, \\dots, x_n]</span> . The ideal I is zero-dimensional if and only if for each  <span class="math">1 \\leq i \\leq n</span> , there exist an element in G whose initial term is a pure power of  <span class="math">x_i</span> :</p>

    <p class="text-gray-300"><span class="math-block">\\mathbb{V}(I)</span>  finite  <span class="math">\\iff \\forall_{i=1}^n (\\exists \\ f \\in G \\mid \\mathsf{LM}(f) = x_i^{\\alpha_i}) \\text{ where } \\alpha_i \\in \\mathbb{N}.</span></p>

    <p class="text-gray-300">The well-known shape lemma characterizes a zero-dimensional ideal w.r.t  <span class="math">G_{\\mathsf{LEX}}</span> :</p>

    <p class="text-gray-300"><strong>Theorem 1 (Shape Lemma).</strong> Let I be a zero-dimensional radical ideal such that the  <span class="math">x_n</span>  coordinate of the points in  <span class="math">\\mathbb{V}(I)</span>  are distinct. Let G be a reduced Gröbner basis for I relative to a LEX monomial order with  <span class="math">x_n</span>  as the last variable.</p>

    <div class="my-4 text-center"><span class="math-block">G = \\{x_1 - g_1(x_n), x_2 - g_2(x_n), \\dots, g_n(x_n)\\}\\</span></div>

    <p class="text-gray-300">where  <span class="math">\\deg(g_i) &lt; \\deg(g_n)</span>  for each  <span class="math">1 \\le i &lt; n</span>  and  <span class="math">\\deg(g_n) = \\dim_{\\mathbb{K}}(R/I)</span> . We say, equivalently, that the ideal I has shape lemma or shape form.</p>

    <p class="text-gray-300">Due to their structure, it is straightforward to see that  <span class="math">d_I = \\deg(g_n)</span>  and the complexity of computing the variety of such an ideal is equivalent to the complexity of factorizing the univariate polynomial  <span class="math">g_n</span> .</p>

    <p class="text-gray-300">If the quotient space is finite-dimensional, each remainder can be written as vector in the basis monomials of  <span class="math">B_I</span> . That means we can define a linear transformation  <span class="math">T_j: \\mathbb{K}[x_1,\\ldots,x_n]/I \\to \\mathbb{K}[x_1,\\ldots,x_n]/I</span>  corresponding to the multiplication by  <span class="math">x_j</span>  for all  <span class="math">1 \\leq j \\leq n</span> .</p>

    <p class="text-gray-300"><span id="page-7-1"></span><strong>Definition 12 (Multiplication matrix).</strong> Let I be a zero-dimensional ideal in  <span class="math">\\mathbb{K}[x_1,\\ldots,x_n]</span> , G a reduced Gröbner basis for I with respect to a monomial ordering  <span class="math">\\prec</span>  and  <span class="math">B_I = (e_1,\\ldots,e_{d_I})</span>  the standard basis for the quotient space  <span class="math">\\mathbb{K}[x_1,\\ldots,x_n]/I</span> , the <strong>multiplication matrix</strong>  <span class="math">T_j</span>  of  <span class="math">x_j</span>  is defined by the square matrix whose i-th vector is represented by the coefficients of the monomials of the basis  <span class="math">B_I</span>  contained in the reduction of  <span class="math">x_je_i</span>  modulo the Gröbner Basis G.</p>

    <p class="text-gray-300">There is a strong connection between zero dimensional ideals, their quotient space and their variety. In particular, for zero dimensional ideals, the number of solutions to an equation system equals the dimension of the quotient space (counted with multiplicities). Counting the number of solutions or finding a good bound on it could be a difficult problem.</p>

    <h2 id="sec-7" class="text-2xl font-bold">3 Gröbner Basis Cryptanalysis</h2>

    <p class="text-gray-300">In Gröbner basis (GB) cryptanalysis a cryptographic primitive is represented as a system  <span class="math">\\mathcal{F}</span>  of polynomial equations with a certain number of variables. Depending on the primitive description, different approaches can be taken towards constructing the polynomial system. For finding solutions to that system, the Gröbner basis method is applied. Since cryptographic primitives are typically</p>

    <p class="text-gray-300">function with fixed input (and output) length constructed over a finite field K, the polynomial system representing such a primitive will always have a finite number of solutions in K. In algebraic geometry language this result in zerodimensional ideals. Solving system of polynomials with GB means finding at least one solution to the problem. This is usually divided into three main computations:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1) A GB G of the ideal I = ⟨F ⟩ is computed with respect to a chosen monomial ordering (usually Degree Reverse Lexicographic) using one of the known algorithms, e.g. F4 [\\[21\\]](#page-35-4), F5 [\\[18\\]](#page-35-5) etc. We will denote the complexity of this part CGB.</li>

      <li>2) One or more univariate polynomials are obtained towards solving the system of polynomials in G. The complexity of this computation is denoted as Cunivar.</li>

      <li>3) Factorize that univariate polynomial by using an off-the-shelf polynomial factoring algorithm to find at least one root (solution) of that representative variable. The complexity of this part is denoted as Croot.</li>

    </ul>

    <h2 id="sec-8" class="text-2xl font-bold">3.1 Complexity of GB cryptanalysis</h2>

    <p class="text-gray-300">The complexity of a GB cryptanalysis depends on the 3 computations described above: finding a Gröbner basis G≺, obtaining a univariate polynomial in GB, and factorizing or root finding of a univariate polynomial from GLEX.</p>

    <p class="text-gray-300">Computing a Gröbner basis Determining the complexity of GB computation, particularly providing a good theoretical bound is a non-trivial task in the context of GB cryptanalysis. Only a good theoretical bound on CGB can be relied upon to compute the security parameter(s) based on this part of the GB cryptanalysis. The generic Macaulay bound<a href="#page-8-0">2</a> is a function of the solving degree dsolv which is the maximum degree reached during the GB computation. This bound does not take any structure of the underlying polynomials into account. In Section <a href="#page-17-1">6.1</a> we provide a more concrete bound on the complexity of computing GB corresponding to the ideal generated by the Anemoi polynomial system.</p>

    <p class="text-gray-300">Obtaining a univariate polynomial We briefly discuss the two main ways to obtain a univariate polynomial e.g. FGLM and Eigenvalue method. Further details on this part in the cryptanalysis of Anemoi are provided in Section <a href="#page-17-1">6.1.</a></p>

    <p class="text-gray-300">FGLM The common way of computing the univariate polynomial, which can be used to obtain the variety of the ideal, is to convert GDRL to GLEX. Owing to the zero-dimensional ideal, one of the equations in GLEX is univariate. From it, we can perform the third step and obtain the variety of the original ideal. For zero dimensional ideals, the change of monomial order is typically done by using the FGLM algorithm [\\[19\\]](#page-35-6) which has complexity O(n<sup>v</sup> · d 3 I ) operations in K, where</p>

    <p class="text-gray-300"><span id="page-8-0"></span><sup>2</sup> we ignore the expression as it is not necessary to follow our result.</p>

    <p class="text-gray-300"> <span class="math">n_v</span>  is the number of variables in R and  <span class="math">d_I = dim_{\\mathbb{K}}(R/I)</span>  is the dimension of the quotient ring R/I. By using fast linear algebra and taking into account that our polynomials are sparse, the bound can be improved to a runtime complexity of  <span class="math">\\mathcal{O}(n_v \\cdot d_I^{\\omega} \\log(d_I))</span>  operation in  <span class="math">\\mathbb{K}</span>  [20], where  <span class="math">\\omega</span>  is the linear algebra constant which theoretically is bounded by  <span class="math">2 \\leq \\omega \\leq 2.3727</span>  [43], but practically the best known procedure is the Strassen algorithm which sets the value of  <span class="math">\\omega</span>  to 2.8074.</p>

    <p class="text-gray-300"><strong>Eigenvalue method</strong> However, the eigenvalue method, which exploits the multiplication matrices of the target variables, can be used instead of FGLM. This method avoids converting Gröbner basis w.r.t monomial ordering, and it is derived from the following result (also known as Stickelberger Theorem) [15, Chapter 2.4].</p>

    <p class="text-gray-300"><strong>Theorem 2.</strong> Let  <span class="math">\\overline{\\mathbb{K}}</span>  be the algebraic closure of the field  <span class="math">\\mathbb{K}</span>  and  <span class="math">I \\subset \\overline{\\mathbb{K}}[x_1, \\ldots, x_n]</span>  be a zero-dimensional ideal. For each  <span class="math">i = 1, \\ldots, n</span>  and any  <span class="math">\\lambda \\in \\overline{\\mathbb{K}}</span> , the value  <span class="math">\\lambda</span>  is an eigenvalue of the endomorphism  <span class="math">T_i</span>  if and only if there exist a point  <span class="math">a \\in \\mathbb{V}(I)</span>  with  <span class="math">a_i = \\lambda</span> .</p>

    <p class="text-gray-300"><span id="page-9-0"></span><strong>Corollary 1.</strong> Let  <span class="math">\\overline{\\mathbb{K}}</span>  be an algebraically closed finite field, I be a zero dimensional ideal in  <span class="math">\\overline{\\mathbb{K}}[x_1, x_2, \\ldots, x_n]</span> ,  <span class="math">\\prec</span>  a valid monomial order and  <span class="math">T_i</span>  the multiplication matrix of the variable  <span class="math">x_i</span>  with respect to  <span class="math">\\prec</span> . The set of solutions for  <span class="math">x_i</span>  is described by the roots of the minimal univariate polynomial in  <span class="math">x_i</span>  defined by  <span class="math">\\det(x_i \\mathbf{I}_{d_I} - T_i) \\in I</span> , where  <span class="math">\\mathbf{I}</span>  is the identity matrix.</p>

    <p class="text-gray-300">Remark 1. In this context we note that in [3], the authors provide a similar result to Corollary 1 without requiring closure of  <span class="math">\\mathbb{K}</span> . Note that a solution to  <span class="math">\\det(x_i\\mathbf{I}_{d_I}-T_i)</span>  can not be guaranteed without considering the polynomial in the closure of  <span class="math">\\mathbb{K}</span> . Indeed, in GB cryptanalysis it can happen that the derived univariate polynomial does not have any solution in the finite field  <span class="math">\\mathbb{K}</span> .</p>

    <p class="text-gray-300">Let  <span class="math">x_i</span>  be the target variable for which we want to obtain a univariate polynomial, and let  <span class="math">T_i</span>  be the associated multiplication matrix defined as in Definition 12. The corresponding univariate polynomial can be defined by computing  <span class="math">\\det(x_i\\mathbf{I}_{d_I}-T_i)</span> , whose roots, by Corollary 1, are the possible values for  <span class="math">x_i</span>  and the solutions we are interested in. The computation of the determinant i.e. the univariate polynomial has complexity  <span class="math">\\mathcal{O}(d_I^{\\omega}[s])</span>  operations in  <span class="math">\\mathbb{K}</span>  using the algorithm by Labahn et al. [30]. Here, s denotes the mean of the column degrees, that is the mean of the maximum degrees (of the polynomials) within each column.</p>

    <p class="text-gray-300">FACTORING POLYNOMIALS OR FINDING ROOTS To factorize polynomials we can choose one of the off-the-shelf algorithms such as the Kaltofen-Shoup algorithm [27] whose probabilistic version has a runtime complexity of  <span class="math">\\mathcal{O}(d^{1.815}\\log(q))</span>  field operations, where d is the degree of the univariate polynomial h we have obtained from the previous step and q is the field characteristic. Due to the fact that we are dealing with zero-dimensional ideals, the degree of the univariate polynomial will be equal to the dimension of the quotient space R/I:  <span class="math">\\deg(h) = d_I</span> .</p>

    <h2 id="sec-9" class="text-2xl font-bold">4 Polynomial Representation of Anemoi</h2>

    <p class="text-gray-300">Our analysis considers the odd characteristic case, i.e. when q=p is an odd prime. In this section, we firstly provide a brief description of Anemoi over field of odd characteristic, then we describe the polynomial representation of Anemoi for  <span class="math">l \\geq 1</span> , where l is the number of non-linear transformations at each round. This polynomial representation (or modelling) has an important role in our GB cryptanalysis. We refer to [7] for a more detailed description of the Anemoi permutation.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">4.1 Anemoi in odd characteristic</h4>

    <p class="text-gray-300">We only provide a brief description of the main components of Anemoi that are important to follow our GB cryptanalysis. More details can be found in Appendix B.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Linear Layer: The Anemoi state consists of 2l elements  <span class="math">(X,Y) \\in \\mathbb{F}_q^l \\times \\mathbb{F}_q^l</span>  where  <span class="math">l \\geq 1</span> . After constant addition to the state, linear transformations  <span class="math">M_l</span>  and  <span class="math">M_l \\circ \\rho</span>  (where  <span class="math">\\rho</span>  is a linear permutation) are applied to the two halves X and Y respectively. On this output a pseudo-hadamard transform denoted as P is applied to the vector (X,Y).</li>

      <li>Non-linear layer: Let  <span class="math">Q_{\\gamma}: \\mathbb{F}_q \\to \\mathbb{F}_q</span> ,  <span class="math">Q_{\\delta}: \\mathbb{F}_q \\to \\mathbb{F}_q</span>  be quadratic polynomials and let  <span class="math">E: \\mathbb{F}_q \\to \\mathbb{F}_q</span>  be a power map inducing the low-degree permutation over  <span class="math">\\mathbb{F}_q</span> , that is  <span class="math">E=x^{\\alpha}</span>  with  <span class="math">\\alpha \\geq 3</span>  coprime with  <span class="math">\\varphi(q)</span> . The non-linear layer is a so-called open Flystel, denoted as H, applied component-wise to X and Y (Figure 1 shows both open Flystel and closed Flystel, an equivalent representation also denoted as verification phase).  <span class="math">Q_{\\gamma}</span>  and  <span class="math">Q_{\\delta}</span>  are defined as follows:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">Q_{\\gamma} = \\beta x^2 + \\gamma \\qquad Q_{\\delta} = \\beta x^2 + \\delta</span></div>

    <p class="text-gray-300">where common values for  <span class="math">\\beta, \\gamma</span>  and  <span class="math">\\delta</span>  are respectively g (generator of the multiplicative subgroup of the field  <span class="math">\\mathbb{F}_q</span> ), 0 and  <span class="math">g^{-1} \\mod q</span> .</p>

    <p class="text-gray-300">Previous works introduced two main models to describe the Anemoi function. In particular, [7] proposed two models:  <span class="math">F_{\\rm CICO}</span>  which represents each round with two equations whose unknowns are the inputs of the main function and  <span class="math">P_{\\rm CICO}</span>  which represents each round with a single equation. [7] shows the analysis of  <span class="math">F_{\\rm CICO}</span> , whilst [29] recently shows the security analysis of  <span class="math">P_{\\rm CICO}</span>  and its differences with respect to the first one. Although, those models were not extended to more than 2 branches. To enhance the GB analysis to more than 2 branches, we propose a new model which we denote as  <span class="math">A_{\\rm CICO}</span> .</p>

    <p class="text-gray-300">A variable x involved in the modelling is indexed as  <span class="math">x_{i,j}</span>  where i and j correspond to branch number and round number respectively. For ease of notation we use  <span class="math">\\mathbf{x}_a</span>  to denote all the variables  <span class="math">x_{i,a}</span>  for  <span class="math">1 \\le i \\le l</span>  from round a. Moreover, we use  <span class="math">\\deg(\\mathbf{x}_a) = \\{\\deg(x_{1,a}), \\ldots, \\deg(x_{l,a})\\}</span>  to identify the degrees of the variables  <span class="math">\\mathbf{x}_a</span> .</p>

    <p class="text-gray-300"><span id="page-11-0"></span><img src="_page_11_Picture_2.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">Fig. 1: Flystel evaluation (left) and verification (right) circuit representations in Anemoi</p>

    <p class="text-gray-300">The so-called CICO (Constrained Input Constrained Output) problem in algebraic modelling and analysis of cryptographic primitives is given as follows.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 13 (CICO problem).</strong> Let  <span class="math">F: \\mathbb{F}_q^t \\to \\mathbb{F}_q^t</span>  be a function and let u < t be an integer. The CICO problem consists of finding  <span class="math">x, y \\in \\mathbb{F}_q^u</span>  such that F(x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0) = (y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For Anemoi , [7] suggests fixing the first l inputs and outputs to zero. Therefore, the CICO problem for Anemoi is represented by</p>

    <p class="text-gray-300"><span id="page-11-2"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$Anemoi(0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{y}_0) = (0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{y}_{out}) \\tag{1}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and we aim to find values for the variables  <span class="math">\\mathbf{y}_0</span> . In the following section, we describe our model  <span class="math">A_{\\text{CICO}}</span>  for  <span class="math">l \\geq 1</span> .</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">4.2 ACICO model</h4>

    <p class="text-gray-300">Let  <span class="math">(\\mathbf{x}_0, \\mathbf{y}_0) = (x_{1,0}, \\dots, x_{l,0}, y_{1,0}, \\dots, y_{l,0})</span>  be the inputs to the Anemoi permutation and  <span class="math">(\\mathbf{x}_{r-1}, \\mathbf{y}_{r-1}) = (x_{1,r-1}, \\dots, x_{l,r-1}, y_{1,r-1}, \\dots, y_{l,r-1})</span>  be the inputs to the r-th round for  <span class="math">1 \\leq r \\leq N</span> . Moreover, let  <span class="math">s_{i,r}</span>  for  <span class="math">1 \\leq i \\leq l</span>  model the input to the function E within the Flystel verification as shown in Figure 1.</p>

    <p class="text-gray-300">For ease of notation, we denote as  <span class="math">\\mathcal{L}_r</span>  the application of the Anemoi linear layer at round r. In particular</p>

    <p class="text-gray-300"><span id="page-11-1"></span> <span class="math-block">\\begin{bmatrix} \\mathbf{L}_{r}^{(1)} \\\\ \\mathbf{L}_{r}^{(2)} \\end{bmatrix} = \\mathcal{L}_{r}(\\mathbf{x}, \\mathbf{y}) := \\begin{bmatrix} 2 &amp; 1 \\\\ 1 &amp; 1 \\end{bmatrix} \\begin{pmatrix} M_{l} \\begin{bmatrix} x_{1,r-1} + c_{1,r-1} &amp; y_{2,r-1} + c_{2,r-1} \\\\ \\dots &amp; \\dots \\\\ x_{l-1,r-1} + c_{l-1,r-1} &amp; y_{l,r-1} + c_{l,r-1} \\\\ x_{l,r-1} + c_{l,r-1} &amp; y_{1,r-1} + c_{1,r-1} \\end{bmatrix} \\end{pmatrix}^{T}</span> (2)</p>

    <p class="text-gray-300">where  <span class="math">c_i</span>  and  <span class="math">d_i</span>  are the round constants. Note that the  <span class="math">\\mathbf{y} + \\mathbf{c}</span>  in Equation (2) is written as the output of  <span class="math">\\rho(\\mathbf{y} + \\mathbf{c})</span> . Furthermore, we use  <span class="math">L_{i,r}^{(j)}</span>  to denote the <em>i</em>-th entry of the <em>j</em>-th vector of the output matrix generated by the application of the linear layer at the round r. Sometimes, when we want to specify what are the inputs to the linear layer  <span class="math">\\mathcal{L}</span>  and then, what are the variables which the output depends on, we use  <span class="math">\\mathcal{L}_{i,r}^{(j)}(\\mathbf{x},\\mathbf{y}) = L_{i,r}^{(j)}</span> .</p>

    <p class="text-gray-300"><strong>Polynomial representation</strong> We can define the following functions for every  <span class="math">1 \\le r \\le N</span> :</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let  <span class="math">L_{i,r}^{(2)}</span>  and  <span class="math">y_{i,r}</span>  be the inputs to the non-linear verification layer V in the r-th round. Notice that this operation is performed for each couple  <span class="math">(L_{i,r}^{(2)}, y_{i,r})</span>  for  <span class="math">1 \\leq i \\leq l</span> . It outputs  <span class="math">L_{i,r}^{(1)}, x_{i,r}</span>  where:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{bmatrix} L_{i,r}^{(1)} \\\\ x_{i,r} \\end{bmatrix} := V(L_{i,r}^{(2)}, y_{i,r}) = \\begin{bmatrix} Q_{\\gamma}(L_{i,r}^{(2)}) + E(s_{i,r}) \\\\ Q_{\\delta}(y_{i,r}) + E(s_{i,r}) \\end{bmatrix}</span></div>

    <p class="text-gray-300">By that definition:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for r = 1 and  <span class="math">1 \\le i \\le l</span> ,  <span class="math">L_{i,1}^{(2)} \\in \\mathbb{F}_q[\\mathbf{x}_0, \\mathbf{y}_0]</span> ,  <span class="math">x_{i,1} \\in \\mathbb{F}_q[y_{i,1}, s_{i,1}]</span>  and  <span class="math">L_{i,1}^{(1)} \\in \\mathbb{F}_q[\\mathbf{x}_0, \\mathbf{y}_0, s_{i,r}]</span></li>

      <li>for  <span class="math">1 &lt; r \\le N</span>  and  <span class="math">1 \\le i \\le l</span> ,  <span class="math">L_{i,r}^{(2)} \\in \\mathbb{F}_q[\\mathbf{x}_{r-1}, \\mathbf{y}_{r-1}, \\mathbf{s}_{r-1}], x_{i,r} \\in \\mathbb{F}_q[y_{i,r}, s_{i,r}]</span> and  <span class="math">L_{i,r}^{(1)} \\in \\mathbb{F}_q[\\mathbf{x}_{r-1}, \\mathbf{y}_{r-1}, \\mathbf{s}_{r-1}, s_{i,r}]</span></li>

    </ul>

    <p class="text-gray-300">By applying the input constraint, that is setting  <span class="math">x_{i,0} = 0</span>  for all  <span class="math">1 \\le i \\le l</span> , we get the first family of polynomials:</p>

    <p class="text-gray-300"><span id="page-12-3"></span> <span class="math-block">a_{i,1} := \\mathcal{L}_{i,1}^{(1)}(\\mathbf{0}, \\mathbf{y}_0) - Q_{\\gamma}\\left(\\mathcal{L}_{i,1}^{(2)}(\\mathbf{0}, \\mathbf{y}_0)\\right) - s_{i,1}^{\\alpha}, \\text{ where } 1 \\le i \\le l.</span>  (3)</p>

    <p class="text-gray-300">Assuming  <span class="math">m_{i,r} := Q_{\\delta}(y_{i,r-1}) + E(s_{i,r-1})</span> , we get</p>

    <p class="text-gray-300"><span id="page-12-0"></span> <span class="math-block">a_{i,r} := \\mathcal{L}_{i,r}^{(1)}(\\mathbf{m}_r, \\mathbf{y}_{r-1}) - Q_{\\gamma} \\left( \\mathcal{L}_{i,r}^{(2)}(\\mathbf{m}_r, \\mathbf{y}_{r-1}) \\right) - s_{i,r}^{\\alpha}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\tag{4}</span></div>

    <p class="text-gray-300">where  <span class="math">1 \\le i \\le l</span>  and  <span class="math">1 &lt; r \\le N</span> . Thus we have  <span class="math">\\deg(a_{i,1}) = \\alpha</span> . Since  <span class="math">\\deg(m_{i,r}) = \\alpha</span>  and  <span class="math">\\mathcal{L}_{i,r}</span>  is a linear function we have</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{deg}(a_{i,r}) = \\max\\{\\mathsf{deg}(\\mathbf{m}_r), \\mathsf{deg}(\\mathbf{m}_r)^2, \\mathsf{deg}(s_{i,r-1})^{\\alpha}\\} = 2\\alpha</span></div>

    <p class="text-gray-300">Additionally, for each round, from the relations of the variables  <span class="math">\\mathbf{y}_{r-1}</span> ,  <span class="math">y_{i,r}</span>  and  <span class="math">s_{i,r}</span>  we get</p>

    <p class="text-gray-300"><span id="page-12-2"></span> <span class="math-block">b_{i,1} := \\mathcal{L}_{i,1}^{(2)}(\\mathbf{0}, \\mathbf{y}_0) - y_{i,1} - s_{i,1}, \\text{ for } r = 1</span>  (5)</p>

    <p class="text-gray-300"><span id="page-12-1"></span> <span class="math-block">b_{i,r} := \\mathcal{L}_{i,r}^{(2)}(\\mathbf{m}_r, \\mathbf{y}_{r-1}) - y_{i,r} - s_{i,r}, \\text{ for } 1 &lt; r \\le N</span> (6)</p>

    <p class="text-gray-300">From the above two equations it is clear that  <span class="math">deg(b_{i,1}) = 1</span> , and  <span class="math">deg(b_{i,r}) = \\max\\{\\alpha, 1\\} = \\alpha</span> . Thus, we obtain 2l polynomials per round given by  <span class="math">a_{i,r}, b_{i,r}</span>  (for  <span class="math">1 \\le i \\le l</span> ) i.e. 2Nl equations overall. At the end, after the last rounds, the linear transformation  <span class="math">\\mathcal{L}</span>  is applied. This leads to l equations of the form:</p>

    <p class="text-gray-300"><span id="page-13-1"></span> <span class="math-block">f_{i,N+1} := \\mathcal{L}_{i,N}^{(1)}(\\mathbf{m}_{N+1}, \\mathbf{y}_N)</span>  (7)</p>

    <p class="text-gray-300">which are equal to zero due to constrained output and  <span class="math">deg(f_{i,N+1}) = \\alpha</span> .</p>

    <p class="text-gray-300"><strong>Definition 14 (ACICO model for</strong>  <span class="math">l \\geq 1</span> ). An algebraic model of the Anemoi permutation  <span class="math">A_{\\pi}: \\mathbb{F}_q^{2l} \\to \\mathbb{F}_q^{2l}</span>  applied for N rounds, under the CICO constraints in Equation (1), is given by the system</p>

    <div class="my-4 text-center"><span class="math-block">A_{\\text{CICO}} = \\{a_1, \\dots, a_N, b_1, \\dots, b_N, f_{N+1}\\}</span></div>

    <p class="text-gray-300">where  <span class="math">A_{\\text{CICO}} \\subset \\mathbb{F}_q[\\boldsymbol{y}_0, \\dots \\boldsymbol{y}_N, \\boldsymbol{s}_1, \\dots, \\boldsymbol{s}_N]</span>  and  <span class="math">a_{i,r}</span> ,  <span class="math">b_{i,r}</span> ,  <span class="math">f_{i,N+1}</span>  are as defined in Equations (4), (6) and (7) respectively. The generated system contains l(2N+1) equations in l(2N+1) variables.</p>

    <p class="text-gray-300"><strong>Degrees of polynomials</strong> For GB analysis with ACICO model, we require the degrees of the polynomials in  <span class="math">A_{\\rm CICO}</span> , that are as follows</p>

    <div class="my-4 text-center"><span class="math-block">\\deg(a_{i,1}) = \\alpha, \\deg(b_{i,1}) = 1, \\deg(f_{i,N+1}) = \\alpha \\tag{8}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\deg(a_{i,r}) = 2\\alpha, \\deg(b_{i,r}) = \\alpha \\tag{9}</span></div>

    <p class="text-gray-300">for  <span class="math">1 \\le i \\le l</span>  and  <span class="math">1 &lt; r \\le N</span> .</p>

    <p class="text-gray-300">As pointed out in Section 3, current literature says that FGLM generates a LEX Gröbner basis in Shape form under certain assumptions, such as the radicality. Having a shape form would be useful to easily determine the variety of the ideal. As far from our knowledge, all the algebraic cryptanalysis done so far, blindly applied the FGLM algorithm, searching for this advantageous structure. In this section we are going to prove the Shape form for a constrained system generating a zero-dimensional ideal, while in Section 6.2 we use that result to prove the Shape form of the ideal  <span class="math">I = \\langle A_{\\text{CICO}} \\rangle</span>  corresponding to Anemoi. In particular, throughout the section, we will consider systems whose polynomials are of the form  <span class="math">f_i := c_i x_i^{\\alpha_i} + q_i(x_1, \\dots, x_n)</span>  where  <span class="math">\\deg_{\\prec}(q_i) &lt; \\deg_{\\prec}(\\mathsf{LM}(f_i))</span>  w.r.t. a generic monomial ordering  <span class="math">\\prec</span> . We will use  <span class="math">\\deg_{\\prec}(x^{\\beta})</span>  to denote the degree of  <span class="math">x^{\\beta}</span>  w.r.t the monomial ordering  <span class="math">\\prec</span>  e.g. in a weighted monomial ordering, if  <span class="math">w_x = 2</span> ,  <span class="math">\\deg_{\\prec}(x^{\\beta}) = 2\\beta</span> .</p>

    <p class="text-gray-300">Some of the theorems taken from [15] are written with respect to  <span class="math">\\mathbb{C}</span> . Due to the fact that their proofs can be easily adapted to work with a generic algebraically closed field  <span class="math">\\overline{\\mathbb{K}}</span> , we present those theorems in terms of  <span class="math">\\overline{\\mathbb{K}}</span> . Moreover, we use Res to denote the resultant of the specified polynomials and  <span class="math">\\operatorname{Res}_{d_1,\\ldots,d_n}^x</span>  to denote the resultant, w.r.t the variable x, of the specified homogeneous polynomials whose degrees are  <span class="math">d_1,\\ldots,d_n</span>  respectively. To prove the shape form of the ideal, we will need the following results.</p>

    <h2 id="sec-13" class="text-2xl font-bold">5.1 Necessary results</h2>

    <p class="text-gray-300">Remark 2. Given a system of homogenous polynomials, the solutions at infinity  <span class="math">(\\infty)</span>  are the solutions of the system obtained by setting the homogenization variable to 0. If the obtained system does not have any other solutions than the trivial one (zero solution) we say that the system has no solutions at infinity.</p>

    <p class="text-gray-300"><span id="page-14-2"></span><strong>Theorem 3 ( [15, Chapter 3, §3, Theorem 3.4]).</strong> Given homogeneous polynomials  <span class="math">F_0, \\ldots, F_n \\in \\overline{\\mathbb{K}}[x_0, \\ldots, x_n]</span>  of degrees  <span class="math">d_0, \\ldots, d_n</span> , let</p>

    <div class="my-4 text-center"><span class="math-block">f_i(x_0, \\dots, x_{n-1}) = F_i(x_0, \\dots, x_{n-1}, 1)</span></div>

    <p class="text-gray-300"><span class="math-block">\\overline{F}_i(x_0, \\dots, x_{n-1}) = F_i(x_0, \\dots, x_{n-1}, 0).</span> (10)</p>

    <p class="text-gray-300">Note that  <span class="math">f_i</span>  is the dehomogenization by the variable  <span class="math">x_n = 1</span>  and  <span class="math">\\overline{F}_0, \\ldots, \\overline{F}_{n-1}</span>  are homogeneous polynomials in  <span class="math">\\overline{\\mathbb{K}}[x_0, \\ldots, x_{n-1}]</span>  of degrees  <span class="math">d_0, \\ldots, d_{n-1}</span> .</p>

    <p class="text-gray-300">If  <span class="math">\\operatorname{Res}(\\overline{F}_0,\\ldots,\\overline{F}_{n-1}) \\neq 0</span> , then the quotient ring  <span class="math">A := \\overline{\\mathbb{K}}[x_0,\\ldots,x_{n-1}]/I</span> , where  <span class="math">I := \\langle f_0,\\ldots,f_{n-1} \\rangle \\subset \\overline{\\mathbb{K}}[x_0,\\ldots,x_{n-1}]</span> , has dimension  <span class="math">d_0 \\cdots d_{n-1}</span>  as a vector space over  <span class="math">\\overline{\\mathbb{K}}</span>  and</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Res}(F_0,\\ldots,F_n) = \\operatorname{Res}(\\overline{F}_0,\\ldots,\\overline{F}_{n-1})^{d_n} \\det(m_{f_n}),</span></div>

    <p class="text-gray-300">where  <span class="math">m_{f_n}: A \\to A</span>  is the linear map given by the multiplication by  <span class="math">f_n</span> .</p>

    <p class="text-gray-300"><span id="page-14-0"></span><strong>Theorem 4.</strong> Let  <span class="math">I \\subset \\mathbb{K}[x_1,\\ldots,x_n]</span>  be a zero-dimensional ideal and let G be its Gröbner basis (w.r.t. a generic monomial order  <span class="math">\\prec</span> ) which contains elements  <span class="math">f_i</span>  such that  <span class="math">\\mathsf{LM}(f_i) = x_i^{\\alpha_i}</span>  for each  <span class="math">1 \\leq i \\leq n</span> . If  <span class="math">f_i := x_i^{\\alpha_i} + Q_i(x_1,\\ldots,x_n)</span>  and  <span class="math">\\deg_{\\prec}(Q_i) &lt; \\deg_{\\prec}(x_i^{\\alpha_i})</span> , then the ideal I has no solutions at infinity except the trivial solution, that is  <span class="math">\\mathbf{0}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">s, n \\in \\mathbb{N}</span>  and  <span class="math">s \\geq n</span> . Let  <span class="math">I := \\langle f_1, \\ldots, f_s \\rangle \\subset \\mathbb{K}[x_1, \\ldots, x_n]</span>  where  <span class="math">f_i := x_i^{\\alpha_i} + Q_i(x_1, \\ldots, x_n)</span>  and  <span class="math">\\deg_{\\prec}(Q_i) &lt; \\deg_{\\prec}(x_i^{\\alpha_i})</span>  for each  <span class="math">1 \\leq i \\leq n</span> . It is, by Lemma 14, a zero-dimensional ideal.</p>

    <p class="text-gray-300">For each  <span class="math">1 \\leq i \\leq n</span> , compute  <span class="math">f_i^H</span>  that is the homogenization of  <span class="math">f_i</span>  with respect to a homogenization variable  <span class="math">x_0</span>  whose generic weight is  <span class="math">w_{x_0} = 1</span>  (recall that every monomial ordering can be expressed as a weighted monomial order). By definition, elements of  <span class="math">\\mathbb{V}(f_1^H,\\ldots,f_n^H)</span>  with  <span class="math">x_0=0</span>  are called solutions at  <span class="math">\\infty</span>  of  <span class="math">f_1=f_2=\\cdots=f_n=0</span> .</p>

    <div class="my-4 text-center"><span class="math-block">f_i^H := x_i^{\\alpha_i} + x_0^{\\alpha_i w_{x_i}} Q\\left(\\frac{x_1}{x_0^{w_{x_1}}}, \\dots, \\frac{x_n}{x_0^{w_{x_n}}}\\right).</span></div>

    <p class="text-gray-300">Due to the fact that each monomial in Q has degree (w.r.t  <span class="math">\\prec</span> ) strictly less than  <span class="math">\\alpha_i</span> , all those monomials will be of the form  <span class="math">x_0^e \\prod_{i=1}^n x_i^{\\beta_i}</span>  where e > 0 and  <span class="math">ew_{x_0} + \\sum_{j=1}^n (\\beta_j w_{x_j}) = \\alpha_i w_{x_i}</span> . By setting  <span class="math">x_0 = 0</span> , the equations  <span class="math">f_i^H</span>  become of the form</p>

    <div class="my-4 text-center"><span class="math-block">f_i^H(x_0 = 0) := x_i^{\\alpha_i} = 0</span></div>

    <p class="text-gray-300"><span id="page-14-1"></span>for  <span class="math">1 \\le i \\le n</span> . The unique solution to this system is the trivial one where  <span class="math">x_i = 0</span>  for each  <span class="math">1 \\le i \\le n</span> . Hence, we conclude that the system has no solutions at  <span class="math">\\infty</span>  except the trivial one (the zero solution).</p>

    <p class="text-gray-300"><strong>Theorem 5 ( [15, Chapter 3, §2, Theorem 2.3]).</strong> If we fix positive degrees  <span class="math">d_0, \\ldots, d_n</span> , then there is a unique polynomial  <span class="math">\\text{Res} \\in \\mathbb{Z}[u_{i,a}]</span>  which has the following properties:</p>

    <p class="text-gray-300">a. If  <span class="math">f_0^H, \\ldots, f_n^H \\in \\overline{\\mathbb{K}}[x_1, \\ldots, x_n]</span>  are homogeneous of degrees  <span class="math">d_0, \\ldots, d_n</span> , then the equations</p>

    <div class="my-4 text-center"><span class="math-block">f_0^H(x_0, x_1, \\dots, x_n) = f_1^H(x_0, x_1, \\dots, x_n) = \\dots, f_n^H(x_0, x_1, \\dots, x_n) = 0</span></div>

    <p class="text-gray-300">have a non-trivial solution over  <span class="math">\\overline{\\mathbb{K}}</span>  if and only if  <span class="math">\\operatorname{Res}(f_0^H,\\ldots,f_n^H)=0</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>b.  <span class="math">\\operatorname{Res}(x_0^{d_0}, x_1^{d_1}, \\dots, x_n^{d_n}) = 1.</span></li>

      <li>c. Res is irreducible, even when regarded as a polynomial in  <span class="math">\\overline{\\mathbb{K}}[u_{i,a}]</span> .</li>

    </ul>

    <p class="text-gray-300">Now, given a set of n polynomials  <span class="math">f_i</span>  defined as in Theorem 4. Compute their homogenization  <span class="math">f_i^H</span>  and denote as</p>

    <p class="text-gray-300"><span class="math-block">\\overline{f}_i(x_1, \\dots, x_n) = f_i^H(1, x_1, \\dots, x_n) = f_i \\overline{F}_i(x_1, \\dots, x_n) = f_i^H(0, x_1, \\dots, x_n).</span> (11)</p>

    <p class="text-gray-300"><span id="page-15-0"></span>In particular,  <span class="math">\\overline{f}_i(x_1,\\ldots,x_n)</span>  denotes the dehomogenization of  <span class="math">f_i^H</span>  by setting  <span class="math">x_0=1</span>  and  <span class="math">\\overline{F}_i(x_1,\\ldots,x_n)</span>  denotes the equations obtained by setting  <span class="math">x_0=0</span> . Note that each  <span class="math">f_i</span>  has total degree  <span class="math">\\alpha_i</span>  due to our construction. Moreover, due to the fact that we are considering homogeneous polynomials, we are working in the projective space  <span class="math">\\mathbb{P}^n</span> . Inside  <span class="math">\\mathbb{P}^n</span>  we have the affine space  <span class="math">\\overline{\\mathbb{K}}^n \\subset \\mathbb{P}^n</span>  (the algebraic closure of  <span class="math">\\mathbb{K}</span> ) defined by  <span class="math">x_0=1</span>  and the solutions of the affine equations</p>

    <div class="my-4 text-center"><span class="math-block">\\overline{f}_1 = \\overline{f}_2 = \\dots = \\overline{f}_n = 0</span></div>

    <p class="text-gray-300">are the solutions which lie in  <span class="math">\\overline{\\mathbb{K}}</span> . Similarly, the nontrivial solutions of the homogeneous equations</p>

    <div class="my-4 text-center"><span class="math-block">\\overline{F}_1 = \\overline{F}_2 = \\dots = \\overline{F}_n = 0</span></div>

    <p class="text-gray-300">are the solutions at  <span class="math">\\infty</span> . From Theorem 4, we know that our system has no nontrivial solutions at  <span class="math">\\infty</span> . By Theorem 5, this is equivalent to the condition</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Res}(\\overline{F}_1, \\overline{F}_2, \\dots, \\overline{F}_n) \\neq 0.</span></div>

    <p class="text-gray-300">Therefore, by Theorem 3, we conclude a well-known result for algebraically closed fields and zero-dimensional ideals, the Bézout's theorem.</p>

    <p class="text-gray-300">Theorem 6 ([15, Chapter 3, §5, Theorem 5.5, Exercise 6]). Assume we have defined equations as in Equation (11). Moreover, assume that our system has no solutions at  <span class="math">\\infty</span> . Then, these equations have  <span class="math">\\alpha_1 \\cdots \\alpha_n</span>  solutions (counted with multiplicities) and the quotient ring  <span class="math">A := \\overline{\\mathbb{K}}[x_1, \\ldots, x_n]/I</span> , where  <span class="math">I := \\langle f_1, \\ldots, f_n \\rangle \\subset \\mathbb{K}[x_1, \\ldots, x_n]</span>  is the ideal defined by the considered equations, has dimension  <span class="math">\\alpha_1 \\cdots \\alpha_n</span>  as a vector space over  <span class="math">\\overline{\\mathbb{K}}</span> . More generically, these solutions are also distinct.</p>

    <p class="text-gray-300">Theorem 3 can be rewritten by changing the homogenization variable. Indeed, we can modify it by considering  <span class="math">x_0</span>  as the homogenization variable.</p>

    <p class="text-gray-300">The next step of the proof path is to show how the resultant is linked with the determinant of the multiplication matrix, meaning the mapping  <span class="math">m_f</span> . The hidden variable technique is a method for solving polynomial systems through resultants. In particular, the main result of this method follows.</p>

    <p class="text-gray-300"><strong>Proposition 1</strong> ( [15, Chapter 3, §5, Proposition 5.15]). Generically,  <span class="math">\\operatorname{Res}_{d_1,\\ldots,d_n}^{x_n}(f_1,\\ldots f_n)</span>  is a polynomial in  <span class="math">x_n</span>  whose roots are the  <span class="math">x_n</span> -coordinates of the solutions of</p>

    <p class="text-gray-300"><span id="page-16-0"></span> <span class="math-block">f_1 = f_2 = \\dots = f_n = 0.</span></p>

    <p class="text-gray-300">Moreover, by [15, Chapter 3, §4, Theorem 4.9, Proposition 4.6] and Proposition 1:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{Res}_{d_1,\\ldots,d_n}^{x_n}(f_1,\\ldots f_n) = \\pm \\frac{\\hat{D}_0}{\\hat{D}_0&#x27;}</span></div>

    <p class="text-gray-300">where  <span class="math">x_n</span>  is the target variable for which we want to find solutions,  <span class="math">\\hat{D}_0</span>  is the determinant of the coefficient matrix and  <span class="math">\\hat{D}&#x27;_0</span>  doesn't involve  <span class="math">x_n</span> , meaning that it is a <em>scalar</em> value. For our purposes, finding solutions for the variable  <span class="math">x_n</span> ,  <span class="math">\\hat{D}&#x27;_0</span>  can be ignored due to the fact that we just need to factor  <span class="math">\\hat{D}_0</span>  to find the desired values.</p>

    <p class="text-gray-300">Now, let us call  <span class="math">\\hat{M}_0</span>  the coefficient matrix whose determinant is  <span class="math">\\hat{D}_0 = \\det(\\hat{M}_0)</span> . Since  <span class="math">\\hat{M}_0</span>  depends on the variable  <span class="math">x_n</span> , it can be written as</p>

    <div class="my-4 text-center"><span class="math-block">\\hat{M}_0 = A_0 + x_n A_1 + \\dots + x_n^l A_l</span></div>

    <p class="text-gray-300">where each  <span class="math">A_i</span>  has constant entries and  <span class="math">A_l \\neq \\mathbf{0}</span> . Suppose  <span class="math">A_i</span>  are matrices of dimension  <span class="math">m \\times m</span> , if  <span class="math">A_l</span>  is invertible we can define the generalized companion matrix:</p>

    <div class="my-4 text-center"><span class="math-block">C = \\begin{bmatrix} 0 &amp; I_m &amp; 0 &amp; \\dots &amp; 0 \\\\ 0 &amp; 0 &amp; I_m &amp; \\dots &amp; 0 \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; 0 &amp; \\dots &amp; I_m \\\\ -A_l^{-1}A_0 - A_l^{-1}A_1 &amp; \\dots &amp; -A_l^{-1}A_{l-1} \\end{bmatrix}</span></div>

    <p class="text-gray-300">where  <span class="math">I_m</span>  is the  <span class="math">m \\times m</span>  identity matrix. The eigenvalues of C are precisely the roots of the polynomial  <span class="math">\\det(\\hat{M}_0) = \\hat{D}_0</span> , as shown by [31, 32].</p>

    <p class="text-gray-300">In other words, let  <span class="math">x_n</span>  be the target variable and  <span class="math">f_1, \\ldots, f_n</span>  the considered equations, by [15, Chapter 2, Theorem 4.5, Corollary 4.6], by Theorem 3 and by [13, Section 3 and 4], the univariate polynomial (denoted as  <span class="math">p_1</span> ) defined by the determinant of the multiplication matrix  <span class="math">m_{x_n}</span>  and the one (denoted as  <span class="math">p_2</span> ) defined by the resultant of the considered equations with respect to the target variable are the same or they differ by a constant c:</p>

    <div class="my-4 text-center"><span class="math-block">p_1 = c \\cdot p_2.</span></div>

    <p class="text-gray-300">The ideal generated by  <span class="math">p_1</span>  is the elimination ideal  <span class="math">I \\cap \\mathbb{K}[x_n]</span> . As a consequence,  <span class="math">\\langle p_1 \\rangle = I \\cap \\mathbb{K}[x_n] = \\langle p_2 \\rangle</span> . Further details can be found in [15, Chapter 3, §6].</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">5.2 The shape lemma for constrained zero-dimensional ideals</h4>

    <p class="text-gray-300"><span id="page-17-2"></span><strong>Theorem 7 ([13, Theorem 1.2]).</strong> Let  <span class="math">I = \\langle f_1, \\ldots, f_n \\rangle</span>  be a zero-dimensional ideal such that the map  <span class="math">\\mathbb{V}(I) \\to \\mathbb{A}^1_{\\mathbb{K}}</span>  given by the projection onto the  <span class="math">n^{th}</span>  coordinate is injective as a map of sets. Then, any two of the following three conditions imply the third:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(1) I has Shape Lemma</li>

      <li>(2)  <span class="math">f_1, \\ldots, f_n</span>  have no solutions at  <span class="math">\\infty</span></li>

      <li>(3)  <span class="math">I \\cap \\mathbb{K}[x_n] = \\langle \\operatorname{Res}_{d_1, \\dots, d_n}^{x_n}(f_1, \\dots f_n) \\rangle</span></li>

    </ul>

    <p class="text-gray-300"><span id="page-17-4"></span><strong>Theorem 8.</strong> Let  <span class="math">I \\subset \\mathbb{K}[x_1,\\ldots,x_n]</span>  be a zero-dimensional ideal and let G be its Gröbner basis (w.r.t a generic monomial ordering  <span class="math">\\prec</span> ) which contains elements  <span class="math">f_i</span>  such that  <span class="math">\\mathsf{LM}(f_i) = x_i^{\\alpha_i}</span>  for each  <span class="math">1 \\leq i \\leq n</span> . If I has no solutions at  <span class="math">\\infty</span> , then the ideal I has a Shape Form in the reduced LEX Gröbner basis.</p>

    <p class="text-gray-300">Proof. In Section 5.1 we proved that a system of such kind satisfies the following property:</p>

    <div class="my-4 text-center"><span class="math-block">\\langle p_1 \\rangle = I \\cap \\mathbb{K}[x_n] = \\langle p_2 \\rangle = \\langle \\operatorname{Res}_{d_1, \\dots, d_n}^{x_n}(f_1, \\dots f_n) \\rangle</span></div>

    <p class="text-gray-300">From Theorem 7, conditions (2) and (3) imply condition (1). Therefore, I has Shape form.</p>

    <p class="text-gray-300">In this section we describe the Gröbner basis cryptanalysis of Anemoi. In particular, we will show what are the particular structures of the DRL and  <span class="math">W_{DRL}</span>  Gröbner basis generated by the  <span class="math">A_{\\rm CICO}</span>  polynomials and how we can avoid converting it to a LEX Gröbner basis to obtain a univariate polynomial. Indeed, we will present three methods to determine the univariate polynomial: FGLM and the computation of  <span class="math">\\det(x_i\\mathbf{I}_{d_I}-T_i)</span>  that were already presented in Subsection 3 and another one based on the Wiedemann algorithm. For each of them, we will show how to improve the complexity thanks to the  <span class="math">A_{\\rm CICO}</span>  model. At the end, we compare our results to previous ones.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">6.1 Gröbner basis for Anemoi</h4>

    <p class="text-gray-300">Here, we prove the structural properties of the polynomials in the GB of the ideal  <span class="math">\\langle A_{\\rm CICO} \\rangle</span>  w.r.t DRL and W<sub>DRL</sub> monomial orderings.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6"><strong>DRL</strong> Gröbner basis</h4>

    <p class="text-gray-300"><strong>Lemma 2.</strong> Given the list of l > 1 polynomials</p>

    <div class="my-4 text-center"><span class="math-block">b_{i,1} := \\mathcal{L}_{i,1}^{(2)}(\\boldsymbol{0}, \\boldsymbol{y}_0) - y_{i,1} - s_{i,1} \\in A_{\\text{CICO}}</span></div>

    <p class="text-gray-300">as defined in eq. (5) for  <span class="math">1 \\le i \\le l</span>  with respect to the DRL monomial ordering, generate the pairs as in Step 2 of the Algorithm 1 and compute the corresponding</p>

    <p class="text-gray-300">S-polynomials. Recursive application of the same procedure on the outputs leads to a stage when we obtain only one S-polynomial. As result of this process, we obtain a set of polynomials whose leading monomials are  <span class="math">y_{i,0}</span>  for  <span class="math">1 \\le i \\le l</span> . When l = 1, the unique polynomial  <span class="math">b_{1,1}</span>  is already in the desired form.</p>

    <p class="text-gray-300"><span id="page-18-1"></span><strong>Lemma 3.</strong> Fix r to be a round number such that  <span class="math">1 &lt; r \\le N</span> , given a list of l > 1 polynomials</p>

    <div class="my-4 text-center"><span class="math-block">b_{i,r} = \\mathcal{L}_{i,r}^{(2)}(\\mathbf{m}_r, \\mathbf{y}_{r-1}) - y_{i,r} - s_{i,r} \\in A_{\\text{CICO}}</span></div>

    <p class="text-gray-300">as defined in eq. (6) for  <span class="math">1 \\le i \\le l</span>  with respect to the DRL monomial ordering, generate the pairs as in Step 2 of the Algorithm 1 and compute the corresponding S-polynomials. We (recursively) apply the same procedure on the outputs until you get only one S-polynomial. As a result, we obtain a set of polynomials whose leading monomials are  <span class="math">s_{i,r-1}^{\\alpha}</span>  for  <span class="math">1 \\le i \\le l</span> . When l = 1, the unique polynomial  <span class="math">b_{1,r}</span>  is already in the desired form.</p>

    <p class="text-gray-300"><span id="page-18-0"></span><strong>Lemma 4.</strong> Given a list of l > 1 polynomials</p>

    <div class="my-4 text-center"><span class="math-block">f_{i,N+1} = \\mathcal{L}_{i,N}^{(1)}(m_{N+1}, y_N)</span></div>

    <p class="text-gray-300">as defined in eq. (7) for  <span class="math">1 \\le i \\le l</span>  with respect to the DRL monomial ordering, generate the pairs as in Step 2 of the Algorithm 1 and compute the corresponding S-polynomials. We (recursively) apply the same procedure on the outputs until you obtain only one S-polynomial. As a result, we obtain a set of polynomials whose leading monomials are  <span class="math">s_{i,N}^{\\alpha}</span>  for  <span class="math">1 \\le i \\le l</span> . When l = 1, the unique polynomial  <span class="math">f_{1,N+1}</span>  is already in the desired form.</p>

    <p class="text-gray-300"><span id="page-18-2"></span><strong>Lemma 5.</strong> After the application of Lemmas 2 to 4, the set of leading monomials of the polynomials in the set G, denoted as LM(G), is composed by:</p>

    <div class="my-4 text-center"><span class="math-block">\\{\\boldsymbol{y}_0, \\boldsymbol{s}_1^{\\alpha}, \\boldsymbol{s}_2^{\\alpha}, \\dots, \\boldsymbol{s}_N^{\\alpha} \\}.</span></div>

    <p class="text-gray-300">Let us denote as  <span class="math">f_{i,1}</span>  the polynomials whose leading monomial is  <span class="math">s_{i,1}^{\\alpha}</span>  generated by Lemma 3. Consider the pairs  <span class="math">(f_{i,1}; a_{i,1})</span>  for  <span class="math">1 \\leq i \\leq l</span>  where</p>

    <div class="my-4 text-center"><span class="math-block">a_{i,1} := \\mathcal{L}_{i,1}^{(1)}(\\boldsymbol{\\textit{0}},\\boldsymbol{\\textit{y}}_0) - Q_{\\gamma}\\left(\\mathcal{L}_{i,1}^{(2)}(\\boldsymbol{\\textit{0}},\\boldsymbol{\\textit{y}}_0)\\right) - s_{i,1}^{\\alpha} \\in A_{\\text{CICO}}</span></div>

    <p class="text-gray-300">as defined in eq. (3). Moreover,  <span class="math">\\mathsf{LM}(f_{i,1}) = s_{i,1}^{\\alpha}</span>  and  <span class="math">\\mathsf{LM}(a_{i,1}) = s_{i,1}^{\\alpha}</span> . Before the reduction, the corresponding S-polynomials  <span class="math">\\mathcal{S}(f_{i,1}, a_{i,1})</span>  have the following monomials (sorted by DRL monomial ordering):</p>

    <p class="text-gray-300"><span id="page-18-4"></span> <span class="math-block">\\{s_{i+1,1}^{\\alpha}, \\dots, s_{l,1}^{\\alpha}\\} \\cup \\bigcup_{k=1}^{l} J_k \\cup \\{y_1^2, y_0, y_1, y_{i,2}, s_{i,2}\\}</span>  (12)</p>

    <p class="text-gray-300"><span id="page-18-3"></span>where  <span class="math">J_k := \\{y_{k-1,0}^2, y_{0,0}y_{k,0}, \\dots, y_{k-1,0}y_{k,0}\\}</span> After the reduction by G, that is getting the remainder of the multivariate polynomial division by G (step 8 of Algorithm 1):</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{LM}(\\overline{\\mathcal{S}(f_{i,1}, a_{i,1})}^G) = y_{i,1} s_{i,1}</span></div>

    <p class="text-gray-300"><strong>Lemma 6.</strong> After the application of Lemmas 2 to 5 the set of leading monomials of the polynomials in the set G, denoted as LM(G), is composed by:</p>

    <div class="my-4 text-center"><span class="math-block">\\{\\boldsymbol{y}_0, \\boldsymbol{s}_1^{\\alpha}, \\dots, \\boldsymbol{s}_N^{\\alpha}, y_{i,1}s_{i,1}\\}</span></div>

    <p class="text-gray-300">for  <span class="math">1 \\le i \\le l</span> .</p>

    <p class="text-gray-300">Let consider the pairs  <span class="math">(b_{i,r}; a_{j,r})</span>  for  <span class="math">1 \\le i, j \\le l</span> , where</p>

    <div class="my-4 text-center"><span class="math-block">a_{j,r} := \\mathcal{L}_{j,r}^{(1)}(\\boldsymbol{m}_r, \\boldsymbol{y}_{r-1}) - Q_{\\gamma}\\left(\\mathcal{L}_{j,r}^{(2)}(\\boldsymbol{m}_r, \\boldsymbol{y}_{r-1})\\right) - s_{j,r}^{\\alpha} \\in A_{\\mathrm{CICO}}</span></div>

    <p class="text-gray-300">as defined in eq. (4) for the DRL monomial ordering and for a fixed value of  <span class="math">r \\geq 2</span> . Thanks to the Buchberger criterion, consider only the pairs  <span class="math">(b_{1,r}; a_{j,r})</span>  for  <span class="math">1 \\leq j \\leq l</span> , where  <span class="math">\\mathsf{LM}(b_{1,r}) = s_{1,r-1}^{\\alpha}</span>  and  <span class="math">\\mathsf{LM}(a_{j,r}) = s_{1,r-1}^{2\\alpha}</span> . The reduction by G of the corresponding S-polynomial  <span class="math">S(b_{1,r}, a_{j,r})</span>  generates a new equation such that:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{LM}(\\overline{\\mathcal{S}(b_{1,r},a_{j,r})}^G) = y_{j,r}s_{j,r}</span></div>

    <p class="text-gray-300"><span id="page-19-0"></span><strong>Lemma 7.</strong> After the application of Lemmas  <span class="math">\\frac{2}{2}</span>  to  <span class="math">\\frac{6}{6}</span>  the set of leading monomials of the polynomials in the set G, denoted as LM(G), is composed by:</p>

    <div class="my-4 text-center"><span class="math-block">\\{y_0, s_1^{\\alpha}, \\dots, s_N^{\\alpha}, y_{i,r}s_{i,r}\\}</span></div>

    <p class="text-gray-300">for  <span class="math">1 \\le i \\le l</span>  and  <span class="math">1 \\le r \\le N</span> .</p>

    <p class="text-gray-300">Let us denote as  <span class="math">h_{i,r}</span>  and  <span class="math">f_{i,r}</span>  the polynomials whose leading monomials are  <span class="math">y_{i,r}s_{i,r}</span>  and  <span class="math">s_{i,r}^{\\alpha}</span>  respectively (generated by Lemmas 3, 5 and 6). Consider all the pairs  <span class="math">(f_{i,r};h_{i,r})</span> . Notice that the Buchberger criterion cannot be used to reduce the amount of considered pairs. The reduction of the corresponding S-polynomial generates new equations such that:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{LM}(\\overline{S(f_{i,r},h_{i,r})}^G) = y_{i,r}^\\alpha</span></div>

    <p class="text-gray-300">Moreover, for  <span class="math">\\alpha = 3</span> , the algorithm terminates due to the fact that there are no other pairs to be considered with respect to the Buchberger Criterion.</p>

    <p class="text-gray-300"><span id="page-19-1"></span><strong>Proposition 2 (DRL Basis structure for</strong>  <span class="math">\\alpha = 3</span> <strong>).</strong> Let F be the system of polynomials generated by the  <span class="math">A_{\\text{CICO}}</span>  model and I the corresponding ideal. For  <span class="math">\\alpha = 3</span> , the DRL Gröbner basis  <span class="math">G_{\\text{DRL}}</span>  of I contains a well-structured set of polynomials. In particular, let  <span class="math">i, k \\in \\mathbb{Z}_{&gt;0}</span> , those polynomials have the following form:</p>

    <p class="text-gray-300">• l equations of degree 1 whose leading terms are  <span class="math">y_{i,0}</span>  for all  <span class="math">1 \\le i \\le l</span> :</p>

    <div class="my-4 text-center"><span class="math-block">g_{i,0} := y_{i,0} + Q(\\mathbf{y}_1, \\mathbf{s}_1)</span></div>

    <p class="text-gray-300">for  <span class="math">1 \\leq k \\leq l</span> , where  <span class="math">\\mathrm{LM}(Q) = y_{1,1}</span>  and the other monomials are linear terms. • Nl equations of degree  <span class="math">\\alpha</span>  whose leading term is  <span class="math">y_{i,j}^{\\alpha}</span>  for all  <span class="math">1 \\leq i \\leq l</span>  and  <span class="math">1 \\leq j \\leq r</span> :</p>

    <div class="my-4 text-center"><span class="math-block">g&#x27;_{i,j} := y^{\\alpha}_{i,j} + Q(s_{i,j}, \\boldsymbol{s}_{j+1}, \\boldsymbol{y}_{j-1}, \\boldsymbol{y}_{j}, \\boldsymbol{y}_{j+1}) \\ for \\ 1 \\leq k \\leq l</span></div>

    <p class="text-gray-300">for  <span class="math">l &lt; k \\leq Nl + l</span> , where  <span class="math">\\mathrm{LM}(Q) = y_{i,j-1}^{\\lfloor \\frac{\\alpha}{2} \\rfloor + 1} s_{i,j}^{\\lfloor \\frac{\\alpha}{2} \\rfloor}</span>  and the remaining monomials define a generic polynomial up to degree  <span class="math">\\alpha</span> .</p>

    <p class="text-gray-300">• Nl equations of degree  <span class="math">\\alpha</span>  whose leading term is  <span class="math">s_{i,j}^{\\alpha}</span>  for all  <span class="math">1 \\leq i \\leq l</span>  and  <span class="math">1 \\leq j \\leq r</span> :</p>

    <div class="my-4 text-center"><span class="math-block">g_{i,j} := s_{i,j}^{\\alpha} + Q(y_j, y_{j+1}, s_{j+1})</span></div>

    <p class="text-gray-300">for  <span class="math">Nl+l &lt; k \\leq 2Nl+l</span> , where  <span class="math">\\mathrm{LM}(Q) = y_{i,j}^2</span>  and the other monomials are linear terms.</p>

    <p class="text-gray-300">• Nl equations of degree 2 whose leading terms are  <span class="math">y_{i,j}s_{i,j}</span>  for all  <span class="math">1 \\le i \\le l</span>  and  <span class="math">1 \\le j \\le N</span> :</p>

    <div class="my-4 text-center"><span class="math-block">g_{i,j}&#x27;&#x27; := y_{i,j}s_{i,j} + Q(s_{i,j}, s_{j+1}, y_{j-1}, y_j, y_{j+1})</span></div>

    <p class="text-gray-300">for  <span class="math">2Nl+l &lt; k \\leq 3Nl+l</span> , where  <span class="math">\\mathrm{LM}(Q) = s_{i,j}^2</span>  and the other monomials are linear terms.</p>

    <p class="text-gray-300">Notice that when j = N, the variables  <span class="math">s_{N+1}</span>  and  <span class="math">y_{N+1}</span>  do not exist, meaning that the equation depend only on the remaining variables. Moreover, the complexity of computing the Gröbner basis is given by</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{O}\\left(\\frac{poly_1(l)N - poly_2(l)}{2}\\right)</span></div>

    <p class="text-gray-300">field operations where  <span class="math">poly_1(l) = l^2(24l^4 + 40l^3 + 32l^2 + 29l - 1)</span>  and  <span class="math">poly_2(l) = l^2(17l^4 + 4l^3 + 27l^2 + 15l + 1)</span> . The given complexity does not take care of the final reductions to obtain a reduced Gröbner basis.</p>

    <p class="text-gray-300"><em>Proof.</em> The result follows from Lemmas 2 to 7. Moreover, the complexity is given by the sum of the values given in the proofs of the lemmas which can be found in Appendix E.1.</p>

    <p class="text-gray-300"><span id="page-20-0"></span>Remark 3. (DRL Basis structure for  <span class="math">\\alpha=5,7,11</span> .) Let F be the system of polynomials generated by the  <span class="math">A_{\\rm CICO}</span>  model and I the corresponding ideal. For  <span class="math">\\alpha=5,7,11</span> , the DRL Gröbner basis  <span class="math">G_{\\rm DRL}</span>  of I contains the polynomials  <span class="math">g_{i,j}</span>  defined in Proposition 2 plus other polynomials which are useful to shorten the quotient ring basis and obtain the minimum univariate polynomial degree needed in Section 6.3.</p>

    <p class="text-gray-300"> <span class="math">\\mathbf{W}_{DRL}</span>  Gröbner basis The phenomenon described in Remark 3 prohibits from efficiently computing the DRL Gröbner basis for  <span class="math">\\alpha=5,7,11</span> . The issue comes from the condition  <span class="math">s^{\\alpha} \\prec_{\\mathsf{DRL}} y^2</span>  that triggers several polynomial reductions. To circumvent this issue we introduce a weighted monomial ordering, denoted as  <span class="math">\\mathbf{W}_{DRL}</span> , such that  <span class="math">y^2 \\prec_{\\mathbf{W}_{DRL}} s^{\\alpha}</span> . In particular, we want to define weights such that  <span class="math">2w(y) \\geq \\alpha w(s)</span> , e.g. if w(s) = 2k then  <span class="math">w(y) = \\alpha k</span> . The following definition is an instantiation of Definition 9.</p>

    <p class="text-gray-300"><strong>Definition 15 (Weighted monomial ordering for</strong> Anemoi). Let  <span class="math">\\mathbf{w} = (w_0, w_1) \\in \\mathbb{R}^2</span> , where  <span class="math">w_j \\neq 0</span>  for j = 0, 1. We define  <span class="math">\\prec_{W_{DRL}}</span>  to be the weighted DRL monomial order defined by weights  <span class="math">w_0, w_1</span> , where  <span class="math">w_0</span>  is the weight associated with the variables  <span class="math">y_{i,r}</span>  for  <span class="math">1 \\leq i \\leq l</span>  and  <span class="math">0 \\leq r \\leq N</span>  and  <span class="math">w_1</span>  is the weight associated with</p>

    <p class="text-gray-300">the variables  <span class="math">s_{i,r}</span>  for  <span class="math">1 \\leq i \\leq l</span>  and  <span class="math">1 \\leq r \\leq N</span> . Moreover, we constrain the</p>

    <p class="text-gray-300">weights to satisfy the following inequality:  <span class="math">2w_0 \\ge \\alpha w_1</span> . Given two monomials  <span class="math">M_0</span>  and  <span class="math">M_1</span> , let  <span class="math">k_y^{(0)}</span>  and  <span class="math">k_y^{(1)}</span>  be the number of variables  <span class="math">y_{i,r}</span>  in  <span class="math">M_0</span>  and  <span class="math">M_1</span> . Furthermore,  <span class="math">k_s^{(0)}</span>  and  <span class="math">k_s^{(1)}</span>  are the number of variables  <span class="math">s_{i,r}</span> in  <span class="math">M_0</span>  and  <span class="math">M_1</span> . We say that:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} M_0 := \\prod_{i=1}^{k_y^{(0)}} y^{e_i^{(0)}} \\prod_{i=1}^{k_s^{(0)}} s^{u_i^{(0)}} \\prec_{W_{DRL}} \\prod_{i=1}^{k_y^{(1)}} y^{e_i^{(1)}} \\prod_{i=1}^{k_s^{(1)}} s^{u_i^{(1)}} \\\\ &amp; \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad</span></div>

    <p class="text-gray-300"><span id="page-21-0"></span><strong>Lemma 8.</strong> Given the list of l > 1 polynomials</p>

    <div class="my-4 text-center"><span class="math-block">b_{i,1} := \\mathcal{L}_{i,1}^{(2)}(\\mathbf{0}, \\mathbf{y}_0) - y_{i,1} - s_{i,1} \\in A_{\\text{CICO}}</span></div>

    <p class="text-gray-300">as defined in eq. (5) for  <span class="math">1 \\le i \\le l</span>  with respect to the  <span class="math">W_{DRL}</span>  monomial ordering, generate the pairs as in Step 2 of the Algorithm 1 and compute the corresponding S-polynomials. Recursive application of the same procedure on the outputs leads to a stage when we obtain only one S-polynomial. As result of this process, we obtain a set of polynomials whose leading monomials are  <span class="math">y_{i,0}</span>  for  <span class="math">1 \\le i \\le l</span> . When l=1, the unique polynomial  <span class="math">b_{1,1}</span>  is already in the desired form.</p>

    <p class="text-gray-300"><span id="page-21-3"></span><strong>Lemma 9.</strong> Fix r to be a round number such that  <span class="math">1 &lt; r \\le N</span> , given a list of l > 1 polynomials</p>

    <div class="my-4 text-center"><span class="math-block">b_{i,r} = \\mathcal{L}_{i,r}^{(2)}(\\boldsymbol{m}_r, \\boldsymbol{y}_{r-1}) - y_{i,r} - s_{i,r} \\in A_{\\text{CICO}}</span></div>

    <p class="text-gray-300">as defined in eq. (6) for  <span class="math">1 \\le i \\le l</span>  with respect to the  <span class="math">W_{DRL}</span>  monomial ordering, generate the pairs as in Step 2 of the Algorithm 1 and compute the corresponding S-polynomials. We (recursively) apply the same procedure on the outputs until you get only one S-polynomial. As a result, we obtain a set of polynomials whose leading monomials are  <span class="math">y_{i,r-1}^2</span>  for  <span class="math">1 \\leq i \\leq l</span> . When l = 1, the unique polynomial  <span class="math">b_{1,r}</span>  is already in the desired form.</p>

    <p class="text-gray-300"><span id="page-21-1"></span><strong>Lemma 10.</strong> Given a list of l > 1 polynomials</p>

    <div class="my-4 text-center"><span class="math-block">f_{i,N+1} = \\mathcal{L}_{i,N}^{(1)}(\\pmb{m}_{N+1}, \\pmb{y}_N)</span></div>

    <p class="text-gray-300"><span id="page-21-2"></span>as defined in eq. (7) for  <span class="math">1 \\le i \\le l</span>  with respect to the  <span class="math">W_{DRL}</span>  monomial ordering, generate the pairs as in Step 2 of the Algorithm 1 and compute the corresponding S-polynomials. We (recursively) apply the same procedure on the outputs until you obtain only one S-polynomial. As a result, we obtain a set of polynomials whose leading monomials are  <span class="math">y_{i,N}^2</span>  for  <span class="math">1 \\leq i \\leq l</span> . When l = 1, the unique polynomial  <span class="math">f_{1,N+1}</span>  is already in the desired form.</p>

    <p class="text-gray-300"><strong>Lemma 11.</strong> After the application of Lemmas 8 to 10, the set of leading monomials of the polynomials in the set G, denoted as LM(G), is composed by:</p>

    <div class="my-4 text-center"><span class="math-block">\\{y_0, y_1^2, y_2^2, \\dots, y_N^2\\}.</span></div>

    <p class="text-gray-300">Consider the pairs  <span class="math">(b_{i,1}; a_{i,1})</span>  for  <span class="math">1 \\le i \\le l</span>  where</p>

    <div class="my-4 text-center"><span class="math-block">a_{i,1} := \\mathcal{L}_{i,1}^{(1)}(\\boldsymbol{\\textit{0}},\\boldsymbol{\\textit{y}}_0) - Q_{\\gamma}\\left(\\mathcal{L}_{i,1}^{(2)}(\\boldsymbol{\\textit{0}},\\boldsymbol{\\textit{y}}_0)\\right) - s_{i,1}^{\\alpha} \\in A_{\\mathrm{CICO}}</span></div>

    <p class="text-gray-300">as defined in eq. (3). For  <span class="math">1 \\le i \\le l</span> ,  <span class="math">\\mathsf{LM}(b_{i,1}) = y_{1,0}</span>  and  <span class="math">\\mathsf{LM}(a_{i,1}) = y_{1,0}^2</span> . Before the reduction, the corresponding S-polynomials  <span class="math">\\mathcal{S}(b_{i,1}, a_{i,1})</span>  have the following monomials (sorted by  <span class="math">W_{DRL}</span>  monomial ordering):</p>

    <p class="text-gray-300"><span id="page-22-2"></span> <span class="math-block">\\bigcup_{k=2}^{l} J_k \\cup \\{y_{1,0}y_{i,1}, s_{i,1}^{\\alpha}\\} \\cup \\{y_{1,0}s_{i,1}, \\mathbf{y}_0, y_{i,1}, s_{i,1}\\}</span> (13)</p>

    <p class="text-gray-300">where  <span class="math">J_k := \\{y_{1,0}y_{k,0}, \\dots, y_{k-1,0}y_{k,0}, y_{k,0}^2\\}</span></p>

    <p class="text-gray-300">After the reduction by G, that is getting the remainder of the multivariate polynomial division by G (step 8 of Algorithm 1):</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{LM}(\\overline{\\mathcal{S}(b_{i,1},a_{i,1})}^G) = y_{i,1}s_{i,1}</span></div>

    <p class="text-gray-300"><span id="page-22-0"></span><strong>Lemma 12.</strong> After the application of Lemmas 8 to 11 the set of leading monomials of the polynomials in the set G, denoted as LM(G), is composed by:</p>

    <div class="my-4 text-center"><span class="math-block">\\{y_0, y_1^2 \\dots, y_N^2, y_{i,1}s_{i,1}\\}</span></div>

    <p class="text-gray-300">for  <span class="math">1 \\leq i \\leq l</span> .</p>

    <p class="text-gray-300">Let consider the pairs  <span class="math">(b_{i,r}; a_{j,r})</span>  for  <span class="math">1 \\leq i, j \\leq l</span> , where</p>

    <div class="my-4 text-center"><span class="math-block">a_{j,r} := \\mathcal{L}_{j,r}^{(1)}(\\pmb{m}_r, \\pmb{y}_{r-1}) - Q_{\\gamma}\\left(\\mathcal{L}_{j,r}^{(2)}(\\pmb{m}_r, \\pmb{y}_{r-1})\\right) - s_{j,r}^{\\alpha} \\in A_{\\text{CICO}}</span></div>

    <p class="text-gray-300">as defined in eq. (4) for the  <span class="math">W_{DRL}</span>  monomial ordering and for a fixed value of  <span class="math">r \\geq 2</span> . Thanks to the Buchberger criterion, consider only the pairs  <span class="math">(b_{1,r}; a_{j,r})</span>  for  <span class="math">1 \\leq j \\leq l</span> , where  <span class="math">\\mathsf{LM}(b_{1,r}) = y_{1,r-1}^2</span>  and  <span class="math">\\mathsf{LM}(a_{j,r}) = y_{1,r-1}^4</span> . The reduction by G of the corresponding S-polynomial  <span class="math">S(b_{1,r}, a_{j,r})</span>  generates a new equation such that:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{LM}(\\overline{\\mathcal{S}(b_{1,r},a_{j,r})}^G) = y_{j,r}s_{j,r}</span></div>

    <p class="text-gray-300"><span id="page-22-1"></span><strong>Lemma 13.</strong> After the application of Lemmas 8 to 12 the set of leading monomials of the polynomials in the set G, denoted as LM(G), is composed by:</p>

    <div class="my-4 text-center"><span class="math-block">\\{y_0, y_1^2, \\dots, y_N^2, y_{i,r}s_{i,r}\\}</span></div>

    <p class="text-gray-300">for  <span class="math">1 \\le i \\le l</span>  and  <span class="math">1 \\le r \\le N</span> .</p>

    <p class="text-gray-300">Let us denote as  <span class="math">h_{i,r}</span>  and  <span class="math">f_{i,r}</span>  the polynomials whose leading monomials are  <span class="math">y_{i,r}s_{i,r}</span>  and  <span class="math">y_{i,r}^2</span>  respectively (generated by Lemmas 9, 11 and 12). Consider all</p>

    <p class="text-gray-300">the pairs  <span class="math">(f_{i,r}; h_{i,r})</span> . Notice that the Buchberger criterion cannot be used to reduce the amount of considered pairs. The reduction of the S-polynomial  <span class="math">S(f_{i,r}, h_{i,r})</span>  generates a new equation such that:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{LM}(\\overline{S(f_{i,r},h_{i,r})}^G) = s_{i,r}^{\\alpha+1}</span></div>

    <p class="text-gray-300"><span id="page-23-0"></span><strong>Proposition 3 (DRL Basis structure for</strong>  <span class="math">\\alpha = 5,7,11</span>  with  <span class="math">\\mathbf{W}_{DRL}</span> ). Let F be the system of polynomials generated by the  <span class="math">A_{\\text{CICO}}</span>  model and I the corresponding ideal. For  <span class="math">\\alpha = 5,7,11</span> , the  <span class="math">W_{DRL}</span>  Gröbner basis  <span class="math">G_{W_{DRL}}</span>  of I contains a well-structured set of polynomials. In particular, let  <span class="math">i, k \\in \\mathbb{Z}_{&gt;0}</span> , those polynomials have the following form:</p>

    <p class="text-gray-300">• l equations of degree 1 whose leading terms are  <span class="math">y_{i,0}</span>  for all  <span class="math">1 \\le i \\le l</span> :</p>

    <div class="my-4 text-center"><span class="math-block">g_{i,0} := y_{i,0} + Q(\\mathbf{y}_1, \\mathbf{s}_1)</span></div>

    <p class="text-gray-300">for  <span class="math">1 \\le k \\le l</span> , where  <span class="math">LM(Q) = y_{1,1}</span>  and the other monomials are linear terms. • Nl equations of degree  <span class="math">\\alpha + 1</span>  whose leading term is  <span class="math">s_{i,j}^{\\alpha+1}</span>  for all  <span class="math">1 \\le i \\le l</span>  and  <span class="math">1 \\le j \\le r</span> :</p>

    <div class="my-4 text-center"><span class="math-block">g&#x27;_{i,j} := s_{i,j}^{\\alpha+1} + Q(s_{i,j}, \\boldsymbol{s}_{j+1}, \\boldsymbol{y}_{j-1}, \\boldsymbol{y}_{j}, \\boldsymbol{y}_{j+1}) \\text{ for } 1 \\leq k \\leq l</span></div>

    <p class="text-gray-300">for  <span class="math">l &lt; k \\le Nl + l</span> , where  <span class="math">LM(Q) = y_{1,j-1}y_{i,j}</span>  and the remaining monomials define a generic polynomial up to degree  <span class="math">\\alpha</span> .</p>

    <p class="text-gray-300">• Nl equations of degree 2 whose leading term is  <span class="math">y_{i,j}^2</span>  for all  <span class="math">1 \\le i \\le l</span>  and  <span class="math">1 \\le j \\le r</span> :</p>

    <div class="my-4 text-center"><span class="math-block">g_{i,j} := y_{i,j}^2 + Q(s_{i,j}^{\\alpha}, y_{l-i-1,j}, \\boldsymbol{y}_{j+1}, \\boldsymbol{s}_{j+1})</span></div>

    <p class="text-gray-300">for  <span class="math">Nl+l &lt; k \\leq 2Nl+l</span> , where  <span class="math">\\mathrm{LM}(Q) = s_{i,j}^{\\alpha}</span>  and the other monomials are linear terms.</p>

    <p class="text-gray-300">• Nl equations of degree 2 whose leading terms are  <span class="math">y_{i,j}s_{i,j}</span>  for all  <span class="math">1 \\le i \\le l</span>  and  <span class="math">1 \\le j \\le N</span> :</p>

    <div class="my-4 text-center"><span class="math-block">g&#x27;&#x27;_{i,j} := y_{i,j}s_{i,j} + Q(s_{i,j}, \\boldsymbol{s}_{j+1}, \\boldsymbol{y}_{j-1}, \\boldsymbol{y}_{j}, \\boldsymbol{y}_{j+1})</span></div>

    <p class="text-gray-300">for  <span class="math">2Nl+l &lt; k \\leq 3Nl+l</span> , where  <span class="math">\\mathrm{LM}(Q) = y_{1,j-1}</span>  and the other monomials are linear terms.</p>

    <p class="text-gray-300">Notice that when j = N, the variables  <span class="math">s_{N+1}</span>  and  <span class="math">y_{N+1}</span>  do not exist, meaning that the equation depend only on the remaining variables. Moreover, the complexity of computing the Gröbner basis is given by</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{O}\\left(\\frac{poly_1(l)N + poly_2(l)}{2}\\right)</span></div>

    <p class="text-gray-300">field operations where  <span class="math">poly_1(l) = l^2(24l^3 + 6l^2 + 7l - 1)</span>  and  <span class="math">poly_2(l) = l^2(4l^4 - 6l^3 + 18l^2 + 11l - 1)</span> . The given complexity does not take care of the final reductions to obtain a reduced Gröbner basis.</p>

    <p class="text-gray-300"><em>Proof.</em> The proof follows the same technique done for the DRL case. The result follows from Lemmas 8 to 13. Moreover, the complexity is given by the sum of the values given in the proofs of the lemmas which can be found in Appendix E.2.</p>

    <h2 id="sec-18" class="text-2xl font-bold">6.2 The shape lemma for Anemoi</h2>

    <p class="text-gray-300"><span id="page-24-2"></span>Corollary 2 (The Shape Lemma for Anemoi). The polynomials generated by the Gröbner basis for Anemoi (see Propositions 2 and 3) follow the preconditions of Theorem 8. Hence, we conclude that Anemoi has Shape form.</p>

    <p class="text-gray-300">Indeed, it is straightforward to notice that the system of polynomials generated by the Gröbner basis for Anemoi (see Propositions 2 and 3) has no solutions at  <span class="math">\\infty</span> . Recursively, we can consider only the equations  <span class="math">f_i</span>  such that  <span class="math">f_i := x_i^{\\alpha_i} + Q_i(x_1, \\ldots, x_n)</span>  and  <span class="math">\\deg_{\\prec}(Q_i) &lt; \\deg_{\\prec}(x_i^{\\alpha_i})</span>  where  <span class="math">\\prec</span>  is either DRL or  <span class="math">W_{DRL}</span> , and back-substitute each considered variable with the only solution (which is zero) until we consider all the polynomials in the GB. At the end, we conclude that the only possible solution at  <span class="math">\\infty</span>  is the trivial one, that is the zero solution. As a consequence, the Anemoi polynomials follow the preconditions of Theorem 8. Thus we conclude that Anemoi has Shape form.</p>

    <h2 id="sec-19" class="text-2xl font-bold">6.3 Univariate polynomial finding</h2>

    <p class="text-gray-300">For obtaining the univariate polynomial(s), we can mainly use two different approaches:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\bullet</span>  Basis conversion: converting  <span class="math">G_{\\mathsf{DRL}}</span>  to  <span class="math">G_{\\mathsf{LEX}}</span>  using  <span class="math">\\mathsf{SparseFGLM}</span></li>

      <li>Eigenvalue method: applying one of the following methods:</li>

      <li>computing  <span class="math">\\det(x_i \\mathbf{I}_{d_I} T_i)</span>  that we refer as polyDet (following [3])</li>

      <li>applying Wiedemann algorithm that we call linSeq (since it generates a linearly recurring sequence from the multiplication matrix  <span class="math">T_i</span> ).</li>

    </ul>

    <p class="text-gray-300">CHANGE OF BASIS WITH SPARSEFGLM One common approach is to apply the FGLM [19] algorithm to convert  <span class="math">G_{\\mathsf{DRL}}</span>  to  <span class="math">G_{\\mathsf{LEX}}</span> . In particular, due to the sparsity of the polynomials involved, we can apply  <span class="math">\\mathsf{SparseFGLM}</span>  [20], whose complexity is:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{O}(n_v \\cdot d_I^\\omega \\log(d_I)) \\tag{14}</span></div>

    <p class="text-gray-300">operation in  <span class="math">\\mathbb{F}_q</span> , where  <span class="math">\\omega</span>  is the linear algebra constant which, in our case, is theoretically bounded by  <span class="math">2 \\leq \\omega \\leq 2.3727</span>  [43].  <span class="math">d_I = dim_{\\mathbb{F}_q}(R/I)</span>  is the dimension of the quotient ring R/I. By applying that algorithm we obtain a Gröbner basis  <span class="math">G_{\\mathsf{LEX}}</span>  containing a univariate polynomial in the smallest variable. Thanks to Corollary 2, we only need to factorize that polynomial to find the values for all the variables of the system. The complexity of SparseFGLM can also be given in terms of the sparsity of the involved matrices:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{O}(d_I(\\mathcal{Z} + n_v \\log(d_I))) \\tag{15}</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathcal{Z}</span>  is the number of non-zero entries [20].</p>

    <p class="text-gray-300">EIGENVALUE METHOD WITH POLYDET SparseFGLM introduces a lot of unnecessary computations with respect to our objective namely, finding possible values for the inputs  <span class="math">y_{1,0}, \\ldots, y_{l,0}</span> . Instead of using SparseFGLM we can compute the multiplication matrix of the l variables we are interested in and, for each of them, compute  <span class="math">\\det(y_{i,0}\\mathbf{I}_{d_I}-T_i)</span>  for  <span class="math">1\\leq i\\leq l</span> . To compute such determinant we can apply the Labahn et al. algorithm [30] whose complexity is given by  <span class="math">\\mathcal{O}(d_I^{\\omega}\\lceil s\\rceil)</span>  where s is the mean of the column degrees. As a consequence, if we use that method to find l univariate polynomials, the overall complexity of polyDet becomes  <span class="math">\\mathcal{O}(l \\cdot d_I^{\\omega})</span> . Further details are given in Section 7.</p>

    <p class="text-gray-300">EIGENVALUE METHOD WITH WIEDEMANN ALGORITHM A third option which can save a lot of unnecessary computations is given by the Wiedemann algorithm. Indeed, we can compute the multiplication matrix of the l variables we are interested in and, for each of them, generate a linearly recurring sequence to determine, thanks to the Berlekamp-Massey algorithm [5], its minimal polynomial [20, 26]. Out of the determistic and probabilistic versions of the Wiedemann algorithm [20, 42], we use, in our analysis, the probabilistic version whose complexity is bounded by</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{O}(d_I(\\mathcal{Z} + \\log(d_I))) \\tag{16}</span></div>

    <p class="text-gray-300">operation in  <span class="math">\\mathbb{F}_q</span> , where  <span class="math">\\mathcal{Z}</span>  is the number of non-zero entries in  <span class="math">T_i</span> . The probability of success (generating the minimal polynomial associated to the generated sequence) is very high, close to 1 in our case, and it is given by:</p>

    <p class="text-gray-300"><span id="page-25-2"></span> <span class="math-block">P_q(n) = \\begin{cases} (1 - \\frac{1}{q})^{2n} &amp; \\text{if } q \\ge n\\\\ (1 - \\frac{1}{q})^{2q} (1 - \\frac{1}{q^2})^{n-q} &amp; \\text{if } \\sqrt{n} \\le q &lt; n \\end{cases}</span>  (17)</p>

    <p class="text-gray-300">where q is the field cardinality and n is the matrix dimension (for sake of simplicity we are considering square matrices) [26]. Due to the fact that we need to apply the method for all the l input variables, the overall complexity is given by:</p>

    <p class="text-gray-300"><span id="page-25-1"></span> <span class="math-block">\\mathcal{O}(ld_I(\\mathcal{Z} + \\log(d_I))) \\tag{18}</span></p>

    <p class="text-gray-300">Note that the Wiedemann algorithm is used in the initial step of SparseFGLM. In Appendix F we provide a brief comparison between the two methods and a way to decide which one fits better for the specific application.</p>

    <p class="text-gray-300"><span id="page-25-0"></span>The value of  <span class="math">d_I</span>  The dimension  <span class="math">d_I</span>  is crucial in determining the complexity of obtaining univariate polynomial. In [29]  <span class="math">d_I</span>  for Anemoi is conjectured as  <span class="math">d_I = (\\alpha + 2)^N</span>  for l = 1 with experimental evidences. We prove and extend this conjecture.</p>

    <p class="text-gray-300">Proposition 4 (Quotient ring dimension for Anemoi). Let N be the number of rounds of Anemoi for  <span class="math">l \\geq 1</span>  and  <span class="math">\\alpha = 3</span>  (resp.  <span class="math">\\alpha = 3, 5, 7, 11</span> ). The dimension of the quotient ring basis of the DRL Gröbner basis (resp.  <span class="math">W_{DRL}</span>  Gröbner basis) w.r.t Anemoi(N,  <span class="math">\\alpha</span> , l) is:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$d_I =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B_{G_{DRL}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B_{G_{W_{DRL}}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">:= (\\alpha + 2)^{Nl}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><em>Proof.</em> We need to distinguish two cases:</p>

    <p class="text-gray-300"><strong>DRL</strong> From Proposition 2, we know that  <span class="math">G_{DRL}</span>  will be composed by:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1) l equations of degree 1 whose leading terms are  <span class="math">y_{i,0}</span>  for all  <span class="math">1 \\le i \\le l</span> .</li>

      <li>2) 2Nl equations of degree  <span class="math">\\alpha</span>  whose leading term is  <span class="math">y_{i,j}^{\\alpha}</span>  or  <span class="math">s_{i,j}^{\\alpha}</span>  for all  <span class="math">1 \\leq i \\leq l</span>  and  <span class="math">1 \\leq j \\leq N</span> .</li>

      <li>3) Nl equations of degree 2 whose leading terms are  <span class="math">y_{i,j}s_{i,j}</span>  for all  <span class="math">1 \\le i \\le l</span>  and  <span class="math">1 \\le j \\le N</span> .</li>

    </ul>

    <p class="text-gray-300">We are interested in defining the quotient ring basis  <span class="math">B_{G_{DRL}}</span> . Due to the fact that the equations from point 1 have got degree 1, we can directly skip them. By considering the equations given at point 2 we would define a quotient ring basis made by  <span class="math">\\alpha^{2Nl}</span>  monomials. But, by point 3, we have to remove all the monomials which are multiples of the leading monomials of the equations at point 3, which act as filter equations: e.g. if  <span class="math">y_{i,j}^2 s_{i,j}^2 \\in B_{G_{DRL}}</span> , due to the fact that  <span class="math">y_{i,j} s_{i,j}</span>  is the leading monomial of one of those equations, we must remove it from  <span class="math">B_{G_{DRL}}</span> . In order to directly count the cardinality of the final quotient ring basis, we need to consider what are the possible monomials  <span class="math">y_{i,j}^{a_0} s_{i,j}^{a_1} Q</span> , where Q is a polynomial depending on other variables and  <span class="math">a_0, a_1 \\in [0, \\ldots, \\alpha-1]</span> , which are not deleted by equations at point 3. For each monomial of that kind:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if  <span class="math">a_0 &gt; 0</span> , then  <span class="math">a_1 = 0</span>  and the possible couples of degrees are: [1, 0], [2, 0].</li>

      <li>if  <span class="math">a_1 &gt; 0</span> , then  <span class="math">a_0 = 0</span>  and the possible couples of degrees are: [0, 1], [0, 2].</li>

      <li>the last possibility is  <span class="math">a_0 = 0</span>  and  <span class="math">a_1 = 0</span> : [0, 0].</li>

    </ul>

    <p class="text-gray-300">For each couple  <span class="math">(y_{i,j}, s_{i,j})</span> , we have  <span class="math">2(\\alpha - 1) + 1 = 2\\alpha - 1</span>  possible combinations. Due to the fact that  <span class="math">\\alpha = 3</span> ,  <span class="math">2\\alpha - 1 = \\alpha + 2</span> . We have Nl couples, then the possible valid monomials within the quotient ring basis are in total  <span class="math">(\\alpha + 2)^{Nl}</span> .</p>

    <p class="text-gray-300"> <span class="math">\\mathbf{W}_{DRL}</span>  From Proposition 3, we know that  <span class="math">G_{\\mathbf{W}_{DRL}}</span>  will be composed by:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1) l equations of degree 1 whose leading terms are  <span class="math">y_{i,0}</span>  for all  <span class="math">1 \\le i \\le l</span> .</li>

      <li>2) Nl equations of degree 2 whose leading term is  <span class="math">y_{i,j}^2</span>  for all  <span class="math">1 \\le i \\le l</span>  and  <span class="math">1 \\le j \\le N</span> .</li>

      <li>3) Nl equations of degree  <span class="math">\\alpha + 1</span>  whose leading term is  <span class="math">s_{i,j}^{\\alpha+1}</span>  for all  <span class="math">1 \\leq i \\leq l</span>  and  <span class="math">1 \\leq j \\leq N</span> .</li>

      <li>4) Nl of degree 2 whose leading terms are  <span class="math">y_{i,j}s_{i,j}</span>  for all  <span class="math">1 \\leq i \\leq l</span>  and  <span class="math">1 \\leq j \\leq N</span> .</li>

    </ul>

    <p class="text-gray-300">We are interested in defining the quotient ring basis  <span class="math">B_{G_{W_{DRL}}}</span> . As done for the previous case, we can directly skip equations at point 1. By considering only the equations at points 2 and 3, we would define a quotient ring basis made by  <span class="math">2^{Nl}\\alpha^{Nl}</span>  monomials. But, by point 4, we have to remove all the monomials which are multiples of the leading monomials of the equations at point 4: e.g. if  <span class="math">y_{i,j}^2 s_{i,j}^2 \\in B_{G_{W_{DRL}}}</span> , due to the fact that  <span class="math">y_{i,j} s_{i,j}</span>  is the leading monomial of one of those equations, we must remove it from  <span class="math">B_{G_{W_{DRL}}}</span> . In order to directly count the cardinality of the final quotient ring basis, we need to consider what are the possible monomials  <span class="math">y_{i,j}^{a_0} s_{i,j}^{a_1} Q</span> , where Q is a polynomial depending on other variables and  <span class="math">a_0 \\in \\{0,1\\}</span>  and  <span class="math">a_1 \\in \\{0,\\ldots,\\alpha\\}</span> , which are not deleted by equations at point 4. For each monomial of that kind:</p>

    <p class="text-gray-300">• if a<sup>0</sup> > 0, then a<sup>1</sup> = 0 and the possible couples of degrees are:</p>

    <p class="text-gray-300"><span class="math-block">[1,0]</span>  (1 couple).</p>

    <p class="text-gray-300">• if a<sup>1</sup> > 0, then a<sup>0</sup> = 0 and the possible couples of degrees are:</p>

    <div class="my-4 text-center"><span class="math-block">[0,1], [0,2], \\ldots, [0,\\alpha] \\ (\\alpha \\text{ couples}).</span></div>

    <p class="text-gray-300">• the last possibility is a<sup>0</sup> = 0 and a<sup>1</sup> = 0:</p>

    <p class="text-gray-300"><span class="math-block">[0,0]</span>  (1 couple).</p>

    <p class="text-gray-300">For each couple (yi,j , si,j ), we have α + 2 possible combinations. We have Nl couples, then the possible valid monomials within the quotient ring basis are in total (α + 2)N l .</p>

    <p class="text-gray-300">Due to the fact that our target variables are involved only in the degree 1 equations, their multiplication matrix dimension will represent the degree of the associated univariate polynomial, that is also the number of roots. The dimension of the multiplication matrix is the dimension of the quotient ring basis, that is composed by all the monomials which are not multiples or a composition of the elements in LM(I), where I is, in our case, the DRL or WDRL Gröbner Basis. The obtained result validates and extends <a href="#page-36-2">\\[29,</a> Conjecture 3] for the case l = 1.</p>

    <h2 id="sec-20" class="text-2xl font-bold">6.4 Polynomial Factorization or Root Finding</h2>

    <p class="text-gray-300">For Anemoi cryptanalysis (or for GB cryptanalysis in general) this part corresponds to finding the collision or preimage (resp. finding solution(s) to the polynomial system). The input to this section is the univariate polynomial obtained in the previous one. To find its roots, we can simply apply one of the off-the-shelf factorization algorithms.</p>

    <p class="text-gray-300">Polynomial factorization As for the polynomial factorization, there are multiple choices. Some of them are: Cantor-Zassenhaus <a href="#page-35-9">\\[12,</a> [17\\]](#page-35-10), Berlekamp Algorithm [\\[4\\]](#page-34-8) and Kaltofen-Shoup probabilistic algorithm [\\[27\\]](#page-36-4).</p>

    <p class="text-gray-300">Since we are dealing with finite fields, the latter one gives the best complexity. Therefore, for our analysis, we choose the Kaltofen-Shoup probabilistic algorithm, whose probabilistic complexity is given by</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{O}(d^{1.815}\\log(q))\\tag{19}</span></div>

    <p class="text-gray-300">where d is the degree of the univariate polynomial and q is the field characteristic. From an experimental point of view, the best algorithm can vary depending on the type of polynomial and on the implementation <a href="#page-36-8">\\[36,</a> [37\\]](#page-36-9).</p>

    <p class="text-gray-300">Root finding To determine the complexity of finding the solutions to the system of polynomials, we need to figure out if we are dealing with an ideal in Shape form, if we have a particular structure to exploit or if we must apply the methods in the previous section for each variable. The Shape form for Anemoi is guaranteed by Corollary <a href="#page-24-2">2.</a> As a result, the complete variety of the system can be determined by applying SparseFGLM, factorizing the only univariate polynomial and exploiting the "nice" form of the derived LEX GB. However, we could be interested in finding a limited number of variables (say nv). Therefore, other methods can be exploited, e.g. the eigenvalue methods can be applied for each of those variables, raising to a complexity of</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{O}(n_v \\cdot d_I^\\omega) \\ \\text{ for polyDet}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{O}(n_v d_I(\\mathcal{Z} + \\log(d_I))) \\ \\text{ for the Wiedemann algorithm}.</span></div>

    <p class="text-gray-300">As a result of this process, we find n<sup>v</sup> univariate polynomials whose roots can be computed with the factorization algorithms above.</p>

    <p class="text-gray-300">Fortunately, the system of polynomials defined by ACICO has a particular structure which can be exploited to avoid the computation of many univariate polynomials. We can just compute l univariate polynomials with the eigenvalue methods, factorize them and find the values for the remaining variables by using gcd (resp. Gaussian elimination) if l = 1 (resp. l > 1). Indeed, we can exploit Theorem 5 and Corollary 1 from [\\[10\\]](#page-35-11). Their analysis works on LEX Gröbner basis, but the algorithm proposed in Corollary 1 can be easily extended to our case. To apply a modified version of <a href="#page-35-11">\\[10,</a> Corollary 1], we need to find at least l univariate polynomials that depend on yi,N for 1 ≤ i ≤ l. Hence, to determine those polynomials, which we will denote as hi(yi,N ), we can use one of the eigenvalue methods. Afterwards, we add them to the equations of our GB in order to obtain the desired form. The procedure to compute the variety of the ideal generated by the DRL basis of Anemoi with respect to the ACICO modelling is given in detail in Algorithm <a href="#page-53-0">4</a> (see Appendix <a href="#page-51-1">G\\)</a>. The same can be done for the WDRL basis given in Proposition <a href="#page-23-0">3</a> due to the similar structure of the generated equations. The complexity of this algorithm depends on the computation of the required l univariate polynomials for which we can choose one of the algorithms previously presented. The complexities of other operations are dominated by that one. Indeed, the complexity of solving a linear system of l equations in l unknowns is in the worst case O(l 3 ). Moreover, if l = 1, we deal with 2 equations of degree 1 in 1 unknown, meaning that its solution comes for free.</p>

    <h2 id="sec-21" class="text-2xl font-bold">7 Anemoi cryptanalysis results</h2>

    <p class="text-gray-300">In this section we discuss the complexities for the first two steps of the Gröbner basis cryptanalysis methodology with respect to Anemoi. Finally, we discuss the experimental results where we show the ease of the GB computation and how the Wiedemann algorithm gives us the possibility to attack more rounds with respect to previous works.</p>

    <p class="text-gray-300"><span id="page-29-0"></span>Table 1: Complexity of the existing Gröbner Basis attacks for l = 1. The number of rounds is given in brackets. The two articles used different values of ω.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Koschatko et al. [29] (ω = 2)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Bariant et al. [3] (ω = 2.8074)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Security</td>

            <td class="px-3 py-2 border-b border-gray-700">α = 3</td>

            <td class="px-3 py-2 border-b border-gray-700">α = 5</td>

            <td class="px-3 py-2 border-b border-gray-700">α = 7</td>

            <td class="px-3 py-2 border-b border-gray-700">α = 11</td>

            <td class="px-3 py-2 border-b border-gray-700">α = 3</td>

            <td class="px-3 py-2 border-b border-gray-700">α = 5</td>

            <td class="px-3 py-2 border-b border-gray-700">α = 7</td>

            <td class="px-3 py-2 border-b border-gray-700">α = 11</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">117 (21) 144 (21) 152 (20) 152 (19) 118 (21) 156 (21) 174 (20) 198 (19)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">210 (37) 257 (37) 277 (36) 280 (35) 203 (37) 270 (37) 307 (36) 358 (35)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <h2 id="sec-22" class="text-2xl font-bold">7.1 Gröbner basis computation complexity</h2>

    <p class="text-gray-300">Propositions <a href="#page-19-1">2</a> and <a href="#page-23-0">3</a> show that the Gröbner basis computation complexity, with respect to the system generated by the ACICO model, polynomially depends on the number of branches l and number of rounds N. Therefore, due to the fact that such result makes the computation of the univariate polynomial the dominant step of the methodology, it is a good choice to make the security of Anemoi relying on that latter complexity bound. Moreover, our experimental results heavily support our choice. As a consequence, we will consider a threat model where the attacker is always able to efficiently compute the GB, focusing our attention on the second step of the Gröbner basis attack, meaning the univariate polynomial finding.</p>

    <h4 id="sec-23" class="text-lg font-semibold mt-6">7.2 Univariate polynomial finding complexities</h4>

    <p class="text-gray-300">Firstly, we introduce the currently known results. Secondly, we present the results with ω = 2.8074 and, in particular, we show how this complexity can be improved by using the Wiedemann algorithm. We will use {CFGLM, CpolyDet, ClinSeq} to denote the SparseFGLM (basis conversion), the determinant computation and the Wiedemann algorithm complexities respectively. Moreover, in Tables <a href="#page-31-0">2</a> to <a href="#page-32-0">4</a> we use underlined values to denote reduced number of rounds.</p>

    <p class="text-gray-300">Koschatko et al. [\\[29\\]](#page-36-2) apply the GB attack presented in Section <a href="#page-7-0">3</a> and its dominating complexity is represented by the Gröbner basis computation CGB (although their small scale experimental results showed it is not the dominating complexity). Table <a href="#page-29-0">1</a> presents their results showing the security level reached by the standard number of rounds of Anemoi. On the other hand, Bariant et al. [\\[3\\]](#page-34-5) present the attack based on the construction of the FreeLunch systems. In this case, the dominating complexity is represented by the matrix determinant computation CpolyDet. Table <a href="#page-29-0">1</a> summarizes their results showing the achieved security level with respect to the standard number of rounds of Anemoi. From a designer perspective it is important to notice that, whilst Koschatko et al. used ω = 2 as a conservative choice, Bariant et al. gave a more practical result by using ω = 2.8074, that is the algebra constant for the currently best known algorithm for matrix multiplication.</p>

    <p class="text-gray-300">Due to our improved results on CGB, our solution is applicable to more than 2 branches (l ≥ 1), and the dominating complexity is always represented by one of the methodologies ( <span class="math">C_{\\text{FGLM}}</span> ,  <span class="math">C_{\\text{polyDet}}</span> ,  <span class="math">C_{\\text{linSeq}}</span> ) we apply for the second step of the Gröbner basis attack. Moreover, the usage of the Wiedemann algorithm allows us to fully exploit the sparsity of the involved equations and multiplication matrices, leading to a significant improvement to the currently known attacks. As well explained in Subsection 6.3, both SparseFGLM both Wiedemann algorithm rely on the sparsity of the involved multiplication matrices. Hence, we derived the following conjecture for  <span class="math">\\alpha = 3.5</span> :</p>

    <p class="text-gray-300"><span id="page-30-0"></span>Conjecture 1 (Sparsity of the multiplication matrices). The level of sparsity of the multiplication matrices of the input variables  <span class="math">y_{i,0}</span>  for  <span class="math">1 \\le i \\le l</span> , computed as  <span class="math">\\mathbb{Z}/d_I^2</span>  where  <span class="math">\\mathbb{Z}</span>  is the number of non-zero entries, is approximately given by:</p>

    <p class="text-gray-300"><span class="math-block">Sparsity(T_i) \\approx \\begin{cases} 0.9e^{-1.148N}/l &amp; \\text{for } \\alpha = 3\\\\ 0.32e^{-1.06N}/l &amp; \\text{for } \\alpha = 5 \\end{cases}</span>  (20)</p>

    <p class="text-gray-300">With Conjecture 1, we can define the complexity given in Equation (18) with respect to the number of rounds of Anemoi.</p>

    <p class="text-gray-300">The corresponding probability of success, given in Equation (17), depends on the field size. When the required conditions are met, it is extremely high and close to 1. With this method we can give a correct value for the complexity of the Wiedemann algorithm without depending on the linear algebra constant, and we have seen that  <span class="math">\\log_{d_I}(C_{\\text{linSeq}})</span>  get closer to the conservative choice of  <span class="math">\\omega = 2</span>  when the number of rounds grows. From an experimental point of view, that result is more applicable than polyDet and SparseFGLM. Moreover, sparse matrices can be represented in the CSR format [33] which maintains the amount of memory usage low with respect to keeping in memory the entire matrix. This, together with the Keller-Gehrig algorithm [28] and the possibility of using the GPU to speed up the matrix-vector multiplication [25] needed to determine the linearly recurring sequence, leads to the possibility of experimentally applying that method also for larger matrices and more Anemoi rounds. Although, it must be kept in mind that having more RAM and being able to reduce the complexity of the multiplication matrix computation would give the possibility to refine the results given in Conjecture 1, leading to more accurate outcomes and to the extension to other values of  <span class="math">\\alpha</span> . Table 2 shows the complexity of the Wiedemann algorithm, with the Conjecture 1, applied to the standard number of rounds of Anemoi for  <span class="math">\\alpha = 3, 5</span> . For the sake of completeness, we also discuss the complexities given by the application of the other two methodologies for the univariate polynomial finding: SparseFGLM and polyDet.</p>

    <p class="text-gray-300">Main differences with the polyDet method applied by [3] The main difference between the complexity of the polyDet method applied in [3] and ours derives from the generated square multiplication matrices. The one generated by the FreeLunch attack is bigger than the proved value of  <span class="math">d_I</span> , leading to univariate polynomials of higher degree. Nevertheless, their method to compute the determinant works on the top-right matrix of dimension  <span class="math">\\alpha^N</span>  (notice that l=1 due to the fact that the FreeLunch method is not extending to more than 2 branches)</p>

    <p class="text-gray-300"><span id="page-31-0"></span>Table 2: Complexity given by linSeq,  <span class="math">ld_I(\\mathcal{Z} + log(d_I))</span> , with the Conjecture 1 on the sparsity level of the matrices. The first line shows the complexity of the algorithm with respect to the number of rounds of Anemoi and the second line shows the number of rounds whose complexity is below the target security level.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Security</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">12</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">28</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">56</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\alpha</span></td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">l=1</td>

            <td class="px-3 py-2 border-b border-gray-700">111 (21)<br>111 (21)</td>

            <td class="px-3 py-2 border-b border-gray-700">143 (21)<br>122 ( <u>18</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">196 (37)<br>196 (37)</td>

            <td class="px-3 py-2 border-b border-gray-700">253 (37)<br>253 (37)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">l = 2</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\begin{vmatrix} 171 &amp; (14) \\\\ 122 &amp; (\\underline{10}) \\end{vmatrix}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">212 (14)<br>120 ( <u>8</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\begin{vmatrix} 269 &amp; (22) \\\\ 245 &amp; (\\underline{20}) \\end{vmatrix}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">335 (22)<br>243 ( <u>16</u> )</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">l=3</td>

            <td class="px-3 py-2 border-b border-gray-700">230 (12)<br>115 ( <u>6</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">283 (12)<br>117 ( <u>5</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">326 (17)<br>249 ( <u>13</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">401 (17)<br>235 ( <u>10</u> )</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">whose columns have maximum degree a value  <span class="math">u_0</span>  defined as in [3, Definition 15]. As a consequence, even if the computation of the determinant is slightly better, its degree is higher than  <span class="math">d_I</span>  (as shown by [3] itself), making the last step of the Gröbner basis cryptanalysis worst. In contrast, in our case, the maximum degree of each column of the matrix  <span class="math">y_{i,0}\\mathbf{I}_{d_I} - T_i</span>  is 1, leading to a complexity of  <span class="math">d_I^{\\omega}</span>  for each input variable  <span class="math">y_{i,0}</span>  where  <span class="math">1 \\leq i \\leq l</span>  and to univariate polynomials of degree  <span class="math">d_I</span> . As a result, for a generic value of l, that is we can apply that method to more than 2 branches, the overall complexity of polyDet is  <span class="math">\\mathcal{O}(l \\cdot d_I^{\\omega})</span> . Table 3 shows the complexities given by polyDet when applied to the standard number of rounds of Anemoi.</p>

    <p class="text-gray-300"><span id="page-31-1"></span>Table 3: Complexity given by polyDet:  <span class="math">ld_I^{\\omega}</span> , for  <span class="math">\\omega=2.8074</span> . The first line shows the complexity of the algorithm with respect to the number of rounds of Anemoi, the second line shows the number of rounds whose complexity is below the target security level.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Security</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">7</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">28</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">56</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\alpha</span></td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">l=1</td>

            <td class="px-3 py-2 border-b border-gray-700">136 (21)<br>123 ( <u>19</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">165 (21)<br>126 ( <u>16</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">177 (20)<br>124 ( <u>14</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">197 (19)<br>124 ( <u>12</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">241 (37)<br>241 (37)</td>

            <td class="px-3 py-2 border-b border-gray-700">291 (37)<br>252 ( <u>32</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">320 (36)<br>249 ( <u>28</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">363 (35)<br>249 ( <u>24</u> )</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">l=2</td>

            <td class="px-3 py-2 border-b border-gray-700">183 (14)<br>118 ( <u>9</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">221 (14)<br>127 ( <u>8</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">232 (13)<br>125 ( <u>7</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">271 (13)<br>125 ( <u>6</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">287 (22)<br>248 ( <u>19</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">347 (22)<br>253 ( <u>16</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">374 (21)<br>250 ( <u>14</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">437 (21)<br>250 ( <u>12</u> )</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">l=3</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\begin{vmatrix} 236 &amp; (12) \\\\ 118 &amp; (\\underline{6}) \\end{vmatrix}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\begin{array}{c} 285 \\ (12) \\\\ 119 \\ (\\underline{5}) \\end{array}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">321 (12) \\\\ 108 (\\underline{4})</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">344 (11)</span> <span class="math">126 (\\underline{4})</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\begin{vmatrix} 334 &amp; (17) \\\\ 255 &amp; (\\underline{13}) \\end{vmatrix}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">403 (17)<br>238 ( <u>10</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">455 (17)<br>241 ( <u>9</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">531 (17)<br>250 ( <u>8</u> )</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">On the usage of SparseFGLM The application of FGLM is supported by Corollary 2. In particular, thanks to the high sparsity of the GB polynomials (Propositions 2 and 3) and of the derived multiplication matrices, we can apply SparseFGLM [20] (see Subsection 6.3). Table 4 shows the complexities given by SparseFGLM when applied to the standard number of rounds of Anemoi.</p>

    <p class="text-gray-300"><span id="page-32-0"></span>Table 4: Complexity given by deterministic SparseFGLM:  <span class="math">n_v \\cdot d_I^{\\omega} \\cdot \\log(d_I)</span> , for  <span class="math">\\omega = 2.8074</span> . The first line shows the complexity of the algorithm with respect to the number of rounds of Anemoi, the second line shows the number of rounds whose complexity is below the target security level.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Security</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">128</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">56</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\alpha</span></td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">l=1</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\begin{vmatrix} 147 &amp; (21) \\\\ 127 &amp; (\\underline{18}) \\end{vmatrix}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">176 (21)<br>120 ( <u>14</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">189 (20)<br>125 ( <u>13</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">208 (19)<br>124 ( <u>11</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">253 (37)<br>253 (37)</td>

            <td class="px-3 py-2 border-b border-gray-700">304 (37)<br>248 ( <u>30</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">333 (36)<br>252 ( <u>27</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">376 (35)<br>250 ( <u>23</u> )</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">l=2</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\begin{vmatrix} 194 &amp; (14) \\\\ 127 &amp; (\\underline{9}) \\end{vmatrix}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">232 (14)<br>120 ( <u>7</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">243 (13)<br>116 ( <u>6</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">282 (13)<br>113 ( <u>5</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">299 (22)<br>247 ( <u>18</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">360 (22)<br>248 ( <u>15</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">387 (21)<br>243 ( <u>13</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">450 (21)<br>240 ( <u>11</u> )</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">l=3</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\begin{vmatrix} 247 &amp; (12) \\\\ 107 &amp; (\\underline{5}) \\end{vmatrix}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">296 (12)<br>104 ( <u>4</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">333 (12)<br>116 ( <u>4</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">355 (11)<br>102 ( <u>3</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">346 (17)<br>247 ( <u>12</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">415 (17)<br>248 ( <u>10</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">467 (17)<br>252 ( <u>9</u> )</td>

            <td class="px-3 py-2 border-b border-gray-700">544 (17)<br>229 ( <u>7</u> )</td>

          </tr>

        </tbody>

      </table>

    </div>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">7.3 Small scale experimental results</h4>

    <p class="text-gray-300">We experimentally test the methodologies in Subsection 6.1 on the  <span class="math">A_{\\rm CICO}</span>  Model applied to a small version of Anemoi. In particular, those results where achieved for Anemoi over  <span class="math">\\mathbb{F}_q</span>  with a 31-bits prime q=1481823929 on a machine with Intel Xeon(R) Gold 6342 CPU @ 2.80GHz (32 cores), 48GB RAM and NVIDIA 48GB L40 GPU under Ubuntu 22.04 using SageMath [40], MSOLVE [6], NTL [35], Macaulay2 [24], Singular [16] and FLINT [39]. Our experimental results and the derived conjectures perfectly match with the theoretical ones. Further details can be found Appendix H.</p>

    <p class="text-gray-300">Comparison with previous works Previous works [3, 29] were able to apply their model to the case l=1 (Anemoi with 2 branches) without mentioning the possibility to extend the attack to more branches. Due to their construction,  <span class="math">P_{\\rm CICO}</span>  and  <span class="math">F_{\\rm CICO}</span>  models are not efficient enough to be applied to more than 2 branches. Moreover, neither the Bariant et al. approach [3] is possible to extend to more than two branches due to the impossibility of finding valid (positive) monomial weights for the generation of the FreeLunch system. Therefore, thanks to our methodology we were able to (a.) precisely define the complexity of computing the GB for Anemoi (b.) reduce the complexity of the first two steps of the attack (see Section 3) and, then, (c.) apply it to more than two branches. Moreover, we supported the application of the FGLM algorithms by proving the Shape</p>

    <p class="text-gray-300">Lemma for Anemoi (and, in general, for a particular type of zero-dimensional ideals which can be frequently found in algebraic cryptanalysis).</p>

    <p class="text-gray-300">We acknowledge the helpful discussion of the results in <a href="#page-34-5">\\[3,</a> [29\\]](#page-36-2) with the corresponding authors during the workshop ALPSY<a href="#page-33-0">3</a> (2024). Parts of this work were included in Luca Campa's Master's Thesis [\\[11\\]](#page-35-13) at the University of Udine.</p>

    <p class="text-gray-300"><span id="page-33-0"></span><sup>3</sup> <https://alpsy-workshop.github.io></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-34-4"></span><span id="page-34-0"></span>[1] Albrecht, M.R., Cid, C., Grassi, L., Khovratovich, D., Lüftenegger, R., Rechberger, C., Schofnegger, M.: Algebraic cryptanalysis of STARKfriendly designs: Application to MARVELlous and MiMC. In: Galbraith, S.D., Moriai, S. (eds.) Advances in Cryptology - ASIACRYPT 2019, Proceedings, Part III. Lecture Notes in Computer Science, vol. 11923, pp. 371– 397. Springer (2019). <https://doi.org/10.1007/978-3-030-34618-8\\_13></li>

      <li><span id="page-34-3"></span>[2] Albrecht, M.R., Grassi, L., Rechberger, C., Roy, A., Tiessen, T.: MiMC: Efficient encryption and cryptographic hashing with minimal multiplicative complexity. In: Cheon, J.H., Takagi, T. (eds.) Advances in Cryptology - ASIACRYPT 2016, Proceedings, Part I. Lecture Notes in Computer Science, vol. 10031, pp. 191–219 (2016). <a href="https://doi.org/10.1007/978-3-662-53887-6\\_7">https://doi.org/10.1007/</a> <a href="https://doi.org/10.1007/978-3-662-53887-6\\_7">978-3-662-53887-6\\\\_7</a></li>

      <li><span id="page-34-5"></span>[3] Bariant, A., Boeuf, A., Lemoine, A., Ayala, I.M., Øygarden, M., Perrin, L., Raddum, H.: The Algebraic FreeLunch: Efficient Gröbner basis attacks against Arithmetization-Oriented primitives. In: Reyzin, L., Stebila, D. (eds.) Advances in Cryptology - CRYPTO 2024, Proceedings, Part IV. Lecture Notes in Computer Science, vol. 14923, pp. 139–173. Springer (2024). <https://doi.org/10.1007/978-3-031-68385-5\\_5></li>

      <li><span id="page-34-8"></span>[4] Berlekamp, E.R.: Factoring polynomials over large finite fields p. 223 (1971). <https://doi.org/10.1145/800204.806290></li>

      <li><span id="page-34-7"></span>[5] Berlekamp, E.R.: Algebraic Coding Theory - Revised Edition. WorldScientific (2015). <https://doi.org/10.1142/9407></li>

      <li><span id="page-34-9"></span>[6] Berthomieu, J., Eder, C., Safey El Din, M.: msolve: A Library for Solving Polynomial Systems. In: 2021 International Symposium on Symbolic and Algebraic Computation. pp. 51–58. 46th International Symposium on Symbolic and Algebraic Computation, ACM (2021). <a href="https://doi.org/10.1145/3452143.3465545">https://doi.org/10.</a> <a href="https://doi.org/10.1145/3452143.3465545">1145/3452143.3465545</a></li>

      <li><span id="page-34-6"></span>[7] Bouvier, C., Briaud, P., Chaidos, P., Perrin, L., Salen, R., Velichkov, V., Willems, D.: New design techniques for efficient arithmetization-oriented hash functions: Anemoi permutations and Jive compression mode. In: Handschuh, H., Lysyanskaya, A. (eds.) CRYPTO 2023, Part III. LNCS, vol. 14083, pp. 507–539. Springer, Heidelberg, Germany (2023). <a href="https://doi.org/10.1007/978-3-031-38548-3_17">https:</a> <a href="https://doi.org/10.1007/978-3-031-38548-3_17">//doi.org/10.1007/978-3-031-38548-3\\\\_17</a></li>

      <li><span id="page-34-1"></span>[8] Buchmann, J., Pyshkin, A., Weinmann, R.: A zero-dimensional Gröbner basis for AES-128. In: Robshaw, M.J.B. (ed.) Fast Software Encryption, 13th International Workshop, FSE 2006, Revised Selected Papers. Lecture Notes in Computer Science, vol. 4047, pp. 78–88. Springer (2006). <a href="https://doi.org/10.1007/11799313\\_6">https:</a> <a href="https://doi.org/10.1007/11799313\\_6">//doi.org/10.1007/11799313\\\\_6</a></li>

      <li><span id="page-34-2"></span>[9] Bulygin, S., Brickenstein, M.: Obtaining and solving systems of equations in key variables only for the small variants of AES. Math. Comput. Sci. 3(2), 185–200 (2010). <https://doi.org/10.1007/S11786-009-0020-Y></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-35-11"></span>[10] Caminata, A., Gorla, E.: Solving multivariate polynomial systems and an invariant from commutative algebra. In: Bajard, J., Topuzoglu, A. (eds.) Arithmetic of Finite Fields - 8th International Workshop, WAIFI 2020, Revised Selected and Invited Papers. Lecture Notes in Computer Science, vol. 12542, pp. 3–36. Springer (2020). <a href="https://doi.org/10.1007/978-3-030-68869-1\\_1">https://doi.org/10.1007/</a> <a href="https://doi.org/10.1007/978-3-030-68869-1\\_1">978-3-030-68869-1\\\\_1</a></li>

      <li><span id="page-35-13"></span>[11] Campa, L.: Gröbner Basis Cryptanalysis and its Application to Arithmetization Oriented Symmetric Primitives. Master's thesis, University of Udine (IT), University of Klagenfurt (AU) (2024), <a href="https://netlibrary.aau.at/obvuklhs/content/titleinfo/11390967/full.pdf">https://netlibrary.aau.at/</a> <a href="https://netlibrary.aau.at/obvuklhs/content/titleinfo/11390967/full.pdf">obvuklhs/content/titleinfo/11390967/full.pdf</a></li>

      <li><span id="page-35-9"></span>[12] Cantor, D.G., Zassenhaus, H.: A new algorithm for factoring polynomials over finite fields. Mathematics of Computation 36(154), 587–592 (1981)</li>

      <li><span id="page-35-8"></span>[13] Cox, D., D'andrea, C.: Subresultants and the Shape Lemma. Math. Comput. 92(343), 2355–2379 (2023). <https://doi.org/10.1090/MCOM/3840></li>

      <li><span id="page-35-2"></span>[14] Cox, D.A., Little, J., O'Shea, D.: Ideals, Varieties, and Algorithms. Undergraduate Texts in Mathematics, Springer, fourth edn. (2015). <a href="https://doi.org/10.1007/978-3-319-16721-3">https:</a> <a href="https://doi.org/10.1007/978-3-319-16721-3">//doi.org/10.1007/978-3-319-16721-3</a></li>

      <li><span id="page-35-3"></span>[15] Cox, D.A., Little, J.B., O'Shea, D.: Using Algebraic Geometry, Graduate Texts in Mathematics, vol. 185. Springer, first edn. (1998). <a href="https://doi.org/10.1007/978-1-4757-6911-1">https://doi.</a> <a href="https://doi.org/10.1007/978-1-4757-6911-1">org/10.1007/978-1-4757-6911-1</a></li>

      <li><span id="page-35-12"></span>[16] Decker, W., Greuel, G.M., Pfister, G., Schönemann, H.: Singular 4-3-0 — A computer algebra system for polynomial computations. <a href="http://www.singular.uni-kl.de">http://www.</a> <a href="http://www.singular.uni-kl.de">singular.uni-kl.de</a> (2022)</li>

      <li><span id="page-35-10"></span>[17] Elia, M., Schipani, D.: Improvements on Cantor-Zassenhaus factorization algorithm. arXiv preprint arXiv:1012.5322 (2010)</li>

      <li><span id="page-35-5"></span>[18] Faugère, J.C.: A new efficient algorithm for computing gröbner bases without reduction to zero (F5). In: Proceedings of the 2002 International Symposium on Symbolic and Algebraic Computation. p. 75–83. ISSAC '02, Association for Computing Machinery (2002). <a href="https://doi.org/10.1145/780506.780516">https://doi.org/10.1145/</a> <a href="https://doi.org/10.1145/780506.780516">780506.780516</a></li>

      <li><span id="page-35-6"></span>[19] Faugère, J., Gianni, P.M., Lazard, D., Mora, T.: Efficient computation of zero-dimensional Gröbner bases by change of ordering. J. Symb. Comput. 16(4), 329–344 (1993). <https://doi.org/10.1006/JSCO.1993.1051></li>

      <li><span id="page-35-7"></span>[20] Faugère, J., Mou, C.: Sparse FGLM algorithms. J. Symb. Comput. 80, 538– 569 (2017). <https://doi.org/10.1016/J.JSC.2016.07.025></li>

      <li><span id="page-35-4"></span>[21] Faugére, J.C.: A new efficient algorithm for computing gröbner bases (F4). Journal of Pure and Applied Algebra 139(1), 61–88 (1999). <a href="https://doi.org/https://doi.org/10.1016/S0022-4049(99">https://doi.</a>00005-5) <a href="https://doi.org/https://doi.org/10.1016/S0022-4049(99">org/https://doi.org/10.1016/S0022-4049\\(99\\)00005-5</a>00005-5)</li>

      <li><span id="page-35-0"></span>[22] Grassi, L., Khovratovich, D., Rechberger, C., Roy, A., Schofnegger, M.: Poseidon: A new hash function for zero-knowledge proof systems. In: Bailey, M.D., Greenstadt, R. (eds.) 30th USENIX Security Symposium, USENIX Security 2021. pp. 519–535. USENIX Association (2021), <a href="https://www.usenix.org/conference/usenixsecurity21/presentation/grassi">https://www.</a> <a href="https://www.usenix.org/conference/usenixsecurity21/presentation/grassi">usenix.org/conference/usenixsecurity21/presentation/grassi</a></li>

      <li><span id="page-35-1"></span>[23] Grassi, L., Lüftenegger, R., Rechberger, C., Rotaru, D., Schofnegger, M.: On a generalization of substitution-permutation networks: The HADES design strategy. In: Canteaut, A., Ishai, Y. (eds.) Advances in Cryptology -</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>EUROCRYPT 2020, Proceedings, Part II. Lecture Notes in Computer Science, vol. 12106, pp. 674–704. Springer (2020). <a href="https://doi.org/10.1007/978-3-030-45724-2\\_23">https://doi.org/10.1007/</a> <a href="https://doi.org/10.1007/978-3-030-45724-2\\_23">978-3-030-45724-2\\\\_23</a></li>

      <li><span id="page-36-14"></span>[24] Grayson, D.R., Stillman, M.E.: Macaulay2, a software system for research in algebraic geometry. Available at <http://www2.macaulay2.com></li>

      <li><span id="page-36-12"></span>[25] Greathouse, J.L., Daga, M.: Efficient sparse matrix-vector multiplication on GPUs using the CSR storage format. In: Damkroger, T., Dongarra, J.J. (eds.) International Conference for High Performance Computing, Networking, Storage and Analysis, SC 2014. pp. 769–780. IEEE Computer Society (2014). <https://doi.org/10.1109/SC.2014.68></li>

      <li><span id="page-36-7"></span>[26] Harrison, G., Johnson, J., Saunders, B.D.: Probabilistic analysis of Wiedemann's algorithm for minimal polynomial computation. J. Symb. Comput. 74, 55–69 (2016). <https://doi.org/10.1016/J.JSC.2015.06.005></li>

      <li><span id="page-36-4"></span>[27] Kaltofen, E., Shoup, V.: Subquadratic-time factoring of polynomials over finite fields. In: 27th ACM STOC. pp. 398–406. ACM Press (1995). <a href="https://doi.org/10.1145/225058.225166">https:</a> <a href="https://doi.org/10.1145/225058.225166">//doi.org/10.1145/225058.225166</a></li>

      <li><span id="page-36-11"></span>[28] Keller-Gehrig, W.: Fast algorithms for the characteristics polynomial. Theoretical Computer Science 36, 309–317 (1985). <a href="https://doi.org/https://doi.org/10.1016/0304-3975(85">https://doi.org/https:</a>90049-0) <a href="https://doi.org/https://doi.org/10.1016/0304-3975(85">//doi.org/10.1016/0304-3975\\(85\\)90049-0</a>90049-0)</li>

      <li><span id="page-36-2"></span>[29] Koschatko, K., Lüftenegger, R., Rechberger, C.: Exploring the six worlds of gröbner basis cryptanalysis: Application to Anemoi. IACR Trans. Symmetric Cryptol. 2024(4), 138–190 (2024). <a href="https://doi.org/10.46586/TOSC.V2024.I4.138-190">https://doi.org/10.46586/TOSC.</a> <a href="https://doi.org/10.46586/TOSC.V2024.I4.138-190">V2024.I4.138-190</a></li>

      <li><span id="page-36-3"></span>[30] Labahn, G., Neiger, V., Zhou, W.: Fast, deterministic computation of the hermite normal form and determinant of a polynomial matrix. J. Complex. 42, 44–71 (2017). <https://doi.org/10.1016/J.JCO.2017.03.003></li>

      <li><span id="page-36-5"></span>[31] Manocha, D.: Multipolynomial resultant algorithms. J. Symb. Comput. 15(2), 99–122 (1993). <https://doi.org/10.1006/JSCO.1993.1009></li>

      <li><span id="page-36-6"></span>[32] Manocha, D.: Solving systems of polynomial equations. IEEE Computer Graphics and Applications 14(2), 46–55 (1994). <a href="https://doi.org/10.1109/38.267470">https://doi.org/10.</a> <a href="https://doi.org/10.1109/38.267470">1109/38.267470</a></li>

      <li><span id="page-36-10"></span>[33] Oberhuber, T., Suzuki, A., Vacata, J.: New row-grouped CSR format for storing the sparse matrices on GPU with implementation in CUDA. CoRR abs/1012.2270 (2010), <http://arxiv.org/abs/1012.2270></li>

      <li><span id="page-36-0"></span>[34] Shannon, C.E.: Communication theory of secrecy systems. Bell Syst. Tech. J. 28(4), 656–715 (1949). <a href="https://doi.org/10.1002/J.1538-7305.1949.TB00928.X">https://doi.org/10.1002/J.1538-7305.1949.</a> <a href="https://doi.org/10.1002/J.1538-7305.1949.TB00928.X">TB00928.X</a></li>

      <li><span id="page-36-13"></span>[35] Shoup, V.: NTL: A library for doing number theory. <https://libntl.org/></li>

      <li><span id="page-36-8"></span>[36] Shoup, V.: Factoring polynomials over finite fields: Asymptotic complexity vs. reality (1993), <a href="https://api.semanticscholar.org/CorpusID:15241727">https://api.semanticscholar.org/CorpusID:</a> <a href="https://api.semanticscholar.org/CorpusID:15241727">15241727</a></li>

      <li><span id="page-36-9"></span>[37] Shoup, V.: Ntl vs flint. <https://libntl.org/benchmarks.pdf> (2021)</li>

      <li><span id="page-36-1"></span>[38] Steiner, M.J.: Solving degree bounds for iterated polynomial systems. IACR Trans. Symmetric Cryptol. 2024(1), 357–411 (2024). <a href="https://doi.org/10.46586/TOSC.V2024.I1.357-411">https://doi.org/</a> <a href="https://doi.org/10.46586/TOSC.V2024.I1.357-411">10.46586/TOSC.V2024.I1.357-411</a></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-37-7"></span>[39] team, T.F.: FLINT: Fast Library for Number Theory (2023), version 3.0.0, <https://flintlib.org></li>

      <li><span id="page-37-6"></span>[40] The Sage Developers: SageMath, the Sage Mathematics Software System (Version 10.4.0) (2024), https://www.sagemath.org</li>

      <li><span id="page-37-2"></span>[41] Weinmann, R.P.: Evaluating algebraic attacks on the AES. Diplom thesis, Technische Universität Darmstadt (2003)</li>

      <li><span id="page-37-5"></span>[42] Wiedemann, D.H.: Solving sparse linear equations over finite fields. IEEE Trans. Inf. Theory 32(1), 54–62 (1986). <a href="https://doi.org/10.1109/TIT.1986.1057137">https://doi.org/10.1109/TIT.</a> <a href="https://doi.org/10.1109/TIT.1986.1057137">1986.1057137</a></li>

      <li><span id="page-37-3"></span>[43] Williams, V.V.: Multiplying matrices faster than coppersmith-winograd. In: Karloff, H.J., Pitassi, T. (eds.) 44th ACM STOC. pp. 887–898. ACM Press (2012). <https://doi.org/10.1145/2213977.2214056></li>

    </ul>

    <h2 id="sec-27" class="text-2xl font-bold">A Mathematical background</h2>

    <p class="text-gray-300"><span id="page-37-4"></span>Lemma 14. Let G be a Gröbner basis for the ideal I ⊂ R = K[x1, . . . , xn]. The ideal I is zero-dimensional if and only if for each 1 ≤ i ≤ n, there exist an element in G whose initial term is a pure power of xi:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\mathbb{V}(I) \\ \\textit{finite} \\ \\iff \\forall_{i=1}^n (\\exists \\ f \\in G \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ \\mathsf{LM}(f) = x_i^{\\alpha_i}) \\quad \\textit{where} \\ \\alpha_i \\in \\mathbb{N}.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Theorem 9 (Shape Lemma). Let I be a zero-dimensional radical ideal such that the x<sup>n</sup> coordinate of the points in V(I) are distinct. Let G be a reduced Gröbner basis for I relative to a LEX monomial order with x<sup>n</sup> as the last variable. G consists of n polynomials</p>

    <div class="my-4 text-center"><span class="math-block">\\{x_1-g_1(x_n),x_2-g_2(x_n),\\ldots,g_n(x_n)\\}\\</span></div>

    <p class="text-gray-300">where deg(gi) < deg(gn) for each 1 ≤ i < n and deg(gn) = dimK(K[x1, . . . , xn]/I). We say, equivalently, that the ideal I has shape lemma or shape form.</p>

    <p class="text-gray-300">We provide a brief description of the main components of Anemoi that are important to follow our GB cryptanalysis</p>

    <p class="text-gray-300">• Linear Layer: The Anemoi state consists of 2l elements (X, Y ) ∈ F l <sup>q</sup> × F l q where l ≥ 1. After constant addition to the state, linear transformations M<sup>l</sup> and M<sup>l</sup> ◦ ρ are applied to the two halves X and Y respectively. On this output a pseudo-hadamard transform denoted as P is applied to the vector (X, Y ). The examples of matrices M<sup>l</sup> are</p>

    <div class="my-4 text-center"><span class="math-block">M_1 = \\begin{bmatrix} 1 \\end{bmatrix} \\quad M_2 = \\begin{bmatrix} 1 &amp; g \\\\ g &amp; g^2 + 1 \\end{bmatrix}</span></div>

    <p class="text-gray-300">Examples of more matrices and ρ are provided in Appendix <a href="#page-38-0">B.1.</a> For our analysis, we will denote as L the block of operations composed by the round constant addition and the linear transformations.</p>

    <p class="text-gray-300">• Non-linear layer: Let  <span class="math">Q_{\\gamma} : \\mathbb{F}_q \\to \\mathbb{F}_q</span> ,  <span class="math">Q_{\\delta} : \\mathbb{F}_q \\to \\mathbb{F}_q</span>  be quadratic polynomials and let  <span class="math">E : \\mathbb{F}_q \\to \\mathbb{F}_q</span>  be a power map inducing the low-degree permutation over  <span class="math">\\mathbb{F}_q</span> , that is  <span class="math">E = x^{\\alpha}</span>  with  <span class="math">\\alpha \\geq 3</span>  coprime with  <span class="math">\\varphi(q)</span> . The non-linear layer is a so-called open Flystel, denoted as H, applied component-wise to X and Y (Figure 1).  <span class="math">Q_{\\gamma}</span>  and  <span class="math">Q_{\\delta}</span>  are defined as follows:</p>

    <div class="my-4 text-center"><span class="math-block">Q_{\\gamma} = \\begin{cases} \\beta x^2 + \\gamma &amp; \\text{if } q &gt; 2 \\text{ is prime} \\\\ \\beta x^3 + \\gamma &amp; \\text{if } q = 2^n \\end{cases} \\quad Q_{\\delta} = \\begin{cases} \\beta x^2 + \\delta &amp; \\text{if } q &gt; 2 \\text{ is prime} \\\\ \\beta x^3 + \\delta &amp; \\text{if } q = 2^n \\end{cases}</span></div>

    <p class="text-gray-300">where common values for  <span class="math">\\beta, \\gamma</span>  and  <span class="math">\\delta</span>  are respectively g (generator of the multiplicative subgroup of the field  <span class="math">\\mathbb{F}_q</span> ), 0 and  <span class="math">g^{-1} \\mod q</span> .</p>

    <p class="text-gray-300">The Anemoi permutation on inputs  <span class="math">(\\mathbf{x}_0, \\mathbf{y}_0) = (x_{1,0}, \\dots, x_{l,0}, y_{1,0}, \\dots, y_{l,0})</span>  (where  <span class="math">w_{i,j}</span>  denotes the <em>i</em>-th input w of the <em>j</em>-th round and  <span class="math">\\mathbf{w}_j = \\{w_{1,j}, \\dots, w_{l,j}\\}</span> ) can be summarized by the following function:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathtt{Anemoi}_{q,\\alpha}(\\mathbf{x}_0,\\mathbf{y}_0) = L \\circ R_N \\circ R_{N-1} \\circ \\cdots \\circ R_1(\\mathbf{x}_0,\\mathbf{y}_0) = (\\mathbf{x}_{N+1},\\mathbf{y}_{N+1})</span></div>

    <p class="text-gray-300">where N is the number of rounds.</p>

    <h2 id="sec-29" class="text-2xl font-bold">Flystel evaluation and verification in detail</h2>

    <p class="text-gray-300">Evaluation phase Let  <span class="math">x_i, y_i</span>  be the inputs to the open Flystel procedure that we denoted as H. The output of H is:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{bmatrix} u_i \\\\ v_i \\end{bmatrix} = H \\begin{pmatrix} \\begin{bmatrix} x_i \\\\ y_i \\end{bmatrix} \\end{pmatrix} = \\begin{bmatrix} x_i - Q_\\gamma(y_i) + Q_\\delta(y_i - E^{-1}(x_i - Q_\\gamma(y_i))) \\\\ y_i - E^{-1}(x_i - Q_\\gamma(y_i)) \\end{bmatrix}</span></div>

    <p class="text-gray-300">Verification phase It is the corresponding counterpart of the open Flystel procedure, and it is called <em>closed</em> Flystel (denoted as V). It is defined in order to verify that  <span class="math">(u_i, v_i) = H(x_i, y_i)</span> . That operation is equivalent to verify that  <span class="math">(x_i, u_i) = V(y_i, v_i)</span> . The output of V is:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{bmatrix} x_i \\\\ u_i \\end{bmatrix} = V \\left( \\begin{bmatrix} y_i \\\\ v_i \\end{bmatrix} \\right) = \\begin{bmatrix} Q_\\gamma(y_i) + E(y_i - v_i) \\\\ Q_\\delta(v_i) + E(y_i - v_i) \\end{bmatrix}</span></div>

    <p class="text-gray-300">Refer to Figure 1 for the meaning of these formulas.</p>

    <h4 id="sec-30" class="text-lg font-semibold mt-6"><strong>B.1</strong> Matrices and parameters</h4>

    <p class="text-gray-300">For l = 3, 4 the matrices involved in the linear layer are</p>

    <div class="my-4 text-center"><span class="math-block">M_3 = \\begin{bmatrix} g+1 &amp; 1 &amp; g+1 \\\\ 1 &amp; 1 &amp; g \\\\ g &amp; 1 &amp; 1 \\end{bmatrix}, \\quad M_4 = \\begin{bmatrix} 1 &amp; g^2 &amp; g^2 &amp; g+1 \\\\ g+1 &amp; g^2+g &amp; g^2 &amp; 2g+1 \\\\ g &amp; g+1 &amp; 1 &amp; g \\\\ g &amp; 2g+1 &amp; g+1 &amp; g+1 \\end{bmatrix}</span></div>

    <p class="text-gray-300">Moreover, the permutation ρ is defined as a circular shift by one position, meaning that the first entry is moved to the last position while shifting the other ones to the previous position:</p>

    <pre><code class="language-text">ρ(i) := (i − 1) mod l for i ∈ {0, . . . , l − 1}.</code></pre>

    <p class="text-gray-300"><span id="page-39-2"></span>In the Anemoi proposal, the authors provide different number of rounds depending on the choice of (α), the number of branches (2l) and the target security levels. These values are summarized in Table <a href="#page-39-2">5.</a></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Security</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">128</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">256</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">α</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">7 11 3</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">7 11</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">l = 1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">21 21 20 19 37 37 36 35</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">l = 2</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">14 14 13 13 22 22 21 21</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">l = 3</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">12 12 12 11 17 17 17 17</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 5: Number of rounds for Anemoi [\\[7\\]](#page-34-6)</p>

    <p class="text-gray-300"><span id="page-39-1"></span>Algorithm 1 Buchberger Gröbner basis algorithm</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">13: B := B ∪ {(i, t)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1 ≤ i ≤ t − 1}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">14: B := B \\ {(i, j)}</p>

    <p class="text-gray-300">15: return G</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">## 1: procedure getGB(F = {f1, . . . , fn}) ▷ 2: B := {(i, j)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1 ≤ i < j ≤ n} 3: G := F 4: t := n 5: while B ̸= ∅ do 6: Select (i, j) ∈ B 7: if lcm(LM(fi), LM(f<sup>j</sup> )) ̸= LM(fi)LM(f<sup>j</sup> )∧Criterion(fi, f<sup>j</sup> , B) = False then 8: r := RedG(S(fi, f<sup>j</sup> )) 9: if r ̸= 0 then 10: t := t + 1 11: f<sup>t</sup> := r 12: G := G ∪ {ft}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where Criterion(f<sup>i</sup> , f<sup>j</sup> , B) is True if and only if there exist some l /∈ {i, j} for which the pairs [i, l] and [j, l] are not in B and LM(fl) divides lcm(LM(fi), LM(f<sup>j</sup> )).</p>

    <h2 id="sec-32" class="text-2xl font-bold">D Wiedemann algorithms</h2>

    <p class="text-gray-300">Wiedemann algorithm is one of the main techniques for solving the second pat of the Gröbner basis cryptanalysis methodology. There exist two versions of the algorithm:</p>

    <p class="text-gray-300">• the probabilistic algorithm (Algorithm <a href="#page-40-1">2\\)</a> has a runtime complexity of</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{O}(d_I(\\mathcal{Z} + \\log(d_I))) \\tag{21}</span></div>

    <p class="text-gray-300">operation in K, where Z is the number of non-zero entries in T<sup>i</sup> . It returns, with large probability, the minimal polynomial associated to the generated sequence [\\[42\\]](#page-37-5).</p>

    <p class="text-gray-300">• the deterministic algorithm (Algorithm <a href="#page-40-2">3\\)</a> has a runtime complexity of</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{O}(d_I(\\mathcal{Z} + d_I \\log(d_I) \\log \\log(d_I))) \\tag{22}</span></div>

    <p class="text-gray-300">operations in K, where Z is still the number of non-zero entries in T<sup>i</sup> .</p>

    <h2 id="sec-33" class="text-2xl font-bold">Algorithm 2 Probabilistic Algorithm <a href="#page-35-7">\\[20,</a> [42\\]](#page-37-5)</h2>

    <pre><code class="language-text">1: procedure getMinPoly(Ti, dI ) ▷ The polynomial fi relative to xi
2: e := (1, 0, . . . , 0)T ∈ K
                          dI×1
3: Choose r0 = r ∈ K
                       dI×1
                           randomly
4: for j = 1, . . . , 2dI − 1 do
5: rj := (Ti)
                 T
                   rj−1
6: Generate the sequence s := [⟨rj , e⟩ : j = 0, . . . , 2dI − 1]
7: fi := BerlekampMassey(s)
8: return fi</code></pre>

    <h4 id="sec-34" class="text-lg font-semibold mt-6">Algorithm 3 Deterministic Algorithm <a href="#page-35-7">\\[20,</a> [42\\]](#page-37-5)</h4>

    <pre><code class="language-text">1: procedure getMinPoly(Ti, dI ) ▷ The polynomial fi relative to xi
2: e1 := (1, 0, . . . , 0)T
                        , e2 := (0, 1, . . . , 0)T
                                           , . . . , edI
                                                    := (0, 0, . . . , 1)T ∈ K
                                                                        dI×1
3: k := 1; F := []; f := 1; d := 0; b := e1; S := []
4: while b ̸= 0 do
5: s := [⟨ek, Tj
                    i b⟩ : j = 0, . . . , 2dI − 1]
6: g := BerlekampMassey(s)
7: f := f · g; d := deg(f); F := F + [g]; b := g(Ti)b; S := S + [s]
8: k := k + 1
9: h =
           Q
             f∈F
                 f
10: return h</code></pre>

    <p class="text-gray-300">In this section we prove the lemmas required by Proposition <a href="#page-19-1">2</a> and Proposition <a href="#page-23-0">3.</a> We will denote the S-polynomial of two polynomials a, b as S(a, b) that is defined as</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{S}(a,b) = \\frac{lcm(\\mathsf{LM}(a),\\mathsf{LM}(b))}{LT(a)} a - \\frac{lcm(\\mathsf{LM}(a),\\mathsf{LM}(b))}{LT(b)} b.</span></div>

    <p class="text-gray-300">S(a, b) G denotes the reduction of the S-polynomial by the set of polynomials in G w.r.t to the corresponding monomial ordering. We use LMk(f) to denote the k th (≥ 2) monomial of the polynomial f.</p>

    <p class="text-gray-300"><span id="page-41-2"></span>Lemma 15. Let p<sup>i</sup> , p<sup>j</sup> ∈ K[x] be such that LM(pi) = LM(p<sup>j</sup> ) and LMt(pi) = LMt(p<sup>j</sup> ) for k ≥ t ≥ 2, then</p>

    <div class="my-4 text-center"><span class="math-block">S_{i,j} := S(p_i, p_j) = \\frac{p_i}{LC(p_i)} - \\frac{p_j}{LC(p_j)}</span></div>

    <p class="text-gray-300">Moreover, LM(Si,j ) = LM2(pi) = LM2(p<sup>j</sup> ), and for t ≤ k − 1</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{LM}_t(\\mathcal{S}_{i,j}) = \\mathsf{LM}_{t+1}(p_i) = \\mathsf{LM}_{t+1}(p_j).</span></div>

    <p class="text-gray-300">Proof. Let p<sup>i</sup> , p<sup>j</sup> ∈ K[xn] such that LM(pi) = LM(p<sup>j</sup> ) and LMt(pi) = LMt(p<sup>j</sup> ) for k ≥ t ≥ 2. Since lcm(LM(pi), LM(p<sup>j</sup> )) = LM(pi) = LM(p<sup>j</sup> ), from the definition of S-polynomial we have</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{S}_{i,j} = \\mathcal{S}(p_i, p_j) = \\frac{\\mathsf{LM}(p_i)}{LT(p_i)} p_i - \\frac{\\mathsf{LM}(p_j)}{LT(p_j)} p_j = \\frac{1}{LC(p_i)} p_i - \\frac{1}{LC(p_j)} p_j</span></div>

    <p class="text-gray-300">Since LM(pi) = LM(p<sup>j</sup> ), it is clear that LM(Si,j ) = LM2(pi) and LMt(Si,j ) = LMt+1(pi) where 2 ≤ t ≤ k − 1. Hence, the result follows.</p>

    <h2 id="sec-36" class="text-2xl font-bold">E.1 Lemmas for DRL case</h2>

    <p class="text-gray-300">Proof (Lemma <a href="#page-17-3">2\\)</a>. Each bi,<sup>1</sup> is described as follows</p>

    <p class="text-gray-300"><span class="math-block">b_{i,1} := \\sum_{k=1}^{l} c_{i,k} y_{k,0} - y_{i,1} - s_{i,1}</span>  where  <span class="math">c_{i,k} \\in \\mathbb{K}</span> .</p>

    <p class="text-gray-300">Observe that LMt(bi,1) = LMt(bj,1) for all 1 ≤ i, j ≤ l and 1 ≤ t ≤ l. The Step 2 of Algorithm <a href="#page-39-1">1</a> uses the pairs (bi,1, bj,1) with i < j for 1 ≤ i, j ≤ l. But, Buchberger Criterion (Appendix <a href="#page-39-0">C\\)</a>, reduces it to l − 1 pairs (b1,1, bj,1) where 1 < j ≤ l.</p>

    <p class="text-gray-300">For each S (0) j := S(b1,1, bj,1), using Lemma <a href="#page-41-2">15,</a> we have</p>

    <p class="text-gray-300"><span class="math-block">\\mathsf{LM}(\\mathcal{S}_{j}^{(0)}) = \\mathsf{LM}_{2}(b_{1,1})</span>  and  <span class="math">\\mathsf{LM}_{t}(\\mathcal{S}_{j}^{(0)}) = \\mathsf{LM}_{t+1}(b_{1,1})</span>  for  <span class="math">2 \\le t \\le l-1</span> .</p>

    <p class="text-gray-300">Next, we compute S-polynomials from the l − 1 polynomials S (0) j (2 ≤ j ≤ l) using l − 2 pairs (S (0) 2 , S (0) i ) for 2 < i ≤ l. For each S (1) i := S(S (0) 2 , S (0) i ), by Lemma <a href="#page-41-2">15,</a> we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\mathsf{LM}(\\mathcal{S}_i^{(1)}) &amp;= \\mathsf{LM}_2(\\mathcal{S}_2^{(0)}) = \\mathsf{LM}_3(b_{1,1}) \\\\ \\mathsf{LM}_2(\\mathcal{S}_i^{(1)}) &amp;= \\mathsf{LM}_3(\\mathcal{S}_2^{(0)}) = \\mathsf{LM}_4(b_{1,1}) \\end{split}</span></div>

    <p class="text-gray-300">Next we proceed in the same way with l−2 polynomials S (1) i . Continuing this way l − 1 times we get only one pair (S (l−2) l−1 , S (l−2) l ) and thus one S-polynomial output S (l−1) l := S(S (l−2) l−1 , S (l−2) l ) with leading monomial yl,<sup>0</sup> = LMl(b1,1).</p>

    <p class="text-gray-300">The overall complexity is given by O( (l−1)l 2 2 ) field operations.</p>

    <p class="text-gray-300">Proof (Lemma <a href="#page-18-1">3\\)</a>. Since mi,r := Qδ(yi,r−1) + E(si,r−1), the polynomial bi,r is described with the following set of monomials (sorted w.r.t DRL):</p>

    <div class="my-4 text-center"><span class="math-block">\\bigcup_{k=1}^{l} \\{s_{k,r-1}^{\\alpha}\\} \\cup \\bigcup_{k=1}^{l} \\{y_{k,r-1}^{2}\\} \\cup \\bigcup_{k=1}^{l} \\{y_{k,r-1}\\} \\cup \\{y_{i,r}, s_{i,r}\\}.</span></div>

    <p class="text-gray-300">Note that LMt(bi,r) = LMt(bj,r) = s α t,r−1 for 1 ≤ i, j ≤ l and 1 ≤ t ≤ l. The step 2 of Algorithm <a href="#page-39-1">1</a> uses the pairs (bi,r, bj,r) with i < j for 1 ≤ i, j ≤ l. But, the Buchberger Criterion (Appendix <a href="#page-39-0">C\\)</a> reduces it to the l−1 pairs (b1,r, bj,r) where 1 < j ≤ l. For each S (0) j := S(b1,r; bj,r), using Lemma <a href="#page-41-2">15,</a> we have</p>

    <p class="text-gray-300"><span class="math-block">\\mathsf{LM}(\\mathcal{S}_{j}^{(0)}) = \\mathsf{LM}_{2}(b_{1,r})</span>  and  <span class="math">\\mathsf{LM}_{t}(\\mathcal{S}_{j}^{(0)}) = \\mathsf{LM}_{t+1}(b_{1,r})</span>  for  <span class="math">2 \\le t \\le l-1</span> .</p>

    <p class="text-gray-300">Next, we compute S-polynomials from the l − 1 polynomials S (0) j (2 ≤ j ≤ l) using l − 2 pairs (S (0) 2 , S (0) i ) for 2 < i ≤ l. For each S (1) i := S(S (0) 2 , S (0) i ), by Lemma <a href="#page-41-2">15,</a> we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\mathsf{LM}(\\mathcal{S}_i^{(1)}) &amp;= \\mathsf{LM}_2(\\mathcal{S}_2^{(0)}) = \\mathsf{LM}_3(b_{1,r}) \\\\ \\mathsf{LM}_2(\\mathcal{S}_i^{(1)}) &amp;= \\mathsf{LM}_3(\\mathcal{S}_2^{(0)}) = \\mathsf{LM}_4(b_{1,r}) \\end{split}</span></div>

    <p class="text-gray-300">Next, we proceed in the same way with l−2 polynomials S (1) i . Continuing this way l − 1 times, we get only one pair (S (l−2) l−1 , S (l−2) l ) and thus one S-polynomial output S (l−1) l := S(S (l−2) l−1 , S (l−2) l ) with leading monomial s α l,r−<sup>1</sup> = LMl(b1,r).</p>

    <p class="text-gray-300">The overall complexity is given by O( (N−1)(l−1)l 2 2 ) field operations.</p>

    <p class="text-gray-300">Proof (Lemma <a href="#page-18-0">4\\)</a>. Recall that mi,r := Qδ(yi,r−1) + E(si,r−1). Hence, fi,N+1 is described with the following set of monomials (sorted w.r.t DRL):</p>

    <div class="my-4 text-center"><span class="math-block">\\bigcup_{k=1}^{l} \\{s_{k,N}^{\\alpha}\\} \\cup \\bigcup_{k=1}^{l} \\{y_{k,N}^{2}\\} \\cup \\bigcup_{k=1}^{l} \\{y_{k,N}\\}.</span></div>

    <p class="text-gray-300">From the above description, it follows  <span class="math">\\mathsf{LM}_t(f_{i,N+1}) = \\mathsf{LM}_t(f_{j,N+1}) = s_{t,N}^{\\alpha}</span>  for  <span class="math">1 \\le i, j \\le l</span>  and  <span class="math">1 \\le t \\le l</span>  The step 2 of Algorithm 1 uses the pairs  <span class="math">(f_{i,N+1}; f_{j,N+1})</span>  with i < j for  <span class="math">1 \\le i, j \\le l</span> . But, the Buchberger Criterion (Appendix C) reduces it to the l-1 pairs  <span class="math">(f_{1,N+1}; f_{j,N+1})</span>  where  <span class="math">1 &lt; j \\le l</span> .</p>

    <p class="text-gray-300">For each  <span class="math">\\mathcal{S}_i^{(0)} := \\mathcal{S}(f_{1,N+1}; f_{j,N+1})</span> , using Lemma 15, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{LM}(\\mathcal{S}_{j}^{(0)}) = \\mathsf{LM}_{2}(f_{1,N+1}) \\quad \\text{and} \\quad \\mathsf{LM}_{t}(\\mathcal{S}_{j}^{(0)}) = \\mathsf{LM}_{t+1}(f_{1,N+1}) \\quad \\text{for } 2 \\leq t \\leq l-1.</span></div>

    <p class="text-gray-300">Next, we compute S-polynomials from the l-1 polynomials  <span class="math">\\mathcal{S}_{j}^{(0)}</span>   <span class="math">(2 \\leq j \\leq l)</span>  using l-2 pairs  <span class="math">(\\mathcal{S}_{2}^{(0)}, \\mathcal{S}_{i}^{(0)})</span>  for  <span class="math">2 &lt; i \\leq l</span> . For each  <span class="math">\\mathcal{S}_{i}^{(1)} := \\mathcal{S}(\\mathcal{S}_{2}^{(0)}, \\mathcal{S}_{i}^{(0)})</span> , by Lemma 15, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\mathsf{LM}(\\mathcal{S}_i^{(1)}) &amp;= \\mathsf{LM}_2(\\mathcal{S}_2^{(0)}) = \\mathsf{LM}_3(f_{1,N+1}) \\\\ \\mathsf{LM}_2(\\mathcal{S}_i^{(1)}) &amp;= \\mathsf{LM}_3(\\mathcal{S}_2^{(0)}) = \\mathsf{LM}_4(f_{1,N+1}). \\end{split}</span></div>

    <p class="text-gray-300">Next, we proceed in the same way with l-2 polynomials  <span class="math">\\mathcal{S}_i^{(1)}</span> . Continuing this way l-1 times, we get only one pair  <span class="math">(\\mathcal{S}_{l-1}^{(l-2)}, \\mathcal{S}_l^{(l-2)})</span>  and thus one S-polynomial output  <span class="math">\\mathcal{S}_l^{(l-1)} := \\mathcal{S}(\\mathcal{S}_{l-1}^{(l-2)}, \\mathcal{S}_l^{(l-2)})</span>  with leading monomial  <span class="math">s_{l,N}^{\\alpha} = \\mathsf{LM}_l(f_{1,N+1})</span> .</p>

    <p class="text-gray-300">The overall complexity is given by  <span class="math">\\mathcal{O}(\\frac{(l-1)l^2}{2})</span>  field operations.</p>

    <p class="text-gray-300"><em>Proof (Lemma 5)</em>. The polynomials  <span class="math">a_{i,1}</span>  for  <span class="math">1 \\le i \\le l</span>  have the following form:</p>

    <div class="my-4 text-center"><span class="math-block">a_{i,1} = s_{i,1}^{\\alpha} + \\sum_{j=0}^{l} \\left( c_{i,j} y_{j,0}^2 + \\sum_{k=1}^{j-1} d_{i,j,k} y_{k,0} y_{j,0} \\right) + \\sum_{j=0}^{l} z_{i,j} y_{j,0}</span></div>

    <p class="text-gray-300">where  <span class="math">c_{i,j}, d_{i,j,k}, z_{i,j} \\in \\mathbb{K}</span>  are generic coefficients.</p>

    <p class="text-gray-300">Buchberger algorithm tackles one pair at a time. At each iteration, creates the S-polynomial of the chosen pair, compute its reduction (steps 6-8) and, if the remainder is different from 0, adds the result to the set G.</p>

    <p class="text-gray-300">First iteration The first pair to be considered is  <span class="math">(f_{1,1}; a_{1,1})</span> . Its corresponding S-polynomial  <span class="math">\\mathcal{S}_1^{(0)} := \\mathcal{S}(f_{1,1}; a_{1,1})</span> , has the form given in Equation (12). This means that each monomial which is divisible by one of the monomials in the set  <span class="math">\\mathsf{LM}(G)</span> , will be replaced by something else. At the moment,  <span class="math">\\mathsf{LM}(G) = \\{\\mathbf{y}_0, \\mathbf{s}_1^{\\alpha}, \\dots, \\mathbf{s}_N^{\\alpha}\\}</span> .</p>

    <p class="text-gray-300"> <span class="math">\\mathsf{LM}(\\mathcal{S}_1^{(0)}) = s_{2,1}^{\\alpha}</span> , which is one of the monomials in  <span class="math">\\mathsf{LM}(G)</span> . It means that we can divide it by the polynomial  <span class="math">p \\in G \\mid \\mathsf{LM}(p) = s_{2,1}^{\\alpha}</span> , that is  <span class="math">f_{2,1}</span> . After the first step of the division algorithm,  <span class="math">s_{2,1}^{\\alpha}</span>  will be removed and substituted with the other monomials of p, in particular by  <span class="math">\\sum_{k=3}^{l} s_{k,1}^{\\alpha}</span> .</p>

    <p class="text-gray-300">By following the division algorithm, we can remove all the monomials of the type  <span class="math">s_{k,1}^{\\alpha}</span> . After having deleted  <span class="math">s_{l,1}^{\\alpha}</span> ,  <span class="math">\\mathsf{LM}(\\mathcal{S}_1^{(0)}) = y_{1,0}^2</span>  and  <span class="math">\\mathsf{LM}_2(\\mathcal{S}_1^{(0)}) = y_{1,0}y_{2,0}</span> . Since  <span class="math">y_{1,0} \\in \\mathsf{LM}(G)</span> , we can proceed with the division algorithm. By performing the division with  <span class="math">p \\in G \\mid \\mathsf{LM}(p) = y_{1,0}</span>  (notice that it was generated in Lemma 2), we are removing  <span class="math">y_{1,0}^2</span> , but adding the monomials given by  <span class="math">y_{1,0}(p-y_{1,0})</span> , in particular we add the monomials  <span class="math">y_{1,0}s_{1,1}</span> ,  <span class="math">y_{1,0}y_{1,1}</span> . After this process  <span class="math">\\mathsf{LM}(\\mathcal{S}_1^{(0)}) = y_{1,0}y_{2,0}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and  <span class="math">\\mathsf{LM}_2(\\mathcal{S}_1^{(0)}) = y_{2,0}^2</span> . We can proceed in this way by doing that for each monomial of the type  <span class="math">y_{i,0}^2</span>  or  <span class="math">y_{i,0}y_{j,0}</span>  with  <span class="math">i \\neq j</span> . Hence, at the end of this process,  <span class="math">\\mathsf{LM}(\\mathcal{S}_1^{(0)}) = y_{l,0}y_{1,1}</span>  and  <span class="math">\\mathsf{LM}_2(\\mathcal{S}_1^{(0)}) = y_{1,1}^2</span> . Again, by dividing with  <span class="math">p \\in G \\mid \\mathsf{LM}(p) = y_{l,0}</span> , we add the monomials of  <span class="math">y_{1,1}(p-y_{l,0}y_{1,1})</span> . Due to the linear layer, the term  <span class="math">y_{1,1}^2</span>  is removed and  <span class="math">\\mathsf{LM}(\\mathcal{S}_1^{(0)}) = y_{1,0}y_{2,1}</span>  and  <span class="math">\\mathsf{LM}_2(\\mathcal{S}_1^{(0)}) = y_{2,0}y_{2,1}</span> . We continue dividing until we get  <span class="math">y_{l,0}y_{2,1}</span>  as the leading monomial. Due to the linear layer, its simplification removes also the term  <span class="math">y_{2,1}^2</span> . We repeat that procedure until we get  <span class="math">y_{l,0}y_{l,1}</span>  as the leading monomial. The division by  <span class="math">p \\in G \\mid \\mathsf{LM}(p) = y_{l,0}</span>  also removes the term  <span class="math">y_{l,1}^2</span> , as done before. After this step,  <span class="math">\\mathsf{LM}(\\mathcal{S}_1^{(0)}) = y_{1,0}s_{1,1}</span>  and  <span class="math">\\mathsf{LM}_2(\\mathcal{S}_1^{(0)}) = y_{1,0}s_{2,1}</span> . We can divide it by the polynomial whose leading monomial is  <span class="math">y_{1,0}</span>  until all the monomials of the type  <span class="math">y_{i,0}s_{j,1}</span>  are removed. At the end of the process  <span class="math">\\mathsf{LM}(\\mathcal{S}_1^{(0)}) = y_{1,1}s_{1,1}</span>  and  <span class="math">\\mathsf{LM}_2(\\mathcal{S}_1^{(0)}) = s_{1,1}^2</span> . Notice that there is no polynomial  <span class="math">p \\in G</span>  such that  $\\mathsf{LM}(p)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_{1,1}s_{1,1}$ . As a result of this process, the obtained equation is added to the set G.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>i-th iteration</strong> Suppose we computed the reduction of the pair  <span class="math">(f_{i-1,1}; a_{i-1,1})</span> , meaning that the set  <span class="math">\\mathsf{LM}(G)</span>  contains all the monomials  <span class="math">y_{j,1}s_{j,1}</span>  for  <span class="math">1 \\leq j \\leq i-1</span>  and consider the next pair  <span class="math">(f_{i,1}; a_{i,1})</span> . By following what we have done before for the first pair, we end in a polynomial  <span class="math">\\mathcal{S}_i^{(0)}</span>  such that  <span class="math">\\mathsf{LM}(\\mathcal{S}_i^{(0)}) = y_{i-1,1}s_{i-1,1}</span>  and  <span class="math">\\mathsf{LM}_2(\\mathcal{S}_i^{(0)}) = s_{i-1,1}^2</span> . Due to the fact that  <span class="math">y_{i-1,1}s_{i-1,1} \\in \\mathsf{LM}(G)</span> , it can be divided again. In particular, after the division, also  <span class="math">\\mathsf{LM}_2(\\mathcal{S}_i^{(0)})</span>  will be removed because of the linear layer. Therefore, the leading monomial would become  <span class="math">\\mathsf{LM}(\\mathcal{S}_i^{(0)}) = y_{1,0}s_{i,1}</span>  and  <span class="math">\\mathsf{LM}_2(\\mathcal{S}_i^{(0)}) = y_{2,0}s_{i,1}</span> . We know that there is a polynomial p such that  <span class="math">\\mathsf{LM}(p) = y_{1,0}</span> , then we can proceed with the division algorithm, getting  <span class="math">\\mathsf{LM}(\\mathcal{S}_i^{(0)}) = y_{2,0}s_{i,1}</span>  and  <span class="math">\\mathsf{LM}_2(\\mathcal{S}_i^{(0)}) = y_{3,0}s_{i,1}</span> . We repeat the process until we get a leading monomial of the type  <span class="math">y_{l,0}s_{i,1}</span> . The last reduction will give  <span class="math">\\mathsf{LM}(\\mathcal{S}) = y_{i,1}s_{i,1}</span>  and  <span class="math">\\mathsf{LM}_2(\\mathcal{S}) = s_{i,1}^2</span> . Notice that there is no polynomial  <span class="math">p \\in G</span>  such that  $\\mathsf{LM}(p)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_{i,1}s_{i,1}$ . Finally, this equation is added to the set G.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The overall complexity is given by  <span class="math">\\mathcal{O}(\\frac{l^3(7l+1)(5l+l^2)}{2})</span>  field operations.</p>

    <p class="text-gray-300">Proof (Lemma 6). Fix a value  <span class="math">r \\geq 2</span> , then, for each pair  <span class="math">(b_{1,r}; a_{i,r})</span>  where  <span class="math">1 \\leq i \\leq l</span> , the corresponding S-polynomials  <span class="math">S_i^{(0)} := S(b_{1,r}, a_{i,r})</span>  contains the following monomials (sorted by DRL monomial ordering):</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\{\\mathbf{s}_{2:l,r-1}^{2\\alpha}\\} \\cup \\bigcup_{j,k=1}^{l} \\{y_{j,r-1}^{2}s_{k,r-1}^{\\alpha}\\} \\cup \\bigcup_{k=2}^{l+1} \\{y_{k-1,r-1}^{4}, y_{1,r-1}^{2}y_{k,r-1}^{2}, \\dots, y_{k-1,r-1}^{2}y_{k,r-1}^{2}\\} \\\\ \\cup \\bigcup_{j,k=1}^{l} y_{j,r-1}s_{k,r-1}^{\\alpha} \\cup \\bigcup_{k=2}^{l+1} \\{y_{k-1,r-1}^{3}, y_{1,r-1}^{2}y_{k,r-1}, \\dots, y_{k-1,r-1}^{2}y_{k,r}^{2}\\} \\\\ \\cup \\{\\mathbf{s}_{r-1}^{\\alpha}, s_{i,r}^{\\alpha}, \\mathbf{y}_{r-1}^{2}, \\mathbf{y}_{r-1}\\} \\end{split}</span></div>

    <p class="text-gray-300">As done for Lemma 5, our objective is to follow the multivariate polynomial division algorithm. In particular, at each step we choose a polynomial in G such that its leading monomial divides the leading monomial of the current</p>

    <p class="text-gray-300">value of  <span class="math">\\mathcal{S}_i^{(0)}</span> . To avoid unnecessary computations, we are going to see what are the leading monomials until a certain step. At the beginning  <span class="math">\\mathsf{LM}(\\mathcal{S}_i^{(0)}) = s_{2,r-1}^{2\\alpha}</span>  and  <span class="math">\\mathsf{LM}_2(\\mathcal{S}_i^{(0)}) = s_{3,r-1}^{2\\alpha}</span> . There is  <span class="math">p \\in G \\mid \\mathsf{LM}(p) = s_{2,r-1}^{\\alpha}</span>  (Lemma 3), then we can proceed with the reduction phase. By doing so,  <span class="math">\\mathsf{LM}(\\mathcal{S}_i^{(0)}) = s_{3,r-1}^{2\\alpha}</span>  and  <span class="math">\\mathsf{LM}_2(\\mathcal{S}_i^{(0)}) = s_{4,r-1}^{2\\alpha}</span> . During those reductions, we always add new monomials, in particular  <span class="math">s_{i,r-1}^{\\alpha}s_{j,r}</span> , where j is the index of the considered divisor  <span class="math">p \\mid \\mathsf{LM}(p) = s_{j,r-1}^{\\alpha}</span> . Continuing this way and after having removed  <span class="math">s_{l,r-1}^{2\\alpha}</span> ,  <span class="math">\\mathsf{LM}(\\mathcal{S}_i^{(0)}) = y_{1,r-1}^2s_{1,r-1}^\\alpha</span> . We repeat this process until all the following monomials are removed:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\sum_{j=1}^{l} s_{j,r-1}^{2\\alpha} + \\sum_{j,k=1}^{l} y_{j,r-1}^{2} s_{k,r-1}^{\\alpha} + \\sum_{j=1}^{l} y_{j,r-1}^{4} + \\\\ \\sum_{j=1,k=2 \\land j \\neq k}^{l} y_{j,r-1}^{2} y_{k,r-1}^{2} + \\sum_{j,k=1}^{l} y_{j,r-1} s_{k,r-1}^{\\alpha}. \\end{split}</span></div>

    <p class="text-gray-300">The last set of reduction, because of the linear layer, removes also the monomials</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{j,k=1}^{l} y_{j,r-1}^2 y_{k,r-1}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">At this point something crucial is happening.  <span class="math">\\mathsf{LM}(\\mathcal{S}_i^{(0)}) = s_{i,r-1}^\\alpha s_{i,r}</span> . We can reduce again by  $p \\in G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{LM}(p) = s_{i,r-1}^\\alpha<span class="math"> , and by doing so, we are introducing the monomial  </span>y_{i,r}s_{i,r}<span class="math"> . At this step we are almost at the end.  </span>\\mathsf{LM}(\\mathcal{S}_i^{(0)}) = s_{1,r-1}^\\alpha<span class="math">  and  </span>\\mathsf{LM}_2(\\mathcal{S}_i^{(0)}) = s_{2,r-1}^\\alpha<span class="math"> . As done before, we continue dividing  </span>\\mathcal{S}_i^{(0)}<span class="math">  and, due to the linear layer and to the structure of our divisors  </span>p_i<span class="math">  generated in Lemma 3  </span>(\\mathsf{LM}_2(p_i) = y_{i,r-1}^2)<span class="math"> , we also remove the monomials  </span>y_{i,r-1}^2<span class="math"> . After having removed all the monomials of the type  </span>s_{i,r-1}^\\alpha<span class="math">  and  </span>y_{i,r-1}^2<span class="math"> ,  </span>\\mathsf{LM}(\\mathcal{S}_i^{(0)}) = s_{i,r}^\\alpha<span class="math">  and  </span>\\mathsf{LM}_2(\\mathcal{S}_i^{(0)}) = y_{i,r}s_{i,r}<span class="math"> . After the last division, we remove  </span>s_{i,r}^\\alpha<span class="math"> , and we get a polynomial whose leading monomial is  </span>y_{i,r}s_{i,r}$ . Finally, this equation is added to the set G.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The overall complexity is given by  <span class="math">\\mathcal{O}(l^3(N-1)(3l^2+2l+2)(4l+4))</span>  field operations.</p>

    <p class="text-gray-300"><em>Proof (Lemma 7)</em>. Fix a round r such that  <span class="math">1 \\le r \\le N</span> . From Lemmas 5 and 6 we know that the polynomials  <span class="math">h_{i,r}</span>  are of the following form</p>

    <p class="text-gray-300"><span class="math-block">\\mathsf{LM}(h_{i,r}) = y_{i,r} s_{i,r}</span>  and  <span class="math">\\mathsf{LM}_2(h_{i,r}) = s_{i,r}^2</span>  for  <span class="math">1 \\le i \\le l</span> .</p>

    <p class="text-gray-300">In the same way, from Lemmas 2 to 4, the polynomials  <span class="math">f_{i,r}</span>  have the following properties:</p>

    <p class="text-gray-300"><span class="math-block">\\mathsf{LM}(f_{i,r}) = s_{i,r}^{\\alpha}</span>  and  <span class="math">\\mathsf{LM}_2(f_{i,r}) = y_{i,r}^2</span>  for  <span class="math">1 \\le i \\le l</span> .</p>

    <p class="text-gray-300">Let consider the pairs  <span class="math">(f_{i,r}; h_{i,r})</span>  for  <span class="math">1 \\le i \\le l</span>  and  <span class="math">1 \\le r \\le N</span> . The corresponding S-polynomial  <span class="math">\\mathcal{S}_i^{(0)} := \\mathcal{S}(f_{i,r}; h_{i,r})</span>  is such that:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\mathsf{LM}(\\mathcal{S}_i^{(0)}) &amp;= s_{i,r}^4 \\\\ \\mathsf{LM}_2(\\mathcal{S}_i^{(0)}) &amp;= y_{i,r}^3 \\end{split}</span></div>

    <p class="text-gray-300">We can divide it due to the fact that  <span class="math">s_{i,r}^{\\alpha} \\in \\mathsf{LM}(G)</span> . After that reduction:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\mathsf{LM}(\\mathcal{S}_i^{(0)}) &amp;= y_{i,r}^3 \\\\ \\mathsf{LM}_2(\\mathcal{S}_i^{(0)}) &amp;= y_{i,r}^2 s_{i,r} \\end{split}</span></div>

    <p class="text-gray-300">At this point, there is no monomial in  <span class="math">\\mathsf{LM}(G)</span>  able to reduce again the result. Therefore, we include those polynomials in the set G. As a result of this process, the set  <span class="math">\\mathsf{LM}(G)</span>  is composed by:</p>

    <div class="my-4 text-center"><span class="math-block">\\{\\mathbf{y}_0, \\mathbf{s}_1^{\\alpha}, \\dots, \\mathbf{s}_N^{\\alpha}, y_{i,r}s_{i,r}, y_{i,r}^3\\}</span></div>

    <p class="text-gray-300">for  <span class="math">1 \\le i \\le l</span>  and  <span class="math">1 \\le r \\le N</span> .</p>

    <p class="text-gray-300">For  <span class="math">\\alpha=3</span> , due to the Buchberger Criterion, there are no other pairs to be considered, hence the algorithm terminates. The polynomials created are not reduced, meaning that the set G is not a reduced Gröbner basis yet. We can reduce each polynomial in G by the other ones in order to remove the monomials which depend on the leading monomials of the other equations. That operation does not change the set  <span class="math">\\mathsf{LM}(G)</span> .</p>

    <p class="text-gray-300">The overall complexity is given by  <span class="math">\\mathcal{O}(6Nl^3)</span>  field operations.</p>

    <h2 id="sec-37" class="text-2xl font-bold">E.2 Lemmas for <span class="math">W_{DRL}</span> case</h2>

    <p class="text-gray-300"><em>Proof</em> (Lemma 8). Each  <span class="math">b_{i,1}</span>  is described as follows</p>

    <p class="text-gray-300"><span class="math-block">b_{i,1} := \\sum_{k=1}^{l} c_{i,k} y_{k,0} - y_{i,1} - s_{i,1}</span>  where  <span class="math">c_{i,k} \\in \\mathbb{K}</span> .</p>

    <p class="text-gray-300">Observe that  <span class="math">\\mathsf{LM}_t(b_{i,1}) = \\mathsf{LM}_t(b_{j,1})</span>  for all  <span class="math">1 \\leq i, j \\leq l</span>  and  <span class="math">1 \\leq t \\leq l</span> . The Step 2 of Algorithm 1 uses the pairs  <span class="math">(b_{i,1}, b_{j,1})</span>  with i < j for  <span class="math">1 \\leq i, j \\leq l</span> . But, Buchberger Criterion (Appendix C), reduces it to l-1 pairs  <span class="math">(b_{1,1}, b_{j,1})</span>  where  <span class="math">1 &lt; j \\leq l</span> .</p>

    <p class="text-gray-300">For each  <span class="math">\\mathcal{S}_{j}^{(0)}:=\\mathcal{S}(b_{1,1},b_{j,1}),</span>  using Lemma 15, we have</p>

    <p class="text-gray-300"><span class="math-block">\\mathsf{LM}(\\mathcal{S}_{j}^{(0)}) = \\mathsf{LM}_{2}(b_{1,1})</span>  and  <span class="math">\\mathsf{LM}_{t}(\\mathcal{S}_{j}^{(0)}) = \\mathsf{LM}_{t+1}(b_{1,1})</span>  for  <span class="math">2 \\le t \\le l-1</span></p>

    <p class="text-gray-300">Next, we compute S-polynomials from the l-1 polynomials  <span class="math">\\mathcal{S}_{j}^{(0)}</span>   <span class="math">(2 \\leq j \\leq l)</span>  using l-2 pairs  <span class="math">(\\mathcal{S}_{2}^{(0)}, \\mathcal{S}_{i}^{(0)})</span>  for  <span class="math">2 &lt; i \\leq l</span> . For each  <span class="math">\\mathcal{S}_{i}^{(1)} := \\mathcal{S}(\\mathcal{S}_{2}^{(0)}, \\mathcal{S}_{i}^{(0)})</span> , by Lemma 15, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{LM}(\\mathcal{S}_{i}^{(1)}) = \\mathsf{LM}_{2}(\\mathcal{S}_{2}^{(0)}) = \\mathsf{LM}_{3}(b_{1,1})$$ $$\\mathsf{LM}_{2}(\\mathcal{S}_{i}^{(1)}) = \\mathsf{LM}_{3}(\\mathcal{S}_{2}^{(0)}) = \\mathsf{LM}_{4}(b_{1,1})</span></div>

    <p class="text-gray-300">Next we proceed in the same way with l-2 polynomials  <span class="math">\\mathcal{S}_i^{(1)}</span> . Continuing this way l-1 times we get only one pair  <span class="math">(\\mathcal{S}_{l-1}^{(l-2)},\\mathcal{S}_l^{(l-2)})</span>  and thus one S-polynomial output  <span class="math">\\mathcal{S}_l^{(l-1)} := \\mathcal{S}(\\mathcal{S}_{l-1}^{(l-2)}, \\mathcal{S}_l^{(l-2)})</span>  with leading monomial  <span class="math">y_{l,0} = \\mathsf{LM}_l(b_{1,1})</span> . The overall complexity is given by  <span class="math">\\mathcal{O}(\\frac{(l-1)l^2}{2})</span>  field operations.</p>

    <p class="text-gray-300">Proof (Lemma 9). Since  <span class="math">m_{i,r} := Q_{\\delta}(y_{i,r-1}) + E(s_{i,r-1})</span> , the polynomial  <span class="math">b_{i,r}</span>  is described by the following set of monomials (sorted w.r.t.  <span class="math">W_{DRL}</span> ):</p>

    <div class="my-4 text-center"><span class="math-block">\\bigcup_{k=1}^{l} \\{y_{k,r-1}^2\\} \\cup \\bigcup_{k=1}^{l} \\{s_{k,r-1}^{\\alpha}\\} \\cup \\bigcup_{k=1}^{l} \\{y_{k,r-1}\\} \\cup \\{y_{i,r}, s_{i,r}\\}.</span></div>

    <p class="text-gray-300">Note that  <span class="math">\\mathsf{LM}_t(b_{i,r}) = \\mathsf{LM}_t(b_{j,r}) = y_{t,r-1}^2</span>  for  <span class="math">1 \\le i, j \\le l</span>  and  <span class="math">1 \\le t \\le l</span> . The step 2 of Algorithm 1 uses the pairs  <span class="math">(b_{i,r}, b_{j,r})</span>  for  <span class="math">1 \\le i &lt; j \\le l</span> . But, the Buchberger Criterion (Appendix C) reduces it to the l-1 pairs  <span class="math">(b_{1,r},b_{j,r})</span>  where  <span class="math">1 &lt; j \\le l</span> . For each  <span class="math">S_i^{(0)} := S(b_{1,r}; b_{j,r})</span> , using Lemma 15, we have</p>

    <p class="text-gray-300"><span class="math-block">\\mathsf{LM}(\\mathcal{S}_{j}^{(0)}) = \\mathsf{LM}_{2}(b_{1,r})</span>  and  <span class="math">\\mathsf{LM}_{t}(\\mathcal{S}_{j}^{(0)}) = \\mathsf{LM}_{t+1}(b_{1,r})</span>  for  <span class="math">2 \\le t \\le l-1</span> .</p>

    <p class="text-gray-300">Next, we compute S-polynomials from the l-1 polynomials  <span class="math">\\mathcal{S}_{j}^{(0)}</span>   <span class="math">(2 \\leq j \\leq l)</span>  using l-2 pairs  <span class="math">(\\mathcal{S}_{2}^{(0)},\\mathcal{S}_{i}^{(0)})</span>  for  <span class="math">2 &lt; i \\leq l</span> . For each  <span class="math">\\mathcal{S}_{i}^{(1)} := \\mathcal{S}(\\mathcal{S}_{2}^{(0)},\\mathcal{S}_{i}^{(0)})</span> , by Lemma 15, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\mathsf{LM}(\\mathcal{S}_i^{(1)}) &amp;= \\mathsf{LM}_2(\\mathcal{S}_2^{(0)}) = \\mathsf{LM}_3(b_{1,r}) \\\\ \\mathsf{LM}_2(\\mathcal{S}_i^{(1)}) &amp;= \\mathsf{LM}_3(\\mathcal{S}_2^{(0)}) = \\mathsf{LM}_4(b_{1,r}) \\end{split}</span></div>

    <p class="text-gray-300">Next, we proceed in the same way with l-2 polynomials  <span class="math">\\mathcal{S}_i^{(1)}</span> . Continuing this way l-1 times, we get only one pair  <span class="math">(\\mathcal{S}_{l-1}^{(l-2)},\\mathcal{S}_{l}^{(l-2)})</span>  and thus one S-polynomial output  <span class="math">\\mathcal{S}_l^{(l-1)} := \\mathcal{S}(\\mathcal{S}_{l-1}^{(l-2)}, \\mathcal{S}_l^{(l-2)})</span>  with leading monomial  <span class="math">y_{l,r-1}^2 = \\mathsf{LM}_l(b_{1,r})</span> .</p>

    <p class="text-gray-300">The overall complexity is given by  <span class="math">\\mathcal{O}(\\frac{(N-1)(l-1)l^2}{2})</span>  field operations.</p>

    <p class="text-gray-300"><em>Proof (Lemma 10).</em> Recall that  <span class="math">m_{i,r} := Q_{\\delta}(y_{i,r-1}) + E(s_{i,r-1})</span> . Hence,  <span class="math">f_{i,N+1}</span>  is described by the following set of monomials (sorted w.r.t.  <span class="math">W_{DRL}</span> ):</p>

    <div class="my-4 text-center"><span class="math-block">\\bigcup_{k=1}^{l} \\{y_{k,r-1}^2\\} \\cup \\bigcup_{k=1}^{l} \\{s_{k,r-1}^{\\alpha}\\} \\cup \\bigcup_{k=1}^{l} \\{y_{k,r-1}\\}.</span></div>

    <p class="text-gray-300">From the above description, it follows  <span class="math">\\mathsf{LM}_t(f_{i,N+1}) = \\mathsf{LM}_t(f_{j,N+1}) = y_{t,N}^2</span>  for  <span class="math">1 \\le t</span>  <span class="math">i, j \\leq l</span>  and  <span class="math">1 \\leq t \\leq l</span>  The step 2 of Algorithm 1 uses the pairs  <span class="math">(f_{i,N+1}; f_{j,N+1})</span> for  <span class="math">1 \\le i &lt; j \\le l</span> . But, the Buchberger Criterion (Appendix C) reduces it to the  <span class="math">l-1 \\text{ pairs } (f_{1,N+1}; f_{j,N+1}) \\text{ where } 1 &lt; j \\le l.</span></p>

    <p class="text-gray-300">For each  <span class="math">\\mathcal{S}_i^{(0)} := \\mathcal{S}(f_{1,N+1}; f_{j,N+1})</span> , using Lemma 15, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{LM}(\\mathcal{S}_{j}^{(0)}) = \\mathsf{LM}_{2}(f_{1,N+1}) \\quad \\text{and} \\quad \\mathsf{LM}_{t}(\\mathcal{S}_{j}^{(0)}) = \\mathsf{LM}_{t+1}(f_{1,N+1}) \\quad \\text{for } 2 \\leq t \\leq l-1</span></div>

    <p class="text-gray-300">Next, we compute S-polynomials from the l-1 polynomials  <span class="math">\\mathcal{S}_{j}^{(0)}</span>   <span class="math">(2 \\leq j \\leq l)</span>  using l-2 pairs  <span class="math">(\\mathcal{S}_{2}^{(0)}, \\mathcal{S}_{i}^{(0)})</span>  for  <span class="math">2 &lt; i \\leq l</span> . For each  <span class="math">\\mathcal{S}_{i}^{(1)} := \\mathcal{S}(\\mathcal{S}_{2}^{(0)}, \\mathcal{S}_{i}^{(0)})</span> , by Lemma 15, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\mathsf{LM}(\\mathcal{S}_i^{(1)}) &amp;= \\mathsf{LM}_2(\\mathcal{S}_2^{(0)}) = \\mathsf{LM}_3(f_{1,N+1}) \\\\ \\mathsf{LM}_2(\\mathcal{S}_i^{(1)}) &amp;= \\mathsf{LM}_3(\\mathcal{S}_2^{(0)}) = \\mathsf{LM}_4(f_{1,N+1}) \\end{split}</span></div>

    <p class="text-gray-300">Next, we proceed in the same way with l-2 polynomials  <span class="math">\\mathcal{S}_i^{(1)}</span> . Continuing this way l-1 times, we get only one pair  <span class="math">(\\mathcal{S}_{l-1}^{(l-2)},\\mathcal{S}_l^{(l-2)})</span>  and thus one S-polynomial output  <span class="math">\\mathcal{S}_l^{(l-1)}:=\\mathcal{S}(\\mathcal{S}_{l-1}^{(l-2)},\\mathcal{S}_l^{(l-2)})</span>  with leading monomial  <span class="math">y_{l,N}^2=\\mathsf{LM}_l(f_{1,N+1})</span> .</p>

    <p class="text-gray-300">The overall complexity is given by  <span class="math">\\mathcal{O}(\\frac{(l-1)l^2}{2})</span>  field operations.</p>

    <p class="text-gray-300">Proof (Lemma 11). Let us consider the pair  <span class="math">(b_{i,1}; a_{i,1})</span> . Its corresponding S-polynomial  <span class="math">\\mathcal{S}_1^{(0)} := \\mathcal{S}(b_{i,1}; a_{i,1})</span> , has the form given in Equation (13). This means that each monomial which is divisible by one of the monomials in the set  <span class="math">\\mathsf{LM}(G)</span> , will be replaced by something else. At the moment,  <span class="math">\\mathsf{LM}(G) = \\{\\mathbf{y}_0, \\mathbf{y}_1^2, \\mathbf{y}_2^2, \\dots, \\mathbf{y}_N^2\\}</span></p>

    <p class="text-gray-300">Computing the S-polynomial introduces newer monomials, in particular it generates  <span class="math">y_{1,0}y_{i,1}</span> .  <span class="math">\\mathsf{LM}(\\mathcal{S}_1^{(0)}) = y_{1,0}y_{2,0}</span> , which is divisible by one of the monomials in  <span class="math">\\mathsf{LM}(G)</span> . It means that we can divide it by the polynomial  <span class="math">p \\in G \\mid \\mathsf{LM}(p) = y_{1,0}</span> . After the first step of the division algorithm,  <span class="math">y_{1,0}y_{2,0}</span>  will be removed and substituted with the monomials of p multiplied by  <span class="math">y_{2,0}</span> .</p>

    <p class="text-gray-300">By following the division algorithm, we can remove all the monomials of the type  <span class="math">y_{i,0}^2</span>  and  <span class="math">y_{i,0}y_{j,0}</span>  until we obtain  <span class="math">\\mathsf{LM}(\\mathcal{S}_1^{(0)}) = y_{1,0}y_{i,1}</span> . Since  <span class="math">y_{1,0} \\in \\mathsf{LM}(G)</span> , we can proceed with the division algorithm. By performing the division with  <span class="math">p \\in G \\mid \\mathsf{LM}(p) = y_{1,0}</span> , we are removing  <span class="math">y_{1,0}y_{i,1}</span> , but adding the monomials given by  <span class="math">y_{i,1}(p-y_{1,0})</span> , in particular we add the monomials  <span class="math">y_{i,1}^2</span>  and  <span class="math">y_{i,1}s_{i,1}</span> . It is straightforward to notice that  <span class="math">y_{i,1}^2</span>  is one of the leading monomials of the equations we introduced with Lemma 9. The next reductions will remove the monomials of the type  <span class="math">y_{i,1}^2</span>  and  <span class="math">y_{i,0}s_{i,1}</span> . Moreover, due to the linear layer, even  <span class="math">s_{i,1}^\\alpha</span>  is removed during the reduction by  <span class="math">p \\in G \\mid \\mathsf{LM}(p) = y_{i,1}^2</span> . At this step,  <span class="math">\\mathsf{LM}(\\mathcal{S}_1^{(0)}) = y_{i,1}s_{i,1}</span> . Notice that there is no polynomial  <span class="math">p \\in G</span>  such that  <span class="math">\\mathsf{LM}(p)</span>  divides  <span class="math">y_{i,1}s_{i,1}</span> . As a result of this process, the obtained equation is added to the set G.</p>

    <p class="text-gray-300">The overall complexity is given by  <span class="math">\\mathcal{O}(l^2(l+1)^2(5l+2l^2))</span>  field operations.</p>

    <p class="text-gray-300">Proof (Lemma 12). Fix a value  <span class="math">r \\geq 2</span> , then, for each pair  <span class="math">(b_{1,r}; a_{i,r})</span>  where  <span class="math">1 \\leq i \\leq l</span> , the corresponding S-polynomials  <span class="math">\\mathcal{S}_i^{(0)} := \\mathcal{S}(b_{1,r}, a_{i,r})</span>  contain the</p>

    <p class="text-gray-300">following monomials (sorted by  <span class="math">W_{DRL}</span>  monomial ordering):</p>

    <div class="my-4 text-center"><span class="math-block">\\{y_{1,r-1}^{2}y_{2,r-1}^{2}\\} \\cup \\bigcup_{k=3}^{l+1} \\{y_{k-1,r-1}^{4}, y_{1,r-1}^{2}y_{k,r-1}^{2}, \\dots, y_{k-1,r-1}^{2}y_{k,r-1}^{2}\\}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\cup \\bigcup_{k=1}^{l} \\left(\\bigcup_{j=1}^{l} \\{y_{j,r-1}^{2}s_{k,r-1}^{\\alpha}\\} \\cup \\{s_{k,r-1}^{2\\alpha}\\}\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\cup \\bigcup_{k=1}^{l} \\{y_{k,r-1}^{3}, y_{1,r-1}^{2}y_{k+1,r-1}, \\dots, y_{k,r-1}^{2}y_{k+1,r-1}, \\dots, y_{k,r-1}^{2}y_{k+1,r-1}\\}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\cup \\bigcup_{j,k=1}^{l} y_{j,r-1}s_{k,r-1}^{\\alpha}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\cup \\{\\mathbf{y}_{r-1}^{2}, \\mathbf{s}_{r-1}^{\\alpha}, s_{i,r}^{\\alpha}, \\mathbf{y}_{r-1}\\}.</span></div>

    <div class="my-4 text-center"><span class="math-block">(24)</span></div>

    <p class="text-gray-300">As done for Lemma 11, our objective is to follow the multivariate polynomial division algorithm. In particular, at each step we choose a polynomial in G such that its leading monomial divides the leading monomial of the current value of  <span class="math">\\mathcal{S}_i^{(0)}</span> . To avoid unnecessary computations, we are going to see what are the leading monomials until a certain step. At the beginning  <span class="math">\\mathsf{LM}(\\mathcal{S}_i^{(0)}) = y_{1,r-1}^2 y_{2,r-1}^2</span>  and  <span class="math">\\mathsf{LM}_2(\\mathcal{S}_i^{(0)}) = y_{2,r-1}^4</span> . There is  <span class="math">p \\in G \\mid \\mathsf{LM}(p) = y_{1,r-1}^2</span>  (Lemma 9), then we can proceed with the reduction phase. By doing so,  <span class="math">\\mathsf{LM}(\\mathcal{S}_i^{(0)}) = y_{2,r-1}^4</span>  and  <span class="math">\\mathsf{LM}_2(\\mathcal{S}_i^{(0)}) = y_{1,r-1}^2 y_{3,r-1}^2</span> . Now, we can reduce by  <span class="math">p \\in G \\mid \\mathsf{LM}(p) = y_{2,r-1}^2</span>  and  <span class="math">\\mathsf{LM}(\\mathcal{S}_i^{(0)}) = y_{1,r-1}^2 y_{3,r-1}^2</span>  and  <span class="math">\\mathsf{LM}_2(\\mathcal{S}_i^{(0)}) = y_{2,r-1}^2 y_{3,r-1}^2</span> . Continuing this way and after having removed  <span class="math">y_{l,r-1}^4</span> ,  <span class="math">\\mathsf{LM}(\\mathcal{S}_i^{(0)}) = y_{1,r-1}^2 s_{1,r-1}^2</span>  and  <span class="math">\\mathsf{LM}_2(\\mathcal{S}_i^{(0)}) = y_{2,r-1}^2 s_{1,r-1}^2</span> . At this point, we can reduce again by  <span class="math">p \\in G \\mid \\mathsf{LM}(p) = y_{1,r-1}^2</span> . Because of the linear layer, it removes the monomials  <span class="math">\\bigcup_{j=1}^l \\{y_{j,r-1}^2 s_{1,r-1}^\\alpha\\} \\cup \\{s_{1,r-1}^{2\\alpha}\\}</span> , leading to  <span class="math">\\mathsf{LM}(\\mathcal{S}_i^{(0)}) = y_{1,r-1}^2 s_{2,r-1}^2</span>  and  <span class="math">\\mathsf{LM}_2(\\mathcal{S}_i^{(0)}) = y_{2,r-1}^2 s_{2,r-1}^2</span> . We repeat this process until all the following monomials are removed:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\{y_{1,r-1}^2y_{2,r-1}^2\\} &amp; \\cup \\bigcup_{k=3}^{l+1} \\{y_{k-1,r-1}^4, y_{2,r-1}^2y_{k,r-1}^2, \\dots, y_{k-1,r-1}^2y_{k,r-1}^2\\} \\cup \\\\ &amp; \\cup \\bigcup_{k=1}^{l} \\left( \\bigcup_{j=1}^{l} \\{y_{j,r-1}^2s_{k,r-1}^\\alpha\\} \\cup \\{s_{k,r-1}^{2\\alpha}\\} \\right). \\end{aligned}</span></div>

    <p class="text-gray-300">The previous reductions introduced the monomials</p>

    <div class="my-4 text-center"><span class="math-block">\\bigcup_{j=1}^{l} y_{j,r}^2 \\cup \\bigcup_{j,k=1}^{l} y_{j,r-1}^2 y_{k,r} \\cup \\bigcup_{j,k=1 \\land j \\neq k}^{l} y_{j,r-1}^2 s_{k,r-1}.</span></div>

    <p class="text-gray-300">At this step  <span class="math">\\mathsf{LM}(\\mathcal{S}_i^{(0)}) = y_{1,k-1}^3</span> . Proceeding in that way, we remove all the monomials:</p>

    <div class="my-4 text-center"><span class="math-block">\\bigcup_{k=1}^{l} \\{y_{k,r-1}^3, y_{1,r-1}^2 y_{k+1,r-1}, \\dots, y_{k,r-1}^2 y_{k+1,r-1}, \\\\ y_{1,r-1} y_{k+1,r-1}^2, \\dots, y_{k,r-1} y_{k+1,r-1}^2 \\} \\\\ \\cup \\bigcup_{j,k=1}^{l} y_{j,r-1}^2 y_{k,r} \\cup \\bigcup_{j,k=1 \\land j \\neq k}^{l} y_{j,r-1}^2 s_{k,r-1}.</span></div>

    <p class="text-gray-300">Something crucial is happening, removing the monomials  <span class="math">\\bigcup_{j,k=1}^{l} y_{j,r-1}^2 y_{k,r}</span>  introduces the following ones:  <span class="math">\\bigcup_{j,k=1}^{l} y_{j,r} s_{k,r}</span>  and  <span class="math">\\bigcup_{j=1}^{l} y_{j,r}^2</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Moreover,  <span class="math">\\mathsf{LM}(\\mathcal{S}_i^{(0)}) = y_{1,r-1}^2</span>  and  <span class="math">\\mathsf{LM}_2(\\mathcal{S}_i^{(0)}) = y_{2,r-1}^2</span>  We can reduce again by the required  $p \\in G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{LM}(p) = y_{j,r-1}^2<span class="math">  until we obtain  </span>\\mathsf{LM}(\\mathcal{S}_i^{(0)}) = y_{1,r}^2<span class="math"> . Again, thanks to the linear layer and the structure of the polynomials generated by Lemmas 8 and 9, this operation will also remove the monomials  </span>\\bigcup_{j,k=1}^l y_{j,r} s_{k,r}<span class="math">  except  </span>y_{i,r} s_{i,r}<span class="math"> . Continuing the reduction with the polynomials created by Lemma 9, we remove the monomials  </span>y_{j,r}^2<span class="math">  for  </span>1 \\leq j \\leq l<span class="math"> . After the last division, we remove  </span>y_{l,r}^2<span class="math"> , and we get a polynomial whose leading monomial is  </span>y_{i,r} s_{i,r}$ . Finally, this equation is added to the set G.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The overall complexity is given by  <span class="math">\\mathcal{O}(3l^3(N-1)(4l^2+l))</span>  field operations.</p>

    <p class="text-gray-300"><em>Proof (Lemma 13).</em> Fix a round r such that  <span class="math">1 \\le r \\le N</span> . From Lemma 12 we know that the polynomials  <span class="math">h_{i,r}</span>  are of the following form</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{LM}(h_{i,r}) = y_{i,r} s_{i,r} \\quad \\text{and} \\quad \\mathsf{LM}_2(h_{i,r}) = s_{i,r}^2 \\quad \\text{for } 1 \\leq i \\leq l.</span></div>

    <p class="text-gray-300">In the same way, from Lemmas 8 to 10, the polynomials  <span class="math">f_{i,r}</span>  have the following properties:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{LM}(f_{i,r}) = y_{i,r}^2 \\quad \\text{and} \\quad \\mathsf{LM}_2(f_{i,r}) = s_{i,r}^\\alpha \\quad \\text{for } 1 \\leq i \\leq l.</span></div>

    <p class="text-gray-300">Let consider the pairs  <span class="math">(f_{i,r}; h_{i,r})</span>  for  <span class="math">1 \\le i \\le l</span>  and  <span class="math">1 \\le r \\le N</span> . The corresponding S-polynomial  <span class="math">\\mathcal{S}_i^{(0)} := \\mathcal{S}(f_{i,r}; h_{i,r})</span>  is such that  <span class="math">\\mathsf{LM}(\\mathcal{S}_i^{(0)}) = s_{i,r}^{\\alpha+1}</span> . At this point, there is no monomial in  <span class="math">\\mathsf{LM}(G)</span>  able to reduce again the result. Therefore, we include those polynomials in the set G. As a result of this process, the set  <span class="math">\\mathsf{LM}(G)</span>  is composed by:</p>

    <div class="my-4 text-center"><span class="math-block">\\{\\mathbf{y}_0, \\mathbf{y}_1^2, \\dots, \\mathbf{y}_N^2, y_{i,r}s_{i,r}, s_{i,r}^{\\alpha+1}\\}</span></div>

    <p class="text-gray-300">for  <span class="math">1 \\le i \\le l</span>  and  <span class="math">1 \\le r \\le N</span> .</p>

    <p class="text-gray-300">Due to the Buchberger Criterion, there are no other pairs to be considered, hence the algorithm terminates. The polynomials created are not reduced, meaning that the set G is not a reduced Gröbner basis yet. We can reduce each polynomial in G by the other ones in order to remove the monomials which depend on the leading monomials of the other equations. That operation does not change the set  <span class="math">\\mathsf{LM}(G)</span> .</p>

    <p class="text-gray-300">The overall complexity is given by  <span class="math">\\mathcal{O}(3Nl^3)</span>  field operations.</p>

    <p class="text-gray-300">For cryptanalysis purposes, applying FGLM algorithms is useful when the output is a basis in Shape Form, and we need to find the complete variety of the system. Theorem 8 gives us the chance to determine whether it is convenient to apply such algorithms or not. Moreover, if we are dealing with sparse polynomials, it makes sense to apply SparseFGLM and Wiedemann algorithm. It is important to notice that Wiedemann algorithm is the starting step of SparseFGLM. Therefore, depending on the situation, what is the best to apply? Generically, it is worth using Wiedemann algorithm when we don't need to compute the entire variety of a system. For example, given an algebraic model for a hash function, cryptographers are usually not interested in the values assumed by the inner variables, but only on those of the input or output variables. The complexity of SparseFGLM can be defined in terms of the number of non-zero entries in the considered matrices. Hence, we can directly compare the two methods and define when one performs extremely better than the other. Suppose we are interested in finding the solutions of k out of n variables. With Wiedemann algorithm, we find a univariate polynomial for each of those variables. Therefore, the overall complexity is k times the complexity of computing the univariate polynomial:  <span class="math">\\mathcal{O}(kd_I(\\mathcal{Z} + \\log(d_I)))</span> . With SparseFGLM the complexity is given by the computation of one univariate polynomial (for the smaller variable with respect to a certain monomial order) plus the conversion of the system to a LEX Gröbner basis in Shape form:  <span class="math">\\mathcal{O}(d_I(\\mathcal{Z}+n\\log(d_I)))</span> . In order to discover when the Wiedemann algorithm performs better than SparseFGLM, we can temporarily remove the asymptotic notation and define the following inequality:</p>

    <div class="my-4 text-center"><span class="math-block">d_I(\\mathcal{Z} + n\\log(d_I)) - kd_I(\\mathcal{Z} + \\log(d_I)) \\ge 0</span></div>

    <p class="text-gray-300">By rewriting the above equation accordingly we get  <span class="math">(n-k)\\log(d_I) \\geq (k-1)\\mathcal{Z}</span> . From that result we can conclude that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if n = k = 1 the complexities are the same</li>

      <li>if  <span class="math">Z \\leq \\frac{n-k}{k-1}\\log(d_I)</span> , repeating Wiedemann algorithm performs better that SparseFGLM.</li>

    </ul>

    <p class="text-gray-300">Note that we assume the sparsity of the multiplication matrices to be almost the same for each variable. This is not always the case. Therefore, this is another check that has to be done to choose the best algorithm.</p>

    <h2 id="sec-39" class="text-2xl font-bold">G Fast variety finding</h2>

    <p class="text-gray-300">Before going to the proposed algorithm, we need to discuss the nice form given by the polynomials in the DRL Gröbner basis in Proposition 2. They can be sorted with respect to the number and the type of variables they depend on. Currently, we have: • l equations which depend only on l + 1 variables:</p>

    <p class="text-gray-300"><span class="math-block">g_{i,N}(s_{i,N}, \\mathbf{y}_N)</span>  where  <span class="math">\\mathsf{LM}(g_{i,N}) = s_{i,N}^{\\alpha}</span></p>

    <p class="text-gray-300">• 2l equations which depend on 2l + 1 variables:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} g_{i,N}&#x27;(s_{i,N},\\mathbf{y}_{N-1},\\mathbf{y}_N) \\text{ where } \\mathsf{LM}(g_{i,N}&#x27;) &amp;= y_{i,N}^\\alpha \\\\ g_{i,N}&#x27;&#x27;(s_{i,N},\\mathbf{y}_{N-1},\\mathbf{y}_N) \\text{ where } \\mathsf{LM}(g_{i,N}&#x27;&#x27;) &amp;= y_{i,N}s_{i,N} \\end{split}</span></div>

    <p class="text-gray-300">• l equations which depend on 3l + 1 variables:</p>

    <p class="text-gray-300"><span class="math-block">g_{i,N-1}(s_{i,N-1}, \\mathbf{y}_{N-1}, \\mathbf{y}_{N}, \\mathbf{s}_{N})</span>  where  <span class="math">\\mathsf{LM}(g_{i,N-1}) = s_{i,N-1}^{\\alpha}</span></p>

    <p class="text-gray-300">• 2l equations which depend on 4l + 1 variables:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} g&#x27;_{i,N-1}(s_{i,N-1},\\mathbf{s}_N,\\mathbf{y}_{N-2},\\mathbf{y}_{N-1},\\mathbf{y}_N) \\text{ where } \\mathsf{LM}(g_{i,N}) &amp;= y_{i,N-1}^\\alpha \\\\ g&#x27;&#x27;_{i,N-1}(s_{i,N-1},\\mathbf{s}_N,\\mathbf{y}_{N-2},\\mathbf{y}_{N-1},\\mathbf{y}_N) \\text{ where } \\mathsf{LM}(g&#x27;&#x27;_{i,N}) &amp;= y_{i,N-1}s_{i,N-1} \\end{split}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>. . .</li>

      <li>l equations which depend on 3l + 1 variables:</li>

    </ul>

    <p class="text-gray-300"><span class="math-block">g_{i,j}(s_{i,j}, \\mathbf{y}_j, \\mathbf{y}_{j+1}, \\mathbf{s}_{j+1})</span>  where  <span class="math">\\mathsf{LM}(g_{i,j}) = s_{i,j}^{\\alpha}</span></p>

    <p class="text-gray-300">• 2l equations which depend on 4l + 1 variables:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} g&#x27;_{i,j}(\\mathbf{y}_{j-1}, \\mathbf{y}_{j}, \\mathbf{y}_{j+1}, \\mathbf{s}_{j+1}, s_{i,j}) \\text{ where } \\mathsf{LM}(g&#x27;_{i,j}) &amp;= y^{\\alpha}_{i,j} \\\\ g&#x27;&#x27;_{i,j}(\\mathbf{y}_{j-1}, \\mathbf{y}_{j}, \\mathbf{y}_{j+1}, \\mathbf{s}_{j+1}, s_{i,j}) \\text{ where } \\mathsf{LM}(g&#x27;&#x27;_{i,j}) &amp;= y_{i,j} s_{i,j} \\end{split}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>. . .</li>

      <li>l equations which depend on 2l + 1 variables:</li>

    </ul>

    <p class="text-gray-300"><span class="math-block">g_{i,0}(y_{i,0}, \\mathbf{s}_1, \\mathbf{y}_1)</span>  where  <span class="math">\\mathsf{LM}(g_{i,0}) = y_{i,0}</span></p>

    <p class="text-gray-300">Algorithm <a href="#page-53-0">4</a> gives the possibility to efficiently compute the variety of the ideal generated by the DRL (or WDRL ) basis of Anemoi w.r.t the ACICO model.</p>

    <p class="text-gray-300">Remark 4. For l = 1, the previous algorithm can be simplified by substituting the linear system solving procedure with the gcd computation as in Corollary 1 from [\\[10\\]](#page-35-11). On the other hand, due to the fact that the equations generated in Steps 6, 9, etc... are degree 1 polynomials, we can simply solve one of the equations to get the value of the unknown variable.</p>

    <h2 id="sec-40" class="text-2xl font-bold">Algorithm 4 Solutions of the polynomial system</h2>

    <p class="text-gray-300">Let  <span class="math">I_{DRL} \\subset R</span>  be the ideal generated by the DRL basis of Anemoi with respect to the  <span class="math">A_{CICO}</span>  representation.  <span class="math">\\mathbb{V}(I_{DRL})</span>  can be computed as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Compute the univariate polynomials  <span class="math">h_i(y_{i,N})</span>  for  <span class="math">1 \\leq i \\leq N</span>  by using polyDet or Wiedemann algorithm.</li>

      <li>2. Find the roots of the univariate polynomials, that is finding a set of solutions for each of the variables  <span class="math">y_{i,N}</span> .</li>

      <li>3. If  <span class="math">\\exists h_i</span>  such that  <span class="math">h_i</span>  is irreducible,  <span class="math">\\mathbb{V}(I_{\\mathsf{DRL}}) = \\emptyset</span>  else, compute the Cartesian product between those sets.</li>

      <li>4. For each tuple of roots  <span class="math">\\tau = (\\tau_1, \\dots, \\tau_l)</span>  in the Cartesian product, compute:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">p_{i,N} = g_{i,N}(s_{i,N},\\tau)</span></div>

    <p class="text-gray-300">for  <span class="math">1 \\leq i \\leq l</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>5. Compute the roots of  <span class="math">p_{i,N}</span>  for  <span class="math">1 \\le i \\le l</span>  to find the possible values of  <span class="math">s_{i,N}</span> . If  <span class="math">\\exists p_{i,N}</span>  irreducible,  <span class="math">\\mathbb{V}(I_{\\mathsf{DRL}}) = \\emptyset</span>  else compute the Cartesian product between the found sets of roots.</li>

      <li>6. For each tuple of roots  <span class="math">\\tau&#x27; = (\\tau&#x27;_1, \\dots, \\tau&#x27;_l)</span>  in the Cartesian product, compute the system of 2l linear equations:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\{g&#x27;_{i,N}(\\mathbf{y}_{N-1},\\tau&#x27;_i,\\tau),\\ldots,g&#x27;&#x27;_{i,N}(\\mathbf{y}_{N-1},\\tau&#x27;_i,\\tau)\\}</span></div>

    <p class="text-gray-300">where  <span class="math">1 \\leq i \\leq l</span> . Solve the system of 2l equations in l unknowns (we just need l equations) and get the new set of roots  <span class="math">\\tau&#x27;&#x27; = (\\tau_1&#x27;&#x27;, \\dots, \\tau_l&#x27;&#x27;)</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">p_{i,N-1} = g_{i,N-1}(s_{i,N-1}, \\tau, \\tau&#x27;, \\tau&#x27;&#x27;)</span></div>

    <p class="text-gray-300">for each  <span class="math">1 \\leq i \\leq l</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>8. Compute the roots  <span class="math">p_{i,N-1}</span>  for  <span class="math">1 \\leq i \\leq l</span> . If  <span class="math">\\exists p_{i,N-1}</span>  irreducible,  <span class="math">\\mathbb{V}(I_{\\mathsf{DRL}}) = \\emptyset</span>  else compute the Cartesian product between the found sets of roots.</li>

      <li>9. For each tuple of roots  <span class="math">\\tau&#x27;&#x27;&#x27; = (\\tau_1&#x27;&#x27;&#x27;, \\dots, \\tau_l&#x27;&#x27;&#x27;)</span>  in the Cartesian product, compute the system of 2l linear equations:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\{g_{i,N-1}&#x27;(\\mathbf{y}_{N-2},\\tau_i&#x27;&#x27;&#x27;,\\tau&#x27;,\\tau),\\ldots,g_{i,N-1}&#x27;&#x27;(\\mathbf{y}_{N-2},\\tau_i&#x27;&#x27;&#x27;,\\tau&#x27;,\\tau)\\}</span></div>

    <p class="text-gray-300">where  <span class="math">1 \\leq i \\leq l</span> . Solve the system in l unknowns as done in step 6 and get the new set of roots  <span class="math">\\tau&#x27;&#x27;&#x27;&#x27; = (\\tau_1&#x27;&#x27;&#x27;&#x27;, \\dots, \\tau_l&#x27;&#x27;&#x27;&#x27;)</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>10. Proceed similarly for the other polynomials  <span class="math">g_{i,j}, g&#x27;_{i,j}, g&#x27;&#x27;_{i,j}</span>  for  <span class="math">1 \\le i \\le l</span>  and  <span class="math">1 \\le j \\le N-2</span> .</li>

      <li>11. At the end, consider the polynomials  <span class="math">g_{i,0}</span> . If we reached this step, it means that we know values for each of the variables they depend on. Being equations of degree 1, the values of the variables  <span class="math">y_{i,0}</span>  are easy to find by substitution.</li>

    </ul>

    <h2 id="sec-41" class="text-2xl font-bold">H Experimental results</h2>

    <p class="text-gray-300">Here we present our experimental results and the derived conjecture on the sparsity of the multiplication matrices.</p>

    <p class="text-gray-300">GB computation One of the main advantages of the ACICO model is the possibility to efficiently compute the Gröbner basis. As shown by Propositions <a href="#page-19-1">2</a> and <a href="#page-23-0">3,</a> we precisely defined the complexity of computing the GB for Anemoi. Table <a href="#page-54-1">6</a> shows the computation time (in milliseconds) of the GB with respect to the standard number of rounds of Anemoi for l = 1, 2, 3 and α = 3, 5, 7, 11. It is straightforward to notice how those results are confirming our complexity definition. Moreover, we were able to compute the GB for more than 100 rounds. As a consequence, both theoretical results both experimental results support our choice of making the security of Anemoi relying only on the second step of the GB cryptanalysis methodology.</p>

    <p class="text-gray-300"><span id="page-54-1"></span>Table 6: For l = 1, 2, 3, the GDRL (if α = 3) and G<sup>W</sup>DRL (if α = 5, 7, 11) computation time in millisecond and the solving degree dsolv. We present the GB results with respect to the number of rounds of Anemoi (in brackets), but we were able to compute the Gröbner basis for more than 100 rounds.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">α = 3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">α = 5</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">α = 7</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">α = 11</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">l = 1 TGB[ms] 2.16 (21) 2.33 (21) 2.12 (20) 1.94 (19)<br>dsolv</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">30</td>

            <td class="px-3 py-2 border-b border-gray-700">42</td>

            <td class="px-3 py-2 border-b border-gray-700">66</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">l = 2 TGB[ms] 4.57 (14) 4.39 (14) 3.83 (13) 4.02 (13)<br>dsolv</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">30</td>

            <td class="px-3 py-2 border-b border-gray-700">42</td>

            <td class="px-3 py-2 border-b border-gray-700">66</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">l = 3 TGB[ms] 11.0 (12) 8.79 (12) 8.74 (12) 8.49 (11)<br>dsolv</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">30</td>

            <td class="px-3 py-2 border-b border-gray-700">42</td>

            <td class="px-3 py-2 border-b border-gray-700">66</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Univariate polynomial finding Tables <a href="#page-55-0">7</a> to <a href="#page-56-0">9</a> show the experimental results for ACICO, l = 1, 2, 3 and α = 3, 5, 7, 11. As pointed out, the generation of the univariate polynomial is the most involving part of the attack, but it is interesting to notice the differences between the three approaches: SparseFGLM, polyDet and Wiedemann algorithm. Due to the fact that our polynomials are extremely sparse as well as the multiplication matrices, SparseFGLM and Wiedemann algorithm are performing better than polyDetAs well explained in Section ˙ <a href="#page-24-0">6.3,</a> both SparseFGLM both Wiedemann algorithm rely on the sparsity of the involved multiplication matrices. Hence, to precisely define their complexity we derived Conjecture <a href="#page-30-0">1.</a> Computing the multiplication matrix is one of the most involving parts. Being able to reduce the complexity of this step would give us the possibility to refine our results, extending them to other values of α.</p>

    <p class="text-gray-300">For cryptanalysis purposes we are not interested in finding the solutions of all the variables involved in the system. As suggested by the CICO problem, we are interested in finding solutions for the input variables. Therefore, applying the Wiedemann algorithm for each variable results in the possibility of applying the attack to more rounds.</p>

    <p class="text-gray-300"><span id="page-55-0"></span>Table 7: For q = 1481823929, l = 1, the computation times for the 3 steps in GB cryptanalysis are listed. As d<sup>I</sup> grows, the SparseFGLM, polyDet and Wiedemann algorithm fails due to memory constraint. For α = 3 the structure of the GB was obtained with DRL monomial ordering, whilst for α = 5, 7, 11 the structure of the GB was obtained with WDRL.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Gröbner basis<br>α<br>N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Univariate Poly.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Factorization</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">dsolv</td>

            <td class="px-3 py-2 border-b border-gray-700">TGB[s]</td>

            <td class="px-3 py-2 border-b border-gray-700">dI</td>

            <td class="px-3 py-2 border-b border-gray-700">TSparseF GLM</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">[s] TpolyDet[s] TW iedemann[s]</td>

            <td class="px-3 py-2 border-b border-gray-700">TF act[s]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0010</td>

            <td class="px-3 py-2 border-b border-gray-700">2<br>5</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0237</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0020</td>

            <td class="px-3 py-2 border-b border-gray-700">1.0502</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0004</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0005</td>

            <td class="px-3 py-2 border-b border-gray-700">3<br>5</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0588</td>

            <td class="px-3 py-2 border-b border-gray-700">8.3710</td>

            <td class="px-3 py-2 border-b border-gray-700">3.3447</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0235</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0006</td>

            <td class="px-3 py-2 border-b border-gray-700">4<br>5</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2866</td>

            <td class="px-3 py-2 border-b border-gray-700">1045.4280</td>

            <td class="px-3 py-2 border-b border-gray-700">6.8501</td>

            <td class="px-3 py-2 border-b border-gray-700">0.4097</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">0.00063</td>

            <td class="px-3 py-2 border-b border-gray-700">5<br>5</td>

            <td class="px-3 py-2 border-b border-gray-700">7.7925</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20.7408</td>

            <td class="px-3 py-2 border-b border-gray-700">6.0211</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">0.00066</td>

            <td class="px-3 py-2 border-b border-gray-700">6<br>5</td>

            <td class="px-3 py-2 border-b border-gray-700">1008.2052</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">110.5109</td>

            <td class="px-3 py-2 border-b border-gray-700">128.1806</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">0.00076</td>

            <td class="px-3 py-2 border-b border-gray-700">7<br>5</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">750.8691</td>

            <td class="px-3 py-2 border-b border-gray-700">6443.1831</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">0.00078</td>

            <td class="px-3 py-2 border-b border-gray-700">8<br>5</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1212.9214</td>

            <td class="px-3 py-2 border-b border-gray-700">14567.52</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">30</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0012</td>

            <td class="px-3 py-2 border-b border-gray-700">2<br>7</td>

            <td class="px-3 py-2 border-b border-gray-700">2.6680</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2355</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2368</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0012</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">30</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0009</td>

            <td class="px-3 py-2 border-b border-gray-700">3<br>7</td>

            <td class="px-3 py-2 border-b border-gray-700">11.5976</td>

            <td class="px-3 py-2 border-b border-gray-700">239.9753</td>

            <td class="px-3 py-2 border-b border-gray-700">1.6871</td>

            <td class="px-3 py-2 border-b border-gray-700">0.4430</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">30</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0010</td>

            <td class="px-3 py-2 border-b border-gray-700">4<br>7</td>

            <td class="px-3 py-2 border-b border-gray-700">132.9562</td>

            <td class="px-3 py-2 border-b border-gray-700">7256.5462</td>

            <td class="px-3 py-2 border-b border-gray-700">16.0431</td>

            <td class="px-3 py-2 border-b border-gray-700">28.0277</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">30</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0011</td>

            <td class="px-3 py-2 border-b border-gray-700">5<br>7</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">131.0137</td>

            <td class="px-3 py-2 border-b border-gray-700">278.0756</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">30</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0012</td>

            <td class="px-3 py-2 border-b border-gray-700">6<br>7</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">1104.3812</td>

            <td class="px-3 py-2 border-b border-gray-700">3273.5400</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">42</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0013</td>

            <td class="px-3 py-2 border-b border-gray-700">2<br>9</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0541</td>

            <td class="px-3 py-2 border-b border-gray-700">1.1463</td>

            <td class="px-3 py-2 border-b border-gray-700">0.4012</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0033</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">42</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0008</td>

            <td class="px-3 py-2 border-b border-gray-700">3<br>9</td>

            <td class="px-3 py-2 border-b border-gray-700">2.021</td>

            <td class="px-3 py-2 border-b border-gray-700">2348.871</td>

            <td class="px-3 py-2 border-b border-gray-700">4.7974</td>

            <td class="px-3 py-2 border-b border-gray-700">2.2697</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">42</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0010</td>

            <td class="px-3 py-2 border-b border-gray-700">4<br>9</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">47.0143</td>

            <td class="px-3 py-2 border-b border-gray-700">61.6649</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">42</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0011</td>

            <td class="px-3 py-2 border-b border-gray-700">5<br>9</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">1307.0560</td>

            <td class="px-3 py-2 border-b border-gray-700">903.4305</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">66</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0012</td>

            <td class="px-3 py-2 border-b border-gray-700">132</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0896</td>

            <td class="px-3 py-2 border-b border-gray-700">15.8898</td>

            <td class="px-3 py-2 border-b border-gray-700">0.8268</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0741</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">66</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0008</td>

            <td class="px-3 py-2 border-b border-gray-700">133</td>

            <td class="px-3 py-2 border-b border-gray-700">29.5011</td>

            <td class="px-3 py-2 border-b border-gray-700">5491.1795</td>

            <td class="px-3 py-2 border-b border-gray-700">14.9939</td>

            <td class="px-3 py-2 border-b border-gray-700">11.9790</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">66</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0010</td>

            <td class="px-3 py-2 border-b border-gray-700">134</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">214.0266</td>

            <td class="px-3 py-2 border-b border-gray-700">138.7288</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 8: For q = 1481823929, l = 2 and α = 3, the computation times for the 3 steps in GB cryptanalysis are listed. For α = 3 the structure of the GB was obtained with DRL monomial ordering, whilst for α = 5, 7, 11 the structure of the GB was obtained with WDRL.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Gröbner basis<br>α<br>N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Univ. Poly</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Factorization</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">dsolv</td>

            <td class="px-3 py-2 border-b border-gray-700">TGB[s]</td>

            <td class="px-3 py-2 border-b border-gray-700">dI</td>

            <td class="px-3 py-2 border-b border-gray-700">TSparseF GLM</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">[s] TpolyDet[s] TW iedemann[s]</td>

            <td class="px-3 py-2 border-b border-gray-700">TF act[s]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2<br>9<br>3<br>3<br>9</td>

            <td class="px-3 py-2 border-b border-gray-700">0.00071<br>0.00082</td>

            <td class="px-3 py-2 border-b border-gray-700">4<br>5<br>6<br>5</td>

            <td class="px-3 py-2 border-b border-gray-700">0.6711<br>1258.0808</td>

            <td class="px-3 py-2 border-b border-gray-700">1567.6331<br>-</td>

            <td class="px-3 py-2 border-b border-gray-700">8.6146<br>283.0214</td>

            <td class="px-3 py-2 border-b border-gray-700">1.4307<br>269.6457</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5<br>2<br>30<br>3<br>30</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0013<br>0.0014</td>

            <td class="px-3 py-2 border-b border-gray-700">4<br>7<br>6<br>7</td>

            <td class="px-3 py-2 border-b border-gray-700">185.3975<br>-</td>

            <td class="px-3 py-2 border-b border-gray-700">7389.7569<br>-</td>

            <td class="px-3 py-2 border-b border-gray-700">32.4342<br>5349.7558</td>

            <td class="px-3 py-2 border-b border-gray-700">23.8519<br>3104.4810</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7<br>2<br>42</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0013</td>

            <td class="px-3 py-2 border-b border-gray-700">4<br>9</td>

            <td class="px-3 py-2 border-b border-gray-700">722.2398</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">97.7862</td>

            <td class="px-3 py-2 border-b border-gray-700">65.0040</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">11 2<br>66</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0013</td>

            <td class="px-3 py-2 border-b border-gray-700">134</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">486.0422</td>

            <td class="px-3 py-2 border-b border-gray-700">141.8831</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-56-0"></span>Table 9: For q = 1481823929, l = 3 and α = 3, the computation times for the 3 steps in GB cryptanalysis are listed. For α = 3 the structure of the GB was obtained with DRL monomial ordering.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Gröbner basis<br>α N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Univ. Poly<br>Factorization</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">dsolv</td>

            <td class="px-3 py-2 border-b border-gray-700">TGB[s]</td>

            <td class="px-3 py-2 border-b border-gray-700">dI<br>TSparseF GLM</td>

            <td class="px-3 py-2 border-b border-gray-700">[s] TpolyDet[s] TW iedemann[s]</td>

            <td class="px-3 py-2 border-b border-gray-700">TF act[s]</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3<br>2<br>9</td>

            <td class="px-3 py-2 border-b border-gray-700">0.00106</td>

            <td class="px-3 py-2 border-b border-gray-700">6<br>5<br>2072.0338</td>

            <td class="px-3 py-2 border-b border-gray-700">789.9852</td>

            <td class="px-3 py-2 border-b border-gray-700">422.6369</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>`;
---

<BaseLayout title="Groebner Basis Cryptanalysis of Anemoi (2025/814)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2025 &middot; eprint 2025/814
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="groebner-basis-cryptanalysis-of-anemoi-2025" />
  </article>
</BaseLayout>
