---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/542';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-20';
const TITLE_HTML = 'MPC-Friendly Symmetric Key Primitives';
const AUTHORS_HTML = 'Lorenzo Grassi, Christian Rechberger, Dragos Rotaru, Peter Scholl, Nigel P.  Smart';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">We discuss the design of symmetric primitives, in particular Pseudo-Random Functions (PRFs) which are suitable for use in a secret-sharing based MPC system. We consider three different PRFs: the Naor-Reingold
PRF, a PRF based on the Legendre symbol, and a specialized block cipher design called MiMC. We present protocols for implementing these PRFs within a secret-sharing based MPC system, and discuss possible applications. We then compare the performance of our protocols. Depending on the application, different PRFs may offer different optimizations and advantages over the classic AES benchmark. Thus, we cannot conclude that there is one optimal PRF to be used in all situations.</p>
    </section>

    <p class="text-gray-300">Lorenzo Grassi Graz University of Technology.</p>

    <p class="text-gray-300">Christian Rechberger Graz University of Technology.</p>

    <p class="text-gray-300">Dragos Rotaru Dept. of Comp. Sci., University of Bristol.</p>

    <p class="text-gray-300">Peter Scholl Dept. of Comp. Sci., University of Bristol.</p>

    <p class="text-gray-300">Nigel P. Smart Dept. of Comp. Sci., University of Bristol.</p>

    <p class="text-gray-300">We discuss the design of symmetric primitives, in particular Pseudo-Random Functions (PRFs) which are suitable for use in a secret-sharing based MPC system. We consider three different PRFs: the Naor-Reingold PRF, a PRF based on the Legendre symbol, and a specialized block cipher design called MiMC. We present protocols for implementing these PRFs within a secret-sharing based MPC system, and discuss possible applications. We then compare the performance of our protocols. Depending on the application, different PRFs may offer different optimizations and advantages over the classic AES benchmark. Thus, we cannot conclude that there is one optimal PRF to be used in all situations.</p>

    <p class="text-gray-300">Secure multi-party computation (MPC) allows a set of parties to jointly evaluate a function on private inputs, with the guarantee that no party can learn anything more than the output of the function. In the last decade, MPC has moved from a theoretical pursuit to a very practical field, as protocols have become more efficient and many implementations been been developed.</p>

    <p class="text-gray-300">For many years now, the de facto benchmark for MPC systems has been secure computation of the AES function <a href="#page-13-0">[41,</a> <a href="#page-12-0">23,</a> <a href="#page-12-1">24,</a> <a href="#page-13-1">39,</a> <a href="#page-13-2">35]</a>. Although the actual choice of this function was originally as a testbed for comparing protocols, it has often been justified as &quot;useful&quot;; for example if an application needs to evaluate a symmetric encryption scheme or pseudorandom function (PRF) with a secret-shared key. If this is indeed required, then there is no particular reason why AES should be the best choice to work with MPC, compared with other PRFs or symmetric ciphers. Indeed we contend that AES is in many ways a very unnatural choice of a PRF evaluation for use in MPC applications. In this work, we conduct a study of some PRFs for use in MPC, including new protocols for evaluating number-theoretic PRFs, and</p>

    <p class="text-gray-300">Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than the author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org.</p>

    <p class="text-gray-300"><em>CCS 2016 Vienna, Austria</em></p>

    <p class="text-gray-300">c 2016 Copyright held by the owner/author(s). Publication rights licensed to ACM. ISBN 978-1-4503-4139-4/16/10. . . $15.00</p>

    <p class="text-gray-300">DOI: <a href="http://dx.doi.org/10.1145/2976749.2978332" target="_blank" rel="noopener noreferrer">http://dx.doi.org/10.1145/2976749.2978332</a></p>

    <p class="text-gray-300">implementation of &quot;traditional&quot; block cipher candidates designed to have a low complexity in MPC.</p>

    <p class="text-gray-300">Before proceeding, we first outline some applications we have in mind. Our focus is on secret sharing based MPC systems such as that typified by BDOZ <a href="#page-11-0">[7]</a>, SPDZ <a href="#page-12-2">[26,</a> <a href="#page-12-3">25]</a>, and VIFF <a href="#page-12-4">[22]</a>; or indeed any classical protocol based on Shamir Secret Sharing. In such situations data is often shared as elements of a finite field Fp, of large prime characteristic. Using such a representation one then has efficient protocols to compute relatively complex functions such as integer comparison <a href="#page-12-5">[21]</a>, fixed point arithmetic <a href="#page-12-6">[17]</a>, and linear programming <a href="#page-12-7">[16]</a>. Indeed the most famous of such efficient high level protocols is that needed to compute the output of an auction <a href="#page-11-1">[8]</a>.</p>

    <p class="text-gray-300">Given such applications, evaluated by an MPC &quot;engine&quot;, the question arises as to how to get data securely in and out of the engine. In traditional presentations the data is entered by the computing parties, and the output is delivered to the computing parties. However, this in practice will be a simplification. Input and output may need to be securely delivered/received by third parties, in addition in a long term reactive functionality the intermediate secure data may need to be stored in a database, or other storage device.</p>

    <p class="text-gray-300">If we examine the case of long term storage of data, which is stored by the MPC engine only to be used again at a later date, the trivial way to store such shared data is for each party to encrypt their share with a symmetric key, and then store each encrypted share. However, this incurs an N-fold increase in storage at the database end (for N MPC servers), which may be prohibitive. A similar trivial solution also applies for data input and output, except data input is now performed using N public keys (one for each MPC server) and output is performed by each server producing a public key encryption of its share to the recipient's public key.</p>

    <p class="text-gray-300">A more efficient solution would be to use a direct evaluation of a symmetric key primitive within the MPC engine. Such a symmetric key primitive should be able to be efficiently evaluated by the MPC engine<a href="#page-0-0">1</a> . We call such a symmetric key primitive &quot;MPC-Friendly&quot;. Given almost all symmetric key primitives can be constructed easily from</p>

    <p class="text-gray-300"><sup>1</sup>Note that public key encryption applications as mentioned above can be built from the symmetric key key primitives in the standard KEM-DEM manner. The KEM component being relatively easy to implement, in most cases, in an MPC friendly manner. Thus we focus on symmetric key primitives in this paper.</p>

    <p class="text-gray-300">Pseudo-Random Functions (PRFs), the goal is therefore to produce an MPC-Friendly PRF.</p>

    <p class="text-gray-300">The main problem of using &quot;traditional&quot; PRFs such as AES is that these are built for computational engines which work over data types that do not easily match the operations possible in the MPC engine. For example AES is very much a byte/word oriented cipher, which is hard to represent using arithmetic in  <span class="math">\\mathbb{F}_p</span> . Thus we are led to a whole new area of PRF design, with very different efficiency metrics compared to traditional PRF design.</p>

      <h3 id="sec-1.2" class="text-xl font-semibold mt-8">1.2 Secondary Applications</h3>

    <p class="text-gray-300">A simple example application of MPC is to enable distributed secure storage of long-term cryptographic keys, by secret-sharing the key and storing each share at a separate server. When the key is required by an application such as encryption or authentication, the MPC protocol is used to compute this functionality. If this cryptographic functionality is a symmetric cipher, then this application would be greatly enhanced by using an &quot;MPC-Friendly&quot; symmetric primitive.</p>

    <p class="text-gray-300">Using traditional symmetric cryptographic primitives directly on shared data can also improve efficiency for some applications. For example, Laur et al. [33] used an oblivious AES implementation to perform a secure join operation on a secret-shared database. After obliviously shuffling the database, the (deterministic) AES encryptions are made public to all parties, so that the join can then be performed efficiently using standard database algorithms.</p>

    <p class="text-gray-300">Lu and Ostrovsky [36] presented a distributed oblivious RAM protocol, which achieves only  <span class="math">O(\\log N)</span>  overhead, better than any ORAM scheme in the non-distributed setting. This protocol could be combined with a secret-shared MPC system to provide a mechanism to allow secure computation of RAM programs. However, the ORAM construction of [36] makes heavy use of a PRF, so such an application would require the use of an MPC-Friendly PRF.</p>

    <p class="text-gray-300">For other operational reasons it may be useful to encrypt data using a special form of encryption such as deterministic encryption, searchable symmetric encryption (SSE) or (leaky) order-revealing encryption (ORE) [9, 10, 18, 6, 14], under a secret-shared key. These algorithms can enable efficient queries on the encrypted data, whilst the query results can then be decrypted into shares for more complex processing using MPC. For transmission across the wire, to (or from) an external application, a form of Authenticated Encryption (AE) is needed. We note that all of these symmetric primitives (SSE, OPE, AE etc) can be built, in generic ways, out of a PRF. Thus the main obstacle preventing such applications is an efficient MPC-Friendly PRF.</p>

      <h3 id="sec-1.3" class="text-xl font-semibold mt-8">1.3 Related Work</h3>

    <p class="text-gray-300">Surprisingly there has been little direct work on this problem, despite the recent plethora of proposed MPC applications; indeed the only paper we know of which explicitly designs PRFs for use in MPC, is [4], which we shall discuss below. The three lines of work most related to the work in this paper, apart from re-purposing designs from elsewhere, are</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Low complexity, &quot;lightweight&quot; ciphers for use in IoT and other constrained environments.</li>
      <li>Block and stream ciphers suited to evaluation by a</li>
    </ul>

    <p class="text-gray-300">Fully Homomorphic/Somewhat Homomorphic encryption scheme. So called SHE-Friendly ciphers.</p>

    <p class="text-gray-300">&bull; Designs for use in SNARKs.</p>

    <p class="text-gray-300">We now elaborate on the prior work in these areas.</p>

    <p class="text-gray-300">Low Complexity Lightweight Ciphers: Block ciphers often iterate a relatively simple round function a number of times to achive security goals. Most early designs in this domain focused on small area when implemented as a circuit in hardware. There, large depth (via a large number of rounds) is of no concern as simply means clocking a circuit that implements a single round more times. Notable exceptions are mCrypton[34] and Noekeon[19] which also feature a relatively low depth. The more recent trend to emphasize low latency (with designs like PRINCE[11]) fits much better with our requirement of having low-depth. A property of all these designs is that they lend themselves well to implementations where binary NAND gates, XOR gates, or multiplexers are the basic building blocks in the used libraries. As explained above the majority of secret sharing based MPC applications require description via  <span class="math">\\mathbb{F}_p</span> . Whilst bit operations are possible over  <span class="math">\\mathbb{F}_p</span>  using standard tricks (which alas turn XOR into a non-linear operation), applying such ciphers would require the  <span class="math">\\mathbb{F}_p</span>  data types to be split into a shared bit representation over  <span class="math">\\mathbb{F}_p</span>  to apply the cipher. Such a conversion is expensive.</p>

    <p class="text-gray-300">SHE-Friendly Ciphers: Perhaps due to the recent theoretical interest in SHE/FHE schemes this area has had more attention than the more practical issues addressed in this paper. The motivating scenario for a SHE-Friendly cipher is to enable data to be securely passed to a cloud environment, using a standard encryption scheme, which the cloud server then homomorphically decrypts to obtain a homomorphic encryption of the original data.</p>

    <p class="text-gray-300">This line of work has resulted in a handful of designs. A block cipher called LowMC [4], a stream cipher called Kreyvium [13] (based on the Trivium stream cipher) and FLIP [37] (based on a filter permutation)<sup>2</sup>. The block cipher LowMC is designed for both MPC and FHE implementation, but actually does not meet the MPC design goals we have set. It does indeed have low depth, but it is a cipher based on operations in characteristic two. The two SHE friendly stream cipher designs of Kreyvium and FLIP also suffer from the same problem as the lightweight designs describe above, as they are also bit-oriented.</p>

    <p class="text-gray-300"><strong>SNARK-Friendly Constructions:</strong> Being SNARK-friendly means that the number of constraints is low. This generally favours larger data types like  <span class="math">\\mathbb{F}_p</span>  or  <span class="math">\\mathbb{F}_{2^n}</span> , and the depth of the circuit is of no concern. MiMC [2] was originally designed for this use case and seems to be the only one in this area. As the depth is not too high either, we choose it for detailed evaluation.</p>

      <h3 id="sec-1.4" class="text-xl font-semibold mt-8">1.4 Contributions</h3>

    <p class="text-gray-300">The goal of this work is to investigate the efficient evaluation of PRFs in a secret-sharing based MPC setting. <sup>3</sup> We</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;2</sup>FLIP was recently cryptanalysed in [28].</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;3</sup>We leave the construction of the various higher level primitives (SSE, ORE, AE etc.) to future work, although many of these can easily be constructed directly from a PRF.</p>

    <p class="text-gray-300">present new protocols for secure computation of PRFs, and implementation results using an actively secure MPC protocol, which tolerates up to N-1 out of N corrupted parties (with an online phase based on the SPDZ protocol [26, 25]).</p>

    <p class="text-gray-300">To fix notation we will consider a PRF of the following form</p>

    <p class="text-gray-300"><span class="math">$F: \\left\\{ \\begin{array}{ccc} (\\mathbb{F}_p)^{\\ell} \\times (\\mathbb{F}_q)^n &amp; \\longrightarrow &amp; (\\mathbb{F}_r)^m \\\\ (k_1, \\dots, k_{\\ell}, x_1, \\dots, x_n) &amp; \\longmapsto &amp; F_k(x_1, \\dots, x_n). \\end{array} \\right.</span>$</p>

    <p class="text-gray-300">The various finite fields  <span class="math">\\mathbb{F}_p</span> ,  <span class="math">\\mathbb{F}_q</span>  and  <span class="math">\\mathbb{F}_r</span>  may be distinct. Our MPC engine is assumed to work over the finite field  <span class="math">\\mathbb{F}_p</span> , as we always assume the key to the PRF will be a secret shared value. As a benchmark, we compare all of our candidates to the baseline AES example used in prior work, and to implementations of the given PRFs on clear data.</p>

    <p class="text-gray-300">Depending on the precise application, there are several distinct design criteria which we may want to consider. Thus, there will not be a one size fits all PRF which works in all applications. We then have various potential cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>In some applications the input is public and we need to embed the public elements  <span class="math">x_1, \\ldots, x_n \\in \\mathbb{F}_q</span>  into  <span class="math">\\mathbb{F}_p</span> . However, the more general case is when the input is secret shared itself, and we have  <span class="math">\\mathbb{F}_q = \\mathbb{F}_p</span> .</li>
      <li>In some applications the output of the PRF will be public, and thus  <span class="math">\\mathbb{F}_r</span>  can be any field. In other applications we also want the output to be secret shared, so we can use it in some other processing such as a mode of operation. In this latter case we will have  <span class="math">\\mathbb{F}_r = F_p</span> . In addition, some applications, such as when using the (leaky) ORE scheme presented in [18] require PRF outputs in  <span class="math">\\{0,1,2\\}</span> , and we may (or may not) require these to be secret shared (and hence embedded in  <span class="math">\\mathbb{F}_p</span> ).</li>
      <li>In some applications we would like a PRF which is just efficient in the MPC engine, and we do not care whether the equivalent standard PRF is efficient or not. In other applications we also require that the standard PRF is also efficient. For example when an external third party is encrypting data for the MPC engine to decrypt.</li>
    </ul>

    <p class="text-gray-300">In this paper we consider four candidate PRFs for use in MPC systems, as well as the comparison case of AES. Two of these are number theoretic in nature (the Naor-Reingold PRF, based on DDH, and a PRF based on the Legendre symbol), whilst MiMC [2] and LowMC [4] are more akin to traditional symmetric block cipher constructions.</p>

    <p class="text-gray-300"><strong>AES:</strong> Since AES does not lend itself well to secure computation over prime fields, we use this purely as a benchmark. We assume an MPC system which is defined over the finite field  <span class="math">\\mathbb{F}_{2^8}</span> , allowing for efficient evaluation of the S-box [23, 24]. We have</p>

    <p class="text-gray-300"><span class="math">$F_{\\mathsf{AES}} : (\\mathbb{F}_{2^8})^{16} \\times (\\mathbb{F}_{2^8})^{16} \\to (\\mathbb{F}_{2^8})^{16}.</span>$</p>

    <p class="text-gray-300"><strong>LowMC:</strong> This is a block cipher candidate [4] designed to be suitable for FHE and MPC style applications; thus it has a low multiplicative depth and a low number of multiplications. It operates over  <span class="math">\\mathbb{F}_2</span> , so like AES, is not well-suited to the MPC applications for which we envisage our block ciphers being used for. Thus we only consider LowMC as an additional base line comparison (along with AES) for our</p>

    <p class="text-gray-300">ciphers. LowMC has block size n bits and key size k bits (we use n=256 and k=128), giving:</p>

    <p class="text-gray-300"><span class="math">$F_{\\mathsf{LowMC}}: (\\mathbb{F}_2)^k \\times (\\mathbb{F}_2)^n \\to (\\mathbb{F}_2)^n</span>$</p>

    <p class="text-gray-300"><strong>Naor-Reingold:</strong> Let  <span class="math">\\mathbb{G} = \\langle g \\rangle</span>  be an elliptic curve group of prime order p in which DDH is hard, and  <span class="math">encode(\\cdot)</span>  be a hash function that maps elements of  <span class="math">\\mathbb{G}</span>  into elements of  <span class="math">\\mathbb{F}_p</span> . The Naor-Reingold PRF takes a uniform secret-shared key in  <span class="math">\\mathbb{F}_p^{n+1}</span> , a message in  <span class="math">\\mathbb{F}_2^n</span>  (secret-shared over  <span class="math">\\mathbb{F}_p</span> ), and outputs a public  <span class="math">\\mathbb{F}_p</span>  element as follows:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} F_{\\mathsf{NR}(n)} : (\\mathbb{F}_p)^{n+1} \\times (\\mathbb{F}_2)^n &amp;\\to \\mathbb{F}_p \\\\ &amp; (\\mathbf{k}, \\mathbf{x}) \\mapsto \\mathsf{encode}(g^{k_0 \\cdot \\prod_{i=1}^n k_i^{x_i}}) \\end{split}</span>$</p>

    <p class="text-gray-300">To evaluate  <span class="math">F_{\\rm NR}</span>  in MPC naively would require computing exponentiations (or EC scalar multiplications) on secret exponents, which is very expensive. However, if the PRF output is public, we show how the exponentiation (and hence PRF evaluation) can be done very efficiently, with active security, using any MPC protocol based on secret sharing.</p>

    <p class="text-gray-300"><strong>Legendre Symbol:</strong> We also consider an unusual PRF based on the pseudorandomness of the Legendre symbol. This is a relatively old idea, going back to a paper of Damg&aring;rd in 1988 [20], but has not been studied much by the cryptographic community. The basic version of the PRF is defined as,</p>

    <p class="text-gray-300"><span class="math">$F_{\\mathsf{Leg(bit)}} : \\mathbb{F}_p \\times \\mathbb{F}_p \\to \\mathbb{F}_2</span>$
<span class="math">$(k, x) \\mapsto L_p(x + k)</span>$</p>

    <p class="text-gray-300">where  <span class="math">L_p(a)</span>  computes the usual Legendre symbol  <span class="math">\\left(\\frac{a}{p}\\right) \\in \\{-1,0,1\\}</span>  and maps this into  <span class="math">\\{0,1,(p+1)/2\\}</span> , by computing</p>

    <p class="text-gray-300"><span class="math">$L_p(a) = \\frac{1}{2} \\left( \\left( \\frac{a}{p} \\right) + 1 \\right) \\pmod{p}.</span>$</p>

    <p class="text-gray-300">The output is embedded into  <span class="math">\\mathbb{F}_p</span> , giving a secret-shared output in  <span class="math">\\mathbb{F}_p</span> . If needed, the range can easily be extended to the whole of  <span class="math">\\mathbb{F}_p</span>  by using a key with multiple field elements and performing several evaluations in parallel. This gives a PRF</p>

    <p class="text-gray-300"><span class="math">$F_{\\mathsf{Leg}(n)}: (\\mathbb{F}_p)^{((n+1)\\cdot \\ell)} \\times (\\mathbb{F}_p)^n \\to \\mathbb{F}_p,</span>$</p>

    <p class="text-gray-300">for some value  <span class="math">\\ell=O(\\log_2 p)</span>  chosen large enough to ensure a sufficient statistical distance from uniform of the output. This PRF takes n finite field elements as input and produces an element in  <span class="math">\\mathbb{F}_p</span>  as output, where n is some fixed (and relatively small) number, say one or two.</p>

    <p class="text-gray-300">Perhaps surprisingly, we show that the Legendre PRF can be evaluated very efficiently in MPC, at the cost of just two multiplications in three rounds of interaction for  <span class="math">F_{\\text{Leg(bit)}}</span> . To the best of our knowledge, this is the only PRF that can be evaluated in a constant number of rounds on secret-shared data, using any arithmetic MPC protocol. Since the underlying hard problem is less well-studied than, say, DDH or factoring, we also provide a brief survey of some known attacks, which are essentially no better than brute force of the key.</p>

    <p class="text-gray-300">MiMC: This is a very recent class of designs whose primary application domain are SNARKs [2]. In addition to a cryptographic hash function, the design also includes a block cipher which is also usable as a PRF, with up to birthday</p>

    <p class="text-gray-300">bound security. The input, output and keys are all defined over  <span class="math">\\mathbb{F}_p</span> , so we get:</p>

    <p class="text-gray-300"><span class="math">$F_{\\mathsf{MiMC}}: \\mathbb{F}_p \\times \\mathbb{F}_p \\to \\mathbb{F}_p.</span>$</p>

    <p class="text-gray-300">The core of the round function is the simple map  <span class="math">x \\mapsto x^3</span>  over  <span class="math">\\mathbb{F}_p</span> . The number of rounds is quite high (for a 128-bit prime p 82 for full security, 73 for PRF security), but in terms of  <span class="math">\\mathbb{F}_p</span>  multiplications the performance turns out to be competitive.</p>

    <p class="text-gray-300">The reason for selecting MiMC as a &quot;standard&quot; block cipher is that firstly it works over a finite prime field of large characteristic, which is a common requirement for applications of secret-sharing based MPC that perform arithmetic on integers or fixed-point data types. Secondly, the depth of the computation is not too large, being 146. Thirdly, the number of non-linear operations is also 146, this means that the offline pre-processing needed (to produce multiplication triples) will be very small compared to other constructions.</p>

    <p class="text-gray-300">In Table 1 we present an overview of the MPC-friendly PRFs we consider. The table shows the number of secure multiplication needed to execute the online evaluation of the function on shared inputs (since in secret-sharing based MPC, additions are free) as well as the number of rounds of communication.</p>

    <p class="text-gray-300">We end this introduction by noting that  <span class="math">F_{\\mathsf{MiMC}}</span>  and  <span class="math">F_{\\mathsf{Leg}(n)}</span>  can be extended to cope with arbitrary length inputs in the standard way; either by using a CBC-MAC style construction or a Merkle&ndash;Damg&aring;rd style construction. For example, to extend  <span class="math">F_{\\mathsf{Leg}(1)}</span>  and  <span class="math">F_{\\mathsf{MiMC}}</span> , so that they can be applied to an input  <span class="math">x_1,\\ldots,x_n\\in\\mathbb{F}_p</span>  we can use CBC mode as in Figure 1. Whereas, to extend  <span class="math">F_{\\mathsf{Leg}(2)}</span>  we can apply Merkle&ndash;Damgard as in Figure 2. These two extension techniques are often more efficient than using an arbitrary length PRF as a base building block.</p>

    <pre><code class="language-text">Length Extension for F_{\\mathsf{Leg}(1)}
1. c_0 \\leftarrow n.
2. For i = 1, \\dots, n do

(a) c_i \\leftarrow x_i + F_{\\mathsf{Leg}(1)}(k, c_{i-1}).
3. a \\leftarrow F_{\\mathsf{Leg}(1)}(k, c_n).
4. Return a.
</code></pre>

    <p class="text-gray-300">Figure 1: Using CBC Mode With  <span class="math">F_{Leg(1)}</span></p>

    <pre><code class="language-text">Length Extension for F_{\\mathsf{Leg}(2)}

1. c_0 \\leftarrow n.

2. For i = 1, \\dots, n do

(a) c_i \\leftarrow F_{\\mathsf{Leg}(2)}(k, c_{i-1}, x_i).

3. Return c_n.
</code></pre>

    <p class="text-gray-300">Figure 2: Using Merkle-Damg&aring;rd With  <span class="math">F_{Leg(2)}</span></p>

    <h4 id="sec-misc-1" class="text-lg font-semibold mt-6">2. BACKGROUND</h4>

    <p class="text-gray-300">In this section we outline some of the basic material which we will assume for the rest of this paper.</p>

    <p class="text-gray-300">The general model of MPC we consider is the so-called arithmetic black box, which is an ideal functionality that allows parties to input and output values to be secret-shared, and performs basic arithmetic operations on these secret values over a finite field  <span class="math">\\mathbb{F}_p</span> . This abstracts away the underlying details of secret-sharing and MPC, and gives us the commands in Figure 3. Note that as well as addition and multiplication,  <span class="math">\\mathcal{F}_{ABB}</span>  has commands for generating random values according to various distributions, which allows more efficient protocols for certain tasks. Finally, the <strong>Share</strong> command gives parties access to random, additive shares of a value stored in the box. This essentially assumes the underlying MPC protocol uses additive secret sharing, but is only used for the Naor-Reingold PRF protocol (Section 3).</p>

    <p class="text-gray-300">We use the notation [x] to denote a secret-shared value that is stored in  <span class="math">\\mathcal{F}_{ABB}</span> . We also define addition and multiplication operators for the  <span class="math">[\\cdot]</span>  notation; so, for example, the statement</p>

    <p class="text-gray-300"><span class="math">$[w] = [x] \\cdot [y] + 2[z]</span>$</p>

    <p class="text-gray-300">implicitly means that the <strong>Add</strong> and <strong>Mult</strong> commands of  <span class="math">\\mathcal{F}_{\\mathsf{ABB}}</span>  are used to compute the shared value [w].</p>

    <h4 id="sec-misc-2" class="text-lg font-semibold mt-6">Functionality <span class="math">\\mathcal{F}_{ABB}</span></h4>

    <p class="text-gray-300">Each value stored in this functionality is associated with a unique identifier that is given to all parties. Let [x] denote the identifier for a value x that is stored by the functionality. Let  <span class="math">A \\subset \\{1, \\ldots, n\\}</span>  denote the index set of corrupted parties.</p>

    <p class="text-gray-300"><strong>Input:</strong> Receive a value  <span class="math">x \\in \\mathbb{F}_p</span>  from some party and store x.</p>

    <p class="text-gray-300">Add([x],[y]): Compute z = x + y and store [z].</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Mult}([x],[y])</span> : Compute  <span class="math">z=x\\cdot y</span>  and store [z].</p>

    <p class="text-gray-300"><strong>Random:</strong> Sample  <span class="math">r \\stackrel{R}{\\leftarrow} \\mathbb{F}_p</span>  and store [r].</p>

    <p class="text-gray-300"><strong>RandomBit:</strong> Sample  <span class="math">b \\stackrel{R}{\\leftarrow} \\{0,1\\} \\subset \\mathbb{F}_p</span>  and store [b].</p>

    <p class="text-gray-300"><strong>RandomSquare:</strong> Sample  <span class="math">s \\stackrel{R}{\\leftarrow} \\mathbb{F}_p</span>  and store  <span class="math">[s^2]</span> .</p>

    <p class="text-gray-300"><strong>Share</strong>([x]): For each  <span class="math">i \\in A</span> , receive  <span class="math">x_i \\in \\mathbb{F}_p</span>  from the adversary. Sample uniform honest parties' shares  <span class="math">\\{x_j\\}_{j \\notin A}</span> , subject to the constraint that  <span class="math">\\sum_{i=1}^n x_i = x</span> . Send  <span class="math">x_i</span>  to party  <span class="math">P_i</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Output}([x])</span> : Send the value x to all parties.</p>

    <p class="text-gray-300">Figure 3: Ideal functionality for arithmetic MPC</p>

    <p class="text-gray-300">Concretely, the MPC protocol we use to implement  <span class="math">\\mathcal{F}_{\\mathsf{ABB}}</span>  is the SPDZ protocol by Damg&aring;rd et al. [26, 25], which operates over a finite field of size  <span class="math">\\geq 2^{\\kappa}</span>  (for statistical security  <span class="math">\\kappa</span> ) and provides active security against any number of corrupted parties. The protocol consists of two stages: a preprocessing phase, which is independent of the inputs and done in advance, and a more efficient online phase, where the actual computation takes place. The purpose of the preprocessing is to generate enough random shared data that will be consumed later by the online phase. The main data produced is one of three different forms:</p>

    <p class="text-gray-300">&bull; Multiplication Triples: A triple of random shares ([a], [b], [c]) such that  <span class="math">c = a \\cdot b \\mod p</span> .</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">PRF</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\log_2 p</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Output (type)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Online cost</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Assumption</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Mult.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Rounds</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">F_{AES}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">shared</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">960</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">50</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">F_{\\sf LowMC}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">shared</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1911</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">F_{NR}(n)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">public</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2 \\cdot n</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">3 + \\log(n+1)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">EC-DDH</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">F_{Leg}(bit)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">shared</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">DSLS</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">F_{Leg}(n)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">shared</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">256 \\cdot n</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">DSLS</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">F_{MiMC}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">shared</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">146</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">73</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">=</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 1: Overview of the cost of evaluating the PRFs in MPC.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Square Pairs: A pair of random shares ([a], [b]) such that  <span class="math">b = a^2 \\mod p</span> .</li>
      <li>Random Bit: A random sharing [a] of a value  <span class="math">a \\in \\{0, 1\\}</span> .</li>
    </ul>

    <p class="text-gray-300">The main arithmetic operations in  <span class="math">\\mathcal{F}_{ABB}</span>  have roughly the following complexity when implemented in SPDZ. Additions (and linear operations) are local operations so essentially for free. A multiplication uses a preprocessed multiplication triple and requires sending two field elements in the online phase, with one round of interaction. Squaring can be done using a square pair and sending just one field element, again in one round.</p>

    <p class="text-gray-300">The preprocessing can be implemented using either somewhat homomorphic encryption (SHE) &mdash; as in the original SPDZ protocols &mdash; or oblivious transfer (OT), using the recent protocol of Keller et al. [31]. We present runtimes using the OT-based offline phase only, as it is much more efficient, even when compared with the weaker covertly secure protocols using SHE.</p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8">2.2 MPC Evaluation of AES and LowMC</h3>

    <p class="text-gray-300">As a means of comparison for the other PRFs we use as a base line a two party implementation of AES using a SPDZ engine over the finite field  <span class="math">\\mathbb{F}_{2^8}</span> , embedded into  <span class="math">\\mathbb{F}_{2^{40}}</span> , as in [24]. We estimate the offline phase costs 200ms per block, with an online phase latency of 8ms and a throughput of over 500 blocks per second. Note that recently, much lower latencies have been obtained by evaluating AES using secure table lookup [27]. However, this technique requires far more (i.e., 256 times) preprocessing data, so we do not consider this. One should also bear in mind that this is only the time needed to evaluate the PRF. In a given application, which is likely to be over a different finite field, the MPC engine will also need to convert data between the two fields  <span class="math">\\mathbb{F}_p</span>  and  <span class="math">\\mathbb{F}_{2^{40}}</span> . This is likely to incur a more significant cost than the evaluation of the PRF itself.</p>

    <p class="text-gray-300">In addition to AES, we also present comparison executions for the low complexity block cipher LowMC. This is to enable a comparison with our  <span class="math">\\mathbb{F}_p</span>  based block ciphers against not only a standard in-use block cipher (AES), but also a block cipher designed for use in MPC/FHE environments.</p>

      <h4 id="sec-2.2.1" class="text-lg font-semibold mt-6">2.2.1 F<sub>LowMC</sub> Definition</h4>

    <p class="text-gray-300">LowMC [4] is a flexible family of block ciphers with operations over  <span class="math">\\mathbb{F}_2</span> , designed to have a low number of multiplications and a low multiplicative depth when implemented in MPC. Similar to AES, it is based on an SPN structure where the block size n, the key size k, the number of Sboxes m in</p>

    <p class="text-gray-300">the substitution layer and the allowed data complexity d of attacks can independently be chosen. The number of rounds r needed to reach the security claims is then derived from these parameters. The two most relevant parts of the round transformation are the Sboxlayer and the Linearlayer. Sboxlayer is an m-fold parallel application of the same 3-bit Sbox (of multiplicative depth 1) on the first 3m bits of the state. If n&gt;3m then for the remaining n-3m bits, the Sboxlayer is the identity. Linearlayer is the multiplication in  <span class="math">\\mathbb{F}_2</span>  of the state with a predetermined dense randomly chosen invertible binary  <span class="math">n\\times n</span>  matrix that is different for every round.</p>

    <p class="text-gray-300">Using the most recent v2[3] formula for r, we need at least 13 rounds to achieve a security comparable to AES as a PRF, i.e. k = 128 and d = 64. Using n = 256, the minimal number Sboxes m for which this is true turns out to be 49.</p>

    <p class="text-gray-300">To evaluate LowMC in MPC, we consider two approaches. In the first method, denoted  <span class="math">F_{\\mathsf{LowMC}}(\\mathsf{vector})</span> , we work over  <span class="math">\\mathbb{F}_{2^{128}}</span>  and compute the matrix multiplications and XOR operations by parallelizing over 128-bit vectors. Specifically, each column  <span class="math">M_i</span>  of the  <span class="math">n \\times n</span>  matrix M is packed into  <span class="math">\\mathbb{F}_{2^{128}}</span>  elements; to compute the product  <span class="math">M[\\mathbf{x}]</span>  we take the inner product of all columns with  <span class="math">[\\mathbf{x}]</span> . For n=256, this requires 512 XORs and 512 local finite field multiplications. However, we then need to switch back to  <span class="math">\\mathbb{F}_2</span>  to evaluate the Sbox (with three  <span class="math">\\mathbb{F}_2</span>  multiplications), which requires bit decomposition, adding one round of interaction for every round of the cipher.</p>

    <p class="text-gray-300">In the second approach, denoted  <span class="math">F_{\\mathsf{LowMC}}(\\mathsf{M4R})</span> , we use the &quot;Method of Four Russians&quot; [1] to perform each matrix multiplication in  <span class="math">O(n^2/\\log n)</span>  bit operations. We do not parallelize the computation by packing bits into vectors, so this actually results in a higher computation cost than the vector method, but avoids the need for bit decomposition in each round.</p>

    <p class="text-gray-300">In both methods, the total number of multiplications over  <span class="math">\\mathbb{F}_2</span>  is  <span class="math">3 \\cdot m \\cdot r</span> . The vector approach requires  <span class="math">256 \\cdot r</span>  additional random bits, and also 2r rounds of communication, instead of r rounds for M4R.</p>

      <h4 id="sec-2.2.3" class="text-lg font-semibold mt-6">2.2.3 Performance</h4>

    <p class="text-gray-300">With parameters n=256, m=49, r=13, we obtained a latency of 4ms and a throughput of almost 600 blocks per second.</p>

    <p class="text-gray-300">As for AES, the need to convert from a  <span class="math">\\mathbb{F}_p</span>  representation to a bit-oriented representation for application of LowMC is likely to dominate the run-time for the actual PRF eval-</p>

    <p class="text-gray-300">uation, making LowMC unsuitable for the applications we discussed at the beginning.</p>

    <h4 id="sec-misc-3" class="text-lg font-semibold mt-6">NAOR-REINGOLD PRF</h4>

    <p class="text-gray-300">In this section we describe the Naor-Reingold PRF, originally presented in [38]. We then go on to describe how it can be efficiently implemented in a secret sharing based MPC system.</p>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8">3.1 <span class="math">F_{NR}</span> <strong>Definition</strong></h3>

    <p class="text-gray-300">Let  <span class="math">\\mathbb{G} = \\langle g \\rangle</span>  be a multiplicatively written group of prime order p in which DDH is hard, and  <span class="math">encode(\\cdot)</span>  be a hash function that maps group elements into elements of  <span class="math">\\mathbb{F}_p</span> . For a message  <span class="math">\\mathbf{x} = (x_1, \\dots, x_n) \\in \\{0, 1\\}^n</span> , the Naor-Reingold PRF [38] is defined by:</p>

    <p class="text-gray-300"><span class="math">$F_{\\mathsf{NR}(n)}(\\mathbf{k}, \\mathbf{x}) = \\mathsf{encode}(g^{k_0 \\cdot \\prod_{i=1}^n k_i^{x_i}})</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\mathbf{k} = (k_0, \\dots, k_n) \\in \\mathbb{F}_p^{n+1}</span>  is the key. In practice, we choose  <span class="math">\\mathbb{G}</span>  to be a 256-bit elliptic curve group over the NIST curve P-256, so require an MPC protocol for  <span class="math">\\mathbb{F}_p</span>  with a 256-bit prime p.</p>

    <p class="text-gray-300">The main ingredient of our method to evaluate  <span class="math">F_{NR}</span>  in MPC, when the key and message are secret-shared over  <span class="math">\\mathbb{F}_p</span> , is an efficient protocol for publicly computing  <span class="math">q^s</span> , for some secret value  <span class="math">s \\in \\mathbb{F}_p</span> . The protocol, shown in Figure 4, uses any arithmetic MPC protocol based on linear secret sharing over  <span class="math">\\mathbb{F}_p</span> . This is modeled for the case of additive secret sharing by the <strong>Share</strong> command of the  <span class="math">\\mathcal{F}_{ABB}</span>  functionality, which produces random shares of secret values.</p>

    <p class="text-gray-300">Given additive shares  <span class="math">s_i \\in \\mathbb{F}_p</span> , each party  <span class="math">P_i</span>  first broadcasts  <span class="math">g^{s_i}</span> , so the result  <span class="math">y = \\prod g^{s_i}</span>  can be computed. To obtain active security, we must ensure that each party used the correct value of  <span class="math">s_i</span> . We do this by computing an additional public exponentiation of  <span class="math">g^t</span> , where  <span class="math">t = r \\cdot s</span>  for some random, secret value r. This serves as a one-time MAC on s, which can then be verified by opening r and checking that  <span class="math">g^t = y^r</span> . If an adversary cheats then passing the check essentially requires guessing the value of r, so occurs only probability 1/p.</p>

    <p class="text-gray-300">Note that the functionality  <span class="math">\\mathcal{F}_{ABB-Exp}</span>  (Figure 5) models an unfair computation, whereby the adversary first learns the output, and can then decide whether to give this to the honest parties or not. This is because in the protocol, they can always simply stop sending messages and abort after learning y.</p>

    <p class="text-gray-300"><strong>Theorem 1.</strong> The protocol  <span class="math">\\Pi_{\\mathsf{Exp}}</span>  securely computes the functionality  <span class="math">\\mathcal{F}_{\\mathsf{ABB-Exp}}</span>  in the  <span class="math">\\mathcal{F}_{\\mathsf{ABB}}\\text{-}\\mathit{hybrid}</span>  model.</p>

    <p class="text-gray-300"><em>Proof.</em> We construct a simulator S, which interacts with any adversary  <span class="math">\\mathcal{A}</span>  (who controls the corrupt parties  <span class="math">\\{P_i: i \\in A\\}</span> ) and the ideal functionality  <span class="math">\\mathcal{F}_{ABB-Exp}</span> , such that no environment can distinguish between an interaction with S and a real execution of the protocol  <span class="math">\\Pi_{\\mathsf{Exp}}</span> .</p>

    <p class="text-gray-300">&bull; In the first round S receives  <span class="math">s_i</span>  for  <span class="math">i \\in A</span> , as the corrupt parties' inputs to the  <span class="math">\\mathcal{F}_{\\mathsf{ABB-Share}}</span>  command.  <span class="math">\\mathcal{S}</span>  calls  <span class="math">\\mathcal{F}_{ABB-Exp}</span>  with (exp, [s]) and receives  <span class="math">y = g^s</span> . Then  <span class="math">\\mathcal{S}</span> samples  <span class="math">s_i \\stackrel{R}{\\leftarrow} \\mathbb{F}_p</span>  and sets  <span class="math">y_i = g^{s_i}</span>  for all  <span class="math">i \\notin A</span> .  <span class="math">\\mathcal{S}</span> modifies one honest party's share  <span class="math">y_i</span>  to  <span class="math">g^s \\prod_{i \\neq i} y_i^{-1}</span> ,</p>

    <h4 id="sec-misc-4" class="text-lg font-semibold mt-6">Protocol <span class="math">\\Pi_{\\mathsf{Exp}}([s])</span></h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The parties call  <span class="math">\\mathcal{F}_{ABB}</span>  with command (Share, [s]), so that each party  <span class="math">P_i</span>  obtains an additive share  <span class="math">s_i \\in \\mathbb{F}_p</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Each party  <span class="math">P_i</span>  broadcasts  <span class="math">y_i = g^{s_i}</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">y = \\prod_i y_i</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Take a random shared [r], and compute  <span class="math">[t] = [r] \\cdot [s]</span></li>
    </ol></li>
      <li>Call  <span class="math">\\mathcal{F}_{ABB}</span>  with (Share, [t]) so that each  <span class="math">P_i</span>  obtains  <span class="math">t_i</span> . Broadcast  <span class="math">z_i = g^{t_i}</span></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Open [r] and check that  <span class="math">\\prod_i z_i = y^r</span></li>
    </ol></li>
      <li>7. Output y</li>
    </ul>

    <p class="text-gray-300">Figure 4: Securely computing a public exponentia-</p>

    <h4 id="sec-misc-5" class="text-lg font-semibold mt-6">Functionality <span class="math">\\mathcal{F}_{ABB-Exp}</span></h4>

    <p class="text-gray-300">Let  <span class="math">G = \\langle g \\rangle</span>  be a group of prime order p. This functionality has all of the features of  <span class="math">\\mathcal{F}_{ABB}</span>  (running in  <span class="math">\\mathbb{F}_p</span> ), plus the following</p>

    <p class="text-gray-300"><strong>PubExp:</strong> On receiving (exp, [s]) from all parties, where s is stored in memory, retrieve s, then send  <span class="math">y = g^s</span>  to the adversary and wait for a response. If the adversary responds with <strong>Deliver</strong> then send y to all parties. Otherwise output  <span class="math">\\perp</span>  to all parties.</p>

    <p class="text-gray-300">Figure 5: Ideal functionality for public exponentiation</p>

    <p class="text-gray-300">then sends  <span class="math">y_i</span>  for all  <span class="math">i \\notin A</span>  to the adversary and gets back the corrupted parties' response  <span class="math">y_i^*</span> , for  <span class="math">i \\in A</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Proceed similarly to the previous step: S samples  <span class="math">r_i \\stackrel{R}{\\leftarrow}</span>  <span class="math">\\mathbb{F}_p</span> , sets  <span class="math">z_i = y_i^{r_i}</span>  such that  <span class="math">\\prod_i z_i = y^r</span> . Sends  <span class="math">z_i</span>  to  <span class="math">\\mathcal{A}</span>  on behalf of the honest parties. Receives back courrupted parties  <span class="math">z_i^*</span> .</li>
      <li>Sends  <span class="math">r \\leftarrow \\sum_{i} r_{i}</span>  to the adversary. S performs the checking phase with  <span class="math">z_i^*</span>  from  <span class="math">\\mathcal{A}</span>  and the honest  <span class="math">z_i</span> . If the check passes send <strong>Deliver</strong> to  <span class="math">\\mathcal{F}_{ABB-Exp}</span> .</li>
    </ul>

    <p class="text-gray-300">The indistinguishability argument follows from the fact that all broadcasted values  <span class="math">g^{x_i}</span>  by  <span class="math">\\mathcal{S}</span>  and the real protocol  <span class="math">\\Pi_{\\mathsf{Exp}}</span>  have uniform distribution over  <span class="math">\\mathbb{F}_p</span>  with output in  <span class="math">\\mathbb{G}</span> with respect to  <span class="math">\\prod_i g^{x_i} = g^x</span> .</p>

    <p class="text-gray-300">Correctness is straightforward if all parties follow the protocol. An adversary A wins if it changes the distribution of the functionality to output <strong>Deliver</strong>. Alas, this happens with negligible probability:</p>

    <p class="text-gray-300">Suppose a corrupt party  <span class="math">P_j</span>  sends  <span class="math">y_j^*</span>  instead of  <span class="math">y_j = g^{s_j}</span> . We can write  <span class="math">y_j^* = g^{s_j} \\cdot e</span> , for some error  <span class="math">e \\neq 1 \\in \\mathbb{G}</span> , and so  <span class="math">y = g^s \\cdot e</span> . Then the check passes if  <span class="math">\\mathcal{A}</span>  can come up with  <span class="math">z_j^*</span>  such that  <span class="math">\\prod_i z_i = g^{rs} \\cdot e^r</span> . Writing  <span class="math">z_j^* = z_j \\cdot f</span> , this is equivalent to coming up with  <span class="math">f \\in \\mathbb{G}</span>  such that  <span class="math">f = e^r</span> . Since r is uniformly random and unknown to the adversary at the time of choosing e and f, passing this check can only happen with probability  <span class="math">1/|\\mathbb{G}|</span> . Note that this requires  <span class="math">\\mathbb{G}</span>  to be of prime order, so that e (which is adversarially chosen) is always a generator of  <span class="math">\\mathbb{G}</span> .</p>

    <h4 id="sec-misc-6" class="text-lg font-semibold mt-6">More Efficient Protocol based on SPDZ.</h4>

    <p class="text-gray-300">When using the SPDZ MPC protocol with the secret-shared MAC representation from [25], we can save performing the multiplication  <span class="math">[t] = [r] \\cdot [s]</span> . Instead, we can take the shared MAC value [m] (on the shared s), which satisfies  <span class="math">m = s \\cdot \\alpha</span>  for a shared MAC key  <span class="math">\\alpha</span> , and use [m] and  <span class="math">[\\alpha]</span>  in place of [t] and [r]. However, in this case  <span class="math">\\alpha</span>  cannot be made public, otherwise all future MACs could be forged. Instead, steps 4&ndash;6 are replaced with:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Each party commits to  <span class="math">z_i = y^{\\alpha_i} \\cdot g^{-m_i}</span> .</li>
      <li>All parties open their commitments and check that  <span class="math">\\prod_i z_i = 1</span> .</li>
    </ul>

    <p class="text-gray-300">If the parties are honest, we have  <span class="math">z_i = g^{s \\cdot \\alpha_i - m_i}</span> , so the check will pass. Since in SPDZ, the honest parties' MAC shares  <span class="math">m_i</span>  are uniformly random, the shares of  <span class="math">\\alpha_i</span>  are perfectly masked by the  <span class="math">g^{-m_i}</span>  factor in  <span class="math">z_i</span> , so no information on  <span class="math">\\alpha</span>  is leaked. The main difference here is that the parties must commit to the  <span class="math">z_i</span>  shares before opening, to prevent a rushing adversary from waiting and forcing the product to always be 1. The number of rounds and exponentiations is the same, but one multiplication is saved compared with the previous protocol.</p>

    <h4 id="sec-misc-7" class="text-lg font-semibold mt-6">Protocol <span class="math">\\Pi_{NR}</span></h4>

    <p class="text-gray-300"><strong>KeyGen:</strong> Call  <span class="math">\\mathcal{F}_{\\mathsf{ABB}}</span> .Random to generate n+1 random keys  <span class="math">[k_0] \\dots [k_n]</span> .</p>

    <p class="text-gray-300"><strong>Eval:</strong> To evaluate  <span class="math">F_{NR(n)}(k, x)</span>  on input [x] with key [k]:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Bit decompose [x] into  <span class="math">[x_1] \\dots [x_n]</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">[s] = [k_0] \\cdot \\prod_{i=1}^n ([k_i][x_i] + (1-[x_i])</span>  (see text for details).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Call  <span class="math">\\mathcal{F}_{\\mathsf{ABB-Exp}}</span>  on input [s].</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Figure 6: Computing  <span class="math">F_{NR(n)}(\\mathbf{k}, \\mathbf{x})</span></p>

    <p class="text-gray-300">Given the protocol for public exponentiation, it is straightforward to evaluate the Naor-Reingold PRF with public output when given a bit-decomposed, secret-shared input  <span class="math">[x_1], \\ldots, [x_n]</span>  and key  <span class="math">[k_0], \\ldots, [k_n]</span> . First compute</p>

    <p class="text-gray-300"><span class="math">$[s] = [k_0] \\cdot \\prod_{i=1}^{n} ([x_i] \\cdot [k_i] + (1 - [x_i]))</span>$</p>

    <p class="text-gray-300">using  <span class="math">\\mathcal{F}_{ABB}</span> , and then use  <span class="math">\\Pi_{Exp}</span>  to obtain  <span class="math">g^s</span> .</p>

    <p class="text-gray-300">The product can be computed in  <span class="math">\\lceil \\log_2 n + 1 \\rceil</span>  rounds using a standard binary tree evaluation. Alternatively, we can obtain a constant (4) rounds protocol using the prefix multiplication protocol of Catrina and de Hoogh [15], (which is an optimized variant of the trick of Bar-Ilan and Beaver [5]) at the expense of 2(n+1) additional multiplications.</p>

    <p class="text-gray-300">Security of the  <span class="math">\\Pi_{NR}</span>  protocol is straightforward, since there is no interaction outside of the arithmetic black box functionality.</p>

    <h4 id="sec-misc-8" class="text-lg font-semibold mt-6">Handling Input in <span class="math">\\mathbb{F}_p</span> .</h4>

    <p class="text-gray-300">If the input is given as a field element rather than in bit-decomposed form, then we must first run a bit decomposition protocol, such as that of Catrina and de Hoogh [15] or Damg&aring;rd et al. [21]. The latter works for arbitrary values of x, whilst the former is more efficient, but requires x is  <span class="math">\\ell</span>  bits long, where  <span class="math">p &gt; 2^{\\ell+\\kappa}</span>  for statistical security  <span class="math">\\kappa</span> .</p>

    <p class="text-gray-300">For the logarithmic rounds variant based on SPDZ, with n-bit input that is already bit decomposed, the protocol requires 2n multiplications of secret values and three exponentations, in a total of  <span class="math">\\lceil \\log_2 n + 1 \\rceil + 3</span>  rounds. The constant rounds variant takes 4n+2 multiplications in 7 rounds. Note that there is a higher cost for the secure multiplications, as we require an MPC protocol operating over  <span class="math">\\mathbb{F}_p</span>  for a 256-bit prime p (for 128-bit security), whereas our other PRF protocols only require MPC operations in 128-bit fields.</p>

      <h3 id="sec-3.4" class="text-xl font-semibold mt-8">3.4 Performance</h3>

    <p class="text-gray-300">The main advantage of this PRF is the small number of rounds required, which leads to a low latency in our benchmarks (4.4ms over LAN). However, the high computation cost (for EC operations) slows down performance and results in a low throughput. We found that with a 256-bit prime p and n=128, the logarithmic rounds variant outperformed the constant rounds protocol in all measures in a LAN environment. In a WAN setting, the constant round protocol achieves a lower latency, but is worse for throughput and preprocessing time.</p>

    <p class="text-gray-300">In this section we consider a PRF based on the Legendre symbol, which to the best of our knowledge was first described in [44]. Whilst this PRF is very inefficient when applied to cleartext data, we show that with secret-shared data in the MPC setting it allows for a very simple protocol.</p>

    <p class="text-gray-300">In 1988, Damg&aring;rd proposed using the sequence of Legendre symbols with respect to a large prime p as a pseudorandom generator [20]. He conjectured that the sequence</p>

    <p class="text-gray-300"><span class="math">$\\left(\\frac{k}{p}\\right), \\left(\\frac{k+1}{p}\\right), \\left(\\frac{k+2}{p}\\right), \\dots</span>$</p>

    <p class="text-gray-300">is pseudorandom, when starting at a random seed k. Although there have been several works studying the <em>statistical</em> uniformity of this sequence, perhaps surprisingly, there has been very little research on cryptographic applications since Damg&aring;rd's paper. Damg&aring;rd also considered variants with the Jacobi symbol, or where p is secret, but these seem less suitable for our application to MPC.</p>

    <p class="text-gray-300">We first normalize the Legendre symbol to be in  <span class="math">\\{0, 1, (p+1)/2\\}</span> , by defining:</p>

    <p class="text-gray-300"><span class="math">$L_p(a) = \\frac{1}{2} \\left( \\left( \\frac{a}{p} \\right) + 1 \\right) \\pmod{p}.</span>$</p>

    <p class="text-gray-300">We now define the corresponding pseudorandom function (as in [44]) as</p>

    <p class="text-gray-300"><span class="math">$F_{\\mathsf{Leg(bit)}}(k, x) = L_p(k + x)</span>$</p>

    <p class="text-gray-300">for  <span class="math">k, x \\in \\mathbb{F}_p</span> , where  <span class="math">p \\approx 2^{\\lambda}</span>  is a public prime. The security of this PRF is based on the following two problems:</p>

    <p class="text-gray-300"><strong>Definition 1</strong> (Shifted Legendre Symbol Problem). Let k be uniformly sampled from  <span class="math">\\mathbb{F}_p</span> , and define  <span class="math">\\mathcal{O}_{\\mathsf{Leg}}</span>  to be an oracle that takes  <span class="math">x \\in \\mathbb{F}_p</span>  and outputs  <span class="math">\\binom{k+x}{p}</span> . Then the Shifted Legendre Symbol (SLS) problem is to find k, with non-negligible probability.</p>

    <p class="text-gray-300">Definition 2 (Decisional Shifted Legendre Symbol Problem). Let OLeg be defined as above, and let O<sup>R</sup> be a random oracle that takes values in F<sup>p</sup> and produces outputs in {&minus;1, 1}. The Decisional Shifted Legendre Symbol (DSLS) problem is to distinguish between OLeg and O<sup>R</sup> with nonnegligible advantage.</p>

    <p class="text-gray-300">The following proposition is then immediate.</p>

    <p class="text-gray-300">Proposition 1. The function FLeg(bit) is a pseudorandom function if there is no probabilistic polynomial time algorithm for the DSLS problem.</p>

    <p class="text-gray-300">The SLS problem has received some attention from the mathematical community, particularly in the quantum setting. We briefly survey some known results below.</p>

    <p class="text-gray-300">A naive algorithm for deterministically solving the SLS problem is to compute k+x p for all (k, x) &isin; F 2 <sup>p</sup> and compare these with OLeg(x) for all x &isin; Fp, which requires O&tilde;(p 2 ) binary operations. Russell and Shparlinski <a href="#page-13-8">[42]</a> described a more sophisticated algorithm using Weil's bound on exponential sums, which reduces this to O&tilde;(p).</p>

    <p class="text-gray-300">Van Dam, Hallgren and Ip <a href="#page-13-7">[44]</a> described a quantum polynomial time algorithm for the SLS problem that recovers the secret k if the oracle can be queried on a quantum state. They conjectured that classically, there is no polynomial time algorithm for this problem. Russell and Shparlinski <a href="#page-13-8">[42]</a> also extended this quantum algorithm to a generalization of the problem where the secret is a polynomial, rather than just a linear shift.</p>

    <p class="text-gray-300">One can also consider another generalization called the hidden shifted power problem, where the oracle returns (k + x) e for some (public) exponent e|(p &minus; 1). The SLS problem is a special case where e = (p&minus;1)/2. Vercauteren <a href="#page-13-9">[45]</a> called this the hidden root problem and described efficient attacks over small characteristic extension fields, with applications to fault attacks on pairings-based cryptography. Bourgain et al. <a href="#page-12-21">[12]</a> showed that if e = p 1&minus;&delta; for some &delta; &gt; 0 then this problem has classical query complexity O(1). Note that neither of these attacks apply to the SLS problem, which cannot be solved with fewer than &Omega;(log p) queries <a href="#page-13-10">[43]</a>.</p>

    <p class="text-gray-300">In conclusion, we are not currently aware of any classical algorithms for the SLS problem in better than O&tilde;(p) time, nor of any method for solving the DSLS problem without first recovering the secret. We note that unlike discrete log and factoring, it is still an open question as to whether there are even efficient quantum algorithms if the SLS oracle can only be queried classically.</p>

    <p class="text-gray-300">It turns out that FLeg(bit) can be evaluated in MPC very efficiently, at roughly the cost of just 2 multiplications in 3 rounds of communication. Although this only produces a single bit of output, composing together multiple instances in parallel with independent keys allows larger outputs to be obtained (see later).</p>

    <p class="text-gray-300">We first describe how to evaluate FLeg(bit) when the output is public, and then show how to extend this to secret-shared output, with only a small cost increase.</p>

    <p class="text-gray-300">Suppose we have a shared, non-zero [a] and want to compute the public output, Lp(a). Since the output is public, we can simply take a random preprocessed non-zero square [s 2 ], compute [c] = [s 2 ] &middot; [a] and open c. By the multiplicativity of the Legendre symbol, Lp(c) = Lp(a).</p>

    <p class="text-gray-300">By composing the PRF n times in parallel, this gives an n-bit output PRF that we can evaluate in MPC with just n multiplications and n openings in two rounds. The preprocessing requires n random squares and multiplication triples.</p>

    <p class="text-gray-300">Now suppose we instead want shared output, [Lp(a)]. If we have a random non-zero value [t], and also the shared value [Lp(t)], then this is easy. Just open [a]&middot;[t], and compute the Legendre symbol of this to get c = Lp(a&middot;t). The shared value [Lp(a)] can then be computed locally using c and [Lp(t)], as c is public.</p>

    <p class="text-gray-300">Generating a random value with a share of its Legendre symbol can be done very cheaply. Our key observation is that we can do this without having to compute any Legendre symbols in MPC. Let &alpha; &isin; Z<sup>p</sup> be a (public) quadratic nonresidue, and perform the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Take a random square [s 2 ] and a random bit [b].</li>
      <li>Output (2[b] &minus; 1, [b] &middot; [s 2 ] + (1 &minus; [b]) &middot; &alpha; &middot; [s 2 ])</li>
    </ul>

    <p class="text-gray-300">Note that since &alpha; is a non-square, the second output value is clearly either a square or non-square based on the value of the random bit b (which is mapped into {&minus;1, 1} by computing 2 &middot; b &minus; 1). Finally, note that since s <sup>2</sup> provides fresh randomness each time, &alpha; can be reused for every PRF evaluation. This gives us the protocol in Figure <a href="#page-7-0">7,</a> which realizes the functionality FABB-Leg shown in Figure <a href="#page-8-0">8.</a> Notice that all bar the computation of u can be performed in a preprocessing phase if needed.</p>

    <h4 id="sec-misc-9" class="text-lg font-semibold mt-6">Protocol &Pi;Legendre</h4>

    <p class="text-gray-300">Let &alpha; be a fixed, quadratic non-residue modulo p.</p>

    <p class="text-gray-300">KeyGen: Call FABB.Random to generate a random key [k].</p>

    <p class="text-gray-300">Eval: To evaluate FLeg(bit) on input [x] with key [k]:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Take a random square [s 2 ] and a random bit [b]</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>[t] &larr; [s 2 ] &middot; ([b] + &alpha; &middot; (1 &minus; [b]))</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>u &larr; Open([t] &middot; ([k] + [x]))</li>
    </ol></li>
      <li>4. Output [y] &larr; ( u p &middot; (2[b] &minus; 1) + 1)/2</li>
    </ul>

    <p class="text-gray-300">Figure 7: Securely computing the FLeg(bit) PRF with secret-shared output</p>

    <h4 id="sec-misc-10" class="text-lg font-semibold mt-6"><em>Security.</em></h4>

    <p class="text-gray-300">At first glance, the security of the protocol appears straightforward: since t and k are uniformly random, the opened value u should be simulatable by a random value, and this will be correct except with probability 1/p (if s <sup>2</sup> = 0). However, proving this turns out to be more tricky. We need to take into account that if x = &minus;k then the protocol causes u = 0 to be opened, but in the ideal world the simulator does not know k so cannot simulate this. This reflects the fact that an adversary who solves the SLS problem can find k and run the protocol with x=-k. Therefore, we need to assume hardness of the SLS problem and show that any environment that distinguishes the two worlds (by causing x=-k to be queried) can be used to recover the key k. The reduction must use the SLS oracle,  <span class="math">\\mathcal{O}_{\\text{Leg}}</span> , to detect whether x=-k, in order to simulate the u value to the environment. To do this, they simply obtain the value  <span class="math">y=\\left(\\frac{x+k}{p}\\right)</span>  from  <span class="math">\\mathcal{O}_{\\text{Leg}}</span>  and check whether y=0, for each <strong>Eval</strong> query made by the adversary.</p>

    <h4 id="sec-misc-11" class="text-lg font-semibold mt-6">Functionality <span class="math">\\mathcal{F}_{ABB-Leg}</span></h4>

    <p class="text-gray-300">This functionality has all of the same commands as  <span class="math">\\mathcal{F}_{\\mathsf{ABB}},</span>  plus the following:</p>

    <p class="text-gray-300"><strong>KeyGen:</strong> On receiving (keygen) from all parties, sample  <span class="math">k \\stackrel{R}{\\leftarrow} \\mathbb{F}_p</span>  and store k.</p>

    <p class="text-gray-300"><strong>PRF:</strong> On receiving (legendre, [x]) from all parties, where x is stored in memory, compute  <span class="math">y = L_p(x+k)</span>  and store y in memory.</p>

    <p class="text-gray-300">Figure 8: Ideal functionality for the Legendre symbol PRF,  <span class="math">F_{\\mathsf{Leg(bit)}}</span></p>

    <p class="text-gray-300"><strong>Theorem 2.</strong> The protocol  <span class="math">\\Pi_{Legendre}</span>  securely computes the functionality  <span class="math">\\mathcal{F}_{ABB-Leg}</span>  in the  <span class="math">\\mathcal{F}_{ABB}</span> -hybrid model, if the SLS problem is hard.</p>

    <p class="text-gray-300"><em>Proof.</em> We construct a simulator  <span class="math">\\mathcal{S}</span>  such that no environment  <span class="math">\\mathcal{Z}</span>  corrupting up to n-1 parties can distinguish between the real protocol  <span class="math">\\Pi_{\\mathsf{Legendre}}</span> , and  <span class="math">\\mathcal{S}</span>  interacting with the ideal functionality  <span class="math">\\mathcal{F}_{\\mathsf{ABB-Leg}}</span> .</p>

    <p class="text-gray-300">In the <strong>KeyGen</strong> stage, S simply calls  <span class="math">\\mathcal{F}_{\\mathsf{ABB-Leg}}</span>  with the <strong>keygen</strong> command. In the <strong>Eval</strong> stage, the main task of S is to simulate the opened value u, which is done by sampling  <span class="math">u \\stackrel{R}{\\leftarrow} \\mathbb{F}_p</span> , and then call  <span class="math">\\mathcal{F}_{\\mathsf{ABB-Leg}}</span>  with (legendre, [x]).</p>

    <p class="text-gray-300">We now argue indistinguishability of the two executions. In the real world, since t is computed as  <span class="math">s^2 \\cdot (b + (1 - b) \\cdot \\alpha)</span>  for a uniform quadratic residue  <span class="math">s^2</span>  and random bit b, then t is uniform in  <span class="math">\\mathbb{F}_p</span> . This is because the map defined by multiplication by  <span class="math">\\alpha</span>  is a bijection between the sets of squares and non-squares modulo p. Therefore, if  <span class="math">s^2</span>  is a uniformly random square, then  <span class="math">\\alpha \\cdot s^2</span>  is a uniformly random non-square.</p>

    <p class="text-gray-300">Now, since t is a fresh uniformly random value on each evaluation, the real world value u and output y, as seen by  <span class="math">\\mathcal{Z}</span> , will be identically distributed to the simulated values as long as  <span class="math">k+x\\neq 0</span>  and  <span class="math">s\\neq 0</span> . Whenever the former happens in the real world u=0 is opened, whereas the ideal world still simulates a random value, so the environment can distinguish. In the latter case, s=0, the output y will be incorrectly computed in the real world, but this can only happen with probability 1/p.</p>

    <p class="text-gray-300">However, any environment  <span class="math">\\mathcal{Z}</span>  that causes k+x=0 to happen with non-negligible probability can be used to construct an algorithm  <span class="math">\\mathcal{A}^*</span>  that breaks the SLS problem, as follows.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{A}^*</span>  runs  <span class="math">\\mathcal{Z}</span> , emulating a valid execution of  <span class="math">\\Pi_{\\mathsf{Legendre}}</span>  by replacing  <span class="math">L_p(x+k)</span>  computation with calls to  <span class="math">\\mathcal{O}_{\\mathsf{Leg}_k}</span> . These modified transcripts have the same distribution since the SLS oracle and (keygen) both generate a random key. When  <span class="math">\\mathcal{A}^*</span>  runs  <span class="math">\\mathcal{Z}</span>  internally, it knows the inputs provided by  <span class="math">\\mathcal{Z}</span>  to all parties, so knows the x value on each invocation of  <span class="math">\\Pi_{\\mathsf{Legendre}}</span> . Once  <span class="math">\\mathcal{Z}</span>  constructs a query for which  <span class="math">\\mathcal{O}_{\\mathsf{Leg}_k}</span>  returns</p>

    <p class="text-gray-300">0 then  <span class="math">\\mathcal{A}^*</span>  responds to the SLS challenge with k=-x. Finally, the algorithm looks like this:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Interact with  <span class="math">\\mathcal Z</span>  as the simulator  <span class="math">\\mathcal S</span>  would do.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Instead of computing the Legendre symbol  <span class="math">L_p(x+k)</span>  as in  <span class="math">\\mathcal{F}_{\\mathsf{ABB-Leg}}</span> , make a call to  <span class="math">\\mathcal{O}_{\\mathsf{Leg}_k}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">\\mathcal{O}_{\\text{Leg}_k}(x) = 0</span> , return -x as the SLS secret.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">The only way  <span class="math">\\mathcal Z</span>  can distinguish between  <span class="math">\\mathcal S</span>  and  <span class="math">\\Pi_{\\mathsf{Legendre}}</span> &mdash; except with probability 1/p&mdash; is by producing a query x for which  <span class="math">\\mathcal O_{\\mathsf{Leg}_k}(x)=0</span> , since the two worlds are statistically close up until this point. If  <span class="math">\\mathcal Z</span>  can do this with probability  <span class="math">\\epsilon</span>  then the probability that  <span class="math">\\mathcal A^*</span>  solves the SLS problem is the same.</p>

    <p class="text-gray-300">Overall,  <span class="math">\\mathcal{S}</span>  correctly simulates the protocol  <span class="math">\\Pi_{\\mathsf{Legendre}}</span>  as long as  <span class="math">u \\neq 0</span> , which happens with probability  <span class="math">\\leq 1/p + \\epsilon</span>  (s = 0 or solving SLS with probability  <span class="math">\\epsilon</span> ).</p>

    <p class="text-gray-300">The basic protocol above is only statistically correct, as  <span class="math">s^2=0</span>  with probability 1/p, and if this occurs the output will always be zero. Although this suffices for most applications, we note that perfect correctness can be obtained, at the expense of a protocol that runs in <em>expected</em> constant rounds. We can guarantee that the square  <span class="math">s^2</span>  is non-zero by computing it as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Take a random square  <span class="math">[s^2]</span>  and a random value [y].</li>
      <li>Compute  <span class="math">[v] = [y \\cdot s^2]</span>  and open v. If v = 0 then return to the first step.</li>
    </ul>

    <p class="text-gray-300">Note, that the iteration of the first step only happens if y=0 or s=0, which occurs with probability 2/p, so the expected number of rounds for this stage of the protocol is one.</p>

    <p class="text-gray-300">Some applications may require a PRF which takes multiple finite field elements as input, and outputs a finite field element. We now present how to extend the basic PRF  <span class="math">F_{\\text{Leg(bit)}}</span>  to a function which takes messages consisting of n finite field elements and outputs a single uniformly random finite field element. Indeed our input could consist of up to t elements in the finite field where  <span class="math">t \\leq n</span> . In practice we will take n = 1 or 2, and can then extend to larger lengths using CBC-mode or Merkle-Damg&aring;rd (as in Section 1.5).</p>

    <p class="text-gray-300">We first define a statistical security parameter  <span class="math">2^{-\\text{stat}}</span> , which bounds the statistical distance from uniform of the output of our PRF. We let define p' to be the nearest power of two to the prime p and set  <span class="math">\\alpha = |p-p&#x27;|</span> . Then if  <span class="math">\\alpha/p &lt; 2^{-\\text{stat}}</span>  we set  <span class="math">\\ell = \\lceil \\log_2 p \\rceil</span> , otherwise we set  <span class="math">\\ell = \\lceil \\log_2 p \\rceil + \\text{stat}</span> . A standard argument will then imply that the following PRF outputs values with the correct distribution.</p>

    <p class="text-gray-300">The key for the PRF is going to be an  <span class="math">\\ell \\times (n+1)</span>  matrix K of random elements in  <span class="math">\\mathbb{F}_p</span> , except (for convenience) that we fix the first column to be equal to one. To apply the PRF to a vector of elements  <span class="math">\\mathbf{x} = (x_1, \\dots, x_t)</span>  we &quot;pad&quot;  <span class="math">\\mathbf{x}</span>  to a vector of n+1 elements as follows  <span class="math">\\mathbf{x}&#x27; = (x_1, \\dots, x_t, 0, \\dots, 0, t)</span>  and then product the matrix-vector product  <span class="math">\\mathbf{y} = K \\cdot \\mathbf{x}&#x27; \\in (\\mathbb{F}_p)^{\\ell}</span> . The output of  <span class="math">F_{\\text{Leg}(n)}</span>  is then given by</p>

    <p class="text-gray-300"><span class="math">$F_{\\mathsf{Leg}(n)}(K, \\mathbf{x}) = \\left(\\sum_{i=0}^{\\ell-1} 2^i \\cdot L_p(y_i)\\right) \\pmod{p}.</span>$</p>

    <p class="text-gray-300">This extended PRF requires one extra round of  <span class="math">\\ell \\cdot (n-1)</span>  secure multiplications compared to  <span class="math">F_{\\mathsf{Leg(bit)}}</span> .</p>

    <p class="text-gray-300">Since the matrix K is compressing, the distribution of  <span class="math">\\mathbf{y}</span>  will act, by the leftover hash lemma, as a random vector in  <span class="math">\\mathbb{F}_p^\\ell</span> . With probability  <span class="math">\\ell/p</span>  we have  <span class="math">y_i \\neq 0</span>  for all i, which implies that the values of  <span class="math">L_p(y_i)</span>  behave as uniform random bits, assuming our previous conjectures on the Legendre symbol. Thus the output value of  <span class="math">F_{\\text{Leg}(n)}(K, \\mathbf{x})</span>  will, by choice of  <span class="math">\\ell</span> , have statistical distance from uniform in  <span class="math">\\mathbb{F}_p</span>  bounded by  <span class="math">2^{-\\text{stat}}</span> .</p>

    <p class="text-gray-300">Our choice of padding method, and the choice of the first matrix column to be equal to one, is to ensure that in the case of n = 1 we have</p>

    <p class="text-gray-300"><span class="math">$F_{\\mathsf{Leg}(n)}(K, \\mathbf{x}) = \\left(\\sum_{i=0}^{\\ell-1} 2^i \\cdot F_{\\mathsf{Leg}(\\mathsf{bit})}(k_i, y_i)\\right) \\pmod{p}.</span>$</p>

    <p class="text-gray-300">In addition the padding method ensures protection against length extension attacks.</p>

    <p class="text-gray-300">We measured performance using the prime  <span class="math">p=2^{127}+45</span> , which implied for  <span class="math">F_{\\mathsf{Leg}(n)}</span>  we could take  <span class="math">\\ell=128</span> . Both  <span class="math">F_{\\mathsf{Leg}(\\mathsf{bit})}</span>  and  <span class="math">F_{\\mathsf{Leg}(1)}</span>  obtain very low latencies (0.35ms and 1.2ms over LAN, respectively) due to the low number of rounds. For a PRF with small outputs,  <span class="math">F_{\\mathsf{Leg}(\\mathsf{bit})}</span>  achieves by far the highest throughput, with over 200000 operations per second. For full field element outputs,  <span class="math">F_{\\mathsf{Leg}(1)}</span>  is around 128 times slower, but still outperforms AES in all metrics except for cleartext computation.</p>

    <h4 id="sec-misc-12" class="text-lg font-semibold mt-6">5. MIMC</h4>

    <p class="text-gray-300">MiMC is a comparatively simple block cipher design, where the plaintexts, the ciphertexts and the secret key are elements of  <span class="math">\\mathbb{F}_p</span>  and can be seen as a simplification of the KN-cipher[40]. Its design is aimed at achieving an efficient implementation over a field  <span class="math">\\mathbb{F}_p</span>  by minimizing computationally expensive field operations (e.g. multiplications or exponentiations).</p>

    <p class="text-gray-300">Let p a prime that satisfies the condition  <span class="math">\\gcd(3,p-1)=1</span> . For a message  <span class="math">x \\in \\mathbb{F}_p</span>  and a secret key  <span class="math">k \\in \\mathbb{F}_p</span> , the encryption process of MiMC is constructed by iterating a round function r times. At round i (where  <span class="math">0 \\le i &lt; r</span> ), the round function  <span class="math">F_i : \\mathbb{F}_p \\to \\mathbb{F}_p</span>  is defined as:</p>

    <p class="text-gray-300"><span class="math">$F_i(x) = (x + k + c_i)^3,</span>$</p>

    <p class="text-gray-300">where  <span class="math">c_i</span>  are random constants in  <span class="math">\\mathbb{F}_p</span>  (for simplicity  <span class="math">c_0 = c_r = 0</span> ). The output of the final round is added with the key k to produce the ciphertext. Hence, the output of  <span class="math">F_{\\mathsf{MiMC}}(x,k)</span>  is then given by</p>

    <p class="text-gray-300"><span class="math">$F_{MiMC}(x,k) = (F_{r-1} \\circ F_{r-2} \\circ \\dots \\circ F_0)(x) + k.</span>$</p>

    <p class="text-gray-300">The condition on p ensures that the cubing function creates a permutation.</p>

    <p class="text-gray-300">The number of rounds for constructing the keyed permutation is given by  <span class="math">r = \\lceil \\log_3 p \\rceil</span>  - for prime fields of size 128 bits the number of rounds is equal to r = 82. This number of round r provides security against a variety of cryptanalytic techniques. In particular, due to the algebraic design principle of MiMC, the most powerful key recovery methods are the algebraic cryptanalytic attacks, as the Interpo-</p>

    <p class="text-gray-300">lation Attack and the GCD Attack. In the first one introduced by Jakobsen and Knudsen in [30], the attacker constructs a polynomial corresponding to the encryption function without any knowledge of the secret key. In particular, the attacker guesses the key of the final round, constructs the polynomial at round r-1 and checks it with one extra plaintext/ciphertext pair. In the second one, given two plaintext/ciphertext pairs  <span class="math">(p^j,c^j)</span>  for j=1,2, the attacker constructs the polynomials  <span class="math">F_{\\mathsf{MiMC}}(p^1,K)-c^1</span>  and  <span class="math">F_{\\mathsf{MiMC}}(p^2,K)-c^2</span>  in the fixed but unknown key K. Since these two polynomials share (K-k) as a factor (where k is the secret key), the attacker can find the value of k by computing the GCD of them.</p>

    <p class="text-gray-300">If the attacker has access to a limited number of plaintext/ciphertext pairs only (at most n &lt; p), then the number of round r can be reduced. In this case, the number of rounds is given by  <span class="math">r = \\max\\{\\lceil \\log_3 n \\rceil, \\lceil \\log_3 p - 2 \\log_3(\\log_3 p) \\rceil\\}</span>  - for prime field of size 128 bits, the number of rounds is equal to r = 73 if  <span class="math">n \\le 2^{115}</span> , while  <span class="math">r = \\lceil \\log_3 n \\rceil</span>  otherwise.</p>

    <p class="text-gray-300">We consider two different approaches for computing  <span class="math">F_{\\mathsf{MiMC}}</span>  in MPC, with a secret shared key and message. The basic approach is simplest, whilst the second variant has half the number of rounds of communication, with slightly more computation.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{MiMC}^{\\mathsf{basic}}</span> : The naive way to evaluate  <span class="math">F_{\\mathsf{MiMC}}</span>  requires one squaring and one multiplication for each of the r rounds. Using SPDZ, the squaring costs one opening in one round of communication, and the multiplication costs two openings in one round, giving a total of 3r openings in 2r rounds of communication.</p>

    <p class="text-gray-300">MiMC<sup>cube</sup>: If for each round we first compute a tuple ([r],  <span class="math">[r^2]</span> ,  <span class="math">[r^3]</span> ), where  <span class="math">r \\stackrel{R}{\\leftarrow} \\mathbb{F}_p</span> , then given a secret-shared value [x], we can open y=x-r and obtain a sharing of  <span class="math">x^3</span>  by the computation</p>

    <p class="text-gray-300"><span class="math">$[x^3] = 3y[r^2] + 3y^2[r] + y^3 + [r^3]</span>$</p>

    <p class="text-gray-300">which is linear in the secret-shared values so does not require interaction.</p>

    <p class="text-gray-300">For a single MiMC encryption, we first compute all of the cube triples for each round, which takes just one round of communication by taking a preprocessed random square pair  <span class="math">([r], [r^2])</span>  and performing one multiplication to obtain  <span class="math">[r^3]</span> . Each round of the cipher then requires just one opening and a small amount of interaction. The total communication complexity is still 3r openings, but in only r rounds.</p>

      <h3 id="sec-5.3" class="text-xl font-semibold mt-8">5.3 Performance</h3>

    <p class="text-gray-300">Using r=73, we measured a latency of 12ms per evaluation for the simple protocol  <span class="math">\\mathsf{MiMC}^{\\mathsf{basic}}</span> , which halves to 6ms for the lower round variant,  <span class="math">\\mathsf{MiMC}^{\\mathsf{cube}}</span> .  <span class="math">\\mathsf{MiMC}^{\\mathsf{basic}}</span>  gives a very high throughput of over 8500 blocks per second (around 20% higher than  <span class="math">\\mathsf{MiMC}^{\\mathsf{cube}}</span> ), and the offline cost is fairly low, at 34 blocks per second. In fact, apart from in latency,  <span class="math">\\mathsf{MiMC}</span>  outperforms all the other PRFs we studied.</p>

    <h4 id="sec-misc-13" class="text-lg font-semibold mt-6">6. PERFORMANCE EVALUATION</h4>

    <p class="text-gray-300">In this section, we evaluate the performance of the PRFs using the SPDZ multi-party computation protocol [26, 25],</p>

    <p class="text-gray-300">which provides active security against any number of corrupted parties. We focus here on the two-party setting, although the protocol easily scales to any number of parties with roughly a linear cost.</p>

    <p class="text-gray-300">The two main metrics we use to evaluate performance are latency and throughput, both of which relate to the online phase of the SPDZ protocol. Latency measures the waiting time for a single PRF evaluation; the best possible latency is recorded by simply timing a large number of sequential executions of the PRF, and taking the average for one operation. In contrast, throughput is maximized by running many operations in parallel to reduce the number of rounds of communication. Of course, this comes at the expense of a higher latency, so a tradeoff must always be made depending on the precise application. In addition to latency and throughput, we present the cost of running the preprocessing phase and computing the PRF on cleartext data, for comparison.</p>

    <p class="text-gray-300">Implementation Details: We implemented the protocols using the architecture of Keller et al. <a href="#page-12-23">[32]</a>, which runs the online phase of SPDZ. This system automatically uses the minimum number of rounds of communication for a given program description, by merging together all independent openings. We extended the software to use the Miracl library for elliptic curve operations over the NIST P-256 curve, as required for the Naor-Reingold protocol. Note that although the SPDZ implementation supports multi-threading, all of our online phase experiments are single-threaded to simplify the comparison.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Data type</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Fp<br>(ms)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">F2128<br>(ms)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128-bit</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256-bit</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">LAN</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Triple/Sq.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.204</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.816</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.204</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Bit</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.204</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.816</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.00014</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">WAN</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Triple/Sq.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.150</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16.560</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.150</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Bit</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.150</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16.560</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.00285</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 2: Time estimates for generating preprocessing data in various fields using oblivious transfer.</p>

    <p class="text-gray-300">To estimate the cost of producing the preprocessing data (multiplication triples, random bits etc.), we used figures from the recent MASCOT protocol <a href="#page-12-18">[31]</a>, which uses OT extensions to obtain what are currently the best reported triple generation times with active security. Although in <a href="#page-12-18">[31]</a>, figures are only given for triple generation in a 128-bit field, we can also use these times for random square and random bit generation, since each of these can be easily obtained from one secret multiplication <a href="#page-12-5">[21]</a>. For the Naor-Reingold PRF, we multiplied these times by a factor of 4 to obtain estimates for a 256-bit field (instead of 128), reflecting the quadratic communication cost of the protocol. <a href="#page-10-0">4</a> The costs for all of these preprocessing data types are summarized in Table <a href="#page-10-1">2.</a></p>

    <p class="text-gray-300">Note that LowMC only requires multiplication triples in F2, for which the protocol of <a href="#page-12-24">[29]</a> could be much faster than using F2<sup>128</sup> triples. However, we are not currently aware of an implementation of this protocol, so use the F2<sup>128</sup> times for now.</p>

    <p class="text-gray-300">Benchmarking Environment: In any application of MPC, one of the most important factors affecting performance is the capability of the network. We ran benchmarks in a standard 1Gbps LAN setting, and also a simulated WAN setting, which restricts bandwidth to 50Mbps and latency to 100ms, using the Linux tc tool. This models a real-world environment where the parties may be in different countries or continents. In both cases, the test machines used have Intel i7-3770 CPUs running at 3.1GHz, with 32GB of RAM.</p>

    <p class="text-gray-300">Results: The results of our experiments in the LAN and WAN environments are shown in Tables <a href="#page-11-8">3</a> and <a href="#page-11-9">4,</a> respectively. All figures are the result of taking an average of 5 experiments, each of which ran at least 1000 PRF operations. We present timings for AES and LowMC purely as a comparison metric; as explained in the introduction, these are not suitable for many MPC applications as they do not operate over a large characteristic finite field.</p>

    <p class="text-gray-300">LowMC obtains slightly better throughput and latency than AES over a LAN, with both the vector and M4R methods achieving similar performance here. In the WAN setting, LowMC gets a very high throughput of over 300 blocks per second. This is due to the low online communication cost for multiplications in F<sup>2</sup> instead of F2<sup>n</sup> or Fp, and the fact that local computation is less significant in a WAN. The M4R method gets half the latency of the vector method in this scenario, since the number of rounds is halved. As discussed earlier, the preprocessing for LowMC would likely be much better than AES if implemented with the protocol of <a href="#page-12-24">[29]</a>.</p>

    <p class="text-gray-300">In both scenarios, the Legendre PRF gives the lowest latency, even when outputing 128-bit field elements rather than bits, due to its low round complexity. The single-bit output variant achieves by far the highest throughput of all the PRFs, so would be ideally suited to an application based on a short-output PRF, such as secure computation of the (leaky) order-revealing encryption scheme in <a href="#page-12-11">[18]</a>. The Legendre PRF with large outputs is useful in scenarios where low latency is very important, although the preprocessing costs are expensive compared to MiMC below. However, the high cost of the Legendre PRF &quot;in the clear&quot; may not make it suitable for applications in which one entity is encrypting data to/from the MPC engine</p>

    <p class="text-gray-300">The Naor-Reingold PRF also achieves a low latency though not as good as the Legendre PRF &mdash; but it suffers greatly when it comes to throughput. Notice that in the LAN setting, the constant rounds protocol actually performs worse than the logarithmic rounds variant in all measures, showing that here the amount of computatation and communication is more of a limiting factor than the number of rounds. Profiling suggested that over 70% of the time was spent performing EC scalar multiplications, so it seems that computation rather than communication is the bottleneck in these timings. The requirement for a 256-bit field (for 128-bit security) will be a limiting factor in many applications, as will the need to bit decompose the input, if it was previously a single field element.</p>

    <p class="text-gray-300">The MiMC cipher seems to provide a good compromise amongst all the prime field candidates, especially as it also performs well when performed &quot;in the clear&quot;. The &quot;cube&quot;</p>

    <p class="text-gray-300"><sup>4</sup>The experiments in <a href="#page-12-18">[31]</a> showed that communication is the main bottleneck of the protocol, so this should give an accurate estimate.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">PRF</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Best latency</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Best throughput</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Prep. (ops/s)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Cleartext (ops/s)</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(ms/op)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Batch size</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ops/s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">AES</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7.713</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2048</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">530</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.097</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">106268670</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FLowMC(vector)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.302</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">591</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.562</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7000</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FLowMC(M4R)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.148</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">475</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.565</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1420</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FNR(128)(log)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.375</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1024</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">370</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.787</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1359</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FNR(128)(const)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.549</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">281</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.384</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1359</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FLeg(bit)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.349</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2048</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">202969</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1225</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17824464</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FLeg(1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.218</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1535</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9.574</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">115591</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FMiMC(basic)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12.007</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2048</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8788</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">33.575</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">189525</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FMiMC(cube)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.889</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1024</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6388</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">33.575</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">189525</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 3: Performance of the PRFs in a LAN setting</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">PRF</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Best latency</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Best throughput</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Prep. (ops/s)</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(ms/op)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Batch size</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ops/s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">AES</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2640</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1024</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">31.947</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.256</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FLowMC(vector)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1315</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2048</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">365</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.1259</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FLowMC(M4R)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">659</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2048</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">334</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.1261</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FNR(128)(log)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">713</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1024</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">59.703</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.2359</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FNR(128)(const)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">478</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1024</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">30.384</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.1175</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FLeg(bit)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">202</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1024</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2053</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">60.241</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FLeg(1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">210</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">512</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">68.413</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.4706</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FMiMC(basic)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7379</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">512</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">59.04</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.650</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FMiMC(cube)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3691</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">512</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">79.66</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.650</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 4: Performance of the PRFs in a simulated WAN setting</p>

    <p class="text-gray-300">variant, which halves the number of rounds, effectively halves the latency compared to the naive protocol. This results in a slightly worse throughput in the LAN setting due to the higher computation costs, whereas in the WAN setting round complexity is more important. Although the latency is much higher than FLeg, due to the large number of rounds, MiMC achieves the best throughput for Fp-bit outputs, with over 6000 operations per second. In addition, the pre-processing costs of MiMC are better than that of both Legendre and the Naor-Reingold PRFs.</p>

    <p class="text-gray-300">So in conclusion there is no single PRF which meets all the criteria we outlined at the beginning. But one would likely prefer the Legendre PRF for applications which require low latency, and which do not involve any party external to the MPC engine, and MiMC for all other applications.</p>

    <p class="text-gray-300">The work in this paper has been partially supported by the ERC via Advanced Grant ERC-2010-AdG-267188-CRIPTO, the Defense Advanced Research Projects Agency (DARPA) and Space and Naval Warfare Systems Center, Pacific (SSC Pacific) under contract No. N66001-15-C-4070, and by the Austrian Science Fund via project P26494-N15.</p>

    <p class="text-gray-300">[1] M. Albrecht, G. Bard, and W. Hart. Algorithm 898: Efficient multiplication of dense matrices over GF(2). ACM Transactions on Mathematical Software (TOMS), 37(1):9, 2010.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">[2] M. Albrecht, L. Grassi, C. Rechberger, A. Roy, and T. Tiessen. MiMC: Efficient encryption and cryptographic hashing with minimal multiplicative complexity. Cryptology ePrint Archive, 2016. <a href="http://eprint.iacr.org/2016/492" target="_blank" rel="noopener noreferrer">http://eprint.iacr.org/2016/492.</a></p></li>
      <li><p class="text-gray-300">[3] M. Albrecht, C. Rechberger, T. Schneider, T. Tiessen, and M. Zohner. Ciphers for MPC and FHE. Cryptology ePrint Archive, Report 2016/687, 2016. <a href="http://eprint.iacr.org/2016/687" target="_blank" rel="noopener noreferrer">http://eprint.iacr.org/2016/687.</a></p></li>
      <li><p class="text-gray-300">[4] M. R. Albrecht, C. Rechberger, T. Schneider, T. Tiessen, and M. Zohner. Ciphers for MPC and FHE. In E. Oswald and M. Fischlin, editors, EUROCRYPT 2015, Part I, volume 9056 of LNCS, pages 430&ndash;454. Springer, Heidelberg, Apr. 2015.</p></li>
      <li><p class="text-gray-300">[5] J. Bar-Ilan and D. Beaver. Non-cryptographic fault-tolerant computing in constant number of rounds of interaction. In P. Rudnicki, editor, 8th ACM PODC, pages 201&ndash;209. ACM, Aug. 1989.</p></li>
      <li><p class="text-gray-300">[6] M. Bellare, A. Boldyreva, and A. O'Neill. Deterministic and efficiently searchable encryption. In A. Menezes, editor, CRYPTO 2007, volume 4622 of LNCS, pages 535&ndash;552. Springer, Heidelberg, Aug. 2007.</p></li>
      <li><p class="text-gray-300">[7] R. Bendlin, I. Damg&#730;ard, C. Orlandi, and S. Zakarias. Semi-homomorphic encryption and multiparty computation. In K. G. Paterson, editor, EUROCRYPT 2011, volume 6632 of LNCS, pages 169&ndash;188. Springer, Heidelberg, May 2011.</p></li>
      <li><p class="text-gray-300">[8] P. Bogetoft, D. L. Christensen, I. Damg&#730;ard,</p></li>
      <li><p class="text-gray-300">M. Geisler, T. Jakobsen, M. Kr&oslash;igaard, J. D. Nielsen, J. B. Nielsen, K. Nielsen, J. Pagter, M. I. Schwartzbach, and T. Toft. Secure multiparty computation goes live. In R. Dingledine and P. Golle, editors, FC 2009, volume 5628 of LNCS, pages 325&ndash;343. Springer, Heidelberg, Feb. 2009.</p></li>
      <li><p class="text-gray-300">[9] A. Boldyreva, N. Chenette, and A. O'Neill. Order-preserving encryption revisited: Improved security analysis and alternative solutions. In P. Rogaway, editor, CRYPTO 2011, volume 6841 of LNCS, pages 578&ndash;595. Springer, Heidelberg, Aug. 2011.</p></li>
      <li><p class="text-gray-300">[10] D. Boneh, K. Lewi, M. Raykova, A. Sahai, M. Zhandry, and J. Zimmerman. Semantically secure order-revealing encryption: Multi-input functional encryption without obfuscation. In E. Oswald and M. Fischlin, editors, EUROCRYPT 2015, Part II, volume 9057 of LNCS, pages 563&ndash;594. Springer, Heidelberg, Apr. 2015.</p></li>
      <li><p class="text-gray-300">[11] J. Borghoff, A. Canteaut, T. Guneysu, E. B. Kavun, &uml; M. Kne&#711;zevi&acute;c, L. R. Knudsen, G. Leander, V. Nikov, C. Paar, C. Rechberger, P. Rombouts, S. S. Thomsen, and T. Yal&cedil;cin. PRINCE - A low-latency block cipher for pervasive computing applications - extended abstract. In X. Wang and K. Sako, editors, ASIACRYPT 2012, volume 7658 of LNCS, pages 208&ndash;225. Springer, Heidelberg, Dec. 2012.</p></li>
      <li><p class="text-gray-300">[12] J. Bourgain, M. Z. Garaev, S. V. Konyagin, and I. E. Shparlinski. On the hidden shifted power problem. SIAM Journal on Computing, 41(6):1524&ndash;1557, 2012.</p></li>
      <li><p class="text-gray-300">[13] A. Canteaut, S. Carpov, C. Fontaine, T. Lepoint, M. Naya-Plasencia, P. Paillier, and R. Sirdey. Stream ciphers: A practical solution for efficient homomorphic-ciphertext compression. In Fast Software Encryption - 23nd International Workshop, FSE 2016, 2016.</p></li>
      <li><p class="text-gray-300">[14] D. Cash, S. Jarecki, C. S. Jutla, H. Krawczyk, M.-C. Rosu, and M. Steiner. Highly-scalable searchable symmetric encryption with support for Boolean queries. In R. Canetti and J. A. Garay, editors, CRYPTO 2013, Part I, volume 8042 of LNCS, pages 353&ndash;373. Springer, Heidelberg, Aug. 2013.</p></li>
      <li><p class="text-gray-300">[15] O. Catrina and S. de Hoogh. Improved primitives for secure multiparty integer computation. In J. A. Garay and R. D. Prisco, editors, SCN 10, volume 6280 of LNCS, pages 182&ndash;199. Springer, Heidelberg, Sept. 2010.</p></li>
      <li><p class="text-gray-300">[16] O. Catrina and S. de Hoogh. Secure multiparty linear programming using fixed-point arithmetic. In D. Gritzalis, B. Preneel, and M. Theoharidou, editors, ESORICS 2010, volume 6345 of LNCS, pages 134&ndash;150. Springer, Heidelberg, Sept. 2010.</p></li>
      <li><p class="text-gray-300">[17] O. Catrina and A. Saxena. Secure computation with fixed-point numbers. In R. Sion, editor, FC 2010, volume 6052 of LNCS, pages 35&ndash;50. Springer, Heidelberg, Jan. 2010.</p></li>
      <li><p class="text-gray-300">[18] N. Chenette, K. Lewi, S. A. Weis, and D. J. Wu. Practical order-revealing encryption with limited leakage. In Fast Software Encryption - 23nd International Workshop, FSE 2016, 2016.</p></li>
      <li><p class="text-gray-300">[19] J. Daemen, M. Peeters, G. Van Assche, and</p></li>
      <li><p class="text-gray-300">V. Rijmen. Nessie proposal: Noekeon. In First Open NESSIE Workshop, 2000.</p></li>
      <li><p class="text-gray-300">[20] I. Damg&#730;ard. On the randomness of legendre and jacobi sequences. In S. Goldwasser, editor, CRYPTO'88, volume 403 of LNCS, pages 163&ndash;172. Springer, Heidelberg, Aug. 1990.</p></li>
      <li><p class="text-gray-300">[21] I. Damg&#730;ard, M. Fitzi, E. Kiltz, J. B. Nielsen, and T. Toft. Unconditionally secure constant-rounds multi-party computation for equality, comparison, bits and exponentiation. In S. Halevi and T. Rabin, editors, TCC 2006, volume 3876 of LNCS, pages 285&ndash;304. Springer, Heidelberg, Mar. 2006.</p></li>
      <li><p class="text-gray-300">[22] I. Damg&#730;ard, M. Geisler, M. Kr&oslash;igaard, and J. B. Nielsen. Asynchronous multiparty computation: Theory and implementation. In S. Jarecki and G. Tsudik, editors, PKC 2009, volume 5443 of LNCS, pages 160&ndash;179. Springer, Heidelberg, Mar. 2009.</p></li>
      <li><p class="text-gray-300">[23] I. Damg&#730;ard and M. Keller. Secure multiparty AES. In R. Sion, editor, FC 2010, volume 6052 of LNCS, pages 367&ndash;374. Springer, Heidelberg, Jan. 2010.</p></li>
      <li><p class="text-gray-300">[24] I. Damg&#730;ard, M. Keller, E. Larraia, C. Miles, and N. P. Smart. Implementing AES via an actively/covertly secure dishonest-majority MPC protocol. In I. Visconti and R. D. Prisco, editors, SCN 12, volume 7485 of LNCS, pages 241&ndash;263. Springer, Heidelberg, Sept. 2012.</p></li>
      <li><p class="text-gray-300">[25] I. Damg&#730;ard, M. Keller, E. Larraia, V. Pastro, P. Scholl, and N. P. Smart. Practical covertly secure MPC for dishonest majority - or: Breaking the SPDZ limits. In J. Crampton, S. Jajodia, and K. Mayes, editors, ESORICS 2013, volume 8134 of LNCS, pages 1&ndash;18. Springer, Heidelberg, Sept. 2013.</p></li>
      <li><p class="text-gray-300">[26] I. Damg&#730;ard, V. Pastro, N. P. Smart, and S. Zakarias. Multiparty computation from somewhat homomorphic encryption. In R. Safavi-Naini and R. Canetti, editors, CRYPTO 2012, volume 7417 of LNCS, pages 643&ndash;662. Springer, Heidelberg, Aug. 2012.</p></li>
      <li><p class="text-gray-300">[27] I. Damg&#730;ard and R. W. Zakarias. Fast oblivious AES A dedicated application of the MiniMac protocol. In AFRICACRYPT 2016, pages 245&ndash;264, 2016.</p></li>
      <li><p class="text-gray-300">[28] S. Duval, V. Lallemand, and Y. Rotella. Cryptanalysis of the FLIP family of stream ciphers. In CRYPTO 2016, 2016.</p></li>
      <li><p class="text-gray-300">[29] T. K. Frederiksen, M. Keller, E. Orsini, and P. Scholl. A Unified Approach to MPC with Preprocessing Using OT. In T. Iwata and J. H. Cheon, editors, ASIACRYPT 2015, volume 9452 of LNCS, pages 711&ndash;735. Springer, Heidelberg, Dec. 2015.</p></li>
      <li><p class="text-gray-300">[30] T. Jakobsen and L. R. Knudsen. The interpolation attack on block ciphers. In E. Biham, editor, FSE'97, volume 1267 of LNCS, pages 28&ndash;40. Springer, Heidelberg, Jan. 1997.</p></li>
      <li><p class="text-gray-300">[31] M. Keller, E. Orsini, and P. Scholl. MASCOT: Faster malicious arithmetic secure computation from oblivious transfer. Cryptology ePrint Archive, 2016. <a href="http://eprint.iacr.org/2016/505" target="_blank" rel="noopener noreferrer">http://eprint.iacr.org/2016/505.</a></p></li>
      <li><p class="text-gray-300">[32] M. Keller, P. Scholl, and N. P. Smart. An architecture for practical actively secure MPC with dishonest majority. In A.-R. Sadeghi, V. D. Gligor, and M. Yung, editors, ACM CCS 13, pages 549&ndash;560. ACM Press, Nov. 2013.</p></li>
      <li><p class="text-gray-300">[33] S. Laur, R. Talviste, and J. Willemson. From oblivious</p></li>
      <li><p class="text-gray-300">AES to efficient and secure database join in the multiparty setting. In M. J. Jacobson Jr., M. E. Locasto, P. Mohassel, and R. Safavi-Naini, editors, ACNS 13, volume 7954 of LNCS, pages 84&ndash;101. Springer, Heidelberg, June 2013.</p></li>
      <li><p class="text-gray-300">[34] C. H. Lim and T. Korkishko. mCrypton - a lightweight block cipher for security of low-cost RFID tags and sensors. In J. Song, T. Kwon, and M. Yung, editors, WISA 05, volume 3786 of LNCS, pages 243&ndash;258. Springer, Heidelberg, Aug. 2006.</p></li>
      <li><p class="text-gray-300">[35] Y. Lindell and B. Riva. Blazing fast 2PC in the offline/online setting with security for malicious adversaries. In I. Ray, N. Li, and C. Kruegel:, editors, ACM CCS 15, pages 579&ndash;590. ACM Press, Oct. 2015.</p></li>
      <li><p class="text-gray-300">[36] S. Lu and R. Ostrovsky. Distributed oblivious RAM for secure two-party computation. In A. Sahai, editor, TCC 2013, volume 7785 of LNCS, pages 377&ndash;396. Springer, Heidelberg, Mar. 2013.</p></li>
      <li><p class="text-gray-300">[37] P. M&acute;eaux, A. Journault, F. Standaert, and C. Carlet. Towards stream ciphers for efficient FHE with low-noise ciphertexts. In M. Fischlin and J. Coron, editors, EUROCRYPT 2016, volume 9665 of Lecture Notes in Computer Science, pages 311&ndash;343. Springer, 2016.</p></li>
      <li><p class="text-gray-300">[38] M. Naor and O. Reingold. Number-theoretic constructions of efficient pseudo-random functions. In 38th FOCS, pages 458&ndash;467. IEEE Computer Society Press, Oct. 1997.</p></li>
      <li><p class="text-gray-300">[39] J. B. Nielsen, P. S. Nordholt, C. Orlandi, and S. S. Burra. A new approach to practical active-secure two-party computation. In R. Safavi-Naini and R. Canetti, editors, CRYPTO 2012, volume 7417 of LNCS, pages 681&ndash;700. Springer, Heidelberg, Aug. 2012.</p></li>
      <li><p class="text-gray-300">[40] K. Nyberg and L. R. Knudsen. Provable security against a differential attack. Journal of Cryptology, 8(1):27&ndash;37, 1995.</p></li>
      <li><p class="text-gray-300">[41] B. Pinkas, T. Schneider, N. P. Smart, and S. C. Williams. Secure two-party computation is practical. In M. Matsui, editor, ASIACRYPT 2009, volume 5912 of LNCS, pages 250&ndash;267. Springer, Heidelberg, Dec. 2009.</p></li>
      <li><p class="text-gray-300">[42] A. Russell and I. Shparlinski. Classical and quantum polynomial reconstruction via Legendre symbol evaluation. Journal of Complexity, 20(2-3):404&ndash;422, 2004.</p></li>
      <li><p class="text-gray-300">[43] W. Van Dam. Quantum algorithms for weighing matrices and quadratic residues. Algorithmica, 34(4):413&ndash;428, 2002.</p></li>
      <li><p class="text-gray-300">[44] W. van Dam, S. Hallgren, and L. Ip. Quantum algorithms for some hidden shift problems. In 14th SODA, pages 489&ndash;498. ACM-SIAM, Jan. 2003.</p></li>
      <li><p class="text-gray-300">[45] F. Vercauteren. The hidden root problem. In S. D. Galbraith and K. G. Paterson, editors, PAIRING 2008, volume 5209 of LNCS, pages 89&ndash;99. Springer, Heidelberg, Sept. 2008.</p></li>
    </ul>

`;
---

<BaseLayout title="MPC-Friendly Symmetric Key Primitives (2016/542)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/542
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li>
          <a href="#abstract" class="hover:text-white">Abstract</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-1.1" class="hover:text-white">Main Motivating Applications</a></li>
            <li><a href="#sec-1.2" class="hover:text-white">Secondary Applications</a></li>
            <li><a href="#sec-1.3" class="hover:text-white">Related Work</a></li>
            <li><a href="#sec-1.4" class="hover:text-white">Contributions</a></li>
            <li><a href="#sec-1.5" class="hover:text-white">Length Extension</a></li>
            <li><a href="#sec-2.1" class="hover:text-white">Multi-Party Computation Model</a></li>
            <li><a href="#sec-2.2" class="hover:text-white">MPC Evaluation of AES and LowMC</a></li>
            <li><a href="#sec-2.2.1" class="hover:text-white">F&lt;sub&gt;LowMC&lt;/sub&gt; Definition</a></li>
            <li><a href="#sec-2.2.2" class="hover:text-white">Computing F&lt;sub&gt;LowMC&lt;/sub&gt; in MPC</a></li>
            <li><a href="#sec-2.2.3" class="hover:text-white">Performance</a></li>
            <li><a href="#sec-3.1" class="hover:text-white">F_&#123;NR&#125; Definition</a></li>
            <li><a href="#sec-3.3" class="hover:text-white">Secure Computation of Naor-Reingold</a></li>
            <li><a href="#sec-3.4" class="hover:text-white">Performance</a></li>
            <li><a href="#sec-4.1" class="hover:text-white">F_&#123;\text&#123;Leg&#125;&#125; Definition</a></li>
            <li><a href="#sec-4.2" class="hover:text-white">Hardness of the Shifted Legendre Symbol Problem</a></li>
            <li><a href="#sec-4.3" class="hover:text-white">Secure Computation of FLeg(bit)</a></li>
            <li><a href="#sec-4.4" class="hover:text-white">Domain and Codomain Extension</a></li>
            <li><a href="#sec-4.5" class="hover:text-white">Performance</a></li>
            <li><a href="#sec-5.1" class="hover:text-white">F_&#123;MiMC&#125; Definition</a></li>
            <li><a href="#sec-5.2" class="hover:text-white">Computing F_&#123;MiMC&#125; in MPC</a></li>
            <li><a href="#sec-5.3" class="hover:text-white">Performance</a></li>
          </ol>
        </li>
      </ol>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="mpc-friendly-symmetric-key-primitives-2016" />
  </article>
</BaseLayout>
