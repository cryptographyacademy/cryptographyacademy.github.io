---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/542';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'MPC-Friendly Symmetric Key Primitives';
const AUTHORS_HTML = 'Lorenzo Grassi, Christian Rechberger, Dragos Rotaru, Peter Scholl, Nigel P.  Smart';

const CONTENT = `    <p class="text-gray-300">Lorenzo Grassi Graz University of Technology.</p>

    <p class="text-gray-300">Christian Rechberger Graz University of Technology.</p>

    <p class="text-gray-300">Dragos Rotaru Dept. of Comp. Sci., University of Bristol.</p>

    <p class="text-gray-300">Peter Scholl Dept. of Comp. Sci., University of Bristol.</p>

    <p class="text-gray-300">Nigel P. Smart Dept. of Comp. Sci., University of Bristol.</p>

    <p class="text-gray-300">We discuss the design of symmetric primitives, in particular Pseudo-Random Functions (PRFs) which are suitable for use in a secret-sharing based MPC system. We consider three different PRFs: the Naor-Reingold PRF, a PRF based on the Legendre symbol, and a specialized block cipher design called MiMC. We present protocols for implementing these PRFs within a secret-sharing based MPC system, and discuss possible applications. We then compare the performance of our protocols. Depending on the application, different PRFs may offer different optimizations and advantages over the classic AES benchmark. Thus, we cannot conclude that there is one optimal PRF to be used in all situations.</p>

    <p class="text-gray-300">Secure multi-party computation (MPC) allows a set of parties to jointly evaluate a function on private inputs, with the guarantee that no party can learn anything more than the output of the function. In the last decade, MPC has moved from a theoretical pursuit to a very practical field, as protocols have become more efficient and many implementations been developed.</p>

    <p class="text-gray-300">For many years now, the de facto benchmark for MPC systems has been secure computation of the AES function [41, 23, 24, 39, 35]. Although the actual choice of this function was originally as a testbed for comparing protocols, it has often been justified as "useful"; for example if an application needs to evaluate a symmetric encryption scheme or pseudorandom function (PRF) with a secret-shared key. If this is indeed required, then there is no particular reason why AES should be the best choice to work with MPC, compared with other PRFs or symmetric ciphers. Indeed we contend that AES is in many ways a very unnatural choice of a PRF evaluation for use in MPC applications. In this work, we conduct a study of some PRFs for use in MPC, including new protocols for evaluating number-theoretic PRFs, and</p>

    <p class="text-gray-300">Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than the author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org.</p>

    <p class="text-gray-300">CCS 2016 Vienna, Austria</p>

    <p class="text-gray-300">© 2016 Copyright held by the owner/author(s). Publication rights licensed to ACM. ISBN 978-1-4503-4139-4/16/10...$15.00</p>

    <p class="text-gray-300">DOI: http://dx.doi.org/10.1145/2976749.2978332</p>

    <p class="text-gray-300">implementation of "traditional" block cipher candidates designed to have a low complexity in MPC.</p>

    <p class="text-gray-300">Before proceeding, we first outline some applications we have in mind. Our focus is on secret sharing based MPC systems such as that typified by BDOZ [7], SPDZ [26, 25], and VIFF [22]; or indeed any classical protocol based on Shamir Secret Sharing. In such situations data is often shared as elements of a finite field  <span class="math">\\mathbb{F}_p</span> , of large prime characteristic. Using such a representation one then has efficient protocols to compute relatively complex functions such as integer comparison [21], fixed point arithmetic [17], and linear programming [16]. Indeed the most famous of such efficient high level protocols is that needed to compute the output of an auction [8].</p>

    <p class="text-gray-300">Given such applications, evaluated by an MPC "engine", the question arises as to how to get data securely in and out of the engine. In traditional presentations the data is entered by the computing parties, and the output is delivered to the computing parties. However, this in practice will be a simplification. Input and output may need to be securely delivered/received by third parties, in addition in a long term reactive functionality the intermediate secure data may need to be stored in a database, or other storage device.</p>

    <p class="text-gray-300">If we examine the case of long term storage of data, which is stored by the MPC engine only to be used again at a later date, the trivial way to store such shared data is for each party to encrypt their share with a symmetric key, and then store each encrypted share. However, this incurs an  <span class="math">N</span> -fold increase in storage at the database end (for  <span class="math">N</span>  MPC servers), which may be prohibitive. A similar trivial solution also applies for data input and output, except data input is now performed using  <span class="math">N</span>  public keys (one for each MPC server) and output is performed by each server producing a public key encryption of its share to the recipient's public key.</p>

    <p class="text-gray-300">A more efficient solution would be to use a direct evaluation of a symmetric key primitive within the MPC engine. Such a symmetric key primitive should be able to be efficiently evaluated by the MPC engine¹. We call such a symmetric key primitive "MPC-Friendly". Given almost all symmetric key primitives can be constructed easily from</p>

    <p class="text-gray-300">Pseudo-Random Functions (PRFs), the goal is therefore to produce an MPC-Friendly PRF.</p>

    <p class="text-gray-300">The main problem of using “traditional” PRFs such as AES is that these are built for computational engines which work over data types that do not easily match the operations possible in the MPC engine. For example AES is very much a byte/word oriented cipher, which is hard to represent using arithmetic in <span class="math">\\mathbb{F}_{p}</span>. Thus we are led to a whole new area of PRF design, with very different efficiency metrics compared to traditional PRF design.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.2 Secondary Applications</h3>

    <p class="text-gray-300">A simple example application of MPC is to enable distributed secure storage of long-term cryptographic keys, by secret-sharing the key and storing each share at a separate server. When the key is required by an application such as encryption or authentication, the MPC protocol is used to compute this functionality. If this cryptographic functionality is a symmetric cipher, then this application would be greatly enhanced by using an “MPC-Friendly” symmetric primitive.</p>

    <p class="text-gray-300">Using traditional symmetric cryptographic primitives directly on shared data can also improve efficiency for some applications. For example, Laur et al. <em>[33]</em> used an oblivious AES implementation to perform a secure join operation on a secret-shared database. After obliviously shuffling the database, the (deterministic) AES encryptions are made public to all parties, so that the join can then be performed efficiently using standard database algorithms.</p>

    <p class="text-gray-300">Lu and Ostrovsky <em>[36]</em> presented a distributed oblivious RAM protocol, which achieves only <span class="math">O(\\log N)</span> overhead, better than any ORAM scheme in the non-distributed setting. This protocol could be combined with a secret-shared MPC system to provide a mechanism to allow secure computation of RAM programs. However, the ORAM construction of <em>[36]</em> makes heavy use of a PRF, so such an application would require the use of an MPC-Friendly PRF.</p>

    <p class="text-gray-300">For other operational reasons it may be useful to encrypt data using a special form of encryption such as deterministic encryption, searchable symmetric encryption (SSE) or (leaky) order-revealing encryption (ORE) <em>[9, 10, 18, 6, 14]</em>, under a secret-shared key. These algorithms can enable efficient queries on the encrypted data, whilst the query results can then be decrypted into shares for more complex processing using MPC. For transmission across the wire, to (or from) an external application, a form of Authenticated Encryption (AE) is needed. We note that all of these symmetric primitives (SSE, OPE, AE etc) can be built, in generic ways, out of a PRF. Thus the main obstacle preventing such applications is an efficient MPC-Friendly PRF.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.3 Related Work</h3>

    <p class="text-gray-300">Surprisingly there has been little direct work on this problem, despite the recent plethora of proposed MPC applications; indeed the only paper we know of which explicitly designs PRFs for use in MPC, is <em>[4]</em>, which we shall discuss below. The three lines of work most related to the work in this paper, apart from re-purposing designs from elsewhere, are</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Low complexity, “lightweight” ciphers for use in IoT and other constrained environments.</li>

      <li>Block and stream ciphers suited to evaluation by a Fully Homomorphic/Somewhat Homomorphic encryption scheme. So called SHE-Friendly ciphers.</li>

      <li>Designs for use in SNARKs.</li>

    </ul>

    <p class="text-gray-300">We now elaborate on the prior work in these areas.</p>

    <p class="text-gray-300">Low Complexity Lightweight Ciphers: Block ciphers often iterate a relatively simple round function a number of times to achive security goals. Most early designs in this domain focused on small area when implemented as a circuit in hardware. There, large depth (via a large number of rounds) is of no concern as simply means clocking a circuit that implements a single round more times. Notable exceptions are mCrypton<em>[34]</em> and Noekeon<em>[19]</em> which also feature a relatively low depth. The more recent trend to emphasize low latency (with designs like PRINCE<em>[11]</em>) fits much better with our requirement of having low-depth. A property of all these designs is that they lend themselves well to implementations where binary NAND gates, XOR gates, or multiplexers are the basic building blocks in the used libraries. As explained above the majority of secret sharing based MPC applications require description via <span class="math">\\mathbb{F}_{p}</span>. Whilst bit operations are possible over <span class="math">\\mathbb{F}_{p}</span> using standard tricks (which alas turn XOR into a non-linear operation), applying such ciphers would require the <span class="math">\\mathbb{F}_{p}</span> data types to be split into a shared bit representation over <span class="math">\\mathbb{F}_{p}</span> to apply the cipher. Such a conversion is expensive.</p>

    <p class="text-gray-300">SHE-Friendly Ciphers: Perhaps due to the recent theoretical interest in SHE/FHE schemes this area has had more attention than the more practical issues addressed in this paper. The motivating scenario for a SHE-Friendly cipher is to enable data to be securely passed to a cloud environment, using a standard encryption scheme, which the cloud server then homomorphically decrypts to obtain a homomorphic encryption of the original data.</p>

    <p class="text-gray-300">This line of work has resulted in a handful of designs. A block cipher called LowMC <em>[4]</em>, a stream cipher called Kreyvium <em>[13]</em> (based on the Trivium stream cipher) and FLIP <em>[37]</em> (based on a filter permutation). The block cipher LowMC is designed for both MPC and FHE implementation, but actually does not meet the MPC design goals we have set. It does indeed have low depth, but it is a cipher based on operations in characteristic two. The two SHE friendly stream cipher designs of Kreyvium and FLIP also suffer from the same problem as the lightweight designs describe above, as they are also bit-oriented.</p>

    <p class="text-gray-300">SNARK-Friendly Constructions: Being SNARK-friendly means that the number of constraints is low. This generally favours larger data types like <span class="math">\\mathbb{F}_{p}</span> or <span class="math">\\mathbb{F}_{2^{n}}</span>, and the depth of the circuit is of no concern. MiMC <em>[2]</em> was originally designed for this use case and seems to be the only one in this area. As the depth is not too high either, we choose it for detailed evaluation.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">1.4 Contributions</h3>

    <p class="text-gray-300">The goal of this work is to investigate the efficient evaluation of PRFs in a secret-sharing based MPC setting. We leave the construction of the various higher level primitives (SSE, ORE, AE etc.) to future work, although many of these can easily be constructed directly from a PRF.</p>

    <p class="text-gray-300">present new protocols for secure computation of PRFs, and implementation results using an actively secure MPC protocol, which tolerates up to <span class="math">N-1</span> out of <span class="math">N</span> corrupted parties (with an online phase based on the SPDZ protocol <em>[26, 25]</em>).</p>

    <p class="text-gray-300">To fix notation we will consider a PRF of the following form</p>

    <p class="text-gray-300">\\[ F:\\left\\{\\begin{array}[]{ccc}(\\mathbb{F}_{p})^{\\ell}\\times(\\mathbb{F}_{q})^{n}&\\longrightarrow&(\\mathbb{F}_{r})^{m}\\\\ (k_{1},\\ldots,k_{\\ell},x_{1},\\ldots,x_{n})&\\longmapsto&F_{k}(x_{1},\\ldots,x_{n}).\\end{array}\\right. \\]</p>

    <p class="text-gray-300">The various finite fields <span class="math">\\mathbb{F}_{p}</span>, <span class="math">\\mathbb{F}_{q}</span> and <span class="math">\\mathbb{F}_{r}</span> may be distinct. Our MPC engine is assumed to work over the finite field <span class="math">\\mathbb{F}_{p}</span>, as we always assume the key to the PRF will be a secret shared value. As a benchmark, we compare all of our candidates to the baseline AES example used in prior work, and to implementations of the given PRFs on clear data.</p>

    <p class="text-gray-300">Depending on the precise application, there are several distinct design criteria which we may want to consider. Thus, there will not be a one size fits all PRF which works in all applications. We then have various potential cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In some applications the input is public and we need to embed the public elements <span class="math">x_{1},\\ldots,x_{n}\\in\\mathbb{F}_{q}</span> into <span class="math">\\mathbb{F}_{p}</span>. However, the more general case is when the input is secret shared itself, and we have <span class="math">\\mathbb{F}_{q}=\\mathbb{F}_{p}</span>.</li>

      <li>In some applications the output of the PRF will be public, and thus <span class="math">\\mathbb{F}_{r}</span> can be any field. In other applications we also want the output to be secret shared, so we can use it in some other processing such as a mode of operation. In this latter case we will have <span class="math">\\mathbb{F}_{r}=F_{p}</span>. In addition, some applications, such as when using the (leaky) ORE scheme presented in <em>[18]</em> require PRF outputs in <span class="math">\\{0,1,2\\}</span>, and we may (or may not) require these to be secret shared (and hence embedded in <span class="math">\\mathbb{F}_{p}</span>).</li>

      <li>In some applications we would like a PRF which is just efficient in the MPC engine, and we do not care whether the equivalent standard PRF is efficient or not. In other applications we also require that the standard PRF is also efficient. For example when an external third party is encrypting data for the MPC engine to decrypt.</li>

    </ul>

    <p class="text-gray-300">In this paper we consider four candidate PRFs for use in MPC systems, as well as the comparison case of AES. Two of these are number theoretic in nature (the Naor-Reingold PRF, based on DDH, and a PRF based on the Legendre symbol), whilst MiMC <em>[2]</em> and LowMC <em>[4]</em> are more akin to traditional symmetric block cipher constructions.</p>

    <p class="text-gray-300">AES: Since AES does not lend itself well to secure computation over prime fields, we use this purely as a benchmark. We assume an MPC system which is defined over the finite field <span class="math">\\mathbb{F}_{2^{8}}</span>, allowing for efficient evaluation of the S-box <em>[23, 24]</em>. We have</p>

    <p class="text-gray-300"><span class="math">F_{\\mathsf{AES}}:(\\mathbb{F}_{2^{8}})^{16}\\times(\\mathbb{F}_{2^{8}})^{16}\\to(\\mathbb{F}_{2^{8}})^{16}.</span></p>

    <p class="text-gray-300">LowMC: This is a block cipher candidate <em>[4]</em> designed to be suitable for FHE and MPC style applications; thus it has a low multiplicative depth and a low number of multiplications. It operates over <span class="math">\\mathbb{F}_{2}</span>, so like AES, is not well-suited to the MPC applications for which we envisage our block ciphers being used for. Thus we only consider LowMC as an additional base line comparison (along with AES) for our ciphers. LowMC has block size <span class="math">n</span> bits and key size <span class="math">k</span> bits (we use <span class="math">n=256</span> and <span class="math">k=128</span>), giving:</p>

    <p class="text-gray-300"><span class="math">F_{\\mathsf{LowMC}}:(\\mathbb{F}_{2})^{k}\\times(\\mathbb{F}_{2})^{n}\\to(\\mathbb{F}_{2})^{n}</span></p>

    <p class="text-gray-300">Naor-Reingold: Let <span class="math">\\mathbb{G}=\\langle g\\rangle</span> be an elliptic curve group of prime order <span class="math">p</span> in which DDH is hard, and <span class="math">\\mathsf{encode}(\\cdot)</span> be a hash function that maps elements of <span class="math">\\mathbb{G}</span> into elements of <span class="math">\\mathbb{F}_{p}</span>. The Naor-Reingold PRF takes a uniform secret-shared key in <span class="math">\\mathbb{F}_{p}^{n+1}</span>, a message in <span class="math">\\mathbb{F}_{2}^{n}</span> (secret-shared over <span class="math">\\mathbb{F}_{p}</span>), and outputs a <em>public</em> <span class="math">\\mathbb{F}_{p}</span> element as follows:</p>

    <p class="text-gray-300"><span class="math">F_{\\mathsf{NR}(n)}:(\\mathbb{F}_{p})^{n+1}\\times(\\mathbb{F}_{2})^{n}</span> <span class="math">\\to\\mathbb{F}_{p}</span> <span class="math">(\\mathbf{k},\\mathbf{x})</span> <span class="math">\\mapsto\\mathsf{encode}(g^{k_{0}\\cdot\\prod_{i=1}^{n}k_{i}^{2})}</span></p>

    <p class="text-gray-300">To evaluate <span class="math">F_{\\mathsf{NR}}</span> in MPC naively would require computing exponentiations (or EC scalar multiplications) on secret exponents, which is very expensive. However, if the PRF output is public, we show how the exponentiation (and hence PRF evaluation) can be done very efficiently, with active security, using any MPC protocol based on secret sharing.</p>

    <p class="text-gray-300">Legendre Symbol: We also consider an unusual PRF based on the pseudorandomness of the Legendre symbol. This is a relatively old idea, going back to a paper of Damgård in 1988 <em>[20]</em>, but has not been studied much by the cryptographic community. The basic version of the PRF is defined as,</p>

    <p class="text-gray-300"><span class="math">F_{\\mathsf{Leg(bit)}}:\\mathbb{F}_{p}\\times\\mathbb{F}_{p}</span> <span class="math">\\to\\mathbb{F}_{2}</span> <span class="math">(k,x)</span> <span class="math">\\mapsto L_{p}(x+k)</span></p>

    <p class="text-gray-300">where <span class="math">L_{p}(a)</span> computes the usual Legendre symbol <span class="math">\\binom{a}{p}\\in\\{-1,0,1\\}</span> and maps this into <span class="math">\\{0,1,(p+1)/2\\}</span>, by computing</p>

    <p class="text-gray-300"><span class="math">L_{p}(a)=\\frac{1}{2}\\left(\\binom{a}{p}+1\\right)\\pmod{p}.</span></p>

    <p class="text-gray-300">The output is embedded into <span class="math">\\mathbb{F}_{p}</span>, giving a secret-shared output in <span class="math">\\mathbb{F}_{p}</span>. If needed, the range can easily be extended to the whole of <span class="math">\\mathbb{F}_{p}</span> by using a key with multiple field elements and performing several evaluations in parallel. This gives a PRF</p>

    <p class="text-gray-300"><span class="math">F_{\\mathsf{Leg}(n)}:(\\mathbb{F}_{p})^{((n+1)\\cdot\\ell)}\\times(\\mathbb{F}_{p})^{n}\\to\\mathbb{F}_{p},</span></p>

    <p class="text-gray-300">for some value <span class="math">\\ell=O(\\log_{2}p)</span> chosen large enough to ensure a sufficient statistical distance from uniform of the output. This PRF takes <span class="math">n</span> finite field elements as input and produces an element in <span class="math">\\mathbb{F}_{p}</span> as output, where <span class="math">n</span> is some fixed (and relatively small) number, say one or two.</p>

    <p class="text-gray-300">Perhaps surprisingly, we show that the Legendre PRF can be evaluated <em>very efficiently</em> in MPC, at the cost of just two multiplications in three rounds of interaction for <span class="math">F_{\\mathsf{Leg(bit)}}</span>. To the best of our knowledge, this is the only PRF that can be evaluated in a constant number of rounds on secret-shared data, using any arithmetic MPC protocol. Since the underlying hard problem is less well-studied than, say, DDH or factoring, we also provide a brief survey of some known attacks, which are essentially no better than brute force of the key.</p>

    <p class="text-gray-300">MiMC: This is a very recent class of designs whose primary application domain are SNARKs <em>[2]</em>. In addition to a cryptographic hash function, the design also includes a block cipher which is also usable as a PRF, with up to birthday</p>

    <p class="text-gray-300">bound security. The input, output and keys are all defined over  <span class="math">\\mathbb{F}_p</span> , so we get:</p>

    <div class="my-4 text-center"><span class="math-block">F _ {\\mathrm {M i M C}}: \\mathbb {F} _ {p} \\times \\mathbb {F} _ {p} \\rightarrow \\mathbb {F} _ {p}.</span></div>

    <p class="text-gray-300">The core of the round function is the simple map  <span class="math">x \\mapsto x^3</span>  over  <span class="math">\\mathbb{F}_p</span> . The number of rounds is quite high (for a 128-bit prime  <span class="math">p</span>  82 for full security, 73 for PRF security), but in terms of  <span class="math">\\mathbb{F}_p</span>  multiplications the performance turns out to be competitive.</p>

    <p class="text-gray-300">The reason for selecting MiMC as a "standard" block cipher is that firstly it works over a finite prime field of large characteristic, which is a common requirement for applications of secret-sharing based MPC that perform arithmetic on integers or fixed-point data types. Secondly, the depth of the computation is not too large, being 146. Thirdly, the number of non-linear operations is also 146, this means that the offline pre-processing needed (to produce multiplication triples) will be very small compared to other constructions.</p>

    <p class="text-gray-300">In Table 1 we present an overview of the MPC-friendly PRFs we consider. The table shows the number of secure multiplication needed to execute the online evaluation of the function on shared inputs (since in secret-sharing based MPC, additions are free) as well as the number of rounds of communication.</p>

    <h2 id="sec-8" class="text-2xl font-bold">1.5 Length Extension</h2>

    <p class="text-gray-300">We end this introduction by noting that  <span class="math">F_{\\mathrm{MIMC}}</span>  and  <span class="math">F_{\\mathrm{Leg}(n)}</span>  can be extended to cope with arbitrary length inputs in the standard way; either by using a CBC-MAC style construction or a Merkle-Damgard style construction. For example, to extend  <span class="math">F_{\\mathrm{Leg}(1)}</span>  and  <span class="math">F_{\\mathrm{MIMC}}</span> , so that they can be applied to an input  <span class="math">x_1, \\ldots, x_n \\in \\mathbb{F}_p</span>  we can use CBC mode as in Figure 1. Whereas, to extend  <span class="math">F_{\\mathrm{Leg}(2)}</span>  we can apply Merkle-Damgard as in Figure 2. These two extension techniques are often more efficient than using an arbitrary length PRF as a base building block.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: Using CBC Mode With  <span class="math">F_{\\mathrm{Leg}(1)}</span> Figure 3: Ideal functionality for arithmetic MPC</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 2: Using Merkle-Damgard With  <span class="math">F_{\\mathrm{Leg}(2)}</span></p>

    <h2 id="sec-9" class="text-2xl font-bold">2. BACKGROUND</h2>

    <p class="text-gray-300">In this section we outline some of the basic material which we will assume for the rest of this paper.</p>

    <h2 id="sec-10" class="text-2xl font-bold">2.1 Multi-Party Computation Model</h2>

    <p class="text-gray-300">The general model of MPC we consider is the so-called arithmetic black box, which is an ideal functionality that allows parties to input and output values to be secret-shared, and performs basic arithmetic operations on these secret values over a finite field  <span class="math">\\mathbb{F}_p</span> . This abstracts away the underlying details of secret-sharing and MPC, and gives us the commands in Figure 3. Note that as well as addition and multiplication,  <span class="math">\\mathcal{F}_{\\mathrm{ABB}}</span>  has commands for generating random values according to various distributions, which allows more efficient protocols for certain tasks. Finally, the Share command gives parties access to random, additive shares of a value stored in the box. This essentially assumes the underlying MPC protocol uses additive secret sharing, but is only used for the Naor-Reingold PRF protocol (Section 3).</p>

    <p class="text-gray-300">We use the notation  <span class="math">[x]</span>  to denote a secret-shared value that is stored in  <span class="math">\\mathcal{F}_{\\mathrm{ABB}}</span> . We also define addition and multiplication operators for the  <span class="math">[\\cdot]</span>  notation; so, for example, the statement</p>

    <div class="my-4 text-center"><span class="math-block">[ w ] = [ x ] \\cdot [ y ] + 2 [ z ]</span></div>

    <p class="text-gray-300">implicitly means that the Add and Mult commands of  <span class="math">\\mathcal{F}_{\\mathrm{ABB}}</span>  are used to compute the shared value  <span class="math">[w]</span> .</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a></p>

    <p class="text-gray-300">Concretely, the MPC protocol we use to implement  <span class="math">\\mathcal{F}_{\\mathrm{ABB}}</span>  is the SPDZ protocol by Damgård et al. [26, 25], which operates over a finite field of size  <span class="math">\\geq 2^n</span>  (for statistical security  <span class="math">\\kappa</span> ) and provides active security against any number of corrupted parties. The protocol consists of two stages: a preprocessing phase, which is independent of the inputs and done in advance, and a more efficient online phase, where the actual computation takes place. The purpose of the preprocessing is to generate enough random shared data that will be consumed later by the online phase. The main data produced is one of three different forms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Multiplication Triples: A triple of random shares  <span class="math">([a], [b], [c])</span>  such that  <span class="math">c = a \\cdot b \\mod p</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PRF</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">log2p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Output (type)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Online cost</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Assumption</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Mult.</td>

            <td class="px-3 py-2 border-b border-gray-700">Rounds</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">FAES</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">shared</td>

            <td class="px-3 py-2 border-b border-gray-700">960</td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">FLowMC</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">shared</td>

            <td class="px-3 py-2 border-b border-gray-700">1911</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">FNR(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">public</td>

            <td class="px-3 py-2 border-b border-gray-700">2·n</td>

            <td class="px-3 py-2 border-b border-gray-700">3 + log(n + 1)</td>

            <td class="px-3 py-2 border-b border-gray-700">EC-DDH</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">FLeg(bit)</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">shared</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">DSLS</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">FLeg(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">shared</td>

            <td class="px-3 py-2 border-b border-gray-700">256·n</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">DSLS</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">FMiMC</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">shared</td>

            <td class="px-3 py-2 border-b border-gray-700">146</td>

            <td class="px-3 py-2 border-b border-gray-700">73</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Overview of the cost of evaluating the PRFs in MPC.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Square Pairs: A pair of random shares  <span class="math">([a],[b])</span>  such that  <span class="math">b = a^2 \\mod p</span> .</li>

      <li>Random Bit: A random sharing  <span class="math">[a]</span>  of a value  <span class="math">a \\in \\{0,1\\}</span> .</li>

    </ul>

    <p class="text-gray-300">The main arithmetic operations in  <span class="math">\\mathcal{F}_{\\mathrm{ABB}}</span>  have roughly the following complexity when implemented in SPDZ. Additions (and linear operations) are local operations so essentially for free. A multiplication uses a preprocessed multiplication triple and requires sending two field elements in the online phase, with one round of interaction. Squaring can be done using a square pair and sending just one field element, again in one round.</p>

    <p class="text-gray-300">The preprocessing can be implemented using either somewhat homomorphic encryption (SHE) — as in the original SPDZ protocols — or oblivious transfer (OT), using the recent protocol of Keller et al. [31]. We present runtimes using the OT-based offline phase only, as it is much more efficient, even when compared with the weaker covertly secure protocols using SHE.</p>

    <p class="text-gray-300">As a means of comparison for the other PRFs we use as a base line a two party implementation of AES using a SPDZ engine over the finite field  <span class="math">\\mathbb{F}_{2^8}</span> , embedded into  <span class="math">\\mathbb{F}_{2^{40}}</span> , as in [24]. We estimate the offline phase costs 200ms per block, with an online phase latency of 8ms and a throughput of over 500 blocks per second. Note that recently, much lower latencies have been obtained by evaluating AES using secure table lookup [27]. However, this technique requires far more (i.e., 256 times) preprocessing data, so we do not consider this. One should also bear in mind that this is only the time needed to evaluate the PRF. In a given application, which is likely to be over a different finite field, the MPC engine will also need to convert data between the two fields  <span class="math">\\mathbb{F}_p</span>  and  <span class="math">\\mathbb{F}_{2^{40}}</span> . This is likely to incur a more significant cost than the evaluation of the PRF itself.</p>

    <p class="text-gray-300">In addition to AES, we also present comparison executions for the low complexity block cipher LowMC. This is to enable a comparison with our  <span class="math">\\mathbb{F}_p</span>  based block ciphers against not only a standard in-use block cipher (AES), but also a block cipher designed for use in MPC/FHE environments.</p>

    <p class="text-gray-300">LowMC [4] is a flexible family of block ciphers with operations over  <span class="math">\\mathbb{F}_2</span> , designed to have a low number of multiplications and a low multiplicative depth when implemented in MPC. Similar to AES, it is based on an SPN structure where the block size  <span class="math">n</span> , the key size  <span class="math">k</span> , the number of Sboxes  <span class="math">m</span>  in</p>

    <p class="text-gray-300">the substitution layer and the allowed data complexity  <span class="math">d</span>  of attacks can independently be chosen. The number of rounds  <span class="math">r</span>  needed to reach the security claims is then derived from these parameters. The two most relevant parts of the round transformation are the SBOXLAYER and the LINEARLAYER. SBOXLAYER is an  <span class="math">m</span> -fold parallel application of the same 3-bit Sbox (of multiplicative depth 1) on the first  <span class="math">3m</span>  bits of the state. If  <span class="math">n &amp;gt; 3m</span>  then for the remaining  <span class="math">n - 3m</span>  bits, the SboxLayer is the identity. LINEARLAYER is the multiplication in  <span class="math">\\mathbb{F}_2</span>  of the state with a predetermined dense randomly chosen invertible binary  <span class="math">n \\times n</span>  matrix that is different for every round.</p>

    <p class="text-gray-300">Using the most recent v2[3] formula for  <span class="math">r</span> , we need at least 13 rounds to achieve a security comparable to AES as a PRF, i.e.  <span class="math">k = 128</span>  and  <span class="math">d = 64</span> . Using  <span class="math">n = 256</span> , the minimal number Sboxes  <span class="math">m</span>  for which this is true turns out to be 49.</p>

    <p class="text-gray-300">To evaluate LowMC in MPC, we consider two approaches. In the first method, denoted  <span class="math">F_{\\mathrm{LowMC}}(\\mathrm{vector})</span> , we work over  <span class="math">\\mathbb{F}_{2^{128}}</span>  and compute the matrix multiplications and XOR operations by parallelizing over 128-bit vectors. Specifically, each column  <span class="math">M_i</span>  of the  <span class="math">n \\times n</span>  matrix  <span class="math">M</span>  is packed into  <span class="math">\\mathbb{F}_{2^{128}}</span>  elements; to compute the product  <span class="math">M[\\mathbf{x}]</span>  we take the inner product of all columns with  <span class="math">[\\mathbf{x}]</span> . For  <span class="math">n = 256</span> , this requires 512 XORs and 512 local finite field multiplications. However, we then need to switch back to  <span class="math">\\mathbb{F}_2</span>  to evaluate the Sbox (with three  <span class="math">\\mathbb{F}_2</span>  multiplications), which requires bit decomposition, adding one round of interaction for every round of the cipher.</p>

    <p class="text-gray-300">In the second approach, denoted  <span class="math">F_{\\mathrm{LowMC}}(\\mathsf{M4R})</span> , we use the "Method of Four Russians" [1] to perform each matrix multiplication in  <span class="math">O(n^{2} / \\log n)</span>  bit operations. We do not parallelize the computation by packing bits into vectors, so this actually results in a higher computation cost than the vector method, but avoids the need for bit decomposition in each round.</p>

    <p class="text-gray-300">In both methods, the total number of multiplications over  <span class="math">\\mathbb{F}_2</span>  is  <span class="math">3 \\cdot m \\cdot r</span> . The vector approach requires  <span class="math">256 \\cdot r</span>  additional random bits, and also  <span class="math">2r</span>  rounds of communication, instead of  <span class="math">r</span>  rounds for M4R.</p>

    <p class="text-gray-300">With parameters  <span class="math">n = 256, m = 49, r = 13</span> , we obtained a latency of 4ms and a throughput of almost 600 blocks per second.</p>

    <p class="text-gray-300">As for AES, the need to convert from a  <span class="math">\\mathbb{F}_p</span>  representation to a bit-oriented representation for application of LowMC is likely to dominate the run-time for the actual PRF eval</p>

    <p class="text-gray-300">uation, making LowMC unsuitable for the applications we discussed at the beginning.</p>

    <p class="text-gray-300">In this section we describe the Naor-Reingold PRF, originally presented in [38]. We then go on to describe how it can be efficiently implemented in a secret sharing based MPC system.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathbb{G} = \\langle g\\rangle</span>  be a multiplicatively written group of prime order  <span class="math">p</span>  in which DDH is hard, and encode  <span class="math">(\\cdot)</span>  be a hash function that maps group elements into elements of  <span class="math">\\mathbb{F}_p</span> . For a message  <span class="math">\\mathbf{x} = (x_{1},\\ldots ,x_{n})\\in \\{0,1\\}^{n}</span> , the Naor-Reingold PRF [38] is defined by:</p>

    <div class="my-4 text-center"><span class="math-block">F _ {\\mathrm {N R} (n)} (\\mathbf {k}, \\mathbf {x}) = \\operatorname {e n c o d e} \\left(g ^ {k _ {0} \\cdot \\prod_ {i = 1} ^ {n} k _ {i} ^ {x _ {i}}}\\right)</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathbf{k} = (k_0,\\dots ,k_n)\\in \\mathbb{F}_p^{n + 1}</span>  is the key.</p>

    <p class="text-gray-300">In practice, we choose  <span class="math">\\mathbb{G}</span>  to be a 256-bit elliptic curve group over the NIST curve P-256, so require an MPC protocol for  <span class="math">\\mathbb{F}_p</span>  with a 256-bit prime  <span class="math">p</span> .</p>

    <p class="text-gray-300">The main ingredient of our method to evaluate  <span class="math">F_{\\mathrm{NR}}</span>  in MPC, when the key and message are secret-shared over  <span class="math">\\mathbb{F}_p</span> , is an efficient protocol for publicly computing  <span class="math">g^s</span> , for some secret value  <span class="math">s \\in \\mathbb{F}_p</span> . The protocol, shown in Figure 4, uses any arithmetic MPC protocol based on linear secret sharing over  <span class="math">\\mathbb{F}_p</span> . This is modeled for the case of additive secret sharing by the Share command of the  <span class="math">\\mathcal{F}_{\\mathrm{ABB}}</span>  functionality, which produces random shares of secret values.</p>

    <p class="text-gray-300">Given additive shares  <span class="math">s_i \\in \\mathbb{F}_p</span> , each party  <span class="math">P_i</span>  first broadcasts  <span class="math">g^{s_i}</span> , so the result  <span class="math">y = \\prod g^{s_i}</span>  can be computed. To obtain active security, we must ensure that each party used the correct value of  <span class="math">s_i</span> . We do this by computing an additional public exponentiation of  <span class="math">g^t</span> , where  <span class="math">t = r \\cdot s</span>  for some random, secret value  <span class="math">r</span> . This serves as a one-time MAC on  <span class="math">s</span> , which can then be verified by opening  <span class="math">r</span>  and checking that  <span class="math">g^t = y^r</span> . If an adversary cheats then passing the check essentially requires guessing the value of  <span class="math">r</span> , so occurs only probability  <span class="math">1/p</span> .</p>

    <p class="text-gray-300">Note that the functionality  <span class="math">\\mathcal{F}_{\\mathrm{ABB - Exp}}</span>  (Figure 5) models an unfair computation, whereby the adversary first learns the output, and can then decide whether to give this to the honest parties or not. This is because in the protocol, they can always simply stop sending messages and abort after learning  <span class="math">y</span> .</p>

    <p class="text-gray-300">Theorem 1. The protocol  <span class="math">\\Pi_{\\mathrm{Exp}}</span>  securely computes the functionality  <span class="math">\\mathcal{F}_{\\mathrm{ABB - Exp}}</span>  in the  <span class="math">\\mathcal{F}_{\\mathrm{ABB}}</span> -hybrid model.</p>

    <p class="text-gray-300">Proof. We construct a simulator  <span class="math">\\mathcal{S}</span> , which interacts with any adversary  <span class="math">\\mathcal{A}</span>  (who controls the corrupt parties  <span class="math">\\{P_i : i \\in A\\}</span> ) and the ideal functionality  <span class="math">\\mathcal{F}_{\\mathrm{ABB - Exp}}</span> , such that no environment can distinguish between an interaction with  <span class="math">\\mathcal{S}</span>  and a real execution of the protocol  <span class="math">\\Pi_{\\mathrm{Exp}}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In the first round  <span class="math">\\mathcal{S}</span>  receives  <span class="math">s_i</span>  for  <span class="math">i \\in A</span> , as the corrupt parties' inputs to the  <span class="math">\\mathcal{F}_{\\mathrm{ABB - Share}}</span>  command.  <span class="math">\\mathcal{S}</span>  calls  <span class="math">\\mathcal{F}_{\\mathrm{ABB - Exp}}</span>  with  <span class="math">(\\exp, [s])</span>  and receives  <span class="math">y = g^s</span> . Then  <span class="math">\\mathcal{S}</span>  samples  <span class="math">s_i \\stackrel{R}{\\leftarrow} \\mathbb{F}_p</span>  and sets  <span class="math">y_i = g^{s_i}</span>  for all  <span class="math">i \\notin A</span> .  <span class="math">\\mathcal{S}</span>  modifies one honest party's share  <span class="math">y_i</span>  to  <span class="math">g^s \\prod_{j \\neq i} y_j^{-1}</span> ,</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The parties call  <span class="math">\\mathcal{F}_{\\mathrm{ABB}}</span>  with command (Share, [s]), so that each party  <span class="math">P_{i}</span>  obtains an additive share  <span class="math">s_i\\in \\mathbb{F}_p</span></li>

      <li>Each party  <span class="math">P_{i}</span>  broadcasts  <span class="math">y_{i} = g^{s_{i}}</span></li>

      <li>Compute  <span class="math">y = \\prod_{i}y_{i}</span></li>

      <li>Take a random shared  <span class="math">[r]</span> , and compute  <span class="math">[t] = [r] \\cdot [s]</span></li>

      <li>Call  <span class="math">\\mathcal{F}_{\\mathrm{ABB}}</span>  with (Share, [t]) so that each  <span class="math">P_{i}</span>  obtains  <span class="math">t_i</span> . Broadcast  <span class="math">z_{i} = g^{t_{i}}</span></li>

      <li>Open  <span class="math">[r]</span>  and check that  <span class="math">\\prod_{i}z_{i} = y^{r}</span></li>

      <li>Output  <span class="math">y</span></li>

    </ol>

    <p class="text-gray-300">Let  <span class="math">G = \\langle g \\rangle</span>  be a group of prime order  <span class="math">p</span> . This functionality has all of the features of  <span class="math">\\mathcal{F}_{\\mathrm{ABB}}</span>  (running in  <span class="math">\\mathbb{F}_p</span> ), plus the following command:</p>

    <p class="text-gray-300">PubExp: On receiving  <span class="math">(\\exp, [s])</span>  from all parties, where  <span class="math">s</span>  is stored in memory, retrieve  <span class="math">s</span> , then send  <span class="math">y = g^s</span>  to the adversary and wait for a response. If the adversary responds with Deliver then send  <span class="math">y</span>  to all parties. Otherwise output  <span class="math">\\perp</span>  to all parties.</p>

    <p class="text-gray-300">Figure 5: Ideal functionality for public exponentiation</p>

    <p class="text-gray-300">then sends  <span class="math">y_{i}</span>  for all  <span class="math">i \\notin A</span>  to the adversary and gets back the corrupted parties' response  <span class="math">y_{i}^{*}</span> , for  <span class="math">i \\in A</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Proceed similarly to the previous step:  <span class="math">\\mathcal{S}</span>  samples  <span class="math">r_i \\stackrel{R}{\\leftarrow} \\mathbb{F}_p</span> , sets  <span class="math">z_i = y_i^{r_i}</span>  such that  <span class="math">\\prod_{i} z_i = y^r</span> . Sends  <span class="math">z_i</span>  to  <span class="math">\\mathcal{A}</span>  on behalf of the honest parties. Receives back corrupted parties  <span class="math">z_i^*</span> .</li>

      <li>Sends  <span class="math">r \\gets \\sum_{i} r_{i}</span>  to the adversary.  <span class="math">S</span>  performs the checking phase with  <span class="math">z_{i}^{*}</span>  from  <span class="math">\\mathcal{A}</span>  and the honest  <span class="math">z_{i}</span> . If the check passes send Deliver to  <span class="math">\\mathcal{F}_{\\mathrm{ABB - Exp}}</span> .</li>

    </ul>

    <p class="text-gray-300">The indistinguishability argument follows from the fact that all broadcasted values  <span class="math">g^{s_i}</span>  by  <span class="math">S</span>  and the real protocol  <span class="math">\\Pi_{\\mathrm{Exp}}</span>  have uniform distribution over  <span class="math">\\mathbb{F}_p</span>  with output in  <span class="math">\\mathbb{G}</span>  with respect to  <span class="math">\\prod_{i} g^{s_i} = g^s</span> .</p>

    <p class="text-gray-300">Correctness is straightforward if all parties follow the protocol. An adversary  <span class="math">\\mathcal{A}</span>  wins if it changes the distribution of the functionality to output Deliver. Alas, this happens with negligible probability:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose a corrupt party  <span class="math">P_{j}</span>  sends  <span class="math">y_{j}^{<em>}</span>  instead of  <span class="math">y_{j} = g^{s_{j}}</span> . We can write  <span class="math">y_{j}^{</em>} = g^{s_{j}} \\cdot e</span> , for some error  <span class="math">e \\neq 1 \\in \\mathbb{G}</span> , and so  <span class="math">y = g^{s} \\cdot e</span> . Then the check passes if  <span class="math">\\mathcal{A}</span>  can come up with  <span class="math">z_{j}^{<em>}</span>  such that  <span class="math">\\prod_{i} z_{i} = g^{rs} \\cdot e^{r}</span> . Writing  <span class="math">z_{j}^{</em>} = z_{j} \\cdot f</span> , this is equivalent to coming up with  <span class="math">f \\in \\mathbb{G}</span>  such that  <span class="math">f = e^{r}</span> . Since  <span class="math">r</span>  is uniformly random and unknown to the adversary at the time of choosing  <span class="math">e</span>  and  <span class="math">f</span> , passing this check can only happen with probability  $1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Note that this requires  </span>\\mathbb{G}<span class="math">  to be of prime order, so that  </span>e<span class="math">  (which is adversarially chosen) is always a generator of  </span>\\mathbb{G}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">When using the SPDZ MPC protocol with the secret-shared MAC representation from [25], we can save performing the</p>

    <p class="text-gray-300">multiplication <span class="math">[t] = [r] \\cdot [s]</span>. Instead, we can take the shared MAC value <span class="math">[m]</span> (on the shared <span class="math">s</span>), which satisfies <span class="math">m = s \\cdot \\alpha</span> for a shared MAC key <span class="math">\\alpha</span>, and use <span class="math">[m]</span> and <span class="math">[\\alpha]</span> in place of <span class="math">[t]</span> and <span class="math">[r]</span>. However, in this case <span class="math">\\alpha</span> cannot be made public, otherwise all future MACs could be forged. Instead, steps 4-6 are replaced with:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Each party commits to <span class="math">z_{i} = y^{\\alpha_{i}} \\cdot g^{-m_{i}}</span>.</li>

      <li>All parties open their commitments and check that <span class="math">\\prod_{i} z_{i} = 1</span>.</li>

    </ul>

    <p class="text-gray-300">If the parties are honest, we have <span class="math">z_{i} = g^{s \\cdot \\alpha_{i} - m_{i}}</span>, so the check will pass. Since in SPDZ, the honest parties' MAC shares <span class="math">m_{i}</span> are uniformly random, the shares of <span class="math">\\alpha_{i}</span> are perfectly masked by the <span class="math">g^{-m_i}</span> factor in <span class="math">z_{i}</span>, so no information on <span class="math">\\alpha</span> is leaked. The main difference here is that the parties must commit to the <span class="math">z_{i}</span> shares before opening, to prevent a rushing adversary from waiting and forcing the product to always be 1. The number of rounds and exponentiations is the same, but one multiplication is saved compared with the previous protocol.</p>

    <h2 id="sec-21" class="text-2xl font-bold">3.3 Secure Computation of Naor-Reingold</h2>

    <p class="text-gray-300">Protocol <span class="math">\\Pi_{\\mathsf{NR}}</span></p>

    <p class="text-gray-300">KeyGen: Call <span class="math">\\mathcal{F}_{\\mathrm{ABB}}</span>. Random to generate <span class="math">n + 1</span> random keys <span class="math">[k_0] \\ldots [k_n]</span>.</p>

    <p class="text-gray-300">Eval: To evaluate <span class="math">F_{\\mathsf{NR}(n)}(k,x)</span> on input <span class="math">[x]</span> with key <span class="math">[k]</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Bit decompose <span class="math">[x]</span> into <span class="math">[x_1]\\ldots [x_n]</span>.</li>

      <li>Compute <span class="math">[s] = [k_0]\\cdot \\prod_{i = 1}^{n}([k_i][x_i] + (1 - [x_i])</span> (see text for details).</li>

      <li>Call <span class="math">\\mathcal{F}_{\\mathrm{ABB - Exp}}</span> on input <span class="math">[s]</span>.</li>

    </ol>

    <p class="text-gray-300">Figure 6: Computing <span class="math">F_{\\mathsf{NR}(n)}(\\mathbf{k}, \\mathbf{x})</span></p>

    <p class="text-gray-300">Given the protocol for public exponentiation, it is straightforward to evaluate the Naor-Reingold PRF with public output when given a bit-decomposed, secret-shared input <span class="math">[x_1],\\ldots ,[x_n]</span> and key <span class="math">[k_0],\\ldots ,[k_n]</span>. First compute</p>

    <div class="my-4 text-center"><span class="math-block">[ s ] = [ k _ {0} ] \\cdot \\prod_ {i = 1} ^ {n} ([ x _ {i} ] \\cdot [ k _ {i} ] + (1 - [ x _ {i} ]))</span></div>

    <p class="text-gray-300">using <span class="math">\\mathcal{F}_{\\mathrm{ABB}}</span>, and then use <span class="math">\\Pi_{\\mathrm{Exp}}</span> to obtain <span class="math">g^{s}</span>.</p>

    <p class="text-gray-300">The product can be computed in <span class="math">\\lceil \\log_2n + 1\\rceil</span> rounds using a standard binary tree evaluation. Alternatively, we can obtain a constant (4) rounds protocol using the prefix multiplication protocol of Catrina and de Hoogh [15], (which is an optimized variant of the trick of Bar-Ilan and Beaver [5]) at the expense of <span class="math">2(n + 1)</span> additional multiplications.</p>

    <p class="text-gray-300">Security of the <span class="math">\\Pi_{\\mathsf{NR}}</span> protocol is straightforward, since there is no interaction outside of the arithmetic black box functionality.</p>

    <h2 id="sec-22" class="text-2xl font-bold">Handling Input in <span class="math">\\mathbb{F}_p</span></h2>

    <p class="text-gray-300">If the input is given as a field element rather than in bit-decomposed form, then we must first run a bit decomposition protocol, such as that of Catrina and de Hoogh [15] or Damgård et al. [21]. The latter works for arbitrary values of <span class="math">x</span>, whilst the former is more efficient, but requires <span class="math">x</span> is <span class="math">\\ell</span> bits long, where <span class="math">p &amp;gt; 2^{\\ell + \\kappa}</span> for statistical security <span class="math">\\kappa</span>.</p>

    <h2 id="sec-23" class="text-2xl font-bold">Complexity</h2>

    <p class="text-gray-300">For the logarithmic rounds variant based on SPDZ, with <span class="math">n</span>-bit input that is already bit decomposed, the protocol requires <span class="math">2n</span> multiplications of secret values and three exponentiations, in a total of <span class="math">\\lceil \\log_2n + 1\\rceil +3</span> rounds. The constant rounds variant takes <span class="math">4n + 2</span> multiplications in 7 rounds. Note that there is a higher cost for the secure multiplications, as we require an MPC protocol operating over <span class="math">\\mathbb{F}_p</span> for a 256-bit prime <span class="math">p</span> (for 128-bit security), whereas our other PRF protocols only require MPC operations in 128-bit fields.</p>

    <h2 id="sec-24" class="text-2xl font-bold">3.4 Performance</h2>

    <p class="text-gray-300">The main advantage of this PRF is the small number of rounds required, which leads to a low latency in our benchmarks (4.4ms over LAN). However, the high computation cost (for EC operations) slows down performance and results in a low throughput. We found that with a 256-bit prime <span class="math">p</span> and <span class="math">n = 128</span>, the logarithmic rounds variant outperformed the constant rounds protocol in all measures in a LAN environment. In a WAN setting, the constant round protocol achieves a lower latency, but is worse for throughput and preprocessing time.</p>

    <h2 id="sec-25" class="text-2xl font-bold">4. PRF FROM THE LEGENDRE SYMBOL</h2>

    <p class="text-gray-300">In this section we consider a PRF based on the Legendre symbol, which to the best of our knowledge was first described in [44]. Whilst this PRF is very inefficient when applied to cleartext data, we show that with secret-shared data in the MPC setting it allows for a very simple protocol.</p>

    <h2 id="sec-26" class="text-2xl font-bold">4.1 <span class="math">F_{\\mathrm{Leg}}</span> Definition</h2>

    <p class="text-gray-300">In 1988, Damgård proposed using the sequence of Legendre symbols with respect to a large prime <span class="math">p</span> as a pseudorandom generator [20]. He conjectured that the sequence</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\frac {k}{p}\\right), \\left(\\frac {k + 1}{p}\\right), \\left(\\frac {k + 2}{p}\\right), \\ldots</span></div>

    <p class="text-gray-300">is pseudorandom, when starting at a random seed <span class="math">k</span>. Although there have been several works studying the statistical uniformity of this sequence, perhaps surprisingly, there has been very little research on cryptographic applications since Damgård's paper. Damgård also considered variants with the Jacobi symbol, or where <span class="math">p</span> is secret, but these seem less suitable for our application to MPC.</p>

    <p class="text-gray-300">We first normalize the Legendre symbol to be in <span class="math">\\{0,1,(p + 1) / 2\\}</span>, by defining:</p>

    <div class="my-4 text-center"><span class="math-block">L _ {p} (a) = \\frac {1}{2} \\left(\\left(\\frac {a}{p}\\right) + 1\\right) \\quad (\\mathrm {m o d} p).</span></div>

    <p class="text-gray-300">We now define the corresponding pseudorandom function (as in [44]) as</p>

    <div class="my-4 text-center"><span class="math-block">F _ {\\text {L e g (b i t)}} (k, x) = L _ {p} (k + x)</span></div>

    <p class="text-gray-300">for <span class="math">k, x \\in \\mathbb{F}_p</span>, where <span class="math">p \\approx 2^{\\lambda}</span> is a public prime. The security of this PRF is based on the following two problems:</p>

    <p class="text-gray-300">Definition 1 (Shifted Legendre Symbol Problem). Let <span class="math">k</span> be uniformly sampled from <span class="math">\\mathbb{F}_p</span>, and define <span class="math">\\mathcal{O}_{\\mathrm{Leg}}</span> to be an oracle that takes <span class="math">x \\in \\overline{\\mathbb{F}_p}</span> and outputs <span class="math">\\left(\\frac{k + x}{p}\\right)</span>. Then the Shifted Legendre Symbol (SLS) problem is to find <span class="math">k</span>, with non-negligible probability.</p>

    <p class="text-gray-300">Definition 2 (Decisional Shifted Legendre Symbol Problem). Let  <span class="math">\\mathcal{O}_{\\mathrm{Leg}}</span>  be defined as above, and let  <span class="math">\\mathcal{O}_{\\mathbb{R}}</span>  be a random oracle that takes values in  <span class="math">\\mathbb{F}_p</span>  and produces outputs in  <span class="math">\\{-1,1\\}</span> . The Decisional Shifted Legendre Symbol (DSLS) problem is to distinguish between  <span class="math">\\mathcal{O}_{\\mathrm{Leg}}</span>  and  <span class="math">\\mathcal{O}_{\\mathbb{R}}</span>  with nonnegligible advantage.</p>

    <p class="text-gray-300">The following proposition is then immediate.</p>

    <p class="text-gray-300">Proposition 1. The function  <span class="math">F_{\\mathrm{Leg(bit)}}</span>  is a pseudorandom function if there is no probabilistic polynomial time algorithm for the DSLS problem.</p>

    <p class="text-gray-300">The SLS problem has received some attention from the mathematical community, particularly in the quantum setting. We briefly survey some known results below.</p>

    <p class="text-gray-300">A naive algorithm for deterministically solving the SLS problem is to compute  <span class="math">\\left(\\frac{k + x}{p}\\right)</span>  for all  <span class="math">(k,x)\\in \\mathbb{F}_p^2</span>  and compare these with  <span class="math">\\mathcal{O}_{\\mathrm{Leg}}(x)</span>  for all  <span class="math">x\\in \\mathbb{F}_p</span> , which requires  <span class="math">\\tilde{O} (p^{2})</span>  binary operations. Russell and Shparlinski [42] described a more sophisticated algorithm using Weil's bound on exponential sums, which reduces this to  <span class="math">\\tilde{O} (p)</span> .</p>

    <p class="text-gray-300">Van Dam, Hallgren and Ip [44] described a quantum polynomial time algorithm for the SLS problem that recovers the secret  <span class="math">k</span>  if the oracle can be queried on a quantum state. They conjectured that classically, there is no polynomial time algorithm for this problem. Russell and Shparlinski [42] also extended this quantum algorithm to a generalization of the problem where the secret is a polynomial, rather than just a linear shift.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">One can also consider another generalization called the hidden shifted power problem, where the oracle returns  <span class="math">(k + x)^{e}</span>  for some (public) exponent  $e</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(p - 1)<span class="math"> . The SLS problem is a special case where  </span>e = (p - 1) / 2<span class="math"> . Vercauteren [45] called this the hidden root problem and described efficient attacks over small characteristic extension fields, with applications to fault attacks on pairings-based cryptography. Bourgain et al. [12] showed that if  </span>e = p^{1 - \\delta}<span class="math">  for some  </span>\\delta &gt; 0<span class="math">  then this problem has classical query complexity  </span>O(1)<span class="math"> . Note that neither of these attacks apply to the SLS problem, which cannot be solved with fewer than  </span>\\Omega (\\log p)$  queries [43].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In conclusion, we are not currently aware of any classical algorithms for the SLS problem in better than  <span class="math">\\tilde{O}(p)</span>  time, nor of any method for solving the DSLS problem without first recovering the secret. We note that unlike discrete log and factoring, it is still an open question as to whether there are even efficient quantum algorithms if the SLS oracle can only be queried classically.</p>

    <p class="text-gray-300">It turns out that  <span class="math">F_{\\mathrm{Leg(bit)}}</span>  can be evaluated in MPC very efficiently, at roughly the cost of just 2 multiplications in 3 rounds of communication. Although this only produces a single bit of output, composing together multiple instances in parallel with independent keys allows larger outputs to be obtained (see later).</p>

    <p class="text-gray-300">We first describe how to evaluate  <span class="math">F_{\\mathrm{Leg(bit)}}</span>  when the output is public, and then show how to extend this to secret-shared output, with only a small cost increase.</p>

    <p class="text-gray-300">Suppose we have a shared, non-zero  <span class="math">[a]</span>  and want to compute the public output,  <span class="math">L_{p}(a)</span> . Since the output is public, we can simply take a random preprocessed non-zero square  <span class="math">[s^2]</span> , compute  <span class="math">[c] = [s^2] \\cdot [a]</span>  and open  <span class="math">c</span> . By the multiplicativity of the Legendre symbol,  <span class="math">L_{p}(c) = L_{p}(a)</span> .</p>

    <p class="text-gray-300">By composing the PRF  <span class="math">n</span>  times in parallel, this gives an  <span class="math">n</span> -bit output PRF that we can evaluate in MPC with just  <span class="math">n</span>  multiplications and  <span class="math">n</span>  openings in two rounds. The preprocessing requires  <span class="math">n</span>  random squares and multiplication triples.</p>

    <p class="text-gray-300">Now suppose we instead want shared output,  <span class="math">[L_p(a)]</span> . If we have a random non-zero value  <span class="math">[t]</span> , and also the shared value  <span class="math">[L_p(t)]</span> , then this is easy. Just open  <span class="math">[a] \\cdot [t]</span> , and compute the Legendre symbol of this to get  <span class="math">c = L_p(a \\cdot t)</span> . The shared value  <span class="math">[L_p(a)]</span>  can then be computed locally using  <span class="math">c</span>  and  <span class="math">[L_p(t)]</span> , as  <span class="math">c</span>  is public.</p>

    <p class="text-gray-300">Generating a random value with a share of its Legendre symbol can be done very cheaply. Our key observation is that we can do this without having to compute any Legendre symbols in MPC. Let  <span class="math">\\alpha \\in \\mathbb{Z}_p</span>  be a (public) quadratic non-residue, and perform the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Take a random square  <span class="math">[s^2]</span>  and a random bit  <span class="math">[b]</span> .</li>

      <li>Output  <span class="math">(2[b] - 1, [b] \\cdot [s^2] + (1 - [b]) \\cdot \\alpha \\cdot [s^2])</span></li>

    </ul>

    <p class="text-gray-300">Note that since  <span class="math">\\alpha</span>  is a non-square, the second output value is clearly either a square or non-square based on the value of the random bit  <span class="math">b</span>  (which is mapped into  <span class="math">\\{-1,1\\}</span>  by computing  <span class="math">2 \\cdot b - 1</span> ). Finally, note that since  <span class="math">s^2</span>  provides fresh randomness each time,  <span class="math">\\alpha</span>  can be reused for every PRF evaluation. This gives us the protocol in Figure 7, which realizes the functionality  <span class="math">\\mathcal{F}_{\\mathrm{ABB - Leg}}</span>  shown in Figure 8. Notice that all bar the computation of  <span class="math">u</span>  can be performed in a preprocessing phase if needed.</p>

    <p class="text-gray-300">Let  <span class="math">\\alpha</span>  be a fixed, quadratic non-residue modulo  <span class="math">p</span> .</p>

    <p class="text-gray-300">KeyGen: Call  <span class="math">\\mathcal{F}_{\\mathrm{ABB}}</span> . Random to generate a random key  <span class="math">[k]</span> .</p>

    <p class="text-gray-300">Eval: To evaluate  <span class="math">F_{\\mathrm{Leg(bit)}}</span>  on input  <span class="math">[x]</span>  with key  <span class="math">[k]</span> :</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Take a random square  <span class="math">[s^2]</span>  and a random bit  <span class="math">[b]</span></li>

      <li><span class="math">[t] \\gets [s^2] \\cdot ([b] + \\alpha \\cdot (1 - [b]))</span></li>

      <li><span class="math">u\\gets \\mathsf{Open}([t]\\cdot ([k] + [x]))</span></li>

      <li>Output  <span class="math">[y] \\gets \\left(\\binom{n}{p} \\cdot (2[b] - 1) + 1\\right)/2</span></li>

    </ol>

    <p class="text-gray-300">Figure 7: Securely computing the  <span class="math">F_{\\mathrm{Leg(bit)}}</span>  PRF with secret-shared output</p>

    <p class="text-gray-300">At first glance, the security of the protocol appears straightforward: since  <span class="math">t</span>  and  <span class="math">k</span>  are uniformly random, the opened value  <span class="math">u</span>  should be simulatable by a random value, and this will be correct except with probability  <span class="math">1 / p</span>  (if  <span class="math">s^2 = 0</span> ). However, proving this turns out to be more tricky. We need to take into account that if  <span class="math">x = -k</span>  then the protocol causes  <span class="math">u = 0</span>  to be opened, but in the ideal world the simulator does not know  <span class="math">k</span>  so cannot simulate this. This reflects the</p>

    <p class="text-gray-300">fact that an adversary who solves the SLS problem can find <span class="math">k</span> and run the protocol with <span class="math">x = -k</span>. Therefore, we need to assume hardness of the SLS problem and show that any environment that distinguishes the two worlds (by causing <span class="math">x = -k</span> to be queried) can be used to recover the key <span class="math">k</span>. The reduction must use the SLS oracle, <span class="math">\\mathcal{O}_{\\mathrm{Leg}}</span>, to detect whether <span class="math">x = -k</span>, in order to simulate the <span class="math">u</span> value to the environment. To do this, they simply obtain the value <span class="math">y = \\left(\\frac{x + k}{p}\\right)</span> from <span class="math">\\mathcal{O}_{\\mathrm{Leg}}</span> and check whether <span class="math">y = 0</span>, for each Eval query made by the adversary.</p>

    <h2 id="sec-33" class="text-2xl font-bold">Functionality <span class="math">\\mathcal{F}_{\\mathrm{ABB - Leg}}</span></h2>

    <p class="text-gray-300">This functionality has all of the same commands as <span class="math">\\mathcal{F}_{\\mathrm{ABB}}</span>, plus the following:</p>

    <p class="text-gray-300"><strong>KeyGen:</strong> On receiving (keygen) from all parties, sample <span class="math">k \\stackrel{R}{\\leftarrow} \\mathbb{F}_p</span> and store <span class="math">k</span>.</p>

    <p class="text-gray-300"><strong>PRF:</strong> On receiving (legendre, [x]) from all parties, where <span class="math">x</span> is stored in memory, compute <span class="math">y = L_p(x + k)</span> and store <span class="math">y</span> in memory.</p>

    <p class="text-gray-300">Figure 8: Ideal functionality for the Legendre symbol PRF, <span class="math">F_{\\mathrm{Leg(bit)}}</span></p>

    <p class="text-gray-300">Theorem 2. The protocol <span class="math">\\Pi_{\\mathrm{Legendre}}</span> securely computes the functionality <span class="math">\\mathcal{F}_{\\mathrm{ABB - Leg}}</span> in the <span class="math">\\mathcal{F}_{\\mathrm{ABB}}</span>-hybrid model, if the SLS problem is hard.</p>

    <p class="text-gray-300">Proof. We construct a simulator <span class="math">\\mathcal{S}</span> such that no environment <span class="math">\\mathcal{Z}</span> corrupting up to <span class="math">n - 1</span> parties can distinguish between the real protocol <span class="math">\\Pi_{\\mathrm{Legendre}}</span>, and <span class="math">\\mathcal{S}</span> interacting with the ideal functionality <span class="math">\\mathcal{F}_{\\mathrm{ABB - Leg}}</span>.</p>

    <p class="text-gray-300">In the KeyGen stage, <span class="math">\\mathcal{S}</span> simply calls <span class="math">\\mathcal{F}_{\\mathrm{ABB - Leg}}</span> with the keygen command. In the Eval stage, the main task of <span class="math">\\mathcal{S}</span> is to simulate the opened value <span class="math">u</span>, which is done by sampling <span class="math">u \\stackrel{R}{\\leftarrow} \\mathbb{F}_p</span>, and then call <span class="math">\\mathcal{F}_{\\mathrm{ABB - Leg}}</span> with (legendre, [x]).</p>

    <p class="text-gray-300">We now argue indistinguishability of the two executions. In the real world, since <span class="math">t</span> is computed as <span class="math">s^2 \\cdot (b + (1 - b) \\cdot \\alpha)</span> for a uniform quadratic residue <span class="math">s^2</span> and random bit <span class="math">b</span>, then <span class="math">t</span> is uniform in <span class="math">\\mathbb{F}_p</span>. This is because the map defined by multiplication by <span class="math">\\alpha</span> is a bijection between the sets of squares and non-squares modulo <span class="math">p</span>. Therefore, if <span class="math">s^2</span> is a uniformly random square, then <span class="math">\\alpha \\cdot s^2</span> is a uniformly random non-square.</p>

    <p class="text-gray-300">Now, since <span class="math">t</span> is a fresh uniformly random value on each evaluation, the real world value <span class="math">u</span> and output <span class="math">y</span>, as seen by <span class="math">\\mathcal{Z}</span>, will be identically distributed to the simulated values as long as <span class="math">k + x \\neq 0</span> and <span class="math">s \\neq 0</span>. Whenever the former happens in the real world <span class="math">u = 0</span> is opened, whereas the ideal world still simulates a random value, so the environment can distinguish. In the latter case, <span class="math">s = 0</span>, the output <span class="math">y</span> will be incorrectly computed in the real world, but this can only happen with probability <span class="math">1/p</span>.</p>

    <p class="text-gray-300">However, any environment <span class="math">\\mathcal{Z}</span> that causes <span class="math">k + x = 0</span> to happen with non-negligible probability can be used to construct an algorithm <span class="math">\\mathcal{A}^*</span> that breaks the SLS problem, as follows.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{A}^<em></span> runs <span class="math">\\mathcal{Z}</span>, emulating a valid execution of <span class="math">\\Pi_{\\mathrm{Legendre}}</span> by replacing <span class="math">L_{p}(x + k)</span> computation with calls to <span class="math">\\mathcal{O}_{\\mathrm{Leg}_k}</span>. These modified transcripts have the same distribution since the SLS oracle and (keygen) both generate a random key. When <span class="math">\\mathcal{A}^</em></span> runs <span class="math">\\mathcal{Z}</span> internally, it knows the inputs provided by <span class="math">\\mathcal{Z}</span> to all parties, so knows the <span class="math">x</span> value on each invocation of <span class="math">\\Pi_{\\mathrm{Legendre}}</span>. Once <span class="math">\\mathcal{Z}</span> constructs a query for which <span class="math">\\mathcal{O}_{\\mathrm{Leg}_k}</span> returns</p>

    <p class="text-gray-300">0 then <span class="math">\\mathcal{A}^*</span> responds to the SLS challenge with <span class="math">k = -x</span>. Finally, the algorithm looks like this:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Interact with <span class="math">\\mathcal{Z}</span> as the simulator <span class="math">\\mathcal{S}</span> would do.</li>

      <li>Instead of computing the Legendre symbol <span class="math">L_{p}(x + k)</span> as in <span class="math">\\mathcal{F}_{\\mathrm{ABB - Leg}}</span>, make a call to <span class="math">\\mathcal{O}_{\\mathrm{Leg}_k}</span>.</li>

      <li>If <span class="math">\\mathcal{O}_{\\mathrm{Leg}_k}(x) = 0</span>, return <span class="math">-x</span> as the SLS secret.</li>

    </ol>

    <p class="text-gray-300">The only way <span class="math">\\mathcal{Z}</span> can distinguish between <span class="math">\\mathcal{S}</span> and <span class="math">\\Pi_{\\mathrm{Legendre}}</span> — except with probability <span class="math">1/p</span> — is by producing a query <span class="math">x</span> for which <span class="math">\\mathcal{O}_{\\mathrm{Leg}_k}(x) = 0</span>, since the two worlds are statistically close up until this point. If <span class="math">\\mathcal{Z}</span> can do this with probability <span class="math">\\epsilon</span> then the probability that <span class="math">\\mathcal{A}^*</span> solves the SLS problem is the same.</p>

    <p class="text-gray-300">Overall, <span class="math">\\mathcal{S}</span> correctly simulates the protocol <span class="math">\\Pi_{\\mathrm{Legendre}}</span> as long as <span class="math">u \\neq 0</span>, which happens with probability <span class="math">\\leq 1/p + \\epsilon</span> (<span class="math">s = 0</span> or solving SLS with probability <span class="math">\\epsilon</span>).</p>

    <h2 id="sec-34" class="text-2xl font-bold">Perfect Correctness.</h2>

    <p class="text-gray-300">The basic protocol above is only statistically correct, as <span class="math">s^2 = 0</span> with probability <span class="math">1/p</span>, and if this occurs the output will always be zero. Although this suffices for most applications, we note that perfect correctness can be obtained, at the expense of a protocol that runs in expected constant rounds. We can guarantee that the square <span class="math">s^2</span> is non-zero by computing it as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Take a random square <span class="math">[s^2]</span> and a random value <span class="math">[y]</span>.</li>

      <li>Compute <span class="math">[v] = [y \\cdot s^2]</span> and open <span class="math">v</span>. If <span class="math">v = 0</span> then return to the first step.</li>

    </ul>

    <p class="text-gray-300">Note, that the iteration of the first step only happens if <span class="math">y = 0</span> or <span class="math">s = 0</span>, which occurs with probability <span class="math">2/p</span>, so the expected number of rounds for this stage of the protocol is one.</p>

    <h2 id="sec-35" class="text-2xl font-bold">4.4 Domain and Codomain Extension</h2>

    <p class="text-gray-300">Some applications may require a PRF which takes multiple finite field elements as input, and outputs a finite field element. We now present how to extend the basic PRF <span class="math">F_{\\mathrm{Leg(bit)}}</span> to a function which takes messages consisting of <span class="math">n</span> finite field elements and outputs a single uniformly random finite field element. Indeed our input could consist of up to <span class="math">t</span> elements in the finite field where <span class="math">t \\leq n</span>. In practice we will take <span class="math">n = 1</span> or 2, and can then extend to larger lengths using CBC-mode or Merkle-Damgård (as in Section 1.5).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We first define a statistical security parameter <span class="math">2^{-\\mathrm{stat}}</span>, which bounds the statistical distance from uniform of the output of our PRF. We let define <span class="math">p&#x27;</span> to be the nearest power of two to the prime <span class="math">p</span> and set $\\alpha =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p - p'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Then if </span>\\alpha / p &lt; 2^{-\\mathrm{stat}}<span class="math"> we set </span>\\ell = \\lceil \\log_2 p \\rceil<span class="math">, otherwise we set </span>\\ell = \\lceil \\log_2 p \\rceil + \\mathrm{stat}$. A standard argument will then imply that the following PRF outputs values with the correct distribution.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The key for the PRF is going to be an <span class="math">\\ell \\times (n + 1)</span> matrix <span class="math">K</span> of random elements in <span class="math">\\mathbb{F}_p</span>, except (for convenience) that we fix the first column to be equal to one. To apply the PRF to a vector of elements <span class="math">\\mathbf{x} = (x_1, \\ldots, x_t)</span> we "pad" <span class="math">\\mathbf{x}</span> to a vector of <span class="math">n + 1</span> elements as follows <span class="math">\\mathbf{x}&#x27; = (x_1, \\ldots, x_t, 0, \\ldots, 0, t)</span> and then product the matrix-vector product <span class="math">\\mathbf{y} = K \\cdot \\mathbf{x}&#x27; \\in (\\mathbb{F}_p)^t</span>. The output of <span class="math">F_{\\mathrm{Leg}(n)}</span> is then given by</p>

    <div class="my-4 text-center"><span class="math-block">F _ {\\operatorname {L e g} (n)} (K, \\mathbf {x}) = \\left(\\sum_ {i = 0} ^ {\\ell - 1} 2 ^ {i} \\cdot L _ {p} \\left(y _ {i}\\right)\\right) \\quad (\\mathrm {m o d} p).</span></div>

    <p class="text-gray-300">This extended PRF requires one extra round of <span class="math">\\ell\\cdot(n-1)</span> secure multiplications compared to <span class="math">F_{\\text{Lsg(bit)}}</span>.</p>

    <p class="text-gray-300">Since the matrix <span class="math">K</span> is compressing, the distribution of <span class="math">\\mathbf{y}</span> will act, by the leftover hash lemma, as a random vector in <span class="math">\\mathbb{F}_{p}^{\\ell}</span>. With probability <span class="math">\\ell/p</span> we have <span class="math">y_{i}\\neq 0</span> for all <span class="math">i</span>, which implies that the values of <span class="math">L_{p}(y_{i})</span> behave as uniform random bits, assuming our previous conjectures on the Legendre symbol. Thus the output value of <span class="math">F_{\\text{Lsg}(n)}(K,\\mathbf{x})</span> will, by choice of <span class="math">\\ell</span>, have statistical distance from uniform in <span class="math">\\mathbb{F}_{p}</span> bounded by <span class="math">2^{-\\text{stat}}</span>.</p>

    <p class="text-gray-300">Our choice of padding method, and the choice of the first matrix column to be equal to one, is to ensure that in the case of <span class="math">n=1</span> we have</p>

    <p class="text-gray-300"><span class="math">F_{\\text{Lsg}(n)}(K,\\mathbf{x})=\\left(\\sum_{i=0}^{\\ell-1}2^{i}\\cdot F_{\\text{Lsg(bit)}}(k_{i},y_{i})\\right)\\pmod{p}.</span></p>

    <p class="text-gray-300">In addition the padding method ensures protection against length extension attacks.</p>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">4.5 Performance</h3>

    <p class="text-gray-300">We measured performance using the prime <span class="math">p=2^{127}+45</span>, which implied for <span class="math">F_{\\text{Lsg}(n)}</span> we could take <span class="math">\\ell=128</span>. Both <span class="math">F_{\\text{Lsg(bit)}}</span> and <span class="math">F_{\\text{Lsg}(1)}</span> obtain very low latencies (0.35ms and 1.2ms over LAN, respectively) due to the low number of rounds. For a PRF with small outputs, <span class="math">F_{\\text{Lsg(bit)}}</span> achieves by far the highest throughput, with over 200000 operations per second. For full field element outputs, <span class="math">F_{\\text{Lsg}(1)}</span> is around 128 times slower, but still outperforms AES in all metrics except for cleartext computation.</p>

    <h2 id="sec-37" class="text-2xl font-bold">5 MIMC</h2>

    <h3 id="sec-38" class="text-xl font-semibold mt-8">5.1 <span class="math">F_{\\text{MimC}}</span> Definition</h3>

    <p class="text-gray-300">MiMC is a comparatively simple block cipher design, where the plaintexts, the ciphertexts and the secret key are elements of <span class="math">\\mathbb{F}_{p}</span> and can be seen as a simplification of the KN-cipher<em>[40]</em>. Its design is aimed at achieving an efficient implementation over a field <span class="math">\\mathbb{F}_{p}</span> by minimizing computationally expensive field operations (e.g. multiplications or exponentiations).</p>

    <p class="text-gray-300">Let <span class="math">p</span> a prime that satisfies the condition <span class="math">\\gcd(3,p-1)=1</span>. For a message <span class="math">x\\in\\mathbb{F}_{p}</span> and a secret key <span class="math">k\\in\\mathbb{F}_{p}</span>, the encryption process of MiMC is constructed by iterating a round function <span class="math">r</span> times. At round <span class="math">i</span> (where <span class="math">0\\leq i&lt;r</span>), the round function <span class="math">F_{i}:\\mathbb{F}_{p}\\to\\mathbb{F}_{p}</span> is defined as:</p>

    <p class="text-gray-300"><span class="math">F_{i}(x)=(x+k+c_{i})^{3},</span></p>

    <p class="text-gray-300">where <span class="math">c_{i}</span> are random constants in <span class="math">\\mathbb{F}_{p}</span> (for simplicity <span class="math">c_{0}=c_{r}=0</span>). The output of the final round is added with the key <span class="math">k</span> to produce the ciphertext. Hence, the output of <span class="math">F_{\\text{MimC}}(x,k)</span> is then given by</p>

    <p class="text-gray-300"><span class="math">F_{\\text{MimC}}(x,k)=(F_{r-1}\\circ F_{r-2}\\circ...\\circ F_{0})(x)+k.</span></p>

    <p class="text-gray-300">The condition on <span class="math">p</span> ensures that the cubing function creates a permutation.</p>

    <p class="text-gray-300">The number of rounds for constructing the keyed permutation is given by <span class="math">r=\\lceil\\log_{3}p\\rceil</span> - for prime fields of size 128 bits the number of rounds is equal to <span class="math">r=82</span>. This number of round <span class="math">r</span> provides security against a variety of cryptanalytic techniques. In particular, due to the algebraic design principle of MiMC, the most powerful key recovery methods are the algebraic cryptanalytic attacks, as the Interpolation Attack and the GCD Attack. In the first one introduced by Jakobsen and Knudsen in <em>[30]</em>, the attacker constructs a polynomial corresponding to the encryption function without any knowledge of the secret key. In particular, the attacker guesses the key of the final round, constructs the polynomial at round <span class="math">r-1</span> and checks it with one extra plaintext/ciphertext pair. In the second one, given two plaintext/ciphertext pairs <span class="math">(p^{j},c^{j})</span> for <span class="math">j=1,2</span>, the attacker constructs the polynomials <span class="math">F_{\\text{MimC}}(p^{1},K)-c^{1}</span> and <span class="math">F_{\\text{MimC}}(p^{2},K)-c^{2}</span> in the fixed but unknown key <span class="math">K</span>. Since these two polynomials share <span class="math">(K-k)</span> as a factor (where <span class="math">k</span> is the secret key), the attacker can find the value of <span class="math">k</span> by computing the GCD of them.</p>

    <p class="text-gray-300">If the attacker has access to a limited number of plaintext/ciphertext pairs only (at most <span class="math">n&lt;p</span>), then the number of round <span class="math">r</span> can be reduced. In this case, the number of rounds is given by <span class="math">r=\\max\\{\\lceil\\log_{3}n\\rceil,\\lceil\\log_{3}p-2\\log_{3}(\\log_{3}p)\\rceil\\}</span> - for prime field of size 128 bits, the number of rounds is equal to <span class="math">r=73</span> if <span class="math">n\\leq 2^{115}</span>, while <span class="math">r=\\lceil\\log_{3}n\\rceil</span> otherwise.</p>

    <h3 id="sec-39" class="text-xl font-semibold mt-8">5.2 Computing <span class="math">F_{\\text{MimC}}</span> in MPC</h3>

    <p class="text-gray-300">We consider two different approaches for computing <span class="math">F_{\\text{MimC}}</span> in MPC, with a secret shared key and message. The basic approach is simplest, whilst the second variant has half the number of rounds of communication, with slightly more computation.</p>

    <h4 id="sec-40" class="text-lg font-semibold mt-6">MiMC^{basic}</h4>

    <p class="text-gray-300">The naive way to evaluate <span class="math">F_{\\text{MimC}}</span> requires one squaring and one multiplication for each of the <span class="math">r</span> rounds. Using SPDZ, the squaring costs one opening in one round of communication, and the multiplication costs two openings in one round, giving a total of <span class="math">3r</span> openings in <span class="math">2r</span> rounds of communication.</p>

    <h4 id="sec-41" class="text-lg font-semibold mt-6">MiMC^{cube}</h4>

    <p class="text-gray-300">If for each round we first compute a tuple (<span class="math">[r]</span>, <span class="math">[r^{2}]</span>, <span class="math">[r^{3}]</span>), where <span class="math">r\\stackrel{{\\scriptstyle R}}{{\\leftarrow}}\\mathbb{F}_{p}</span>, then given a secret-shared value <span class="math">[x]</span>, we can open <span class="math">y=x-r</span> and obtain a sharing of <span class="math">x^{3}</span> by the computation</p>

    <p class="text-gray-300"><span class="math">[x^{3}]=3y[r^{2}]+3y^{2}[r]+y^{3}+[r^{3}]</span></p>

    <p class="text-gray-300">which is linear in the secret-shared values so does not require interaction.</p>

    <p class="text-gray-300">For a single MiMC encryption, we first compute all of the cube triples for each round, which takes just one round of communication by taking a preprocessed random square pair (<span class="math">[r],[r^{2}])</span> and performing one multiplication to obtain <span class="math">[r^{3}]</span>. Each round of the cipher then requires just one opening and a small amount of interaction. The total communication complexity is still <span class="math">3r</span> openings, but in only <span class="math">r</span> rounds.</p>

    <h3 id="sec-42" class="text-xl font-semibold mt-8">5.3 Performance</h3>

    <p class="text-gray-300">Using <span class="math">r=73</span>, we measured a latency of 12ms per evaluation for the simple protocol MiMC^{basic}, which halves to 6ms for the lower round variant, MiMC^{cube}. MiMC^{basic} gives a very high throughput of over 8500 blocks per second (around 20% higher than MiMC^{cube}), and the offline cost is fairly low, at 34 blocks per second. In fact, apart from in latency, MiMC outperforms all the other PRFs we studied.</p>

    <h2 id="sec-43" class="text-2xl font-bold">6 PERFORMANCE EVALUATION</h2>

    <p class="text-gray-300">In this section, we evaluate the performance of the PRFs using the SPDZ multi-party computation protocol <em>[26, 25]</em>,</p>

    <p class="text-gray-300">which provides active security against any number of corrupted parties. We focus here on the two-party setting, although the protocol easily scales to any number of parties with roughly a linear cost.</p>

    <p class="text-gray-300">The two main metrics we use to evaluate performance are latency and throughput, both of which relate to the online phase of the SPDZ protocol. Latency measures the waiting time for a single PRF evaluation; the best possible latency is recorded by simply timing a large number of sequential executions of the PRF, and taking the average for one operation. In contrast, throughput is maximized by running many operations in parallel to reduce the number of rounds of communication. Of course, this comes at the expense of a higher latency, so a tradeoff must always be made depending on the precise application. In addition to latency and throughput, we present the cost of running the preprocessing phase and computing the PRF on cleartext data, for comparison.</p>

    <p class="text-gray-300">Implementation Details: We implemented the protocols using the architecture of Keller et al. [32], which runs the online phase of SPDZ. This system automatically uses the minimum number of rounds of communication for a given program description, by merging together all independent openings. We extended the software to use the Miracl library for elliptic curve operations over the NIST P-256 curve, as required for the Naor-Reingold protocol. Note that although the SPDZ implementation supports multi-threading, all of our online phase experiments are single-threaded to simplify the comparison.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Data type</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fp (ms)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F2128 (ms)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">128-bit</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">256-bit</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">LAN</td>

            <td class="px-3 py-2 border-b border-gray-700">Triple/Sq.</td>

            <td class="px-3 py-2 border-b border-gray-700">0.204</td>

            <td class="px-3 py-2 border-b border-gray-700">0.816</td>

            <td class="px-3 py-2 border-b border-gray-700">0.204</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Bit</td>

            <td class="px-3 py-2 border-b border-gray-700">0.204</td>

            <td class="px-3 py-2 border-b border-gray-700">0.816</td>

            <td class="px-3 py-2 border-b border-gray-700">0.00014</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">WAN</td>

            <td class="px-3 py-2 border-b border-gray-700">Triple/Sq.</td>

            <td class="px-3 py-2 border-b border-gray-700">4.150</td>

            <td class="px-3 py-2 border-b border-gray-700">16.560</td>

            <td class="px-3 py-2 border-b border-gray-700">4.150</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Bit</td>

            <td class="px-3 py-2 border-b border-gray-700">4.150</td>

            <td class="px-3 py-2 border-b border-gray-700">16.560</td>

            <td class="px-3 py-2 border-b border-gray-700">0.00285</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: Time estimates for generating preprocessing data in various fields using oblivious transfer.</p>

    <p class="text-gray-300">To estimate the cost of producing the preprocessing data (multiplication triples, random bits etc.), we used figures from the recent MASCOT protocol [31], which uses OT extensions to obtain what are currently the best reported triple generation times with active security. Although in [31], figures are only given for triple generation in a 128-bit field, we can also use these times for random square and random bit generation, since each of these can be easily obtained from one secret multiplication [21]. For the Naor-Reingold PRF, we multiplied these times by a factor of 4 to obtain estimates for a 256-bit field (instead of 128), reflecting the quadratic communication cost of the protocol. The costs for all of these preprocessing data types are summarized in Table 2.</p>

    <p class="text-gray-300">Note that LowMC only requires multiplication triples in  <span class="math">\\mathbb{F}_2</span> , for which the protocol of [29] could be much faster than</p>

    <p class="text-gray-300">using  <span class="math">\\mathbb{F}_{2^{128}}</span>  triples. However, we are not currently aware of an implementation of this protocol, so use the  <span class="math">\\mathbb{F}_{2^{128}}</span>  times for now.</p>

    <p class="text-gray-300">Benchmarking Environment: In any application of MPC, one of the most important factors affecting performance is the capability of the network. We ran benchmarks in a standard 1Gbps LAN setting, and also a simulated WAN setting, which restricts bandwidth to 50Mbps and latency to 100ms, using the Linux tc tool. This models a real-world environment where the parties may be in different countries or continents. In both cases, the test machines used have Intel i7-3770 CPUs running at 3.1GHz, with 32GB of RAM.</p>

    <p class="text-gray-300">Results: The results of our experiments in the LAN and WAN environments are shown in Tables 3 and 4, respectively. All figures are the result of taking an average of 5 experiments, each of which ran at least 1000 PRF operations. We present timings for AES and LowMC purely as a comparison metric; as explained in the introduction, these are not suitable for many MPC applications as they do not operate over a large characteristic finite field.</p>

    <p class="text-gray-300">LowMC obtains slightly better throughput and latency than AES over a LAN, with both the vector and M4R methods achieving similar performance here. In the WAN setting, LowMC gets a very high throughput of over 300 blocks per second. This is due to the low online communication cost for multiplications in  <span class="math">\\mathbb{F}_2</span>  instead of  <span class="math">\\mathbb{F}_{2^n}</span>  or  <span class="math">\\mathbb{F}_p</span> , and the fact that local computation is less significant in a WAN. The M4R method gets half the latency of the vector method in this scenario, since the number of rounds is halved. As discussed earlier, the preprocessing for LowMC would likely be much better than AES if implemented with the protocol of [29].</p>

    <p class="text-gray-300">In both scenarios, the Legendre PRF gives the lowest latency, even when outputting 128-bit field elements rather than bits, due to its low round complexity. The single-bit output variant achieves by far the highest throughput of all the PRFs, so would be ideally suited to an application based on a short-output PRF, such as secure computation of the (leaky) order-revealing encryption scheme in [18]. The Legendre PRF with large outputs is useful in scenarios where low latency is very important, although the preprocessing costs are expensive compared to MiMC below. However, the high cost of the Legendre PRF "in the clear" may not make it suitable for applications in which one entity is encrypting data to/from the MPC engine</p>

    <p class="text-gray-300">The Naor-Reingold PRF also achieves a low latency — though not as good as the Legendre PRF — but it suffers greatly when it comes to throughput. Notice that in the LAN setting, the constant rounds protocol actually performs worse than the logarithmic rounds variant in all measures, showing that here the amount of computation and communication is more of a limiting factor than the number of rounds. Profiling suggested that over  <span class="math">70\\%</span>  of the time was spent performing EC scalar multiplications, so it seems that computation rather than communication is the bottleneck in these timings. The requirement for a 256-bit field (for 128-bit security) will be a limiting factor in many applications, as will the need to bit decompose the input, if it was previously a single field element.</p>

    <p class="text-gray-300">The MiMC cipher seems to provide a good compromise amongst all the prime field candidates, especially as it also performs well when performed "in the clear". The "cube"</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PRF</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Best latency (ms/op)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Best throughput</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prep. (ops/s)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cleartext (ops/s)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Batch size</td>

            <td class="px-3 py-2 border-b border-gray-700">ops/s</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AES</td>

            <td class="px-3 py-2 border-b border-gray-700">7.713</td>

            <td class="px-3 py-2 border-b border-gray-700">2048</td>

            <td class="px-3 py-2 border-b border-gray-700">530</td>

            <td class="px-3 py-2 border-b border-gray-700">5.097</td>

            <td class="px-3 py-2 border-b border-gray-700">106268670</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\(F_{LowMC}\\)(vector)</td>

            <td class="px-3 py-2 border-b border-gray-700">4.302</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">591</td>

            <td class="px-3 py-2 border-b border-gray-700">2.562</td>

            <td class="px-3 py-2 border-b border-gray-700">7000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\(F_{LowMC}\\)(M4R)</td>

            <td class="px-3 py-2 border-b border-gray-700">4.148</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">475</td>

            <td class="px-3 py-2 border-b border-gray-700">2.565</td>

            <td class="px-3 py-2 border-b border-gray-700">1420</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\(F_{NR(128)}\\)(log)</td>

            <td class="px-3 py-2 border-b border-gray-700">4.375</td>

            <td class="px-3 py-2 border-b border-gray-700">1024</td>

            <td class="px-3 py-2 border-b border-gray-700">370</td>

            <td class="px-3 py-2 border-b border-gray-700">4.787</td>

            <td class="px-3 py-2 border-b border-gray-700">1359</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\(F_{NR(128)}\\)(const)</td>

            <td class="px-3 py-2 border-b border-gray-700">4.549</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">281</td>

            <td class="px-3 py-2 border-b border-gray-700">2.384</td>

            <td class="px-3 py-2 border-b border-gray-700">1359</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\(F_{Leg(hit)}\\)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.349</td>

            <td class="px-3 py-2 border-b border-gray-700">2048</td>

            <td class="px-3 py-2 border-b border-gray-700">202969</td>

            <td class="px-3 py-2 border-b border-gray-700">1225</td>

            <td class="px-3 py-2 border-b border-gray-700">17824464</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\(F_{Leg(1)}\\)</td>

            <td class="px-3 py-2 border-b border-gray-700">1.218</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">1535</td>

            <td class="px-3 py-2 border-b border-gray-700">9.574</td>

            <td class="px-3 py-2 border-b border-gray-700">115591</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\(F_{MiMC}\\)(basic)</td>

            <td class="px-3 py-2 border-b border-gray-700">12.007</td>

            <td class="px-3 py-2 border-b border-gray-700">2048</td>

            <td class="px-3 py-2 border-b border-gray-700">8788</td>

            <td class="px-3 py-2 border-b border-gray-700">33.575</td>

            <td class="px-3 py-2 border-b border-gray-700">189525</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\(F_{MiMC}\\)(cube)</td>

            <td class="px-3 py-2 border-b border-gray-700">5.889</td>

            <td class="px-3 py-2 border-b border-gray-700">1024</td>

            <td class="px-3 py-2 border-b border-gray-700">6388</td>

            <td class="px-3 py-2 border-b border-gray-700">33.575</td>

            <td class="px-3 py-2 border-b border-gray-700">189525</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3: Performance of the PRFs in a LAN setting</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PRF</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Best latency (ms/op)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Best throughput</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prep. (ops/s)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Batch size</td>

            <td class="px-3 py-2 border-b border-gray-700">ops/s</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AES</td>

            <td class="px-3 py-2 border-b border-gray-700">2640</td>

            <td class="px-3 py-2 border-b border-gray-700">1024</td>

            <td class="px-3 py-2 border-b border-gray-700">31.947</td>

            <td class="px-3 py-2 border-b border-gray-700">0.256</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\(F_{LowMC}\\)(vector)</td>

            <td class="px-3 py-2 border-b border-gray-700">1315</td>

            <td class="px-3 py-2 border-b border-gray-700">2048</td>

            <td class="px-3 py-2 border-b border-gray-700">365</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1259</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\(F_{LowMC}\\)(M4R)</td>

            <td class="px-3 py-2 border-b border-gray-700">659</td>

            <td class="px-3 py-2 border-b border-gray-700">2048</td>

            <td class="px-3 py-2 border-b border-gray-700">334</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1261</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\(F_{NR(128)}\\)(log)</td>

            <td class="px-3 py-2 border-b border-gray-700">713</td>

            <td class="px-3 py-2 border-b border-gray-700">1024</td>

            <td class="px-3 py-2 border-b border-gray-700">59.703</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2359</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\(F_{NR(128)}\\)(const)</td>

            <td class="px-3 py-2 border-b border-gray-700">478</td>

            <td class="px-3 py-2 border-b border-gray-700">1024</td>

            <td class="px-3 py-2 border-b border-gray-700">30.384</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1175</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\(F_{Leg(hit)}\\)</td>

            <td class="px-3 py-2 border-b border-gray-700">202</td>

            <td class="px-3 py-2 border-b border-gray-700">1024</td>

            <td class="px-3 py-2 border-b border-gray-700">2053</td>

            <td class="px-3 py-2 border-b border-gray-700">60.241</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\(F_{Leg(1)}\\)</td>

            <td class="px-3 py-2 border-b border-gray-700">210</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">68.413</td>

            <td class="px-3 py-2 border-b border-gray-700">0.4706</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\(F_{MiMC}\\)(basic)</td>

            <td class="px-3 py-2 border-b border-gray-700">7379</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">59.04</td>

            <td class="px-3 py-2 border-b border-gray-700">1.650</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\(F_{MiMC}\\)(cube)</td>

            <td class="px-3 py-2 border-b border-gray-700">3691</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">79.66</td>

            <td class="px-3 py-2 border-b border-gray-700">1.650</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 4: Performance of the PRFs in a simulated WAN setting</p>

    <p class="text-gray-300">variant, which halves the number of rounds, effectively halves the latency compared to the naive protocol. This results in a slightly worse throughput in the LAN setting due to the higher computation costs, whereas in the WAN setting round complexity is more important. Although the latency is much higher than  <span class="math">F_{\\mathrm{Leg}}</span> , due to the large number of rounds, MiMC achieves the best throughput for  <span class="math">\\mathbb{F}_p</span> -bit outputs, with over 6000 operations per second. In addition, the pre-processing costs of MiMC are better than that of both Legendre and the Naor-Reingold PRFs.</p>

    <p class="text-gray-300">So in conclusion there is no single PRF which meets all the criteria we outlined at the beginning. But one would likely prefer the Legendre PRF for applications which require low latency, and which do not involve any party external to the MPC engine, and MiMC for all other applications.</p>

    <p class="text-gray-300">The work in this paper has been partially supported by the ERC via Advanced Grant ERC-2010-AdG-267188-CRIPTO, the Defense Advanced Research Projects Agency (DARPA) and Space and Naval Warfare Systems Center, Pacific (SSC Pacific) under contract No. N66001-15-C-4070, and by the Austrian Science Fund via project P26494-N15.</p>

    <p class="text-gray-300">[1] M. Albrecht, G. Bard, and W. Hart. Algorithm 898: Efficient multiplication of dense matrices over GF(2). ACM Transactions on Mathematical Software (TOMS), 37(1):9, 2010.</p>

    <p class="text-gray-300">[2] M. Albrecht, L. Grassi, C. Rechberger, A. Roy, and T. Tiessen. MiMC: Efficient encryption and cryptographic hashing with minimal multiplicative complexity. Cryptology ePrint Archive, 2016. http://eprint.iacr.org/2016/492. [3] M. Albrecht, C. Rechberger, T. Schneider, T. Tiessen, and M. Zohner. Ciphers for MPC and FHE. Cryptology ePrint Archive, Report 2016/687, 2016. http://eprint.iacr.org/2016/687. [4] M. R. Albrecht, C. Rechberger, T. Schneider, T. Tiessen, and M. Zohner. Ciphers for MPC and FHE. In E. Oswald and M. Fischlin, editors, EUROCRYPT 2015, Part I, volume 9056 of LNCS, pages 430-454. Springer, Heidelberg, Apr. 2015. [5] J. Bar-Ilan and D. Beaver. Non-cryptographic fault-tolerant computing in constant number of rounds of interaction. In P. Rudnicki, editor, 8th ACM PODC, pages 201-209. ACM, Aug. 1989. [6] M. Bellare, A. Boldyreva, and A. O'Neill. Deterministic and efficiently searchable encryption. In A. Menezes, editor, CRYPTO 2007, volume 4622 of LNCS, pages 535-552. Springer, Heidelberg, Aug. 2007. [7] R. Bendlin, I. Damgård, C. Orlandi, and S. Zakarias. Semi-homomorphic encryption and multiparty computation. In K. G. Paterson, editor, EUROCRYPT 2011, volume 6632 of LNCS, pages 169-188. Springer, Heidelberg, May 2011. [8] P. Bogetoft, D. L. Christensen, I. Damgård,</p>

    <p class="text-gray-300">M. Geisler, T. Jakobsen, M. Krøigaard, J. D. Nielsen, J. B. Nielsen, K. Nielsen, J. Pagter, M. I. Schwartzbach, and T. Toft. Secure multiparty computation goes live. In R. Dingledine and P. Golle, editors, FC 2009, volume 5628 of LNCS, pages 325–343. Springer, Heidelberg, Feb. 2009.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[9] A. Boldyreva, N. Chenette, and A. O’Neill. Order-preserving encryption revisited: Improved security analysis and alternative solutions. In P. Rogaway, editor, CRYPTO 2011, volume 6841 of LNCS, pages 578–595. Springer, Heidelberg, Aug. 2011.</li>

      <li>[10] D. Boneh, K. Lewi, M. Raykova, A. Sahai, M. Zhandry, and J. Zimmerman. Semantically secure order-revealing encryption: Multi-input functional encryption without obfuscation. In E. Oswald and M. Fischlin, editors, EUROCRYPT 2015, Part II, volume 9057 of LNCS, pages 563–594. Springer, Heidelberg, Apr. 2015.</li>

      <li>[11] J. Borghoff, A. Canteaut, T. Güneysu, E. B. Kavun, M. Knežević, L. R. Knudsen, G. Leander, V. Nikov, C. Paar, C. Rechberger, P. Rombouts, S. S. Thomsen, and T. Yalçin. PRINCE - A low-latency block cipher for pervasive computing applications - extended abstract. In X. Wang and K. Sako, editors, ASIACRYPT 2012, volume 7658 of LNCS, pages 208–225. Springer, Heidelberg, Dec. 2012.</li>

      <li>[12] J. Bourgain, M. Z. Garaev, S. V. Konyagin, and I. E. Shparlinski. On the hidden shifted power problem. SIAM Journal on Computing, 41(6):1524–1557, 2012.</li>

      <li>[13] A. Canteaut, S. Carpov, C. Fontaine, T. Lepoint, M. Naya-Plasencia, P. Paillier, and R. Sirdey. Stream ciphers: A practical solution for efficient homomorphic-ciphertext compression. In Fast Software Encryption - 23nd International Workshop, FSE 2016, 2016.</li>

      <li>[14] D. Cash, S. Jarecki, C. S. Jutla, H. Krawczyk, M.-C. Rosu, and M. Steiner. Highly-scalable searchable symmetric encryption with support for Boolean queries. In R. Canetti and J. A. Garay, editors, CRYPTO 2013, Part I, volume 8042 of LNCS, pages 353–373. Springer, Heidelberg, Aug. 2013.</li>

      <li>[15] O. Catrina and S. de Hoogh. Improved primitives for secure multiparty integer computation. In J. A. Garay and R. D. Prisco, editors, SCN 10, volume 6280 of LNCS, pages 182–199. Springer, Heidelberg, Sept. 2010.</li>

      <li>[16] O. Catrina and S. de Hoogh. Secure multiparty linear programming using fixed-point arithmetic. In D. Gritzalis, B. Preneel, and M. Theoharidou, editors, ESORICS 2010, volume 6345 of LNCS, pages 134–150. Springer, Heidelberg, Sept. 2010.</li>

      <li>[17] O. Catrina and A. Saxena. Secure computation with fixed-point numbers. In R. Sion, editor, FC 2010, volume 6052 of LNCS, pages 35–50. Springer, Heidelberg, Jan. 2010.</li>

      <li>[18] N. Chenette, K. Lewi, S. A. Weis, and D. J. Wu. Practical order-revealing encryption with limited leakage. In Fast Software Encryption - 23nd International Workshop, FSE 2016, 2016.</li>

      <li>[19] J. Daemen, M. Peeters, G. Van Assche, and V. Rijmen. Nessie proposal: Noekeon. In First Open NESSIE Workshop, 2000.</li>

      <li>[20] I. Damgård. On the randomness of legendre and jacobi sequences. In S. Goldwasser, editor, CRYPTO’88, volume 403 of LNCS, pages 163–172. Springer, Heidelberg, Aug. 1990.</li>

      <li>[21] I. Damgård, M. Fitzi, E. Kiltz, J. B. Nielsen, and T. Toft. Unconditionally secure constant-rounds multi-party computation for equality, comparison, bits and exponentiation. In S. Halevi and T. Rabin, editors, TCC 2006, volume 3876 of LNCS, pages 285–304. Springer, Heidelberg, Mar. 2006.</li>

      <li>[22] I. Damgård, M. Geisler, M. Krøigaard, and J. B. Nielsen. Asynchronous multiparty computation: Theory and implementation. In S. Jarecki and G. Tsudik, editors, PKC 2009, volume 5443 of LNCS, pages 160–179. Springer, Heidelberg, Mar. 2009.</li>

      <li>[23] I. Damgård and M. Keller. Secure multiparty AES. In R. Sion, editor, FC 2010, volume 6052 of LNCS, pages 367–374. Springer, Heidelberg, Jan. 2010.</li>

      <li>[24] I. Damgård, M. Keller, E. Larraia, C. Miles, and N. P. Smart. Implementing AES via an actively/covertly secure dishonest-majority MPC protocol. In I. Visconti and R. D. Prisco, editors, SCN 12, volume 7485 of LNCS, pages 241–263. Springer, Heidelberg, Sept. 2012.</li>

      <li>[25] I. Damgård, M. Keller, E. Larraia, V. Pastro, P. Scholl, and N. P. Smart. Practical covertly secure MPC for dishonest majority - or: Breaking the SPDZ limits. In J. Crampton, S. Jajodia, and K. Mayes, editors, ESORICS 2013, volume 8134 of LNCS, pages 1–18. Springer, Heidelberg, Sept. 2013.</li>

      <li>[26] I. Damgård, V. Pastro, N. P. Smart, and S. Zakarias. Multiparty computation from somewhat homomorphic encryption. In R. Safavi-Naini and R. Canetti, editors, CRYPTO 2012, volume 7417 of LNCS, pages 643–662. Springer, Heidelberg, Aug. 2012.</li>

      <li>[27] I. Damgård and R. W. Zakarias. Fast oblivious AES A dedicated application of the MiniMac protocol. In AFRICACRYPT 2016, pages 245–264, 2016.</li>

      <li>[28] S. Duval, V. Lallemand, and Y. Rotella. Cryptanalysis of the FLIP family of stream ciphers. In CRYPTO 2016, 2016.</li>

      <li>[29] T. K. Frederiksen, M. Keller, E. Orsini, and P. Scholl. A Unified Approach to MPC with Preprocessing Using OT. In T. Iwata and J. H. Cheon, editors, ASIACRYPT 2015, volume 9452 of LNCS, pages 711–735. Springer, Heidelberg, Dec. 2015.</li>

      <li>[30] T. Jakobsen and L. R. Knudsen. The interpolation attack on block ciphers. In E. Biham, editor, FSE’97, volume 1267 of LNCS, pages 28–40. Springer, Heidelberg, Jan. 1997.</li>

      <li>[31] M. Keller, E. Orsini, and P. Scholl. MASCOT: Faster malicious arithmetic secure computation from oblivious transfer. Cryptology ePrint Archive, 2016. http://eprint.iacr.org/2016/505.</li>

      <li>[32] M. Keller, P. Scholl, and N. P. Smart. An architecture for practical actively secure MPC with dishonest majority. In A.-R. Sadeghi, V. D. Gligor, and M. Yung, editors, ACM CCS 13, pages 549–560. ACM Press, Nov. 2013.</li>

      <li>[33] S. Laur, R. Talviste, and J. Willemson. From oblivious</li>

    </ul>

    <p class="text-gray-300">AES to efficient and secure database join in the multiparty setting. In M. J. Jacobson Jr., M. E. Locasto, P. Mohassel, and R. Safavi-Naini, editors, ACNS 13, volume 7954 of LNCS, pages 84–101. Springer, Heidelberg, June 2013.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[34] C. H. Lim and T. Korkishko. mCrypton - a lightweight block cipher for security of low-cost RFID tags and sensors. In J. Song, T. Kwon, and M. Yung, editors, WISA 05, volume 3786 of LNCS, pages 243–258. Springer, Heidelberg, Aug. 2006.</li>

      <li>[35] Y. Lindell and B. Riva. Blazing fast 2PC in the offline/online setting with security for malicious adversaries. In I. Ray, N. Li, and C. Kruegel:, editors, ACM CCS 15, pages 579–590. ACM Press, Oct. 2015.</li>

      <li>[36] S. Lu and R. Ostrovsky. Distributed oblivious RAM for secure two-party computation. In A. Sahai, editor, TCC 2013, volume 7785 of LNCS, pages 377–396. Springer, Heidelberg, Mar. 2013.</li>

      <li>[37] P. Méaux, A. Journault, F. Standaert, and C. Carlet. Towards stream ciphers for efficient FHE with low-noise ciphertexts. In M. Fischlin and J. Coron, editors, EUROCRYPT 2016, volume 9665 of Lecture Notes in Computer Science, pages 311–343. Springer, 2016.</li>

      <li>[38] M. Naor and O. Reingold. Number-theoretic constructions of efficient pseudo-random functions. In 38th FOCS, pages 458–467. IEEE Computer Society Press, Oct. 1997.</li>

      <li>[39] J. B. Nielsen, P. S. Nordholt, C. Orlandi, and S. S. Burra. A new approach to practical active-secure two-party computation. In R. Safavi-Naini and R. Canetti, editors, CRYPTO 2012, volume 7417 of LNCS, pages 681–700. Springer, Heidelberg, Aug. 2012.</li>

      <li>[40] K. Nyberg and L. R. Knudsen. Provable security against a differential attack. Journal of Cryptology, 8(1):27–37, 1995.</li>

      <li>[41] B. Pinkas, T. Schneider, N. P. Smart, and S. C. Williams. Secure two-party computation is practical. In M. Matsui, editor, ASIACRYPT 2009, volume 5912 of LNCS, pages 250–267. Springer, Heidelberg, Dec. 2009.</li>

      <li>[42] A. Russell and I. Shparlinski. Classical and quantum polynomial reconstruction via Legendre symbol evaluation. Journal of Complexity, 20(2-3):404–422, 2004.</li>

      <li>[43] W. Van Dam. Quantum algorithms for weighing matrices and quadratic residues. Algorithmica, 34(4):413–428, 2002.</li>

      <li>[44] W. van Dam, S. Hallgren, and L. Ip. Quantum algorithms for some hidden shift problems. In 14th SODA, pages 489–498. ACM-SIAM, Jan. 2003.</li>

      <li>[45] F. Vercauteren. The hidden root problem. In S. D. Galbraith and K. G. Paterson, editors, PAIRING 2008, volume 5209 of LNCS, pages 89–99. Springer, Heidelberg, Sept. 2008.</li>

    </ul>`;
---

<BaseLayout title="MPC-Friendly Symmetric Key Primitives (2016/542)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/542
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
