---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2018/262';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Chimeric Ledgers: Translating and Unifying UTXO-based and Account-based Cryptocurrencies';
const AUTHORS_HTML = 'Joachim Zahnentferner';

const CONTENT = `    <p class="text-gray-300">Joachim Zahnentferner Input Output HK Hong Kong Email: chimeric.ledgers@protonmail.com</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Cryptocurrencies are historically divided in two broad groups with respect to the style of transactions that they accept. In the account-based style, each address is seen as an account with a balance, and transactions are transfers of value from one account to another. In the UTxO-based style, transactions inductively spend outputs generated by previous transactions and create new unspent outputs, and there is no intrinsic notion of account associated with an address. Each style has advantages and disadvantages. This paper formally defines: the two styles; translations that allow to simulate one style by the other; new transaction types that allow both styles of transactions to co-exist on the same ledger; and a new transaction type that combines features from both styles.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">The rising popularity of various cryptocurrencies has created a demand for transferring assets from one cryptocurrency to another. Currently the most common solution is to use online exchanges, but it requires trusting the chosen exchanges. Trust on a centralized exchange not only goes against the usual descentralization principles of cryptocurrencies but also has already proven to be risky, as there have been many cases of exchanges that have been hacked and lost large amounts of assets. Alternative descentralized solutions, such as descentralized exchanges <em>[1]</em>, cross-chain transactions <em>[2, 3]</em> and side-chains <em>[4, 5]</em> promise a future where assets can be more freely and trustlessly moved between distinct cryptocurrencies, or even between various chains of a multi-layered/multi-chain cryptocurrency <em>[6, 7]</em>.</p>

    <p class="text-gray-300">However, for this future to eventually become a reality, a clearer and formal understanding of the differences between various cryptocurrencies is desirable. Intuitively, moving assets between cryptocurrencies with incompatible security properties, monetary policies or accounting behaviours could be problematic.</p>

    <p class="text-gray-300">The main goal of this paper is to clarify, formalize and define translations between the two transaction accounting systems used by cryptocurrencies nowadays. The first one, known as UTxO-based (because it tracks unspent transaction outputs), was introduced by Bitcoin <em>[8]</em>, whereas the second one, called account-based, is used by Ethereum <em>[9, 10]</em>.</p>

    <p class="text-gray-300">There have been many informal discussions comparing both accounting approaches, often presenting reasons to choose one instead of the other (e.g. <em>[11, 12, 13, 14, 15]</em>). This paper takes a neutral stance on this debate. Assuming that each approach has its own advantages and disadvantages, it is likely that they will co-exist in the foreseeable future. This paper aims to facilitate their co-existence, and its main proposal is the notion of chimeric ledger, which can contain both UTxO-based and account-based transactions.</p>

    <p class="text-gray-300">The contributions of this paper are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>formal abstract and minimalistic definitions for UTxO-based cryptocurrencies (Sec. 3).</li>

      <li>formal abstract and minimalistic definitions for account-based cryptocurrencies (Sec. 4).</li>

      <li>translations between both approaches (Sec. 5).</li>

      <li>definitions of new transaction types that allow users to convert their funds between the UTxO-</li>

    </ul>

    <p class="text-gray-300">based and account-based styles of accounting, enabling chimeric ledgers (Sec. 7).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>definition of a new transaction type, combining features of UTxO-based transaction and account-based transaction (Sec. 8).</li>

    </ul>

    <p class="text-gray-300">It should be noted that this paper discusses accounting aspects only, intentionally leaving cryptographic authorization and monetary policy concerns aside. The rationale for this decision is to provide an independent accounting foundation on top of which a wide range of monetary policies and authorizations schemes could be defined in future work. A reference implementation in Scala of all concepts defined here is available (https://gofile.io/?c=hSGlkW). It is recommended to read the implementation together with the paper.</p>

    <h2 id="sec-4" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">A <em>blockchain</em> is, as the name suggests, an immutable chain of blocks of data. Blocks are continuously appended to the chain by mutually distrusting peers. When peers disagree with each other (e.g. on which block to append), a fork occurs, leading to competing versions of the chain that differ from each other on their most recent blocks. Forks are quickly corrected, because peers follow a consensus protocol to decide which competing version they should keep.</p>

    <p class="text-gray-300"><em>Cryptocurrencies</em> are blockchain systems where the block data are transactions transferring values between addresses. In such systems, the blockchain functions as a descentralized ledger, maintained by peers reliably without a central trusted authority. Peers are responsible for validating and grouping available unprocessed transactions into a new block and then trying to append the new block to the chain according to the consensus protocol. Typically, there is an economic incentive for this work: if a peer manages to append a block, it receives all the fees allocated by the transactions in the block and possibly an additional subsidy of newly forged money. The forging of new money depends on the monetary policy of the cryptocurrency.</p>

    <p class="text-gray-300">In the formalism presented here, the technical details of the underlying blockchain are disregarded, because only the ledger of transactions (i.e. the data stored in the blockchain) is of interest. In particular, it does not matter whether the ledger is stored in a single chain or in multiple chains (e.g. a main chain and various sidechains). Furthermore, as the focus is on the accounting aspects only, the formalism abstracts away features of cryptocurrencies such as signatures, scripts and smart contracts. In particular, it does not matter whether the transactions transfer value directly (as in Bitcoin) or call smart contracts that indirectly execute the transfers of value (e.g. as in ERC20 tokens <em>[16]</em> running on Ethereum). For convenience, a <em>ledger</em> is assumed to be simply a list of transactions. Nevertheless, the formalism described here is still applicable to cryptocurrencies that store transactions in graphs (e.g. IOTA <em>[17]</em>), as long as the graph nodes can be topologically sorted into a list (as is the case if there are no circular dependencies between transactions). It is possible and perhaps helpful, though not necessary, to associate a <em>state</em> to a ledger and think of any <em>transaction</em> as a state transition function. The following sections define various subtypes of Transaction.</p>

    <h6 id="sec-5" class="text-base font-medium mt-4">Definition 1.</h6>

    <p class="text-gray-300">A <em>ledger</em> is a list of valid transactions:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Ledger}\\stackrel{{\\scriptstyle\\mathfrak{def}}}{{=}}\\mathsf{List}[\\mathsf{Transaction}]</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Notations: A record data type with fields <span class="math">\\varphi_{1}</span>, <span class="math">\\ldots</span>, <span class="math">\\varphi_{n}</span> of types <span class="math">T_{1}</span>, <span class="math">\\ldots</span>, <span class="math">T_{n}</span> is denoted <span class="math">(\\varphi_{1}\\colon T_{1},\\ldots,\\varphi_{n}\\colon T_{n})</span>. If <span class="math">t</span> is a value of a record data type <span class="math">T</span> and <span class="math">\\varphi</span> is the name of a field of <span class="math">T</span>, then <span class="math">t.\\varphi</span> denotes the value of <span class="math">\\varphi</span> for <span class="math">t</span>. A list <span class="math">\\lambda</span> of type <span class="math">\\mathsf{List}[T]</span> is either the empty list <span class="math">[]</span> or a list <span class="math">e\\mathrel{\\mathop{\\mathchar 58\\relax}}\\lambda^{\\prime}</span> with <em>head</em> <span class="math">e</span> of type <span class="math">T</span> and <em>tail</em> <span class="math">\\lambda^{\\prime}</span> of type <span class="math">\\mathsf{List}[T]</span>. <span class="math">[e_{1},\\ldots,e_{n}]</span> is an abbreviation for <span class="math">e_{1}\\mathrel{\\mathop{\\mathchar 58\\relax}}\\ldots\\mathrel{\\mathop{\\mathchar 58\\relax}}e_{n}\\mathrel{\\mathop{\\mathchar 58\\relax}}:[.\\,.\\,.\\,.]</span> (with the head being the 0-th element of <span class="math">\\lambda</span> (with the head being the 0-th element, by convention). The concatenation of two lists <span class="math">\\lambda_{1}</span> and <span class="math">\\lambda_{2}</span> is denoted <span class="math">\\lambda_{1}\\mathrel{\\mathop{\\mathchar 58\\relax}}\\mathrel{\\mathop{\\mathchar 58\\relax}}\\lambda_{2}</span>. The length of a list <span class="math">\\lambda</span> is denoted $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\lambda</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. A list of integers from </span>n<span class="math"> to </span>m<span class="math">, including </span>n<span class="math"> and </span>m<span class="math">, is denoted </span>[n..m]<span class="math">. The standard equality symbol (</span>=<span class="math">) is used to state that two values are equal. The definitional equality symbol (</span>\\stackrel{{\\scriptstyle\\mathfrak{def}}}{{=}}<span class="math">) is used to define the new constant or function symbol on the left term. The explanatory equality symbol (</span>\\dot{=}<span class="math">) is used to explain an introduced value: a sentence such as “the value </span>v\\dot{=}(n,m)<span class="math"> is …” should be read as “the value </span>v<span class="math">, which is of the form </span>(n,m)<span class="math">, is …”. To ease readability, integer values representing amounts of money are preceded by </span>\\$$ and values representing addresses are preceded by <span class="math">@</span>. An anonymous function that takes a tuple as argument may be denoted as <span class="math">(a_{1},\\ldots,a_{n})\\Rightarrow\\ldots</span>. For instance, the <span class="math">k</span>-th projection of a tuple may be denoted <span class="math">(a_{1},\\ldots,a_{n})\\Rightarrow a_{k}</span>. The cryptographic collision-resistant hash of an object <span class="math">c</span> is denoted <span class="math">c^{\\#}</span>. The assignment of a value <span class="math">c</span> to a variable <span class="math">v</span> is denoted <span class="math">v\\leftarrow c</span>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">##</p>

    <h2 id="sec-6" class="text-2xl font-bold">3 UTxO-Based Cryptocurrencies</h2>

    <p class="text-gray-300">In a time where bank accounts are ubiquitous in financially advanced societies, it is intuitive and natural to imagine transactions as transfers of value between accounts. This, however, is not how Bitcoin’s UTxO-based transactions work. To intuitively understand UTxO-based transactions, which are formally defined in Definition 2, it is helpful to think of them in terms of cash transactions, where a buyer pays with coins and notes of various denominations, with a few key improvements enabled by Bitcoin’s digital nature:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>With cash, denominations are fixed (e.g. notes of <span class="math">1, </span>5, <span class="math">10, </span>50, $100 and coins of 50c, 10c, 5c, …). In Bitcoin, denominations are arbitrary.</li>

      <li>With cash, the coins and notes remain intact as they change hands during a transaction. With bitcoin, the “coins” of arbitrary denominations spent by a transaction are essentially destroyed (i.e. spent as inputs) and new “coins” of equal total value are created (i.e. the new unspent outputs).</li>

      <li>With cash, if the buyer doesn’t have coins and notes with the exact value of the item he wants to purchase, he/she must pay with a value greater than the value of the item and then hope that the seller will give back any surplus (i.e. the “change”) shortly thereafter in a second transaction, instead of running away with it. With Bitcoin, the buyer can create a “coin” (i.e. an output) with value equal to the surplus and send it back to himself/herself in the same transaction where the payment is made.</li>

      <li>A Bitcoin transaction also has a fee indirectly paid to whoever includes it in the ledger, and may (under certain conditions) forge value out of nothing, whereas cash relies on a centralized mint to forge new coins and notes.</li>

    </ul>

    <h6 id="sec-7" class="text-base font-medium mt-4">Definition 2.</h6>

    <p class="text-gray-300">The datatype for UTxO-based transactions is defined as:</p>

    <p class="text-gray-300"><span class="math">\\textsf{UtxoTx}\\stackrel{{\\scriptstyle\\textrm{def}}}{{=}}</span> <span class="math">(inputs\\colon\\textsf{Set}[\\textsf{Input}],</span> <span class="math">outputs\\colon\\textsf{List}[\\textsf{Output}],</span> <span class="math">forge\\colon\\textsf{Value},fee\\colon\\textsf{Value})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Bitcoin’s cash-like approach can be appreciated from a historical and ideological point of view, considering that Bitcoin was created with a strong anti-bank sentiment, as evidenced by Satoshi Nakamoto’s famous message (“The Times 3 January 2009 Chancellor on brink of second bailout for banks”) in Bitcoin’s first block.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Normally, a transaction would also include signatures or authorization scripts that determine whether the inputs are allowed to spend the outputs to which they refer. For the reasons discussed in Sec. 2, such authorization details are abstracted away here.</li>

    </ol>

    <p class="text-gray-300">The datatype for outputs is:</p>

    <p class="text-gray-300"><span class="math">\\textsf{Output}\\stackrel{{\\scriptstyle\\textrm{def}}}{{=}}</span> <span class="math">(address\\colon\\textsf{Address},value\\colon\\textsf{Value})</span></p>

    <p class="text-gray-300">where <span class="math">value</span> is the value of the output and <span class="math">address</span> is the address that owns it. The datatype for inputs is:</p>

    <p class="text-gray-300"><span class="math">\\textsf{Input}\\stackrel{{\\scriptstyle\\textrm{def}}}{{=}}</span> <span class="math">(id\\colon\\textsf{Id},index\\colon\\textsf{Int})</span></p>

    <p class="text-gray-300">where <span class="math">id</span> is the id of a previous transaction to which this input refers, and <span class="math">index</span> indicates which of the referred transaction’s outputs should be spent.</p>

    <p class="text-gray-300">The transaction output to which an input refers in a ledger can be retrieved with the functions of Definition 3. Because the input may refer to a transaction (or its output) that cannot be found in the ledger, all these functions have return (monadic) types of the form <span class="math">\\textsf{Option}[X]</span> for some <span class="math">X</span>, whose values may be either <span class="math">\\mathrm{none}</span> or <span class="math">\\mathrm{some}(x)</span> for any <span class="math">x</span> of type <span class="math">X</span>.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Definition 3.</h6>

    <p class="text-gray-300">The function <span class="math">\\mathrm{tx}\\colon\\textsf{Input}\\rightarrow\\textsf{Ledger}\\rightarrow\\textsf{Option}[\\textsf{UtxoTx}]</span>, when applied to an input <span class="math">i</span> and a ledger <span class="math">\\lambda</span>, retrieves a transaction <span class="math">t</span> contained in <span class="math">\\lambda</span> such that <span class="math">t^{\\#}=i.id</span>, if such a <span class="math">t</span> exists. The function <span class="math">\\mathrm{out}\\colon\\textsf{Input}\\rightarrow\\textsf{Ledger}\\rightarrow\\textsf{Option}[\\textsf{Output}]</span> returns <span class="math">\\mathrm{tx}(i).get.inputs(i.index)</span>, if this exists. And finally, the function <span class="math">\\mathrm{value}\\colon\\textsf{Input}\\rightarrow\\textsf{Ledger}\\rightarrow\\textsf{Option}[\\textsf{Value}]</span>, returns <span class="math">\\mathrm{out}(i).get.value</span>, if this exists.</p>

    <p class="text-gray-300">UTxO-based cryptocurrencies rely on the notion of unspent transaction outputs. This is usually imagined to be a set of all the outputs of all the ledger’s transactions that have not been spent yet. Unfortunately, this is problematic. As an output is essentially just a pair of an address and a value, there might be several transactions having equal outputs. A set would treat all these equal outputs as the same object. A multi-set would not solve the problem either, because it would not be clear which copy of an output belongs to which transaction. An element of the set of unspent transaction outputs needs to be a reference to a transaction and an output in this transaction, and this is essentially what an input is.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The types Address and Value are regarded here as aliases for unbounded unsigned non-negative integers.</li>

      <li>Values of type Id are typically cryptographic collision-resistant hashes of the transactions to which they refer. Whenever the number of potential transactions (which is typically infinite) is larger than the number of possible values of type Id (which is typically, but not necessarily, finite), the pigeonhole principle guarantees that at least two transactions will be mapped to the same id. Nevertheless, a collision-resistant hash function ensures that it is hard to construct a transaction that will have the same id as another.</li>

    </ol>

    <p class="text-gray-300">Therefore it is helpful to define unspent transaction outputs as a set of “spendable” inputs.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Definition 4.</h6>

    <p class="text-gray-300">The <em>unspent outputs</em> of a transaction can be computed by applying the following function:</p>

    <p class="text-gray-300">\\[ \\begin{split}\\text{unspentOutputs}\\colon\\textsf{UtxoTx}\\rightarrow\\textsf{Set}[\\textsf{Input}]\\\\ \\text{unspentOutputs}(t)\\stackrel{{\\scriptstyle\\rm def}}{{=}}(map\\\\ ((o,i)\\Rightarrow\\textsf{Input}(t^{\\#},i))\\\\ t.\\textsf{outputs.zipWithIndex}\\\\ ).\\textsf{toSet}\\end{split} \\]</p>

    <p class="text-gray-300">where: <span class="math">zipWithIndex</span> augments the outputs with their respective indexes, the anonymous function maps an output to a spendable input consisting of the transaction’s hash and the output’s index, and <span class="math">toSet</span> converts the list to a set.</p>

    <p class="text-gray-300">The <em>outputs spent</em> by a transaction are simply the transaction’s inputs, and can be computed by applying the following function:</p>

    <p class="text-gray-300">\\[ \\begin{split}\\text{spentOutputs}\\colon\\textsf{UtxoTx}\\rightarrow\\textsf{Set}[\\textsf{Input}]\\\\ \\text{spentOutputs}(t)\\stackrel{{\\scriptstyle\\rm def}}{{=}}t.\\textsf{inputs}\\end{split} \\]</p>

    <p class="text-gray-300">In a ledger containing only UTxO-based transactions, the relevant information for the ledger’s state is its set of unspent outputs, which can be computed by starting with an empty set for the empty ledger, and then updating it for every added transaction by removing the outputs spent by the transaction and adding the unspent outputs generated by the transaction.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 5.</h6>

    <p class="text-gray-300">The <em>set of unspent outputs</em> of a ledger can be computed by applying the following function:</p>

    <p class="text-gray-300">\\[ \\begin{split}\\text{unspentOutputs}\\colon\\textsf{Ledger}\\rightarrow\\textsf{Set}[\\textsf{Input}]\\\\ \\text{unspentOutputs}([])\\stackrel{{\\scriptstyle\\rm def}}{{=}}\\emptyset\\\\ \\text{unspentOutputs}(t\\dvtx)\\stackrel{{\\scriptstyle\\rm def}}{{=}}\\text{unspentOutputs}(\\lambda)\\\\ -\\text{spentOutputs}(t)\\\\ +\\text{unspentOutputs}(t)\\end{split} \\]</p>

    <p class="text-gray-300">For a UTxO-based transaction to be valid, all its inputs must refer to unspent outputs in the ledger and value must be preserved, as described in Definition 6.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Definition 6.</h6>

    <p class="text-gray-300">A UTxO-based transaction <span class="math">t</span> is <em>valid</em> for a ledger <span class="math">\\lambda</span> iff the following two conditions hold:</p>

    <p class="text-gray-300">all inputs refer to unspent outputs:</p>

    <p class="text-gray-300"><span class="math">\\forall i\\in t.\\textsf{inputs},i\\in\\textsf{unspentOutputs}(\\lambda)</span></p>

    <p class="text-gray-300">value is preserved:</p>

    <p class="text-gray-300"><span class="math">t.\\textsf{forge}+\\sum_{i\\in t.\\textsf{inputs}}value(i,\\lambda).get=t.\\textsf{fee}+\\sum_{o\\in t.\\textsf{outputs}}o.\\textsf{value}</span></p>

    <p class="text-gray-300">The balance of an address in a ledger can be defined as the sum of the values of outputs that have been paid to the address and that have not been spent yet. To simplify the definition, it is useful to firstly consider the balance of an address in a single transaction.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Definition 7.</h6>

    <p class="text-gray-300">The UTxO-<em>balance</em> of an address <span class="math">a</span> in a valid transaction <span class="math">t</span> w.r.t. a ledger <span class="math">\\lambda</span> is:</p>

    <p class="text-gray-300">\\[ \\begin{split}\\mathcal{B}_{\\text{\\tiny UTxO}}\\colon\\textsf{Address}\\rightarrow\\textsf{UtxoTx}\\rightarrow\\textsf{Ledger}\\rightarrow\\textsf{Value}\\\\ \\mathcal{B}_{\\text{\\tiny UTxO}}(a,t,\\lambda)\\stackrel{{\\scriptstyle\\rm def}}{{=}}\\sum_{\\begin{subarray}{c}a\\in t.\\textsf{outputs}\\\\ o.\\textsf{address}=a\\end{subarray}}o.\\textsf{value}-\\sum_{\\begin{subarray}{c}i\\in t.\\textsf{inputs}\\\\ o^{\\prime}=\\textsf{out}(i,\\lambda).get\\\\ o^{\\prime}.\\textsf{address}=a\\end{subarray}}o^{\\prime}.\\textsf{value}\\end{split} \\]</p>

    <p class="text-gray-300">Now the balance of an address in a ledger can be defined inductively, treating each transaction’s balance for the address as a balance update and overloading the definition of <span class="math">\\mathcal{B}_{\\text{\\tiny UTxO}}</span> through ad-hoc polymorphism.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Definition 8.</h6>

    <p class="text-gray-300">The UTxO-<em>balance</em> of an address <span class="math">a</span> in a ledger <span class="math">\\lambda</span> is:</p>

    <p class="text-gray-300">\\[ \\begin{split}\\mathcal{B}_{\\text{\\tiny UTxO}}\\colon\\textsf{Address}\\rightarrow\\textsf{Ledger}\\rightarrow\\textsf{Value}\\\\ \\mathcal{B}_{\\text{\\tiny UTxO}}(a,[])\\stackrel{{\\scriptstyle\\rm def}}{{=}}\\mathcal{B}_{\\text{\\tiny UTxO}}(a,t\\dvtx)\\stackrel{{\\scriptstyle\\rm def}}{{=}}\\mathcal{B}_{\\text{\\tiny UTxO}}(a,\\lambda)+\\mathcal{B}_{\\text{\\tiny UTxO}}(a,t,\\lambda)\\end{split} \\]</p>

    <p class="text-gray-300">The definitions above are illustrated in Example 1.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Example 1.</h6>

    <p class="text-gray-300">The following are examples of UTxO-based transactions:</p>

    <p class="text-gray-300"><span class="math">t_{1}\\stackrel{{\\scriptstyle\\rm def}}{{=}}\\textsf{UtxoTx}(\\emptyset,\\textsf{[Output(@1,</span>1000)],<span class="math">1000,</span>0)}$</p>

    <p class="text-gray-300"><span class="math">t_{2}\\stackrel{{\\scriptstyle\\rm def}}{{=}}\\textsf{UtxoTx}(\\{\\textsf{Input}(t_{1}^{\\#},0)\\},</span></p>

    <p class="text-gray-300"><span class="math">[\\textsf{Output(@2,</span>800),Output(@1,<span class="math">200)],</span>0,$0)</p>

    <p class="text-gray-300"><span class="math">t_{3}\\stackrel{{\\scriptstyle\\rm def}}{{=}}\\textsf{UtxoTx}(\\{\\textsf{Input}(t_{2}^{\\#},1)\\},[\\textsf{Output(@3,</span>199)],<span class="math">0,</span>1)</p>

    <p class="text-gray-300"><span class="math">t_{4}\\stackrel{{\\scriptstyle\\rm def}}{{=}}\\textsf{UtxoTx}(\\{\\textsf{Input}(t_{3}^{\\#},0)\\},[\\textsf{Output(@2,</span>207)],<span class="math">10,</span>2)</p>

    <p class="text-gray-300"><span class="math">t_{5}\\stackrel{{\\scriptstyle\\rm def}}{{=}}\\textsf{UtxoTx}(\\{\\textsf{Input}(t_{4}^{\\#},0),\\textsf{Input}(t_{2}^{\\#},0)\\},</span></p>

    <p class="text-gray-300"><span class="math">[\\textsf{Output(@2,</span>500),Output(@3,<span class="math">500)],</span>0,$7)</p>

    <p class="text-gray-300"><span class="math">t_{6}\\stackrel{{\\scriptstyle\\rm def}}{{=}}\\textsf{UtxoTx}(\\{\\textsf{Input}(t_{5}^{\\#},0),\\textsf{Input}(t_{5}^{\\#},1)\\},</span></p>

    <p class="text-gray-300"><span class="math">[\\textsf{Output(@3,</span>999)],<span class="math">0,</span>1)$</p>

    <p class="text-gray-300">Transaction <span class="math">t_{1}</span> forges <span class="math">1000, creates a </span>1000 coin and assigns it to address @1. In transaction <span class="math">t_{2}</span>, @1 spends</p>

    <p class="text-gray-300">it, giving an <span class="math">800 coin to @2 and a </span>200 coin back to itself. In transaction <span class="math">t_{3}</span>, besides a coin to @3, a fee or tax of <span class="math">1 is paid. In </span>t_{4}<span class="math">, @3 spends its </span>199 coin, forges <span class="math">10, pays a </span>2 fee and creates a <span class="math">207 coin for @2. In </span>t_{5}<span class="math">, the </span>207 and <span class="math">800 coins of @2 are spent and two </span>500 coins are created, one of them owned by @3 and the other owned by @2. In <span class="math">t_{6}</span> these two coins are spent, a new <span class="math">999 coin for @3 is created and a </span>1 fee is paid. Each of these transactions is valid for a ledger consisting of the previous transactions, in order. In the final ledger <span class="math">\\lambda\\doteq[t_{6},t_{5},t_{4},t_{3},t_{2},t_{1}]</span>, the unspent outputs are: <span class="math">\\texttt{unspentOutputs}(\\lambda)\\doteq\\{\\texttt{Input}(t_{6}^{\\#},0)\\}</span>. The balance of @3 is <span class="math">\\mathcal{B}_{\\texttt{UTxO}}(@3,\\lambda)\\doteq 999</span>; the balance of any other address is zero. A total of <span class="math">1010 has been forged and a total of </span>11 has been destroyed in fees.</p>

    <p class="text-gray-300">Remarks about Bitcoin: In Bitcoin’s implementation <em>[18]</em>, <span class="math">\\mathit{forge}</span> and <span class="math">\\mathit{fee}</span> are implicit. The fee is assumed to be the total value of inputs minus the total value of outputs in a transaction with at least one input or zero otherwise, and the forged amount is supposed to be equal to the total value of the outputs in a coinbase transaction without inputs or zero otherwise. The framework presented here is slightly more flexible and general, because a transaction may simultaneously have non-zero fee and forge values and may have non-zero forge values even with a non-empty set of inputs (as illustrated in transaction <span class="math">t_{4}</span> in Example 1).</p>

    <h2 id="sec-15" class="text-2xl font-bold">4 Account-Based Cryptocurrencies</h2>

    <p class="text-gray-300">Whereas Bitcoin, with its UTxO-based approach, aimed to be an account-less electronic cash system, other cryptocurrencies, such as Ethereum and all ERC-20 tokens, opted for cash-less account-based systems. An address is seen as an account, and a transaction transfers a value from one account to another. Every transaction also contains a unique nonce to protect against replay attacks. To allow transactions that just create money and assign it a receiver or that just take money from a sender and spend it as fee, both the sender and the receiver are optional.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Definition 9.</h6>

    <p class="text-gray-300">The datatype for account-based transaction is defined as:</p>

    <p class="text-gray-300"><span class="math">\\texttt{AccTx}\\stackrel{{\\scriptstyle\\mathfrak{def}}}{{=}}(sender\\!:\\!\\!\\texttt{Option[Address]},</span> <span class="math">\\textit{receiver}\\!:\\!\\!\\texttt{Option[Address]},</span> <span class="math">\\textit{value}\\!:\\!\\!\\texttt{Value},\\textit{forge}\\!:\\!\\!\\texttt{Value},\\textit{fee}\\!:\\!\\!\\texttt{Value},</span> <span class="math">\\textit{nonce}\\!:\\!\\!\\texttt{Int})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Without a unique id, nothing would prevent the receiver of an authorized transaction from including it multiple times in the ledger.</li>

    </ol>

    <p class="text-gray-300">with the following requirement:</p>

    <p class="text-gray-300">value is preserved:</p>

    <p class="text-gray-300"><span class="math">t.\\mathit{forge}+\\sum_{s\\in s.\\mathit{sender}}(t.\\mathit{value}+t.\\mathit{fee}-t.\\mathit{forge})</span> <span class="math">\\parallel</span> <span class="math">t.\\mathit{fee}+\\sum_{r\\in t.\\mathit{receiver}}t.\\mathit{value}</span></p>

    <p class="text-gray-300">The balance of an address in a transaction is what the address receives (if it is the receiver) minus what it spends (if it is the sender).</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Definition 10.</h6>

    <p class="text-gray-300">The account-balance of an address <span class="math">a</span> in a transaction <span class="math">t</span> is:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}_{\\texttt{Acc}}\\!:\\!\\!\\texttt{Address}\\rightarrow\\texttt{UtxoTx}\\rightarrow\\texttt{Value}</span> <span class="math">\\mathcal{B}_{\\texttt{Acc}}(a,t)\\stackrel{{\\scriptstyle\\mathfrak{def}}}{{=}}received-spent</span> where : <span class="math">received</span> <span class="math">=\\texttt{if }(a\\in t.\\textit{receiver})\\ t.\\textit{value}\\ \\texttt{else}\\ 0</span> <span class="math">\\textit{spent}</span> <span class="math">=\\texttt{if }(a\\in t.\\textit{sender})\\ t.\\textit{value}+t.\\textit{fee}-t.\\textit{forge}</span> <span class="math">\\text{else}\\ 0</span></p>

    <p class="text-gray-300">As before, the balance of an address in a ledger can be defined inductively, treating each transaction’s balance for the address as a balance update.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Definition 11.</h6>

    <p class="text-gray-300">The account-balance of an address <span class="math">a</span> in a ledger <span class="math">\\lambda</span> is:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}_{\\texttt{Acc}}\\!:\\!\\!\\texttt{Address}\\rightarrow\\texttt{Ledger}\\rightarrow\\texttt{Value}</span> <span class="math">\\mathcal{B}_{\\texttt{Acc}}(a,[])\\stackrel{{\\scriptstyle\\mathfrak{def}}}{{=}}0</span> <span class="math">\\mathcal{B}_{\\texttt{Acc}}(a,t\\!:\\!:\\!\\lambda)\\stackrel{{\\scriptstyle\\mathfrak{def}}}{{=}}\\mathcal{B}_{\\texttt{Acc}}(a,\\lambda)+\\mathcal{B}_{\\texttt{Acc}}(a,t,\\lambda)</span></p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Definition 12.</h6>

    <p class="text-gray-300">An account-based transaction <span class="math">t</span> is valid for a ledger <span class="math">\\lambda</span> iff the following two conditions hold:</p>

    <p class="text-gray-300">sender has enough money:</p>

    <p class="text-gray-300"><span class="math">\\forall s\\in t.\\mathit{sender},\\mathcal{B}_{\\texttt{Acc}}(s,\\lambda)\\geq t.\\mathit{value}+t.\\mathit{fee}-t.\\mathit{forge}</span> transaction is unique: <span class="math">\\forall t^{\\prime}\\in\\lambda,t^{\\prime}\\neq t</span></p>

    <p class="text-gray-300">The definitions above are illustrated in Example 2.</p>

    <p class="text-gray-300">Example 2. The following are examples of account-based transactions:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} t _ {1} \\stackrel {\\text {d e f}} {=} (\\mathrm {n o n e}, \\mathrm {s o m e} (@ 1), \\$ 1000, \\$1000, \\$0, 0) \\\\ t _ {2} \\stackrel {\\text {d e f}} {=} (\\mathrm {s o m e} (@ 1), \\mathrm {s o m e} (@ 2), \\$800, \\$0, \\$0, 0) \\\\ t _ {3} \\stackrel {\\text {d e f}} {=} (\\mathrm {s o m e} (@ 1), \\mathrm {s o m e} (@ 3), \\$199, \\$0, \\$1, 0) \\\\ t _ {4} \\stackrel {\\text {d e f}} {=} (\\mathrm {s o m e} (@ 3), \\mathrm {s o m e} (@ 2), \\$207, \\$10, \\$2, 0)]) \\\\ t _ {5} \\stackrel {\\text {d e f}} {=} (\\mathrm {s o m e} (@ 2), \\mathrm {s o m e} (@ 3), \\$500, \\$0, \\$7, 0)]) \\\\ t _ {6} \\stackrel {\\text {d e f}} {=} (\\mathrm {s o m e} (@ 2), \\mathrm {s o m e} (@ 3), \\$499, \\$0, \\$1, 0)]) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">The transactions listed above achieve the same effects as the transactions in Example 1. In the final ledger  <span class="math">\\lambda \\doteq [t_6, t_5, t_4, t_3, t_2, t_1]</span> ,  <span class="math">\\mathcal{B}_{\\mathrm{ACC}}(\\mathbb{Q}3, \\lambda) \\doteq 999</span> .</p>

    <p class="text-gray-300">Remarks about Ethereum: Note that Ethereum has a more strict condition for the transaction's nonce. Whereas here it is only required that there be no  <span class="math">t&#x27; \\in \\Lambda&#x27;</span>  such that  <span class="math">t&#x27; = t</span> , Ethereum requires that  <span class="math">t.nonce = t^<em>.nonce + 1</span> , if  <span class="math">t^</em></span>  is the most recent transaction in  <span class="math">\\Lambda&#x27;</span>  such that  <span class="math">t^*.sender = t.sender</span> . The weaker condition used here is sufficient to prevent replays and allows transactions to be processed in any order. Ethereum's condition, on the other hand, gives users control over the order in which their transactions should be executed and can be more efficiently checked, as it only requires a comparison with the most recent transaction from the same sender already in the ledger. The weaker condition is adopted here, because it is more general and hence encompasses also potential account-based cryptocurrencies that are less strict than Ethereum. In Ethereum, ethers can be transferred either directly through an externally created message or through a message created during the execution of a contract. Ethereum uses the word "transaction" only for the former.</p>

    <p class="text-gray-300">Remarks about ERC-20 Tokens: In ERC-20 tokens, value is transferred by sending an Ethereum transaction that calls the 'transfer' function of the token's contract. Although the Ethereum transaction that wraps the function call has a fee and a nonce, the transfer function itself has no fee, forge or nonce arguments. Therefore, the notion of ERC-20 transfer is mostly less general than this paper's notion of account-based transaction. However, because an ERC-20 transfer pays fees in a different currency (i.e. ethers), the definitions discussed here would have to be generalized (straightforwardly) to a multi-currency scenario to fully simulate ERC-20.</p>

    <p class="text-gray-300">As illustrated by examples 1 and 2, it is possible to have UTxO-based and account-based transactions that have the same effect. The following two subsections describe how to translate transactions from one style to another in general. The translations produce equivalent transactions in the sense of Definition 13.</p>

    <p class="text-gray-300">Definition 13. A list <span class="math">^8</span>  of transactions  <span class="math">\\ell \\doteq [t_n, \\ldots, t_1]</span>  on a ledger  <span class="math">\\lambda</span>  is equivalent to a list of transactions  <span class="math">\\ell&#x27; \\doteq [t_m&#x27;, \\ldots, t_1&#x27;]</span>  on a ledger  <span class="math">\\lambda&#x27;</span>  iff the following hold:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\text{equal forged amounts:} \\quad \\text{equal fees:} \\\\ \\sum_{t \\in \\ell} t. \\text{forge} = \\sum_{t&#x27; \\in \\ell&#x27;} t&#x27;. \\text{forge} \\quad \\sum_{t \\in \\ell} t. \\text{fee} = \\sum_{t&#x27; \\in \\ell&#x27;} t&#x27;. \\text{fee} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">balance effects are equal:</p>

    <div class="my-4 text-center"><span class="math-block">\\forall a, \\mathcal {B} (a, \\ell ::: \\lambda) - \\mathcal {B} (a, \\lambda) = \\mathcal {B} (a, \\ell^ {\\prime}:::: \\lambda^ {\\prime}) - \\mathcal {B} (a, \\lambda^ {\\prime})</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathcal{B}(a,\\lambda)\\stackrel {\\mathrm{def}}{=}\\mathcal{B}_{\\mathrm{ACC}}(a,\\lambda) + \\mathcal{B}_{\\mathrm{UTxO}}(a,\\lambda).</span></p>

    <p class="text-gray-300">If  <span class="math">t</span>  is an account-based transaction, let  <span class="math">\\mathcal{T}_{\\mathrm{UTxO}}^{\\mathrm{ACC}}(t,\\lambda&#x27;)</span>  be a UTxO-translation of  <span class="math">t</span>  for a target ledger  <span class="math">\\lambda&#x27;</span>  (assumed to be such that  <span class="math">\\mathcal{B}_{\\mathrm{UTxO}}(s,\\lambda&#x27;) \\geq t.value + t.fee - t.forge</span> , if  <span class="math">t</span> 's sender is  <span class="math">s</span> ) constructed as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let  <span class="math">spent \\stackrel{\\text{def}}{=} t.value + t.fee - t.forge</span> , if  <span class="math">t.sender = \\text{some}(s)</span> , and  <span class="math">spent \\stackrel{\\text{def}}{=} 0</span> , otherwise.</li>

      <li>Construct a subset  <span class="math">I</span>  of inputs from unspentOutputs  <span class="math">(\\lambda^{\\prime})</span>  such that  <span class="math">\\forall i \\in I, \\text{out}(i).get.address = t.sender.get</span>  and  <span class="math">\\sum_{i \\in I} \\text{out}(i).get.value \\geq spent</span></li>

      <li>If  <span class="math">t.receiver = \\mathrm{some}(r)</span>  for some address  <span class="math">r</span> , construct an output  <span class="math">\\mathsf{Output}(r, t.value)</span> .</li>

      <li>If  <span class="math">t.sender = \\mathrm{some}(s)</span>  for some address  <span class="math">s</span> , construct an output  <span class="math">\\mathsf{Output}(s, change)</span> , where  <span class="math">change = spent - t.value</span> .</li>

      <li>Let  <span class="math">O</span>  be a list of outputs containing the outputs constructed in the previous two steps.</li>

      <li>Let  <span class="math">\\mathcal{T}_{\\mathrm{UTxO}}^{\\mathrm{ACC}}(t,\\lambda&#x27;) \\stackrel{\\mathrm{def}}{=} \\mathsf{UtxoTx}(I,O,t.forge,t.fee)</span> .</li>

    </ol>

    <p class="text-gray-300">The following proposition can be proven easily by analyzing the four cases depending on whether  <span class="math">t.receiver</span>  and  <span class="math">t.sender</span>  are defined.</p>

    <p class="text-gray-300">Proposition 1.  <span class="math">[\\mathcal{T}_{\\mathrm{UTxO}}^{\\mathrm{ACC}}(t,\\lambda^{\\prime})]</span>  on  <span class="math">\\lambda^\\prime</span>  is equivalent to  <span class="math">[t]</span>  on ledger  <span class="math">\\lambda</span>  , for any account-based transaction  <span class="math">t</span>  and</p>

    <p class="text-gray-300">ledgers <span class="math">\\lambda</span> and <span class="math">\\lambda&#x27;</span> such that <span class="math">\\mathcal{B}_{\\mathrm{AC}(s,\\lambda)} \\geq \\text{spent}</span> and <span class="math">\\mathcal{B}_{\\mathrm{UTxO}}(s,\\lambda&#x27;) \\geq \\text{spent}</span>, where <span class="math">\\text{spent} = t.\\text{value} + t.\\text{fee} - t.\\text{forge}</span>, if <span class="math">t.\\text{sender} = \\mathrm{some}(s)</span>.</p>

    <p class="text-gray-300">In general, many translations are possible, because there may be many choices of <span class="math">I</span> in step 2.</p>

    <p class="text-gray-300">The translation described above assumes that each address in the source ledger <span class="math">\\lambda</span> is mapped to the same single address in the target ledger <span class="math">\\lambda&#x27;</span> (and it may even be the case that <span class="math">\\lambda&#x27; = \\lambda</span>). It is straightforward to generalize this translation to the case where each address in the source ledger is mapped to a set of addresses in the target ledger. In step 2 it would be necessary to search for inputs that belong to any of the addresses in the set to which the sender of <span class="math">t</span> is mapped. And in steps 3 and 4, it would be necessary to distribute the value and the change among the addresses in the sets to which the receiver and the sender of <span class="math">t</span> are mapped, respectively, thereby creating a list of outputs instead of a single output in each step. The distribution leads to more degrees of freedom and hence to a greater number of possible translations.</p>

    <h2 id="sec-22" class="text-2xl font-bold">5.2. From UTxO-Based to Account-Based</h2>

    <p class="text-gray-300">Translating in the other direction is more difficult.</p>

    <p class="text-gray-300"><strong>Proposition 2.</strong> For an arbitrary UTxO-based transaction <span class="math">t</span> on a source ledger <span class="math">\\lambda</span>, there is generally no account-based transaction <span class="math">t&#x27;</span> and target ledger <span class="math">\\lambda&#x27;</span> such that <span class="math">[t]</span> on <span class="math">\\lambda</span> is equivalent to <span class="math">[t&#x27;]</span> on <span class="math">\\lambda&#x27;</span>.</p>

    <p class="text-gray-300"><strong>Proof:</strong> Consider the ledger <span class="math">\\lambda</span> of Example 1 and a new transaction</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} t_7 \\stackrel{\\text{def}}{=} \\mathrm{UTxO-Tx}(\\{\\mathrm{Input}(t_6^#, 0)\\}, \\\\ [\\mathrm{Output}(\\#1, \\$499), \\mathrm{Output}(\\#2, \\$499)], \\$0, \\$1) \\end{array}</span></div>

    <p class="text-gray-300">which has a single sender (<span class="math">\\#3</span>) and two different receivers (<span class="math">\\#1</span> and <span class="math">\\#2</span>). Any account-based transaction <span class="math">t&#x27;</span> has at most one receiver. Therefore, <span class="math">t&#x27;</span> could transfer money to <span class="math">\\#1</span> or <span class="math">\\#2</span>, but not to both.</p>

    <p class="text-gray-300">Whenever a UTxO-based transaction has more than one sender or more than one receiver, it cannot be translated into a single equivalent account-based transaction. But it can be translated into a list of account-based transactions. One way to approach this problem is to see it as constraint satisfaction problem: if a UTxO-based transaction <span class="math">t</span> in a ledger <span class="math">\\lambda</span> has <span class="math">n</span> senders and <span class="math">m</span> receivers, an account-based transaction <span class="math">t_{(s,r)}&#x27;</span> may be created for</p>

    <p class="text-gray-300">each pair of sender and receiver <span class="math">(s,r)</span> in such a way that <span class="math">\\sum_{s,r} t_{(s,r)}&#x27; \\cdot fee = t.fee</span>, <span class="math">\\sum_{s,r} t_{(s,r)}&#x27; \\cdot forge = t.forge</span>, <span class="math">\\sum_{r} t_{(s,r)}&#x27; \\cdot value = \\sum_{o \\in t.\\text{outputs}, n.\\text{addresses}} o.\\text{value}</span> and <span class="math">\\sum_{r} (t_{(s,r)}&#x27; \\cdot value + t_{(s,r)}&#x27; \\cdot fee - t_{(s,r)}&#x27; \\cdot forge) = \\sum_{i \\in t.\\text{inputs}, out(i).get. addresses}} out(i).get.value</span>. This approach is very general: all possible equivalent nonredundant account-based transaction sequences can be generated as solutions to this constraint satisfaction problem. However, it can lead to <span class="math">n \\times m</span> transactions.</p>

    <p class="text-gray-300">Fortunately, the problem is loosely constrained, and it is in fact always possible to solve the problem with at most <span class="math">n + m</span> transactions and at least <span class="math">\\max(n, m)</span> transactions. To obtain a solution that is optimal on the number of transactions, the constraint satisfaction problem could be turned into an optimization problem, but solving the optimization problem would be computationally expensive. Instead, the proposal below describes a heuristic translation that is guaranteed to be within these bounds and to run in <span class="math">\\mathcal{O}(n + m)</span>, although it is not guaranteed to obtain the smallest possible number of transactions. During its execution, the translation optimistically expects that it will generate exactly <span class="math">\\max(n^<em>, m^</em>)</span> account-based transactions (where <span class="math">n^<em></span> and <span class="math">m^</em></span> are the numbers of senders and receivers that remain to be considered), and tries (but doesn't always perfectly succeed) to distribute the remaining fee and the remaining forged value evenly across the generated transactions.</p>

    <p class="text-gray-300">If <span class="math">t</span> is a valid UTxO-based transaction for a source ledger <span class="math">\\lambda</span>, let <span class="math">\\mathcal{T}_{\\mathrm{AC}}^{\\mathrm{UTxO}}(t,\\lambda)</span> be an account-translation of <span class="math">t</span> for the source ledger <span class="math">\\lambda</span> constructed as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initialize <span class="math">ss</span> as the list of senders of <span class="math">t</span> (i.e. those addresses <span class="math">a</span> such that <span class="math">\\mathcal{B}_{\\mathrm{UTxO}}(a,t,\\lambda) &amp;lt; 0</span>).</li>

      <li>Initialize <span class="math">rs</span> as the list of receivers of <span class="math">t</span> (i.e. those addresses <span class="math">a</span> such that <span class="math">\\mathcal{B}_{\\mathrm{UTxO}}(a,t,\\lambda) &amp;gt; 0</span>).</li>

      <li>Initialize <span class="math">remForge \\gets t.forge</span> (the remaining forge) and <span class="math">remFee \\gets t.fee</span> (the remaining fee).</li>

      <li>For every <span class="math">s \\in ss</span>, initialize <span class="math">remSpend(s) \\gets -\\mathcal{B}_{\\mathrm{UTxO}}(s, t, \\lambda)</span>, where <span class="math">remSpend</span> is a map storing the remaining amount each sender should spend.</li>

      <li>For every <span class="math">r \\in rs</span>, initialize <span class="math">remReceive(s) \\gets \\mathcal{B}_{\\mathrm{UTxO}}(s, t, \\lambda)</span>, where <span class="math">remReceive</span> is a map storing the remaining amount each receiver should receive.</li>

      <li>Initialize <span class="math">result \\gets []</span></li>

      <li>While <span class="math">ss</span> is non-empty or <span class="math">rs</span> is non-empty, execute one of the following cases:</li>

    </ol>

    <p class="text-gray-300">A) If both <span class="math">ss</span> and <span class="math">rs</span> are non-empty, let <span class="math">s</span> and <span class="math">r</span> be their heads and <span class="math">st</span> and <span class="math">rt</span> their tails and do:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A sequence of transactions is redundant iff there is more than one transaction from the same sender to the same receiver.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. $expectNumTrans\\leftarrow max(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ss</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">rs</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^{10}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">fee\\leftarrow remFee/ expectNumTrans</span></li>

      <li><span class="math">forge\\leftarrow remForge/ expectNumTrans</span></li>

      <li><span class="math">v\\leftarrow remSpend(s)-fee+forge</span></li>

      <li>if <span class="math">v=remReceive(r)</span>, do <span class="math">ss\\leftarrow st</span> and <span class="math">rs\\leftarrow rt</span>;</li>

    </ol>

    <p class="text-gray-300">else if <span class="math">v&lt;remReceive(r)</span>, do <span class="math">fee\\leftarrow fee<em>(v/remReceive(r))</span> and <span class="math">forge\\leftarrow forge</em>(v/remReceive(r))</span> (reducing the fee and forge in order to heuristically account for the larger than expected number of transactions) and do <span class="math">ss\\leftarrow st</span> (leaving <span class="math">rs</span> unchanged); otherwise (if <span class="math">v&gt;remReceive</span>)), do <span class="math">fee\\leftarrow fee<em>(remReceive(r)/v)</span>, <span class="math">forge\\leftarrow forge</em>(remReceive(r)/v)</span> (reducing the fee and forge in order to heuristically account for the larger than expected number of transactions), <span class="math">v\\leftarrow remReceive(r)</span> and <span class="math">rs\\leftarrow rt</span> (leaving <span class="math">ss</span> unchanged).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Add the following transaction to result: AccTx(some<span class="math">(s)</span>, some<span class="math">(r),v,forge,fee,0)</span></li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">ss</span> is empty, let <span class="math">r</span> be the head and <span class="math">rt</span> the tail of <span class="math">rs</span> and do:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. <span class="math">v\\leftarrow remReceive(r)</span>; $fee\\leftarrow remFee/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">rs</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">; </span>forge\\leftarrow v+fee$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Add the following transaction to result: AccTx(none, some<span class="math">(r),v,forge,fee,0)</span></li>

      <li><span class="math">rs\\leftarrow rt</span></li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">rs</span> is empty, let <span class="math">s</span> be the head and <span class="math">st</span> the tail of <span class="math">ss</span> and do:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. <span class="math">v\\leftarrow 0</span>; $fee\\leftarrow remFee/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ss</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">; </span>forge\\leftarrow fee-remSpend(s)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Add the following transaction to result: AccTx(some<span class="math">(s)</span>, none, <span class="math">0,forge,fee,0)</span></li>

      <li><span class="math">ss\\leftarrow st</span></li>

    </ol>

    <p class="text-gray-300">and then update the state as follows: <span class="math">remForge\\leftarrow remForge-forge</span>; <span class="math">remFee\\leftarrow remFee-fee</span>; <span class="math">remSpend(s)\\leftarrow remSpend(s)-(v+fee-forge)</span> and <span class="math">remReceive(r)\\leftarrow remReceive(s)-v</span> (if <span class="math">s</span> and <span class="math">r</span> are defined, respectively).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathcal{T}_{\\text{\\tiny Acc}}^{\\text{\\tiny UTxO}}(t,\\lambda)\\stackrel{{\\scriptstyle\\text{\\tiny def}}}{{=}}\\text{\\it result}</span></li>

    </ul>

    <p class="text-gray-300">All account-based transactions generated by the translation have nonces set to zero by default. Before using them on a target ledger, it may be necessary to increment their nonces. Alternatively, the target ledger could be passed as an extra argument to <span class="math">\\mathcal{T}_{\\text{\\tiny Acc}}^{\\text{\\tiny UTxO}}</span>, which would then inspect the target ledger and create transactions with nonces that guarantee uniqueness. The translation assumes the target ledger has a permissive monetary policy that does not restrict forging, and tries to distribute <span class="math">t.forge</span> evenly across all generated transactions. If this is not the case, the translation should be modified to adhere to the monetary policy. To simplify the presentation, it has been assumed that an address in the source ledger (of the UTxO-based transaction) corresponds to the same address in the target ledger (of the account-based transactions obtained by translation). It would be straightforward to generalize the translation to the case where an address in the source ledger is mapped to another address (or even to a set of addresses) in the target ledger. The following propositions hold.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Proposition 3.</h6>

    <p class="text-gray-300"><span class="math">\\mathcal{T}_{\\text{\\tiny Acc}}^{\\text{\\tiny UTxO}}(t,\\lambda)</span> on <span class="math">\\lambda^{\\prime}</span> is equivalent to <span class="math">[t]</span> on ledger <span class="math">\\lambda</span>, for any UTxO-based transaction <span class="math">t</span> and ledgers <span class="math">\\lambda</span> and <span class="math">\\lambda^{\\prime}</span> such that <span class="math">\\mathcal{B}_{\\text{\\tiny Acc}}(s,\\lambda^{\\prime})\\geq\\mathcal{B}_{\\text{\\tiny UTxO}}(s,t,\\lambda)</span> for every sender address in <span class="math">t</span>.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Proposition 4.</h6>

    <p class="text-gray-300"><span class="math">\\mathcal{T}_{\\text{\\tiny Acc}}^{\\text{\\tiny UTxO}}(t,\\lambda)</span> can be computed in <span class="math">\\mathcal{O}(n+m)</span> and in <span class="math">\\Omega(\\max(n,m))</span>, where <span class="math">n</span> is the number of senders and <span class="math">m</span> is the number of receivers of <span class="math">t</span>, and the number of generated transactions <span class="math">g</span> is such that <span class="math">max(n,m)\\leq g\\leq n+m</span>.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that, for every iteration of the while loop, one address is removed from either <span class="math">ss</span> or <span class="math">rs</span>, and sometimes (when <span class="math">v=remReceive(r)</span> in step 7.A.5) both <span class="math">ss</span> and <span class="math">rs</span> have an address removed. Therefore, if $n=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ss</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>m=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">rs</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> at the beginning, there will be at least </span>\\max(n,m)<span class="math"> and at most </span>n+m<span class="math"> iterations of the while loop. Since all steps in each iteration can be done in constant time w.r.t. </span>n<span class="math"> and </span>m<span class="math">, the running-time is in </span>\\mathcal{O}(n+m)<span class="math"> and in </span>\\Omega(\\max(n,m))<span class="math">. As every iteration generates a transaction, the total number of generated transactions is between </span>max(n,m)<span class="math"> and </span>n+m$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-26" class="text-2xl font-bold">6 Comparison and Unification</h2>

    <p class="text-gray-300">Despite the accounting equivalence implied by the translations, Proposition 2 and the translation of Sec. 5.2 show that it is generally necessary to create several account-based transactions to simulate the effect of a single UTxO-based transaction. This is important: while all the value transfers in a single UTxO-based transaction are processed atomically and simultaneously, the corresponding account-based transactions are not guaranteed to be so. Theoretically, there may be a wide time gap between their executions.</p>

    <p class="text-gray-300">Moreover, whereas a single UTxO-based transaction with multiple inputs and outputs does not need</p>

    <p class="text-gray-300">to match senders with receivers, the corresponding sequence of account-based transaction must do so, arbitrarily, even though this information may be irrelevant. A consequence of this fact is that a single UTxO-based transaction with multiple inputs and outputs can be (linearly) more concise than the corresponding sequence of account-based transactions.</p>

    <p class="text-gray-300">On the other hand, account-based transactions are clearly simpler and more concise for transfers between two addresses, because the change’s value and destination do not need to be explicitly stated. Furthermore, value preservation is something that depends only on the transaction itself (and is even trivial when both sender and receiver are defined), whereas checking value preservation with UTxO requires searching the values of the unspent outputs referred by the inputs and hence does not depend only on the transaction itself.</p>

    <p class="text-gray-300">Algebraically, the operation of composition of two UTxO-based transactions is easily definable (i.e. as long as the two transactions do not spend the same unspent output, there is another UTxO-based transaction that has the same effect as the two transactions combined), whereas account-based transactions can only be composed into a single new account-based transaction if they involve the same addresses.</p>

    <p class="text-gray-300">There are two trivial solutions for the problem of lack of atomicity in the account-based style. Firstly, a new “wrapper” transaction type could be defined, to contain a list of account-based transactions that ought to be executed atomically. Secondly, the account-based transaction type AccTx could be modified to include an optional pointer to another account-based transaction, and the notion of ledger could be modified to only allow the simultaneous inclusion of such chains of account-based transactions. However, a better solution, that unifies ideas from both styles and combines their above mentioned advantages, is proposed below.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Definition 14.</h6>

    <p class="text-gray-300">The hybrid transaction type is:</p>

    <p class="text-gray-300"><span class="math">\\textsf{HybridTx}\\overset{\\textsf{def}}{=}\\left(\\textit{inputs}:\\textsf{Map[Address,Value]},~{}\\right.</span> <span class="math">\\textit{outputs}:\\textsf{Map[Address,Value]},~{}</span> <span class="math">\\textit{forge}:\\textsf{Value},\\textit{fee}:\\textsf{Value},\\textit{nonce}:\\textsf{Int})</span></p>

    <p class="text-gray-300">requiring value preservation.</p>

    <p class="text-gray-300">The inputs and outputs are simply maps from addresses to values that they spend or receive through the transaction. The transaction updates the account balances of these addresses as expected. To be valid, senders of a hybrid transaction must have a positive balance on the ledger and the transaction must be unique.</p>

    <h2 id="sec-28" class="text-2xl font-bold">7. Chimeric Ledgers</h2>

    <p class="text-gray-300">Definition 1 already allows a ledger to contain transactions of various types. However, for UTxO- and account-based transactions to co-exist meaningfully, users should be able to convert their UTxO balances into account balances and vice versa. The conversion can be enabled through new transaction types.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Definition 15.</h6>

    <p class="text-gray-300">The type for deposit transactions is:</p>

    <p class="text-gray-300"><span class="math">\\textsf{DepTx}\\overset{\\textsf{def}}{=}\\left(\\textit{inputs}:\\textsf{Set[Input]},~{}\\textsf{depositor}:\\textsf{Address},~{}\\right.</span> <span class="math">\\textit{forge}:\\textsf{Value},\\textit{fee}:\\textsf{Value})</span></p>

    <p class="text-gray-300">The type for withdrawal transactions is:</p>

    <p class="text-gray-300"><span class="math">\\textsf{WithTx}\\overset{\\textsf{def}}{=}\\left(\\textit{withdrawer}:\\textsf{Address},\\textit{outputs}:\\textsf{List[Output]},~{}\\right.</span> <span class="math">\\textit{forge}:\\textsf{Value},\\textit{fee}:\\textsf{Value},\\textit{nonce}:\\textsf{Int})</span></p>

    <p class="text-gray-300">Through the analogy that sees UTxO-based transactions as cash-like transfers and account-based transactions as bank account transfers, it can be said that a deposit transaction takes coins and notes of various denominations (i.e. the inputs) and deposits them in the depositor’s account. The inputs are considered spent, and the account balance of the depositor’s address is increased by an amount equal to what has been spent minus the fee and plus any forged amount. A withdrawal transaction does the opposite. It reduces the account balance of the withdrawer’s address by an amount equal to the total value of the withdrawn coins and notes (i.e. the generated outputs) plus the fee and minus the forged amount.</p>

    <h2 id="sec-30" class="text-2xl font-bold">8. Discussion</h2>

    <p class="text-gray-300">Related Work: The definitions in Sec. 3 are inspired by similar definitions in <em>[19, 20]</em> and <em>[21]</em>. In contrast to those works, the framework described here has explicit fees and forged values and focuses only on accounting. The definitions in Sec. 4 aim to be a simplification and generalization, again focusing only on accounting, of similar definitions in <em>[10]</em> and <em>[16]</em>. The work in <em>[22]</em> presents a formal graph-based framework that can be instantiated to both UTxO and account-based transactions.</p>

    <p class="text-gray-300">Hybrid transactions combine the best of both styles. They have the atomicity and algebraic elegance of UTxO-based transactions and the simplicity and locality of account-based transactions.</p>

    <p class="text-gray-300">With a chimeric ledger, the dilemma of choosing between UTxO and account-based styles can be avoided. Instead, both transaction styles are offered, and users may choose whatever they prefer. If there is any difference between the two styles (e.g. storage space, processing time, privacy, suitability for smart contracts, …), the free market would naturally price each transaction style differently.</p>

    <p class="text-gray-300">The new deposit and withdrawal transaction types may be helpful to describe the transfer of assets between a main chain and a sidechain when each chain uses a different accounting style. Furthermore, they could also be useful in scenario where account-based smart contracts needed to be executed in a mostly UTxO-based ledger: a contract could receive funds through a deposit transaction and pay out funds through withdrawal transaction. Alternatively, the translations defined in Sec. 5 could be used to allow smart contracts to operate directly with UTxO under the surface, although with an account-based semantics in the programming language level.</p>

    <p class="text-gray-300">The minimalistic abstract and general models presented in sections 3 and 4 can be (and have already been) used for test-driven development of software wallets. Planned future work includes extending these models to the multi-asset case, and developing monetary policy layers on top of these models.</p>

    <p class="text-gray-300">Acknowledgments: the author is grateful to Alexander Chepurnoy, Duncan Coutts, Edsko de Vries, Philipp Kant and Philip Wadler for fruitful discussions on drafts of this paper.</p>

    <h2 id="sec-31" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] “Bisq: The peer-to-peer bitcoin exchange.” [Online]. Available: https://github.com/bisq-network/docs/blob/master/exchange/whitepaper.adoc</li>

      <li>[2] “Atomic cross-chain trading,” <em>Bitcoin-Wiki</em>. [Online]. Available: en.bitcoin.it/wiki/Atomic_cross-chain_trading</li>

      <li>[3] M. Herlihy, “Atomic cross-chain swaps,” <em>CoRR</em>, vol. abs/1801.09515, 2018.</li>

      <li>[4] A. Back, M. Corallo, L. Dashjr, M. Friedenbach, G. Maxwell, A. Miller, A. Poelstra, J. Timoón, and P. Wuille, “Enabling blockchain innovations with pegged sidechains,” 2014. [Online]. Available: https://www.blockstream.com/sidechains.pdf</li>

      <li>[5] A. Kiayias, N. Lamprou, and A. Stouka, “Proofs of proofs of work with sublinear complexity,” in <em>Financial Cryptography and Data Security - FC 2016 International Workshops</em>, 2016, pp. 61–78.</li>

      <li>[6] “Cardano.” [Online]. Available: whycardano.com/</li>

      <li>[7] “Chainweb: A proof-of-work parallel-chain architecture for massive throughput (draft v15),” 2018. [Online]. Available: http://kadena.io/docs/chainweb-v15.pdf</li>

      <li>[8] S. Nakamoto, “Bitcoin: A peer-to-peer electronic cash system,” 2008.</li>

      <li>[9] V. Buterin, “Ethereum: A next generation smart contract & decentralized application platform,” <em>Ethereum Project White Paper</em>, 2014. [Online]. Available: http://www.the-blockchain.com/docs/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf</li>

      <li>[10] G. Wood, “Ethereum: A secure decentralised generalised transaction ledger,” <em>Ethereum Project Yellow Paper</em>, 2014. [Online]. Available: https://ethereum.github.io/yellowpaper/paper.pdf</li>

      <li>[11] V. Buterin, “Thoughts on utxos,” <em>Medium.com</em>, 2016. [Online]. Available: https://medium.com/@ConsenSys/thoughts-on-utxo-by-vitalik-buterin-2bb782c67e53</li>

      <li>[12] M. Hearn, “Rationale for and tradeoffs in adopting a utxo-style model,” <em>Corda Blog</em>, 2016. [Online]. Available: https://www.corda.net/2016/12/rationale-tradeoffs-adopting-utxo-style-model/</li>

      <li>[13] P. Dai, “Why qtum chose utxo model and the benefits,” <em>8BTC</em>, 2017. [Online]. Available: http://news.8btc.com/why-qtum-choose-utxo-model-and-the-benefits</li>

      <li>[14] “Design rationale: Blockchain-level protocol: Account and not utxos,” <em>Ethereum Wiki</em>, 2017. [Online]. Available: https://github.com/ethereum/wiki/wiki/Design-Rationale#accounts-and-not-utxos</li>

      <li>[15] “Utxo model vs. account/balance model (forum thread),” <em>StackExchange: Bitcoin</em>, 2017. [Online]. Available: https://bitcoin.stackexchange.com/questions/49853/utxo-model-vs-account-balance-model</li>

      <li>[16] F. Vogesteller and V. Buterin, “ERC-20 token standard,” <em>EIPs</em>, 2015. [Online]. Available: github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md</li>

      <li>[17] S. Popov, “The tangle,” <em>IOTA White Paper</em>, 2017. [Online]. Available: iota.org/IOTA_Whitepaper.pdf</li>

    </ul>

    <p class="text-gray-300">[18] “Transaction,” Bitcoin Wiki, July 2017. [Online]. Available: https://en.bitcoin.it/wiki/Transaction [19] B. White, “A theory for lightweight cryptocurrency ledgers,” 2015. [Online]. Available: https://github.com/ceilican/ledgertheory/blob/master/lightcrypto.pdf [20] N. Atzei, M. Bartoletti, S. Lande, and R. Zunino, “A formal model of bitcoin transactions,” Cryptology ePrint Archive, 2017. [Online]. Available: https://eprint.iacr.org/2017/1124.pdf [21] A. Chepurnoy, “The blockchain and the scorex tutorial,” Scorex Foundation, Tech. Rep., 2016. [Online]. Available: https://github.com/ScorexFoundation/ScorexTutorial/blob/master/scorex.pdf [22] C. Cachin, A. De Caro, P. Moreno-Sanchez, B. Tackmann, and M. Vukolić, “The transaction graph for modeling blockchain semantics,” 2017.</p>

    <pre><code>---BEGIN POP MESSAGE---
hQENA3eYtjicCb6G4Qf/ci7lKredlkdIEsxokkEdNRQYseQelIYAeqEeskvngsDJ
aCbKf3YXMAeEjueBW9EvTrjG8PnkLfv1N9tpfWemTuj65JcoiBkI/CGDeG2msuhd
tC+W9eo5s0+Z7p4HZPRFf1I4Im1Bow77JFNHcqqf/0G/sZ+7kk1gECZzs9bBE4b+
kG3EF1248D49JVukqIeiyybF4O9D80mDK4kKAJLuPysqrE8xfdODW8O5AsDOIsfY
YW8Jy4TdgikEDq6Ns0X4d/jcjBq03XM3NjvA7812X1ouNSFMyoNWcJNTw9J+sXNw
krtosI9Q/50S/C3FR/f87742gIFNgO81YXQvQstBLNLA7AOYfZvDYc7WG1iw8OJn
wP1JN4DOuOLvo11aej70h59vLqFQFsLjX0KsN77uaftXWpEIc+ETY4eD4mEttBnz
kLraN9ZRhx3x8yunujpBrZjp650E6KwGA/aOhTruB8ZN9GENVyL3tyqeBkOFbS3p
1XE1cCeE7TkcGkLpV9E/NsFPs2T1asR1814GwpLK7vw1OT44H3eN4+qc12FwtEe8
5rDKq6BGkhPKNC81sYcdtnNzdyjC82KbD31BrEB31c1Dv02sD20s+HEs18MmMknY
YW50Z75y8W3YfL5/00p0B4HqanpyZ1Hcq2P4wM9cjpPhnPc500chOYGdLAmKw1JL
uEC3dEOMy3LWtkBWQT1N6F/NA02W049mTLJN0I7nZn1GucIZYDkj3r/WaJHTZd7K
7A7BhaJD1Dbj5uC2F/qdHAuHVhetdpByv87wXWF1JMNFWvYnwOe99gqlj/aCCToE
fj01/sqpswoo4jNqc9kMEqpVYghoayeNy5fQYfsw/aaF0p382gfREbDeEbNfMV+f
Hq3MEU9SuSmfPyZnGLvr/f2u8o83e1b444mwtBj+
=cj7k
---END POP MESSAGE---</code></pre>`;
---

<BaseLayout title="Chimeric Ledgers: Translating and Unifying UTXO-based and Ac... (2018/262)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2018 &middot; eprint 2018/262
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
