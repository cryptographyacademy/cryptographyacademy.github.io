---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2022/1626';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'MinRoot: Candidate Sequential Function for  Ethereum VDF';
const AUTHORS_HTML = 'Dmitry Khovratovich, Mary Maller, Pratyush Ranjan Tiwari';

const CONTENT = `    <p class="text-gray-300">MinRoot: Candidate Sequential Function for Ethereum VDF</p>

    <p class="text-gray-300">Dmitry Khovratovich Ethereum Foundation khovratovich@gmail.com Mary Maller Ethereum Foundation mary.maller@ethereum.org Pratyush Ranjan Tiwari Johns Hopkins University ptiwari4@jhu.edu</p>

    <h6 id="sec-1" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">We present a candidate sequential function for a VDF protocol to be used within the Ethereum ecosystem. The new function, called MinRoot, is an optimized iterative algebraic transformation and is a strict improvement over competitors VeeDo and Sloth++. We analyze various attacks on sequentiality and suggest weakened versions for public scrutiny. We also announce bounties on certain research directions in cryptanalysis.</p>

    <h2 id="sec-2" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Distributed consensus protocols often require not only fast computations for efficiency, but also guaranteed slow computations for security. When we say guaranteed slow computations we mean that there is a lower bound on the time the computation takes even if one has access to an unlimited number of cores; i.e., the computation cannot be parallelized. Slow computations are required when a party is supposed to produce an output that will eventually benefit some other participants, so that the slowness of computation would guarantee unpredictability and thus fairness.</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">VDF usage in Ethereum.</h4>

    <p class="text-gray-300">An example of this requirement in Ethereum is the following. A group of 32 validators progressively builds a chain of collective randomness, with one value <span class="math">O</span> generated per epoch <span class="math">\\mathcal{E}</span>. This randomness is used to select, for example, which validator can add a block onto the blockchain and reap the rewards of doing so. If the randomness is unbiased then the frequency with which a validator is selected depends on their stake in the system. However, if a malicious actor were to bias the randomness, then they can sample many different strings of randomness and select the one which benefits them most. Currently the randomness <span class="math">O</span> is given by the reveals from a RANDAO commit-reveal scheme used to generate a random number where the commits are inputs produced by the validators during <span class="math">\\mathcal{E}</span>. However this commit-reveal scheme is biasable: a malicious validator that plays last can choose whether or not to reveal and the result will be different based on their choice. To transform <span class="math">O</span> into a form of unbiasable randomness, one solution is to pass <span class="math">O</span> through a <em>verifiable delay function</em> (VDF) which is guaranteed to be slow to compute, such that all validators must choose whether to reveal or not <em>before</em> they know the output of the VDF. Note that <span class="math">O</span> can be evaluated by any VDF evaluator for each epoch <span class="math">\\mathcal{E}</span>. It is expected that the lowest execution time will be achieved on specialized hardware, and such hardware should be available to the participants. To summarize, a VDF protocol should have the following features</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Tight latency bounds: the minimal time needed to compute the VDF with arbitrary parallelism on modern hardware should be close to the best known algorithm to date.</li>

      <li>Minimum hardware: as a benign VDF computation brings no benefit to the executor, it should as cheap as possible so that parties could afford it.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Succinct proofs: the VDF outputs should be widely available to all Ethereum nodes, and their verification should not expose a DoS attack vector.</li>

      <li>Quantum upgrade: when/if the quantum computers become powerful enough it should be possible to switch to a post-quantum version of the protocol while retaining the deployed hardware.</li>

      <li>Delay granularity: it should be possible to select the VDF expected running time with sufficient precision in seconds.</li>

    </ul>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">VDF informal definition</h4>

    <p class="text-gray-300">A VDF is a tuple <span class="math">(F,\\Pi)</span> of function <span class="math">F</span> and non-interactive protocol <span class="math">\\Pi</span> which works as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Prover runs <span class="math">F</span> on challenge <span class="math">I</span> and produces output <span class="math">O</span>;</li>

      <li>Prover engages in <span class="math">\\Pi</span> and produces a proof <span class="math">\\pi</span> that <span class="math">F(I)=O</span>;</li>

      <li>Verifier obtains <span class="math">(I,O,\\pi)</span> and verifies <span class="math">\\pi</span>.</li>

    </ol>

    <p class="text-gray-300">To qualify for a VDF, the proof protocol should be <em>complete</em> and <em>sound</em>, the proof should be <em>succinct</em>, <em>non-malleable</em> (to prevent manipulation with the VDF output) and allow <em>fast verification</em>. A number of VDF constructions has been proposed in the recent past <em>[x14, x23, x1, x10, x11, x12, x13]</em> with their own advantages and limitations.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">VDF based on an iterative sequential function</h4>

    <p class="text-gray-300">. An important class of VDFs is built as follows: <span class="math">F</span> is an iteration of so called iterative sequential function <em>[x1]</em> and <span class="math">\\Pi</span> is a proof of computation, for example a recursive SNARK <em>[x2, x11]</em>. Here the SNARK part provides soundness and succinctness, whereas the iterative sequential function guarantees that the computation time can not be reduced on parallel machines.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Our contributions</h4>

    <p class="text-gray-300">This document describes a candidate iterative sequential function called MinRoot. As of November 2022, Ethereum plans to use the Nova proof system <em>[x16]</em> as a recursive SNARK for a VDF. While this is not am immediate requirement, we expect that the resulting protocol would suit a large number of applications as well as other blockchains currently united as the VDF Alliance.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Paper structure.</h4>

    <p class="text-gray-300">In this report we first recall VDF and sequentiality definitions and then extend them in Section 2. We propose MinRoot in Section 3. We describe our own cryptanalytic attacks on MinRoot in classical (Section 4) and quantum (Section 5) scenarios. We describe cryptanalytic targets and research bounties in Section 6.</p>

    <h2 id="sec-8" class="text-2xl font-bold">2 Definitions</h2>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">2.1 Generic definitions</h3>

    <p class="text-gray-300">A VDF is defined by Boneh et al. <em>[x1]</em> as follows.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 1 (Verifiable Delay Functions).</h6>

    <p class="text-gray-300">A verifiable delay function (VDF) consists of the following algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}(\\lambda,\\mathsf{t})\\to\\mathsf{pp}</span>: The puzzle generation algorithm takes as input a security parameter <span class="math">\\lambda</span> and a difficulty parameter <span class="math">\\mathsf{t}</span> and outputs public parameters <span class="math">\\mathsf{pp}</span> which fix the domain <span class="math">\\mathcal{X}</span> and range <span class="math">\\mathcal{Y}</span> of the puzzle and other information required to compute a puzzle or verify a puzzle solution</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Eval}(\\mathsf{pp},x)\\to(y,\\pi)</span>: The puzzle evaluation algorithm takes as input the public parameters <span class="math">\\mathsf{pp}</span>, an input from the domain <span class="math">x</span>. It outputs a puzzle solution <span class="math">y</span> and a proof <span class="math">\\pi</span>.</li>

      <li><span class="math">\\mathsf{Verify}(\\mathsf{pp},x,y,\\pi)\\to 0/1</span>: The puzzle verification algorithm takes as input the public parameters <span class="math">\\mathsf{pp}</span>, an input from the domain <span class="math">x</span>, an input from the range <span class="math">y</span> and a proof <span class="math">\\pi</span>. It outputs either <span class="math">0</span> or <span class="math">1</span>.</li>

    </ul>

    <p class="text-gray-300">Additionally, VDFs must satisfy the correctness, soundness and sequentiality definitions as defined below.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Definition 2 (Correctness).</h6>

    <p class="text-gray-300">A verifiable delay function is correct if <span class="math">\\forall\\lambda,\\mathsf{t}</span>, <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{Setup}(\\lambda,\\mathsf{t})</span>, and <span class="math">\\forall x\\in\\mathcal{X}</span> if <span class="math">(y,\\pi)\\leftarrow\\mathsf{Eval}(\\mathsf{pp},x)</span> then <span class="math">\\mathsf{Verify}(\\mathsf{pp},x,y,\\pi)=1</span>.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Definition 3 (Soundness).</h6>

    <p class="text-gray-300">For soundness it is required that an adversary can not get a verifier to accept an incorrect VDF solution.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\mathbb{P}\\left[\\begin{array}[]{c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c}\\mathsf{Verify}(\\mathsf{pp},x,y,\\pi)=1&\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(x,y,\\pi)\\leftarrow\\mathcal{A}(\\lambda,\\mathsf{t},\\mathsf{pp})\\\\ \\end{array}\\bigg{]}\\leq\\mathsf{negl} \\]</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Definition 4 (Sequentiality).</h6>

    <p class="text-gray-300">For functions <span class="math">\\sigma(t)</span> and <span class="math">p(t)</span>, the VDF is <span class="math">(p,\\sigma)</span>-sequential if no pair of randomized algorithms <span class="math">\\mathcal{A}_{0}</span>, which runs in total time <span class="math">O(poly(\\lambda,\\mathsf{t}))</span>, and <span class="math">\\mathcal{A}_{1}</span>, which runs in parallel time <span class="math">\\sigma(t)</span> on at most <span class="math">p(t)</span> processors, can win the following <em>sequentiality game</em> with probability greater than <span class="math">\\mathsf{negl}(\\lambda)</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{pp}\\leftarrow\\mathsf{Setup}(\\lambda,\\mathsf{t})</span>;</li>

      <li><span class="math">L\\leftarrow\\mathcal{A}_{0}(\\lambda,\\mathsf{pp},\\mathsf{t})</span>; (preprocessing of <span class="math">\\mathsf{pp}</span>)</li>

      <li><span class="math">x\\stackrel{{\\scriptstyle\\S}}{{\\leftarrow}}\\mathcal{X}</span>; (choosing random input)</li>

      <li><span class="math">y_{A}\\leftarrow\\mathcal{A}_{1}(L,\\mathsf{pp},x)</span>; (computing an output)</li>

      <li>Win if <span class="math">y_{A}=y</span> where <span class="math">(y,\\pi)=\\mathsf{Eval}(\\mathsf{pp},x)</span>.</li>

    </ul>

    <p class="text-gray-300">Function <span class="math">\\sigma(t)</span> is a lower bound on how fast an adversary can compute a VDF. For the Ethereum application we need <span class="math">\\sigma(t)</span> to significantly exceed the time that is given to a party to craft their input, i.e. minutes, whereas the VDF computation time can be a few hours or days. Thus <span class="math">\\sigma(t)</span> must be set to at least <span class="math">t/100</span>, and for the security margin we set it to be <span class="math">t/2</span>. See more discussion on this topic in <em>[x1]</em>.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">2.2 Multiple targets</h3>

    <p class="text-gray-300">We would like to cover additionally the case when the adversary is able to choose an input from a fairly big set. This corresponds to the real world use case when it is possible to grind a number of possible inputs by, for instance, hashing a nonce.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Definition 5 (Multiple Target Sequentiality).</h6>

    <p class="text-gray-300">For functions <span class="math">\\sigma(t)</span> and <span class="math">p(t)</span>, the VDF is <span class="math">(p,\\sigma)</span>-multitarget-sequential if no pair of randomized algorithms <span class="math">\\mathcal{A}_{0}</span>, which runs in total time <span class="math">O(poly(\\lambda,\\mathsf{t}))</span>, and <span class="math">\\mathcal{A}_{1}</span>, which runs in parallel time <span class="math">\\sigma(t)</span> on at most <span class="math">p(t)</span> processors, can win the following <em>sequentiality game</em> with probability greater than <span class="math">\\mathsf{negl}(\\lambda)</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{pp}\\leftarrow\\mathsf{Setup}(\\lambda,\\mathsf{t})</span>;</li>

      <li><span class="math">L\\leftarrow\\mathcal{A}_{0}(\\lambda,\\mathsf{pp},\\mathsf{t})</span>; (preprocessing of <span class="math">\\mathsf{pp}</span>)</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">X\\stackrel{{\\scriptstyle\\S}}{{\\leftarrow}}\\mathcal{X}</span>, $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><p(t)$; (choosing random input set)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">y_{A}\\leftarrow\\mathcal{A}_{1}(L,\\mathsf{pp},x)</span>, <span class="math">\\quad x\\in X</span>; (computing an output)</li>

      <li>Win if <span class="math">y_{A}=y</span> where <span class="math">(y,\\pi)=\\mathsf{Eval}(\\mathsf{pp},x)</span>.</li>

    </ul>

    <p class="text-gray-300">2.3 VDF from IVC</p>

    <p class="text-gray-300">As indicated in <em>[x1]</em>, one can build a sequential VDF by proving an incrementally verifiable computation (IVC) of a so called sequential function.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Definition 6 (Sequential function).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Function <span class="math">f:X\\to Y</span> is a <span class="math">(\\mathsf{t},\\epsilon)</span>-sequential function if for $\\lambda=O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ the following conditions hold:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>There exists an algorithm that for all <span class="math">x\\in X</span> evaluates <span class="math">f</span> in parallel time <span class="math">\\mathsf{t}</span> using <span class="math">\\mathsf{poly}(\\log\\mathsf{t},\\lambda)</span> processors.</li>

      <li>For all <span class="math">\\mathcal{A}</span> that run in parallel time strictly less than <span class="math">(1-\\epsilon)\\mathsf{t}</span> with <span class="math">\\mathsf{poly}(\\mathsf{t},\\lambda)</span> processors:</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathbb{P}\\left[y_{a}=f(x)\\;\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\;y_{a}\\leftarrow\\mathcal{A}(\\lambda,x),\\;x\\stackrel{{\\scriptstyle\\<span class="math">}}{{\\leftarrow}}X\\right]\\leq\\mathsf{negl}(\\lambda)</span></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-17" class="text-base font-medium mt-4">Definition 7.</h6>

    <p class="text-gray-300">Let <span class="math">g:X\\to X</span> be a <span class="math">(\\mathsf{t},\\epsilon)</span>-sequential function. A function <span class="math">f:\\mathbb{N}\\times X\\to X</span> defined as</p>

    <p class="text-gray-300"><span class="math">f(k,x)=g^{(k)}(x)=\\underbrace{g\\circ g\\circ\\cdots\\circ g}_{k\\ \\text{times}}</span></p>

    <p class="text-gray-300">is said to be an <em>iterated sequential function</em> (with round function <span class="math">g</span>) if for all <span class="math">k=2^{o(\\lambda)}</span> the function <span class="math">h:X\\to X</span> defined as <span class="math">h(x)=f(k,x)</span> is <span class="math">(k\\mathsf{t},\\epsilon)</span>-sequential.</p>

    <p class="text-gray-300">A straightforward SNARK prover computes a proof for a circuit of size <span class="math">m</span> in time superlinear of <span class="math">m</span> <em>[x2]</em>. However, it turns out that with a reasonable amount of parallel processors a prover can run in time only logarithmic of <span class="math">m</span>. One can carefully split an iterated sequential function into chunks and apply such a prover as soon as each chunk is ready, in order to obtain a sequential VDF.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Theorem 1 (<em>[x1]</em>,informal).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{S}</span> be a SNARK system such that a parallel prover using <span class="math">O(m\\log m)</span> processors computes a SNARK for a circuit of size <span class="math">m</span> in time <span class="math">\\alpha m</span>. Let <span class="math">f</span> be an iterated sequential function with <span class="math">(s,\\epsilon)</span>-sequential round function <span class="math">g</span>. Then there exists a <span class="math">\\sigma(t)</span>-sequential VDF with <span class="math">\\sigma(t)=(1-\\epsilon)t</span> that is evaluated on <span class="math">O_{\\alpha}(\\log\\frac{t}{s}\\cdot\\log t)</span> processors.</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">2.4 Concrete security</h3>

    <p class="text-gray-300">The sequentiality Definition 6 deals with adversaries whose computational power is upper bounded only asymptotically as a function of security parameter <span class="math">\\lambda</span>. It thus makes sense to investigate how concretely powerful an adversary should be to violate the sequentiality property. For this we also have to specify the number of processors run by a regular evaluator.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Definition 8 (Concrete sequentiality).</h6>

    <p class="text-gray-300">We say that the VDF function <span class="math">F</span> is <span class="math">(\\sigma,\\alpha,T_{0},T_{1},n_{E})</span>-parallel if there exist two adversaries <span class="math">\\mathcal{A}_{0}</span> and <span class="math">\\mathcal{A}_{1}</span> that win the multitarget sequentiality game with probability <span class="math">\\alpha</span> against an evaluator with <span class="math">n_{E}</span> processors, so that <span class="math">\\mathcal{A}_{0}</span> runs in total time <span class="math">T_{0}</span>, counted in calls to <span class="math">F</span>, and <span class="math">\\mathcal{A}_{1}</span> runs in parallel time <span class="math">\\sigma t</span> and total time <span class="math">T_{1}</span>.</p>

    <p class="text-gray-300">This definition implies that <span class="math">\\mathcal{A}_{1}</span> uses at least <span class="math">T_{1}</span> processors.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Definition 9.</h6>

    <p class="text-gray-300">We say that the function has <span class="math">\\lambda</span> bits of VDF security if it is not <span class="math">(\\sigma=0.5,\\alpha,T_{0},T_{1},n_{E}=2^{16})</span>-parallel for any <span class="math">\\alpha\\leq 1</span> such that <span class="math">max(T_{0}/\\alpha,T_{1}/\\alpha)&lt;2^{\\lambda}</span>.</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">2.5 Theoretical shortcomings</h3>

    <p class="text-gray-300">In this section we mention a few issues that prevents a construction of VDF and sequential function on a more solid basis.</p>

    <h4 id="sec-23" class="text-lg font-semibold mt-6">Existence of sequentiality</h4>

    <p class="text-gray-300">It is known that a very wide class of functions from <span class="math">\\mathbb{P}</span> (i.e. computable in polynomial time) can be computed in polylogarithmic time on a polynomial number of parallel processors. These functions are known as <span class="math">\\mathbb{NC}</span>. The provable existence of sequential functions that <em>can not</em> be computed in polylogarithmic parallel time would imply that <span class="math">\\mathbb{NC}\\neq\\mathbb{P}</span>, which is an unsolved mathematical problem.</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">Sequentiality from <span class="math">\\mathbb{P}</span>-complete problems</h4>

    <p class="text-gray-300">We know, however, should sequential functions appear they would be <span class="math">\\mathbb{P}</span>-complete, i.e. any other <span class="math">\\mathbb{P}</span> problem would reduce to them by a reduction from <span class="math">\\mathbb{NC}</span>. The candidate <span class="math">\\mathbb{P}</span>-complete problems, such as CVP (Circuit Value Problem), do not appear to be effective enough for our usecase. They are either solvable in (quasi)linear time, thus spending most of the algorithm on just reading the input, or require just a too large input to constitute a significant gap to a parallel implementation. An interested reader may find more information on <span class="math">\\mathbb{P}</span>-complete problems and open research directions in <em>[GHR^{+}95]</em>.</p>

    <h2 id="sec-25" class="text-2xl font-bold">3 MinRoot candidate sequential function</h2>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">3.1 Related work and design rationale</h3>

    <p class="text-gray-300">We build MinRoot candidate sequential function <span class="math">g</span> to be used for an iterated round function <span class="math">f</span>. There exist several candidates for <span class="math">g</span> in the literature with [VeeDo and Sloth++ [BBB+18]] being the most prominent. In the core, both transform the state <span class="math">S</span> to <span class="math">S^{\\prime}</span> so that the pair satisfies a low-degree polynomial relation <span class="math">G(S,S^{\\prime})=0</span>. In more details, the forward direction is some inverse to a power function, where the exponent is selected to be an injective mapping. When <span class="math">p\\not\\equiv 1\\pmod{3}</span> we have:</p>

    <p class="text-gray-300"><span class="math">\\text{Sloth}++:(x_{i+1},y_{i+1})</span> <span class="math">\\leftarrow\\underbrace{(x_{i},y_{i})^{(p^{2}+1)/4}}_{\\text{over }\\mathbb{F}_{p^{2}}}+(c_{1},c_{2})</span> <span class="math">\\text{VeeDo}:(x_{i+1},y_{i+1})</span> <span class="math">\\leftarrow A\\cdot(\\underbrace{x_{i}^{(2p-1)/3},y_{i}^{(2p-1)/3}}_{\\text{both over }\\mathbb{F}_{p}})+(c_{1,i},c_{2,i})</span></p>

    <p class="text-gray-300">Here <span class="math">(x_{i},y_{i})</span> is the state at <span class="math">i</span>-th step. We have found a better alternative to both, with only one exponentiation per round, which we call MinRoot (Figure 1):</p>

    <p class="text-gray-300"><span class="math">\\text{Domain}\\ :X=\\mathbb{F}_{p}^{2};</span> (1) <span class="math">\\text{MinRoot round function}\\ :g_{MR}(x_{i+1},y_{i+1},i)\\leftarrow((x_{i}+y_{i})^{(2p-1)/3},x_{i})+(0,i)</span> (2)</p>

    <p class="text-gray-300">If we have <span class="math">p\\equiv 1\\pmod{3}</span> but <span class="math">p\\not\\equiv 1\\pmod{5}</span>, which is the case for the primes which are prime group orders of popular BLS12-381 and BN254 curves, we use the fifth root as <span class="math">(x_{i}+y_{i})^{(4p-3)/5}</span>.</p>

    <h4 id="sec-27" class="text-lg font-semibold mt-6">MinRoot VDF.</h4>

    <p class="text-gray-300">We suggest using MinRoot round function within an IVC-based VDF as described in <em>[BBB+18]</em>. Ethereum plans to use Nova <em>[KST+22]</em> as an underlying SNARK. Given that we can run up to <span class="math">2^{30}</span> iterations of <span class="math">g_{MR}</span> per second, we have the following parameter range:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">t\\approx 2^{36}</span> for 1 minute;</li>

      <li><span class="math">t\\approx 2^{42}</span> for 1 hour;</li>

      <li><span class="math">t\\approx 2^{46}</span> for 1 day.</li>

    </ul>

    <p class="text-gray-300">We denote the resulting VDF as <span class="math">F_{MR}^{t}</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: Round functions of candidate iterated sequential functions (assuming the field where the cubic root is well defined).</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> VeeDo</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Sloth++</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a></p>

    <p class="text-gray-300">We claim sequentiality of MinRoot round function based on the following conjecture.</p>

    <p class="text-gray-300">Conjecture 1. For  <span class="math">a</span>  being co-prime with  <span class="math">p - 1</span> , computing  <span class="math">x^{\\frac{1}{a}} \\mod p</span>  is on average at least as hard as computing  <span class="math">x^{2} \\mod p</span> .</p>

    <p class="text-gray-300">The hardness of squaring is discussed in Section 3.5.</p>

    <p class="text-gray-300">Even if  <span class="math">g_{MR}</span>  is sequential it does not guarantee that  <span class="math">f</span> , the iterated  <span class="math">g_{MR}</span> , is iterated sequential. The latter statement is captured as follows. We formulate it as a claim rather than a conjecture to emphasize that it is a subject of cryptanalytic investigation.</p>

    <p class="text-gray-300">Claim 1. We claim 128 bits of multitarget VDF security (Definition 9) for MinRoot over 256-bit field  <span class="math">\\mathbb{F}_p</span>  against both classical and quantum adversaries.</p>

    <p class="text-gray-300">We first observe that VeeDo uses two parallelizable exponentiations per round, whereas MinRoot does only one. Thus for the same delay time and same state size VeeDo requires twice the hardware, whereas the smaller state would reduce the security against precomputation attacks. Note also that VeeDo needs additional storage for constants (or hardware that computes those).</p>

    <p class="text-gray-300">A comparison to  <span class="math">\\mathrm{Sloth}++</span>  is less straightforward. Assuming that both state elements in all designs are  <span class="math">l</span> -bit primes, we get that MinRoot uses one exponentiation to an  <span class="math">l</span> -bit exponent, VeeDo uses two, whereas  <span class="math">\\mathrm{Sloth}++</span>  computes a single  <span class="math">2l</span> -bit exponentiation of a  <span class="math">2l</span> -bit field element, which should yield twice longer step at CPU or an ASIC circuit twice as large. On the other hand, a hardware of the same size would imply twice smaller state, which succumbs to precomputation attacks. We conclude that MinRoot is more efficient in terms of hardware.</p>

    <h4 id="sec-31" class="text-lg font-semibold mt-6">Concrete performance of MinRoot</h4>

    <p class="text-gray-300">We assume that to compute a root function one uses a window-based square-and-multiply algorithm, which boils down to a sequence of modular multiplications. Our CPU benchmarks demonstrate that a naive 256-bit exponentiation takes about 10000 ns. An optimized ASIC implementation will be faster but given that at least 40 gates are needed for squaring <em>[x10]</em>. The ASIC estimate for this design is 1ns per square/multiply. This means that the ASIC can takes 300ns per MinRoot iteration which gives us 3.3 million iterations/second. For the prover, each iteration is 3 constraints. To create a proof, a prover performs 2 multi-scalar multiplication/multi-exponentiation (MSMs) the size of the number of constraints. At 3.3 million iterations per second this <span class="math">is</span> 2 MSMs of size <span class="math">10^{7}</span> per second for <span class="math">2\\times 10^{7}</span> bases/second. We currently have GPU code that does <span class="math">2\\times 10^{7}</span> bases/second on a 384 bit curve and this should go up to about <span class="math">4\\times 10^{7}</span> bases/second when we move to256-bit curves. This means that a single GPU should be able to create SNARK proofs for 2 ASIC VDF evaluators.</p>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">3.5 Sequentiality of the round function: latency bounds</h3>

    <p class="text-gray-300">Currently the fastest exponentiation <span class="math">x^{y}</span> algorithm that works with variable base is the windowing-ladder algorithm <em>[x5]</em>. In the nutshell it splits the exponent <span class="math">y</span> into windows of bitlength <span class="math">k</span>, precomputes powers of <span class="math">x</span>, and then applies the square-and-multiply method. For the 256-bit exponent the optimal <span class="math">k</span> equals 5, which yields 256 squares and 66 multiplications. We are aware of no substantial improvement to this bound.</p>

    <p class="text-gray-300">Going further down, the modulo squaring itself has been the subject of latency analysis in various models. For the gate depth model, the best available lower bounds <em>[x14]</em> indicate that a squaring modulo <span class="math">\\ell</span>-bit prime circuit has depth at least <span class="math">2\\log_{2}(\\ell-1)-2\\log_{2}(\\log_{2}(\\ell-1)-1)-4</span>, whereas the concrete upper bounds yield circuits of depth smaller than <span class="math">5\\log_{2}\\ell</span> <em>[x10]</em>. We consider this gap to be small enough to prevent breakthroughs in circuit construction.</p>

    <h2 id="sec-33" class="text-2xl font-bold">4 Classical Cryptanalysis</h2>

    <p class="text-gray-300">In this section we consider attacks on sequentiality against both the MinRoot round function <span class="math">g_{MR}</span> and the full VDF function <span class="math">F_{MR}^{t}</span>.</p>

    <h4 id="sec-34" class="text-lg font-semibold mt-6">Multitarget parallel adversary</h4>

    <p class="text-gray-300">In our attacks we consider multitarget adversaries as the most powerful ones. The online adversaries get their set of VDF inputs as follows. We allow each adversary’s processor sampling a VDF input at the rate of one per time equal to the single call of <span class="math">g_{MR}</span>. We assume a common memory of size <span class="math">M</span> shared by adversary’s processors. Further simplifying towards the adversary, we assume that lookups in the memory can be made in parallel from <span class="math">S</span> processors in constant time, even though more realistic algorithms require <span class="math">\\sqrt{max(S,M)}</span> time <em>[x11]</em>.</p>

    <h3 id="sec-35" class="text-xl font-semibold mt-8">4.1 Precomputation attacks</h3>

    <p class="text-gray-300">Here we consider attacks based on precomputing certain calls to <span class="math">F_{MR}^{t}</span>, shortly denoted by <span class="math">F</span>. Note that for the security level of 128 bits we allow an adversary to make up to <span class="math">2^{128}</span> precomputation calls to <span class="math">F</span>. Recall that the VDF function <span class="math">F_{MR}^{t}</span> maps <span class="math">X</span> of size <span class="math">N=2^{512}</span> to itself. Let the inverse of <span class="math">g_{MR}</span> be computable with advantage <span class="math">\\gamma</span> over the forward iteration (it is approximately <span class="math">2^{-6}</span>).</p>

    <h4 id="sec-36" class="text-lg font-semibold mt-6">4.1.1 Attack 1</h4>

    <p class="text-gray-300">The simplest attack works as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Precomputation adversary <span class="math">\\mathcal{A}_{0}</span> applies <span class="math">F^{-1}</span> (i.e. invert <span class="math">F</span>) to <span class="math">M/\\gamma</span> elements of <span class="math">X</span> and create a proof for every inversion.</li>

      <li>Stores results as <span class="math">\\overline{X}=\\{(I,O,\\pi)\\}</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Online adversary <span class="math">\\mathcal{A}_{1}</span> samples input set <span class="math">X</span> of size <span class="math">S</span> on <span class="math">S</span> processors and checks if there is an overlap.</li>

    </ol>

    <p class="text-gray-300">This costs at most <span class="math">M</span> precomputation time and <span class="math">max(M/\\gamma,S)</span> space, but the chance to find a matching input is at most <span class="math">\\frac{MS}{\\gamma N}</span>. Therefore the function is at best <span class="math">(0,\\frac{MS}{\\gamma N},M,S,n_{E})</span>-parallel.</p>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">4.1.2 Attack 2</h4>

    <p class="text-gray-300">We make the following improvements to Attack 1:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Offline adversary computes only half-chains.</li>

      <li>Online adversary computes half-chains starting from all points of <span class="math">X</span> but in the forward direction.</li>

    </ul>

    <p class="text-gray-300">At the same cost this attack doubles the size of both matching sets chains and thus increases the matching probability by the factor of 4. The sequentiality advantage is <span class="math">\\sigma=1/2</span>. Therefore the function is at best <span class="math">(0.5,\\frac{4MS}{\\gamma N},M,S,n_{E})</span>-parallel.</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Remark 1.</h6>

    <p class="text-gray-300">Note that since all round functions are different, a precomputed segment is valid for only specific rounds. If the round function was the same, the winning probability would increase by the difficulty factor <span class="math">t</span>.</p>

    <h4 id="sec-39" class="text-lg font-semibold mt-6">4.1.3 Attack 3</h4>

    <p class="text-gray-300">This attack modifies Attack 1 in the following way:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Offline adversary is the same.</li>

      <li>Online adversary samples a new VDF input on each processor throughout <span class="math">1/2</span> of time required to compute <span class="math">F</span>.</li>

    </ul>

    <p class="text-gray-300">The adversary samples <span class="math">t/2</span> as many inputs, so <span class="math">F</span> is <span class="math">(1/2,\\frac{tMS}{2\\gamma N},M,St/2,n_{E})</span>-parallel. The attack is in fact as powerful as Attack 1, since those two have the same success rate for the same online cost.</p>

    <h4 id="sec-40" class="text-lg font-semibold mt-6">4.1.4 Mitigation and parameter selection</h4>

    <p class="text-gray-300">Looking at the attacks from the security level perspective, we obtain that the most powerful is Attack 2 where we set <span class="math">M=S</span> and the value <span class="math">max(T_{0}/\\alpha,T_{1}/\\alpha)</span> is minimized for <span class="math">M=\\sqrt{N}</span>. In this scenario we have</p>

    <p class="text-gray-300"><span class="math">\\lambda&lt;0.5\\log(\\gamma N)</span></p>

    <p class="text-gray-300">Therefore, if we select <span class="math">N=2^{512}</span>, the real security level approaches 250 bits, and we can safely claim that MinRoot has 128 bits of multitarget security.</p>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">4.2 Algebraic attacks</h3>

    <p class="text-gray-300">Algebraic attacks aim to find a shortcut in computing <span class="math">F</span> by exploiting its algebraic properties. In order to speed up <span class="math">t</span> rounds, i.e. computing <span class="math">f^{t}</span> one should be able to solve equations of form</p>

    <p class="text-gray-300"><span class="math">f^{-t}(I)=O</span> (3)</p>

    <p class="text-gray-300">for given <span class="math">I</span>.</p>

    <p class="text-gray-300">If (3) is multivariate, then the problem is NP-complete. The the best methods that tackle practical-size systems of relatively low degree are Groebner basis algorithms <em>[x10, x14]</em>. These algorithms find a generating set for the ideal generated by (3) so that they can be solved as univariate equations. Little is known about the actual complexity of Groebner basis algorithms, but the available heuristic analysis suggests that it is exponential in <span class="math">d</span>, thus quickly become impractical. Even in the unlucky</p>

    <p class="text-gray-300">case when a Groebner basis can be found for the system of equations that describe a VDF, we still face the problem of solving univariate equations for it.</p>

    <p class="text-gray-300">Univariate equations over finite fields can be solved using Berlekamp or Cantor-Zassenhaus algorithms. It is known <em>[x18]</em> that an equation of degree <span class="math">r</span> can be solved using <span class="math">O(r\\log p)</span> operations over elements of <span class="math">\\mathbb{F}_{p}</span>. This should be compared with <span class="math">O(d\\log p)</span> operations needed to compute <span class="math">f^{d}</span>. We conclude that, unless <span class="math">f^{d}</span> has some structure that makes the univariate equations of its Groebner basis of very low degree (at most <span class="math">\\sqrt[3]{d}</span>), generic algebraic methods are not applicable even if <span class="math">f</span> or <span class="math">\\widetilde{f}</span> has univariate representation.</p>

    <p class="text-gray-300">We note that univariate algorithms can be parallelized to have logarithmic depth. The following theorem is an improvement of a classical result by Valiant.</p>

    <p class="text-gray-300">Theorem<em>[x10]</em> Th. 12.1] The GCD and resultant of two univariate polynomials of degree <span class="math">d</span> can be computed in parallel time <span class="math">O(\\log^{3}d)</span> using <span class="math">\\frac{d^{2}}{\\log^{2}d}</span> processors.</p>

    <p class="text-gray-300">However, to be a threat to the 128-bit security the degree should not exceed <span class="math">2^{70}</span>, which is reached in less than 30 rounds of degree-5 round function (the inverse of <span class="math">g_{mr}</span>). We conjecture that existing parallel GCD algorithms can not compute a GCD of polynomials degree <span class="math">2^{64}</span> faster than a sequential evaluation of 30 MinRoot rounds.</p>

    <p class="text-gray-300">There exist algorithms to invert a bijective transformation of degree <span class="math">d</span> in <span class="math">O(d^{\\omega})</span> time for certain transformations <em>[x5]</em> but to the best of our knowledge they have never been implemented.</p>

    <h2 id="sec-42" class="text-2xl font-bold">5 Quantum Cryptanalysis</h2>

    <p class="text-gray-300">Quantum algorithms are considered in more details in Appendix. Here we apply Grover algorithm to precomputation attacks from Section 4.1</p>

    <h3 id="sec-43" class="text-xl font-semibold mt-8">5.1 Grover+Precomputation Attack</h3>

    <p class="text-gray-300">The main advantage of Grover algorithm compared to classical counterparts is the ability to search in a larger candidate space. However, the Grover algorithm itself is sequential, i.e. a parallel algorithm can only increase the detection probability but can not decrease the Grover running time.</p>

    <p class="text-gray-300">Thus we modify the classical Attack 1 as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Precomputation adversary <span class="math">\\mathcal{A}_{0}</span> applies <span class="math">F^{-1}</span> (i.e. invert <span class="math">F</span>) to <span class="math">M/\\gamma</span> elements of <span class="math">X</span> and create a proof for every inversion.</li>

      <li>Stores results as <span class="math">\\overline{X}=\\{(I,O,\\pi)\\}</span> in quantum memory (QRAM) <em>[x2]</em>.</li>

      <li>Online adversary <span class="math">\\mathcal{A}_{1}</span> runs <span class="math">S</span> copies of multitarget Grover algorithms (Appendix A.1.2) that check if <span class="math">\\overline{X}</span> overlaps with <span class="math">X</span>. Each copy runs for <span class="math">1/2</span> of time needed to compute <span class="math">F</span>.</li>

    </ol>

    <p class="text-gray-300">This costs <span class="math">M</span> precomputation time and <span class="math">max(M,S)</span> space. Assume for the sake of simplicity that a quantum predicate check runs in time equal to a single round of <span class="math">F</span>, so that each Grover processor makes <span class="math">t/2</span> iterations. The probability to find a match of <span class="math">M</span> stored proofs among <span class="math">S</span> inputs over <span class="math">t/2</span> iterations is <span class="math">\\frac{MSt^{2}}{4\\gamma N}</span> (4). Therefore the function is <span class="math">(1/2,\\frac{MSt^{2}}{4\\gamma N},M,St/2,n_{E})</span>-parallel.</p>

    <p class="text-gray-300">The maximum probability and the number of security level bits to beat is achieved for <span class="math">M=St/2=\\sqrt{2\\gamma N/t}</span>. For the maximum reasonable length of 1 year we get <span class="math">t\\approx 2^{54}</span> with the maximum possible security level of <span class="math">0.5\\log N-30</span> bits, i.e. around 225 bits for 512-bit <span class="math">N</span>. Thus we can safely claim 128-bit security against quantum adversaries too.</p>

    <h4 id="sec-44" class="text-lg font-semibold mt-6">Attacks that do not work</h4>

    <p class="text-gray-300">Interestingly, Grover algorithm does not seem to improve if use chain-based approach (Section 4.1.2). The reason is that the latter requires to compute several iterations of <span class="math">f</span> which can not be iterated in Grover. Thus we conclude that the attack above is the best we can hope with Grover.</p>

    <p class="text-gray-300">For the same reason we can not effectively run a quantum meet-in-the-middle attack <em>[x1]</em> on <span class="math">F</span> by splitting in two parts, as Grover would need to compute many iterations of <span class="math">F</span> sequentially.</p>

    <h3 id="sec-45" class="text-xl font-semibold mt-8">5.2 Practicality of Quantum Search</h3>

    <p class="text-gray-300">Grover’s search is usually discussed for some oracle function <span class="math">f(\\cdot)</span>. However, several practical issues need to be considered when a specific construction of <span class="math">f(\\cdot)</span> is being considered. The work of Viamontes, Markov and Hayes <em>[x22]</em> focuses on these issues. The first issue is that in order to query <span class="math">f(\\cdot)</span> in superposition, we need a quantum hardware implementation of <span class="math">f(\\cdot)</span>. While a quantum circuit is usually similar in size to its classical counterpart, if the the circuit’s maximum depth exceeds <span class="math">\\sqrt{N}</span> then the evaluation of <span class="math">f(\\cdot)</span> is the more cost consuming part of searching a size <span class="math">N</span> database. This would diminish the quantum speedup by a considerable amount. Hence, to come up with resource estimates for quantum attacks we first come up with the quantum circuits for the VDF candidates.</p>

    <h3 id="sec-46" class="text-xl font-semibold mt-8">5.3 Quantum Grobner</h3>

    <p class="text-gray-300">We note that quite little is known about the quantum complexity of Groebner basis algorithms nor of the equation solving. There exist several results showing that Gaussian elimination of sparse matrices can be sped up greatly on a quantum computerhttps://arxiv.org/abs/0811.3171, which in turns would shorten the elimination step in the Groebner basis algorithms. However, it is the subject of the future research if an algorithm like F4 or F5 <em>[x6]</em> can be improved as a whole. We expect that if it can be done, running a quantum algorithm every few steps would induce high latency, and the high value of <span class="math">D</span> would rule out such strategies. To the best of our knowledge there is no quantum improvement to solving univariate equations either.</p>

    <h2 id="sec-47" class="text-2xl font-bold">6 Cryptanalysis targets and research bounties</h2>

    <p class="text-gray-300">In order to facilitate third-party cryptanalysis of MinRoot candidate function, we suggest the following weakened versions:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>MinRoot over 16-bit prime 65537. We expect practical attacks here.</li>

      <li>MinRoot over 24-bit prime. We expect theoretical attacks faster than <span class="math">2^{64}</span>.</li>

      <li>MinRoot over 32-bit prime. We expect theoretical attacks faster than <span class="math">2^{64}</span>.</li>

      <li>MinRoot over 64-bit prime. We expect theoretical attacks faster than <span class="math">2^{128}</span>.</li>

    </ul>

    <p class="text-gray-300">We also plan to announce bounties for the most interesting research and fastest implementations of:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parallel GCD algorithms;</li>

      <li>Inversion of several MinRoot rounds using algebraic tools.</li>

      <li>Evaluation of MinRoot round function on one CPU core, on GPU, and on multiple processors.</li>

    </ul>

    <h2 id="sec-48" class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">We thank Dankrad Feist and Avihu Levi for fruitful discussions that led to the improvement of the MinRoot design.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BBBF18] Dan Boneh, Joseph Bonneau, Benedikt Bünz, and Ben Fisch. Verifiable delay functions. In CRYPTO (1), volume 10991 of Lecture Notes in Computer Science, pages 757–788. Springer, 2018.</li>

      <li>[BBHR19] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable zero knowledge with no trusted setup. In CRYPTO (3), volume 11694 of Lecture Notes in Computer Science, pages 701–732. Springer, 2019.</li>

      <li>[BGH20] Sean Bowe, Jack Grigg, and Daira Hopwood. Halo2. URL: https://github.com/zcash/halo2, 2020.</li>

      <li>[BHMT02] Gilles Brassard, Peter Høyer, Michele Mosca, and Alain Tapp. Quantum amplitude amplification and estimation. Quantum Computation and Information, page 53–74, 2002.</li>

      <li>[BHT97] Gilles Brassard, Peter Høyer, and Alain Tapp. Quantum cryptanalysis of hash and claw-free functions. SIGACT News, 28(2):14–19, 1997.</li>

      <li>[BNPS19] Xavier Bonnetain, María Naya-Plasencia, and André Schrottenloher. Quantum security analysis of aes. IACR Transactions on Symmetric Cryptology, 2019(2):55–93, 2019.</li>

      <li>[CLO97] David A. Cox, John Little, and Donal O’Shea. Ideals, varieties, and algorithms - an introduction to computational algebraic geometry and commutative algebra (2. ed.). Undergraduate texts in mathematics. Springer, 1997.</li>

      <li>[CMW08] Antonio Cafure, Guillermo Matera, and Ariel Waissbein. Efficient inversion of rational maps over finite fields. In Algorithms in algebraic geometry, pages 55–77. Springer, 2008.</li>

      <li>[COS20] Alessandro Chiesa, Dev Ojha, and Nicholas Spooner. Fractal: Post-quantum and transparent recursive proofs from holography. In EUROCRYPT (1), volume 12105 of Lecture Notes in Computer Science, pages 769–793. Springer, 2020.</li>

      <li>[CP05] Richard E. Crandall and Carl Pomerance. Prime numbers: a computational perspective. Springer, 2nd ed edition, 2005.</li>

      <li>[DGMV20] Nico Döttling, Sanjam Garg, Giulio Malavolta, and Prashant Nalini Vasudevan. Tight verifiable delay functions. In Security and Cryptography for Networks - 12th International Conference, SCN 2020, Amalfi, Italy, September 14-16, 2020, Proceedings, pages 65–84, 2020.</li>

      <li>[EFKP20] Naomi Ephraim, Cody Freitag, Ilan Komargodski, and Rafael Pass. Continuous verifiable delay functions. In Advances in Cryptology - EUROCRYPT 2020 - 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Zagreb, Croatia, May 10-14, 2020, Proceedings, Part III, pages 125–154, 2020.</li>

      <li>[Fau02] Jean Charles Faugere. A new efficient algorithm for computing gröbner bases without reduction to zero (<span class="math">f_{5}</span>). In Proceedings of the 2002 international symposium on Symbolic and algebraic computation, pages 75–83, 2002.</li>

      <li>[FMPS19] Luca De Feo, Simon Masson, Christophe Petit, and Antonio Sanso. Verifiable delay functions from supersingular isogenies and pairings. In Advances in Cryptology - ASIACRYPT 2019 - 25th International Conference on the Theory and Application of Cryptology and Information Security, Kobe, Japan, December 8-12, 2019, Proceedings, Part I, pages 248–277, 2019.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[GHR^{+}95] Raymond Greenlaw, H James Hoover, Walter L Ruzzo, et al. Limits to parallel computation: P-completeness theory. Oxford University Press on Demand, 1995.</li>

      <li>[Gro96] Lov K. Grover. A fast quantum mechanical algorithm for database search. In STOC, pages 212–219. ACM, 1996.</li>

      <li>[KST22] Abhiram Kothapalli, Srinath Setty, and Ioanna Tzialla. Nova: Recursive zero-knowledge arguments from folding schemes. In CRYPTO (4), volume 13510 of Lecture Notes in Computer Science, pages 359–388. Springer, 2022.</li>

      <li>[LSSS85] Hans-Werner Lang, Manfred Schimmler, Hartmut Schmeck, and Heiko Schröder. Systolic sorting on a mesh-connected network. IEEE Trans. Computers, 34(7):652–658, 1985.</li>

      <li>[LV20] Alex Lombardi and Vinod Vaikuntanathan. Fiat-shamir for repeated squaring with applications to ppad-hardness and vdfs. In Advances in Cryptology - CRYPTO 2020 - 40th Annual International Cryptology Conference, CRYPTO 2020, Santa Barbara, CA, USA, August 17-21, 2020, Proceedings, Part III, pages 632–651, 2020.</li>

      <li>[LW17] Arjen K. Lenstra and Benjamin Wesolowski. Trustworthy public randomness with sloth, unicorn, and trx. Int. J. Appl. Cryptogr., 3(4):330–343, 2017.</li>

      <li>[MOS20] Ahmet Can Mert, Erdinc Ozturk, and Erkay Savas. Low-latency asic algorithms of modular squaring of large integers for vdf evaluation. Cryptology ePrint Archive, Report 2020/480, 2020. https://ia.cr/2020/480.</li>

      <li>[Pan96] Victor Y Pan. Parallel computation of polynomial gcd and some related parallel computations over abstract fields. Theoretical Computer Science, 162(2):173–223, 1996.</li>

      <li>[Pie19] Krzysztof Pietrzak. Simple verifiable delay functions. In ITCS, volume 124 of LIPIcs, pages 60:1–60:15. Schloss Dagstuhl - Leibniz-Zentrum für Informatik, 2019.</li>

      <li>[Sho94] Peter W. Shor. Algorithms for quantum computation: Discrete logarithms and factoring. In FOCS, pages 124–134. IEEE Computer Society, 1994.</li>

      <li>[VMH05] George F. Viamontes, Igor L. Markov, and John P. Hayes. Is quantum search practical? Comput. Sci. Eng., 7(3):62–70, 2005.</li>

      <li>[vzGG13] Joachim von zur Gathen and Jürgen Gerhard. Modern Computer Algebra. Cambridge University Press, 3rd edition, 2013.</li>

      <li>[Wes19] Benjamin Wesolowski. Efficient verifiable delay functions. In EUROCRYPT (3), volume 11478 of Lecture Notes in Computer Science, pages 379–407. Springer, 2019.</li>

      <li>[WW20] Benjamin Wesolowski and Ryan Williams. Lower bounds for the depth of modular squaring. Cryptology ePrint Archive, Report 2020/1461, 2020. https://ia.cr/2020/1461.</li>

      <li>[Zal99] Christof Zalka. Grover’s quantum searching algorithm is optimal. Physical Review A, 60(4), 1999.</li>

    </ul>

    <h2 id="sec-49" class="text-2xl font-bold">Appendix A Quantum algorithms</h2>

    <p class="text-gray-300">Quantum algorithms are the algortihms specially designed for quantum computers. A unique property of a quantum computer is able to perform operations not on a single state but on a superposition of states, so that certain classical algorithms can be amortized. The most famous examples are Shor’s algorithm for factorization <em>[x20]</em> and its derivative for discrete logarithm search, as well as the Grover search algorithm <em>[x11]</em>. The latter is our main interest as we have excluded factoring- and DLP-based schemes from consideration.</p>

    <p class="text-gray-300">A.1 Grover’s algorithm</p>

    <p class="text-gray-300">The Grover algorithm was originally formulated as a database search, however, it can be equivalently written as a preimage search algorithm for some hard-to-invert function. Concretely, given <span class="math">O\\in Z_{N}</span> (or any other domain efficiently mappable to <span class="math">Z_{N}</span>) and function <span class="math">H</span>, Grover algorithm finds <span class="math">I</span> such that <span class="math">H(I)=O</span> in time equivalent to <span class="math">\\sqrt{N}</span> calls to <span class="math">H</span> on a quantum computer. Note that the algorithm is inherently sequential and so far no one knows how to parallelize it so that the computing time can be reduced. The probability to find the preimage in <span class="math">t</span> time grows as <span class="math">t^{2}/N</span> <em>[x10]</em>.</p>

    <h4 id="sec-50" class="text-lg font-semibold mt-6">A.1.1 Single-target Grover’s</h4>

    <p class="text-gray-300">Grover’s algorithm makes a particular sequence of operations multiple times. At a high-level, after each iteration the probability amplitude of the marked index state is increased. Once enough iterations are performed, this amplitude is high enough that when a measurement is performed, with high probability the resulting index corresponds to the special marked state. Each iteration is made of 2 simple operations. The following description assumes that we are using Grover’s algorithm to perform unstructured search on a boolean function <span class="math">f:\\{0,1\\}^{n}\\rightarrow\\{0,1\\}</span> where there is only one unique element <span class="math">x^{\\prime}</span> such that <span class="math">f(x^{\\prime})=1</span> and <span class="math">N=2^{n}</span>. The input to Grover’s algorithm is an equal superposition of all inputs:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\phi_{0}=\\frac{1}{\\sqrt{N}}\\sum_{x=0}^{N-1}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\right\\rangle$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The 2 operations performed at each iteration of Grover’s algorithm are as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Amplitude flip $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x^{\\prime}\\right\\rangle\\rightarrow-\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x^{\\prime}\\right\\rangle<span class="math">: The amplitude of the unique element </span>x^{\\prime}$ is negated. This operation is implemented using the following gate logic:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ (-1)^{f(x)}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\right\\rangle=\\left\\{\\begin{array}[]{ll}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\right\\rangle&\\mbox{ if }f(x)=0\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Post this operation, the state of the input qubits is:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$-\\frac{1}{\\sqrt{N}}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x^{\\prime}\\right\\rangle+\\sum_{x\\neq x^{\\prime}}\\frac{1}{\\sqrt{N}}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\right\\rangle$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Diffusion operator: The goal of the diffusion operator is to increase the amplitude of <span class="math">x^{\\prime}</span>. The diffusion operator flips the amplitude of each <span class="math">x\\in\\{0,1\\}^{n}</span> around the average amplitude <span class="math">\\mu=\\frac{1}{N}\\sum_{x}A_{x}</span> where <span class="math">A_{x}</span> represents the amplitude of <span class="math">x</span>. This operation is implemented using the following gate logic:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\sum_{x\\in\\{0,1\\}}\\alpha_{x}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\right\\rangle\\mapsto\\sum_{x\\in\\{0,1\\}^{n}}(2\\mu-A_{x})\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\right\\rangle$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The mean amplitude before the diffusion operator is roughly <span class="math">\\frac{1}{\\sqrt{N}}</span>. Therefore, after the diffusion operator all entries remain roughly the same as they go from, <span class="math">\\frac{1}{\\sqrt{N}}</span> to <span class="math">\\frac{2}{\\sqrt{N}}-\\frac{1}{\\sqrt{N}}</span>. However, the amplitude of <span class="math">x^{\\prime}</span> , <span class="math">A_{x^{\\prime}}</span>, goes from <span class="math">-\\frac{1}{\\sqrt{N}}</span> to <span class="math">\\frac{3}{\\sqrt{N}}</span>.</p>

    <p class="text-gray-300">The above two operations are then repeatedly applied, increasing the amplitude of <span class="math">x^{\\prime}</span> after each round by <span class="math">\\frac{2}{\\sqrt{N}}</span>. After <span class="math">O(\\sqrt{N})</span> rounds, the amplitude of <span class="math">x^{\\prime}</span> is up to a desirable constant and at this point a measurement is performed which collapses the state to <span class="math">x^{\\prime}</span> with constant probability.</p>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">A.1.2 Multi-target Grover</p>

    <p class="text-gray-300">For us the main interest is the multi-target version of the Grover algorithm, which we hope to use in the pre-computation attacks. The same algorithm works in the multi-target case but now instead of requiring <span class="math">O(\\sqrt{N})</span> iterations, the number of iterations required is <span class="math">O(\\sqrt{\\frac{N}{k}})</span> as there are <span class="math">k</span> targets whose amplitude gets amplified after each iteration. Hence, the multi-target Grover’s finds a pre-image to one of <span class="math">k</span> targets in time <span class="math">\\sqrt{N/k}</span>. The probability to find the pre-image in <span class="math">t</span> time grows as</p>

    <p class="text-gray-300"><span class="math">f_{MG}(k,t,N)=kt^{2}/N</span> (4)</p>

    <p class="text-gray-300">according to <em>[x10]</em>.</p>

    <h4 id="sec-51" class="text-lg font-semibold mt-6">A.1.3 Quantum Parallelism</h4>

    <p class="text-gray-300">Achieving speed-ups via parallelism is an important line of work for most search algorithms. However, in the case of Grover’s algorithm, the work of Zalka <em>[x50]</em> proves that quantum searching can not be parallelized better than the naive case. The naive case assigns different parts of the search space to separate quantum computers. And hence, you get a linear improvement in search time with multiple quantum computers corresponding to increased computational cost.</p>`;
---

<BaseLayout title="MinRoot: Candidate Sequential Function for  Ethereum VDF (2022/1626)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2022 &middot; eprint 2022/1626
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
