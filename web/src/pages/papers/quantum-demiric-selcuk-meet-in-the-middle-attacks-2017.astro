---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2017/1229';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Quantum Demiric-Selçuk Meet-in-the-Middle Attacks: Applications to 6-Round Generic Feistel Constructions';
const AUTHORS_HTML = 'Akinori Hosoyamada, Yu Sasaki';

const CONTENT = `    <p class="text-gray-300">Akinori Hosoyamada [ 0000-0003-2910-2302 ] Yu Sasaki</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">This paper shows that quantum computers can significantly speed-up a type of meet-in-the-middle attacks initiated by Demiric and Selçuk (DS-MITM attacks), which is currently one of the most powerful cryptanalytic approaches in the classical setting against symmetric-key schemes. The quantum DS-MITM attacks are demonstrated against 6 rounds of the generic Feistel construction supporting an <span class="math">n</span>-bit key and an <span class="math">n</span>-bit block, which was attacked by Guo et al. in the classical setting with data, time, and memory complexities of <span class="math">O(2^{3n/4})</span>. The complexities of our quantum attacks depend on the adversary’s model and the number of qubits available. When the adversary has an access to quantum computers for offline computations but online queries are made in a classical manner (so called Q1 model), the attack complexities are <span class="math">O(2^{n/2})</span> classical queries, <span class="math">O(2^{n}/q)</span> quantum computations by using about <span class="math">q</span> qubits. Those are balanced at <span class="math">\\tilde{O}(2^{n/2})</span>, which significantly improves the classical attack. Technically, we convert the quantum claw finding algorithm to be suitable in the Q1 model. The attack is then extended to the case that the adversary can make superposition queries (so called Q2 model). The attack approach is drastically changed from the one in the Q1 model; the attack is based on 3-round distinguishers with Simon’s algorithm and then appends 3 rounds for key recovery. This can be solved by applying the combination of Simon’s and Grover’s algorithms recently proposed by Leander and May.</p>

    <h6 id="sec-3" class="text-base font-medium mt-4">Keywords:</h6>

    <p class="text-gray-300">post-quantum cryptography Demiric-Selçuk meet-in-the-middle attack Feistel construction Grover’s algorithm claw finding algorithm classical query model</p>

    <h2 id="sec-4" class="text-2xl font-bold">1 Introduction</h2>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.1 Background</h3>

    <p class="text-gray-300">Post-quantum cryptography is a hot topic in the current symmetric-key cryptographic community. It has been known that Grover’s quantum algorithm <em>[x10]</em> and its generalized versions <em>[x3, x4]</em> reduce the cost of the exhaustive search on a <span class="math">k</span>-bit key from <span class="math">2^{k}</span> to <span class="math">2^{k/2}</span>. Whereas Grover’s algorithm is quite generic, post-quantum security of specific constructions has also been evaluated, which includes key recovery attacks against Even-Mansour constructions <em>[x16]</em>, distinguishers against 3-round Feistel constructions <em>[x17]</em>, key recovery attacks against multiple encryptions <em>[x18]</em>, forgery attacks against CBC-like MACs <em>[x15]</em>, key recovery attacks against FX constructions <em>[x20]</em>, and so on. Given those advancement of the quantum attacks, NIST announced that they take into account the post-quantum security in the profile of the light-weight cryptographic schemes <em>[x22]</em>. It is now important to investigate how quantum computers can impact to the symmetric-key cryptography.</p>

    <p class="text-gray-300">It is also possible to view the quantum attacks from an approach-wise. That is, several researchers converted the well-known cryptanalytic approaches in the classical setting to ones in the quantum setting. Several examples are quantum differential cryptanalysis <em>[x15]</em>, quantum meet-in-the-middle attacks <em>[x16, x19]</em>, quantum universal forgery attacks <em>[x15]</em>, and so on.</p>

    <p class="text-gray-300">At the present time, one of the most powerful cryptanalytic approaches in the classical setting is a type of the meet-in-the-middle attacks initiated by Demiric and Selçuk <em>[x11]</em>. The attacks are often called meet-in-the-middle attacks, while we call them the <em>DS-MITM attacks</em> in order to distinguish them from the simple and traditional meet-in-the-middle attacks that separate the attack target into two independent parts. The DS-MITM attacks are powerful. For example, one of the current best attacks against AES-128 is the DS-MITM attacks <em>[x12]</em>, which can often be applied to other SPN-based ciphers as well. The DS-MITM attacks are also effective against Feistel constructions <em>[x12]</em> and their variants <em>[x14]</em>. Considering those facts, it is of great interest to investigate whether quantum computers can significantly speed-up the DS-MitM attacks.</p>

    <p class="text-gray-300">A pioneering work of quantum attacks against symmetric-key cryptography by Kuwakado and Morii <em>[x14]</em> and a remarkable work by Kaplan et al. <em>[x13]</em> demonstrate that security of symmetric-key primitives drops to a linear to the output size when adversaries are allowed to make superposition queries, in which the adversaries pass superposition states to oracles and receive the results also as superposition states. Such a situation may be realized in future, and this security model is theoretically interesting. Indeed, several attacks have recently been proposed in this model <em>[x15, x4, x11]</em>. On the other hand, we can consider another security model such that adversaries only make queries through a classical network but have access to quantum computers in their local environment. This model is relatively realistic. Kaplan et al. <em>[x13]</em> called the former and the latter settings <em>Q2 model</em> and <em>Q1 model</em>, respectively.</p>

    <p class="text-gray-300">Given the above background, our target in this paper is a quantum version of the DS-MITM attacks. As a demonstration, we improve on the classical DS-MITM attack against generic 6-round Feistel constructions proposed by Guo et al. <em>[x10]</em>. Our main focus is the Q1 model, while we also discuss further speed-up in the Q2 model.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.2 Simple Quantum Attacks against Feistel Construction</h3>

    <p class="text-gray-300">Before we explain the summary of our results, we explain that simple applications of the quantum attacks do not strongly impact to the security of the Feistel construction. We start by introducing the target Feistel construction analyzed in this paper.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Target Feistel Construction.</h4>

    <p class="text-gray-300">This paper presents cryptanalysis against a Feistel construction that is typically analyzed in the context of generic attacks. Namely, our target is a balanced Feistel construction whose block size is <span class="math">n</span> bits, and the round function first XORs an <span class="math">n/2</span>-bit subkey and then apply a public function <span class="math">F:\\{0,1\\}^{n/2}\\mapsto\\{0,1\\}^{n/2}</span>. Subkeys in each round are independently chosen, thus the key size for <span class="math">r</span> rounds is <span class="math">nr/2</span> bits. The public function <span class="math">F</span> can be different in different rounds. To avoid making the paper unnecessarily complicated, we denote the public function in all rounds by an identical notation <span class="math">F</span>.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">Classical Attacks against Feistel Construction.</h4>

    <p class="text-gray-300">Generic attacks in the classical setting against the class of Feistel constructions have been studied by many papers in various approaches; the impossible differential attack <em>[x12]</em>, the all-subkeys recovery attack <em>[x11, x11]</em>, the DS-MITM attack <em>[x10]</em>, the dissection attack <em>[x6]</em>, and so on. The number of attacked rounds depends on the assumed key size. Considering that the block size is <span class="math">n</span> bits and thus the adversaries can obtain the full codebook with <span class="math">2^{n}</span> queries and memory, let us discuss the case that the adversaries can spend up to <span class="math">2^{n}</span> computations. In this setting, the best attack is the DS-MITM attack <em>[x10]</em> that recovers the key up to 6 rounds with <span class="math">O(2^{3n/4})</span> complexities in all of data, time, and memory.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">Application of Grover’s Algorithm and Parallelization.</h4>

    <p class="text-gray-300">The most simple quantum attack is applying Grover’s algorithm <em>[x14]</em> to exhaustive key search. Let <span class="math">k</span> denote the key length. With a quantum computer and Grover’s algorithm, the exhaustive search can be performed in time <span class="math">O(2^{k/2})</span>. Furthermore, if <span class="math">O(n2^{p})</span> qubits are available to the adversary, the Grover search can be parallelized <em>[x12]</em>, and the cost of the exhaustive search is reduced in time <span class="math">O(2^{(k-p)/2})</span>. Thus, by applying the parallelized Grover search to the <span class="math">r</span>-round Feistel construction, key recovery attacks can be performed in time <span class="math">O(2^{nr/4-p/2})</span> with <span class="math">O(1)</span> classical queries, using <span class="math">O(n2^{p})</span> qubits.</p>

    <p class="text-gray-300">For 6 rounds (<span class="math">r=6</span>), the key can be recovered in time <span class="math">O(2^{n})</span>, using <span class="math">\\tilde{O}(2^{n})</span> qubits. This does not have any advantages. Strictly speaking, the exhaustive search can be performed without guessing the last-round subkey, but the attack still does not have any advantage over the classical DS-MITM attack.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">Application of Quantum Dissection Attacks.</h4>

    <p class="text-gray-300">Consider an iterated block cipher, i.e., the cipher which is constructed as <span class="math">E_{k}^{r}=E_{1,K_{1}}\\circ E_{2,K_{2}}\\circ\\cdots\\circ E_{r,K_{r}}</span>, where each <span class="math">E_{i}</span> is an <span class="math">n</span>-block cipher with <span class="math">m</span>-bit key, and subkeys in <span class="math">k=(K_{1},\\ldots,K_{r})</span> are independently chosen. <span class="math">E_{k}^{r}</span> is an <span class="math">n</span>-bit block cipher with <span class="math">mr</span>-bit key, and the iterated construction is one of the simplest ways to handle a long key only by using a block cipher for short keys.</p>

    <p class="text-gray-300">Kaplan proposed quantum meet-in-the-middle attacks and quantum dissection attacks to recover the key against the iterated construction <em>[x10]</em>. For <span class="math">r=2</span>, the quantum meet-in-the-middle attack can recover the full key in time <span class="math">O(2^{2m/3})</span>, using <span class="math">O(2^{2m/3})</span> qubits. For <span class="math">r=4</span>, the quantum dissection attack can recover the full key in time <span class="math">O(2^{2m/3+n/2})</span>, using <span class="math">O(2^{2m/3})</span> qubits.</p>

    <p class="text-gray-300">These attacks can be applied to Feistel constructions, as Dinur et al. <em>[x6]</em> applied the dissection attack to Feistel constructions in the classical setting. For example, 6-round Feistel constructions can be regarded as</p>

    <p class="text-gray-300">two iterations of the 3-round Feistel construction. Thus, applying the quantum meet-in-the-middle attack, we can recover the full key in time <span class="math">O(2^{n})</span>, using <span class="math">O(2^{n})</span> qubits. Again, this approach does not have any advantage over the classical DS-MITM attack.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">1.3 Our Contributions</h3>

    <p class="text-gray-300">We show that quantum computers significantly speed-up the DS-MITM attacks in both of the Q1 and Q2 models.</p>

    <p class="text-gray-300">For the Q1 model, we need to solve a variant of <em>claw finding problem</em> to find a match between the offline and online phases. Normally, a claw between functions <span class="math">f^{\\prime}</span> and <span class="math">g</span> is defined to be a pair <span class="math">(x,y)</span> such that <span class="math">f^{\\prime}(x)=g(y)</span>, and there exist quantum algorithms <em>[x1, x2, x15, x28]</em> to find a claw assuming both of <span class="math">f^{\\prime}</span> and <span class="math">g</span> are quantum accessible. However, we need to find a pair <span class="math">(x,y)</span> such that <span class="math">f(x,y)=g(y)</span>, and <span class="math">g</span> must be implemented in a classical manner in our Q1 model attack. Thus we describe a quantum algorithm to solve this issue.</p>

    <p class="text-gray-300">We then apply the above algorithm in the Q1 model to improve the classical DS-MITM attack by Guo et al. <em>[x12]</em> against the 6-round Feistel construction. The data complexity, or the number of classical queries, is reduced from <span class="math">O(2^{3n/4})</span> of the classical attack to <span class="math">O(2^{n/2})</span>. The time complexity <span class="math">T</span> depends on the parameter <span class="math">q</span> that is the number of qubits available. In fact, <span class="math">T</span> is given by a tradeoff curve <span class="math">Tq=2^{n}</span>, where <span class="math">q\\leq 2^{n/2}</span>. Hence, in addition to <span class="math">D</span>, the quantum attack outperforms the classical attack with respect to <span class="math">T</span> when <span class="math">q&gt;2^{n/4}</span>. In particular, all parameters are balanced at <span class="math">\\tilde{O}(2^{n/2})</span>, which improves previous <span class="math">O(2^{3n/4})</span> in the classical setting.</p>

    <p class="text-gray-300">We then further analyze the attack complexity against the 6-round generic Feistel construction in the Q2 model. The approach is quite different from the one in the Q1 model. We use the distinguisher against 3-round Feistel construction by Kuwakado and Morii <em>[x18]</em> as a base, and then append 3 more rounds for key recovery. The 3-round distinguisher uses Simon’s algorithm <em>[x24]</em> whereas the 3-round key recovery requires to use Grover’s algorithm <em>[x14]</em>. The combination of those two algorithms has recently been studied by Leander and May <em>[x20]</em>, which leads to significant speed-up in our setting. In this attack, <span class="math">T=D=2^{3n/4}</span> that is the same as the classical attack, but the space, i.e. the number of qubits and the amount of classical memory is <span class="math">O(1)</span>. This extreme efficiency in space is only available in the Q2 model.</p>

    <p class="text-gray-300">As pointed out in Kaplan et al. <em>[x13]</em>, the 3-round distinguisher has the following problem:</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Problem 1</h6>

    <p class="text-gray-300">The 3-round distinguisher by Kuwakado and Morii only uses the right half <span class="math">n/2</span>-bits of outputs of the Feistel construction. On the other hand, if the Feistel construction is implemented on a quantum circuit, then it will output all the <span class="math">n</span>-bits. In the classical setting, attackers can just truncate received <span class="math">n</span> bits to obtain the right half <span class="math">n/2</span>-bits. However, in the quantum setting, truncating <span class="math">n</span> bits to <span class="math">n/2</span>-bits is non-trivial because all (quantum) bits are entangled. Hence the 3-round distinguisher is applicable only when attackers have access to a quantum circuit which outputs just the right half <span class="math">n/2</span>-bits of the Feistel construction.</p>

    <p class="text-gray-300">This paper shows a general technique to simulate “truncation” of outputs of oracles in the quantum setting. Our technique can apply not only to the 3-round distinguisher by Kuwakado and Morii but also to various situations in symmetric-key cryptography This technique solves the controversial issue of the quantum distinguisher by Kuwakado and Morii, which is pointed out by Kaplan et al <em>[x13]</em>.</p>

    <p class="text-gray-300">The attack complexity against 6-round Feistel construction in each attack setting is summarized in Table 1. When the attacks are compared with respect to a product of the time complexity, data complexity, the number of qubits and the amount of classical memory, the Q2 model outperforms the other two. When the attacks are compared with respect to a maximum value among the time complexity, data complexity, the number of qubits and the amount of classical memory, the Q1 model becomes the best.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">1.4 Paper Outline</h3>

    <p class="text-gray-300">The paper is organized as follows. Section 2.1 explains attack models and quantum algorithms related to this work. Section 3 extends the previous quantum claw finding algorithm to the case that one function is evaluated only in the classical manner. Section 4 improves the previous DS-MITM attack against 6-round Feistel construction by</p>

    <p class="text-gray-300">Table 1. Summary of the Attack Complexities against 6-Round Feistel Construction</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Setting</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Time (T)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Data (D)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">#qubits (N)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Classical Mem (M)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Overall Complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Product (TDMN)</td>

            <td class="px-3 py-2 border-b border-gray-700">max(T,D,M,N)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Classical</td>

            <td class="px-3 py-2 border-b border-gray-700">N3/4</td>

            <td class="px-3 py-2 border-b border-gray-700">N3/4</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">N1/2</td>

            <td class="px-3 py-2 border-b border-gray-700">N9/4</td>

            <td class="px-3 py-2 border-b border-gray-700">N3/4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Q1</td>

            <td class="px-3 py-2 border-b border-gray-700">N/q</td>

            <td class="px-3 py-2 border-b border-gray-700">N1/2</td>

            <td class="px-3 py-2 border-b border-gray-700">q</td>

            <td class="px-3 py-2 border-b border-gray-700">N1/2</td>

            <td class="px-3 py-2 border-b border-gray-700">N8/4</td>

            <td class="px-3 py-2 border-b border-gray-700">N1/2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Q2</td>

            <td class="px-3 py-2 border-b border-gray-700">N3/4</td>

            <td class="px-3 py-2 border-b border-gray-700">N3/4</td>

            <td class="px-3 py-2 border-b border-gray-700">log(N)</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">log N·N6/4</td>

            <td class="px-3 py-2 border-b border-gray-700">N3/4</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The range of  <span class="math">q</span>  in Q1 is  <span class="math">q \\leq N^{1/2}</span> . All complexities of Q1 are balanced when  <span class="math">q = N^{1/2}</span> . Q1 always outperforms classical attacks in terms of the data complexity for any  <span class="math">q</span> . Besides, it improves classical attacks in terms of the time complexity when  <span class="math">N^{1/4} \\leq q \\leq N^{1/2}</span> .</p>

    <p class="text-gray-300">applying the theory in Sect. 3. Section 5 discusses the attack on Feistel construction when the adversaries can make superposition queries.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This section gives attack models and a summary of the quantum algorithms that are related to our work. Throughout the paper, we assume a basic knowledge of the quantum circuit model. For a public function  <span class="math">F: \\{0,1\\}^{n/2} \\to \\{0,1\\}^{n/2}</span> , we assume that a quantum circuit which calculates  <span class="math">F</span> ,  $C_F:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y\\rangle \\mapsto</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y \\oplus F(x)\\rangle<span class="math">  is available, and  </span>C_F$  runs in a constant time.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If we want to access some data or to operate table look-up in a quantum algorithm without any measurement, we have to set all data on quantum circuits so that data can be accessed in quantum superposition states. In particular, if we want to implement random access to memories, we need as many qubits (or width of the quantum circuit) as the data size. Thus, quantum memory for random access is physically equivalent to quantum processor. We regard that they are essentially identical.</p>

    <p class="text-gray-300">Regardless of whether we use quantum computers or classical computers, the running time of an algorithm significantly depends on how a computational hardware is realized, when the algorithm needs exponentially many hardware resources. Thus if we want to use exponentially many qubits, we have to pay attention to data communication costs in quantum hardwares. In the quantum setting, Bernstein [Ber09] and Banegas and Bernstein [BB17] introduced two communication models, which they call free communication model and realistic communication model. The free communication model assumes that we can operate a unitary operation on any pairs of qubits. On the other hand, the realistic communication model assumes that  <span class="math">2^{p}</span>  qubits are arranged as a  <span class="math">2^{p/2} \\times 2^{p/2}</span>  mesh, and a unitary operation can be operated only on a pair of qubits that are within a constant distance. A quantum hardware in the free communication model which has  <span class="math">O(N)</span>  qubits can simulate a quantum hardware in the free communication model which has  <span class="math">O(\\sqrt{N})</span>  qubits, with time overhead  <span class="math">O(\\sqrt{N})</span>  [BBG+13].</p>

    <p class="text-gray-300">In this paper, for simplicity, we estimate the time complexity of quantum algorithms in the free communication model. Note that this does not imply that our proposed attacks do not work in the realistic communication model. We design our algorithms so that small quantum processors (of size polynomial in  <span class="math">n</span> ) parallelly run without any communication between each pair of small processors. Hence if the realistic communication model is applied, time complexity increases by a factor of polynomial in  <span class="math">n</span> .</p>

    <p class="text-gray-300">Grover's Algorithm. Grover's quantum algorithm, or the Grover search, is one of the most famous quantum algorithms, with which we can obtain quadratic speed up on database searching problems compared to the classical algorithms. It was originally developed by Grover [Gro96] and generalized later [BBHT98,BHMT02]. Let us consider the following problem:</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Problem 2.</h6>

    <p class="text-gray-300">Suppose a function <span class="math">\\phi:\\{0,1\\}^{u}\\to\\{0,1\\}</span> is given as a black box, with a promise that there is <span class="math">x</span> such that <span class="math">\\phi(x)=1</span>. Then, find <span class="math">x</span> such that <span class="math">\\phi(x)=1</span>.</p>

    <p class="text-gray-300">Grover’s algorithm can solve the above problem with <span class="math">O(2^{u/2})</span> evaluations of <span class="math">\\phi</span> using <span class="math">O(u)</span> qubits, if <span class="math">\\phi</span> is given as a quantum oracle (or using <span class="math">O(v)</span> qubits, if <span class="math">\\phi</span> is given as a <span class="math">v</span>-qubit quantum circuit without any measurement). The algorithm is composed of iterations of an elementary step which operates <span class="math">O(1)</span> evaluation of <span class="math">\\phi</span>, and can easily be parallelized <em>[x11]</em>.</p>

    <p class="text-gray-300">If we can use a quantum computer with <span class="math">O(u2^{p})</span> qubits, we regard it as <span class="math">2^{p}</span> independent small quantum processors with <span class="math">O(u)</span> qubits. Then, by parallelly running <span class="math">O(\\sqrt{2^{u}/2^{p}})</span> iterations on each small quantum processor, we can find <span class="math">x</span> such that <span class="math">\\phi(x)=1</span> with high probability. This parallelized algorithm runs in time <span class="math">O(\\sqrt{2^{u}/2^{p}}\\cdot T_{\\phi})</span>, where <span class="math">T_{\\phi}</span> is the time needed to evaluate <span class="math">\\phi</span> once.</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">Simon’s Algorithm.</h4>

    <p class="text-gray-300">Grover’s algorithm is an exponential time algorithm. Here we introduce a quantum algorithm that can solve a problem in polynomial time. The problem is defined as follows:</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Problem 3.</h6>

    <p class="text-gray-300">Let <span class="math">\\phi:\\{0,1\\}^{u}\\to\\{0,1\\}^{u}</span> be a function such that there is a unique secret value <span class="math">s</span> that satisfies <span class="math">\\phi(x)=\\phi(y)</span> if and only if <span class="math">x=y</span> or <span class="math">x=y\\oplus s</span>. Then, find <span class="math">s</span>.</p>

    <p class="text-gray-300">Suppose <span class="math">\\phi</span> is given as a quantum oracle. Then, Simon’s algorithm <em>[x23]</em> can solve the above problem with <span class="math">O(n)</span> queries, using <span class="math">O(n)</span> qubits. We have to solve a system of linear equations after making queries, which requires <span class="math">O(n^{3})</span> arithmetic operations. Since any classical algorithm needs exponential time to solve this problem (see the original paper <em>[x23]</em> for details), Simon’s algorithm obtains exponential speed-up from classical algorithms. The algorithm can be applied to the problem of which condition <span class="math">\`\`\\phi(x)=\\phi(y)</span> if and only if <span class="math">x=y</span> or <span class="math">x=y\\oplus s&quot;</span> is replaced with the weaker condition “<span class="math">\\phi(x\\oplus s)=\\phi(x)</span> for any <span class="math">x&quot;</span>, under the assumption that <span class="math">\\phi</span> satisfies some good properties <em>[x14]</em>.</p>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">Quantum Claw Finding Algorithms.</h4>

    <p class="text-gray-300">Let us consider two functions <span class="math">f:\\{0,1\\}^{u}\\to\\{0,1\\}^{\\ell}</span> and <span class="math">g:\\{0,1\\}^{v}\\to\\{0,1\\}^{\\ell}</span>. If there is a pair <span class="math">(x,y)\\in\\{0,1\\}^{u}\\times\\{0,1\\}^{v}</span> such that <span class="math">f(x)=g(y)</span>, then it is called a <em>claw</em> of the functions <span class="math">f</span> and <span class="math">g</span>. Now we consider the following problem:</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Problem 4.</h6>

    <p class="text-gray-300">Let <span class="math">u,v</span> be positive integers such that <span class="math">u\\geq v</span>. Suppose that two functions <span class="math">f:\\{0,1\\}^{u}\\to\\{0,1\\}^{\\ell}</span> and <span class="math">g:\\{0,1\\}^{v}\\to\\{0,1\\}^{\\ell}</span> are given as black boxes. Then, find a claw of <span class="math">f</span> and <span class="math">g</span>.</p>

    <p class="text-gray-300">This problem, called <em>claw finding problem</em>, has attracted researchers’ attention and is well studied. It is known that, given <span class="math">f</span> and <span class="math">g</span> as quantum oracles, this problem can be solved with <span class="math">O(2^{(u+v)/3})</span> queries in the case <span class="math">v\\leq u&lt;2v</span>, and <span class="math">O(2^{u/2})</span> queries in the case <span class="math">2v\\leq u</span> <em>[x1, x1, x10, x20]</em>. Quantum claw finding algorithms and their generalizations already have some applications in attacks against symmetric-key cryptosystems <em>[x16, x21]</em>. Below we assume <span class="math">\\ell=O(u+v)</span>.</p>

    <h2 id="sec-22" class="text-2xl font-bold">3 Claw Finding between Classical and Quantum Functions</h2>

    <p class="text-gray-300">Quantum claw finding algorithms are useful, though, they cannot be applied if one of target functions, say <span class="math">g</span>, is not quantum accessible. For example, if we need some information from a classical online (i.e., keyed) oracle to calculate <span class="math">g(y)</span>, then we have to use other algorithms, even if we have a quantum computer.</p>

    <p class="text-gray-300">Sections 3 and 4 focus on the Q1 model. Hence, this section considers how to find a claw of functions <span class="math">f,g</span> where <span class="math">g</span> can be evaluated only classically. We are particularly interested in the case that there exists only a single claw of <span class="math">f</span> and <span class="math">g</span>, and show that the following proposition holds.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Proposition 1.</h6>

    <p class="text-gray-300">Suppose that <span class="math">f</span> can be implemented on a quantum circuit <span class="math">C_{f}</span> using <span class="math">O(u+v)</span> qubits, <span class="math">g</span> can be evaluated only classically, and we can use a quantum computer with <span class="math">O((u+v)2^{p})</span> qubits. Assume that there exist only a single claw of <span class="math">f</span> and <span class="math">g</span>. Then we can solve Problem 4 in time</p>

    <p class="text-gray-300"><span class="math">O\\left(T^{C}_{g,all}+2^{u/2+v-(p+p_{L})/2}\\cdot T^{Q}_{f}+2^{v-p_{L}+p}\\right),</span> (1)</p>

    <p class="text-gray-300">where <span class="math">T^{C}_{g,all}</span> is the time to calculate the pair <span class="math">(y,g(y))</span> for all <span class="math">y</span>, <span class="math">T^{Q}_{f}</span> is the time to run <span class="math">C_{f}</span> once, and <span class="math">p_{L}</span> is a parameter that satisfies <span class="math">p_{L}\\leq\\min\\{p,n\\}</span>. We also use <span class="math">O(2^{v})</span> classical memory.</p>

    <p class="text-gray-300">Below we give an algorithm to find a claw and confirm that it gives the upper bound 1, which shows Proposition 1.</p>

    <p class="text-gray-300">Algorithm. First, evaluate <span class="math">g(y)</span> for all <span class="math">y</span> classically, and store each pair <span class="math">(y, g(y))</span> in a list <span class="math">L</span>. For each <span class="math">y \\in \\{0,1\\}^v</span>, define a function <span class="math">f_y: \\{0,1\\}^u \\to \\{0,1\\}</span> by <span class="math">f_y(x) = 1</span> if and only if <span class="math">f(x) = g(y)</span>. Given <span class="math">C_f</span> and the list <span class="math">L</span>, we can implement <span class="math">f_y</span> on a quantum circuit that runs in time <span class="math">O(T_f^Q)</span> using <span class="math">O(u + v)</span> qubits. Note that the parallelized Grover search on <span class="math">f_y</span>, which parallelly runs <span class="math">O(2^{p - p_L})</span> independent small processors, can find <span class="math">x_0</span> such that <span class="math">f_y(x_0) = 1</span> (if there exists) in time <span class="math">O(2^{u/2 - (p - p_L)/2} \\cdot T_f^Q)</span>. Let <span class="math">C_y^{Grover}</span> denote this quantum circuit of size <span class="math">O((u + v)2^p)</span>. Then, run the following procedure:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">0 \\leq i \\leq 2^{v - p_L} - 1</span>, do:</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. Run $C_{(i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j)}^{Grover}<span class="math"> parallelly for </span>0 \\leq j \\leq 2^{p_L} - 1$ (see Fig. 1).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the above procedure, we consider that <span class="math">i,j</span> are elements in <span class="math">\\{0,1\\}^{v - p_L}</span> and <span class="math">\\{0,1\\}^{p^L}</span>, respectively, and $i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j\\in \\{0,1\\}^v$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1. How to use <span class="math">O(2^p)</span> qubits</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Complexity analysis. To evaluate <span class="math">g(y)</span> and store it for every <span class="math">y</span>, we need <span class="math">O(T_{g,all}^{C})</span> time and <span class="math">O(2^{v})</span> classical memory. In Step 2 of the procedure, the parallelized Grover search on $f_{(i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j)}<span class="math"> requires time </span>O(2^{u / 2 - (p - p_L) / 2}T_f^Q)<span class="math"> for each </span>i<span class="math"> and </span>j<span class="math"> as stated above. In Step 3 of the procedure, we need time </span>O(2^{p})<span class="math"> to check whether a pair </span>(x,(i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j))<span class="math"> such that </span>f_{(i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j)}(x) = 1<span class="math"> exists. Thus, the total running time is </span>O(T_{g,all}^{C} + 2^{v - p_{L}}\\cdot (2^{u / 2 - p / 2 + p_{L} / 2}T_{f}^{Q} + 2^{p})) = O(T_{g,all}^{C} + 2^{u / 2 + v - p / 2 - p_{L} / 2}\\cdot T_{f}^{Q} + 2^{v - p_{L} + p})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As for the number of qubits, for a fixed <span class="math">i</span>, we use <span class="math">O((u + v)2^{p - p_L})</span> qubits for the parallelized Grover search on $f_{(i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j)}<span class="math"> for each </span>0 \\leq j \\leq 2^{p_L} - 1<span class="math">. Thus the total number of qubits we use is </span>O((u + v)2^{p - p_L}) \\cdot 2^{p_L} = O((u + v)2^p)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-24" class="text-2xl font-bold">3.1 Variation of Claw Finding</h2>

    <p class="text-gray-300">Next, we consider the following variant of the claw finding problem.</p>

    <p class="text-gray-300">Problem 5. Suppose that functions <span class="math">f: \\{0,1\\}^u \\times \\{0,1\\}^v \\to \\{0,1\\}^\\ell</span> and <span class="math">g: \\{0,1\\}^v \\to \\{0,1\\}^\\ell</span> are given as black boxes, with promise that there is a unique pair <span class="math">(x,y) \\in \\{0,1\\}^u \\times \\{0,1\\}^v</span> such that <span class="math">f(x,y) = g(y)</span>. Then, find such a pair <span class="math">(x,y)</span>.</p>

    <p class="text-gray-300">Again, we assume that <span class="math">g</span> can be evaluated only classically, <span class="math">f</span> can be implemented on a quantum circuit, and <span class="math">\\ell = O(u + v)</span>. Problem 5 appears to be different from Problem 4, however, we can also solve it by applying our algorithm introduced above with a slight modification to the definition of <span class="math">f_y</span> as: <span class="math">f_y(x) = 1</span> if and only if <span class="math">f(x,y) = g(y)</span>. With this small modification, we can find the pair <span class="math">(x,y)</span> such that <span class="math">f(x,y) = g(y)</span> with the same complexity as in Proposition 1. The next section treats this variant problem to attack Feistel constructions, instead of the original claw finding problem. In what follows, we measure <span class="math">p \\leq v</span> and <span class="math">2^v \\leq T_{g,all}^C</span>.</p>

    <p class="text-gray-300">Corollary 1. Suppose that <span class="math">f</span> can be implemented on a quantum circuit <span class="math">C_f</span> using <span class="math">O(u + v)</span> qubits, <span class="math">g</span> can be evaluated only classically, and we can use a quantum computer with <span class="math">O((u + v)2^p)</span> qubits, where <span class="math">p \\leq v</span>. Assume that there is a unique claw of <span class="math">f</span> and <span class="math">g</span>. Then we can solve Problem 4 in time</p>

    <div class="my-4 text-center"><span class="math-block">O \\left(T _ {g, a l l} ^ {C} + 2 ^ {\\frac {u}{2} + v - p} \\cdot T _ {f} ^ {Q}\\right), \\tag {2}</span></div>

    <p class="text-gray-300">where  <span class="math">T_{g,all}^{C} \\geq 2^{e}</span>  is the time to calculate the pair  <span class="math">(y, g(y))</span>  for all  <span class="math">y</span>  and  <span class="math">T_{f}^{Q}</span>  is the time to run  <span class="math">C_{f}</span>  once. We also use  <span class="math">O(2^{e})</span>  classical memory.</p>

    <p class="text-gray-300">The algorithms that we introduced in this section assume an ideal situation that we are given a quantum circuit that calculates  <span class="math">f</span>  without error. However, in real applications, having some error might be inevitable (e.g. we use Grover's algorithm as a subroutine a few times to calculate  <span class="math">f</span> ). Nevertheless, if error is small, then the above algorithms can still be applied with a small modification. (Roughly speaking, we use quantum amplitude amplification technique [BHMT02] instead of Grover's algorithm. See Section B in the appendix for details.)</p>

    <p class="text-gray-300">In this section, we show that quantum computers can significantly speed-up the DS-MITM attacks even under the limitation that queries are made only in a classical manner (Q1 model). To demonstrate it, we improve on the previous key recovery attack against 6-round Feistel constructions presented by Guo et al. [GJNS14].</p>

    <p class="text-gray-300">Overview of DS-MITM Attacks We first briefly introduce the framework of the DS-MITM attack. The attack generally consists of the distinguisher and the key-recovery parts as illustrated in Fig. 2. A truncated differential is specified to the entire cipher and suppose that the plaintext difference  <span class="math">\\Delta P</span>  propagates to the input difference  <span class="math">\\Delta X</span>  of the distinguisher with probability  <span class="math">p_1</span> . Similarly, the ciphertext difference  <span class="math">\\Delta C</span>  propagates to the output difference  <span class="math">\\Delta Y</span>  of the distinguisher with probability  <span class="math">p_2</span>  when decryption is performed. The attack is composed of two parts: distinguisher analysis and queried-data analysis.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 2. Overview of DS-MITM Attacks.</p>

    <p class="text-gray-300">In the distinguisher analysis, the attacker enumerates all the possible differential characteristics that can satisfy the specified truncated differential. Suppose that there exist  <span class="math">N_{c}</span>  such characteristics. For each of them, input paired values to the distinguisher are expected to be fixed uniquely. Let  <span class="math">(X,X_0^{\\prime})</span>  be the paired values. Then, the attacker generates a set of texts called  <span class="math">\\delta</span> -set by generating  <span class="math">\\delta - 1</span>  new texts  <span class="math">X_{i}^{\\prime} \\gets X_{0}^{\\prime} \\oplus i</span>  for  <span class="math">i = 1,2,\\dots,\\delta - 1</span> . Suppose that the corresponding value at the output of the distinguisher can be computed. Let  <span class="math">Y,Y_0&#x27;,Y_1&#x27;,Y_2&#x27;,\\dots,Y_{\\delta - 1}&#x27;</span>  be the corresponding values at the output of the distinguisher. The attacker then computes the differences between  <span class="math">Y</span>  and  <span class="math">Y_{i}^{\\prime}</span>  for  <span class="math">i = 0,1,\\dots,\\delta - 1</span>  and makes a sequence of  <span class="math">\\delta</span>  output differences at the output of the distinguisher. This sequence is called  <span class="math">\\Delta</span> -sequence. Note that the difference between  <span class="math">Y</span>  and  <span class="math">Y_{i}^{\\prime}</span>  may be able to be computed only partially, say  <span class="math">\\gamma</span>  bits. Thus the bit-size of the sequence is  <span class="math">\\gamma \\delta</span> . In the end, the  <span class="math">\\Delta</span> -sequence of the size  <span class="math">\\gamma \\delta</span>  bits is computed for each of the  <span class="math">N_{c}</span>  characteristics and stored in a list  <span class="math">L</span> .</p>

    <p class="text-gray-300">In the queried-data analysis, the attacker makes queries to collect  <span class="math">(p_1p_2)^{-1}</span>  paired values having the plaintext difference  <span class="math">\\Delta P</span>  and the ciphertext difference  <span class="math">\\Delta C</span> . One pair, with a good probability, satisfies  <span class="math">\\Delta X</span>  and  <span class="math">\\Delta Y</span>  at the input and output of the distinguisher, respectively. Thus for each of  <span class="math">(p_1p_2)^{-1}</span>  paired values, the attacker guesses subkeys for the key-recovery rounds such that  <span class="math">\\Delta X</span>  and  <span class="math">\\Delta Y</span>  appear after the first and the last key recovery parts, respectively. Then, one of the paired texts (corresponding to  <span class="math">P&#x27;</span> ) is modified to  <span class="math">P_i&#x27;</span>  so that the  <span class="math">\\delta</span> -set is generated at the input to the distinguisher, and those are queried to the oracle to obtain the corresponding ciphertext  <span class="math">C_i&#x27;</span> . The attacker then processes  <span class="math">C_i&#x27;</span>  with the guessed subkeys for the last key-recovery part, and the  <span class="math">\\Delta</span> -sequence is computed at the output of the distinguisher. Finally, those are matched the list  <span class="math">L</span> . If the analyzed pair is a right pair and the guessed subkeys are correct, then a match will be found. Otherwise, a match will not be found as long as  <span class="math">(p_1p_2)^{-1}N_c\\times 2^{-\\gamma \\delta}\\ll 1</span> .</p>

    <p class="text-gray-300">Application to 6-Round Feistel Constructions. Guo et al. [GJNS14] applied the DS-MITM attack to 6-round Feistel constructions. The attack needs to solve the following problems.</p>

    <p class="text-gray-300">Problem 6. Let  <span class="math">F: \\{0,1\\}^{n/2} \\mapsto \\{0,1\\}^{n/2}</span>  be a public function and  <span class="math">\\Delta</span>  be a fixed difference.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For a given output difference  <span class="math">\\Delta_{o}</span> , how can we find all  <span class="math">v</span>  such that  <span class="math">F(v) \\oplus F(v \\oplus \\Delta) = \\Delta_{o}</span> ?</li>

      <li>For a given input difference  <span class="math">\\Delta_{i}</span> , how can we find all  <span class="math">v</span>  such that  <span class="math">F(v) \\oplus F(v \\oplus \\Delta_{i}) = \\Delta</span> ?</li>

    </ul>

    <p class="text-gray-300">In the classical attack, those problems can be solved only with 1 access to the precomputed table of size  <span class="math">2^{n/2}</span> . The procedure is rather straightforward. Readers are refer to the paper by Guo et al. [GJNS14] for the exact procedure.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Distinguisher Analysis. The core of the attacks is the 5-round distinguisher explained below. The input and output differences for the 5 rounds are defined as  $0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X<span class="math">  and  </span>Y\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0<span class="math"> , respectively, where  </span>X,Y\\in \\{0,1\\}^{n / 2},X\\neq Y<span class="math"> . For a given  </span>X,Y<span class="math"> , the number of the 5-round differential characteristics satisfying those input and output differences is  </span>2^{n / 2}<span class="math"> . In fact, by representing the  </span>n / 2<span class="math"> -bit difference of the second round-function&#x27;s output as  </span>Z$ , the 5-round differential characteristics can be fixed to</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fig. 3. Left:  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  Differential Characteristics in the 5-Round Distinguisher. Right: 1-Round Extension for Key-Recovery.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a></p>

    <p class="text-gray-300">For each  <span class="math">Z</span> , both input and output differences of  <span class="math">F</span>  in the middle 3 rounds are fixed, which suggests that the paired values during  <span class="math">F</span>  are fixed to one choice on average. Guo et al. showed that by generating a  <span class="math">\\delta</span> -set at the right half of the distinguisher's input, the corresponding  <span class="math">\\Delta</span> -sequence can be computed for the right-half of the distinguisher's</p>

    <p class="text-gray-300">output. Readers are referred to the paper by Guo et al. <em>[x10]</em> for the complete analysis. The computed <span class="math">\\Delta</span>-sequences are stored in the list <span class="math">L</span>. Note that the size of <span class="math">\\delta</span> is very small. Indeed, <span class="math">p_{1}=2^{-n/2}</span>, <span class="math">p_{2}=1</span>, <span class="math">N_{c}=2^{n/2}</span> and <span class="math">\\gamma=n/2</span>. Hence, <span class="math">\\delta=3</span> is sufficient to filter out all the wrong candidates.</p>

    <p class="text-gray-300">To balance the complexities between the distinguisher analysis and the queried-data analysis, Guo et al. iterated the above analysis for <span class="math">2^{n/4}</span> different choices of <span class="math">Y</span>. More precisely, the <span class="math">n/4</span> MSBs of <span class="math">Y</span> are always set to <span class="math">0</span> and <span class="math">n/4</span> LSBs of <span class="math">Y</span> are exhaustively analyzed. The complexity of the procedure for each choice of <span class="math">Y</span> is <span class="math">O(2^{n/2})</span> both in time and memory. Hence, the entire complexity of the distinguisher part is <span class="math">O(2^{3n/4})</span> in both time and memory.</p>

    <h4 id="sec-27" class="text-lg font-semibold mt-6">Queried-Data Analysis.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Guo et al. appended 1-round before the 5-round distinguisher to achieve the 6-round key-recovery attack, which is illustrated in the right-half of Fig. 3. By propagating the input difference to the distinguisher, $0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X<span class="math">, in backwards, </span>\\Delta P<span class="math"> is set to </span>X\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em><span class="math"> where </span></em><span class="math"> can be any </span>n/2<span class="math">-bit difference. The probability </span>p_{1}<span class="math"> that a randomly chosen plaintext pair with the difference </span>X\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">*<span class="math"> satisfies the difference </span>0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X<span class="math"> after 1 round is </span>2^{-n/2}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The attacker collects the pairs that satisfy the truncated differential in Fig. 3 by using the structure technique. Namely, the attacker prepares 2 sets of <span class="math">2^{n/2}</span> plaintexts in which the first and the second sets have the form $\\{(c\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0),(c\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1),\\cdots,(c\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2^{n/2}-1)\\}<span class="math"> and </span>\\{(c\\oplus X\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0),(c\\oplus X\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1),\\cdots,(c\\oplus X\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2^{n/2}-1)\\}<span class="math">, respectively, where </span>c<span class="math"> is a randomly chosen </span>n/2<span class="math">-bit constant. About </span>2^{n}<span class="math"> pairs exist whereas only </span>O(2^{n/4})<span class="math"> pairs satisfy </span>\\Delta C<span class="math"> in the corresponding ciphertexts. By iterating this procedure </span>O(2^{n/4})<span class="math"> times for different choices of </span>c<span class="math">, the attacker collects </span>O(2^{n/2})<span class="math"> pairs satisfying the truncated differential in Fig. 3. In summary, with </span>O(2^{3n/4})<span class="math"> queries (and thus the time complexity of </span>O(2^{3n/4})<span class="math"> memory accesses), </span>O(2^{n/2})$ pairs are obtained, in which one pair will satisfy the probabilistic differential propagation in the first round.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For each pair, the input and output differences of <span class="math">F</span> in the first round are fixed, which will fix <span class="math">K_{0}</span> uniquely. The attacker then modifies the left-half of the plaintext such that <span class="math">\\delta</span>-set with <span class="math">\\delta=3</span> is generated at the right-half of the input to the distinguisher. The right-half of the plaintext is also modified to ensure that the left-half of the input to the distinguisher is not affected. The modified plaintexts are then queried to obtain the corresponding ciphertexts. The attacker computes the corresponding <span class="math">\\Delta</span>-sequence and matches <span class="math">L</span>; the list computed during the distinguisher analysis. A match recovers <span class="math">K_{0}</span> and <span class="math">Z</span>. The other subkeys are trivially recovered from the second round one by one.</p>

    <h4 id="sec-28" class="text-lg font-semibold mt-6">Summary of Complexity.</h4>

    <p class="text-gray-300">In the distinguisher analysis, both of the time and memory complexities are <span class="math">O(2^{3n/4})</span>. In the queried-data analysis, the data and time complexities are <span class="math">O(2^{3n/4})</span> and it uses a memory of size <span class="math">O(2^{n/2})</span> to collect the pairs with the structure technique.</p>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">Remarks.</h4>

    <p class="text-gray-300">Solving Problem 6 is rather straightforward in the classical attack with <span class="math">O(2^{n/2})</span> memory, whereas this is a crucial problem to the quantum adversaries. This is because the efficient table look-up cannot be executed in quantum computers.</p>

    <h3 id="sec-30" class="text-xl font-semibold mt-8">4.2 Quantum DS-MITM Attack on 6-Round Feistel Constructions</h3>

    <p class="text-gray-300">We now convert the classical DS-MITM attack on 6-round Feistel constructions into quantum one, in which the adversary has access to a quantum computer to perform offline computations whereas queries are made in the classical manner. The attack complexity becomes <span class="math">O(2^{n/2})</span> queries, <span class="math">O(2^{n/2})</span> offline quantum computations by using <span class="math">O(2^{n/2})</span> qubits.</p>

    <p class="text-gray-300">The main idea is to introduce quantum operations to reduce the complexity of the distinguisher analysis. We show that the claw finding algorithm in Sect. 3 can be used to find a match between the distinguisher and the queried-data analyses. This enables us to adjust the tradeoff between the complexities in the distinguisher and the queried-data analyses, and thus the data complexity can also be reduced.</p>

    <h4 id="sec-31" class="text-lg font-semibold mt-6">Adjusted Truncated Differentials.</h4>

    <p class="text-gray-300">After the careful analysis, we determined to analyze all <span class="math">2^{n/2}</span> choices of <span class="math">Y</span> in the 5-round distinguisher during the distinguisher analysis part. In the classical attack, this increases the cost of the distinguisher analysis to <span class="math">O(2^{n})</span>, whereas it reduces the number of queries in the queried-data analysis. In the quantum attack, the increased cost of the distinguisher analysis can be reduced to its square root, i.e. <span class="math">O(2^{n/2})</span> and eventually the cost of two analyses are balanced.</p>

    <h4 id="sec-32" class="text-lg font-semibold mt-6">Switching Online and Offline Phases.</h4>

    <p class="text-gray-300">The claw finding algorithm in Sect. 3 matches the result of the quantum computation against the results collected in the classical method. Namely, the results of the queried-data analysis must be stored before the distinguisher analysis starts.</p>

    <p class="text-gray-300">This can be easily done by switching the order of the two analyses. In fact, such a switch has already been applied by Darbez and Perrin <em>[x10, Appendix E]</em> though their goal is to optimize the classical attack complexity, which is different from ours.</p>

    <h4 id="sec-33" class="text-lg font-semibold mt-6">Queried-Data Analysis.</h4>

    <p class="text-gray-300">Because queries are made in the classical manner, the procedure of the queried-data analysis remains unchanged from the classical attack by Guo et al. However, to directly apply the claw finding algorithm to the DS-MITM attack, we explicitly separate the procedure to collect <span class="math">p_{1}^{-1}=2^{n/2}</span> pairs satisfying the truncated differentials (both <span class="math">\\Delta P</span> and <span class="math">\\Delta C</span>) and the procedure to compute <span class="math">\\Delta</span>-sequences.</p>

    <h4 id="sec-34" class="text-lg font-semibold mt-6">Precomputation for Collecting Pairs.</h4>

    <p class="text-gray-300">The goal of this procedure is to collect <span class="math">2^{n/2}</span> pairs satisfying both <span class="math">\\Delta P=X\\parallel<em></span> and <span class="math">\\Delta C=</em>\\parallel 0</span>. To use the structure technique, we query 2 sets of <span class="math">2^{n/2}</span> plaintexts <span class="math">\\{(c\\parallel 0),(c\\parallel 1),\\cdots,(c\\parallel 2^{n/2}-1)\\}</span> and <span class="math">\\{(c\\oplus X\\parallel 0),(c\\oplus X\\parallel 1),\\cdots,(c\\oplus X\\parallel 2^{n/2}-1)\\}</span>. About <span class="math">2^{n}</span> pairs can be generated and <span class="math">2^{n/2}</span> of them have no difference in the right-half of the ciphertexts. The generated pairs are stored in the list <span class="math">L^{pre}</span> indexed by the difference <span class="math">Y</span> (the left-half of <span class="math">\\Delta C</span>). In summary, this procedure requires <span class="math">O(2^{n/2})</span> classical queries, <span class="math">O(2^{n/2})</span> memory access and <span class="math">O(2^{n/2})</span> classical memory.</p>

    <h4 id="sec-35" class="text-lg font-semibold mt-6">Generating <span class="math">\\Delta</span>-sequences.</h4>

    <p class="text-gray-300">The goal of this procedure is to generate <span class="math">\\Delta</span>-sequences for all the pairs stored in <span class="math">L^{pre}</span>. To make it consistent with the notations in Sect. 3, we define a classical function <span class="math">g:\\{0,1\\}^{n/2}\\rightarrow\\{0,1\\}^{\\delta n/2}</span> that takes the difference <span class="math">Y</span> (the left-half of <span class="math">\\Delta C</span>) as input and outputs the <span class="math">\\Delta</span>-sequence as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Pick up all the pairs in <span class="math">L^{pre}</span> such that the difference <span class="math">Y</span> matches the <span class="math">g</span>’s input.</li>

      <li>Compute the <span class="math">\\Delta</span>-sequences as in the classical attack by assuming that the probabilistic differential propagation in the first round is satisfied.</li>

    </ol>

    <p class="text-gray-300">Then, the classical queried-data analysis becomes identical with computing <span class="math">g(y)</span> for all <span class="math">y\\in Y</span>. The cost of computing <span class="math">g</span> for a single choice of <span class="math">y</span> is 1. Hence, with the notation in Sect. 3, <span class="math">T^{C}_{g,all}</span> becomes <span class="math">O(2^{n/2})</span>. After this phase, a list <span class="math">L</span> with a classical memory that stores <span class="math">O(2^{n/2})</span> <span class="math">\\Delta</span>-sequences is generated.</p>

    <h4 id="sec-36" class="text-lg font-semibold mt-6">Quantum Distinguisher Analysis.</h4>

    <p class="text-gray-300">The goal of the distinguisher analysis is to calculate <span class="math">\\Delta</span>-sequences for all <span class="math">2^{n/2}</span> choices of <span class="math">Y</span> and <span class="math">2^{n/2}</span> choices of <span class="math">Z</span> in Fig. 3 in order to find a match with <span class="math">L</span>. We define a quantum function <span class="math">f:\\{0,1\\}^{n/2}\\times\\{0,1\\}^{n/2}\\rightarrow\\{0,1\\}^{\\delta n/2}</span> that takes <span class="math">Z</span> and <span class="math">Y</span> as input and calculates the corresponding <span class="math">\\Delta</span>-sequence. Given that <span class="math">L</span> is computed before this analysis, the goal can be viewed as searching for a preimage <span class="math">Z</span> such that <span class="math">\\exists Y,f(Z,Y)\\in L</span>.</p>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">An Issue to be taken into account.</h4>

    <p class="text-gray-300">Note that in our situation, the function <span class="math">f</span> might be incompletely defined. We want to define <span class="math">f(Z,Y)</span> to be the corresponding <span class="math">\\Delta</span>-sequence to <span class="math">(Z,Y)</span>, however, to be precise, we will have the following issue when Problem 6 is solved.</p>

    <p class="text-gray-300">To calculate the corresponding <span class="math">\\Delta</span>-sequence, we need input/output pairs of the 2nd, 3rd, and 4th round functions that are compatible with the pair <span class="math">(Z,Y)</span>. Though there exists one suitable pair for each round function on average, there might be no pair or more than one pair that are compatible with the pair <span class="math">(Z,Y)</span>.</p>

    <p class="text-gray-300">This issue already exists even in the classical setting, but it is trivially solved. However, solving the issue in the quantum setting is non-trivial, and deserves careful attention. In what follows, for simplicity, we first describe the attack by assuming that the above issue is naturally solved as in the classical setting, and later explain how to deal with it.</p>

    <h4 id="sec-38" class="text-lg font-semibold mt-6">Quantum procedures and complexity.</h4>

    <p class="text-gray-300">Assume that <span class="math">f(Z,Y)</span> is uniquely determined for each <span class="math">(Z,Y)</span>. Remember that the goal of the quantum distinguisher analysis is to find <span class="math">Z</span> such that <span class="math">\\exists Y,f(Z,Y)\\in L</span>. As discussed in Corollary 1, suppose that a quantum circuit <span class="math">C_{f}</span> that calculates <span class="math">f(Z,Y)</span> for a single choice of <span class="math">(Z,Y)</span> in time <span class="math">T_{f}^{Q}</span> can be implemented by using <span class="math">O(n)</span> qubits and we can use a quantum computer with <span class="math">O(n2^{p})</span> qubits. Then the time complexity to find such <span class="math">Z</span> becomes <span class="math">O(2^{n/4+n/2-p}\\cdot T_{f}^{Q}+2^{n/2})</span>.</p>

    <p class="text-gray-300">We construct <span class="math">C_{f}</span> so that it runs the following steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Find the input/output pair of the 2nd round function <span class="math">F</span> that has input difference <span class="math">X</span> and output difference <span class="math">Z</span>.</li>

      <li>Find the input/output pair of the 3rd round function <span class="math">F</span> that has input difference <span class="math">Z</span> and output difference <span class="math">X\\oplus Y</span>.</li>

      <li>Find the input/output pair of the 4th round function <span class="math">F</span> that has input difference <span class="math">Y</span> and output difference <span class="math">Z</span>.</li>

      <li>Construct a <span class="math">\\delta</span>-set and calculate the corresponding <span class="math">\\Delta</span>-sequence, using the result of Steps 1, 2, and 3.</li>

      <li>Output the <span class="math">\\Delta</span>-sequence obtained in Step 4.</li>

    </ol>

    <p class="text-gray-300">Steps 1,2, and 3 correspond to Problem 6, which was solved using an efficient table look-up in the classical setting. However, in our circuit <span class="math">C_{f}</span>, we use the Grover search to find the input/output pairs, since there is an obstacle that quantum computer cannot perform an efficient table look-up. Because the input and output sizes of <span class="math">F</span> are <span class="math">n/2</span> bits, we can run Steps 1,2, and 3 with Grover’s algorithm in time <span class="math">O(2^{n/4})</span>, using <span class="math">O(n)</span> qubits. The complexities of Steps 4 and 5 are much smaller than that of the application of Grover’s algorithm. Hence the above <span class="math">C_{f}</span> runs in time <span class="math">T_{f}^{Q}=O(2^{n/4})</span>, using <span class="math">O(n)</span> qubits. Note that <span class="math">C_{f}</span> may return an error with a small probability since we use the Grover search as subroutines for a few times. However we can deal with this error, as explained in Sect. 3.</p>

    <p class="text-gray-300">As described in Corollary 1, if <span class="math">O(n2^{p})</span> qubits are available (<span class="math">p\\leq n/2</span>), then we can find <span class="math">Z</span> such that <span class="math">f(Z,Y)\\in L</span> in time <span class="math">O(2^{n/4+n/2-p+n/4}+2^{n/2})=O(2^{n-p})</span>. Complexities are balanced at <span class="math">p=n/2</span>. In summary, we can find a match with time complexity <span class="math">O(2^{n/2})</span>, using <span class="math">O(n2^{n/2})</span> qubits.</p>

    <h5 id="sec-39" class="text-base font-semibold mt-4">Dealing with the issue.</h5>

    <p class="text-gray-300">Next, we explain how to deal with the issue described above. We regard that each element in <span class="math">\\{0,1\\}^{n/2}</span> is a binary representation of an integer <span class="math">i</span> (<span class="math">0\\leq i\\leq 2^{n/2}-1</span>).</p>

    <p class="text-gray-300">As described before, to calculate the value <span class="math">f(Z,Y)</span>, we have to calculate input and output pairs of the 2nd, 3rd, and 4th round functions that are compatible with <span class="math">Z,Y</span> (and <span class="math">X</span>). More concretely, we have to calculate a tuple <span class="math">(\\alpha_{2},\\alpha_{3},\\alpha_{4})</span> that satisfies <span class="math">F(\\alpha_{2})\\oplus F(\\alpha_{2}\\oplus X)=Z</span> (the condition for the 2nd round function), and <span class="math">F(\\alpha_{3})\\oplus F(\\alpha_{3}\\oplus Z)=X\\oplus Y</span> (the condition for the 3rd round function), and <span class="math">F(\\alpha_{4})\\oplus F(\\alpha_{4}\\oplus Y)=Z</span> (the condition for the 4th round function). Without loss of generality, we assume <span class="math">\\alpha_{2}&lt;\\alpha_{2}\\oplus X,\\alpha_{3}&lt;\\alpha_{3}\\oplus Z,\\alpha_{4}&lt;\\alpha_{4}\\oplus Y</span>. Remember that the issue is that there might be no such tuple <span class="math">(\\alpha_{2},\\alpha_{3},\\alpha_{4})</span>, or more than one tuples that are compatible with <span class="math">Z,Y</span>.</p>

    <p class="text-gray-300">If there is no tuple that is compatible with <span class="math">(Z,Y)</span>, we simply put <span class="math">f(Z,Y):=\\perp</span>. The problem is that there might be more than one tuples that are compatible with <span class="math">(Z,Y)</span>. In the classical setting, the number of solutions for a given <span class="math">(Z,Y)</span> can be obtained easily by looking-up a precomputation table. On the other hand, in the quantum setting, we need to iterate Grover’s algorithm multiple times if there are more than one tuples, thus the complexity of this part increases as proportional to the number of tuples.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Now we assume that the following property holds: for arbitrary <span class="math">d\\neq d^{\\prime}\\in\\{0,1\\}^{n/2}\\setminus\\{0^{n/2}\\}</span>, there are at most <span class="math">N_{max}:=\\lceil 3(\\frac{n}{2}-1)/\\log(\\frac{n}{2}-1)\\rceil</span> many bit-strings <span class="math">\\alpha</span> that satisfies <span class="math">F(\\alpha)\\oplus F(\\alpha\\oplus d)=d^{\\prime}</span> and <span class="math">\\alpha&lt;\\alpha\\oplus d</span>. This is a reasonable assumption since, for a random function <span class="math">\\phi:\\{0,1\\}^{u}\\to\\{0,1\\}^{u}</span>, we have $\\Pr[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi^{-1}(d^{\\prime})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 3u/\\log u]\\geq 1-1/2^{u}<span class="math"> (see Lemma 5.1 in <em>[x18]</em>), and </span>F(\\cdot)\\oplus F(\\cdot\\oplus d)<span class="math"> is an almost random function if </span>F<span class="math"> is random (and here we consider that the domain of </span>F(\\cdot)\\oplus F(\\cdot\\oplus d)<span class="math"> is </span>\\{x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x<x\\oplus d\\}<span class="math">, of which cardinality is </span>2^{n/2-1}$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To avoid the problem that there might be more than one tuples, we divide the problem into <span class="math">N_{max}^{3}</span> cases, and associate a triplet <span class="math">(i,j,k)</span> with each case (<span class="math">0\\leq i,j,k\\leq N_{max}-1</span>). We run the quantum distinguish analysis described above for each cases, i.e., run it <span class="math">N_{max}^{3}</span> times. In the case <span class="math">(i,j,k)</span>, we search for <span class="math">\\alpha_{2},\\alpha_{3},\\alpha_{4}</span> from the sets of strings of which most significant <span class="math">\\log N_{max}</span> bits are <span class="math">i,j</span>, and <span class="math">k</span>, respectively. By our assumption described above, there is at most only one tuple <span class="math">(\\alpha_{2},\\alpha_{3},\\alpha_{4})</span> in each case, and the problem does not occur in each case.</p>

    <p class="text-gray-300">Trying all <span class="math">N_{max}^{3}</span> cases increases the time complexity by a factor of <span class="math">N_{max}^{3}</span>. However, we run the Grover search on the restricted domains for each case, and thus the time complexity decreases by a factor of <span class="math">\\sqrt{N_{max}}</span>. Consequently, dealing with the issue increases the time complexity by a factor of <span class="math">N_{max}^{3}/\\sqrt{N_{max}}=N_{max}^{5/2}=O(n^{5/2})</span>.</p>

    <h4 id="sec-40" class="text-lg font-semibold mt-6">Complexity Summary.</h4>

    <p class="text-gray-300">The complexity of the attack is as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The queried-data analysis requires <span class="math">O(2^{n/2})</span> classical queries, <span class="math">O(2^{n/2})</span> computations and <span class="math">O(2^{n/2})</span> classical memory.</li>

      <li>The quantum distinguisher analysis requires <span class="math">O(n2^{n/2})</span> qubits and <span class="math">O(n^{5/2}2^{n/2})</span> offline computations.</li>

    </ul>

    <p class="text-gray-300">In the end, all the complexities are balanced at <span class="math">\\tilde{O}(2^{n/2})</span>, which is significantly smaller than the classical attack by Guo et al. that requires <span class="math">\\tilde{O}(2^{3n/4})</span> queries and offline computations.</p>

    <p class="text-gray-300">This section discusses quantum attacks in the Q2 model. That is, an adversary is allowed to make quantum superposition queries to online oracles. We show that we can recover full keys of an  <span class="math">r</span> -round Feistel construction ( <span class="math">r &amp;gt; 3</span> ) in time  <span class="math">O(n^{3}2^{n(r - 3) / 4})</span> , using  <span class="math">O(n^2)</span>  qubits. Our idea is to combine the trivial key-recovery attack using Grover search with the quantum distinguisher of 3-round Feistel construction by Kuwakado and Morii [KM10], which was later generalized by Kaplan et al. [KLLN16a]. To combine them, we apply the technique by Leander and May [LM17], with a little adjustment. We also show in Sect. 5.2 how to simulate the "half output oracle" given a usual complete encryption oracle, which solves the controversial issue in the quantum distinguisher by Kuwakado and Morii (see Problem 1).</p>

    <p class="text-gray-300">Again, we consider  <span class="math">n</span> -bit Feistel constructions such that each  <span class="math">n/2</span> -bit round key is added before round function  <span class="math">F</span> . We do not consider parallelization for quantum query attacks, since it seems unreasonable to assume that there are many copies of the online oracle and an adversary is allowed to parallelly access to them.</p>

    <p class="text-gray-300">We briefly explain the quantum attack that distinguishes 3-round Feistel constructions from a random permutation  <span class="math">\\pi</span>  [KM10,KLLN16a]. The attack works in the Q2 model, and runs in polynomial time due to Simon's algorithm.</p>

    <p class="text-gray-300">Assume that we are given a quantum oracle that calculates  <span class="math">W(x,y)</span> , the right  <span class="math">n/2</span> -bits of the ciphertext which is encrypted with 3-round Feistel constructions (see Fig. 5.1). Then,  <span class="math">W(x,y) = x \\oplus F(K_1 \\oplus y \\oplus F(K_0 \\oplus x))</span>  holds. Now,</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Fig.4. 3-round Feistel constructions</p>

    <p class="text-gray-300">fix two different bit strings  <span class="math">\\alpha, \\beta \\in \\{0,1\\}^{n/2}</span>  and define  <span class="math">f: \\{0,1\\}^{n/2+1} \\to \\{0,1\\}^{n/2}</span>  by  <span class="math">f(0,x) := W(\\alpha,x) \\oplus \\beta</span>  and  <span class="math">f(1,x) := W(\\beta,x) \\oplus \\alpha</span>  for  <span class="math">x \\in \\{0,1\\}^{n/2}</span> . Then simple calculation shows that  <span class="math">f((b,x) \\oplus (1,F(K_0 \\oplus \\alpha) \\oplus F(K_0 \\oplus \\beta))) = f(b,x)</span>  holds, i.e.,  <span class="math">f</span>  has a period  <span class="math">(1,F(K_0 \\oplus \\alpha) \\oplus F(K_0 \\oplus \\beta))</span> .</p>

    <p class="text-gray-300">On the other hand, if we are given a quantum oracle that calculates the right  <span class="math">n/2</span> -bits of  <span class="math">\\pi(x,y)</span>  instead of  <span class="math">W(x,y)</span> , and construct such a function  <span class="math">f</span> , then  <span class="math">f</span>  does not have such a period with high probability. Thus, roughly speaking, we can distinguish 3-round Feistel constructions from a random permutation  <span class="math">\\pi</span>  with high probability by using Simon's algorithm.</p>

    <p class="text-gray-300">The distinguishing attack described above is interesting, though, there is a controversial issue. As pointed out by Kaplan et al. [KLLN16a], if we are only given the complete encryption oracle (quantum oracle that returns  <span class="math">n</span> -bit output values  <span class="math">(V(x,y), W(x,y))</span>  or  <span class="math">\\pi(x,y)</span> ), then it is not trivial whether the above attack works. In the classical setting, if we are given the complete encryption oracle and want only the right half of outputs, then we can just truncate outputs of the complete oracle. However, in the quantum setting, answers to queries are in quantum superposition states, of which right  <span class="math">n/2</span> -bits and left  <span class="math">n/2</span> -bits are entangled. Since the usual truncation destroys entanglements, it is not trivial how to simulate the oracle that returns exactly the right half of the output, from the complete encryption oracle. However, it is still possible, and below we explain how to simulate truncation of outputs of quantum oracles without destroying quantum entanglements.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let $\\mathcal{O}:\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\right\\rangle\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y\\right\\rangle\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z\\right\\rangle\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w\\right\\rangle\\mapsto\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\right\\rangle\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y\\right\\rangle\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z\\oplus O_{L}(x,y)\\right\\rangle\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w\\oplus O_{R}(x,y)\\right\\rangle<span class="math"> be the complete encryption oracle, where </span>O_{L},O_{R}<span class="math"> denote the left and right </span>n/2<span class="math">-bits of the complete encryption, respectively. Our goal is to simulate oracle </span>\\mathcal{O}_{R}:\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\right\\rangle\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y\\right\\rangle\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w\\right\\rangle\\mapsto\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\right\\rangle\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y\\right\\rangle\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w\\oplus O_{R}(x,y)\\right\\rangle<span class="math">. Instead of simulating </span>\\mathcal{O}_{R}<span class="math"> itself, it suffices to simulate an operator </span>\\mathcal{O}_{R}^{\\prime}:\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\right\\rangle\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y\\right\\rangle\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w\\right\\rangle\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{n/2}\\right\\rangle\\mapsto\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\right\\rangle\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y\\right\\rangle\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w\\oplus O_{R}(x,y)\\right\\rangle\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{n/2}\\right\\rangle<span class="math"> using ancilla qubits. Let </span>\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\right\\rangle:=H^{n/2}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{n/2}\\right\\rangle<span class="math">, where </span>H^{n/2}<span class="math"> is an </span>n/2<span class="math">-bit Hadamard gate. Then </span>\\mathcal{O}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\right\\rangle\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y\\right\\rangle\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\right\\rangle\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w\\right\\rangle=\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\right\\rangle\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y\\right\\rangle\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\right\\rangle\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w\\oplus O_{R}(x,y)\\right\\rangle<span class="math"> holds for any </span>x,y,w\\in\\{0,1\\}^{n/2}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Now, define <span class="math">\\mathcal{O}_{R}^{\\prime}:=(I\\otimes H^{n/2})\\cdot\\mathsf{Swap}\\cdot\\mathcal{O}\\cdot\\mathsf{Swap}\\cdot(I\\otimes H^{n/2})</span>, where <span class="math">\\mathsf{Swap}</span> is an operator that swaps last <span class="math">n</span>-qubits: $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\right\\rangle\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y\\right\\rangle\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z\\right\\rangle\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w\\right\\rangle\\mapsto\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\right\\rangle\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y\\right\\rangle\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w\\right\\rangle\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z\\right\\rangle<span class="math">. Then easy calculations show that </span>\\mathcal{O}_{R}^{\\prime}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\right\\rangle\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y\\right\\rangle\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w\\right\\rangle\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{n/2}\\right\\rangle=\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\right\\rangle\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y\\right\\rangle\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w\\oplus O_{R}(x,y)\\right\\rangle\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{n/2}\\right\\rangle<span class="math"> holds. Hence we can simulate </span>\\mathcal{O}_{R}<span class="math"> given the complete encryption oracle </span>\\mathcal{O}$, using ancilla qubits.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-44" class="text-xl font-semibold mt-8">5.3 Grover Meets Simon Technique and Adjustment for Feistel Constructions</h3>

    <p class="text-gray-300">To combine the quantum distinguisher described above with key recovery using the Grover’s search, we use a technique by Leander and May <em>[x14]</em>. They proposed the technique that combines Grover’s algorithm with Simon’s algorithm, to recover keys of FX constructions.</p>

    <p class="text-gray-300">We want to apply it to Feistel constructions, however, some adjustment is needed since their algorithm is dedicatedly designed to attack FX constructions. In this section, we first describe the original proposition by Leander and May, then describe our adjusted proposition, and finally describe difference between them.</p>

    <h4 id="sec-45" class="text-lg font-semibold mt-6">The original technique.</h4>

    <p class="text-gray-300">The following proposition is the original technique by Leander and May <em>[x14]</em>.</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Proposition 2 (Theorem 2 in <em>[x14]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">\\Psi:\\mathbb{F}_{2}^{m}\\times\\mathbb{F}_{2}^{n}\\to\\mathbb{F}_{2}^{n}</span> be a function such that <span class="math">\\Psi(k,\\cdot):\\mathbb{F}_{2}^{n}\\to\\mathbb{F}_{2}^{n}</span> is a random function for any fixed <span class="math">k\\in\\mathbb{F}_{2}^{n}</span>. Suppose <span class="math">\\Psi</span> is public, and an adversary can calculate it offline. For <span class="math">k_{0}\\in\\{0,1\\}^{m}</span> and <span class="math">k_{1},k_{2}\\in\\{0,1\\}^{n}</span>, let <span class="math">\\Phi_{k_{0},k_{1},k_{2}}:\\mathbb{F}_{2}^{m}\\times\\mathbb{F}_{2}^{3n}\\to\\mathbb{F}_{2}^{n}</span> be the function defined by <span class="math">\\Phi_{k_{0},k_{1},k_{2}}(x)=\\Psi(k_{0},x\\oplus k_{1})\\oplus k_{2}</span>. Then, given quantum oracle accesses to <span class="math">\\Phi_{k_{0},k_{1},k_{2}}(\\cdot)</span>, we can recover <span class="math">(k_{0},k_{1},k_{2})</span> with a constant probability and <span class="math">O((m+n)2^{m/2})</span> queries, using <span class="math">O(m+n^{2})</span> qubits.</p>

    <p class="text-gray-300">Leander and May’s algorithm firstly defines function <span class="math">\\Phi^{\\prime}:\\mathbb{F}_{2}^{m}\\times\\mathbb{F}_{2}^{n}\\to\\mathbb{F}_{2}^{n}</span> by <span class="math">\\Phi^{\\prime}(k,x)=\\Phi_{k_{0},k_{1},k_{2}}(x)\\oplus\\Psi(k,x)</span>. Since <span class="math">\\Phi^{\\prime}(k_{0},x\\oplus k_{1})=\\Psi(k_{0},x\\oplus k_{1})\\oplus k_{2}\\oplus\\Psi(k,x)=\\Phi^{\\prime}(k_{0},x)</span> holds, <span class="math">\\Phi^{\\prime}(k_{0},\\cdot)</span> has a period <span class="math">k_{1}</span>. Roughly speaking, their algorithm searches for the correct key <span class="math">k_{0}</span> with the Grover search, and checks whether or not each candidate key <span class="math">k</span> is correct by checking whether <span class="math">\\Phi^{\\prime}(k,\\cdot)</span> is periodic or not, by running many independent Simon’s algorithm parallelly. The Grover search for an <span class="math">m</span>-bit key <span class="math">k_{0}</span> requires <span class="math">O(m)</span> qubits. <span class="math">O(n)</span> parallel Simon’s algorithm requires <span class="math">O(n^{2})</span> qubits. Thus the above algorithm needs <span class="math">O(m+n^{2})</span> qubits.</p>

    <p class="text-gray-300">Note that the above proposition refers only to <em>query complexity</em>, but not to <em>time complexity</em>. In the above algorithm, <span class="math">O(n^{3})</span> arithmetic are needed to solve linear equations after <span class="math">O(n)</span> queries are made by Simon’s algorithm (see Section 2.2). This is the essential point that makes difference between the query complexity and the time complexity. Taking these <span class="math">O(n^{3})</span> operations into account, the running time of their algorithm is <span class="math">O((m+n^{3})2^{m/2})</span>.</p>

    <h4 id="sec-47" class="text-lg font-semibold mt-6">Adjusted technique.</h4>

    <p class="text-gray-300">Now we describe our adjusted technique, which can be proven in the similar way as the original proposition. In the next section, <span class="math">k_{0}</span> in Proposition 3 will correspond to subkeys of the last <span class="math">(r-3)</span>-rounds <span class="math">K_{3},\\ldots,K_{r-1}</span> of <span class="math">r</span>-round Feistel constructions, and <span class="math">k_{1}</span> will correspond to the hidden period in the quantum distinguishing attack introduced in Section 5.1.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Proposition 3.</h6>

    <p class="text-gray-300">Let <span class="math">\\Psi:\\mathbb{F}_{2}^{m}\\times\\mathbb{F}_{2}^{n}\\to\\mathbb{F}_{2}^{n}</span> be a function such that <span class="math">\\Psi(k,\\cdot):\\mathbb{F}_{2}^{n}\\to\\mathbb{F}_{2}^{n}</span> is a random function for any fixed <span class="math">k\\in\\mathbb{F}_{2}^{n}</span>. Let <span class="math">\\Phi:\\mathbb{F}_{2}^{m}\\times\\mathbb{F}_{2}^{n}\\to\\mathbb{F}_{2}^{n}</span> be a function such that <span class="math">\\Phi(k,\\cdot):\\mathbb{F}_{2}^{n}\\to\\mathbb{F}_{2}^{n}</span> is a random function for any fixed <span class="math">k\\in\\mathbb{F}_{2}^{n}\\setminus\\{k_{0}\\}</span>, and <span class="math">\\Phi(k_{0},x)=\\Psi(k_{0},x\\oplus k_{1})</span>. Then, given quantum oracle accesses to <span class="math">\\Phi(\\cdot,\\cdot)</span> and <span class="math">\\Psi(\\cdot,\\cdot)</span>, we can recover <span class="math">(k_{0},k_{1})</span> with a constant probability and <span class="math">O((m+n^{2})2^{m/2})</span> queries, using <span class="math">O(m+n^{2})</span> qubits.</p>

    <p class="text-gray-300">Again, we search for the correct key <span class="math">k_{0}</span> with the Grover search and check whether or not <span class="math">\\Phi^{\\prime}(k,\\cdot)=\\Phi(k,\\cdot)\\oplus\\Psi(k,\\cdot)</span> is periodic for the candidate key <span class="math">k</span> by running Simon’s algorithm parallelly. Our algorithm is not so much different from the original one, though, we give detailed descriptions of the algorithm in Appendix C, for completeness. Due to the similar reason as for Proposition 2, <em>time complexity</em> of this variant algorithm also becomes at most <span class="math">O((m+n^{3})2^{m/2})</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">The difference between Proposition 2 and Proposition 3. Here we explain how our algorithm (and our problem that it solves) in Proposition 3 differs from the original algorithm (Proposition 2).</p>

    <p class="text-gray-300">In the original problem (Proposition 2), <span class="math">\\Psi</span> is assumed to be a public function (that is, adversary can calculate <span class="math">\\Phi</span> offline), and <span class="math">\\Phi_{k_{0},k_{1},k_{2}}</span> is given as an online oracle. On the other hand, in our problem (Proposition 3), both of two functions <span class="math">\\Phi</span> and <span class="math">\\Psi</span> are given as online oracles, and adversary cannot calculate them offline. In addition, the domain size of <span class="math">\\Phi_{k_{0},k_{1},k_{2}}</span> in the original problem differs from that of <span class="math">\\Phi</span> in our problem. These lead to the difference of query complexities between the original proposition and ours. See Appendix C for details.</p>

    <p class="text-gray-300">In the situation that we want to combine Grover’s and Simon’s algorithm and we are given two keyed quantum oracles, the original proposition cannot be applied and some modification such as Proposition 3 is required.</p>

    <h3 id="sec-49" class="text-xl font-semibold mt-8">5.4 Combining the Quantum Distinguisher with Key Recovery Attacks</h3>

    <p class="text-gray-300">This section explains how to apply Proposition 3 to extend the quantum distinguisher in Section 5.1 to key recovery attacks. We begin with explaining intuition behind our attack.</p>

    <p class="text-gray-300">Consider to guess subkeys for the last <span class="math">(r-3)</span>-rounds <span class="math">K_{3},\\ldots,K_{r-1}</span>, given the quantum encryption oracle of an <span class="math">r</span>-round Feistel construction. Let us suppose the guess is correct. Then we can implement a quantum circuit that calculates the first three rounds of the Feistel construction. On the other hand, if the guess is incorrect, then the corresponding quantum circuit will be the circuit that calculates an almost random function. Hence we can check the correctness of the guess by using the 3-round quantum distinguisher. We guess <span class="math">K_{3},\\ldots,K_{r-1}</span> by using Grover’s algorithm, while we use Simon’s algorithm for the 3-round distinguisher.</p>

    <p class="text-gray-300">Next, we describe details of our attack. Assume that we are given the quantum encryption oracle of an <span class="math">r</span>-round Feistel construction <span class="math">\\mathsf{Enc}^{r}:\\{0,1\\}^{n}\\to\\{0,1\\}^{n}</span>. For <span class="math">k=(K_{3}^{\\prime},\\ldots,K_{r-1}^{\\prime})\\in\\{0,1\\}^{(r-3)n/2}</span>, let <span class="math">D_{k}:\\{0,1\\}^{n}\\to\\{0,1\\}^{n}</span> denote the partial decryption of the last <span class="math">(r-3)</span>-rounds with the key candidate <span class="math">(K_{3}^{\\prime},\\ldots,K_{r-1}^{\\prime})</span>. Define <span class="math">W:\\{0,1\\}^{(r-3)n/2}\\times\\{0,1\\}^{n/2}\\times\\{0,1\\}^{n/2}\\to\\{0,1\\}^{n/2}</span> be the function defined by</p>

    <p class="text-gray-300"><span class="math">W(k,x,y):=\\text{the right half </span>n/2<span class="math">-bits of </span>D_{k}\\circ\\mathsf{Enc}^{r}(x,y)<span class="math">}.</span> (3)</p>

    <p class="text-gray-300">We can implement a quantum circuit of <span class="math">W</span> using the quantum oracle of <span class="math">\\mathsf{Enc}^{r}</span> and the simulating technique we described in Section 5.2. Note that <span class="math">W(k_{0},x,y)=x\\oplus F(K_{1}\\oplus y\\oplus F(K_{0}\\oplus x))</span> holds, where <span class="math">k_{0}=(K_{3},\\ldots,K_{r-1})</span> is the set of correct partial keys of the Feistel construction <span class="math">\\mathsf{Enc}^{r}</span> from the 4-th round to the last round.</p>

    <p class="text-gray-300">Now, fix two different <span class="math">n/2</span>-bit strings <span class="math">\\alpha,\\beta</span>, and define <span class="math">\\Psi,\\Phi:\\{0,1\\}^{(r-3)n/2}\\times\\{0,1\\}^{n/2}\\to\\{0,1\\}^{n/2}</span> by <span class="math">\\Psi(k,x):=W(k,\\alpha,x)\\oplus\\beta</span> and <span class="math">\\Phi(k,x):=W(k,\\beta,x)\\oplus\\alpha</span>. Then <span class="math">\\Psi(k,\\cdot)</span> is an almost random function for each <span class="math">k</span>, and <span class="math">\\Phi(k,\\cdot)</span> is also an almost random function for each <span class="math">k\\neq k_{0}</span>. In addition, <span class="math">\\Phi(k_{0},x)=\\Psi(K_{0},x\\oplus k_{1})</span> holds, where <span class="math">k_{1}=F(\\alpha\\oplus K_{0})\\oplus F(\\beta\\oplus K_{0})</span>, since</p>

    <p class="text-gray-300"><span class="math">\\Phi(k_{0},x)</span> <span class="math">=W(k_{0},\\beta,x)\\oplus\\alpha=\\beta\\oplus F\\left(K_{1}\\oplus x\\oplus F(\\beta\\oplus K_{0})\\right)\\alpha</span> <span class="math">=\\alpha\\oplus F\\left(K_{1}\\oplus x\\oplus F(\\beta\\oplus K_{0})\\oplus F(\\alpha\\oplus K_{0})\\oplus F(\\alpha\\oplus K_{0})\\right)\\oplus\\beta=W(k_{0},\\alpha,x\\oplus k_{1})\\oplus\\beta=\\Psi(k_{0},x\\oplus k_{1}).</span></p>

    <p class="text-gray-300">Thus, by applying Proposition 3, we can recover the round keys <span class="math">K_{3},\\ldots,K_{r-1}</span>. After we obtain <span class="math">K_{3},\\ldots,K_{r-1}</span>, we can construct a quantum circuit that calculates the first 3 rounds of the Feistel construction. Hence, for arbitrary <span class="math">\\alpha,\\beta\\in\\{0,1\\}^{n/2}</span> such that <span class="math">\\alpha\\neq\\beta</span>, we can compute <span class="math">F(\\alpha\\oplus K_{0})\\oplus F(\\beta\\oplus K_{0})</span> in polynomial time by using the 3-round distinguisher. Then we can recover <span class="math">K_{0}</span> in time <span class="math">O(2^{n/4})</span> by using the Grover search. Once <span class="math">K_{0},K_{3},\\ldots,K_{r-1}</span> are recovered, we can easily recover <span class="math">K_{1},K_{2}</span> in time <span class="math">O(2^{n/4})</span> by using the Grover search.</p>

    <h4 id="sec-50" class="text-lg font-semibold mt-6">Complexity.</h4>

    <p class="text-gray-300">Consequently, we can recover <span class="math">K_{0},\\ldots K_{r-1}</span> in time <span class="math">O(n^{3}2^{(r-3)n/4})</span>, using <span class="math">O(n^{2})</span> qubits. In particular, for the case <span class="math">r=6</span>, all the complexities are balanced at <span class="math">\\tilde{O}(2^{n/2})</span>, which is the same as the attack in Section 4:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The attack requires <span class="math">O((m+n^{2})2^{n})</span> queries, <span class="math">O(n^{3}2^{n/2})</span> computations, and <span class="math">O(m+n^{2})</span> qubits. No classical memory is required in this attack.</li>

    </ul>

    <p class="text-gray-300">We do not consider parallelization here, since it seems unreasonable to assume that there exist many copies of the online quantum oracle and adversaries can parallelly access to them.</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>AC18. Carlisle Adams and Jan Camenisch, editors. Selected Areas in Cryptography - SAC 2017 - 24th International Conference, Ottawa, ON, Canada, August 16-18, 2017, Revised Selected Papers, volume 10719 of Lecture Notes in Computer Science. Springer, 2018.</li>

      <li>Amb04. Andris Ambainis. Quantum walk algorithm for element distinctness. In 45th Symposium on Foundations of Computer Science (FOCS 2004), 17-19 October 2004, Rome, Italy, Proceedings, pages 22–31. IEEE Computer Society, 2004.</li>

      <li>BB17. Gustavo Banegas and Daniel J. Bernstein. Low-communication parallel quantum multi-target preimage search. In Adams and Camenisch [AC18], pages 325–335.</li>

      <li>BBG^{+}13. Robert Beals, Stephen Brierley, Oliver Gray, Aram W Harrow, Samuel Kutin, Noah Linden, Dan Shepherd, and Mark Stather. Efficient distributed quantum computing. Proc. R. Soc. A, 469(2153):20120686, 2013.</li>

      <li>BBHT98. Michel Boyer, Gilles Brassard, Peter Høyer, and Alain Tapp. Tight bounds on quantum searching. Fortschritte der Physik, 46(4-5):493–505, 1998.</li>

      <li>Ber09. Daniel J Bernstein. Cost analysis of hash collisions: Will quantum computers make sharcs obsolete? SHARCS’09 Special-purpose Hardware for Attacking Cryptographic Systems, page 105, 2009.</li>

      <li>BHMT02. Gilles Brassard, Peter Høyer, Michele Mosca, and Alain Tapp. Quantum amplitude amplification and estimation. Contemporary Mathematics, 305:53–74, 2002.</li>

      <li>BHT97. Gilles Brassard, Peter Høyer, and Alain Tapp. Quantum cryptanalysis of hash and claw-free functions. SIGACT News, 28(2):14–19, 1997.</li>

      <li>Bon17. Xavier Bonnetain. Quantum key-recovery on full AEZ. In Adams and Camenisch [AC18], pages 394–406.</li>

      <li>DDKS15. Itai Dinur, Orr Dunkelman, Nathan Keller, and Adi Shamir. New attacks on Feistel structures with improved memory complexities. In Rosario Gennaro and Matthew Robshaw, editors, Advances in Cryptology - CRYPTO 2015 - 35th Annual Cryptology Conference, Santa Barbara, CA, USA, August 16-20, 2015, Proceedings, Part I, volume 9215 of Lecture Notes in Computer Science, pages 433–454. Springer, 2015.</li>

      <li>DFJ13. Patrick Derbez, Pierre-Alain Fouque, and Jérémy Jean. Improved key recovery attacks on reduced-round AES in the single-key setting. In Thomas Johansson and Phong Q. Nguyen, editors, Advances in Cryptology - EUROCRYPT 2013, 32nd Annual International Conference on the Theory and Applications of Cryptographic Techniques, Athens, Greece, May 26-30, 2013. Proceedings, volume 7881 of Lecture Notes in Computer Science, pages 371–387. Springer, 2013.</li>

      <li>DP15. Patrick Derbez and Léo Perrin. Meet-in-the-middle attacks and structural analysis of round-reduced PRINCE. In Gregor Leander, editor, Fast Software Encryption - 22nd International Workshop, FSE 2015, Istanbul, Turkey, March 8-11, 2015, Revised Selected Papers, volume 9054 of Lecture Notes in Computer Science, pages 190–216. Springer, 2015.</li>

      <li>DS08. Hüseyin Demirci and Ali Aydin Selçuk. A meet-in-the-middle attack on 8-round AES. In Kaisa Nyberg, editor, Fast Software Encryption, 15th International Workshop, FSE 2008, Lausanne, Switzerland, February 10-13, 2008, Revised Selected Papers, volume 5086 of Lecture Notes in Computer Science, pages 116–126. Springer, 2008.</li>

      <li>DW17. Xiaoyang Dong and Xiaoyun Wang. Quantum key-recovery attack on Feistel structures. IACR Cryptology ePrint Archive, 2017:1199, 2017.</li>

      <li>GJNS14. Jian Guo, Jérémy Jean, Ivica Nikolic, and Yu Sasaki. Meet-in-the-middle attacks on generic Feistel constructions. In Palash Sarkar and Tetsu Iwata, editors, Advances in Cryptology - ASIACRYPT 2014 - 20th International Conference on the Theory and Application of Cryptology and Information Security, Kaoshiung, Taiwan, R.O.C., December 7-11, 2014. Proceedings, Part I, volume 8873 of Lecture Notes in Computer Science, pages 458–477. Springer, 2014.</li>

      <li>GJNS16. Jian Guo, Jérémy Jean, Ivica Nikolic, and Yu Sasaki. Meet-in-the-middle attacks on classes of contracting and expanding Feistel constructions. IACR Trans. Symmetric Cryptol., 2016(2):307–337, 2016.</li>

      <li>GR04. Lov K. Grover and Terry Rudolph. How significant are the known collision and element distinctness quantum algorithms? Quantum Information & Computation, 4(3):201–206, 2004.</li>

      <li>Gro96. Lov K. Grover. A fast quantum mechanical algorithm for database search. In Gary L. Miller, editor, Proceedings of the Twenty-Eighth Annual ACM Symposium on the Theory of Computing, Philadelphia, Pennsylvania, USA, May 22-24, 1996, pages 212–219. ACM, 1996.</li>

      <li>HS18. Akinori Hosoyamada and Yu Sasaki. Cryptanalysis against symmetric-key schemes with online classical queries and offline quantum computations. In Topics in Cryptology - CT-RSA 2018 - The Cryptographers’ Track at the RSA Conference 2018, San Francisco, CA, USA, April 16-20, 2018, Proceedings, pages 198–218, 2018.</li>

      <li>IS12. Takanori Isobe and Kyoji Shibutani. All subkeys recovery attack on block ciphers: Extending meet-in-the-middle approach. In Lars R. Knudsen and Huapeng Wu, editors, Selected Areas in Cryptography, 19th International Conference, SAC 2012, Windsor, ON, Canada, August 15-16, 2012, Revised Selected Papers, volume 7707 of Lecture Notes in Computer Science, pages 202–221. Springer, 2012.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[IS13] Takanori Isobe and Kyoji Shibutani. Generic key recovery attack on Feistel scheme. In Kazue Sako and Palash Sarkar, editors, Advances in Cryptology - ASIACRYPT 2013 - 19th International Conference on the Theory and Application of Cryptology and Information Security, Bengaluru, India, December 1-5, 2013, Proceedings, Part I, volume 8269 of Lecture Notes in Computer Science, pages 464–485. Springer, 2013.</li>

      <li>[Kap14] Marc Kaplan. Quantum attacks against iterated block ciphers. CoRR, abs/1410.1434, 2014.</li>

      <li>[KLLN16a] Marc Kaplan, Gaëtan Leurent, Anthony Leverrier, and María Naya-Plasencia. Breaking symmetric cryptosystems using quantum period finding. In Matthew Robshaw and Jonathan Katz, editors, Advances in Cryptology - CRYPTO 2016 - 36th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 14-18, 2016, Proceedings, Part II, volume 9815 of Lecture Notes in Computer Science, pages 207–237. Springer, 2016.</li>

      <li>[KLLN16b] Marc Kaplan, Gaëtan Leurent, Anthony Leverrier, and María Naya-Plasencia. Quantum differential and linear cryptanalysis. IACR Trans. Symmetric Cryptol., 2016(1):71–94, 2016.</li>

      <li>[KM10] Hidenori Kuwakado and Masakatu Morii. Quantum distinguisher between the 3-round Feistel cipher and the random permutation. In IEEE International Symposium on Information Theory, ISIT 2010, June 13-18, 2010, Austin, Texas, USA, Proceedings, pages 2682–2685. IEEE, 2010.</li>

      <li>[KM12] Hidenori Kuwakado and Masakatu Morii. Security on the quantum-type Even-Mansour cipher. In Proceedings of the International Symposium on Information Theory and its Applications, ISITA 2012, Honolulu, HI, USA, October 28-31, 2012, pages 312–316. IEEE, 2012.</li>

      <li>[Knu02] Lars R. Knudsen. The security of Feistel ciphers with six rounds or less. J. Cryptology, 15(3):207–222, 2002.</li>

      <li>[LM17] Gregor Leander and Alexander May. Grover meets Simon - quantumly attacking the FX-construction. In Tsuyoshi Takagi and Thomas Peyrin, editors, Advances in Cryptology - ASIACRYPT 2017 - 23rd International Conference on the Theory and Applications of Cryptology and Information Security, Hong Kong, China, December 3-7, 2017, Proceedings, Part II, volume 10625 of Lecture Notes in Computer Science, pages 161–178. Springer, 2017.</li>

      <li>[MBTM17] Kerry A. McKay, Larry Bassham, Meltem Snmez Turan, and Nicky Mouha. NISTIR 8114 Report on Lightweight Cryptography. Technical report, U.S. Department of Commerce, National Institute of Standards and Technology, 2017.</li>

      <li>[MS17] Bart Mennink and Alan Szepieniec. XOR of PRPs in a quantum world. In Tanja Lange and Tsuyoshi Takagi, editors, Post-Quantum Cryptography - 8th International Workshop, PQCrypto 2017, Utrecht, The Netherlands, June 26-28, 2017, Proceedings, volume 10346 of Lecture Notes in Computer Science, pages 367–383. Springer, 2017.</li>

      <li>[MU05] Michael Mitzenmacher and Eli Upfal. Probability and Computing: Randomized Algorithms and Probabilistic Analysis. Cambridge University Press, 2005.</li>

      <li>[Sim97] Daniel R. Simon. On the power of quantum computation. SIAM J. Comput., 26(5):1474–1483, 1997.</li>

      <li>[Tan09] Seiichiro Tani. Claw finding algorithms using quantum walk. Theor. Comput. Sci., 410(50):5285–5297, 2009.</li>

      <li>[Zha05] Shengyu Zhang. Promised and distributed quantum search. In Lusheng Wang, editor, Computing and Combinatorics, 11th Annual International Conference, COCOON 2005, Kunming, China, August 16-29, 2005, Proceedings, volume 3595 of Lecture Notes in Computer Science, pages 430–439. Springer, 2005.</li>

    </ul>

    <h2 id="sec-51" class="text-2xl font-bold">Appendix A On Quantum Amplitude Amplification</h2>

    <p class="text-gray-300">This section briefly explains the <em>quantum amplitude amplification</em> technique, which is developed by Brassard, Høyer, Mosca, Tapp <em>[x1]</em> since the later sections in the appendix need it.</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Proposition 4 (Quantum Amplitude Amplification <em>[x1]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{A}</span> be a quantum algorithm on <span class="math">u</span> qubits without any measurement. Let <span class="math">\\mathcal{B}:\\{0,1\\}^{u}\\to\\{0,1\\}</span> be a boolean function. We call an element <span class="math">x\\in\\{0,1\\}^{u}</span> is <em>good</em> if <span class="math">\\mathcal{B}(x)=1</span>, and <em>bad</em> otherwise. Define unitary operators <span class="math">S_{\\mathcal{B}}</span> and <span class="math">S_{0}</span> on <span class="math">u</span>-qubit states by</p>

    <p class="text-gray-300">\\[ S_{\\mathcal{B}}:\\ket{x}\\mapsto\\begin{cases}-\\ket{x}&\\text{if <span class="math">x</span> is good},\\\\ \\ket{x}&\\text{otherwise},\\end{cases} \\] (4)</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300">\\[ S_{0}:\\ket{x}\\mapsto\\begin{cases}-\\ket{x}&\\text{if <span class="math">x=0</span>,}\\\\ \\ket{x}&\\text{otherwise}.\\end{cases} \\] (5)</p>

    <p class="text-gray-300">Let <span class="math">a</span> be the probability that we obtain a good element <span class="math">x</span> when we measure <span class="math">\\mathcal{A}\\ket{0}</span>. Define <span class="math">Q:=-\\mathcal{A}S_{0}\\mathcal{A}^{-1}S_{\\mathcal{B}}</span> and let <span class="math">t&gt;0</span> be an integer. Then, the probability that we obtain a good <span class="math">x</span> when we measure <span class="math">Q^{t}\\mathcal{A}\\ket{0}</span> is equal to <span class="math">\\sin^{2}((2t+1)\\theta_{a})</span>, where <span class="math">\\theta_{a}\\in[0,\\pi/2]</span> is the constant defined by <span class="math">\\sin^{2}\\theta_{a}=a</span> .</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">We need this proposition in the appendix C. Below we call <span class="math">\\mathcal{B}</span> classifier, following the work by Leander and May <em>[x13]</em>. Note that, if there is a <span class="math">O(u)</span>-qubit quantum circuit that calculates <span class="math">\\mathcal{B}</span> in time <span class="math">T_{\\mathcal{B}}</span>, then <span class="math">S_{\\mathcal{B}}</span> can be implemented on a quantum circuit with <span class="math">O(u)</span>-qubits so that it runs in time <span class="math">O(T_{\\mathcal{B}})</span>. In the above proposition, we have to know or estimate the probability <span class="math">a</span> before running algorithms, which may not be possible in some situations. However, actually we can find a good element even if we do not know the probability <span class="math">a</span> in advance.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Proposition 5 (Quantum Amplitude Amplification, without knowing <span class="math">a</span> <em>[x1]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">a</span> be the probability that we obtain a good element <span class="math">x</span> when we measure <span class="math">\\mathcal{A}\\ket{0}</span>. Then, there is a quantum algorithm that runs in time <span class="math">O(\\sqrt{1/a}(T_{\\mathcal{A}}+T_{\\mathcal{B}}))</span> that finds a good element <span class="math">x</span> with constant probability. Here, <span class="math">T_{\\mathcal{A}}</span> and <span class="math">T_{\\mathcal{B}}</span> are the time that is required to run <span class="math">\\mathcal{A}</span> and evaluate <span class="math">\\mathcal{B}</span> on a quantum circuit, respectively.</p>

    <p class="text-gray-300">The algorithm in Proposition 5 is described as the following procedures. First, a sequence of positive integers <span class="math">t_{1},t_{2},\\dots</span> is defined. Second, the algorithm run the following procedure for each <span class="math">i\\geq 1</span>: run the quantum circuit <span class="math">Q^{t_{i}}\\mathcal{A}</span> on the initial state <span class="math">\\ket{0}</span>, and measure the final quantum state. If a good element <span class="math">x</span> is obtained, then the algorithm outputs <span class="math">x</span> as a result, and stops. If the algorithm cannot find such a good element, then it runs forever.</p>

    <p class="text-gray-300">If <span class="math">\\mathcal{A}</span> is an Hadamard gate, quantum amplitude amplification matches the Grover search on <span class="math">\\mathcal{B}</span>, and thus this technique is a generalization of the Grover search. In the similar way as for the Grover search, quantum amplitude amplification can be parallelized. If <span class="math">O(u2^{p})</span> qubits are available, then we regard them as <span class="math">O(2^{p})</span> small quantum processors of size <span class="math">O(u)</span>. By running the algorithm on those small processors, we can find a good element in time <span class="math">O(\\sqrt{1/a2^{p}}(T_{\\mathcal{A}}+T_{\\mathcal{B}}))</span>.</p>

    <h2 id="sec-54" class="text-2xl font-bold">Appendix B Dealing with Small Errors of <span class="math">f</span></h2>

    <p class="text-gray-300">This section shows that Corollary 1 is still valid even if <span class="math">f</span> can be calculated only with some small error. We use the quantum amplitude amplification technique (see Appendix C) instead of the Grover search. Suppose that our goal is to find <span class="math">x</span> such that <span class="math">f(x,y_{0})=g(y_{0})</span> for a fixed <span class="math">y_{0}\\in\\{0,1\\}^{v}</span>. Assume <span class="math">w,\\ell=O(u+v)</span>, and we only have a quantum circuit <span class="math">C^{\\prime}_{f}</span> that calculates <span class="math">f</span> with some error:</p>

    <p class="text-gray-300"><span class="math">C^{\\prime}_{f}:\\ket{x}\\ket{y_{0}}\\ket{0^{w+\\ell}}\\mapsto\\sqrt{1-\\delta^{2}_{x,y_{0}}}\\ket{x}\\ket{y_{0}}\\ket{\\psi_{x,y_{0}}}\\ket{f(x,y_{0})}+\\delta_{x,y_{0}}\\ket{x}\\ket{y_{0}}\\ket{\\texttt{garbage}},</span></p>

    <p class="text-gray-300">for some <span class="math">w</span>-qubit state <span class="math">\\ket{\\psi_{x,y_{0}}}</span>, which contains some necessary intermediate information to calculate <span class="math">f(x,y_{0})</span>, and <span class="math">(w+\\ell)</span>-qubit state <span class="math">\\ket{\\texttt{garbage}}</span>, which corresponds to unnecessary information. Here we assume that <span class="math">f</span> is calculated by using the Grover search that normally contains some small error, and we now assume that <span class="math">\\delta_{x,y_{0}}=O(1/2^{u/2})</span>. Let <span class="math">U_{\\oplus y_{0}}</span> denote the unitary operator <span class="math">\\ket{z}\\mapsto\\ket{z\\oplus y_{0}}</span>. With the notations in Proposition 4, we put <span class="math">\\mathcal{A}:=C^{\\prime}_{f}\\cdot(H^{u}\\otimes U_{\\oplus y_{0}}\\otimes I_{w+\\ell})</span>, which suggests that</p>

    <p class="text-gray-300"><span class="math">\\mathcal{A}\\ket{0^{u+v+w+\\ell}}</span> <span class="math">=C^{\\prime}_{f}\\left(\\sqrt{1/2^{u}}\\sum_{x}\\ket{x}\\ket{y_{0}}\\ket{0^{w+\\ell}}\\right)</span> <span class="math">=\\sqrt{1/2^{u}}\\sum_{x}\\left(\\sqrt{1-\\delta^{2}_{x,y_{0}}}\\ket{x}\\ket{y_{0}}\\ket{\\psi_{x,y_{0}}}\\ket{f(x,y_{0})}+\\delta_{x,y_{0}}\\ket{x}\\ket{y_{0}}\\ket{\\texttt{garbage}}\\right),</span></p>

    <p class="text-gray-300">where <span class="math">H^{u}</span> is the Hadamard operator of dimension on <span class="math">u</span>-qubit states and <span class="math">I_{w+\\ell}</span> is the identity operator on <span class="math">(w+\\ell)</span>-qubit states. Now we run the quantum amplitude amplification with the above <span class="math">\\mathcal{A}</span>, defining that the “good” element corresponds to a state such that the last <span class="math">\\ell</span>-qubits match <span class="math">g(y_{0})</span>. That is, we define <span class="math">\\mathcal{B}:\\{0,1\\}^{u+v+w+\\ell}\\rightarrow\\{0,1\\}</span> by <span class="math">\\mathcal{B}(\\alpha)=1</span> if and only if the last <span class="math">\\ell</span>-bits of <span class="math">\\alpha</span> is <span class="math">g(y_{0})</span>. A quantum circuit of <span class="math">\\mathcal{B}</span> can be implemented using <span class="math">O(u+v)</span>-qubits since we already know <span class="math">(y_{0},g(y_{0}))</span>. Then, the good probability is roughly equals to <span class="math">1/2^{u}</span>, which suggests that we can find <span class="math">x</span> such that <span class="math">f_{y_{0}}(x)=1</span> in time <span class="math">O(2^{u/2})</span>. Thus our algorithm works even if <span class="math">f</span> can be calculated with a small error.</p>

    <h2 id="sec-55" class="text-2xl font-bold">Appendix C Detail Descriptions of the Algorithm in Proposition 3</h2>

    <p class="text-gray-300">Our algorithm in Proposition 2 is not so much different from the original algorithm in Proposition 3 by Leander and May, but here we give details and concrete descriptions of our algorithm in Proposition 3 for completeness.</p>

    <p class="text-gray-300">We use similar notations as in <em>[x14]</em>. The algorithm needs <em>quantum amplitude amplification</em> by Brassard, Høyer, Mosca and Tapp <em>[x2]</em> (see Proposition 4).</p>

    <p class="text-gray-300">The algorithm in Proposition 3 consists of two parts. The first part recovers <span class="math">k_{0}</span>, and the second part recovers <span class="math">k_{1}</span>. Since <span class="math">\\Phi^{\\prime}(k_{0},\\cdot):=\\Phi(k_{0},\\cdot)\\oplus\\Psi(k_{0},\\cdot)</span> is a periodic function with the period <span class="math">k_{1}</span>, the second part is trivial after recovering <span class="math">k_{0}</span> (we can use Simon’s algorithm to recover <span class="math">k_{1}</span>). Hence, in what follows, we explain the quantum algorithm to recover <span class="math">k_{0}</span>.</p>

    <p class="text-gray-300">Roughly speaking, the algorithm is defined as <span class="math">Q^{t}\\mathcal{A}</span> for some suitable quantum algorithm <span class="math">\\mathcal{A}</span>, classifier <span class="math">\\mathcal{B}</span>, and a parameter <span class="math">t</span>. Remember that the oracle <span class="math">\\Phi</span> in our problem is a little different from the oracle <span class="math">\\Phi_{k_{0},k_{1},k_{2}}</span> in the original problem. Due to this difference of oracles, our algorithm is slightly different from the original algorithm in the construction of classifier <span class="math">\\mathcal{B}</span>. In our classifier <span class="math">\\mathcal{B}</span> described below, process branches depending on whether the condition <span class="math">\\Psi(k_{0},m_{i}\\oplus k_{1}^{\\prime})=\\Psi(k_{0},m_{i}\\oplus k_{1}^{\\prime})</span> for any <span class="math">i</span> holds. On the other hand, in the original algorithm by Leander and May, the corresponding branch occurs depending on a different condition. The difference of oracles does not affect algorithm <span class="math">\\mathcal{A}</span>, and it is almost same as the corresponding algorithm in the original one by Leander and May.</p>

    <p class="text-gray-300">Below we give descriptions of <span class="math">\\mathcal{A}</span> and <span class="math">\\mathcal{B}</span>, and then describe the concrete description of the algorithm. Descriptions below basically follow arguments given in <em>[x14]</em>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">#### Quantum algorithm <span class="math">\\mathcal{A}</span> on input $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0\\rangle$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathcal{A}</span> is a quantum algorithm without measurement on <span class="math">m+2n(n+\\sqrt{n})</span> qubits. Let <span class="math">h:\\{0,1\\}^{m}\\times(\\{0,1\\}^{n})^{\\times(n+\\sqrt{n})}\\rightarrow(\\{0,1\\}^{n})^{\\times(n+\\sqrt{n})}</span> be the function defined by</p>

    <p class="text-gray-300"><span class="math">h(k;x_{1},\\ldots,x_{n+\\sqrt{n}})=(\\Phi^{\\prime}(k,x_{1}),\\ldots,\\Phi^{\\prime}(k,x_{n+\\sqrt{n}})),</span> (6)</p>

    <p class="text-gray-300">where <span class="math">\\Phi^{\\prime}(k,x)=\\Phi(k,x)\\oplus\\Psi(k,x)</span>, and</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$U_{h}:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k\\rangle\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{1},\\ldots,x_{n+\\sqrt{n}}\\rangle\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_{1},\\ldots,y_{n+\\sqrt{n}}\\rangle\\mapsto</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k\\rangle\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{1},\\ldots,x_{n+\\sqrt{n}}\\rangle\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_{1}\\oplus\\Phi^{\\prime}(k,x_{1}),\\ldots,y_{n+\\sqrt{n}}\\oplus\\Phi^{\\prime}(k,x_{n+\\sqrt{n}})\\rangle$ (7)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">be the corresponding unitary operator. Then the quantum algorithm <span class="math">\\mathcal{A}</span> on input $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0\\rangle$ is defined as follows:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Apply <span class="math">H^{\\otimes m+n(n+\\sqrt{n})}\\otimes I_{n(n+\\sqrt{n})}</span> on $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0\\rangle$, which produces the quantum state</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\sum_{k,x_{1},\\ldots,x_{n+\\sqrt{n}}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k\\rangle\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{1},\\ldots,x_{n+\\sqrt{n}}\\rangle\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0\\rangle\\,.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Apply <span class="math">U_{h}</span>, which yields the state</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\sum_{k,x_{1},\\ldots,x_{n+\\sqrt{n}}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k\\rangle\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{1},\\ldots,x_{n+\\sqrt{n}}\\rangle\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi^{\\prime}(k,x_{1}),\\ldots,\\Phi^{\\prime}(k,x_{n+\\sqrt{n}})\\rangle$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Apply <span class="math">I_{m}\\otimes H^{\\otimes n(n+\\sqrt{n})}\\otimes I_{n(n+\\sqrt{n})}</span>, which results in the final state</li>

    </ol>

    <p class="text-gray-300">\\[ \\sum_{\\begin{subarray}{c}k,x_{1},\\ldots,x_{n+\\sqrt{n}}\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{1},\\ldots,u_{n+\\sqrt{n}}\\end{subarray}}(-1)^{\\sum_{i}u_{i}\\cdot x_{i}}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k\\rangle\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{1},\\ldots,u_{n+\\sqrt{n}}\\rangle\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi^{\\prime}(k,x_{1}),\\ldots,\\Phi^{\\prime}(k,x_{n+\\sqrt{n}})\\rangle \\]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In particular, <span class="math">\\mathcal{A}</span> is formally defined as <span class="math">\\mathcal{A}:=(I_{m}\\otimes H^{\\otimes n(n+\\sqrt{n})}\\otimes I_{n(n+\\sqrt{n})})\\cdot U_{h}\\cdot(H^{\\otimes m+n(n+\\sqrt{n})}\\otimes I_{n(n+\\sqrt{n})})</span>. <span class="math">\\mathcal{A}</span> makes <span class="math">O(n+\\sqrt{n})</span> quantum queries (in Step 2).</p>

    <h4 id="sec-56" class="text-lg font-semibold mt-6">Classifier <span class="math">\\mathcal{B}</span> (and the operator <span class="math">S_{\\mathcal{B}}</span>).</h4>

    <p class="text-gray-300">Here we define classifier <span class="math">\\mathcal{B}:\\{0,1\\}^{m+n(n+\\sqrt{n})}\\rightarrow\\{0,1\\}</span>. First, at the beginning of the algorithm, take <span class="math">\\lceil\\frac{3m+n(n+\\sqrt{n})}{n}\\rceil</span> random messages <span class="math">\\{m_{i}\\}_{i}</span> such that <span class="math">m_{i}\\neq m_{j}</span> for <span class="math">i\\neq j</span>. Then the value <span class="math">\\mathcal{B}(k,u_{1},\\ldots,u_{n+\\sqrt{n}})</span> is determined by the following procedures:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">dim(Span(u_{1},\\ldots,u_{n+\\sqrt{n}}))\\neq n-1</span>, then</li>

      <li>Return 0</li>

      <li>Else</li>

      <li>Calculate the unique <span class="math">k_{1}^{\\prime}\\in\\{0,1\\}^{n}</span> such that <span class="math">k_{1}^{\\prime}\\perp Span(u_{1},\\ldots,u_{n+\\sqrt{n}})</span>.</li>

      <li>If <span class="math">\\Psi(k,m_{i}\\oplus k_{1}^{\\prime})=\\Psi(k,m_{i}\\oplus k_{1}^{\\prime})</span> hold for all <span class="math">i</span>, then</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Return 1</li>

      <li>Else</li>

      <li>Return 0</li>

      <li>End If</li>

      <li>End If</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The unitary operator, or quantum circuit, of <span class="math">S_{\\mathcal{B}}</span> is constructed so that it runs the above procedure and finally calculate $S_{\\mathcal{B}}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\eta\\right\\rangle=(-1)^{\\mathcal{B}(\\eta)}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\eta\\right\\rangle<span class="math"> for each </span>\\eta<span class="math">. Then it is obvious that </span>S_{\\mathcal{B}}<span class="math"> requires </span>O(m+n(n+\\sqrt{n}))<span class="math"> queries (in Step 5) and some deterministic calculations to solve linear equations, which requires additional time time </span>O(n^{3})<span class="math"> (in Steps 1 and 4). Eventually, </span>\\mathcal{B}<span class="math"> can be evaluated once in time </span>O(m+n^{3})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-57" class="text-base font-medium mt-4">Remark 1</h6>

    <p class="text-gray-300">The classifier in the original algorithm by Leander and May requires no query, since it does not need online queries in the step that corresponds to Step 5 in our algorithm. This difference derives from the difference between the setting of our problem and the original one: <span class="math">\\Psi</span> is given as an online (keyed) oracle in our setting, whereas <span class="math">\\Psi</span> is assumed to be calculated offline in the original setting.</p>

    <h4 id="sec-58" class="text-lg font-semibold mt-6">The Concrete Description of the Algorithm in Proposition 3.</h4>

    <p class="text-gray-300">The concrete description of the algorithm in Proposition 3 (to recover <span class="math">k_{0}</span>) is as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Take <span class="math">\\left\\lceil\\frac{3m+n(n+\\sqrt{n})}{n}\\right\\rceil</span> random messages <span class="math">\\{m_{i}\\}_{i}</span> such that <span class="math">m_{i}\\neq m_{j}</span> for <span class="math">i\\neq j</span>.</li>

      <li>Set <span class="math">t:=\\left\\lceil\\left(\\pi/\\mathrm{Arcsin}(2^{-\\frac{m}{\\eta}})\\right)\\right\\rceil</span></li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. Set $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0\\right\\rangle<span class="math"> as the initial state, run </span>Q^{t}\\mathcal{A}$, and measure the final state.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output the first <span class="math">m</span>-bit of the measurement result in Step 3.</li>

    </ol>

    <p class="text-gray-300">Note that we can easily recover <span class="math">k_{1}</span> once we recover <span class="math">k_{0}</span>, as stated above.</p>

    <p class="text-gray-300">Complexity analysis for our algorithm is almost same as the original one, since there is little difference between our algorithm and the original one. Thus the claim of Proposition 3 holds.</p>`;
---

<BaseLayout title="Quantum Demiric-Selçuk Meet-in-the-Middle Attacks: Applicati... (2017/1229)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2017 &middot; eprint 2017/1229
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
