---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2010/525';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-18';
const TITLE_HTML = 'Torus-based compression by factor 4 and 6';
const AUTHORS_HTML = 'Koray Karabina';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">We extend the torus-based compression technique for cyclotomic subgroups and show how the elements of certain subgroups in characteristic two and three fields can be compressed by a factor of 4 and 6, respectively. Our compression and decompression functions can be computed at a negligible cost. In particular, our techniques lead to very efficient exponentiation algorithms that work with the compressed representations of elements and can be easily incorporated into pairing-based protocols that require exponentiations or products of pairings.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> Cyclotomic subgroups &middot; torus-based compression &middot; exponentiation &middot; pairing-based cryptography</p>
    </section>

    <h2 id="sec-misc-1" class="text-2xl font-bold">Algorithm 4 The FDDE exponentiation algorithm</h2>

    <p class="text-gray-300">Input: C(g) and eOutput:  <span class="math">C(g^e)</span></p>

    <pre><code class="language-text">1: Write e = \\sum_{i=0}^{s-1} b_i 3^i where b_i \\in \\{-1, 0, 1\\} and b_{s-1} = 1
 2: Decompress C(g) to g = g_0 + g_1 \\sigma by using Theorem 5.4
 3: x \\leftarrow g_0, y \\leftarrow g_1
 4: for i from s-2 down to 0 do
        x&#x27; \\leftarrow x^3, \\ y&#x27; \\leftarrow y^3 c_0
        if b_i = 1 then
 6:
           u_0 \\leftarrow (g_0 + g_1)(x&#x27; + y&#x27;), \\ u_1 \\leftarrow g_0 x&#x27;, \\ u_2 \\leftarrow g_1 y&#x27;, \\ u_3 \\leftarrow u_2 c_0
 7:
           x&#x27; \\leftarrow u_1 + u_3, \\ y&#x27; \\leftarrow u_0 - (u_1 + u_2)
 8:
        else if b_i = -1 then
 9:
           u_0 \\leftarrow (g_0 - g_1)(x&#x27; + y&#x27;), \\ u_1 \\leftarrow g_0 x&#x27;, \\ u_2 \\leftarrow -g_1 y&#x27;, \\ u_3 \\leftarrow u_2 c_0
10:
           x&#x27; \\leftarrow u_1 + u_3, \\ y&#x27; \\leftarrow u_0 - (u_1 + u_2)
11:
12:
        x \\leftarrow x&#x27;, \\ y \\leftarrow y&#x27;
13:
14: end for
15: q&#x27; \\leftarrow (x + y\\sigma)
16: Compress (g&#x27;) to \\mathcal{C}(g&#x27;) = (i&#x27;, c&#x27;), by using Theorem 5.4
17: Output (i&#x27;,c&#x27;)
</code></pre>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) Use  <span class="math">\\operatorname{Tr}_{a^6,a}(g)</span>  directly and perform computations in  <span class="math">\\mathbb{F}_q</span>  (Algorithm 3 in [8]).</li>
      <li>(2) First decompress  <span class="math">\\operatorname{Tr}_{q^6,q}(g)</span>  to  <span class="math">\\operatorname{Tr}_{q^6,q^3}(g)</span> . Then use  <span class="math">\\operatorname{Tr}_{q^6,q^3}(g)</span>  directly and perform computations in  <span class="math">\\mathbb{F}_{q^3}</span>  (Algorithm 4 in [8]).</li>
      <li>(3) First decompress  <span class="math">\\operatorname{Tr}_{q^6,q}(g)</span>  to g and perform computations in  <span class="math">\\mathbb{F}_{q^6}</span>  (Algorithm DDE in [8]).</li>
      <li>(4) First decompress  <span class="math">\\operatorname{Tr}_{q^6,q}(g)</span>  to  <span class="math">\\operatorname{Tr}_{q^6,q^2}(g)</span> . Then use  <span class="math">\\operatorname{Tr}_{q^6,q^2}(g)</span>  to construct a copy of  <span class="math">\\mathbb{F}_{q^6}</span>  based on the minimal polynomial of g over  <span class="math">\\mathbb{F}_{q^2}</span> , and perform computations in  <span class="math">\\mathbb{F}_{q^6}</span>  (Algorithm BPV-I in [8]).</li>
      <li>(5) First decompress  <span class="math">\\operatorname{Tr}_{q^6,q}(g)</span>  to  <span class="math">\\operatorname{Tr}_{q^6,q^3}(g)</span> . Then use  <span class="math">\\operatorname{Tr}_{q^6,q^3}(g)</span>  to construct a copy of  <span class="math">\\mathbb{F}_{q^6}</span>  based on the minimal polynomial of g over  <span class="math">\\mathbb{F}_{q^3}</span> , and perform computations in  <span class="math">\\mathbb{F}_{q^6}</span>  (Algorithm BPV-II in [8]).</li>
      <li>(6) Use  <span class="math">\\operatorname{Tr}_{q^6,q}(g)</span>  to construct a copy of  <span class="math">\\mathbb{F}_{q^6}</span>  based on the minimal polynomial of g over  <span class="math">\\mathbb{F}_q</span> , and perform computations in  <span class="math">\\mathbb{F}_{q^6}</span>  (Algorithm BPV-III in [8]).</li>
      <li>(7) First decompress  <span class="math">\\operatorname{Tr}_{q^6,q}(g)</span>  to  <span class="math">\\operatorname{Tr}_{q^6,q^2}(g)</span> . Then use  <span class="math">\\operatorname{Tr}_{q^6,q^2}(g)</span>  directly and perform computations in  <span class="math">\\mathbb{F}_{q^2}</span>  (Algorithm XTR<sub>3</sub> in [15]).</li>
    </ul>

    <p class="text-gray-300">The algorithms based on (1), (4), (6) and (7) are overall faster than the algorithms based on (2), (3) and (5) because of the expensive decompression operations required in the latter algorithms. In particular, it was reported in [8] that XTR<sub>3</sub> in [15] can be further sped up and it is the fastest exponentiation algorithm for general bases. However, if decompression can be precomputed, for example when the base is fixed, then the algorithm based on (3) is the fastest.</p>

    <p class="text-gray-300">Note that by Theorem 7.2, given C(g) for some  <span class="math">g \\in G_{\\ell} \\setminus \\{\\pm 1\\}</span> , one can recover g (and also  <span class="math">\\operatorname{Tr}_{q^6,q}(g)</span> ,  <span class="math">\\operatorname{Tr}_{q^6,q^2}(g)</span>  and  <span class="math">\\operatorname{Tr}_{q^6,q^3}(g)</span> ) at a negligible cost. Hence, it is more advantageous to use C(g) instead of  <span class="math">\\operatorname{Tr}_{q^6,q}(g)</span> . For example, using C(g), we can obtain faster exponentiation algorithms than the trace-based exponentiation algorithms in the case of a general base  <span class="math">\\operatorname{Tr}_{q^6,q}(g)</span> , by simply computing  <span class="math">\\operatorname{Tr}_{q^6,q}(g)</span>  from C(g) and adapting an algorithm based on (3).</p>

    <h3 id="sec-misc-2" class="text-xl font-semibold mt-8">8. A COMPARISON OF EXPONENTIATION ALGORITHMS</h3>

    <p class="text-gray-300">In this section, we estimate the running times of the exponentiation algorithms discussed in Sections 6.2 and 7.2, and compare them with the fastest previously-known exponentiation algorithms. We consider the case of a general base, C(g) or  <span class="math">\\text{Tr}_{q^k,q}(g)</span> , which is the most interesting case because when the base is fixed we may ignore the cost of obtaining one of C(g) and  <span class="math">\\text{Tr}_{q^k,q}(g)</span>  from the other, and hence obtain an equivalent performance in torus-based and trace-based exponentiation algorithms.</p>

    <p class="text-gray-300">We denote by  <span class="math">C_i</span> ,  <span class="math">M_i</span> , and  <span class="math">S_i</span>  the operations of cubing, multiplication, and squaring in  <span class="math">\\mathbb{F}_{q^i}</span>  for i = 1, 2, 3. We assume that  <span class="math">S_2 = 2S_1</span>  for characteristic two,  <span class="math">C_3 = 3C_1</span>  for characteristic three, and also assume, using Karatsuba's technique, that  <span class="math">M_2 = 3M_1</span>  and  <span class="math">M_3 = 6M_1</span> .</p>

    <p class="text-gray-300">Note that the HCTBE and FDDE algorithms can easily be modified to work with window NAF techniques. In particular, we assume that the width-w radix-2 and radix-3 NAF representation of the exponent e are used in for the characteristic-two and the characteristic-three cases, respectively. Note that width-w radix-2 and radix-3 NAF representations of e contain on average  <span class="math">\\log_2 e/(w+1)</span>  and  <span class="math">2\\log_3 e/(2w+1)</span>  nonzero digits, respectively; see for example [18].</p>

    <p class="text-gray-300">The estimated costs of the exponentiation algorithms are presented in Table 1. In our analysis, we ignore the compression/decompression costs and also the precomputation costs required for window NAF methods as they are negligible comparing to the overall cost of algorithms.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Table 1. Comparison of exponentiation</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">algorithms for factor-4 and factor-6</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">compression in the case of a general base.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">The exponent is <span class="math">e</span> .</td>
          </tr>
        </tbody>
      </table>
    </div>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Algorithms</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Main Loop</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Characteristic-two fields</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Algorithm 3 in [7]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(3.19M_1)\\log_2 e</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FDDE</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(4S_1 + \\frac{9}{(w+1)}M_1)\\log_2 e</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">HCTBE</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(4S_1 + \\frac{6}{(w+1)}M_1)\\log_2 e</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Characteristic-three fields</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">XTR <sub>3</sub> in [15]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(3M_1)\\log_2 e</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FDDE</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(6C_1 + \\frac{36}{(2w+1)}M_1)\\log_3 e</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">HCTBE</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(6C_1 + \\frac{24}{(2w+1)}M_1)\\log_3 e</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Assuming that  <span class="math">S_1</span>  and  <span class="math">C_1</span>  are essentially free in characteristic-two and characteristic-three fields, respectively, and setting w = 3, we can estimate the cost of FDDE as  <span class="math">(2.25M_1)\\log_2 e</span> , and the cost of HCTBE as  <span class="math">(1.5M_1)\\log_2 e</span>  in characteristic-two fields. Similarly, the cost of FDDE and HCTBE in characteristic-three fields can be approximated as  <span class="math">(3.24M_1)\\log_2 e</span>  and  <span class="math">(2.16M_1)\\log_2 e</span> , respectively.</p>

    <p class="text-gray-300">Therefore, if we require that the input to an exponentiation algorithm and the output of the algorithm are the compressed representation of g and  <span class="math">g^e</span> , it seems best to compress g to  <span class="math">\\mathcal{C}(g)</span>  by a factor of 4 or 6, and to use the HCTBE algorithms to compute the factor-4 or factor-6 compressed representation  <span class="math">\\mathcal{C}(g^e)</span>  of  <span class="math">g^e</span> . It also seems that the HCTBE algorithms outperform the fastest previously-known exponentiation algorithms in  <span class="math">G_\\ell</span> . The reason is that compression/decompression costs in the HCTBE algorithms are negligible and that each multiplication step in the HCTBE algorithm in characteristic-two requires  <span class="math">6M_1</span>  whereas it would require  <span class="math">9M_1</span>  in a conventional exponentiation algorithm adapting Karatsuba's method. Similarly, each multiplication step in the HCTBE algorithm in characteristic-three requires  <span class="math">12M_1</span>  whereas it would require  <span class="math">18M_1</span>  in a conventional exponentiation algorithm adapting Karatsuba's method (see also Remark 7.3).</p>

    <p class="text-gray-300">To be more concrete, we list the expected running times of the six exponentiation algorithms in a particular setting in Table 2 based on the estimates given in Table 1. For the 128-bit security level, in the characteristic-two case we let  <span class="math">q = 2^{1223}</span>  and  <span class="math">t = 2^{612}</span> . Then  <span class="math">q + 1 + t = 5\\ell</span>  where  <span class="math">\\ell</span>  is a 1221-bit prime. We will ignore the cost  <span class="math">S_1</span> . In the characteristic-three case, we let  <span class="math">q = 3^{509}</span>  and  <span class="math">t = 3^{255}</span> . Then  <span class="math">q + 1 - t = 7\\ell</span>  where  <span class="math">\\ell</span>  is an 804-bit prime. We will ignore the cost  <span class="math">C_1</span> . In both cases, we choose w = 3.</p>

    <p class="text-gray-300">TABLE 2. Comparison of exponentiation algorithms for factor-4 and factor-6 compression in the case of a general base at the 128-bit security level. The exponent is an 1221-bit integer in the characteristic-two case, and an 804-bit integer in the characteristic-three case.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Algorithms</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Main Loop</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">A characteristic-two field</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Algorithm 3 in [7]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">3895M_1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FDDE</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2747M_1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">HCTBE</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">1831M_1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">A characteristic-three field</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">XTR <sub>3</sub> in [15]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2412M_1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FDDE</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2609M_1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">HCTBE</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">1739M_1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <h3 id="sec-misc-3" class="text-xl font-semibold mt-8">9. Concluding remarks</h3>

    <p class="text-gray-300">We showed that by building on torus-based compression techniques, it is possible to compress elements in  <span class="math">G_{\\ell}</span>  by a factor of 4 when  <span class="math">|G_{\\ell}| = \\ell = q + 1 \\pm t</span> ,  <span class="math">q = 2^m</span>  and  <span class="math">t = \\sqrt{2q}</span> ; and by a factor of 6 when  <span class="math">|G_{\\ell}| = \\ell = q + 1 - t</span> ,  <span class="math">q = 3^m</span>  and  <span class="math">t = \\sqrt{3q}</span> . Our methods achieve the best possible compression ratio in  <span class="math">G_{\\ell}</span> , and moreover have the feature that the compression and decompression maps are computable at a negligible cost. We discussed several exponentiation algorithms and, in particular, showed that HCTBE outperforms the fastest exponentiation algorithms in both the characteristic-two and the characteristic-three cases.</p>

    <p class="text-gray-300">We note that the pairing values of bilinear pairings derived from supersingular elliptic curves of embedding degrees 4 and 6 over finite fields of characteristic two and three, and derived from supersingular hyperelliptic curves of embedding degrees 12 over finite fields of characteristic two, lie in  <span class="math">G_{\\ell}</span>  for a suitable choice of parameters. Therefore, our techniques can be easily incorporated into pairing-based protocols that require exponentiations or products of pairings; examples of such protocols include Scott's identity-based key agreement protocol [14] and Waters signature scheme [21].</p>

    <p class="text-gray-300">Our compression method compresses  <span class="math">g \\in G_{\\ell}</span>  to an element  <span class="math">\\mathcal{C}(g)</span>  in  <span class="math">\\mathbb{F}_q</span> . However, given  <span class="math">\\mathcal{C}(g)</span>  and  <span class="math">e \\in \\mathbb{Z}</span> , all the exponentiation algorithms to compute  <span class="math">\\mathcal{C}(g^e)</span>  first decompresses  <span class="math">\\mathcal{C}(g)</span>  (at least partially), and then exponentiate. It is natural to ask if one can devise a multiplication formula for  <span class="math">g, h \\in G_{\\ell}</span>  which computes  <span class="math">\\mathcal{C}(g) * \\mathcal{C}(h) = \\mathcal{C}(gh)</span>  directly in  <span class="math">\\mathbb{F}_q</span> .</p>

    <p class="text-gray-300">The author would like to thank Alfred Menezes for his careful reading of the earlier drafts of this paper and for his corrections and suggestions.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>[1] E. Brier and M. Joye. Weirstra&szlig; elliptic curves and side channel attacks. &acute; Public Key Cryptography PKC 2002, Lecture Notes In Computer Science, 2274:335&ndash;345, 2002.</li>
      <li>[2] A. Brouwer, R. Pellikaan, and E. Verheul. Doing more with fewer bits. Advances in Cryptology ASI-ACRYPT '99, Lecture Notes in Computer Science, 1716:321&ndash;332, 1999.</li>
      <li>[3] K. Giuliani and G. Gong. Analogues to the Gong-Harn and XTR cryptosystems. Technical Report CORR 2003-34, University of Waterloo, 2003. Available at http://www.cacr.math.uwaterloo.ca/techreports/ 2003/corr2003-34.ps.</li>
      <li>[4] G. Gong and L. Harn. Public-key cryptosystems based on cubic finite field extensions. IEEE Transactions on Information Theory, 45:2601&ndash;2605, 1999.</li>
      <li>[5] R. Granger, D. Page, and M. Stam. On small characteristic algebraic tori in pairing-based cryptography. LMS Journal of Computation and Mathematics, 9:64&ndash;85, 2004.</li>
      <li>[6] D. Hankerson, A. Menezes, and S. Vanstone. Guide to elliptic curve cryptography. Springer-Verlag, New York, USA, 2004.</li>
      <li>[7] K. Karabina. Double-exponentiation in factor-4 groups and its applications. Twelfth IMA International Conference on Cryptography and Coding, Lecture Notes in Computer Science, 5921:336&ndash;350, 2009.</li>
      <li>[8] K. Karabina. Factor-4 and 6 compression of cyclotomic subgroups of F &lowast; <sup>2</sup>4<sup>m</sup> and <sup>F</sup> &lowast; <sup>3</sup>6m. Journal of Mathematical Cryptology, 4:1&ndash;42, 2010.</li>
      <li>[9] A. Lenstra and E. Verheul. The XTR public key system. Advances in Cryptology CRYPTO 2000, Lecture Notes in Computer Science, 1880:1&ndash;19, 2000.</li>
      <li>[10] J. L&acute;opez and R. Dahab. Fast multiplication on elliptic curves over GF(2<sup>m</sup>) without precomputation. Cryptographic Hardware and Embedded Systems, Lecture Notes In Computer Science, 1717:316&ndash;327, 1999.</li>
      <li>[11] P. Montgomery. Speeding the Pollard and elliptic curve methods of factorization. Mathematics of Computation, 48:243&ndash;264, 1987.</li>
      <li>[12] K. Rubin and A. Silverberg. Torus-based cryptography. Advances in Cryptology CRYPTO 2003, Lecture Notes in Computer Science, 2729:349&ndash;365, 2003.</li>
      <li>[13] K. Rubin and A. Silverberg. Compression in finite fields and torus-based cryptography. SIAM Journal on Computing, 37:1401&ndash;1428, 2008.</li>
      <li>[14] M. Scott. Authenticated ID-based key exchange and remote log-in with simple token and PIN number. Cryptology ePrint Archive, Report 2002/164, 2002. http://eprint.iacr.org/2002/164.</li>
      <li>[15] M. Shirase, D. Han, Y. Hibin, H. Kim, and T. Takagi. A more compact representation of XTR cryptosystem. IEICE Transactions on Fundamentals of Electronics, Communications and Computer Sciences, E91-A:2843&ndash;2850, 2008.</li>
      <li>[16] P. Smith and C. Skinner. A public-key cryptosystem and a digital signature system based on the Lucas function analogue to discrete logarithms. Advances in Cryptology &ndash; ASIACRYPT '94, Lecture Notes In Computer Science, 917:357&ndash;364, 1994.</li>
      <li>[17] M. Stam and A. Lenstra. Speeding up XTR. Advances in Cryptology ASIACRYPT 2001, Lecture Notes in Computer Science, 2248:125&ndash;143, 2001.</li>
      <li>[18] T. Takagi, S. Yen, and B. Wu. Radix-r non-adjacent form. Information Security ISC 2004, Lecture Notes In Computer Science, 3225:99&ndash;110, 2004.</li>
      <li>[19] M. van Dijk, R. Granger, D. Page, K. Rubin, A. Silverberg, M. Stam, and D. Woodruff. Practical cryptography in high dimensional tori. Advances in Cryptology &ndash; EUROCRYPT 2005, Lecture Notes in Computer Science, 3494:234&ndash;250, 2005.</li>
      <li>[20] M. van Dijk and D. Woodruff. Asymptotically optimal communication for torus-based cryptography. Advances in Cryptology &ndash; CRYPTO 2004, Lecture Notes in Computer Science, 3152:151&ndash;178, 2004.</li>
      <li>[21] B. Waters. Efficient identity-based encryption without random oracles. Advances in Cryptology EURO-CRYPT 2005, Lecture Notes in Computer Science, 3494:114&ndash;127, 2005.</li>
    </ul>

    <p class="text-gray-300">Dept. of Combinatorics and Optimization, University of Waterloo, Waterloo, Ontario, Canada N2L 3G1</p>

    <p class="text-gray-300">E-mail address: kkarabin@uwaterloo.ca</p>

`;
---

<BaseLayout title="Torus-based compression by factor 4 and 6 (2010/525)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2010 &middot; eprint 2010/525
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="2-a-review-of-torus-based-compression-2010" />
  </article>
</BaseLayout>
