---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2010/525';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-18';
const TITLE_HTML = '2. A REVIEW OF TORUS-BASED COMPRESSION';
const AUTHORS_HTML = 'Let q be a prime power and  $\\mathbb{F}_q$  denote the finite field of order q. We denote the trace function  $\\operatorname{Tr}_{\\mathbb{F}_{q^i}/\\mathbb{F}_{q^j}}: \\mathbb{F}_{q^i} \\to \\mathbb{F}_{q^j}$  by  $\\operatorname{Tr}_{q^i,q^j}$ .';

const CONTENT = `    <h3 id="sec-1" class="text-xl font-semibold mt-8">TORUS-BASED COMPRESSION BY FACTOR 4 AND 6</h3>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">KORAY KARABINA</h4>

    <p class="text-gray-300">ABSTRACT. We extend the torus-based compression technique for cyclotomic subgroups and show how the elements of certain subgroups in characteristic two and three fields can be compressed by a factor of 4 and 6, respectively. Our compression and decompression functions can be computed at a negligible cost. In particular, our techniques lead to very efficient exponentiation algorithms that work with the compressed representations of elements and can be easily incorporated into pairing-based protocols that require exponentiations or products of pairings.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1. Introduction</h3>

    <p class="text-gray-300">It has been an attractive objective in cryptography to reduce bandwidth requirements while not forfeiting security and efficiency. For example, Montgomery's [11] scalar multiplication algorithm for a certain class of elliptic curves defined over odd characteristic fields only involves the x-coordinate of the input point P = (x, y). In addition to its advantage of being able to discard the y-coordinate of P, the algorithm can be implemented based on Lucas chains and provides a built-in resistance against certain side-channel attacks. Later on, Montgomery's idea was improved and generalized to any elliptic curve defined over odd characteristic fields and also to elliptic curves defined over binary fields (see for example [1, 10]). Similarly, there have been several proposals to compress the elements of certain subgroups of the multiplicative groups of certain finite fields, and to compute with the compressed representation of elements [16, 4, 2, 9, 3, 12, 20, 19, 15, 8]. The most notable of these proposals is the XTR cryptosystem [9] which compresses the elements of the order- <span class="math">(p^2 - p + 1)</span>  subgroup G of  <span class="math">\\mathbb{F}_{p^6}^*</span>  by a factor of three, and at the same time achieves faster exponentiation in G compared to the previous algorithms that work with the natural representation of elements in  <span class="math">\\mathbb{F}_{p^6}</span> .</p>

    <p class="text-gray-300">The compression methods in the finite field setting fall into two category. They either use a rational parameterization of an algebraic torus [12, 20, 19], or use the trace representation of elements [16, 4, 2, 9, 3, 15, 8]. Even though there is a close relationship between these two methods (see [12]), they have different properties. While the rational parametrization of a torus enjoys the full functionality of the group structure, the trace function is not multiplicative and hence novel techniques are required to adapt fast exponentiation algorithms to work with the trace representation of elements (see for example [17, 7]).</p>

    <p class="text-gray-300">Having briefly mentioned the two different compression approaches in finite fields it is natural to ask the following two questions. First, what is the best possible compression ratio for the elements of a subgroup G of the multiplicative group  <span class="math">\\mathbb{F}^*</span>  of a finite field  <span class="math">\\mathbb{F}</span> , where  <span class="math">\\mathbb{F}</span>  is the minimal field with  <span class="math">G \\subset \\mathbb{F}^*</span> ? One should of course require the corresponding compression and decompression functions to be efficiently computable, and the decompression of an element to be unique or almost unique. Second, how does the tori-compression method compare to the trace-compression method?</p>

    <p class="text-gray-300">The first question was partially answered in [13] for cyclotomic subgroups of finite fields. More precisely, Rubin and Silverberg observed that for a positive integer k and a prime power q</p>

    <p class="text-gray-300">Key words and phrases. Cyclotomic subgroups, torus-based compression, exponentiation, pairing-based cryptography.</p>

    <p class="text-gray-300">there is an algebraic torus  <span class="math">\\mathbb{T}_{q,k}</span> , a  <span class="math">\\varphi(k)</span> -dimensional algebraic variety over  <span class="math">\\mathbb{F}_q</span> , and its group  <span class="math">\\mathbb{T}_{q,k}(\\mathbb{F}_q)</span>  of  <span class="math">\\mathbb{F}_q</span> -rational points is isomorphic to the order- <span class="math">\\Phi_k(q)</span>  (cyclotomic) subgroup of  <span class="math">\\mathbb{F}_q^*</span> . Here,  <span class="math">\\Phi_k(q)</span>  is the kth-cyclotomic polynomial evaluated at q, and  <span class="math">\\varphi</span>  is Euler's totient function. Consequently, one would hope to use only  <span class="math">\\varphi(k)</span>   <span class="math">\\mathbb{F}_q</span> -elements in order to (uniquely) represent elements of  <span class="math">\\mathbb{T}_{q,k}(\\mathbb{F}_q)</span> . For example, when k=4 and k=6, the elements of the order- <span class="math">(q^2+1)</span>  subgroup  <span class="math">G_{q,4}</span>  of  <span class="math">\\mathbb{F}_q^*</span>  and the elements of the order- <span class="math">(q^2-q+1)</span>  subgroup  <span class="math">G_{q,6}</span>  of  <span class="math">\\mathbb{F}_{q^6}^*</span>  can efficiently be compressed and decompressed by a factor 2 and 3, respectively, attaining the best possible compression ratio  <span class="math">k/\\varphi(k)</span>  (see [12, 13]). Recently, it was shown in [15, 8] that it is possible to further compress (and decompress) the elements of certain proper subgroups  <span class="math">G_\\ell</span>  of  <span class="math">G_{q,4}</span>  in characteristic-two fields, and  <span class="math">G_{q,6}</span>  in characteristic-three fields by an additional factor 2, thereby obtaining compression factors 4 and 6, respectively. These seem to be the optimal compression factors as  <span class="math">|G_\\ell| = q \\pm \\sqrt{2q} + 1</span>  and  <span class="math">|G_\\ell| = q \\pm \\sqrt{3q} + 1</span>  in characteristic two and three, respectively, whereby  <span class="math">|G_\\ell| \\approx q</span> . In general, it would be desirable to compress the elements of any order- <span class="math">\\ell</span>  subgroup  <span class="math">G_\\ell \\subsetneq G_{q,k} \\subset \\mathbb{F}_q^*</span>  by a factor  <span class="math">(k \\log q)/\\log \\ell</span>  in any characteristic.</p>

    <p class="text-gray-300">In this paper, we look for answers to these questions. Our arguments suggest that, the torus-compression techniques cannot, in general, be extended to achieve compression factor  <span class="math">(k \\log q)/\\log \\ell</span>  for proper subgroups  <span class="math">G_{\\ell}</span>  of  <span class="math">G_{q,k}</span> . At first glance our arguments might appear to contradict the aforementioned compression factors 4 and 6 achieved in the case of  <span class="math">G_{q\\pm\\sqrt{2q}+1} \\subsetneq G_{q,4}</span>  where q is a power of 2, and  <span class="math">G_{q\\pm\\sqrt{3q}+1} \\subsetneq G_{q,6}</span>  where q is a power of 3. However, we explain why this discrepancy occurs, and how it helps to work in characteristic two and three fields to compress the elements of certain subgroups  <span class="math">G_{\\ell}</span>  by a factor  <span class="math">k \\approx (k \\log q)/\\log \\ell</span> , when  <span class="math">\\ell \\approx q</span> . In particular, we present torus-based compression methods in characteristic two and three fields that achieve factor-4 and 6 compression, respectively. We should emphasize that previously the only method known to compress by a factor-4 and 6 was to use the trace representation of elements [15, 8]. Our new approach gives us the opportunity to compare the two compression methods and, in fact, has the advantage that computing the decompression functions is essentially free. This yields more efficient exponentiation algorithms compared to the trace-based exponentiation algorithms where decompression is quite costly.</p>

    <p class="text-gray-300">The remainder of this paper is organized as follows. In Section 2, we recall some of the results in the literature and set the notation for the paper. In Section 3, we construct our argument to support the difficulty of obtaining the <em>optimal</em> compression factor k for the elements of  <span class="math">G_{\\ell} \\subsetneq G_{q,k} \\subset \\mathbb{F}_{q^k}</span> , where  <span class="math">\\ell \\approx q</span> . We analyze two particular cases in Sections 4 and 5 and show that, in contrast to our pessimistic arguments in Section 3, one can obtain factor-4 and factor-6 compression using torus-based techniques. In Sections 6 and 7 we describe several exponentiation algorithms based on our compression and decompression techniques. In Section 8 we give a comparison of exponentiation algorithms and conclude in Section 9.</p>

    <p class="text-gray-300">Let q be a prime power and  <span class="math">\\mathbb{F}_q</span>  denote the finite field of order q. We denote the trace function  <span class="math">\\operatorname{Tr}_{\\mathbb{F}_{q^i}/\\mathbb{F}_{q^j}}: \\mathbb{F}_{q^i} \\to \\mathbb{F}_{q^j}</span>  by  <span class="math">\\operatorname{Tr}_{q^i,q^j}</span> .</p>

    <p class="text-gray-300">Let  <span class="math">\\ell</span>  be a positive integer such that  <span class="math">\\gcd(\\ell,q) = 1</span> , and let k be the smallest positive integer such that  <span class="math">q^k \\equiv 1 \\pmod{\\ell}</span> . Then the order- <span class="math">\\ell</span>  group  <span class="math">G_\\ell</span>  is a subgroup of the cyclotomic subgroup  <span class="math">G_{q,k} \\subset \\mathbb{F}_{q^k}^*</span> , where  <span class="math">|G_{q,k}| = \\Phi_k(q)</span> .</p>

    <p class="text-gray-300">Rubin and Silverberg proved that  <span class="math">G_{q,k}</span>  is isomorphic to the  <span class="math">\\mathbb{F}_q</span> -rational points of an algebraic torus  <span class="math">\\mathbb{T}_{q,k}</span>  of dimension  <span class="math">\\varphi(k)</span>  over  <span class="math">\\mathbb{F}_q</span> . In particular, for k=2 and k=6 they presented explicit compression and decompression algorithms for the elements of  <span class="math">\\mathbb{T}_{q,k}(\\mathbb{F}_q)</span>  achieving compression factors  <span class="math">2/\\varphi(2)=2</span>  and  <span class="math">3=6/\\varphi(6)</span> . The compression and decompression maps that correspond</p>

    <p class="text-gray-300">to the case k = 2 will be the building blocks in our arguments, so we explicitly state them here for future reference (see [12, 13] for more details).</p>

    <p class="text-gray-300">Let  <span class="math">\\mathbb{F}_{q^2} = \\mathbb{F}_q[\\sigma]/(f(\\sigma))</span> . If q is even, we set  <span class="math">f(\\sigma) = \\sigma^2 + \\sigma + c</span>  with  <span class="math">c \\in \\mathbb{F}_q</span>  and  <span class="math">\\text{Tr}_{q^2,2}(c) = 1</span> . If q is odd, we set  <span class="math">f(\\sigma) = \\sigma^2 - c</span>  where  <span class="math">c \\in \\mathbb{F}_q</span>  is a quadratic non-residue. Then</p>

    <p class="text-gray-300">(2.1)
<span class="math">$\\mathcal{C}: G_{q,2} \\setminus \\{\\pm 1\\} \\to \\mathbb{F}_q</span>$
<span class="math">$g_0 + g_1 \\sigma \\mapsto \\frac{g_0 + 1}{q_1},</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300">(2.2)
<span class="math">$\\mathcal{D}: \\quad \\mathbb{F}_q \\to G_{q,2}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\alpha \\mapsto \\begin{cases} \\frac{\\alpha + \\sigma}{\\alpha + 1 + \\sigma} &amp; \\text{if } q \\text{ is even,} \\\\ \\frac{\\alpha + \\sigma}{\\alpha - \\sigma} &amp; \\text{if } q \\text{ is odd,} \\end{cases}</span>$</p>

    <p class="text-gray-300">define the compression and the decompression maps, respectively [13]. After observing that</p>

    <p class="text-gray-300"><span class="math">$G_{q,2} = \\{g_0 + g_1\\sigma : g_0, g_1 \\in \\mathbb{F}_q \\text{ and } (g_0 + g_1\\sigma)^{q+1} = 1\\}</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\begin{cases} \\{g_0 + g_1\\sigma : g_0, g_1 \\in \\mathbb{F}_q \\text{ and } g_0^2 + cg_1^2 + g_0g_1 = 1 &amp; \\text{if } q \\text{ is even;} \\\\ \\{g_0 + g_1\\sigma : g_0, g_1 \\in \\mathbb{F}_q \\text{ and } g_0^2 - cg_1^2 = 1 &amp; \\text{if } q \\text{ is odd,} \\end{cases}</span>$</p>

    <p class="text-gray-300">one can check that  <span class="math">\\mathcal{C}</span>  and  <span class="math">\\mathcal{D}</span>  are inverses of each other when they are defined, and that</p>

    <p class="text-gray-300">(2.3)
<span class="math">$\\mathcal{D}(\\alpha)\\mathcal{D}(\\beta) = \\mathcal{D}\\left(\\frac{\\alpha\\beta + c}{\\alpha + \\beta + 1}\\right) \\text{ if } q \\text{ is even,}</span>$</p>

    <p class="text-gray-300">(2.4)
<span class="math">$\\mathcal{D}(\\alpha)\\mathcal{D}(\\beta) = \\mathcal{D}\\left(\\frac{\\alpha\\beta + c}{\\alpha + \\beta}\\right) \\text{ if } q \\text{ is odd.}</span>$</p>

    <p class="text-gray-300">We note that formulas (2.3) and (2.4) can be used to perform multiplication and exponentiation in  <span class="math">G_{q,2} \\setminus \\{\\pm 1\\}</span>  when working with the compressed representation of elements in  <span class="math">\\mathbb{F}_q</span> .</p>

    <p class="text-gray-300">In Section 2 we saw that one can at best hope to compress the elements of  <span class="math">G_{q,k} \\subset \\mathbb{F}_{q^k}^*</span>  by a factor  <span class="math">k/\\varphi(k)</span>  which seems to be the optimal compression factor as  <span class="math">|G_{q,k}| \\approx q^{\\varphi(k)}</span> . However, it is also known that for k=4 and k=6, one can compress further by a factor of 2 and obtain compression factor  <span class="math">2k/\\varphi(k)=k</span>  for the elements of certain proper subgroups  <span class="math">G_\\ell</span>  of  <span class="math">G_{q,k}</span>  [15, 8]. In particular, for k=4 we have  <span class="math">q=2^m</span>  and  <span class="math">\\ell=q\\pm\\sqrt{2q}+1</span> , and for k=6 we have  <span class="math">q=3^m</span>  and  <span class="math">\\ell=q\\pm\\sqrt{3q}+1</span> ; in both cases, m is odd. Note that, in both cases,  <span class="math">G_\\ell\\approx q</span>  and so k is the optimal compression factor. In general, it would be desirable to compress the elements of any order- <span class="math">\\ell</span>  subgroup  <span class="math">G_\\ell \\subseteq G_{q,k} \\subseteq \\mathbb{F}_{q^k}^*</span>  by an optimal factor  <span class="math">(k\\log q)/\\log \\ell</span>  in any characteristic.</p>

    <p class="text-gray-300">We first recall some details on how to achieve compression factor k=4 in characteristic-two fields using the trace representation of elements, and explain why this compression technique does not seem to generalize to fields with characteristic different from two.</p>

    <p class="text-gray-300">Let  <span class="math">q = 2^m, t = \\sqrt{2q}</span>  and  <span class="math">\\ell = q \\pm t + 1</span> , where m is odd. We note that  <span class="math">\\Phi_4(q) = q^2 + 1 = (q + t - 1)(q - t + 1)</span>  and  <span class="math">G_\\ell \\subset G_{q,4} \\subset \\mathbb{F}_{q^4}^*</span>  has embedding degree k = 4 with respect to q. In [8], it was shown that if  <span class="math">g \\in G_\\ell</span>  then the minimal polynomial  <span class="math">f_q</span>  of g over  <span class="math">\\mathbb{F}_q</span>  is</p>

    <p class="text-gray-300"><span class="math">$f_g(x) = x^4 - \\operatorname{Tr}_{q^4,q}(g)x^3 + \\operatorname{Tr}_{q^4,q}(g)^t x^2 - \\operatorname{Tr}_{q^4,q}(g)x + 1.</span>$</p>

    <p class="text-gray-300">One readily deduces that g can be uniquely identified up to conjugation over  <span class="math">\\mathbb{F}_q</span>  from  <span class="math">\\operatorname{Tr}_{q^4,q}(g)</span> , thereby achieving factor-4 compression. A natural extension is to try to represent the elements of  <span class="math">G_\\ell</span>  with embedding degree 4 using their traces over  <span class="math">\\mathbb{F}_q</span> , where q is not even. We fix parameters  <span class="math">(q,\\ell)</span>  such that q is a prime power,  <span class="math">\\gcd(q,\\ell)=1</span> ,  <span class="math">q^2+1\\equiv 0\\pmod{\\ell}</span> , and  <span class="math">q^i\\not\\equiv 1\\pmod{\\ell}</span>  for</p>

    <p class="text-gray-300"><span class="math">1 \\leq i &lt; 4</span> . It is shown in [8] that the minimal polynomial  <span class="math">f_g</span>  of  <span class="math">g \\in G_\\ell</span>  over  <span class="math">\\mathbb{F}_q</span>  can be computed as</p>

    <p class="text-gray-300"><span class="math">$f_g(x) = x^4 - \\text{Tr}_{q^4,q}(g)x^3 + (\\text{Tr}_{q^4,q}(g^{q+1}) + 2)x^2 - \\text{Tr}_{q^4,q}(g)x + 1.</span>$</p>

    <p class="text-gray-300">Therefore, two  <span class="math">\\mathbb{F}_q</span> -elements (as opposed to only one) are generally required to identify g uniquely up to its conjugates over  <span class="math">\\mathbb{F}_q</span> , unless one of  <span class="math">\\operatorname{Tr}_{q^4,q}(g)</span>  or  <span class="math">\\operatorname{Tr}_{q^4,q}(g^{q+1})</span>  can be obtained from the other. In fact, one can find parameters  <span class="math">(q,\\ell)</span> , and elements  <span class="math">g_1, g_2 \\in G_\\ell \\subsetneq G_{q,4}</span>  such that  <span class="math">g_1</span>  and  <span class="math">g_2</span>  are not conjugates over  <span class="math">\\mathbb{F}_q</span>  but  <span class="math">\\operatorname{Tr}_{q^4,q}(g_1) = \\operatorname{Tr}_{q^4,q}(g_2)</span> .</p>

    <p class="text-gray-300">Next, we provide some evidence that, in general, compressing the elements of  <span class="math">G_{\\ell} \\subsetneq G_{q,k} \\subseteq \\mathbb{F}_{q^k}^*</span>  by an optimal factor  <span class="math">(k \\log q)/\\log \\ell</span>  might not be possible using tori-like techniques. Again, we consider the case k=4 and  <span class="math">\\ell \\approx q</span> . Note that  <span class="math">(k \\log q)/\\log \\ell \\approx 4</span> . Let  <span class="math">\\mathbb{F}_{q^2} = \\mathbb{F}_q[w]/(g(w))</span>  and  <span class="math">\\mathbb{F}_{q^4} = \\mathbb{F}_{q^2}[\\sigma]/(f(\\sigma))</span>  for some suitable f and g. Let  <span class="math">g=g_0+g_1\\sigma\\in G_\\ell</span>  and recall from Section 2 that if  <span class="math">g\\neq \\pm 1</span>  then it can be uniquely identified with an element  <span class="math">\\alpha\\in \\mathbb{F}_{q^2}</span>  if  <span class="math">f(\\sigma)</span>  is of the form  <span class="math">\\sigma^2-c</span>  or  <span class="math">\\sigma^2+\\sigma+c</span> ; see (2.1) and (2.2). More precisely, if  <span class="math">g=g_0+g_1\\sigma</span>  then  <span class="math">\\alpha=(g_0+1)/g_1</span>  and  <span class="math">g=\\mathcal{D}(\\alpha)</span> , where  <span class="math">\\mathcal{D}(\\alpha)=(\\alpha+\\sigma)/(\\alpha-\\sigma)</span>  if q is even, and  <span class="math">\\mathcal{D}(\\alpha)=(\\alpha+\\sigma)/(\\alpha+1+\\sigma)</span>  if q is odd. Let  <span class="math">\\alpha=a+bw</span>  for some  <span class="math">a,b\\in \\mathbb{F}_q</span> . Note that the compression of g into (a,b) does not utilize the fact that g lies in a proper subgroup  <span class="math">G_\\ell</span>  of  <span class="math">G_{q,4}</span> . Therefore, one might try to compress g further into g0 (or g2), by using the relation g2 1 to obtain an expression for one of g3 and g4 in terms of the other. For example, the most naive way would be to use the relation  <span class="math">g^\\ell=1</span>  and obtain a polynomial g2, g3 such that g3 such that g4 and g5 are g6. Then we would hope to find g6 among the roots of g6, g7. Since we also want the corresponding decompression function to be efficiently computable and g6 and g7.</p>

    <p class="text-gray-300"><strong>Question:</strong> What is the minimum expected degree and sparsity of a polynomial  <span class="math">P(x,y) \\in \\overline{\\mathbb{F}}_q[x,y]</span>  such that (i) for (almost) all  <span class="math">b \\in \\mathbb{F}_q</span>  there exists an (almost) unique solution  <span class="math">a \\in \\mathbb{F}_q</span>  to P(x,b)=0; and (ii) for  <span class="math">\\alpha=a+bw</span>  we have  <span class="math">\\mathcal{D}(\\alpha)\\in G_\\ell</span> .</p>

    <p class="text-gray-300">Remark 3.1. Given  <span class="math">\\binom{n+m}{n}</span>  pairs  <span class="math">(X_i, z_i) \\in \\mathbb{F}_q^m \\times \\mathbb{F}_q</span> , an nth degree polynomial P in m variables can be constructed such that  <span class="math">P(X_i) = z_i</span> . Note that  <span class="math">\\binom{n+m}{n}</span>  is the number of ways of choosing n elements from a set of m+1 elements with repetitions allowed, which is therefore the maximum number of monomials in P. Hence, when m=2 we would expect  <span class="math">\\deg(P(x,y)) \\leq \\sqrt{\\ell} \\approx \\sqrt{q}</span> . We would even expect, in general, that  <span class="math">\\deg(P(x,y)) \\approx \\sqrt{q}</span>  unless the relation  <span class="math">g^{\\ell} = 1</span>  can be manipulated towards obtaining a polynomial P(x,y) of a rather special form. This shows that tori-like techniques described above will likely fail to produce efficient compression and decompression functions.</p>

    <h2 id="sec-4" class="text-2xl font-bold">4. Factor-4 compression in Characteristic two</h2>

    <p class="text-gray-300">Let
<span class="math">$q = 2^m</span>$
,  <span class="math">m</span>  odd,  <span class="math">t = \\sqrt{2q}</span> ,  <span class="math">\\ell = q + 1 - t</span>  and  <span class="math">\\bar{\\ell} = q + 1 + t</span> . Then
<span class="math">$q^4 - 1 = (q^2 - 1)(q^2 + 1)</span>$
<span class="math">$= (q^2 - 1)(q + 1 - t)(q + 1 + t).</span>$</p>

    <p class="text-gray-300">Let  <span class="math">G_{\\ell} \\subset G_{q,4} \\subset \\mathbb{F}_{q^4}^*</span>  and  <span class="math">G_{\\bar{\\ell}} \\subset G_{q,4} \\subset \\mathbb{F}_{q^4}^*</span>  be subgroups such that  <span class="math">|G_{q,4}| = q^2 + 1</span> ,  <span class="math">|G_{\\ell}| = \\ell</span>  and  <span class="math">|G_{\\bar{\\ell}}| = \\bar{\\ell}</span> . In this section, we set  <span class="math">\\mathbb{F}_{q^2} = \\mathbb{F}_q[w]/(w^2 + w + c_0)</span>  and  <span class="math">\\mathbb{F}_{q^4} = \\mathbb{F}_{q^2}[\\sigma]/(\\sigma^2 + \\sigma + c_1)</span> . We must have  <span class="math">\\operatorname{Tr}_{q,2}(c_0) = \\operatorname{Tr}_{q^2,2}(c_1) = 1</span> .</p>

    <p class="text-gray-300"><strong>Lemma 4.1.</strong> Let  <span class="math">\\mathbb{F}_{q^2} = \\mathbb{F}_q[w]/(w^2 + w + c_0)</span>  and  <span class="math">\\mathbb{F}_{q^4} = \\mathbb{F}_{q^2}[\\sigma]/(\\sigma^2 + \\sigma + c_1)</span>  with  <span class="math">\\operatorname{Tr}_{q,2}(c_0) = \\operatorname{Tr}_{g^2,2}(c_1) = 1</span> . Then</p>

    <p class="text-gray-300">(4.1)
<span class="math">$\\sigma^q + \\sigma = \\sum_{i=0}^{m-1} c_1^{2^i} = u_0 + u_1 w,</span>$</p>

    <p class="text-gray-300">(4.2)
<span class="math">$\\sigma^t + \\sigma = \\sum_{i=0}^{(m-1)/2} c_1^{2^i} = u_2 + u_3 w,</span>$</p>

    <p class="text-gray-300"><span class="math">$(4.3) w^q + w = 1,</span>$</p>

    <p class="text-gray-300">(4.4)
<span class="math">$w^t + w = \\sum_{i=0}^{(m-1)/2} c_0^{2^i} = u_4,</span>$</p>

    <p class="text-gray-300">for some  <span class="math">u_i \\in \\mathbb{F}_q</span> . In particular,  <span class="math">u_1 = 1</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> The equalities can be proven by repeatedly squaring the equations  <span class="math">\\sigma^2 + \\sigma = c_1</span>  and  <span class="math">w^2 + w = c_0</span> . We have  <span class="math">u_1 = 1</span>  since</p>

    <p class="text-gray-300"><span class="math">$1 = \\operatorname{Tr}_{\\sigma^2, 2}(c_1) = (\\sigma + \\sigma^q) + (\\sigma + \\sigma^q)^q = u_1(w + w^q) = u_1.</span>$</p>

    <p class="text-gray-300">We furthermore assume throughout this section that  <span class="math">\\sigma^2 + \\sigma = c_1 = u_5 + u_6 w</span> , where  <span class="math">u_5, u_6 \\in \\mathbb{F}_q</span> .</p>

    <p class="text-gray-300">Let  <span class="math">g = g_0 + g_1 \\sigma \\in G_{q,4}</span> . We already know from Section 2 that if  <span class="math">g \\neq 1</span>  then g can be compressed to an element  <span class="math">\\alpha = (g_0 + 1)/g_1 \\in \\mathbb{F}_{q^2}</span> , and that a compressed element  <span class="math">\\alpha \\in \\mathbb{F}_{q^2}</span>  can be decompressed to obtain  <span class="math">g = (\\alpha + \\sigma)/(\\alpha + 1 + \\sigma) \\in G_{q,4} \\setminus \\{1\\}</span> . Our objective is to show that  <span class="math">g \\in \\{G_\\ell, G_{\\bar{\\ell}}\\} \\setminus \\{1\\}</span>  can further be compressed to  <span class="math">b \\in \\mathbb{F}_q</span> , and that a compressed  <span class="math">b \\in \\mathbb{F}_q</span>  can be decompressed to obtain  <span class="math">g \\in \\{G_\\ell, G_{\\bar{\\ell}}\\} \\setminus \\{1\\}</span> . The following theorem plays a key role.</p>

    <p class="text-gray-300"><strong>Theorem 4.2.</strong> Let  <span class="math">g = (\\alpha + \\sigma)/(\\alpha + 1 + \\sigma) \\in G_{q,4} \\setminus \\{1\\}</span>  where  <span class="math">\\alpha = a + bw \\in \\mathbb{F}_{q^2}</span>  for some  <span class="math">a, b \\in \\mathbb{F}_q</span> . If  <span class="math">g \\in G_\\ell</span>  then a is a root of the polynomial</p>

    <p class="text-gray-300"><span class="math">$P_1(x,b) = x^t + x + b^{t+1} + (u_0 + u_4)b^t + (u_0 + u_3 + 1)b + (u_0u_3 + u_2 + u_6),</span>$</p>

    <p class="text-gray-300">where the  <span class="math">u_i</span> 's are as specified in Lemma 4.1. If  <span class="math">q \\in G_{\\bar{\\ell}}</span>  then a is a root of the polynomial</p>

    <p class="text-gray-300"><span class="math">$P_1(x,b) = x^t + x + b^{t+1} + (u_0 + u_4)b^t + (u_0 + u_3 + 1)b + (u_0u_3 + u_2 + u_6 + 1).</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">g = (\\alpha + \\sigma)/(\\alpha + 1 + \\sigma) \\in G_{\\ell} \\setminus \\{1\\}</span> . After expanding and simplifying  <span class="math">g^{q+1-t} = 1</span> , we find that  <span class="math">\\alpha + \\sigma</span>  is a root of</p>

    <p class="text-gray-300"><span class="math">$P(x) = x^{q+t} + x^{q+1} + x^{t+1} + x^t.</span>$</p>

    <p class="text-gray-300">Now, writing  <span class="math">\\alpha = a + bw</span>  for some  <span class="math">a, b \\in \\mathbb{F}_a</span>  and simplifying  <span class="math">P(\\alpha + \\sigma) = 0</span>  gives us</p>

    <p class="text-gray-300"><span class="math">$P(\\alpha) = a^{2} + ab + (\\sigma^{q} + \\sigma)a + (w^{2} + w)b^{2} + ba^{t} + w^{t}b^{t+1}</span>$</p>

    <p class="text-gray-300"><span class="math">$+(w(\\sigma^{q} + \\sigma) + \\sigma^{t} + \\sigma)b + (\\sigma^{q} + \\sigma + 1)a^{t}</span>$</p>

    <p class="text-gray-300"><span class="math">$+(w^{t}(\\sigma^{q} + \\sigma + 1))b^{t} + (\\sigma^{q}(\\sigma^{t} + \\sigma) + \\sigma^{t}(\\sigma + 1))</span>$</p>

    <p class="text-gray-300"><span class="math">$= a^{2} + ab + (u_{0} + w)a + c_{0}b^{2} + ba^{t} + (u_{4} + w)b^{t+1}</span>$</p>

    <p class="text-gray-300"><span class="math">$+((u_{0} + u_{3} + 1)w + (c_{0} + u_{2}))b + (u_{0} + 1 + w)a^{t}</span>$</p>

    <p class="text-gray-300"><span class="math">$+((u_{0} + u_{4})w + (c_{0} + u_{0}u_{4} + u_{4}))b^{t} + (u_{0}u_{3} + u_{2} + u_{6})w</span>$</p>

    <p class="text-gray-300"><span class="math">$+(c_{0}u_{3} + u_{0}u_{2} + u_{2} + u_{5})</span>$</p>

    <p class="text-gray-300"><span class="math">$= P_{0}(a, b) + P_{1}(a, b)w = 0,</span>$</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">$P_{0}(a,b) = a^{t}b + (u_{0} + 1)a^{t} + a^{2} + ab + u_{0}a + u_{4}b^{t+1}</span>$</p>

    <p class="text-gray-300"><span class="math">$+ (c_{0} + u_{0}u_{4} + u_{4})b^{t} + c_{0}b^{2} + (c_{0} + u_{2})b</span>$</p>

    <p class="text-gray-300"><span class="math">$+ (c_{0}u_{3} + u_{0}u_{2} + u_{2} + u_{5}),</span>$</p>

    <p class="text-gray-300"><span class="math">$P_{1}(a,b) = a^{t} + a + b^{t+1} + (u_{0} + u_{4})b^{t} + (u_{0} + u_{3} + 1)b</span>$</p>

    <p class="text-gray-300"><span class="math">$+ (u_{0}u_{3} + u_{2} + u_{6}).</span>$</p>

    <p class="text-gray-300">Hence, if  <span class="math">g = \\frac{\\alpha + \\sigma}{\\alpha + 1 + \\sigma} \\in G_{\\ell}</span>  for some  <span class="math">\\alpha = a + bw \\in \\mathbb{F}_{q^2}</span>  with  <span class="math">a, b \\in \\mathbb{F}_q</span> , we must have  <span class="math">P_0(a, b) = P_1(a, b) = 0</span> . In particular, a must be a root of the polynomial</p>

    <p class="text-gray-300"><span class="math">$P_1(x) = P_1(x, b) = x^t + x + b^{t+1} + (u_0 + u_4)b^t + (u_0 + u_3 + 1)b + (u_0u_3 + u_2 + u_6).</span>$</p>

    <p class="text-gray-300">The case when  <span class="math">g \\in G_{\\bar{\\ell}} \\setminus \\{1\\}</span>  can be proved similarly.</p>

    <p class="text-gray-300"><strong>Lemma 4.3.</strong> Let  <span class="math">P_1(x) = x^t + x + u \\in \\mathbb{F}_q[x]</span> . Then  <span class="math">P_1(x) = 0</span>  has a solution in  <span class="math">\\mathbb{F}_q</span>  if and only if  <span class="math">\\operatorname{Tr}_{q,2}(u) = 0</span> . If  <span class="math">\\operatorname{Tr}_{q,2}(u) = 0</span>  then  <span class="math">P_1(x) = 0</span>  has exactly two solutions  <span class="math">a_0, a_1</span>  in  <span class="math">\\mathbb{F}_q</span> , and  <span class="math">a_1 = a_0 + 1</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> We first prove that  <span class="math">P_1(x) = 0</span>  has a solution in  <span class="math">\\mathbb{F}_q</span>  if and only if  <span class="math">\\operatorname{Tr}_{q,2}(u) = 0</span> . Suppose that  <span class="math">P_1(x) = x^t + x + u = 0</span>  has a solution, say  <span class="math">a \\in \\mathbb{F}_q</span> . Then</p>

    <p class="text-gray-300">(4.5)
<span class="math">$\\operatorname{Tr}_{q,2}(u) = \\operatorname{Tr}_{q,2}(a^t + a) = \\operatorname{Tr}_{q,2}(a)^t + \\operatorname{Tr}_{q,2}(a) = 0.</span>$</p>

    <p class="text-gray-300">Now, define a half-trace function  <span class="math">H: \\mathbb{F}_q \\to \\mathbb{F}_q</span>  as follows&lt;sup&gt;1&lt;/sup&gt;</p>

    <p class="text-gray-300">(4.6)
<span class="math">$H(u) = \\sum_{i=0}^{(m-1)/2} u^{2^i}.</span>$</p>

    <p class="text-gray-300">Then  <span class="math">H(u)^t + H(u) = u + \\operatorname{Tr}_{q,2}(u)</span> , and so  <span class="math">H(u) \\in \\mathbb{F}_q</span>  is a solution to  <span class="math">P_1(x) = 0</span>  when  <span class="math">\\operatorname{Tr}_{q,2}(u) = 0</span> .</p>

    <p class="text-gray-300">Next we prove that if  <span class="math">\\operatorname{Tr}_{q,2}(u)=0</span>  then  <span class="math">P_1(x)=0</span>  has exactly two solutions, namely H(u) and H(u)+1. We first consider the case m=4i+3. Note that  <span class="math">q=2^m</span>  and  <span class="math">t=\\sqrt{2q}=2^{2i+2}</span> . Let us fix a normal basis to represent  <span class="math">\\mathbb{F}_q</span>  as an m-dimensional vector space over  <span class="math">\\mathbb{F}_2</span> . In this representation, we may set</p>

    <p class="text-gray-300"><span class="math">$x = (x_0, x_1, \\dots, x_{2i}, x_{2i+1}, x_{2i+2}, x_{2i+3}, \\dots, x_{4i+1}, x_{4i+2}),</span>$</p>

    <p class="text-gray-300"><span class="math">$x^t = (x_{2i+1}, x_{2i+2}, \\dots, x_{4i+1}, x_{4i+2}, x_0, x_1, \\dots, x_{2i-1}, x_{2i}),</span>$</p>

    <p class="text-gray-300"><span class="math">$u = (u_0, u_1, \\dots, u_{2i}, u_{2i+1}, u_{2i+2}, u_{2i+3}, \\dots, u_{4i+1}, u_{4i+2}).</span>$</p>

    <p class="text-gray-300">Then  <span class="math">P_1(x) = 0</span>  has a solution if and only if the linear system of equations determined by</p>

    <p class="text-gray-300"><span class="math">$(4.7) x_j + x_{2i+2+j} = u_{2i+2+j}, \\ 0 \\le j \\le 2i,</span>$</p>

    <p class="text-gray-300"><span class="math">$(4.8) x_{2i+1+j} + x_j = u_j, \\ 1 \\le j \\le 2i+1,</span>$</p>

    <p class="text-gray-300"><span class="math">$(4.9) x_{2i+2} + x_0 = u_0</span>$</p>

    <p class="text-gray-300">has a solution  <span class="math">X = (x_0, x_1, \\dots, x_{4i+2}) \\in \\mathbb{F}_2^m</span> . We can see from (4.7) and (4.8) that a choice of  <span class="math">x_0 \\in \\{0, 1\\}</span>  fixes  <span class="math">x_j</span>  for all  <span class="math">1 \\le j \\le 4i + 2</span> , and hence fixes two vectors  <span class="math">X_0</span>  and  <span class="math">X_1</span>  in  <span class="math">\\mathbb{F}_2^m</span> . Now, it follows from (4.9) that  <span class="math">P_1(x) = 0</span>  has a solution if and only if  <span class="math">x_0 + x_{2i+1} = u_0</span> . Therefore,  <span class="math">P_1(x) = 0</span>  has at most two solutions in  <span class="math">\\mathbb{F}_q</span> . In particular, when  <span class="math">P_1(x) = 0</span>  has a solution  <span class="math">a_0</span>  then there are exactly two solutions and the other solution is  <span class="math">a_1 = a_0 + 1</span>  since</p>

    <p class="text-gray-300"><span class="math">$P_1(a_0+1) = (a_0+1)^t + (a_0+1) + u = a_0^t + a_0 + u = 0.</span>$</p>

    <p class="text-gray-300">The case m = 4i + 1 can be similarly proven.</p>

    <p class="text-gray-300">Now, we are ready to describe our compression/decompression maps that achieve factor- <span class="math">(4 \\log q/(1 + \\log q))</span>  compression.</p>

    <p class="text-gray-300"><strong>Theorem 4.4.</strong> For some fixed representation of  <span class="math">\\mathbb{F}_q</span>  as an m-dimensional vector space over  <span class="math">\\mathbb{F}_2</span> , let j be a coordinate position such that the vector representations of  <span class="math">\\beta</span>  and  <span class="math">\\beta + 1</span>  differ in the jth coordinate position for all  <span class="math">\\beta \\in \\mathbb{F}_q</span> . Let  <span class="math">G \\in \\{G_\\ell, G_{\\overline{\\ell}}\\}</span> . Define a compression map</p>

    <p class="text-gray-300">(4.10)
<span class="math">$\\mathcal{C}: G \\setminus \\{1\\} \\rightarrow \\{0, 1\\} \\times \\mathbb{F}_q</span>$
<span class="math">$q \\mapsto (i, b),</span>$</p>

    <p class="text-gray-300">&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;1&lt;/sup&gt;The definition is similar to the one in [6, Section 3.6.2]</p>

    <p class="text-gray-300">where  <span class="math">g = g_0 + g_1\\sigma</span> ,  <span class="math">(g_0 + 1)/g_1 = a + bw</span> , and i is the jth bit in the vector representation of a. And define a decompression map</p>

    <p class="text-gray-300"><span class="math">$(4.11) \\mathcal{D}: \\{0,1\\} \\times \\mathbb{F}_q \\to G \\setminus \\{1\\}</span>$</p>

    <p class="text-gray-300"><span class="math">$(i,b) \\mapsto (\\alpha + \\sigma)/(\\alpha + 1 + \\sigma),</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\alpha = a + bw</span> , and a is one of the two roots of  <span class="math">P_1(x,b)</span>  (see Theorem 4.2) whose jth bit when represented as a vector over  <span class="math">\\mathbb{F}_2</span>  is equal to i. Then  <span class="math">\\mathcal{C}</span>  and  <span class="math">\\mathcal{D}</span>  are inverses of each other when they are defined. Moreover, if  <span class="math">\\mathcal{D}(0,b) \\in G</span>  then  <span class="math">\\mathcal{D}(1,b) \\in G</span>  and  <span class="math">\\mathcal{D}(0,b)\\mathcal{D}(1,b) = 1</span> .</p>

    <p class="text-gray-300">Proof. It follows from Theorem 4.2 and Lemma 4.3 that  <span class="math">\\mathcal{C}</span>  and  <span class="math">\\mathcal{D}</span>  are inverses of each other when they are defined. Now, by Lemma 4.3,  <span class="math">P_1(x,b)</span>  has exactly 2 solutions  <span class="math">a_0</span>  and  <span class="math">a_1</span>  in  <span class="math">\\mathbb{F}_q</span> , and  <span class="math">a_1 = a_0 + 1</span> . Note that since  <span class="math">g = \\frac{\\alpha + \\sigma}{\\alpha + 1 + \\sigma} \\in G</span>  with  <span class="math">\\alpha = a + bw</span>  corresponding to  <span class="math">(a_0, b)</span> , the element  <span class="math">h = \\frac{\\alpha + 1 + \\sigma}{\\alpha + \\sigma}</span>  corresponds to  <span class="math">(a_1, b)</span>  and is in fact the multiplicative inverse of g. It follows that  <span class="math">\\mathcal{D}(0, b)\\mathcal{D}(1, b) = 1</span> .</p>

    <p class="text-gray-300"><strong>Remark 4.5.</strong> The polynomials  <span class="math">P_0(x, y)</span>  and  <span class="math">P_1(x, y)</span>  are both of degree  <span class="math">(t+1) \\approx \\sqrt{q}</span>  which is in accordance with Remark 3.1. However,  <span class="math">P_1(x, b)</span>  is very sparse and moreover it is easy to find a root  <span class="math">a \\in \\mathbb{F}_q</span> , in contrast to what one would expect in general for high-degree polynomials.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">5. Factor-6 compression in Characteristic three</h3>

    <p class="text-gray-300">Let  <span class="math">q = 3^m</span> ,  <span class="math">m \\equiv 5 \\pmod{12}</span> ,  <span class="math">t = \\sqrt{3q}</span>  and  <span class="math">\\ell = q + 1 - t</span> . Then</p>

    <p class="text-gray-300"><span class="math">$q^{6} - 1 = (q^{3} - 1)(q^{3} + 1)</span>$</p>

    <p class="text-gray-300"><span class="math">$= (q^{3} - 1)(q + 1)(q^{2} - q + 1)</span>$</p>

    <p class="text-gray-300"><span class="math">$= (q^{3} - 1)(q + 1)(q + 1 - t)(q + 1 + t).</span>$</p>

    <p class="text-gray-300">Let  <span class="math">G_{\\ell} \\subset G_{q,6} \\subset \\mathbb{F}_{q^6}^*</span>  be subgroups such that  <span class="math">|G_{q,6}| = q^2 - q + 1</span>  and  <span class="math">|G_{\\ell}| = \\ell</span> . Since  <span class="math">f(w) = w^3 - w - 1</span>  has splitting field  <span class="math">\\mathbb{F}_{3^3}</span>  and  <span class="math">\\gcd(3, m) = 1</span> , f is irreducible over  <span class="math">\\mathbb{F}_q</span>  and we set  <span class="math">\\mathbb{F}_{q^3} = \\mathbb{F}_q[w]/(w^3 - w - 1)</span> . We also let  <span class="math">c_0 \\in \\mathbb{F}_{q^3}</span>  be a quadratic non-residue and set  <span class="math">\\mathbb{F}_{q^6} = \\mathbb{F}_{q^3}[\\sigma]/(\\sigma^2 - c_0)</span> .</p>

    <p class="text-gray-300"><strong>Lemma 5.1.</strong> Let  <span class="math">\\mathbb{F}_{q^3} = \\mathbb{F}_q[w]/(w^3 - w - 1)</span>  and  <span class="math">\\mathbb{F}_{q^6} = \\mathbb{F}_{q^3}[\\sigma]/(\\sigma^2 - c_0)</span>  where  <span class="math">c_0 \\in \\mathbb{F}_{q^3}</span>  is a quadratic non-residue. Then</p>

    <p class="text-gray-300">$$\\sigma^{t} = c_{1}\\sigma,
\\sigma^{q} = c_{2}\\sigma,
\\sigma^{q^{2}} = c_{3}\\sigma,
w^{t} = w,
w^{2t} = w^{2},
w^{q} = w + 2,
w^{2q} = w^{2} + w + 1,
w^{q^{2}} = w + 1.$$</p>

    <p class="text-gray-300">for some  <span class="math">c_1, c_2, c_3 \\in \\mathbb{F}_{q^3}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> The equalities can be proven by using the defining equations of  <span class="math">\\sigma</span>  and w, and noting that  <span class="math">w^{3^{2k}} = w + 2k</span>  and  <span class="math">w^{3^{2k+1}} = w + 1 + 2k</span> .</p>

    <p class="text-gray-300">We furthermore assume throughout this section that  <span class="math">c_i = u_{3i} + u_{3i+1}w + u_{3i+2}w^2</span>  for i = 0, 1, 2, 3, where  <span class="math">u_i \\in \\mathbb{F}_q</span> .</p>

    <p class="text-gray-300">Let  <span class="math">g = g_0 + g_1 \\sigma \\in G_{q,6}</span> . We already know from Section 2 that if  <span class="math">g \\neq \\pm 1</span>  then g can be compressed to an element  <span class="math">\\alpha = (g_0 + 1)/g_1 \\in \\mathbb{F}_{q^3}</span> , and that a compressed  <span class="math">\\alpha \\in \\mathbb{F}_{q^3}</span>  can be decompressed to obtain  <span class="math">g = (\\alpha + \\sigma)/(\\alpha - \\sigma) \\in G_{q,6} \\setminus \\{\\pm 1\\}</span> . Our objective is to show that  <span class="math">g \\in G_\\ell</span>  can be compressed to  <span class="math">c \\in \\mathbb{F}_q</span> , and that a compressed  <span class="math">c \\in \\mathbb{F}_q</span>  can be decompressed to obtain  <span class="math">g \\in G_\\ell \\setminus \\{\\pm 1\\}</span> . The following theorem plays a key role.</p>

    <p class="text-gray-300"><strong>Theorem 5.2.</strong> Let  <span class="math">g = (\\alpha + \\sigma)/(\\alpha - \\sigma) \\in G_{\\ell} \\setminus \\{\\pm 1\\}</span>  where  <span class="math">\\alpha = a + bw + cw^2</span>  for some  <span class="math">a, b, c \\in \\mathbb{F}_q</span> . Then  <span class="math">(x_1, x_2, x_3, x_4, x_5, x_6) = (a, a^t, b, b^t, c, c^t)</span>  is a root of each  <span class="math">f_i</span>  and  <span class="math">g_i</span>  for i = 0, 1, 2, where</p>

    <p class="text-gray-300"><span class="math">$f_0 = u_0 u_3 u_6 + u_0 u_4 u_8 + u_0 u_5 u_7 + u_1 u_3 u_8 + u_1 u_4 u_7 + u_1 u_5 u_6</span>$</p>

    <p class="text-gray-300"><span class="math">$+ u_1 u_5 u_8 + u_2 u_3 u_7 + u_2 u_4 u_6 + u_2 u_4 u_8 + u_2 u_5 u_7 + u_2 u_5 u_8</span>$</p>

    <p class="text-gray-300"><span class="math">$+ u_3 x_1^2 + (u_4 + 2u_5) x_3^2 + (u_3 + 2u_4 + 2u_5) x_5^2 + (2u_6 + 2) x_1 x_2</span>$</p>

    <p class="text-gray-300"><span class="math">$+ (2u_7 + 2u_8 + 2) x_5 x_6 + (2u_6 + 2u_8 + 2) x_3 x_6 + (2u_8 + 1) x_2 x_3</span>$</p>

    <p class="text-gray-300"><span class="math">$+ (2u_7 + 2) x_2 x_5 + (2u_6 + 2u_8 + 2) x_4 x_5 + (2u_3 + 2u_5) x_1 x_3</span>$</p>

    <p class="text-gray-300"><span class="math">$+ (u_3 + 2u_4 + u_5) x_1 x_5 + 2u_3 x_3 x_5 + 2u_7 x_3 x_4 + 2u_7 x_1 x_6</span>$</p>

    <p class="text-gray-300"><span class="math">$+ 2u_8 x_1 x_4,</span>$</p>

    <p class="text-gray-300"><span class="math">$f_{1} = u_{0}u_{3}u_{7} + u_{0}u_{4}u_{6} + u_{0}u_{4}u_{8} + u_{0}u_{5}u_{7} + u_{0}u_{5}u_{8} + u_{1}u_{3}u_{6}</span>$</p>

    <p class="text-gray-300"><span class="math">$+u_{1}u_{3}u_{8} + u_{1}u_{4}u_{7} + u_{1}u_{4}u_{8} + u_{1}u_{5}u_{6} + u_{1}u_{5}u_{7} + u_{1}u_{5}u_{8}</span>$</p>

    <p class="text-gray-300"><span class="math">$+u_{2}u_{3}u_{7} + u_{2}u_{3}u_{8} + u_{2}u_{4}u_{6} + u_{2}u_{4}u_{7} + u_{2}u_{4}u_{8} + u_{2}u_{5}u_{6}</span>$</p>

    <p class="text-gray-300"><span class="math">$+u_{2}u_{5}u_{7} + 2u_{2}u_{5}u_{8} + u_{4}x_{1}^{2} + (2u_{3} + u_{4})x_{3}^{2} + (2u_{3} + u_{5})x_{5}^{2}</span>$</p>

    <p class="text-gray-300"><span class="math">$+(2u_{6} + 2u_{7} + u_{8} + 1)x_{5}x_{6} + (2u_{7} + 2u_{8} + 1)x_{3}x_{4}</span>$</p>

    <p class="text-gray-300"><span class="math">$+(2u_{6} + 2u_{7} + 2u_{8} + 2)x_{3}x_{6} + (2u_{6} + 2u_{8} + 2)x_{2}x_{3}</span>$</p>

    <p class="text-gray-300"><span class="math">$+(2u_{7} + 2u_{8} + 2)x_{2}x_{5} + (2u_{6} + 2u_{7} + 2u_{8} + 1)x_{4}x_{5}</span>$</p>

    <p class="text-gray-300"><span class="math">$+(2u_{7} + 2u_{8})x_{1}x_{6} + (2u_{6} + 2u_{8} + 2)x_{1}x_{4} + u_{3}x_{1}x_{5}</span>$</p>

    <p class="text-gray-300"><span class="math">$+(2u_{3} + 2u_{4} + 2u_{5})x_{1}x_{3} + 2u_{4}x_{3}x_{5} + 2u_{7}x_{1}x_{2},</span>$</p>

    <p class="text-gray-300"><span class="math">$f_{2} = u_{0}u_{3}u_{8} + u_{0}u_{4}u_{7} + u_{0}u_{5}u_{6} + u_{0}u_{5}u_{8} + u_{1}u_{3}u_{7} + u_{1}u_{4}u_{6}</span>$</p>

    <p class="text-gray-300"><span class="math">$+u_{1}u_{4}u_{8} + u_{1}u_{5}u_{7} + u_{1}u_{5}u_{8} + u_{2}u_{3}u_{6} + u_{2}u_{3}u_{8} + u_{2}u_{4}u_{7}</span>$</p>

    <p class="text-gray-300"><span class="math">$+u_{2}u_{4}u_{8} + u_{2}u_{5}u_{6} + u_{2}u_{5}u_{7} + u_{2}u_{5}u_{8} + 2u_{7}x_{2}x_{3} + u_{5}x_{1}^{2}</span>$</p>

    <p class="text-gray-300"><span class="math">$+(u_{3} + 2u_{4} + u_{5})x_{3}^{2} + (2u_{3} + 2u_{4})x_{5}^{2} + (2u_{4} + 2u_{5})x_{1}x_{3}</span>$</p>

    <p class="text-gray-300"><span class="math">$+(2u_{3} + u_{4})x_{1}x_{5} + 2u_{8}x_{1}x_{2} + 2u_{5}x_{3}x_{5} + 2u_{7}x_{1}x_{4}</span>$</p>

    <p class="text-gray-300"><span class="math">$+(2u_{6} + 2u_{7} + 2u_{8} + 1)x_{5}x_{6} + (2u_{6} + 2u_{8} + 2)x_{3}x_{4}</span>$</p>

    <p class="text-gray-300"><span class="math">$+(2u_{7} + 2u_{8} + 1)x_{3}x_{6} + (2u_{6} + 2u_{8} + 2)x_{2}x_{5}</span>$</p>

    <p class="text-gray-300"><span class="math">$+(2u_{7} + 2u_{8} + 2)x_{4}x_{5} + (2u_{6} + 2u_{8} + 2)x_{1}x_{6}.</span>$</p>

    <p class="text-gray-300"><span class="math">$g_0 = u_2u_7u_{11} + u_2u_8u_{10} + u_2u_8u_{11} + u_0u_6u_9 + u_1u_7u_{10} + u_0u_7u_{11}</span>$</p>

    <p class="text-gray-300"><span class="math">$+u_0u_8u_{10} + u_1u_6u_{11} + u_2u_7u_9 + u_1u_8u_9 + u_1u_8u_{11} + u_2u_6u_{10}</span>$</p>

    <p class="text-gray-300"><span class="math">$+(2u_9 + 2 + u_6)x_1^2 + (u_9 + u_6 + 2u_8 + u_{11})x_3x_1</span>$</p>

    <p class="text-gray-300"><span class="math">$+(2u_9 + 1 + 2u_8 + u_{10} + 2u_{11} + 2u_7 + u_6)x_1x_5</span>$</p>

    <p class="text-gray-300"><span class="math">$+(u_7 + u_8 + 2u_{10} + u_{11} + 1)x_3^2</span>$</p>

    <p class="text-gray-300"><span class="math">$+(2u_6+2u_7+2u_9+u_{10}+u_{11}+2)x_5^2+(2u_6+u_9+1)x_3x_5</span>$</p>

    <p class="text-gray-300"><span class="math">$g_{1} = u_{0}u_{6}u_{10} + u_{0}u_{7}u_{9} + u_{0}u_{7}u_{11} + u_{0}u_{8}u_{10} + u_{0}u_{8}u_{11} + u_{1}u_{6}u_{9}</span>$</p>

    <p class="text-gray-300"><span class="math">$+u_{1}u_{6}u_{11} + u_{1}u_{7}u_{10} + u_{1}u_{7}u_{11} + u_{1}u_{8}u_{9} + u_{1}u_{8}u_{10} + u_{1}u_{8}u_{11}</span>$</p>

    <p class="text-gray-300"><span class="math">$+u_{2}u_{6}u_{10} + u_{2}u_{6}u_{11} + u_{2}u_{7}u_{9} + u_{2}u_{7}u_{10} + u_{2}u_{7}u_{11} + u_{2}u_{8}u_{9}</span>$</p>

    <p class="text-gray-300"><span class="math">$+u_{2}u_{8}u_{10} + 2u_{2}u_{8}u_{11} + (u_{7} + 2u_{10})x_{1}^{2}</span>$</p>

    <p class="text-gray-300"><span class="math">$+(u_{6} + u_{7} + 2u_{8} + u_{9} + 2u_{10})x_{3}^{2}</span>$</p>

    <p class="text-gray-300"><span class="math">$+(u_{7} + 2u_{8} + u_{9} + 2u_{11} + 2)x_{5}^{2}</span>$</p>

    <p class="text-gray-300"><span class="math">$+(2u_{6} + u_{7} + 2u_{8} + u_{9} + u_{10} + u_{11} + 1)x_{1}x_{3}</span>$</p>

    <p class="text-gray-300"><span class="math">$+(2u_{6} + u_{8} + 2u_{9})x_{1}x_{5} + (2u_{7} + u_{10})x_{3}x_{5},</span>$</p>

    <p class="text-gray-300"><span class="math">$g_{2} = u_{1}u_{6}u_{10} + u_{1}u_{7}u_{9} + u_{1}u_{7}u_{11} + u_{1}u_{8}u_{10} + u_{1}u_{8}u_{11} + u_{2}u_{6}u_{9}</span>$</p>

    <p class="text-gray-300"><span class="math">$+u_{2}u_{6}u_{11} + u_{2}u_{7}u_{10} + u_{2}u_{7}u_{11} + u_{0}u_{6}u_{11} + u_{0}u_{7}u_{10} + u_{0}u_{8}u_{9}</span>$</p>

    <p class="text-gray-300"><span class="math">$+u_{0}u_{8}u_{11} + u_{2}u_{8}u_{9} + u_{2}u_{8}u_{10} + u_{2}u_{8}u_{11} + (u_{8} + 2u_{11})x_{1}^{2}</span>$</p>

    <p class="text-gray-300"><span class="math">$+(2u_{7} + u_{8} + u_{10} + u_{11})x_{1}x_{3}</span>$</p>

    <p class="text-gray-300"><span class="math">$+(2u_{6} + 2u_{7} + u_{9} + 2u_{10} + 1)x_{1}x_{5}</span>$</p>

    <p class="text-gray-300"><span class="math">$+(u_{6} + u_{7} + u_{8} + 2u_{9} + u_{10} + 2u_{11} + 2)x_{3}^{2}</span>$</p>

    <p class="text-gray-300"><span class="math">$+(2u_{6} + u_{8} + u_{9} + u_{10} + 1)x_{5}^{2} + (2u_{8} + u_{11})x_{3}x_{5},</span>$</p>

    <p class="text-gray-300">and where  <span class="math">c_i = u_{3i} + u_{3i+1}w + u_{3i+2}w^2</span> , for i = 0, 1, 2, 3, are as specified in Lemma 5.1.</p>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">g = (\\alpha + \\sigma)/(\\alpha - \\sigma) \\in G_{\\ell} \\setminus \\{\\pm 1\\}</span> . Expanding the equations  <span class="math">g^{q^2 - q + 1} = 1</span>  and  <span class="math">g^{q+1-t} = 1</span>  and simplifying using Lemma 5.1 yields the polynomials  <span class="math">f_i, g_i \\in \\mathbb{F}_q[x_1, x_2, \\dots, x_6]</span>  for i = 0, 1, 2 such that  <span class="math">(x_1, x_2, x_3, x_4, x_5, x_6) = (a, a^t, b, b^t, c, c^t)</span>  is a root of each  <span class="math">f_i</span>  and  <span class="math">g_i</span> , as required.</p>

    <p class="text-gray-300">Theorem 5.2 suggests that one can compress an element  <span class="math">g \\in G_{\\ell} \\setminus \\{\\pm 1\\}</span>  to an element  <span class="math">c \\in \\mathbb{F}_q</span> . Given a compressed representation c of an element g, one might reconstruct g by finding a common root  <span class="math">(a, a^t, b, b^t, c, c^t)</span>  of the  <span class="math">f_i</span>  and  <span class="math">g_i</span> . This may be achieved by constructing a Groebner basis of the ideal in  <span class="math">\\mathbb{F}_q[x_1, x_2, \\dots, x_6]</span>  generated by  <span class="math">f_i</span>  and  <span class="math">g_i</span>  evaluated at  <span class="math">x_5 = c</span> ,  <span class="math">x_6 = c^t</span>  for i = 0, 1, 2. The next corollary shows that this is indeed possible in the case that  <span class="math">c_0 = -1</span> .</p>

    <p class="text-gray-300">Corollary 5.3. Let  <span class="math">\\mathbb{F}_{q^3} = \\mathbb{F}_q[w]/(w^3 - w - 1)</span>  and  <span class="math">\\mathbb{F}_{q^6} = \\mathbb{F}_{q^3}[\\sigma]/(\\sigma^2 + 1)</span> . Let  <span class="math">f_i, g_i</span>  be as in Theorem 5.2. Then a Groebner basis of the ideal  <span class="math">\\langle f_0, f_1, f_2, g_0, g_1, g_2 \\rangle</span>  in  <span class="math">\\mathbb{F}_q[x_1, x_2, \\dots, x_6]</span>  is</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{rcl} P_1 &amp; = &amp; x_1 + 2x_3^2x_4 + 2x_3x_4x_5 + x_3 + x_5^2x_6 + 2x_5, \\\\ P_2 &amp; = &amp; x_2 + 2x_3^3x_4^2 + 2x_4^2x_5^3 + x_4x_5^3x_6 + x_5^3x_6^2 + 2x_6, \\\\ P_3 &amp; = &amp; x_3^2x_4x_5 + 2x_3^2 + x_3x_4x_5^2 + 2x_3x_5 + 2x_5^3x_6 + 2x_5^2 + 2, \\\\ P_4 &amp; = &amp; x_3x_4^2x_5^2 + x_3x_4x_5 + x_3 + 2x_4^2x_5^3 + 2x_4x_5^3x_6 + 2x_4x_5^2 \\\\ &amp; &amp; + 2x_5^3x_6^2 + 2x_5 + 2x_6, \\\\ P_5 &amp; = &amp; x_3x_6 + 2x_4x_5 + 2x_5x_6 + 1, \\\\ P_6 &amp; = &amp; x_4^3x_5^3 + 2x_4x_5^3x_6^2 + 2x_5^3x_6^3 + 2x_6^2 + 2. \\end{array}</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> If one sets  <span class="math">c_0 = -1</span>  in Theorem 5.2 then  <span class="math">g_1 = g_2 = 0</span> , and the polynomials  <span class="math">f_i</span>  and  <span class="math">g_0</span>  simplify to</p>

    <p class="text-gray-300"><span class="math">$f_0 = 2x_1^2 + x_1x_3 + 2x_1x_5 + x_2x_3 + 2x_2x_5 + x_3x_5 + 2x_5^2 + 2x_5x_6 + 2,</span>$</p>

    <p class="text-gray-300"><span class="math">$f_1 = x_1x_3 + 2x_1x_5 + 2x_2x_5 + x_3^2 + x_3x_4 + 2x_4x_5 + x_5^2 + 2x_5x_6,</span>$</p>

    <p class="text-gray-300"><span class="math">$f_2 = x_1x_5 + 2x_3^2 + x_3x_6 + 2x_4x_5 + x_5^2 + 2x_5x_6,</span>$</p>

    <p class="text-gray-300"><span class="math">$g_0 = 2x_1x_5 + x_3^2 + 2x_5^2 + 1.</span>$</p>

    <p class="text-gray-300">It can be verified using Magma with the commands</p>

    <p class="text-gray-300"><span class="math">$R &lt; x1, x2, x3, x4, x5, x6 &gt;:= PolynomialRing(FiniteField(3), 6);</span>$</p>

    <p class="text-gray-300"><span class="math">B := [R!f_0, R!f_1, R!f_2, R!g_0];</span>
<span class="math">I := ideal &lt; R|B &gt;;</span>
<span class="math">GroebnerBasis(I);</span></p>

    <p class="text-gray-300">that a Groebner basis of the ideal  <span class="math">\\langle f_0, f_1, f_2, g_0 \\rangle</span>  in  <span class="math">\\mathbb{F}_q[x_1, x_2, \\dots, x_6]</span>  is determined by the  <span class="math">P_i</span> 's, as required.</p>

    <p class="text-gray-300">5.1. <strong>Decompression procedure.</strong> Let  <span class="math">\\mathbb{F}_{q^3} = \\mathbb{F}_q[w]/(w^3 - w - 1)</span>  and  <span class="math">\\mathbb{F}_{q^6} = \\mathbb{F}_{q^3}[\\sigma]/(\\sigma^2 + 1)</span> . Let  <span class="math">g = (\\alpha + \\sigma)/(\\alpha - \\sigma) \\in G_\\ell \\setminus \\{\\pm 1\\}</span>  where  <span class="math">\\alpha = a + bw + cw^2</span>  for some  <span class="math">a, b, c \\in \\mathbb{F}_q</span> . By Theorem 5.2 and Corollary 5.3,  <span class="math">b^t</span>  must be a root of</p>

    <p class="text-gray-300">(5.1)
<span class="math">$P_6(x_4) = c^3 x_4^3 + 2c^{2t+3} x_4 + 2(c^{3(t+1)} + c^{2t} + 1).</span>$</p>

    <p class="text-gray-300">In fact, there are exactly three roots of  <span class="math">P_6(x_4)</span>  in  <span class="math">\\mathbb{F}_q</span> , and if r is a root then the other two roots are given by  <span class="math">r \\pm c^t</span> . Therefore, if c is given,  <span class="math">b^t</span>  can be determined uniquely up to 3 elements, that is,  <span class="math">b^t \\in \\{r, r-c^t, r+c^t\\}</span> . Once  <span class="math">b^t</span>  is fixed, one can solve for b uniquely by using  <span class="math">P_5(x_3) = 0</span> , where  <span class="math">P_5(x_3)</span>  is obtained by evaluating  <span class="math">P_5</span>  at  <span class="math">x_4 = b^t</span> ,  <span class="math">x_5 = c</span> ,  <span class="math">x_6 = c^t</span>  (see Corollary 5.3), or by using the fact that  <span class="math">b \\mapsto b^t</span>  is a Frobenius map. Having determined b,  <span class="math">b^t</span> , c and  <span class="math">c^t</span>  we can use  <span class="math">P_2(x_2) = 0</span> , where  <span class="math">P_2(x_2)</span>  is obtained by evaluating  <span class="math">P_2</span>  at  <span class="math">x_3 = b</span> ,  <span class="math">x_4 = b^t</span> ,  <span class="math">x_5 = c</span> ,  <span class="math">x_6 = c^t</span>  (see Corollary 5.3), to solve for  <span class="math">a^t</span>  uniquely. Finally, a can be determined either by using  <span class="math">P_1(x_1) = 0</span> , where  <span class="math">P_1(x_1)</span>  is obtained by evaluating  <span class="math">P_1</span>  at  <span class="math">x_3 = b</span> ,  <span class="math">x_4 = b^t</span> ,  <span class="math">x_5 = c</span> ,  <span class="math">x_6 = c^t</span>  (see Corollary 5.3), or by using the fact that  <span class="math">a \\mapsto a^t</span>  is a Frobenius map.</p>

    <p class="text-gray-300">To summarize, suppose that  <span class="math">g \\in G_{\\ell} \\setminus \\{\\pm 1\\}</span>  and  <span class="math">g = (\\alpha + \\sigma)/(\\alpha - \\sigma)</span>  with  <span class="math">\\alpha = a + bw + cw^2</span> . If c is given, then the three pairs  <span class="math">(x_{1h}, x_{3h})</span> , h = 1, 2, 3 can be efficiently determined such that  <span class="math">(a, b, c) \\in \\{(x_{1h}, x_{3h}, c) : h = 1, 2, 3\\}</span> . In fact, one can check that  <span class="math">c \\neq 0</span>  and</p>

    <p class="text-gray-300"><span class="math">$\\{(x_{1h}, x_{3h}, c): h = 1, 2, 3\\} = \\{(a, b, c), (a - b + c, b + c, c), (a + b + c, b - c, c)\\}.</span>$</p>

    <p class="text-gray-300">Suppose now that we have fixed some representation of  <span class="math">\\mathbb{F}_q</span>  as an m-dimensional vector space over  <span class="math">\\mathbb{F}_3</span> . Then there must exist a <em>smallest index j</em> such that exactly one of  <span class="math">x_{3h}</span> 's j'th trit is equal to b's j'th trit, say  <span class="math">i \\in \\{0, 1, 2\\}</span> , when they are represented as vectors over  <span class="math">\\mathbb{F}_3</span> . This yields one-to-one compression/decompression maps that achieve factor- <span class="math">(6 \\log q)/(2 + \\log q)</span>  compression.</p>

    <p class="text-gray-300">Theorem 5.4. Define a compression map</p>

    <p class="text-gray-300">(5.2)
<span class="math">$\\mathcal{C}: G_{\\ell} \\setminus \\{\\pm 1\\} \\rightarrow \\{0, 1, 2\\} \\times \\mathbb{F}_{q}</span>$
<span class="math">$q \\mapsto (i, c),</span>$</p>

    <p class="text-gray-300">where  <span class="math">g = g_0 + g_1 \\sigma</span> ,  <span class="math">(g_0 + 1)/g_1 = a + bw + cw^2</span> , and i is defined above. Define a decompression map</p>

    <p class="text-gray-300">(5.3)
<span class="math">$\\mathcal{D}: \\{0,1,2\\} \\times \\mathbb{F}_q \\to G_{\\ell} \\setminus \\{\\pm 1\\}</span>$
<span class="math">$(i,c) \\mapsto (\\alpha + \\sigma)/(\\alpha - \\sigma),</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\alpha = a + bw + cw^2</span> , and a, b can be constructed as described above. Then  <span class="math">\\mathcal{C}</span>  and  <span class="math">\\mathcal{D}</span>  are inverses of each other when they are defined. Moreover, if  <span class="math">\\mathcal{D}(0,c) \\in G_{\\ell} \\setminus \\{\\pm 1\\}</span>  then  <span class="math">\\mathcal{D}(i,b) \\in G_{\\ell} \\setminus \\{\\pm 1\\}</span>  for i = 1, 2, and  <span class="math">\\mathcal{D}(0,c)\\mathcal{D}(1,c)\\mathcal{D}(2,c) = 1</span> .</p>

    <p class="text-gray-300">Proof. It is clear from our arguments above that C and D are inverses of each other when they are defined. Now, let  <span class="math">c \\in \\mathbb{F}_q^*</span>  be such that  <span class="math">g = (\\alpha + \\sigma)/(\\alpha - \\sigma) \\in G_\\ell \\setminus \\{\\pm 1\\}</span> , where  <span class="math">\\alpha = a+bw+cw^2</span> . Let  <span class="math">i_1</span>  be the jth trit of b, where j is the smallest index such that if (b+c)'s j'th trit is  <span class="math">i_2</span>  and (b-c)'s j'th trit is  <span class="math">i_3</span> , then  <span class="math">i_1, i_2, i_3</span>  are pairwise different. It follows from our arguments above that the decompression function satisfies  <span class="math">D(i_h, c) = g_h</span> , where  <span class="math">g_h = (\\alpha_h - \\sigma)/(\\alpha_h + \\sigma)</span> , and  <span class="math">\\alpha_1 = a + bw + cw^2</span> ,  <span class="math">\\alpha_2 = (a - b + c) + (b + c)w + cw^2</span> ,  <span class="math">\\alpha_3 = (a + b + c) + (b - c)w + cw^2</span> . Moreover, one can check that  <span class="math">g_1 = g</span> ,  <span class="math">g_2 = g^{-q} = g^{q^4}</span> , and  <span class="math">g_3 = g^{q^2}</span> , that is  <span class="math">g_1g_2g_3 = 1</span> , as required.</p>

    <p class="text-gray-300"><strong>Remark 5.5.</strong> It would be interesting to prove similar results for  <span class="math">q = 3^m</span>  where  <span class="math">m \\not\\equiv 5 \\pmod{12}</span> , and for any quadratic non-residue  <span class="math">c_0 \\in \\mathbb{F}_{q^3}</span> ,  <span class="math">c_0 \\neq -1</span> . The main difficulty when  <span class="math">c_0 \\neq -1</span>  seems to be that the polynomials  <span class="math">f_i</span> ,  <span class="math">g_i</span>  are defined strictly over  <span class="math">\\mathbb{F}_q</span>  rather than over  <span class="math">\\mathbb{F}_3</span>  which is the case when  <span class="math">c_0 = -1</span> .</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">6. Factor-4 compression and exponentiation algorithms</h3>

    <p class="text-gray-300">In this section, we analyze the efficiency of the compression and decompression methods proposed in Section 4. The efficiency of these methods matters because given a compressed representation of an element, one can consider a variety of exponentiation algorithms that can work directly with that compressed representation, or with partially or fully decompressed representations of the element.</p>

    <p class="text-gray-300">We first show that compression and decompression can be achieved at a negligible cost. Then we describe two exponentiation algorithms and provide a performance comparison.</p>

    <p class="text-gray-300">6.1. Compression/decompression costs. Let  <span class="math">q = 2^m</span> , m odd,  <span class="math">t = \\sqrt{2q}</span>  and  <span class="math">\\ell = q + 1 - t</span> . Let  <span class="math">G_{\\ell} \\subset \\mathbb{F}_{q^4}^*</span>  be the subgroup with  <span class="math">|G_{\\ell}| = \\ell</span> . Let  <span class="math">\\mathbb{F}_{q^2} = \\mathbb{F}_q[w]/(w^2 + w + c_0)</span>  and  <span class="math">\\mathbb{F}_{q^4} = \\mathbb{F}_{q^2}[\\sigma]/(\\sigma^2 + \\sigma + c_1)</span> , where  <span class="math">\\text{Tr}_{q,2}(c_0) = \\text{Tr}_{q^2,2}(c_1) = 1</span> . We further assume that  <span class="math">\\mathbb{F}_q</span>  is represented as an m-dimensional vector space over  <span class="math">\\mathbb{F}_2</span>  via a polynomial basis  <span class="math">\\{1, z, \\ldots, z^{m-1}\\}</span> .</p>

    <p class="text-gray-300">We first show that the compression and decompression maps described in Theorem 4.4 are very efficiently computable.</p>

    <p class="text-gray-300"><strong>Lemma 6.1.</strong> Let  <span class="math">P_1(x) = x^t + x + u \\in \\mathbb{F}_q[x]</span> . If  <span class="math">P_1(x) = 0</span>  has a solution in  <span class="math">\\mathbb{F}_q</span>  then it can be computed at a cost of (m-1)/2 squarings and (m-1)/2 additions in  <span class="math">\\mathbb{F}_q</span> . If storage for m  <span class="math">\\mathbb{F}_q</span> -elements is available then finding the  <span class="math">\\mathbb{F}_q</span> -solutions of  <span class="math">P_1(x) = 0</span>  in  <span class="math">\\mathbb{F}_q</span>  requires on average m/2 additions in  <span class="math">\\mathbb{F}_q</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">u = \\sum_{i=0}^{m-1} u_i z^i</span>  and suppose that  <span class="math">P_1(x) = x^t + x + u = 0</span>  has a solution in  <span class="math">\\mathbb{F}_q</span> . It follows from Lemma 4.3 that the solutions in  <span class="math">\\mathbb{F}_q</span>  are given by H(u) and H(u) + 1, where  <span class="math">H(u) = \\sum_{i=0}^{(m-1)/2} u^{2^i}</span> , which can be computed at a cost of (m-1)/2 squarings and (m-1)/2 additions in  <span class="math">\\mathbb{F}_q</span> . If one can store  <span class="math">H(z^i)</span>  for  <span class="math">0 \\le i &lt; m</span>  then</p>

    <p class="text-gray-300"><span class="math">$H(u) = \\sum_{i=0}^{m-1} u_i H(z^i)</span>$</p>

    <p class="text-gray-300">can be computed at a cost of m/2 additions on average.</p>

    <p class="text-gray-300"><strong>Theorem 6.2.</strong> Let C and D be compression and decompression maps, respectively, as described in Theorem 4.4. Then compression via C requires 1 division in  <span class="math">\\mathbb{F}_{q^2}</span>  and decompression via D requires (m-1)/2 squarings and (m-1)/2 additions in  <span class="math">\\mathbb{F}_q</span> , and 1 division in  <span class="math">\\mathbb{F}_{q^4}</span> . If storage for m  <span class="math">\\mathbb{F}_q</span> -elements is available then decompression requires on average m/2 additions in  <span class="math">\\mathbb{F}_q</span>  and 1 division in  <span class="math">\\mathbb{F}_{q^4}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> The proof follows from Theorem 4.4 and Lemma 6.1.</p>

    <p class="text-gray-300">6.2. <strong>Exponentiation algorithms.</strong> Recall that in our compression method, given  <span class="math">g = g_0 + g_1 \\sigma \\in G_{\\ell} \\setminus \\{1\\}</span> , we first compress g to  <span class="math">\\alpha = (g_0 + 1)/g_1 = a + bw</span> , and then compress  <span class="math">\\alpha</span>  to (i, b) where  <span class="math">i \\in \\{0, 1\\}</span> . By Theorem 6.2, compressing g to (i, b) and decompressing (i, b) to  <span class="math">\\alpha</span>  (and to g) can be achieved at a negligible cost. In this context, we call  <span class="math">\\alpha</span>  a half-compressed element.</p>

    <p class="text-gray-300">We present two exponentiation algorithms to compute  <span class="math">g^e</span>  given  <span class="math">\\mathcal{C}(g) = (i,b)</span>  and  <span class="math">e \\in \\mathbb{Z}</span> . The first exponentiation algorithm, which we call HCTBE (Half-Compressed Torus-Based Exponentiation), partially decompresses (i,b) to  <span class="math">\\alpha</span>  and then uses a multiplication formula for half-compressed elements. The output is then compressed to obtain  <span class="math">\\mathcal{C}(g^e)</span> . The second algorithm, which we call FDDE (Fully-Decompressed Direct Exponentiation Algorithm), fully decompresses (i,b) to g and uses a conventional square-and-multiply exponentiation algorithm in  <span class="math">\\mathbb{F}_{g^4}</span> .</p>

    <p class="text-gray-300">6.2.1. The HCTBE algorithm. The algorithm makes use of the multiplication formula (2.3) to compute  <span class="math">C(g^e)</span> . The formula requires an inversion in  <span class="math">\\mathbb{F}_{q^2}</span>  that makes the exponentiation algorithm quite costly if one tries to use (2.3) directly. However, the problem can be overcome as follows. If  <span class="math">g = g_0 + g_1 \\sigma</span> ,  <span class="math">h = h_0 + h_1 \\sigma \\in G_{\\ell} \\setminus \\{1\\}</span>  are represented by  <span class="math">\\alpha = (g_0 + 1)/g_1</span> ,  <span class="math">\\beta = (h_0 + 1)/h_1 \\in \\mathbb{F}_{q^2}</span> , respectively, then we have</p>

    <p class="text-gray-300"><span class="math">$g \\cdot h = \\left(\\frac{\\alpha + \\sigma}{\\alpha + 1 + \\sigma}\\right) \\left(\\frac{\\beta + \\sigma}{\\beta + 1 + \\sigma}\\right)</span>$
<span class="math">$= \\frac{\\alpha\\beta + c_1 + (\\alpha + \\beta + 1)\\sigma}{\\alpha\\beta + c_1 + \\alpha + \\beta + 1 + (\\alpha + \\beta + 1)\\sigma}.</span>$</p>

    <p class="text-gray-300">In other words, if the product of any two elements in  <span class="math">G_{\\ell}</span>  is computed by this formula then the result will be of the form</p>

    <p class="text-gray-300">(6.1)
<span class="math">$\\frac{x+y\\sigma}{x+y+y\\sigma}, \\text{ for some } x,y \\in \\mathbb{F}_{q^2}.</span>$</p>

    <p class="text-gray-300">In particular, given C(g) = (i, b) and  <span class="math">e \\in \\mathbb{Z}</span> , one can first decompress (i, b) to  <span class="math">\\alpha</span> , and then perform an exponentiation to compute  <span class="math">C(g^e)</span>  by using the formulas</p>

    <p class="text-gray-300">$$\\left(\\frac{x+y\\sigma}{x+y+y\\sigma}\\right)^2 = \\frac{x^2+y^2c_1+y^2\\sigma}{x^2+y^2c_1+y^2+y^2\\sigma},
\\left(\\frac{\\alpha+\\sigma}{\\alpha+1+\\sigma}\\right)\\left(\\frac{x+y\\sigma}{x+y+y\\sigma}\\right) = \\frac{\\alpha x+yc_1+(\\alpha y+x+y)\\sigma}{\\alpha x+yc_1+\\alpha y+x+y+(\\alpha y+x+y)\\sigma},$$</p>

    <p class="text-gray-300">in the square and multiply steps of the exponentiation algorithm. Note that by (6.1) it suffices to only keep track of the numerator during the computations, and to do a single division in  <span class="math">\\mathbb{F}_{q^4}</span>  to obtain  <span class="math">g^e</span>  and finally its compressed value  <span class="math">\\mathcal{C}(g^e)</span> . Our discussion yields Algorithm 1.</p>

    <p class="text-gray-300">Assuming that  <span class="math">c_1 \\in \\mathbb{F}_{q^2}</span>  is chosen so that the cost of multiplying an element by  <span class="math">c_1</span>  is negligible, the cost of the squaring step (step 5), and the cost of the multiplication step (step 7) in Algorithm 1 is approximately 2 squarings in  <span class="math">\\mathbb{F}_{q^2}</span>  and 2 multiplications in  <span class="math">\\mathbb{F}_{q^2}</span> , respectively.</p>

    <p class="text-gray-300">6.2.2. The FDDE algorithm. After decompressing C(g) = (i, b) to  <span class="math">g = g_0 + g_1 \\sigma</span> , we use a conventional square-and-multiply exponentiation algorithm as described in Algorithm 2. Since</p>

    <p class="text-gray-300"><span class="math">$(x+y\\sigma)^2 = x^2 + y^2c + y^2\\sigma, (g_0 + g_1\\sigma)(x+y\\sigma) = g_0x + g_1yc + (g_0y + g_1x + g_1yc)\\sigma,</span>$</p>

    <p class="text-gray-300">each squaring step (step 5) in Algorithm 2 requires 2 squarings in  <span class="math">\\mathbb{F}_{q^2}</span> . Using Karatsuba's technique, each multiplication step (steps 7-8) requires 3 multiplications in  <span class="math">\\mathbb{F}_{q^2}</span> . We assume that  <span class="math">c_1 \\in \\mathbb{F}_{q^2}</span>  is chosen appropriately so that the cost of multiplying an element by  <span class="math">c_1</span>  is negligible.</p>

    <p class="text-gray-300">Input: C(g) and eOutput:  <span class="math">C(g^e)</span> 1: Write  <span class="math">e = \\sum_{i=1}^{s-1} h_i 2^i</span>  who</p>

    <pre><code class="language-text">1: Write e = \\sum_{i=0}^{s-1} b_i 2^i where b_i \\in \\{0,1\\} and b_{s-1} = 1
 2: Decompress C(g) to \\alpha by using Theorem 4.4
 3: x \\leftarrow \\alpha, y \\leftarrow 1
4: for i from s-2 down to 0 do
       y&#x27; \\leftarrow y^2, \\ x&#x27; \\leftarrow x^2 + y&#x27;c_1
       if b_i = 1 then
          x&#x27; \\leftarrow \\alpha x + y c_1, \\ y&#x27; \\leftarrow \\alpha y + x + y
 7:
       end if
 8:
       x \\leftarrow x&#x27;, \\ y \\leftarrow y&#x27;
9:
10: end for
11: g&#x27; \\leftarrow (x + y\\sigma)/(x + y + y\\sigma)
12: Compress (g&#x27;) to \\mathcal{C}(g&#x27;) = (i&#x27;, b&#x27;), by using Theorem 4.4
13: Output (i&#x27;, b&#x27;)
</code></pre>

    <p class="text-gray-300">Input: C(g) and eOutput:  <span class="math">C(g^e)</span></p>

    <pre><code class="language-text">1: Write e = \\sum_{i=0}^{s-1} b_i 2^i where b_i \\in \\{0,1\\} and b_{s-1} = 1
 2: Decompress C(g) to g = g_0 + g_1 \\sigma by using Theorem 4.4
 3: x \\leftarrow g_0, y \\leftarrow g_1
 4: for i from s-2 down to 0 do
       y&#x27; \\leftarrow y^2, \\ x&#x27; \\leftarrow x^2 + y&#x27;c_1
        if b_i = 1 then
           u_0 \\leftarrow (g_0 + g_1)(x&#x27; + y&#x27;), \\ u_1 \\leftarrow g_0 x&#x27;, \\ u_2 \\leftarrow g_1 y&#x27;, \\ u_3 \\leftarrow u_2 c_1
           x&#x27; \\leftarrow u_1 + u_3, \\ y&#x27; \\leftarrow x&#x27; + u_0 + u_2
 8:
        end if
g.
        x \\leftarrow x&#x27;, \\ y \\leftarrow y&#x27;
11: end for
12: g&#x27; \\leftarrow (x + y\\sigma)
13: Compress (g&#x27;) to \\mathcal{C}(g&#x27;) = (i&#x27;, b&#x27;), by using Theorem 4.4
14: Output (i&#x27;, b&#x27;)
</code></pre>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>6.2.3. A comparison with trace-based exponentiation. In [8], it was shown that it is possible to compress elements of  <span class="math">G_{\\ell}</span>  by a factor 4 by identifying an element  <span class="math">g \\in G_{\\ell}</span>  with its trace  <span class="math">\\operatorname{Tr}_{q^4,q}(g)</span> . Given  <span class="math">\\operatorname{Tr}_{q^4,q}(g)</span>  and an integer e, five exponentiation algorithms were proposed and analyzed in [8] to compute  <span class="math">\\operatorname{Tr}_{q^4,q}(g^e)</span> . The algorithms are based on the following ideas:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) Use  <span class="math">\\operatorname{Tr}_{q^4,q}(g)</span>  directly and perform computations in  <span class="math">\\mathbb{F}_q</span>  (Algorithm 1 in [8]).</li>
      <li>(2) First decompress  <span class="math">\\operatorname{Tr}_{q^4,q}(g)</span>  to  <span class="math">\\operatorname{Tr}_{q^4,q^2}(g)</span> . Then use  <span class="math">\\operatorname{Tr}_{q^4,q^2}(g)</span>  directly and perform computations in  <span class="math">\\mathbb{F}_{q^2}</span>  (Algorithm 2 in [8]).</li>
      <li>(3) First decompress  <span class="math">\\operatorname{Tr}_{q^4,q}(g)</span>  to g and perform computations in  <span class="math">\\mathbb{F}_{q^4}</span>  (Algorithm DDE in [8]).</li>
      <li>(4) First decompress  <span class="math">\\operatorname{Tr}_{q^4,q}(g)</span>  to  <span class="math">\\operatorname{Tr}_{q^4,q^2}(g)</span> . Then use  <span class="math">\\operatorname{Tr}_{q^4,q^2}(g)</span>  to construct a copy of  <span class="math">\\mathbb{F}_{q^4}</span>  based on the minimal polynomial of g over  <span class="math">\\mathbb{F}_{q^2}</span> , and perform computations in  <span class="math">\\mathbb{F}_{q^4}</span>  (Algorithm BPV-I in [8]).</li>
      <li>(5) Use  <span class="math">\\operatorname{Tr}_{q^4,q}(g)</span>  to construct a copy of  <span class="math">\\mathbb{F}_{q^4}</span>  based on the minimal polynomial of g over  <span class="math">\\mathbb{F}_q</span> , and perform computations in  <span class="math">\\mathbb{F}_{q^4}</span>  (Algorithm BPV-II in [8]).</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">If a decompression is performed then it is the most expensive step in these algorithms. Therefore, the algorithms based on (1) and (5) are overall faster than the algorithms based on (2), (3) and (4). In particular, Algorithm 1 in [8] was reported to be the fastest exponentiation algorithm in the case of using a general base  <span class="math">\\text{Tr}_{q^4,q}(g)</span> , and its performance was further improved in [7] (see Algorithm 3 in [7]). However, once decompression can be performed in advance, such as in the case of using a fixed base  <span class="math">\\text{Tr}_{q^4,q}(g)</span> , then the algorithm based on (3) is the fastest.</p>

    <p class="text-gray-300">Note that by Theorem 6.2, given C(g) for some  <span class="math">g \\in G_{\\ell} \\setminus \\{1\\}</span> , one can recover g (and also  <span class="math">\\operatorname{Tr}_{q^4,q}(g)</span>  and  <span class="math">\\operatorname{Tr}_{q^4,q^2}(g)</span> ) at a negligible cost. Hence, it is more advantageous to use C(g) instead of  <span class="math">\\operatorname{Tr}_{q^4,q}(g)</span> . For example, using C(g), we can obtain faster exponentiation algorithms than the trace-based exponentiation algorithms in the case of a general base by simply computing  <span class="math">\\operatorname{Tr}_{q^4,q}(g)</span>  from C(g) and adapting an algorithm based on (3).</p>

    <p class="text-gray-300">This section is analogous to Section 6. We analyze the efficiency of the compression and decompression methods proposed in Section 5. We first show that compression and decompression can be achieved at a negligible cost, and then describe two exponentiation algorithms and provide a performance comparison.</p>

    <p class="text-gray-300">7.1. Compression/decompression costs. Let  <span class="math">q = 3^m</span> , m odd,  <span class="math">t = \\sqrt{3q}</span>  and  <span class="math">\\ell = q+1-t</span> . Let  <span class="math">G_{\\ell} \\subset \\mathbb{F}_{q^6}^*</span>  be the subgroup with  <span class="math">|G_{\\ell}| = \\ell</span> . Let  <span class="math">\\mathbb{F}_{q^3} = \\mathbb{F}_q[w]/(w^3-w-1)</span>  and  <span class="math">\\mathbb{F}_{q^6} = \\mathbb{F}_{q^3}[\\sigma]/(\\sigma^2-c_0)</span>  where  <span class="math">c_0</span>  is a quadratic non-residue in  <span class="math">\\mathbb{F}_{q^3}</span> . We further assume that  <span class="math">\\mathbb{F}_q</span>  is represented as an m-dimensional vector space over  <span class="math">\\mathbb{F}_3</span>  via a polynomial basis  <span class="math">\\{1, z, \\ldots, z^{m-1}\\}</span> .</p>

    <p class="text-gray-300"><strong>Lemma 7.1.</strong> Let  <span class="math">P_6(x) = c^3x^3 + 2c^{2t+3}x + 2(c^{3(t+1)} + c^{2t} + 1) \\in \\mathbb{F}_q[x]</span>  for some  <span class="math">c \\in \\mathbb{F}_q</span> . If  <span class="math">P_6(x) = 0</span>  has a solution in  <span class="math">\\mathbb{F}_q</span>  and storage of m  <span class="math">\\mathbb{F}_q</span> -elements is available, then finding the  <span class="math">\\mathbb{F}_q</span> -solutions requires on average 2m/3 additions, 2 multiplications, 1 squaring and 1 division in  <span class="math">\\mathbb{F}_q</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> First observe that if  <span class="math">B \\in \\mathbb{F}_q</span>  is a quadratic non-residue and  <span class="math">x^3 + Bx + C = 0</span>  has a solution in  <span class="math">\\mathbb{F}_q</span>  then all solutions are given by</p>

    <p class="text-gray-300"><span class="math">\${r_1, r_2, r_3} = {(-B)^{1/2}R(D), (-B)^{1/2}(R(D) + 1), (-B)^{1/2}(R(D) + 2)},</span>$</p>

    <p class="text-gray-300">where  <span class="math">D = C/(-B)^{3/2}</span>  and R(D) is a root of</p>

    <p class="text-gray-300"><span class="math">$x^3 - x + D</span>$</p>

    <p class="text-gray-300">Clearly, if  <span class="math">x^3 - x + D = 0</span>  has a solution  <span class="math">R(D) \\in \\mathbb{F}_q</span>  then it can be found trit-wise when a normal basis  <span class="math">\\{\\theta, \\theta^3, \\dots, \\theta^{3^{m-1}}\\}</span>  is used to represent  <span class="math">\\mathbb{F}_q</span>  as an m-dimensional vector space over  <span class="math">\\mathbb{F}_3</span> . Let us suppose that  <span class="math">R(D) = \\sum_{i=0}^{m-1} R_i \\theta^{3^i}</span>  and the m  <span class="math">\\mathbb{F}_q</span> -elements</p>

    <p class="text-gray-300"><span class="math">$\\theta^{3^i} = \\sum_{j=0}^{m-1} \\theta_{ij} z^j, \\ 0 \\le i &lt; m</span>$</p>

    <p class="text-gray-300">are precomputed and stored. Then a solution</p>

    <p class="text-gray-300"><span class="math">$R(D) = \\sum_{i=0}^{m-1} R_i \\sum_{j=0}^{m-1} \\theta_{ij} z^j</span>$</p>

    <p class="text-gray-300">to  <span class="math">x^3 - x + D = 0</span>  is obtained in  <span class="math">\\mathbb{F}_q</span> , at an average cost of 2m/3 additions in  <span class="math">\\mathbb{F}_q</span> .</p>

    <p class="text-gray-300">Now, in order to find a solution of  <span class="math">P_6(x) = c^3 x^3 + 2c^{2t+3}x + 2(c^{3(t+1)} + c^{2t} + 1) = 0</span>  in  <span class="math">\\mathbb{F}_q</span> , we first compute  <span class="math">B = 2c^{2t+3}/c^3 = 2c^{2t}</span>  and  <span class="math">C = 2(c^{3(t+1)} + c^{2t} + 1)/c^3</span> . Then</p>

    <p class="text-gray-300"><span class="math">$D = C/(-B)^{3/2} = (2(c^{3(t+1)} + c^{2t} + 1)/c^{3t+3})</span>$</p>

    <p class="text-gray-300">can be computed at a cost of 1 multiplication, 1 squaring and 1 division in  <span class="math">\\mathbb{F}_q</span>  (we ignore the cost of addition in  <span class="math">\\mathbb{F}_q</span>  and Frobenius operations). From our argument above we can find a solution of  <span class="math">x^3 - x + D = 0</span>  in  <span class="math">\\mathbb{F}_q</span>  at an average cost of 2m/3 additions in  <span class="math">\\mathbb{F}_q</span> . Hence, the solutions of  <span class="math">P_6(x) = 0</span>  are given by</p>

    <p class="text-gray-300"><span class="math">\${r_1, r_2, r_3} = {c^t R(D), c^t (R(D) + 1), c^t (R(D) + 2)},</span>$</p>

    <p class="text-gray-300">and can be obtained at an average cost of 2m/3 additions, 2 multiplications, 1 squaring and 1 division in  <span class="math">\\mathbb{F}_q</span> .</p>

    <p class="text-gray-300">From now on, we shall assume that  <span class="math">m \\equiv 5 \\pmod{12}</span>  and  <span class="math">c_0 = -1</span> .</p>

    <p class="text-gray-300"><strong>Theorem 7.2.</strong> Let C and D be compression and decompression maps, respectively, as described in Theorem 5.4. Then compression via C requires 1 division in  <span class="math">\\mathbb{F}_{q^3}</span>  and decompression via D requires on average 2m/3 additions, 2 multiplications, 1 squaring, 1 division in  <span class="math">\\mathbb{F}_q</span> , and 1 division in  <span class="math">\\mathbb{F}_{q^6}</span> , with a storage of m  <span class="math">\\mathbb{F}_q</span> -elements.</p>

    <p class="text-gray-300"><em>Proof.</em> The proof follows from Theorem 5.4 and Lemma 7.1.</p>

    <p class="text-gray-300">7.2. <strong>Exponentiation algorithms.</strong> Recall that in our compression method, given  <span class="math">g = g_0 + g_1 \\sigma \\in G_{\\ell} \\setminus \\{\\pm 1\\}</span> , we first compress g to  <span class="math">\\alpha = (g_0 + 1/g_1) = a + bw + cw^2</span> , by a factor 2, and then compress  <span class="math">\\alpha</span>  to (i, c),  <span class="math">i \\in \\{0, 1, 2\\}</span>  by a factor of 3. By Theorem 7.2, compressing g to (i, c), and decompressing (i, c) to  <span class="math">\\alpha</span>  (and to g) can be achieved at a negligible cost. In this context, we call  <span class="math">\\alpha</span>  a half-compressed element.</p>

    <p class="text-gray-300">We present two exponentiation algorithms to compute  <span class="math">g^e</span>  given  <span class="math">\\mathcal{C}(g) = (i,c)</span>  and  <span class="math">e \\in \\mathbb{Z}</span> . The first exponentiation algorithm, which we call HCTBE (Half-Compressed Torus-Based Exponentiation), partially decompresses (i,c) to  <span class="math">\\alpha</span>  and uses a multiplication formula for half-compressed elements. The output is then compressed to obtain  <span class="math">\\mathcal{C}(g^e)</span> . The second algorithm, which we call FDDE (Fully-Decompressed Direct Exponentiation Algorithm), fully decompresses (i,c) to g and uses a conventional cube-and-multiply exponentiation algorithm in  <span class="math">\\mathbb{F}_{q^6}</span> .</p>

    <p class="text-gray-300">7.2.1. The HCTBE algorithm. The algorithm makes use of the multiplication formula (2.4) to compute  <span class="math">C(g^e)</span> . If  <span class="math">g = g_0 + g_1 \\sigma</span> ,  <span class="math">h = h_0 + h_1 \\sigma \\in G_\\ell \\setminus \\{\\pm 1\\}</span>  are represented by  <span class="math">\\alpha = (g_0 + 1)/g_1</span> ,  <span class="math">\\beta = (h_0 + 1)/h_1 \\in \\mathbb{F}_{q^3}</span> , respectively, then we have</p>

    <p class="text-gray-300"><span class="math">$g \\cdot h = \\left(\\frac{\\alpha + \\sigma}{\\alpha - \\sigma}\\right) \\left(\\frac{\\beta + \\sigma}{\\beta - \\sigma}\\right)</span>$
<span class="math">$= \\frac{\\alpha\\beta + c_0 + (\\alpha + \\beta)\\sigma}{\\alpha\\beta + c_0 - (\\alpha + \\beta)\\sigma}.</span>$</p>

    <p class="text-gray-300">In other words, if the product of any two elements in  <span class="math">G_{\\ell}</span>  is computed by this formula then the result will be of the form</p>

    <p class="text-gray-300">(7.1)
<span class="math">$\\frac{x+y\\sigma}{x-y\\sigma}, \\text{ for some } x, y \\in \\mathbb{F}_{q^3}.</span>$</p>

    <p class="text-gray-300">In particular, given C(g) = (i, c) and  <span class="math">e \\in \\mathbb{Z}</span> , one can first decompress (i, c) to  <span class="math">\\alpha</span> , and then perform an exponentiation to compute  <span class="math">C(g^e)</span>  by using the formulas</p>

    <p class="text-gray-300">$$\\left(\\frac{x+y\\sigma}{x-y\\sigma}\\right)^{3} = \\frac{x^{3}+y^{3}c_{0}\\sigma}{x^{3}-y^{3}c_{0}\\sigma},
\\left(\\frac{\\alpha+\\sigma}{\\alpha-\\sigma}\\right)\\left(\\frac{x+y\\sigma}{x-y\\sigma}\\right) = \\frac{\\alpha x+yc_{0}+(\\alpha y+x)\\sigma}{\\alpha x+yc_{0}-(\\alpha y+x)\\sigma},
\\left(\\frac{\\alpha-\\sigma}{\\alpha+\\sigma}\\right)\\left(\\frac{x+y\\sigma}{x-y\\sigma}\\right) = \\frac{\\alpha x-yc_{0}+(\\alpha y-x)\\sigma}{\\alpha x-yc_{0}-(\\alpha y-x)\\sigma}$$</p>

    <p class="text-gray-300">in the <em>cube</em> and <em>multiply</em> steps of the exponentiation algorithm. Note that by (7.1) it suffices to only keep track of the numerator during the computations, and to do a single division in  <span class="math">\\mathbb{F}_{a^6}</span>  to obtain  <span class="math">g^e</span>  and finally its compressed value  <span class="math">\\mathcal{C}(g^e)</span> . Our discussion yields Algorithm 3.</p>

    <pre><code class="language-text">Input: C(g) and e
Output: C(g^e)
</code></pre>

    <pre><code class="language-text">1: Write e = \\sum_{i=0}^{s-1} b_i 3^i where b_i \\in \\{-1, 0, 1\\} and b_{s-1} = 1
 2: Decompress C(g) to \\alpha by using Theorem 5.4
 3: x \\leftarrow \\alpha, y \\leftarrow 1
 4: for i from s-2 down to 0 do
       x&#x27; \\leftarrow x^3, \\ y&#x27; \\leftarrow y^3 c_0
       if b_i = 1 then
           x&#x27; \\leftarrow \\alpha x + y c_0, \\ y&#x27; \\leftarrow (\\alpha y + x)
 7:
        else if b_i = -1 then
 8:
           x&#x27; \\leftarrow \\alpha x - y c_0, \\ y&#x27; \\leftarrow (\\alpha y - x)
 9:
       end if
10:
        x \\leftarrow x&#x27;, \\ y \\leftarrow y&#x27;
11:
12: end for
13: g&#x27; \\leftarrow (x + y\\sigma)/(x - y\\sigma)
14: Compress (g&#x27;) to C(g&#x27;) = (i&#x27;, c&#x27;), by using Theorem 5.4
15: Output (i&#x27;, c&#x27;)
</code></pre>

    <p class="text-gray-300">Since  <span class="math">c_0 = -1</span> , the cost of the cubing step (step 5) and the cost of the multiplication step (step 7 or step 9) in Algorithm 3 is approximately 2 cubings in  <span class="math">\\mathbb{F}_{q^3}</span>  and 2 multiplications in  <span class="math">\\mathbb{F}_{q^3}</span> , respectively.</p>

    <p class="text-gray-300">Remark 7.3. Granger, Page and Stam [5, Section 3.2] proposed an exponentiation algorithm that works in the quotient group  <span class="math">\\mathbb{F}_{q^6}^*/\\mathbb{F}_{q^3}^*</span>  where  <span class="math">q=3^m</span> , m is odd, and mimics the mixed addition method for point multiplication on elliptic curves. Algorithm 1 can be seen as analogous to their algorithm. The main difference is that they identify  <span class="math">g=g_0+g_1\\sigma</span>  with  <span class="math">\\alpha=g_0/g_1</span>  instead of  <span class="math">\\alpha=(g_0+1)/g_1</span>  and therefore their method cannot be directly adapted to obtain a fast exponentiation algorithm in  <span class="math">G_\\ell \\subset \\mathbb{F}_{q^6}^*</span> . In particular, it was reported in [5, Table 3] that exponentiation in  <span class="math">\\mathbb{F}_{q^6}^*/\\mathbb{F}_{q^3}^*</span>  is more efficient than exponentiation in  <span class="math">G_\\ell</span> . The HCTBE algorithm equalizes the efficiency of exponentiation algorithms in  <span class="math">G_\\ell</span>  and  <span class="math">\\mathbb{F}_{q^6}^*/\\mathbb{F}_{q^3}^*</span> .</p>

    <p class="text-gray-300">7.2.2. The FDDE algorithm. After decompressing C(g) = (i, b) to  <span class="math">g = g_0 + g_1 \\sigma</span> , we use a conventional cube-and-multiply exponentiation algorithm as described in Algorithm 4. Since</p>

    <p class="text-gray-300"><span class="math">$(x+y\\sigma)^3 = x^3 + y^3c_0\\sigma,</span>$</p>

    <p class="text-gray-300"><span class="math">$(g_0 + g_1\\sigma)(x+y\\sigma) = g_0x + g_1yc_0 + (g_0y + g_1x)\\sigma,</span>$</p>

    <p class="text-gray-300"><span class="math">$(g_0 - g_1\\sigma)(x+y\\sigma) = g_0x - g_1yc_0 + (g_0y - g_1x)\\sigma,</span>$</p>

    <p class="text-gray-300">each cubing step (step 5) in Algorithm 4 requires 2 cubings in  <span class="math">\\mathbb{F}_{q^3}</span> . Using Karatsuba's technique, each multiplication step (steps 7-8 or steps 10-11) requires 3 multiplications in  <span class="math">\\mathbb{F}_{q^3}</span>  (note that  <span class="math">c_0 = -1</span> ).</p>

    <p class="text-gray-300">7.2.3. A comparison with trace-based exponentiation. In [15], it was shown that it is possible to compress elements of  <span class="math">G_{\\ell}</span>  by a factor 6 by identifying an element  <span class="math">g \\in G_{\\ell}</span>  with its trace  <span class="math">\\operatorname{Tr}_{q^6,q}(g)</span> . Given  <span class="math">\\operatorname{Tr}_{q^6,q}(g)</span>  and an integer e, six exponentiation algorithms were proposed and analyzed in [8] to compute  <span class="math">\\operatorname{Tr}_{q^6,q}(g^e)</span> . The performance of these six algorithms were also compared with a previously-known exponentiation algorithm XTR&lt;sub&gt;3&lt;/sub&gt; in [15]. The algorithms are based on the following ideas:</p>

    <h2 id="sec-7" class="text-2xl font-bold">Algorithm 4 The FDDE exponentiation algorithm</h2>

    <p class="text-gray-300">Input: C(g) and eOutput:  <span class="math">C(g^e)</span></p>

    <pre><code class="language-text">1: Write e = \\sum_{i=0}^{s-1} b_i 3^i where b_i \\in \\{-1, 0, 1\\} and b_{s-1} = 1
 2: Decompress C(g) to g = g_0 + g_1 \\sigma by using Theorem 5.4
 3: x \\leftarrow g_0, y \\leftarrow g_1
 4: for i from s-2 down to 0 do
        x&#x27; \\leftarrow x^3, \\ y&#x27; \\leftarrow y^3 c_0
        if b_i = 1 then
 6:
           u_0 \\leftarrow (g_0 + g_1)(x&#x27; + y&#x27;), \\ u_1 \\leftarrow g_0 x&#x27;, \\ u_2 \\leftarrow g_1 y&#x27;, \\ u_3 \\leftarrow u_2 c_0
 7:
           x&#x27; \\leftarrow u_1 + u_3, \\ y&#x27; \\leftarrow u_0 - (u_1 + u_2)
 8:
        else if b_i = -1 then
 9:
           u_0 \\leftarrow (g_0 - g_1)(x&#x27; + y&#x27;), \\ u_1 \\leftarrow g_0 x&#x27;, \\ u_2 \\leftarrow -g_1 y&#x27;, \\ u_3 \\leftarrow u_2 c_0
10:
           x&#x27; \\leftarrow u_1 + u_3, \\ y&#x27; \\leftarrow u_0 - (u_1 + u_2)
11:
12:
        x \\leftarrow x&#x27;, \\ y \\leftarrow y&#x27;
13:
14: end for
15: q&#x27; \\leftarrow (x + y\\sigma)
16: Compress (g&#x27;) to \\mathcal{C}(g&#x27;) = (i&#x27;, c&#x27;), by using Theorem 5.4
17: Output (i&#x27;,c&#x27;)
</code></pre>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) Use  <span class="math">\\operatorname{Tr}_{a^6,a}(g)</span>  directly and perform computations in  <span class="math">\\mathbb{F}_q</span>  (Algorithm 3 in [8]).</li>
      <li>(2) First decompress  <span class="math">\\operatorname{Tr}_{q^6,q}(g)</span>  to  <span class="math">\\operatorname{Tr}_{q^6,q^3}(g)</span> . Then use  <span class="math">\\operatorname{Tr}_{q^6,q^3}(g)</span>  directly and perform computations in  <span class="math">\\mathbb{F}_{q^3}</span>  (Algorithm 4 in [8]).</li>
      <li>(3) First decompress  <span class="math">\\operatorname{Tr}_{q^6,q}(g)</span>  to g and perform computations in  <span class="math">\\mathbb{F}_{q^6}</span>  (Algorithm DDE in [8]).</li>
      <li>(4) First decompress  <span class="math">\\operatorname{Tr}_{q^6,q}(g)</span>  to  <span class="math">\\operatorname{Tr}_{q^6,q^2}(g)</span> . Then use  <span class="math">\\operatorname{Tr}_{q^6,q^2}(g)</span>  to construct a copy of  <span class="math">\\mathbb{F}_{q^6}</span>  based on the minimal polynomial of g over  <span class="math">\\mathbb{F}_{q^2}</span> , and perform computations in  <span class="math">\\mathbb{F}_{q^6}</span>  (Algorithm BPV-I in [8]).</li>
      <li>(5) First decompress  <span class="math">\\operatorname{Tr}_{q^6,q}(g)</span>  to  <span class="math">\\operatorname{Tr}_{q^6,q^3}(g)</span> . Then use  <span class="math">\\operatorname{Tr}_{q^6,q^3}(g)</span>  to construct a copy of  <span class="math">\\mathbb{F}_{q^6}</span>  based on the minimal polynomial of g over  <span class="math">\\mathbb{F}_{q^3}</span> , and perform computations in  <span class="math">\\mathbb{F}_{q^6}</span>  (Algorithm BPV-II in [8]).</li>
      <li>(6) Use  <span class="math">\\operatorname{Tr}_{q^6,q}(g)</span>  to construct a copy of  <span class="math">\\mathbb{F}_{q^6}</span>  based on the minimal polynomial of g over  <span class="math">\\mathbb{F}_q</span> , and perform computations in  <span class="math">\\mathbb{F}_{q^6}</span>  (Algorithm BPV-III in [8]).</li>
      <li>(7) First decompress  <span class="math">\\operatorname{Tr}_{q^6,q}(g)</span>  to  <span class="math">\\operatorname{Tr}_{q^6,q^2}(g)</span> . Then use  <span class="math">\\operatorname{Tr}_{q^6,q^2}(g)</span>  directly and perform computations in  <span class="math">\\mathbb{F}_{q^2}</span>  (Algorithm XTR&lt;sub&gt;3&lt;/sub&gt; in [15]).</li>
    </ul>

    <p class="text-gray-300">The algorithms based on (1), (4), (6) and (7) are overall faster than the algorithms based on (2), (3) and (5) because of the expensive decompression operations required in the latter algorithms. In particular, it was reported in [8] that XTR&lt;sub&gt;3&lt;/sub&gt; in [15] can be further sped up and it is the fastest exponentiation algorithm for general bases. However, if decompression can be precomputed, for example when the base is fixed, then the algorithm based on (3) is the fastest.</p>

    <p class="text-gray-300">Note that by Theorem 7.2, given C(g) for some  <span class="math">g \\in G_{\\ell} \\setminus \\{\\pm 1\\}</span> , one can recover g (and also  <span class="math">\\operatorname{Tr}_{q^6,q}(g)</span> ,  <span class="math">\\operatorname{Tr}_{q^6,q^2}(g)</span>  and  <span class="math">\\operatorname{Tr}_{q^6,q^3}(g)</span> ) at a negligible cost. Hence, it is more advantageous to use C(g) instead of  <span class="math">\\operatorname{Tr}_{q^6,q}(g)</span> . For example, using C(g), we can obtain faster exponentiation algorithms than the trace-based exponentiation algorithms in the case of a general base  <span class="math">\\operatorname{Tr}_{q^6,q}(g)</span> , by simply computing  <span class="math">\\operatorname{Tr}_{q^6,q}(g)</span>  from C(g) and adapting an algorithm based on (3).</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">8. A COMPARISON OF EXPONENTIATION ALGORITHMS</h3>

    <p class="text-gray-300">In this section, we estimate the running times of the exponentiation algorithms discussed in Sections 6.2 and 7.2, and compare them with the fastest previously-known exponentiation algorithms. We consider the case of a general base, C(g) or  <span class="math">\\text{Tr}_{q^k,q}(g)</span> , which is the most interesting case because when the base is fixed we may ignore the cost of obtaining one of C(g) and  <span class="math">\\text{Tr}_{q^k,q}(g)</span>  from the other, and hence obtain an equivalent performance in torus-based and trace-based exponentiation algorithms.</p>

    <p class="text-gray-300">We denote by  <span class="math">C_i</span> ,  <span class="math">M_i</span> , and  <span class="math">S_i</span>  the operations of cubing, multiplication, and squaring in  <span class="math">\\mathbb{F}_{q^i}</span>  for i = 1, 2, 3. We assume that  <span class="math">S_2 = 2S_1</span>  for characteristic two,  <span class="math">C_3 = 3C_1</span>  for characteristic three, and also assume, using Karatsuba's technique, that  <span class="math">M_2 = 3M_1</span>  and  <span class="math">M_3 = 6M_1</span> .</p>

    <p class="text-gray-300">Note that the HCTBE and FDDE algorithms can easily be modified to work with window NAF techniques. In particular, we assume that the width-w radix-2 and radix-3 NAF representation of the exponent e are used in for the characteristic-two and the characteristic-three cases, respectively. Note that width-w radix-2 and radix-3 NAF representations of e contain on average  <span class="math">\\log_2 e/(w+1)</span>  and  <span class="math">2\\log_3 e/(2w+1)</span>  nonzero digits, respectively; see for example [18].</p>

    <p class="text-gray-300">The estimated costs of the exponentiation algorithms are presented in Table 1. In our analysis, we ignore the compression/decompression costs and also the precomputation costs required for window NAF methods as they are negligible comparing to the overall cost of algorithms.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Table 1. Comparison of exponentiation</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">algorithms for factor-4 and factor-6</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">compression in the case of a general base.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">The exponent is <span class="math">e</span> .</td>
          </tr>
        </tbody>
      </table>
    </div>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Algorithms</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Main Loop</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Characteristic-two fields</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Algorithm 3 in [7]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(3.19M_1)\\log_2 e</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FDDE</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(4S_1 + \\frac{9}{(w+1)}M_1)\\log_2 e</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">HCTBE</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(4S_1 + \\frac{6}{(w+1)}M_1)\\log_2 e</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Characteristic-three fields</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">XTR &lt;sub&gt;3&lt;/sub&gt; in [15]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(3M_1)\\log_2 e</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FDDE</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(6C_1 + \\frac{36}{(2w+1)}M_1)\\log_3 e</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">HCTBE</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(6C_1 + \\frac{24}{(2w+1)}M_1)\\log_3 e</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Assuming that  <span class="math">S_1</span>  and  <span class="math">C_1</span>  are essentially free in characteristic-two and characteristic-three fields, respectively, and setting w = 3, we can estimate the cost of FDDE as  <span class="math">(2.25M_1)\\log_2 e</span> , and the cost of HCTBE as  <span class="math">(1.5M_1)\\log_2 e</span>  in characteristic-two fields. Similarly, the cost of FDDE and HCTBE in characteristic-three fields can be approximated as  <span class="math">(3.24M_1)\\log_2 e</span>  and  <span class="math">(2.16M_1)\\log_2 e</span> , respectively.</p>

    <p class="text-gray-300">Therefore, if we require that the input to an exponentiation algorithm and the output of the algorithm are the compressed representation of g and  <span class="math">g^e</span> , it seems best to compress g to  <span class="math">\\mathcal{C}(g)</span>  by a factor of 4 or 6, and to use the HCTBE algorithms to compute the factor-4 or factor-6 compressed representation  <span class="math">\\mathcal{C}(g^e)</span>  of  <span class="math">g^e</span> . It also seems that the HCTBE algorithms outperform the fastest previously-known exponentiation algorithms in  <span class="math">G_\\ell</span> . The reason is that compression/decompression costs in the HCTBE algorithms are negligible and that each multiplication step in the HCTBE algorithm in characteristic-two requires  <span class="math">6M_1</span>  whereas it would require  <span class="math">9M_1</span>  in a conventional exponentiation algorithm adapting Karatsuba's method. Similarly, each multiplication step in the HCTBE algorithm in characteristic-three requires  <span class="math">12M_1</span>  whereas it would require  <span class="math">18M_1</span>  in a conventional exponentiation algorithm adapting Karatsuba's method (see also Remark 7.3).</p>

    <p class="text-gray-300">To be more concrete, we list the expected running times of the six exponentiation algorithms in a particular setting in Table 2 based on the estimates given in Table 1. For the 128-bit security level, in the characteristic-two case we let  <span class="math">q = 2^{1223}</span>  and  <span class="math">t = 2^{612}</span> . Then  <span class="math">q + 1 + t = 5\\ell</span>  where  <span class="math">\\ell</span>  is a 1221-bit prime. We will ignore the cost  <span class="math">S_1</span> . In the characteristic-three case, we let  <span class="math">q = 3^{509}</span>  and  <span class="math">t = 3^{255}</span> . Then  <span class="math">q + 1 - t = 7\\ell</span>  where  <span class="math">\\ell</span>  is an 804-bit prime. We will ignore the cost  <span class="math">C_1</span> . In both cases, we choose w = 3.</p>

    <p class="text-gray-300">TABLE 2. Comparison of exponentiation algorithms for factor-4 and factor-6 compression in the case of a general base at the 128-bit security level. The exponent is an 1221-bit integer in the characteristic-two case, and an 804-bit integer in the characteristic-three case.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Algorithms</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Main Loop</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">A characteristic-two field</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Algorithm 3 in [7]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">3895M_1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FDDE</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2747M_1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">HCTBE</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">1831M_1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">A characteristic-three field</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">XTR &lt;sub&gt;3&lt;/sub&gt; in [15]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2412M_1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FDDE</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2609M_1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">HCTBE</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">1739M_1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">9. Concluding remarks</h3>

    <p class="text-gray-300">We showed that by building on torus-based compression techniques, it is possible to compress elements in  <span class="math">G_{\\ell}</span>  by a factor of 4 when  <span class="math">|G_{\\ell}| = \\ell = q + 1 \\pm t</span> ,  <span class="math">q = 2^m</span>  and  <span class="math">t = \\sqrt{2q}</span> ; and by a factor of 6 when  <span class="math">|G_{\\ell}| = \\ell = q + 1 - t</span> ,  <span class="math">q = 3^m</span>  and  <span class="math">t = \\sqrt{3q}</span> . Our methods achieve the best possible compression ratio in  <span class="math">G_{\\ell}</span> , and moreover have the feature that the compression and decompression maps are computable at a negligible cost. We discussed several exponentiation algorithms and, in particular, showed that HCTBE outperforms the fastest exponentiation algorithms in both the characteristic-two and the characteristic-three cases.</p>

    <p class="text-gray-300">We note that the pairing values of bilinear pairings derived from supersingular elliptic curves of embedding degrees 4 and 6 over finite fields of characteristic two and three, and derived from supersingular hyperelliptic curves of embedding degrees 12 over finite fields of characteristic two, lie in  <span class="math">G_{\\ell}</span>  for a suitable choice of parameters. Therefore, our techniques can be easily incorporated into pairing-based protocols that require exponentiations or products of pairings; examples of such protocols include Scott's identity-based key agreement protocol [14] and Waters signature scheme [21].</p>

    <p class="text-gray-300">Our compression method compresses  <span class="math">g \\in G_{\\ell}</span>  to an element  <span class="math">\\mathcal{C}(g)</span>  in  <span class="math">\\mathbb{F}_q</span> . However, given  <span class="math">\\mathcal{C}(g)</span>  and  <span class="math">e \\in \\mathbb{Z}</span> , all the exponentiation algorithms to compute  <span class="math">\\mathcal{C}(g^e)</span>  first decompresses  <span class="math">\\mathcal{C}(g)</span>  (at least partially), and then exponentiate. It is natural to ask if one can devise a multiplication formula for  <span class="math">g, h \\in G_{\\ell}</span>  which computes  <span class="math">\\mathcal{C}(g) * \\mathcal{C}(h) = \\mathcal{C}(gh)</span>  directly in  <span class="math">\\mathbb{F}_q</span> .</p>

    <p class="text-gray-300">The author would like to thank Alfred Menezes for his careful reading of the earlier drafts of this paper and for his corrections and suggestions.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>[1] E. Brier and M. Joye. Weirstra elliptic curves and side channel attacks.  Public Key Cryptography PKC 2002, Lecture Notes In Computer Science, 2274:335345, 2002.</li>
      <li>[2] A. Brouwer, R. Pellikaan, and E. Verheul. Doing more with fewer bits. Advances in Cryptology ASI-ACRYPT '99, Lecture Notes in Computer Science, 1716:321332, 1999.</li>
      <li>[3] K. Giuliani and G. Gong. Analogues to the Gong-Harn and XTR cryptosystems. Technical Report CORR 2003-34, University of Waterloo, 2003. Available at http://www.cacr.math.uwaterloo.ca/techreports/ 2003/corr2003-34.ps.</li>
      <li>[4] G. Gong and L. Harn. Public-key cryptosystems based on cubic finite field extensions. IEEE Transactions on Information Theory, 45:26012605, 1999.</li>
      <li>[5] R. Granger, D. Page, and M. Stam. On small characteristic algebraic tori in pairing-based cryptography. LMS Journal of Computation and Mathematics, 9:6485, 2004.</li>
      <li>[6] D. Hankerson, A. Menezes, and S. Vanstone. Guide to elliptic curve cryptography. Springer-Verlag, New York, USA, 2004.</li>
      <li>[7] K. Karabina. Double-exponentiation in factor-4 groups and its applications. Twelfth IMA International Conference on Cryptography and Coding, Lecture Notes in Computer Science, 5921:336350, 2009.</li>
      <li>[8] K. Karabina. Factor-4 and 6 compression of cyclotomic subgroups of F  &lt;sup&gt;2&lt;/sup&gt;4&lt;sup&gt;m&lt;/sup&gt; and &lt;sup&gt;F&lt;/sup&gt;  &lt;sup&gt;3&lt;/sup&gt;6m. Journal of Mathematical Cryptology, 4:142, 2010.</li>
      <li>[9] A. Lenstra and E. Verheul. The XTR public key system. Advances in Cryptology CRYPTO 2000, Lecture Notes in Computer Science, 1880:119, 2000.</li>
      <li>[10] J. Lopez and R. Dahab. Fast multiplication on elliptic curves over GF(2&lt;sup&gt;m&lt;/sup&gt;) without precomputation. Cryptographic Hardware and Embedded Systems, Lecture Notes In Computer Science, 1717:316327, 1999.</li>
      <li>[11] P. Montgomery. Speeding the Pollard and elliptic curve methods of factorization. Mathematics of Computation, 48:243264, 1987.</li>
      <li>[12] K. Rubin and A. Silverberg. Torus-based cryptography. Advances in Cryptology CRYPTO 2003, Lecture Notes in Computer Science, 2729:349365, 2003.</li>
      <li>[13] K. Rubin and A. Silverberg. Compression in finite fields and torus-based cryptography. SIAM Journal on Computing, 37:14011428, 2008.</li>
      <li>[14] M. Scott. Authenticated ID-based key exchange and remote log-in with simple token and PIN number. Cryptology ePrint Archive, Report 2002/164, 2002. http://eprint.iacr.org/2002/164.</li>
      <li>[15] M. Shirase, D. Han, Y. Hibin, H. Kim, and T. Takagi. A more compact representation of XTR cryptosystem. IEICE Transactions on Fundamentals of Electronics, Communications and Computer Sciences, E91-A:28432850, 2008.</li>
      <li>[16] P. Smith and C. Skinner. A public-key cryptosystem and a digital signature system based on the Lucas function analogue to discrete logarithms. Advances in Cryptology  ASIACRYPT '94, Lecture Notes In Computer Science, 917:357364, 1994.</li>
      <li>[17] M. Stam and A. Lenstra. Speeding up XTR. Advances in Cryptology ASIACRYPT 2001, Lecture Notes in Computer Science, 2248:125143, 2001.</li>
      <li>[18] T. Takagi, S. Yen, and B. Wu. Radix-r non-adjacent form. Information Security ISC 2004, Lecture Notes In Computer Science, 3225:99110, 2004.</li>
      <li>[19] M. van Dijk, R. Granger, D. Page, K. Rubin, A. Silverberg, M. Stam, and D. Woodruff. Practical cryptography in high dimensional tori. Advances in Cryptology  EUROCRYPT 2005, Lecture Notes in Computer Science, 3494:234250, 2005.</li>
      <li>[20] M. van Dijk and D. Woodruff. Asymptotically optimal communication for torus-based cryptography. Advances in Cryptology  CRYPTO 2004, Lecture Notes in Computer Science, 3152:151178, 2004.</li>
      <li>[21] B. Waters. Efficient identity-based encryption without random oracles. Advances in Cryptology EURO-CRYPT 2005, Lecture Notes in Computer Science, 3494:114127, 2005.</li>
    </ul>

    <p class="text-gray-300">Dept. of Combinatorics and Optimization, University of Waterloo, Waterloo, Ontario, Canada N2L 3G1</p>

    <p class="text-gray-300">E-mail address: kkarabin@uwaterloo.ca</p>

`;
---

<BaseLayout title="2. A REVIEW OF TORUS-BASED COMPRESSION (2010/525)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2010 &middot; eprint 2010/525
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="2-a-review-of-torus-based-compression-2010" />
  </article>
</BaseLayout>
