---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2002/161';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Practical  Verifiable Encryption and Decryption of Discrete Logarithms';
const AUTHORS_HTML = 'Jan Camenisch, Victor Shoup';

const CONTENT = `    <p class="text-gray-300">Practical Verifiable Encryption and Decryption of Discrete Logarithms*</p>

    <p class="text-gray-300">Jan Camenisch† Victor Shoup‡</p>

    <p class="text-gray-300">August 22, 2003</p>

    <p class="text-gray-300">Abstract</p>

    <p class="text-gray-300">This paper addresses the problem of designing practical protocols for proving properties about encrypted data. To this end, it presents a variant of the new public key encryption of Cramer and Shoup based on Paillier's decision composite residuosity assumption, along with efficient protocols for verifiable encryption and decryption of discrete logarithms (and more generally, of representations with respect to multiple bases). This is the first verifiable encryption system that provides chosen ciphertext security and avoids inefficient cut-and-choose proofs. The presented protocols have numerous applications, including key escrow, optimistic fair exchange, publicly verifiable secret and signature sharing, universally composable commitments, group signatures, and confirmer signatures.</p>

    <p class="text-gray-300">Keywords. Verifiable encryption, verifiable decryption, adaptive chosen ciphertext security, public key encryption.</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">This paper concerns itself with the general problem of proving properties about encrypted data. In the case of public-key encryption, which is the setting in which we are interested here, there are two parties who are in a position to prove some property to another party about an encrypted message — namely, the party who created the ciphertext, and the party who holds the secret key. A protocol in which the encryptor is the prover is a verifiable encryption protocol, while a protocol in which the decryptor is the prover is a verifiable decryption protocol.</p>

    <p class="text-gray-300">For example, suppose a party <span class="math">T</span> has a public key/secret key pair <span class="math">(\\mathsf{PK},\\mathsf{SK})</span> for a public key encryption scheme. Party <span class="math">A</span> might encrypt, using <span class="math">T</span>'s public key <span class="math">\\mathsf{PK}</span>, a secret message <span class="math">m</span> that satisfies a publicly-defined property <span class="math">\\theta</span>, and give the resulting ciphertext <span class="math">\\psi</span> to another party <span class="math">B</span>. The latter party might demand that <span class="math">A</span> prove that <span class="math">\\psi</span> is an encryption of a message satisfying property <span class="math">\\theta</span>. Ideally, the proof should be "zero knowledge," so that no unnecessary information about <span class="math">m</span> is leaked to <span class="math">B</span> as part of the proof. Another party <span class="math">B&#x27;</span> might obtain the ciphertext <span class="math">\\psi</span>, and may request that <span class="math">T</span> prove or disprove that <span class="math">\\psi</span> decrypts under <span class="math">\\mathsf{SK}</span> to a message <span class="math">m</span> satisfying a publicly-defined property <span class="math">\\theta&#x27;</span>; a special case of this would be the situation where <span class="math">T</span> simply gives <span class="math">m</span> to <span class="math">B&#x27;</span>, and proves to <span class="math">B&#x27;</span> that the decryption was performed correctly. Again, ideally, the proof should be "zero knowledge."</p>

    <p class="text-gray-300">Now, if one expects to obtain reasonably practical protocols for this problem, it seems necessary to restrict the type of properties that the protocols should work with. In this paper, we consider</p>

    <p class="text-gray-300">*An extended abstract of this paper appears in the proceedings of Crypto 2003.</p>

    <p class="text-gray-300">†IBM Research, Zurich Research Laboratory, CH-8803 Rüschlikon, jca@zurich.ibm.com</p>

    <p class="text-gray-300">‡Courant Institute, New York University, shoup@cs.nyu.edu</p>

    <p class="text-gray-300">only properties related to the discrete logarithm problem. The message <span class="math">m</span> encrypted by <span class="math">A</span> above is the discrete logarithm of an element <span class="math">\\delta</span> with respect to a base <span class="math">\\gamma</span>, and <span class="math">A</span> proves to <span class="math">B</span> that <span class="math">\\psi</span> is an encryption <span class="math">\\log_{\\gamma}\\delta</span> under <span class="math">T</span>’s public key <span class="math">\\mathsf{PK}</span>. Here, the common inputs to <span class="math">A</span> and <span class="math">B</span> in the proof protocol are <span class="math">\\mathsf{PK}</span>, <span class="math">\\psi</span>, <span class="math">\\delta</span>, and <span class="math">\\gamma</span>. Similarly, when a party <span class="math">B^{\\prime}</span> presents <span class="math">\\psi</span> to <span class="math">T</span> for decryption, <span class="math">T</span> may state and prove whether or nor <span class="math">\\psi</span> decrypts to <span class="math">\\log_{\\gamma}\\delta</span>, or alternatively, <span class="math">T</span> may give the decryption of <span class="math">\\psi</span> to <span class="math">B^{\\prime}</span>, and simply prove that the decryption was performed correctly. We also consider the obvious generalizations from discrete logarithms to representations with respect to several bases — i.e., proving that a ciphertext is an encryption of <span class="math">(m_{1},\\ldots,m_{k})</span> such that <span class="math">\\delta=\\gamma_{1}^{m_{1}}\\cdots\\gamma_{k}^{m_{k}}</span>.</p>

    <p class="text-gray-300">Although the restriction to properties related to the discrete logarithm problem may seem excessive, it turns out (as we discuss in some detail below) that protocols for proving such properties have many useful applications in cryptography, including key escrow, optimistic fair exchange, publicly verifiable secret and signature sharing, universally composable commitments, group signatures, and confirmer signatures. One reason why this restriction is not really so excessive is because in the past few years, efficient protocols for proving numerous properties about committed values — using Pedersen’s commitment scheme <em>[x20]</em> and generalizations to groups of unknown order — have been developed (c.f., <em>[x10, x12, x3]</em>); combining these protocols with our scheme for verifiable encryption of a representation (i.e., an opening of a commitment), we immediately get corresponding protocols for proving such properties about encrypted values.</p>

    <h5 id="sec-1" class="text-base font-semibold mt-4">Our contribution</h5>

    <p class="text-gray-300">The contribution of this paper is to present and analyze a practical public-key encryption scheme, together with a suite of practical proof protocols for the properties related to the discrete logarithm problem outlined above. The encryption scheme is a variant of the new public key encryption scheme of Cramer and Shoup <em>[x13]</em> based on Paillier’s decision composite residuosity assumption <em>[x21]</em>, suitably modified so as to support our proof protocols. The proof protocols are all of the usual, three move “<span class="math">\\Sigma</span>-protocol” type <em>[x4]</em>, satisfying the usual, and very strong conditions of special honest verifier zero knowledge and special soundness. We note that any such protocol can be easily and efficiently converted into a “real” zero-knowledge protocol using well known techniques, e.g., <em>[x5]</em>. Our scheme for verifiable encryption of discrete logarithms is the first one that provides chosen ciphertext security and avoids inefficient cut-and-choose proofs. Our scheme for verifiable decryption of discrete logarithms is the first practical protocol of its kind. Our system is very flexible, in that a single public key for the encryption scheme can be used with many different groups; that is, users can choose their own (arbitrary and varied) groups for discrete logarithms, subject only to some (reasonable) size constraints. As pointed out in <em>[x18, x6, x2]</em> such <em>separability</em> in system design is highly desirable in practice. Although our protocols do not rely on the random oracle heuristic, we hasten to point out that even allowing this heuristic, our protocols are much more efficient than previously known protocols for these problems.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">1.1 Applications</h3>

    <p class="text-gray-300">In this section, we outline some of the numerous applications of verifiable encryption and decryption of discrete logarithms and representations. For all of them our protocols, used together with the existing solutions, either yield more efficient solutions or add security against chosen ciphertext attacks, which is often crucial.</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">1.1.1 Key Escrow</h4>

    <p class="text-gray-300">Party <span class="math">A</span> may encrypt its own secret key for an asymmetric cryptographic primitive under the public key of a trusted third party <span class="math">T</span>, and present to a second party <span class="math">B</span> the ciphertext <span class="math">\\psi</span> and a proof that <span class="math">\\psi</span></p>

    <p class="text-gray-300">is indeed an encryption of it’s secret key. This problem area has attracted a good deal of attention, with specific schemes being proposed in <em>[x21, x1, x27, x1, x16]</em>.</p>

    <p class="text-gray-300">Now, if <span class="math">A</span>’s secret key is, say, a key for a discrete log based scheme, such as Schnorr or DSS signatures or ElGamal encryption, we can use our verifiable encryption protocol directly. We note that for this and other applications, it is important to be able to bind some public data, called a label, to the ciphertext at both encryption and decryption time. In this application, user <span class="math">A</span> would attach a label to <span class="math">\\psi</span> that indicates the conditions under which <span class="math">\\psi</span> should be decrypted, e.g., <span class="math">A</span>’s identity and perhaps an expiration date. The definition of chosen ciphertext security ensures that decrypting a ciphertext under any label different from the label used to create the ciphertext reveals no information about the original encrypted message.</p>

    <p class="text-gray-300">Even though <span class="math">T</span> is “trusted,” it might be nice to minimize the trust we need to place in <span class="math">T</span>. To this end, verifiable decryption comes in handy — we can force <span class="math">T</span> to prove that it performed the decryption operation correctly. Of course, this does not prevent <span class="math">T</span> from misbehaving in other ways, such as divulging a secret key to an unauthorized party.</p>

    <p class="text-gray-300">If <span class="math">A</span>’s secret key is for a factoring based scheme, one can still use our protocol for verifiable encryption of a representation. One can use Pedersen’s commitment scheme to commit to some quantity related to the secret key, and then use an appropriate protocol to prove that the committed value is indeed the right one, together with our protocol to prove that the encryption contains an opening of the commitment. The quantity committed to could be the factorization of an RSA modulus, the decryption exponent of an RSA scheme, or an appropriate root in a Guillou-Quisquater scheme — there are protocols for proving that a committed value is of such a form <em>[x10, x12, x13, x14, x15]</em>.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">1.1.2 Optimistic Fair Exchange</h4>

    <p class="text-gray-300">Two parties <span class="math">A</span> and <span class="math">B</span> want to exchange some valuable digital data (e.g., signatures on a contract, e-cash), but in a fair way: either each party obtains the other’s data, or neither party does. One way to do this is by employing a trusted third party <span class="math">T</span>, but, for the sake of efficiency, with <span class="math">T</span> only involved in crisis situations. One approach to this problem is to have both parties verifiably encrypt to each other their data under <span class="math">T</span>’s public key, and only then to reveal their data to each other — if one party backs out unexpectedly, the other can go to <span class="math">T</span> to obtain the required data. The general problem of optimistic fair exchange has been extensively studied, c.f., <em>[x1, x2, x3, x4, x5]</em>, while the solution using verifiable encryption was studied in detail in <em>[x1]</em>.</p>

    <p class="text-gray-300">Our scheme for verifiable encryption may be used directly to efficiently implement the fair exchange of Schnorr or DSS signatures. As outlined in <em>[x1]</em>, if the public key of the Schnorr signature scheme consists of the base <span class="math">\\gamma</span> and the group element <span class="math">\\alpha=\\gamma^{x}</span>, and <span class="math">A</span> has a signature on a message <span class="math">m</span> of the form <span class="math">(\\beta,c,s)</span>, where <span class="math">\\beta=\\gamma^{r}</span>, <span class="math">c=H(\\beta,m)</span>, <span class="math">s=r+xc\\bmod\\rho</span>, and <span class="math">\\rho</span> is the group size, then <span class="math">A</span> gives to <span class="math">B</span> the triple <span class="math">(\\beta,c,\\delta)</span>, where <span class="math">\\delta=\\gamma^{s}</span>, along with an encryption <span class="math">\\psi</span> of <span class="math">s</span> under <span class="math">T</span>’s public key, and proves to <span class="math">B</span> that <span class="math">\\psi</span> is an encryption of <span class="math">\\log_{\\gamma}\\delta</span>. In addition to checking the proof that <span class="math">\\psi</span> is a correct encryption of <span class="math">\\log_{\\gamma}\\delta</span>, <span class="math">B</span> also checks that <span class="math">\\delta=\\beta\\gamma^{c}</span>; with these checks, <span class="math">B</span> can be sure that if the need arises, <span class="math">\\psi</span> can be decrypted so as to obtain a signature on <span class="math">m</span>. As argued in <em>[x1]</em>, this technique of reducing a signature to a discrete logarithm does not make it any easier for anyone to forge a signature. Moreover, as discussed in <em>[x1]</em>, similar techniques can be used to facilitate the fair exchange of other items, such as electronic cash.</p>

    <p class="text-gray-300">As in the escrow application, the label mechanism plays a crucial role here, helping to enforce the logic of the exchange protocol, and a verifiable decryption protocol may be used to hold <span class="math">T</span>’s feet to the fire.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Stadler <em>[x18]</em> introduced the notion of publicly verifiable secret sharing. Here, one party, the dealer, shares a secret with several proxies <span class="math">P_{1},\\ldots,P_{n}</span>, in such a way that a third party (other than the dealer and the proxies) can verify that the sharing was done correctly. This can be done quite simply by sharing the secret using Shamir’s secret sharing scheme: the dealer encrypts <span class="math">P_{i}</span>’s share under <span class="math">P_{i}</span>’s public key, and gives to the third party commitments to these shares, along with commitments to the coefficients of the blinding polynomial, and all of the ciphertexts, and proves to the third party that the ciphertexts encrypt openings of the commitments to the shares. As the openings to the commitments are just discrete logarithms, verifiable encryption of discrete logarithms is just the right tool.</p>

    <p class="text-gray-300">Using the notion discussed above above for reducing a signature to a discrete logarithm, one can easily implement a (publicly) verifiable signature sharing scheme <em>[x5, x7]</em> for Schnorr and DSS signatures.</p>

    <p class="text-gray-300">These two applications of verifiable encryption were discussed in <em>[x6]</em>.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">1.1.4 Universally Composable Commitments</h4>

    <p class="text-gray-300">The notion of universally composable (UC) commitments, introduced by Canetti and Fischlin <em>[x5]</em>, is a very strong notion of security for a commitment scheme. It basically says that commitments in the real world act like commitments in an ideal world in which, when a party <span class="math">A</span> commits to a value <span class="math">x</span> to a party <span class="math">B</span>, <span class="math">A</span> presents <span class="math">x</span> to an idealized trusted party <span class="math">T</span> (that does not exist in the real world), and when <span class="math">A</span> opens the commitment, <span class="math">T</span> gives <span class="math">x</span> to <span class="math">B</span>. In the ideal world, no information about <span class="math">x</span> is revealed to <span class="math">B</span> prior to opening, and <span class="math">A</span> is forced to fix the value committed to when the commitment protocol runs.</p>

    <p class="text-gray-300">This notion of security is so strong, in fact, that it can only be realized in the common reference string (CRS) model, where all parties have access to a string that was generated by a trusted party according to some prescribed distribution. In the CRS model, the simulator <span class="math">S</span> in the ideal world is given the privilege of generating the common reference string, and so <span class="math">S</span> may know some “side information” related to the common reference string that is not available to anyone in the real world.</p>

    <p class="text-gray-300">Verifiable encryption of a representation may be used to implement UC commitments in the CRS model, as follows. The CRS consists of a public key for the encryption scheme, along with bases <span class="math">\\gamma_{1}</span> and <span class="math">\\gamma_{2}</span> for some suitable group. When <span class="math">A</span> commits a value <span class="math">x</span> to <span class="math">B</span>, he creates a Pedersen commitment <span class="math">C=\\gamma_{1}^{x}\\gamma_{2}^{x}</span>, and an encryption <span class="math">\\psi</span> of the representation <span class="math">(x,r)</span> of <span class="math">C</span> with respect to <span class="math">(\\gamma_{1},\\gamma_{2})</span>. <span class="math">A</span> then gives <span class="math">(C,\\psi)</span> to <span class="math">B</span>, and proves to <span class="math">B</span> that <span class="math">\\psi</span> indeed decrypts to a representation of <span class="math">C</span>. In order to satisfy the definition of security for UC commitments, and in particular, to prevent “man in the middle attacks,” a label containing <span class="math">A</span>’s identity should be attached to <span class="math">\\psi</span>.</p>

    <p class="text-gray-300">The reason this is secure is that the simulator <span class="math">S</span> in the CRS model knows the secret key to the encryption scheme, which allows him to “extract” values committed by corrupted parties, and <span class="math">S</span> knows the discrete logarithm of <span class="math">\\gamma_{2}</span> with respect to <span class="math">\\gamma_{1}</span>, which allows him to “equivocate” values committed by honest parties. The proof that <span class="math">\\psi</span> is an encryption of a representation <span class="math">C</span> ensures that the value extracted by the simulator at commitment time agrees with the value revealed at opening time.</p>

    <p class="text-gray-300">The details of this construction and security proof are the subject of a forthcoming paper.</p>

    <p class="text-gray-300">#</p>

    <p class="text-gray-300">1.1.5 Confirmer Signatures</p>

    <p class="text-gray-300">In a confirmer signature scheme, a notion introduced in <em>[x10]</em>, a party <span class="math">A</span> creates an “opaque signature” <span class="math">\\psi</span> on a message <span class="math">m</span>, which can not be verified by any other party except a designated trusted third party <span class="math">T</span>, who may either confirm or deny the validity of the signature to another party <span class="math">B</span>. Under appropriate circumstances, <span class="math">T</span> may also <em>convert</em> <span class="math">\\psi</span> into an ordinary signature, which may then be verified by anybody. Additionally, the party <span class="math">A</span> may prove the validity of an opaque signature <span class="math">\\psi</span> to a party <span class="math">B</span>, at the time that <span class="math">A</span> creates and gives <span class="math">\\psi</span> to <span class="math">B</span>. As described in <em>[x11]</em>, one may implement confirmer signatures as follows: <span class="math">A</span> creates an ordinary signature <span class="math">\\sigma</span> on <span class="math">m</span>, and encrypts <span class="math">\\sigma</span> under <span class="math">T</span>’s public key. Using verifiable encryption, <span class="math">A</span> may prove to <span class="math">B</span> that the resulting ciphertext <span class="math">\\psi</span> indeed encrypts a valid signature on <span class="math">m</span>, and using verifiable decryption, <span class="math">T</span> may confirm or deny the validity of <span class="math">\\psi</span>, or alternatively, just decrypt <span class="math">\\psi</span>, thus converting it to the ordinary signature <span class="math">\\sigma</span>. To implement this idea for Schnorr signatures, one again uses the idea outlined in above for reducing signatures to discrete logarithms. The details of all this are the subject of a forthcoming paper.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">1.1.6 Group Signatures and Anonymous Credentials</h4>

    <p class="text-gray-300">In a group signature scheme (see <em>[x2, x23, x12]</em>), when a user joined a group (whose membership is controlled by a special party, called the <em>group manager</em>), the user may sign messages on behalf of the group, without revealing his individual identity; however, under appropriate circumstances, the identity of the individual who actually signed a particular message may be revealed (using a special party, called the <em>anonymity revocation manager</em>, which may be distinct from the group manager).</p>

    <p class="text-gray-300">Without going into too many details, verifiable encryption may be used in the following way as a component in such a system. When a group member signs a message, he encrypts enough information under the public key of the anonymity revocation manager, so that later, if the identity of the signer needs to be revealed, this information can be decrypted. To prove that this information correctly identifies the signer, he makes a Pedersen commitment to this information, proves that the committed value identifies the user, encrypts the opening of the commitment, and proves that the ciphertext decrypts to an opening of the commitment. To turn this into a signature scheme, one must use the Fiat-Shamir heuristic <em>[x16]</em> to make it non-interactive (the interactive version is called an <em>identity escrow</em> scheme <em>[x23]</em>).</p>

    <p class="text-gray-300">Although one can implement group signatures without it, by using verifiable encryption, one can build a more modular system, in which the group manager and anonymity manager are separate entities with independently generated public keys (this is the separability issue). Verifiable decryption can be used both to ensure the correct behavior of the anonymity revocation manager (preventing it from “framing” innocent users), and to allow even more fine-grained control of anonymity revocation: instead of simply revealing the identity of a particular signer, the anonymity revocation manager can state (and prove) whether or not a particular signature was generated by a particular user.</p>

    <p class="text-gray-300">Credential systems <em>[x11, x12]</em> are a generalization of group signatures that allow users to show credentials to various organizations, and obtain new credentials, without revealing their identity, except through the use of an anonymity revocation manager. Verifiable encryption can be used as a component in such systems in a manner similar to that described above for group signatures. In fact, our verifiable encryption scheme is used in a prototype credential system developed at IBM called <em>idemix</em> <em>[x12, x17]</em>.</p>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">1.2 Previous Work and Further Discussion</p>

    <p class="text-gray-300">In all applications mentioned in §1.1, it is essential that the underlying encryption scheme provide security against chosen ciphertext attacks. As pointed out in <em>[x1]</em>, the earlier work on verifiable encryption in <em>[x22, x3, x27]</em> overlooked this fact, as does <em>[x26]</em>.</p>

    <p class="text-gray-300">Our encryption scheme and proof protocols are quite efficient. In particular, the proof protocols are conventional “<span class="math">\\Sigma</span>-protocols,” rather than the generally more expensive “cut and choose” protocols, such as those in <em>[x22, x3, x27, x1]</em>, that have been previously designed for the problem of verifiable encryption. Moreover, our verifiable encryption scheme actually produces a proof that a given ciphertext is correct, as opposed to the paradigm followed in <em>[x22, x3, x27, x1]</em>, which intertwines the process of encrypting and proving, so that the entire transcript of the proof must be retained by the verifier in lieu of a (short) ciphertext. Additionally, the combined encrypting/proving paradigm makes it much harder to incorporate any type of verifiable decryption protocol.</p>

    <p class="text-gray-300">Our verifiable decryption protocols are the first practical schemes of their kind.</p>

    <p class="text-gray-300">Unlike, e.g., the schemes in <em>[x22, x27]</em>, we do not require that all users of the system work with the same algebraic group — in our system, there are no “double decker” discrete logarithms, and the encryption keys may be used with any group or groups, provided certain reasonable size restrictions are met.</p>

    <p class="text-gray-300">Our decryption procedure can be implemented as a threshold decryption protocol. This allows one to minimize the trust placed in the decryptor, and in some applications this may be a preferable alternative to verifiable decryption.</p>

    <p class="text-gray-300">Our protocols are based on a number of techniques. The key ingredients that make our verifiable encryption protocol possible are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Fujisaki and Okamoto’s method for proving relations on committed values <em>[x10]</em> (with some refinements, as in <em>[x4, x11]</em>),</li>

      <li>the related interval proofs <em>[x5, x6]</em>,</li>

      <li>Paillier encryption <em>[x23]</em>, and</li>

      <li>Cramer and Shoup’s universal hash proof encryption technique <em>[x7]</em>.</li>

    </ul>

    <p class="text-gray-300">The additional ingredients needed to make our verifiable decryption protocols work are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Cramer, Damgård, and Schoenmakers’ proofs of partial knowledge <em>[x8]</em>,</li>

      <li>Boudot’s exact interval proofs <em>[x3]</em>, and</li>

      <li>new protocols for proving the inequality of discrete logarithms.</li>

    </ul>

    <p class="text-gray-300">To give the reader a rough idea of the complexity of of our protocols, consider a setting in which the discrete logarithms being encrypted are with respect to an element of order <span class="math">\\rho</span>, where <span class="math">\\rho</span> is, say, around <span class="math">\\ell^{\\prime}\\approx 160</span> bits. For such a <span class="math">\\rho</span>, it suffices to work with a modulus <span class="math">n</span> of around <span class="math">\\ell\\approx 1024</span> bits for the Paillier encryption scheme. Counting just squarings, which are all that matter asymptotically, and ignoring lower order terms, the encryption algorithm takes <span class="math">3\\ell</span> squarings mod <span class="math">n^{2}</span>, and the decryption algorithm takes <span class="math">5\\ell</span> squarings mod <span class="math">n^{2}</span>. For the verifiable encryption protocol, the prover performs <span class="math">2\\ell</span> squarings mod <span class="math">n</span>, <span class="math">3\\ell</span> squarings mod <span class="math">n^{2}</span>, and <span class="math">\\ell^{\\prime}</span> squarings in the underlying group; the verifier performs <span class="math">3\\ell</span> squarings mod <span class="math">n^{2}</span>, <span class="math">\\ell</span> squarings mod <span class="math">n</span>, and <span class="math">\\ell^{\\prime}</span> squarings in the group. The verifiable decryption protocols are about 5 to 6 times slower than this. For representations</p>

    <p class="text-gray-300">with respect to several bases, the complexity of the encryption and decryption algorithms, and the corresponding proof protocols, grows linearly in the number of bases, as one would expect.</p>

    <h2 id="sec-8" class="text-2xl font-bold">2 Preliminaries</h2>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">2.1 Notation</h3>

    <p class="text-gray-300">Let <span class="math">a</span> be a real number. We denote by <span class="math">\\lfloor a\\rfloor</span> the largest integer <span class="math">b\\leq a</span>, by <span class="math">\\lceil a\\rceil</span> the smallest integer <span class="math">b\\geq a</span>, and by <span class="math">\\lceil a\\rfloor</span> the largest integer <span class="math">b\\leq a+1/2</span>. For positive real numbers <span class="math">a</span> and <span class="math">b</span>, let <span class="math">[a]</span> denote the set <span class="math">\\{0,\\ldots,\\lfloor a\\rfloor-1\\}</span> and <span class="math">[a,b]</span> denote the set <span class="math">\\{\\lfloor a\\rfloor,\\ldots,\\lfloor b\\rfloor\\}</span> and <span class="math">[-a,b]</span> denote the set <span class="math">\\{-\\lfloor a\\rfloor,\\ldots,\\lfloor b\\rfloor\\}</span>.</p>

    <p class="text-gray-300">Let <span class="math">a</span>, <span class="math">b</span>, and <span class="math">c</span> be integers, with <span class="math">b&gt;0</span>. Most of the time, we use least non-negative remainders, i.e., <span class="math">c=a\\bmod b</span> is <span class="math">a-\\lfloor a/b\\rfloor b</span> and we have <span class="math">0\\leq c&lt;b</span>. Sometimes, we have to compute balanced remainders, i.e., <span class="math">c=a\\rm{rem}\\,b</span> is <span class="math">a-\\lceil a/b\\rfloor b</span> and we have <span class="math">-b/2\\leq c&lt;b/2</span>. Moreover, if <span class="math">b</span> is odd, then <span class="math">-(b-1)/2\\leq a\\rm{rem}\\,b\\leq(b-1)/2</span> for all <span class="math">a</span>.</p>

    <p class="text-gray-300">By <span class="math">\\text{neg}(\\lambda)</span> we denote a negligible function, i.e., a function <span class="math">f</span> such that <span class="math">f(\\lambda)&lt;1/p(\\lambda)</span> holds for all polynomials <span class="math">p(\\lambda)</span> and all sufficiently large <span class="math">\\lambda</span>.</p>

    <p class="text-gray-300">Let <span class="math">(P,V)</span> be a pair of interactive Turing machines. By <span class="math">V(x)_{P(y)}</span> we denote the output of <span class="math">V</span> upon interacting with <span class="math">P</span>, where <span class="math">V</span>’s input is <span class="math">x</span> and <span class="math">P</span>’s input is <span class="math">y</span>.</p>

    <p class="text-gray-300">We use notation introduced by Camenisch and Stadler <em>[x1]</em> for the various zero-knowledge proofs of knowledge of discrete logarithms and proofs of the validity of statements about discrete logarithms. For instance,</p>

    <p class="text-gray-300"><span class="math">PK\\{(a,b,c):y=g^{a}h^{b}\\ \\wedge\\ \\mathfrak{y}=\\mathfrak{g}^{a}\\mathfrak{h}^{c}\\ \\wedge\\ (u\\leq a\\leq v)\\}</span></p>

    <p class="text-gray-300">denotes a “zero-knowledge Proof of Knowledge of integers <span class="math">a</span>, <span class="math">b</span>, and <span class="math">g</span> such that <span class="math">y=g^{a}h^{b}</span> and <span class="math">\\mathfrak{y}=\\mathfrak{g}^{a}\\mathfrak{h}^{c}</span> holds, where <span class="math">v&lt;a&lt;u</span>,” where <span class="math">y,g,h,\\mathfrak{y},\\mathfrak{g}</span>, and <span class="math">\\mathfrak{h}</span> are elements of some groups <span class="math">G=\\langle g\\rangle=\\langle h\\rangle</span> and <span class="math">\\mathfrak{G}=\\langle\\mathfrak{g}\\rangle=\\langle\\mathfrak{h}\\rangle</span>. The convention is that the elements listed in the round brackets denote quantities the knowledge of which is being proved (and are in general not known to the verifier), while all other parameters are known to the verifier. Using this notation, a proof-protocol can be described by just pointing out its aim while hiding all details.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">2.2 Special Honest-Verifier Zero-Knowledge Protocols</h3>

    <p class="text-gray-300">A special honest-verifier zero-knowledge protocol is a protocol between a prover and a verifier, where <span class="math">y</span> is their common input and <span class="math">x</span> is the prover’s additional input. The protocol is restricted to three moves: in the first move the prover sends the verifier a “commitment” message <span class="math">t</span>, in the second move the verifier sends the prover a “challenge” message <span class="math">c</span>, and in the third move the prover sends the verifier a “response” message <span class="math">s</span>. Finally, there must exist a simulator that, on input <span class="math">y</span> and any “challenge” message <span class="math">\\tilde{c}</span>, outputs a “commitment” and “response” messages <span class="math">\\tilde{t}</span> and <span class="math">\\tilde{s}</span> such that the distribution of the triple <span class="math">(\\tilde{t},\\tilde{c},\\tilde{s})</span> is (statistically) indistinguishable from the one of triples <span class="math">(t,c,s)</span> stemming from real conversations of the prover and the verifier for which <span class="math">c=\\tilde{c}</span>. Note that the existence of such a simulator implies that the protocol is (ordinary) honest-verifier zero-knowledge.</p>

    <p class="text-gray-300">For particular types of proof systems, we shall give explicit, detailed definitions of special honest-verifier zero knowledge, as appropriate.</p>

    <p class="text-gray-300">While this notion of zero-knowledge is not sufficient for most applications, there exist a number of generic constructions to turn a special honest-verifier zero-knowledge protocol into one that</p>

    <p class="text-gray-300">satisfies stronger notions of zero-knowledge. The most important examples are probably the constructions to obtain concurrent zero-knowledge protocols <em>[x10, x11, x14]</em> or witness-hiding protocols <em>[x12]</em>. In particular, the construction due to Damgård achieves (concurrent) zero-knowledge virtually for free <em>[x10]</em>.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">2.3 Secure Public-Key Encryption</h3>

    <p class="text-gray-300">Here, we recall the notion of a public-key encryption scheme. Actually, we need the notion of a public-key encryption scheme that supports <em>labels</em>. A label is an arbitrary bit string that is input to the encryption and decryption algorithms, specifying the “context” in which the encryption or decryption operation is to take place.</p>

    <p class="text-gray-300">A public key encryption scheme provides three algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a probabilistic, polynomial-time <em>key generation</em> algorithm <span class="math">\\mathcal{G}</span> that on input <span class="math">1^{\\lambda}</span> — where <span class="math">\\lambda\\geq 0</span> is a security parameter — outputs a public-key/private-key pair <span class="math">(\\mathsf{PK},\\mathsf{SK})</span>. A public key <span class="math">\\mathsf{PK}</span> specifies a finite, easy-to-recognize <em>message space</em> <span class="math">M_{\\mathsf{PK}}</span>.</li>

      <li>a probabilistic, polynomial-time <em>encryption</em> algorithm <span class="math">\\mathcal{E}</span> that takes as input a public key <span class="math">\\mathsf{PK}</span>, a message <span class="math">m\\in M_{\\mathsf{PK}}</span>, and a label <span class="math">L</span>, and outputs a ciphertext <span class="math">\\psi</span>.</li>

      <li>a deterministic, polynomial-time <em>decryption</em> algorithm <span class="math">\\mathcal{D}</span> that takes as input a private key <span class="math">\\mathsf{SK}</span>, a ciphertext <span class="math">\\psi</span>, a label <span class="math">L</span>, and outputs either a message <span class="math">m\\in M_{\\mathsf{PK}}</span>, where <span class="math">\\mathsf{PK}</span> is the public-key corresponding to <span class="math">\\mathsf{SK}</span>, or a special symbol reject.</li>

    </ul>

    <p class="text-gray-300">Any public-key encryption scheme should satisfy a “correctness” or “soundness” property, which loosely speaking means that the decryption operation “undoes” the encryption operation. For our purposes, we can formulate this as follows. We call a public-key encryption scheme <em>sound</em> if for all <span class="math">(\\mathsf{PK},\\mathsf{SK})\\in\\mathcal{G}(1^{\\lambda})</span>, for all <span class="math">m\\in M_{\\mathsf{PK}}</span>, for all <span class="math">L\\in\\{0,1\\}^{*}</span>, and for all <span class="math">\\psi\\in\\mathcal{E}(\\mathsf{PK},m,L)</span>, we have <span class="math">\\mathcal{D}(\\mathsf{SK},\\psi,L)=m</span>.</p>

    <p class="text-gray-300">This definition can easily be relaxed to allow for an incorrect decryption with negligible probability, but we do not pursue this matter here. For all encryption schemes presented in this paper, it is trivial to verify this soundness property, and so we will not explicitly deal with this issue again.</p>

    <p class="text-gray-300">We say that a ciphertext is <em>valid</em> w.r.t. a label <span class="math">L</span> (and a key pair <span class="math">(\\mathsf{PK},\\mathsf{SK})</span>) if the decryption algorithm does not reject it and is <em>invalid</em> w.r.t. <span class="math">L</span> otherwise.</p>

    <p class="text-gray-300">Note that in this paper, we only work with finite message spaces.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">2.4 Adaptive Chosen Ciphertext Security</h3>

    <p class="text-gray-300">Consider a public-key encryption scheme, and consider the following game, played against an arbitrary probabilistic, polynomial-time adversary.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Key-Generation Phase.</em> Let <span class="math">\\lambda\\geq 0</span> be the security parameter. We run the key-generation algorithm of the public-key encryption scheme on input <span class="math">1^{\\lambda}</span>, and get a key pair <span class="math">(\\mathsf{PK},\\mathsf{SK})</span>. We equip an <em>encryption oracle</em> with the public key <span class="math">\\mathsf{PK}</span>, and a <em>decryption oracle</em> with the secret key <span class="math">\\mathsf{SK}</span>. The public key <span class="math">\\mathsf{PK}</span> is presented to the adversary.</li>

      <li><em>Probing Phase I.</em> In this phase, the attacker gets to interact with the decryption oracle in an arbitrary, adaptive fashion. This phase goes on for a polynomial amount of time, specified by the adversary. More precisely, in each round of this interaction, the adversary sends a <em>query</em> <span class="math">(\\psi,L)</span> to the decryption oracle. A query is a pair of bit strings chosen in an arbitrary way by</li>

    </ol>

    <p class="text-gray-300">the adversary. The decryption oracle in turn decrypts <span class="math">\\psi</span> with label <span class="math">L</span> under the secret key <span class="math">\\mathsf{SK}</span>, and responds to the query by returning the decryption to the adversary.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Target-Selection Phase.</em> The adversary selects two messages <span class="math">m_{0}</span> and <span class="math">m_{1}</span> from the message space, along with a label <span class="math">L^{<em>}</span>, and presents <span class="math">(m_{0},m_{1},L^{</em>})</span> to the encryption oracle. The encryption oracle selects a random <span class="math">\\sigma\\in\\{0,1\\}</span>, and encrypts <span class="math">m_{\\sigma}</span> with label <span class="math">L^{<em>}</span> under <span class="math">\\mathsf{PK}</span>. The resulting encryption <span class="math">\\psi^{</em>}</span>, the <em>target ciphertext</em>, is presented to the adversary.</li>

      <li><em>Probing Phase II.</em> This phase is as Probing Phase I, the only difference being that the decryption oracle only responds to queries <span class="math">(\\psi,L)</span> with <span class="math">(\\psi,L)\\neq(\\psi^{<em>},L^{</em>})</span>.</li>

      <li><em>Guessing-Phase.</em> The adversary outputs a bit <span class="math">\\hat{\\sigma}</span>.</li>

    </ol>

    <p class="text-gray-300">The adversary is said to <em>win</em> the game if <span class="math">\\hat{\\sigma}=\\sigma</span>. We define the <em>advantage</em> (over random guessing) of the adversary as the absolute value of the difference of the probability that he wins and <span class="math">1/2</span>.</p>

    <p class="text-gray-300">A public-key encryption scheme is said to be <em>secure against adaptive chosen ciphertext attack</em> if for all polynomial time, probabilistic adversaries, the advantage in this guessing game is negligible as a function of the security parameter.</p>

    <h2 id="sec-13" class="text-2xl font-bold">3 The Encryption Scheme</h2>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">3.1 Background</h3>

    <p class="text-gray-300">Let <span class="math">p,q,p^{\\prime},q^{\\prime}</span> be distinct odd primes with <span class="math">p=2p^{\\prime}+1</span> and <span class="math">q=2q^{\\prime}+1</span>, and where <span class="math">p^{\\prime}</span> and <span class="math">q^{\\prime}</span> are both <span class="math">\\ell</span> bits in length. Let <span class="math">n=pq</span> and <span class="math">n^{\\prime}=p^{\\prime}q^{\\prime}</span>. Consider the group <span class="math">\\mathbb{Z}_{n^{2}}^{<em>}</span> and the subgroup <span class="math">\\mathbf{P}</span> of <span class="math">\\mathbb{Z}_{n^{2}}^{</em>}</span> consisting of all <span class="math">n</span>-th powers of elements in <span class="math">\\mathbb{Z}_{n^{2}}^{*}</span>.</p>

    <p class="text-gray-300">Paillier’s Decision Composite Residuosity (DCR) assumption <em>[x14]</em> is that given only <span class="math">n</span>, it is hard to distinguish random elements of <span class="math">\\mathbb{Z}_{n^{2}}^{*}</span> from random elements of <span class="math">\\mathbf{P}</span>.</p>

    <p class="text-gray-300">To be completely formal, one should specify a sequence of bit lengths <span class="math">\\ell(\\lambda)</span>, parameterized by a security parameter <span class="math">\\lambda\\geq 0</span>, and to generate an instance of the problem for security parameter <span class="math">\\lambda</span>, the primes <span class="math">p^{\\prime}</span> and <span class="math">q^{\\prime}</span> should be distinct, random primes of length <span class="math">\\ell=\\ell(\\lambda)</span>, such that <span class="math">p=2p^{\\prime}+1</span> and <span class="math">q=2q^{\\prime}+1</span> are also primes.</p>

    <p class="text-gray-300">The primes <span class="math">p^{\\prime}</span> and <span class="math">q^{\\prime}</span> are called Sophie Germain primes and the primes <span class="math">p</span> and <span class="math">q</span> are called safe primes. It has never been proven that there are infinitely many Sophie Germain primes. Nevertheless, it is widely conjectured, and amply supported by empirical evidence, that the probability that a random <span class="math">\\ell</span>-bit number is Sophie Germain prime is <span class="math">\\Omega(1/\\ell^{2})</span>. We shall assume that this conjecture holds, so that we can assume that problem instances can be efficiently generated.</p>

    <p class="text-gray-300">Note that Paillier did not make the restriction to safe primes in originally formulating the DCR assumption. As will become evident, we need to restrict ourselves to safe primes for technical reasons. However, it is easy to see that the DCR assumption without this restriction implies the DCR assumption with this restriction, assuming that safe primes are sufficiently dense, as we are here.</p>

    <p class="text-gray-300">We can decompose <span class="math">\\mathbb{Z}_{n^{2}}^{*}</span> as an internal direct product</p>

    <p class="text-gray-300"><span class="math">\\mathbb{Z}_{n^{2}}^{*}=\\mathbf{G}_{n}\\cdot\\mathbf{G}_{n^{\\prime}}\\cdot\\mathbf{G}_{2}\\cdot\\mathbf{T},</span></p>

    <p class="text-gray-300">where each group <span class="math">\\mathbf{G}_{\\tau}</span> is a cyclic group of order <span class="math">\\tau</span>, and <span class="math">\\mathbf{T}</span> is the subgroup of <span class="math">\\mathbb{Z}_{n^{2}}^{*}</span> generated by <span class="math">(-1\\bmod n^{2})</span>. This decomposition is unique, except for the choice of <span class="math">\\mathbf{G}_{2}</span> (there are two possible</p>

    <p class="text-gray-300">choices). For any <span class="math">x \\in \\mathbb{Z}_{n^2}^*</span>, we can express <span class="math">x</span> uniquely as <span class="math">x = x(\\mathbf{G}_n)x(\\mathbf{G}_{n&#x27;})x(\\mathbf{G}_2)x(\\mathbf{T})</span>, where for each <span class="math">\\mathbf{G}_{\\tau}</span>, <span class="math">x(\\mathbf{G}_{\\tau}) \\in \\mathbf{G}_{\\tau}</span>, and <span class="math">x(\\mathbf{T}) \\in \\mathbf{T}</span>.</p>

    <p class="text-gray-300">Note that the element <span class="math">h = (1 + n \\bmod n^2) \\in \\mathbb{Z}_{n^2}^*</span> has order <span class="math">n</span>, i.e., it generates <span class="math">\\mathbf{G}_n</span>, and that <span class="math">h^a = (1 + an \\bmod n^2)</span> for <span class="math">0 \\leq a &amp;lt; n</span>. Observe that <span class="math">\\mathbf{P} = \\mathbf{G}_{n&#x27;}\\mathbf{G}_2\\mathbf{T}</span>.</p>

    <h2 id="sec-15" class="text-2xl font-bold">3.2 The Scheme</h2>

    <p class="text-gray-300">For a security parameter <span class="math">\\lambda \\geq 0</span>, <span class="math">\\ell = \\ell(\\lambda)</span> is an auxiliary parameter.</p>

    <p class="text-gray-300">The scheme makes use of a keyed hash scheme <span class="math">\\mathcal{H}</span> that uses a key hk, chosen at random from an appropriate key space associated with the security parameter <span class="math">\\lambda</span>; the resulting hash function <span class="math">\\mathcal{H}_{\\mathrm{hk}}(\\cdot)</span> maps a triple <span class="math">(u,e,L)</span> to a number in the set <span class="math">[2^{\\ell}]</span>. We shall assume that <span class="math">\\mathcal{H}</span> is collision resistant, i.e., given a randomly chosen hash key hk, it is computationally infeasible to find two triples <span class="math">(u,e,L) \\neq (u&#x27;,e&#x27;,L&#x27;)</span> such that <span class="math">\\mathcal{H}_{\\mathrm{hk}}(u,e,L) = \\mathcal{H}_{\\mathrm{hk}}(u&#x27;,e&#x27;,L&#x27;)</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\mathrm{abs}:\\mathbb{Z}_{n^2}^<em>\\to \\mathbb{Z}_{n^2}^</em></span> map <span class="math">(a\\bmod n^2)</span>, where <span class="math">0 &amp;lt; a &amp;lt; n^2</span>, to <span class="math">(n^{2} - a\\bmod n^{2})</span> if <span class="math">a &amp;gt; n^2 /2</span>, and to <span class="math">(a\\bmod n^2)</span>, otherwise. Note that <span class="math">v^{2} = (\\mathrm{abs}(v))^{2}</span> holds for all <span class="math">v\\in \\mathbb{Z}_{n^2}^*</span>.</p>

    <p class="text-gray-300">We now describe the key generation, encryption, and decryption algorithms of the encryption scheme, as they behave for a given value of the security parameter <span class="math">\\lambda</span>.</p>

    <p class="text-gray-300"><strong>Key Generation.</strong> Select two random <span class="math">\\ell</span>-bit Sophie Germain primes <span class="math">p&#x27;</span> and <span class="math">q&#x27;</span>, with <span class="math">p&#x27; \\neq q&#x27;</span>, and compute <span class="math">p := (2p&#x27; + 1)</span>, <span class="math">q := (2q&#x27; + 1)</span>, <span class="math">n := pq</span>, and <span class="math">n&#x27; := p&#x27;q&#x27;</span>, where <span class="math">\\ell = \\ell(\\lambda)</span> is an auxiliary security parameter. Choose random <span class="math">x_1, x_2, x_3 \\in_R [n^2/4]</span>, choose a random <span class="math">g&#x27; \\in_R \\mathbb{Z}_{n^2}^*</span>, and compute <span class="math">g := (g&#x27;)^{2n}</span>, <span class="math">y_1 := g^{x_1}</span>, <span class="math">y_2 := g^{x_2}</span>, and <span class="math">y_3 := g^{x_3}</span>. Also, generate a hash key hk from the key space of the hash scheme <span class="math">\\mathcal{H}</span> associated with the security parameter <span class="math">\\lambda</span>. The public key is <span class="math">(\\mathsf{hk}, n, g, y_1, y_2, y_3)</span>. The secret key is <span class="math">(\\mathsf{hk}, n, x_1, x_2, x_3)</span>.</p>

    <p class="text-gray-300">In the rest of the paper, let <span class="math">h = (1 + n \\bmod n^2) \\in \\mathbb{Z}_{n^2}^*</span>, which as discussed above, is an element of order <span class="math">n</span>.</p>

    <p class="text-gray-300"><strong>Encryption.</strong> To encrypt a message <span class="math">m \\in [n]</span> with label <span class="math">L \\in \\{0,1\\}^*</span> under a public key as above, choose a random <span class="math">r \\in_R [n/4]</span> and compute</p>

    <div class="my-4 text-center"><span class="math-block">u := g^r \\ , \\qquad \\qquad e := y_1^r h^m \\ , \\quad \\text{and} \\qquad \\qquad v := \\mathrm{abs} \\left( (y_2 y_3^{\\mathcal{H}_{\\mathrm{hk}}(u,e,L)})^r \\right) \\ .</span></div>

    <p class="text-gray-300">The ciphertext is <span class="math">(u,e,v)</span>.</p>

    <p class="text-gray-300"><strong>Decryption.</strong> To decrypt a ciphertext <span class="math">(u,e,v) \\in \\mathbb{Z}_{n^2}^<em> \\times \\mathbb{Z}_{n^2}^</em> \\times \\mathbb{Z}_{n^2}^*</span> with label <span class="math">L</span> under a secret key as above, first check that <span class="math">\\mathrm{abs}(v) = v</span> and <span class="math">u^{2(x_2 + \\mathcal{H}_{\\mathrm{hk}}(u,e,L)x_3)} = v^2</span>. If this does not hold, then output reject and halt. Next, let <span class="math">t = 2^{-1} \\bmod n</span>, and compute <span class="math">\\hat{m} := (e / u^{x_1})^{2t}</span>. If <span class="math">\\hat{m}</span> is of the form <span class="math">h^m</span> for some <span class="math">m \\in [n]</span>, then output <span class="math">m</span>; otherwise, output reject.</p>

    <p class="text-gray-300">This scheme differs from the DCR-based schemes presented in [CS02], because in our situation, special attention must be paid to the treatment of elements of order 2 in the <span class="math">\\mathbb{Z}_{n^2}^*</span>, as these can cause some trouble for the proof systems we discuss in the next sections. Because of these differences, the above encryption scheme does not exactly fit into the general framework of [CS02], even though the basic ideas are the same. We therefore analyze the security of the scheme starting from first principles, rather than trying to modify their framework.</p>

    <p class="text-gray-300">Before presenting the security analysis, we remark on one of the more peculiar aspects of the scheme, namely, the role of the <span class="math">\\mathrm{abs}(\\cdot)</span> function in the encryption and decryption algorithms. If one left this out, i.e., replaced <span class="math">\\mathrm{abs}(\\cdot)</span> by the identity function, then the scheme would be malleable, as</p>

    <p class="text-gray-300">10</p>

    <p class="text-gray-300"><span class="math">(u,e,v)</span> is an encryption of some message <span class="math">m</span> with label <span class="math">L</span>, then so is <span class="math">(u,e,-v)</span>. This particular type of malleability <em>[x1, x26]</em> is in fact rather “benign,” and would be acceptable in most applications. However, we prefer to achieve non-malleability in the strictest sense, and because this comes at a marginal cost, we do so. We also mention that in independent work, Gennaro and Lindell <em>[x12]</em> devise a similar (but not quite identical) scheme, but for completely different purposes: their goal is to construct efficient password-based key exchange protocols.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">The above scheme is secure against adaptive chosen ciphertext attack provided the DCR assumption holds, and provided <span class="math">\\mathcal{H}</span> is collision resistant.</p>

    <p class="text-gray-300">The rest of this section is devoted to the proof of Theorem 1.</p>

    <p class="text-gray-300">Let us fix a value of the security parameter <span class="math">\\lambda</span>, which fixes <span class="math">\\ell=\\ell(\\lambda)</span>, and let us fix an adversary <span class="math">A</span>. Let <span class="math">\\psi^{<em>}=(u^{</em>},e^{<em>},v^{</em>})</span> denote the target ciphertext, and <span class="math">L^{*}</span> the associated label.</p>

    <p class="text-gray-300">We prove this theorem by analyzing a sequence of modifications to the environment in which the adversary runs. We refer to the attack game run with the original environment as Game 0 (c.f. §2.4), and to the attack game run with subsequent modifications to the environment as Games 1, 2, etc. Each of these games are best viewed as operating on the same underlying probability space. The value of the random variable <span class="math">\\sigma</span> is identical in each game, but the output <span class="math">\\hat{\\sigma}</span> of the adversary may vary among games. We define the event <span class="math">T_{i}</span>, for <span class="math">i\\geq 0</span>, as the event that the <span class="math">\\sigma=\\hat{\\sigma}</span> in Game <span class="math">i</span>.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Game 1.</h6>

    <p class="text-gray-300">This is the same as Game 0, except for the following modification to the decryption oracle. If the decryption oracle is invoked in Probing Phase II with a ciphertext/label pair <span class="math">((u,e,v),L)</span> such that <span class="math">(u,e,L)\\neq(u^{<em>},e^{</em>},L^{<em>})</span> but <span class="math">\\mathcal{H}_{\\mathsf{hk}}(u,e,L)=\\mathcal{H}_{\\mathsf{hk}}(u^{</em>},e^{<em>},L^{</em>})</span>, then the decryption oracle <em>rejects</em> the ciphertext.</p>

    <p class="text-gray-300">Let <span class="math">F_{1}</span> be the event that a ciphertext is rejected in Game 1 using the above rejection rule. It is clear that Games 0 and 1 proceed identically until <span class="math">F_{1}</span> occurs; more precisely, the events <span class="math">T_{1}\\wedge\\neg F_{1}</span> and <span class="math">T_{0}\\wedge\\neg F_{1}</span> are identical. Therefore,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[T_{1}]-\\Pr[T_{0}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\Pr[F_{1}].$ (1)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Moreover, we have</p>

    <p class="text-gray-300"><span class="math">\\Pr[F_{1}]\\leq\\mathsf{AdvCRHF}_{A^{\\prime}}(\\lambda),</span> (2)</p>

    <p class="text-gray-300">where <span class="math">\\mathsf{AdvCRHF}_{A^{\\prime}}(\\lambda)</span> denotes the success probability that a particular adversary <span class="math">A^{\\prime}</span> has in finding a collision in <span class="math">\\mathcal{H}</span> for the given value of the security parameter <span class="math">\\lambda</span>. The running time of <span class="math">A^{\\prime}</span> is about the same as that of <span class="math">A</span>. Indeed, given a hash key <span class="math">\\mathsf{hk}</span>, adversary <span class="math">A^{\\prime}</span> simply runs Game 1, using the given value of <span class="math">\\mathsf{hk}</span> in the key generation algorithm, and when <span class="math">F_{1}</span> occurs, <span class="math">A^{\\prime}</span> outputs <span class="math">(u,e,L)</span> and <span class="math">(u^{<em>},e^{</em>},L^{*})</span>.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Game 2.</h6>

    <p class="text-gray-300">This game is the same as Game 1, except for the following modification to the decryption oracle. If the decryption oracle is invoked in Probing Phase II with a ciphertext <span class="math">(u,e,v)</span> such that <span class="math">v^{2}=(v^{<em>})^{2}</span> and <span class="math">v\\neq v^{</em>}</span>, then the decryption oracle <em>rejects</em> the ciphertext.</p>

    <p class="text-gray-300">Let <span class="math">F_{2}</span> be the event that a ciphertext is rejected in Game 2 using the above rejection rule, but would not have been rejected for any other reason. It is clear that Games 1 and 2 proceed identically until <span class="math">F_{2}</span> occurs; more precisely, the events <span class="math">T_{2}\\wedge\\neg F_{2}</span> and <span class="math">T_{1}\\wedge\\neg F_{2}</span> are identical. Therefore,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[T_{2}]-\\Pr[T_{1}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\Pr[F_{2}].$ (3)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Moreover, we have</p>

    <p class="text-gray-300"><span class="math">\\Pr[F_{2}]\\leq\\mathsf{AdvFactor}_{A^{\\prime\\prime}}(\\lambda),</span> (4)</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">\\mathsf{AdvFactor}_{A^{\\prime\\prime}}(\\lambda)</span> denotes the success probability that a particular algorithm <span class="math">A^{\\prime\\prime}</span> has in factoring a number <span class="math">n</span> as generated by the encryption algorithm for the given value of the security parameter <span class="math">\\lambda</span>. The running time of <span class="math">A^{\\prime\\prime}</span> is about the same as that of <span class="math">A</span>. Algorithm <span class="math">A^{\\prime\\prime}</span> takes the given number <span class="math">n</span>, constructs the remaining components of the public key, and then lets adversary <span class="math">A</span> run in Game 2. If and when event <span class="math">F_{2}</span> occurs, we have <span class="math">v^{2}=(v^{<em>})^{2}</span>, <span class="math">v\\neq v^{</em>}</span>, <span class="math">\\text{abs}(v)=v</span>, and <span class="math">\\text{abs}(v^{<em>})=v^{</em>}</span>. This implies that <span class="math">v\\neq\\pm v^{<em>}</span>. It follows that if <span class="math">v/v^{</em>}=(a\\bmod n^{2})</span>, then <span class="math">\\gcd(a,n)</span> splits <span class="math">n</span>.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Game 3.</h6>

    <p class="text-gray-300">This game is the same as Game 2, except for the following modification to the encryption oracle. Instead of computing <span class="math">e^{<em>}</span> and <span class="math">v^{</em>}</span> as in the encryption algorithm, we compute them using the secret key, as follows:</p>

    <p class="text-gray-300"><span class="math">e^{<em>}</span> <span class="math">:=</span> <span class="math">(u^{</em>})^{x_{1}}h^{m_{\\sigma}}</span> <span class="math">v^{<em>}</span> <span class="math">:=</span> <span class="math">\\text{abs}\\left((u^{</em>})^{x_{2}+\\mathcal{H}_{\\text{hk}}(u^{<em>},e^{</em>},L^{*})x_{3}}\\right)</span></p>

    <p class="text-gray-300">This modification is purely conceptual, as the values of <span class="math">e^{<em>}</span> and <span class="math">v^{</em>}</span> computed by the encryption oracle in Game 3 are identical to those computed in Game 2. Therefore,</p>

    <p class="text-gray-300"><span class="math">\\Pr[T_{3}]=\\Pr[T_{2}].</span> (5)</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Game 4.</h6>

    <p class="text-gray-300">Now we further modify the encryption oracle. Let <span class="math">r^{<em>}</span> denote the value of <span class="math">r</span> generated by the encryption oracle. Then, instead of computing <span class="math">u^{</em>}</span> as <span class="math">g^{r^{<em>}}</span>, the encryption oracle in this game chooses a random <span class="math">\\bar{u}\\in\\mathbf{P}</span>, and sets <span class="math">u^{</em>}:=\\bar{u}^{2}</span>.</p>

    <p class="text-gray-300">We claim that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[T_{4}]-\\Pr[T_{3}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O(2^{-\\ell}).$ (6)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To see this, observe that <span class="math">\\bar{u}^{2}</span> is uniformly distributed over <span class="math">\\mathbf{G}_{n^{\\prime}}</span>. Also, observe that with probability <span class="math">1-O(2^{-\\ell})</span>, <span class="math">g</span> is a generator for <span class="math">\\mathbf{G}_{n^{\\prime}}</span>, and that the distribution of <span class="math">r^{*}</span> is <span class="math">O(2^{-\\ell})</span>-close to the uniform distribution on <span class="math">[n^{\\prime}]</span>. It is an easy exercise to show that the bound (6) follows from these observations.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Game 5.</h6>

    <p class="text-gray-300">We again modify the encryption oracle. Instead of choosing <span class="math">\\bar{u}</span> at random from <span class="math">\\mathbf{P}</span>, the encryption oracle chooses <span class="math">\\bar{u}</span> at random from <span class="math">\\mathbb{Z}_{n^{2}}^{*}</span>; otherwise, the computation is identical to that of Game 4.</p>

    <p class="text-gray-300">It is clear that any significant difference between <span class="math">\\Pr[T_{5}]</span> and <span class="math">\\Pr[T_{4}]</span> leads immediately to an effective statistical test for distinguishing <span class="math">\\mathbf{P}</span> from <span class="math">\\mathbb{Z}_{n^{2}}^{*}</span>. More precisely, there exists an adversary <span class="math">A^{\\prime\\prime\\prime}</span>, whose running time is roughly the same as that of <span class="math">A</span>, such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[T_{5}]-\\Pr[T_{4}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\mathsf{AdvDCR}_{A^{\\prime\\prime\\prime}}(\\lambda),$ (7)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">\\mathsf{AdvDCR}_{A^{\\prime\\prime\\prime}}(\\lambda)</span> denotes the advantage that <span class="math">A^{\\prime\\prime\\prime}</span> has in distinguishing <span class="math">\\mathbf{P}</span> from <span class="math">\\mathbb{Z}_{n^{2}}^{*}</span> for the given value of the security parameter <span class="math">\\lambda</span>.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Game 6.</h6>

    <p class="text-gray-300">We again modify the encryption oracle. This time, we replace <span class="math">u^{<em>}</span> by a random element of <span class="math">\\mathbf{G}_{n}\\mathbf{G}_{n^{\\prime}}</span> such that <span class="math">u^{</em>}(\\mathbf{G}_{n})</span> has order <span class="math">n</span>.</p>

    <p class="text-gray-300">We claim that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[T_{6}]-\\Pr[T_{5}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O(2^{-\\ell}).$ (8)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To see this, note that in Game 5, <span class="math">u^{<em>}</span> is uniformly distributed over <span class="math">\\mathbf{G}_{n}\\mathbf{G}_{n^{\\prime}}</span>, and so <span class="math">u^{</em>}(\\mathbf{G}_{n})</span> has order <span class="math">n</span> with probability <span class="math">1-O(2^{-\\ell})</span>. The bound (8) follows immediately.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Game 7.</h6>

    <p class="text-gray-300">Now we modify the key generation algorithm. Instead of choosing <span class="math">x_{1},x_{2},x_{3}</span> at random from <span class="math">[n^{2}/4]</span>, we choose them at random from <span class="math">[nn^{\\prime}]</span>.</p>

    <p class="text-gray-300">Because the uniform distribution on <span class="math">[n^{2}/4]</span> is <span class="math">O(2^{-\\ell})</span>-close to the uniform distribution on <span class="math">[nn^{\\prime}]</span>, it follows immediately that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[T_{7}]-\\Pr[T_{6}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O(2^{-\\ell}).$ (9)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-24" class="text-base font-medium mt-4">Game 8.</h6>

    <p class="text-gray-300">Now we modify the decryption oracle. In this game, in addition to rejecting a ciphertext <span class="math">(u,e,v)\\in\\mathbb{Z}_{n^{2}}^{<em>}\\times\\mathbb{Z}_{n^{2}}^{</em>}\\times\\mathbb{Z}_{n^{2}}^{*}</span> with label <span class="math">L</span> if <span class="math">u^{2(x_{2}+\\mathcal{H}_{\\mathsf{hk}}(u,e,L)x_{3})}\\neq v^{2}</span>, the decryption oracle also rejects this ciphertext if <span class="math">u\\notin\\mathbf{G}_{n^{\\prime}}\\mathbf{G}_{2}\\mathbf{T}</span>.</p>

    <p class="text-gray-300">In this game, the decryption oracle leaks no information about the value of <span class="math">x_{1}</span> modulo <span class="math">n</span>. ¿From this, and the fact that <span class="math">u^{<em>}(\\mathbf{G}_{n})</span> has order <span class="math">n</span> and <span class="math">e^{</em>}=(u^{*})^{x_{1}}h^{m_{\\sigma}}</span>, it follows that <span class="math">A</span>’s output <span class="math">\\hat{\\sigma}</span> is independent of <span class="math">\\sigma</span>. Therefore,</p>

    <p class="text-gray-300"><span class="math">\\Pr[T_{8}]=1/2.</span> (10)</p>

    <p class="text-gray-300">Let <span class="math">F_{8}</span> be the event that in Game 8, some ciphertext <span class="math">(u,e,v)</span> with label <span class="math">L</span> is rejected using the special rejection rule introduced in Game 8, but would not have been rejected for any other reason, i.e., the special rejection rules introduced in Games 1 and 2 do not apply, and <span class="math">u^{2(x_{2}+\\mathcal{H}_{\\mathsf{hk}}(u,e,L)x_{3})}=v^{2}</span>.</p>

    <p class="text-gray-300">It is clear that Games 7 and 8 proceed identically until <span class="math">F_{8}</span> occurs. More precisely, the events <span class="math">T_{8}\\wedge\\neg F_{8}</span> and <span class="math">T_{7}\\wedge\\neg F_{8}</span> are identical. Therefore,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[T_{8}]-\\Pr[T_{7}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\Pr[F_{8}].$ (11)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">\\kappa=\\kappa(\\lambda)</span> denote an upper bound on the number of decryption oracle queries made by <span class="math">A</span> for the given value of the security parameter <span class="math">\\lambda</span>. We assume this bound holds, regardless of the environment in which <span class="math">A</span> runs. We claim that</p>

    <p class="text-gray-300"><span class="math">\\Pr[F_{8}]\\leq\\kappa\\cdot 2^{-\\ell}.</span> (12)</p>

    <p class="text-gray-300">To prove (12), we argue as follows. Let <span class="math">\\bar{x}_{2}</span> and <span class="math">\\bar{x}_{3}</span> denote the values of <span class="math">x_{2}</span> and <span class="math">x_{3}</span>, respectively, modulo <span class="math">n</span>. Similarly, let <span class="math">\\bar{x}_{2}^{\\prime}</span> and <span class="math">\\bar{x}_{3}^{\\prime}</span> denote the values of <span class="math">x_{2}</span> and <span class="math">x_{3}</span>, respectively, modulo <span class="math">n^{\\prime}</span>.</p>

    <p class="text-gray-300">Let us condition on fixed values of</p>

    <p class="text-gray-300"><span class="math">n,g,x_{1},\\bar{x}_{2}^{\\prime},\\bar{x}_{3}^{\\prime},\\mathsf{hk},</span></p>

    <p class="text-gray-300">as well as fixed values of the coin tosses of <span class="math">A</span>. In this conditional probability space, the public key is fixed, <span class="math">A</span>’s queries to the decryption oracle in Probing Phase I, as well as the responses of the decryption oracle. To see why responses of the decryption oracle are fully determined, observe that all ciphertexts <span class="math">(u,e,v)</span> with <span class="math">u\\notin\\mathbf{G}_{n^{\\prime}}\\mathbf{G}_{2}\\mathbf{T}</span> are rejected, and that the decryption oracle squares <span class="math">u</span> in all computations involving <span class="math">u</span>; thus, the response of the decryption oracle is determined by <span class="math">\\bar{x}_{2}^{\\prime}</span> and <span class="math">\\bar{x}_{3}^{\\prime}</span>, which are fixed. Also, in this conditional probability space, it is determined whether or not <span class="math">A</span> invokes the encryption oracle, and if so, <span class="math">A</span>’s inputs to the encryption oracle. However, by the Chinese Remainder Theorem, the values of <span class="math">\\bar{x}_{2}</span> and <span class="math">\\bar{x}_{3}</span> in this conditional probability space are still uniformly and independently distributed over <span class="math">[n]</span>.</p>

    <p class="text-gray-300">In this conditional probability space, consider a particular invocation of the decryption oracle in Probing Phase I with a ciphertext <span class="math">(u,e,v)</span> and label <span class="math">L</span>. Suppose that <span class="math">u\\notin\\mathbf{G}_{n^{\\prime}}\\mathbf{G}_{2}\\mathbf{T}</span>. Let <span class="math">\\bar{u}=u(\\mathbf{G}_{n}^{\\prime})^{2}</span>, <span class="math">\\bar{u}^{\\prime}=u(\\mathbf{G}_{n})^{2}</span>, and <span class="math">H=\\mathcal{H}_{\\mathsf{hk}}(u,e,L)</span>. Note that <span class="math">\\bar{u}\\neq 1</span>, and so <span class="math">\\bar{u}</span> has order <span class="math">p</span>, <span class="math">q</span>, or <span class="math">n</span>. Now, we have</p>

    <p class="text-gray-300"><span class="math">u^{2(x_{2}+\\mathcal{H}_{\\mathsf{hk}}(u,e,L)x_{3})}=(\\bar{u})^{\\bar{x}_{2}+H\\bar{x}_{3}}(\\bar{u}^{\\prime})^{\\bar{x}_{2}^{\\prime}+H\\bar{x}_{3}^{\\prime}}.</span></p>

    <p class="text-gray-300"><span class="math">u^{2(x_{2}+\\mathcal{H}_{\\mathsf{bk}}(u,e,L)x_{3})}</span> is uniformly distributed over a particular coset in <span class="math">\\mathbf{G}_{n^{\\prime}}\\mathbf{G}_{n}</span> of the subgroup generated by <span class="math">\\bar{u}</span>. As <span class="math">v^{2}</span> is fixed in this conditional probability space, it follows that <span class="math">u^{2(x_{2}+\\mathcal{H}_{\\mathsf{bk}}(u,e,L)x_{3})}=v^{2}</span> with probability at most <span class="math">2^{-\\ell}</span>.</p>

    <p class="text-gray-300">Now suppose that in this conditional probability space <span class="math">A</span> invokes the encryption oracle with particular messages <span class="math">m_{0}</span> and <span class="math">m_{1}</span>, and a label <span class="math">L^{<em>}</span>. Let us further condition on fixed values of <span class="math">\\sigma</span> and <span class="math">u^{</em>}</span>. This determines the value of <span class="math">e^{<em>}</span>, and also the value of <span class="math">H^{</em>}=\\mathcal{H}_{\\mathsf{bk}}(u^{<em>},e^{</em>},L^{<em>})</span>. Let us also further condition a fixed value of <span class="math">\\bar{x}_{2}+H^{</em>}\\bar{x}_{3}</span> modulo <span class="math">n</span>. This determines the value <span class="math">v^{*}</span>. In the resulting conditional probability space, the output of the encryption oracle, as well as all queries and responses of decryption oracle queries in Probing Phase II are completely determined.</p>

    <p class="text-gray-300">In this conditional probability space, consider a particular invocation of the decryption oracle in Probing Phase II with a ciphertext <span class="math">(u,e,v)</span> and label <span class="math">L</span>, such that <span class="math">(u,e,v,L)\\neq(u^{<em>},e^{</em>},v^{*},L)</span>. Suppose that <span class="math">u\\notin\\mathbf{G}_{n^{\\prime}}\\mathbf{G}_{2}\\mathbf{T}</span>, and that the special rejection rules introduced in Games 1 and 2 do not apply. We consider two cases.</p>

    <p class="text-gray-300"><em>Case 1:</em> <span class="math">(u,e,L)=(u^{<em>},e^{</em>},L^{<em>})</span>. We must have <span class="math">v\\neq v^{</em>}</span>, as <span class="math">(u,e,v,L)\\neq(u^{<em>},e^{</em>},v^{<em>},L)</span>. Because the special rejection rule in Game 2 does not apply, we must have <span class="math">v^{2}\\neq(v^{</em>})^{2}</span>, which implies that <span class="math">u^{2(x_{2}+\\mathcal{H}_{\\mathsf{bk}}(u,e,L)x_{3})}\\neq v^{2}</span>.</p>

    <p class="text-gray-300"><em>Case 2:</em> <span class="math">(u,e,L)\\neq(u^{<em>},e^{</em>},L^{<em>})</span>. As the special rejection rule in Game 1 does not apply, we must have <span class="math">H\\neq H^{</em>}</span>. By the definition of <span class="math">\\mathcal{H}</span>, this implies that <span class="math">H\\not\\equiv H^{<em>}\\ (\\mathrm{mod}\\ p)</span> and <span class="math">H\\not\\equiv H^{</em>}\\ (\\mathrm{mod}\\ q)</span>. This in turn implies that in this conditional probability space, the distribution of <span class="math">\\bar{x}_{2}+H\\bar{x}_{3}</span> modulo <span class="math">n</span> is uniform. It follows that <span class="math">u^{2(x_{2}+\\mathcal{H}_{\\mathsf{bk}}(u,e,L)x_{3})}</span> is uniformly distributed over a particular coset in <span class="math">\\mathbf{G}_{n^{\\prime}}\\mathbf{G}_{n}</span> of the subgroup generated by <span class="math">\\bar{u}</span>. Because <span class="math">v^{2}</span> is fixed in this conditional probability space, it follows that <span class="math">u^{2(x_{2}+\\mathcal{H}_{\\mathsf{bk}}(u,e,L)x_{3})}=v^{2}</span> with probability at most <span class="math">2^{-\\ell}</span>.</p>

    <p class="text-gray-300">The above arguments show that the event <span class="math">F_{8}</span> occurs for a particular decryption query with probability at most <span class="math">2^{-\\ell}</span>. The bound (12) now follows.</p>

    <p class="text-gray-300">Putting together (1)-(12), we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[T_{0}]-1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\mathsf{AdvCRHF}_{A^{\\prime}}(\\lambda)+\\mathsf{AdvFactor}_{A^{\\prime\\prime}}(\\lambda)+\\mathsf{AdvDCR}_{A^{\\prime\\prime\\prime}}(\\lambda)+\\kappa\\cdot 2^{-\\ell}+O(2^{-\\ell}).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Theorem 1 now follows immediately.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">3.3 Extensions to Threshold Decryption</h3>

    <p class="text-gray-300">Our scheme can easily be transformed to provide threshold decryption, where it comes in handy that the knowledge of the factorization of <span class="math">n</span> is not required for decryption. This allows one to reduce the trust assumption for the decryptor when used as a trusted third party. This can be done either along the lines in <em>[x20]</em>, which requires a random oracle security argument, or along the lines in <em>[x1]</em>, which does not require that argument, but for which the decryption protocol is less efficient.</p>

    <h2 id="sec-26" class="text-2xl font-bold">4 The Strong RSA and Factoring Assumptions</h2>

    <p class="text-gray-300">This strong RSA assumption is the following: given a composite modulus <span class="math">n</span> and a random element <span class="math">g\\in\\mathbb{Z}_{n}^{<em>}</span>, it is hard to compute <span class="math">h\\in\\mathbb{Z}_{n}^{</em>}</span> and integer <span class="math">e&gt;1</span> such that <span class="math">h^{e}=g</span>. To be complete, one needs to specify more precisely the distribution from which <span class="math">n</span> is drawn. As in §3, we shall specify that <span class="math">n</span> is of the form <span class="math">pq</span>, where <span class="math">p=2p^{\\prime}+1</span>, <span class="math">q=2q^{\\prime}+1</span>, and <span class="math">p^{\\prime}</span> and <span class="math">q^{\\prime}</span> are uniformly distributed over all <span class="math">\\ell</span>-bit numbers such that <span class="math">p,q,p^{\\prime},q^{\\prime}</span> are prime and <span class="math">p^{\\prime}\\neq q^{\\prime}</span>. We also set <span class="math">n^{\\prime}=p^{\\prime}q^{\\prime}</span>. As usual, <span class="math">\\ell=\\ell(\\lambda)</span>, where <span class="math">\\lambda</span> is a security parameter.</p>

    <p class="text-gray-300">We will make use of both the strong RSA assumption, as well as the assumption that factoring integers <span class="math">n</span> as above is hard. Of course, the strong RSA assumption implies that factoring is hard.</p>

    <p class="text-gray-300">We will make use of these two assumptions as follows. First, we shall make extensive use of the well known fact that if factoring is hard, then it is hard to compute a non-zero multiple of <span class="math">n^{\\prime}</span>. We shall also make use of the fact that if factoring is hard, then it is hard to compute a non-zero multiple of either <span class="math">p^{\\prime}</span> or <span class="math">q^{\\prime}</span>. To see this, suppose that <span class="math">m</span> is a non-zero multiple of <span class="math">p^{\\prime}</span> or <span class="math">q^{\\prime}</span>. If <span class="math">m</span> is a multiple of <span class="math">n^{\\prime}</span>, then the above mentioned result applies. Otherwise, with overwhelming probability, for random <span class="math">z\\in\\mathbb{Z}_{n}^{*}</span>, <span class="math">\\gcd(z^{2m}-1,n)</span> will be either <span class="math">p</span> or <span class="math">q</span>, as the reader may easily check using the Chinese Remainder Theorem. Thus, assuming factoring is hard, we may assume that it is hard to compute a non-zero integer <span class="math">m</span> such that <span class="math">\\gcd(m,n^{\\prime})\\neq 1</span>.</p>

    <p class="text-gray-300">We also shall use the following facts:</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Theorem 2.</h6>

    <p class="text-gray-300">Under the assumption that factoring is hard, given a modulus <span class="math">n</span> (distributed as above), along with random elements <span class="math">g,h\\in(\\mathbb{Z}_{n}^{*})^{2}</span>, it is hard to compute integers <span class="math">a,b</span>, such that</p>

    <p class="text-gray-300"><span class="math">1=g^{a}h^{b}\\ \\ \\mbox{and}\\ \\ (a\\neq 0\\ \\mbox{or}\\ b\\neq 0).</span> (13)</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose there is an algorithm <span class="math">A</span> that takes as input <span class="math">n,g,h</span> as above, and outputs <span class="math">a,b</span> satisfying (13) with non-negligible probability. We can use use <span class="math">A</span> to factor a given <span class="math">n</span>, as follows: generate <span class="math">g\\in(\\mathbb{Z}_{n}^{<em>})^{2}</span> at random — with overwhelming probability, <span class="math">g</span> has order <span class="math">n^{\\prime}</span>; choose <span class="math">r\\in[1,n^{2}]</span> at random, and set <span class="math">h=g^{r}</span> — the distribution of <span class="math">h</span> is statistically close to the uniform distribution on <span class="math">(\\mathbb{Z}_{n}^{</em>})^{2}</span>; feed <span class="math">n,g,h</span> to <span class="math">A</span>, obtaining <span class="math">a,b</span>. With non-negligible probability, we have</p>

    <p class="text-gray-300"><span class="math">g\\ \\mbox{has order}\\ n^{\\prime}\\ \\ ,\\qquad 1=g^{a+rb}\\ \\ ,\\quad\\mbox{and}\\quad(a\\neq 0\\ \\mbox{or}\\ b\\neq 0)\\ .</span> (14)</p>

    <p class="text-gray-300">Claim: with non-negligible probability, not only does (14) hold, but also <span class="math">a+rb\\neq 0</span>. To prove this claim, let us condition on fixed values of <span class="math">n,g,h,a,b</span>, and coins of <span class="math">A</span>, such that <span class="math">A</span> outputs <span class="math">a,b</span> on inputs <span class="math">n,g,h</span>, and such that the conditions in (14) are satisfied. Let us write <span class="math">r=r_{2}n^{\\prime}+r_{1}</span>, where <span class="math">0\\leq r_{1}&lt;n^{\\prime}</span>. In this conditional probability space, the value <span class="math">r_{1}</span> is also fixed, but the distribution of <span class="math">r_{2}</span> is statistically close to the uniform distribution on <span class="math">[4n]</span>. We can write the equation <span class="math">a+rb=0</span> as <span class="math">a+r_{2}n^{\\prime}b+r_{1}b=0</span>, and in this equation all terms are fixed except for <span class="math">r_{2}</span>. We may as well assume that <span class="math">b\\neq 0</span>, as otherwise, <span class="math">a\\neq 0</span> and the equation never holds. There is at most one solution in <span class="math">r_{2}</span> to the equation (as the coefficient <span class="math">n^{\\prime}b</span> is non-zero), and so it holds with only negligible probability. That proves the claim.</p>

    <p class="text-gray-300">The identity <span class="math">g^{a+rb}</span> implies that <span class="math">a+rb</span> is a multiple of <span class="math">n^{\\prime}</span>, and if <span class="math">a+rb\\neq 0</span>, we have a non-zero multiple of <span class="math">n^{\\prime}</span>. ∎</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Theorem 3.</h6>

    <p class="text-gray-300">Under the strong RSA assumption, given a modulus <span class="math">n</span> (distributed as above), along with random elements <span class="math">g,h\\in(\\mathbb{Z}_{n}^{<em>})^{2}</span>, it is hard to compute <span class="math">w\\in\\mathbb{Z}_{n}^{</em>}</span> and integers <span class="math">a,b,c</span> such that</p>

    <p class="text-gray-300"><span class="math">w^{c}=g^{a}h^{b}\\ \\ \\mbox{and}\\ \\ (c\\nmid a\\ \\mbox{or}\\ c\\nmid b).</span> (15)</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose we have an algorithm <span class="math">A</span> that given <span class="math">n,g,h</span> as above, computes <span class="math">w,a,b,c</span> satisfying (15) with non-negligible probability.</p>

    <p class="text-gray-300">Case 1. Let us first consider the case where <span class="math">c=0</span> with non-negligible probability. Then the condition that <span class="math">c\\nmid a</span> or <span class="math">c\\nmid b</span> simply means that <span class="math">a\\neq 0</span> or <span class="math">b\\neq 0</span>, and the result is implied by Theorem 2.</p>

    <p class="text-gray-300">Case 2. Let us next consider the remaining, and more interesting, case where <span class="math">c\\neq 0</span> with non-negligible probability. We may as well assume that <span class="math">\\gcd(c,n^{\\prime})=1</span>, since as was discussed at the beginning of the proof, under the assumption that factoring is hard, it is difficult to compute non-zero <span class="math">c</span> such that <span class="math">\\gcd(c,n^{\\prime})\\neq 1</span>. We now show how we can use <span class="math">A</span> to either factor a given <span class="math">n</span> or find a non-trivial root of a given <span class="math">g</span>, thus contradicting the strong RSA assumption (since a random element of <span class="math">\\mathbb{Z}_{n}^{\\star}</span> is a square with probability <span class="math">1/4</span>).</p>

    <p class="text-gray-300">Given <span class="math">n</span> and <span class="math">g</span>, we proceed as follows. First, note that with overwhelming probability, <span class="math">g</span> has order <span class="math">n^{\\prime}</span>. Let us compute <span class="math">h=g^{r}</span>, for <span class="math">r</span> randomly chosen from <span class="math">[1,n^{2}]</span>, so that the distribution of <span class="math">h</span> is statistically close to the uniform distribution on <span class="math">(\\mathbb{Z}_{n}^{\\star})^{2}</span>. Now we feed <span class="math">n,g,h</span> to <span class="math">A</span>, obtaining <span class="math">w,a,b,c</span>. With non-negligible probability, we have</p>

    <p class="text-gray-300"><span class="math">g\\text{ has order }n^{\\prime},\\ \\ w^{c}=g^{a+rb},\\ \\ c\\neq 0,\\ \\ \\gcd(c,n^{\\prime})=1,\\ \\ \\text{and}\\ \\ c\\nmid a\\enspace.</span> (16)</p>

    <p class="text-gray-300">Claim: with non-negligible probability, not only does (16) hold, but also <span class="math">c\\nmid(a+rb)</span>. To prove this claim, let now condition on fixed values of <span class="math">n,g,h,w,a,b,c</span>, and coins of <span class="math">A</span>, such that <span class="math">A</span> outputs <span class="math">w,a,b,c</span> on inputs <span class="math">n,g,h</span>, and such that the conditions in (16) are satisfied. Let us write <span class="math">r=r_{2}n^{\\prime}+r_{1}</span>, where <span class="math">0\\leq r_{1}&lt;n^{\\prime}</span>. In this conditional probability space, the value <span class="math">r_{1}</span> is also fixed, but the distribution of <span class="math">r_{2}</span> is statistically close to the uniform distribution on <span class="math">[4n]</span>.</p>

    <p class="text-gray-300">Now, consider the congruence</p>

    <p class="text-gray-300"><span class="math">a+rb\\equiv 0\\pmod{c}\\enspace.</span></p>

    <p class="text-gray-300">This congruence holds if and only if</p>

    <p class="text-gray-300"><span class="math">a+r_{1}b+r_{2}n^{\\prime}b\\equiv 0\\pmod{c}\\enspace.</span></p>

    <p class="text-gray-300">Now, in the conditional probability space, all terms in the above congruence are fixed, except for <span class="math">r_{2}</span>. Let us bound from above the probability that this congruence holds. We may as well assume that <span class="math">c\\nmid b</span>, because if <span class="math">c\\mid b</span>, then <span class="math">c\\nmid a</span>, and the congruence will never hold. As <span class="math">\\gcd(c,n^{\\prime})=1</span>, it follows that the solutions <span class="math">r_{2}</span> to the above congruence are uniquely determined modulo <span class="math">c/d^{\\prime}</span>, where <span class="math">d^{\\prime}=\\gcd(c,b)</span>. Since <span class="math">c\\nmid b</span>, it follows that <span class="math">d^{\\prime}</span> is a proper divisor of <span class="math">c</span>, and hence <span class="math">c/d^{\\prime}\\geq 2</span>. Because the distribution of <span class="math">r_{2}</span> is statistically close to the uniform distribution on a very large range, it follows that the congruence holds with probability at most about <span class="math">1/2</span>. This proves the claim.</p>

    <p class="text-gray-300">It is left to show that if <span class="math">c\\nmid(a+rb)</span>, then we can either factor <span class="math">n</span>, or just compute a non-trivial root of <span class="math">g</span>. Let <span class="math">d=\\gcd(c,a+rb)</span>. Since we are assuming that <span class="math">c\\nmid(a+rb)</span>, it follows that <span class="math">c/d\\geq 2</span>. There are integers <span class="math">\\alpha</span> and <span class="math">\\beta</span> such that <span class="math">d=\\alpha c+\\beta(a+rb)</span>, and using the identity <span class="math">w^{c}=g^{a}h^{b}</span>, we have</p>

    <p class="text-gray-300"><span class="math">g^{d}=(w^{\\beta}g^{\\alpha})^{c},</span></p>

    <p class="text-gray-300">and so <span class="math">g=\\zeta(w^{\\beta}g^{\\alpha})^{c/d}</span> for some <span class="math">\\zeta\\mathbb{Z}_{n}^{\\star}</span> with <span class="math">\\zeta^{d}=1</span>. Thus, the order of <span class="math">\\zeta</span> divides <span class="math">d</span>, and of course, since <span class="math">2n^{\\prime}</span> is the exponent of <span class="math">\\mathbb{Z}_{n}^{\\star}</span>, it follows that the order of <span class="math">\\zeta</span> divides <span class="math">\\gcd(d,2n^{\\prime})</span>. Now, since <span class="math">d\\mid c</span> and <span class="math">\\gcd(c,n^{\\prime})=1</span>, we have <span class="math">\\gcd(d,n^{\\prime})=1</span>, from which it follows that <span class="math">\\zeta</span> has order dividing <span class="math">2</span>.</p>

    <p class="text-gray-300">So either <span class="math">\\zeta=\\pm 1</span> or <span class="math">\\gcd(\\zeta-1,n)</span> splits <span class="math">n</span>. In the latter case we have factored <span class="math">n</span>. In the former case we can compute such a root of <span class="math">g</span> as follows. If <span class="math">c/d</span> is even, then <span class="math">(w^{\\beta}g^{\\alpha})^{c/d}\\in(\\mathbb{Z}_{n}^{\\star})^{2}</span> and so (because <span class="math">g\\in(\\mathbb{Z}_{n}^{\\star})^{2}</span>), we must have <span class="math">\\zeta=1</span> (as <span class="math">-1\\notin(\\mathbb{Z}_{n}^{\\star})^{2}</span>). If <span class="math">c/d</span> is odd then <span class="math">g=(\\zeta w^{\\beta}g^{\\alpha})^{c/d}</span>. In either case, we have computed a <span class="math">(c/d)</span>th root of <span class="math">g</span>.</p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300">Discussion. The strong RSA assumption was introduced independently in <em>[x1]</em> and <em>[x10]</em>. Since then, it has been found to be useful in the analysis of many cryptographic schemes (e.g., *[x5, x11]</p>

    <p class="text-gray-300">GHR99, CS00, ACJT00, CL01]<em>). We do not claim that Theorem 3 is new: it has appeared implicitly and in more restricted form in previous papers: the essential idea in the proof of Theorem 3 already appears in </em>[x10]<em>, although that paper deals with a more restricted, and somewhat simpler, setting; also, the paper </em>[x12]<em> implicitly contains a proof of a statement that is very similar to that of Theorem 3. The paper </em>[x17]* also makes some similar claims (implicitly), but some of their proofs are flawed. Theorem 3 is actually a bit more general than we actually need for our paper, but as it is actually a quite useful theorem in several contexts, we prefer to state it in a very general form.</p>

    <h2 id="sec-31" class="text-2xl font-bold">5 Verifiable Encryption</h2>

    <p class="text-gray-300">Loosely speaking, verifiable encryption for a relation <span class="math">\\mathcal{R}</span> is a protocol that allows a prover to convince a verifier that a given ciphertext is an encryption under a given public key of a value <span class="math">w</span> such that <span class="math">(\\delta,w)\\in\\mathcal{R}</span> for a given <span class="math">\\delta</span>.</p>

    <p class="text-gray-300">Asokan et al. <em>[x2, x3]</em> present a protocol for verifiable encryption for the case where <span class="math">w</span> is a homomorphic pre-image of <span class="math">\\delta</span> and Camenisch and Damgård <em>[x11]</em> present a protocol that works for any relation <span class="math">\\mathcal{R}</span> that has a three-move honest-verifier zero-knowledge proof of knowledge where the verifier sends as a second message a random challenge. Both these protocols work for any secure public key encryption scheme. However, they are based on the cut-and-choose paradigm and hence are rather impractical.</p>

    <p class="text-gray-300">In this section we present an efficient verifiable encryption protocol for discrete logarithms in conjunction with the encryption scheme presented in the previous section. We then discuss extensions of this protocol.</p>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">5.1 Definition of Verifiable Encryption</h3>

    <p class="text-gray-300">Before stating the formal definition of verifiable encryption, we begin with a high level discussion of what we are after, along with some auxiliary definitions.</p>

    <p class="text-gray-300">Let <span class="math">(\\mathcal{G},\\mathcal{E},\\mathcal{D})</span> be a public key encryption scheme, and suppose we have generated a key pair <span class="math">(\\mathsf{PK},\\mathsf{SK})</span>.</p>

    <p class="text-gray-300">A verifiable encryption scheme proves that a ciphertext encrypts a plaintext satisfying a certain relation <span class="math">\\mathcal{R}</span>. The relation <span class="math">\\mathcal{R}</span> is defined by a <em>generator</em> algorithm <span class="math">\\mathcal{G}^{\\prime}</span> which on input <span class="math">1^{\\lambda}</span> outputs a <em>description</em> <span class="math">\\Psi=\\Psi[\\mathcal{R},W,\\Delta]</span> of a binary relation <span class="math">\\mathcal{R}</span> on <span class="math">W\\times\\Delta</span>. We require that the sets <span class="math">\\mathcal{R}</span>, <span class="math">W</span>, and <span class="math">\\Delta</span> are easy to recognize (given <span class="math">\\Psi</span>). For <span class="math">\\delta\\in\\Delta</span>, an element <span class="math">w\\in W</span> such that <span class="math">(w,\\delta)\\in\\mathcal{R}</span> is called a <em>witness</em> for <span class="math">\\delta</span>. The idea is that the encryptor will be given a value <span class="math">\\delta</span>, a witness <span class="math">w</span> for <span class="math">\\delta</span>, and a label <span class="math">L</span>, and then encrypts <span class="math">w</span> under <span class="math">L</span>, yielding a ciphertext <span class="math">\\psi</span>. After this, the encryptor may prove to another party that <span class="math">\\psi</span> decrypts under <span class="math">L</span> to a witness for <span class="math">\\delta</span>. In carrying out the proof, the encryptor will of course need to make use of the random coins that were used by the encryption algorithm: we denote by <span class="math">\\mathcal{E}^{\\prime}(\\mathsf{PK},m,L)</span> the pair <span class="math">(\\psi,\\mathit{coins})</span>, where <span class="math">\\psi</span> is the output of <span class="math">\\mathcal{E}(\\mathsf{PK},m,L)</span> and <span class="math">\\mathit{coins}</span> are the random coins used by <span class="math">\\mathcal{E}</span> to compute <span class="math">\\psi</span>.</p>

    <p class="text-gray-300">In such a proof system, the (honest) verifier will output <span class="math">0</span> or <span class="math">1</span>, with <span class="math">1</span> signifying “accept.” We of course shall require that the proof system is sound, in the sense that if a verifier accepts a proof, then with overwhelming probability, <span class="math">\\psi</span> indeed decrypts under <span class="math">L</span> to a witness for <span class="math">\\delta</span>. However, it is convenient, and adequate for many applications, to take a more relaxed approach: instead of requiring that <span class="math">\\psi</span> decrypts under <span class="math">L</span> to a witness, we only require that a witness can be easily reconstructed from the plaintext using some efficient <em>reconstruction</em> algorithm. Such an algorithm <em>recon</em> takes as input a public key <span class="math">\\mathsf{PK}</span>, a relation description <span class="math">\\Psi[\\mathcal{R},W,\\delta]</span>, an element <span class="math">\\delta\\in\\Delta</span>, and a message <span class="math">m\\in M_{\\mathsf{PK}}\\cup\\{\\mathsf{reject}\\}</span>, and outputs <span class="math">w\\in W\\cup\\{\\mathsf{reject}\\}</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">We need to make some technical "compatibility" requirements: we say that an encryption scheme, a relation generator, and a reconstruction algorithm as above are mutually compatible if for all  <span class="math">\\lambda \\geq 0</span> , all  <span class="math">(\\mathsf{PK},\\mathsf{SK}) \\in \\mathcal{G}(1^{\\lambda})</span> , and all  <span class="math">\\Psi[\\mathcal{R},W,\\Delta] \\in \\mathcal{G}&#x27;(1^{\\lambda})</span> , we have</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">W \\subset M_{\\mathsf{PK}}</span> , and</li>

      <li>for all  <span class="math">(w, \\delta) \\in \\mathcal{R}</span> , we have  <span class="math">\\text{recon}(\\mathsf{PK}, \\Psi, \\delta, w) = w</span> .</li>

    </ul>

    <p class="text-gray-300">The first requirement simply says that witness "fit" into the message space, and the second requirement simply says that the reconstruction routine does not modify valid witnesses (together with the correctness property for the encryption scheme, this ensures that an encryption of a witness decrypts and reconstructs to the same witness).</p>

    <p class="text-gray-300">We shall also require that the proof system is special honest-verifier zero knowledge. To formulate this more precisely below, we let  <span class="math">\\text{Trans}(\\mathsf{PK}, \\Psi, \\delta, \\psi, L, c, w, \\text{coins})</span>  denote the transcript seen by a verifier that uses a fixed challenge  <span class="math">c</span> .</p>

    <p class="text-gray-300">Definition 1. A proof system  <span class="math">(\\mathcal{P},\\mathcal{V})</span> , together with mutually compatible encryption scheme  <span class="math">(\\mathcal{G},\\mathcal{E},\\mathcal{D})</span> , relation generator  <span class="math">\\mathcal{G}&#x27;</span> , and reconstruction algorithm recon, form a verifiable encryption scheme, if the following properties hold.</p>

    <p class="text-gray-300">Correctness: for all  <span class="math">(\\mathsf{PK},\\mathsf{SK})\\in \\mathcal{G}(1^{\\lambda})</span>  , for all  <span class="math">\\Psi [\\mathcal{R},W,\\Delta ]\\in \\mathcal{G}&#x27;(1^{\\lambda})</span>  , for all  <span class="math">(w,\\delta)\\in \\mathcal{R}</span>  , for all  <span class="math">L\\in \\{0,1\\} ^*</span>  , for all  <span class="math">(\\psi ,coins)\\in \\mathcal{E}&#x27;(\\mathsf{PK},w,L)</span></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ x \\leftarrow \\mathcal {V} (\\mathrm {P K}, \\Psi , \\delta , \\psi , L) _ {\\mathcal {P} (\\mathrm {P K}, \\Psi , \\delta , \\psi , L, w, c o i n s)}: x = 1 \\right] = 1 - \\operatorname {n e g} (\\lambda).</span></div>

    <p class="text-gray-300">Soundness: for all adversaries  <span class="math">(\\mathcal{A}^<em>,\\mathcal{P}^</em>)</span></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\begin{array}{l} (\\mathsf {P K}, \\mathsf {S K}) \\leftarrow \\mathcal {G} (1 ^ {\\lambda}); \\Psi [ \\mathcal {R}, W, \\Delta ] \\leftarrow \\mathcal {G} ^ {\\prime} (1 ^ {\\lambda}); \\end{array} \\right. \\\\ (\\delta , \\psi , L, a u x) \\leftarrow \\mathcal {A} ^ {*} (\\mathrm {P K}, \\mathrm {S K}, \\Psi); \\\\ x \\leftarrow \\mathcal {V} (\\mathrm {P K}, \\Psi , \\delta , \\psi , L) _ {\\mathcal {P} ^ {*} (a u x)}; \\\\ m \\leftarrow \\mathcal {D} (\\mathrm {S K}, \\psi , L); \\\\ w \\leftarrow \\operatorname {r e c o n} (\\mathrm {P K}, \\Psi , \\delta , m): \\\\ x = 1 \\wedge (w, \\delta) \\notin \\mathcal {R} \\quad ] = \\operatorname {n e g} (\\lambda). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Special honest-verifier zero knowledge: There exists a simulator Sim such that for all adversaries  <span class="math">(\\mathcal{A}^<em>, \\mathcal{B}^</em>, \\mathcal{C}^*)</span> , we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\begin{array}{l} (\\mathsf {P K}, \\mathsf {S K}) \\leftarrow \\mathcal {G} (1 ^ {\\lambda}); \\Psi [ \\mathcal {R}, W, \\Delta ] \\leftarrow \\mathcal {G} ^ {\\prime} (1 ^ {\\lambda}); \\end{array} \\right. \\\\ (w, \\delta , L, a u x) \\leftarrow \\mathcal {A} ^ {*} (\\mathrm {P K}, \\mathrm {S K}, \\Psi), \\text {w h e r e} (w, \\delta) \\in \\mathcal {R}; \\\\ (\\psi , \\text {c o i n s}) \\leftarrow \\mathcal {E} ^ {\\prime} (\\mathrm {P K}, w, L); \\\\ c \\leftarrow \\mathcal {B} ^ {*} (a u x, \\psi); \\\\ b \\leftarrow \\{0, 1 \\}; \\\\ \\text {i f} b = 0 \\\\ \\text {t h e n} \\alpha \\leftarrow \\text {T r a n s} (\\mathrm {P K}, \\Psi , \\delta , \\psi , L, c, w, \\text {c o i n s}) \\\\ e l s e \\alpha \\leftarrow \\operatorname {S i m} (\\mathrm {P K}, \\Psi , \\delta , \\psi , L, c); \\\\ \\hat {b} \\leftarrow \\mathcal {C} ^ {*} (a u x, \\psi , \\alpha): \\\\ b = \\hat {b} \\quad ] = 1 / 2 + \\operatorname {n e g} (\\lambda). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">The above definitions are fairly traditional. Our formulations of soundness and special honest-verifier zero knowledge are basically of the “computational” variety, but where we have taken the notion of “computational” one step further: instead of universally quantifying over the inputs to the verifier (respectively, simulator), we quantify “computationally.” This is technically convenient, and is adequate for most applications.</p>

    <p class="text-gray-300">Also, the above definitions assume that the key for the encryption scheme are generated by a trusted party. While it is possible to define verifiable encryption in a setting where the keys are not generated by a trusted party, the definitions in this case are a bit more complicated and subtle, and we do not present them here. Nevertheless, our protocols would require only slight modification to remain secure in this setting.</p>

    <h3 id="sec-33" class="text-xl font-semibold mt-8">5.2 Verifiable Encryption of a Discrete Logarithm</h3>

    <p class="text-gray-300">Let <span class="math">(\\mathsf{hk},n,g,y_{1},y_{2},y_{3})</span> be a public key of the encryption scheme described in §3. Recall that the message space associated with this public key is <span class="math">[n]</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\Gamma</span> be a cyclic group of order <span class="math">\\rho</span> generated by <span class="math">\\gamma</span>. We assume that <span class="math">\\gamma</span> and <span class="math">\\rho</span> are publicly known, and that <span class="math">\\rho</span> is prime. Let <span class="math">W=[\\rho]</span> and <span class="math">\\Delta=\\Gamma</span>, and let <span class="math">\\mathcal{R}=\\{(w,\\delta)\\in W\\times\\Delta:\\gamma^{w}=\\delta\\}</span>. The “discrete logarithm” relation <span class="math">\\mathcal{R}</span> is the relation with respect to which we want to verifiably encrypt.</p>

    <p class="text-gray-300">We shall of course require that <span class="math">n&gt;\\rho</span> (in fact, we will make a stronger requirement). The reconstruction routine <em>recon</em> will map a plaintext <span class="math">m\\in[n]</span> to the integer <span class="math">(m\\mathop{\\mathrm{rem}}\\nolimits n)\\mod\\rho</span>, i.e., it computes the balanced remainder of <span class="math">m</span> modulo <span class="math">n</span>, and then computes the least non-negative remainder of this modulo <span class="math">\\rho</span>.</p>

    <h4 id="sec-34" class="text-lg font-semibold mt-6">Setup.</h4>

    <p class="text-gray-300">Our protocol requires the auxiliary parameters <span class="math">\\mathfrak{n}</span>, which must the product of two safe <span class="math">(\\mathfrak{l}+1)</span>-bit primes <span class="math">\\mathfrak{p}=2\\mathfrak{p}^{\\prime}+1</span> and <span class="math">\\mathfrak{q}=2\\mathfrak{q}^{\\prime}+1</span>, and <span class="math">\\mathfrak{g}</span> and <span class="math">\\mathfrak{h}</span>, which are two generators of <span class="math">\\mathfrak{G}_{\\mathfrak{n}^{\\prime}}\\subset\\mathbb{Z}_{\\mathfrak{n}}^{<em>}</span>, where <span class="math">\\mathfrak{n}^{\\prime}=\\mathfrak{p}^{\\prime}\\mathfrak{q}^{\\prime}</span>; <span class="math">\\mathfrak{G}_{\\mathfrak{n}^{\\prime}}</span> is the subgroup of <span class="math">\\mathbb{Z}_{\\mathfrak{n}}^{</em>}</span> of order <span class="math">\\mathfrak{n}^{\\prime}</span>, and <span class="math">\\mathfrak{l}=\\mathfrak{l}(\\lambda)</span>.</p>

    <p class="text-gray-300">One may view <span class="math">\\mathfrak{n}</span>, <span class="math">\\mathfrak{g}</span>, and <span class="math">\\mathfrak{h}</span> as additional components of the public key of the encryption scheme, or as system parameters generated by a trusted party. Depending on the setting, we may simply put <span class="math">\\mathfrak{n}:=n</span>. In any event, the prover should not be privy to the factorization of <span class="math">\\mathfrak{n}</span>.</p>

    <p class="text-gray-300">Let <span class="math">k=k(\\lambda)</span> and <span class="math">k^{\\prime}=k^{\\prime}(\\lambda)</span> be further security parameters, where <span class="math">2^{-k(\\lambda)}</span> and <span class="math">2^{-k^{\\prime}(\\lambda)}</span> are negligible functions (<span class="math">\\{0,1\\}^{k}</span> is the “challenge space” of the verifier and <span class="math">k^{\\prime}</span> controls the quality of the zero-knowledge property). We require that <span class="math">2^{k}&lt;\\min\\{p^{\\prime},q^{\\prime},\\mathfrak{p}^{\\prime},\\mathfrak{q}^{\\prime},\\rho\\}</span> holds. Finally, we require that <span class="math">\\rho&lt;n2^{-k-k^{\\prime}-3}</span> holds, i.e., that <span class="math">\\log_{\\gamma}\\delta</span> “fits into an encryption”. (If this condition is not meet, the value <span class="math">\\log_{\\gamma}\\delta</span> could be split into smaller pieces, each of which would then be verifiably encrypted. However, we do not address this here.)</p>

    <h4 id="sec-35" class="text-lg font-semibold mt-6">The protocol.</h4>

    <p class="text-gray-300">The common input of the prover and verifier is: the public key <span class="math">(\\mathsf{hk},n,g,y_{1},y_{2},y_{3})</span>, the augmented public key <span class="math">(\\mathfrak{n},\\mathfrak{g},\\mathfrak{h})</span>, a group element <span class="math">(\\delta)</span>, a ciphertext <span class="math">(u,e,v)</span>, and a label <span class="math">L</span>. The prover has additional inputs <span class="math">m=\\log_{\\gamma}\\delta</span> and <span class="math">r\\in_{R}[n/4]</span> such that</p>

    <p class="text-gray-300"><span class="math">u=g^{r},\\qquad\\qquad\\qquad e=y_{1}^{r}h^{m},\\quad\\text{and}\\qquad\\qquad\\qquad v=\\operatorname{abs}\\left((y_{2}y_{3}^{\\mathcal{H}_{\\mathsf{hk}}(u,e,L)})^{r}\\right)\\ .</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover chooses a random <span class="math">s\\in_{R}[\\mathfrak{n}/4]</span> and computes <span class="math">\\mathfrak{k}:=\\mathfrak{g}^{m}\\mathfrak{h}^{s}</span>. The prover sends <span class="math">\\mathfrak{k}</span> to the verifier.</li>

      <li>Then the prover and verifier engage in the following protocol.</li>

    </ol>

    <p class="text-gray-300">(a) The prover chooses random</p>

    <div class="my-4 text-center"><span class="math-block">r ^ {\\prime} \\in_ {R} [ - n 2 ^ {k + k ^ {\\prime} - 2}, n 2 ^ {k + k ^ {\\prime} - 2} ], s ^ {\\prime} \\in_ {R} [ - \\mathfrak {n} 2 ^ {k + k ^ {\\prime} - 2}, \\mathfrak {n} 2 ^ {k + k ^ {\\prime} - 2} ], m ^ {\\prime} \\in_ {R} [ - \\rho 2 ^ {k + k ^ {\\prime}}, \\rho 2 ^ {k + k ^ {\\prime}} ].</span></div>

    <p class="text-gray-300">The prover computes</p>

    <div class="my-4 text-center"><span class="math-block">u ^ {\\prime} := g ^ {2 r ^ {\\prime}}, e ^ {\\prime} := y _ {1} ^ {2 r ^ {\\prime}} h ^ {2 m ^ {\\prime}}, v ^ {\\prime} := (y _ {2} y _ {3} ^ {\\mathcal {H} _ {\\mathrm {b k}} (u, e, L)}) ^ {2 r ^ {\\prime}}, \\delta^ {\\prime} := \\gamma^ {m ^ {\\prime}}, \\text { and } \\mathfrak {k} ^ {\\prime} := \\mathfrak {g} ^ {m ^ {\\prime}} \\mathfrak {h} ^ {s ^ {\\prime}}.</span></div>

    <p class="text-gray-300">The prover sends  <span class="math">u^{\\prime},e^{\\prime},v^{\\prime},\\delta^{\\prime}</span>  , and  <span class="math">\\mathfrak{k}&#x27;</span>  to the verifier.</p>

    <p class="text-gray-300">(b) The verifier chooses a random challenge  <span class="math">c \\in_{R} \\{0,1\\}^{k}</span>  and sends  <span class="math">c</span>  to the prover. (c) The prover replies with  <span class="math">\\tilde{r} \\coloneqq r&#x27; - cr</span> ,  <span class="math">\\tilde{s} \\coloneqq s&#x27; - cs</span> , and  <span class="math">\\tilde{m} \\coloneqq m&#x27; - cm</span>  (computed in  <span class="math">\\mathbb{Z}</span> ). (d) The verifier checks whether the relations</p>

    <div class="my-4 text-center"><span class="math-block">u ^ {\\prime} = u ^ {2 c} g ^ {2 \\tilde {r}}, \\quad e ^ {\\prime} = e ^ {2 c} y _ {1} ^ {2 \\tilde {r}} h ^ {2 \\tilde {m}}, \\quad v ^ {\\prime} = v ^ {2 c} (y _ {2} y _ {3} ^ {\\mathcal {H} _ {\\mathrm {b k}} (u, e, L)}) ^ {2 \\tilde {r}},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\delta^ {\\prime} = \\delta^ {c} \\gamma^ {\\tilde {m}}, \\quad \\mathfrak {k} ^ {\\prime} = \\mathfrak {k} ^ {c} \\mathfrak {g} ^ {\\tilde {m}} \\mathfrak {h} ^ {\\tilde {s}}, \\quad \\text { and } \\quad - n / 4 &amp;lt;   \\tilde {m} &amp;lt;   n / 4</span></div>

    <p class="text-gray-300">hold. If any of them does not hold, the verifier stops and outputs 0.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If  <span class="math">v = \\mathrm{abs}(v)</span>  the verifier outputs 1; otherwise she outputs 0.</li>

    </ol>

    <p class="text-gray-300">Using notation from [CS97] we denote the sub-protocol of Step 2 as</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} P K \\{(r, m, s): u ^ {2} = g ^ {2 r} \\wedge e ^ {2} = y _ {1} ^ {2 r} h ^ {2 m} \\wedge v ^ {2} = (y _ {2} y _ {3} ^ {\\mathcal {H} _ {\\mathrm {b k}} (u, e, L)}) ^ {2 r} \\wedge \\\\ \\delta = \\gamma^ {m} \\wedge \\mathfrak {k} = \\mathfrak {g} ^ {m} \\mathfrak {h} ^ {s} \\wedge - n / 2 &amp;lt;   m &amp;lt;   n / 2 \\}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Proof of Security. We prove the following theorem about the above system. Given this theorem, one can apply the standard constructions (e.g., [Dam00]) to turn the sub-protocol used in Step 2 into an efficient one that is zero-knowledge w.r.t. any verifier, and can thus obtain a verifiable encryption system that satisfies computational zero-knowledge.</p>

    <p class="text-gray-300">Theorem 4. Under the strong RSA assumption, the above system is a verifiable encryption scheme.</p>

    <p class="text-gray-300">Proof. The correctness and special honest-verifier zero-knowledge properties are easy to verify, and we leave this to the reader.</p>

    <p class="text-gray-300">It remains to consider soundness.</p>

    <p class="text-gray-300">If the success-probability of the prover is non-negligible, then there is a knowledge extractor that produces (in time polynomial in  <span class="math">\\lambda</span>  and with non-negligible probability) two answers  <span class="math">(\\tilde{r}^{(1)},\\tilde{s}^{(1)},\\tilde{m}^{(1)})</span> <span class="math">(\\tilde{r}^{(2)},\\tilde{s}^{(2)},\\tilde{m}^{(2)})</span>  from the prover on two different challenges  <span class="math">c^{(1)}</span>  and  <span class="math">c^{(2)}</span>  w.r.t. the same  <span class="math">u^{\\prime}</span> ,  <span class="math">e^{\\prime}</span> ,  <span class="math">v^{\\prime}</span> ,  <span class="math">\\delta^{\\prime}</span> , and  <span class="math">\\mathfrak{k}&#x27;</span> . W.l.o.g., suppose that  <span class="math">c^{(2)} &amp;gt; c^{(1)}</span> . Let  <span class="math">\\Delta r = \\tilde{r}^{(1)} - \\tilde{r}^{(2)}</span> ,  <span class="math">\\Delta s = \\tilde{s}^{(1)} - \\tilde{s}^{(2)}</span> ,  <span class="math">\\Delta m = \\tilde{m}^{(1)} - \\tilde{m}^{(2)}</span> , and  <span class="math">\\Delta c = c^{(2)} - c^{(1)} &amp;gt; 0</span> . From the verification equations one can derive the following equations:</p>

    <div class="my-4 text-center"><span class="math-block">u ^ {2 \\Delta c} = g ^ {2 \\Delta r} \\quad e ^ {2 \\Delta c} = y _ {1} ^ {2 \\Delta r} h ^ {2 \\Delta m} \\quad v ^ {2 \\Delta c} = (y _ {2} y _ {3} ^ {\\mathcal {H} _ {\\mathrm {b k}} (u, e, L)}) ^ {2 \\Delta r}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\delta^ {\\Delta c} = \\gamma^ {\\Delta m} \\quad \\mathfrak {k} ^ {\\Delta c} = \\mathfrak {g} ^ {\\Delta m} \\mathfrak {h} ^ {\\Delta s}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Now we use the strong RSA assumption. By Theorem 3, since we have computed  <span class="math">\\mathfrak{k},\\Delta m,\\Delta s</span>  and  <span class="math">\\Delta c</span>  such that  <span class="math">\\mathfrak{k}^{\\Delta c} = \\mathfrak{g}^{\\Delta m}\\mathfrak{h}^{\\Delta s}</span> , we may assume that  <span class="math">\\Delta c\\mid \\Delta m</span>  and  <span class="math">\\Delta c\\mid \\Delta s</span> . Also, by construction we have  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; \\min \\{p,q,p',q',\\mathfrak{p},\\mathfrak{q},\\mathfrak{p}',\\mathfrak{q}',\\rho \\}<span class="math">  and hence  </span>\\Delta c<span class="math">  is invertible modulo any of those primes. Let  </span>\\hat{c} = \\Delta c^{-1}\\bmod nn'<span class="math"> . As  </span>u^{2}<span class="math">  has order dividing  </span>nn'<span class="math"> , we get  </span>u^{2} = g^{2\\Delta r\\hat{c}}$ , i.e.,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">u = w _ {1} g ^ {\\Delta r \\hat {c}} \\tag {17}</span></div>

    <p class="text-gray-300">for some <span class="math">w_{1}</span> of order 2. Similarly, we get</p>

    <p class="text-gray-300"><span class="math">e</span> <span class="math">=w_{2}y_{1}^{\\Delta r\\hat{c}}h^{\\Delta m/\\Delta c}</span> (18) <span class="math">v</span> <span class="math">=w_{3}(y_{2}y_{3}^{\\mathcal{H}_{\\mathsf{bk}}(u,e,L)})^{\\Delta r\\hat{c}}</span> (19) <span class="math">\\delta</span> <span class="math">=\\gamma^{\\Delta m/\\Delta c}</span> (20)</p>

    <p class="text-gray-300">for some <span class="math">w_{2}</span> and <span class="math">w_{3}</span> of order 2. It is not hard to see that from <span class="math">v=\\mathrm{abs}(v)</span> and from Eqns. (17)-(19) it follows that decryption of the triple <span class="math">(u,e,v)</span> will provide the integer <span class="math">\\bar{m}:=\\Delta m/\\Delta c\\bmod n</span> modulo <span class="math">n</span> (note that due to the squarings in the decryption algorithm, all the <span class="math">w_{i}</span>’s disappear).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We claim that for <span class="math">\\hat{m}=(\\bar{m}\\operatorname{rem}n)\\bmod\\rho</span> we have <span class="math">\\delta=\\gamma^{\\hat{m}}</span>, i.e., that <span class="math">(u,e,v)</span> is an encryption of <span class="math">\\log_{\\gamma}\\delta</span>. As $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{m}^{(1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{m}^{(2)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><n/4<span class="math"> and </span>\\Delta c\\mid\\Delta m<span class="math">, we must have </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta m/\\Delta c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><n/2<span class="math">. Hence </span>\\Delta m/\\Delta c=((\\Delta m/\\Delta c\\bmod n)\\operatorname{rem}n)=\\bar{m}\\operatorname{rem}n<span class="math"> and therefore </span>\\delta=\\gamma^{\\Delta m/\\Delta c}=\\gamma^{\\hat{m}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">∎</p>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">5.3 Extensions</h3>

    <p class="text-gray-300">Our encryption scheme can be extended as follows to encrypt <span class="math">l</span> messages at once. The idea is to use several <span class="math">y_{1}</span>’s to compute several <span class="math">e</span>’s. That is, the secret key becomes <span class="math">(\\mathsf{hk},x_{1}^{(1)},\\ldots,x_{1}^{(l)},x_{2},x_{3})</span> with <span class="math">x_{1}^{(1)},\\ldots,x_{1}^{(l)},x_{2},x_{3}\\in_{R}[n^{2}/4]</span>, and the public key becomes <span class="math">(\\mathsf{hk},n,g,y_{1}^{(1)},\\ldots,y_{1}^{(l)},y_{2},y_{3})</span> with <span class="math">y_{1}^{(i)}:=g^{x_{1}^{(i)}}</span>. To encrypt a messages <span class="math">m^{(i)}\\in[n]</span> with label <span class="math">L\\in\\{0,1\\}^{*}</span> under a public key as above, choose a random <span class="math">r\\in_{R}[n/4]</span> and compute</p>

    <p class="text-gray-300"><span class="math">u:=g^{r}\\enspace,\\qquad\\qquad e^{(i)}:=\\left(y_{1}^{(i)}\\right)^{r}h^{m^{(i)}}\\enspace,\\quad\\text{and}\\qquad\\qquad v:=\\mathrm{abs}\\left((y_{2}y_{3}^{\\mathcal{H}_{\\mathsf{bk}}(u,e,L)})^{r}\\right)\\enspace.</span></p>

    <p class="text-gray-300">To decrypt a ciphertext <span class="math">(u,e^{(1)},\\ldots,e^{(l)},v)</span> with label <span class="math">L</span> under a secret key as above, first check that <span class="math">\\mathrm{abs}(v)=v</span> and <span class="math">u^{2(x_{2}+\\mathcal{H}_{\\mathsf{bk}}(u,e,L)x_{3})}=v^{2}</span>. If this does not hold, then output reject and halt. Next, let <span class="math">t=2^{-1}\\bmod n</span>, and compute <span class="math">\\hat{m}^{(i)}:=(e^{(i)}/u^{x_{1}^{(i)}})^{2t}</span>. If all <span class="math">\\hat{m}^{(i)}</span>’s are of the form <span class="math">h^{m^{(i)}}</span> for some <span class="math">m^{(i)}\\in[n]</span>, then output the <span class="math">m^{(i)}</span>’s; otherwise, output reject. It is easy to prove this encryption scheme secure.</p>

    <p class="text-gray-300">It is now straightforward to extend our verifiable encryption protocol to the above encryption scheme to obtain to a verifiable encryption scheme that encrypts a (subset of a) representation of a group element with respect to several bases.</p>

    <p class="text-gray-300">Further, all of these protocols can be easily adapted to the case where the order of the group <span class="math">\\Gamma</span> is not known, i.e., a subgroup of of <span class="math">\\mathbb{Z}_{N}^{*}</span> for an RSA-modulus <span class="math">N</span>.</p>

    <h2 id="sec-37" class="text-2xl font-bold">6 Proving the Inequality of Discrete Logarithms</h2>

    <p class="text-gray-300">Our protocol for verifiable decryption (below) requires that one party proves to another party whether or not two discrete logarithms are equal, where one of the discrete logarithms might <em>not be known</em> to the prover (that is, in the case the discrete logarithms are not equal). There are well-known, efficient, special honest-verifier zero-knowledge proof systems for proving that two discrete logarithms are equal (see <em>[x10]</em>), so we focus on the problem of proving that two discrete logarithms are unequal. We discuss an efficient protocol for this problem separately as it is of independent interest and as the algebraic setting here is simpler than the one in which we use it in the next section.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Let <span class="math">G=\\langle g\\rangle</span> be a group of prime order <span class="math">q</span>. The prover and verifier have common inputs <span class="math">g,h,y,z\\in G</span>, where <span class="math">g</span> and <span class="math">h</span> are generators for <span class="math">G</span>, and <span class="math">\\log_{g}y\\neq\\log_{h}z</span>. The prover has the additional input <span class="math">x=\\log_{g}y</span>. The prover and verifier then engage in the following protocol.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover chooses <span class="math">r\\in_{R}\\mathbb{Z}_{q}</span>, computes the auxiliary commitment <span class="math">C=(h^{x}/z)^{r}</span>, and sends <span class="math">C</span> to the verifier.</li>

      <li>The prover executes the protocol denoted</li>

    </ol>

    <p class="text-gray-300"><span class="math">PK\\{(\\alpha,\\beta):\\ C=h^{\\alpha}\\big{(}\\frac{1}{z}\\big{)}^{\\beta}\\ \\wedge\\ 1=g^{\\alpha}\\big{(}\\frac{1}{y}\\big{)}^{\\beta}\\}</span></p>

    <p class="text-gray-300">with the verifier.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier accepts if it accepts in Step 2, and if <span class="math">C\\neq 1</span>; otherwise, the verifier rejects.</li>

    </ol>

    <p class="text-gray-300">Note that in an actual implementation, the value <span class="math">C</span> may be sent to the verifier as part of the first message in the sub-protocol in Step 2.</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Theorem 5.</h6>

    <p class="text-gray-300">The above protocol is a special honest-verifier proof system for proving that <span class="math">\\log_{g}y\\neq\\log_{h}z</span>.</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Correctness of the protocol is by inspection.</p>

    <p class="text-gray-300">Consider the protocol’s soundness. If a prover can make an honest verifier accept with non-negligible probability, then using standard rewinding arguments, there exist values <span class="math">\\alpha</span> and <span class="math">\\beta</span> such that the equations</p>

    <p class="text-gray-300"><span class="math">C</span> <span class="math">=h^{\\alpha}\\big{(}\\frac{1}{z}\\big{)}^{\\beta}</span> <span class="math">1</span> <span class="math">=g^{\\alpha}\\big{(}\\frac{1}{y}\\big{)}^{\\beta}</span> (21)</p>

    <p class="text-gray-300">hold. From the second equation of (21) one can conclude that</p>

    <p class="text-gray-300"><span class="math">\\alpha\\equiv\\beta\\log_{g}y\\pmod{q}\\enspace.</span></p>

    <p class="text-gray-300">Substituting <span class="math">\\beta\\log_{g}y</span> for <span class="math">\\alpha</span> in the first equation of (21), we get <span class="math">C=(h^{\\log_{g}y}/z)^{\\beta}</span>. As the verifier accepts only if <span class="math">C\\neq 1</span>, this implies that <span class="math">h^{\\log_{g}y}/z\\neq 1</span>, i.e., that <span class="math">\\log_{g}y\\neq\\log_{h}z</span>.</p>

    <p class="text-gray-300">To see that the protocol is special honest-verifier zero knowledge, note that in an actual run of the protocol with an honest prover, <span class="math">C</span> is a random element of <span class="math">G</span>. Thus, the simulator can simply generate <span class="math">C</span> at random, and then use the simulator for the proof in Step 2. ∎</p>

    <p class="text-gray-300">Let us briefly discuss related work. Independently of our work, Bresson and Stern <em>[x1]</em> provide a protocol to prove that two discrete logarithms are not equal that is similar to ours. However, their protocol is about a factor of two less efficient than ours and is only computationally sound. Also, we note that the protocol proposed by Michels and Stadler <em>[x10]</em> to prove whether or not two discrete logarithms are equal is <em>not</em> zero knowledge because it reveals the value <span class="math">h^{x}</span> (which the simulator can not compute, but a (dishonest) verifier can if he chooses <span class="math">h</span> such the he knows <span class="math">\\log_{g}h</span>).</p>

    <h2 id="sec-40" class="text-2xl font-bold">7 Verifiable Decryption</h2>

    <p class="text-gray-300">In this section we provide a protocol that allows the decryptor to prove that she decrypted correctly. In particular, we provide a protocol that allows the decryptor to prove whether or not a given ciphertext decrypts to a given plaintext. We then extend the protocol to one for proving whether or not a given ciphertext decrypts to the discrete logarithm of a given group element.</p>

    <p class="text-gray-300">7.1 Definition of Verifiable Decryption</p>

    <p class="text-gray-300">Verifiable decryption is a protocol between a prover, knowing the decryption key, and a verifier, who as the result of the protocol either rejects or learns whether or not a given ciphertext decrypts under a given label to a plaintext that satisfies a given relation.</p>

    <p class="text-gray-300">We adopt the notation and terminology in §5.1. In addition, for mutually compatible encryption scheme encryption scheme <span class="math">(\\mathcal{G},\\mathcal{E},\\mathcal{D})</span>, relation generator <span class="math">\\mathcal{G}^{\\prime}</span>, and reconstruction algorithm <em>recon</em>, we define the function <span class="math">f</span> that for all <span class="math">(\\mathsf{PK},\\mathsf{SK})\\in\\mathcal{G}(1^{\\lambda})</span>, all <span class="math">\\Psi[\\mathcal{R},W,\\Delta]\\in\\mathcal{G}^{\\prime}</span>, all <span class="math">\\psi,L\\in\\{0,1\\}^{*}</span>, and all <span class="math">\\delta\\in\\Delta</span></p>

    <p class="text-gray-300">\\[ f(\\Psi,\\delta,\\psi,L,\\mathsf{SK})=\\begin{cases}+1&\\text{if }(\\text{recon}(\\mathsf{PK},\\Psi,\\delta,\\mathcal{D}(\\mathsf{SK},\\psi,L)),\\delta)\\in\\mathcal{R};\\\\ -1&\\text{otherwise.}\\end{cases} \\]</p>

    <p class="text-gray-300">The (honest) verifier in a verifiable decryption protocol will output either a value <span class="math">\\pm 1</span>, indicating that this is the value of <span class="math">f</span>, or the value <span class="math">0</span>, indicating that the proof is invalid.</p>

    <p class="text-gray-300">A difficulty in defining soundness for verifiable decryption is that for many public key encryption schemes (including ours and, e.g., the ElGamal based Cramer-Shoup one <em>[x10]</em>), it is not well defined whether or not a ciphertext is valid given only the public key. More precisely, there are ciphertexts that can be both valid and invalid, depending on the actual value of the secret key. Hence, it is in principle possible that the decryptor/prover could change her mind about such ciphertexts, which seems inappropriate. In the following definition, we assume that the public and secret key are generated by a trusted party which allows us to define soundness in terms of the secret key and public key rather than only the public key. As for verifiable encryption, the definitions for the setting where the keys are not generated by a trusted party are a bit more complicated and subtle, and we do not present them here. However, our protocols would require only slight modification to remain secure in this setting.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Definition 2.</h6>

    <p class="text-gray-300">A proof system <span class="math">(\\mathcal{P},\\mathcal{V})</span>, together with mutually compatible encryption scheme <span class="math">(\\mathcal{G},\\mathcal{E},\\mathcal{D})</span>, relation generator <span class="math">\\mathcal{G}^{\\prime}</span>, and reconstruction algorithm <em>recon</em>, form a <em>verifiable decryption scheme</em>, if the following properties hold.</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Correctness:</h6>

    <p class="text-gray-300">For all <span class="math">(\\mathsf{PK},\\mathsf{SK})\\in\\mathcal{G}(1^{\\lambda})</span>, for all <span class="math">\\Psi[\\mathcal{R},W,\\Delta]\\in\\mathcal{G}^{\\prime}(1^{\\lambda})</span>, for all <span class="math">\\delta\\in\\Delta</span>, for all <span class="math">\\psi,L\\in\\{0,1\\}^{*}</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr[x\\leftarrow\\mathcal{V}(\\mathsf{PK},\\Psi,\\delta,\\psi,L)_{\\mathcal{P}(\\mathsf{PK},\\Psi,\\delta,\\psi,L,\\mathsf{SK})}:x=f(\\Psi,\\delta,\\psi,L,SK)]=1-\\text{neg}(\\lambda)\\enspace.</span></p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Soundness:</h6>

    <p class="text-gray-300">For all adversaries <span class="math">(\\mathcal{A}^{<em>}</span>, <span class="math">\\mathcal{P}^{</em>})</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\enspace</span> <span class="math">(\\mathsf{PK},\\mathsf{SK})\\leftarrow\\mathcal{G}(1^{\\lambda});\\Psi[\\mathcal{R},W,\\Delta]\\leftarrow\\mathcal{G}^{\\prime}(1^{\\lambda});</span> <span class="math">(\\delta,\\psi,L,\\text{aux})\\leftarrow\\mathcal{A}^{<em>}(\\mathsf{PK},\\mathsf{SK},\\Psi);</span> <span class="math">x\\leftarrow\\mathcal{V}(\\mathsf{PK},\\Psi,\\delta,\\psi,L)_{\\mathcal{P}^{</em>}(\\text{aux})}:</span> <span class="math">x=-f(\\Psi,\\delta,\\psi,L,SK)\\enspace\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad \\quad\\quad 1\\enspace\\quad\\text{neg}(\\lambda)\\enspace.</span></p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Special honest-verifier zero knowledge:</h6>

    <p class="text-gray-300">There exists a simulator Sim such that for all adve</p>

    <p class="text-gray-300">saries <span class="math">(\\mathcal{A}^{<em>}</span>, <span class="math">\\mathcal{B}^{</em>})</span>, we have</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\quad</span> <span class="math">(\\mathsf{PK},\\mathsf{SK})\\leftarrow\\mathcal{G}(1^{\\lambda});\\Psi[\\mathcal{R},W,\\Delta]\\leftarrow\\mathcal{G}^{\\prime}(1^{\\lambda});</span> <span class="math">(\\delta,\\psi,L,c,\\text{aux})\\leftarrow\\mathcal{A}^{<em>}(\\mathsf{PK},\\mathsf{SK},\\Psi);</span> <span class="math">b\\leftarrow\\{0,1\\};</span> if <span class="math">b=0</span> <span class="math">\\text{then }\\alpha\\leftarrow\\text{Trans}(\\mathsf{PK},\\Psi,\\delta,\\psi,L,c,\\mathsf{SK})</span> <span class="math">\\text{else }\\ \\alpha\\leftarrow\\text{Sim}(\\mathsf{PK},\\Psi,\\delta,\\psi,L,c,f(\\Psi,\\delta,\\psi,L,\\mathsf{SK}));</span> <span class="math">\\hat{b}\\leftarrow\\mathcal{B}^{</em>}(\\text{aux},\\alpha):</span> <span class="math">b=\\hat{b}</span> <span class="math">]\\ \\ =1/2+\\text{neg}(\\lambda)\\enspace.</span></p>

    <h3 id="sec-45" class="text-xl font-semibold mt-8">7.2 Verifiable Decryption of a Matching Plaintext</h3>

    <p class="text-gray-300">We give a protocol for the decryptor to prove whether or not a ciphertext <span class="math">(u,e,v)</span> decrypts to a message <span class="math">m</span> under label <span class="math">L</span>, i.e., using this protocol she can show that she did correctly decrypt. This is a special case of verifiable decryption in which the relation <span class="math">\\mathcal{R}</span> is equality, and the reconstruction routine returns its last input as its output.</p>

    <p class="text-gray-300">For our encryption scheme in §3, this proof corresponds to proving whether or not the two equations</p>

    <p class="text-gray-300"><span class="math">u^{2(x_{2}+\\mathcal{H}_{\\text{bk}}(u,e,L)x_{3})}/v^{2}=1</span> <span class="math">\\text{and}</span> <span class="math">(e/u^{x_{1}})^{2}/h^{2m}=1</span> (22)</p>

    <p class="text-gray-300">hold (assuming that the public test <span class="math">\\text{abs}(v)=v</span> is satisfied). If the ciphertext is invalid, one or both of the two statements do not hold. If the ciphertext is valid but decrypts to another message, the first statement holds but the second one does not.</p>

    <p class="text-gray-300">Proving that both of these equations hold is a fairly straightforward application of known techniques.</p>

    <p class="text-gray-300">To prove that at least one of the equations does not hold, we can use the “proof of partial knowledge” technique of <em>[x10]</em>, combined with the technique developed in §6. However, because in the present setting the group has non-prime order we can not prove the relationship among the secrets in the same way as in §6 and, more importantly, the resulting protocol would not be zero-knowledge. The former problem can be solved using an auxiliary group <span class="math">\\mathfrak{G}_{\\mathfrak{n}^{\\prime}}\\subset\\mathbb{Z}_{\\mathfrak{n}}^{*}</span> as we did in §5. We consider the latter problem. Depending on the values of the secret keys <span class="math">x_{1}</span>, <span class="math">x_{2}</span>, and <span class="math">x_{3}</span>, the left hand sides of the equations (22), and thus the auxiliary commitments to be provided in the protocol, lie in different (sub-)groups, i.e., in <span class="math">\\mathbf{G}_{n}</span>, <span class="math">\\mathbf{G}_{n^{\\prime}}</span>, or <span class="math">\\mathbf{G}_{n}\\mathbf{G}_{n^{\\prime}}</span>. As the simulator does not know the values <span class="math">x_{1}</span>, <span class="math">x_{2}</span>, and <span class="math">x_{3}</span>, it can not simulate these auxiliary commitments. We solve this problem using the fact that for all elements <span class="math">a\\in\\mathbf{G}_{n}\\mathbf{G}_{n^{\\prime}}</span> we have</p>

    <p class="text-gray-300"><span class="math">a\\neq 1\\qquad\\Leftrightarrow\\qquad(a^{n}\\in\\mathbf{G}_{n^{\\prime}}\\wedge a^{n}\\neq 1)\\quad\\vee\\quad(a\\in\\mathbf{G}_{n}\\wedge a\\neq 1)\\enspace.</span></p>

    <p class="text-gray-300">Thus, to prove that (at least) one of the equations (22) does not hold, we prove that either</p>

    <p class="text-gray-300"><span class="math">\\Big{(}\\frac{u^{2(x_{2}+\\mathcal{H}_{\\text{bk}}(u,e,L)x_{3})}}{v^{2}}\\Big{)}^{n}\\neq 1</span> (23)</p>

    <p class="text-gray-300">or</p>

    <p class="text-gray-300"><span class="math">\\Big{(}\\frac{u^{2(x_{2}+\\mathcal{H}_{\\text{bk}}(u,e,L)x_{3})}}{v^{2}}\\Big{)}^{n}=1\\qquad\\qquad\\text{and}\\qquad\\qquad\\frac{u^{2(x_{2}+\\mathcal{H}_{\\text{bk}}(u,e,L)x_{3})}}{v^{2}}\\neq 1</span> (24)</p>

    <p class="text-gray-300">or</p>

    <p class="text-gray-300"><span class="math">\\Big{(}\\frac{(e/u^{x_{1}})^{2}}{h^{2m}}\\Big{)}^{n}=(e/u^{x_{1}})^{2n}\\neq 1</span> (25)</p>

    <p class="text-gray-300">or</p>

    <p class="text-gray-300"><span class="math">\\Big{(}\\frac{(e/u^{x_{1}})^{2}}{h^{2m}}\\Big{)}^{n}=1\\qquad\\qquad\\text{and}\\qquad\\qquad\\frac{(e/u^{x_{1}})^{2}}{h^{2m}}\\neq 1</span> (26)</p>

    <p class="text-gray-300">holds. Now, whenever one of the four cases applies it is always well defined in which group the left-hand sides of the inequalities lie and we can apply the ideas underlying the protocol in §6 to prove that at least one of these four inequalities applies. We remark that the case where the statements (23-25) are false but the statement (26) is true corresponds to the case where the ciphertext is a valid encryption of a message different from <span class="math">m</span>. If any of the statements (23-25) is true corresponds to the cases where the ciphertext is invalid.</p>

    <p class="text-gray-300">We are now ready to describe the protocol between the decryptor and a verifier. Their common input is <span class="math">(\\mathsf{hk},n,g,y_{1},y_{2},y_{3})</span>, <span class="math">(\\mathfrak{n},\\mathfrak{g},\\mathfrak{h})</span>, <span class="math">(u,e,v)</span>, <span class="math">m</span>, and <span class="math">L</span> and the additional input to the decryptor is <span class="math">(x_{1},x_{2},x_{3})</span>. The triple <span class="math">(\\mathfrak{n},\\mathfrak{g},\\mathfrak{h})</span> is an auxiliary parameter as in the one previous section. (As we assume here that <span class="math">n</span> is generated by a trusted party as well, i.e., that the decryptor is not provided with <span class="math">n</span>’s factorization; also, <span class="math">n</span> and <span class="math">\\mathfrak{n}</span> could be identical.) In the following description we assume that all the messages the prover sends to the verifier prior to the execution of one of the possible PK protocols will in fact be bundled with the first message of that PK protocol. Here we provide the proof-protocols only by high-level notation; the actual protocols are easily derived from it (cf. also the the verifiable encryption protocol presented in §5 and its high-level notation).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">m\\not\\in[n]</span> or the ciphertext is malformed, (e.g., if <span class="math">v\\neq\\text{abs}(v)</span>), the verifier outputs <span class="math">-1</span>, and the protocol stops.</li>

      <li>If <span class="math">(u,e,v)</span> is a valid ciphertext and decrypts to <span class="math">m</span> under label <span class="math">L</span>, the decryptor sends <span class="math">1</span> to the verifier, and then engages in the protocol denoted</li>

    </ol>

    <p class="text-gray-300"><span class="math">PK\\{(x_{1},x_{2},x_{3}):y_{1}=g^{x_{1}}\\ \\wedge\\ y_{2}=g^{x_{2}}\\ \\wedge\\ y_{3}=g^{x_{3}}\\ \\wedge v^{2}=u^{2x_{2}}u^{2\\mathcal{H}_{\\text{bk}}(u,e,L)x_{3}}\\ \\wedge\\ \\frac{e^{2}}{h^{2m}}=u^{2x_{1}}\\}</span></p>

    <p class="text-gray-300">with the verifier.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">(u,e,v)</span> is an invalid ciphertext w.r.t. the label <span class="math">L</span> or decrypts to some message different from <span class="math">m</span> under <span class="math">L</span>, then the decryptor sends <span class="math">-1</span> to the verifier. They proceed as follows.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The decryptor chooses <span class="math">a_{1}\\in_{R}[n/4]</span>, <span class="math">a_{2}\\in_{R}[n^{2}/4]</span>, <span class="math">a_{3}\\in_{R}[n/4]</span>, and <span class="math">a_{4}\\in_{R}[n^{2}/4]</span>, along with <span class="math">b_{1},b_{2},b_{3},b_{3}\\in_{R}[\\mathfrak{n}/4]</span>.</li>

    </ol>

    <p class="text-gray-300">She then computes <span class="math">\\mathfrak{C}_{1}:=\\mathfrak{g}^{a_{1}}\\mathfrak{h}^{b_{1}}</span>, <span class="math">\\mathfrak{C}_{2}:=\\mathfrak{g}^{a_{2}}\\mathfrak{h}^{b_{2}}</span>, <span class="math">\\mathfrak{C}_{3}:=\\mathfrak{g}^{a_{3}}\\mathfrak{h}^{b_{3}}</span>, and <span class="math">\\mathfrak{C}_{4}:=\\mathfrak{g}^{a_{4}}\\mathfrak{h}^{b_{4}}</span>.</p>

    <p class="text-gray-300">She chooses <span class="math">C_{1}\\in_{R}\\mathbf{G}_{n^{\\prime}}</span>, <span class="math">C_{2}\\in_{R}\\mathbf{G}_{n}</span>, <span class="math">C_{3}\\in_{R}\\mathbf{G}_{n^{\\prime}}</span>, and <span class="math">C_{4}\\in_{R}\\mathbf{G}_{n}</span>.</p>

    <p class="text-gray-300">Furthermore,</p>

    <p class="text-gray-300"><span class="math">\\text{(Case 1) if }u^{2n(x_{2}+\\mathcal{H}_{\\text{bk}}(u,e,L)x_{3})}\\neq v^{2n},\\ \\ \\text{ she sets }\\qquad</span> <span class="math">C_{1}:=(u^{x_{2}+\\mathcal{H}_{\\text{bk}}(u,e,L)x_{3}}/v)^{2na_{1}},</span> <span class="math">\\text{(Case 2) else if }u^{2(x_{2}+\\mathcal{H}_{\\text{bk}}(u,e,L)x_{3})}\\neq v^{2},\\ \\ \\text{ she sets }\\qquad</span> <span class="math">C_{2}:=(u^{x_{2}+\\mathcal{H}_{\\text{bk}}(u,e,L)x_{3}}/v)^{2a_{2}},</span> <span class="math">\\text{(Case 3) else if }(u^{x_{1}}/e)^{2}\\not\\in\\langle h\\rangle,\\ \\ \\text{ she sets }\\qquad</span> <span class="math">C_{3}:=(u^{x_{1}}/e)^{2na_{3}},</span> <span class="math">\\text{(Case 4) else }(u^{x_{1}}/e)^{2}\\neq h^{2m},\\ \\ \\text{ and she sets }\\qquad</span> <span class="math">C_{4}:=(u^{x_{1}}h^{m}/e)^{2a_{4}}\\ \\ .</span></p>

    <p class="text-gray-300">The decryptor sends <span class="math">C_{1}</span>, <span class="math">C_{2}</span>, <span class="math">C_{3}</span>, <span class="math">C_{4}</span>, <span class="math">\\mathfrak{C}_{1}</span>, <span class="math">\\mathfrak{C}_{2}</span>, <span class="math">\\mathfrak{C}_{3}</span>, and <span class="math">\\mathfrak{C}_{4}</span> to the verifier.</p>

    <p class="text-gray-300">(b) The decryptor and the verifier carry out the protocol denoted</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} PK \\Bigl \\{(x_1, x_2, x_3, a_1, \\ldots, a_4, b_1, \\ldots, b_4, r_1, \\ldots, r_4 \\, s_1, \\ldots, s_4): \\\\ \\quad \\left[ y_1 = g^{x_1} \\wedge y_2 = g^{x_2} \\wedge y_3 = g^{x_3} \\wedge \\right. \\\\ \\quad \\left. C_1 = u^{2nr_1} \\left(\\frac{1}{v}\\right)^{2na_1} \\wedge \\mathfrak{C}_1 = \\mathfrak{g}^{a_1} \\mathfrak{h}^{b_1} \\wedge 1 = \\left(\\frac{1}{\\mathfrak{C}_1}\\right)^{x_2} \\left(\\frac{1}{\\mathfrak{C}_1}\\right)^{\\mathcal{H}_{\\mathfrak{h}k}(u, e, L) x_3} \\mathfrak{g}^{r_1} \\mathfrak{h}^{s_1} \\right] \\\\ \\vee \\left[ y_1 = g^{x_1} \\wedge y_2 = g^{x_2} \\wedge y_3 = g^{x_3} \\wedge \\right. \\\\ \\quad \\left. C_2 = u^{2r_2} \\left(\\frac{1}{v}\\right)^{a_2} \\wedge \\mathfrak{C}_2 = \\mathfrak{g}^{a_2} \\mathfrak{h}^{b_2} \\wedge 1 = \\left(\\frac{1}{\\mathfrak{C}_2}\\right)^{x_2} \\left(\\frac{1}{\\mathfrak{C}_2}\\right)^{\\mathcal{H}_{\\mathfrak{h}k}(u, e, L) x_3} \\mathfrak{g}^{r_2} \\mathfrak{h}^{s_2} \\right] \\\\ \\vee \\left[ y_1 = g^{x_1} \\wedge y_2 = g^{x_2} \\wedge y_3 = g^{x_3} \\wedge \\right. \\\\ \\quad \\left. C_3 = u^{2nr_3} \\left(\\frac{1}{e}\\right)^{2na_3} \\wedge \\mathfrak{C}_3 = \\mathfrak{g}^{a_3} \\mathfrak{h}^{b_3} \\wedge 1 = \\left(\\frac{1}{\\mathfrak{C}_3}\\right)^{x_1} \\mathfrak{g}^{r_3} \\mathfrak{h}^{s_3} \\right] \\\\ \\vee \\left[ y_1 = g^{x_1} \\wedge y_2 = g^{x_2} \\wedge y_3 = g^{x_3} \\wedge \\right. \\\\ \\quad \\left. C_4 = u^{2r_4} \\left(\\frac{h^m}{e}\\right)^{2a_4} \\wedge \\mathfrak{C}_4 = \\mathfrak{g}^{a_4} \\mathfrak{h}^{b_4} \\wedge 1 = \\left(\\frac{1}{\\mathfrak{C}_4}\\right)^{x_1} \\mathfrak{g}^{r_4} \\mathfrak{h}^{s_4} \\right] \\Biggr \\}, \\end{array}</span></div>

    <p class="text-gray-300">where <span class="math">r_1, \\ldots, r_4, s_1, \\ldots, s_4</span> are temporary secrets (i.e.,</p>

    <div class="my-4 text-center"><span class="math-block">r_1 = a_1 (x_2 + \\mathcal{H}_{\\mathfrak{h}k}(u, e, L) x_3), \\quad s_1 = b_1 (x_2 + \\mathcal{H}_{\\mathfrak{h}k}(u, e, L) x_3),</span></div>

    <div class="my-4 text-center"><span class="math-block">r_2 = a_2 (x_2 + \\mathcal{H}_{\\mathfrak{h}k}(u, e, L) x_3), \\quad s_2 = b_2 (x_2 + \\mathcal{H}_{\\mathfrak{h}k}(u, e, L) x_3),</span></div>

    <div class="my-4 text-center"><span class="math-block">r_3 = x_1 a_3, \\quad s_3 = x_1 b_3,</span></div>

    <div class="my-4 text-center"><span class="math-block">r_4 = x_1 a_4, \\quad s_4 = x_1 b_4,</span></div>

    <p class="text-gray-300">(computed in <span class="math">\\mathbb{Z}</span>)). (To derive the actual protocol one may to apply the techniques by Cramer et al.[CDS94] for realizing the <span class="math">\\vee</span>'s.)</p>

    <p class="text-gray-300">(c) The verifier checks that <span class="math">C_1^2 \\neq 1</span>, <span class="math">C_2^2 \\neq 1</span>, <span class="math">C_3^2 \\neq 1</span>, and <span class="math">C_4^2 \\neq 1</span>.</p>

    <p class="text-gray-300">The computational load of the prover and the verifier is about one to four times the load in the protocol for verifiable encryption described in the previous section (depending on whether Step 2 or Step 3 gets carried out).</p>

    <p class="text-gray-300">Theorem 6. Assuming factoring is hard, the above scheme is a verifiable decryption scheme (for matching plaintexts).</p>

    <p class="text-gray-300">Proof. Correctness is trivial, and we leave this to the reader.</p>

    <p class="text-gray-300">We now show that the protocol is special honest-verifier computational zero-knowledge by providing a simulator.</p>

    <p class="text-gray-300">First the simulator executes step 1 of the protocol as the decryptor would, that is, if <span class="math">m \\notin [n]</span> or if the ciphertext is malformed the simulator stops. The simulator queries an oracle to determine whether or not <span class="math">\\psi</span> decrypts to <span class="math">m</span>. If it does, it sends the verifier 1 it simulates step 2 by the simulator for the <span class="math">PK</span>-protocol of step 2. If does not, it simulates step 3 as follows. First the simulator sends the verifier <span class="math">-1</span>. Then it chooses <span class="math">b_1, b_2, b_3, b_4 \\in_{R} [\\mathfrak{n}/4]</span>. It then computes <span class="math">\\mathfrak{C}_1 := \\mathfrak{h}^{b_1}</span>, <span class="math">\\mathfrak{C}_2 := \\mathfrak{h}^{b_2}</span>, <span class="math">\\mathfrak{C}_3 := \\mathfrak{h}^{b_3}</span>, and <span class="math">\\mathfrak{C}_4 := \\mathfrak{h}^{b_4}</span>. It chooses <span class="math">C_1 \\in_{R} \\mathbf{G}_{n&#x27;}</span>, <span class="math">C_2 \\in_{R} \\mathbf{G}_n</span>, <span class="math">C_3 \\in_{R} \\mathbf{G}_{n&#x27;}</span>, and <span class="math">C_4 \\in_{R} \\mathbf{G}_n</span>. Next it invokes the simulator for the <span class="math">PK</span>-protocol of step 3. This concludes the simulator.</p>

    <p class="text-gray-300">26</p>

    <p class="text-gray-300">It remains to show that the simulator indeed works. It is clear that the simulation of steps 1 and 2 works. Consider step 3.</p>

    <p class="text-gray-300">Note that in the real run as well as in the simulation the pairs <span class="math">(\\mathfrak{C}_1,C_1),\\ldots ,(\\mathfrak{C}_4,C_4)</span> are independently distributed. Moreover they obviously have the same distribution in the simulation as in the real run except for the one pair for which the prover replaces the <span class="math">C_i</span>.</p>

    <p class="text-gray-300">We consider the cases where the prover replaces <span class="math">C_1</span> and <span class="math">C_2</span>, respectively. The remaining two cases are analogous.</p>

    <p class="text-gray-300">Case 1. Here <span class="math">u^{2n(x_2 + \\mathcal{H}_{bk}(u,e,L)x_3)} \\neq v^{2n}</span> holds and the prover replaces <span class="math">C_1</span>. Note that <span class="math">(u^{(x_2 + \\mathcal{H}_{bk}(u,e,L)x_3)} / v)^{2n} \\in \\mathbf{G}_{n&#x27;}</span> and <span class="math">(u^{(x_2 + \\mathcal{H}_{bk}(u,e,L)x_3)} / v)^{2n} \\neq 1</span>. Thus <span class="math">(u^{(x_2 + \\mathcal{H}_{bk}(u,e,L)x_3)} / v)</span> generates <span class="math">\\mathbf{G}_{n&#x27;}</span> (or we could factor <span class="math">n</span>) and <span class="math">C_1 = (u^{x_2 + \\mathcal{H}_{bk}(u,e,L)x_3} / v)^{2na_1}</span> is a random element of <span class="math">\\mathbf{G}_{n&#x27;}</span> as <span class="math">a_1</span> is chosen at random from the appropriate interval. Also, as <span class="math">b_1</span> is chosen independently of <span class="math">a_1</span>, <span class="math">\\mathfrak{C}_1</span> is a random element from <span class="math">\\mathfrak{G}_{n&#x27;}</span>. Hence <span class="math">\\mathfrak{C}_1</span> and <span class="math">C_1</span> have the same distribution in the run with the real prover as in the simulation.</p>

    <p class="text-gray-300">Case 2. As the above case does not apply, i.e., <span class="math">(u^{(x_2 + \\mathcal{H}_{bk}(u,e,L)x_3)} / v)^{2n} = 1</span> we have that <span class="math">(u^{x_2 + \\mathcal{H}_{bk}(u,e,L)x_3)} / v)^2 \\in \\mathbf{G}_n</span>. Again, <span class="math">(u^{x_2 + \\mathcal{H}_{bk}(u,e,L)x_3} / v)^2</span> generates <span class="math">\\mathbf{G}_n</span> (or we could factor <span class="math">n</span>) and <span class="math">C_2 = (u^{x_2 + \\mathcal{H}_{bk}(u,e,L)x_3} / v)^{2a_2}</span> as <span class="math">a_1</span> is chosen at random. For the same reason as in Case 1, <span class="math">\\mathfrak{C}_2</span> is a random element from <span class="math">\\mathfrak{G}_{n&#x27;}</span> and <span class="math">\\mathfrak{C}_2</span> and <span class="math">C_2</span> have the same distribution in the run with the real prover as in the simulation.</p>

    <p class="text-gray-300">These facts, together with the fact that all the <span class="math">PK</span>-protocols used as sub-protocols are special honest-verifier zero-knowledge (showing the latter is standard and left to the reader), imply that the verifiable decryption protocol is special honest-verifier zero-knowledge. Note that we have used in an essential way the fact that we quantify "computationally" over the inputs to the simulator: the inputs that cause the simulator to fail are assumed to be hard to find.</p>

    <p class="text-gray-300">In the remainder we prove soundness. Let us generate a public keys and secret keys according to the usual algorithms, obtaining</p>

    <div class="my-4 text-center"><span class="math-block">n, g, y _ {1}, y _ {2}, y _ {3}, x _ {1}, x _ {2}, x _ {3}, \\mathfrak {n}, \\mathfrak {g}, \\mathfrak {h}.</span></div>

    <p class="text-gray-300">All of this information is available to the adversary, who produces <span class="math">m, \\psi, L</span>, and is able to make the verifier accept on these inputs with non-negligible probability. Using standard rewinding techniques we can produce two accepting conversations for either the <span class="math">PK</span> protocol in Step 2 or the one in Step 3 (for different challenges but the same first message), depending on whether <span class="math">m = \\mathcal{D}(1^{\\lambda}, \\mathsf{SK}, \\psi, L)</span>. We consider these two cases.</p>

    <p class="text-gray-300">Case I. First assume that <span class="math">m \\neq \\mathcal{D}(1^{\\lambda}, \\mathsf{SK}, \\psi, L)</span> but that <span class="math">V</span>'s output is 1. Let <span class="math">(u, e, v) \\coloneqq \\psi</span>. In this case we get two accepting conversations of the <span class="math">PK</span> protocol in Step 2 and hence two answers</p>

    <div class="my-4 text-center"><span class="math-block">(\\tilde {x} _ {1} ^ {(1)}, \\tilde {x} _ {2} ^ {(1)}, \\tilde {x} _ {3} ^ {(1)}) \\quad \\text{and} \\quad (\\tilde {x} _ {1} ^ {(2)}, \\tilde {x} _ {2} ^ {(2)}, \\tilde {x} _ {3} ^ {(2)})</span></div>

    <p class="text-gray-300">for the two different challenges <span class="math">c^{(1)}</span> and <span class="math">c^{(2)}</span> but with the same first message (here we use the same notation for the protocol variables as for the <span class="math">PK</span> protocol in the previous section). W.l.o.g., suppose that <span class="math">c^{(2)} &amp;gt; c^{(1)}</span>. Let <span class="math">\\Delta x_{1} = \\tilde{x}_{1}^{(1)} - \\tilde{x}_{1}^{(2)}, \\Delta x_{2} = \\tilde{x}_{2}^{(1)} - \\tilde{x}_{2}^{(2)}, \\Delta x_{3} = \\tilde{x}_{3}^{(1)} - \\tilde{x}_{3}^{(2)}</span>, and <span class="math">\\Delta c = c^{(2)} - c^{(1)}</span>. From the verification equation of the <span class="math">PK</span> protocol one can derive the following equations:</p>

    <div class="my-4 text-center"><span class="math-block">y _ {1} ^ {\\Delta c} = g ^ {\\Delta x _ {1}} , \\quad y _ {2} ^ {\\Delta c} = g ^ {\\Delta x _ {2}} , \\quad y _ {3} ^ {\\Delta c} = g ^ {\\Delta x _ {3}} , \\tag {27}</span></div>

    <div class="my-4 text-center"><span class="math-block">v ^ {2 \\Delta c} = u ^ {2 \\Delta x _ {2}} u ^ {2 \\mathcal {H} _ {b k} (u, e, L) \\Delta x _ {3}}, \\quad \\text{and} \\tag {28}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\frac {e ^ {2}}{h ^ {2 m}}\\right) ^ {\\Delta c} = u ^ {2 \\Delta x _ {1}}. \\tag {29}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As <span class="math">n</span> is the product of two safe primes <span class="math">p</span> and <span class="math">q</span>, we have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; \\min\\{p, q, p'q'\\}<span class="math"> and hence </span>\\Delta c<span class="math"> is invertible modulo </span>n'n<span class="math">. We know </span>x_i<span class="math"> such that </span>y_i = g^{x_i}$ and therefore it follows from (27) that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\Delta c x _ {i} \\equiv \\Delta x _ {i} \\quad (\\mathrm {m o d} n ^ {\\prime}) \\quad \\mathrm {f o r} \\quad i = 1, \\dots , 3. \\tag {30}</span></div>

    <p class="text-gray-300">Now, <span class="math">\\mathcal{D}(1^{\\lambda},\\mathsf{SK},\\psi ,L)\\neq m</span> means that least one of the four statements (23-26) must be true and therefore at least one of the two statements</p>

    <div class="my-4 text-center"><span class="math-block">u ^ {2 \\left(x _ {2} + \\mathcal {H} _ {\\mathrm {h k}} (u, e, L) x _ {3}\\right)} \\neq v ^ {2} \\quad \\text {o r} \\quad \\left(e / u ^ {x _ {1}}\\right) ^ {2} \\neq h ^ {2 m} \\tag {31}</span></div>

    <p class="text-gray-300">holds. We consider these two cases:</p>

    <p class="text-gray-300">Case 1. If <span class="math">u^{2(x_2 + \\mathcal{H}_{\\mathrm{hk}}(u,e,L)x_3)} \\neq v^2</span> we must have that <span class="math">u^{2\\Delta c(x_2 + \\mathcal{H}_{\\mathrm{hk}}(u,e,L)x_3)} \\neq v^{2\\Delta c} = u^{2\\Delta x_2 + \\mathcal{H}_{\\mathrm{hk}}(u,e,L)\\Delta x_3}</span> (from Equation (28) and because <span class="math">\\Delta c</span> is invertible modulo <span class="math">nn&#x27;</span>) and therefore also</p>

    <div class="my-4 text-center"><span class="math-block">\\Delta c (x _ {2} + \\mathcal {H} _ {\\mathrm {h k}} (u, e, L) x _ {3}) \\not \\equiv \\Delta x _ {2} + \\mathcal {H} _ {\\mathrm {h k}} (u, e, L) \\Delta x _ {3} \\quad (\\mathrm {m o d} n ^ {\\prime} n),</span></div>

    <p class="text-gray-300">as the order of <span class="math">u^2</span> divides <span class="math">n&#x27;n</span>. From (30) it follows that</p>

    <div class="my-4 text-center"><span class="math-block">\\Delta c (x _ {2} + \\mathcal {H} _ {\\mathrm {h k}} (u, e, L) x _ {3}) \\equiv \\Delta x _ {2} + \\mathcal {H} _ {\\mathrm {h k}} (u, e, L) \\Delta x _ {3} \\quad (\\mathrm {m o d} n ^ {\\prime}).</span></div>

    <p class="text-gray-300">Therefore <span class="math">\\Delta cx_{2} - \\Delta x_{2} + (\\Delta cx_{3} - \\Delta x_{3})\\mathcal{H}_{\\mathrm{hk}}(u,e,L)</span> must be a non-zero multiple of <span class="math">n&#x27;</span>, which would allow us to factor <span class="math">n</span>, which is impossible.</p>

    <p class="text-gray-300">Case 2. If <span class="math">u^{2x_1} \\neq \\left(\\frac{e}{h^m}\\right)^2</span> we can, similarly as in case 1, conclude that <span class="math">u^{2\\Delta cx_1} \\neq u^{2\\Delta x_1}</span> from Equation (29) and that <span class="math">\\Delta cx_1 - \\Delta x_1</span> is a non-zero multiple of <span class="math">n&#x27;</span>, which would again allow us to factor <span class="math">n</span>, which is impossible.</p>

    <p class="text-gray-300">Case II. It remains to consider the case when <span class="math">V</span>'s output is <span class="math">-1</span> but <span class="math">m = \\mathcal{D}(1^{\\lambda},\\mathsf{SK},\\psi ,L)</span> holds. Let <span class="math">(u,e,v)\\coloneqq \\psi</span>. Thus we have</p>

    <div class="my-4 text-center"><span class="math-block">v ^ {2} = u ^ {2 \\left(x _ {2} + \\mathcal {H} _ {\\mathrm {h k}} (u, e, L) x _ {3}\\right)} \\quad \\text {a n d} \\quad u ^ {2 x _ {1}} = \\left(\\frac {e}{h ^ {m}}\\right) ^ {2}. \\tag {32}</span></div>

    <p class="text-gray-300">As usual we obtain two accepting conversation of the <span class="math">PK</span> protocol in Step 3 and thus two answers</p>

    <div class="my-4 text-center"><span class="math-block">(\\tilde {x} _ {1} ^ {(1)}, \\tilde {x} _ {2} ^ {(1)}, \\tilde {x} _ {3} ^ {(1)}, \\tilde {a} _ {1} ^ {(1)}, \\ldots , \\tilde {a} _ {6} ^ {(1)}, \\tilde {b} _ {1} ^ {(1)}, \\ldots , \\tilde {b} _ {4} ^ {(1)}, \\tilde {r} _ {1} ^ {(1)}, \\ldots , \\tilde {r} _ {4} ^ {(1)}, \\tilde {s} _ {1} ^ {(1)}, \\ldots , \\tilde {s} _ {4} ^ {(1)})</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">(\\tilde {x} _ {1} ^ {(2)}, \\tilde {x} _ {2} ^ {(2)}, \\tilde {x} _ {3} ^ {(2)}, \\tilde {a} _ {1} ^ {(2)}, \\ldots , \\tilde {a} _ {4} ^ {(2)}, \\tilde {b} _ {1} ^ {(2)}, \\ldots , \\tilde {b} _ {4} ^ {(2)}, \\tilde {r} _ {1} ^ {(2)}, \\ldots , \\tilde {r} _ {4} ^ {(2)}, \\tilde {s} _ {1} ^ {(2)}, \\ldots , \\tilde {s} _ {4} ^ {(2)})</span></div>

    <p class="text-gray-300">for the two different challenges <span class="math">c^{(1)}</span> and <span class="math">c^{(2)}</span> but with the same first message (here we use the same notation for the protocol variables as for the <span class="math">PK</span> protocol in the previous section and left out an intermediate step that deals with the <span class="math">\\vee</span>'s (c.f. [CDS94])). W.l.o.g., suppose that <span class="math">c^{(2)} &amp;gt; c^{(1)}</span>. Let</p>

    <div class="my-4 text-center"><span class="math-block">\\Delta x _ {i} = \\tilde {x} _ {i} ^ {(1)} - \\tilde {x} _ {i} ^ {(2)} (i = 1, \\dots , 3); \\quad \\Delta a _ {i} = \\tilde {a} _ {i} ^ {(1)} - \\tilde {a} _ {i} ^ {(2)} (i = 1, \\dots , 4);</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Delta b _ {i} = \\tilde {b} _ {i} ^ {(1)} - \\tilde {b} _ {i} ^ {(2)} (i = 1, \\dots , 4); \\quad \\Delta s _ {i} = \\tilde {s} _ {i} ^ {(1)} - \\tilde {s} _ {i} ^ {(2)} (i = 1, \\dots , 4);</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Delta r _ {i} = \\tilde {r} _ {i} ^ {(1)} - \\tilde {r} _ {i} ^ {(2)} (i = 1, \\dots , 4); \\quad \\Delta c = c ^ {(2)} - c ^ {(1)}.</span></div>

    <p class="text-gray-300">From the verification equation of the <span class="math">PK</span> protocol one can derive that</p>

    <p class="text-gray-300"><span class="math">y_{1}{}^{\\Delta c}=g^{\\Delta x_{1}}\\;\\;,\\qquad\\qquad\\qquad y_{2}{}^{\\Delta c}=g^{\\Delta x_{2}}\\;\\;,\\quad\\mbox{and}\\qquad\\qquad\\qquad y_{3}{}^{\\Delta c}=g^{\\Delta x_{3}}\\;\\;,</span> (33)</p>

    <p class="text-gray-300">hold and either</p>

    <p class="text-gray-300"><span class="math">C_{1}^{\\Delta c}=u^{2n\\Delta r_{1}}(\\frac{1}{v})^{2n\\Delta a_{1}}\\;\\;,\\quad\\mathfrak{C}_{1}^{\\Delta c}=\\mathfrak{g}^{\\Delta a_{1}}\\mathfrak{h}^{\\Delta b_{1}}\\;\\;,\\quad\\mbox{and}\\quad 1=(\\frac{1}{\\mathfrak{C}_{1}})^{\\Delta x_{2}+\\mathcal{H}_{\\mathfrak{hk}}(u,e,L)\\Delta x_{3}}\\mathfrak{g}^{\\Delta r_{1}}\\mathfrak{h}^{\\Delta s_{1}}</span> (34)</p>

    <p class="text-gray-300">or</p>

    <p class="text-gray-300"><span class="math">C_{2}^{\\Delta c}=u^{2\\Delta r_{2}}(\\frac{1}{v})^{2\\Delta a_{2}}\\;\\;,\\qquad\\mathfrak{C}_{2}^{\\Delta c}=\\mathfrak{g}^{\\Delta a_{2}}\\mathfrak{h}^{\\Delta b_{2}}\\;\\;,\\quad\\mbox{and}\\quad 1=(\\frac{1}{\\mathfrak{C}_{2}})^{\\Delta x_{2}+\\mathcal{H}_{\\mathfrak{hk}}(u,e,L)\\Delta x_{3}}\\mathfrak{g}^{\\Delta r_{2}}\\mathfrak{h}^{\\Delta s_{2}}</span> (35)</p>

    <p class="text-gray-300">or</p>

    <p class="text-gray-300"><span class="math">C_{3}^{\\Delta c}=u^{2n\\Delta r_{3}}(\\frac{1}{e})^{2n\\Delta a_{3}}\\;\\;,\\quad\\mathfrak{C}_{3}^{\\Delta c}=\\mathfrak{g}^{\\Delta a_{3}}\\mathfrak{h}^{\\Delta b_{3}}\\;\\;,\\quad\\mbox{and}\\quad 1=(\\frac{1}{\\mathfrak{C}_{3}})^{\\Delta x_{1}}\\mathfrak{g}^{\\Delta r_{3}}\\mathfrak{h}^{\\Delta s_{3}}</span> (36)</p>

    <p class="text-gray-300">or</p>

    <p class="text-gray-300"><span class="math">C_{4}^{\\Delta c}=u^{2\\Delta r_{4}}(\\frac{1}{e})^{n\\Delta a_{4}}\\;\\;,\\qquad\\mathfrak{C}_{4}^{\\Delta c}=\\mathfrak{g}^{\\Delta a_{4}}\\mathfrak{h}^{\\Delta b_{4}}\\;\\;,\\quad\\mbox{and}\\quad 1=(\\frac{1}{\\mathfrak{C}_{4}})^{\\Delta x_{1}}\\mathfrak{g}^{\\Delta r_{4}}\\mathfrak{h}^{\\Delta s_{4}}</span> (37)</p>

    <p class="text-gray-300">hold. We know <span class="math">x_{i}</span> such that <span class="math">y_{i}=g^{x_{i}}</span> and therefore it follows from (33) that</p>

    <p class="text-gray-300"><span class="math">\\Delta c\\,x_{i}\\equiv\\Delta x_{i}\\quad(\\mbox{mod }n^{\\prime})\\quad\\mbox{for}\\quad i=1,\\ldots,3\\;\\;.</span> (38)</p>

    <p class="text-gray-300">We next consider the implications of the cases when the equations (34), the equations (35), the equations (36), or the equations (37) hold in conjunction with (33).</p>

    <p class="text-gray-300">Consider the case where Equations (33) and (34) hold. From the last two equations of (34) we get</p>

    <p class="text-gray-300"><span class="math">\\mathfrak{g}^{\\Delta a_{1}(\\Delta x_{2}+\\mathcal{H}_{\\mathfrak{hk}}(u,e,L)\\Delta x_{3})}\\mathfrak{h}^{\\Delta b_{1}(\\Delta x_{2}+\\mathcal{H}_{\\mathfrak{hk}}(u,e,L)\\Delta x_{3})}=\\mathfrak{g}^{\\Delta c\\Delta r_{1}}\\mathfrak{h}^{\\Delta c\\Delta s_{1}}\\;\\;.</span></p>

    <p class="text-gray-300">Under the assumption that factoring <span class="math">\\mathfrak{n}</span> is hard, and applying Theorem 2, we may assume that</p>

    <p class="text-gray-300"><span class="math">\\Delta a_{1}(\\Delta x_{2}+\\mathcal{H}_{\\mathfrak{hk}}(u,e,L)\\Delta x_{3})=\\Delta c\\Delta r_{1}\\;\\;.</span> (39)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Because <span class="math">n</span> is the product of two safe primes and we have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\min\\{p,q,p^{\\prime}q^{\\prime}\\}<span class="math">, it follows from </span>C_{1}^{2}\\neq 1<span class="math"> (which is checked by the verifier in Step 3c) that </span>C_{1}^{\\Delta c}\\neq 1<span class="math">. From the first equation of (34) it follows that </span>u^{2n\\Delta r_{1}}\\neq v^{2n\\Delta a_{1}}<span class="math">. By Eq. (39) and the fact that </span>u^{2n}<span class="math"> and </span>v^{2n}<span class="math"> have order dividing </span>n^{\\prime}$, we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">u^{2n\\Delta a_{1}(\\Delta x_{2}+\\mathcal{H}_{\\mathfrak{hk}}(u,e,L)\\Delta x_{3})}\\neq v^{2n\\Delta c\\Delta a_{1}}\\;\\;,</span></p>

    <p class="text-gray-300">and hence</p>

    <p class="text-gray-300"><span class="math">u^{2n(\\Delta x_{2}+\\mathcal{H}_{\\mathfrak{hk}}(u,e,L)\\Delta x_{3})}\\neq v^{2n\\Delta c}\\;\\;.</span> (40)</p>

    <p class="text-gray-300">From (40) and the first equation of (32) we have</p>

    <p class="text-gray-300"><span class="math">u^{2n(\\Delta x_{2}+\\mathcal{H}_{\\mathfrak{hk}}(u,e,L)\\Delta x_{3})}\\neq v^{2n\\Delta c}=u^{2n\\Delta c(x_{2}+\\mathcal{H}_{\\mathfrak{hk}}(u,e,L)x_{3})}\\;\\;.</span></p>

    <p class="text-gray-300">Because the order of <span class="math">u^{2n}</span> divides <span class="math">n^{\\prime}</span> we can further conclude that</p>

    <p class="text-gray-300"><span class="math">\\Delta x_{2}+\\mathcal{H}_{\\sf hk}(u,e,L)\\Delta x_{3}\\not\\equiv\\Delta c(x_{2}+\\mathcal{H}_{\\sf hk}(u,e,L)x_{3})\\pmod{n^{\\prime}}\\enspace.</span></p>

    <p class="text-gray-300">From (38) if follows that</p>

    <p class="text-gray-300"><span class="math">\\Delta x_{2}+\\mathcal{H}_{\\sf hk}(u,e,L)\\Delta x_{3}\\equiv\\Delta c(x_{2}+\\mathcal{H}_{\\sf hk}(u,e,L)x_{3})\\pmod{n^{\\prime}}\\enspace,</span></p>

    <p class="text-gray-300">which is a contradiction to the previous equation and hence this case can not occur.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We consider the case where Equations (33) and (35) hold. Similarly as in case 1, we can derive that</li>

    </ol>

    <p class="text-gray-300"><span class="math">u^{2(\\Delta x_{2}+\\mathcal{H}_{\\sf hk}(u,e,L)\\Delta x_{3})}\\neq v^{2\\Delta c}=u^{2\\Delta c(x_{2}+\\mathcal{H}_{\\sf hk}(u,e,L)x_{3})}</span></p>

    <p class="text-gray-300">holds (assuming <span class="math">\\mathfrak{n}</span> is hard to factor). Because the order of <span class="math">u^{2}</span> divides <span class="math">n^{\\prime}n</span> we can further conclude that</p>

    <p class="text-gray-300"><span class="math">\\Delta x_{2}+\\mathcal{H}_{\\sf hk}(u,e,L)\\Delta x_{3}\\not\\equiv\\Delta c(x_{2}+\\mathcal{H}_{\\sf hk}(u,e,L)x_{3})\\pmod{n^{\\prime}n}\\enspace.</span></p>

    <p class="text-gray-300">From (38) if follows that</p>

    <p class="text-gray-300"><span class="math">\\Delta x_{2}+\\mathcal{H}_{\\sf hk}(u,e,L)\\Delta x_{3}\\equiv\\Delta c(x_{2}+\\mathcal{H}_{\\sf hk}(u,e,L)x_{3})\\pmod{n^{\\prime}}\\enspace.</span></p>

    <p class="text-gray-300">Therefore <span class="math">\\Delta cx_{2}-\\Delta x_{2}+(\\Delta cx_{3}-\\Delta x_{3})\\mathcal{H}_{\\sf hk}(u,e,L)</span> must be a non-zero multiple of <span class="math">n^{\\prime}</span>, which would allow us to factor <span class="math">n</span>, which is a contradiction.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Similarly as in case 1, from the Equations (33) and (36), one can derive that</li>

    </ol>

    <p class="text-gray-300"><span class="math">u^{2n\\Delta x_{1}}\\neq e^{2n\\Delta c}</span> (41)</p>

    <p class="text-gray-300">holds (or we factor <span class="math">\\mathfrak{n}</span> with non-negligible probability). From the second equation of (32) and <span class="math">h^{n}=1</span> if follows that <span class="math">u^{2nx_{1}}=e^{2n}</span> and <span class="math">u^{2n\\Delta cx_{1}}=e^{2n\\Delta c}</span>, and from (41), that</p>

    <p class="text-gray-300"><span class="math">u^{2n\\Delta cx_{1}}\\neq u^{2n\\Delta x_{1}}\\qquad\\text{and finally that}\\qquad\\Delta cx_{1}\\not\\equiv\\Delta x_{1}\\pmod{n^{\\prime}}</span></p>

    <p class="text-gray-300">as <span class="math">u^{2n}</span> has order dividing <span class="math">n^{\\prime}</span>. The latter, however, is a contradiction to Eqn. (38) and thus this case can not occur.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Similarly as before, from the Equations (33) and (37) one can show that</li>

    </ol>

    <p class="text-gray-300"><span class="math">u^{2\\Delta x_{1}}\\neq(\\frac{e}{h^{m}})^{2\\Delta c}</span> (42)</p>

    <p class="text-gray-300">holds (or we factor <span class="math">\\mathfrak{n}</span> with non-negligible probability). From the second equation of (32) and from (42) we get <span class="math">u^{2\\Delta cx_{1}}\\neq u^{2\\Delta x_{1}}</span>. Similarly as in case 2, it follows that <span class="math">\\Delta cx_{1}-\\Delta x_{1}</span> is a multiple of <span class="math">n^{\\prime}</span> and we are again able to factor <span class="math">n</span>.</p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">7.3 Verifiable Decryption of a Discrete Logarithm</p>

    <p class="text-gray-300">We now describe how the protocol provided in the previous section can be modified to obtain a protocol for verifiable decryption of a discrete logarithm. The setting and notation are as in §5.2; in particular, we make use of the same reconstruction routine.</p>

    <p class="text-gray-300">We need to modify the protocol from the previous section only for the cases where the ciphertext is valid. That is, instead of proving that the ciphertext decrypts (or does not decrypt) to a given message, the decryptor now has to prove that it decrypts (or does not decrypt) to a value <span class="math">m</span> such that <span class="math">(m\\operatorname{rem}n)\\equiv\\log_{\\gamma}\\delta\\pmod{\\rho}</span>. This corresponds to proving whether or not the three equations</p>

    <p class="text-gray-300"><span class="math">u^{2(x_{2}+\\mathcal{H}_{\\mathsf{bk}}(u,e,L)x_{3})}/v^{2}=1\\qquad\\text{or}\\qquad(e/u^{x_{1}})^{2n}=1\\qquad\\text{or}\\qquad\\delta=\\gamma^{(\\log_{b^{2}}(e/u^{x_{1}})^{2}\\operatorname{rem}n)}</span> (43)</p>

    <p class="text-gray-300">hold. Note that <span class="math">\\log_{b^{2}}(e/u^{x_{1}})^{2}</span> exists if and only if <span class="math">(e/u^{x_{1}})^{2n}=1</span>. The first two statements of (43) can be handled as in the previous section. The last one can be handled by proving knowledge of a secret, say <span class="math">m</span>, that (1) equals the encrypted message modulo <span class="math">n</span>, (2) equals (or doesn’t equal) <span class="math">\\log_{\\gamma}\\delta</span> modulo <span class="math">q</span>, and (3) lies in the interval <span class="math">[-(n-1)/2,(n-1)/2]</span>. The first two properties can be proved under the strong RSA assumption using additional parameters <span class="math">(\\mathfrak{n},\\mathfrak{g},\\mathfrak{h})</span> as in the previous section. We discuss proving the last one. Different from the interval-proof used for verifiable encryption, this interval-proof needs to be exact, i.e., if we allowed for the same sloppiness, then the prover could for instance add a multiple of <span class="math">n</span> to <span class="math">m</span> and then show that <span class="math">(u,e,v)</span> does not (or does) decrypt to <span class="math">\\log_{\\gamma}\\delta</span>.</p>

    <p class="text-gray-300">Boudot <em>[x1]</em> presents several protocols to prove that in integer <span class="math">m</span> lies exactly in an interval <span class="math">[a,b]</span>. One protocol uses the fact that <span class="math">x\\in[a,b]</span> is equivalent to <span class="math">b-x\\geq 0</span> and <span class="math">x-a\\geq 0</span> and that one can show that an integer is positive by proving knowledge of four values the squares of which sum up to the considered integer (in <span class="math">\\mathbb{Z}</span>), again under the strong RSA assumption using additional parameters <span class="math">(\\mathfrak{n},\\mathfrak{g},\\mathfrak{h})</span>. Lagrange proved that an integer can always be represented as four squares and Rabin and Shallit <em>[x12]</em> provide an efficient algorithm for finding such squares.</p>

    <p class="text-gray-300">We note that in our case the interval is symmetric and it therefore suffices to prove that <span class="math">((n-1)/2)^{2}-m^{2}\\geq 0</span> holds, which is more efficient.</p>

    <p class="text-gray-300">With these observations one can derive the following protocol for verifiable decryption of a discrete logarithm from the protocol presented in the previous section.</p>

    <p class="text-gray-300">The common input of the decryptor and the verifier is <span class="math">(\\mathsf{hk},n,g,y_{1},y_{2},y_{3}),(\\mathfrak{n},\\mathfrak{g},\\mathfrak{h}),(u,e,v),\\delta,L</span> and the additional input to the decryptor is <span class="math">(x_{1},x_{2},x_{3})</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\delta\\not\\in\\Gamma</span> or the ciphertext is malformed (e.g., if <span class="math">v\\neq\\operatorname{abs}(v)</span>), the verifier outputs <span class="math">-1</span>, and the protocol stops.</li>

    </ol>

    <p class="text-gray-300">In case <span class="math">(u,e,v)</span> is a valid ciphertext w.r.t. label <span class="math">L</span>, the prover decrypts it, thereby obtains <span class="math">m</span>, and computes integers <span class="math">w_{1},\\ldots,w_{4}</span> such that <span class="math">\\sum_{i=1}^{4}w_{i}=(n-1)^{2}/4-m^{2}</span> (c.f. <em>[x12]</em>).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">(u,e,v)</span> indeed decrypts to <span class="math">\\log_{\\gamma}\\delta</span> under label <span class="math">L</span>, i.e., if <span class="math">\\delta=\\gamma^{m\\operatorname{rem}n}</span>, the decryptor sends <span class="math">1</span> to the verifier, chooses <span class="math">t_{1},\\ldots,t_{5}\\in_{R}[\\mathfrak{n}/4]</span>, computes</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathfrak{W}_{1}:=\\mathfrak{g}^{w_{1}}\\mathfrak{h}^{t_{1}},\\mathfrak{W}_{2}:=\\mathfrak{g}^{w_{2}}\\mathfrak{h}^{t_{2}},\\mathfrak{W}_{3}:=\\mathfrak{g}^{w_{3}}\\mathfrak{h}^{t_{3}},\\mathfrak{W}_{4}:=\\mathfrak{g}^{w_{4}}\\mathfrak{h}^{t_{4}},\\text{ and }\\mathfrak{M}:=\\mathfrak{g}^{m}\\mathfrak{h}^{t_{5}}\\enspace,</span></p>

    <p class="text-gray-300">and sends <span class="math">\\mathfrak{W}_{1}</span>, <span class="math">\\mathfrak{W}_{2}</span>, <span class="math">\\mathfrak{W}_{3}</span>, <span class="math">\\mathfrak{W}_{4}</span>, and <span class="math">\\mathfrak{M}</span> to the verifier.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">The prover and the verifier engage in the protocol</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} P K \\{(x _ {1}, x _ {2}, x _ {3}, m, w _ {1}, \\dots , w _ {4}, t _ {1}, \\dots , t _ {5}, s): \\\\ y _ {1} = g ^ {x _ {1}} \\wedge y _ {2} = g ^ {x _ {2}} \\wedge y _ {3} = g ^ {x _ {3}} \\wedge \\\\ v ^ {2} = u ^ {2 x _ {2}} u ^ {2 \\mathcal {H} _ {b h} (u, e, L) x _ {3}} \\wedge e ^ {2} = u ^ {2 x _ {1}} h ^ {2 m} \\wedge \\\\ \\mathfrak {M} _ {1} = \\mathfrak {g} ^ {w _ {1}} \\mathfrak {h} ^ {t _ {1}} \\wedge \\mathfrak {M} _ {2} = \\mathfrak {g} ^ {w _ {2}} \\mathfrak {h} ^ {t _ {2}} \\wedge \\mathfrak {M} _ {3} = \\mathfrak {g} ^ {w _ {3}} \\mathfrak {h} ^ {t _ {3}} \\wedge \\mathfrak {M} _ {4} = \\mathfrak {g} ^ {w _ {4}} \\mathfrak {h} ^ {t _ {4}} \\wedge \\\\ \\mathfrak {M} = \\mathfrak {g} ^ {m} \\mathfrak {h} ^ {t _ {5}} \\wedge \\mathfrak {g} ^ {(n - 1) ^ {2} / 4} = \\mathfrak {M} ^ {m} \\mathfrak {M} _ {1} ^ {w _ {1}} \\mathfrak {M} _ {2} ^ {w _ {2}} \\mathfrak {M} _ {3} ^ {w _ {3}} \\mathfrak {M} _ {4} ^ {w _ {4}} \\mathfrak {h} ^ {s} \\wedge \\\\ \\delta = \\gamma^ {m} \\}, \\end{array}</span></div>

    <p class="text-gray-300">where <span class="math">s</span> is a temporary secret (i.e., <span class="math">s = -t_5m - \\sum_{i=1}^{4} w_it_i</span>).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">(u, e, v)</span> is an invalid ciphertext w.r.t. the label <span class="math">L</span> or decrypts to some message <span class="math">m</span> such that <span class="math">\\delta \\neq \\gamma^{m \\text{ rem } n}</span>, then the decryptor sends <span class="math">-1</span> to the verifier. They proceed as follows.</li>

    </ol>

    <p class="text-gray-300">(a) The decryptor chooses <span class="math">a_1 \\in_{R} [n/4]</span> <span class="math">a_2 \\in_{R} [n^2/4]</span>, <span class="math">a_3 \\in_{R} [n/4]</span>, and <span class="math">a_4 \\in_{R} [\\rho]</span>, along with <span class="math">b_1, \\ldots, b_3, t_1, \\ldots, t_5 \\in_{R} [\\mathfrak{n}/4]</span>.</p>

    <p class="text-gray-300">She computes <span class="math">\\mathfrak{C}_1\\coloneqq \\mathfrak{g}^{a_1}\\mathfrak{h}^{b_1}</span>, <span class="math">\\mathfrak{C}_2\\coloneqq \\mathfrak{g}^{a_2}\\mathfrak{h}^{b_2}</span>, <span class="math">\\mathfrak{C}_3\\coloneqq \\mathfrak{g}^{a_3}\\mathfrak{h}^{b_3}</span>, and <span class="math">\\mathfrak{C}_4\\coloneqq \\mathfrak{g}^{a_4}\\mathfrak{h}^{b_4}</span>.</p>

    <p class="text-gray-300">She computes <span class="math">\\mathfrak{M}_1\\coloneqq \\mathfrak{h}^{t_1}</span>, <span class="math">\\mathfrak{M}_2\\coloneqq \\mathfrak{h}^{t_2}</span>, <span class="math">\\mathfrak{M}_3\\coloneqq \\mathfrak{h}^{t_3}</span>, <span class="math">\\mathfrak{M}_4\\coloneqq \\mathfrak{h}^{t_4}</span>, and <span class="math">\\mathfrak{M}\\coloneqq \\mathfrak{h}^{t_5}</span>.</p>

    <p class="text-gray-300">She chooses <span class="math">C_1 \\in_{R} \\mathbf{G}_{n&#x27;}</span>, <span class="math">C_2 \\in_{R} \\mathbf{G}_n</span>, <span class="math">C_3 \\in_{R} \\mathbf{G}_{n&#x27;}</span>, and <span class="math">C_4 \\in_{R} \\Gamma</span>.</p>

    <p class="text-gray-300">Furthermore,</p>

    <p class="text-gray-300">(Case 1) if <span class="math">u^{2n(x_2 + \\mathcal{H}_{bh}(u,e,L)x_3)} \\neq v^{2n}</span>, she sets <span class="math">C_1 := (u^{x_2 + \\mathcal{H}_{bh}(u,e,L)x_3} / v)^{2na_1}</span>,</p>

    <p class="text-gray-300">(Case 2) else if <span class="math">u^{2(x_2 + \\mathcal{H}_{bh}(u,e,L)x_3)} \\neq v^2</span>, she sets <span class="math">C_2 := (u^{x_2 + \\mathcal{H}_{bh}(u,e,L)x_3} / v)^{2a_2}</span>,</p>

    <p class="text-gray-300">(Case 3) else if <span class="math">(u^{x_1} / e)^2 \\notin \\langle h \\rangle</span>, she sets <span class="math">C_3 := (u^{x_1} / e)^{2na_3}</span>,</p>

    <p class="text-gray-300">(Case 4) else <span class="math">\\delta \\neq \\gamma^{m\\mathrm{rem}}n</span>, and she sets <span class="math">C_4 := (\\gamma^m /\\delta)^{a_4}</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathfrak {M} _ {i} := \\mathfrak {g} ^ {w _ {i}} \\mathfrak {h} ^ {t _ {i}} \\quad (i = 1, \\dots , 4), \\quad \\text{and}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathfrak {M} := \\mathfrak {g} ^ {m} \\mathfrak {h} ^ {t _ {5}}.</span></div>

    <p class="text-gray-300">The decryptor sends <span class="math">C_1, C_2, C_3, C_4, \\mathfrak{C}_1, \\mathfrak{C}_2, \\mathfrak{C}_3</span>, and <span class="math">\\mathfrak{C}_4</span> to the verifier.</p>

    <p class="text-gray-300">(b) The decryptor and the verifier carry out the protocol denoted</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} P K \\Big \\{(x _ {1}, x _ {2}, x _ {3}, a _ {1}, \\dots , a _ {4}, b _ {1}, \\dots , b _ {4}, r _ {1}, \\dots , r _ {4} s _ {1}, \\dots , s _ {5}, t _ {1}, \\dots , t _ {5}, w _ {1}, \\dots , w _ {4}, m): \\\\ \\left[ \\begin{array}{l} y _ {1} = g ^ {x _ {1}} \\wedge y _ {2} = g ^ {x _ {2}} \\wedge y _ {3} = g ^ {x _ {3}} \\wedge \\\\ C _ {1} = u ^ {2 n r _ {1}} \\left(\\frac {1}{v}\\right) ^ {2 n a _ {1}} \\wedge \\mathfrak {C} _ {1} = \\mathfrak {g} ^ {a _ {1}} \\mathfrak {h} ^ {b _ {1}} \\wedge 1 = \\left(\\frac {1}{\\mathfrak {C} _ {1}}\\right) ^ {x _ {2}} \\left(\\frac {1}{\\mathfrak {C} _ {1}}\\right) ^ {\\mathcal {H} _ {\\mathrm {h k}} (u, e, L) x _ {3}} \\mathfrak {g} ^ {r _ {1}} \\mathfrak {h} ^ {s _ {1}} \\right] \\end{array} \\right. \\\\ \\vee \\left[ \\begin{array}{l l l l} y _ {1} = g ^ {x _ {1}} &amp;amp; \\wedge &amp;amp; y _ {2} = g ^ {x _ {2}} &amp;amp; \\wedge &amp;amp; y _ {3} = g ^ {x _ {3}} \\wedge \\\\ C _ {2} = u ^ {2 r _ {2}} \\left(\\frac {1}{v}\\right) ^ {a _ {2}} &amp;amp; \\wedge &amp;amp; \\mathfrak {C} _ {2} = \\mathfrak {g} ^ {a _ {2}} \\mathfrak {h} ^ {b _ {2}} &amp;amp; \\wedge &amp;amp; 1 = \\left(\\frac {1}{\\mathfrak {C} _ {2}}\\right) ^ {x _ {2}} \\left(\\frac {1}{\\mathfrak {C} _ {2}}\\right) ^ {\\mathcal {H} _ {\\mathrm {h k}} (u, e, L) x _ {3}} \\mathfrak {g} ^ {r _ {2}} \\mathfrak {h} ^ {s _ {2}} \\end{array} \\right] \\\\ \\vee \\left[ \\begin{array}{l l l l} y _ {1} = g ^ {x _ {1}} &amp;amp; \\wedge &amp;amp; y _ {2} = g ^ {x _ {2}} &amp;amp; \\wedge &amp;amp; y _ {3} = g ^ {x _ {3}} \\wedge \\\\ C _ {3} = u ^ {2 n r _ {3}} \\left(\\frac {1}{e}\\right) ^ {2 n a _ {3}} &amp;amp; \\wedge &amp;amp; \\mathfrak {C} _ {3} = \\mathfrak {g} ^ {a _ {3}} \\mathfrak {h} ^ {b _ {3}} &amp;amp; \\wedge &amp;amp; 1 = \\left(\\frac {1}{\\mathfrak {C} _ {3}}\\right) ^ {x _ {1}} \\mathfrak {g} ^ {r _ {3}} \\mathfrak {h} ^ {s _ {3}} \\end{array} \\right] \\\\ \\vee \\left[ \\begin{array}{l l l l} y _ {1} = g ^ {x _ {1}} &amp;amp; \\wedge &amp;amp; y _ {2} = g ^ {x _ {2}} &amp;amp; \\wedge &amp;amp; y _ {3} = g ^ {x _ {3}} \\wedge \\\\ &amp;amp; &amp;amp; &amp;amp; &amp;amp; e ^ {2} = u ^ {2 x _ {1}} h ^ {2 m} \\wedge \\\\ \\mathfrak {M} _ {1} = \\mathfrak {g} ^ {w _ {1}} \\mathfrak {h} ^ {t _ {1}} &amp;amp; \\wedge &amp;amp; \\mathfrak {M} _ {2} = \\mathfrak {g} ^ {w _ {2}} \\mathfrak {h} ^ {t _ {2}} &amp;amp; \\wedge &amp;amp; \\mathfrak {M} _ {3} = \\mathfrak {g} ^ {w _ {3}} \\mathfrak {h} ^ {t _ {3}} \\wedge \\mathfrak {M} _ {4} = \\mathfrak {g} ^ {w _ {4}} \\mathfrak {h} ^ {t _ {4}} \\wedge \\\\ \\mathfrak {M} = \\mathfrak {g} ^ {m} \\mathfrak {h} ^ {t _ {5}} &amp;amp; \\wedge &amp;amp; \\mathfrak {g} ^ {(n - 1) ^ {2} / 4} = \\mathfrak {M} ^ {m} \\mathfrak {M} _ {1} ^ {w _ {1}} \\mathfrak {M} _ {2} ^ {w _ {2}} \\mathfrak {M} _ {3} ^ {w _ {3}} \\mathfrak {M} _ {4} ^ {w _ {4}} \\mathfrak {h} ^ {s _ {5}} \\wedge \\\\ C _ {4} = \\gamma^ {r _ {4}} (\\frac {1}{\\delta}) ^ {a _ {4}} &amp;amp; \\wedge &amp;amp; \\mathfrak {C} _ {4} = \\mathfrak {g} ^ {a _ {4}} \\mathfrak {h} ^ {b _ {4}} &amp;amp; \\wedge &amp;amp; 1 = (\\frac {1}{\\mathfrak {C} _ {4}}) ^ {m} \\mathfrak {g} ^ {r _ {4}} \\mathfrak {h} ^ {s _ {4}} \\end{array} \\right] \\Big \\} , \\\\ \\end{array}</span></div>

    <p class="text-gray-300">where <span class="math">r_1, \\ldots, r_4, s_1, \\ldots, s_4</span> are temporary secrets (i.e.,</p>

    <div class="my-4 text-center"><span class="math-block">r _ {1} = a _ {1} \\left(x _ {2} + \\mathcal {H} _ {\\mathrm {h k}} (u, e, L) x _ {3}\\right),</span></div>

    <div class="my-4 text-center"><span class="math-block">s _ {1} = b _ {1} \\left(x _ {2} + \\mathcal {H} _ {\\mathrm {h k}} (u, e, L) x _ {3}\\right),</span></div>

    <div class="my-4 text-center"><span class="math-block">r _ {2} = a _ {2} \\left(x _ {2} + \\mathcal {H} _ {\\mathrm {h k}} (u, e, L) x _ {3}\\right),</span></div>

    <div class="my-4 text-center"><span class="math-block">s _ {2} = b _ {2} \\left(x _ {2} + \\mathcal {H} _ {\\mathrm {h k}} (u, e, L) x _ {3}\\right),</span></div>

    <div class="my-4 text-center"><span class="math-block">r _ {3} = x _ {1} a _ {3},</span></div>

    <div class="my-4 text-center"><span class="math-block">s _ {3} = x _ {1} b _ {3},</span></div>

    <div class="my-4 text-center"><span class="math-block">r _ {4} = m a _ {4},</span></div>

    <div class="my-4 text-center"><span class="math-block">s _ {4} = m b _ {4},</span></div>

    <div class="my-4 text-center"><span class="math-block">s _ {5} = - t _ {5} m - \\sum_ {i = 1} ^ {4} w _ {i} t _ {i}.</span></div>

    <p class="text-gray-300">(computed in <span class="math">\\mathbb{Z}</span>)). (To derive the actual protocol one has to apply the techniques by Cramer et al.[CDS94] for realizing the <span class="math">\\vee</span>'s.)</p>

    <p class="text-gray-300">(c) The verifier checks that <span class="math">C_1^2 \\neq 1</span>, <span class="math">C_2^2 \\neq 1</span>, <span class="math">C_3^2 \\neq 1</span>, and <span class="math">C_4 \\neq 1</span>.</p>

    <p class="text-gray-300">Theorem 7. Under the strong RSA assumption, the above scheme is a verifiable decryption scheme (for discrete logarithms).</p>

    <p class="text-gray-300">Proof. One needs to prove soundness, correctness and special honest-verifier zero-knowledge w.r.t. an oracle <span class="math">f&#x27;(\\delta, \\psi, L, \\mathsf{SK})</span> that replies with 1 if <span class="math">\\delta = \\gamma^{\\hat{m}}</span> where <span class="math">\\hat{m} = \\mathcal{D}(\\mathsf{SK}, \\psi, L) \\operatorname{rem} n</span>, or with <span class="math">-1</span> otherwise.</p>

    <p class="text-gray-300">The following proof is very similar to the one of Theorem 6.</p>

    <p class="text-gray-300">Correctness is by inspection.</p>

    <p class="text-gray-300">We now show that the whole protocol is special honest-verifier computational zero-knowledge by providing a simulator.</p>

    <p class="text-gray-300">33</p>

    <p class="text-gray-300">First the simulator executes Step 1 of the protocol as the decryptor would, that is, if <span class="math">\\delta \\notin \\Gamma</span> or <span class="math">v \\neq \\mathrm{abs}(v)</span> it and stops. Otherwise, the simulator chooses random integers <span class="math">m, w_1, \\ldots, w_4 \\in_R [-n/2, n/2]</span>.</p>

    <p class="text-gray-300">If <span class="math">f&#x27;(\\delta, \\psi, L, \\mathsf{SK}) = 1</span>, it simulates step 2 as follows. It chooses <span class="math">t_1, \\ldots, t_5 \\in_R [\\mathfrak{n}/4]</span> and computes <span class="math">\\mathfrak{W}_1 := \\mathfrak{h}^{t_1}</span>, <span class="math">\\mathfrak{W}_2 := \\mathfrak{h}^{t_2}</span>, <span class="math">\\mathfrak{W}_3 := \\mathfrak{h}^{t_3}</span>, <span class="math">\\mathfrak{W}_4 := \\mathfrak{h}^{t_4}</span>, and <span class="math">\\mathfrak{M} := \\mathfrak{h}^{t_5}</span>. Then it sends the values <span class="math">\\mathfrak{W}_1, \\ldots, \\mathfrak{W}_4</span>, and <span class="math">\\mathfrak{M}</span> to the verifier and finally invokes the simulator for the <span class="math">PK</span>-protocol of step 2.</p>

    <p class="text-gray-300">If <span class="math">f&#x27;(\\delta, \\psi, L, \\mathsf{SK}) = 1</span>, it simulates step 3 as follows. The simulator chooses <span class="math">b_1, b_2, b_3, b_4 \\in_R t_1, \\ldots, t_5[\\mathfrak{n}/4]</span>. It then computes <span class="math">\\mathfrak{C}_1 := \\mathfrak{h}^{b_1}</span>, <span class="math">\\mathfrak{C}_2 := \\mathfrak{h}^{b_2}</span>, <span class="math">\\mathfrak{C}_3 := \\mathfrak{h}^{b_3}</span>, <span class="math">\\mathfrak{C}_4 := \\mathfrak{h}^{b_4}</span>, <span class="math">\\mathfrak{W}_1 := \\mathfrak{h}^{t_1}</span>, <span class="math">\\mathfrak{W}_2 := \\mathfrak{h}^{t_2}</span>, <span class="math">\\mathfrak{W}_3 := \\mathfrak{h}^{t_3}</span>, <span class="math">\\mathfrak{W}_4 := \\mathfrak{h}^{t_4}</span>, and <span class="math">\\mathfrak{M} := \\mathfrak{h}^{t_5}</span>. It chooses <span class="math">C_1 \\in_R \\mathbf{G}_{n&#x27;}</span>, <span class="math">C_2 \\in_R \\mathbf{G}_n</span>, <span class="math">C_3 \\in_R \\mathbf{G}_{n&#x27;}</span>, and <span class="math">C_4 \\in_R \\Gamma</span>. It finally invokes the simulator for the <span class="math">PK</span>-protocol of step 3. This concludes the simulator.</p>

    <p class="text-gray-300">The argument that this simulation actually works is rather similar to the one given in the proof of Theorem 6.</p>

    <p class="text-gray-300">In the remainder we prove soundness. Let us generate a public keys and secret keys according to the usual algorithms, obtaining</p>

    <div class="my-4 text-center"><span class="math-block">n, g, y _ {1}, y _ {2}, y _ {3}, x _ {1}, x _ {2}, x _ {3}, \\mathfrak {n}, \\mathfrak {g}, \\mathfrak {h}.</span></div>

    <p class="text-gray-300">All of this information is available to the adversary, who produces <span class="math">\\delta, \\psi, L</span>, and is able to make the verifier accept on these inputs with non-negligible probability. By standard rewinding techniques we can produce two accepting conversations for either the <span class="math">PK</span> protocol in Step 2 or the one in Step 3 (for different challenges but the same first message), depending on whether <span class="math">\\delta = \\gamma^{\\hat{m}}</span>, where <span class="math">\\hat{m} = \\mathcal{D}(\\mathsf{SK}, \\psi, L) \\operatorname{rem} n</span>, for <span class="math">(\\delta, \\psi, L)</span> provided by <span class="math">\\mathcal{A}^*</span>. We consider these two cases.</p>

    <p class="text-gray-300">Case I. First assume that <span class="math">\\delta \\neq \\gamma^{\\hat{m}}</span> or reject <span class="math">= \\mathcal{D}(\\mathsf{SK},\\psi ,L)</span> but that <span class="math">V</span>'s output is 1. Let <span class="math">(u,e,v)\\coloneqq \\psi</span>. We can now get two accepting conversations of the <span class="math">PK</span> protocol in Step 2 and hence two answers</p>

    <div class="my-4 text-center"><span class="math-block">(\\tilde {x} _ {1} ^ {(1)}, \\tilde {x} _ {2} ^ {(1)}, \\tilde {x} _ {3} ^ {(1)}, \\tilde {m} ^ {(1)}, \\tilde {w} _ {1} ^ {(1)}, \\ldots , \\tilde {w} _ {4} ^ {(1)}, \\tilde {t} _ {1} ^ {(1)}, \\ldots , \\tilde {t} _ {5} ^ {(1)}, \\tilde {s} ^ {(1)})</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">(\\tilde {x} _ {1} ^ {(2)}, \\tilde {x} _ {2} ^ {(2)}, \\tilde {x} _ {3} ^ {(2)}, \\tilde {m} ^ {(2)}, \\tilde {w} _ {1} ^ {(2)}, \\ldots , \\tilde {w} _ {4} ^ {(2)}, \\tilde {t} _ {1} ^ {(2)}, \\ldots , \\tilde {t} _ {5} ^ {(2)}, \\tilde {s} ^ {(2)})</span></div>

    <p class="text-gray-300">for the two different challenges <span class="math">c^{(1)}</span> and <span class="math">c^{(2)}</span> but with the same first message (here we use the same notation for the protocol variables as for the <span class="math">PK</span> protocol in the previous section). W.l.o.g., suppose that <span class="math">c^{(2)} &amp;gt; c^{(1)}</span>. Let <span class="math">\\Delta x_{1} = \\tilde{x}_{1}^{(1)} - \\tilde{x}_{1}^{(2)}</span>, <span class="math">\\Delta x_{2} = \\tilde{x}_{2}^{(1)} - \\tilde{x}_{2}^{(2)}</span>, <span class="math">\\Delta x_{3} = \\tilde{x}_{3}^{(1)} - \\tilde{x}_{3}^{(2)}</span>, <span class="math">\\Delta m = \\tilde{m}^{(1)} - \\tilde{m}^{(2)}</span>, <span class="math">\\Delta w_{1} = \\tilde{w}_{1}^{(1)} - \\tilde{w}_{1}^{(2)}</span>, ..., <span class="math">\\Delta w_{4} = \\tilde{w}_{4}^{(1)} - \\tilde{w}_{4}^{(2)}</span>, <span class="math">\\Delta t_{1} = \\tilde{t}_{1}^{(1)} - \\tilde{t}_{1}^{(2)}</span>, ..., <span class="math">\\Delta t_{5} = \\tilde{t}_{5}^{(1)} - \\tilde{t}_{5}^{(2)}</span>, <span class="math">\\Delta s = \\tilde{s}^{(1)} - \\tilde{s}^{(2)}</span>, and <span class="math">\\Delta c = c^{(2)} - c^{(1)}</span>. From the verification equation of the <span class="math">PK</span> protocol one can derive the following equations:</p>

    <div class="my-4 text-center"><span class="math-block">y _ {1} ^ {\\Delta c} = g ^ {\\Delta x _ {1}} \\quad y _ {2} ^ {\\Delta c} = g ^ {\\Delta x _ {2}} \\quad y _ {3} ^ {\\Delta c} = g ^ {\\Delta x _ {3}} \\tag {44}</span></div>

    <div class="my-4 text-center"><span class="math-block">v ^ {2 \\Delta c} = u ^ {2 \\Delta x _ {2}} u ^ {2 \\mathcal {H} _ {\\mathrm {b k}} (u, e, L) \\Delta x _ {3}} \\tag {45}</span></div>

    <div class="my-4 text-center"><span class="math-block">e ^ {2 \\Delta c} = u ^ {2 \\Delta x _ {1}} h ^ {2 \\Delta m} \\tag {46}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathfrak {W} _ {1} ^ {\\Delta c} = \\mathfrak {g} ^ {\\Delta w _ {1}} \\mathfrak {h} ^ {\\Delta t _ {1}} \\quad \\mathfrak {W} _ {2} ^ {\\Delta c} = \\mathfrak {g} ^ {\\Delta w _ {2}} \\mathfrak {h} ^ {\\Delta t _ {2}} \\quad \\mathfrak {W} _ {3} ^ {\\Delta c} = \\mathfrak {g} ^ {\\Delta w _ {3}} \\mathfrak {h} ^ {\\Delta t _ {3}} \\quad \\mathfrak {W} _ {4} ^ {\\Delta c} = \\mathfrak {g} ^ {\\Delta w _ {4}} \\mathfrak {h} ^ {\\Delta t _ {4}} \\tag {47}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathfrak {M} ^ {\\Delta c} = \\mathfrak {g} ^ {\\Delta m} \\mathfrak {h} ^ {\\Delta t _ {5}} \\quad \\mathfrak {g} ^ {\\Delta c (n - 1) ^ {2} / 4} = \\mathfrak {M} ^ {\\Delta m} \\mathfrak {W} _ {1} ^ {\\Delta w _ {1}} \\mathfrak {W} _ {2} ^ {\\Delta w _ {2}} \\mathfrak {W} _ {3} ^ {\\Delta w _ {3}} \\mathfrak {W} _ {4} ^ {\\Delta w _ {4}} \\mathfrak {h} ^ {\\Delta s} \\tag {48}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\delta^ {\\Delta c} = \\gamma^ {\\Delta m} \\tag {49}</span></div>

    <p class="text-gray-300">Consider the equations (47) and (48). Under the strong RSA assumption, and using Theorem 3, we may assume that <span class="math">\\Delta c</span> divides each of <span class="math">\\Delta m</span>, <span class="math">\\Delta w_{1}</span>, <span class="math">\\ldots</span>, <span class="math">\\Delta w_{4}</span>, <span class="math">\\Delta t_{1}</span>, <span class="math">\\ldots</span>, <span class="math">\\Delta t_{5}</span>, and <span class="math">\\Delta s</span>. So we compute <span class="math">\\hat{m}=\\Delta m/\\Delta c</span>, <span class="math">\\hat{w}_{1}=\\Delta w_{1}/\\Delta c</span>, <span class="math">\\ldots</span>, <span class="math">\\hat{w}_{4}=\\Delta w_{4}/\\Delta c</span>, <span class="math">\\hat{t}_{1}=\\Delta t_{1}/\\Delta c</span>, <span class="math">\\ldots</span>, <span class="math">\\hat{t}_{5}=\\Delta t_{5}/\\Delta c</span>, and <span class="math">\\hat{s}=\\Delta s/\\Delta c</span> and we know that</p>

    <p class="text-gray-300"><span class="math">\\mathfrak{M}=\\mathfrak{m}\\mathfrak{g}^{\\hat{m}}\\mathfrak{h}^{\\hat{t_{5}}}\\quad\\mathfrak{W}_{1}=\\mathfrak{w}_{1}\\mathfrak{g}^{\\hat{w}_{1}}\\mathfrak{h}^{\\hat{t}_{1}}\\quad\\mathfrak{W}_{2}=\\mathfrak{w}_{2}\\mathfrak{g}^{\\hat{w}_{2}}\\mathfrak{h}^{\\hat{t}_{2}}\\quad\\mathfrak{W}_{3}=\\mathfrak{w}_{3}\\mathfrak{g}^{\\hat{w}_{3}}\\mathfrak{h}^{\\hat{t}_{3}}\\quad\\mathfrak{W}_{4}=\\mathfrak{w}_{4}\\mathfrak{g}^{\\hat{w}_{4}}\\mathfrak{h}^{\\hat{t}_{4}}\\quad\\delta=\\gamma^{\\hat{m}}</span> (50)</p>

    <p class="text-gray-300">holds for some <span class="math">\\mathfrak{m}</span>, <span class="math">\\mathfrak{w}_{1}</span>, <span class="math">\\mathfrak{w}_{2}</span>, <span class="math">\\mathfrak{w}_{3}</span>, and <span class="math">\\mathfrak{w}_{4}</span> such that <span class="math">\\mathfrak{m}^{2}=1</span> and <span class="math">\\mathfrak{w}_{i}^{2}=1</span>. Furthermore, we can rewrite the second equation of (48) as follows</p>

    <p class="text-gray-300"><span class="math">\\mathfrak{g}^{(n-1)^{2}/4}=\\mathfrak{a}\\mathfrak{g}^{\\hat{m}^{2}+\\sum\\hat{w}_{i}^{2}}\\mathfrak{h}^{\\hat{m}\\hat{t}_{5}+\\sum\\hat{w}_{i}\\hat{t}_{i}+\\hat{s}}</span> (51)</p>

    <p class="text-gray-300">for some <span class="math">\\mathfrak{a}</span> such that <span class="math">\\mathfrak{a}^{2}=1</span>. In fact, <span class="math">\\mathfrak{a}=1</span> as, first, <span class="math">\\mathfrak{a}</span> must lie in <span class="math">\\langle\\mathfrak{g}\\rangle</span> and, second, if <span class="math">\\mathfrak{a}\\neq\\pm 1</span> then <span class="math">\\gcd(\\mathfrak{a}-1,\\mathfrak{n})</span> splits <span class="math">\\mathfrak{n}</span>. Applying Theorem 2, we may assume that</p>

    <p class="text-gray-300"><span class="math">(n-1)^{2}/4=\\hat{m}^{2}+\\hat{w}_{1}^{2}+\\hat{w}_{2}^{2}+\\hat{w}_{3}^{2}+\\hat{w}_{4}^{2}</span></p>

    <p class="text-gray-300">and thus <span class="math">(n-1)^{2}/4-\\hat{m}^{2}\\geq 0</span> which is equivalent to</p>

    <p class="text-gray-300"><span class="math">-(n-1)/2\\leq\\hat{m}\\leq(n-1)/2\\enspace.</span> (52)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider Equations (44-46). As <span class="math">n</span> is the product of two safe primes <span class="math">p</span> and <span class="math">q</span>, we have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\min\\{p,q,p^{\\prime}q^{\\prime}\\}<span class="math"> and hence </span>\\Delta c<span class="math"> is invertible modulo </span>n^{\\prime}n<span class="math">. By construction we know </span>x_{i}<span class="math"> such that </span>y_{i}=g^{x_{i}}$ and therefore it follows from (44) that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\Delta c\\,x_{i}\\equiv\\Delta x_{i}\\pmod{n^{\\prime}}\\quad\\text{for}\\quad i=1,\\ldots,3\\enspace.</span> (53)</p>

    <p class="text-gray-300">Now we can either have <span class="math">\\mathcal{D}(\\mathsf{SK},\\psi,L)=\\mathsf{reject}</span> or <span class="math">\\delta\\neq\\gamma^{(m\\,\\mathrm{rem}\\,n)}</span> where <span class="math">m=\\mathcal{D}(\\mathsf{SK},\\psi,L)=\\log_{h^{2}}(e/u^{x_{1}})^{2}</span>, i.e., one of the three statements</p>

    <p class="text-gray-300"><span class="math">u^{2(x_{2}+\\mathcal{H}_{\\mathsf{hk}}(u,e,L)x_{3})}/v^{2}\\neq 1\\qquad\\quad\\text{or}\\qquad\\quad(e/u^{x_{1}})^{2n}\\neq 1\\qquad\\quad\\text{or}\\qquad\\quad(\\frac{e}{u^{x_{1}}})^{2}\\neq h^{2\\hat{m}}</span> (54)</p>

    <p class="text-gray-300">must hold (cf. (43)), where the last is equivalent to <span class="math">\\delta\\neq\\gamma^{(m\\,\\mathrm{rem}\\,n)}</span> because of Equations (49) and (52) and the fact that <span class="math">-(n-1)/2\\leq(m\\,\\mathrm{rem}\\,n)\\leq(n-1)/2</span>.</p>

    <p class="text-gray-300">We consider these three cases:</p>

    <p class="text-gray-300">If <span class="math">u^{2(x_{2}+\\mathcal{H}_{\\mathsf{hk}}(u,e,L)x_{3})}\\neq v^{2}</span> we must have that <span class="math">u^{2\\Delta c(x_{2}+\\mathcal{H}_{\\mathsf{hk}}(u,e,L)x_{3})}\\neq v^{2\\Delta c}=u^{2\\Delta x_{2}+\\mathcal{H}_{\\mathsf{hk}}(u,e,L)\\Delta x_{3}}</span> (from Equation (45) and because <span class="math">\\Delta c</span> is invertible modulo <span class="math">nn^{\\prime}</span>) and therefore also</p>

    <p class="text-gray-300"><span class="math">\\Delta c(x_{2}+\\mathcal{H}_{\\mathsf{hk}}(u,e,L)x_{3})\\not\\equiv\\Delta x_{2}+\\mathcal{H}_{\\mathsf{hk}}(u,e,L)\\Delta x_{3}\\pmod{n^{\\prime}n}\\enspace,</span></p>

    <p class="text-gray-300">as the order of <span class="math">u^{2}</span> divides <span class="math">n^{\\prime}n</span>. From (53) it follows that</p>

    <p class="text-gray-300"><span class="math">\\Delta c(x_{2}+\\mathcal{H}_{\\mathsf{hk}}(u,e,L)x_{3})\\equiv\\Delta x_{2}+\\mathcal{H}_{\\mathsf{hk}}(u,e,L)\\Delta x_{3}\\pmod{n^{\\prime}}\\enspace.</span></p>

    <p class="text-gray-300">Therefore <span class="math">\\Delta cx_{2}-\\Delta x_{2}+(\\Delta cx_{3}-\\Delta x_{3})\\mathcal{H}_{\\mathsf{hk}}(u,e,L)</span> must be a non-zero multiple of <span class="math">n^{\\prime}</span> and we can factor <span class="math">n</span>, a contradiction.</p>

    <p class="text-gray-300">Case 2. If <span class="math">u^{2nx_1} \\neq e^{2n}</span> we have that <span class="math">u^{2n\\Delta cx_1} \\neq e^{2n\\Delta c}</span>. Because of (46) and <span class="math">h^n = 1</span>, we get</p>

    <div class="my-4 text-center"><span class="math-block">u^{2n\\Delta cx_1} \\neq u^{2n\\Delta x_1} \\quad \\text{and thus} \\quad \\Delta cx_1 \\not\\equiv \\Delta x_1 \\pmod{n&#x27;} \\ ,</span></div>

    <p class="text-gray-300">because <span class="math">u^{2n}</span> has order dividing <span class="math">n&#x27;</span>. The latter, however, is a contradiction to Eqn. (53) and thus this case can not occur.</p>

    <p class="text-gray-300">Case 3. The inequality <span class="math">(\\frac{e}{u^{x_1}})^2 \\neq h^{2\\hat{m}}</span> is equivalent to <span class="math">(\\frac{e}{h^{\\hat{m}}})^2 \\neq u^{2x_1}</span>. Recalling that <span class="math">\\hat{m}\\Delta c = \\Delta m</span> we can rewrite (46) as</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\frac{e^{\\Delta c}}{h^{\\Delta m}}\\right)^2 = \\left(\\frac{e}{h^{\\hat{m}}}\\right)^{2\\Delta c} = u^{2\\Delta x_1} \\quad \\text{and conclude that} \\quad u^{2\\Delta cx_1} \\neq u^{2\\Delta x_1} \\ .</span></div>

    <p class="text-gray-300">Similarly to case 1, it follows that <span class="math">\\Delta cx_1 - \\Delta x_1</span> is a multiple of <span class="math">n&#x27;</span> and we are again able to factor <span class="math">n</span>, a contradiction.</p>

    <p class="text-gray-300">Case II. It remains to consider the case when <span class="math">V</span>'s output is <span class="math">-1</span> but <span class="math">\\delta = \\gamma^{(\\mathcal{D}(\\mathsf{SK},\\psi ,L)\\mathrm{rem}n)}</span> holds. Let <span class="math">(u,e,v)\\coloneqq \\psi</span>. Now all the three equations</p>

    <div class="my-4 text-center"><span class="math-block">u^{2(x_2 + \\mathcal{H}_{\\mathrm{sk}}(u, e, L)x_3)} / v^2 = 1 \\quad (e / u^{x_1})^{2n} = 1 \\quad \\delta = \\gamma^{(\\log_{h^2}(e / u^{x_1})^2 \\mathrm{rem} n)} \\tag{55}</span></div>

    <p class="text-gray-300">must hold. As usual we obtain two accepting conversation of the <span class="math">PK</span> protocol in Step 3 and thus two answers</p>

    <div class="my-4 text-center"><span class="math-block">(\\tilde{x}_1^{(1)}, \\tilde{x}_2^{(1)}, \\tilde{x}_3^{(1)}, \\tilde{a}_1^{(1)}, \\ldots, \\tilde{a}_4^{(1)}, \\tilde{b}_1^{(1)}, \\ldots, \\tilde{b}_4^{(1)}, \\tilde{r}_1^{(1)}, \\ldots, \\tilde{r}_4^{(1)}, \\tilde{s}_1^{(1)}, \\ldots, \\tilde{s}_5^{(1)}, \\tilde{t}_1^{(1)}, \\ldots, \\tilde{t}_5^{(1)}, \\tilde{w}_1^{(1)}, \\ldots, \\tilde{w}_4^{(1)}, \\tilde{m}_1^{(1)})</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">(\\tilde{x}_1^{(2)}, \\tilde{x}_2^{(2)}, \\tilde{x}_3^{(2)}, \\tilde{a}_1^{(2)}, \\ldots, \\tilde{a}_4^{(2)}, \\tilde{b}_1^{(2)}, \\ldots, \\tilde{b}_4^{(2)}, \\tilde{r}_1^{(2)}, \\ldots, \\tilde{r}_4^{(2)}, \\tilde{s}_1^{(2)}, \\ldots, \\tilde{s}_5^{(2)}, \\tilde{t}_1^{(2)}, \\ldots, \\tilde{t}_5^{(2)}, \\tilde{w}_1^{(2)}, \\ldots, \\tilde{w}_4^{(2)}, \\tilde{m}_1^{(2)})</span></div>

    <p class="text-gray-300">for the two different challenges <span class="math">c^{(1)}</span> and <span class="math">c^{(2)}</span> but with the same first message (here we use the same notation for the protocol variables as for the <span class="math">PK</span> protocol in the previous section and left out an intermediate step that deals with the <span class="math">\\vee</span>'s (c.f. [CDS94])). W.l.o.g., suppose that <span class="math">c^{(2)} &amp;gt; c^{(1)}</span>. Let</p>

    <div class="my-4 text-center"><span class="math-block">\\Delta x_i = \\tilde{x}_i^{(1)} - \\tilde{x}_i^{(2)} \\ (i = 1, \\dots, 3); \\quad \\Delta a_i = \\tilde{a}_i^{(1)} - \\tilde{a}_i^{(2)} \\ (i = 1, \\dots, 4);</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Delta b_i = \\tilde{b}_i^{(1)} - \\tilde{b}_i^{(2)} \\ (i = 1, \\dots, 4); \\quad \\Delta r_i = \\tilde{r}_i^{(1)} - \\tilde{r}_i^{(2)} \\ (i = 1, \\dots, 4);</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Delta s_i = \\tilde{s}_i^{(1)} - \\tilde{s}_i^{(2)} \\ (i = 1, \\dots, 5); \\quad \\Delta t_i = \\tilde{t}_i^{(1)} - \\tilde{t}_i^{(2)} \\ (i = 1, \\dots, 5);</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Delta w_i = \\tilde{w}_i^{(1)} - \\tilde{w}_i^{(2)} \\ (i = 1, \\dots, 4); \\quad \\Delta m = m^{(1)} - c^{(2)};</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Delta c = c^{(2)} - c^{(1)} \\ .</span></div>

    <p class="text-gray-300">From the verification equation of the <span class="math">PK</span> protocol one can derive that</p>

    <div class="my-4 text-center"><span class="math-block">y_1^{\\Delta c} = g^{\\Delta x_1} \\ , \\quad y_2^{\\Delta c} = g^{\\Delta x_2} \\ , \\quad \\text{and} \\quad y_3^{\\Delta c} = g^{\\Delta x_3} \\ , \\tag{56}</span></div>

    <p class="text-gray-300">hold and either</p>

    <div class="my-4 text-center"><span class="math-block">C_1^{\\Delta c} = u^{2n\\Delta r_1} \\left(\\frac{1}{v}\\right)^{2n\\Delta a_1} \\ , \\quad \\mathfrak{C}_1^{\\Delta c} = \\mathfrak{g}^{\\Delta a_1} \\mathfrak{h}^{\\Delta b_1} \\ , \\quad \\text{and} \\quad 1 = \\left(\\frac{1}{\\mathfrak{C}_1}\\right)^{\\Delta x_2 + \\mathcal{H}_{\\mathrm{sk}}(u, e, L)\\Delta x_3} \\mathfrak{g}^{\\Delta r_1} \\mathfrak{h}^{\\Delta s_1} \\tag{57}</span></div>

    <p class="text-gray-300">or</p>

    <p class="text-gray-300"><span class="math">C_{2}^{\\Delta c}=u^{2\\Delta r_{2}}(\\frac{1}{v})^{2\\Delta a_{2}}\\;\\;,\\qquad\\mathfrak{C}_{2}^{\\Delta c}=\\mathfrak{g}^{\\Delta a_{2}}\\mathfrak{h}^{\\Delta b_{2}}\\;\\;,\\quad\\text{and}\\quad\\;1=(\\frac{1}{\\mathfrak{C}_{2}})^{\\Delta x_{2}+\\mathcal{H}_{\\text{bk}}(u,e,L)\\Delta x_{3}}\\mathfrak{g}^{\\Delta r_{2}}\\mathfrak{h}^{\\Delta s_{2}}</span> (58)</p>

    <p class="text-gray-300">or</p>

    <p class="text-gray-300"><span class="math">C_{3}^{\\Delta c}=u^{2n\\Delta r_{3}}(\\frac{1}{e})^{2n\\Delta a_{3}}\\;\\;,\\quad\\mathfrak{C}_{3}^{\\Delta c}=\\mathfrak{g}^{\\Delta a_{3}}\\mathfrak{h}^{\\Delta b_{3}}\\;\\;,\\quad\\text{and}\\quad\\;1=(\\frac{1}{\\mathfrak{C}_{3}})^{\\Delta x_{1}}\\mathfrak{g}^{\\Delta r_{3}}\\mathfrak{h}^{\\Delta s_{3}}</span> (59)</p>

    <p class="text-gray-300">or</p>

    <p class="text-gray-300"><span class="math">C_{4}^{\\Delta c}=\\gamma^{\\Delta r_{4}}(\\frac{1}{\\delta})^{\\Delta a_{4}}\\;\\;,\\qquad\\quad\\mathfrak{C}_{4}^{\\Delta c}=\\;\\mathfrak{g}^{\\Delta a_{4}}\\mathfrak{h}^{\\Delta b_{4}}\\;\\;,\\qquad\\quad\\;1=(\\frac{1}{\\mathfrak{C}_{4}})^{\\Delta m}\\mathfrak{g}^{\\Delta r_{4}}\\mathfrak{h}^{\\Delta s_{4}}</span> (60) <span class="math">e^{2\\Delta c}=u^{2\\Delta x_{1}}h^{2\\Delta m}\\;\\;,\\quad\\mathfrak{M}^{\\Delta c}=\\mathfrak{g}^{\\Delta m}\\mathfrak{h}^{\\Delta t_{5}}\\;\\;,\\quad\\;\\mathfrak{g}^{\\Delta c(n-1)^{2}/4}=\\mathfrak{M}^{\\Delta m}\\mathfrak{M}_{1}^{\\Delta w_{1}}\\mathfrak{M}_{2}^{\\Delta w_{2}}\\mathfrak{M}_{3}^{\\Delta w_{3}}\\mathfrak{M}_{4}^{\\Delta w_{4}}\\mathfrak{h}^{\\Delta s_{5}}</span> (61) <span class="math">\\mathfrak{M}_{1}^{\\Delta c}=\\mathfrak{g}^{\\Delta w_{1}}\\mathfrak{h}^{\\Delta t_{1}}\\;\\;,\\quad\\mathfrak{M}_{2}^{\\Delta c}=\\mathfrak{g}^{\\Delta w_{2}}\\mathfrak{h}^{\\Delta t_{2}}\\;\\;,\\quad\\mathfrak{M}_{3}^{\\Delta c}=\\mathfrak{g}^{\\Delta w_{3}}\\mathfrak{h}^{\\Delta t_{3}}\\;\\;,\\quad\\text{and}\\quad\\;\\mathfrak{M}_{4}^{\\Delta c}=\\mathfrak{g}^{\\Delta w_{4}}\\mathfrak{h}^{\\Delta t_{4}}\\;\\;.</span> (62)</p>

    <p class="text-gray-300">hold. We know <span class="math">x_{i}</span> such that <span class="math">y_{i}=g^{x_{i}}</span> and therefore it follows from (33) that</p>

    <p class="text-gray-300"><span class="math">\\Delta c\\,x_{i}\\equiv\\Delta x_{i}\\quad(\\text{mod }n^{\\prime})\\quad\\text{for}\\quad i=1,\\ldots,3\\;\\;.</span> (63)</p>

    <p class="text-gray-300">We next consider the implications of the cases when the equations (57), the equations (58), the equations (59), or the equations (60-62) hold in conjunction with (56). The first three cases appear also in the proof of Theorem 6, while the last one is different:</p>

    <p class="text-gray-300">Case 4. Similarly as in Case I above, from the Equations (61) and (62) we can derive that</p>

    <p class="text-gray-300"><span class="math">e^{2\\Delta c}=u^{2\\Delta x_{1}}h^{2\\Delta c\\hat{m}}\\qquad\\text{and}\\qquad-(n-1)/2\\leq\\hat{m}\\leq(n-1)/2</span> (64)</p>

    <p class="text-gray-300">where <span class="math">\\hat{m}=\\Delta m/\\Delta c</span>. Using Equations (63) and the fact that <span class="math">\\Delta c</span> is invertible modulo <span class="math">nn^{\\prime}</span>, we get</p>

    <p class="text-gray-300"><span class="math">e^{2}=u^{2x_{1}}h^{2\\hat{m}}\\;\\;,</span></p>

    <p class="text-gray-300">and, because of the second equation of (64),</p>

    <p class="text-gray-300"><span class="math">\\hat{m}=(\\log_{h^{2}}u^{2x_{1}}/e^{2}\\operatorname{rem}n)</span> (65)</p>

    <p class="text-gray-300">Similarly as we did in Case II in the proof of Theorem 6, one can derive from the last two equations of (60) that</p>

    <p class="text-gray-300"><span class="math">\\Delta r_{4}=\\Delta a_{4}\\hat{m}</span> (66)</p>

    <p class="text-gray-300">holds (using the strong RSA assumption for <span class="math">\\mathfrak{n}</span>). Now using (66) in the first equation of (60)</p>

    <p class="text-gray-300"><span class="math">C_{4}^{\\Delta c}=\\gamma^{\\Delta a_{4}\\hat{m}}(\\frac{1}{\\delta})^{\\Delta a_{4}}\\qquad\\text{and}\\qquad C_{4}=(\\frac{\\gamma^{\\hat{m}}}{\\delta})^{\\hat{a}_{4}}\\;\\;,</span> (67)</p>

    <p class="text-gray-300">where <span class="math">\\hat{a}_{4}:=\\Delta a_{4}/\\Delta c</span> (mod <span class="math">\\rho</span>). Because <span class="math">C_{4}\\neq 1</span> we must have that <span class="math">\\delta\\neq\\gamma^{\\hat{m}}</span> and because of (65) that</p>

    <p class="text-gray-300"><span class="math">\\delta\\neq\\gamma^{(\\log_{h^{2}}u^{2x_{1}}/e^{2}\\operatorname{rem}n)}\\;\\;,</span></p>

    <p class="text-gray-300">which is a contradiction to the third equation of (55) and hence this case can not occur.</p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">##</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[ACJT00] G. Ateniese, J. Camenisch, M. Joye, and G. Tsudik, <em>A practical and provably secure coalition-resistant group signature scheme</em>, Advances in Cryptology — CRYPTO 2000 (M. Bellare, ed.), LNCS, vol. 1880, Springer Verlag, 2000, pp. 255–270.</li>

      <li>[ADR02] J. H. An, Y. Dodis, and T. Rabin, <em>On the security of joint signature and encryption</em>, Advances in Cryptology — EUROCRYPT 2002 (L. Knudsen, ed.), LNCS, vol. 2332, Springer, 2002, pp. 83–107.</li>

      <li>[ASW97] N. Asokan, M. Schunter, and M. Waidner, <em>Optimistic protocols for fair exchange</em>, Proc. 4th ACM Conference on Computer and Communications Security, 1997, pp. 6–17.</li>

      <li>[ASW98] N. Asokan, V. Shoup, and M. Waidner, <em>Optimistic fair exchange of digital signatures</em>, Advances in Cryptology — EUROCRYPT ’98 (K. Nyberg, ed.), LNCS, vol. 1403, Springer Verlag, 1998, pp. 591–606.</li>

      <li>[ASW00] N. Asokan, V. Shoup, and M. Waidner, <em>Optimistic fair exchange of digital signatures</em>, IEEE Journal on Selected Areas in Communications 18 (2000), no. 4, 591–610.</li>

      <li>[BDM98] F. Bao, R. Deng, and W. Mao, <em>Efficient and practical fair exchange protocols with off-line TTP</em>, IEEE Symposium on Security and Privacy, IEEE Computer Society Press, 1998, pp. 77–85.</li>

      <li>[BG96] M. Bellare and S. Goldwasser, <em>Encapsulated key escrow</em>, Tech. Report TR 688, MIT Laboratory for Computer Science, April 1996.</li>

      <li>[Bou00] F. Boudot, <em>Efficient proofs that a committed number lies in an interval</em>, Advances in Cryptology — EUROCRYPT 2000 (B. Preneel, ed.), LNCS, vol. 1807, Springer Verlag, 2000, pp. 431–444.</li>

      <li>[BP90] H. Bürk and A. Pfitzmann, <em>Digital payment systems enabling security and unobservability</em>, Computer &amp; Security 9 (1990), no. 8, 715–721.</li>

      <li>[BP97] N. Barić and B. Pfitzmann, <em>Collision-free accumulators and fail-stop signature schemes without trees</em>, Advances in Cryptology — EUROCRYPT ’97 (W. Fumy, ed.), LNCS, vol. 1233, Springer Verlag, 1997, pp. 480–494.</li>

      <li>[BS02] E. Bresson and J. Stern, <em>Proofs of knowledge for non-monotone discrete-log formulae and applications</em>, Information Security (ISC 2002) (A. H. Chan and V. Gligor, eds.), LNCS, vol. 2433, Springer Verlag, 2002, pp. 272–288.</li>

      <li>[CD00] J. Camenisch and I. Damgård, <em>Verifiable encryption, group encryption, and their applications to group signatures and signature sharing schemes</em>, Advances in Cryptology — ASIACRYPT 2000 (T. Okamoto, ed.), LNCS, vol. 1976, Springer Verlag, 2000, pp. 331–345.</li>

      <li>[CDS94] R. Cramer, I. Damgård, and B. Schoenmakers, <em>Proofs of partial knowledge and simplified design of witness hiding protocols</em>, Advances in Cryptology — CRYPTO ’94 (Y. G. Desmedt, ed.), LNCS, vol. 839, Springer Verlag, 1994, pp. 174–187.</li>

    </ul>

    <p class="text-gray-300">[CF01] R. Canetti and M. Fischlin, Universally composable commitments, Advances in Cryptology — CRYPTO 2001 (J. Kilian, ed.), LNCS, vol. 2139, Springer Verlag, 2001, pp. 19–40.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[CFT98] A. Chan, Y. Frankel, and Y. Tsiounis, Easy come – easy go divisible cash, Advances in Cryptology — EUROCRYPT ’98 (K. Nyberg, ed.), LNCS, vol. 1403, Springer Verlag, 1998, pp. 561–575.</li>

      <li>[CG98] D. Catalano and R. Gennaro, New efficient and secure protocols for verifiable signature sharing and other applications, Advances in Cryptology — CRYPTO ’98 (Berlin) (H. Krawczyk, ed.), LNCS, vol. 1642, Springer Verlag, 1998, pp. 105–120.</li>

      <li>[CG99] R. Canetti and S. Goldwasser, An efficient threshold public key cryptosystem secure against adaptive chosen ciphertext attack, Advances in Cryptology — EUROCRYPT ’99 (J. Stern, ed.), LNCS, vol. 1592, Springer Verlag, 1999, pp. 90–106.</li>

      <li>[CGGM00] R. Canetti, O. Goldreich, S. Goldwasser, and S. Micali, Resettable zero-knowledge, Proc. 32st Annual ACM Symposium on Theory of Computing (STOC), ACM Press, 2000, pp. 235–244.</li>

      <li>[Cha85] D. Chaum, Security without identification: Transaction systems to make big brother obsolete, Communications of the ACM 28 (1985), no. 10, 1030–1044.</li>

      <li>[Cha94] D. Chaum, Designated confirmer signatures, Advances in Cryptology — EUROCRYPT ’94 (A. De Santis, ed.), LNCS, vol. 950, Springer Verlag Berlin, 1994, pp. 86–91.</li>

      <li>[CL01] J. Camenisch and A. Lysyanskaya, Efficient non-transferable anonymous multi-show credential system with optional anonymity revocation, Advances in Cryptology — EUROCRYPT 2001 (B. Pfitzmann, ed.), LNCS, vol. 2045, Springer Verlag, 2001, pp. 93–118.</li>

      <li>[CM98] J. Camenisch and M. Michels, A group signature scheme with improved efficiency, Advances in Cryptology — ASIACRYPT ’98 (K. Ohta and D. Pei, eds.), LNCS, vol. 1514, Springer Verlag, 1998, pp. 160–174.</li>

      <li>[CM99a] J. Camenisch and M. Michels, Proving in zero-knowledge that a number <span class="math">n</span> is the product of two safe primes, Advances in Cryptology — EUROCRYPT ’99 (J. Stern, ed.), LNCS, vol. 1592, Springer Verlag, 1999, pp. 107–122.</li>

      <li>[CM99b] J. Camenisch and M. Michels, Separability and efficiency for generic group signature schemes, Advances in Cryptology — CRYPTO ’99 (M. Wiener, ed.), LNCS, vol. 1666, Springer Verlag, 1999, pp. 413–430.</li>

      <li>[CM00] J. Camenisch and M. Michels, Confirmer signature schemes secure against adaptive adversaries, Advances in Cryptology — EUROCRYPT 2000 (B. Preneel, ed.), LNCS, vol. 1807, Springer Verlag, 2000, pp. 243–258.</li>

      <li>[CP93] D. Chaum and T. P. Pedersen, Wallet databases with observers, Advances in Cryptology — CRYPTO ’92 (E. F. Brickell, ed.), LNCS, vol. 740, Springer-Verlag, 1993, pp. 89–105.</li>

    </ul>

    <p class="text-gray-300">[CS97] J. Camenisch and M. Stadler, <em>Efficient group signature schemes for large groups</em>, Advances in Cryptology — CRYPTO ’97 (B. Kaliski, ed.), LNCS, vol. 1296, Springer Verlag, 1997, pp. 410–424.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[CS98] R. Cramer and V. Shoup, <em>A practical public key cryptosystem provably secure against adaptive chosen ciphertext attack</em>, Advances in Cryptology — CRYPTO ’98 (Berlin) (H. Krawczyk, ed.), LNCS, vol. 1642, Springer Verlag, 1998, pp. 13–25.</li>

      <li>[CS00] R. Cramer and V. Shoup, <em>Signature schemes based on the strong RSA assumption</em>, ACM Transactions on Information and System Security 3 (2000), no. 3, 161–185.</li>

      <li>[CS02] R. Cramer and V. Shoup, <em>Universal hash proofs and a paradigm for adaptive chosen ciphertext secure public-key encryption</em>, Advances in Cryptology — EUROCRYPT 2002, LNCS, vol. 2332, Springer, 2002, pp. 45–64.</li>

      <li>[CVH02] J. Camenisch and E. Van Herreweghen, <em>Design and implementation of the </em>idemix<em> anonymous credential system</em>, Proc. 9th ACM Conference on Computer and Communications Security, acm press, 2002.</li>

      <li>[Dam00] I. Damgård, <em>Efficient concurrent zero-knowledge in the auxiliary string model</em>, Advances in Cryptology — EUROCRYPT 2000 (B. Preneel, ed.), LNCS, vol. 1807, Springer Verlag, 2000, pp. 431–444.</li>

      <li>[DF02] I. Damgård and E. Fujisaki, <em>An integer commitment scheme based on groups with hidden order</em>, Advances in Cryptology — ASIACRYPT 2002, LNCS, vol. 2501, Springer, 2002.</li>

      <li>[DNS98] C. Dwork, M. Naor, and A. Sahai, <em>Concurrent zero knowledge</em>, Proc. 30th Annual ACM Symposium on Theory of Computing (STOC), 1998.</li>

      <li>[FO97] E. Fujisaki and T. Okamoto, <em>Statistical zero knowledge protocols to prove modular polynomial relations</em>, Advances in Cryptology — CRYPTO ’97 (B. Kaliski, ed.), LNCS, vol. 1294, Springer Verlag, 1997, pp. 16–30.</li>

      <li>[FR95] M. Franklin and M. Reiter, <em>Verifiable signature sharing</em>, Advances in Cryptology — EUROCRYPT ’95 (L. C. Guillou and J.-J. Quisquater, eds.), LNCS, vol. 921, Springer Verlag, 1995, pp. 50–63.</li>

      <li>[FS87] A. Fiat and A. Shamir, <em>How to prove yourself: Practical solutions to identification and signature problems</em>, Advances in Cryptology — CRYPTO ’86 (A. M. Odlyzko, ed.), LNCS, vol. 263, Springer Verlag, 1987, pp. 186–194.</li>

      <li>[GHR99] R. Gennaro, S. Halevi, and T. Rabin, <em>Secure hash-and-sign signatures without the random oracle</em>, Advances in Cryptology — EUROCRYPT ’99 (J. Stern, ed.), LNCS, vol. 1592, Springer Verlag, 1999, pp. 123–139.</li>

      <li>[GL03] R. Gennaro and Y. Lindell, <em>A framework for password-based authenticated key exchange</em>, Advances in Cryptology — EUROCRYPT 2003 (E. Biham, ed.), LNCS, vol. 2656, Springer Verlag, 2003, pp. 524–543.</li>

      <li>[KP98] J. Kilian and E. Petrank, <em>Identity escrow</em>, Advances in Cryptology — CRYPTO ’98 (Berlin) (H. Krawczyk, ed.), LNCS, vol. 1642, Springer Verlag, 1998, pp. 169–185.</li>

    </ul>

    <p class="text-gray-300">[Mic] S. Micali, <em>Efficient certificate revocation and certified e-mail with transparent post offices</em>, Presentation at the 1997 RSA Security Conference.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[MS98] M. Michels and M. Stadler, <em>Generic constructions for secure and efficient confirmer signature schemes</em>, Advances in Cryptology — EUROCRYPT ’98 (K. Nyberg, ed.), LNCS, vol. 1403, Springer Verlag, 1998, pp. 406–421.</li>

      <li>[Pai99] P. Paillier, <em>Public-key cryptosystems based on composite residuosity classes</em>, Advances in Cryptology — EUROCRYPT ’99 (J. Stern, ed.), LNCS, vol. 1592, Springer Verlag, 1999, pp. 223–239.</li>

      <li>[Ped92] T. P. Pedersen, <em>Non-interactive and information-theoretic secure verifiable secret sharing</em>, Advances in Cryptology – CRYPTO ’91 (J. Feigenbaum, ed.), LNCS, vol. 576, Springer Verlag, 1992, pp. 129–140.</li>

      <li>[PS00] G. Poupard and J. Stern, <em>Fair encryption of RSA keys</em>, Advances in Cryptology: EUROCRYPT 2000 (B. Preneel, ed.), LNCS, vol. 1087, Springer Verlag, 2000, pp. 173–190.</li>

      <li>[RS86] M. O. Rabin and J. O. Shallit, <em>Randomized algorithms in number theory</em>, Communications on Pure and Applied Mathematics 39 (1986), 239–256.</li>

      <li>[SG98] V. Shoup and R. Gennaro, <em>Securing threshold cryptosystems against chosen ciphertext attack</em>, Advances in Cryptology — EUROCRYPT ’98 (K. Nyberg, ed.), LNCS, vol. 1403, Springer, 1998.</li>

      <li>[Sho01] V. Shoup, <em>A proposal for an ISO standard for public key encryption</em>, http://eprint.iacr.org/2001/112, 2001.</li>

      <li>[Sta96] M. Stadler, <em>Publicly verifiable secret sharing</em>, Advances in Cryptology — EUROCRYPT ’96 (U. Maurer, ed.), LNCS, vol. 1070, Springer Verlag, 1996, pp. 191–199.</li>

      <li>[YY98] A. Young and M. Young, <em>Auto-recoverable auto-certifiable cryptosystems.</em>, Advances in Cryptology — EUROCRYPT ’98 (K. Nyberg, ed.), LNCS, vol. 1403, Springer Verlag, 1998, pp. 17–31.</li>

    </ul>`;
---

<BaseLayout title="Practical  Verifiable Encryption and Decryption of Discrete ... (2002/161)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2002 &middot; eprint 2002/161
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
