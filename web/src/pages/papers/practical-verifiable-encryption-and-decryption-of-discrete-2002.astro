---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2002/161';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-17';
const TITLE_HTML = 'Practical Verifiable Encryption and Decryption of Discrete Logarithms∗';
const AUTHORS_HTML = 'Jan Camenisch† Victor Shoup‡ August 22, 2003';

const CONTENT = `    <p class="text-gray-300">Jan Camenisch† Victor Shoup‡ August 22, 2003</p>

    <h4 id="sec-1" class="text-lg font-semibold mt-6">Abstract</h4>

    <p class="text-gray-300">This paper addresses the problem of designing practical protocols for proving properties about encrypted data. To this end, it presents a variant of the new public key encryption of Cramer and Shoup based on Paillier's decision composite residuosity assumption, along with efficient protocols for verifiable encryption and decryption of discrete logarithms (and more generally, of representations with respect to multiple bases). This is the first verifiable encryption system that provides chosen ciphertext security and avoids inefficient cut-and-choose proofs. The presented protocols have numerous applications, including key escrow, optimistic fair exchange, publicly verifiable secret and signature sharing, universally composable commitments, group signatures, and confirmer signatures.</p>

    <p class="text-gray-300">Keywords. Verifiable encryption, verifiable decryption, adaptive chosen ciphertext security, public key encryption.</p>

    <p class="text-gray-300">This paper concerns itself with the general problem of proving properties about encrypted data. In the case of public-key encryption, which is the setting in which we are interested here, there are two parties who are in a position to prove some property to another party about an encrypted message — namely, the party who created the ciphertext, and the party who holds the secret key. A protocol in which the encryptor is the prover is a verifiable encryption protocol, while a protocol in which the decryptor is the prover is a verifiable decryption protocol.</p>

    <p class="text-gray-300">For example, suppose a party T has a public key/secret key pair (PK, SK) for a public key encryption scheme. Party A might encrypt, using T's public key PK, a secret message m that satisfies a publicly-defined property θ, and give the resulting ciphertext ψ to another party B. The latter party might demand that A prove that ψ is an encryption of a message satisfying property θ. Ideally, the proof should be &quot;zero knowledge,&quot; so that no unnecessary information about m is leaked to B as part of the proof. Another party B&lt;sup&gt;0&lt;/sup&gt; might obtain the ciphertext ψ, and may request that T prove or disprove that ψ decrypts under SK to a message m satisfying a publicly-defined property θ 0 ; a special case of this would be the situation where T simply gives m to B&lt;sup&gt;0&lt;/sup&gt; , and proves to B&lt;sup&gt;0&lt;/sup&gt; that the decryption was performed correctly. Again, ideally, the proof should be &quot;zero knowledge.&quot;</p>

    <p class="text-gray-300">Now, if one expects to obtain reasonably practical protocols for this problem, it seems necessary to restrict the type of properties that the protocols should work with. In this paper, we consider</p>

    <p class="text-gray-300">&lt;sup&gt;∗&lt;/sup&gt;An extended abstract of this paper appears in the proceedings of Crypto 2003.</p>

    <p class="text-gray-300">&lt;sup&gt;†&lt;/sup&gt; IBM Research, Zurich Research Laboratory, CH–8803 R¨uschlikon, jca@zurich.ibm.com</p>

    <p class="text-gray-300">&lt;sup&gt;‡&lt;/sup&gt;Courant Institute, New York University, shoup@cs.nyu.edu</p>

    <p class="text-gray-300">only properties related to the discrete logarithm problem. The message m encrypted by A above is the discrete logarithm of an element  <span class="math">\\delta</span>  with respect to a base  <span class="math">\\gamma</span> , and A proves to B that  <span class="math">\\psi</span>  is an encryption  <span class="math">\\log_{\\gamma} \\delta</span>  under T's public key PK. Here, the common inputs to A and B in the proof protocol are PK,  <span class="math">\\psi</span> ,  <span class="math">\\delta</span> , and  <span class="math">\\gamma</span> . Similarly, when a party B' presents  <span class="math">\\psi</span>  to T for decryption, T may state and prove whether or nor  <span class="math">\\psi</span>  decrypts to  <span class="math">\\log_{\\gamma} \\delta</span> , or alternatively, T may give the decryption of  <span class="math">\\psi</span>  to B', and simply prove that the decryption was performed correctly. We also consider the obvious generalizations from discrete logarithms to representations with respect to several bases — i.e., proving that a ciphertext is an encryption of  <span class="math">(m_1, \\ldots, m_k)</span>  such that  <span class="math">\\delta = \\gamma_1^{m_1} \\cdots \\gamma_k^{m_k}</span> .</p>

    <p class="text-gray-300">Although the restriction to properties related to the discrete logarithm problem may seem excessive, it turns out (as we discuss in some detail below) that protocols for proving such properties have many useful applications in cryptography, including key escrow, optimistic fair exchange, publicly verifiable secret and signature sharing, universally composable commitments, group signatures, and confirmer signatures. One reason why this restriction is not really so excessive is because in the past few years, efficient protocols for proving numerous properties about committed values—using Pedersen's commitment scheme [Ped92] and generalizations to groups of unknown order—have been developed (c.f., [FO97, DF02, Bou00]); combining these protocols with our scheme for verifiable encryption of a representation (i.e., an opening of a commitment), we immediately get corresponding protocols for proving such properties about encrypted values.</p>

    <p class="text-gray-300">Our contribution. The contribution of this paper is to present and analyze a practical public-key encryption scheme, together with a suite of practical proof protocols for the properties related to the discrete logarithm problem outlined above. The encryption scheme is a variant of the new public key encryption scheme of Cramer and Shoup [CS02] based on Paillier's decision composite residuosity assumption [Pai99], suitably modified so as to support our proof protocols. The proof protocols are all of the usual, three move &quot;Σ-protocol&quot; type [CDS94], satisfying the usual, and very strong conditions of special honest verifier zero knowledge and special soundness. We note that any such protocol can be easily and efficiently converted into a &quot;real&quot; zero-knowledge protocol using well known techniques, e.g., [Dam00]. Our scheme for verifiable encryption of discrete logarithms is the first one that provides chosen ciphertext security and avoids inefficient cut-and-choose proofs. Our scheme for verifiable decryption of discrete logarithms is the first practical protocol of its kind. Our system is very flexible, in that a single public key for the encryption scheme can be used with many different groups; that is, users can choose their own (arbitrary and varied) groups for discrete logarithms, subject only to some (reasonable) size constraints. As pointed out in [KP98, CM99b, ASW00] such separability in system design is highly desirable in practice. Although our protocols do not rely on the random oracle heuristic, we hasten to point out that even allowing this heuristic, our protocols are much more efficient than previously known protocols for these problems.</p>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">1.1 Applications</h4>

    <p class="text-gray-300">In this section, we outline some of the numerous applications of verifiable encryption and decryption of discrete logarithms and representations. For all of them our protocols, used together with the existing solutions, either yield more efficient solutions or add security against chosen ciphertext attacks, which is often crucial.</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">1.1.1 Key Escrow</h4>

    <p class="text-gray-300">Party A may encrypt its own secret key for an asymmetric cryptographic primitive under the public key of a trusted third party T, and present to a second party B the ciphertext  <span class="math">\\psi</span>  and a proof that  <span class="math">\\psi</span></p>

    <p class="text-gray-300">is indeed an encryption of it's secret key. This problem area has attracted a good deal of attention, with specific schemes being proposed in [Sta96, BG96, YY98, ASW00, PS00].</p>

    <p class="text-gray-300">Now, if A's secret key is, say, a key for a discrete log based scheme, such as Schnorr or DSS signatures or ElGamal encryption, we can use our verifiable encryption protocol directly. We note that for this and other applications, it is important to be able to bind some public data, called a label, to the ciphertext at both encryption and decryption time. In this application, user A would attach a label to ψ that indicates the conditions under which ψ should be decrypted, e.g., A's identity and perhaps an expiration date. The definition of chosen ciphertext security ensures that decrypting a ciphertext under any label different from the label used to create the ciphertext reveals no information about the original encrypted message.</p>

    <p class="text-gray-300">Even though T is &quot;trusted,&quot; it might be nice to minimize the trust we need to place in T. To this end, verifiable decryption comes in handy — we can force T to prove that it performed the decryption operation correctly. Of course, this does not prevent T from misbehaving in other ways, such as divulging a secret key to an unauthorized party.</p>

    <p class="text-gray-300">If A's secret key is for a factoring based scheme, one can still use our protocol for verifiable encryption of a representation. One can use Pedersen's commitment scheme to commit to some quantity related to the secret key, and then use an appropriate protocol to prove that the committed value is indeed the right one, together with our protocol to prove that the encryption contains an opening of the commitment. The quantity committed to could be the factorization of an RSA modulus, the decryption exponent of an RSA scheme, or an appropriate root in a Guillou-Quisquater scheme — there are protocols for proving that a committed value is of such a form [FO97, CM99a, DF02, PS00, Bou00].</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1.2 Optimistic Fair Exchange</h3>

    <p class="text-gray-300">Two parties A and B want to exchange some valuable digital data (e.g., signatures on a contract, e-cash), but in a fair way: either each party obtains the other's data, or neither party does. One way to do this is by employing a trusted third party T, but, for the sake of efficiency, with T only involved in crisis situations. One approach to this problem is to have both parties verifiably encrypt to each other their data under T's public key, and only then to reveal their data to each other — if one party backs out unexpectedly, the other can go to T to obtain the required data. The general problem of optimistic fair exchange has been extensively studied, c.f., [ASW97, BDM98, BP90, Mic, ASW00], while the solution using verifiable encryption was studied in detail in [ASW00].</p>

    <p class="text-gray-300">Our scheme for verifiable encryption may be used directly to efficiently implement the fair exchange of Schnorr or DSS signatures. As outlined in [ASW00], if the public key of the Schnorr signature scheme consists of the base γ and the group element α = γ x , and A has a signature on a message m of the form (β, c, s), where β = γ r , c = H(β, m), s = r + xc mod ρ, and ρ is the group size, then A gives to B the triple (β, c, δ), where δ = γ s , along with an encryption ψ of s under T's public key, and proves to B that ψ is an encryption of log&lt;sup&gt;γ&lt;/sup&gt; δ. In addition to checking the proof that ψ is a correct encryption of log&lt;sup&gt;γ&lt;/sup&gt; δ, B also checks that δ = βγ&lt;sup&gt;c&lt;/sup&gt; ; with these checks, B can be sure that if the need arises, ψ can be decrypted so as to obtain a signature on m. As argued in [ASW00], this technique of reducing a signature to a discrete logarithm does not make it any easier for anyone to forge a signature. Moreover, as discussed in [ASW00], similar techniques can be used to facilitate the fair exchange of other items, such as electronic cash.</p>

    <p class="text-gray-300">As in the escrow application, the label mechanism plays a crucial role here, helping to enforce the logic of the exchange protocol, and a verifiable decryption protocol may be used to hold T's feet to the fire.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">1.1.3 Publicly Verifiable Secret Sharing and Signature Sharing</h4>

    <p class="text-gray-300">Stadler [Sta96] introduced the notion of publicly verifiable secret sharing. Here, one party, the dealer, shares a secret with several proxies P1, . . . , Pn, in such a way that a third party (other than the dealer and the proxies) can verify that the sharing was done correctly. This can be done quite simply by sharing the secret using Shamir's secret sharing scheme: the dealer encrypts P&lt;sup&gt;i&lt;/sup&gt; 's share under P&lt;sup&gt;i&lt;/sup&gt; 's public key, and gives to the third party commitments to these shares, along with commitments to the coefficients of the blinding polynomial, and all of the ciphertexts, and proves to the third party that the ciphertexts encrypt openings of the commitments to the shares. As the openings to the commitments are just discrete logarithms, verifiable encryption of discrete logarithms is just the right tool.</p>

    <p class="text-gray-300">Using the notion discussed above above for reducing a signature to a discrete logarithm, one can easily implement a (publicly) verifiable signature sharing scheme [FR95, CG98] for Schnorr and DSS signatures.</p>

    <p class="text-gray-300">These two applications of verifiable encryption were discussed in [CD00].</p>

    <p class="text-gray-300">The notion of universally composable (UC) commitments, introduced by Canetti and Fischlin [CF01], is a very strong notion of security for a commitment scheme. It basically says that commitments in the real world act like commitments in an ideal world in which, when a party A commits to a value x to a party B, A presents x to an idealized trusted party T (that does not exist in the real world), and when A opens the commitment, T gives x to B. In the ideal world, no information about x is revealed to B prior to opening, and A is forced to fix the value committed to when the commitment protocol runs.</p>

    <p class="text-gray-300">This notion of security is so strong, in fact, that it can only be realized in the common reference string (CRS) model, where all parties have access to a string that was generated by a trusted party according to some prescribed distribution. In the CRS model, the simulator S in the ideal world is given the privilege of generating the common reference string, and so S may know some &quot;side information&quot; related to the common reference string that is not available to anyone in the real world.</p>

    <p class="text-gray-300">Verifiable encryption of a representation may be used to implement UC commitments in the CRS model, as follows. The CRS consists of a public key for the encryption scheme, along with bases γ&lt;sup&gt;1&lt;/sup&gt; and γ&lt;sup&gt;2&lt;/sup&gt; for some suitable group. When A commits a value x to B, he creates a Pedersen commitment C = γ x 1 γ r 2 , and an encryption ψ of the representation (x, r) of C with respect to (γ1, γ2). A then gives (C, ψ) to B, and proves to B that ψ indeed decrypts to a representation of C. In order to satisfy the definition of security for UC commitments, and in particular, to prevent &quot;man in the middle attacks,&quot; a label containing A's identity should be attached to ψ.</p>

    <p class="text-gray-300">The reason this is secure is that the simulator S in the CRS model knows the secret key to the encryption scheme, which allows him to &quot;extract&quot; values committed by corrupted parties, and S knows the discrete logarithm of γ&lt;sup&gt;2&lt;/sup&gt; with respect to γ1, which allows him to &quot;equivocate&quot; values committed by honest parties. The proof that ψ is an encryption of a representation C ensures that the value extracted by the simulator at commitment time agrees with the value revealed at opening time.</p>

    <p class="text-gray-300">The details of this construction and security proof are the subject of a forthcoming paper.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">1.1.5 Confirmer Signatures</h4>

    <p class="text-gray-300">In a confirmer signature scheme, a notion introduced in [Cha94], a party A creates an &quot;opaque signature&quot; ψ on a message m, which can not be verified by any other party except a designated trusted third party T, who may either confirm or deny the validity of the signature to another party B. Under appropriate circumstances, T may also convert ψ into an ordinary signature, which may then be verified by anybody. Additionally, the party A may prove the validity of an opaque signature ψ to a party B, at the time that A creates and gives ψ to B. As described in [CM00], one may implement confirmer signatures as follows: A creates an ordinary signature σ on m, and encrypts σ under T's public key. Using verifiable encryption, A may prove to B that the resulting ciphertext ψ indeed encrypts a valid signature on m, and using verifiable decryption, T may confirm or deny the validity of ψ, or alternatively, just decrypt ψ, thus converting it to the ordinary signature σ. To implement this idea for Schnorr signatures, one again uses the idea outlined in above for reducing signatures to discrete logarithms. The details of all this are the subject of a forthcoming paper.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">1.1.6 Group Signatures and Anonymous Credentials</h4>

    <p class="text-gray-300">In a group signature scheme (see [ACJT00, KP98, CD00]), when a user joined a group (whose membership is controlled by a special party, called the group manager ), the user may sign messages on behalf of the group, without revealing his individual identity; however, under appropriate circumstances, the identity of the individual who actually signed a particular message may be revealed (using a special party, called the anonymity revocation manager, which may be distinct from the group manager).</p>

    <p class="text-gray-300">Without going into too many details, verifiable encryption may be used in the following way as a component in such a system. When a group member signs a message, he encrypts enough information under the public key of the anonymity revocation manager, so that later, if the identity of the signer needs to be revealed, this information can be decrypted. To prove that this information correctly identifies the signer, he makes a Pedersen commitment to this information, proves that the committed value identifies the user, encrypts the opening of the commitment, and proves that the ciphertext decrypts to an opening of the commitment. To turn this into a signature scheme, one must use the Fiat-Shamir heuristic [FS87] to make it non-interactive (the interactive version is called an identity escrow scheme [KP98]).</p>

    <p class="text-gray-300">Although one can implement group signatures without it, by using verifiable encryption, one can build a more modular system, in which the group manager and anonymity manager are separate entities with independently generated public keys (this is the separability issue). Verifiable decryption can be used both to ensure the correct behavior of the anonymity revocation manager (preventing it from &quot;framing&quot; innocent users), and to allow even more fine-grained control of anonymity revocation: instead of simply revealing the identity of a particular signer, the anonymity revocation manager can state (and prove) whether or not a particular signature was generated by a particular user.</p>

    <p class="text-gray-300">Credential systems [Cha85, CL01] are a generalization of group signatures that allow users to show credentials to various organizations, and obtain new credentials, without revealing their identity, except through the use of an anonymity revocation manager. Verifiable encryption can be used as a component in such systems in a manner similar to that described above for group signatures. In fact, our verifiable encryption scheme is used in a prototype credential system developed at IBM called idemix [CL01, CVH02].</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">1.2 Previous Work and Further Discussion</h3>

    <p class="text-gray-300">In all applications mentioned in §1.1, it is essential that the underlying encryption scheme provide security against chosen ciphertext attacks. As pointed out in [ASW00], the earlier work on verifiable encryption in [Sta96, BG96, YY98] overlooked this fact, as does [PS00].</p>

    <p class="text-gray-300">Our encryption scheme and proof protocols are quite efficient. In particular, the proof protocols are conventional &quot;Σ-protocols,&quot; rather than the generally more expensive &quot;cut and choose&quot; protocols, such as those in [Sta96, BG96, YY98, ASW00], that have been previously designed for the problem of verifiable encryption. Moreover, our verifiable encryption scheme actually produces a proof that a given ciphertext is correct, as opposed to the paradigm followed in [Sta96, BG96, YY98, ASW00], which intertwines the process of encrypting and proving, so that the entire transcript of the proof must be retained by the verifier in lieu of a (short) ciphertext. Additionally, the combined encrypting/proving paradigm makes it much harder to incorporate any type of verifiable decryption protocol.</p>

    <p class="text-gray-300">Our verifiable decryption protocols are the first practical schemes of their kind.</p>

    <p class="text-gray-300">Unlike, e.g., the schemes in [Sta96, YY98], we do not require that all users of the system work with the same algebraic group — in our system, there are no &quot;double decker&quot; discrete logarithms, and the encryption keys may be used with any group or groups, provided certain reasonable size restrictions are met.</p>

    <p class="text-gray-300">Our decryption procedure can be implemented as a threshold decryption protocol. This allows one to minimize the trust placed in the decryptor, and in some applications this may be a preferable alternative to verifiable decryption.</p>

    <p class="text-gray-300">Our protocols are based on a number of techniques. The key ingredients that make our verifiable encryption protocol possible are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Fujisaki and Okamoto's method for proving relations on committed values [FO97] (with some refinements, as in [CS00, DF02]),</li>
      <li>the related interval proofs [CM98, CFT98],</li>
      <li>Paillier encryption [Pai99], and</li>
      <li>Cramer and Shoup's universal hash proof encryption technique [CS02].</li>
    </ul>

    <p class="text-gray-300">The additional ingredients needed to make our verifiable decryption protocols work are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Cramer, Damg˚ard, and Schoenmakers' proofs of partial knowledge [CDS94],</li>
      <li>Boudot's exact interval proofs [Bou00], and</li>
      <li>new protocols for proving the inequality of discrete logarithms.</li>
    </ul>

    <p class="text-gray-300">To give the reader a rough idea of the complexity of of our protocols, consider a setting in which the discrete logarithms being encrypted are with respect to an element of order ρ, where ρ is, say, around <code>&lt;sup&gt;0&lt;/sup&gt; ≈ 160 bits. For such a ρ, it suffices to work with a modulus n of around</code> ≈ 1024 bits for the Paillier encryption scheme. Counting just squarings, which are all that matter asymptotically, and ignoring lower order terms, the encryption algorithm takes 3<code> squarings mod n 2 , and the decryption algorithm takes 5</code> squarings mod n 2 . For the verifiable encryption protocol, the prover performs 2<code> squarings mod n, 3</code> squarings mod n 2 , and <code> 0 squarings in the underlying group; the verifier performs 3</code> squarings mod n 2 , <code>squarings mod n, and</code> 0 squarings in the group. The verifiable decryption protocols are about 5 to 6 times slower than this. For representations</p>

    <p class="text-gray-300">with respect to several bases, the complexity of the encryption and decryption algorithms, and the corresponding proof protocols, grows linearly in the number of bases, as one would expect.</p>

    <p class="text-gray-300">Let a be a real number. We denote by bac the largest integer b ≤ a, by dae the smallest integer b ≥ a, and by dac the largest integer b ≤ a + 1/2. For positive real numbers a and b, let [a] denote the set {0, . . . , bac − 1} and [a, b] denote the set {bac, . . . , bbc} and [−a, b] denote the set {−bac, . . . , bbc}.</p>

    <p class="text-gray-300">Let a, b, and c be integers, with b &gt; 0. Most of the time, we use least non-negative remainders, i.e., c = a mod b is a − ba/bcb and we have 0 ≤ c &lt; b. Sometimes, we have to compute balanced remainders, i.e., c = a rem b is a − da/bcb and we have −b/2 ≤ c &lt; b/2. Moreover, if b is odd, then −(b − 1)/2 ≤ a rem b ≤ (b − 1)/2 for all a.</p>

    <p class="text-gray-300">By neg(λ) we denote a negligible function, i.e., a function f such that f(λ) &lt; 1/p(λ) holds for all polynomials p(λ) and all sufficiently large λ.</p>

    <p class="text-gray-300">Let (P, V ) be a pair of interactive Turing machines. By V (x)P(y) we denote the output of V upon interacting with P, where V 's input is x and P's input is y.</p>

    <p class="text-gray-300">We use notation introduced by Camenisch and Stadler [CS97] for the various zero-knowledge proofs of knowledge of discrete logarithms and proofs of the validity of statements about discrete logarithms. For instance,</p>

    <p class="text-gray-300"><span class="math">$PK\\{(a,b,c): y=g^ah^b \\land \\mathfrak{h}=\\mathfrak{g}^a\\mathfrak{h}^c \\land (u \\leq a \\leq v)\\}</span>$</p>

    <p class="text-gray-300">denotes a &quot;zero-knowledge Proof of Knowledge of integers a, b, and g such that y = g ah &lt;sup&gt;b&lt;/sup&gt; and y = g ah &lt;sup&gt;c&lt;/sup&gt; holds, where v &lt; a &lt; u,&quot; where y, g, h, y, g, and h are elements of some groups G = hgi = hhi and G = hgi = hhi. The convention is that the elements listed in the round brackets denote quantities the knowledge of which is being proved (and are in general not known to the verifier), while all other parameters are known to the verifier. Using this notation, a proof-protocol can be described by just pointing out its aim while hiding all details.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">2.2 Special Honest-Verifier Zero-Knowledge Protocols</h3>

    <p class="text-gray-300">A special honest-verifier zero-knowledge protocol is a protocol between a prover and a verifier, where y is their common input and x is the prover's additional input. The protocol is restricted to three moves: in the first move the prover sends the verifier a &quot;commitment&quot; message t, in the second move the verifier sends the prover a &quot;challenge&quot; message c, and in the third move the prover sends the verifier a &quot;response&quot; message s. Finally, there must exist a simulator that, on input y and any &quot;challenge&quot; message ˜c, outputs a &quot;commitment&quot; and &quot;response&quot; messages t˜and ˜s such that the distribution of the triple (t,˜ c, ˜ s˜) is (statistically) indistinguishable from the one of triples (t, c, s) stemming from real conversations of the prover and the verifier for which c = ˜c. Note that the existence of such a simulator implies that the protocol is (ordinary) honest-verifier zero-knowledge.</p>

    <p class="text-gray-300">For particular types of proof systems, we shall give explicit, detailed definitions of special honest-verifier zero knowledge, as appropriate.</p>

    <p class="text-gray-300">While this notion of zero-knowledge is not sufficient for most applications, there exist a number of generic constructions to turn a special honest-verifier zero-knowledge protocol into one that</p>

    <p class="text-gray-300">satisfies stronger notions of zero-knowledge. The most important examples are probably the constructions to obtain concurrent zero-knowledge protocols [Dam00, DNS98, CGGM00] or witnesshiding protocols [CDS94]. In particular, the construction due to Damg˚ard achieves (concurrent) zero-knowledge virtually for free [Dam00].</p>

    <p class="text-gray-300">Here, we recall the notion of a public-key encryption scheme. Actually, we need the notion of a public-key encryption scheme that supports labels. A label is an arbitrary bit string that is input to the encryption and decryption algorithms, specifying the &quot;context&quot; in which the encryption or decryption operation is to take place.</p>

    <p class="text-gray-300">A public key encryption scheme provides three algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>a probabilistic, polynomial-time key generation algorithm G that on input 1&lt;sup&gt;λ&lt;/sup&gt; where λ ≥ 0 is a security parameter — outputs a public-key/private-key pair (PK, SK). A public key PK specifies a finite, easy-to-recognize message space MPK.</li>
      <li>a probabilistic, polynomial-time encryption algorithm E that takes as input a public key PK, a message m ∈ MPK, and a label L, and outputs a ciphertext ψ.</li>
      <li>a deterministic, polynomial-time decryption algorithm D that takes as input a private key SK, a ciphertext ψ, a label L, and outputs either a message m ∈ MPK, where PK is the public-key corresponding to SK, or a special symbol reject.</li>
    </ul>

    <p class="text-gray-300">Any public-key encryption scheme should satisfy a &quot;correctness&quot; or &quot;soundness&quot; property, which loosely speaking means that the decryption operation &quot;undoes&quot; the encryption operation. For our purposes, we can formulate this as follows. We call a public-key encryption scheme sound if for all (PK, SK) ∈ G(1&lt;sup&gt;λ&lt;/sup&gt; ), for all m ∈ MPK, for all L ∈ {0, 1} ∗ , and for all ψ ∈ E(PK, m, L), we have D(SK, ψ, L) = m.</p>

    <p class="text-gray-300">This definition can easily be relaxed to allow for an incorrect decryption with negligible probability, but we do not pursue this matter here. For all encryption schemes presented in this paper, it is trivial to verify this soundness property, and so we will not explicitly deal with this issue again.</p>

    <p class="text-gray-300">We say that a ciphertext is valid w.r.t. a label L (and a key pair (PK, SK)) if the decryption algorithm does not reject it and is invalid w.r.t. L otherwise.</p>

    <p class="text-gray-300">Note that in this paper, we only work with finite message spaces.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">2.4 Adaptive Chosen Ciphertext Security</h3>

    <p class="text-gray-300">Consider a public-key encryption scheme, and consider the following game, played against an arbitrary probabilistic, polynomial-time adversary.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Key-Generation Phase. Let λ ≥ 0 be the security parameter. We run the key-generation algorithm of the public-key encryption scheme on input 1&lt;sup&gt;λ&lt;/sup&gt; , and get a key pair (PK, SK). We equip an encryption oracle with the public key PK, and a decryption oracle with the secret key SK. The public key PK is presented to the adversary.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Probing Phase I. In this phase, the attacker gets to interact with the decryption oracle in an arbitrary, adaptive fashion. This phase goes on for a polynomial amount of time, specified by the adversary. More precisely, in each round of this interaction, the adversary sends a query (ψ, L) to the decryption oracle. A query is a pair of bit strings chosen in an arbitrary way by</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">the adversary. The decryption oracle in turn decrypts  <span class="math">\\psi</span>  with label L under the secret key SK, and responds to the query by returning the decryption to the adversary.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Target-Selection Phase. The adversary selects two messages  <span class="math">m_0</span>  and  <span class="math">m_1</span>  from the message space, along with a label  <span class="math">L^*</span> , and presents  <span class="math">(m_0, m_1, L^*)</span>  to the encryption oracle. The encryption oracle selects a random  <span class="math">\\sigma \\in \\{0, 1\\}</span> , and encrypts  <span class="math">m_{\\sigma}</span>  with label  <span class="math">L^*</span>  under PK. The resulting encryption  <span class="math">\\psi^*</span> , the target ciphertext, is presented to the adversary.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Probing Phase II. This phase is as Probing Phase I, the only difference being that the decryption oracle only responds to queries  <span class="math">(\\psi, L)</span>  with  <span class="math">(\\psi, L) \\neq (\\psi^*, L^*)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Guessing-Phase. The adversary outputs a bit  <span class="math">\\hat{\\sigma}</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">The adversary is said to win the game if  <span class="math">\\hat{\\sigma} = \\sigma</span> . We define the advantage (over random guessing) of the adversary as the absolute value of the difference of the probability that he wins and 1/2.</p>

    <p class="text-gray-300">A public-key encryption scheme is said to be secure against adaptive chosen ciphertext attack if for all polynomial time, probabilistic adversaries, the advantage in this guessing game is negligible as a function of the security parameter.</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">3.1 Background</h4>

    <p class="text-gray-300">Let p, q, p', q' be distinct odd primes with p = 2p' + 1 and q = 2q' + 1, and where p' and q' are both  <span class="math">\\ell</span>  bits in length. Let n = pq and n' = p'q'. Consider the group  <span class="math">\\mathbb{Z}_{n^2}^*</span>  and the subgroup  <span class="math">\\mathbf{P}</span>  of  <span class="math">\\mathbb{Z}_{n^2}^*</span>  consisting of all n-th powers of elements in  <span class="math">\\mathbb{Z}_{n^2}^*</span> .</p>

    <p class="text-gray-300">Paillier's Decision Composite Residuosity (DCR) assumption [Pai99] is that given only n, it is hard to distinguish random elements of  <span class="math">\\mathbb{Z}_{n^2}^*</span>  from random elements of  <span class="math">\\mathbb{P}</span> .</p>

    <p class="text-gray-300">To be completely formal, one should specify a sequence of bit lengths  <span class="math">\\ell(\\lambda)</span> , parameterized by a security parameter  <span class="math">\\lambda \\geq 0</span> , and to generate an instance of the problem for security parameter  <span class="math">\\lambda</span> , the primes p' and q' should be distinct, random primes of length  <span class="math">\\ell = \\ell(\\lambda)</span> , such that p = 2p' + 1 and q = 2q' + 1 are also primes.</p>

    <p class="text-gray-300">The primes p' and q' are called Sophie Germain primes and the primes p and q are called safe primes. It has never been proven that there are infinitely many Sophie Germain primes. Nevertheless, it is widely conjectured, and amply supported by empirical evidence, that the probability that a random  <span class="math">\\ell</span> -bit number is Sophie Germain prime is  <span class="math">\\Omega(1/\\ell^2)</span> . We shall assume that this conjecture holds, so that we can assume that problem instances can be efficiently generated.</p>

    <p class="text-gray-300">Note that Paillier did not make the restriction to safe primes in originally formulating the DCR assumption. As will become evident, we need to restrict ourselves to safe primes for technical reasons. However, it is easy to see that the DCR assumption without this restriction implies the DCR assumption with this restriction, assuming that safe primes are sufficiently dense, as we are here.</p>

    <p class="text-gray-300">We can decompose  <span class="math">\\mathbb{Z}_{n^2}^*</span>  as an internal direct product</p>

    <p class="text-gray-300"><span class="math">$\\mathbb{Z}_{n^2}^* = \\mathbf{G}_n \\cdot \\mathbf{G}_{n&#x27;} \\cdot \\mathbf{G}_2 \\cdot \\mathbf{T},</span>$</p>

    <p class="text-gray-300">where each group  <span class="math">\\mathbf{G}_{\\tau}</span>  is a cyclic group of order  <span class="math">\\tau</span> , and  <span class="math">\\mathbf{T}</span>  is the subgroup of  <span class="math">\\mathbb{Z}_{n^2}^*</span>  generated by  <span class="math">(-1 \\bmod n^2)</span> . This decomposition is unique, except for the choice of  <span class="math">\\mathbf{G}_2</span>  (there are two possible</p>

    <p class="text-gray-300">choices). For any  <span class="math">x \\in \\mathbb{Z}_{n^2}^*</span> , we can express x uniquely as  <span class="math">x = x(\\mathbf{G}_n)x(\\mathbf{G}_{n&#x27;})x(\\mathbf{G}_2)x(\\mathbf{T})</span> , where for each  <span class="math">\\mathbf{G}_{\\tau}</span> ,  <span class="math">x(\\mathbf{G}_{\\tau}) \\in \\mathbf{G}_{\\tau}</span> , and  <span class="math">x(\\mathbf{T}) \\in \\mathbf{T}</span> .</p>

    <p class="text-gray-300">Note that the element  <span class="math">h = (1 + n \\mod n^2) \\in \\mathbb{Z}_{n^2}^*</span>  has order n, i.e., it generates  <span class="math">\\mathbf{G}_n</span> , and that  <span class="math">h^a = (1 + an \\mod n^2)</span>  for  <span class="math">0 \\le a &lt; n</span> . Observe that  <span class="math">\\mathbf{P} = \\mathbf{G}_{n&#x27;}\\mathbf{G}_2\\mathbf{T}</span> .</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">3.2 The Scheme</h4>

    <p class="text-gray-300">For a security parameter  <span class="math">\\lambda \\geq 0</span> ,  <span class="math">\\ell = \\ell(\\lambda)</span>  is an auxiliary parameter.</p>

    <p class="text-gray-300">The scheme makes use of a keyed hash scheme  <span class="math">\\mathcal{H}</span>  that uses a key hk, chosen at random from an appropriate key space associated with the security parameter  <span class="math">\\lambda</span> ; the resulting hash function  <span class="math">\\mathcal{H}_{hk}(\\cdot)</span>  maps a triple (u, e, L) to a number in the set  <span class="math">[2^{\\ell}]</span> . We shall assume that  <span class="math">\\mathcal{H}</span>  is collision resistant, i.e., given a randomly chosen hash key hk, it is computationally infeasible to find two triples  <span class="math">(u, e, L) \\neq (u&#x27;, e&#x27;, L&#x27;)</span>  such that  <span class="math">\\mathcal{H}_{hk}(u, e, L) = \\mathcal{H}_{hk}(u&#x27;, e&#x27;, L&#x27;)</span> .</p>

    <p class="text-gray-300">Let abs:  <span class="math">\\mathbb{Z}_{n^2}^* \\to \\mathbb{Z}_{n^2}^*</span>  map  <span class="math">(a \\mod n^2)</span> , where  <span class="math">0 &lt; a &lt; n^2</span> , to  <span class="math">(n^2 - a \\mod n^2)</span>  if  <span class="math">a &gt; n^2/2</span> , and to  <span class="math">(a \\mod n^2)</span> , otherwise. Note that  <span class="math">v^2 = (abs(v))^2</span>  holds for all  <span class="math">v \\in \\mathbb{Z}_{n^2}^*</span> .</p>

    <p class="text-gray-300">We now describe the key generation, encryption, and decryption algorithms of the encryption scheme, as they behave for a given value of the security parameter  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300"><strong>Key Generation.</strong> Select two random  <span class="math">\\ell</span> -bit Sophie Germain primes p' and q', with  <span class="math">p&#x27; \\neq q&#x27;</span> , and compute p := (2p'+1), q := (2q'+1), n := pq, and n' := p'q', where  <span class="math">\\ell = \\ell(\\lambda)</span>  is an auxiliary security parameter. Choose random  <span class="math">x_1, x_2, x_3 \\in_R [n^2/4]</span> , choose a random  <span class="math">g&#x27; \\in_R \\mathbb{Z}_{n^2}^*</span> , and compute  <span class="math">g := (g&#x27;)^{2n}, y_1 := g^{x_1}, y_2 := g^{x_2}</span> , and  <span class="math">y_3 := g^{x_3}</span> . Also, generate a hash key hk from the key space of the hash scheme  <span class="math">\\mathcal{H}</span>  associated with the security parameter  <span class="math">\\lambda</span> . The public key is  <span class="math">(hk, n, g, y_1, y_2, y_3)</span> . The secret key is  <span class="math">(hk, n, x_1, x_2, x_3)</span> .</p>

    <p class="text-gray-300">In the rest of the paper, let  <span class="math">h = (1 + n \\mod n^2) \\in \\mathbb{Z}_{n^2}^*</span> , which as discussed above, is an element of order n.</p>

    <p class="text-gray-300"><strong>Encryption.</strong> To encrypt a message  <span class="math">m \\in [n]</span>  with label  <span class="math">L \\in \\{0,1\\}^*</span>  under a public key as above, choose a random  <span class="math">r \\in_R [n/4]</span>  and compute</p>

    <p class="text-gray-300"><span class="math">$u := g^r</span>$
,  <span class="math">e := y_1^r h^m</span> , and  <span class="math">v := \\operatorname{abs}\\left((y_2 y_3^{\\mathcal{H}_{hk}(u,e,L)})^r\\right)</span> .</p>

    <p class="text-gray-300">The ciphertext is (u, e, v).</p>

    <p class="text-gray-300"><strong>Decryption.</strong> To decrypt a ciphertext  <span class="math">(u, e, v) \\in \\mathbb{Z}_{n^2}^* \\times \\mathbb{Z}_{n^2}^* \\times \\mathbb{Z}_{n^2}^*</span>  with label L under a secret key as above, first check that abs(v) = v and  <span class="math">u^{2(x_2 + \\mathcal{H}_{hk}(u, e, L)x_3)} = v^2</span> . If this does not hold, then output reject and halt. Next, let  <span class="math">t = 2^{-1} \\mod n</span> , and compute  <span class="math">\\hat{m} := (e/u^{x_1})^{2t}</span> . If  <span class="math">\\hat{m}</span>  is of the form  <span class="math">h^m</span>  for some  <span class="math">m \\in [n]</span> , then output m; otherwise, output reject.</p>

    <p class="text-gray-300">This scheme differs from the DCR-based schemes presented in [CS02], because in our situation, special attention must be paid to the treatment of elements of order 2 in the  <span class="math">\\mathbb{Z}_{n^2}^*</span> , as these can cause some trouble for the proof systems we discuss in the next sections. Because of these differences, the above encryption scheme does not exactly fit into the general framework of [CS02], even though the basic ideas are the same. We therefore analyze the security of the scheme starting from first principles, rather than trying to modify their framework.</p>

    <p class="text-gray-300">Before presenting the security analysis, we remark on one of the more peculiar aspects of the scheme, namely, the role of the  <span class="math">abs(\\cdot)</span>  function in the encryption and decryption algorithms. If one left this out, i.e., replaced  <span class="math">abs(\\cdot)</span>  by the identity function, then the scheme would be malleable, as</p>

    <p class="text-gray-300">(u, e, v) is an encryption of some message m with label L, then so is (u, e, -v). This particular type of malleability [ADR02, Sho01] is in fact rather &quot;benign,&quot; and would be acceptable in most applications. However, we prefer to achieve non-malleability in the strictest sense, and because this comes at a marginal cost, we do so. We also mention that in independent work, Gennaro and Lindell [GL03] devise a similar (but not quite identical) scheme, but for completely different purposes: their goal is to construct efficient password-based key exchange protocols.</p>

    <p class="text-gray-300"><strong>Theorem 1.</strong> The above scheme is secure against adaptive chosen ciphertext attack provided the DCR assumption holds, and provided  <span class="math">\\mathcal{H}</span>  is collision resistant.</p>

    <p class="text-gray-300">The rest of this section is devoted to the proof of Theorem 1.</p>

    <p class="text-gray-300">Let us fix a value of the security parameter  <span class="math">\\lambda</span> , which fixes  <span class="math">\\ell = \\ell(\\lambda)</span> , and let us fix an adversary A. Let  <span class="math">\\psi^* = (u^*, e^*, v^*)</span>  denote the target ciphertext, and  <span class="math">L^*</span>  the associated label.</p>

    <p class="text-gray-300">We prove this theorem by analyzing a sequence of modifications to the environment in which the adversary runs. We refer to the attack game run with the original environment as Game 0 (c.f. §2.4), and to the attack game run with subsequent modifications to the environment as Games 1, 2, etc. Each of these games are best viewed as operating on the same underlying probability space. The value of the random variable  <span class="math">\\sigma</span>  is identical in each game, but the output  <span class="math">\\hat{\\sigma}</span>  of the adversary may vary among games. We define the event  <span class="math">T_i</span> , for  <span class="math">i \\geq 0</span> , as the event that the  <span class="math">\\sigma = \\hat{\\sigma}</span>  in Game i.</p>

    <p class="text-gray-300"><strong>Game 1.</strong> This is the same as Game 0, except for the following modification to the decryption oracle. If the decryption oracle is invoked in Probing Phase II with a ciphertext/label pair ((u, e, v), L) such that  <span class="math">(u, e, L) \\neq (u^*, e^*, L^*)</span>  but  <span class="math">\\mathcal{H}_{hk}(u, e, L) = \\mathcal{H}_{hk}(u^*, e^*, L^*)</span> , then the decryption oracle rejects the ciphertext.</p>

    <p class="text-gray-300">Let  <span class="math">F_1</span>  be the event that a ciphertext is rejected in Game 1 using the above rejection rule. It is clear that Games 0 and 1 proceed identically until  <span class="math">F_1</span>  occurs; more precisely, the events  <span class="math">T_1 \\wedge \\neg F_1</span>  and  <span class="math">T_0 \\wedge \\neg F_1</span>  are identical. Therefore,</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[T_1] - \\Pr[T_0]| \\le \\Pr[F_1]. \\tag{1}</span>$</p>

    <p class="text-gray-300">Moreover, we have</p>

    <p class="text-gray-300"><span class="math">$\\Pr[F_1] \\le \\mathsf{AdvCRHF}_{A&#x27;}(\\lambda),\\tag{2}</span>$</p>

    <p class="text-gray-300">where  <span class="math">AdvCRHF_{A&#x27;}(\\lambda)</span>  denotes the success probability that a particular adversary A' has in finding a collision in  <span class="math">\\mathcal{H}</span>  for the given value of the security parameter  <span class="math">\\lambda</span> . The running time of A' is about the same as that of A. Indeed, given a hash key hk, adversary A' simply runs Game 1, using the given value of hk in the key generation algorithm, and when  <span class="math">F_1</span>  occurs, A' outputs (u, e, L) and  <span class="math">(u^*, e^*, L^*)</span> .</p>

    <p class="text-gray-300"><strong>Game 2.</strong> This game is the same as Game 1, except for the following modification to the decryption oracle. If the decryption oracle is invoked in Probing Phase II with a ciphertext (u, e, v) such that  <span class="math">v^2 = (v^*)^2</span>  and  <span class="math">v \\neq v^*</span> , then the decryption oracle rejects the ciphertext.</p>

    <p class="text-gray-300">Let  <span class="math">F_2</span>  be the event that a ciphertext is rejected in Game 2 using the above rejection rule, but would not have been rejected for any other reason. It is clear that Games 1 and 2 proceed identically until  <span class="math">F_2</span>  occurs; more precisely, the events  <span class="math">T_2 \\wedge \\neg F_2</span>  and  <span class="math">T_1 \\wedge \\neg F_2</span>  are identical. Therefore,</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[T_2] - \\Pr[T_1]| \\le \\Pr[F_2]. \\tag{3}</span>$</p>

    <p class="text-gray-300">Moreover, we have</p>

    <p class="text-gray-300"><span class="math">$\\Pr[F_2] \\le \\mathsf{AdvFactor}_{A&#x27;&#x27;}(\\lambda),\\tag{4}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\mathsf{AdvFactor}_{A&#x27;&#x27;}(\\lambda)</span>  denotes the success probability that a particular algorithm A'' has in factoring a number n as generated by the encryption algorithm for the given value of the security parameter  <span class="math">\\lambda</span> . The running time of A'' is about the same as that of A. Algorithm A'' takes the given number n, constructs the remaining components of the public key, and then lets adversary A run in Game 2. If and when event  <span class="math">F_2</span>  occurs, we have  <span class="math">v^2 = (v^*)^2</span> ,  <span class="math">v \\neq v^*</span> , abs(v) = v, and  <span class="math">abs(v^*) = v^*</span> . This implies that  <span class="math">v \\neq \\pm v^*</span> . It follows that if  <span class="math">v/v^* = (a \\mod n^2)</span> , then  <span class="math">\\gcd(a, n)</span>  splits n.</p>

    <p class="text-gray-300"><strong>Game 3.</strong> This game is the same as Game 2, except for the following modification to the encryption oracle. Instead of computing  <span class="math">e^*</span>  and  <span class="math">v^*</span>  as in the encryption algorithm, we compute them using the secret key, as follows:</p>

    <p class="text-gray-300"><span class="math">$e^* := (u^*)^{x_1} h^{m_{\\sigma}}</span>$</p>

    <p class="text-gray-300"><span class="math">v^* := \\operatorname{abs} \\left( (u^*)^{x_2 + \\mathcal{H}_{hk}(u^*, e^*, L^*)x_3} \\right)</span></p>

    <p class="text-gray-300">This modification is purely conceptual, as the values of  <span class="math">e^*</span>  and  <span class="math">v^*</span>  computed by the encryption oracle in Game 3 are identical to those computed in Game 2. Therefore,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[T_3] = \\Pr[T_2]. \\tag{5}</span>$</p>

    <p class="text-gray-300"><strong>Game</strong> 4. Now we further modify the encryption oracle. Let  <span class="math">r^*</span>  denote the value of r generated by the encryption oracle. Then, instead of computing  <span class="math">u^*</span>  as  <span class="math">g^{r^*}</span> , the encryption oracle in this game chooses a random  <span class="math">\\bar{u} \\in \\mathbf{P}</span> , and sets  <span class="math">u^* := \\bar{u}^2</span> .</p>

    <p class="text-gray-300">We claim that</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[T_4] - \\Pr[T_3]| = O(2^{-\\ell}).</span>$
(6)</p>

    <p class="text-gray-300">To see this, observe that  <span class="math">\\bar{u}^2</span>  is uniformly distributed over  <span class="math">\\mathbf{G}_{n&#x27;}</span> . Also, observe that with probability  <span class="math">1 - O(2^{-\\ell})</span> , g is a generator for  <span class="math">\\mathbf{G}_{n&#x27;}</span> , and that the distribution of  <span class="math">r^*</span>  is  <span class="math">O(2^{-\\ell})</span> -close to the uniform distribution on [n']. It is an easy exercise to show that the bound (6) follows from these observations.</p>

    <p class="text-gray-300"><strong>Game 5.</strong> We again modify the encryption oracle. Instead of choosing  <span class="math">\\bar{u}</span>  at random from  <span class="math">\\mathbf{P}</span> , the encryption oracle chooses  <span class="math">\\bar{u}</span>  at random from  <span class="math">\\mathbb{Z}_{n^2}^*</span> ; otherwise, the computation is identical to that of Game 4.</p>

    <p class="text-gray-300">It is clear that any significant difference between  <span class="math">\\Pr[T_5]</span>  and  <span class="math">\\Pr[T_4]</span>  leads immediately to an effective statistical test for distinguishing <strong>P</strong> from  <span class="math">\\mathbb{Z}_{n^2}^*</span> . More precisely, there exists an adversary A''', whose running time is roughly the same as that of A, such that</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[T_5] - \\Pr[T_4]| \\le \\mathsf{AdvDCR}_{A&#x27;&#x27;&#x27;}(\\lambda),\\tag{7}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\mathsf{AdvDCR}_{A&#x27;&#x27;&#x27;}(\\lambda)</span>  denotes the advantage that A''' has in distinguishing  <span class="math">\\mathbf{P}</span>  from  <span class="math">\\mathbb{Z}_{n^2}^*</span>  for the given value of the security parameter  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300"><strong>Game 6.</strong> We again modify the encryption oracle. This time, we replace  <span class="math">u^*</span>  by a random element of  <span class="math">\\mathbf{G}_n\\mathbf{G}_{n&#x27;}</span>  such that  <span class="math">u^*(\\mathbf{G}_n)</span>  has order n.</p>

    <p class="text-gray-300">We claim that</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[T_6] - \\Pr[T_5]| = O(2^{-\\ell}).</span>$
(8)</p>

    <p class="text-gray-300">To see this, note that in Game 5,  <span class="math">u^*</span>  is uniformly distributed over  <span class="math">\\mathbf{G}_n\\mathbf{G}_{n&#x27;}</span> , and so  <span class="math">u^*(\\mathbf{G}_n)</span>  has order n with probability  <span class="math">1 - O(2^{-\\ell})</span> . The bound (8) follows immediately.</p>

    <p class="text-gray-300"><strong>Game 7.</strong> Now we modify the key generation algorithm. Instead of choosing  <span class="math">x_1, x_2, x_3</span>  at random from  <span class="math">\\lfloor n^2/4 \\rfloor</span> , we choose them at random from  <span class="math">\\lfloor nn&#x27; \\rfloor</span> .</p>

    <p class="text-gray-300">Because the uniform distribution on  <span class="math">[n^2/4]</span>  is  <span class="math">O(2^{-\\ell})</span> -close to the uniform distribution on [nn'], it follows immediately that</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[T_7] - \\Pr[T_6]| = O(2^{-\\ell}).</span>$
(9)</p>

    <p class="text-gray-300"><strong>Game</strong> 8. Now we modify the decryption oracle. In this game, in addition to rejecting a ciphertext  <span class="math">(u, e, v) \\in \\mathbb{Z}_{n^2}^* \\times \\mathbb{Z}_{n^2}^* \\times \\mathbb{Z}_{n^2}^*</span>  with label L if  <span class="math">u^{2(x_2 + \\mathcal{H}_{hk}(u, e, L)x_3)} \\neq v^2</span> , the decryption oracle also rejects this ciphertext if  <span class="math">u \\notin \\mathbf{G}_{n&#x27;}\\mathbf{G}_2\\mathbf{T}</span> .</p>

    <p class="text-gray-300">In this game, the decryption oracle leaks no information about the value of  <span class="math">x_1</span>  modulo n. ¿From this, and the fact that  <span class="math">u^*(\\mathbf{G}_n)</span>  has order n and  <span class="math">e^* = (u^*)^{x_1} h^{m_{\\sigma}}</span> , it follows that A's output  <span class="math">\\hat{\\sigma}</span>  is independent of  <span class="math">\\sigma</span> . Therefore,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[T_8] = 1/2.</span>$
(10)</p>

    <p class="text-gray-300">Let  <span class="math">F_8</span>  be the event that in Game 8, some ciphertext (u, e, v) with label L is rejected using the special rejection rule introduced in Game 8, but would not have been rejected for any other reason, i.e., the special rejection rules introduced in Games 1 and 2 do not apply, and  <span class="math">u^{2(x_2+\\mathcal{H}_{hk}(u,e,L)x_3)} = v^2</span> .</p>

    <p class="text-gray-300">It is clear that Games 7 and 8 proceed identically until  <span class="math">F_8</span>  occurs. More precisely, the events  <span class="math">T_8 \\wedge \\neg F_8</span>  and  <span class="math">T_7 \\wedge \\neg F_8</span>  are identical. Therefore,</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[T_8] - \\Pr[T_7]| \\le \\Pr[F_8]. \\tag{11}</span>$</p>

    <p class="text-gray-300">Let  <span class="math">\\kappa = \\kappa(\\lambda)</span>  denote an upper bound on the number of decryption oracle queries made by A for the given value of the security parameter  <span class="math">\\lambda</span> . We assume this bound holds, regardless of the environment in which A runs. We claim that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[F_8] \\le \\kappa \\cdot 2^{-\\ell}.\\tag{12}</span>$</p>

    <p class="text-gray-300">To prove (12), we argue as follows. Let  <span class="math">\\bar{x}_2</span>  and  <span class="math">\\bar{x}_3</span>  denote the values of  <span class="math">x_2</span>  and  <span class="math">x_3</span> , respectively, modulo n. Similarly, let  <span class="math">\\bar{x}_2&#x27;</span>  and  <span class="math">\\bar{x}_3&#x27;</span>  denote the values of  <span class="math">x_2</span>  and  <span class="math">x_3</span> , respectively, modulo n'.</p>

    <p class="text-gray-300">Let us condition on fixed values of</p>

    <p class="text-gray-300"><span class="math">$n,g,x_1,\\bar{x}_2&#x27;,\\bar{x}_3&#x27;,\\mathsf{hk},</span>$</p>

    <p class="text-gray-300">as well as fixed values of the coin tosses of A. In this conditional probability space, the public key is fixed, A's queries to the decryption oracle in Probing Phase I, as well as the responses of the decryption oracle. To see why responses of the decryption oracle are fully determined, observe that all ciphertexts (u, e, v) with  <span class="math">u \\notin \\mathbf{G}_{n&#x27;}\\mathbf{G}_2\\mathbf{T}</span>  are rejected, and that the decryption oracle squares u in all computations involving u; thus, the response of the decryption oracle is determined by  <span class="math">\\bar{x}&#x27;_2</span>  and  <span class="math">\\bar{x}&#x27;_3</span> , which are fixed. Also, in this conditional probability space, it is determined whether or not A invokes the encryption oracle, and if so, A's inputs to the encryption oracle. However, by the Chinese Remainder Theorem, the values of  <span class="math">\\bar{x}_2</span>  and  <span class="math">\\bar{x}_3</span>  in this conditional probability space are still uniformly and independently distributed over [n].</p>

    <p class="text-gray-300">In this conditional probability space, consider a particular invocation of the decryption oracle in Probing Phase I with a ciphertext (u, e, v) and label L. Suppose that  <span class="math">u \\notin \\mathbf{G}_{n&#x27;}\\mathbf{G}_2\\mathbf{T}</span> . Let  <span class="math">\\bar{u} = u(\\mathbf{G}&#x27;_n)^2</span> ,  <span class="math">\\bar{u}&#x27; = u(\\mathbf{G}_n)^2</span> , and  <span class="math">H = \\mathcal{H}_{hk}(u, e, L)</span> . Note that  <span class="math">\\bar{u} \\neq 1</span> , and so  <span class="math">\\bar{u}</span>  has order p, q, or n. Now, we have</p>

    <p class="text-gray-300"><span class="math">$u^{2(x_2 + \\mathcal{H}_{hk}(u, e, L)x_3)} = (\\bar{u})^{\\bar{x}_2 + H\\bar{x}_3} (\\bar{u}&#x27;)^{\\bar{x}&#x27;_2 + H\\bar{x}&#x27;_3}.</span>$</p>

    <p class="text-gray-300">It follows that  <span class="math">u^{2(x_2+\\mathcal{H}_{hk}(u,e,L)x_3)}</span>  is uniformly distributed over a particular coset in  <span class="math">\\mathbf{G}_{n&#x27;}\\mathbf{G}_n</span>  of the subgroup generated by  <span class="math">\\bar{u}</span> . As  <span class="math">v^2</span>  is fixed in this conditional probability space, it follows that  <span class="math">u^{2(x_2+\\mathcal{H}_{hk}(u,e,L)x_3)} = v^2</span>  with probability at most  <span class="math">2^{-\\ell}</span> .</p>

    <p class="text-gray-300">Now suppose that in this conditional probability space A invokes the encryption oracle with particular messages  <span class="math">m_0</span>  and  <span class="math">m_1</span> , and a label  <span class="math">L^*</span> . Let us further condition on fixed values of  <span class="math">\\sigma</span>  and  <span class="math">u^*</span> . This determines the value of  <span class="math">e^*</span> , and also the value of  <span class="math">H^* = \\mathcal{H}_{hk}(u^*, e^*, L^*)</span> . Let us also further condition a fixed value of  <span class="math">\\bar{x}_2 + H^*\\bar{x}_3</span>  modulo n. This determines the value  <span class="math">v^*</span> . In the resulting conditional probability space, the output of the encryption oracle, as well as all queries and responses of decryption oracle queries in Probing Phase II are completely determined.</p>

    <p class="text-gray-300">In this conditional probability space, consider a particular invocation of the decryption oracle in Probing Phase II with a ciphertext (u, e, v) and label L, such that  <span class="math">(u, e, v, L) \\neq (u^*, e^*, v^*, L)</span> . Suppose that  <span class="math">u \\notin \\mathbf{G}_{n&#x27;}\\mathbf{G}_2\\mathbf{T}</span> , and that the special rejection rules introduced in Games 1 and 2 do not apply. We consider two cases.</p>

    <p class="text-gray-300">Case 1:  <span class="math">(u, e, L) = (u^*, e^*, L^*)</span> . We must have  <span class="math">v \\neq v^*</span> , as  <span class="math">(u, e, v, L) \\neq (u^*, e^*, v^*, L)</span> . Because the special rejection rule in Game 2 does not apply, we must have  <span class="math">v^2 \\neq (v^*)^2</span> , which implies that  <span class="math">u^{2(x_2 + \\mathcal{H}_{hk}(u, e, L)x_3)} \\neq v^2</span> .</p>

    <p class="text-gray-300">Case 2:  <span class="math">(u, e, L) \\neq (u^*, e^*, L^*)</span> . As the special rejection rule in Game 1 does not apply, we must have  <span class="math">H \\neq H^*</span> . By the definition of  <span class="math">\\mathcal{H}</span> , this implies that  <span class="math">H \\not\\equiv H^* \\pmod{p}</span>  and  <span class="math">H \\not\\equiv H^* \\pmod{q}</span> . This in turn implies that in this conditional probability space, the distribution of  <span class="math">\\bar{x}_2 + H\\bar{x}_3</span>  modulo n is uniform. It follows that  <span class="math">u^{2(x_2 + \\mathcal{H}_{hk}(u, e, L)x_3)}</span>  is uniformly distributed over a particular coset in  <span class="math">\\mathbf{G}_{n&#x27;}\\mathbf{G}_n</span>  of the subgroup generated by  <span class="math">\\bar{u}</span> . Because  <span class="math">v^2</span>  is fixed in this conditional probability space, it follows that  <span class="math">u^{2(x_2 + \\mathcal{H}_{hk}(u, e, L)x_3)} = v^2</span>  with probability at most  <span class="math">2^{-\\ell}</span> .</p>

    <p class="text-gray-300">The above arguments show that the event  <span class="math">F_8</span>  occurs for a particular decryption query with probability at most  <span class="math">2^{-\\ell}</span> . The bound (12) now follows.</p>

    <p class="text-gray-300">Putting together (1)-(12), we have</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[T_0] - 1/2| \\leq \\mathsf{AdvCRHF}_{A&#x27;}(\\lambda) + \\mathsf{AdvFactor}_{A&#x27;&#x27;}(\\lambda) + \\mathsf{AdvDCR}_{A&#x27;&#x27;&#x27;}(\\lambda) + \\kappa \\cdot 2^{-\\ell} + O(2^{-\\ell}).</span>$</p>

    <p class="text-gray-300">Theorem 1 now follows immediately.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">3.3 Extensions to Threshold Decryption</h4>

    <p class="text-gray-300">Our scheme can easily be transformed to provide threshold decryption, where it comes in handy that the knowledge of the factorization of n is not required for decryption. This allows one to reduce the trust assumption for the decryptor when used as a trusted third party. This can be done either along the lines in [SG98], which requires a random oracle security argument, or along the lines in [CG99], which does not require that argument, but for which the decryption protocol is less efficient.</p>

    <p class="text-gray-300">This strong RSA assumption is the following: given a composite modulus n and a random element  <span class="math">g \\in \\mathbb{Z}_n^*</span> , it is hard to compute  <span class="math">h \\in \\mathbb{Z}_n^*</span>  and integer e &gt; 1 such that  <span class="math">h^e = g</span> . To be complete, one needs to specify more precisely the distribution from which n is drawn. As in §3, we shall specify that n is of the form pq, where p = 2p' + 1, q = 2q' + 1, and p' and q' are uniformly distributed over all  <span class="math">\\ell</span> -bit numbers such that p, q, p', q' are prime and  <span class="math">p&#x27; \\neq q&#x27;</span> . We also set n' = p'q'. As usual,  <span class="math">\\ell = \\ell(\\lambda)</span> , where  <span class="math">\\lambda</span>  is a security parameter.</p>

    <p class="text-gray-300">We will make use of both the strong RSA assumption, as well as the assumption that factoring integers n as above is hard. Of course, the strong RSA assumption implies that factoring is hard.</p>

    <p class="text-gray-300">We will make use of these two assumptions as follows. First, we shall make extensive use of the well known fact that if factoring is hard, then it is hard to compute a non-zero multiple of n 0 . We shall also make use of the fact that if factoring is hard, then it is hard to compute a non-zero multiple of either p &lt;sup&gt;0&lt;/sup&gt; or q 0 . To see this, suppose that m is a non-zero multiple of p &lt;sup&gt;0&lt;/sup&gt; or q 0 . If m is a multiple of n 0 , then the above mentioned result applies. Otherwise, with overwhelming probability, for random z ∈ Z ∗ n , gcd(z &lt;sup&gt;2&lt;/sup&gt;&lt;sup&gt;m&lt;/sup&gt; − 1, n) will be either p or q, as the reader may easily check using the Chinese Remainder Theorem. Thus, assuming factoring is hard, we may assume that it is hard to compute a non-zero integer m such that gcd(m, n&lt;sup&gt;0&lt;/sup&gt; ) 6= 1.</p>

    <p class="text-gray-300">We also shall use the following facts:</p>

    <p class="text-gray-300">Theorem 2. Under the assumption that factoring is hard, given a modulus n (distributed as above), along with random elements g, h ∈ (Z ∗ n ) 2 , it is hard to compute integers a, b, such that</p>

    <p class="text-gray-300"><span class="math">$1 = g^a h^b \\quad and \\quad (a \\neq 0 \\text{ or } b \\neq 0).</span>$
(13)</p>

    <p class="text-gray-300">Proof. Suppose there is an algorithm A that takes as input n, g, h as above, and outputs a, b satisfying (13) with non-negligible probability. We can use use A to factor a given n, as follows: generate g ∈ (Z ∗ n ) &lt;sup&gt;2&lt;/sup&gt; at random — with overwhelming probability, g has order n 0 ; choose r ∈ [1, n&lt;sup&gt;2&lt;/sup&gt; ] at random, and set h = g &lt;sup&gt;r&lt;/sup&gt; — the distribution of h is statistically close to the uniform distribution on (Z ∗ n ) 2 ; feed n, g, h to A, obtaining a, b. With non-negligible probability, we have</p>

    <p class="text-gray-300"><span class="math">$g</span>$
has order  <span class="math">n&#x27;</span> ,  <span class="math">1 = g^{a+rb}</span> , and  <span class="math">(a \\neq 0 \\text{ or } b \\neq 0)</span> . (14)</p>

    <p class="text-gray-300">Claim: with non-negligible probability, not only does (14) hold, but also a + rb 6= 0. To prove this claim, let us condition on fixed values of n, g, h, a, b, and coins of A, such that A outputs a, b on inputs n, g, h, and such that the conditions in (14) are satisfied. Let us write r = r2n &lt;sup&gt;0&lt;/sup&gt; + r1, where 0 ≤ r&lt;sup&gt;1&lt;/sup&gt; &lt; n&lt;sup&gt;0&lt;/sup&gt; . In this conditional probability space, the value r&lt;sup&gt;1&lt;/sup&gt; is also fixed, but the distribution of r&lt;sup&gt;2&lt;/sup&gt; is statistically close to the uniform distribution on [4n]. We can write the equation a+rb = 0 as a + r2n 0 b + r1b = 0, and in this equation all terms are fixed except for r2. We may as well assume that b 6= 0, as otherwise, a 6= 0 and the equation never holds. There is at most one solution in r&lt;sup&gt;2&lt;/sup&gt; to the equation (as the coefficient n 0 b is non-zero), and so it holds with only negligible probability. That proves the claim.</p>

    <p class="text-gray-300">The identity g &lt;sup&gt;a&lt;/sup&gt;+rb implies that a + rb is a multiple of n 0 , and if a + rb 6= 0, we have a non-zero multiple of n 0 .</p>

    <p class="text-gray-300">Theorem 3. Under the strong RSA assumption, given a modulus n (distributed as above), along with random elements g, h ∈ (Z ∗ n ) 2 , it is hard to compute w ∈ Z ∗ &lt;sup&gt;n&lt;/sup&gt; and integers a, b, c such that</p>

    <p class="text-gray-300"><span class="math">$w^c = g^a h^b \\quad and \\quad (c \\nmid a \\text{ or } c \\nmid b). \\tag{15}</span>$</p>

    <p class="text-gray-300">Proof. Suppose we have an algorithm A that given n, g, h as above, computes w, a, b, c satisfying (15) with non-negligible probability.</p>

    <p class="text-gray-300">Case 1. Let us first consider the case where c = 0 with non-negligible probability. Then the condition that c - a or c - b simply means that a 6= 0 or b 6= 0, and the result is implied by Theorem 2.</p>

    <p class="text-gray-300">Case 2. Let us next consider the remaining, and more interesting, case where  <span class="math">c \\neq 0</span>  with non-negligible probability. We may as well assume that gcd(c, n') = 1, since as was discussed at the beginning of the proof, under the assumption that factoring is hard, it is difficult to compute non-zero c such that  <span class="math">gcd(c, n&#x27;) \\neq 1</span> . We now show how we can use A to either factor a given n or find a non-trivial root of a given g, thus contradicting the strong RSA assumption (since a random element of  <span class="math">\\mathbb{Z}_n^*</span>  is a square with probability 1/4).</p>

    <p class="text-gray-300">Given n and g, we proceed as follows. First, note that with overwhelming probability, g has order n'. Let us compute  <span class="math">h = g^r</span> , for r randomly chosen from  <span class="math">[1, n^2]</span> , so that the distribution of h is statistically close to the uniform distribution on  <span class="math">(\\mathbb{Z}_n^*)^2</span> . Now we feed n, g, h to A, obtaining w, a, b, c. With non-negligible probability, we have</p>

    <p class="text-gray-300"><span class="math">$g</span>$
has order  <span class="math">n&#x27;</span> ,  <span class="math">w^c = g^{a+rb}</span> ,  <span class="math">c \\neq 0</span> ,  <span class="math">\\gcd(c, n&#x27;) = 1</span> , and  <span class="math">c \\nmid a</span> . (16)</p>

    <p class="text-gray-300">Claim: with non-negligible probability, not only does (16) hold, but also  <span class="math">c \\nmid (a+rb)</span> . To prove this claim, let now condition on fixed values of n, g, h, w, a, b, c, and coins of A, such that A outputs w, a, b, c on inputs n, g, h, and such that the conditions in (16) are satisfied. Let us write  <span class="math">r = r_2n&#x27; + r_1</span> , where  <span class="math">0 \\le r_1 &lt; n&#x27;</span> . In this conditional probability space, the value  <span class="math">r_1</span>  is also fixed, but the distribution of  <span class="math">r_2</span>  is statistically close to the uniform distribution on [4n].</p>

    <p class="text-gray-300">Now, consider the congruence</p>

    <p class="text-gray-300"><span class="math">$a + rb \\equiv 0 \\pmod{c}</span>$
.</p>

    <p class="text-gray-300">This congruence holds if and only if</p>

    <p class="text-gray-300"><span class="math">$a + r_1 b + r_2 n&#x27; b \\equiv 0 \\pmod{c} .</span>$</p>

    <p class="text-gray-300">Now, in the conditional probability space, all terms in the above congruence are fixed, except for  <span class="math">r_2</span> . Let us bound from above the probability that this congruence holds. We may as well assume that  <span class="math">c \\nmid b</span> , because if  <span class="math">c \\mid b</span> , then  <span class="math">c \\nmid a</span> , and the congruence will never hold. As  <span class="math">\\gcd(c, n&#x27;) = 1</span> , it follows that the solutions  <span class="math">r_2</span>  to the above congruence are uniquely determined modulo c/d', where  <span class="math">d&#x27; = \\gcd(c, b)</span> . Since  <span class="math">c \\nmid b</span> , it follows that d' is a proper divisor of c, and hence  <span class="math">c/d&#x27; \\geq 2</span> . Because the distribution of  <span class="math">r_2</span>  is statistically close to the uniform distribution on a very large range, it follows that the congruence holds with probability at most about 1/2. This proves the claim.</p>

    <p class="text-gray-300">It is left to show that if  <span class="math">c \\nmid (a+rb)</span> , then we can either factor n, or just compute a non-trivial root of g. Let  <span class="math">d = \\gcd(c, a+rb)</span> . Since we are assuming that  <span class="math">c \\nmid (a+rb)</span> , it follows that  <span class="math">c/d \\geq 2</span> . There are integers  <span class="math">\\alpha</span>  and  <span class="math">\\beta</span>  such that  <span class="math">d = \\alpha c + \\beta(a+rb)</span> , and using the identity  <span class="math">w^c = g^a h^b</span> , we have</p>

    <p class="text-gray-300"><span class="math">$g^d = (w^\\beta g^\\alpha)^c,</span>$</p>

    <p class="text-gray-300">and so  <span class="math">g = \\zeta(w^{\\beta}g^{\\alpha})^{c/d}</span>  for some  <span class="math">\\zeta\\mathbb{Z}_n^*</span>  with  <span class="math">\\zeta^d = 1</span> . Thus, the order of  <span class="math">\\zeta</span>  divides d, and of course, since 2n' is the exponent of  <span class="math">\\mathbb{Z}_n^*</span> , it follows that the order of  <span class="math">\\zeta</span>  divides  <span class="math">\\gcd(d, 2n&#x27;)</span> . Now, since  <span class="math">d \\mid c</span>  and  <span class="math">\\gcd(c, n&#x27;) = 1</span> , we have  <span class="math">\\gcd(d, n&#x27;) = 1</span> , from which it follows that  <span class="math">\\zeta</span>  has order dividing 2.</p>

    <p class="text-gray-300">So either  <span class="math">\\zeta = \\pm 1</span>  or  <span class="math">\\gcd(\\zeta - 1, n)</span>  splits n. In the latter case we have factored n. In the former case we can compute such a root of g as follows. If c/d is even, then  <span class="math">(w^{\\beta}g^{\\alpha})^{c/d} \\in (\\mathbb{Z}_n^*)^2</span>  and so (because  <span class="math">g \\in (\\mathbb{Z}_n^*)^2</span> ), we must have  <span class="math">\\zeta = 1</span>  (as  <span class="math">-1 \\notin (\\mathbb{Z}_n^*)^2</span> ). If c/d is odd then  <span class="math">g = (\\zeta w^{\\beta}g^{\\alpha})^{c/d}</span> . In either case, we have computed a (c/d)th root of g.</p>

    <p class="text-gray-300">Discussion. The strong RSA assumption was introduced independently in [BP97] and [FO97]. Since then, it has been found to be useful in the analysis of many cryptographic schemes (e.g., [CM98,</p>

    <p class="text-gray-300">GHR99, CS00, ACJT00, CL01]). We do not claim that Theorem 3 is new: it has appeared implicitly and in more restricted form in previous papers: the essential idea in the proof of Theorem 3 already appears in [CS00], although that paper deals with a more restricted, and somewhat simpler, setting; also, the paper [DF02] implicitly contains a proof of a statement that is very similar to that of Theorem 3. The paper [FO97] also makes some similar claims (implicitly), but some of their proofs are flawed. Theorem 3 is actually a bit more general than we actually need for our paper, but as it is actually a quite useful theorem in several contexts, we prefer to state it in a very general form.</p>

    <p class="text-gray-300">Loosely speaking, verifiable encryption for a relation R is a protocol that allows a prover to convince a verifier that a given ciphertext is an encryption under a given public key of a value w such that (δ, w) ∈ R for a given δ.</p>

    <p class="text-gray-300">Asokan et al. [ASW98, ASW00] present a protocol for verifiable encryption for the case where w is a homomorphic pre-image of δ and Camenisch and Damg˚ard [CD00] present a protocol that works for any relation R that has a three-move honest-verifier zero-knowledge proof of knowledge where the verifier sends as a second message a random challenge. Both these protocols work for any secure public key encryption scheme. However, they are based on the cut-and-choose paradigm and hence are rather impractical.</p>

    <p class="text-gray-300">In this section we present an efficient verifiable encryption protocol for discrete logarithms in conjunction with the encryption scheme presented in the previous section. We then discuss extensions of this protocol.</p>

    <p class="text-gray-300">Before stating the formal definition of verifiable encryption, we begin with a high level discussion of what we are after, along with some auxiliary definitions.</p>

    <p class="text-gray-300">Let (G, E, D) be a public key encryption scheme, and suppose we have generated a key pair (PK, SK).</p>

    <p class="text-gray-300">A verifiable encryption scheme proves that a ciphertext encrypts a plaintext satisfying a certain relation R. The relation R is defined by a generator algorithm G &lt;sup&gt;0&lt;/sup&gt; which on input 1&lt;sup&gt;λ&lt;/sup&gt; outputs a description Ψ = Ψ[R, W, ∆] of a binary relation R on W × ∆. We require that the sets R, W, and ∆ are easy to recognize (given Ψ). For δ ∈ ∆, an element w ∈ W such that (w, δ) ∈ R is called a witness for δ. The idea is that the encryptor will be given a value δ, a witness w for δ, and a label L, and then encrypts w under L, yielding a ciphertext ψ. After this, the encryptor may prove to another party that ψ decrypts under L to a witness for δ. In carrying out the proof, the encryptor will of course need to make use of the random coins that were used by the encryption algorithm: we denote by E 0 (PK, m, L) the pair (ψ, coins), where ψ is the output of E(PK, m, L) and coins are the random coins used by E to compute ψ.</p>

    <p class="text-gray-300">In such a proof system, the (honest) verifier will output 0 or 1, with 1 signifying &quot;accept.&quot; We of course shall require that the proof system is sound, in the sense that if a verifier accepts a proof, then with overwhelming probability, ψ indeed decrypts under L to a witness for δ. However, it is convenient, and adequate for many applications, to take a more relaxed approach: instead of requiring that ψ decrypts under L to a witness, we only require that a witness can be easily reconstructed from the plaintext using some efficient reconstruction algorithm. Such an algorithm recon takes as input a public key PK, a relation description Ψ[R, W, δ], an element δ ∈ ∆, and a message m ∈ MPK ∪ {reject}, and outputs w ∈ W ∪ {reject}.</p>

    <p class="text-gray-300">We need to make some technical &quot;compatibility&quot; requirements: we say that an encryption scheme, a relation generator, and a reconstruction algorithm as above are mutually compatible if for all λ ≥ 0, all (PK, SK) ∈ G(1&lt;sup&gt;λ&lt;/sup&gt; ), and all Ψ[R, W, ∆] ∈ G&lt;sup&gt;0&lt;/sup&gt; (1&lt;sup&gt;λ&lt;/sup&gt; ), we have</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>W ⊂ MPK, and</li>
      <li>for all (w, δ) ∈ R, we have recon(PK, Ψ, δ, w) = w.</li>
    </ul>

    <p class="text-gray-300">The first requirement simply says that witness &quot;fit&quot; into the message space, and the second requirement simply says that the reconstruction routine does not modify valid witnesses (together with the correctness property for the encryption scheme, this ensures that an encryption of a witness decrypts and reconstructs to the same witness).</p>

    <p class="text-gray-300">We shall also require that the proof system is special honest-verifier zero knowledge. To formulate this more precisely below, we let Trans(PK, Ψ, δ, ψ, L, c, w, coins) denote the transcript seen by a verifier that uses a fixed challenge c.</p>

    <p class="text-gray-300">Definition 1. A proof system (P, V), together with mutually compatible encryption scheme (G, E, D), relation generator G 0 , and reconstruction algorithm recon , form a verifiable encryption scheme, if the following properties hold.</p>

    <p class="text-gray-300">Correctness: for all (PK, SK) ∈ G(1&lt;sup&gt;λ&lt;/sup&gt; ), for all Ψ[R, W, ∆] ∈ G&lt;sup&gt;0&lt;/sup&gt; (1&lt;sup&gt;λ&lt;/sup&gt; ), for all (w, δ) ∈ R, for all L ∈ {0, 1} ∗ , for all (ψ, coins) ∈ E&lt;sup&gt;0&lt;/sup&gt; (PK, w, L),</p>

    <p class="text-gray-300"><span class="math">$\\Pr[x \\leftarrow \\mathcal{V}(\\mathsf{PK}, \\Psi, \\delta, \\psi, L)_{\\mathcal{P}(\\mathsf{PK}, \\Psi, \\delta, \\psi, L, w, coins)} : x = 1] = 1 - \\operatorname{neg}(\\lambda).</span>$</p>

    <p class="text-gray-300">Soundness: for all adversaries (A&lt;sup&gt;∗&lt;/sup&gt; , P ∗ ),</p>

    <pre><code class="language-text">Pr[ (PK, SK) ← G(1λ
                    ); Ψ[R, W, ∆] ← G0
                                    (1λ
                                       );
    (δ, ψ, L, aux ) ← A∗
                     (PK, SK, Ψ);
    x ← V(PK, Ψ, δ, ψ, L)P∗(aux)
                              ;
    m ← D(SK, ψ, L);
    w ← recon(PK, Ψ, δ, m) :
    x = 1 ∧ (w, δ) ∈ R/ ] = neg(λ).
</code></pre>

    <p class="text-gray-300">Special honest-verifier zero knowledge: There exists a simulator Sim such that for all adversaries (A&lt;sup&gt;∗&lt;/sup&gt; , B ∗ , C ∗ ), we have</p>

    <pre><code class="language-text">Pr[ (PK, SK) ← G(1λ
                    ); Ψ[R, W, ∆] ← G0
                                     (1λ
                                       );
    (w, δ, L, aux ) ← A∗
                      (PK, SK, Ψ), where (w, δ) ∈ R;
    (ψ, coins) ← E0
                  (PK, w, L);
    c ← B∗
           (aux , ψ);
    b ← {0, 1};
    if b = 0
       then α ← Trans(PK, Ψ, δ, ψ, L, c, w, coins)
       else α ← Sim(PK, Ψ, δ, ψ, L, c);
    ˆb ← C∗
          (aux , ψ, α) :
    b = ˆb ] = 1/2 + neg(λ).
</code></pre>

    <p class="text-gray-300">The above definitions are fairly traditional. Our formulations of soundness and special honest-verifier zero knowledge are basically of the &quot;computational&quot; variety, but where we have taken the notion of &quot;computational&quot; one step further: instead of universally quantifying over the inputs to the verifier (respectively, simulator), we quantify &quot;computationally.&quot; This is technically convenient, and is adequate for most applications.</p>

    <p class="text-gray-300">Also, the above definitions assume that the key for the encryption scheme are generated by a trusted party. While it is possible to define verifiable encryption in a setting where the keys are not generated by a trusted party, the definitions in this case are a bit more complicated and subtle, and we do not present them here. Nevertheless, our protocols would require only slight modification to remain secure in this setting.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">5.2 Verifiable Encryption of a Discrete Logarithm</h3>

    <p class="text-gray-300">Let  <span class="math">(hk, n, g, y_1, y_2, y_3)</span>  be a public key of the encryption scheme described in §3. Recall that the message space associated with this public key is [n].</p>

    <p class="text-gray-300">Let  <span class="math">\\Gamma</span>  be a cyclic group of order  <span class="math">\\rho</span>  generated by  <span class="math">\\gamma</span> . We assume that  <span class="math">\\gamma</span>  and  <span class="math">\\rho</span>  are publicly known, and that  <span class="math">\\rho</span>  is prime. Let  <span class="math">W = [\\rho]</span>  and  <span class="math">\\Delta = \\Gamma</span> , and let  <span class="math">\\mathcal{R} = \\{(w, \\delta) \\in W \\times \\Delta : \\gamma^w = \\delta\\}</span> . The &quot;discrete logarithm&quot; relation  <span class="math">\\mathcal{R}</span>  is the relation with respect to which we want to verifiably encrypt.</p>

    <p class="text-gray-300">We shall of course require that  <span class="math">n &gt; \\rho</span>  (in fact, we will make a stronger requirement). The reconstruction routine recon will map a plaintext  <span class="math">m \\in [n]</span>  to the integer  <span class="math">(m \\operatorname{rem} n) \\mod \\rho</span> , i.e., it computes the balanced remainder of m modulo n, and then computes the least non-negative remainder of this modulo  <span class="math">\\rho</span> .</p>

    <p class="text-gray-300"><strong>Setup.</strong> Our protocol requires the auxiliary parameters  <span class="math">\\mathfrak{n}</span> , which must the product of two safe  <span class="math">(\\mathfrak{l}+1)</span> -bit primes  <span class="math">\\mathfrak{p}=2\\mathfrak{p}&#x27;+1</span>  and  <span class="math">\\mathfrak{q}=2\\mathfrak{q}&#x27;+1</span> , and  <span class="math">\\mathfrak{g}</span>  and  <span class="math">\\mathfrak{h}</span> , which are two generators of  <span class="math">\\mathfrak{G}_{\\mathfrak{n}&#x27;}\\subset\\mathbb{Z}_{\\mathfrak{n}}^*</span> , where  <span class="math">\\mathfrak{n}&#x27;=\\mathfrak{p}&#x27;\\mathfrak{q}&#x27;</span> ;  <span class="math">\\mathfrak{G}_{\\mathfrak{n}&#x27;}</span>  is the subgroup of  <span class="math">\\mathbb{Z}_{\\mathfrak{n}}^*</span>  of order  <span class="math">\\mathfrak{n}&#x27;</span> , and  <span class="math">\\mathfrak{l}=\\mathfrak{l}(\\lambda)</span> .</p>

    <p class="text-gray-300">One may view  <span class="math">\\mathfrak{n}</span> ,  <span class="math">\\mathfrak{g}</span> , and  <span class="math">\\mathfrak{h}</span>  as additional components of the public key of the encryption scheme, or as system parameters generated by a trusted party. Depending on the setting, we may simply put  <span class="math">\\mathfrak{n} := n</span> . In any event, the prover should not be privy to the factorization of  <span class="math">\\mathfrak{n}</span> .</p>

    <p class="text-gray-300">Let  <span class="math">k = k(\\lambda)</span>  and  <span class="math">k&#x27; = k&#x27;(\\lambda)</span>  be further security parameters, where  <span class="math">2^{-k(\\lambda)}</span>  and  <span class="math">2^{-k&#x27;(\\lambda)}</span>  are negligible functions  <span class="math">(\\{0,1\\}^k)</span>  is the &quot;challenge space&quot; of the verifier and k' controls the quality of the zero-knowledge property). We require that  <span class="math">2^k &lt; \\min\\{p&#x27;, q&#x27;, \\mathfrak{p}&#x27;, \\mathfrak{q}&#x27;, \\mathfrak{p}&#x27;, \\mathfrak{q}&#x27;, \\rho\\}</span>  holds. Finally, we require that  <span class="math">\\rho &lt; n2^{-k-k&#x27;-3}</span>  holds, i.e., that  <span class="math">\\log_{\\gamma} \\delta</span>  &quot;fits into an encryption&quot;. (If this condition is not meet, the value  <span class="math">\\log_{\\gamma} \\delta</span>  could be split into smaller pieces, each of which would then be verifiably encrypted. However, we do not address this here.)</p>

    <p class="text-gray-300"><strong>The protocol.</strong> The common input of the prover and verifier is: the public key (hk, n, g,  <span class="math">y_1</span> ,  <span class="math">y_2</span> ,  <span class="math">y_3</span> ), the augmented public key ( <span class="math">\\mathfrak{n}</span> ,  <span class="math">\\mathfrak{g}</span> ,  <span class="math">\\mathfrak{h}</span> ), a group element ( <span class="math">\\delta</span> ), a ciphertext (u, e, v), and a label L. The prover has additional inputs  <span class="math">m = \\log_{\\gamma} \\delta</span>  and  <span class="math">r \\in_{R} [n/4]</span>  such that</p>

    <p class="text-gray-300"><span class="math">$u = g^r</span>$
,  <span class="math">e = y_1^r h^m</span> , and  <span class="math">v = abs\\left((y_2 y_3^{\\mathcal{H}_{hk}(u,e,L)})^r\\right)</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The prover chooses a random  <span class="math">s \\in_R [\\mathfrak{n}/4]</span>  and computes  <span class="math">\\mathfrak{k} := \\mathfrak{g}^m \\mathfrak{h}^s</span> . The prover sends  <span class="math">\\mathfrak{k}</span>  to the verifier</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Then the prover and verifier engage in the following protocol.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">(a) The prover chooses random</p>

    <p class="text-gray-300"><span class="math">$r&#x27; \\in_R [-n2^{k+k&#x27;-2}, n2^{k+k&#x27;-2}], \\quad s&#x27; \\in_R [-\\mathfrak{n}2^{k+k&#x27;-2}, \\mathfrak{n}2^{k+k&#x27;-2}], \\quad m&#x27; \\in_R [-\\rho2^{k+k&#x27;}, \\rho2^{k+k&#x27;}].</span>$</p>

    <p class="text-gray-300">The prover computes  <span class="math">u&#x27;:=g^{2r&#x27;},\\ e&#x27;:=y_1^{2r&#x27;}h^{2m&#x27;},\\ v&#x27;:=(y_2y_3^{\\mathcal{H}_{\\mathsf{hk}}(u,e,L)})^{2r&#x27;},\\ \\delta&#x27;:=\\gamma^{m&#x27;},\\ \\mathrm{and}\\ \\mathfrak{k}&#x27;:=\\mathfrak{g}^{m&#x27;}\\mathfrak{h}^{s&#x27;}.</span></p>

    <p class="text-gray-300">The prover sends u', e', v',  <span class="math">\\delta&#x27;</span> , and  <span class="math">\\mathfrak{k}&#x27;</span>  to the verifier.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(b) The verifier chooses a random challenge  <span class="math">c \\in_R \\{0,1\\}^k</span>  and sends c to the prover.</li>
      <li>(c) The prover replies with  <span class="math">\\tilde{r} := r&#x27; cr</span> ,  <span class="math">\\tilde{s} := s&#x27; cs</span> , and  <span class="math">\\tilde{m} := m&#x27; cm</span>  (computed in  <span class="math">\\mathbb{Z}</span> ).</li>
      <li>(d) The verifier checks whether the relations</li>
    </ul>

    <p class="text-gray-300"><span class="math">$u&#x27; = u^{2c}g^{2\\tilde{r}}, \\qquad e&#x27; = e^{2c}y_1^{2\\tilde{r}}h^{2\\tilde{m}}, \\qquad v&#x27; = v^{2c}(y_2y_3^{\\mathcal{H}_{hk}(u,e,L)})^{2\\tilde{r}},</span>$</p>

    <p class="text-gray-300"><span class="math">$\\delta&#x27; = \\delta^c\\gamma^{\\tilde{m}}, \\qquad \\mathfrak{k}&#x27; = \\mathfrak{k}^c\\mathfrak{g}^{\\tilde{m}}\\mathfrak{h}^{\\tilde{s}}, \\quad \\text{and} \\qquad -n/4 &lt; \\tilde{m} &lt; n/4</span>$</p>

    <p class="text-gray-300">hold. If any of them does not hold, the verifier stops and outputs 0.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If v = abs(v) the verifier outputs 1; otherwise she outputs 0.</li>
    </ol>

    <p class="text-gray-300">Using notation from [CS97] we denote the sub-protocol of Step 2 as</p>

    <p class="text-gray-300"><span class="math">$PK\\{(r,m,s): u^2 = g^{2r} \\wedge e^2 = y_1^{2r}h^{2m} \\wedge v^2 = (y_2y_3^{\\mathcal{H}_{hk}(u,e,L)})^{2r} \\wedge \\delta = \\gamma^m \\wedge \\mathfrak{k} = \\mathfrak{g}^m\\mathfrak{h}^s \\wedge -n/2 &lt; m &lt; n/2\\} \\ .</span>$</p>

    <p class="text-gray-300"><strong>Proof of Security.</strong> We prove the following theorem about the above system. Given this theorem, one can apply the standard constructions (e.g., [Dam00]) to turn the sub-protocol used in Step 2 into an efficient one that is zero-knowledge w.r.t. any verifier, and can thus obtain a verifiable encryption system that satisfies computational zero-knowledge.</p>

    <p class="text-gray-300"><strong>Theorem 4.</strong> Under the strong RSA assumption, the above system is a verifiable encryption scheme.</p>

    <p class="text-gray-300"><em>Proof.</em> The correctness and special honest-verifier zero-knowledge properties are easy to verify, and we leave this to the reader.</p>

    <p class="text-gray-300">It remains to consider soundness.</p>

    <p class="text-gray-300">If the success-probability of the prover is non-negligible, then there is a knowledge extractor that produces (in time polynomial in  <span class="math">\\lambda</span>  and with non-negligible probability) two answers  <span class="math">(\\tilde{r}^{(1)}, \\tilde{s}^{(1)}, \\tilde{m}^{(1)})</span>   <span class="math">(\\tilde{r}^{(2)}, \\tilde{s}^{(2)}, \\tilde{m}^{(2)})</span>  from the prover on two different challenges  <span class="math">c^{(1)}</span>  and  <span class="math">c^{(2)}</span>  w.r.t. the same  <span class="math">u&#x27;, e&#x27;, v&#x27;, \\delta&#x27;</span> , and  <span class="math">\\mathfrak{t}&#x27;</span> . W.l.o.g., suppose that  <span class="math">c^{(2)} &gt; c^{(1)}</span> . Let  <span class="math">\\Delta r = \\tilde{r}^{(1)} - \\tilde{r}^{(2)}</span> ,  <span class="math">\\Delta s = \\tilde{s}^{(1)} - \\tilde{s}^{(2)}</span> ,  <span class="math">\\Delta m = \\tilde{m}^{(1)} - \\tilde{m}^{(2)}</span> , and  <span class="math">\\Delta c = c^{(2)} - c^{(1)} &gt; 0</span> . From the verification equations one can derive the following equations:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} u^{2\\Delta c} &amp;= g^{2\\Delta r} &amp; e^{2\\Delta c} &amp;= y_1^{2\\Delta r} h^{2\\Delta m} &amp; v^{2\\Delta c} &amp;= (y_2 y_3^{\\mathcal{H}_{hk}(u,e,L)})^{2\\Delta r} \\\\ \\delta^{\\Delta c} &amp;= \\gamma^{\\Delta m} &amp; \\mathfrak{k}^{\\Delta c} &amp;= \\mathfrak{g}^{\\Delta m} \\mathfrak{h}^{\\Delta s} \\end{split}</span>$</p>

    <p class="text-gray-300">Now we use the strong RSA assumption. By Theorem 3, since we have computed  <span class="math">\\mathfrak{k}, \\Delta m, \\Delta s</span> , and  <span class="math">\\Delta c</span>  such that  <span class="math">\\mathfrak{k}^{\\Delta c} = \\mathfrak{g}^{\\Delta m}\\mathfrak{h}^{\\Delta s}</span> , we may assume that  <span class="math">\\Delta c \\mid \\Delta m</span>  and  <span class="math">\\Delta c \\mid \\Delta s</span> . Also, by construction we have  <span class="math">|\\Delta c| &lt; \\min\\{p, q, p&#x27;, q&#x27;, \\mathfrak{p}, \\mathfrak{q}, \\mathfrak{p}&#x27;, \\mathfrak{q}&#x27;, \\rho\\}</span>  and hence  <span class="math">\\Delta c</span>  is invertible modulo any of those primes. Let  <span class="math">\\hat{c} = \\Delta c^{-1} \\mod nn&#x27;</span> . As  <span class="math">u^2</span>  has order dividing nn', we get  <span class="math">u^2 = q^{2\\Delta r\\hat{c}}</span> , i.e.,</p>

    <p class="text-gray-300"><span class="math">$u = w_1 g^{\\Delta r \\hat{c}} \\tag{17}</span>$</p>

    <p class="text-gray-300">for some w&lt;sup&gt;1&lt;/sup&gt; of order 2. Similarly, we get</p>

    <p class="text-gray-300"><span class="math">$e = w_2 y_1^{\\Delta r \\hat{c}} h^{\\Delta m/\\Delta c} \\tag{18}</span>$</p>

    <p class="text-gray-300"><span class="math">$v = w_3 (y_2 y_3^{\\mathcal{H}_{hk}(u,e,L)})^{\\Delta r \\hat{c}}</span>$
(19)</p>

    <p class="text-gray-300"><span class="math">$\\delta = \\gamma^{\\Delta m/\\Delta c} \\tag{20}</span>$</p>

    <p class="text-gray-300">for some w&lt;sup&gt;2&lt;/sup&gt; and w&lt;sup&gt;3&lt;/sup&gt; of order 2. It is not hard to see that from v = abs(v) and from Eqns. (17)-(19) it follows that decryption of the triple (u, e, v) will provide the integer ¯m := ∆m/∆c mod n modulo n (note that due to the squarings in the decryption algorithm, all the w&lt;sup&gt;i&lt;/sup&gt; 's disappear).</p>

    <p class="text-gray-300">We claim that for ˇm = ( ¯m rem n) mod ρ we have δ = γ mˇ , i.e., that (u, e, v) is an encryption of log&lt;sup&gt;γ&lt;/sup&gt; δ. As |m˜ (1)|, |m˜ (2)| &lt; n/4 and ∆c | ∆m, we must have |∆m/∆c| &lt; n/2. Hence ∆m/∆c = ((∆m/∆c mod n) rem n) = ¯m rem n and therefore δ = γ &lt;sup&gt;∆&lt;/sup&gt;m/∆&lt;sup&gt;c&lt;/sup&gt; = γ mˇ .</p>

    <p class="text-gray-300">Our encryption scheme can be extended as follows to encrypt l messages at once. The idea is to use several y1's to compute several e's. That is, the secret key becomes (hk, x (1) 1 , . . . , x (l) 1 , x2, x3) with x (1) 1 , . . . , x (l) 1 , x2, x&lt;sup&gt;3&lt;/sup&gt; ∈&lt;sup&gt;R&lt;/sup&gt; [n &lt;sup&gt;2&lt;/sup&gt;/4], and the public key becomes (hk, n, g, y (1) 1 , . . . , y (l) 1 , y2, y3) with y (i) 1 := g x (i) &lt;sup&gt;1&lt;/sup&gt; . To encrypt a messages m(i) ∈ [n] with label L ∈ {0, 1} &lt;sup&gt;∗&lt;/sup&gt; under a public key as above, choose a random r ∈&lt;sup&gt;R&lt;/sup&gt; [n/4] and compute</p>

    <p class="text-gray-300"><span class="math">$u := g^r</span>$
,  <span class="math">e^{(i)} := (y_1^{(i)})^r h^{m^{(i)}}</span> , and  <span class="math">v := abs\\left((y_2 y_3^{\\mathcal{H}_{hk}(u,e,L)})^r\\right)</span> .</p>

    <p class="text-gray-300">To decrypt a ciphertext (u, e(1), . . . , e(l) , v) with label L under a secret key as above, first check that abs(v) = v and u 2(x2+Hhk(u,e,L)x3) = v 2 . If this does not hold, then output reject and halt. Next, let t = 2−&lt;sup&gt;1&lt;/sup&gt; mod n, and compute ˆm(i) := (e (i)/u&lt;sup&gt;x&lt;/sup&gt; (i) &lt;sup&gt;1&lt;/sup&gt; ) 2t . If all ˆm(i) 's are of the form h m(i) for some m(i) ∈ [n], then output the m(i) 's; otherwise, output reject. It is easy to prove this encryption scheme secure.</p>

    <p class="text-gray-300">It is now straightforward to extend our verifiable encryption protocol to the above encryption scheme to obtain to a verifiable encryption scheme that encrypts a (subset of a) representation of a group element with respect to several bases.</p>

    <p class="text-gray-300">Further, all of these protocols can be easily adapted to the case where the order of the group Γ is not known, i.e., a subgroup of of Z ∗ &lt;sup&gt;N&lt;/sup&gt; for an RSA-modulus N.</p>

    <p class="text-gray-300">Our protocol for verifiable decryption (below) requires that one party proves to another party whether or not two discrete logarithms are equal, where one of the discrete logarithms might not be known to the prover (that is, in the case the discrete logarithms are not equal). There are well-known, efficient, special honest-verifier zero-knowledge proof systems for proving that two discrete logarithms are equal (see [CP93]), so we focus on the problem of proving that two discrete logarithms are unequal. We discuss an efficient protocol for this problem separately as it is of independent interest and as the algebraic setting here is simpler than the one in which we use it in the next section.</p>

    <p class="text-gray-300">Let G = hgi be a group of prime order q. The prover and verifier have common inputs g, h, y, z ∈ G, where g and h are generators for G, and log&lt;sup&gt;g&lt;/sup&gt; y 6= log&lt;sup&gt;h&lt;/sup&gt; z. The prover has the additional input x = log&lt;sup&gt;g&lt;/sup&gt; y. The prover and verifier then engage in the following protocol.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The prover chooses r ∈&lt;sup&gt;R&lt;/sup&gt; Zq, computes the auxiliary commitment C = (h &lt;sup&gt;x&lt;/sup&gt;/z) r , and sends C to the verifier.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The prover executes the protocol denoted</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$PK\\{(\\alpha,\\beta):\\ C=h^{\\alpha}\\left(\\frac{1}{z}\\right)^{\\beta}\\ \\wedge\\ 1=g^{\\alpha}\\left(\\frac{1}{y}\\right)^{\\beta}\\}</span>$</p>

    <p class="text-gray-300">with the verifier.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The verifier accepts if it accepts in Step 2, and if C 6= 1; otherwise, the verifier rejects.</li>
    </ol>

    <p class="text-gray-300">Note that in an actual implementation, the value C may be sent to the verifier as part of the first message in the sub-protocol in Step 2.</p>

    <p class="text-gray-300">Theorem 5. The above protocol is a special honest-verifier proof system for proving that log&lt;sup&gt;g&lt;/sup&gt; y 6= log&lt;sup&gt;h&lt;/sup&gt; z.</p>

    <p class="text-gray-300">Proof. Correctness of the protocol is by inspection.</p>

    <p class="text-gray-300">Consider the protocol's soundness. If a prover can make an honest verifier accept with nonnegligible probability, then using standard rewinding arguments, there exist values α and β such that the equations</p>

    <p class="text-gray-300"><span class="math">$C = h^{\\alpha} \\left(\\frac{1}{z}\\right)^{\\beta}</span>$</p>

    <p class="text-gray-300"><span class="math">$1 = g^{\\alpha} \\left(\\frac{1}{y}\\right)^{\\beta}</span>$
(21)</p>

    <p class="text-gray-300">hold. From the second equation of (21) one can conclude that</p>

    <p class="text-gray-300"><span class="math">$\\alpha \\equiv \\beta \\log_g y \\pmod{q} .</span>$</p>

    <p class="text-gray-300">Substituting β log&lt;sup&gt;g&lt;/sup&gt; y for α in the first equation of (21), we get C = (h log&lt;sup&gt;g&lt;/sup&gt; y /z) β . As the verifier accepts only if C 6= 1, this implies that h log&lt;sup&gt;g&lt;/sup&gt; y /z 6= 1, i.e., that log&lt;sup&gt;g&lt;/sup&gt; y 6= log&lt;sup&gt;h&lt;/sup&gt; z.</p>

    <p class="text-gray-300">To see that the protocol is special honest-verifier zero knowledge, note that in an actual run of the protocol with an honest prover, C is a random element of G. Thus, the simulator can simply generate C at random, and then use the simulator for the proof in Step 2.</p>

    <p class="text-gray-300">Let us briefly discuss related work. Independently of our work, Bresson and Stern [BS02] provide a protocol to prove that two discrete logarithms are not equal that is similar to ours. However, their protocol is about a factor of two less efficient than ours and is only computationally sound. Also, we note that the protocol proposed by Michels and Stadler [MS98] to prove whether or not two discrete logarithms are equal is not zero knowledge because it reveals the value h x (which the simulator can not compute, but a (dishonest) verifier can if he chooses h such the he knows log&lt;sup&gt;g&lt;/sup&gt; h).</p>

    <p class="text-gray-300">In this section we provide a protocol that allows the decryptor to prove that she decrypted correctly. In particular, we provide a protocol that allows the decryptor to prove whether or not a given ciphertext decrypts to a given plaintext. We then extend the protocol to one for proving whether or not a given ciphertext decrypts to the discrete logarithm of a given group element.</p>

    <p class="text-gray-300">Verifiable decryption is a protocol between a prover, knowing the decryption key, and a verifier, who as the result of the protocol either rejects or learns whether or not a given ciphertext decrypts under a given label to a plaintext that satisfies a given relation.</p>

    <p class="text-gray-300">We adopt the notation and terminology in §5.1. In addition, for mutually compatible encryption scheme encryption scheme (G, E, D), relation generator G 0 , and reconstruction algorithm recon, we define the function f that for all (PK, SK) ∈ G(1&lt;sup&gt;λ&lt;/sup&gt; ), all Ψ[R, W, ∆] ∈ G&lt;sup&gt;0&lt;/sup&gt; , all ψ, L ∈ {0, 1} ∗ , and all δ ∈ ∆</p>

    <p class="text-gray-300">&lt;sup&gt;f&lt;/sup&gt;(Ψ, δ, ψ, L, SK) = ( +1 if (recon(PK, Ψ, δ, D(SK, ψ, L)), δ) ∈ R; −1 otherwise.</p>

    <p class="text-gray-300">The (honest) verifier in a verifiable decryption protocol will output either a value ±1, indicating that this is the value of f, or the value 0, indicating that the proof is invalid.</p>

    <p class="text-gray-300">A difficulty in defining soundness for verifiable decryption is that for many public key encryption schemes (including ours and, e.g., the ElGamal based Cramer-Shoup one [CS98]), it is not well defined whether or not a ciphertext is valid given only the public key. More precisely, there are ciphertexts that can be both valid and invalid, depending on the actual value of the secret key. Hence, it is in principle possible that the decryptor/prover could change her mind about such ciphertexts, which seems inappropriate. In the following definition, we assume that the public and secret key are generated by a trusted party which allows us to define soundness in terms of the secret key and public key rather than only the public key. As for verifiable encryption, the definitions for the setting where the keys are not generated by a trusted party are a bit more complicated and subtle, and we do not present them here. However, our protocols would require only slight modification to remain secure in this setting.</p>

    <p class="text-gray-300">Definition 2. A proof system (P, V), together with mutually compatible encryption scheme (G, E, D), relation generator G 0 , and reconstruction algorithm recon , form a verifiable decryption scheme, if the following properties hold.</p>

    <p class="text-gray-300">Correctness: For all (PK, SK) ∈ G(1&lt;sup&gt;λ&lt;/sup&gt; ), for all Ψ[R, W, ∆] ∈ G&lt;sup&gt;0&lt;/sup&gt; (1&lt;sup&gt;λ&lt;/sup&gt; ), for all δ ∈ ∆, for all ψ, L ∈ {0, 1} ∗ ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[x \\leftarrow \\mathcal{V}(\\mathsf{PK}, \\Psi, \\delta, \\psi, L)_{\\mathcal{P}(\\mathsf{PK}, \\Psi, \\delta, \\psi, L, \\mathsf{SK})} : x = f(\\Psi, \\delta, \\psi, L, SK)] = 1 - \\operatorname{neg}(\\lambda) .</span>$</p>

    <p class="text-gray-300">Soundness: For all adversaries (A&lt;sup&gt;∗&lt;/sup&gt; , P ∗ ),</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\Pr[ &amp; \\quad (\\mathsf{PK},\\mathsf{SK}) \\leftarrow \\mathcal{G}(1^{\\lambda}); \\Psi[\\mathcal{R},W,\\Delta] \\leftarrow \\mathcal{G}&#x27;(1^{\\lambda}); \\\\ &amp; \\quad (\\delta,\\psi,L,aux) \\leftarrow \\mathcal{A}^*(\\mathsf{PK},\\mathsf{SK},\\Psi); \\\\ &amp; \\quad x \\leftarrow \\mathcal{V}(\\mathsf{PK},\\Psi,\\delta,\\psi,L)_{\\mathcal{P}^*(aux)}: \\\\ &amp; \\quad x = -f(\\Psi,\\delta,\\psi,L,SK) \\end{split} \\right] = \\ \\operatorname{neg}(\\lambda) \\ . \\end{split}</span>$</p>

    <p class="text-gray-300">Special honest-verifier zero knowledge: There exists a simulator Sim such that for all adver-</p>

    <p class="text-gray-300">saries (A&lt;sup&gt;∗&lt;/sup&gt; , B ∗ ), we have</p>

    <pre><code class="language-text">Pr[ (PK, SK) ← G(1λ
                   ); Ψ[R, W, ∆] ← G0
                                   (1λ
                                      );
    (δ, ψ, L, c, aux ) ← A∗
                       (PK, SK, Ψ);
    b ← {0, 1};
    if b = 0
       then α ← Trans(PK, Ψ, δ, ψ, L, c, SK)
       else α ← Sim(PK, Ψ, δ, ψ, L, c, f(Ψ, δ, ψ, L, SK));
    ˆb ← B∗
          (aux , α) :
    b = ˆb ] = 1/2 + neg(λ) .
</code></pre>

    <p class="text-gray-300">We give a protocol for the decryptor to prove whether or not a ciphertext (u, e, v) decrypts to a message m under label L, i.e., using this protocol she can show that she did correctly decrypt. This is a special case of verifiable decryption in which the relation R is equality, and the reconstruction routine returns its last input as its output.</p>

    <p class="text-gray-300">For our encryption scheme in §3, this proof corresponds to proving whether or not the two equations</p>

    <p class="text-gray-300"><span class="math">$u^{2(x_2 + \\mathcal{H}_{hk}(u, e, L)x_3)}/v^2 = 1</span>$
and  <span class="math">(e/u^{x_1})^2/h^{2m} = 1</span>  (22)</p>

    <p class="text-gray-300">hold (assuming that the public test abs(v) = v is satisfied). If the ciphertext is invalid, one or both of the two statements do not hold. If the ciphertext is valid but decrypts to another message, the first statement holds but the second one does not.</p>

    <p class="text-gray-300">Proving that both of these equations hold is a fairly straightforward application of known techniques.</p>

    <p class="text-gray-300">To prove that at least one of the equations does not hold, we can use the &quot;proof of partial knowledge&quot; technique of [CDS94], combined with the technique developed in §6. However, because in the present setting the group has non-prime order we can not prove the relationship among the secrets in the same way as in §6 and, more importantly, the resulting protocol would not be zero-knowledge. The former problem can be solved using an auxiliary group G&lt;sup&gt;n&lt;/sup&gt; &lt;sup&gt;0&lt;/sup&gt; ⊂ Z ∗ &lt;sup&gt;n&lt;/sup&gt; as we did in §5. We consider the latter problem. Depending on the values of the secret keys x1, x2, and x3, the left hand sides of the equations (22), and thus the auxiliary commitments to be provided in the protocol, lie in different (sub-)groups, i.e., in Gn, Gn&lt;sup&gt;0&lt;/sup&gt;, or GnGn&lt;sup&gt;0&lt;/sup&gt;. As the simulator does not know the values x1, x2, and x3, it can not simulate these auxiliary commitments. We solve this problem using the fact that for all elements a ∈ GnGn&lt;sup&gt;0&lt;/sup&gt; we have</p>

    <p class="text-gray-300"><span class="math">$a \\neq 1 \\qquad \\Leftrightarrow \\qquad (a^n \\in \\mathbf{G}_{n&#x27;} \\wedge a^n \\neq 1) \\quad \\lor \\quad (a \\in \\mathbf{G}_n \\wedge a \\neq 1) .</span>$</p>

    <p class="text-gray-300">Thus, to prove that (at least) one of the equations (22) does not hold, we prove that either</p>

    <p class="text-gray-300"><span class="math">$\\left(\\frac{u^{2(x_2+\\mathcal{H}_{hk}(u,e,L)x_3)}}{v^2}\\right)^n \\neq 1 \\tag{23}</span>$</p>

    <p class="text-gray-300">or</p>

    <p class="text-gray-300"><span class="math">$\\left(\\frac{u^{2(x_2+\\mathcal{H}_{hk}(u,e,L)x_3)}}{v^2}\\right)^n = 1</span>$
and  <span class="math">\\frac{u^{2(x_2+\\mathcal{H}_{hk}(u,e,L)x_3)}}{v^2} \\neq 1</span>  (24)</p>

    <p class="text-gray-300">or</p>

    <p class="text-gray-300"><span class="math">$\\left(\\frac{(e/u^{x_1})^2}{h^{2m}}\\right)^n = (e/u^{x_1})^{2n} \\neq 1 \\tag{25}</span>$</p>

    <p class="text-gray-300">or</p>

    <p class="text-gray-300"><span class="math">$\\left(\\frac{(e/u^{x_1})^2}{h^{2m}}\\right)^n = 1</span>$
and  <span class="math">\\frac{(e/u^{x_1})^2}{h^{2m}} \\neq 1</span>  (26)</p>

    <p class="text-gray-300">holds. Now, whenever one of the four cases applies it is always well defined in which group the left-hand sides of the inequalities lie and we can apply the ideas underlying the protocol in  <span class="math">\\S 6</span>  to prove that at least one of these four inequalities applies. We remark that the case where the statements (23-25) are false but the statement (26) is true corresponds to the case where the ciphertext is a valid encryption of a message different from m. If any of the statements (23-25) is true corresponds to the cases where the ciphertext is invalid.</p>

    <p class="text-gray-300">We are now ready to describe the protocol between the decryptor and a verifier. Their common input is  <span class="math">(hk, n, g, y_1, y_2, y_3)</span> , (n, g, h), (u, e, v), m, and L and the additional input to the decryptor is  <span class="math">(x_1, x_2, x_3)</span> . The triple (n, g, h) is an auxiliary parameter as in the one previous section. (As we assume here that n is generated by a trusted party as well, i.e., that the decryptor is not provided with n's factorization; also, n and n could be identical.) In the following description we assume that all the messages the prover sends to the verifier prior to the execution of one of the possible PK protocols will in fact be bundled with the first message of that PK protocol. Here we provide the proof-protocols only by high-level notation; the actual protocols are easily derived from it (cf. also the the verifiable encryption protocol presented in §5 and its high-level notation).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">m \\notin [n]</span>  or the ciphertext is malformed, (e.g., if  <span class="math">v \\neq abs(v)</span> ), the verifier outputs -1, and the protocol stops.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If (u, e, v) is a valid ciphertext and decrypts to m under label L, the decryptor sends 1 to the verifier, and then engages in the protocol denoted</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$PK\\{(x_1,x_2,x_3): y_1=g^{x_1} \\wedge y_2=g^{x_2} \\wedge y_3=g^{x_3} \\wedge v^2=u^{2x_2}u^{2\\mathcal{H}_{hk}(u,e,L)x_3} \\wedge \\frac{e^2}{h^{2m}}=u^{2x_1}\\}</span>$</p>

    <p class="text-gray-300">with the verifier.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If (u, e, v) is an invalid ciphertext w.r.t. the label L or decrypts to some message different from m under L, then the decryptor sends -1 to the verifier. They proceed as follows.</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) The decryptor chooses  <span class="math">a_1 \\in_R [n/4]</span> ,  <span class="math">a_2 \\in_R [n^2/4]</span> ,  <span class="math">a_3 \\in_R [n/4]</span> , and  <span class="math">a_4 \\in_R [n^2/4]</span> , along with  <span class="math">b_1, b_2, b_3, b_3 \\in_R [n/4]</span> .</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">She then computes  <span class="math">\\mathfrak{C}_1 := \\mathfrak{g}^{a_1}\\mathfrak{h}^{b_1}</span> ,  <span class="math">\\mathfrak{C}_2 := \\mathfrak{g}^{a_2}\\mathfrak{h}^{b_2}</span> ,  <span class="math">\\mathfrak{C}_3 := \\mathfrak{g}^{a_3}\\mathfrak{h}^{b_3}</span> , and  <span class="math">\\mathfrak{C}_4 := \\mathfrak{g}^{a_4}\\mathfrak{h}^{b_4}</span> . She chooses  <span class="math">C_1 \\in_R \\mathbf{G}_{n&#x27;}</span> ,  <span class="math">C_2 \\in_R \\mathbf{G}_n</span> ,  <span class="math">C_3 \\in_R \\mathbf{G}_{n&#x27;}</span> , and  <span class="math">C_4 \\in_R \\mathbf{G}_n</span> .</p>

    <p class="text-gray-300">Furthermore.</p>

    <p class="text-gray-300">(Case 1) if
<span class="math">$u^{2n(x_2+\\mathcal{H}_{hk}(u,e,L)x_3)} \\neq v^{2n}</span>$
, she sets  <span class="math">C_1 := (u^{x_2+\\mathcal{H}_{hk}(u,e,L)x_3}/v)^{2na_1}</span> ,
(Case 2) else if  <span class="math">u^{2(x_2+\\mathcal{H}_{hk}(u,e,L)x_3)} \\neq v^2</span> , she sets  <span class="math">C_2 := (u^{x_2+\\mathcal{H}_{hk}(u,e,L)x_3}/v)^{2a_2}</span> ,
(Case 3) else if  <span class="math">(u^{x_1}/e)^2 \\notin \\langle h \\rangle</span> , she sets  <span class="math">C_3 := (u^{x_1}/e)^{2na_3}</span> ,
(Case 4) else  <span class="math">(u^{x_1}/e)^2 \\neq h^{2m}</span> , and she sets  <span class="math">C_4 := (u^{x_1}h^m/e)^{2a_4}</span> .</p>

    <p class="text-gray-300">The decryptor sends  <span class="math">C_1</span> ,  <span class="math">C_2</span> ,  <span class="math">C_3</span> ,  <span class="math">C_4</span> ,  <span class="math">\\mathfrak{C}_1</span> ,  <span class="math">\\mathfrak{C}_2</span> ,  <span class="math">\\mathfrak{C}_3</span> , and  <span class="math">\\mathfrak{C}_4</span>  to the verifier.</p>

    <p class="text-gray-300">(b) The decryptor and the verifier carry out the protocol denoted</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} PK\\Big\\{ &amp;(x_1,x_2,x_3,\\,a_1,\\ldots,a_4,\\,b_1,\\ldots,b_4,\\,r_1,\\ldots,r_4\\,s_1,\\ldots,s_4): \\\\ &amp; \\Big[y_1=g^{x_1} \\ \\land \\ y_2=g^{x_2} \\ \\land \\ y_3=g^{x_3} \\ \\land \\\\ &amp; C_1=u^{2nr_1}(\\frac{1}{v})^{2na_1} \\ \\land \\ \\mathfrak{C}_1=\\mathfrak{g}^{a_1}\\mathfrak{h}^{b_1} \\ \\land \\ 1=(\\frac{1}{\\mathfrak{C}_1})^{x_2}(\\frac{1}{\\mathfrak{C}_1})^{\\mathcal{H}_{hk}(u,e,L)x_3}\\mathfrak{g}^{r_1}\\mathfrak{h}^{s_1}\\Big] \\\\ &amp; \\vee \\Big[y_1=g^{x_1} \\ \\land \\ y_2=g^{x_2} \\ \\land \\ y_3=g^{x_3} \\ \\land \\\\ &amp; C_2=u^{2r_2}(\\frac{1}{v})^{a_2} \\ \\land \\ \\mathfrak{C}_2=\\mathfrak{g}^{a_2}\\mathfrak{h}^{b_2} \\ \\land \\ 1=(\\frac{1}{\\mathfrak{C}_2})^{x_2}(\\frac{1}{\\mathfrak{C}_2})^{\\mathcal{H}_{hk}(u,e,L)x_3}\\mathfrak{g}^{r_2}\\mathfrak{h}^{s_2}\\Big] \\\\ &amp; \\vee \\Big[y_1=g^{x_1} \\ \\land \\ y_2=g^{x_2} \\ \\land \\ y_3=g^{x_3} \\ \\land \\\\ &amp; C_3=u^{2nr_3}(\\frac{1}{e})^{2na_3} \\ \\land \\ \\mathfrak{C}_3=\\mathfrak{g}^{a_3}\\mathfrak{h}^{b_3} \\ \\land \\ 1=(\\frac{1}{\\mathfrak{C}_3})^{x_1}\\mathfrak{g}^{r_3}\\mathfrak{h}^{s_3}\\Big] \\\\ &amp; \\vee \\Big[y_1=g^{x_1} \\ \\land \\ y_2=g^{x_2} \\ \\land \\ y_3=g^{x_3} \\ \\land \\\\ &amp; C_4=u^{2r_4}(\\frac{h^m}{e})^{2a_4} \\ \\land \\ \\mathfrak{C}_4=\\mathfrak{g}^{a_4}\\mathfrak{h}^{b_4} \\ \\land \\ 1=(\\frac{1}{\\mathfrak{C}_4})^{x_1}\\mathfrak{g}^{r_4}\\mathfrak{h}^{s_4}\\Big]\\Big\\} \\ , \\end{split}</span>$</p>

    <p class="text-gray-300">where  <span class="math">r_1, \\ldots, r_4, s_1, \\ldots, s_4</span>  are temporary secrets (i.e.,</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} r_1 &amp;= a_1(x_2 + \\mathcal{H}_{\\mathsf{hk}}(u, e, L)x_3), &amp; s_1 &amp;= b_1(x_2 + \\mathcal{H}_{\\mathsf{hk}}(u, e, L)x_3), \\\\ r_2 &amp;= a_2(x_2 + \\mathcal{H}_{\\mathsf{hk}}(u, e, L)x_3), &amp; s_2 &amp;= b_2(x_2 + \\mathcal{H}_{\\mathsf{hk}}(u, e, L)x_3), \\\\ r_3 &amp;= x_1a_3, &amp; s_3 &amp;= x_1b_3, \\\\ r_4 &amp;= x_1a_4, &amp; s_4 &amp;= x_1b_4, \\end{split}</span>$</p>

    <p class="text-gray-300">(computed in  <span class="math">\\mathbb{Z}</span> )). (To derive the actual protocol one may to apply the techniques by Cramer et al.[CDS94] for realizing the  <span class="math">\\vee</span> 's.)</p>

    <p class="text-gray-300">(c) The verifier checks that  <span class="math">C_1^2 \\neq 1</span> ,  <span class="math">C_2^2 \\neq 1</span> ,  <span class="math">C_3^2 \\neq 1</span> , and  <span class="math">C_4^2 \\neq 1</span> .</p>

    <p class="text-gray-300">The computational load of the prover and the verifier is about one to four times the load in the protocol for verifiable encryption described in the previous section (depending on whether Step 2 or Step 3 gets carried out).</p>

    <p class="text-gray-300"><strong>Theorem 6.</strong> Assuming factoring is hard, the above scheme is a verifiable decryption scheme (for matching plaintexts).</p>

    <p class="text-gray-300"><em>Proof.</em> Correctness is trivial, and we leave this to the reader.</p>

    <p class="text-gray-300">We now show that the protocol is special honest-verifier computational zero-knowledge by providing a simulator.</p>

    <p class="text-gray-300">First the simulator executes step 1 of the protocol as the decryptor would, that is, if  <span class="math">m \\notin [n]</span>  or if the ciphertext is malformed the simulator stops. The simulator queries an oracle to determine whether or not  <span class="math">\\psi</span>  decrypts to m. If it does, it sends the verifier 1 it simulates step 2 by the simulator for the PK-protocol of step 2. If does not, it simulates step 3 as follows. First the simulator sends the verifier -1. Then it chooses  <span class="math">b_1, b_2, b_3, b_3 \\in_R [\\mathfrak{n}/4]</span> . It then computes  <span class="math">\\mathfrak{C}_1 := \\mathfrak{h}^{b_1}</span> ,  <span class="math">\\mathfrak{C}_2 := \\mathfrak{h}^{b_2}</span> ,  <span class="math">\\mathfrak{C}_3 := \\mathfrak{h}^{b_3}</span> , and  <span class="math">\\mathfrak{C}_4 := \\mathfrak{h}^{b_4}</span> . It chooses  <span class="math">C_1 \\in_R \\mathbf{G}_{n&#x27;}</span> ,  <span class="math">C_2 \\in_R \\mathbf{G}_{n}</span> ,  <span class="math">C_3 \\in_R \\mathbf{G}_{n&#x27;}</span> , and  <span class="math">C_4 \\in_R \\mathbf{G}_{n}</span> . Next it invokes the simulator for the PK-protocol of step 3. This concludes the simulator.</p>

    <p class="text-gray-300">It remains to show that the simulator indeed works. It is clear that the simulation of steps 1 and 2 works. Consider step 3.</p>

    <p class="text-gray-300">Note that in the real run as well as in the simulation the pairs  <span class="math">(\\mathfrak{C}_1, C_1), \\ldots, (\\mathfrak{C}_4, C_4)</span>  are independently distributed. Moreover they obviously have the same distribution in the simulation as in the real run except for the one pair for which the prover replaces the  <span class="math">C_i</span> .</p>

    <p class="text-gray-300">We consider the cases where the prover replaces  <span class="math">C_1</span>  and  <span class="math">C_2</span> , respectively. The remaining two cases are analogous.</p>

    <p class="text-gray-300">Case 1. Here  <span class="math">u^{2n(x_2+\\mathcal{H}_{hk}(u,e,L)x_3)} \\neq v^{2n}</span>  holds and the prover replaces  <span class="math">C_1</span> . Note that  <span class="math">(u^{(x_2+\\mathcal{H}_{hk}(u,e,L)x_3)}/v)^{2n} \\in \\mathbf{G}_{n&#x27;}</span>  and  <span class="math">(u^{(x_2+\\mathcal{H}_{hk}(u,e,L)x_3)}/v)^{2n} \\neq 1</span> . Thus  <span class="math">(u^{(x_2+\\mathcal{H}_{hk}(u,e,L)x_3)}/v)</span>  generates  <span class="math">\\mathbf{G}_{n&#x27;}</span>  (or we could factor n) and  <span class="math">C_1 = (u^{x_2+\\mathcal{H}_{hk}(u,e,L)x_3}/v)^{2na_1}</span>  is a random element of  <span class="math">\\mathbf{G}_{n&#x27;}</span>  as  <span class="math">a_1</span>  is chosen at random from the appropriate interval. Also, as  <span class="math">b_1</span>  is chosen independently of  <span class="math">a_1</span> ,  <span class="math">\\mathfrak{C}_1</span>  is a random element from  <span class="math">\\mathfrak{G}_{n&#x27;}</span> . Hence  <span class="math">\\mathfrak{C}_1</span>  and  <span class="math">C_1</span>  have the same distribution in the run with the real prover as in the simulation.</p>

    <p class="text-gray-300">Case 2. As the above case does not apply, i.e.,  <span class="math">(u^{(x_2+\\mathcal{H}_{hk}(u,e,L)x_3)}/v)^{2n}=1</span>  we have that  <span class="math">(u^{x_2+\\mathcal{H}_{hk}(u,e,L)x_3)}/v)^2 \\in \\mathbf{G}_n</span> . Again,  <span class="math">(u^{x_2+\\mathcal{H}_{hk}(u,e,L)x_3)}/v)^2</span>  generates  <span class="math">\\mathbf{G}_n</span>  (or we could factor n) and  <span class="math">C_2 = (u^{x_2+\\mathcal{H}_{hk}(u,e,L)x_3}/v)^{2a_2}</span>  as  <span class="math">a_1</span>  is chosen at random. For the same reason as in Case 1,  <span class="math">\\mathfrak{C}_2</span>  is a random element from  <span class="math">\\mathfrak{G}_{n&#x27;}</span>  and  <span class="math">\\mathfrak{C}_2</span>  and  <span class="math">C_2</span>  have the same distribution in the run with the real prover as in the simulation.</p>

    <p class="text-gray-300">These facts, together with the fact that all the PK-protocols used as sub-protocols are special honest-verifier zero-knowledge (showing the latter is standard and left to the reader), imply that the verifiable decryption protocol is special honest-verifier zero-knowledge. Note that we have used in an essential way the fact that we quantify &quot;computationally&quot; over the inputs to the simulator: the inputs that cause the simulator to fail are assumed to be hard to find.</p>

    <p class="text-gray-300">In the remainder we prove soundness. Let us generate a public keys and secret keys according to the usual algorithms, obtaining</p>

    <p class="text-gray-300"><span class="math">$n, g, y_1, y_2, y_3, x_1, x_2, x_3, \\mathfrak{n}, \\mathfrak{g}, \\mathfrak{h}.</span>$</p>

    <p class="text-gray-300">All of this information is available to the adversary, who produces  <span class="math">m, \\psi, L</span> , and is able to make the verifier accept on these inputs with non-negligible probability. Using standard rewinding techniques we can produce two accepting conversations for either the PK protocol in Step 2 or the one in Step 3 (for different challenges but the same first message), depending on whether  <span class="math">m = \\mathcal{D}(1^{\\lambda}, \\mathsf{SK}, \\psi, L)</span> . We consider these two cases.</p>

    <p class="text-gray-300">Case I. First assume that  <span class="math">m \\neq \\mathcal{D}(1^{\\lambda}, \\mathsf{SK}, \\psi, L)</span>  but that V's output is 1. Let  <span class="math">(u, e, v) := \\psi</span> . In this case we get two accepting conversations of the PK protocol in Step 2 and hence two answers</p>

    <p class="text-gray-300"><span class="math">$(\\tilde{x}_1^{(1)}, \\tilde{x}_2^{(1)}, \\tilde{x}_3^{(1)})</span>$
and  <span class="math">(\\tilde{x}_1^{(2)}, \\tilde{x}_2^{(2)}, \\tilde{x}_3^{(2)})</span></p>

    <p class="text-gray-300">for the two different challenges  <span class="math">c^{(1)}</span>  and  <span class="math">c^{(2)}</span>  but with the same first message (here we use the same notation for the protocol variables as for the PK protocol in the previous section). W.l.o.g., suppose that  <span class="math">c^{(2)} &gt; c^{(1)}</span> . Let  <span class="math">\\Delta x_1 = \\tilde{x}_1^{(1)} - \\tilde{x}_1^{(2)}</span> ,  <span class="math">\\Delta x_2 = \\tilde{x}_2^{(1)} - \\tilde{x}_2^{(2)}</span> ,  <span class="math">\\Delta x_3 = \\tilde{x}_3^{(1)} - \\tilde{x}_3^{(2)}</span> , and  <span class="math">\\Delta c = c^{(2)} - c^{(1)}</span> . From the verification equation of the PK protocol one can derive the following equations:</p>

    <p class="text-gray-300"><span class="math">$y_1^{\\Delta c} = g^{\\Delta x_1} , y_2^{\\Delta c} = g^{\\Delta x_2} , y_3^{\\Delta c} = g^{\\Delta x_3} , (27)</span>$</p>

    <p class="text-gray-300"><span class="math">$v^{2\\Delta c} = u^{2\\Delta x_2} u^{2\\mathcal{H}_{\\mathsf{hk}}(u,e,L)\\Delta x_3} , \\text{ and}</span>$
(28)</p>

    <p class="text-gray-300"><span class="math">$\\left(\\frac{e^2}{h^{2m}}\\right)^{\\Delta c} = u^{2\\Delta x_1} \\ . \\tag{29}</span>$</p>

    <p class="text-gray-300">As n is the product of two safe primes p and q, we have  <span class="math">|\\Delta c| &lt; \\min\\{p, q, p&#x27;q&#x27;\\}</span>  and hence  <span class="math">\\Delta c</span>  is invertible modulo n'n. We know  <span class="math">x_i</span>  such that  <span class="math">y_i = g^{x_i}</span>  and therefore it follows from (27) that</p>

    <p class="text-gray-300"><span class="math">$\\Delta c \\, x_i \\equiv \\Delta x_i \\pmod{n&#x27;} \\quad \\text{for} \\quad i = 1, \\dots, 3 \\ .</span>$
(30)</p>

    <p class="text-gray-300">Now,  <span class="math">\\mathcal{D}(1^{\\lambda}, \\mathsf{SK}, \\psi, L) \\neq m</span>  means that least one of the four statements (23-26) must be true and therefore at least one of the two statements</p>

    <p class="text-gray-300"><span class="math">$u^{2(x_2 + \\mathcal{H}_{hk}(u, e, L)x_3)} \\neq v^2</span>$
or  <span class="math">(e/u^{x_1})^2 \\neq h^{2m}</span>  (31)</p>

    <p class="text-gray-300">holds. We consider these two cases:</p>

    <p class="text-gray-300">Case 1. If  <span class="math">u^{2(x_2+\\mathcal{H}_{hk}(u,e,L)x_3)} \\neq v^2</span>  we must have that  <span class="math">u^{2\\Delta c(x_2+\\mathcal{H}_{hk}(u,e,L)x_3)} \\neq v^{2\\Delta c} = u^{2\\Delta x_2+\\mathcal{H}_{hk}(u,e,L)\\Delta x_3}</span>  (from Equation (28) and because  <span class="math">\\Delta c</span>  is invertible modulo nn') and therefore also</p>

    <p class="text-gray-300"><span class="math">$\\Delta c(x_2 + \\mathcal{H}_{hk}(u, e, L)x_3) \\not\\equiv \\Delta x_2 + \\mathcal{H}_{hk}(u, e, L)\\Delta x_3 \\pmod{n&#x27;n}</span>$
,</p>

    <p class="text-gray-300">as the order of  <span class="math">u^2</span>  divides n'n. From (30) it follows that</p>

    <p class="text-gray-300"><span class="math">$\\Delta c(x_2 + \\mathcal{H}_{hk}(u, e, L)x_3) \\equiv \\Delta x_2 + \\mathcal{H}_{hk}(u, e, L)\\Delta x_3 \\pmod{n&#x27;}</span>$
.</p>

    <p class="text-gray-300">Therefore  <span class="math">\\Delta cx_2 - \\Delta x_2 + (\\Delta cx_3 - \\Delta x_3)\\mathcal{H}_{hk}(u, e, L)</span>  must be a non-zero multiple of n', which would allow us to factor n, which is impossible.</p>

    <p class="text-gray-300">Case 2. If  <span class="math">u^{2x_1} \\neq (\\frac{e}{h^m})^2</span>  we can, similarly as in case 1, conclude that  <span class="math">u^{2\\Delta cx_1} \\neq u^{2\\Delta x_1}</span>  from Equation (29) and that  <span class="math">\\Delta cx_1 - \\Delta x_1</span>  is a non-zero multiple of n', which would again allow us to factor n, which is impossible.</p>

    <p class="text-gray-300">Case II. It remains to consider the case when V's output is -1 but  <span class="math">m = \\mathcal{D}(1^{\\lambda}, \\mathsf{SK}, \\psi, L)</span>  holds. Let  <span class="math">(u, e, v) := \\psi</span> . Thus we have</p>

    <p class="text-gray-300"><span class="math">$v^2 = u^{2(x_2 + \\mathcal{H}_{hk}(u, e, L)x_3)}</span>$
and  <span class="math">u^{2x_1} = (\\frac{e}{h^m})^2</span> . (32)</p>

    <p class="text-gray-300">As usual we obtain two accepting conversation of the PK protocol in Step 3 and thus two answers</p>

    <p class="text-gray-300"><span class="math">$(\\tilde{x}_1^{(1)}, \\tilde{x}_2^{(1)}, \\tilde{x}_3^{(1)}, \\tilde{a}_1^{(1)}, \\dots, \\tilde{a}_6^{(1)}, \\tilde{b}_1^{(1)}, \\dots, \\tilde{b}_4^{(1)}, \\tilde{r}_1^{(1)}, \\dots, \\tilde{r}_4^{(1)}, \\tilde{s}_1^{(1)}, \\dots, \\tilde{s}_4^{(1)})</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$(\\tilde{x}_1^{(2)}, \\tilde{x}_2^{(2)}, \\tilde{x}_3^{(2)}, \\tilde{a}_1^{(2)}, \\dots, \\tilde{a}_4^{(2)}, \\tilde{b}_1^{(2)}, \\dots, \\tilde{b}_4^{(2)}, \\tilde{r}_1^{(2)}, \\dots, \\tilde{r}_4^{(2)}, \\tilde{s}_1^{(2)}, \\dots, \\tilde{s}_4^{(2)})</span>$</p>

    <p class="text-gray-300">for the two different challenges  <span class="math">c^{(1)}</span>  and  <span class="math">c^{(2)}</span>  but with the same first message (here we use the same notation for the protocol variables as for the PK protocol in the previous section and left out an intermediate step that deals with the  <span class="math">\\vee</span> 's (c.f. [CDS94])). W.l.o.g., suppose that  <span class="math">c^{(2)} &gt; c^{(1)}</span> . Let</p>

    <p class="text-gray-300"><span class="math">$\\Delta x_{i} = \\tilde{x}_{i}^{(1)} - \\tilde{x}_{i}^{(2)} \\ (i = 1, \\dots, 3); \\qquad \\Delta a_{i} = \\tilde{a}_{i}^{(1)} - \\tilde{a}_{i}^{(2)} \\ (i = 1, \\dots, 4);</span>$</p>

    <p class="text-gray-300"><span class="math">$\\Delta b_{i} = \\tilde{b}_{i}^{(1)} - \\tilde{b}_{i}^{(2)} \\ (i = 1, \\dots, 4); \\qquad \\Delta s_{i} = \\tilde{s}_{i}^{(1)} - \\tilde{s}_{i}^{(2)} \\ (i = 1, \\dots, 4);</span>$</p>

    <p class="text-gray-300"><span class="math">$\\Delta r_{i} = \\tilde{r}_{i}^{(1)} - \\tilde{r}_{i}^{(2)} \\ (i = 1, \\dots, 4); \\qquad \\Delta c = c^{(2)} - c^{(1)} \\ .</span>$</p>

    <p class="text-gray-300">From the verification equation of the PK protocol one can derive that</p>

    <p class="text-gray-300"><span class="math">$y_1^{\\Delta c} = g^{\\Delta x_1}</span>$
,  <span class="math">y_2^{\\Delta c} = g^{\\Delta x_2}</span> , and  <span class="math">y_3^{\\Delta c} = g^{\\Delta x_3}</span> , (33)</p>

    <p class="text-gray-300">hold and either</p>

    <p class="text-gray-300"><span class="math">$C_1^{\\Delta c} = u^{2n\\Delta r_1} (\\frac{1}{v})^{2n\\Delta a_1} , \\quad \\mathfrak{C}_1^{\\Delta c} = \\mathfrak{g}^{\\Delta a_1} \\mathfrak{h}^{\\Delta b_1} , \\quad \\text{and} \\quad 1 = (\\frac{1}{\\mathfrak{C}_1})^{\\Delta x_2 + \\mathcal{H}_{hk}(u,e,L)\\Delta x_3} \\mathfrak{g}^{\\Delta r_1} \\mathfrak{h}^{\\Delta s_1}</span>$
(34)</p>

    <p class="text-gray-300">or</p>

    <p class="text-gray-300"><span class="math">$C_2^{\\Delta c} = u^{2\\Delta r_2} (\\frac{1}{v})^{2\\Delta a_2} , \\qquad \\mathfrak{C}_2^{\\Delta c} = \\mathfrak{g}^{\\Delta a_2} \\mathfrak{h}^{\\Delta b_2} , \\quad \\text{and} \\quad 1 = (\\frac{1}{\\mathfrak{C}_2})^{\\Delta x_2 + \\mathcal{H}_{\\mathsf{hk}}(u,e,L)\\Delta x_3} \\mathfrak{g}^{\\Delta r_2} \\mathfrak{h}^{\\Delta s_2}</span>$
(35)</p>

    <p class="text-gray-300">or</p>

    <p class="text-gray-300"><span class="math">$C_3^{\\Delta c} = u^{2n\\Delta r_3} (\\frac{1}{e})^{2n\\Delta a_3} , \\quad \\mathfrak{C}_3^{\\Delta c} = \\mathfrak{g}^{\\Delta a_3} \\mathfrak{h}^{\\Delta b_3} , \\quad \\text{and} \\quad 1 = (\\frac{1}{\\mathfrak{C}_3})^{\\Delta x_1} \\mathfrak{g}^{\\Delta r_3} \\mathfrak{h}^{\\Delta s_3}</span>$
(36)</p>

    <p class="text-gray-300">or</p>

    <p class="text-gray-300"><span class="math">$C_4^{\\Delta c} = u^{2\\Delta r_4} (\\frac{1}{e})^{n\\Delta a_4} , \\qquad \\mathfrak{C}_4^{\\Delta c} = \\mathfrak{g}^{\\Delta a_4} \\mathfrak{h}^{\\Delta b_4} , \\quad \\text{and} \\quad 1 = (\\frac{1}{\\mathfrak{C}_4})^{\\Delta x_1} \\mathfrak{g}^{\\Delta r_4} \\mathfrak{h}^{\\Delta s_4}</span>$
(37)</p>

    <p class="text-gray-300">hold. We know x&lt;sup&gt;i&lt;/sup&gt; such that y&lt;sup&gt;i&lt;/sup&gt; = g &lt;sup&gt;x&lt;/sup&gt;&lt;sup&gt;i&lt;/sup&gt; and therefore it follows from (33) that</p>

    <p class="text-gray-300"><span class="math">$\\Delta c x_i \\equiv \\Delta x_i \\pmod{n&#x27;} \\quad \\text{for} \\quad i = 1, \\dots, 3 .</span>$
(38)</p>

    <p class="text-gray-300">We next consider the implications of the cases when the equations (34), the equations (35), the equations (36), or the equations (37) hold in conjunction with (33).</p>

    <p class="text-gray-300">Case 1. Consider the case where Equations (33) and (34) hold. From the last two equations of (34) we get</p>

    <p class="text-gray-300"><span class="math">$\\mathfrak{g}^{\\Delta a_1(\\Delta x_2 + \\mathcal{H}_{\\mathsf{hk}}(u,e,L)\\Delta x_3)}\\mathfrak{h}^{\\Delta b_1(\\Delta x_2 + \\mathcal{H}_{\\mathsf{hk}}(u,e,L)\\Delta x_3)} = \\mathfrak{g}^{\\Delta c\\Delta r_1}\\mathfrak{h}^{\\Delta c\\Delta s_1}</span>$</p>

    <p class="text-gray-300">Under the assumption that factoring n is hard, and applying Theorem 2, we may assume that</p>

    <p class="text-gray-300"><span class="math">$\\Delta a_1(\\Delta x_2 + \\mathcal{H}_{hk}(u, e, L)\\Delta x_3) = \\Delta c \\Delta r_1 . \\tag{39}</span>$</p>

    <p class="text-gray-300">.</p>

    <p class="text-gray-300">Because n is the product of two safe primes and we have |∆c| &lt; min{p, q, p&lt;sup&gt;0&lt;/sup&gt; q &lt;sup&gt;0&lt;/sup&gt;}, it follows from C 2 1 6= 1 (which is checked by the verifier in Step 3c) that C ∆c 1 6= 1. From the first equation of (34) it follows that u &lt;sup&gt;2&lt;/sup&gt;n∆r&lt;sup&gt;1&lt;/sup&gt; 6= v 2n∆a&lt;sup&gt;1&lt;/sup&gt; . By Eq. (39) and the fact that u &lt;sup&gt;2&lt;/sup&gt;&lt;sup&gt;n&lt;/sup&gt; and v &lt;sup&gt;2&lt;/sup&gt;&lt;sup&gt;n&lt;/sup&gt; have order dividing n 0 , we have</p>

    <p class="text-gray-300"><span class="math">$u^{2n\\Delta a_1(\\Delta x_2 + \\mathcal{H}_{hk}(u,e,L)\\Delta x_3)} \\neq v^{2n\\Delta c\\Delta a_1}</span>$</p>

    <p class="text-gray-300">and hence</p>

    <p class="text-gray-300"><span class="math">$u^{2n(\\Delta x_2 + \\mathcal{H}_{hk}(u,e,L)\\Delta x_3)} \\neq v^{2n\\Delta c} . \\tag{40}</span>$</p>

    <p class="text-gray-300">,</p>

    <p class="text-gray-300">From (40) and the first equation of (32) we have</p>

    <p class="text-gray-300"><span class="math">$u^{2n(\\Delta x_2 + \\mathcal{H}_{hk}(u,e,L)\\Delta x_3)} \\neq v^{2n\\Delta c} = u^{2n\\Delta c(x_2 + \\mathcal{H}_{hk}(u,e,L)x_3)}.</span>$</p>

    <p class="text-gray-300">Because the order of u &lt;sup&gt;2&lt;/sup&gt;&lt;sup&gt;n&lt;/sup&gt; divides n &lt;sup&gt;0&lt;/sup&gt; we can further conclude that</p>

    <p class="text-gray-300"><span class="math">$\\Delta x_2 + \\mathcal{H}_{\\mathsf{hk}}(u, e, L) \\Delta x_3 \\not\\equiv \\Delta c(x_2 + \\mathcal{H}_{\\mathsf{hk}}(u, e, L)x_3) \\pmod{n&#x27;}</span>$
.</p>

    <p class="text-gray-300">From (38) if follows that</p>

    <p class="text-gray-300"><span class="math">$\\Delta x_2 + \\mathcal{H}_{hk}(u, e, L)\\Delta x_3 \\equiv \\Delta c(x_2 + \\mathcal{H}_{hk}(u, e, L)x_3) \\pmod{n&#x27;}</span>$
,</p>

    <p class="text-gray-300">which is a contradiction to the previous equation and hence this case can not occur.</p>

    <p class="text-gray-300">Case 2. We consider the case where Equations (33) and (35) hold. Similarly as in case 1, we can derive that</p>

    <p class="text-gray-300"><span class="math">$u^{2(\\Delta x_2 + \\mathcal{H}_{hk}(u,e,L)\\Delta x_3)} \\neq v^{2\\Delta c} = u^{2\\Delta c(x_2 + \\mathcal{H}_{hk}(u,e,L)x_3)}</span>$</p>

    <p class="text-gray-300">holds (assuming n is hard to factor). Because the order of u &lt;sup&gt;2&lt;/sup&gt; divides n &lt;sup&gt;0&lt;/sup&gt;n we can further conclude that</p>

    <p class="text-gray-300"><span class="math">$\\Delta x_2 + \\mathcal{H}_{\\mathsf{hk}}(u, e, L) \\Delta x_3 \\not\\equiv \\Delta c(x_2 + \\mathcal{H}_{\\mathsf{hk}}(u, e, L)x_3) \\pmod{n&#x27;n}</span>$
.</p>

    <p class="text-gray-300">From (38) if follows that</p>

    <p class="text-gray-300"><span class="math">$\\Delta x_2 + \\mathcal{H}_{\\mathsf{hk}}(u, e, L) \\Delta x_3 \\equiv \\Delta c(x_2 + \\mathcal{H}_{\\mathsf{hk}}(u, e, L)x_3) \\pmod{n&#x27;}</span>$
.</p>

    <p class="text-gray-300">Therefore ∆cx&lt;sup&gt;2&lt;/sup&gt; − ∆x&lt;sup&gt;2&lt;/sup&gt; + (∆cx&lt;sup&gt;3&lt;/sup&gt; − ∆x3)Hhk(u, e, L) must be a non-zero multiple of n 0 , which would allow us to factor n, which is a contradiction.</p>

    <p class="text-gray-300">Case 3. Similarly as in case 1, from the Equations (33) and (36), one can derive that</p>

    <p class="text-gray-300"><span class="math">$u^{2n\\Delta x_1} \\neq e^{2n\\Delta c} \\tag{41}</span>$</p>

    <p class="text-gray-300">holds (or we factor n with non-negligible probability). From the second equation of (32) and h &lt;sup&gt;n&lt;/sup&gt; = 1 if follows that u &lt;sup&gt;2&lt;/sup&gt;nx&lt;sup&gt;1&lt;/sup&gt; = e &lt;sup&gt;2&lt;/sup&gt;&lt;sup&gt;n&lt;/sup&gt; and u &lt;sup&gt;2&lt;/sup&gt;n∆cx&lt;sup&gt;1&lt;/sup&gt; = e 2n∆c , and from (41), that</p>

    <p class="text-gray-300"><span class="math">$u^{2n\\Delta cx_1} \\neq u^{2n\\Delta x_1}</span>$
and finally that  <span class="math">\\Delta cx_1 \\not\\equiv \\Delta x_1 \\pmod{n&#x27;}</span></p>

    <p class="text-gray-300">as u &lt;sup&gt;2&lt;/sup&gt;&lt;sup&gt;n&lt;/sup&gt; has order dividing n 0 . The latter, however, is a contradiction to Eqn. (38) and thus this case can not occur.</p>

    <p class="text-gray-300">Case 4. Similarly as before, from the Equations (33) and (37) one can show that</p>

    <p class="text-gray-300"><span class="math">$u^{2\\Delta x_1} \\neq \\left(\\frac{e}{h^m}\\right)^{2\\Delta c} \\tag{42}</span>$</p>

    <p class="text-gray-300">holds (or we factor n with non-negligible probability). From the second equation of (32) and from (42) we get u 2∆cx&lt;sup&gt;1&lt;/sup&gt; 6= u 2∆x&lt;sup&gt;1&lt;/sup&gt; . Similarly as in case 2, it follows that ∆cx&lt;sup&gt;1&lt;/sup&gt; − ∆x&lt;sup&gt;1&lt;/sup&gt; is a multiple of n &lt;sup&gt;0&lt;/sup&gt; and we are again able to factor n.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">7.3 Verifiable Decryption of a Discrete Logarithm</h4>

    <p class="text-gray-300">We now describe how the protocol provided in the previous section can be modified to obtain a protocol for verifiable decryption of a discrete logarithm. The setting and notation are as in §5.2; in particular, we make use of the same reconstruction routine.</p>

    <p class="text-gray-300">We need to modify the protocol from the previous section only for the cases where the ciphertext is valid. That is, instead of proving that the ciphertext decrypts (or does not decrypt) to a given message, the decryptor now has to prove that it decrypts (or does not decrypt) to a value m such that  <span class="math">(m \\operatorname{rem} n) \\equiv \\log_{\\gamma} \\delta \\pmod{\\rho}</span> . This corresponds to proving whether or not the three equations</p>

    <p class="text-gray-300"><span class="math">$u^{2(x_2 + \\mathcal{H}_{hk}(u, e, L)x_3)}/v^2 = 1</span>$
or  <span class="math">(e/u^{x_1})^{2n} = 1</span>  or  <span class="math">\\delta = \\gamma^{(\\log_{h^2}(e/u^{x_1})^2 \\operatorname{rem} n)}</span>  (43)</p>

    <p class="text-gray-300">hold. Note that  <span class="math">\\log_{h^2}(e/u^{x_1})^2</span>  exists if and only if  <span class="math">(e/u^{x_1})^{2n}=1</span> . The first two statements of (43) can be handled as in the previous section. The last one can be handled by proving knowledge of a secret, say m, that (1) equals the encrypted message modulo n, (2) equals (or doesn't equal)  <span class="math">\\log_{\\gamma}\\delta</span>  modulo q, and (3) lies in the interval [-(n-1)/2,(n-1)/2]. The first two properties can be proved under the strong RSA assumption using additional parameters  <span class="math">(\\mathfrak{n},\\mathfrak{g},\\mathfrak{h})</span>  as in the previous section. We discuss proving the last one. Different from the interval-proof used for verifiable encryption, this interval-proof needs to be exact, i.e., if we allowed for the same sloppiness, then the prover could for instance add a multiple of n to m and then show that (u, e, v) does not (or does) decrypt to  <span class="math">\\log_{\\gamma}\\delta</span> .</p>

    <p class="text-gray-300">Boudot [Bou00] presents several protocols to prove that in integer m lies exactly in an interval [a, b]. One protocol uses the fact that  <span class="math">x \\in [a, b]</span>  is equivalent to  <span class="math">b - x \\ge 0</span>  and  <span class="math">x - a \\ge 0</span>  and that one can show that an integer is positive by proving knowledge of four values the squares of which sum up to the considered integer (in  <span class="math">\\mathbb{Z}</span> ), again under the strong RSA assumption using additional parameters  <span class="math">(\\mathfrak{n}, \\mathfrak{g}, \\mathfrak{h})</span> . Lagrange proved that an integer can always be represented as four squares and Rabin and Shallit [RS86] provide an efficient algorithm for finding such squares.</p>

    <p class="text-gray-300">We note that in our case the interval is symmetric and it therefore suffices to prove that  <span class="math">((n-1)/2)^2 - m^2 \\ge 0</span>  holds, which is more efficient.</p>

    <p class="text-gray-300">With these observations one can derive the following protocol for verifiable decryption of a discrete logarithm from the protocol presented in the previous section.</p>

    <p class="text-gray-300">The common input of the decryptor and the verifier is  <span class="math">(hk, n, g, y_1, y_2, y_3), (\\mathfrak{n}, \\mathfrak{g}, \\mathfrak{h}), (u, e, v), \\delta, L</span>  and the additional input to the decryptor is  <span class="math">(x_1, x_2, x_3)</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">\\delta \\notin \\Gamma</span>  or the ciphertext is malformed (e.g., if  <span class="math">v \\neq abs(v)</span> ), the verifier outputs -1, and the protocol stops.</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>In case (u, e, v) is a valid ciphertext w.r.t. label L, the prover decrypts it, thereby obtains m, and computes integers  <span class="math">w_1, \\ldots, w_4</span>  such that  <span class="math">\\sum_{i=1}^4 w_i = (n-1)^2/4 m^2</span>  (c.f. [RS86]).</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If (u, e, v) indeed decrypts to  <span class="math">\\log_{\\gamma} \\delta</span>  under label L, i.e., if  <span class="math">\\delta = \\gamma^{m \\text{ rem } n}</span> , the decryptor sends 1 to the verifier, chooses  <span class="math">t_1, \\ldots, t_5 \\in_R [\\mathfrak{n}/4]</span> , computes</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\mathfrak{W}_1 := \\mathfrak{g}^{w_1}\\mathfrak{h}^{t_1}, \\mathfrak{W}_2 := \\mathfrak{g}^{w_2}\\mathfrak{h}^{t_2}, \\mathfrak{W}_3 := \\mathfrak{g}^{w_3}\\mathfrak{h}^{t_3}, \\mathfrak{W}_4 := \\mathfrak{g}^{w_4}\\mathfrak{h}^{t_4}, \\text{ and } \\mathfrak{M} := \\mathfrak{g}^m\\mathfrak{h}^{t_5}</span>$
,</p>

    <p class="text-gray-300">and sends  <span class="math">\\mathfrak{W}_1</span> ,  <span class="math">\\mathfrak{W}_2</span> ,  <span class="math">\\mathfrak{W}_3</span> ,  <span class="math">\\mathfrak{W}_4</span> , and  <span class="math">\\mathfrak{M}</span>  to the verifier.</p>

    <p class="text-gray-300">The prover and the verifier engage in the protocol</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} PK\\{(x_1,x_2,x_3,m,w_1,\\dots,w_4,t_1,\\dots,t_5,s): \\\\ y_1 &amp;= g^{x_1} \\ \\land \\ y_2 = g^{x_2} \\ \\land \\ y_3 = g^{x_3} \\ \\land \\\\ v^2 &amp;= u^{2x_2}u^{2\\mathcal{H}_{\\mathsf{hk}}(u,e,L)x_3} \\ \\land \\ e^2 = u^{2x_1}h^{2m} \\ \\land \\\\ \\mathfrak{W}_1 &amp;= \\mathfrak{g}^{w_1}\\mathfrak{h}^{t_1} \\ \\land \\ \\mathfrak{W}_2 = \\mathfrak{g}^{w_2}\\mathfrak{h}^{t_2} \\ \\land \\ \\mathfrak{W}_3 = \\mathfrak{g}^{w_3}\\mathfrak{h}^{t_3} \\ \\land \\ \\mathfrak{W}_4 = \\mathfrak{g}^{w_4}\\mathfrak{h}^{t_4} \\ \\land \\\\ \\mathfrak{M} &amp;= \\mathfrak{g}^m\\mathfrak{h}^{t_5} \\ \\land \\ \\mathfrak{g}^{(n-1)^2/4} = \\mathfrak{M}^m\\mathfrak{W}_1^{w_1}\\mathfrak{W}_2^{w_2}\\mathfrak{W}_3^{w_3}\\mathfrak{W}_4^{w_4}\\mathfrak{h}^s \\ \\land \\\\ \\delta &amp;= \\gamma^m\\} \\ , \\end{split}</span>$</p>

    <p class="text-gray-300">where s is a temporary secret (i.e.,  <span class="math">s = -t_5 m - \\sum_{i=1}^4 w_i t_i</span> ).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If (u, e, v) is an invalid ciphertext w.r.t. the label L or decrypts to some message m such that  <span class="math">\\delta \\neq \\gamma^{m \\text{ rem } n}</span> , then the decryptor sends -1 to the verifier. They proceed as follows.</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) The decryptor chooses  <span class="math">a_1 \\in_R [n/4]</span>   <span class="math">a_2 \\in_R [n^2/4]</span> ,  <span class="math">a_3 \\in_R [n/4]</span> , and  <span class="math">a_4 \\in_R [\\rho]</span> , along with  <span class="math">b_1, \\ldots, b_3, t_1, \\ldots, t_5 \\in_R [\\mathfrak{n}/4]</span> . She computes  <span class="math">\\mathfrak{C}_1 := \\mathfrak{g}^{a_1}\\mathfrak{h}^{b_1}</span> ,  <span class="math">\\mathfrak{C}_2 := \\mathfrak{g}^{a_2}\\mathfrak{h}^{b_2}</span> ,  <span class="math">\\mathfrak{C}_3 := \\mathfrak{g}^{a_3}\\mathfrak{h}^{b_3}</span> , and  <span class="math">\\mathfrak{C}_4 := \\mathfrak{g}^{a_4}\\mathfrak{h}^{b_4}</span> . She computes  <span class="math">\\mathfrak{W}_1 := \\mathfrak{h}^{t_1}</span> ,  <span class="math">\\mathfrak{W}_2 := \\mathfrak{h}^{t_2}</span> ,  <span class="math">\\mathfrak{W}_3 := \\mathfrak{h}^{t_3}</span> ,  <span class="math">\\mathfrak{W}_4 := \\mathfrak{h}^{t_4}</span> , and  <span class="math">\\mathfrak{M} := \\mathfrak{h}^{t_5}</span> . She chooses  <span class="math">C_1 \\in_R \\mathbf{G}_{n&#x27;}</span> ,  <span class="math">C_2 \\in_R \\mathbf{G}_n</span> ,  <span class="math">C_3 \\in_R \\mathbf{G}_{n&#x27;}</span> , and  <span class="math">C_4 \\in_R \\Gamma</span> . Furthermore,</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">(Case 1) if
<span class="math">$u^{2n(x_2+\\mathcal{H}_{hk}(u,e,L)x_3)} \\neq v^{2n}</span>$
, she sets  <span class="math">C_1 := (u^{x_2+\\mathcal{H}_{hk}(u,e,L)x_3}/v)^{2na_1}</span> ,
(Case 2) else if  <span class="math">u^{2(x_2+\\mathcal{H}_{hk}(u,e,L)x_3)} \\neq v^2</span> , she sets  <span class="math">C_2 := (u^{x_2+\\mathcal{H}_{hk}(u,e,L)x_3}/v)^{2a_2}</span> ,
(Case 3) else if  <span class="math">(u^{x_1}/e)^2 \\notin \\langle h \\rangle</span> , she sets  <span class="math">C_3 := (u^{x_1}/e)^{2na_3}</span> ,
(Case 4) else  <span class="math">\\delta \\neq \\gamma^{m \\text{ rem } n}</span> , and she sets  <span class="math">C_4 := (\\gamma^m/\\delta)^{a_4}</span> ,
<span class="math">\\mathfrak{W}_i := \\mathfrak{g}^{w_i}\\mathfrak{h}^{t_i} \\ (i = 1, \\dots, 4)</span> , and
<span class="math">\\mathfrak{M} := \\mathfrak{g}^m\\mathfrak{h}^{t_5}</span> .</p>

    <p class="text-gray-300">The decryptor sends  <span class="math">C_1</span> ,  <span class="math">C_2</span> ,  <span class="math">C_3</span> ,  <span class="math">C_4</span> ,  <span class="math">\\mathfrak{C}_1</span> ,  <span class="math">\\mathfrak{C}_2</span> ,  <span class="math">\\mathfrak{C}_3</span> , and  <span class="math">\\mathfrak{C}_4</span>  to the verifier.</p>

    <p class="text-gray-300">(b) The decryptor and the verifier carry out the protocol denoted</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} PK\\Big\\{ &amp;(x_1,x_2,x_3,\\,a_1,\\ldots,a_4,\\,b_1,\\ldots,b_4,\\,r_1,\\ldots,r_4\\,s_1,\\ldots,s_5,t_1,\\ldots,t_5,w_1,\\ldots,w_4,m) : \\\\ &amp; \\Big[y_1=g^{x_1} \\ \\land \\ y_2=g^{x_2} \\ \\land \\ y_3=g^{x_3} \\ \\land \\\\ &amp; C_1=u^{2nr_1}(\\frac{1}{v})^{2na_1} \\ \\land \\ \\mathfrak{C}_1=\\mathfrak{g}^{a_1}\\mathfrak{h}^{b_1} \\ \\land \\ 1=(\\frac{1}{\\mathfrak{C}_1})^{x_2}(\\frac{1}{\\mathfrak{C}_1})^{\\mathcal{H}_{hk}(u,e,L)x_3}\\mathfrak{g}^{r_1}\\mathfrak{h}^{s_1}\\Big] \\\\ &amp; \\vee \\Big[y_1=g^{x_1} \\ \\land \\ y_2=g^{x_2} \\ \\land \\ y_3=g^{x_3} \\ \\land \\\\ &amp; C_2=u^{2r_2}(\\frac{1}{v})^{a_2} \\ \\land \\ \\mathfrak{C}_2=\\mathfrak{g}^{a_2}\\mathfrak{h}^{b_2} \\ \\land \\ 1=(\\frac{1}{\\mathfrak{C}_2})^{x_2}(\\frac{1}{\\mathfrak{C}_2})^{\\mathcal{H}_{hk}(u,e,L)x_3}\\mathfrak{g}^{r_2}\\mathfrak{h}^{s_2}\\Big] \\\\ &amp; \\vee \\Big[y_1=g^{x_1} \\ \\land \\ y_2=g^{x_2} \\ \\land \\ y_3=g^{x_3} \\ \\land \\\\ &amp; C_3=u^{2nr_3}(\\frac{1}{e})^{2na_3} \\ \\land \\ \\mathfrak{C}_3=\\mathfrak{g}^{a_3}\\mathfrak{h}^{b_3} \\ \\land \\ 1=(\\frac{1}{\\mathfrak{C}_3})^{x_1}\\mathfrak{g}^{r_3}\\mathfrak{h}^{s_3}\\Big] \\\\ &amp; \\vee \\Big[y_1=g^{x_1} \\ \\land \\ y_2=g^{x_2} \\ \\land \\ y_3=g^{x_3} \\ \\land \\\\ &amp; \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad</span>$</p>

    <p class="text-gray-300">where  <span class="math">r_1, \\ldots, r_4, s_1, \\ldots, s_4</span>  are temporary secrets (i.e.,</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} r_1 &amp;= a_1(x_2 + \\mathcal{H}_{\\mathsf{hk}}(u, e, L)x_3), &amp; s_1 &amp;= b_1(x_2 + \\mathcal{H}_{\\mathsf{hk}}(u, e, L)x_3), \\\\ r_2 &amp;= a_2(x_2 + \\mathcal{H}_{\\mathsf{hk}}(u, e, L)x_3), &amp; s_2 &amp;= b_2(x_2 + \\mathcal{H}_{\\mathsf{hk}}(u, e, L)x_3), \\\\ r_3 &amp;= x_1a_3, &amp; s_3 &amp;= x_1b_3, \\\\ r_4 &amp;= ma_4, &amp; s_4 &amp;= mb_4, \\\\ &amp; s_5 &amp;= -t_5m - \\sum_{i=1}^4 w_it_i. \\end{split}</span>$</p>

    <p class="text-gray-300">(computed in  <span class="math">\\mathbb{Z}</span> )). (To derive the actual protocol one has to apply the techniques by Cramer et al.[CDS94] for realizing the  <span class="math">\\vee</span> 's.)</p>

    <p class="text-gray-300">(c) The verifier checks that  <span class="math">C_1^2 \\neq 1</span> ,  <span class="math">C_2^2 \\neq 1</span> ,  <span class="math">C_3^2 \\neq 1</span> , and  <span class="math">C_4 \\neq 1</span> .</p>

    <p class="text-gray-300"><strong>Theorem 7.</strong> Under the strong RSA assumption, the above scheme is a verifiable decryption scheme (for discrete logarithms).</p>

    <p class="text-gray-300"><em>Proof.</em> One needs to prove soundness, correctness and special honest-verifier zero-knowledge w.r.t. an oracle  <span class="math">f&#x27;(\\delta, \\psi, L, \\mathsf{SK})</span>  that replies with 1 if  <span class="math">\\delta = \\gamma^{\\hat{m}}</span>  where  <span class="math">\\hat{m} = \\mathcal{D}(\\mathsf{SK}, \\psi, L)</span>  rem n, or with -1 otherwise.</p>

    <p class="text-gray-300">The following proof is very similar to the one of Theorem 6.</p>

    <p class="text-gray-300">Correctness is by inspection.</p>

    <p class="text-gray-300">We now show that the whole protocol is special honest-verifier computational zero-knowledge by providing a simulator. First the simulator executes Step 1 of the protocol as the decryptor would, that is, if  <span class="math">\\delta \\notin \\Gamma</span>  or  <span class="math">v \\neq \\operatorname{abs}(v)</span>  it and stops. Otherwise, the simulator chooses random integers  <span class="math">m, w_1, \\ldots, w_4 \\in R</span>  [-n/2, n/2].</p>

    <p class="text-gray-300">If  <span class="math">f&#x27;(\\delta, \\psi, L, \\mathsf{SK}) = 1</span> , it simulates step 2 as follows. It chooses  <span class="math">t_1, \\ldots, t_5 \\in_R [\\mathfrak{n}/4]</span>  and computes  <span class="math">\\mathfrak{W}_1 := \\mathfrak{h}^{t_1}, \\mathfrak{W}_2 := \\mathfrak{h}^{t_2}, \\mathfrak{W}_3 := \\mathfrak{h}^{t_3}, \\mathfrak{W}_4 := \\mathfrak{h}^{t_4}</span> , and  <span class="math">\\mathfrak{M} := \\mathfrak{h}^{t_5}</span> . Then it sends the values  <span class="math">\\mathfrak{W}_1, \\ldots, \\mathfrak{W}_4</span> , and  <span class="math">\\mathfrak{M}</span>  to the verifier and finally invokes the simulator for the PK-protocol of step 2.</p>

    <p class="text-gray-300">If  <span class="math">f&#x27;(\\delta, \\psi, L, \\mathsf{SK}) = 1</span> , it simulates step 3 as follows. The simulator chooses  <span class="math">b_1, b_2, b_3, b_3 \\in_R t_1, \\ldots, t_5[\\mathfrak{n}/4]</span> . It then computes  <span class="math">\\mathfrak{C}_1 := \\mathfrak{h}^{b_1}</span> ,  <span class="math">\\mathfrak{C}_2 := \\mathfrak{h}^{b_2}</span> ,  <span class="math">\\mathfrak{C}_3 := \\mathfrak{h}^{b_3}</span> ,  <span class="math">\\mathfrak{C}_4 := \\mathfrak{h}^{b_4}</span> ,  <span class="math">\\mathfrak{W}_1 := \\mathfrak{h}^{t_1}</span> ,  <span class="math">\\mathfrak{W}_2 := \\mathfrak{h}^{t_2}</span> ,  <span class="math">\\mathfrak{W}_3 := \\mathfrak{h}^{t_3}</span> ,  <span class="math">\\mathfrak{W}_4 := \\mathfrak{h}^{t_4}</span> , and  <span class="math">\\mathfrak{M} := \\mathfrak{h}^{t_5}</span> . It chooses  <span class="math">C_1 \\in_R \\mathbf{G}_{n&#x27;}</span> ,  <span class="math">C_2 \\in_R \\mathbf{G}_{n}</span> ,  <span class="math">C_3 \\in_R \\mathbf{G}_{n&#x27;}</span> , and  <span class="math">C_4 \\in_R \\Gamma</span> . It finally invokes the simulator for the PK-protocol of step 3. This concludes the simulator.</p>

    <p class="text-gray-300">The argument that this simulation actually works is rather similar to the one given in the proof of Theorem 6.</p>

    <p class="text-gray-300">In the remainder we prove soundness. Let us generate a public keys and secret keys according to the usual algorithms, obtaining</p>

    <p class="text-gray-300"><span class="math">$n, g, y_1, y_2, y_3, x_1, x_2, x_3, \\mathfrak{n}, \\mathfrak{g}, \\mathfrak{h}</span>$</p>

    <p class="text-gray-300">All of this information is available to the adversary, who produces  <span class="math">\\delta, \\psi, L</span> , and is able to make the verifier accept on these inputs with non-negligible probability. By standard rewinding techniques we can produce two accepting conversations for either the PK protocol in Step 2 or the one in Step 3 (for different challenges but the same first message), depending on whether  <span class="math">\\delta = \\gamma^{\\hat{m}}</span> , where  <span class="math">\\hat{m} = \\mathcal{D}(\\mathsf{SK}, \\psi, L) \\operatorname{rem} n</span> , for  <span class="math">(\\delta, \\psi, L)</span>  provided by  <span class="math">\\mathcal{A}^*</span> . We consider these two cases.</p>

    <p class="text-gray-300">Case I. First assume that  <span class="math">\\delta \\neq \\gamma^{\\hat{m}}</span>  or reject  <span class="math">= \\mathcal{D}(\\mathsf{SK}, \\psi, L)</span>  but that V's output is 1. Let  <span class="math">(u, e, v) := \\psi</span> . We can now get two accepting conversations of the PK protocol in Step 2 and hence two answers</p>

    <p class="text-gray-300"><span class="math">$(\\tilde{x}_1^{(1)}, \\tilde{x}_2^{(1)}, \\tilde{x}_3^{(1)}, \\tilde{m}^{(1)}, \\tilde{w}_1^{(1)}, \\dots, \\tilde{w}_4^{(1)}, \\tilde{t}_1^{(1)}, \\dots, \\tilde{t}_5^{(1)}, \\tilde{s}^{(1)})</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$(\\tilde{x}_1^{(2)}, \\tilde{x}_2^{(2)}, \\tilde{x}_3^{(2)}, \\tilde{m}^{(2)}, \\tilde{w}_1^{(2)}, \\dots, \\tilde{w}_4^{(2)}, \\tilde{t}_1^{(2)}, \\dots, \\tilde{t}_5^{(2)}, \\tilde{s}^{(2)})</span>$</p>

    <p class="text-gray-300">for the two different challenges  <span class="math">c^{(1)}</span>  and  <span class="math">c^{(2)}</span>  but with the same first message (here we use the same notation for the protocol variables as for the PK protocol in the previous section). W.l.o.g., suppose that  <span class="math">c^{(2)} &gt; c^{(1)}</span> . Let  <span class="math">\\Delta x_1 = \\tilde{x}_1^{(1)} - \\tilde{x}_1^{(2)}</span> ,  <span class="math">\\Delta x_2 = \\tilde{x}_2^{(1)} - \\tilde{x}_2^{(2)}</span> ,  <span class="math">\\Delta x_3 = \\tilde{x}_3^{(1)} - \\tilde{x}_3^{(2)}</span> ,  <span class="math">\\Delta m = \\tilde{m}^{(1)} - \\tilde{m}^{(2)}</span> ,  <span class="math">\\Delta w_1 = \\tilde{w}_1^{(1)} - \\tilde{w}_1^{(2)}</span> , ...,  <span class="math">\\Delta w_4 = \\tilde{w}_4^{(1)} - \\tilde{w}_4^{(2)}</span> ,  <span class="math">\\Delta t_1 = \\tilde{t}_1^{(1)} - \\tilde{t}_1^{(2)}</span> , ...,  <span class="math">\\Delta t_5 = \\tilde{t}_5^{(1)} - \\tilde{t}_5^{(2)}</span> ,  <span class="math">\\Delta s = \\tilde{s}^{(1)} - \\tilde{s}^{(2)}</span> , and  <span class="math">\\Delta c = c^{(2)} - c^{(1)}</span> . From the verification equation of the PK protocol one can derive the following equations:</p>

    <p class="text-gray-300"><span class="math">$y_1^{\\Delta c} = g^{\\Delta x_1}</span>$
<span class="math">y_2^{\\Delta c} = g^{\\Delta x_2}</span>   <span class="math">y_3^{\\Delta c} = g^{\\Delta x_3}</span>  (44)</p>

    <p class="text-gray-300"><span class="math">$v^{2\\Delta c} = u^{2\\Delta x_2} u^{2\\mathcal{H}_{hk}(u,e,L)\\Delta x_3} \\tag{45}</span>$</p>

    <p class="text-gray-300"><span class="math">$e^{2\\Delta c} = u^{2\\Delta x_1} h^{2\\Delta m} \\tag{46}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\mathfrak{W}_{1}^{\\Delta c} = \\mathfrak{g}^{\\Delta w_{1}} \\mathfrak{h}^{\\Delta t_{1}} \\qquad \\mathfrak{W}_{2}^{\\Delta c} = \\mathfrak{g}^{\\Delta w_{2}} \\mathfrak{h}^{\\Delta t_{2}} \\qquad \\mathfrak{W}_{3}^{\\Delta c} = \\mathfrak{g}^{\\Delta w_{3}} \\mathfrak{h}^{\\Delta t_{3}} \\qquad \\mathfrak{W}_{4}^{\\Delta c} = \\mathfrak{g}^{\\Delta w_{4}} \\mathfrak{h}^{\\Delta t_{4}}</span>$
(47)</p>

    <p class="text-gray-300"><span class="math">$\\mathfrak{M}^{\\Delta c} = \\mathfrak{g}^{\\Delta m} \\mathfrak{h}^{\\Delta t_5} \\qquad \\qquad \\mathfrak{g}^{\\Delta c(n-1)^2/4} = \\mathfrak{M}^{\\Delta m} \\mathfrak{W}_1^{\\Delta w_1} \\mathfrak{W}_2^{\\Delta w_2} \\mathfrak{W}_3^{\\Delta w_3} \\mathfrak{W}_4^{\\Delta w_4} \\mathfrak{h}^{\\Delta s}</span>$
(48)</p>

    <p class="text-gray-300"><span class="math">$\\delta^{\\Delta c} = \\gamma^{\\Delta m} \\tag{49}</span>$</p>

    <p class="text-gray-300">Consider the equations (47) and (48). Under the strong RSA assumption, and using Theorem 3, we may assume that  <span class="math">\\Delta c</span>  divides each of  <span class="math">\\Delta m</span> ,  <span class="math">\\Delta w_1</span> , ...,  <span class="math">\\Delta w_4</span> ,  <span class="math">\\Delta t_1</span> , ...,  <span class="math">\\Delta t_5</span> , and  <span class="math">\\Delta s</span> . So we compute  <span class="math">\\hat{m} = \\Delta m/\\Delta c</span> ,  <span class="math">\\hat{w}_1 = \\Delta w_1/\\Delta c</span> , ...,  <span class="math">\\hat{w}_4 = \\Delta w_4/\\Delta c</span> ,  <span class="math">\\hat{t}_1 = \\Delta t_1/\\Delta c</span> , ...,  <span class="math">\\hat{t}_5 = \\Delta t_5/\\Delta c</span> , and  <span class="math">\\hat{s} = \\Delta s/\\Delta c</span>  and we know that</p>

    <p class="text-gray-300"><span class="math">$\\mathfrak{M}=\\mathfrak{m}\\mathfrak{g}^{\\hat{m}}\\mathfrak{h}^{\\hat{t}_{\\hat{5}}}\\quad \\mathfrak{W}_{1}=\\mathfrak{w}_{1}\\mathfrak{g}^{\\hat{w}_{1}}\\mathfrak{h}^{\\hat{t}_{1}}\\quad \\mathfrak{W}_{2}=\\mathfrak{w}_{2}\\mathfrak{g}^{\\hat{w}_{2}}\\mathfrak{h}^{\\hat{t}_{2}}\\quad \\mathfrak{W}_{3}=\\mathfrak{w}_{3}\\mathfrak{g}^{\\hat{w}_{3}}\\mathfrak{h}^{\\hat{t}_{3}}\\quad \\mathfrak{W}_{4}=\\mathfrak{w}_{4}\\mathfrak{g}^{\\hat{w}_{4}}\\mathfrak{h}^{\\hat{t}_{4}}\\quad \\delta=\\gamma^{\\hat{m}}</span>$</p>

    <p class="text-gray-300"><span class="math">$(50)</span>$</p>

    <p class="text-gray-300">holds for some  <span class="math">\\mathfrak{m}</span> ,  <span class="math">\\mathfrak{w}_1</span> ,  <span class="math">\\mathfrak{w}_2</span> ,  <span class="math">\\mathfrak{w}_3</span> , and  <span class="math">\\mathfrak{w}_4</span>  such that  <span class="math">\\mathfrak{m}^2 = 1</span>  and  <span class="math">\\mathfrak{w}_i^2 = 1</span> . Furthermore, we can rewrite the second equation of (48) as follows</p>

    <p class="text-gray-300"><span class="math">$\\mathfrak{g}^{(n-1)^2/4} = \\mathfrak{a}\\mathfrak{g}^{\\hat{m}^2 + \\sum \\hat{w}_i^2} \\mathfrak{h}^{\\hat{m}\\hat{t}_5 + \\sum \\hat{w}_i\\hat{t}_i + \\hat{s}}</span>$
(51)</p>

    <p class="text-gray-300">for some  <span class="math">\\mathfrak{a}</span>  such that  <span class="math">\\mathfrak{a}^2 = 1</span> . In fact,  <span class="math">\\mathfrak{a} = 1</span>  as, first,  <span class="math">\\mathfrak{a}</span>  must lie in  <span class="math">\\langle \\mathfrak{g} \\rangle</span>  and, second, if  <span class="math">\\mathfrak{a} \\neq \\pm 1</span>  then  <span class="math">\\gcd(\\mathfrak{a} - 1, \\mathfrak{n})</span>  splits  <span class="math">\\mathfrak{n}</span> . Applying Theorem 2, we may assume that</p>

    <p class="text-gray-300"><span class="math">$(n-1)^2/4 = \\hat{m}^2 + \\hat{w}_1^2 + \\hat{w}_2^2 + \\hat{w}_3^2 + \\hat{w}_4^2</span>$</p>

    <p class="text-gray-300">and thus  <span class="math">(n-1)^2/4 - \\hat{m}^2 \\ge 0</span>  which is equivalent to</p>

    <p class="text-gray-300"><span class="math">$-(n-1)/2 \\le \\hat{m} \\le (n-1)/2 . \\tag{52}</span>$</p>

    <p class="text-gray-300">Consider Equations (44-46). As n is the product of two safe primes p and q, we have  <span class="math">|\\Delta c| &lt; \\min\\{p, q, p&#x27;q&#x27;\\}</span>  and hence  <span class="math">\\Delta c</span>  is invertible modulo n'n. By construction we know  <span class="math">x_i</span>  such that  <span class="math">y_i = g^{x_i}</span>  and therefore it follows from (44) that</p>

    <p class="text-gray-300"><span class="math">$\\Delta c x_i \\equiv \\Delta x_i \\pmod{n&#x27;} \\quad \\text{for} \\quad i = 1, \\dots, 3 \\ .</span>$
(53)</p>

    <p class="text-gray-300">Now we can either have  <span class="math">\\mathcal{D}(\\mathsf{SK}, \\psi, L) = \\mathsf{reject}</span>  or  <span class="math">\\delta \\neq \\gamma^{(m \\, \\mathrm{rem} \\, n)}</span>  where  <span class="math">m = \\mathcal{D}(\\mathsf{SK}, \\psi, L) = \\log_{h^2}(e/u^{x_1})^2</span> , i.e., one of the three statements</p>

    <p class="text-gray-300"><span class="math">$u^{2(x_2 + \\mathcal{H}_{hk}(u, e, L)x_3)}/v^2 \\neq 1</span>$
or  <span class="math">(e/u^{x_1})^{2n} \\neq 1</span>  or  <span class="math">(\\frac{e}{u^{x_1}})^2 \\neq h^{2\\hat{m}}</span>  (54)</p>

    <p class="text-gray-300">must hold (cf. (43)), where the last is equivalent to  <span class="math">\\delta \\neq \\gamma^{(m \\text{ rem } n)}</span>  because of Equations (49) and (52) and the fact that  <span class="math">-(n-1)/2 \\leq (m \\text{ rem } n) \\leq (n-1)/2</span> .</p>

    <p class="text-gray-300">We consider these three cases:</p>

    <p class="text-gray-300">Case 1. If  <span class="math">u^{2(x_2+\\mathcal{H}_{hk}(u,e,L)x_3)} \\neq v^2</span>  we must have that  <span class="math">u^{2\\Delta c(x_2+\\mathcal{H}_{hk}(u,e,L)x_3)} \\neq v^{2\\Delta c} = u^{2\\Delta x_2+\\mathcal{H}_{hk}(u,e,L)\\Delta x_3}</span>  (from Equation (45) and because  <span class="math">\\Delta c</span>  is invertible modulo nn') and therefore also</p>

    <p class="text-gray-300"><span class="math">$\\Delta c(x_2 + \\mathcal{H}_{hk}(u, e, L)x_3) \\not\\equiv \\Delta x_2 + \\mathcal{H}_{hk}(u, e, L)\\Delta x_3 \\pmod{n&#x27;n}</span>$
,</p>

    <p class="text-gray-300">as the order of  <span class="math">u^2</span>  divides n'n. From (53) it follows that</p>

    <p class="text-gray-300"><span class="math">$\\Delta c(x_2 + \\mathcal{H}_{\\mathsf{bk}}(u, e, L)x_3) \\equiv \\Delta x_2 + \\mathcal{H}_{\\mathsf{bk}}(u, e, L)\\Delta x_3 \\pmod{n&#x27;}</span>$
.</p>

    <p class="text-gray-300">Therefore  <span class="math">\\Delta cx_2 - \\Delta x_2 + (\\Delta cx_3 - \\Delta x_3)\\mathcal{H}_{hk}(u, e, L)</span>  must be a non-zero multiple of n' and we can factor n, a contradiction.</p>

    <p class="text-gray-300">Case 2. If  <span class="math">u^{2nx_1} \\neq e^{2n}</span>  we have that  <span class="math">u^{2n\\Delta cx_1} \\neq e^{2n\\Delta c}</span> . Because of (46) and  <span class="math">h^n = 1</span> , we get  <span class="math">u^{2n\\Delta cx_1} \\neq u^{2n\\Delta cx_1} \\neq u^{2n\\Delta cx_1}</span>  and thus  <span class="math">\\Delta cx_1 \\not\\equiv \\Delta x_1 \\pmod{n&#x27;}</span> ,</p>

    <p class="text-gray-300">because  <span class="math">u^{2n}</span>  has order dividing n'. The latter, however, is a contradiction to Eqn. (53) and thus this case can not occur.</p>

    <p class="text-gray-300">Case 3. The inequality  <span class="math">(\\frac{e}{u^{x_1}})^2 \\neq h^{2\\hat{m}}</span>  is equivalent to  <span class="math">(\\frac{e}{h^{\\hat{m}}})^2 \\neq u^{2x_1}</span> . Recalling that  <span class="math">\\hat{m}\\Delta c = \\Delta m</span>  we can rewrite (46) as</p>

    <p class="text-gray-300"><span class="math">$\\left(\\frac{e^{\\Delta c}}{h^{\\Delta m}}\\right)^2 = \\left(\\frac{e}{h^{\\hat{m}}}\\right)^{2\\Delta c} = u^{2\\Delta x_1}</span>$
and conclude that  <span class="math">u^{2\\Delta c x_1} \\neq u^{2\\Delta x_1}</span> .</p>

    <p class="text-gray-300">Similarly to case 1, it follows that  <span class="math">\\Delta cx_1 - \\Delta x_1</span>  is a multiple of n' and we are again able to factor n, a contradiction.</p>

    <p class="text-gray-300">Case II. It remains to consider the case when V's output is -1 but  <span class="math">\\delta = \\gamma^{(\\mathcal{D}(\\mathsf{SK},\\psi,L)\\,\\mathrm{rem}\\,n)}</span>  holds. Let  <span class="math">(u,e,v) := \\psi</span> . Now all the three equations</p>

    <p class="text-gray-300"><span class="math">$u^{2(x_2 + \\mathcal{H}_{hk}(u, e, L)x_3)}/v^2 = 1 \\qquad (e/u^{x_1})^{2n} = 1 \\qquad \\delta = \\gamma^{(\\log_{h^2}(e/u^{x_1})^2 \\operatorname{rem} n)}</span>$
(55)</p>

    <p class="text-gray-300">must hold. As usual we obtain two accepting conversation of the PK protocol in Step 3 and thus two answers</p>

    <p class="text-gray-300"><span class="math">$(\\tilde{x}_1^{(1)}, \\tilde{x}_2^{(1)}, \\tilde{x}_3^{(1)}, \\tilde{a}_1^{(1)}, \\dots, \\tilde{a}_4^{(1)}, \\tilde{b}_1^{(1)}, \\dots, \\tilde{b}_4^{(1)}, \\tilde{r}_1^{(1)}, \\dots, \\tilde{r}_4^{(1)}, \\tilde{s}_1^{(1)}, \\dots, \\tilde{s}_5^{(1)}, \\tilde{t}_1^{(1)}, \\dots, \\tilde{t}_5^{(1)}, \\tilde{w}_1^{(1)}, \\dots, \\tilde{w}_4^{(1)}, \\tilde{m}_1^{(1)})</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$(\\tilde{x}_1^{(2)}, \\tilde{x}_2^{(2)}, \\tilde{x}_3^{(2)}, \\tilde{a}_1^{(2)}, \\dots, \\tilde{a}_4^{(2)}, \\tilde{b}_1^{(2)}, \\dots, \\tilde{b}_4^{(2)}, \\tilde{r}_1^{(2)}, \\dots, \\tilde{r}_4^{(2)}, \\tilde{s}_1^{(2)}, \\dots, \\tilde{s}_5^{(2)}, \\tilde{t}_1^{(2)}, \\dots, \\tilde{t}_5^{(2)}, \\tilde{w}_1^{(2)}, \\dots, \\tilde{w}_4^{(2)}, \\tilde{m}_1^{(2)})</span>$</p>

    <p class="text-gray-300">for the two different challenges  <span class="math">c^{(1)}</span>  and  <span class="math">c^{(2)}</span>  but with the same first message (here we use the same notation for the protocol variables as for the PK protocol in the previous section and left out an intermediate step that deals with the  <span class="math">\\vee</span> 's (c.f. [CDS94])). W.l.o.g., suppose that  <span class="math">c^{(2)} &gt; c^{(1)}</span> . Let</p>

    <p class="text-gray-300"><span class="math">$\\Delta x_{i} = \\tilde{x}_{i}^{(1)} - \\tilde{x}_{i}^{(2)} \\ (i = 1, \\dots, 3); \\qquad \\Delta a_{i} = \\tilde{a}_{i}^{(1)} - \\tilde{a}_{i}^{(2)} \\ (i = 1, \\dots, 4);</span>$</p>

    <p class="text-gray-300"><span class="math">$\\Delta b_{i} = \\tilde{b}_{i}^{(1)} - \\tilde{b}_{i}^{(2)} \\ (i = 1, \\dots, 4); \\qquad \\Delta r_{i} = \\tilde{r}_{i}^{(1)} - \\tilde{r}_{i}^{(2)} \\ (i = 1, \\dots, 4);</span>$</p>

    <p class="text-gray-300"><span class="math">$\\Delta s_{i} = \\tilde{s}_{i}^{(1)} - \\tilde{s}_{i}^{(2)} \\ (i = 1, \\dots, 5); \\qquad \\Delta t_{i} = \\tilde{t}_{i}^{(1)} - \\tilde{t}_{i}^{(2)} \\ (i = 1, \\dots, 5);</span>$</p>

    <p class="text-gray-300"><span class="math">$\\Delta w_{i} = \\tilde{w}_{i}^{(1)} - \\tilde{w}_{i}^{(2)} \\ (i = 1, \\dots, 4); \\qquad \\Delta m = m^{(1)} - c^{(2)};</span>$</p>

    <p class="text-gray-300"><span class="math">$\\Delta c = c^{(2)} - c^{(1)}.</span>$</p>

    <p class="text-gray-300">From the verification equation of the PK protocol one can derive that</p>

    <p class="text-gray-300"><span class="math">$y_1^{\\Delta c} = g^{\\Delta x_1}</span>$
,  <span class="math">y_2^{\\Delta c} = g^{\\Delta x_2}</span> , and  <span class="math">y_3^{\\Delta c} = g^{\\Delta x_3}</span> , (56)</p>

    <p class="text-gray-300">hold and either</p>

    <p class="text-gray-300"><span class="math">$C_1^{\\Delta c} = u^{2n\\Delta r_1} (\\frac{1}{v})^{2n\\Delta a_1} , \\quad \\mathfrak{C}_1^{\\Delta c} = \\mathfrak{g}^{\\Delta a_1} \\mathfrak{h}^{\\Delta b_1} , \\quad \\text{and} \\quad 1 = (\\frac{1}{\\mathfrak{C}_1})^{\\Delta x_2 + \\mathcal{H}_{\\mathsf{hk}}(u,e,L)\\Delta x_3} \\mathfrak{g}^{\\Delta r_1} \\mathfrak{h}^{\\Delta s_1}</span>$
(57)</p>

    <p class="text-gray-300">or</p>

    <p class="text-gray-300"><span class="math">$C_2^{\\Delta c} = u^{2\\Delta r_2} (\\frac{1}{v})^{2\\Delta a_2} , \\qquad \\mathfrak{C}_2^{\\Delta c} = \\mathfrak{g}^{\\Delta a_2} \\mathfrak{h}^{\\Delta b_2} , \\quad \\text{and} \\quad 1 = (\\frac{1}{\\mathfrak{C}_2})^{\\Delta x_2 + \\mathcal{H}_{hk}(u,e,L)\\Delta x_3} \\mathfrak{g}^{\\Delta r_2} \\mathfrak{h}^{\\Delta s_2}</span>$
(58)</p>

    <p class="text-gray-300">or</p>

    <p class="text-gray-300"><span class="math">$C_3^{\\Delta c} = u^{2n\\Delta r_3} (\\frac{1}{e})^{2n\\Delta a_3} , \\quad \\mathfrak{C}_3^{\\Delta c} = \\mathfrak{g}^{\\Delta a_3} \\mathfrak{h}^{\\Delta b_3} , \\quad \\text{and} \\quad 1 = (\\frac{1}{\\mathfrak{C}_3})^{\\Delta x_1} \\mathfrak{g}^{\\Delta r_3} \\mathfrak{h}^{\\Delta s_3}</span>$
(59)</p>

    <p class="text-gray-300">or</p>

    <p class="text-gray-300"><span class="math">$C_4^{\\Delta c} = \\gamma^{\\Delta r_4} (\\frac{1}{\\delta})^{\\Delta a_4} , \\qquad \\mathfrak{C}_4^{\\Delta c} = \\mathfrak{g}^{\\Delta a_4} \\mathfrak{h}^{\\Delta b_4} , \\qquad 1 = (\\frac{1}{\\mathfrak{C}_4})^{\\Delta m} \\mathfrak{g}^{\\Delta r_4} \\mathfrak{h}^{\\Delta s_4}</span>$
(60)</p>

    <p class="text-gray-300"><span class="math">$e^{2\\Delta c} = u^{2\\Delta x_1} h^{2\\Delta m} , \\quad \\mathfrak{M}^{\\Delta c} = \\mathfrak{g}^{\\Delta m} \\mathfrak{h}^{\\Delta t_5} , \\quad \\mathfrak{g}^{\\Delta c(n-1)^2/4} = \\mathfrak{M}^{\\Delta m} \\mathfrak{W}_1^{\\Delta w_1} \\mathfrak{W}_2^{\\Delta w_2} \\mathfrak{W}_3^{\\Delta w_3} \\mathfrak{W}_4^{\\Delta w_4} \\mathfrak{h}^{\\Delta s_5}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\tag{61}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\mathfrak{W}_{1}^{\\Delta c} = \\mathfrak{g}^{\\Delta w_{1}}\\mathfrak{h}^{\\Delta t_{1}} , \\quad \\mathfrak{W}_{2}^{\\Delta c} = \\mathfrak{g}^{\\Delta w_{2}}\\mathfrak{h}^{\\Delta t_{2}} , \\quad \\mathfrak{W}_{3}^{\\Delta c} = \\mathfrak{g}^{\\Delta w_{3}}\\mathfrak{h}^{\\Delta t_{3}} , \\quad \\text{and} \\quad \\mathfrak{W}_{4}^{\\Delta c} = \\mathfrak{g}^{\\Delta w_{4}}\\mathfrak{h}^{\\Delta t_{4}} . \\tag{62}</span>$</p>

    <p class="text-gray-300">hold. We know  <span class="math">x_i</span>  such that  <span class="math">y_i = g^{x_i}</span>  and therefore it follows from (33) that</p>

    <p class="text-gray-300"><span class="math">$\\Delta c x_i \\equiv \\Delta x_i \\pmod{n&#x27;} \\quad \\text{for} \\quad i = 1, \\dots, 3 \\ .</span>$
(63)</p>

    <p class="text-gray-300">We next consider the implications of the cases when the equations (57), the equations (58), the equations (59), or the equations (60-62) hold in conjunction with (56). The first three cases appear also in the proof of Theorem 6, while the last one is different:</p>

    <p class="text-gray-300">Case 4. Similarly as in Case I above, from the Equations (61) and (62) we can derive that</p>

    <p class="text-gray-300"><span class="math">$e^{2\\Delta c} = u^{2\\Delta x_1} h^{2\\Delta c\\hat{m}}</span>$
and  <span class="math">-(n-1)/2 \\le \\hat{m} \\le (n-1)/2</span>  (64)</p>

    <p class="text-gray-300">where  <span class="math">\\hat{m} = \\Delta m/\\Delta c</span> . Using Equations (63) and the fact that  <span class="math">\\Delta c</span>  is invertible modulo nn', we get</p>

    <p class="text-gray-300"><span class="math">$e^2 = u^{2x_1} h^{2\\hat{m}}</span>$</p>

    <p class="text-gray-300">and, because of the second equation of (64).</p>

    <p class="text-gray-300"><span class="math">$\\hat{m} = (\\log_{h^2} u^{2x_1} / e^2 \\operatorname{rem} n) \\tag{65}</span>$</p>

    <p class="text-gray-300">Similarly as we did in Case II in the proof of Theorem 6, one can derive from the last two equations of (60) that</p>

    <p class="text-gray-300"><span class="math">$\\Delta r_4 = \\Delta a_4 \\hat{m} \\tag{66}</span>$</p>

    <p class="text-gray-300">holds (using the strong RSA assumption for  <span class="math">\\mathfrak{n}</span> ). Now using (66) in the first equation of (60)</p>

    <p class="text-gray-300"><span class="math">$C_4^{\\Delta c} = \\gamma^{\\Delta a_4 \\hat{m}} (\\frac{1}{\\delta})^{\\Delta a_4} \\quad \\text{and} \\quad C_4 = (\\frac{\\gamma^{\\hat{m}}}{\\delta})^{\\hat{a}_4} ,</span>$
(67)</p>

    <p class="text-gray-300">where  <span class="math">\\hat{a}_4 := \\Delta a_4/\\Delta c \\pmod{\\rho}</span> . Because  <span class="math">C_4 \\neq 1</span>  we must have that  <span class="math">\\delta \\neq \\gamma^{\\hat{m}}</span>  and because of (65) that</p>

    <p class="text-gray-300"><span class="math">$\\delta \\neq \\gamma^{(\\log_{h^2} u^{2x_1}/e^2 \\operatorname{rem} n)}</span>$</p>

    <p class="text-gray-300">which is a contradiction to the third equation of (55) and hence this case can not occur.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">[ACJT00] G. Ateniese, J. Camenisch, M. Joye, and G. Tsudik, A practical and provably secure coalition-resistant group signature scheme, Advances in Cryptology — CRYPTO 2000 (M. Bellare, ed.), LNCS, vol. 1880, Springer Verlag, 2000, pp. 255–270.</p></li>
      <li><p class="text-gray-300">[ADR02] J. H. An, Y. Dodis, and T. Rabin, On the security of joint signature and encryption, Advances in Cryptology — EUROCRYPT 2002 (L. Knudsen, ed.), LNCS, vol. 2332, Springer, 2002, pp. 83–107.</p></li>
      <li><p class="text-gray-300">[ASW97] N. Asokan, M. Schunter, and M. Waidner, Optimistic protocols for fair exchange, Proc. 4th ACM Conference on Computer and Communications Security, 1997, pp. 6–17.</p></li>
      <li><p class="text-gray-300">[ASW98] N. Asokan, V. Shoup, and M. Waidner, Optimistic fair exchange of digital signatures, Advances in Cryptology — EUROCRYPT '98 (K. Nyberg, ed.), LNCS, vol. 1403, Springer Verlag, 1998, pp. 591–606.</p></li>
      <li><p class="text-gray-300">[ASW00] N. Asokan, V. Shoup, and M. Waidner, Optimistic fair exchange of digital signatures, IEEE Journal on Selected Areas in Communications 18 (2000), no. 4, 591–610.</p></li>
      <li><p class="text-gray-300">[BDM98] F. Bao, R. Deng, and W. Mao, Efficient and practical fair exchange protocols with offline TTP, IEEE Symposium on Security and Privacy, IEEE Computer Society Press, 1998, pp. 77–85.</p></li>
      <li><p class="text-gray-300">[BG96] M. Bellare and S. Goldwasser, Encapsulated key escrow, Tech. Report TR 688, MIT Laboratory for Computer Science, April 1996.</p></li>
      <li><p class="text-gray-300">[Bou00] F. Boudot, Efficient proofs that a committed number lies in an interval, Advances in Cryptology — EUROCRYPT 2000 (B. Preneel, ed.), LNCS, vol. 1807, Springer Verlag, 2000, pp. 431–444.</p></li>
      <li><p class="text-gray-300">[BP90] H. B¨urk and A. Pfitzmann, Digital payment systems enabling security and unobservability, Computer &amp; Security 9 (1990), no. 8, 715–721.</p></li>
      <li><p class="text-gray-300">[BP97] N. Bari´c and B. Pfitzmann, Collision-free accumulators and fail-stop signature schemes without trees, Advances in Cryptology — EUROCRYPT '97 (W. Fumy, ed.), LNCS, vol. 1233, Springer Verlag, 1997, pp. 480–494.</p></li>
      <li><p class="text-gray-300">[BS02] E. Bresson and J. Stern, Proofs of knowledge for non-monotone discrete-log formulae and applications, Information Security (ISC 2002) (A. H. Chan and V. Gligor, eds.), LNCS, vol. 2433, Springer Verlag, 2002, pp. 272–288.</p></li>
      <li><p class="text-gray-300">[CD00] J. Camenisch and I. Damg˚ard, Verifiable encryption, group encryption, and their applications to group signatures and signature sharing schemes, Advances in Cryptology — ASIACRYPT 2000 (T. Okamoto, ed.), LNCS, vol. 1976, Springer Verlag, 2000, pp. 331–345.</p></li>
      <li><p class="text-gray-300">[CDS94] R. Cramer, I. Damg˚ard, and B. Schoenmakers, Proofs of partial knowledge and simplified design of witness hiding protocols, Advances in Cryptology — CRYPTO '94 (Y. G. Desmedt, ed.), LNCS, vol. 839, Springer Verlag, 1994, pp. 174–187.</p></li>
      <li><p class="text-gray-300">[CF01] R. Canetti and M. Fischlin, Universally composable commitments, Advances in Cryptology — CRYPTO 2001 (J. Kilian, ed.), LNCS, vol. 2139, Springer Verlag, 2001, pp. 19–40.</p></li>
      <li><p class="text-gray-300">[CFT98] A. Chan, Y. Frankel, and Y. Tsiounis, Easy come easy go divisible cash, Advances in Cryptology — EUROCRYPT '98 (K. Nyberg, ed.), LNCS, vol. 1403, Springer Verlag, 1998, pp. 561–575.</p></li>
      <li><p class="text-gray-300">[CG98] D. Catalano and R. Gennaro, New efficient and secure protocols for verifiable signature sharing and other applications, Advances in Cryptology — CRYPTO '98 (Berlin) (H. Krawczyk, ed.), LNCS, vol. 1642, Springer Verlag, 1998, pp. 105–120.</p></li>
      <li><p class="text-gray-300">[CG99] R. Canetti and S. Goldwasser, An efficient threshold public key cryptosystem secure against adaptive chosen ciphertext attack, Advances in Cryptology — EUROCRYPT '99 (J. Stern, ed.), LNCS, vol. 1592, Springer Verlag, 1999, pp. 90–106.</p></li>
      <li><p class="text-gray-300">[CGGM00] R. Canetti, O. Goldreich, S. Goldwasser, and S. Micali, Resettable zero-knowledge, Proc. 32st Annual ACM Symposium on Theory of Computing (STOC), ACM Press, 2000, pp. 235–244.</p></li>
      <li><p class="text-gray-300">[Cha85] D. Chaum, Security without identification: Transaction systems to make big brother obsolete, Communications of the ACM 28 (1985), no. 10, 1030–1044.</p></li>
      <li><p class="text-gray-300">[Cha94] D. Chaum, Designated confirmer signatures, Advances in Cryptology EUROCRYPT '94 (A. De Santis, ed.), LNCS, vol. 950, Springer Verlag Berlin, 1994, pp. 86–91.</p></li>
      <li><p class="text-gray-300">[CL01] J. Camenisch and A. Lysyanskaya, Efficient non-transferable anonymous multi-show credential system with optional anonymity revocation, Advances in Cryptology — EU-ROCRYPT 2001 (B. Pfitzmann, ed.), LNCS, vol. 2045, Springer Verlag, 2001, pp. 93– 118.</p></li>
      <li><p class="text-gray-300">[CM98] J. Camenisch and M. Michels, A group signature scheme with improved efficiency, Advances in Cryptology — ASIACRYPT '98 (K. Ohta and D. Pei, eds.), LNCS, vol. 1514, Springer Verlag, 1998, pp. 160–174.</p></li>
      <li><p class="text-gray-300">[CM99a] J. Camenisch and M. Michels, Proving in zero-knowledge that a number n is the product of two safe primes, Advances in Cryptology — EUROCRYPT '99 (J. Stern, ed.), LNCS, vol. 1592, Springer Verlag, 1999, pp. 107–122.</p></li>
      <li><p class="text-gray-300">[CM99b] J. Camenisch and M. Michels, Separability and efficiency for generic group signature schemes, Advances in Cryptology — CRYPTO '99 (M. Wiener, ed.), LNCS, vol. 1666, Springer Verlag, 1999, pp. 413–430.</p></li>
      <li><p class="text-gray-300">[CM00] J. Camenisch and M. Michels, Confirmer signature schemes secure against adaptive adversaries, Advances in Cryptology — EUROCRYPT 2000 (B. Preneel, ed.), LNCS, vol. 1807, Springer Verlag, 2000, pp. 243–258.</p></li>
      <li><p class="text-gray-300">[CP93] D. Chaum and T. P. Pedersen, Wallet databases with observers, Advances in Cryptology — CRYPTO '92 (E. F. Brickell, ed.), LNCS, vol. 740, Springer-Verlag, 1993, pp. 89– 105.</p></li>
      <li><p class="text-gray-300">[CS97] J. Camenisch and M. Stadler, Efficient group signature schemes for large groups, Advances in Cryptology — CRYPTO '97 (B. Kaliski, ed.), LNCS, vol. 1296, Springer Verlag, 1997, pp. 410–424.</p></li>
      <li><p class="text-gray-300">[CS98] R. Cramer and V. Shoup, A practical public key cryptosystem provably secure against adaptive chosen ciphertext attack, Advances in Cryptology — CRYPTO '98 (Berlin) (H. Krawczyk, ed.), LNCS, vol. 1642, Springer Verlag, 1998, pp. 13–25.</p></li>
      <li><p class="text-gray-300">[CS00] R. Cramer and V. Shoup, Signature schemes based on the strong RSA assumption, ACM Transactions on Information and System Security 3 (2000), no. 3, 161–185.</p></li>
      <li><p class="text-gray-300">[CS02] R. Cramer and V. Shoup, Universal hash proofs and a paradigm for adaptive chosen ciphertext secure public-key encryption, Advances in Cryptology — EUROCRYPT 2002, LNCS, vol. 2332, Springer, 2002, pp. 45–64.</p></li>
      <li><p class="text-gray-300">[CVH02] J. Camenisch and E. Van Herreweghen, Design and implementation of the idemix anonymous credential system, Proc. 9th ACM Conference on Computer and Communications Security, acm press, 2002.</p></li>
      <li><p class="text-gray-300">[Dam00] I. Damg˚ard, Efficient concurrent zero-knowledge in the auxiliary string model, Advances in Cryptology — EUROCRYPT 2000 (B. Preneel, ed.), LNCS, vol. 1807, Springer Verlag, 2000, pp. 431–444.</p></li>
      <li><p class="text-gray-300">[DF02] I. Damg˚ard and E. Fujisaki, An integer commitment scheme based on groups with hidden order, Advances in Cryptology — ASIACRYPT 2002, LNCS, vol. 2501, Springer, 2002.</p></li>
      <li><p class="text-gray-300">[DNS98] C. Dwork, M. Naor, and A. Sahai, Concurrent zero knowledge, Proc. 30th Annual ACM Symposium on Theory of Computing (STOC), 1998.</p></li>
      <li><p class="text-gray-300">[FO97] E. Fujisaki and T. Okamoto, Statistical zero knowledge protocols to prove modular polynomial relations, Advances in Cryptology — CRYPTO '97 (B. Kaliski, ed.), LNCS, vol. 1294, Springer Verlag, 1997, pp. 16–30.</p></li>
      <li><p class="text-gray-300">[FR95] M. Franklin and M. Reiter, Verifiable signature sharing, Advances in Cryptology EUROCRYPT '95 (L. C. Guillou and J.-J. Quisquater, eds.), LNCS, vol. 921, Springer Verlag, 1995, pp. 50–63.</p></li>
      <li><p class="text-gray-300">[FS87] A. Fiat and A. Shamir, How to prove yourself: Practical solutions to identification and signature problems, Advances in Cryptology — CRYPTO '86 (A. M. Odlyzko, ed.), LNCS, vol. 263, Springer Verlag, 1987, pp. 186–194.</p></li>
      <li><p class="text-gray-300">[GHR99] R. Gennaro, S. Halevi, and T. Rabin, Secure hash-and-sign signatures without the random oracle, Advances in Cryptology — EUROCRYPT '99 (J. Stern, ed.), LNCS, vol. 1592, Springer Verlag, 1999, pp. 123–139.</p></li>
      <li><p class="text-gray-300">[GL03] R. Gennaro and Y. Lindell, A framework for password-based authenticated key exchange, Advances in Cryptology — EUROCRYPT 2003 (E. Biham, ed.), LNCS, vol. 2656, Springer Verlag, 2003, pp. 524–543.</p></li>
      <li><p class="text-gray-300">[KP98] J. Kilian and E. Petrank, Identity escrow, Advances in Cryptology CRYPTO '98 (Berlin) (H. Krawczyk, ed.), LNCS, vol. 1642, Springer Verlag, 1998, pp. 169–185.</p></li>
      <li><p class="text-gray-300">[Mic] S. Micali, Efficient certificate revocation and certified e-mail with transparent post offices, Presentation at the 1997 RSA Security Conference.</p></li>
      <li><p class="text-gray-300">[MS98] M. Michels and M. Stadler, Generic constructions for secure and efficient confirmer signature schemes, Advances in Cryptology — EUROCRYPT '98 (K. Nyberg, ed.), LNCS, vol. 1403, Springer Verlag, 1998, pp. 406–421.</p></li>
      <li><p class="text-gray-300">[Pai99] P. Paillier, Public-key cryptosystems based on composite residuosity classes, Advances in Cryptology — EUROCRYPT '99 (J. Stern, ed.), LNCS, vol. 1592, Springer Verlag, 1999, pp. 223–239.</p></li>
      <li><p class="text-gray-300">[Ped92] T. P. Pedersen, Non-interactive and information-theoretic secure verifiable secret sharing, Advances in Cryptology – CRYPTO '91 (J. Feigenbaum, ed.), LNCS, vol. 576, Springer Verlag, 1992, pp. 129–140.</p></li>
      <li><p class="text-gray-300">[PS00] G. Poupard and J. Stern, Fair encryption of RSA keys, Advances in Cryptology: EU-ROCRYPT 2000 (B. Preneel, ed.), LNCS, vol. 1087, Springer Verlag, 2000, pp. 173–190.</p></li>
      <li><p class="text-gray-300">[RS86] M. O. Rabin and J. O. Shallit, Randomized algorithms in number theory, Communications on Pure and Applied Mathematics 39 (1986), 239–256.</p></li>
      <li><p class="text-gray-300">[SG98] V. Shoup and R. Gennaro, Securing threshold cryptosystems against chosen ciphertext attack, Advances in Cryptology — EUROCRYPT '98 (K. Nyberg, ed.), LNCS, vol. 1403, Springer, 1998.</p></li>
      <li><p class="text-gray-300">[Sho01] V. Shoup, A proposal for an ISO standard for public key encryption, http://eprint. iacr.org/2001/112, 2001.</p></li>
      <li><p class="text-gray-300">[Sta96] M. Stadler, Publicly verifiable secret sharing, Advances in Cryptology EUROCRYPT '96 (U. Maurer, ed.), LNCS, vol. 1070, Springer Verlag, 1996, pp. 191–199.</p></li>
      <li><p class="text-gray-300">[YY98] A. Young and M. Young, Auto-recoverable auto-certifiable cryptosystems., Advances in Cryptology — EUROCRYPT '98 (K. Nyberg, ed.), LNCS, vol. 1403, Springer Verlag, 1998, pp. 17–31.</p></li>
    </ul>

`;
---

<BaseLayout title="Practical Verifiable Encryption and Decryption of Discrete L... (2002/161)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2002 &middot; eprint 2002/161
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="practical-verifiable-encryption-and-decryption-of-discrete-2002" />
  </article>
</BaseLayout>
