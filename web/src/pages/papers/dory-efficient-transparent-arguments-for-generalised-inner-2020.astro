---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/1274';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Dory: Efficient, Transparent arguments for Generalised Inner Products and Polynomial Commitments';
const AUTHORS_HTML = 'Jonathan Lee';

const CONTENT = `    <p class="text-gray-300">Dory: Efficient, Transparent arguments for Generalised Inner Products and Polynomial Commitments</p>

    <p class="text-gray-300">Jonathan Lee*</p>

    <p class="text-gray-300">Microsoft Research, Nanotronics Imaging*</p>

    <p class="text-gray-300">Abstract. This paper presents Dory, a transparent setup, public-coin interactive argument for inner-pairing products between committed vectors of elements of two source groups. For a product of vectors of length <span class="math">n</span>, proofs are <span class="math">6\\log n</span> target group elements and <span class="math">O(1)</span> additional elements. Verifier work is dominated by an <span class="math">O(\\log n)</span> multi-exponentiation in the target group and <span class="math">O(1)</span> pairings. Security is reduced to the standard SXDH assumption in the standard model.</p>

    <p class="text-gray-300">We apply Dory to build a multivariate polynomial commitment scheme via the Fiat-Shamir transform. For a dense polynomial with <span class="math">n</span> coefficients, Prover work to compute a commitment is dominated by a multi-exponentiation in one source group of size <span class="math">n</span>. Prover work to show that a commitment to an evaluation is correct is <span class="math">O(n^{\\log 8 / \\log 25})</span> in general (<span class="math">O(n^{1/2})</span> for univariate or multilinear polynomials); communication complexity and Verifier work are both <span class="math">O(\\log n)</span>. These asymptotics previously required trusted setup or concretely inefficient groups of unknown order. Critically for applications, these arguments can be batched, saving large factors on the Prover and improving Verifier asymptotics: to validate <span class="math">\\ell</span> polynomial evaluations for polynomials of size at most <span class="math">n</span> requires <span class="math">O(\\ell + \\log n)</span> exponentiations and <span class="math">O(\\ell \\log n)</span> field operations.</p>

    <p class="text-gray-300">Dory is also concretely efficient: Using one core and setting <span class="math">n = 2^{20}</span>, commitments are 128 bytes and take <span class="math">\\sim 10s</span> to generate. Evaluation proofs are <span class="math">\\sim 18kB</span>, requiring <span class="math">\\sim 3.5s</span> to generate and <span class="math">\\sim 30ms</span> to verify. For batches at <span class="math">n = 2^{20}</span>, the marginal cost per evaluation is <span class="math">&amp;lt; 1kB</span> communication, <span class="math">\\sim 30ms</span> for the Prover and <span class="math">\\sim 1ms</span> for the Verifier.</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Zero-knowledge succinct arguments of knowledge (zkSNARKs) for the satisfiability of Rank-1 Constraint Systems (R1CS) are the subject of ongoing research. A general strategy to construct zkSNARKS for R1CS is to partition the proof into two phases. First, an information-theoretic argument reduces proving the existence of a satisfying assignment to a consistency check on commitments to evaluations of (possibly multi-variate) polynomials. Some computationally sound</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>jlee@nanotronics.co</li>

      <li>Current Affiliation: Nanotronics Imaging; work done primarily at Microsoft Research</li>

    </ul>

    <p class="text-gray-300">argument with sub-linear verification time is used to show these commitments to evaluations are correct. These auxiliary arguments are variously inner-product arguments, or the more restricted <em>polynomial commitments</em>, introduced by Kate <em>[32]</em> and generalised to multivariate polynomials in <em>[36]</em>.</p>

    <p class="text-gray-300">Spartan <em>[37]</em> makes the independence of the information-theoretic argument and these auxiliary arguments explicit, provides an extensive overview of the history and details of prior works, and details key practical considerations relating to the uniformity of the computation to verify. There are multiple approaches in the literature to constructing these auxiliary arguments, and for each many concrete constructions. Non-exhaustively, Bulletproofs <em>[18]</em> use inner-product arguments and Hyrax <em>[40]</em> utilise polynomial commitments, both based on the logarithmic communication complexity discrete log-based work (LCC-DLOG) of Bootle et al. <em>[15]</em>, which in turn uses ideas from <em>[26]</em>. Spartan <em>[37]</em> optimises this approach further, and Halo <em>[17]</em> applies these on cycles of pairing friendly curves to achieve recursive composition.</p>

    <p class="text-gray-300">Ligero <em>[4]</em>, Aurora <em>[9]</em>, Virgo <em>[41]</em> and Fractal <em>[21]</em> use Interactive Oracle Proofs based on Reed-Solomon codes (RS-IOP) to prove that a polynomial is of bounded degree <em>[7]</em>. Supersonic and its follow on works <em>[19, 13]</em> makes use of groups of unknown order to construct Diophantine ARguments of Knowledge (DARK-GUO) proofs for polynomial evaluations over fields. Other works rely on some trusted setup, which allows the use of other commitment schemes. For example PLONK <em>[23]</em> makes use of KZG <em>[32]</em> commitments directly, whilst <em>[20]</em> uses sublinear-sized KZG commitments as a component in their GIPP argument and polynomial commitment. In all cases these interactive arguments are then compiled to non-interactive arguments in the random-oracle model.</p>

    <p class="text-gray-300">This paper introduces a new argument for generalised inner products without trusted setup, inspired by Bootle et al. <em>[15]</em> but applying new techniques to achieve a logarithmic <span class="math">\\mathcal{V}</span> complexity. This argument can be applied to give polynomial commitments for arbitrary numbers of variables, using two-tiered homomorphic commitments of Groth <em>[27]</em> applied to matrix commitment strategy of <em>[40]</em>. This commitment was also used in Bünz et al. <em>[20]</em> for univariate and bivariate polynomials.</p>

    <p class="text-gray-300">For transparent polynomial commitment schemes, there are four key operations: (1) <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> must generate public parameters; (2) <span class="math">\\mathcal{P}</span> must commit to a polynomial and transmit that commitment to <span class="math">\\mathcal{V}</span>; (3, 4) <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> must compute, transmit and verify a proof of evaluation of the polynomial. We give the best achieved asymptotics of previous transparent polynomial commitment schemes, grouped by overall approach, in Figure 1.</p>

    <p class="text-gray-300">Unfortunately, implementations generally bundle their polynomial commitment with differing polynomial IOPs for some language, so concrete comparisons of the <em>polynomial commitments</em> in isolation are challenging. To allow for a somewhat concrete discussion, we first note typical object sizes and operation times for fast implementations of the required primitives at the 128-bit security</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Transparent Setup?</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Communication Complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Time Complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Commit</td>

            <td class="px-3 py-2 border-b border-gray-700">Eval</td>

            <td class="px-3 py-2 border-b border-gray-700">Gen</td>

            <td class="px-3 py-2 border-b border-gray-700">Commit</td>

            <td class="px-3 py-2 border-b border-gray-700">Eval (P)</td>

            <td class="px-3 py-2 border-b border-gray-700">Eval (V)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">LCC-DLOG</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">n1/2</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">log n</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">n1/2H</td>

            <td class="px-3 py-2 border-b border-gray-700">n G</td>

            <td class="px-3 py-2 border-b border-gray-700">n1/2 G</td>

            <td class="px-3 py-2 border-b border-gray-700">n1/2 G</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">RS-IOP</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">H</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">log2n</td>

            <td class="px-3 py-2 border-b border-gray-700">H</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">n log n H</td>

            <td class="px-3 py-2 border-b border-gray-700">n log n H</td>

            <td class="px-3 py-2 border-b border-gray-700">log2n H</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DARK-GUO</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">GU</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">log n</td>

            <td class="px-3 py-2 border-b border-gray-700">GU</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">n log n GU</td>

            <td class="px-3 py-2 border-b border-gray-700">n GU</td>

            <td class="px-3 py-2 border-b border-gray-700">n log n GU</td>

            <td class="px-3 py-2 border-b border-gray-700">log n GU</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KZG [32,36]</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">GT</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">log n</td>

            <td class="px-3 py-2 border-b border-gray-700">GT</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">r P</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">GIPP [20]</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">GT</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">log n</td>

            <td class="px-3 py-2 border-b border-gray-700">GT</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">n1/2 G1</td>

            <td class="px-3 py-2 border-b border-gray-700">n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">n1/2 P</td>

            <td class="px-3 py-2 border-b border-gray-700">log n GT</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This work</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">GT</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">log n</td>

            <td class="px-3 py-2 border-b border-gray-700">GT</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">n1/2P</td>

            <td class="px-3 py-2 border-b border-gray-700">n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">n1/2P</td>

            <td class="px-3 py-2 border-b border-gray-700">log n GT</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">level in Figure 2. We note that blstrs is enhanced to apply torus-based pairing compression [35] of  <span class="math">\\mathbb{G}_T</span>  for serialisation.</p>

    <p class="text-gray-300">Fig. 1: Asymptotic comparisons for dense univariate polynomials of degree  <span class="math">n</span> , neglecting Pippenger-type savings in groups. We report the most expensive dominant operations for the most efficient instantiations of each class.  <span class="math">\\mathbb{H}</span>  denotes a hash function.  <span class="math">\\mathbb{G}</span>  denotes a group.  <span class="math">\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T</span>  denote the two source groups and the target group of a pairing  <span class="math">P</span> .  <span class="math">\\mathbb{G}_U</span>  is a group of unknown order. These schemes all generalise to multivariate polynomials with degree sequence  <span class="math">(d_1, \\ldots, d_r)</span> , setting  <span class="math">n = \\prod_i (d_i + 1)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Setting</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Implementation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Size (bytes)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Time (μs)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Group of Unknown Order</td>

            <td class="px-3 py-2 border-b border-gray-700">ANTIC-QFB</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">GU</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">832</td>

            <td class="px-3 py-2 border-b border-gray-700">27000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Hashing</td>

            <td class="px-3 py-2 border-b border-gray-700">rust-crypto</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">H</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">0.072</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Group</td>

            <td class="px-3 py-2 border-b border-gray-700">curve25519-dalek</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">42</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Group with Pairing</td>

            <td class="px-3 py-2 border-b border-gray-700">blstrs</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">110</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G2</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">96</td>

            <td class="px-3 py-2 border-b border-gray-700">270</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">GT</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">470</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">P</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">600</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fig. 2: Micro-benchmarks on a single core (AMD Ryzen 5 3600). For groups we give the serialised size in bytes of a group element, and the time taken to multiply a random point by a 256-bit scalar.  <span class="math">P</span>  denotes a pairing computation, and  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  denotes hashing of a 512-bit message to a 256-bit digest.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Unfortunately, each prior approach to transparent polynomial commitments have substantial problems in practice. Concretely, only LCC-DLOG based-schemes provide a linear-time Prover, which is key for large applications where  <span class="math">n \\sim 2^{20 - -30}</span> . Unfortunately, these schemes require  <span class="math">\\Omega(n^{1/2})</span>  computation by  <span class="math">\\mathcal{V}</span>  to Eval a committed polynomial, and have similarly sized commitments. This is because they commit to a matrix with  <span class="math">O(n)</span>  entries by committing to the rows and later</p>

    <p class="text-gray-300">opening a commitment to some linear combination of the rows. Hyrax <em>[40]</em> and its successors saturate this bound with small concrete constants. However for large <span class="math">n</span> these commitments remain quite large (<span class="math">\\gg 10kB</span>), and can be challenging in applications applications where the polynomial commitment is used as a routine and so many commitments must be sent.</p>

    <p class="text-gray-300">RS-IOP-based schemes are built on Reed-Solomon based IOPPs, and would have attractive concrete costs, even with their asymptotic slowness, if the concrete constants were commensurate with the cost of hashing. Unfortunately the soundness error of the underlying IOPP is quite large and the <em>proven</em> bounds are worse still, requiring a number of repetitions linear in the security level. For example, libiop <em>[8]</em> runs the underlying proof in Fractal <em>[21]</em> <span class="math">\\sim 500</span> times to achieve provable 128-bit security. This large additional multiplicative constant largely closes the micro-benchmark gap with curve arithmetic, especially as multi-exponentiations in groups permit log savings using Pippenger’s algorithm.</p>

    <p class="text-gray-300">DARK-GUO-based schemes <em>[19, 13]</em> are built around groups of unknown order, which can be constructed transparently as class groups of quadratic number fields, or analogously as Jacobians of higher genus curves <em>[22]</em>. They have a long history of crpytographic use <em>[31, 33, 14]</em>. Unfortunately, general sub-exponential attacks on the order are known <em>[12]</em>; fast attacks on a low-density sets of weak groups are problematic for applications with transparent setup <em>[22]</em>, which forces the group operation to be materially slower than operations on curves, as is seen in Figure 2. In the particular case of Supersonic <em>[19, 13]</em>, even with Pippenger-type acceleration <span class="math">\\mathcal{P}</span> must perform <em>O</em>(<em>n</em><span class="math">\\lambda</span>) group operations, and generating parameters takes <em>O</em>(<em>n</em><span class="math">\\lambda\\log n</span>) group operations, which is unlikely to be efficient in practice.</p>

    <p class="text-gray-300">Finally, if transparent setup is given up then Kate commitments <em>[32]</em> and their multivariate generalisation <em>[36]</em> are available, generally requiring <em>O</em>(<em>n</em>) operations in <span class="math">\\mathbb{G}_{1}</span> for <span class="math">\\mathcal{P}</span>, <em>O</em>(1) commitment sizes and a <span class="math">\\mathcal{V}</span> time linear in the number of variables. This is combined with ideas from LCC-DLOG in <em>[20]</em> to achieve sublinear Prover computation for evaluation. Whilst performant, these systems have unprovable knowledge-of-exponent type assumptions for their security, which is undesirable.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">1.2 Review of LCC-DLOG techniques</h3>

    <p class="text-gray-300">Dory builds on the LCC-DLOG tradition, which construct inner-product arguments <em>[15, 18, 20]</em> or reductions of Hadamard products to inner products <em>[26]</em> with efficient Provers and sublinear communication from homomorphic commitments.</p>

    <p class="text-gray-300">Explicitly for the inner product as a bilinear form, these provide arguments for inner products between vectors of scalars and group elements or generalised products between the source groups of a pairing, where either input may be committed. Let these vectors have length <span class="math">n^{\\prime}</span>, WLOG a power of two (in most cases for polynomial commitments <span class="math">n^{\\prime}=O(n^{1/2})</span>). The key idea, which is inherited in Dory, is to observe that for any vectors <span class="math">\\vec{u_{L}},\\vec{u_{R}},\\vec{v_{L}},\\vec{v_{R}}</span>, and any non-zero scalar <span class="math">a</span>:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\langle\\vec{u_{L}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{u_{R}},\\vec{v_{L}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{v_{R}}\\rangle=\\langle a\\vec{u_{L}}+\\vec{u_{R}},a^{-1}\\vec{v_{L}}+\\vec{v_{R}}\\rangle-a\\langle\\vec{u_{L}},\\vec{v_{R}}\\rangle-a^{-1}\\langle\\vec{u_{R}},\\vec{v_{L}}\\rangle.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">So a claim about the inner product <span class="math">\\langle\\vec{u},\\vec{v}\\rangle</span> of length <span class="math">n^{\\prime}</span> can be reduced to some claims about the inner products of vectors of length <span class="math">n^{\\prime}/2</span>. The Verifier uses the</p>

    <p class="text-gray-300">omomorphic properties of the commitment scheme (WLOG of <span class="math">\\vec{u}</span>) and some Prover assistance to find commitments to these shorter vectors <span class="math">\\vec{u^{\\prime}}=a\\vec{u_{L}}+\\vec{u_{R}}</span>, <span class="math">a^{-1}\\vec{v_{L}}+\\vec{v_{R}}</span>, and to a claim for a commitment to the product <span class="math">\\langle\\vec{u^{\\prime}},\\vec{v^{\\prime}}\\rangle</span>, for some Verifier challenge <span class="math">a</span>. This procedure is applied recursively to obtain a claim about vectors of length <span class="math">1</span>, for which some sigma protocol are used. Computational soundness comes from rewinding the Prover, since <span class="math">\\vec{u}</span> can be recovered from a few samples of <span class="math">\\vec{u^{\\prime}}</span> considered as a function of <span class="math">a</span>.</p>

    <p class="text-gray-300">The key problem is that when the commitment key used for <span class="math">\\vec{u}</span> is unstructured, the commitment to <span class="math">\\vec{u^{\\prime}}</span> is made with some <em>challenge-dependent</em> commitment key. This point is typically implicit, since the entire iterated reduction and final proof is presented as a single protocol. In this case, what one sees is that the Verifier has some final <span class="math">O(n^{\\prime})</span> computation that must be performed, using the challenges to convert the initial commitment key to a single curve point.</p>

    <p class="text-gray-300">In <em>[26]</em>, similar techniques are applied to a sequence of vectors with common commitment keys, which allows the Verifier computation to be avoided, at the cost of being only able to combine inner-products rather than compute them. In <em>[15, 18]</em>, inner-product arguments are given, but with linear Verifier computation. These are generalised to pairing groups in <em>[20]</em>, where the key observation is made (following <em>[17]</em>) that this Verifier computation can be expressed as the evaluation of a polynomial whose coefficients are entries in the original commitment key. In this case they structure the commitment key to allow this to be done by opening a Kate commitment.</p>

    <p class="text-gray-300">To construct polynomial commitments, these works use the matrix commitment idea of <em>[26]</em> in an essentially similar fashion as <em>[40, 20]</em>. In its simplest form, this represents a polynomial <span class="math">f(x)</span> of degree <span class="math">n=n^{\\prime}{}^{2}</span> by a matrix <span class="math">M</span> such that:</p>

    <p class="text-gray-300"><span class="math">f(x)=(1,x,x^{2},\\ldots,x^{n^{\\prime}-1})M(1,x^{n^{\\prime}},x^{2n^{\\prime}},\\ldots,x^{n-n^{\\prime}})^{T},</span></p>

    <p class="text-gray-300">which is possible as each entry of <span class="math">M</span> is multiplied by a distinct power <span class="math">x^{i}</span> for <span class="math">i\\in\\{0,\\ldots,n-1\\}</span>. In <em>[40]</em>, the Verifier keeps a homomorphic commitment to each row of <span class="math">M</span>, combines them by hand, and then engages in a <span class="math">\\sqrt{n}</span>-sized inner product argument. In this case the <span class="math">\\sqrt{n}</span> lower bound is sharp, as either the initial linear combination or the inner-product argument must be this large. In <em>[20]</em>, this outer combination is done with a multivariate Kate opening, using the structure-preserving commitment scheme of Abe et al. <em>[3]</em>.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.3 Core techniques of Dory</h3>

    <p class="text-gray-300">We now sketch the key ideas that allow Dory to achieve a logarithmic Verifier.</p>

    <p class="text-gray-300"><em>Symmetry of messages and commitment keys:</em> The structure-preserving commitment scheme of <em>[3]</em> has a symmetry between the messages and the commitment key; for some pairing group <span class="math">(\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T})</span> if the message is a vector in <span class="math">\\mathbb{G}_{1}</span> then the commitment key is a vector in <span class="math">\\mathbb{G}_{2}</span> (and vice versa), with the commitment itself in <span class="math">\\mathbb{G}_{T}</span>. So the Verifier is free to treat parts of a commitment key as messages,</p>

    <p class="text-gray-300">and compute a commitment to them with a second commitment key. Additionally, the commitment key and all Verifier challenges are public, so we can hope to outsource computations on the commitment key to the Prover. This is not possible in the no-pairing setting of <em>[15, 18, 40]</em>, and is not exploited in <em>[20]</em>.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Structured Verifier computation:</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The computations that the Verifier has to perform on the commitment key are highly structured; as observed in <em>[17, 20]</em> that this inner product can be thought of as a multivariate polynomial evaluation. Equivalently, it is an inner product with a vector of scalars, which is a Kronecker products of <span class="math">\\log n^{\\prime}</span> vectors of length <span class="math">2</span> (each built from one of the Verifier’s challenges); this kind of vector occurs throughout Dory, and we say that a vector with such a cauterisation has <em>multiplicative structure</em>. Given the first challenge <span class="math">a</span>, the Verifier must turn the commitment key $\\vec{I^{\\prime}}=(\\vec{I^{\\prime}}_{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{I^{\\prime}}_{R})<span class="math"> into </span>\\Gamma^{\\prime}=(f(a)\\vec{I^{\\prime}}_{L}+g(a)\\vec{I^{\\prime}}_{R})<span class="math">, where </span>f,g<span class="math"> are cheap to compute; after this </span>a<span class="math"> can be discarded. Plainly if the verified holds structure-preserving commitments to </span>\\vec{I^{\\prime}}_{L},\\vec{I^{\\prime}}_{R}<span class="math"> they can quickly compute a commitment to </span>\\Gamma^{\\prime}<span class="math">. Once the remaining challenges are known, the Verifier’s remaining computation with </span>\\Gamma^{\\prime}<span class="math"> is a length </span>n^{\\prime}/2$ inner product. So we can hope to outsource this to the Prover. The key point is that given structure-preserving commitments to the commitment key, the Verifier can apply one (or a few) challenges to shrink the commitment key and have the Prover do the linear work of computing the actual inner product.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Naively, this let us to use a <span class="math">\\log n^{\\prime}</span>-round protocol along the lines of <em>[15, 18, 20]</em> as a black box to reduce computing a length <span class="math">n^{\\prime}</span> inner product of committed vectors to computing a length <span class="math">n^{\\prime}/2</span> inner product on committed vectors derived from the commitment keys of the commitments used in the length <span class="math">n^{\\prime}</span> inner product. If we recursively use this idea, we obtain an <span class="math">\\mathit{O}(\\log^{2}n^{\\prime})</span>-round protocol for length <span class="math">n^{\\prime}</span> inner products.</p>

    <p class="text-gray-300">Alternately, we can start to run these inner product arguments in parallel, so that the inner product arguments in parallel, so that after <span class="math">k</span> rounds we would have <span class="math">k+1</span> claims about inner products of <span class="math">n^{\\prime}2^{-k}</span>-length vectors. This allows us to combine claims about vectors in the same group along the lines of the ‘collapsing’ observed in <em>[17]</em>. This makes each round somewhat more complex, but the number of claims remains <span class="math">\\mathit{O}(1)</span>, and so a logarithmic Verifier is feasible.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Structured public scalars:</h4>

    <p class="text-gray-300">Finally, Dory must handle public vectors of scalars, or for a polynomial commitment the point of evaluation. For general inner products this seems hopeless, as even reading a full vector would be a linear lower bound. However, for polynomial commitments the polynomial size vector of scalars has multiplicative structure, as it is the evaluation of monomials for fixed values of variables. Conveniently, inner products of vectors of this form can be computed in only logarithmically many operations. For a small concrete example, <span class="math">(1,x,y,xy,z,xz,yz,xyz)\\cdot(1,a,b,ab,c,ac,bc,abc)=(1+ax)(1+by)(1+cz)</span>. So any final inner product of public vectors with a challenge-derived vector can, in the context of polynomial commitments, be computed in logarithmic time.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Public parameters:</h4>

    <p class="text-gray-300">We note that for Dory, the public parameters contain commitment keys for of every power-of-2 length less than <span class="math">n^{\\prime}</span> in both <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span>, and commitments to the left and right halves of each commitment key (using the a commitment key of half the length). This use of public parameters with structure but without trusted setup can be seen as analogous to the <em>computational commitments</em> used in Spartan <em>[37]</em>, as we perform some linear-size computation <em>once</em> during setup to accelerate the online proof generation and verification.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Batching:</h4>

    <p class="text-gray-300">Throughout, ideas similar of those of Bowe et al. <em>[17]</em> allow these arguments to be batched for reduced verification time further (see §3.4,§4.4,§5.1,§6.2). Ultimately the cost of evaluating each additional polynomial commitment is reduced to <em>O</em>(1) group operations and <em>O</em>(log<span class="math">\\,n</span>) additional operations in <span class="math">\\mathbb{F}</span>.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">Application to Polynomial commitments:</h4>

    <p class="text-gray-300">In §6, similarly to Hyrax <em>[40, §6]</em> and Bünz et al. <em>[20]</em>, we construct a polynomial commitment from a two-tiered homomorphic commitment to matrices. Prior approaches here break knowledge soundness (c.f. Definition 10). Ultimately, evaluation of a dense univariate or multilinear polynomial with <em>n</em> coefficients is reduced to to two inner products of size <span class="math">O(n^{1/2})</span> (see §5), between public vectors of scalars with multiplicative structure and vectors in <span class="math">\\mathbb{G}_{1},\\mathbb{G}_{2}</span> respectively (see §4). Unlike prior works, these two inner products are proved together, saving a further <span class="math">2\\times</span>.</p>

    <h2 id="sec-9" class="text-2xl font-bold">2 Preliminaries</h2>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">2.1 Notation</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Vector, matrix and tensor indices will begin at 1. For any two vectors <span class="math">v_{1},v_{2}</span> we denote their concatenation by $(v_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v_{2})<span class="math">. We use </span>\\otimes<span class="math"> to denote the Kronecker product, sending an </span>m\\times n<span class="math"> matrix </span>A<span class="math"> and </span>p\\times q<span class="math"> matrix </span>B<span class="math"> to an <em>mp</em></span>\\times<span class="math"> <em>nq</em> matrix built up of appended copies of </span>B<span class="math"> multiplied by scalars in </span>A<span class="math">. For any vector </span>v<span class="math"> of even length we will denote the left and right halves of </span>v<span class="math"> by </span>v_{L}<span class="math"> and </span>v_{R}<span class="math">; more formally: </span>v_{L}=((1,0)\\otimes I_{n/2})v<span class="math"> and </span>v_{R}=((0,1)\\otimes I_{n/2})v$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We write <span class="math">\\leftarrow_{\\S}S</span> for a uniformly random sample of <span class="math">S</span>, with the understanding that this encodes no additional structure; for example for groups <span class="math">\\mathbb{G}</span> we assume that samples <span class="math">g_{i}\\leftarrow_{\\S}\\mathbb{G}</span> have unrelated logarithms, and <span class="math">\\mathcal{V}</span> challenges are independent of the transcript. Techniques to sample from curves are known <em>[38, 30, 11, 39]</em>.</p>

    <p class="text-gray-300">We write all groups <em>additively</em>, and assume we are given some method to sample Type III pairings <em>[24]</em> at a given security level. Then we are furnished with a prime field <span class="math">\\mathbb{F}=\\mathbb{F}_{p}</span>, three groups <span class="math">\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T}</span> of order <span class="math">p</span>, a bilinear map <span class="math">e:\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\to\\mathbb{G}_{T}</span>, and generators <span class="math">G_{1}\\in\\mathbb{G}_{1}</span>, <span class="math">G_{2}\\in\\mathbb{G}_{2}</span> such that <span class="math">e(G_{1},G_{2})</span> generates <span class="math">\\mathbb{G}_{T}</span>. Concretely, classes of <em>pairing-friendly</em> curves (e.g. Barreto-Lynn-Scott <em>[5]</em> or Barreto-Naehrig <em>[6]</em> curves) are believed to satisfy these properties.</p>

    <p class="text-gray-300">We generally suppress the distinction between <em>e</em> and multiplication of <span class="math">\\mathbb{F},\\mathbb{G}_{1},\\mathbb{G}_{2}</span> or <span class="math">\\mathbb{G}_{T}</span> by elements of <span class="math">\\mathbb{F}</span>, writing all of these bilinear maps as multiplication; we will also use <span class="math">\\langle,\\rangle</span> to denote the generalised inner products given by <span class="math">\\langle\\vec{a},\\vec{b}\\rangle=\\sum_{i=1}^{n}\\vec{a}_{i}\\vec{b}_{i}</span>, with signatures: <span class="math">\\mathbb{F}^{n}\\times\\mathbb{F}^{n}\\to\\mathbb{F}</span>, <span class="math">\\mathbb{F}^{n}\\times\\mathbb{G}^{n}_{\\{1,2,T\\}}\\to\\mathbb{G}_{\\{1,2,T\\}}</span> or <span class="math">\\mathbb{G}^{n}_{1}\\times\\mathbb{G}^{n}_{2}\\to\\mathbb{G}_{T}</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">We will present our arguments as depending on some precomputed, structured public parameters which are derived from public, independent and uniformly random samples of <span class="math">\\mathbb{G}_1, \\mathbb{G}_2</span>.</p>

    <h2 id="sec-11" class="text-2xl font-bold">2.2 Computationally hard problems in Type III pairings</h2>

    <p class="text-gray-300">For Type III pairings there are no efficiently computable morphisms between <span class="math">\\mathbb{G}_1, \\mathbb{G}_2</span>, so the standard security assumption is Symmetric eXternal Diffie-Hellman:</p>

    <p class="text-gray-300"><strong>Definition 1 (SXDH [3]).</strong> For <span class="math">(\\mathbb{F}_p, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, e, G_1, G_2)</span> as above, the Decisional Diffie-Hellman (DDH) assumption holds for <span class="math">(\\mathbb{F}_p, \\mathbb{G}_1, G_1)</span> and <span class="math">(\\mathbb{F}_p, \\mathbb{G}_2, G_2)</span></p>

    <p class="text-gray-300">A DDH instance in <span class="math">\\mathbb{G}_1</span> can be mapped to one in <span class="math">\\mathbb{G}_T</span> by <span class="math">g \\to e(g, G_2)</span>, so SXDH implies that DDH holds in <span class="math">\\mathbb{G}_T</span>. In any group, DDH implies DLOG, and so:</p>

    <p class="text-gray-300"><strong>Lemma 1.</strong> For <span class="math">(\\mathbb{F}_p, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, e, G_1, G_2)</span> satisfying SXDH, <span class="math">n = \\mathrm{poly}(\\lambda)</span> and <span class="math">\\mathbb{G} \\in \\{\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T\\}</span>, given <span class="math">\\vec{B} \\stackrel{\\S}{\\leftarrow} \\mathbb{G}^n</span> no non-uniform polynomial-time adversary can compute a non-trivial <span class="math">\\vec{A} \\in \\mathbb{F}^n</span> such that <span class="math">\\langle \\vec{A}, \\vec{B} \\rangle = 0</span>.</p>

    <p class="text-gray-300">SXDH also implies the Double Pairing and reverse Double Pairing assumptions:</p>

    <p class="text-gray-300"><strong>Lemma 2.</strong> For <span class="math">(\\mathbb{F}_p, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, e, G_1, G_2)</span> as above, given <span class="math">A_1, A_2 \\gets_{\\S} \\mathbb{G}_1</span> no non-uniform polynomial-time adversary can compute non-trivial <span class="math">B_1, B_2 \\in \\mathbb{G}_2</span> such that: <span class="math">A_1B_1 + A_2B_2 = 0</span>. Similarly, given <span class="math">A_1, A_2 \\gets_{\\S} \\mathbb{G}_2</span> no adversary can compute non-trivial <span class="math">B_1, B_2 \\in \\mathbb{G}_1</span> such that <span class="math">B_1A_1 + B_2A_2 = 0</span>.</p>

    <p class="text-gray-300"><strong>Lemma 3.</strong> For <span class="math">(\\mathbb{F}_p, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, e, G_1, G_2)</span> as above and <span class="math">n = \\mathrm{poly}(\\lambda)</span>, given <span class="math">\\vec{A} \\gets \\mathbb{G}_1^n</span> no non-uniform polynomial-time adversary can compute a non-trivial <span class="math">\\vec{B} \\in \\mathbb{G}_2^n</span> such that: <span class="math">\\langle \\vec{A}, \\vec{B} \\rangle = 0</span>. Similarly, given <span class="math">\\vec{A} \\gets_{\\S} \\mathbb{G}_2^n</span>, no adversary can compute non-trivial <span class="math">\\vec{B} \\in \\mathbb{G}_1^n</span> such that <span class="math">\\langle \\vec{B}, \\vec{A} \\rangle = 0</span>.</p>

    <h2 id="sec-12" class="text-2xl font-bold">2.3 Succinct interactive arguments of knowledge</h2>

    <p class="text-gray-300">We follow the presentation in [37]. Let <span class="math">\\mathcal{P}, \\mathcal{V}</span> be a pair of interactive PPT algorithms. Fix an algorithm <span class="math">\\mathsf{Gen}</span> and public parameters <span class="math">pp = \\mathsf{Gen}(\\lambda)</span>, where <span class="math">\\lambda</span> a security parameter such that <span class="math">O(2^{-\\lambda}) = \\mathsf{negl}(\\lambda)</span> is negligible. For a NP language <span class="math">\\mathcal{L}</span> there is a deterministic polynomial time <span class="math">\\mathsf{Sat}_{\\mathcal{L}}</span> s.t. <span class="math">\\{\\exists w: \\mathsf{Sat}_{\\mathcal{L}}(\\mathbf{x}, w) = 1\\} \\Leftrightarrow \\mathbf{x} \\in \\mathcal{L}</span>. We denote the transcript of the interaction of two PPTs <span class="math">\\mathcal{P}, \\mathcal{V}</span> with random tapes <span class="math">z_{\\mathcal{P}}, z_{\\mathcal{V}} \\in \\{0,1\\}^*</span> on <span class="math">\\mathbf{x}</span> by <span class="math">tr\\langle \\mathcal{P}(z_{\\mathcal{P}}), \\mathcal{V}(z_{\\mathcal{V}}) \\rangle(\\mathbf{x})</span>.</p>

    <p class="text-gray-300"><strong>Definition 2.</strong> A public-coin succinct interactive argument of knowledge for an NP language <span class="math">\\mathcal{L}</span> is a protocol between <span class="math">\\mathcal{P}, \\mathcal{V}</span> satisfying: properties:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <strong>Completeness:</strong> If <span class="math">\\mathbf{x} \\in \\mathcal{L}</span>, for any witness <span class="math">w</span>, <span class="math">\\mathbf{x} \\in \\mathcal{L}</span> and <span class="math">r \\in \\{0,1\\}^*</span>, $\\mathbb{P}[\\langle \\mathcal{P}(pp,w), \\mathcal{V}(pp,r) \\rangle(\\mathbf{x}) = 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Sat}_{\\mathcal{L}}(\\mathbf{x},w) = 1] \\geq 1 - \\mathsf{negl}(\\lambda)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Soundness:</strong> For <span class="math">\\mathbf{x} \\notin \\mathcal{L}</span>, any PPT Prover <span class="math">\\mathcal{P}^<em></span>, and for all <span class="math">r \\in \\{0,1\\}^</em></span>, <span class="math">\\mathbb{P}[\\langle \\mathcal{P}^*(pp), \\mathcal{V}(pp,r) \\rangle(\\mathbf{x}) = 1] \\leq \\mathsf{negl}(\\lambda)</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Knowledge soundness: For any PPT adversary <span class="math">\\mathcal{A}</span>, there exists a PPT extractor <span class="math">\\mathcal{E}</span> such that <span class="math">\\forall \\mathbf{x} \\in \\mathcal{L}, \\forall r \\in \\{0,1\\}^*</span>, if</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {P} [ \\langle \\mathcal {A} (p p), \\mathcal {V} (p p, r) \\rangle (\\mathbf {x}) = 1 ] \\geq \\operatorname {n e g l} (\\lambda),</span></div>

    <p class="text-gray-300">then <span class="math">\\mathbb{P}[\\mathrm{Sat}_{\\mathcal{L}}(\\mathbf{x},\\mathcal{E}^{\\mathcal{A}}(pp,\\mathbf{x})) = 1]\\geq \\mathrm{negl}(\\lambda).</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Succinctness: Communication between <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> is sublinear in $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Public coin: Each <span class="math">\\mathcal{V}</span> message <span class="math">\\mathcal{M} \\stackrel{\\S}{\\leftarrow} \\mathcal{C}</span>, for <span class="math">\\mathcal{C}</span> some fixed set.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 3.</strong> An interactive argument <span class="math">(\\text{Gen}, \\mathcal{P}, \\mathcal{V})</span> for <span class="math">\\mathcal{L}</span> is Honest-Verifier Statistical Zero-Knowledge (HVSZK) if there exists a PPT algorithm <span class="math">S(\\mathbf{x}, z)</span> called the simulator, running in time polynomial in $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, such that for every </span>\\mathbf{x} \\in \\mathcal{L}<span class="math">, </span>w \\in \\mathcal{R}_{\\mathbf{x}}<span class="math">, and </span>z \\in \\{0,1\\}^*<span class="math">, the statistical distance between the distributions </span>tr\\langle \\mathcal{P}(w), \\mathcal{V}(z) \\rangle(\\mathbf{x})<span class="math"> and </span>S(\\mathbf{x}, z)<span class="math"> is </span>\\mathrm{negl}(\\lambda)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If we have a family of languages <span class="math">\\mathcal{L}_{\\mathrm{params}}</span>, we will often name a pair of interactive PPT algorithms <span class="math">\\mathsf{Func} = (\\mathcal{P},\\mathcal{V})</span>, and suppress reference to the tapes and prover witness, i.e. write that <span class="math">\\mathcal{P},\\mathcal{V}</span> run <span class="math">\\mathsf{Func}_{\\mathrm{params}}(\\mathbf{x})</span> successfully to mean that <span class="math">\\mathcal{P}</span> possesses some witness <span class="math">w</span> for <span class="math">\\mathbf{x} \\in \\mathcal{L}_{\\mathrm{params}}</span> and <span class="math">\\langle \\mathcal{P}(pp,w),\\mathcal{V}(pp,r)\\rangle (\\mathrm{params},\\mathbf{x}) = 1</span>.</p>

    <p class="text-gray-300"><strong>Remark 1.</strong> When compiled with the Fiat-Shamir transform, HVSZK, public-coin, succinct interactive arguments are transformed into zkSNARKs. Standard techniques [25] can also remove the honest-verifier requirement.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 4 (Witness-extended emulation [28,40]).</strong> An public coin interactive argument <span class="math">(\\text{Gen}, \\mathcal{P}, \\mathcal{V})</span> for <span class="math">\\mathcal{L}</span> has witness-extended emulation if for all deterministic polynomial time programs <span class="math">\\mathcal{P}^<em></span> there exists an expected polynomial time emulator <span class="math">E</span> such that for all non-uniform polynomial time adversaries <span class="math">A</span> and all <span class="math">z_{\\mathcal{V}} \\in \\{0,1\\}^</em></span>, the following probabilities differ by at most <span class="math">\\mathrm{negl}(\\lambda)</span>: $\\mathbb{P}[\\mathcal{A}(t,\\mathbf{x}) = 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pp \\gets \\text{Gen}(1^{\\lambda}) \\land (\\mathbf{x}, z_{\\mathcal{P}}) \\gets A(pp) \\land t \\gets \\text{tr}\\langle \\mathcal{P}^*(z_{\\mathcal{P}}), \\mathcal{V}(z_{\\mathcal{V}}) \\rangle(\\mathbf{x})]<span class="math"> and </span>\\mathbb{P}[\\mathcal{A}(t,\\mathbf{x}) = 1 \\land (\\text{Accept}(t) = 1 \\Rightarrow \\mathrm{Sat}_{\\mathcal{L}}(\\mathbf{x}, w) = 1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pp \\gets \\text{Gen}(1^{\\lambda}) \\land (\\mathbf{x}, z_{\\mathcal{P}}) \\gets A(pp) \\land (t, w) \\gets E^{\\mathcal{P}^*(z_{\\mathcal{P}})}(\\mathbf{x})]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Witness-extended emulation implies soundness and knowledge soundness. For a <span class="math">(2\\mu + 1)</span>-move interactive protocol, a <span class="math">(w_1, \\ldots, w_\\mu)</span>-tree of accepting transcripts is a tree of depth <span class="math">\\mu</span> in which: (1) the root is labelled with <span class="math">\\mathbf{x}</span> and the initial <span class="math">\\mathcal{P}</span> message; (2) each node at depth <span class="math">i</span> has <span class="math">w_i</span> children, labelled with distinct <span class="math">\\mathcal{V}</span> challenges and subsequent <span class="math">\\mathcal{P}</span> message; (3) the concatenation of the labels on any path from the root to a leaf of the tree is an accepting transcript for the protocol.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 5 (Tree extractability (arguments)).</strong> A <span class="math">(2\\mu + 1)</span>-move interactive protocol <span class="math">(\\mathcal{P}, \\mathcal{V})</span> with Verifier message space <span class="math">\\mathcal{C}</span> is <span class="math">(W, \\epsilon)</span>-tree extractable if there exists a PPT algorithm extracting a witness from <span class="math">(w_1, \\ldots, w_\\mu)</span>-tree of accepting transcripts with failure probability <span class="math">\\leq \\epsilon</span>, <span class="math">\\prod_i w_i \\leq W</span> and $\\max_i (w_i) \\leq \\epsilon</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Definition 6 (Tree extractability (reductions)).</strong> We say an interactive protocol reducing <span class="math">\\mathbf{x} \\in \\mathcal{L}</span> to <span class="math">\\mathbf{x}&#x27; \\in \\mathcal{L}&#x27;</span> is <span class="math">(W, \\epsilon)</span>-tree extractable if the composition of this argument with a final <span class="math">\\mathcal{P}</span> message revealing a witness <span class="math">w&#x27;</span> for <span class="math">\\mathbf{x}&#x27; \\in \\mathcal{L}&#x27;</span> is a <span class="math">(W, \\epsilon)</span>-tree extractable argument for <span class="math">\\mathcal{L}</span>.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Lemma 4.</h6>

    <p class="text-gray-300">Let <span class="math">(\\mathcal{P},\\mathcal{V})</span> be a <span class="math">(W,\\epsilon)</span>-tree extractable reduction from <span class="math">\\mathcal{L}</span> to <span class="math">\\mathcal{L}^{\\prime}</span>, and <span class="math">(\\mathcal{P}^{\\prime},\\mathcal{V}^{\\prime})</span> be a <span class="math">(W^{\\prime},\\epsilon^{\\prime})</span>-tree extractable argument for <span class="math">\\mathcal{L}^{\\prime}</span>. Then the composition of <span class="math">(\\mathcal{P},\\mathcal{V})</span> and <span class="math">(\\mathcal{P}^{\\prime},\\mathcal{V}^{\\prime})</span> is a <span class="math">(WW^{\\prime},\\epsilon+W\\epsilon^{\\prime})</span>-tree extractable argument for <span class="math">\\mathcal{L}</span>.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let the first protocol be extractable from a <span class="math">(w_{1},\\ldots,w_{\\mu})</span>-tree of accepting transcripts and the second from a <span class="math">(w_{1}^{\\prime},\\ldots,w_{\\mu^{\\prime}}^{\\prime})</span>-tree of accepting transcripts. We ask for a <span class="math">(w_{1},\\ldots,w_{\\mu},w_{1}^{\\prime},\\ldots,w_{\\mu^{\\prime}}^{\\prime})</span>-tree of accepting transcripts, which has size bounded by <span class="math">WW^{\\prime}</span>. We run the PPT extractor for <span class="math">(\\mathcal{P},\\mathcal{V})</span> on the depth <span class="math">w_{\\mu}</span> subtree rooted at the origin, and for each new witness <span class="math">w^{\\prime}</span> for <span class="math">\\mathds{x}^{\\prime}\\in\\mathcal{L}^{\\prime}</span> that it asks for we run the PPT extractor for <span class="math">(\\mathcal{P}^{\\prime},\\mathcal{V}^{\\prime})</span> on the depth <span class="math">w_{\\mu^{\\prime}}</span> subtree rooted at this depth <span class="math">\\mu</span> point. We run the inner extractor at most <span class="math">W</span> times, so taking a union bound our overall failure probability is bounded by <span class="math">\\epsilon+W\\epsilon^{\\prime}</span>.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Lemma 5 (<em>[15, Lemma 1]**[40, Lemma 13]</em>).</h6>

    <p class="text-gray-300">If <span class="math">W=\\texttt{poly}(\\lambda)</span> and <span class="math">\\epsilon=\\texttt{negl}(\\lambda)</span>, then any <span class="math">(W,\\epsilon)</span>-tree extractable <span class="math">(\\mathcal{P},\\mathcal{V})</span> has witness-extended emulation.</p>

    <p class="text-gray-300">We now state a lemma whose object is to obtain results similar to those provided by the Schwartz-Zippel lemma without requiring random evaluation points.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Lemma 6.</h6>

    <p class="text-gray-300">For <span class="math">V</span> a finite vector space over <span class="math">\\mathbb{F}</span>, if <span class="math">g\\in V[X,X^{-1}]</span> is a formal Laurent polynomial of degree <span class="math">d</span> and order <span class="math">e</span>, and <span class="math">g(x)=[0]_{V}</span> for <span class="math">d+e+1</span> values of <span class="math">x\\in\\mathbb{F}</span> then <span class="math">g\\equiv[0]_{V}</span>.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300"><span class="math">V</span> is finite so has a basis <span class="math">\\{v_{1},\\ldots,v_{k}\\}</span>. Each coefficient of <span class="math">g</span> can be uniquely represented by a linear combination of the <span class="math">v_{i}</span>, so there exist Laurent polynomials <span class="math">f_{i}\\in\\mathbb{F}[X,X^{-1}]</span> of degree at most <span class="math">d</span> and order at most <span class="math">e</span> such that: <span class="math">g\\equiv\\sum_{i}v_{i}\\cdot f_{i}</span>. At each of the given <span class="math">d+e+1</span> values each of these <span class="math">f_{i}</span> vanish. So <span class="math">f_{i}(X).X^{e}</span> is a polynomial of degree <span class="math">\\leq d+e</span>, vanishing at <span class="math">&gt;d+e</span> points. So each <span class="math">f_{i}\\equiv 0</span> by the factor theorem and hence <span class="math">g\\equiv[0]_{V}</span></p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Remark 2.</h6>

    <p class="text-gray-300">Suitable vector spaces <span class="math">V</span> for the above lemma include any <span class="math">\\mathbb{G}</span> a group of order <span class="math">p</span>, or any finite vector <span class="math">\\mathbb{G}^{k}</span> of such a group, or Laurent polynomials in another variable <span class="math">Y</span> of bounded degree and order (as a finite dimensional sub-space of the vector space <span class="math">\\mathbb{G}^{k}[Y,\\,Y^{-1}]</span>).</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">2.4 Commitments</h3>

    <p class="text-gray-300">As in <em>[37]</em>, we work with the definitions of polynomial commitments from Bünz et al. <em>[19]</em>, which allows interactive proofs for evaluations, rather than those of Kate et al. <em>[32]</em>. A <em>commitment scheme</em> for some space of messages <span class="math">\\mathcal{X}</span> is a tuple of three protocols (<span class="math">\\mathsf{Gen},\\mathsf{Commit},\\mathsf{Open}</span>):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">pp\\leftarrow\\mathsf{Gen}(1^{\\lambda})</span>: produces public parameters <span class="math">pp</span>.</li>

      <li><span class="math">(\\mathcal{C},\\mathcal{S})\\leftarrow\\mathsf{Commit}(pp;\\,x)</span>: takes as input some <span class="math">x\\in\\mathcal{X}</span>; produces a public commitment <span class="math">\\mathcal{C}</span> and a secret opening hint <span class="math">\\mathcal{S}</span>.</li>

      <li><span class="math">b\\leftarrow\\mathsf{Open}(pp;\\,\\mathcal{C},x,\\mathcal{S})</span>: verifies the opening of commitment <span class="math">\\mathcal{C}</span> to <span class="math">x\\in\\mathcal{X}</span> with the opening hint <span class="math">\\mathcal{S}</span>; outputs <span class="math">b\\in\\{0,1\\}</span></li>

    </ul>

    <p class="text-gray-300">Our commitment schemes sample <span class="math">\\mathcal{S}</span> uniformly from some space, so we can pass it as a parameter, which gives a modified signature <span class="math">\\mathcal{C} \\leftarrow \\text{Commit}(pp; \\mathcal{S})</span>.</p>

    <p class="text-gray-300"><strong>Definition 7.</strong> A tuple of three protocols (Gen, Commit, Open) is a commitment scheme for <span class="math">\\mathcal{X}</span> if for any PPT adversary <span class="math">\\mathcal{A}</span>:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P} \\left[ \\begin{array}{c} b_0 = b_1 = 1 \\\\ \\wedge x_0 \\neq x_1 \\end{array} \\Bigg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} pp \\leftarrow \\text{Gen}(1^\\lambda) \\wedge (\\mathcal{C}, x_0, x_1, \\mathcal{S}_0, \\mathcal{S}_1) = \\mathcal{A}(pp) \\wedge \\\\ b_0 \\leftarrow \\text{Open}(pp; \\mathcal{C}, x_0, \\mathcal{S}_0) \\wedge b_1 \\leftarrow \\text{Open}(pp; \\mathcal{C}, x_1, \\mathcal{S}_1) \\end{array} \\right] \\leq \\text{negl}(\\lambda).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><strong>Definition 8.</strong> A commitment scheme (Gen, Commit, Open) provides hiding commitments if for all PPT adversaries <span class="math">\\mathcal{A} = (\\mathcal{A}_0, \\mathcal{A}_1)</span>:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1 - 2 \\cdot \\mathbb{P} \\left[ b = \\bar{b} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} pp \\leftarrow \\text{Gen}(1^\\lambda) \\wedge \\\\ (x_0, x_1, st) = \\mathcal{A}_0(pp) \\wedge b \\stackrel{\\$}{\\leftarrow} \\{0, 1\\} \\wedge \\\\ (\\mathcal{C}, \\mathcal{S}) \\leftarrow \\text{Commit}(pp; x_b) \\wedge \\bar{b} \\leftarrow \\mathcal{A}_1(st, \\mathcal{C}) \\end{array} \\right] \\right] \\leq \\text{negl}(\\lambda) \\right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">If this holds for all algorithms, then the commitment is statistically hiding.</p>

    <p class="text-gray-300"><strong>Pedersen and AFGHO Commitments:</strong> For messages <span class="math">\\mathcal{X} = \\mathbb{F}^n</span> and any <span class="math">i \\in \\{1,2,T\\}</span>, the Pedersen commitment scheme is defined by:</p>

    <div class="my-4 text-center"><span class="math-block">pp \\leftarrow \\text{Gen}(1^\\lambda) = \\left(g \\stackrel{\\$}{\\leftarrow} G_i^n, h \\stackrel{\\$}{\\leftarrow} G_i\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">(\\mathcal{C}, \\mathcal{S}) \\leftarrow \\text{Commit}(pp; x) = \\left\\{ r \\stackrel{\\$}{\\leftarrow} \\mathbb{F} ; (\\langle x, g \\rangle + rh, r) \\right\\}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\text{Open}(pp; \\mathcal{C}, x, \\mathcal{S}) = (\\langle x, g \\rangle + r(h) \\stackrel{?}{=} \\mathcal{C})</span></div>

    <p class="text-gray-300">If DLOG in <span class="math">\\mathbb{G}_i</span> is hard, then this is a hiding commitment scheme. Similarly, Abe et. al. [3] define a structure preserving commitment to group elements. In this case we have <span class="math">\\mathcal{X} = \\mathbb{G}_i^n</span> for <span class="math">i \\in \\{1,2\\}</span> and:</p>

    <div class="my-4 text-center"><span class="math-block">pp \\leftarrow \\text{Gen}(1^\\lambda) = \\left(g \\stackrel{\\$}{\\leftarrow} G_{3-i}^n, H_1 \\stackrel{\\$}{\\leftarrow} G_1, H_2 \\stackrel{\\$}{\\leftarrow} G_2\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">(\\mathcal{C}, \\mathcal{S}) \\leftarrow \\text{Commit}(pp; x) = \\left\\{ r \\stackrel{\\$}{\\leftarrow} \\mathbb{F} ; (\\langle x, g \\rangle + r \\cdot e(H_1, H_2), r) \\right\\}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\text{Open}(pp, \\mathcal{C}, x, \\mathcal{S}) = (\\langle x, g \\rangle + \\mathcal{S} \\cdot e(H_1, H_2) \\stackrel{?}{=} \\mathcal{C})</span></div>

    <p class="text-gray-300">This is hiding as <span class="math">r \\cdot e(H_1, H_2)</span> is uniformly random in <span class="math">\\mathbb{G}_T</span>. It is a commitment conditional on SXDH; providing two distinct openings violates Lemma 3). This commitment reduces to that of [3], since in that work an opening for a commitment to a vector <span class="math">x \\in \\mathbb{G}_1^n</span> would supply some <span class="math">R \\in G_1</span> such that <span class="math">\\mathcal{C} = \\langle x, g \\rangle + e(R, H_2)</span>. Here, an opening provides <span class="math">r \\in \\mathbb{F}</span> such that <span class="math">R = rH_1</span>, which is strictly stronger. Both the Pedersen and AFGHO commitments are additively homomorphic.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Remark 3.</strong> The existence of $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{1/2}<span class="math">-time attacks on DLOG on curves implies that if SXHD holds then </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-1/2} = \\text{negl}(\\lambda)$; in the sequel we will assume this.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">11</p>

    <p class="text-gray-300">Commitments to matrices Composing the Pedersen and AFGHO commitments yields a two-tiered homomorphic commitment [27] to matrices. Formally, we take  <span class="math">\\mathcal{X} = \\mathbb{F}^{n\\times m}</span> , and for  <span class="math">M_{ij}\\in \\mathcal{X}</span>  we have:</p>

    <div class="my-4 text-center"><span class="math-block">p p \\leftarrow \\operatorname {G e n} \\left(1 ^ {\\lambda}\\right) = \\left(\\Gamma_ {1} \\stackrel {{\\S}} {{\\leftarrow}} \\mathbb {G} _ {1} ^ {m}, H _ {1} \\stackrel {{\\S}} {{\\leftarrow}} \\mathbb {G} _ {1}, \\Gamma_ {2} \\stackrel {{\\S}} {{\\leftarrow}} \\mathbb {G} _ {2} ^ {n}, H _ {2} \\stackrel {{\\S}} {{\\leftarrow}} \\mathbb {G} _ {2}\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">(\\mathcal {C}, \\mathcal {S}) \\leftarrow \\mathsf {C o m m i t} (p p; M _ {i j}) = \\left\\{ \\begin{array}{c} r _ {r o w s} \\stackrel {{\\S}} {{\\leftarrow}} \\mathbb {F} ^ {n}; r _ {f i n} \\stackrel {{\\S}} {{\\leftarrow}} \\mathbb {F}; H _ {T} \\leftarrow e (H _ {1}, H _ {2}); \\\\ V _ {i} \\leftarrow \\mathsf {C o m m i t} _ {P e d e r s e n} ((\\Gamma_ {1}, H _ {1}); M _ {i j}, r _ {r o w s, i}); \\\\ C \\leftarrow \\mathsf {C o m m i t} _ {A F G H O} ((\\Gamma_ {2}, H _ {T}); \\vec {V}, r _ {f i n}; \\\\ (C, (r _ {r o w s}, r _ {f i n}, \\vec {V})) \\end{array} \\right\\}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {O p e n} (p p; \\mathcal {C}, M, \\mathcal {S}) = \\left( \\begin{array}{c} \\mathcal {C} \\stackrel {?} {=} \\sum_ {i} \\Gamma_ {2 i} \\left(\\sum_ {j} M _ {i j} \\Gamma_ {1 j} + r _ {r o w s, i} H _ {1}\\right) \\\\ + r _ {f i n} \\cdot e (H _ {1}, H _ {2}) \\end{array} \\right)</span></div>

    <p class="text-gray-300">Remark 4.  <span class="math">\\vec{V} \\in \\mathbb{G}_1^n</span>  is a vector of hiding commitments to the rows of  <span class="math">M</span> . So if  <span class="math">\\vec{L} \\in \\mathbb{F}^n</span>  then  <span class="math">\\sum L_i V_i \\in \\mathbb{G}_1</span>  is a hiding commitment to  <span class="math">\\vec{L}^T M \\in \\mathbb{F}^m</span> .</p>

    <h2 id="sec-20" class="text-2xl font-bold">2.5 Polynomial commitments and evaluation from vector-matrix-vector products</h2>

    <p class="text-gray-300">Let  <span class="math">(\\mathsf{Gen}_{\\mathbb{F}},\\mathsf{Commit}_{\\mathbb{F}},\\mathsf{Open}_{\\mathbb{F}})</span>  be a commitment scheme for  <span class="math">\\mathcal{X} = \\mathbb{F}</span>  with public parameters  <span class="math">pp_{\\mathbb{F}}</span> . We define polynomial commitments for multilinear polynomials, following [37,19], which (contra Kate [32]) allow interactive evaluation proofs.</p>

    <p class="text-gray-300"><strong>Definition 9.</strong> A tuple of protocols (Gen, Commit, Open, Eval) is an honest-verifier, zero-knowledge, extractable polynomial commitment scheme for  <span class="math">\\ell</span> -variable multilinear polynomials over  <span class="math">\\mathbb{F}</span>  if (Gen, Commit, Open) is a commitment scheme for  <span class="math">\\ell</span> -variable multilinear polynomials over  <span class="math">\\mathbb{F}</span> , and Eval is an HVSZK interactive argument of knowledge for:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {R} _ {E v a l} (p p, p p _ {\\mathbb {F}}) = \\left\\{\\langle (\\mathcal {C} _ {G}, \\vec {x}, \\mathcal {C} _ {v}), (G, \\mathcal {S} _ {G}, v, \\mathcal {S} _ {v}) \\rangle \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} G \\in \\mathbb {F} [ X _ {1}, \\ldots , X _ {\\ell} ] \\\\ \\wedge G \\text{ is multilinear} \\\\ \\wedge v \\in \\mathbb {F} \\wedge G (\\vec {x}) = v \\\\ \\wedge \\mathsf {O p e n} (p p; \\mathcal {C} _ {G}, G, \\mathcal {S} _ {G}) = 1 \\\\ \\wedge \\mathsf {O p e n} _ {\\mathbb {F}} (p p _ {\\mathbb {F}}; \\mathcal {C} _ {v}, v, \\mathcal {S} _ {v}) = 1 \\end{array} \\right. \\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Note that we have modified the definition from [19] by requiring evaluations  <span class="math">G(\\vec{x})</span>  are committed, which is required for zkSNARK applications. We also define a weaker knowledge soundness property useful for R1CS SNARKs as in [15,37]:</p>

    <p class="text-gray-300"><strong>Definition 10. Random Evaluation Knowledge Soundness.</strong></p>

    <p class="text-gray-300">For  <span class="math">pp \\gets \\mathsf{Gen}(1^{\\lambda})</span> ,  <span class="math">pp_{\\mathbb{F}} \\gets \\mathsf{Gen}_{\\mathbb{F}}(1^{\\lambda})</span> , and commitment  <span class="math">\\mathcal{C}_G</span> , the protocol:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {V} \\rightarrow \\mathcal {P}: \\vec {x} \\stackrel {\\S} {\\leftarrow} \\mathbb {F} ^ {\\ell}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {P}: \\left(\\mathcal {C} _ {e}, \\mathcal {S} _ {e}\\right) \\leftarrow \\operatorname {C o m m i t} _ {\\mathbb {F}} \\left(p p _ {\\mathbb {F}}; G (\\vec {x})\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {P} \\rightarrow \\mathcal {V}: \\mathcal {C} _ {\\mathbb {F}}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {P}, \\mathcal {V}: \\text{Accept if } \\operatorname {E v a l} (p p, p p _ {\\mathbb {F}}; \\mathcal {C} _ {G}, \\vec {x}, \\mathcal {C} _ {v}) = 1.</span></div>

    <p class="text-gray-300">is an argument of knowledge with witness-extended emulation for:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {R} (p p, p p _ {\\mathbb {F}}) = \\left\\{\\langle \\mathcal {C} _ {G}, (G, \\mathcal {S} _ {G}, \\mathcal {S} _ {v}) \\rangle \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} G \\in \\mathbb {F} [ X _ {1}, \\ldots , X _ {\\ell} ] \\text { is multilinear} \\\\ \\wedge v \\in \\mathbb {F} \\wedge G (\\vec {x}) = v \\\\ \\wedge \\text {Open} (p p; \\mathcal {C} _ {G}, G, \\mathcal {S} _ {G}) = 1 \\\\ \\wedge \\text {Open} _ {\\mathbb {F}} (p p _ {\\mathbb {F}}; \\mathcal {C} _ {v}, v, \\mathcal {S} _ {v}) = 1 \\end{array} \\right\\}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We say a scheme providing this property in place of knowledge soundness is random evaluation extractable. We also note that prior polynomial commitment schemes in [15,20] satisfy only this weaker property. In these works, the commitment to a polynomial is a  <span class="math">n^{1/2}</span>  length list of commitments to lists of scalars of length  <span class="math">n^{1/2}</span>  (resp. a structure-preserving commitment to a list of Kate commitments to polynomials). However, for any particular point of evaluation  <span class="math">\\vec{x}</span> ,  <span class="math">\\mathcal{P}</span>  only shows that know an opening of some  <span class="math">\\vec{x}</span> -dependent linear combination of these commitments. So a Knowledge Soundness adversary may pick  <span class="math">\\vec{x}</span> , then produce  <span class="math">\\mathcal{C}_G</span> , without knowledge of openings of all rows (and hence without knowledge of a  <span class="math">G, S_G</span>  opening of  <span class="math">\\mathcal{C}_G</span> ). In the R1CS SNARK context of [15], this is mitigated as the surrounding protocol enforces that  <span class="math">\\vec{x} \\gets \\mathbb{F}^\\ell</span>  after  <span class="math">\\mathcal{C}_G</span>  is made public.</p>

    <p class="text-gray-300">Any polynomial  <span class="math">f</span>  in variables  <span class="math">X_{1},\\ldots ,X_{\\ell}</span>  of degree  <span class="math">d_{1},\\ldots ,d_{\\ell}</span>  can be reformulated as a multilinear polynomial in  <span class="math">\\{X_i,X_i^2,\\dots X_i^{2^{\\lceil \\log (d_i + 1)\\rceil -1}}:i\\in [\\ell ]\\}</span> . For example, the bivariate polynomial  <span class="math">f(X_{1},X_{2})\\coloneqq 1 + X_{1}^{2}X_{2} + X_{1}^{7}</span>  can be written as a 4-variable multilinear polynomial  <span class="math">g(Y_1,Y_2,Y_3,Y_4) = 1 + Y_2Y_4 + Y_1Y_2Y_3</span> , with  <span class="math">f(x_{1},x_{2})\\equiv g(x_{1},x_{1}^{2},x_{1}^{4},x_{2})</span> . Any multilinear polynomial  <span class="math">g</span>  in  <span class="math">r</span>  variables can be written as a sum of monomials, so:</p>

    <div class="my-4 text-center"><span class="math-block">g (x _ {1}, \\dots , x _ {r}) = \\sum_ {(i _ {1}, \\dots , i _ {r}) \\in \\{1, 2 \\} ^ {r}} T _ {i _ {1}, \\dots , i _ {r}} \\prod_ {j \\in \\{1, \\dots , r \\}} x _ {j} ^ {i _ {j} - 1},</span></div>

    <p class="text-gray-300">where  <span class="math">T</span>  is an order  <span class="math">r</span>  tensor. In the given concrete example,  <span class="math">T</span>  would be an  <span class="math">2 \\times 2 \\times 2 \\times 2</span>  tensor  <span class="math">T_{ijkl}</span> , with  <span class="math">T_{1111} = T_{1212} = T_{2221} = 1</span>  and  <span class="math">T_{ijkl} = 0</span>  otherwise. Note that this sum is the contraction of  <span class="math">T</span>  with the  <span class="math">r</span>  vectors  <span class="math">(1, \\vec{x}_i)</span> . In general, for any  <span class="math">n_1 \\times \\ldots \\times n_r</span>  tensor  <span class="math">T</span>  and  <span class="math">0 \\leq k \\leq r</span>  we can rearrange  <span class="math">T</span>  into a  <span class="math">(\\prod_{i &amp;lt; k} n_i) \\times (\\prod_{i \\geq k} n_i)</span>  matrix  <span class="math">M</span> , such that:</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {i _ {1} = 1} ^ {n _ {1}} \\dots \\sum_ {i _ {r} = 1} ^ {n _ {r}} T _ {i _ {1} \\dots i _ {r}} (\\vec {v _ {j}}) _ {i _ {j}} = \\left(\\otimes_ {i &amp;lt;   k} \\vec {v _ {i}}\\right) ^ {T} M \\left(\\otimes_ {i \\geq k} \\vec {v _ {i}}\\right)</span></div>

    <p class="text-gray-300">for all vectors  <span class="math">\\vec{v_i} \\in \\mathbb{F}^{n_i}</span> . Explicitly this is given by setting  <span class="math">M_{ij} \\coloneqq T_{i_1, \\dots, i_r}</span>  where:</p>

    <div class="my-4 text-center"><span class="math-block">i - 1 = \\left(i _ {k - 1} - 1\\right) + n _ {k - 1} \\left(\\left(i _ {k - 2} - 1\\right) + n _ {k - 2} \\left(\\dots \\left(\\left(i _ {2} - 1\\right) + n _ {2} \\left(i _ {1} - 1\\right)\\right)\\right)\\right),</span></div>

    <div class="my-4 text-center"><span class="math-block">j - 1 = \\left(i _ {r} - 1\\right) + n _ {r} \\left(\\left(i _ {r - 1} - 1\\right) + n _ {r - 1} \\left(\\dots \\left(\\left(i _ {k + 1} - 1\\right) + n _ {k + 1} \\left(i _ {k} - 1\\right)\\right)\\right)\\right)</span></div>

    <p class="text-gray-300">2 In applications for multilinear polynomials in ℓ variables, it is often convenient to specify a polynomial on some cube, e.g. {0,1}ℓ rather than by coefficients. In this case, analogous formulae exist, as:</p>

    <div class="my-4 text-center"><span class="math-block">g (\\vec {x}) = \\sum_ {i _ {1}, \\dots , i _ {r} \\in \\{0, 1 \\}} g (i _ {1}, \\dots , i _ {r}) \\prod_ {j \\in 1, \\dots , r} \\left(1 - x _ {j}, x _ {j}\\right) _ {i _ {j} + 1},</span></div>

    <p class="text-gray-300">Similar formulae interpolate  <span class="math">g</span>  from evaluations on any set  <span class="math">\\{a_1, b_1\\} \\times \\ldots \\times \\{a_\\ell, b_\\ell\\}</span> .</p>

    <p class="text-gray-300">We select <span class="math">k</span> to make the matrix <span class="math">M</span> approximately square. In our concrete example <span class="math">k = 2</span> and <span class="math">M_{ij}</span> is a <span class="math">4 \\times 4</span> matrix with <span class="math">M_{11} = M_{22} = M_{43} = 1</span> and <span class="math">M_{ij} = 0</span> otherwise.</p>

    <p class="text-gray-300">So the evaluation of <span class="math">f</span> at some point <span class="math">x</span> can be replaced with the evaluation of a multilinear polynomial in <span class="math">r = \\sum_{i} \\lceil \\log(d_i + 1) \\rceil</span>, variables, which can in turn be replaced by a vector-matrix-vector product with vectors of length at most <span class="math">2^m = 2^{\\lceil r/2 \\rceil} = O\\left(\\left(\\prod_i d_i\\right)^{1/2} 2^{\\ell/2}\\right)</span>. The vectors in this product have multiplicative structure, being formed as Kronecker products of vectors <span class="math">(1, x_i^{2^i})</span> for <span class="math">i \\in \\{1, \\ldots, r\\}</span>, <span class="math">j \\in \\{0, \\ldots, \\lceil \\log(d_i + 1) \\rceil - 1\\}</span>. For univariate polynomials of degree <span class="math">d</span>, <span class="math">m \\leq (3 + \\log d)/2</span>, and for multilinear polynomials in <span class="math">\\ell</span> variables <span class="math">m \\leq (\\ell + 1)/2</span>. In the concrete example, we have:</p>

    <div class="my-4 text-center"><span class="math-block">f (x _ {1}, x _ {2}) \\equiv g (x _ {1}, x _ {1} ^ {2}, x _ {1} ^ {4}, x _ {2}) = (1, x _ {1} ^ {2}, x _ {1}, x _ {1} ^ {3}) ^ {T} M (1, x _ {2}, x _ {1} ^ {4}, x _ {1} ^ {4} x _ {2}),</span></div>

    <p class="text-gray-300">where the two vectors <span class="math">(1, x_1^2, x_1, x_1^3) = (1, x_1) \\otimes (1, x_1^2)</span> and <span class="math">(1, x_2, x_1^4, x_1^4 x_2) = (1, x_1^4) \\otimes (1, x_2)</span> have multiplicative structure.</p>

    <p class="text-gray-300">We begin by showing the simplest form of Dory: an argument for inner products between two vectors in <span class="math">\\vec{v_1} \\in \\mathbb{G}_1^n</span>, <span class="math">\\vec{v_2} \\in \\mathbb{G}_2^n</span>, committed with AFGHO commitments with generators <span class="math">(\\Gamma_2, e(H_1, H_2)) \\in \\mathbb{G}_2^n \\times \\mathbb{G}_T</span> and <span class="math">(\\Gamma_1, e(H_1, H_2)) \\in \\mathbb{G}_1^n \\times \\mathbb{G}_T</span> respectively.</p>

    <p class="text-gray-300">In our initial presentation of the protocols, and discussions of completeness and soundness, we will highlight that which is required only to achieve hiding in commitments and zero-knowledge in the protocols in blue. Discussion of HVSZK properties necessarily requires that commitments be hiding and the full zero-knowledge protocols are used. Formally, we define a language:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} (C, D _ {1}, D _ {2}) \\in \\mathcal {L} _ {n, \\Gamma_ {1}, \\Gamma_ {2}, H _ {1}, H _ {2}} \\subset \\mathbb {G} _ {T} ^ {3} \\\\ \\Leftrightarrow \\exists (\\vec {v _ {1}} \\in \\mathbb {G} _ {1} ^ {n}, \\vec {v _ {2}} \\in \\mathbb {G} _ {2} ^ {n}, r _ {C} \\in \\mathbb {F}, r _ {D _ {1}} \\in \\mathbb {F}, r _ {D _ {2}} \\in \\mathbb {F}): \\\\ D _ {1} = \\langle \\vec {v _ {1}}, \\Gamma_ {2} \\rangle + r _ {D _ {1}} \\cdot e (H _ {1}, H _ {2}), \\quad D _ {2} = \\langle \\Gamma_ {1}, \\vec {v _ {2}} \\rangle + r _ {D _ {2}} \\cdot e (H _ {1}, H _ {2}), \\\\ C = \\langle \\vec {v _ {1}}, \\vec {v _ {2}} \\rangle + r _ {C} \\cdot e (H _ {1}, H _ {2}) \\end{array}</span></div>

    <p class="text-gray-300">For <span class="math">n</span> even, and <span class="math">\\Gamma_{\\{1,2\\}}&#x27; \\in \\mathbb{G}_{[1,2]}^{2^{n/2}}</span>, we will show (Section 3.2) an reduction from membership in <span class="math">\\mathcal{L}_{n,\\Gamma_1,\\Gamma_2,H_1,H_2}</span> to membership in <span class="math">\\mathcal{L}_{n/2,\\Gamma_1&#x27;,\\Gamma_2&#x27;,H_1,H_2}</span>. In Section 3.1, we give an argument of knowledge for <span class="math">\\mathcal{L}_{1,\\Gamma_1,\\Gamma_2,H_1,H_2}</span>. In Section 3.4 we give an argument reducing two claims of membership of <span class="math">\\mathcal{L}_{n,\\Gamma_1,\\Gamma_2,H_1,H_2}</span> to one. In Section 3.3 we discuss concrete efficiency and optimisations for <span class="math">\\mathcal{V}</span>.</p>

    <p class="text-gray-300">We give a interactive argument of knowledge for <span class="math">\\mathcal{L}_{1,\\Gamma_1,\\Gamma_2,H_1,H_2}</span>. This requires showing the product of two elements <span class="math">v_{1} \\in \\mathbb{G}_{1}</span> and <span class="math">v_{2} \\in \\mathbb{G}_{2}</span> under AFGHO commitments; the analogous argument for Pedersen commitments is folklore. Since pairings are more expensive than multiplications in <span class="math">\\mathbb{G}_1</span> or <span class="math">\\mathbb{G}_2</span>, we combine the usual final three checks into a single pairing with a Verifier challenge.</p>

    <p class="text-gray-300">|  Scalar-ProductΓ1,Γ2,H1,H2(C,D1,D2)  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  Precompute: HT = e(H1,H2), χ = e(Γ1,Γ2)  |</p>

    <p class="text-gray-300">|  P witness: (v1,v2,rC,rD1,rD2) for (C,D1,D2) ∈ L1,Γ1,Γ2,H1,H2  |</p>

    <p class="text-gray-300">|  P: rP1,rP2,rQ,rR←<span class="math"> F, d1←</span> G1, d2←$ G2  |</p>

    <p class="text-gray-300">|  P → V: P1 = e(d1,Γ2) + rP1HT, P2 = e(Γ1,d2) + rP2HT, Q = e(d1,v2) + e(v1,d2) + rQHT, R = e(d1,d2) + rRHT, V → P: c←$ F  |</p>

    <p class="text-gray-300">|  P → V: E1← d1 + cv1, E2← d2 + cv2, r1← rP1 + crD1, r2← rP2 + crD2, r3← rR + crQ + c2rC  |</p>

    <p class="text-gray-300">|  V: d←$ F, accept if: e(E1 + dΓ1,E2 + d-1Γ2) = χ + R + cQ + c2C + dP2 + dcD2 + d-1P1 + d-1cD1 - (r3 + dr2 + d-1r1)HT  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 1. For  <span class="math">\\Gamma_1, H_1 \\stackrel{\\S}{\\leftarrow} \\mathbb{G}_1</span> ,  <span class="math">\\Gamma_2, H_2 \\stackrel{\\S}{\\leftarrow} \\mathbb{G}_2</span> , Scalar-Product is an HVSZK, public-coin, succinct interactive argument of knowledge for  <span class="math">\\mathcal{L}_{1,\\Gamma_1,\\Gamma_2,H_1,H_2}</span>  with  $(9,9/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ -tree extractability under SXDH.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. Succinctness and the Public Coin property are immediate. Completeness holds as for an honest Prover:</p>

    <p class="text-gray-300"><span class="math">e(E_{1} + d\\Gamma_{1},E_{2} + d^{-1}\\Gamma_{2})</span></p>

    <p class="text-gray-300"><span class="math">= e(d_{1} + cv_{1},d_{2} + cv_{2})</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">d\\cdot e(\\Gamma_1,d_2 + cv_2) + d^{-1}\\cdot e(d_1 + cv_1,\\Gamma_2) + e(\\Gamma_1,\\Gamma_2)</span></li>

    </ul>

    <p class="text-gray-300"><span class="math">= \\chi +c^{2}\\cdot e(v_{1},v_{2}) + c[e(d_{1},v_{2}) + e(v_{1},d_{2})] + e(d_{1},d_{2})</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">d\\cdot e(\\Gamma_1,d_2) + dc\\cdot e(\\Gamma_1,v_2) + d^{-1}\\cdot e(d_1,\\Gamma_2) + d^{-1}c\\cdot e(v_1,\\Gamma_2)</span></li>

    </ul>

    <p class="text-gray-300"><span class="math">= \\chi +R + cQ + c^{2}C</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">dP_{2} + dcD_{2} + d^{-1}P_{1} + d^{-1}cD_{1} - (r_{3} + dr_{2} + d^{-1}r_{1})H_{T}</span></li>

    </ul>

    <p class="text-gray-300">so  <span class="math">\\mathcal{V}</span>  accepts.</p>

    <p class="text-gray-300">HVSZK: Note that for an honest  <span class="math">\\mathcal{P}</span> ,  <span class="math">E_1, E_2, Q</span>  are uniformly random in  <span class="math">\\mathbb{G}_T</span>  and  <span class="math">r_1, r_2, r_3 \\stackrel{\\S}{\\leftarrow} \\mathbb{F}</span> . We split the final check into terms that are proportional to  <span class="math">d^{-1}, d, 1</span> :</p>

    <p class="text-gray-300"><span class="math">P_{1} = e(E_{1},\\Gamma_{2}) + r_{1}H_{T} - cD_{1},</span> <span class="math">P_{2} = e(\\Gamma_{1},E_{2}) + r_{2}H_{T} - cD_{2},</span></p>

    <p class="text-gray-300"><span class="math">R = e(E_{1},E_{2}) + r_{3}H_{T} - cQ - c^{2}C</span></p>

    <p class="text-gray-300">To construct a simulator: Sample  <span class="math">Q, E_1, E_2 \\stackrel{\\S}{\\leftarrow} \\mathbb{G}_T^3</span>  and compute the challenge  <span class="math">c</span>  from  <span class="math">\\mathcal{V}</span> 's coins. Then sample  <span class="math">r_1, r_2, r_3 \\stackrel{\\S}{\\leftarrow} \\mathbb{F}</span>  and compute  <span class="math">P_1, P_2, R</span>  as above.</p>

    <p class="text-gray-300">Tree extractability: In the simpler case where commitments are not hiding and the protocol is not ZK, then <span class="math">\\mathcal{V}</span> has sent the full witness <span class="math">E_{1}=v_{1},E_{2}=v_{2}</span> to <span class="math">\\mathcal{P}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We have <span class="math">\\mu=2</span> with an empty final <span class="math">\\mathcal{P}</span> message, and set <span class="math">w_{1}=w_{2}=3</span>. So we have a tree of accepting transcripts for <span class="math">3</span> values <span class="math">c</span>, and for each <span class="math">c</span> there are <span class="math">3</span> accepting values of <span class="math">d</span>. We fail if any of these <span class="math">9</span> <span class="math">d</span> are <span class="math">0</span>, which occurs with probability $\\leq 9/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Across all transcripts, </span>P_{1}<span class="math">, </span>P_{2}<span class="math">, </span>Q<span class="math">, </span>R<span class="math">, </span>C<span class="math">, </span>D_{1}<span class="math">, </span>D_{2}<span class="math"> are constant, and </span>E_{1},E_{2},r_{1},r_{2},r_{3}<span class="math"> can be interpolated as quadratics in </span>c$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For each <span class="math">c</span>, the final check contains terms in <span class="math">d</span> only of form <span class="math">d,1,d^{-1}</span>, so is a check of equality of Laurent polynomials of degree and order <span class="math">1</span>. This difference vanishes for three distinct choices of <span class="math">d</span>, so Lemma 6 implies the coefficients for each degree must be separately equal. So for each of the three challenge <span class="math">c</span>:</p>

    <p class="text-gray-300"><span class="math">e(E_{1}(c),E_{2}(c))+r_{3}(c)H_{T}</span> <span class="math">=R+cQ+c^{2}\\,C</span> (1) <span class="math">e(E_{1}(c),\\Gamma_{2})+r_{1}(c)\\cdot e(H_{1},H_{2})</span> <span class="math">=P_{1}+cD_{1}</span> (2) <span class="math">e(\\Gamma_{1},E_{2}(c))+r_{2}(c)\\cdot e(H_{1},H_{2})</span> <span class="math">=P_{2}+cD_{2}</span> (3)</p>

    <p class="text-gray-300">For <span class="math">i=1,2</span>, we interpolate <span class="math">E_{i}(c)=d_{i}+cv_{i}+c^{2}\\,U_{i}</span> and <span class="math">r_{i}=r_{P_{i}}+cr_{D_{i}}+c^{2}r_{U_{i}}</span>. Our first task is to show that <span class="math">\\,U_{i}=[0]_{G_{i}}</span> and <span class="math">r_{U_{i}}=0</span>, i.e. that <span class="math">\\mathcal{P}</span> is constrained to send <span class="math">E_{1},E_{2},r_{1},r_{2}</span> that depend only <em>affinely</em> on <span class="math">c</span>. Equation 2 is an equality of polynomials in <span class="math">\\mathbb{G}_{T}[c]</span> of degree <span class="math">2</span> which holds at <span class="math">3</span> points. Applying Lemma 6, the coefficients are equal. Writing out the quadratic and linear coefficients gives:</p>

    <p class="text-gray-300"><span class="math">e(\\,U_{1},\\Gamma_{2})+e(r_{U_{1}}H_{1},H_{2})=0,\\quad e(v_{1},\\Gamma_{2})+r_{D_{1}}H_{T}=D_{1}.</span></p>

    <p class="text-gray-300">Since <span class="math">\\Gamma_{2},H_{2}\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathbb{G}_{2}<span class="math">, Lemma 3 forces the first equation to be satisfied by </span>\\,U_{1}=r_{U_{1}}H_{1}=[0]_{\\mathbb{G}_{1}}<span class="math">. We also have </span>v_{1},r_{D_{1}}<span class="math"> satisfying our constraint on </span>D_{1}<span class="math">. Similar considerations applied to Equation 3 imply that </span>\\,U_{2}=[0]_{\\mathbb{G}_{2}}<span class="math">, </span>r_{U_{2}}=0<span class="math">, and provide a </span>v_{2},r_{D_{2}}<span class="math"> satisfying the constraint on </span>D_{2}$.</p>

    <p class="text-gray-300">It remains to extract <span class="math">r_{C}</span> to satisfy the constraint on <span class="math">\\,C</span>. We interpolate <span class="math">r_{3}(c)=r_{R}+cr_{Q}+c^{2}r_{C}</span>, and substitute our linear expressions for <span class="math">E_{1},E_{2}</span> into Equation 1:</p>

    <p class="text-gray-300"><span class="math">R+\\,cQ+c^{2}\\,C</span> <span class="math">=e(d_{1},d_{2})+r_{R}H_{T}+c(e(d_{1},v_{2})+e(v_{1},d_{2})+r_{Q}H_{T})</span> <span class="math">+\\,c^{2}(e(v_{1},v_{2})+r_{C}H_{T})</span></p>

    <p class="text-gray-300">This is an equality of quadratics in <span class="math">\\mathbb{G}_{T}[c]</span> holding at <span class="math">3</span> distinct values, so from Lemma 6 the <span class="math">c^{2}</span> coefficients are equal. So <span class="math">\\,C=\\,e(v_{1},v_{2})+r_{C}H_{T}</span>. Hence <span class="math">(v_{1},v_{2},r_{D_{1}},r_{D_{2}},r_{C})</span> is a witness for <span class="math">(C,D_{1},D_{2})\\in\\mathcal{L}_{1,\\Gamma_{1},\\Gamma_{2},H_{1},H_{2}}</span>.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">3.2 Dory-Reduce</h3>

    <p class="text-gray-300">We now show an interactive argument reducing membership of <span class="math">\\mathcal{L}_{2^{m},\\Gamma_{1},\\Gamma_{2},H_{1},H_{2}}</span> to membership of <span class="math">\\mathcal{L}_{2^{m-1},\\Gamma_{1}^{\\prime},\\Gamma_{2}^{\\prime},H_{1},H_{2}}</span>. The simplest approach to this (neglecting zero-knowledge) would be to start with the <span class="math">3</span> claims</p>

    <p class="text-gray-300"><span class="math">D_{1}=\\langle\\vec{v_{1}},\\Gamma_{2}\\rangle,\\qquad\\qquad D_{2}=\\langle\\Gamma_{1},\\vec{v_{2}}\\rangle,\\qquad\\qquad C=\\langle\\vec{v_{1}},\\vec{v_{2}}\\rangle</span></p>

    <p class="text-gray-300">and fold each in some LCC-DLOG-like [15,18,20] fashion with a  <span class="math">\\mathcal{V}</span>  challenge  <span class="math">\\alpha</span>  into claims about  <span class="math">2^{m - 1}</span>  length vectors  <span class="math">v_{i\\alpha}^{\\vec{\\Gamma}},\\Gamma_{i\\alpha}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">D _ {1} ^ {\\prime} = \\langle v _ {1 \\alpha} ^ {-}, \\Gamma_ {2 \\alpha} \\rangle , \\qquad D _ {2} ^ {\\prime} = \\langle \\Gamma_ {1 \\alpha}, v _ {2 \\alpha} ^ {-} \\rangle , \\qquad C ^ {\\prime} = \\langle v _ {1 \\alpha} ^ {-}, v _ {2 \\alpha} ^ {-} \\rangle ,</span></div>

    <p class="text-gray-300"><span class="math">\\mathcal{P}, \\mathcal{V}</span>  would separately compute commitments  <span class="math">\\varDelta_{1}=\\langle v_{1\\alpha}^{-},\\varGamma_{2}^{\\prime}\\rangle</span>  and  <span class="math">\\varDelta_{2\\alpha}=\\langle\\varGamma_1&#x27;,v_{2\\alpha}^-\\rangle</span>  from  <span class="math">\\alpha</span>  and precomputed data.</p>

    <p class="text-gray-300">We would then combine  <span class="math">v_{i\\alpha}^{-}</span>  and  <span class="math">\\Gamma_{i\\alpha}</span>  for each  <span class="math">i</span>  in accordance with additional Verifier challenges. This produces a final  <span class="math">C&#x27;&#x27;</span>  from  <span class="math">C&#x27;, D_1&#x27;, D_2&#x27;</span> , a final  <span class="math">D_1&#x27;&#x27;</span>  from  <span class="math">D_1&#x27;</span>  and  <span class="math">\\Delta_1</span> , and a final  <span class="math">D_2&#x27;&#x27;</span>  from  <span class="math">D_2&#x27;</span>  and  <span class="math">\\Delta_2</span> , with the Prover sending additional cross-terms to support these combinations. However, this approach requires sending at least 8 elements of  <span class="math">\\mathbb{G}_T</span>  (two for each claim to fold and two for the final combining stage). Instead, we effectively swap the order of these two stages, which allows sending only 6 elements of  <span class="math">\\mathbb{G}_T</span> .</p>

    <pre><code class="language-latex">Dory-Reduce  $m,\\Gamma_1,\\Gamma_2,\\Gamma_1&#x27;,\\Gamma_2&#x27;,H_1,H_2(C,D_1,D_2)$
Precompute:  $H_{T} = e(H_{1},H_{2})$ $\\varDelta_{1L}=\\langle\\Gamma_{1L},\\Gamma_{2}^{\\prime}\\rangle$ $\\varDelta_{1R}=\\langle\\Gamma_{1R},\\Gamma_{2}^{\\prime}\\rangle$ $\\varDelta_{2L}=\\langle\\Gamma_{1}^{\\prime},\\Gamma_{2L}\\rangle$ $\\varDelta_{2R}=\\langle\\Gamma_{1}^{\\prime},\\Gamma_{2R}\\rangle$  , and  $\\chi=\\langle\\Gamma_1,\\Gamma_2\\rangle$ $\\mathcal{P}$  witness:  $(\\vec{v}_1,\\vec{v}_2,r_c,r_{D_1},r_{D_2})$  for  $(C,D_1,D_2)\\in \\mathcal{L}_{2^m,\\Gamma_1,\\Gamma_2,H_1,H_2}$ $\\mathcal{P}$  ..  $r_{D_{1L}},r_{D_{1R}},r_{D_{2L}},r_{D_{2R}}\\gets \\S F$ $\\mathcal{P}\\rightarrow \\mathcal{V}$  ..  $D_{1L} = \\langle v_{1L}^{-},\\Gamma_{2}^{\\prime}\\rangle +r_{D_{1L}}H_{T},$ $D_{1R} = \\langle v_{1R}^{-},\\Gamma_{2}^{\\prime}\\rangle +r_{D_{1R}}H_{T}$ $D_{2L} = \\langle \\Gamma_1&#x27;,v_2&#x27; - r_{D_2L}H_T,$ $D_{2R} = \\langle \\Gamma_1&#x27;,v_2&#x27; - r_{D_2R}H_T$ $\\mathcal{V}\\rightarrow \\mathcal{P}$  ..  $\\beta \\leftarrow \\S F$ $\\mathcal{P}(*)$  ..  $\\vec{v}_1\\gets \\vec{v}_1 + \\beta \\Gamma_1$ $\\vec{v}_2\\gets \\vec{v}_2 + \\beta^{-1}\\Gamma_2$ $r_C\\gets r_C + \\beta r_{D_2} + \\beta^{-1}r_{D_1}$ $\\mathcal{P}$  ..  $r_{C+},r_{C-}\\gets \\S F$ $\\mathcal{P}\\rightarrow \\mathcal{V}$  ..  $C_+ = \\langle v_{1L}^{-},v_{2R}^{-}\\rangle +r_{C+}H_{T},$ $C_{-} = \\langle v_{1R}^{-},v_{2L}^{-}\\rangle +r_{C-}H_{T}$ $\\mathcal{V}\\rightarrow \\mathcal{P}$  ..  $\\alpha \\leftarrow \\S F$ $\\mathcal{P}(**)$  ..  $\\vec{v}_1&#x27;\\gets \\alpha v_{1L}^- +v_{1R}^-$ $\\vec{v}_2&#x27;\\gets \\alpha^{-1}v_{2L}^- +v_{2R}^-$ $r_{D_1}&#x27;\\gets \\alpha r_{D_{1L}} + r_{D_{1R}},$ $r_{D_2}&#x27;\\gets \\alpha^{-1}r_{D_{2L}} + r_{D_{2R}},$ $r_C&#x27;\\gets r_C + \\alpha r_{C+} + \\alpha^{-1}r_{C-}$
$\\mathcal{V}(**)$  ..  $C&#x27;\\gets C + \\chi +\\beta D_2 + \\beta^{-1}D_1 + \\alpha C_+ + \\alpha^{-1}C_{-}$ $D_1&#x27;\\gets \\alpha D_{1L} + D_{1R} + \\alpha \\beta \\Delta_{1L} + \\beta \\Delta_{1R}$ $D_2&#x27;\\gets \\alpha^{-1}D_{2L} + D_{2R} + \\alpha^{-1}\\beta^{-1}\\Delta_{2L} + \\beta^{-1}\\Delta_{2R}$
$\\mathcal{V}$  : Accept if  $(C&#x27;,D_1&#x27;,D_2&#x27;)\\in \\mathcal{L}_{2^{m - 1}},\\Gamma_1&#x27;,\\Gamma_2&#x27;,H_1,H_2$ $\\mathcal{P}$  witness:  $(\\vec{v}_1&#x27;,\\vec{v}_2&#x27;,r_C&#x27;,r_{D_1}&#x27;,r_{D_2}&#x27;)$</code></pre>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 2. For  <span class="math">\\Gamma_1&#x27; \\stackrel{\\S}{\\leftarrow} \\mathbb{G}_1^{2^{m-1}}</span> ,  <span class="math">H_1 \\stackrel{\\S}{\\leftarrow} \\mathbb{G}_1</span> ,  <span class="math">\\Gamma_2&#x27; \\stackrel{\\S}{\\leftarrow} \\mathbb{G}_2^{2^{m-1}}</span> ,  <span class="math">H_2 \\stackrel{\\S}{\\leftarrow} \\mathbb{G}_2</span> , Dory-Reduce is an an HVSZK, public-coin, succinct interactive argument of knowledge for  <span class="math">\\mathcal{L}_{2^m, \\Gamma_1, \\Gamma_2, H_1, H_2}</span>  with  $(9,12/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ -tree extractability under SXDH.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Before proving this theorem, we will sketch why tree-extractability holds. First we observe that the  <span class="math">\\mathcal{P}</span>  witness for  <span class="math">(C,D_1&#x27;,D_2&#x27;)\\in \\mathcal{L}_{2^{m - 1}},\\Gamma_1&#x27;,\\Gamma_2&#x27;,H_1,H_2</span>  opens  <span class="math">D_1&#x27;,D_2&#x27;</span>  as binding commitments.  <span class="math">\\nu</span>  computes these commitments with bivariate Laurent polynomials, and across a tree of accepting transcripts  <span class="math">\\mathcal{P}</span>  opens at enough points to allow an extractor to open each coefficient of each polynomial.</p>

    <p class="text-gray-300">Since these commitments are binding, coefficients equal to <span class="math">0</span> must be opened by <span class="math">\\vec{0}</span>, and coefficients <span class="math">\\Delta_{\\{1,2\\}\\{L,R\\}}</span> must be opened by <span class="math">\\Gamma_{\\{1,2\\}\\{L,R\\}}</span>. So <span class="math">\\mathcal{P}</span> is substantially constrained in their witness <span class="math">v_{1}^{\\prime},v_{2}^{\\prime},\\ldots</span>. The extractor also finds vectors opening <span class="math">D_{\\{1,2\\}\\{L,R\\}}</span> (which will end up being <span class="math">v_{\\{1,2\\}\\{L,R\\}}</span>).</p>

    <p class="text-gray-300">Substituting these into the product constraint on <span class="math">C^{\\prime}</span> (as a function of <span class="math">\\alpha,\\beta</span>), we again get an equality of bivariate Laurent polynomials at enough places to force equality of coefficients. Each of <span class="math">C,D_{1},D_{2}</span> can be computed from coefficients of <span class="math">C^{\\prime}</span>, and these will turn out to be exactly the conditions on <span class="math">C,D_{1},D_{2}</span> required to have found a witness <span class="math">(v_{1},v_{2},\\ldots)</span> for <span class="math">(C,D_{1},D_{2})\\in\\mathcal{L}_{2^{\\infty},\\Gamma_{1},\\Gamma_{2},H_{1},H_{2}}</span>. Essentially similar arguments are used throughout for tree-extractability.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Proof (Theorem 2).</h6>

    <p class="text-gray-300">Succinctness and the Public Coin properties are immediate. HVSZK holds as all messages from <span class="math">\\mathcal{P}</span> to <span class="math">\\mathcal{V}</span> are uniformly random elements of <span class="math">\\mathbb{G}_{T}</span>, so are trivially simulated. Completeness holds from substituting the definition of <span class="math">\\mathcal{P}</span>’s witness into the constraints of <span class="math">\\mathcal{L}_{2^{\\infty-1},\\Gamma_{1}^{\\prime},\\Gamma_{2}^{\\prime},H_{1},H_{2}}</span>, and cancelling terms to obtain the constraints of <span class="math">\\mathcal{L}_{2^{\\infty},\\Gamma_{1},\\Gamma_{2},H_{1},H_{2}}</span>.</p>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">Tree extractability</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We have <span class="math">\\mu=2</span>, and set <span class="math">w_{1}=w_{2}=3</span>. So we have a tree of accepting transcripts for <span class="math">3</span> values <span class="math">\\beta</span>, and for each <span class="math">\\beta</span> <span class="math">3</span> values of <span class="math">\\alpha</span>. We fail if any of these challenges are <span class="math">0</span>, which occurs with probability $\\leq 12/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. For each leaf, the Prover reveals the witness </span>(\\vec{v_{1}}^{\\prime},\\vec{v_{2}}^{\\prime},r_{C}^{\\prime},r_{D_{1}}^{\\prime},r_{D_{2}}^{\\prime})$. Our witness extraction is analogous to witness extraction of GIPA in <em>[20]</em> or of the improved inner product argument in <em>[18, Appendix B]</em>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">D_{1L},D_{1R}</span> are constant for all transcripts in the tree. We interpolate <span class="math">C_{+},C_{-}</span> as a Laurent polynomials in <span class="math">\\mathbb{G}_{T}[\\beta,\\beta^{-1}]</span> of degree <span class="math">1</span> and order -1, and interpolate <span class="math">\\vec{v_{1}}^{\\prime},\\vec{v_{2}}^{\\prime},r_{D_{1}}^{\\prime},r_{D_{2}}^{\\prime},r_{C}^{\\prime}</span> can as bivariate Laurent polynomials of degree <span class="math">1</span> and order -1 in variables <span class="math">\\alpha,\\beta</span>, with computable coefficients in <span class="math">\\mathbb{G}_{1}^{n/2},\\mathbb{G}_{2}^{n/2},\\mathbb{F},\\mathbb{F}</span> and <span class="math">\\mathbb{F}</span> respectively. Since <span class="math">(C^{\\prime},D_{1}^{\\prime},D_{2}^{\\prime})(\\alpha,\\beta)\\in\\mathcal{L}_{2^{\\infty-1},\\Gamma_{1}^{\\prime},\\Gamma_{2}^{\\prime},H_{1},H_{2}}</span> for each leaf:</p>

    <p class="text-gray-300"><span class="math">D_{1}^{\\prime}</span> <span class="math">=\\alpha D_{1L}+D_{1R}+\\alpha\\beta\\langle\\Gamma_{1L},\\Gamma_{2}^{\\prime}\\rangle+\\beta\\langle\\Gamma_{1R},\\Gamma_{2}^{\\prime}\\rangle</span> <span class="math">=\\langle\\vec{v_{1}}^{\\prime}(\\alpha,\\beta),\\Gamma_{2}^{\\prime}\\rangle+r_{D_{1}}^{\\prime}(\\alpha,\\beta)\\cdot e(H_{1},H_{2}),</span></p>

    <p class="text-gray-300">holds for all <span class="math">9</span> <span class="math">(\\beta,\\alpha)</span> pairs. For each challenge value of <span class="math">\\beta</span>, we have two Laurent polynomials in <span class="math">\\alpha</span> of degree and order <span class="math">1</span>, equal at <span class="math">3</span> values. So by Lemma 6 at each of these three <span class="math">\\beta</span> we have an equality of Laurent polynomials. So overall, we have a pair of Laurent polynomials in <span class="math">\\beta</span> of degree and order <span class="math">1</span>, whose coefficients are in a finite dimensional subspace of <span class="math">\\mathbb{G}[\\alpha,\\alpha^{-1}]</span>, with equality holding at <span class="math">3</span> values of <span class="math">\\beta</span>. So applying Lemma 6 again, we have an equality of bivariate Laurent polynomials, and so each coefficient must match.</p>

    <p class="text-gray-300">So monomials with <span class="math">\\alpha^{-1}</span> or <span class="math">\\beta^{-1}</span> factors have vanishing coefficients. <span class="math">\\Gamma_{2}^{\\prime}\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathbb{G}_{2}^{2^{\\infty-1}}<span class="math"> and </span>H_{2}\\stackrel{{\\scriptstyle\\<span class="math">}}{{\\leftarrow}}\\mathbb{G}_{2}</span>, so Lemma 3 implies that if we can compute <span class="math">\\vec{v},r</span> such that <span class="math">\\langle\\vec{v},\\Gamma_{2}^{\\prime}\\rangle+r\\cdot e(H_{1},H_{2})=0</span>, then <span class="math">\\vec{v}=\\vec{0}</span> and <span class="math">r=0</span>. So <span class="math">\\vec{v_{1}}^{\\prime},r_{D_{1}}^{\\prime}</span> must be multilinear in <span class="math">\\alpha,\\beta</span>. Similarly the <span class="math">\\alpha\\beta</span> and <span class="math">\\beta</span> coefficients of <span class="math">\\vec{v_{1}}^{\\prime}(\\alpha,\\beta)</span> must be vectors with inner products with <span class="math">\\Gamma_{2}^{\\prime}</span> of <span class="math">\\langle\\Gamma_{1L},\\Gamma_{2}^{\\prime}\\rangle</span> and <span class="math">\\langle\\Gamma_{1R},\\Gamma_{2}^{\\prime}\\rangle</span> respectively, and so must be <span class="math">\\Gamma_{1L}</span> and <span class="math">\\Gamma_{1R}</span> respectively (or else we violate Lemma 3).</p>

    <p class="text-gray-300">We apply symmetric arguments to  <span class="math">\\vec{v_2}^{\\prime}, r_{D_2}^{\\prime}</span> . So the interpolation of  <span class="math">\\vec{v_1}^{\\prime}(\\alpha, \\beta)</span>  and  <span class="math">\\vec{v_2}^{\\prime}(\\alpha, \\beta)</span>  provides vectors  <span class="math">v_{1L}^{\\prime}, v_{1R}^{\\prime}, v_{2L}^{\\prime}, v_{2R}^{\\prime}</span>  such that:</p>

    <div class="my-4 text-center"><span class="math-block">\\vec {v _ {1}} ^ {\\prime} (\\alpha , \\beta) = \\alpha v _ {1 L} ^ {\\prime} + v _ {1 R} ^ {\\prime} + \\beta (\\alpha \\Gamma_ {1 L} + \\Gamma_ {1 R})</span></div>

    <div class="my-4 text-center"><span class="math-block">\\vec {v _ {2}} ^ {\\prime} (\\alpha , \\beta) = \\alpha^ {- 1} v _ {2 L} ^ {\\prime} + v _ {2 R} ^ {\\prime} + \\beta^ {- 1} (\\alpha^ {- 1} \\Gamma_ {2 L} + \\Gamma_ {2 R})</span></div>

    <p class="text-gray-300">We interpolate  <span class="math">r_C^\\prime (\\alpha ,\\beta) = r_C + \\beta r_{D_2} + \\beta^{-1}r_{D_1} + \\alpha f_\\alpha (\\beta) + \\alpha^{-1}f_{\\alpha^{-1}}(\\beta)</span> , for  <span class="math">f_{\\alpha},f_{\\alpha^{-1}}</span>  two Laurent polynomials of degree 1 and order -1. Then substituting into the constraint of  <span class="math">\\mathcal{L}_{2^{\\alpha -1},\\Gamma_1&#x27;,\\Gamma_2&#x27;,H_1,H_2}</span>  on  <span class="math">C^\\prime</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} C ^ {\\prime} = C + \\chi + \\beta D _ {2} + \\beta^ {- 1} D _ {1} + \\alpha C _ {+} (\\beta) + \\alpha^ {- 1} C _ {-} (\\beta) \\\\ = \\left\\langle \\vec {v _ {1}} ^ {\\prime} (\\alpha , \\beta), \\vec {v _ {2}} ^ {\\prime} (\\alpha , \\beta) \\right\\rangle + r _ {C} ^ {\\prime} (\\alpha , \\beta) H _ {T} \\\\ = \\left(\\left\\langle v _ {1 L} ^ {\\prime}, v _ {2 L} ^ {\\prime} \\right\\rangle + \\left\\langle v _ {1 R} ^ {\\prime}, v _ {2 R} ^ {\\prime} \\right\\rangle + r _ {C} H _ {T}\\right) + \\chi \\\\ + \\beta (\\langle \\Gamma_ {1 L}, v _ {2 L} ^ {\\prime} \\rangle + \\langle \\Gamma_ {1 R}, v _ {2 R} ^ {\\prime} \\rangle + r _ {D _ {2}} H _ {T}) + \\beta^ {- 1} (\\langle v _ {1 L} ^ {\\prime}, \\Gamma_ {2 L} \\rangle + \\langle v _ {1 L} ^ {\\prime}, \\Gamma_ {2 L} \\rangle + r _ {D _ {1}} H _ {T}) \\\\ + \\alpha (\\langle v _ {1 L} ^ {\\prime}, v _ {2 R} ^ {\\prime} \\rangle + \\langle \\Gamma_ {1 L}, \\Gamma_ {2 R} \\rangle + \\beta \\langle \\Gamma_ {1 L}, v _ {2 R} ^ {\\prime} \\rangle + \\beta^ {- 1} \\langle v _ {1 L} ^ {\\prime}, \\Gamma_ {2 R} \\rangle + f _ {\\alpha} (\\beta) H _ {T}) \\\\ + \\alpha^ {- 1} (\\langle v _ {1 R} ^ {\\prime}, v _ {2 L} ^ {\\prime} \\rangle + \\langle \\Gamma_ {1 R}, \\Gamma_ {2 L} \\rangle + \\beta \\langle \\Gamma_ {1 R}, v _ {2 L} ^ {\\prime} \\rangle + \\beta^ {- 1} \\langle v _ {1 R} ^ {\\prime}, \\Gamma_ {2 L} \\rangle + f _ {\\alpha^ {- 1}} (\\beta) H _ {T}) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">These are two bivariate Laurent series of degree 1 and order -1, equal at 3 values of  <span class="math">\\alpha</span> , for each of 3 values of  <span class="math">\\beta</span> , and so applying Lemma 6 in two rounds we conclude they are equal coefficient by coefficient. In particular comparing the  <span class="math">1, \\beta, \\beta^{-1}</span>  coefficients:</p>

    <div class="my-4 text-center"><span class="math-block">C = \\left\\langle v _ {1 L} ^ {\\prime}, v _ {2 L} ^ {\\prime} \\right\\rangle + \\left\\langle v _ {1 R} ^ {\\prime}, v _ {2 R} ^ {\\prime} \\right\\rangle + r _ {C} H _ {T}</span></div>

    <div class="my-4 text-center"><span class="math-block">D _ {1} = \\left\\langle v _ {1 L} ^ {\\prime}, \\Gamma_ {2 L} \\right\\rangle + \\left\\langle v _ {1 R} ^ {\\prime \\prime}, \\Gamma_ {2 R} \\right\\rangle + r _ {D _ {1}} H _ {T}</span></div>

    <div class="my-4 text-center"><span class="math-block">D _ {2} = \\left\\langle \\Gamma_ {1 L}, v _ {2 L} ^ {\\prime} \\right\\rangle + \\left\\langle \\Gamma_ {1 R}, v _ {2 R} ^ {\\prime} \\right\\rangle + r _ {D _ {2}} H _ {T}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and so  $((v_{1L}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v_{2L}^{\\prime}),(v_{2L}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v_{2R}^{\\prime}),r_C,r_{D_1},r_{D_2})$  is the desired witness.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Remark 5. No property of Dory-Reduce depends on the construction of  <span class="math">\\Gamma_1, \\Gamma_2</span> . Instead we require only that the smaller commitment keys  $(\\Gamma_1'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_1), (\\Gamma_2'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_2)<span class="math">  are sampled randomly. In particular  </span>\\Gamma_1, \\Gamma_2<span class="math">  can depend on  </span>\\Gamma_1', \\Gamma_2'$  without affecting the tree-extractability of Dory-Reduce.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-26" class="text-2xl font-bold">3.3 Dory-Innerproduct</h2>

    <p class="text-gray-300">The full inner product argument applies Dory-Reduce iteratively to shrink an inner-product to a product, and then applies Scalar-Product.</p>

    <p class="text-gray-300">Dory-Innerproduct <span class="math">_{F_{1,0}, F_{2,0}, H_1, H_2}(C, D_1, D_2)</span></p>

    <p class="text-gray-300">Precompute:  <span class="math">H_{T} = e(H_{1},H_{2})</span> , for all  <span class="math">j\\in 0\\dots m - 1</span>  compute</p>

    <p class="text-gray-300"><span class="math">\\Gamma_{1,j + 1} = (\\Gamma_{1,j})_L,\\Gamma_{2,j + 1} = (\\Gamma_{2,j})_L</span>  , for all  <span class="math">i\\in 0\\dots m</span>  compute</p>

    <p class="text-gray-300"><span class="math">\\chi_{i} = \\langle \\Gamma_{1,i},\\Gamma_{2,i}\\rangle</span>  , and for all  <span class="math">i\\in 0\\dots m - 1</span>  compute:</p>

    <div class="my-4 text-center"><span class="math-block">\\Delta_ {1 L, i} = \\left\\langle \\left(\\Gamma_ {1, i}\\right) _ {L}, \\Gamma_ {2, i + 1} \\right\\rangle \\quad = \\Delta_ {2 L, i} = \\left\\langle \\Gamma_ {1, i + 1}, \\left(\\Gamma_ {2, i}\\right) _ {L} \\right\\rangle ,</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Delta_ {1 R, i} = \\left\\langle \\left(\\Gamma_ {1, i}\\right) _ {R}, \\Gamma_ {2, i + 1} \\right\\rangle , \\quad \\Delta_ {2 R, i} = \\left\\langle \\Gamma_ {1, i + 1}, \\left(\\Gamma_ {2, i}\\right) _ {R} \\right\\rangle ,</span></div>

    <p class="text-gray-300"><span class="math">\\mathcal{P}</span>  witness:  <span class="math">(\\vec{v_1},\\vec{v_2},r_C,r_{D_1},r_{D_2})</span>  for  <span class="math">(C,D_1,D_2)\\in \\mathcal{L}_{2^m,\\Gamma_{1,0},\\Gamma_{2,0},H_1,H_2}</span>  For  <span class="math">j = 0\\dots m - 1</span>  ..  <span class="math">\\mathcal{P},\\mathcal{V}</span>  ..  <span class="math">(C,D_1,D_2)\\gets \\mathsf{Dory - Reduce}_{m - j,\\Gamma_{1,j}\\Gamma_{2,j},\\Gamma_{1,j + 1},\\Gamma_{2,j + 1},H_1,H_2}(C,D_1,D_2)</span> <span class="math">\\mathcal{P},\\mathcal{V}</span>  : Scalar-Product  <span class="math">\\Gamma_{1,m},\\Gamma_{2,m},H_1,H_2(C,D_1,D_2)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 3. If  <span class="math">\\Gamma_{i,0} \\stackrel{\\S}{\\leftarrow} \\mathbb{G}_i^{2^m}</span>  and  <span class="math">H_i \\stackrel{\\S}{\\leftarrow} \\mathbb{G}_i</span> , then Dory-Innerproduct is an HVSZK, public-coin, succinct interactive argument of knowledge for  <span class="math">\\mathcal{L}_{2^m, \\Gamma_1, \\Gamma_2, H_1, H_2}</span>  with  $(9^{m+1}, 10.5 \\cdot 9^m /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> -tree extractability under SXDH. If  </span>n = 2^m = \\mathrm{poly}(\\lambda)$  then Dory-Innerproduct has witness extended emulation.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. Since  <span class="math">\\Gamma_{i,0} \\stackrel{\\S}{\\leftarrow} \\mathbb{G}_i^{2^m}</span> , for any  <span class="math">j \\geq 0</span>  we have  <span class="math">\\Gamma_{i,j} \\stackrel{\\S}{\\leftarrow} \\mathbb{G}_i^{2^{m-j}}</span>  as it is the first  <span class="math">2^{m-j}</span>  elements of  <span class="math">\\Gamma_{i,0}</span> . So for each round the requirements of Theorems 2 and 1 are satisfied. Succinctness, the Public Coin property, Completeness and HVSZK follow from the same properties of the two sub-arguments.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Tree-extractability follows from Lemma 4 applied round by round. We have  <span class="math">m + 1</span>  rounds each with  <span class="math">W = 9</span> , and the error bound  <span class="math">\\epsilon</span>  is given by  $(9^{m + 1} + 12(9^m + 9^{m - 1} + \\ldots)) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 10.5 \\cdot 9^m /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . When  </span>n = 2^m = \\mathrm{poly}(\\lambda)<span class="math"> , then  </span>W = \\mathcal{O}(n^{\\log 9}) = \\mathrm{poly}(\\lambda)<span class="math">  and  </span>\\epsilon = \\mathcal{O}(n^{\\log 9} /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) = \\mathrm{negl}(\\lambda)$  (c.f. Remark 3). Witness extended emulation follows from Lemma 5.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathcal{P}</span> : In each call to Dory-Reduce,  <span class="math">\\mathcal{P}</span>  sends 6 elements of  <span class="math">\\mathbb{G}_T</span>  to  <span class="math">\\mathcal{V}</span> . For the  <span class="math">j</span> -th call  <span class="math">\\mathcal{P}</span>  performs 6 multi-pairings of size  <span class="math">2^{m - j - 1}</span> ,  <span class="math">O(2^{m - j})</span>  operations in  <span class="math">\\mathbb{F}</span> , and  <span class="math">O(1)</span>  operations in  <span class="math">\\mathbb{G}_T</span> . For the call to Scalar-Product,  <span class="math">\\mathcal{P}</span>  computes  <span class="math">O(1)</span>  pairings and exponentiations in  <span class="math">\\mathbb{G}_T</span> . So the overall cost to  <span class="math">\\mathcal{P}</span>  is dominated by multi-pairings of total size  <span class="math">6 \\times 2^m</span> ,  <span class="math">O(m)</span>  group operations, and  <span class="math">O(2^m)</span>  field arithmetic.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}</span> : Naively, in each invocation of Dory-Reduce  <span class="math">\\mathcal{V}</span>  computes 10 exponentiations in  <span class="math">\\mathbb{G}_T</span> , 2 inversions and 2 multiplications in  <span class="math">\\mathbb{F}</span> , and  <span class="math">O(1)</span>  additional operations in  <span class="math">\\mathbb{G}_T</span>  and additions in  <span class="math">\\mathbb{F}</span> . In the invocation of Scalar-Product  <span class="math">\\mathcal{V}</span>  computes 1 pairing, 7 exponentiations in  <span class="math">\\mathbb{G}_T</span> , 1 inversion and 5 multiplications in  <span class="math">\\mathbb{F}</span> , and  <span class="math">O(1)</span>  additional operations in  <span class="math">\\mathbb{G}_T</span>  and additions in  <span class="math">\\mathbb{F}</span> .</p>

    <p class="text-gray-300">Deferring  <span class="math">\\mathcal{V}</span>  Computation:  <span class="math">\\mathcal{V}</span> 's computation depends only on the messages from  <span class="math">\\mathcal{P}</span>  and the  <span class="math">4m + 1</span>  precomputed values. For each call to Dory-Reduce,  <span class="math">\\mathcal{V}</span>  uses the values  <span class="math">\\varDelta_{1L}=\\varDelta_{2L},\\varDelta_{1R},\\varDelta_{2R},\\chi</span> , and in the final check  <span class="math">\\mathcal{V}</span>  uses  <span class="math">e(\\Gamma_{1m},\\Gamma_{2m})</span> . We will use superscripts on group elements and subscripts on the challenge scalars to denote which call they came from. We assume that we precompute  <span class="math">\\varDelta_{\\{1,2\\}\\{L,R\\}}^j</span>  as before, but instead of computing  <span class="math">\\chi_i</span>  for  <span class="math">i\\in 0\\dots m</span> , we compute:  <span class="math">\\chi = \\sum_{j = 0}^{m - 1}\\langle \\Gamma_{1j},\\Gamma_{2j}\\rangle</span>  and  <span class="math">\\chi_{fin} = \\langle \\Gamma_{1m},\\Gamma_{2m}\\rangle</span> . Collapsing the Dory-Reduce rounds,</p>

    <p class="text-gray-300">we obtain the arguments for Scalar-Product:</p>

    <p class="text-gray-300">$$ \\begin{array}{l} C \\leftarrow C + \\chi + \\beta_ {0} D _ {2} ^ {0} + \\beta_ {0} ^ {- 1} D _ {1} ^ {0} + \\sum_ {j = 0} ^ {m - 1} \\left(\\alpha_ {j} C _ {+} ^ {j} + \\alpha_ {j} ^ {- 1} C _ {-} ^ {j}\\right) + \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\sum_ {j = 1} ^ {m - 1} \\beta_ {j} \\left(\\alpha_ {j - 1} ^ {- 1} D _ {2 L} ^ {j - 1} + D _ {2 R} ^ {j - 1} + \\alpha_ {j - 1} ^ {- 1} \\beta_ {j - 1} ^ {- 1} \\Delta_ {2 L} ^ {j - 1} + \\beta_ {j - 1} ^ {- 1} \\Delta_ {2 R} ^ {j - 1}\\right) \\\\</li>

      <li>\\sum_ {j = 1} ^ {m - 1} \\beta_ {j} ^ {- 1} \\left(\\alpha_ {j - 1} D _ {1 L} ^ {j - 1} + D _ {1 R} ^ {j - 1} + \\alpha_ {j - 1} \\beta_ {j - 1} \\Delta_ {1 L} ^ {j - 1} + \\beta_ {j - 1} \\Delta_ {1 R} ^ {j - 1}\\right) \\\\</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <div class="my-4 text-center"><span class="math-block">D _ {1} \\leftarrow \\alpha_ {j - 1} D _ {1 L} ^ {m - 1} + D _ {1 R} ^ {m - 1} + \\alpha_ {m - 1} \\beta_ {m - 1} \\Delta_ {1 L} ^ {m - 1} + \\beta_ {m - 1} \\Delta_ {1 R} ^ {m - 1}</span></div>

    <div class="my-4 text-center"><span class="math-block">D _ {2} \\leftarrow \\alpha_ {j - 1} ^ {- 1} D _ {2 L} ^ {m - 1} + D _ {2 R} ^ {m - 1} + \\alpha_ {m - 1} ^ {- 1} \\beta_ {m - 1} ^ {- 1} \\Delta_ {2 L} ^ {m - 1} + \\beta_ {m - 1} ^ {- 1} \\Delta_ {2 R} ^ {m - 1}</span></div>

    <p class="text-gray-300">which are substituted into the check in Scalar-Product. This reduces  <span class="math">\\mathcal{V}</span> 's group operations to a multi-exponentiation in  <span class="math">\\mathbb{G}_T</span>  of size  <span class="math">9m + 9</span> , two exponentiations in  <span class="math">\\mathbb{G}_T</span> , and one pairing. Using Montgomery's trick for batch inversions, we compute the coefficients with one inversion and  <span class="math">O(m)</span>  multiplications and additions in  <span class="math">\\mathbb{F}</span> .</p>

    <h2 id="sec-28" class="text-2xl font-bold">3.4 Batching inner products</h2>

    <p class="text-gray-300">Suppose we have  <span class="math">(C, D_1, D_2), (C&#x27;, D_1&#x27;, D_2&#x27;) \\in \\mathcal{L}_{n,\\Gamma_1,\\Gamma_2,H_1,H_2}</span> , and  <span class="math">\\mathcal{P}</span>  possesses witnesses  <span class="math">(\\vec{v}_1, \\vec{v}_2, r_C, r_{D_1}, r_{D_2})</span>  and  <span class="math">(\\vec{v}_1&#x27;, \\vec{v}_2&#x27;, r_C&#x27;, r_{D_1}&#x27;, r_{D_2}&#x27;)</span>  respectively. Then we have the following two-to-one interactive argument:</p>

    <pre><code class="language-latex">Batch-Innerproduct  $\\Gamma_1,\\Gamma_2(C,D_1,D_2,C&#x27;,D_1&#x27;,D_2&#x27;)$
Precompute:  $H_{T} = e(H_{1},H_{2})\\in G_{T}$ $\\mathcal{P}$  witness:  $(\\vec{v}_1,\\vec{v}_2,r_c,r_{D_1},r_{D_2})$  for  $(C,D_1,D_2)\\in \\mathcal{L}_{n,\\Gamma_1,\\Gamma_2,H_1,H_2}$  , and  $(\\vec{v}_1&#x27;,\\vec{v}_2&#x27;,r_c&#x27;,r_{D_1}&#x27;,r_{D_2}&#x27;)$  for  $(C&#x27;,D_1&#x27;,D_2&#x27;)\\in \\mathcal{L}_{n,\\Gamma_1,\\Gamma_2,H_1,H_2}$ $\\mathcal{P}$  ..  $r_X\\gets_{\\S}\\mathbb{F}$ $\\mathcal{P}\\to \\mathcal{V}$  ..  $X = \\langle \\vec{v}_1,\\vec{v}_2&#x27;\\rangle +\\langle \\vec{v}_1&#x27;,\\vec{v}_2\\rangle +r_XH_T$ $\\mathcal{V}\\rightarrow \\mathcal{P}$  ..  $\\gamma \\leftarrow_{\\S}\\mathbb{F}$ $\\mathcal{P}$  ..  $\\vec{v}_1^{\\prime \\prime}\\gets \\gamma \\vec{v}_1 + \\vec{v}_1&#x27;$  ，  $\\vec{v}_2^{\\prime \\prime}\\gets \\gamma \\vec{v}_2 + \\vec{v}_2&#x27;$  ，  $r_{D_1}^{\\prime \\prime}\\gets \\gamma r_{D_1} + r_{D_1}^{\\prime},r_{D_2}^{\\prime \\prime}\\gets \\gamma r_{D_2} + r_{D_2}^{\\prime},r_C^{\\prime \\prime}\\gets \\gamma^2 r_C + \\gamma r_X + r_C^{\\prime}$ $\\mathcal{V}$  ..  $D_1^{\\prime \\prime}\\gets \\gamma D_1 + D_1&#x27;$  ，  $D_2^{\\prime \\prime}\\gets \\gamma D_2 + D_2&#x27;$  ，  $C&#x27;&#x27;\\gets \\gamma^2 C + \\gamma X + C&#x27;$  ，  $\\mathcal{V}$  Accept if  $(C^{\\prime \\prime},D_1^{\\prime \\prime},D_2^{\\prime \\prime})\\in \\mathcal{L}_{n,\\Gamma_1,\\Gamma_2,H_1,H_2}$ $\\mathcal{P}$  witness:  $(\\vec{v}_1^{\\prime \\prime},\\vec{v}_2^{\\prime \\prime},r_C^{\\prime \\prime},r_{D_1}^{\\prime \\prime},r_{D_2}^{\\prime \\prime})$</code></pre>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 4. If  <span class="math">\\Gamma_i \\stackrel{\\S}{\\leftarrow} \\mathbb{G}_i^n</span> ,  <span class="math">H_i \\stackrel{\\S}{\\leftarrow} G_i</span> , Batch-Innerproduct is an HVSZK, public-coin, succinct interactive argument of knowledge for  <span class="math">(\\mathcal{L}_{n,\\Gamma_1,\\Gamma_2,H_1,H_2})^2</span>  with  $(3,3/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ -tree extractability under SXDH.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. Succinctness, the Public Coin property, Completeness, Soundness and HVSZK of this protocol are immediate.</p>

    <p class="text-gray-300">To show tree extractability, we have  <span class="math">\\mu = 1</span>  and set  <span class="math">w_{1} = 3</span> . We are given witnesses for 3 distinct challenges  <span class="math">\\gamma</span> . For  <span class="math">i \\in \\{1,2\\}</span> , we interpolate  <span class="math">\\vec{v_i^0}</span>  and  <span class="math">r_{D_i}^{\\prime \\prime}</span>  as</p>

    <p class="text-gray-300">quadratics in <span class="math">\\gamma</span>. Then from Lemma 6, the contribution of the quadratic terms to <span class="math">D_{i}^{\\prime \\prime} = \\gamma D_{i} + D_{i}^{\\prime}</span> is identically zero, and so from Lemma 3 there are no quadratic terms. Hence <span class="math">\\vec{v_i}^{\\prime \\prime}(\\gamma) = \\gamma \\vec{v_i} +\\vec{v_i^{\\prime}}</span> for some <span class="math">\\vec{v_i}</span> and <span class="math">\\vec{v_i^{\\prime}}</span>, and <span class="math">r_{D_i}^{\\prime \\prime}(\\gamma) = \\gamma r + D_i + r_{D_i}^{\\prime}</span>, compatible with the commitments <span class="math">D_{i},D_{i}^{\\prime}</span>. Interpolating <span class="math">r_C&#x27;&#x27;(\\gamma) = r_C&#x27; + \\gamma r_X + \\gamma^2 r_C</span> and substituting in our affine <span class="math">\\vec{v_i}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\gamma^ {2} C + \\gamma X + C ^ {\\prime} = C ^ {\\prime \\prime} (\\gamma) = \\left\\langle \\vec {v _ {1}} ^ {\\prime \\prime} (\\gamma), \\vec {v _ {2}} ^ {\\prime \\prime} (\\gamma) \\right\\rangle + r _ {C} ^ {\\prime \\prime} (\\gamma) H _ {T} \\\\ = \\gamma^ {2} (\\langle \\vec {v _ {1}}, \\vec {v _ {2}} \\rangle + r _ {C} H _ {T}) + \\gamma (\\langle \\vec {v _ {1}}, \\vec {v _ {2}} ^ {\\prime} \\rangle + \\langle \\vec {v _ {1}} ^ {\\prime}, \\vec {v _ {2}} \\rangle + r _ {X} H _ {T}) + (\\langle \\vec {v _ {1}} ^ {\\prime}, \\vec {v _ {2}} ^ {\\prime} \\rangle + r _ {C} ^ {\\prime} H _ {T}). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Since this holds for 3 values of <span class="math">\\gamma</span>, Lemma 6 implies that the two polynomials have identical coefficients, so <span class="math">C = \\langle \\vec{v_1},\\vec{v_2}\\rangle +r_CH_T</span> and <span class="math">C^{\\prime} = \\langle \\vec{v_{1}}^{\\prime},\\vec{v_{2}}^{\\prime}\\rangle +r_{C}^{\\prime}H_{T}</span> and we have extracted the required witnesses.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Concretely, in Batch-Innerproduct messages from <span class="math">\\mathcal{P}</span> to <span class="math">\\mathcal{V}</span> have size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">; </span>\\mathcal{P}<span class="math">&#x27;s computation is clearly dominated by an </span>2n<span class="math">-sized multi-pairing and </span>\\mathcal{V}<span class="math">&#x27;s computation is clearly </span>O(1)<span class="math"> exponentiations in </span>\\mathbb{G}_T$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-29" class="text-2xl font-bold">4 Inner products with public vectors of scalars</h2>

    <p class="text-gray-300">In the previous section, we constructed Dory-Innerproduct, a succinct argument of knowledge for generalised inner products between committed vectors in <span class="math">\\mathbb{G}_1^n</span> and <span class="math">\\mathbb{G}_2^n</span>. For a polynomial commitment scheme we also require the ability to prove products of committed vectors with vectors of scalars with multiplicative structure. However, this structure is not preserved when instances are batched, so we will extend our arguments to allow for general vectors in <span class="math">\\mathbb{F}^n</span>. We define a family of languages, parameterised by a pair of vectors <span class="math">\\vec{s_1},\\vec{s_2}\\in \\mathbb{F}^n</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left(C, D _ {1}, D _ {2}, E _ {1}, E _ {2}\\right) \\in \\mathcal {L} _ {n, \\Gamma_ {1}, \\Gamma_ {2}, H _ {1}, H _ {2}} \\left(\\vec {s _ {1}}, \\vec {s _ {2}}\\right) \\subset \\mathbb {G} _ {T} ^ {3} \\times \\mathbb {G} _ {1} \\times \\mathbb {G} _ {2} \\\\ \\Leftrightarrow \\exists (\\vec {v _ {1}} \\in \\mathbb {G} _ {1} ^ {n}, \\vec {v _ {2}} \\in \\mathbb {G} _ {2} ^ {n}, r _ {C}, r _ {D _ {1}}, r _ {D _ {2}}, r _ {E _ {1}}, r _ {E _ {2}} \\in \\mathbb {F}): \\\\ D _ {1} = \\langle \\vec {v _ {1}}, \\Gamma_ {2} \\rangle + r _ {D _ {1}} \\cdot e (H _ {1}, H _ {2}), \\quad D _ {2} = \\langle \\Gamma_ {1}, \\vec {v _ {2}} \\rangle + r _ {D _ {2}} \\cdot e (H _ {1}, H _ {2}), \\\\ E _ {1} = \\langle \\vec {v _ {1}}, \\vec {s _ {2}} \\rangle + r _ {E _ {1}} H _ {1}, \\quad E _ {2} = \\langle \\vec {s _ {1}}, \\vec {v _ {2}} \\rangle + r _ {E _ {2}} H _ {2}, \\\\ C = \\langle \\vec {v _ {1}}, \\vec {v _ {2}} \\rangle + r _ {C} \\cdot e (H _ {1}, H _ {2}), \\\\ \\end{array}</span></div>

    <p class="text-gray-300">We extend the arguments of the previous section to these languages. Note that <span class="math">(C, D_1, D_2, E_1, E_2) \\in \\mathcal{L}_{n, \\Gamma_1, \\Gamma_2, H_1, H_2}(\\vec{s_1}, \\vec{s_2})</span> implies <span class="math">(C, D_1, D_2) \\in \\mathcal{L}_{n, \\Gamma_1, \\Gamma_2, H_1, H_2}</span>.</p>

    <h2 id="sec-30" class="text-2xl font-bold">4.1 General reduction with <span class="math">O(n)</span> cost</h2>

    <p class="text-gray-300">There is a reduction from <span class="math">\\mathcal{L}_{n,\\Gamma_1,\\Gamma_2,H_1,H_2}(\\vec{s_1},\\vec{s_2})</span> to <span class="math">\\mathcal{L}_{n,\\Gamma_1,\\Gamma_2,H_1,H_2}</span>, with <span class="math">O(n)</span> costs to <span class="math">\\mathcal{P},\\mathcal{V}</span>, where the <span class="math">\\vec{s_i}</span> are essentially multiplied by some <span class="math">\\mathcal{V}</span>-selected challenge in <span class="math">\\mathbb{G}_i</span> and added to the witness vectors.</p>

    <p class="text-gray-300">Fold-Scalars <span class="math">n,\\Gamma_1,\\Gamma_2,H_1,H_2</span> <span class="math">(C,D_{1},D_{2},E_{1},E_{2},\\vec{s_{1}},\\vec{s_{2}})</span></p>

    <p class="text-gray-300">Precompute: <span class="math">H_{T} = e(H_{1},H_{2})</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}</span> witness: <span class="math">(\\vec{v_1},\\vec{v_2},r_C,r_{D_1}r_{D_2},r_{E_1},r_{E_2})</span> for</p>

    <p class="text-gray-300"><span class="math">(C,D_1,D_2,E_1,E_2)\\in \\mathcal{L}_{n,\\Gamma_1,\\Gamma_2,H_1,H_2}(\\vec{s_1},\\vec{s_2})</span></p>

    <p class="text-gray-300">|  V→P: γ←$ F  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  P(**) : v1'← v1+γs1H1, v2'← v2+γ-1s2H2,  |</p>

    <p class="text-gray-300">|  r'C← rC+γrE2+γ-1rE1  |</p>

    <p class="text-gray-300">|  V(**) : C'← C+⟨s1, s2⟩H_T+γ·e(H1,E2)+γ-1·e(E1,H2),  |</p>

    <p class="text-gray-300">|  D1'← D1+e(H1,⟨s1,γΓ2⟩), D2'← D2+e(γ-1⟨Γ1, s2), H2)  |</p>

    <p class="text-gray-300">|  V: Accept if (C',D1',D2') ∈ Ln,Γ1,Γ2,H1,H2  |</p>

    <p class="text-gray-300">|  P witness: (v1',v2',r'C, rD1, rD2)  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 5. For  <span class="math">\\Gamma_i \\stackrel{\\S}{\\leftarrow} \\mathbb{G}_i^n</span> ,  <span class="math">H_i \\stackrel{\\S}{\\leftarrow} G_i</span> , Fold-Scalars is an HVSZK, public-coin, succinct interactive argument of knowledge for  <span class="math">\\mathcal{L}_{n,\\Gamma_1,\\Gamma_2,H_1,H_2}(\\vec{s_1},\\vec{s_2})</span>  with  $(3,3/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ -tree extractability under SXDH.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. Completeness, Succinctness and Public-Coin are immediate.  <span class="math">\\mathcal{P}</span>  messages are independent and uniformly random, so zero-knowledge is straightforward.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To show tree-extractability, we have  <span class="math">\\mu = 1</span>  and  <span class="math">w_{1} = 3</span> . We have 3 challenges of  <span class="math">\\gamma</span> , and fail if any are 0, which occurs with probability at most  $3 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . For  </span>i \\in \\{1,2\\}<span class="math"> , we interpolate  </span>v_{i}^{\\prime}<span class="math">  and  </span>r_{i}^{\\prime}<span class="math">  as degree 1 order 1 Laurent polynomials in  </span>\\gamma<span class="math"> . Then from Lemma 6, the contribution of the  </span>\\gamma^{-1}<span class="math">  terms of  </span>\\vec{v_{1}^{\\prime}}<span class="math">  and  </span>r_1^\\prime<span class="math">  to  </span>D_1^\\prime<span class="math">  are identically zero, and so from Lemma 3 there are no  </span>\\gamma^{-1}<span class="math">  terms. Similarly the  </span>\\gamma<span class="math">  term of  </span>\\vec{v_{1}^{\\prime}}<span class="math">  must be  </span>H_{1}\\vec{s_{1}}<span class="math"> . Similarly there are no  </span>\\gamma<span class="math">  terms in  </span>\\vec{v_{2}^{\\prime}}<span class="math">  and  </span>r_2^\\prime<span class="math"> , and the  </span>\\gamma^{-1}<span class="math">  term of  </span>\\vec{v_{2}^{\\prime}}<span class="math">  must be  </span>H_{2}\\vec{s_{2}}<span class="math"> . So we find some  </span>\\vec{v_1},\\vec{v_2}<span class="math">  such that:  </span>\\vec{v_1}^\\prime (\\gamma) = \\vec{v_1} +\\gamma \\vec{s_1} H_1<span class="math"> ,  </span>\\vec{v_2}^\\prime (\\gamma) = \\vec{v_2} +\\gamma^{-1}\\vec{s_2} H_2<span class="math"> . We interpolate  </span>r_C^\\prime (\\gamma) = r_C^\\prime +\\gamma r_{E_2} + \\gamma^{-1}r_{E_1}$ , and get:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} C ^ {\\prime} (\\gamma) = C + \\langle \\vec {s _ {1}}, \\vec {s _ {2}} \\rangle H _ {T} + \\gamma \\cdot e (H _ {1}, E _ {2}) + \\gamma^ {- 1} \\cdot e (E _ {1}, H _ {2}) \\\\ = \\left\\langle \\vec {v _ {1}} ^ {\\prime} (\\gamma), \\vec {v _ {2}} ^ {\\prime} (\\gamma) \\right\\rangle + r _ {C} ^ {\\prime} (\\gamma) H _ {T} \\\\ = \\left\\langle \\vec {v _ {1}}, \\vec {v _ {2}} \\right\\rangle + \\left(r _ {C} ^ {\\prime} + \\left\\langle \\vec {s _ {1}}, \\vec {s _ {2}} \\right\\rangle\\right) H _ {T} \\\\ + \\gamma \\cdot e (H _ {1}, \\langle \\vec {s _ {1}}, \\vec {v _ {2}} \\rangle + r _ {E _ {2}} H _ {2}) + \\gamma^ {- 1} \\cdot e (\\langle \\vec {v _ {1}}, \\vec {s _ {2}} \\rangle + r _ {E _ {1}} H _ {1}, H _ {2}). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Since this holds for 3 values of  <span class="math">\\gamma</span> , the  <span class="math">1, \\gamma, \\gamma^{-1}</span>  Lemma 6 implies that the coefficients must be equal, which immediately implies we have extracted the required witness.</p>

    <p class="text-gray-300">We add  <span class="math">E_{1\\beta} = \\langle \\Gamma_1, \\vec{s_2} \\rangle</span> ,  <span class="math">E_{2\\beta} = \\langle \\vec{s_1}, \\Gamma_2 \\rangle</span>  to  <span class="math">\\mathcal{P}</span> 's first message. Prior to their second message,  <span class="math">\\mathcal{P}</span>  samples  <span class="math">r_{E_{\\{1,2\\} \\{+, - \\}}} \\stackrel{\\S}{\\leftarrow} \\mathbb{F}</span>  and adds</p>

    <p class="text-gray-300">|  P → V: E1+ = ⟨v1L, s2R⟩ + rE1+ H1, E1- = ⟨v1R, s2L⟩ + rE1- H1,  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  E2+ = ⟨s1L, v2R⟩ + rE2+ H2, E2- = ⟨s1R, v2L⟩ + rE2- H2  |</p>

    <p class="text-gray-300">to their second message. After  <span class="math">\\mathcal{P}</span> 's second message,  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  compute:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}</span>  ..  <span class="math">r_{E_1}&#x27; \\gets r_{E_1} + \\alpha r_{E_{1+}} + \\alpha^{-1} r_{E_{2-}}</span> ,  <span class="math">r_{E_2}&#x27; \\gets r_{E_2} + \\alpha r_{E_{2+}} + \\alpha^{-1} r_{E_{2-}}</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}</span>  ..  <span class="math">E_1^{\\prime}\\gets E_1 + \\beta E_{1\\beta} + \\alpha E_{1+} + \\alpha^{-1}E_{2-},</span></p>

    <p class="text-gray-300"><span class="math">E_2^{\\prime}\\gets E_2 + \\beta^{-1}E_{2\\beta} + \\alpha E_{2+} + \\alpha^{-1}E_{2-},</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}, \\mathcal{V}</span> :  <span class="math">\\vec{s_1&#x27;} \\gets \\alpha s_{1L}^+ + s_{1R}^-</span> ,  <span class="math">\\vec{s_2&#x27;} \\gets \\alpha^{-1} s_{2L}^+ + s_{2R}^-</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 6. For  <span class="math">\\Gamma_2&#x27; \\stackrel{\\S}{\\leftarrow} \\mathsf{G}_2^{m-1}</span> ,  <span class="math">H_2 \\stackrel{\\S}{\\leftarrow} \\mathsf{G}_2</span> ,  <span class="math">\\Gamma_1 \\stackrel{\\S}{\\leftarrow} \\mathsf{G}_2^{m-1}</span> ,  <span class="math">H_1 \\stackrel{\\S}{\\leftarrow} \\mathsf{G}_1</span> , the extended Dory-Reduce is an HVSZK, public-coin, succinct interactive argument of knowledge for  <span class="math">\\mathcal{L}_{2^m, \\Gamma_1, \\Gamma_2, H_1, H_2}(\\vec{s_1}, \\vec{s_2})</span>  with  $(9, 12/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ -tree extractability under SXDH.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Succinctness and the Public Coin properties are immediate. Completeness and HVSZK hold as in the proof of Theorem 2.  $(9,12 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> -tree extractability is implied by Theorem 2 as a witness for  </span>(C,D_1,D_2)\\in \\mathcal{L}_{n,\\Gamma_1,\\Gamma_2,H_1,H_2}$  suffices.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We use the extended Dory-Reduce, and apply Fold-Scalars at  <span class="math">n = 1</span> :</p>

    <p class="text-gray-300">Dory-Innerproduct  <span class="math">\\Gamma_{1,0},\\Gamma_{2,0},H_1,H_2(C,D_1,D_2,E_1,E_2,\\vec{s}_1,\\vec{s}_2)</span></p>

    <p class="text-gray-300">Precompute:  <span class="math">H_{T} = e(H_{1},H_{2})</span> , for all  <span class="math">i\\in 0\\dots m - 1</span>  compute:</p>

    <p class="text-gray-300"><span class="math">\\Gamma_{1,i + 1} = (\\Gamma_{1,i})_L,</span> <span class="math">\\Gamma_{2,i + 1} = (\\Gamma_{2,i})_L,</span></p>

    <p class="text-gray-300"><span class="math">\\Delta_{1L,i} = \\langle (\\Gamma_{1,i})_L,\\Gamma_{2,i + 1}\\rangle ,\\quad \\Delta_{1R,i} = \\langle (\\Gamma_{1,i})_R,\\Gamma_{2,i + 1}\\rangle ,</span></p>

    <p class="text-gray-300"><span class="math">\\Delta_{2L,i} = \\langle \\Gamma_{1,i + 1},(\\Gamma_{2,i})_L\\rangle ,\\quad \\Delta_{2R,i} = \\langle \\Gamma_{1,i + 1},(\\Gamma_{2,i})_R\\rangle ,</span></p>

    <p class="text-gray-300">and for all  <span class="math">i\\in 0\\dots m</span>  compute  <span class="math">\\chi_{i} = \\langle \\Gamma_{1i},\\Gamma_{2i}\\rangle</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}</span>  witness:  <span class="math">(\\vec{v_1},\\vec{v_2},r_C,r_{D_1},r_{D_2},r_{E_1},r_{E_2})</span>  for</p>

    <p class="text-gray-300"><span class="math">(C,D_{1},D_{2},E_{1},E_{2})\\in \\mathcal{L}_{2^{m},\\Gamma_{1,0},\\Gamma_{2,0},H_{1},H_{2}}(\\vec{s_{1}},\\vec{s_{2}})</span></p>

    <p class="text-gray-300">For  <span class="math">j = 0\\ldots m - 1</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}, \\mathcal{V}</span> :  <span class="math">(C, D_1, D_2, E_1, E_2, \\vec{s_1}, \\vec{s_2}) \\gets</span></p>

    <p class="text-gray-300">Dory-Reduce  <span class="math">m - j,\\Gamma_{1,j}\\Gamma_{2,j},\\Gamma_{1,j + 1},\\Gamma_{2,j + 1},H_1,H_2(C,D_1,D_2,E_1,E_2,\\vec{s_1},\\vec{s_2})</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}, \\mathcal{V}</span> :  <span class="math">(C, D_1, D_2) \\gets \\text{Fold-Scalars}_{\\Gamma_{1,m}, \\Gamma_{2,m}, H_1, H_2}(C, D_1, D_2, E_1, E_2, \\vec{s_1}, \\vec{s_2})</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}, \\mathcal{V}</span> : Scalar-Product  <span class="math">\\Gamma_{1,m}, \\Gamma_{2,m}, H_1, H_2(C, D_1, D_2)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 7. If  <span class="math">\\Gamma_{1,0} \\stackrel{\\S}{\\leftarrow} \\mathsf{G}_1^{2^m}</span> ,  <span class="math">\\Gamma_{2,0} \\stackrel{\\S}{\\leftarrow} \\mathsf{G}_2^{2^m}</span> ,  <span class="math">H_1 \\stackrel{\\S}{\\leftarrow} \\mathsf{G}_1</span>  and  <span class="math">H_2 \\stackrel{\\S}{\\leftarrow} \\mathsf{G}_2</span> , then the extended Dory-Innerproduct is an HVSZK, public-coin, succinct interactive argument of knowledge for  <span class="math">\\mathcal{L}_{2^m, \\Gamma_1, \\Gamma_2, H_1, H_2}(\\vec{s_1}, \\vec{s_2})</span>  with  $(9^{m+1}, 10.5 \\cdot 9^m /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> -tree extractability under SXDH. If  </span>n = 2^m = \\mathrm{poly}(\\lambda)$  then the extended Dory-Innerproduct has witness extended emulation.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. Succinctness and the Public Coin properties are immediate. Completeness and HVSZK hold as in the proof of Theorem 3. Tree-extractability and witness extended emulation when  <span class="math">n = \\mathsf{poly}(\\lambda)</span>  is implied by Theorem 3 as a witness for  <span class="math">(C, D_1, D_2) \\in \\mathcal{L}_{n, \\Gamma_1, \\Gamma_2, H_1, H_2}</span>  suffices.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Concrete costs of the extended Dory-Innerproduct  <span class="math">\\mathcal{P}</span>  sends 3 additional elements of  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span>  in each invocation of Dory-Reduce.  <span class="math">\\mathcal{P}</span>  also computes exponentiations of total size  <span class="math">2\\times 2^{m - j}</span>  exponentiations in  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span> , and  <span class="math">O(2^{m - j})</span>  additional field arithmetic. So in total,  <span class="math">\\mathcal{P}</span> 's work is:  <span class="math">(6P + 4\\mathbb{G}_2 + 4\\mathbb{G}_1 + O(1)\\mathbb{F})\\times n + o(n)</span>  which is dominated by the  <span class="math">6n</span>  pairings, especially as multi-exponentiations in  <span class="math">\\mathbb{G}_1,\\mathbb{G}_2</span>  can be accelerated with variants of Pippenger's algorithm. The total size of  <span class="math">\\mathcal{P}</span> 's messages is:  $(6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\log n + 4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 5</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . As before,  </span>\\mathcal{V}<span class="math">  defers computation to reduce their costs. To compute the  </span>C,E_1,E_2<span class="math">  passed to Fold-Scalars requires, respectively, a multi-exponentiation in  </span>\\mathbb{G}_T<span class="math">  of size  </span>9m + 9<span class="math"> , a multi-exponentiation in  </span>\\mathbb{G}_1<span class="math">  of size  </span>4m<span class="math">  and a multi-exponentiation in  </span>\\mathbb{G}_2<span class="math">  of size  </span>4m<span class="math"> . The computation of the final  </span>D_{1},D_{2}<span class="math">  and verification of Fold-Scalars and Scalar-Product require 3 additional pairings and  </span>O(1)<span class="math">  exponentiations. Whilst naively there are 5 pairings, 2 of them are pairings with  </span>H_{1}<span class="math">  and 2 are pairings with  </span>H_{2}$ , which can be combined in the final check of Scalar-Product.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathcal{V}</span>  must also compute the final  <span class="math">\\vec{s_1},\\vec{s_2}</span>  used as arguments to Fold-Scalars. In particular, these are the scalars:  <span class="math">\\langle \\vec{s_1},\\otimes_{i = 0}^{m - 1}(\\alpha_i,1)\\rangle ,\\langle \\vec{s_2},\\otimes_{i = 0}^{m - 1}(\\alpha_i^{-1},1)\\rangle .</span>  For general vectors  <span class="math">\\vec{s_1},\\vec{s_2}</span> , these require  <span class="math">O(n)</span>  operations in  <span class="math">\\mathbb{F}</span> . However, when the vectors  <span class="math">\\vec{s_i}</span>  themselves have multiplicative structure, we have the identity:</p>

    <div class="my-4 text-center"><span class="math-block">\\langle \\otimes_ {i = 0} ^ {m - 1} (\\ell_ {i}, r _ {i}), \\otimes_ {i = 0} ^ {m - 1} (a _ {i}, 1) \\rangle = \\prod_ {i = 0} ^ {m - 1} (\\ell_ {i} a _ {i} + r _ {i}),</span></div>

    <p class="text-gray-300">which allows the computation of the product in  <span class="math">O(m)</span>  operations in  <span class="math">\\mathbb{F}</span> . Similarly, a vector that can be written as a sum of  <span class="math">\\ell</span>  vectors with multiplicative structure can have this inner product computed in  <span class="math">O(\\ell m)</span>  operations in  <span class="math">\\mathbb{F}</span>  (as in Section 4.4).</p>

    <h2 id="sec-33" class="text-2xl font-bold">4.4 Extending Batch-Innerproduct</h2>

    <p class="text-gray-300"><span class="math">\\mathcal{P}</span>  samples  <span class="math">r_{Y_1}, r_{Y_2} \\stackrel{\\S}{\\leftarrow} \\mathbb{F}</span> , and we add:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {P} \\rightarrow \\mathcal {V}: Y _ {1} = \\left\\langle \\vec {v _ {1}}, \\vec {s _ {2}} ^ {\\prime} \\right\\rangle + \\left\\langle \\vec {v _ {1}} ^ {\\prime}, \\vec {s _ {2}} \\right\\rangle + r _ {Y _ {1}} H _ {1}, \\quad Y _ {2} = \\left\\langle \\vec {s _ {1}} ^ {\\prime}, \\vec {v _ {2}} \\right\\rangle + \\left\\langle \\vec {s _ {1}}, \\vec {v _ {2}} ^ {\\prime} \\right\\rangle + r _ {Y _ {2}} H _ {2}</span></div>

    <p class="text-gray-300">to  <span class="math">\\mathcal{P}</span> 's first message. After receiving  <span class="math">\\gamma</span> ,  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  compute:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {P}: r _ {E _ {1}} ^ {\\prime \\prime} \\leftarrow \\gamma^ {2} r _ {E _ {1}} + \\gamma r _ {Y _ {1}} + r _ {E _ {1}} ^ {\\prime}, \\quad r _ {E _ {2}} ^ {\\prime \\prime} \\leftarrow \\gamma^ {2} r _ {E _ {2}} + \\gamma r _ {Y _ {2}} + r _ {E _ {2}} ^ {\\prime}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {V}: E _ {1} ^ {\\prime \\prime} \\leftarrow \\gamma^ {2} E _ {1} + \\gamma Y _ {1} + E _ {1} ^ {\\prime}, \\quad E _ {2} ^ {\\prime \\prime} \\leftarrow \\gamma^ {2} E _ {2} + \\gamma Y _ {2} + E _ {2} ^ {\\prime}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {P}, \\mathcal {V}: \\vec {s _ {1}} ^ {\\prime \\prime} \\leftarrow \\gamma \\vec {s _ {2}} + \\vec {s _ {2}} ^ {\\prime}, \\quad \\vec {s _ {2}} ^ {\\prime \\prime} \\leftarrow \\gamma \\vec {s _ {1}} + \\vec {s _ {1}} ^ {\\prime}</span></div>

    <p class="text-gray-300">Theorem 8. If  <span class="math">\\Gamma_1 \\stackrel{\\S}{\\leftarrow} \\mathbb{G}_1^n</span> ,  <span class="math">\\Gamma_2 \\stackrel{\\S}{\\leftarrow} \\mathbb{G}_2^n</span> ,  <span class="math">H_1 \\stackrel{\\S}{\\leftarrow} G_1</span>  and  <span class="math">H_2 \\stackrel{\\S}{\\leftarrow} G_2</span> , the extended Batch-Innerproduct is an HVSZK, public-coin, succinct interactive argument of knowledge for  <span class="math">\\mathcal{L}_{n,\\Gamma_1,\\Gamma_2,H_1,H_2}(\\vec{s_1},\\vec{s_2}) \\times \\mathcal{L}_{n,\\Gamma_1,\\Gamma_2,H_1,H_2}(\\vec{s_1}&#x27;,\\vec{s_2}&#x27;)</span>  with witness extended emulation under SXDH.</p>

    <p class="text-gray-300">Proof. Succinctness and the Public Coin properties are immediate. Completeness and HVSZK hold following the proof of Theorem 4. Witness extended emulation is implied by Theorem 4, as a witness for membership of  <span class="math">(\\mathcal{L}_{n,\\Gamma_1,\\Gamma_2,H_1,H_2})^2</span>  suffices.</p>

    <p class="text-gray-300">25</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathcal{P}</span> 's messages to  <span class="math">\\mathcal{V}</span>  have size  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}_T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . As before,  </span>\\mathcal{P}<span class="math"> &#x27;s computation is dominated by a  </span>2n<span class="math"> -size multi-pairing and  </span>\\mathcal{V}<span class="math"> &#x27;s group operations are  </span>O(1)<span class="math">  exponentiations. For general vectors  </span>\\vec{s_1}, \\vec{s_2}<span class="math"> ,  </span>\\mathcal{V}<span class="math">  must perform  </span>O(n)<span class="math">  operations in  </span>\\mathbb{F}<span class="math"> . However, if  </span>\\vec{s_i}, \\vec{s_i'}<span class="math">  are some linear combination of  </span>\\ell, \\ell'<span class="math">  vectors with multiplicative structure, then  </span>s_i''<span class="math">  is a linear combination of  </span>\\ell + \\ell'<span class="math">  vectors with multiplicative structure; this representation can be computed in  </span>O(m)<span class="math">  operations in  </span>\\mathbb{F}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let  <span class="math">n = 2^m</span> . Fix some commitment scheme for  <span class="math">\\mathbb{F}</span>  and  <span class="math">\\mathbb{F}^{n\\times n}</span>  with public parameters  <span class="math">pp_{\\mathbb{F}}</span> ,  <span class="math">pp_{\\mathbb{F}^{n\\times n}}</span>  respectively, and define:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left(\\mathcal {C} _ {M}, \\mathcal {C} _ {y}, \\vec {L}, \\vec {R}\\right) \\in \\mathcal {L} _ {V M V, n, p p _ {\\mathbb {F} ^ {n \\times n}}, p p _ {\\mathbb {F}}} \\subset \\mathbb {G} _ {T} \\times \\mathbb {G} _ {1} \\times \\mathbb {F} ^ {n} \\times \\mathbb {F} ^ {n} \\\\ \\Leftrightarrow \\exists (M \\in \\mathbb {F} ^ {n \\times n}, y \\in \\mathbb {F}, \\mathcal {S} _ {M}, \\mathcal {S} _ {y}): y = \\vec {L} ^ {T} M \\vec {R}, \\\\ \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">O p e n (p p _ {\\mathbb {F} ^ {n \\times n}}, \\mathcal {C} _ {M}, M, \\mathcal {S} _ {M}) = 1, O p e n (p p _ {\\mathbb {F}}, \\mathcal {C} _ {y}, y, \\mathcal {S} _ {y}) = 1.</span></div>

    <p class="text-gray-300">This is a stepping stone to polynomial commitments, in which  <span class="math">\\vec{L},\\vec{R}</span>  will have multiplicative structure. For a batch of  <span class="math">\\ell</span>  evaluations these vectors will be linear combinations of  <span class="math">\\ell</span>  vectors with multiplicative structure. We require public parameters  <span class="math">pp_{VMV}</span> , generated by the public coin  <span class="math">\\mathsf{Gen}_{VMV}</span> :</p>

    <p class="text-gray-300">|  Γ1,0, Γ1,fin, H1← G12m × G1 × G1, Γ2,0, Γ2,fin, H2← G22m × G2 × G2,  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">∀i ∈ 0,..., m-1:</td>

            <td class="px-3 py-2 border-b border-gray-700">Δ1L,i = ⟨Γ1,i+1, Γ2,i+1⟩,</td>

            <td class="px-3 py-2 border-b border-gray-700">Δ2L,i = ⟨Γ1,i+1, Γ2,i+1⟩,</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">∀i ∈ 0,..., m-1:</td>

            <td class="px-3 py-2 border-b border-gray-700">Δ1R,i = ⟨(Γ1,i)R, Γ2,i+1⟩,</td>

            <td class="px-3 py-2 border-b border-gray-700">Δ2R,i = ⟨Γ1,i+1, (Γ2,i)R⟩,</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">χ = ∑j=0m-1⟨Γ1,j, Γ2,j⟩,</td>

            <td class="px-3 py-2 border-b border-gray-700">χfin = ⟨Γ1m, Γ2m⟩</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">HT = e(H1, H2)</td>

            <td class="px-3 py-2 border-b border-gray-700">Y = e(H1, Γ2,fin)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We fix Pedersen commitment parameters  <span class="math">pp_{\\mathbb{F}} = (\\Gamma_{1,fin}, H_1)</span> , and parameters  <span class="math">pp_{\\mathbb{F}^{n \\times n}} = \\{\\Gamma_{1,0}, H_1, \\Gamma_{2,0}, H_2\\}</span>  for the matrix commitment from Section 2.4. Recall that if  <span class="math">\\operatorname{Commit}(pp, M) = (T, (\\vec{r_{\\mathrm{rows}}}, r_{\\mathrm{fin}}, \\vec{T}&#x27;)</span> , then  <span class="math">\\vec{T}&#x27; \\in \\mathbb{G}_1^n</span>  is a vector of Pedersen commitments to the rows of  <span class="math">M</span>  with generators  <span class="math">(\\Gamma_{1,0}; H_1)</span> , and  <span class="math">T</span>  is a AFGHO commitment to  <span class="math">\\vec{T}&#x27;</span>  with generators  <span class="math">(\\Gamma_{2,0}; H_2)</span> . So  <span class="math">T</span>  is a hiding commitment to  <span class="math">M</span> . The alert reader may note that  <span class="math">\\vec{T}&#x27;</span>  depends only on  <span class="math">M</span>  and  <span class="math">\\vec{r_{\\mathrm{rows}}}</span> ; it is retained in the opening hint by  <span class="math">\\mathcal{P}</span>  to accelerate the evaluation proof.</p>

    <p class="text-gray-300">The general strategy for an argument of knowledge for  <span class="math">\\mathcal{L}_{VMV,n,pp_{\\mathbb{F}^{n\\times n}},pp_{\\mathbb{F}}}</span>  is as follows. The commitment to  <span class="math">y = \\vec{L}^T M\\vec{R}</span>  is  <span class="math">y_{com} = y\\Gamma_{1,fin} + r_yH_1</span> .  <span class="math">\\mathcal{P}</span>  can compute the vector  <span class="math">\\vec{v} = \\vec{L}^T M</span> , and by construction  <span class="math">y = \\vec{L}^T M\\vec{R} = \\langle \\vec{v},\\vec{R}\\rangle</span> . Since</p>

    <p class="text-gray-300">Pedersen commitments are linearly homomorphic:</p>

    <div class="my-4 text-center"><span class="math-block">v _ {c o m} := \\langle \\vec {L}, C ^ {\\prime} \\rangle = \\operatorname {C o m m i t} _ {\\Gamma_ {1, 0}; H _ {1}} (\\vec {v}; \\langle \\vec {L}, r _ {\\text {r o w s}} ^ {\\rightarrow} \\rangle)</span></div>

    <p class="text-gray-300">is a hiding commitment to  <span class="math">\\vec{v}</span>  with blind  <span class="math">r_v = \\langle \\vec{L}, r_{\\mathrm{rows}} \\rangle</span> . Recall also that  <span class="math">T</span>  is a hiding commitment to  <span class="math">\\vec{T}&#x27; \\in \\mathbb{G}_1^n</span> . So to prove  <span class="math">(T, y_{com}, \\vec{L}, \\vec{R}) \\in \\mathcal{L}_{VMV,n,pp_{\\mathrm{yn} \\times n}, ppr}</span> , it suffices to prove knowledge of  <span class="math">\\vec{T}&#x27; \\in \\mathbb{G}_1^n</span> ,  <span class="math">\\vec{v} \\in \\mathbb{F}^n</span> ,  <span class="math">r_v, r_{\\mathrm{fin}}</span> ,  <span class="math">r_y \\in \\mathbb{F}</span>  such that:  <span class="math">T = \\langle \\vec{T}&#x27;, \\Gamma_2 \\rangle + r_{\\mathrm{fin}} H_T</span> ,  <span class="math">\\langle \\vec{L}, \\vec{T}&#x27; \\rangle = \\langle \\vec{v}, \\Gamma_1 \\rangle + r_v H_1</span> , and  <span class="math">y_{com} = \\langle \\vec{v}, \\vec{R} \\rangle \\Gamma_{1,fin} + r_y H_1</span></p>

    <pre><code class="language-latex">Eval-VMV-REppVMV  $(T,y_{com},\\vec{L},\\vec{R})$ $\\mathcal{P}$  witness:  $M,(\\vec{T}^{\\prime},r_{\\mathrm{rows}}^{\\rightarrow},r_{\\mathrm{fin}}),r_y$ $\\mathcal{P}$  ..  $\\vec{v} = \\vec{L}^{T}M$ $r_v = \\langle \\vec{L},r_{\\mathrm{rows}}\\rangle$ $y = \\langle \\vec{v},\\vec{R}\\rangle$ $r_C,r_{D_2},r_{E_1},r_{E_2}\\stackrel {\\S}{\\leftarrow}\\mathbb{F}$ $\\mathcal{P}\\to \\mathcal{V}$  ..  $C = e(\\langle \\vec{v},\\vec{T}^{\\prime}\\rangle ,\\Gamma_{2,fin}) + r_{C}H_{T}$ $D_{2} = e(\\langle \\Gamma_{1},\\vec{v}\\rangle ,\\Gamma_{2,fin}) + r_{D_{2}}H_{T},$ $E_{1} = \\langle \\vec{L},C^{\\prime}\\rangle +r_{E_{1}}H_{1}$ $E_{2} = y\\Gamma_{2,fin} + r_{E_{2}}H_{2},$ $\\mathcal{P},\\mathcal{V}$  ..  $\\Sigma$  -protocol showing  $\\mathcal{P}$  knows  $s\\in \\mathbb{F}^3$  ..  $E_{2} = s_{1}\\Gamma_{2,fin} + s_{2}H_{2}\\wedge y_{C} = s_{1}\\Gamma_{1,fin} + s_{3}H_{1}$ $\\mathcal{P}$  witness:  $s = (y,r_{E_2},r_y)$ $\\mathcal{P},\\mathcal{V}$  ..  $\\Sigma$  -protocol showing  $\\mathcal{P}$  knows  $t\\in \\mathbb{F}^2$  ..  $e(E_1,\\Gamma_{2,fin}) - D_2 = e(H_1,t_1\\Gamma_{2,fin} + t_2H_2)$ $\\mathcal{P}$  witness:  $t = (r_{E_1} + r_v, - r_{D_2})$ $\\mathcal{P},\\mathcal{V}$  : Dory-Innerproduct  $\\Gamma_{1,0},\\Gamma_{2,0},H_1,H_2(C,T,D_2,E_1,E_2,L,\\vec{R})$  .  $\\mathcal{P}$  witness:  $(\\vec{T}&#x27;,\\vec{v}\\Gamma_{2,fin},r_C,r_{\\mathrm{fin}},r_{D_2},r_{E_1},r_{E_2})$</code></pre>

    <p class="text-gray-300">Theorem 9. For  <span class="math">pp_{VMV}</span>  sampled as above, Eval-VMV-RE is an HVSZK, public-coin, complete, succinct interactive argument of knowledge for  <span class="math">\\mathcal{L}_{VMV}</span> . Assuming SXDH: If for fixed  <span class="math">T</span>  and tuples  <span class="math">(\\vec{L^i},\\vec{R^i},y_{com}^i)\\in \\mathbb{F}^n\\times \\mathbb{F}^n\\times \\mathbb{G}_1</span> ,  <span class="math">\\vec{R^i} (\\vec{L^i})^T</span>  span  <span class="math">\\mathbb{F}^{n\\times n}</span>  and  <span class="math">\\mathcal{P}</span>  can pass Eval-VMV-RE  <span class="math">(T,y_{com}^{i},\\vec{L^{i}},\\vec{R^{i}})</span>  with non-negligible probability for each  <span class="math">i</span> , then  <span class="math">M</span> ,  <span class="math">\\vec{T}&#x27;</span> ,  <span class="math">r_{rows}</span> ,  <span class="math">r_{fin}</span>  and the set  <span class="math">\\{r_y^i\\}_i</span>  can be extracted.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Remark 6. Note that we do not claim that Eval-VMV-RE with  <span class="math">\\vec{L},\\vec{R}</span>  sampled is  $(O(n^{2}),O(n^{2}) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> -tree extractable, as without the spanning condition on  </span>\\vec{L},\\vec{R}<span class="math">  the transcript can be independent of at least one entry of  </span>M$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. Completeness is straightforward from the definition of  <span class="math">\\mathcal{P}</span> 's witnesses. Succinctness, the Public Coin property and HVSZK of Eval-VMV-RE follow straightforwardly from the same properties for the two auxiliary  <span class="math">\\Sigma</span> -protocols and Dory-Innerproduct.</p>

    <p class="text-gray-300">Recall that in  <span class="math">\\mathsf{Gen}_{VMV}</span> ,  <span class="math">\\Gamma_{1,0},\\Gamma_{2,0},\\Gamma_{1,fin},\\Gamma_{2,fin},H_1,H_2</span>  are all sampled, so on SXDH finding a non-trivial linear relationship between them contradicts Lemma 3. Given tuples  <span class="math">(\\vec{L^i},\\vec{R^i},y_{com}^i)</span>  such that  <span class="math">\\mathcal{P}</span>  passes Eval-VMV-RE for some fixed  <span class="math">T</span>  with non-negligible probability, witness extract Dory-Innerproduct and the two</p>

    <p class="text-gray-300">sigma proofs in Eval-VMV-RE. For each <span class="math">i</span>, we have (suppressing <span class="math">i</span> superscripts):</p>

    <div class="my-4 text-center"><span class="math-block">\\vec{v_1} \\in \\mathbb{G}_1^n, \\vec{v_2} \\in \\mathbb{G}_2^n, S, y_C \\in \\mathbb{G}_1, D_2 \\in \\mathbb{G}_2, E_1, E_2 \\in \\mathbb{G}_T, y \\in \\mathbb{F}.</span></div>

    <div class="my-4 text-center"><span class="math-block">s_2, r_y, t_1, t_2, r_C, r_{D_1}, r_{D_2}, r_{E_1}, r_{E_2} \\in \\mathbb{F}:</span></div>

    <div class="my-4 text-center"><span class="math-block">e(E_1, \\Gamma_{2,fin}) = D_2 + e(H_1, t_1 \\Gamma_{2,fin} - t_2 H_2) \\quad (4),</span></div>

    <div class="my-4 text-center"><span class="math-block">E_2 = y \\Gamma_{2,fin} + s_2 H_2 \\tag{5}, \\quad y_C = y \\Gamma_{1,fin} + r_y H_1 \\tag{6},</span></div>

    <div class="my-4 text-center"><span class="math-block">T = \\langle \\vec{v_1}, \\Gamma_{2,0} \\rangle + r_{D_1} \\cdot e(H_1, H_2) \\quad (7), \\quad D_2 = \\langle \\Gamma_{1,0}, \\vec{v_2} \\rangle + r_{D_2} \\cdot e(H_1, H_2) \\quad (8),</span></div>

    <div class="my-4 text-center"><span class="math-block">E_1 = \\langle \\vec{L}, \\vec{v_1} \\rangle + r_{E_1} H_1 \\quad (9), \\quad E_2 = \\langle \\vec{R}, \\vec{v_2} \\rangle + r_{E_2} H_2 \\tag{10}</span></div>

    <p class="text-gray-300">Since <span class="math">T</span> is a constant in (7), <span class="math">\\vec{v_1}^i, r_{D_1}^i</span> must also be fixed for all <span class="math">i</span>, as otherwise the difference of some pair gives a non-trivial relationship between <span class="math">\\Gamma_2, H_2</span>, contradicting Lemma 3. Then substituting (8, 9) into (4) we have for each <span class="math">i</span> (suppressing <span class="math">i</span> superscripts):</p>

    <div class="my-4 text-center"><span class="math-block">e(\\langle \\vec{L}, \\vec{v_1} \\rangle, \\Gamma_{2,fin}) = \\langle \\Gamma_{1,0}, \\vec{v_2} \\rangle + e(H_1, (t_1 - r_{E_1}) \\Gamma_{2,fin} - (t_2 - r_{D_2}) H_2) \\tag{11}</span></div>

    <p class="text-gray-300">Then if <span class="math">\\vec{v_2}^i</span> is not a linear function of <span class="math">\\vec{L&#x27;}</span>, there exists a linear combination of these relationships eliminating <span class="math">\\vec{L&#x27;}</span> from the left hand side (since <span class="math">\\vec{v_1}</span> is a constant) without eliminating <span class="math">\\vec{v_2}</span> on the right. So we would obtain a non-trivial relationship between <span class="math">\\Gamma_{1,0}, H_1</span>, contradicting Lemma 3. From (5, 10) we have (suppressing <span class="math">i</span> superscripts): <span class="math">\\langle \\vec{R}, \\vec{v_2} \\rangle = y \\Gamma_{2,fin} + (s_2 - r_{E_2}) H_2</span>, and so if <span class="math">y^i</span> and <span class="math">(s_2^i - r_{E_2}^i)</span> are not bilinear in <span class="math">\\vec{L&#x27;}, \\vec{R&#x27;}</span> we obtain a non-trivial relationship between <span class="math">\\Gamma_{2,fin}, H_2</span>, contradicting Lemma 3. In particular since <span class="math">\\vec{R&#x27;}(\\vec{L&#x27;})^T</span> span <span class="math">\\mathbb{F}^{n \\times n}</span> we extract fixed matrices <span class="math">M, B \\in \\mathbb{F}^{n \\times n}</span> such that <span class="math">y^i = (\\vec{L&#x27;})^T M \\vec{R&#x27;}</span> and <span class="math">s_2^i - r_{E_2}^i = (\\vec{L&#x27;})^T B \\vec{R&#x27;}</span> for all <span class="math">i</span>. So <span class="math">\\vec{v_2}^i = (\\vec{L&#x27;})^T M \\Gamma_{2,fin} + (\\vec{L&#x27;})^T B H_2</span>. Substituting into (11), we have for each <span class="math">i</span> (suppressing <span class="math">i</span> superscripts):</p>

    <div class="my-4 text-center"><span class="math-block">e(\\langle \\vec{L}, \\vec{v_1} - M \\Gamma_{1,0} \\rangle + (r_{E_1} - t_1) H_1, \\Gamma_{2,fin}) = e(\\langle \\vec{L}^T B, \\Gamma_{1,0} \\rangle + (r_{D_2} - t_2) H_1, H_2)</span></div>

    <p class="text-gray-300">and so either we find a non-trivial pairing relationship between <span class="math">\\Gamma_{2,fin}, H_2</span>, contradicting Lemma 3, or for all <span class="math">i</span> and suppressing superscripts:</p>

    <div class="my-4 text-center"><span class="math-block">0 = \\langle \\vec{L}, \\vec{v_1} - M \\Gamma_{1,0} \\rangle + (r_{E_1} - t_1) H_1 \\quad (12), \\quad 0 = \\langle \\vec{L}^T B, \\Gamma_{1,0} \\rangle + (r_{D_2} - t_2) H_1 \\quad (13).</span></div>

    <p class="text-gray-300">Similarly a non-trivial relationship between <span class="math">\\Gamma_{1,0}, H_1</span> would violate Lemma 1. So Equation 13 implies that <span class="math">(\\vec{L&#x27;})^T B = 0</span> and <span class="math">r_{D_2}^i = t_2^i</span> for all <span class="math">i</span>, so <span class="math">B = 0</span>. From Equation 12 the first we deduce that <span class="math">r_{E_1}^i - t_1^i</span> must be a linear function of <span class="math">\\vec{L&#x27;}</span> and independent of <span class="math">\\vec{R}</span>, so we have some <span class="math">\\vec{r_{\\mathrm{rows}}} \\in \\mathbb{F}^n</span> such that <span class="math">r_{E_1}^i - t_1^i = (\\vec{L&#x27;})^T \\vec{r_{\\mathrm{rows}}}</span>, which implies that <span class="math">\\vec{v_1} = M \\Gamma_{1,0} + \\vec{r_{\\mathrm{rows}}} H_1</span>. Substituting into (7) we have:</p>

    <div class="my-4 text-center"><span class="math-block">T = \\langle M \\Gamma_{1,0}, \\Gamma_{2,0} \\rangle + e(H_1, r_{D_2} H_2 + \\langle \\vec{r_{\\mathrm{rows}}}, \\Gamma_{2,0} \\rangle),</span></div>

    <p class="text-gray-300">i.e. that <span class="math">T</span> is a commitment to <span class="math">M</span> with opening hint <span class="math">(\\vec{r_{\\mathrm{rows}}}, r_{\\mathrm{fin}} = r_{D_2}, \\vec{T}&#x27; = \\vec{v_1})</span>. Substituting <span class="math">y = (\\vec{L&#x27;})^T M \\vec{R&#x27;}</span> into (6), <span class="math">y_C^i</span> is a commitment to the evaluation. So we have extracted a matrix <span class="math">M</span>, evaluations <span class="math">y^i</span> and opening hints <span class="math">\\vec{T}&#x27;, \\vec{r_{\\mathrm{rows}}}, r_{\\mathrm{fin}}</span> and <span class="math">r_y^i</span> consistent with the commitments.</p>

    <p class="text-gray-300">28</p>

    <p class="text-gray-300">If  <span class="math">\\mathcal{P}</span>  additionally shows that  <span class="math">T</span>  can be opened at some random challenge point, we can obtain tree extractability</p>

    <pre><code class="language-latex">Eval-VMVppVMV  $(T,y_{com},\\vec{L},\\vec{R})$ $\\mathcal{P}$  witness:  $M,(\\vec{T}^{\\prime},r_{\\mathrm{rows}}^{\\rightarrow}r_{\\mathrm{fin}}),r_y$ $\\mathcal{V}\\to \\mathcal{P}$  ..  $u\\gets_{\\mathbb{S}}\\mathbb{F}$ $\\mathcal{P},\\mathcal{V}$  ..  $\\vec{L}^{\\prime} = (1,u,u^{2},\\dots u^{n - 1})$  ，  $\\vec{R}^{\\prime} = (1,u^{n},u^{2n},\\dots ,u^{(n - 1)n})$ $\\mathcal{P}$  ..  $r_{y^{\\prime}}\\gets_{\\mathbb{S}}\\mathbb{F}$  .
$\\mathcal{P}\\rightarrow \\mathcal{V}$  ..  $y_{com}^{\\prime} = \\vec{L}^{\\prime}MR^{\\prime}\\Gamma_{1,fin} + r_{y^{\\prime}}H_{1}$ $\\mathcal{P},\\mathcal{V}$  :Eval-VMV-REppVMV  $(T,y_{com},\\vec{L},\\vec{R})\\wedge$  Eval-VMV-REppVMV  $(T,y_{com}^{\\prime},\\vec{L}^{\\prime},\\vec{R}^{\\prime})$ $\\mathcal{P}$  witnesses:  $(M,(\\vec{T}^{\\prime},r_{\\mathrm{rows}}^{\\rightarrow}r_{\\mathrm{fin}}),r_y)$  and  $(M,(\\vec{T}^{\\prime},r_{\\mathrm{rows}}^{\\rightarrow}r_{\\mathrm{fin}}),r_{y^{\\prime}})$</code></pre>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 10. Eval-VMV is a HVSZK succinct interactive argument of knowledge for  <span class="math">\\mathcal{L}_{VMV}</span>  with  $(\\mathcal{O}(n^{2 + \\log 9},\\mathcal{O}(n^{2 + \\log 9}) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ -tree extractability under SXDH.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. All properties except tree extractability are immediate.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We take  <span class="math">\\mu = 1</span>  and set  <span class="math">w_{1} = n^{2}</span> . Internal to each of the  <span class="math">2n^{2}</span>  calls to Eval-VMV-RE, the two sigma proofs are each  $(2,2 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> -tree extractable, and Dory-Innerproduct is  </span>(\\mathcal{O}(n^{\\log 9}),\\mathcal{O}(n^{\\log 9}) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ -tree extractable.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">So it suffices to show that this  <span class="math">\\mathcal{O}(n^{2 + \\log 9})</span> -sized tree of accepting transcripts requires  <span class="math">\\mathcal{P}</span>  to pass Eval-VMV-RE for  <span class="math">T</span>  fixed and some collection of  <span class="math">\\vec{L^{\\prime}},\\vec{R^{\\prime}}</span>  containing  <span class="math">\\vec{L},\\vec{R}</span>  such that  <span class="math">\\vec{R^{\\prime}} (\\vec{L^{\\prime}})^{T}</span>  span  <span class="math">\\mathbb{F}^{n\\times n}</span> . Reading off the entries in  <span class="math">\\vec{R}^{\\prime}(\\vec{L}^{\\prime})^{T}</span>  row-wise gives  <span class="math">1,u,u^{2},\\ldots ,u^{n^{2} - 1}</span> . Any linear dependence between these  <span class="math">n^2</span>  vectors would imply the existence of a non-zero polynomial of degree  <span class="math">n^2 -1</span>  vanishing at  <span class="math">n^2</span>  distinct  <span class="math">u</span> , which is impossible. Hence they span  <span class="math">\\mathbb{F}^{n\\times n}</span>  as required.</p>

    <p class="text-gray-300">From Section 4.4, we can batch multiple invocations of Dory-Innerproduct and so we similarly have an argument for a batches of Eval-VMV-RE or Eval-VMV. We can further optimise these batch arguments by observing that the Sigma proofs in Eval-VMV-RE show knowledge of logarithms with respect to fixed bases  <span class="math">\\Gamma_{2,fin}, H_2, \\Gamma_{1,fin}, H_1</span> . So as is standard we linearly combine these claims with random challenges supplied by  <span class="math">\\mathcal{V}</span>  and prove the combination, with negligible alteration to soundness and extractability.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For an  <span class="math">n \\times n</span>  matrix  <span class="math">M</span> , the size of the public parameters is  $(n + 2)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ (n + 2)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ (3\\log n + 4)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}_T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , and running Gen requires sampling  </span>n + 2<span class="math">  elements of  </span>\\mathbb{G}_1<span class="math"> ,  </span>n + 2<span class="math">  elements of  </span>\\mathbb{G}_2<span class="math"> ,  </span>3n<span class="math">  pairings and  </span>\\log n<span class="math">  additions in  </span>\\mathbb{G}_T$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To Commit a matrix  <span class="math">M</span> ,  <span class="math">\\mathcal{P}</span>  samples  <span class="math">n + 1</span>  elements of  <span class="math">\\mathbb{F}</span> , and performs  <span class="math">n</span>  multi-exponentiations of size  <span class="math">n + 1</span>  in  <span class="math">\\mathbb{G}_1</span> , a multi-pairing of size  <span class="math">n</span> , and an exponentiation and addition in  <span class="math">\\mathbb{G}_T</span> . The  <span class="math">n</span>  multi-exponentiations in  <span class="math">\\mathbb{G}_1</span>  are over fixed generators  $(\\Gamma_{1,0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_1)$ , so Pippenger-type optimisations save an asymptotic</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">factor <span class="math">2\\log n</span>. Proving Eval-VMV-RE requires proving Dory-Innerproduct, three multi-exponentiations in <span class="math">\\mathbb{G}_1</span> of size <span class="math">n</span> and <span class="math">O(1)</span> additional exponentiations in <span class="math">\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T</span>. The messages from <span class="math">\\mathcal{P}</span> to <span class="math">\\mathcal{V}</span> have size $5</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">; </span>\\mathcal{V}<span class="math">&#x27;s computation is 5 exponentiations in </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, 3 exponentiations in </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, an exponentiation in </span>\\mathbb{G}_T<span class="math"> and 2 pairings. Beyond proving a batch of two instances of Eval-VMV-RE, proving Eval-VMV requires </span>\\mathcal{P}<span class="math"> perform </span>O(1)<span class="math"> exponentiations in </span>\\mathbb{G}_1<span class="math">. The messages from </span>\\mathcal{P}<span class="math"> to </span>\\mathcal{V}<span class="math"> have size </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Noting that </span>\\vec{L}', \\vec{R}'<span class="math"> have multiplicative structure and so do not need to be instantiated explicitly by </span>\\mathcal{V}<span class="math">, </span>\\mathcal{V}<span class="math">&#x27;s computation is </span>O(\\log n)<span class="math"> multiplications in </span>\\mathbb{F}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-37" class="text-2xl font-bold">6 Dory-PC</h2>

    <p class="text-gray-300">We recall the discussion in Section 2.5. Concretely, the evaluation of any multivariate polynomial in <span class="math">X_{1}\\ldots X_{\\ell}</span> of degrees <span class="math">d_{1},\\ldots ,d_{\\ell}</span> at <span class="math">\\vec{x}\\in \\mathbb{F}^{\\ell}</span> can be replaced by the evaluation of a multilinear polynomial in <span class="math">r = \\sum_{i}\\lceil \\log (d_i + 1)\\rceil</span> variables, where the coefficients of the two polynomials are equal. Given a multilinear polynomial <span class="math">f</span> on <span class="math">r</span> variables, we observe that:</p>

    <div class="my-4 text-center"><span class="math-block">f (\\vec {x}) = \\sum_ {b \\in \\{0, 1 \\} ^ {r}} f _ {b} \\prod_ {i} x _ {i} ^ {b _ {i}} = \\sum_ {v \\in \\{0, 1 \\} ^ {r}} f (v) \\prod_ {i} \\left(x _ {i} v _ {i} + (1 - x _ {i}) (1 - v _ {i})\\right)</span></div>

    <p class="text-gray-300">which provides for the evaluation of the polynomial as a contraction of a <span class="math">2 \\times \\ldots \\times 2</span> tensor <span class="math">T^{i_1 \\ldots i_r}</span> with vectors given either the coefficients of <span class="math">f</span> or its evaluations on <span class="math">\\{0,1\\}^r</span>. Let <span class="math">m = \\lceil r / 2 \\rceil</span>. In either case, we can define a <span class="math">2^m \\times 2^m</span> matrix <span class="math">M_{ij}</span> by:</p>

    <div class="my-4 text-center"><span class="math-block">M _ {i j} = T ^ {i _ {1} \\dots i _ {r}} \\text{ if } i 2 ^ {r} + j = \\sum_ {k = 1} ^ {r} i _ {k} 2 ^ {r - k}, \\quad M _ {i j} = 0 \\text{ otherwise}.</span></div>

    <p class="text-gray-300">and then <span class="math">f(\\vec{x}) = (1 - z)\\vec{L}^T M\\vec{R}</span> where <span class="math">\\vec{L} = \\otimes_{i=1}^{m}(\\ell_i, r_i)</span> and <span class="math">z = 0</span> for <span class="math">r</span> even, <span class="math">\\vec{L} = (1, z) \\otimes \\left( \\otimes_{i=1}^{m-1}(\\ell_i, r_i) \\right)</span> for <span class="math">z \\stackrel{\\S}{\\leftarrow} \\mathbb{F}</span> for <span class="math">r</span> odd, and <span class="math">\\vec{R} = \\otimes_{i=r-m+1}^{r}(\\ell_i, r_i)</span>. In the case where we are given the coefficients of <span class="math">f</span>, we take <span class="math">\\ell_i = 1, r_i = x_i</span>. If we are given the evaluations of <span class="math">f</span> on the <span class="math">\\{0,1\\}</span> cube, we take <span class="math">\\ell_i = 1 - x_i</span>, <span class="math">r_i = x_i</span>. Note that the implicit extension to a polynomial in <span class="math">2m</span> variables has no impact, as the additional variable is unconditionally set to 0. So we have reduced polynomial evaluation to a vector-matrix-vector product, where the vectors <span class="math">\\vec{L}, \\vec{R}</span> have multiplicative structure. Dory-PC-RE uses the commitment scheme of Section 2.4, and uses Eval-VMV-RE as Eval. Similarly Dory-PC uses Eval-VMV as Eval.</p>

    <p class="text-gray-300"><strong>Theorem 11.</strong> Dory-PC-RE is an honest-verifier, statistical zero-knowledge, random evaluation extractable polynomial commitment scheme for <span class="math">r</span>-variable multilinear polynomials. Dory-PC is an honest-verifier, statistical zero-knowledge, extractable polynomial commitment scheme for <span class="math">r</span>-variable multilinear polynomials.</p>

    <p class="text-gray-300"><strong>Proof.</strong> All properties except extractability are immediate for both schemes. For Dory-PC, Theorem 10 proves extractability.</p>

    <p class="text-gray-300">For Dory-PC-RE: Suppose some <span class="math">2^{r+1}=2n^{2}</span> distinct <span class="math">\\vec{x}\\in\\mathbb{F}^{r}</span> are sampled. If the outer products <span class="math">\\vec{R}\\vec{L}^{T}</span> do not span <span class="math">\\mathbb{F}^{n\\times n}</span>, there is some non-zero element of the dual whose inner product with these is <span class="math">0</span>; this gives a some non-zero multilinear polynomial vanishing for all <span class="math">\\vec{x}</span>. By the Schwartz-Zippel lemma and a union bound, the probability that this occurs is bounded by</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2^{r}}\\cdot\\left(\\frac{r}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^{2^{r+1}}=\\left(\\frac{r^{2}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^{2^{r}}=\\mathtt{negl}(\\lambda),$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">as even $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-1/2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathtt{negl}(\\lambda)$ (Remark 3). Theorem 9 then completes the proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Since the vectors <span class="math">\\vec{L},\\vec{R}</span> (and <span class="math">\\vec{L}^{\\prime},\\vec{R}^{\\prime}</span> in Dory-PC) have multiplicative structure, the remarks made in Section 4.3 apply; <span class="math">\\mathcal{V}</span>’s use of these vectors are restricted to computing inner products with vectors <span class="math">\\otimes_{i=0}^{m-1}(\\alpha_{i},1)</span>, <span class="math">\\otimes_{i=0}^{m-1}(\\alpha_{i}^{-1},1)</span> which can be computed in <span class="math">O(m)</span> operations in <span class="math">\\mathbb{F}</span> given <span class="math">x</span>, <span class="math">\\alpha_{i},\\alpha_{i}^{-1}</span>.</p>

    <h3 id="sec-38" class="text-xl font-semibold mt-8">6.1 Concrete costs of Dory-PC-RE</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">n=\\prod_{i}(d_{i}+1)</span>, and let $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O(n)<span class="math"> be the number of non-zero entries in the matrix </span>M<span class="math">. In the worst case </span>d_{i}=4<span class="math"> and </span>m=\\frac{3}{2\\log 5}\\log n+O(1)<span class="math">. For multilinear or univariate polynomials </span>m=\\frac{1}{2}\\log n+O(1)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Using the fact that the <span class="math">2^{m}\\times 2^{m}</span> matrix has at most $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> non-zero entries, </span>\\mathcal{P}<span class="math">’s time to run Commit is dominated by </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+2^{m}<span class="math"> exponentiations in </span>\\mathbb{G}_{1}<span class="math"> and </span>2^{m}<span class="math"> pairings. From Section 5.2, </span>\\mathcal{P}<span class="math">’s time to run Eval is dominated by </span>O(2^{m})$ pairings.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The size of <span class="math">\\mathcal{P}\\to\\mathcal{V}</span> messages is $(6m+7)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+(3m+3)(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)+8</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and </span>\\mathcal{V}\\to\\mathcal{P}<span class="math"> messages are </span>O(m)<span class="math"> sampled elements of </span>\\mathbb{F}<span class="math">. </span>\\mathcal{V}<span class="math"> computes a </span>9m+O(1)<span class="math"> sized multi-exponentiation in </span>\\mathbb{G}_{T}<span class="math"> and </span>O(1)$ additional exponentiations and pairings.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-39" class="text-xl font-semibold mt-8">6.2 Batching</h3>

    <p class="text-gray-300">Given a batch of <span class="math">\\ell</span> polynomials with individual <span class="math">m_{i}\\leq m</span>, we can use batching to reduce the communication complexity and computational work of <span class="math">\\mathcal{V}</span> substantially. Using Section 5.1, the total size of <span class="math">\\mathcal{P}</span> to <span class="math">\\mathcal{V}</span> messages is:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$(6m+3\\ell+5)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}_{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+(3m+2\\ell+2)(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)+8</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathcal{P}</span>’s main computation remains <span class="math">O(\\ell\\times 2^{m})</span> pairings, though a factor of <span class="math">3</span> is saved in the implied constant. However, deferring <span class="math">\\mathcal{V}</span>’s computations as before, <span class="math">\\mathcal{V}</span>’s group operations can be reduced to an exponentiation in <span class="math">\\mathbb{G}_{T}</span> of size <span class="math">9m+3\\ell+6</span>, exponentiations in <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span> of size <span class="math">3m+2\\ell+2</span>, and a multi-pairing of size <span class="math">4</span>. Unfortunately, the computations with vectors <span class="math">\\vec{L},\\vec{R}</span> cannot be efficiently batched, and so <span class="math">\\mathcal{V}</span> performs an additional <span class="math">2\\ell m</span> multiplications and additions in <span class="math">\\mathbb{F}</span>.</p>

    <p class="text-gray-300">As a corollary, the concrete costs of a batch of <span class="math">\\ell</span> instances of Dory-PC is given by the cost of a batch of <span class="math">2\\ell</span> instances of Dory-PC-RE, with an additional <span class="math">\\ell</span> elements of <span class="math">\\mathbb{G}_{1}</span> added to the <span class="math">\\mathcal{P}</span> to <span class="math">\\mathcal{V}</span> messages.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">We implemented Dory to provide polynomial commitments for dense multilinear polynomials, building on framework for non-interactive arguments and dense multilinear polynomials in the Spartan library [37]. This took  <span class="math">\\sim 3400</span>  LOC. Our implementation used the BLS12-381 curve as implemented in blstrs [2]. We implemented fast algorithms for computing (multiple) multi-exponentiations and torus based compression for serialisation of elements of  <span class="math">\\mathbb{G}_T</span>  in  <span class="math">\\sim 1650</span>  LOC.</p>

    <p class="text-gray-300">The implementation was evaluated on a machine with an AMD Ryzen 5 3600 CPU at  <span class="math">3.6\\mathrm{GHz}</span>  and 16GB RAM. All measurements were taken for a single core. We compare with Spartan-PC, a discrete-log based random evaluation extractable polynomial commitment scheme implemented in the Spartan library [37], which is a highly optimised derivative of the commitment scheme in [40] using Curve25519 as implemented by curve25519-dalek for its curve arithmetic. Throughout, we compare dense multilinear polynomials in  <span class="math">m</span>  variables, i.e. with  <span class="math">n = 2^m</span>  random coefficients. We report results for a variety of polynomial sizes in Figure 3.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 3: Measured performance of Dory-PC-RE for varying polynomial degree.</p>

    <p class="text-gray-300">As can be seen, Dory is slower than the baseline for  <span class="math">\\mathcal{P}</span>  in Commit by a consistent factor  <span class="math">\\sim 2.7</span> , matching the relative speed of  <span class="math">\\mathbb{G}_1</span>  arithmetic on the implementations of Curve25519 and BLS12-381 as seen in Figure 2.</p>

    <p class="text-gray-300">The time taken for  <span class="math">\\mathcal{P}</span>  to prove an evaluation is similarly somewhat slower than Spartan-PC. Naively scaling from microbenchmarks in Figure 2 would suggest that Dory might be  <span class="math">\\sim 45\\times</span>  slower asymptotically. As can be seen, this is essentially true on small instances, but for  <span class="math">n\\sim 2^{20}</span>  the linear  <span class="math">\\mathbb{F}</span>  arithmetic to evaluating the polynomial becomes dominant for Spartan-PC; for  <span class="math">n = 2^{28}</span>  Dory is  <span class="math">\\sim 30\\%</span>  slower than Spartan-PC.</p>

    <p class="text-gray-300">The time taken for Dory's  <span class="math">\\mathcal{V}</span>  to verify an evaluation clearly shows  <span class="math">O(\\log n)</span>  complexity, concretely taking  <span class="math">\\sim (13 + \\log n)ms</span> . The  <span class="math">\\mathcal{V}</span>  of Spartan-PC scales like  <span class="math">n^{1/2}</span> , and is concretely slower than Dory for  <span class="math">n \\gtrsim 2^{24}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In terms of communication complexity, Dory clearly shows a fixed 192-byte commitment size, whilst Dory' proofs are consistently larger than those of Spartan-PC by a factor  <span class="math">\\sim 24</span> . This is this is the ratio between  $6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}_T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 3(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  in the BLS12-381 curve and  </span>2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  in Curve25519, and so is the ratio between the log  </span>n<span class="math">  contributions to the proof size in the two systems. In applications, one might expect to have  </span>\\approx 1<span class="math">  evaluation proof of each freshly committed polynomial; in this context the point where a Dory evaluation proof becomes smaller than a Spartan-PC commitment is  </span>n = 2^{18}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Batching: Recall that Dory-PC effectively batches two evaluations of Dory-PC-PE. We use the batched Dory-PC-RE argument to open multiple committed polynomial evaluations. This naturally impacts the time taken for  <span class="math">\\mathcal{P}</span>  to run Eval, the resulting proof size, and  <span class="math">\\nu</span> 's time taken to run Eval on the batch. We report results for a variety of batch sizes in Figure 4.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 4: Performance of Eval for batched Dory-PC-RE evaluations,  <span class="math">n = 2^{20}</span> .</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a></p>

    <p class="text-gray-300">As can be seen, the marginal costs to increase the batch size by one are small; the marginal  <span class="math">\\mathcal{P}</span>  time is  <span class="math">\\sim 305ms</span> , the marginal contribution to the proof size is 912 bytes, and the marginal  <span class="math">\\mathcal{V}</span>  time is  <span class="math">\\sim 1.1ms</span> . For large batches, this provides  <span class="math">\\mathcal{P}</span>  a constant  <span class="math">\\sim 11.5\\times</span>  saving over proving each evaluation separately; for proof sizes and  <span class="math">\\mathcal{V}</span>  large batches save a factor  <span class="math">\\sim 2\\log n</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Rust-crypto. https://github.com/DaGenix/rust-crypto/, 2017.</li>

      <li>blstrs. https://github.com/filecoin-project/blstrs/, 2020.</li>

      <li>M. Abe, G. Fuchsbauer, J. Groth, K. Haralambiev, and M. Ohkubo. Structure-preserving signatures and commitments to group elements. In T. Rabin, editor, CRYPTO, 2010.</li>

      <li>S. Ames, C. Hazay, Y. Ishai, and M. Venkitasubramaniam. Ligero: Lightweight sublinear arguments without a trusted setup. In CCS, 2017.</li>

      <li>P. S. L. M. Barreto, B. Lynn, and M. Scott. Constructing elliptic curves with prescribed embedding degrees. In S. Cimato, G. Persiano, and C. Galdi, editors, Security in Communication Networks, 2003.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>P. S. L. M. Barreto and M. Naehrig. Pairing-friendly elliptic curves of prime order. In B. Preneel and S. Tavares, editors, Selected Areas in Cryptography, 2006.</li>

      <li>E. Ben-Sasson, I. Bentov, Y. Horesh, and M. Riabzev. Fast Reed-Solomon Interactive Oracle Proofs of Proximity. In ICALP, 2018.</li>

      <li>E. Ben-Sasson, A. Chiesa, A. Kazorian, D. Ojha, A. Popovs, M. Riabzev, N. Spooner, M. Virza, and N. Ward. libiop: a C++ library for IOP-based zkSNARKs. https://github.com/relic-toolkit/relic.</li>

      <li>E. Ben-Sasson, A. Chiesa, M. Riabzev, N. Spooner, M. Virza, and N. P. Ward. Aurora: Transparent succinct arguments for R1CS, 2019.</li>

      <li>D. J. Bernstein. Curve25519: New diffie-hellman speed records. In PKC, 2006.</li>

      <li>D. J. Bernstein, M. Hamburg, A. Krasnova, and T. Lange. Elligator: Elliptic-curve points indistinguishable from uniform random strings. In CCS, 2013.</li>

      <li>J.-F. Biasse, M. J. Jacobson, Jr., and A. K. Silvester. Security estimates for quadratic field based cryptosystems. In ACISP, 2010.</li>

      <li>A. R. Block, J. Holmgren, A. Rosen, R. D. Rothblum, and P. Soni. Time- and space-efficient arguments from groups of unknown order. Springer-Verlag, 2021.</li>

      <li>D. Boneh, B. Bünz, and B. Fisch. A survey of two verifiable delay functions. Cryptology ePrint Archive, Report 2018/712, 2018.</li>

      <li>J. Bootle, A. Cerulli, P. Chaidos, J. Groth, and C. Petit. Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In EUROCRYPT, 2016.</li>

      <li>S. Bowe. Bls12-381: New zk-snark elliptic curve construction. https://electriccoin.co/blog/new-snark-curve/, 2013.</li>

      <li>S. Bowe, J. Grigg, and D. Hopwood. Recursive proof composition without a trusted setup. Cryptology ePrint Archive, Report 2019/1021, 2019.</li>

      <li>B. Bünz, J. Bootle, D. Boneh, A. Poelstra, P. Wuille, and G. Maxwell. Bulletproofs: Short proofs for confidential transactions and more. In S&P, 2018.</li>

      <li>B. Bünz, B. Fisch, and A. Szepieniec. Transparent snarks from dark compilers. Cryptology ePrint Archive, Report 2019/1229, 2019.</li>

      <li>B. Bünz, M. Maller, P. Mishra, N. Tyagi, and N. Vesely. Proofs for inner pairing products and applications. Cryptology ePrint Archive, Report 2019/1177, 2019.</li>

      <li>A. Chiesa, D. Ojha, and N. Spooner. Fractal: Post-quantum and transparent recursive proofs from holography. Cryptology ePrint Archive, Report 2019/1076, 2019.</li>

      <li>S. Dobson, S. D. Galbraith, and B. Smith. Trustless groups of unknown order with hyperelliptic curves. Cryptology ePrint Archive, Report 2020/196, 2020.</li>

      <li>A. Gabizon, Z. J. Williamson, and O. Ciobotaru. Plonk: Permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge. 2019.</li>

      <li>S. D. Galbraith, K. G. Paterson, and N. P. Smart. Pairings for cryptographers. Discrete Applied Mathematics, 156(16):3113 – 3121, 2008.</li>

      <li>O. Goldreich, A. Sahai, and S. Vadhan. Honest-verifier statistical zero-knowledge equals general statistical zero-knowledge. In STOC, 1998.</li>

      <li>J. Groth. Linear algebra with sub-linear zero-knowledge arguments. In CRYPTO, 2009.</li>

      <li>J. Groth. Efficient zero-knowledge arguments from two-tiered homomorphic commitments. In D. H. Lee and X. Wang, editors, ASIACRYPT, 2011.</li>

      <li>J. Groth and Y. Ishai. Sub-linear zero-knowledge argument for correctness of a shuffle. In EUROCRYPT, 2008.</li>

      <li>W. Hart. Antic – algebraic number theory in c. https://github.com/wbhart/antic, 2013.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>T. Icart. How to hash into elliptic curves. In CRYPTO, 2009.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>31. M. J. Jacobson, Jr. and A. J. v. d. Poorten. Computational aspects of NUCOMP. In ANTS, 2002.</li>

      <li>32. A. Kate, G. M. Zaverucha, and I. Goldberg. Constant-size commitments to polynomials and their applications. In ASIACRYPT, 2010.</li>

      <li>33. H. Lipmaa. On diophantine complexity and statistical zero-knowledge arguments. In ASIACRYPT, 2003.</li>

      <li>34. I. A. Lovecruft and H. de Valence. curve25519-dalek: A pure-rust implementation of group operations on ristretto and curve25519.</li>

    </ul>

    <p class="text-gray-300">https://github.com/dalek-cryptography/curve25519-dalek, 2018.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>35. M. Naehrig, P. S. L. M. Barreto, and P. Schwabe. On compressible pairings and their computation. In S. Vaudenay, editor, AFRICACRYPT, 2008.</li>

      <li>36. C. Papamanthou, E. Shi, and R. Tamassia. Signatures of correct computation. In TCC, 2013.</li>

      <li>37. S. Setty. Spartan: Efficient and general-purpose zksnarks without trusted setup. In D. Micciancio and T. Ristenpart, editors, CRYPTO, 2020.</li>

      <li>38. A. Shallue and C. E. van de Woestijne. Construction of rational points on elliptic curves over finite fields. In ANTS, 2006.</li>

      <li>39. M. Tibouchi. Elligator squared: Uniform points on elliptic curves of prime order as uniform random strings. In FOCS, 2014.</li>

      <li>40. R. S. Wahby, I. Tzialla, A. Shelat, J. Thaler, and M. Walfish. Doubly-efficient zkSNARKs without trusted setup. In S&P, 2018.</li>

      <li>41. J. Zhang, T. Xie, Y. Zhang, and D. Song. Transparent polynomial delegation and its applications to zero knowledge proof. In S&P, 2020.</li>

    </ul>`;
---

<BaseLayout title="Dory: Efficient, Transparent arguments for Generalised Inner... (2020/1274)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/1274
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
