---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/419';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Pointproofs: Aggregating Proofs for Multiple Vector Commitments';
const AUTHORS_HTML = 'Sergey Gorbunov, Leonid Reyzin, Hoeteck Wee, Zhenfei Zhang';

const CONTENT = `    <p class="text-gray-300">Pointproofs: Aggregating Proofs for Multiple Vector Commitments</p>

    <p class="text-gray-300">Sergey Gorbunov^{2}, Leonid Reyzin^{1,3}, Hoeteck Wee^{4,5}, and Zhenfei Zhang^{1}</p>

    <p class="text-gray-300">^{1}Algorand ^{2}University of Waterloo ^{3}Boston University ^{4}CNRS, ENS, PSL ^{5}NTT Research</p>

    <p class="text-gray-300">September 22, 2024</p>

    <h6 id="sec-1" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Vector commitments enable a user to commit to a sequence of values and provably reveal one or many values at specific positions at a later time. In this work, we construct Pointproofs— a new vector commitment scheme that supports non-interactive aggregation of proofs across multiple commitments. Our construction enables any third party to aggregate a collection of proofs with respect to different, independently computed commitments into a single proof represented by an elliptic curve point of 48-bytes. In addition, our scheme is hiding: a commitment and proofs for some values reveal no information about the remaining values.</p>

    <p class="text-gray-300">We build Pointproofs and demonstrate how to apply them to blockchain smart contracts. In our example application, Pointproofs reduce bandwidth overheads for propagating a block of transactions by at least <span class="math">60\\%</span> compared to prior state-of-art vector commitments.</p>

    <p class="text-gray-300">Pointproofs are also efficient: on a single-thread, it takes <span class="math">0.08</span> seconds to generate a proof for <span class="math">8</span> values with respect to one commitment, <span class="math">0.25</span> seconds to aggregate <span class="math">4000</span> such proofs across multiple commitments into one proof, and <span class="math">23</span> seconds (0.7 ms per value proven) to verify the aggregated proof.</p>

    <h2 id="sec-2" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Vector commitments <em>[x19, x7]</em> allow a committer to commit to a vector of <span class="math">N</span> values and then selectively reveal elements of the committed vector, proving that they correspond to the original commitment. Vector commitments are used to reduce storage costs in a variety of applications, described in more detail below: instead of storing a vector of values, one can store only the commitment and receive the values together with their proofs as needed. Vector commitments allow applications to trade off storage (of all values) for bandwidth (taken up by revealed values and proofs).</p>

    <p class="text-gray-300">To make the tradeoff between storage and bandwidth more attractive, we need to reduce the proof size. Because individual proofs need to be cryptographically hard to forge, their sizes cannot be reduced too far. Instead, the savings come from having a single short proof for multiple revealed values. The shortest such proofs in the literature are provided by the so-called subvector commitments of Lai and Malavolta *[x18</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">reference</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pp</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">opening</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">group</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Same-Commitment Aggregatable</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cross-Commitment Aggregatable</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[LM19, Fig 1]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N)</td>

            <td class="px-3 py-2 border-b border-gray-700">256 B</td>

            <td class="px-3 py-2 border-b border-gray-700">class group</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[LM19, Fig 2]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N2)</td>

            <td class="px-3 py-2 border-b border-gray-700">48 B</td>

            <td class="px-3 py-2 border-b border-gray-700">bilinear</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[BBF19]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">1312 B</td>

            <td class="px-3 py-2 border-b border-gray-700">class group</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[CFG+20, 5.1]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">1024 B</td>

            <td class="px-3 py-2 border-b border-gray-700">class group</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[CFG+20, 5.2]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">512 B</td>

            <td class="px-3 py-2 border-b border-gray-700">class group</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[TAB+20]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N)</td>

            <td class="px-3 py-2 border-b border-gray-700">48 B</td>

            <td class="px-3 py-2 border-b border-gray-700">bilinear</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">this work</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N)</td>

            <td class="px-3 py-2 border-b border-gray-700">48 B</td>

            <td class="px-3 py-2 border-b border-gray-700">bilinear</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Summary of subvector commitments with constant-size commitments and openings to subvectors at 128-bit security level. (See Table 3 for an explanation of the numbers.)</p>

    <p class="text-gray-300">Section 5.2]: a proof takes up only 48 bytes (for typical parameter values at conjectured 128-bit security) regardless of how many elements of the vector are being revealed. <span class="math">^{1}</span></p>

    <p class="text-gray-300">In many distributed applications, the commitments, values, and proofs come from multiple sources that are not even aware of each other's data. This presents two problems that are not solved by subvector commitments:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>there is no single entity that can produce a single proof for all the values;</li>

      <li>proofs need to be with respect to multiple different commitments.</li>

    </ul>

    <p class="text-gray-300">For instance, consider a blockchain that contains information on multiple accounts. Each account, controlled by a different user, is associated with a memory that consists of multiple variables. The memory may, for example, store the values of variables in a smart contract. To validate each block, participants in the blockchain protocol (so-called "validators") need to have access to the variables used during the relevant transactions. One solutions is to have validators store all the variables locally. However, to save on storage, we may instead apply commitments, and ask account holders to commit to the values of their variables. During the relevant transaction, account holders would produce proofs for the relevant values. Our goal is to save on bandwidth required for these proofs to reach validators, while enabling solutions that do not rely on central parties or additional interaction.</p>

    <p class="text-gray-300">We construct Pointproofs—an efficient commitment scheme with small commitments and proofs. Using Pointproofs, a user can independently commit to her variables and provide short proofs for any subset of them. Moreover, any third party can non-interactively aggregate multiple proofs with respect to different commitments into a single short proof.</p>

    <p class="text-gray-300">We note that dynamic aggregation for a single commitment gives, in particular, subvector commitments. Such same-commitment aggregation was explored by Boneh, Bunz, and Fisch [BBF19] and (in work independent of ours) by Tomescu et al.  <span class="math">\\left[\\mathrm{TAB}^{+}20\\right]</span> , who showed how to aggregate proofs for elements of a vector into a single proof for a subvector. Aggregation of [BBF19] was extended to incremental aggregation (which allows aggregation of already aggregated proofs) by Campanelli et al.  <span class="math">\\left[\\mathrm{CFG}^{+}20\\right]</span> . To the best of our knowledge, there have been no schemes that can aggregate proofs across multiple commitments; see Table 1 for a summary of prior constructions.</p>

    <p class="text-gray-300">1.1 Our Contributions</p>

    <p class="text-gray-300">First, we formalize aggregatable vector commitments in the cross-commitment setting (Section 3). For functionality, we require that proofs for individual elements of a single vector commitment can be aggregated by any third party into a single proof for the subvector, and proofs for subvectors of multiple commitments can be aggregated by any third party into a single proof for the multiple subvectors. We also consider hiding while still supporting the aggregation property.</p>

    <p class="text-gray-300">Next, we add same-commitment and cross-commitment aggregation to the vector commitments of <em>[x14]</em> to construct Pointproofs (Section 4). Our proof is a single point on a pairing-friendly curve (48 bytes at 128-bit security), whether for a single value, a subvector of values for a single commitment, or a set of subvectors for multiple commitments. Our construction easily extends to support full hiding of the committed values at the cost of an additional exponentiation and no increase in commitment or proof sizes. While the authors of <em>[x2, Section 3]</em> point out that hiding in vector commitments can be achieved generically by adding an inner layer of hiding commitments to individual values, this approach does not automatically extend to aggregatable vector commitments, because proofs for the inner layer are not automatically aggregatable.</p>

    <p class="text-gray-300">We provide a design overview for applying Pointproofs to reduce storage requirements for blockchains (Section 5). We specifically focus on smart contracts. Consider a smart contract with multiple variables. The current values <span class="math">(m_{1},\\ldots,m_{N})</span> of all the variables in a given contract are committed to a single vector commitment <span class="math">C</span>, one commitment per contract. To transact with the contract, one provides a <span class="math">48</span>-byte proof <span class="math">\\hat{\\pi}</span> of the current values of the variables needed for the transaction, which are then (optionally) updated as a result of the transaction. When there are multiple smart contracts, cross-commitment aggregation allows us to compress multiple proofs <span class="math">\\hat{\\pi}_{1},\\ldots,\\hat{\\pi}_{\\ell}</span> into a single <span class="math">48</span>-byte proof <span class="math">\\pi</span>. This essentially eliminates the bandwidth overhead due to proofs in a proposed block, which, depending on the setting, can take up more bandwidth than the values being proven.</p>

    <p class="text-gray-300">When applied to smart contracts storage, Pointproofs can be used to reduce validators’ storage requirements to <span class="math">4.5</span> GB for <span class="math">10^{8}</span> accounts while adding only <span class="math">31</span> KB per block overhead for <span class="math">1000</span> transactions (assuming one open value per transaction). Alternative approaches to smart contracts require either (a) extensive storage from validators (TBs), (b) a central entity to generate proofs for all users, or (c) introduce at least an additional <span class="math">60\\%</span> bandwidth overhead per block. (See Section 5.2 for a more detailed comparison.)</p>

    <p class="text-gray-300">We implement Pointproofs and show that Pointproofs are efficient to produce, aggregate, verify, and update for real-time use. We release our code to open source under the MIT license on GitHub <em>[x1]</em>. In our benchmarks for a commitment for 1000 variables of a smart contract at 128-bit security level, a user can produce a subvector proof for an arbitrary subset of variables (touched by a particular transaction) in 54-123ms; a block proposer can cross-commitment aggregate all these proofs, at the cost of about .07ms per proof; a validator who stores commitments can verify the aggregated proofs in a block at the cost of 0.7–1.9ms per value verified, and update commitments to reflect new values of the variables (which change in response to the transaction execution) at the cost of .0.2–0.3ms per variable updated (numerical ranges are due to variations in the number of commitments and values proven per commitment).</p>

    <p class="text-gray-300">Summary of Contributions. To summarize, our contributions are as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We formalize aggregatable vector commitments in the cross-commitment setting. We also formalize the hiding property while also supporting aggregation.</li>

      <li>We construct Pointproofs based on bilinear groups and prove their security (in the algebraic group and random oracle models).</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We show how to apply Pointproofs to smart-contract-based transactions on blockchains and evaluate them compared to alternative solutions.</li>

      <li>We build Pointproofs and evaluate their performance for various parameters.</li>

    </ul>

    <p class="text-gray-300">We envisage that there will be multiple possible applications for cross-commitment aggregation of proofs. Just like signature aggregation can be beneficial to compress multiple signatures produced by different users into a short signature—with applications ranging from sensor networks <em>[x1]</em> to internet routing <em>[x3]</em> to consensus <em>[x10]</em>—proof aggregation can help whenever multiple committed values produced by different users are revealed. One can imagine many settings in which multiple users or entities independently commit to their databases of records (e.g., public keys, healthcare records, transactions, etc.) and concurrently produce proofs to reveal several committed values. Cross-commitment aggregation can be applied to save on bandwidth in such settings.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.2 Related Work</h3>

    <p class="text-gray-300">The idea of using commitments to trade storage for bandwidth in the context of blockchains has appeared in multiple works in varying levels of detail, including <em>[x37, x26, x38, x27, x13, x12, x14, x15]</em>. The improvement of putting multiple proofs together to save bandwidth in this context has also appeared in a number of works, including <em>[x30, x11, x4, CFG^{+}20]</em>. Third-party aggregation in blockchains has been explored more for signatures than for commitments <em>[x10]</em>. Aggregating commitment proofs is a natural counterpart to aggregating signatures.</p>

    <p class="text-gray-300">There is a long line of work on authenticated data structures in general (going back at least to <em>[x28]</em>) and vector commitments specifically (first formalized in <em>[x29, x16]</em>). Constant-size proofs for a subvector of values were also achieved in <em>[x19, x32]</em>; unfortunately, the binding notion defined in <em>[x19, Section 3.4]</em> is not strong enough to preclude openings to two inconsistent subvectors (this work was later extended by <em>[TAB^{+}20]</em> to achieve the necessary binding notion).</p>

    <p class="text-gray-300">In Table 1, we compare our scheme to other subvector commitment commitments. Because of our focus on constant-size proofs for multiple values, we omit vector commitment schemes that do not have this feature <em>[x29, x16, x22, x1]</em>.</p>

    <p class="text-gray-300">The starting point for our commitments is the scheme of Libert and Yung <em>[x29]</em>. We simply augment it with aggregation algorithms for proofs within the same commitment and across multiple commitments. Our scheme, like the scheme of <em>[x29]</em>, requires public parameters whose size is linear in the size of the committed vector. Our public parameters are easy to keep short because of cross-commitment aggregation: we can split up a long vector into shorter ones and simply aggregate the proofs (although this approach increases the total size of the commitments, which cannot be aggregated).</p>

    <p class="text-gray-300">Like the scheme of <em>[x29]</em>, our scheme relies on a <span class="math">q</span>-type assumption. In order to prove security of aggregation, we have to work in the algebraic group model and the random oracle model (see Section 2). We can reduce these assumptions by lowering efficiency and/or security requirements (see Appendices A and B).</p>

    <p class="text-gray-300">Following the work of Libert and Yung, there has been a long line of work on pairing-based vector commitments, including <em>[x16, x22, x17]</em>, and a parallel line of work on polynomial commitments (starting with <em>[x19]</em>; see <em>[BM^{+}19]</em> for an overview). None of these address aggregation. In Appendix C</p>

    <p class="text-gray-300">we show that recent (independent of ours) construction of polynomial commitments with batch opening by Boneh et al. [BDFG20] also gives vector commitments with aggregation, but with lower efficiency than our construction.</p>

    <p class="text-gray-300">In a recent (and independent of ours) work, Campanelli et al. [CFG+20] introduced incremental aggregation for proofs, which allows unbounded aggregation of already aggregated proofs (effectively making aggregation an associative operation). They achieve it for same-commitment aggregation by modifying hidden-order group constructions of [LM19, BBF19]. Our aggregation is not associative. In another recent (and independent of ours) work, Tomescu et al. [TAB+20] proposed pairing-based commitments with same-commitment aggregation based on the work of [KZG10]; in their scheme, public parameters needed to verify and update proofs are short.</p>

    <h2 id="sec-4" class="text-2xl font-bold">1.3 Technical Overview of Our Scheme</h2>

    <p class="text-gray-300">Our starting point is a pairing-based vector commitment of Libert and Yung [LY10]; the novelty of our work lies in the aggregation algorithms.</p>

    <p class="text-gray-300">Let <span class="math">(\\mathbb{G}_1,\\mathbb{G}_2,\\mathbb{G}_T)</span> be a bilinear group of prime order <span class="math">p</span>, along with a pairing <span class="math">e:\\mathbb{G}_1\\times \\mathbb{G}_2\\to \\mathbb{G}_T</span> and generators <span class="math">g_{1},g_{2},g_{T} = e(g_{1},g_{2})</span> for <span class="math">\\mathbb{G}_1,\\mathbb{G}_2,\\mathbb{G}_T</span> respectively. Let <span class="math">\\alpha \\in \\mathbb{Z}_p</span> be a secret value (known to no one after the initial generation of public parameters). The public parameters are given by <span class="math">2N - 1</span> values in <span class="math">\\mathbb{G}_1</span>, <span class="math">N</span> values in <span class="math">\\mathbb{G}_2</span>, and one value in <span class="math">\\mathbb{G}_T</span> (which can be easily computed from the others):</p>

    <div class="my-4 text-center"><span class="math-block">g _ {1} ^ {\\alpha}, \\dots , g _ {1} ^ {\\alpha^ {N}}, g _ {1} ^ {\\alpha^ {N + 2}}, \\dots , g _ {1} ^ {\\alpha^ {2 N}}; g _ {2} ^ {\\alpha}, \\dots , g _ {2} ^ {\\alpha^ {N}}; g _ {T} ^ {\\alpha^ {N + 1}}.</span></div>

    <p class="text-gray-300">It is important that <span class="math">g_1^{\\alpha^{N + 1}}</span> is missing in the public parameters.</p>

    <p class="text-gray-300">A commitment to a vector <span class="math">\\mathbf{m} = (m_1, \\ldots, m_N) \\in \\mathbb{Z}_p^N</span> is given by raising <span class="math">g_1</span> to a polynomial with coefficients given by <span class="math">\\mathbf{m}</span> (no constant term), evaluated at <span class="math">\\alpha</span>:</p>

    <div class="my-4 text-center"><span class="math-block">C := g _ {1} ^ {\\sum_ {i = 1} ^ {N} m _ {i} \\alpha^ {i}}</span></div>

    <p class="text-gray-300">To reveal <span class="math">m_{i}</span>, the committer computes a proof, which has a similar polynomial, but without <span class="math">m_{i}</span>, and with a shift so that <span class="math">m_{i}</span>, if it were present, would be the coefficient of <span class="math">\\alpha^{N + 1}</span> instead of <span class="math">\\alpha^i</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\pi_ {i} := g _ {1} ^ {\\sum_ {j \\neq i} m _ {j} \\alpha^ {N + 1 - i + j}} = \\left(C / g _ {1} ^ {m _ {i} \\alpha^ {i}}\\right) ^ {\\alpha^ {N + 1 - i}}</span></div>

    <p class="text-gray-300">The proof can be verified using</p>

    <div class="my-4 text-center"><span class="math-block">e (C, g _ {2} ^ {\\alpha^ {N + 1 - i}}) \\stackrel {?} {=} e (\\pi_ {i}, g _ {2}) \\cdot g _ {T} ^ {\\alpha^ {N + 1} m _ {i}}</span></div>

    <p class="text-gray-300">Indeed, Libert and Yung [LY10] show that under a <span class="math">q</span>-type assumption, the scheme is binding: namely, it is hard to find a commitment <span class="math">C</span> along with proofs <span class="math">(m_i^0,\\pi^0),(m_i^1,\\pi^1)</span> with <span class="math">m_i^0\\neq m_i^1</span> satisfying the above verification equation. The intuition for binding is quite simple. Note that the adversary does not get <span class="math">g_1^{\\alpha^{N + 1}}</span>, and therefore the coefficient of <span class="math">\\alpha^{N + 1}</span> in the exponent of <span class="math">\\pi</span>, even if adversarially produced, should be 0. Comparing coefficients of <span class="math">g_T^{\\alpha^{N + 1}}</span> on both sides of the verification equation, we have that <span class="math">m_{i}</span> on the right-hand-side of the verification equation must match <span class="math">m_{i}</span> in <span class="math">C</span>.</p>

    <p class="text-gray-300">5</p>

    <p class="text-gray-300">Aggregation: first idea. Now, suppose the committer would like to reveal multiple values <span class="math">\\{m_{i}:i\\in S\\}</span> (where <span class="math">S\\subseteq[N]</span>) for a single commitment <span class="math">C</span> via a very short proof <span class="math">\\pi_{S}</span>. A natural idea is to take</p>

    <p class="text-gray-300"><span class="math">\\pi_{S}=\\prod_{i\\in S}\\pi_{i}</span></p>

    <p class="text-gray-300">which can in turn be verified using</p>

    <p class="text-gray-300"><span class="math">e\\left(C,\\prod_{i\\in S}g_{2}^{\\alpha^{N+1-i}}\\right)\\stackrel{{\\scriptstyle?}}{{=}}e(\\pi_{S},g_{2})\\cdot g_{T}^{\\alpha^{N+1}\\sum_{i\\in S}m_{i}}</span></p>

    <p class="text-gray-300">It is easy to see that this scheme is insecure, in that an adversary can commit to <span class="math">(m_{1},m_{2})=(1,3)</span> and then provide a valid proof revealing <span class="math">(m_{1},m_{2})=(2,2)</span> for <span class="math">S=\\{1,2\\}</span>. Indeed, if we compare the coefficients of <span class="math">g_{T}^{\\alpha^{N+1}}</span> on both sides of the verification equation, it is easy to see that the adversary is only bound to <span class="math">\\sum_{i\\in S}m_{i}</span> and not all of the values <span class="math">\\{m_{i}:i\\in S\\}</span>. More generally, we need to prevent attacks against inconsistent reveals for possibly two different sets, so that an adversary cannot, for example, "prove" that <span class="math">(m_{1},m_{2})</span> is <span class="math">(1,3)</span> and <span class="math">(m_{2},m_{3})</span> is <span class="math">(2,1)</span>.</p>

    <p class="text-gray-300">Handling same-commitment aggregation. To get around these attacks, we introduce additional "random" scalars <span class="math">t_{i}</span> into the verification equation:</p>

    <p class="text-gray-300"><span class="math">e\\left(C,\\prod_{i\\in S}g_{2}^{\\alpha^{N+1-i}t_{i}}\\right)\\stackrel{{\\scriptstyle?}}{{=}}e(\\pi_{S},g_{2})\\cdot g_{T}^{\\alpha^{N+1}\\sum_{i\\in S}m_{i}t_{i}}</span></p>

    <p class="text-gray-300">and compute the aggregate proof <span class="math">\\pi_{S}</span> by <span class="math">\\pi_{S}=\\prod_{i\\in S}\\pi_{i}^{t_{i}}</span>. The scalars <span class="math">t_{i}</span> are computed by applying a hash function <span class="math">H</span> on some carefully chosen inputs depending on <span class="math">C,S,\\{m_{i}:i\\in S\\}</span>. We note that a similar idea appears in the context of aggregating signatures <em>[x1]</em>.</p>

    <p class="text-gray-300">To get an intuition for how introducing random scalars yields binding, let us once again look at the coefficient of <span class="math">g_{T}^{\\alpha^{N+1}}</span> on both sides of the verification equation. Now, the adversary is bound to <span class="math">\\sum_{i\\in S}m_{i}t_{i}</span>. A standard argument tells us that for any <span class="math">\\{m_{i}:i\\in S\\}\\neq\\{m_{i}^{\\prime}:i\\in S\\}</span>, we have</p>

    <p class="text-gray-300"><span class="math">\\Pr\\Big{[}\\sum_{i\\in S}m_{i}t_{i}=\\sum_{i\\in S}m_{i}^{\\prime}t_{i}^{\\prime}\\Big{]}=1/p</span></p>

    <p class="text-gray-300">where the probability is over random <span class="math">t_{i}\\leftarrow\\mathbb{Z}_{p}</span>. Therefore, if the <span class="math">t_{i}</span>’s are indeed random, then the adversary is also bound to <span class="math">\\{m_{i}:i\\in S\\}</span>.</p>

    <p class="text-gray-300">To formalize this intuition, we first need to model the hash function <span class="math">H</span> as a random oracle <em>[x2]</em> so that we can carry out the above probabilistic argument. Furthermore, we need to restrict the adversary to the so-called algebraic group model <em>[x11]</em> (see Section 2 for details), so that we can express adversarially generated commitments <span class="math">C</span> in terms of public parameters.</p>

    <p class="text-gray-300">Handling cross-commitment aggregation. Now, suppose we have a collection of commitments <span class="math">C_{j}</span> to <span class="math">\\mathbf{m}_{j}=(m_{j,1},\\ldots,m_{j,N})</span>, along with proofs <span class="math">\\hat{\\pi}_{j}</span> for <span class="math">\\mathbf{m}_{j}[S_{j}]</span>, each satisfying</p>

    <p class="text-gray-300"><span class="math">e\\left(C_{j},g_{2}^{\\sum_{i\\in S_{j}}\\alpha^{N+1-i}t_{j,i}}\\right)=e(\\hat{\\pi}_{j},g_{2})\\cdot g_{T}^{\\alpha^{N+1}\\sum_{i\\in S_{j}}m_{j,i}t_{j,i}}</span></p>

    <p class="text-gray-300">We can again multiply these equations together to obtain:</p>

    <p class="text-gray-300"><span class="math">\\prod_{j}e\\left(C_{j},g_{2}^{\\sum_{i\\in S_{j}}\\alpha^{N+1-i}t_{j,i}}\\right)=e\\left(\\prod_{j}\\hat{\\pi}_{j},g_{2}\\right)\\cdot g_{T}^{\\alpha^{N+1}\\sum_{j}\\sum_{i\\in S_{j}}m_{j,i}t_{j,i}}</span></p>

    <p class="text-gray-300">For the same reason as before, this approach alone does not yield a secure scheme. Instead, we will need to introduce additional random scalars <span class="math">t_{j}^{\\prime}</span> and use the following aggregate verification equation:</p>

    <p class="text-gray-300"><span class="math">\\prod_{j}e\\left(C_{j},g_{2}^{\\sum_{i\\in S_{j}}\\alpha^{N+1-i}t_{j,i}}\\right)^{t_{j}^{\\prime}}\\stackrel{{\\scriptstyle?}}{{=}}e(\\pi,g_{2})\\cdot g_{T}^{\\alpha^{N+1}\\sum_{j}\\sum_{i\\in S_{j}}m_{j,i}t_{j,i}t_{j}^{\\prime}}</span></p>

    <p class="text-gray-300">where the aggregated proof <span class="math">\\pi:=\\prod_{j}\\hat{\\pi}_{j}^{t_{j}^{\\prime}}</span>.</p>

    <h2 id="sec-5" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">Notation Given a (column) vector <span class="math">\\mathbf{v}=(v_{1},\\ldots,v_{N})</span>, we use <span class="math">\\mathbf{v}[S]:=(v_{i},i\\in S)</span> to denote the subvector indexed by <span class="math">S</span>, and <span class="math">\\mathbf{v}[-i]</span> to denote <span class="math">\\mathbf{v}[[N]\\setminus\\{i\\}]</span>, i.e., <span class="math">\\mathbf{v}</span> with <span class="math">v_{i}</span> deleted. For a positive integer <span class="math">N</span>, we denote the set <span class="math">\\{1,\\ldots,N\\}</span> by <span class="math">[N]</span>.</p>

    <p class="text-gray-300">The Algebraic Group Model (AGM) The algebraic group model <em>[x10]</em> lies between the standard model and the widely-used generic group model. In AGM, we consider only so-called <em>algebraic adversaries</em>. Such adversaries have direct access to group elements and, in particular, can use their bit representation, like in the standard model. However, these adversaries are assumed to output new group elements only by applying the group operation to received group elements (like in the generic group model). This requirement is formalized as follows. Suppose an adversary is given group elements <span class="math">X_{1},\\ldots,X_{N}\\in\\mathbb{G}_{1}</span>. Then, for every group element <span class="math">Z\\in\\mathbb{G}_{1}</span> that the adversary outputs, it must also output <span class="math">z_{1},\\ldots,z_{N}\\in\\mathbb{Z}_{p}</span> such that <span class="math">Z=\\prod_{i=1}^{N}X_{i}^{z_{i}}</span>.</p>

    <p class="text-gray-300">Security Assumption Let <span class="math">\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T}</span> be multiplicative groups of prime order <span class="math">p</span> with a nondegenerate bilinear pairing <span class="math">e:\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\to\\mathbb{G}_{T}</span>. Fix generators <span class="math">g_{1}</span>, <span class="math">g_{2}</span>, and <span class="math">g_{T}:=e(g_{1},g_{2})</span> for the three groups.</p>

    <p class="text-gray-300">We assume that the following variant of <em>weak bilinear Diffie-Hellman exponent problem <span class="math">\\ell</span>-</em>wBDHE (see <em>[x5, x6, x13]</em> for similar problems for symmetric pairings) is hard:</p>

    <p class="text-gray-300">Input: <span class="math">g_{1}^{\\alpha}\\ ,\\ g_{1}^{(\\alpha^{2})}\\ ,\\ \\ldots\\ ,\\ g_{1}^{(\\alpha^{\\ell})}\\ ,</span> <span class="math">g_{1}^{(\\alpha^{\\ell+2})}\\ ,\\ \\ldots\\ ,\\ g_{1}^{(\\alpha^{3\\ell})}\\ ,</span> <span class="math">g_{2}^{\\alpha}\\ ,\\ g_{2}^{(\\alpha^{2})}\\ ,\\ \\ldots\\ ,\\ g_{2}^{(\\alpha^{\\ell})}\\ ,</span> for <span class="math">\\alpha\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathbb{Z}_{p}<span class="math"> Compute: </span>g_{1}^{(\\alpha^{\\ell+1})}$</p>

    <p class="text-gray-300">The advantage <span class="math">\\mathbf{Adv}_{\\mathbb{G}_{1}\\times\\mathbb{G}_{2}}^{\\ell\\text{-}\\mathbf{wBDHE}^{\\prime}}(\\mathcal{A})</span> of an adversary <span class="math">\\mathcal{A}</span> is defined as its probability in solving this problem. As shown in <em>[x5]</em> (for a slight variant), the assumption holds in the generic bilinear group model. Concretely, for the BLS12-381 pairing-friendly curve with <span class="math">\\ell=32</span>, the best attack has complexity <span class="math">2^{112}</span> <em>[x11]</em> (more generally, roughly <span class="math">\\sqrt{p/\\ell}</span>).</p>

    <p class="text-gray-300">The Random Oracle Model (ROM) Our security proofs are in the random oracle model, formalized in <em>[x11]</em>: we model a cryptographic hash function as a truly random function, accessible to all parties only via oracle queries. We will use two random oracles <span class="math">H</span> and <span class="math">H^{\\prime}</span>, both with output space <span class="math">\\mathbb{Z}_{p}</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">3 Defining Vector Commitments with Aggregation</p>

    <p class="text-gray-300">We define aggregatable vector commitments in two steps: first, we consider aggregation of proofs for a single commitment; then, we discuss aggregating such same-commitment aggregated proofs into a single cross-commitment proof.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">3.1 Same-Commitment Aggregation</h3>

    <p class="text-gray-300">A <em>vector commitment with same-commitment aggregation</em> for message space <span class="math">\\mathcal{M}</span> consists of the following polynomial-time algorithms Setup, Commit, UpdateCommit, Aggregate, Verify:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{pp}\\leftarrow\\mathsf{Setup}(1^{\\lambda},1^{N})</span>. Outputs public parameters that will be used by all parties to commit to message vectors of length <span class="math">N</span> (inputs are given in unary to allow for running time polynomial in <span class="math">\\lambda</span> and <span class="math">N</span>). The public parameters will be provided as an implicit input to the remaining algorithms, including the adversary in the security definition. Even though the parameters are public, their generation may involve secret randomness that should not be known to the adversary. How to generate parameters in a trustworthy manner (which is crucial for security) depends on the application.</li>

      <li><span class="math">C\\leftarrow\\mathsf{Commit}(\\mathbf{m};r)</span>. Takes as input a vector <span class="math">\\mathbf{m}\\in\\mathcal{M}^{N}</span> along with randomness <span class="math">r</span> and outputs a commitment <span class="math">C</span>.</li>

      <li><span class="math">C^{\\prime}\\leftarrow\\mathsf{UpdateCommit}(C,S,\\mathbf{m}[S],\\mathbf{m}^{\\prime}[S])</span>. Takes as input a commitment <span class="math">C</span> and updates the positions in <span class="math">S</span> from <span class="math">\\mathbf{m}[S]</span> to <span class="math">\\mathbf{m}^{\\prime}[S]</span> to produce a new commitment <span class="math">C^{\\prime}</span>.</li>

      <li><span class="math">\\pi_{i}\\leftarrow\\mathsf{Prove}(i,\\mathbf{m},r)</span>. Takes as input an index <span class="math">i\\in[N]</span> and <span class="math">(\\mathbf{m},r)</span> used in Commit and outputs a proof <span class="math">\\pi_{i}</span>.</li>

      <li><span class="math">\\hat{\\pi}\\leftarrow\\mathsf{Aggregate}(C,S,\\mathbf{m}[S],\\{\\pi_{i}:i\\in S\\})</span>. Takes as input a commitment <span class="math">C</span>, a set of indices <span class="math">S\\subseteq[N]</span> with the corresponding proofs <span class="math">\\{\\pi_{i}:i\\in S\\}</span> (computed using Prove) and outputs an aggregated proof <span class="math">\\hat{\\pi}</span>.</li>

      <li><span class="math">b\\leftarrow\\mathsf{Verify}(C,S,\\mathbf{m}[S],\\hat{\\pi})</span>. Takes as input a commitment <span class="math">C</span>, a set of indices <span class="math">S\\subseteq[N]</span> along with an aggregated proof <span class="math">\\hat{\\pi}</span>, and outputs whether <span class="math">C</span> is a commitment to a message vector consistent with <span class="math">\\mathbf{m}[S]</span>.</li>

    </ul>

    <p class="text-gray-300">For simplicity of presentation and without loss of generality, we assume that Verify always operates on aggregated proofs, even for a set of size <span class="math">1</span>. It should be noted that there may be more efficient ways to compute an aggregated proof than via several invocations of Prove followed by a single Aggregate; these efficiency improvements, while helpful for performance, do not affect our definitions. Similarly, there may be more efficient ways than invoking Prove to update existing proofs when commitments are updated; we do not formally define proof updates as a separate algorithm here.</p>

    <p class="text-gray-300">Correctness of opening. For all <span class="math">\\lambda,N,\\mathbf{m}\\in\\mathcal{M}^{N},S\\subseteq[N]</span>, we have</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{l}\\mathsf{pp}\\leftarrow\\mathsf{Setup}(1^{\\lambda},1^{N})\\\\ C\\leftarrow\\mathsf{Commit}(\\mathbf{m};r)\\\\ \\pi_{i}\\leftarrow\\mathsf{Prove}(i,\\mathbf{m},r),\\forall i\\in S\\\\ \\pi\\leftarrow\\mathsf{Aggregate}(C,S,\\mathbf{m}[S],\\{\\pi_{i}:i\\in S\\})\\\\ \\mathsf{Verify}(C,S,\\mathbf{m}[S],\\hat{\\pi})=1\\end{array}\\right]=1 \\]</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300"><span class="math">\\mathbf{UpdateCommit}(\\mathbf{Commit}(\\mathbf{m};r),S,\\mathbf{m}[S],\\mathbf{m}^{\\prime}[S])=\\mathbf{Commit}(\\mathbf{m}^{\\prime};r)</span></p>

    <p class="text-gray-300">Note that in our definition, updates are deterministic. Other definitions are also possible. See Section 3.3 for further discussion.</p>

    <p class="text-gray-300">Binding. For every <span class="math">N</span> and every adversary running in time polynomial in <span class="math">\\lambda</span>, the probability of finding</p>

    <p class="text-gray-300"><span class="math">C,(\\hat{\\pi}^{0},S^{0},\\mathbf{m}^{0}[S^{0}]),(\\hat{\\pi}^{1},S^{1},\\mathbf{m}^{1}[S^{1}])</span></p>

    <p class="text-gray-300">such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Verify}(C,S^{b},\\mathbf{m}^{b}[S^{b}],\\hat{\\pi}^{b})=1</span> for both <span class="math">b=0</span> and <span class="math">b=1</span>;</li>

      <li><span class="math">\\mathbf{m}^{0}[S^{0}\\cap S^{1}]\\neq\\mathbf{m}^{1}[S^{0}\\cap S^{1}]</span></li>

    </ul>

    <p class="text-gray-300">(assuming parameters generated by <span class="math">\\mathsf{Setup}(1^{\\lambda},1^{N})</span>) is negligible in <span class="math">\\lambda</span>.</p>

    <p class="text-gray-300">One can also consider a weaker notion of binding, in which the commitment <span class="math">C</span> must be honestly computed by <span class="math">\\mathsf{Commit}</span> (on some, possibly adversarially chosen, messages) rather than chosen arbitrarily by the adversary. This notion often suffices in blockchain applications. See Appendix B for details.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">3.2 Cross-commitment aggregation</h3>

    <p class="text-gray-300">Cross-commitment aggregation adds two algorithms to aggregate proofs across <span class="math">\\ell</span> commitments :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\pi\\leftarrow\\mathsf{AggregateAcross}(\\{\\,C_{j},S_{j},\\mathbf{m}_{j}[S_{j}],\\hat{\\pi}_{j}\\,\\}_{j\\in[\\ell]})</span> Takes as input a collection <span class="math">(\\{\\,C_{j},S_{j},\\mathbf{m}_{j}[S_{j}]\\,\\}_{j\\in[\\ell]})</span> along with the corresponding same-commitment-aggregated proofs <span class="math">\\{\\,\\hat{\\pi}_{j}\\,\\}_{j\\in[\\ell]}</span> (computed using <span class="math">\\mathsf{Aggregate}</span>) and outputs an aggregated proof <span class="math">\\pi</span>.</li>

      <li><span class="math">b\\leftarrow\\mathsf{VerifyAcross}(\\{\\,C_{j},S_{j},\\mathbf{m}_{j}[S_{j}]\\,\\}_{j\\in[\\ell]},\\pi)</span>. Takes as input a collection <span class="math">(\\{\\,C_{j},S_{j},\\mathbf{m}_{j}[S_{j}]\\,\\}_{j\\in[\\ell]})</span> along with a cross-commitment-aggregated proof <span class="math">\\pi</span>, and checks that <span class="math">C_{j}</span> is a commitment to a message vector consistent with <span class="math">\\mathbf{m}_{j}[S_{j}]</span> for all <span class="math">j\\in[\\ell]</span>.</li>

    </ul>

    <p class="text-gray-300">We require the same correctness of opening as before, extended to cross-commitment aggregation in a natural way.</p>

    <p class="text-gray-300">The binding property also extends naturally: to win, the adversary now needs to find</p>

    <p class="text-gray-300"><span class="math">\\{\\,C^{b}_{j}\\,\\}_{j\\in[\\ell^{b}]}\\text{ and }(\\pi^{b},\\{\\,S^{b}_{j},\\mathbf{m}^{b}[S^{b}_{j}]\\,\\}_{j\\in[\\ell^{b}]})\\text{ for }b=0\\text{ and }b=1</span></p>

    <p class="text-gray-300">such that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{VerifyAcross}(\\{\\,C^{b}_{j},S^{b}_{j},\\mathbf{m}^{b}_{j}[S^{b}_{j}]\\,\\}_{j\\in[\\ell^{b}]},\\pi^{b})=1</span> for both <span class="math">b=0</span> and <span class="math">b=1</span></li>

      <li><span class="math">\\exists j^{0}\\in[\\ell^{0}],j^{1}\\in[\\ell^{1}]:\\,\\mathbf{m}^{0}_{j^{0}}[S^{0}_{j^{0}}\\cap S^{1}_{j^{1}}]\\neq\\mathbf{m}^{1}_{j^{1}}[S^{0}_{j^{0}}\\cap S^{1}_{j^{1}}]</span> and <span class="math">C^{0}_{j^{0}}=C^{1}_{j^{1}}</span>.</li>

    </ol>

    <p class="text-gray-300">As a sanity check, observe that for the special case <span class="math">\\ell^{0}=\\ell^{1}=1</span>, the winning condition stipulates that <span class="math">j^{0}=j^{1}=1</span> and <span class="math">C^{0}_{1}=C^{1}_{1}</span>, matching same-commitment binding, except with <span class="math">\\mathsf{VerifyAcross}</span> in place of <span class="math">\\mathsf{Verify}</span>.</p>

    <p class="text-gray-300">As part of binding, we also need to make sure that a cross-commitment aggregated proof cannot be used to prove an opening that is inconsistent with a same-commitment opening. Formally, this means this that for the case of <span class="math">\\ell^{0}=1</span>, we allow the adversary to win also if <span class="math">\\mathsf{Verify}(C^{0}_{1},S^{0}_{1},\\mathbf{m}^{0}_{1}[S^{0}_{1}],\\pi^{0})=1</span>, even if <span class="math">\\mathsf{VerifyAcross}(\\{C^{0}_{1},S^{0}_{1},\\mathbf{m}^{0}_{1}[S^{0}_{1}]\\},\\pi^{0})=0</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">3.3 Hiding</p>

    <p class="text-gray-300">Vector commitments optionally include the hiding property, which we now define. For this paper, we consider simulation-based statistical security, which stipulates that there exists an efficient randomized simulator <span class="math">(\\mathsf{Setup}^{<em>},\\mathsf{Commit}^{</em>},\\mathsf{Prove}^{<em>})</span> with the following properties. <span class="math">\\mathsf{Setup}^{</em>}</span> outputs <span class="math">\\mathsf{pp}</span> and a trapdoor <span class="math">\\mathsf{td}</span>. <span class="math">\\mathsf{Commit}^{<em>}(;r)</span> takes no inputs except randomness, and outputs a random fake commitment <span class="math">C</span>. <span class="math">\\mathsf{Prove}^{</em>}</span>, given the trapdoor, an <span class="math">r</span> used to produce a fake <span class="math">C</span>, an index <span class="math">i</span>, and a value <span class="math">m_{i}</span>, produces a fake proof <span class="math">\\pi</span>. The main idea of the definition is that fake proofs are statistically indistinguishable from real ones, even given the commitments, and even if the committed messages are chosen adversarially. This indistinguishability is defined below. The intuition is that since fake committing and fake proving doesn’t involve any messages but the one being proven, it follows that fake commitments and proofs leak no information about other messages, and therefore, by indistinguishability, neither do real ones. This intuition is formalized below via a standard oracle-based definition.</p>

    <p class="text-gray-300">Let a stateful real oracle <span class="math">\\mathcal{O}\\text{-real}(\\mathsf{pp})</span> take two types of queries: a query <span class="math">\\mathbf{m}_{j}</span> chooses a random <span class="math">r_{j}</span> and returns <span class="math">\\mathsf{Commit}(\\mathbf{m}_{j}r_{j})</span>, while a query <span class="math">(j,i)</span> returns <span class="math">\\mathsf{Prove}(i,m_{j},r_{j})</span>. Let a stateful simulated oracle <span class="math">\\mathcal{O}\\text{-sim}(\\mathsf{pp},\\mathsf{td})</span> respond to the same types of queries as follows: a query <span class="math">\\mathbf{m}_{j}</span> chooses a random <span class="math">r_{j}</span> and runs <span class="math">\\mathsf{Commit}^{<em>}(;r_{j})</span> to get a random fake commitment, while a query <span class="math">(j,i)</span> returns <span class="math">\\mathsf{Prove}^{</em>}(\\mathsf{td},r_{j},i,(\\mathbf{m}_{j})_{i})</span>. Crucially for the hiding property, <span class="math">\\mathsf{Commit}^{<em>}</span> gets no information about <span class="math">\\mathbf{m}_{j}</span>, while <span class="math">\\mathsf{Prove}^{</em>}</span> gets <span class="math">(\\mathbf{m}_{j})_{i}</span> but no information about <span class="math">\\mathbf{m}_{j}[-i]</span>.</p>

    <p class="text-gray-300">The hiding property states that for every stateful computationally unbounded adversary <span class="math">\\mathcal{A}</span>, the following two distributions are at most negligibly far:</p>

    <p class="text-gray-300">\\[ \\left[\\begin{array}[]{c}\\mathsf{pp}\\leftarrow\\mathsf{Setup}(1^{\\lambda},1^{N});\\\\ \\mathsf{output}\\;\\mathcal{A}^{\\mathcal{O}\\text{-real}(\\mathsf{pp})}\\end{array}\\right],\\left[\\begin{array}[]{c}(\\mathsf{pp},\\mathsf{td})\\leftarrow\\mathsf{Setup}^{*}(1^{\\lambda},1^{N});\\\\ \\mathsf{output}\\;\\mathcal{A}^{\\mathcal{O}\\text{-sim}(\\mathsf{pp},\\mathsf{td})}\\end{array}\\right] \\]</p>

    <p class="text-gray-300">Note that even though the hiding definition does not explicitly refer to aggregated proofs as computed using Aggregate, it does imply a meaningful security guarantee for aggregated proofs, because they are results of public computations on existing proofs. For example, an adversary who sees <span class="math">m_{2},m_{3}</span> along with an aggregated proof <span class="math">\\pi_{\\{2,3\\}}</span> learns nothing about <span class="math">m_{1},m_{4}</span>, because the inputs to the aggregation algorithm include only <span class="math">\\pi_{2},\\pi_{3},m_{2}</span>, and <span class="math">m_{3}</span>.</p>

    <p class="text-gray-300">Our updates are defined to be deterministic, and thus reveal the relationship between the pre- and post-update committed vectors. One can additionally define a rerandomization algorithm that, when performed after a deterministic update, will hide this relationship. Our scheme supports such rerandomization (see Section 4.5). We do not formally address this hiding property.</p>

    <h2 id="sec-8" class="text-2xl font-bold">4 Our Construction</h2>

    <p class="text-gray-300">Understanding intuition behind our scheme, described in Section 1.3, will help make sense of the formal details presented in this section. We use the notation (including pairing groups of order <span class="math">p</span> and random oracles <span class="math">H,H^{\\prime}</span>) from Section 2.</p>

    <p class="text-gray-300">Our message space <span class="math">\\mathcal{M}</span> is <span class="math">\\mathbb{Z}_{p}</span>; we can handle general message spaces <span class="math">\\{0,1\\}^{*}</span> by hashing to <span class="math">\\mathbb{Z}_{p}</span> using a collision-resistant hash function.</p>

    <p class="text-gray-300">11</p>

    <p class="text-gray-300">Here, both Commit and Prove are deterministic.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{Setup}(1^{\\lambda}, 1^{N})</span>. Samples <span class="math">\\alpha \\gets \\mathbb{Z}_p</span> and outputs</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} g_{1}^{\\mathbf{a}} = (g_{1}^{\\alpha}, \\dots, g_{1}^{\\alpha^{N}}), \\\\ g_{1}^{\\alpha^{N} \\mathbf{a}[-1]} = (g_{1}^{\\alpha^{N+2}}, \\dots, g_{1}^{\\alpha^{2N}}), \\\\ g_{2}^{\\mathbf{a}} = (g_{2}^{\\alpha}, \\dots, g_{2}^{\\alpha^{N}}) \\end{array}</span></div>

    <p class="text-gray-300">where</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{a} := (\\alpha, \\alpha^{2}, \\dots, \\alpha^{N})</span></div>

    <p class="text-gray-300">In fact, it is sufficient for the prover to hold <span class="math">g_1^{\\mathbf{a}}, g_1^{\\alpha^N \\mathbf{a}[-1]}</span> and for the verifier to hold <span class="math">g_2^{\\mathbf{a}}, g_T^{\\alpha^{N+1}} = e(g_1^\\alpha, g_2^{\\alpha^N})</span>.</p>

    <p class="text-gray-300">Note that <span class="math">\\alpha</span> must never be known to the adversary.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{Commit}(\\mathbf{m})</span>, for <span class="math">\\mathbf{m} \\in \\mathbb{Z}_p^N</span>. Outputs</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">C := g_{1}^{\\mathbf{m}^{\\top} \\mathbf{a}} = g_{1}^{\\sum_{i \\in [N]} m_{i} \\alpha^{i}}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{UpdateCommit}(C, S, \\mathbf{m}[S], \\mathbf{m}&#x27;[S])</span>. Outputs</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">C&#x27; := C \\cdot g_{1}^{(\\mathbf{m}&#x27;[S] - \\mathbf{m}[S])^{\\top} \\mathbf{a}[S]} = C \\cdot g_{1}^{\\sum_{i \\in S} (m_{i}&#x27; - m_{i}) \\alpha^{i}}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{Prove}(i, \\mathbf{m})</span>. Outputs</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\pi_{i} := g_{1}^{\\alpha^{N+1-i} \\mathbf{m}[-i]^{\\top} \\mathbf{a}[-i]} = g_{1}^{\\sum_{j \\in [N] - \\{i\\}} m_{j} \\alpha^{N+1-i+j}}</span></div>

    <p class="text-gray-300">Note that anyone can compute <span class="math">g_1^{\\alpha^{N+1-i} \\mathbf{a}[-i]}</span> for all <span class="math">i \\in [N]</span> given <span class="math">\\mathfrak{pp}</span>. If a value <span class="math">m_j</span> at index <span class="math">j \\neq i</span> changes <span class="math">m_j&#x27;</span>, a proof can be updated in a way similar to a commitment: <span class="math">\\pi&#x27; := \\pi \\cdot g_1^{(m_j&#x27; - m_j) \\alpha^{N+1-i+j}}</span>. If <span class="math">m_i</span> changes, then the proof <span class="math">\\pi</span> need not be updated (but the commitment <span class="math">C</span> does).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{Aggregate}(C, S, \\mathbf{m}[S], \\{\\pi_i : i \\in S\\})</span>. Outputs</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\hat{\\pi} := \\prod_{i \\in S} \\pi_{i}^{t_{i}}</span></div>

    <p class="text-gray-300">where</p>

    <div class="my-4 text-center"><span class="math-block">t_{i} = H(i, C, S, \\mathbf{m}[S])</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{Verify}(C, S, \\mathbf{m}[S], \\hat{\\pi})</span>. Checks that</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">e\\left(C, g_{2}^{\\sum_{i \\in S} \\alpha^{N+1-i} t_{i}}\\right) \\stackrel{?}{=} e(\\hat{\\pi}, g_{2}) \\cdot g_{T}^{\\alpha^{N+1} \\sum_{i \\in S} m_{i} t_{i}}</span></div>

    <p class="text-gray-300">where <span class="math">t_i</span> is the same as in Aggregate.</p>

    <p class="text-gray-300">Implementation and Efficiency. We now discuss a few implementation details. We summarize the performance of our scheme (including algorithms from Section 4.2) in Table 2.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup can be performed securely and efficiently via a large-scale distributed computation, similar to <em>[x1]</em>, but simpler because of the structure of the parameters <em>[x28]</em>. The first party chooses <span class="math">\\alpha_{1}</span> and generates its own public parameters according to Setup; each subsequent party <span class="math">i</span>, in sequence, chooses a secret <span class="math">\\alpha_{i}</span> and raises each element of the public parameters generated so far to the appropriate power of <span class="math">\\alpha_{i}</span>; at the end, we will use <span class="math">\\alpha_{s}</span> generated by a public random beacon for one final rerandomization, so that the final <span class="math">\\alpha=\\alpha_{s}\\cdot\\prod_{i}\\alpha_{i}</span>. Furthermore, each party will prove knowledge of <span class="math">\\alpha_{i}</span>, and each party will use the output of the previous party only if this proof of knowledge is consistent with first elements of the <span class="math">g_{1}^{\\mathfrak{n}}</span> and <span class="math">g_{2}^{\\mathfrak{n}}</span> vectors, and if the appropriate pairing relationships between the various group elements hold (to ensure the remaining elements of the parameters are computed correctly).</li>

      <li>Commit takes <span class="math">\\mathsf{nz}(\\mathbf{m})\\ \\mathbb{G}_{1}</span>-exponentiations and Prove takes one fewer, where <span class="math">\\mathsf{nz}(\\mathbf{m})</span> is the number of non-zero entries in the vector <span class="math">\\mathbf{m}</span>. We note that products of exponentiations are considerably more efficient than separate exponentiations—via, for example, Pippenger’s algorithm <em>[x32]</em>.</li>

      <li>When producing a proof <span class="math">\\hat{\\pi}</span> for <span class="math">\\mathbf{m}[S]</span> where <span class="math">S</span> is known in advance, it is faster to compute the proof directly using the formula</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\hat{\\pi}=\\prod_{k=2}^{N}g_{1}^{c_{k}\\alpha^{k}}\\cdot\\prod_{k=1}^{N-1}g_{1}^{c_{N+1+k}\\alpha^{N+1+k}}</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">c_{k}</span> <span class="math">=\\sum_{i\\in S,i\\geq N-k+2}m_{k+i-N-1}t_{i}</span> <span class="math">c_{N+1+k}</span> <span class="math">=\\sum_{i\\in S,i\\leq N-k}m_{k+i}t_{i}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">instead of running Prove multiple times followed by Aggregate. The cost of this computation is a product of $\\min(2N-2,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\mathsf{nz}(\\mathbf{m}))\\ \\mathbb{G}_{1}<span class="math">-exponentiations (to be more precise, the </span>2N-2<span class="math"> term can be replaced with </span>N+\\max(S)-\\min(S)-1<span class="math">, because </span>c_{2},\\ldots,c_{N+1-\\max(S)}<span class="math">, </span>c_{N+1}<span class="math">, and </span>c_{2N-\\min(S)+2},\\ldots,c_{2N}$ are 0).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For Verify, because operations in <span class="math">\\mathbb{G}_{1}</span> are typically faster than in <span class="math">\\mathbb{G}_{2}</span>, which are faster than in <span class="math">\\mathbb{G}_{T}</span>, it is more efficient to compute <span class="math">r=(\\sum_{i\\in S}m_{i}t_{i})^{-1}\\ \\mathrm{mod}\\ p</span> (the special case when the inverse does not exist needs to be handled separately) and check</li>

    </ul>

    <p class="text-gray-300"><span class="math">e\\left(C,g_{2}^{r\\sum_{i\\in S}\\alpha^{N+1-i}t_{i}}\\right)\\cdot e\\left(\\hat{\\pi}^{-r},g_{2}\\right)\\stackrel{{\\scriptstyle?}}{{=}}g_{T}^{\\alpha^{N+1}}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that a product of two pairings can be computed considerably faster than two separate pairings (because the time-consuming final exponentiation needs to be performed only once). Note also that if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1<span class="math"> and we set </span>t_{i}=1<span class="math"> for the sole </span>i\\in S<span class="math">, as discussed above, then it is more efficient to move exponentiation to </span>\\mathbb{G}_{1}<span class="math"> and compute the first term as </span>(C^{r},g_{2}^{\\alpha^{N+1-i}})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- For  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1<span class="math"> , we could set  </span>t_i = 1<span class="math">  for the single  </span>i \\in S<span class="math">  (this letting  </span>\\hat{\\pi} = \\pi_i<span class="math">  and eliminating the need for Aggregate) to save work. All the proofs go through unchanged, because all  </span>t_i<span class="math">  values (except 0, which occurs with probability  </span>1/p<span class="math"> ) are functionally equivalent to  </span>t_i = 1<span class="math"> , via raising the verification equation to  </span>1/t_i<span class="math"> . It may be worthwhile to create a special case for  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1$  in an implementation to save on Aggregate, depending on how frequent this case is.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Operation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Time</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Commit</td>

            <td class="px-3 py-2 border-b border-gray-700">nz(m)-exp1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Prove</td>

            <td class="px-3 py-2 border-b border-gray-700">nz(m)-exp1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Aggregate</td>

            <td class="px-3 py-2 border-b border-gray-700">S</td>

            <td class="px-3 py-2 border-b border-gray-700">-exp1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Same-Aggr. Prove</td>

            <td class="px-3 py-2 border-b border-gray-700">min(2N-2,</td>

            <td class="px-3 py-2 border-b border-gray-700">S</td>

            <td class="px-3 py-2 border-b border-gray-700">·nz(m))-exp1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verify</td>

            <td class="px-3 py-2 border-b border-gray-700">1-exp1+</td>

            <td class="px-3 py-2 border-b border-gray-700">S</td>

            <td class="px-3 py-2 border-b border-gray-700">-exp2+2-pp</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AggregateAcross</td>

            <td class="px-3 py-2 border-b border-gray-700">l-exp1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">VerifyAcross</td>

            <td class="px-3 py-2 border-b border-gray-700">1-exp1+∑j(</td>

            <td class="px-3 py-2 border-b border-gray-700">Sj</td>

            <td class="px-3 py-2 border-b border-gray-700">-exp2)+(l+1)-pp</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: Concrete efficiency of our scheme, ignoring costs of hashing and  <span class="math">\\mathbb{Z}_p</span>  operations. Here,  <span class="math">\\mathrm{nz}(\\mathbf{m})</span>  denotes the number of non-zero entries in the vector  <span class="math">\\mathbf{m}</span> ,  <span class="math">k</span> -exp <span class="math">_i</span>  denotes a product of  <span class="math">k</span>  exponentiations in  <span class="math">\\mathbb{G}_i</span> , and  <span class="math">k</span> -pp denotes a product of  <span class="math">k</span>  parings.</p>

    <p class="text-gray-300">Proof of correctness. First, we show that for all  <span class="math">i \\in [N]</span> ,  <span class="math">\\pi_i = \\operatorname{Prove}(i, \\mathbf{m}) = g_1^{\\alpha^{N+1-i} \\mathbf{m}[-i]^\\top \\mathbf{a}[-i]}</span>  satisfies:</p>

    <div class="my-4 text-center"><span class="math-block">e \\left(C, g _ {2} ^ {\\alpha^ {N + 1 - i}}\\right) = e \\left(\\pi_ {i}, g _ {2}\\right) \\cdot g _ {T} ^ {\\alpha^ {N + 1} m _ {i}} \\tag {1}</span></div>

    <p class="text-gray-300">Observe that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {m} ^ {\\top} \\mathbf {a} = \\mathbf {m} [ - i ] ^ {\\top} \\mathbf {a} [ - i ] + \\alpha^ {i} m _ {i}</span></div>

    <p class="text-gray-300">Multiplying both sides by  <span class="math">\\alpha^{N + 1 - i}</span>  yields</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathbf {m} ^ {\\top} \\mathbf {a}) \\alpha^ {N + 1 - i} = \\alpha^ {N + 1 - i} \\mathbf {m} [ - i ] ^ {\\top} \\mathbf {a} [ - i ] + \\alpha^ {N + 1} m _ {i}</span></div>

    <p class="text-gray-300">and thus</p>

    <div class="my-4 text-center"><span class="math-block">e (g _ {1} ^ {\\mathbf {m} ^ {\\top} \\mathbf {a}}, g _ {2} ^ {\\alpha^ {N + 1 - i}}) = e (g _ {1} ^ {\\alpha^ {N + 1 - i} \\mathbf {m} [ - i ] ^ {\\top} \\mathbf {a} [ - i ]}, g _ {2}) \\cdot g _ {T} ^ {\\alpha^ {N + 1} m _ {i}}</span></div>

    <p class="text-gray-300">and (1) holds. To show correctness of aggregated proofs, we first raise both sides of (1) to the power  <span class="math">t_i</span> , to get</p>

    <div class="my-4 text-center"><span class="math-block">e (C, g _ {2} ^ {\\alpha^ {N + 1 - i} t _ {i}}) = e (\\pi_ {i} ^ {t _ {i}}, g _ {2}) \\cdot g _ {T} ^ {\\alpha^ {N + 1} m _ {i} t _ {i}}</span></div>

    <p class="text-gray-300">Multiplying these equations for all  <span class="math">i \\in S</span>  yields</p>

    <div class="my-4 text-center"><span class="math-block">e \\left(C, g _ {2} ^ {\\sum_ {i \\in S} \\alpha^ {N + 1 - i} t _ {i}}\\right) = e \\left(\\prod_ {i \\in S} \\pi_ {i} ^ {t _ {i}}, g _ {2}\\right) \\cdot g _ {T} ^ {\\alpha^ {N + 1} \\sum_ {i \\in S} m _ {i} t _ {i}}</span></div>

    <p class="text-gray-300">Correctness for updates follows readily from the equality:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {m} ^ {\\prime \\top} \\mathbf {a} = \\left(\\mathbf {m} ^ {\\prime} [ S ] - \\mathbf {m} [ S ]\\right) ^ {\\top} \\mathbf {a} [ S ] + \\mathbf {m} ^ {\\top} \\mathbf {a}</span></div>

    <p class="text-gray-300">4.2 Cross-Commitment Aggregation</p>

    <p class="text-gray-300">We describe the following additional algorithms:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{AggregateAcross}(\\{C_{j},S_{j},\\mathbf{m}_{j}[S_{j}],\\hat{\\pi}_{j}\\}_{j\\in[\\ell]})</span>. Outputs</p>

    <p class="text-gray-300"><span class="math">\\pi:=\\prod_{j=1}^{\\ell}\\hat{\\pi}_{j}^{t^{\\prime}_{j}}</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">t^{\\prime}_{j}=H^{\\prime}(j,\\{C_{j},S_{j},\\mathbf{m}_{j}[S_{j}]\\}_{j\\in[\\ell]})</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{VerifyAcross}(\\{C_{j},S_{j},\\mathbf{m}_{j}[S_{j}]\\}_{j\\in[\\ell]},\\pi)</span>. Checks that</p>

    <p class="text-gray-300"><span class="math">\\prod_{j=1}^{\\ell}e\\left(C_{j},g_{2}^{\\sum_{i\\in S_{j}}\\alpha^{N+1-i}t_{j,i}}\\right)^{t^{\\prime}_{j}}\\stackrel{{\\scriptstyle?}}{{=}}e(\\pi,g_{2})\\cdot g_{T}^{\\alpha^{N+1}\\sum_{j\\in[\\ell],i\\in S_{j}}m_{j,i}t_{j,i}t^{\\prime}_{j}}</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">t_{j,i}=H(i,C_{j},S_{j},\\mathbf{m}_{j}[S_{j}]),</span> <span class="math">t^{\\prime}_{j}=H^{\\prime}(j,\\{C_{j},S_{j},\\mathbf{m}_{j}[S_{j}]\\}_{j\\in[\\ell]}),</span> <span class="math">\\mathbf{m}_{j}=(m_{j,1},\\ldots,m_{j,N})</span></p>

    <p class="text-gray-300">Implementation and Efficiency. Recall that a summary of computational costs is given in Table 2.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Similarly to Verify, it is faster to implement VerifyAcross by computing <span class="math">r=(\\sum_{j\\in[\\ell],i\\in S_{j}}m_{j,i}t_{j,i}t^{\\prime}_{j})^{-1}</span> <span class="math">\\mod p</span> (with a special case for the inverse does not exist) and checking that</li>

    </ul>

    <p class="text-gray-300"><span class="math">e(\\pi^{-r},g_{2})\\cdot\\prod_{j=1}^{\\ell}e\\left(C_{j},g_{2}^{rt^{\\prime}_{j}\\sum_{i\\in S_{j}}\\alpha^{N+1-i}t_{j,i}}\\right)\\stackrel{{\\scriptstyle?}}{{=}}g_{T}^{\\alpha^{N+1}}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- We note that when <span class="math">\\ell=1</span>, we could set <span class="math">t_{1}=1</span>, thus eliminating the need for AggregateAcross and setting VerifyAcross <span class="math">=</span> Verify. This modification is similar to the case of $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1$ for same-commitment aggregation and works for the same reason.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof of correctness. By correctness of <span class="math">\\hat{\\pi}_{j}</span>, each <span class="math">\\hat{\\pi}_{j}</span> satisfies its verification equation. Raising <span class="math">j</span>th verification equation to <span class="math">t^{\\prime}_{j}</span> and multiplying over all <span class="math">j\\in[\\ell]</span> yields the desired equality.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">4.3 Proof of binding for same-commitment aggregation</h3>

    <p class="text-gray-300">Our scheme satisfies binding for same-commitment aggregation in the AGM+ROM model under the <span class="math">\\ell</span>-wBDHE^{∗} assumption (as described in Section 2).</p>

    <p class="text-gray-300">Proof intuition. Suppose the adversary computes <span class="math">C=g_{1}^{\\mathbf{z}^{\\top}\\mathbf{a}}</span> and provides an accepting proof <span class="math">\\hat{\\pi}</span> for <span class="math">(S,\\mathbf{m}[S])</span> where <span class="math">\\mathbf{m}[S]\\neq\\mathbf{z}[S]</span>. Note that the adversary does not get <span class="math">g_{1}^{\\alpha^{N+1}}</span>, and so the coefficient of <span class="math">\\alpha^{N+1}</span></p>

    <p class="text-gray-300"><span class="math">\\log_{g_{1}}\\hat{\\pi}</span> should be <span class="math">0</span>. Comparing coefficients of <span class="math">g_{T}^{\\alpha^{N+1}}</span> on both sides of the verification equation, we therefore have</p>

    <p class="text-gray-300"><span class="math">\\mathbf{z}[S]^{\\top}\\mathbf{t}\\equiv_{p}\\mathbf{m}[S]^{\\top}\\mathbf{t}\\,,</span></p>

    <p class="text-gray-300">where <span class="math">\\mathbf{t}=(H(i,C,S,\\mathbf{m}[S]),i\\in S)</span>. Now, suppose <span class="math">\\mathbf{t}\\leftarrow\\mathbb{Z}_{p}^{[S]}</span> is chosen uniformly at random after <span class="math">(S,\\mathbf{z}[S],\\mathbf{m}[S])</span> are fixed, in which case</p>

    <p class="text-gray-300"><span class="math">\\Pr_{\\mathbf{t}}\\big{[}\\mathbf{z}[S]\\not\\equiv_{p}\\mathbf{m}[S]\\text{ and }\\mathbf{z}[S]^{\\top}\\mathbf{t}\\equiv_{p}\\mathbf{m}[S]^{\\top}\\mathbf{t}\\big{]}=1/p\\,.</span></p>

    <p class="text-gray-300">To ensure the uniform choice of <span class="math">\\mathbf{t}</span> for any fixed <span class="math">(S,\\mathbf{z}[S],\\mathbf{m}[S])</span>, we note that <span class="math">C</span> determines <span class="math">\\mathbf{z}</span> in AGM and that <span class="math">C</span>, <span class="math">S</span>, and <span class="math">\\mathbf{m}[S]</span> are input to the random oracle <span class="math">H(i,\\cdot,\\cdot,\\cdot)</span>, which produces <span class="math">t_{i}</span>.</p>

    <p class="text-gray-300">On the necessity of inputting <span class="math">S</span> and <span class="math">\\mathbf{m}[S]</span> to <span class="math">H</span>. The attacker wins if</p>

    <p class="text-gray-300"><span class="math">\\sum_{i\\in S}z_{i}t_{i}\\equiv_{p}\\sum_{i\\in S}m_{i}t_{i}</span> (2)</p>

    <p class="text-gray-300">(as long as <span class="math">z_{i}\\neq m_{i}</span> for some <span class="math">i\\in S</span>). Thus, if <span class="math">t_{i}</span> can be determined without <span class="math">m_{i}</span>, the attacker could simply fix all values but a single <span class="math">m_{i}</span> and solve for the remaining <span class="math">m_{i}</span>. Moreover, even if we hash the actual messages first (and thus <span class="math">m_{i}</span> values are random, rather than under the attacker’s control), Wagner’s attack <em>[x27]</em> yields a <span class="math">2^{\\sqrt{\\log p}}</span> algorithm that given <span class="math">\\{z_{i}t_{i},m_{i}t_{i}\\}_{i\\in[N]}</span>, computes a set <span class="math">S</span> of size <span class="math">2^{\\sqrt{\\log p}}</span> such that (2) holds. This yields a <span class="math">2^{\\sqrt{\\log p}}</span> attack if we set <span class="math">t_{i}=H(i,C)</span> instead of <span class="math">H(i,C,S,\\mathbf{m}[S])</span>. At 128-bit security level for the curve (i.e., <span class="math">\\log p\\approx 256</span>), we have <span class="math">2^{\\sqrt{\\log p}}\\approx 2^{16}</span>, which makes for a very practical attack! It seems plausible that the attack also extends to the setting of <span class="math">t_{i}=H(i,C,S)</span>: it would suffice to extend Wagner’s algorithm to finding values that sum to a given constant, because the values of the elements of <span class="math">S</span> are not committed, and thus, although <span class="math">\\sum_{i\\in S}z_{i}t_{i}</span> is fixed, the attacker can choose from a list of random <span class="math">m_{i}</span> for each <span class="math">i\\in S</span>.</p>

    <p class="text-gray-300">Analysis. The formal analysis proceeds in two steps.</p>

    <p class="text-gray-300">Step 1: bounding “lucky” queries. Consider any query <span class="math">(\\star,C,S,\\mathbf{m}[S])</span> that an algebraic adversary (on input pp) makes to <span class="math">H</span>. Since the adversary is algebraic, it must output <span class="math">\\mathbf{z}\\in\\mathbb{Z}_{p}^{N},\\mathbf{y}\\in\\mathbb{Z}_{p}^{N-1}</span> such that</p>

    <p class="text-gray-300"><span class="math">C=g_{1}^{\\mathbf{z}^{\\top}\\mathbf{a}+\\alpha^{N}\\mathbf{y}^{\\top}\\mathbf{a}[-1]}=g_{1}^{\\sum_{i\\in[N]}z_{i}\\alpha^{i}+\\sum_{j\\in[N-1]}y_{j}\\alpha^{N+1+j}}</span></p>

    <p class="text-gray-300">We say that the query is ”<span class="math">H</span>-lucky” if</p>

    <p class="text-gray-300"><span class="math">\\mathbf{m}[S]\\not\\equiv_{p}\\mathbf{z}[S]\\text{ and }(\\mathbf{m}[S]-\\mathbf{z}[S])^{\\top}\\mathbf{t})\\equiv_{p}0\\,,</span></p>

    <p class="text-gray-300">where <span class="math">\\mathbf{t}=(H(i,C,S,\\mathbf{m}[S]):i\\in S)</span>. Note that a query is <span class="math">H</span>-lucky with probability at most <span class="math">1/p</span>. Here we use the fact that the query to <span class="math">H</span> fixes <span class="math">(S,\\mathbf{m}[S],\\mathbf{z}[S])</span>.</p>

    <p class="text-gray-300">By the union bound, the probability that an adversary makes an <span class="math">H</span>-lucky query is at most <span class="math">q_{H}/p</span>, where <span class="math">q_{H}</span> is the number of queries to <span class="math">H</span>. Below, we assume this never happens.</p>

    <p class="text-gray-300">Step 2: extracting <span class="math">g_{1}^{\\alpha^{N+1}}</span>. Now, we will show that a winning algebraic adversary can be used to compute <span class="math">g_{1}^{\\alpha^{N+1}}</span>, contradicting <span class="math">\\ell</span>-wBDHE^{∗}.</p>

    <p class="text-gray-300">Consider the output of a winning algebraic adversary</p>

    <p class="text-gray-300"><span class="math">C,\\{S^{b},\\mathbf{m}^{b}[S^{b}],\\hat{\\pi}^{b}\\}_{b=0,1}</span></p>

    <p class="text-gray-300">together with <span class="math">\\mathbf{z},\\mathbf{y}</span> such that <span class="math">C = g_1^{\\mathbf{z}^\\top \\mathbf{a} + \\alpha^N\\mathbf{y}^\\top \\mathbf{a}[-1]}</span>. Since <span class="math">\\mathbf{m}^0 [S^0\\cap S^1]\\neq \\mathbf{m}^1 [S^0\\cap S^1]</span>, it must be the case that either <span class="math">\\mathbf{m}^0 [S_0]\\neq \\mathbf{z}[S_0]</span> or <span class="math">\\mathbf{m}^1 [S_1]\\neq \\mathbf{z}[S_1]</span>. Let <span class="math">(S^{<em>},\\mathbf{m}^{</em>},\\hat{\\pi}^{*})</span> be such that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {m} ^ {*} [ S ^ {*} ] \\neq \\mathbf {z} [ S ^ {*} ] \\text{ and } \\operatorname {V e r i f y} (C, S ^ {*}, \\mathbf {m} ^ {*} [ S ^ {*} ], \\hat {\\pi} ^ {*}) = 1</span></div>

    <p class="text-gray-300">Since <span class="math">\\hat{\\pi}^*</span> is an accepting proof, we have:</p>

    <div class="my-4 text-center"><span class="math-block">e \\left(C, g _ {2} ^ {\\sum_ {i \\in S ^ {*}} \\alpha^ {N + 1 - i} t _ {i}}\\right) = e \\left(\\hat {\\pi} ^ {*}, g _ {2}\\right) \\cdot g _ {T} ^ {\\alpha^ {N + 1} \\mathbf {m} ^ {*} \\left[ S ^ {*} \\right] ^ {\\top} \\mathbf {t}}</span></div>

    <p class="text-gray-300">where <span class="math">t_i = H(i, C, S^<em>, \\mathbf{m}^</em>[S^*])</span>. This implies</p>

    <div class="my-4 text-center"><span class="math-block">C ^ {\\sum_ {i \\in S ^ {*}} \\alpha^ {N + 1 - i} t _ {i}} = \\hat {\\pi} ^ {*} \\cdot g _ {1} ^ {\\alpha^ {N + 1} \\mathbf {m} ^ {*} [ S ^ {*} ] ^ {\\top} \\mathbf {t}}</span></div>

    <p class="text-gray-300">We can write the LHS as a product of terms that involve <span class="math">g_1^{\\alpha^{N+1}}</span> and terms that do not, namely</p>

    <div class="my-4 text-center"><span class="math-block">\\left(g _ {1} ^ {\\alpha^ {N + 1} \\mathbf {z} [ S ^ {*} ] ^ {\\top} \\mathbf {t}}\\right) \\cdot \\left(\\underbrace {g _ {1} ^ {\\sum_ {i \\in S ^ {*}} \\alpha^ {N + 1 - i} \\mathbf {z} [ - i ] ^ {\\top} \\mathbf {a} [ - i ] t _ {i}}} _ {\\text{depends on } g _ {1} ^ {\\alpha^ {2}}, \\dots , g _ {1} ^ {\\alpha^ {N}}, g _ {1} ^ {\\alpha^ {N + 2}}, \\dots , g _ {1} ^ {\\alpha^ {2 N}}}\\right) \\cdot \\left(\\underbrace {g _ {1} ^ {\\alpha^ {N} \\mathbf {y} ^ {\\top} \\mathbf {a} [ - 1 ] \\sum_ {i \\in S ^ {*}} \\alpha^ {N + 1 - i} t _ {i}}} _ {\\text{depends on } g _ {1} ^ {\\alpha^ {N + 3}}, \\dots , g _ {1} ^ {\\alpha^ {3 N}}}\\right)</span></div>

    <p class="text-gray-300">Moving the terms involving <span class="math">g_1^{\\alpha^{N + 1}}</span> to the RHS, we obtain</p>

    <div class="my-4 text-center"><span class="math-block">\\left(g _ {1} ^ {\\sum_ {i \\in S ^ {*}} \\alpha^ {N + 1 - i} \\mathbf {z} [ - i ] ^ {\\top} \\mathbf {a} [ - i ] t _ {i}}\\right) \\cdot \\left(g _ {1} ^ {\\alpha^ {N} \\mathbf {y} ^ {\\top} \\mathbf {a} [ - 1 ] \\sum_ {i \\in S ^ {*}} \\alpha^ {N + 1 - i} t _ {i}}\\right) \\cdot (\\hat {\\pi} ^ {*}) ^ {- 1} = g _ {1} ^ {\\alpha^ {N + 1} (\\mathbf {m} ^ {*} [ S ^ {*} ] - \\mathbf {z} [ S ^ {*} ]) ^ {\\top} \\mathbf {t}}</span></div>

    <p class="text-gray-300">Now, recall that <span class="math">\\mathbf{m}^{<em>}[S^{</em>}] \\neq \\mathbf{z}[S^{<em>}]</span> and that there are no <span class="math">H</span>-lucky queries, so we must have <span class="math">(\\mathbf{m}^{</em>}[S^{<em>}] - \\mathbf{z}[S^{</em>}])^{\\top}\\mathbf{t} \\not\\equiv_{p} 0</span>, and therefore we can compute its inverse <span class="math">r</span> modulo <span class="math">p</span> and raise both sides of the preceding equation to the power <span class="math">r</span> to get <span class="math">g_1^{\\alpha^{N+1}}</span> on the RHS. Since the LHS is something we can compute given the output of the adversary and <span class="math">g_1^{\\mathbf{a}}, g_1^{\\alpha^N\\mathbf{a}[-1]}, g_1^{\\alpha^{2N}\\mathbf{a}}</span>, we can compute <span class="math">g_1^{\\alpha^{N+1}}</span>.</p>

    <h2 id="sec-11" class="text-2xl font-bold">4.4 Proof of binding for cross-commitment aggregation</h2>

    <p class="text-gray-300">Our scheme satisfies binding for cross-commitment aggregation under the same models and assumptions as for same-commitment aggregation.</p>

    <p class="text-gray-300"><strong>Step 1: bounding "H-lucky" queries</strong> This step is the same as for same-commitment aggregation.</p>

    <p class="text-gray-300"><strong>Step 2: bounding "H'-lucky" queries</strong> Consider any query <span class="math">(\\star, \\{C_j, S_j, \\mathbf{m}_j[S_j]\\}_{j \\in [\\ell]})</span> that an algebraic adversary makes to <span class="math">H&#x27;</span>. Since the adversary is algebraic, it must output <span class="math">\\{\\mathbf{z}_j, \\mathbf{y}_j\\}_{j \\in [\\ell]}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">C _ {j} = g _ {1} ^ {\\mathbf {z} _ {j} ^ {\\top} \\mathbf {a} + \\alpha^ {N} \\mathbf {y} _ {j} ^ {\\top} \\mathbf {a} [ - 1 ]}</span></div>

    <p class="text-gray-300">We say that the query is "H'-lucky" if</p>

    <div class="my-4 text-center"><span class="math-block">\\exists j: \\left(\\mathbf {m} _ {j} [ S _ {j} ] - \\mathbf {z} _ {j} [ S _ {j} ]\\right) ^ {\\top} \\mathbf {t} _ {j} \\not \\equiv_ {p} 0 \\quad \\text{and} \\quad \\sum_ {j = 1} ^ {\\ell} \\left(\\mathbf {m} _ {j} [ S _ {j} ] - \\mathbf {z} _ {j} [ S _ {j} ]\\right) ^ {\\top} \\mathbf {t} _ {j} t _ {j} ^ {\\prime} \\equiv_ {p} 0</span></div>

    <p class="text-gray-300">where <span class="math">\\mathbf{t}_j = (H(i,C_j,S_j,\\mathbf{m}[S_j]),i\\in S_j)</span>. A query is <span class="math">H^{\\prime}</span>-lucky with probability at most <span class="math">1 / p</span>. Here we use the fact that the query to <span class="math">H^{\\prime}</span> fixes <span class="math">\\{(S_j,\\mathbf{m}_j[S_j],\\mathbf{z}_j[S_j])\\}_{j\\in [\\ell]}</span>.</p>

    <p class="text-gray-300">16</p>

    <p class="text-gray-300">Step 3: extracting <span class="math">g_{1}^{\\alpha^{N+1}}</span>. Consider the output of a winning adversary. It contains <span class="math">\\{C_{j}^{b}\\}_{j\\in[\\ell^{b}]}</span> for <span class="math">b=0,1</span>; because the adversary is algebraic, it also contains <span class="math">\\mathbf{z}_{j}^{b},\\mathbf{y}_{j}^{b}</span> such that <span class="math">C_{j}^{b}=g_{1}^{\\mathbf{z}_{j}^{b}^{\\top}\\mathbf{a}+\\alpha^{N}\\mathbf{y}_{j}^{b}^{\\top}\\mathbf{a}[-1]}</span>. The winning conditions specifies <span class="math">j^{0}</span> and <span class="math">j^{1}</span> such that <span class="math">C_{j^{0}}^{0}=C_{j^{1}}^{1}</span>; regardless of what the adversary outputs, we will set <span class="math">\\mathbf{z}_{j^{1}}^{1}=\\mathbf{z}_{j^{0}}^{0}</span> and <span class="math">\\mathbf{y}_{j^{1}}^{1}=\\mathbf{y}_{j^{0}}^{0}</span>. This allows to us to apply the same reasoning as in the same-commitment case to argue that either <span class="math">\\mathbf{m}_{j^{0}}^{0}</span> or <span class="math">\\mathbf{m}_{j^{1}}^{1}</span> is distinct from <span class="math">\\mathbf{z}_{j^{0}}^{0}=\\mathbf{z}_{j^{1}}^{1}</span>. That is, for ^{∗} equal to either <span class="math">0</span> or <span class="math">1</span>,</p>

    <p class="text-gray-300"><span class="math">\\mathbf{m}_{j^{<em>}}^{</em>}[S_{j^{<em>}}^{</em>}]\\neq\\mathbf{z}_{j^{<em>}}^{</em>}[S_{j^{<em>}}^{</em>}]</span> and <span class="math">\\left(\\text{VerifyAcross}(\\{C_{j}^{<em>},S_{j}^{</em>},\\mathbf{m}_{j}^{<em>}[S_{j}^{</em>}]\\}_{j\\in[\\ell^{<em>}]},\\pi^{</em>}\\right)=1</span> <span class="math">\\text{ or }(\\ell^{<em>}=1\\text{ and }\\text{Verify}(C_{1}^{</em>},S_{1}^{<em>},\\mathbf{m}_{1}^{</em>}[S_{1}^{<em>}],\\pi^{</em>})=1)\\right).</span></p>

    <p class="text-gray-300">If <span class="math">\\text{Verify}(\\cdots)=1</span>, we use the argument for same-commitment aggregation. If <span class="math">\\text{VerifyAcross}(\\cdots)=1</span>, then via a similar calculation we deduce that</p>

    <p class="text-gray-300"><span class="math">\\frac{\\sum_{j=1}^{\\ell^{<em>}}\\sum_{i\\in S_{j}^{</em>}}\\alpha^{N+1-i}\\mathbf{z}_{j}^{<em>}[-i]^{\\top}\\mathbf{a}[-i]t_{j,i}t_{j}^{\\prime}}{\\sum_{j=1}^{\\ell^{</em>}}\\alpha^{N}\\mathbf{y}_{j}^{\\top}\\mathbf{a}[-1]\\sum_{i\\in S^{<em>}}\\alpha^{N+1-i}t_{j,i}t_{j}^{\\prime}}\\cdot(\\pi^{</em>})^{-1}=g_{1}^{\\alpha^{N+1}\\sum_{j=1}^{\\ell^{<em>}}(\\mathbf{m}_{j}^{</em>}[S_{j}^{<em>}]-\\mathbf{z}_{j}^{</em>}[S_{j}^{*}])^{\\top}\\mathbf{t}_{j}t_{j}^{\\prime}}</span></p>

    <p class="text-gray-300">The LHS of the equation above does not depend on <span class="math">g_{1}^{\\alpha^{N+1}}</span>. Since there are no <span class="math">H</span>-lucky queries, it must be the case that</p>

    <p class="text-gray-300"><span class="math">(\\mathbf{m}_{j^{<em>}}^{</em>}[S_{j^{<em>}}^{</em>}]-\\mathbf{z}_{j^{<em>}}^{</em>}[S_{j^{<em>}}^{</em>}])^{\\top}\\mathbf{t}_{j^{*}}\\not\\equiv_{p}0\\,.</span></p>

    <p class="text-gray-300">Moreover, since there are no <span class="math">H^{\\prime}</span>-lucky queries, we have</p>

    <p class="text-gray-300"><span class="math">\\sum_{j=1}^{\\ell^{<em>}}(\\mathbf{m}_{j}^{</em>}[S_{j}^{<em>}]-\\mathbf{z}_{j}^{</em>}[S_{j}^{*}])^{\\top}\\mathbf{t}_{j}t_{j}^{\\prime}\\not\\equiv_{p}0\\,.</span></p>

    <p class="text-gray-300">We can then compute <span class="math">g_{1}^{\\alpha^{N+1}}</span> the same way as for the same-commitment case.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">4.5 Adding hiding</h3>

    <p class="text-gray-300">The technique is identical to the one of Libert and Yung <em>[x20]</em>. We will introduce a random coordinate into the exponent vector used by Commit, so that the commitment itself becomes uniformly distributed and thus leaks no information about <span class="math">\\mathbf{m}</span>. This small change suffices to get hiding, because proofs do not leak additional information. Specifically, an accepting proof <span class="math">\\pi_{i}</span> for <span class="math">m_{i}</span> is uniquely determined given <span class="math">C,m_{i}</span>, and therefore leaks no additional information about <span class="math">\\mathbf{m}</span> apart from <span class="math">C,m_{i}</span>, thus providing information-theoretic privacy for <span class="math">\\mathbf{m}[-i]</span>. The same holds for aggregated proofs, which use no information except for the commitments, the proofs, and the messages being opened.</p>

    <p class="text-gray-300">Scheme. Let <span class="math">(\\text{Setup}_{0},\\text{Commit}_{0},\\text{Prove}_{0},\\text{Aggregate}_{0},\\text{Verify}_{0})</span> denote our non-private scheme. Our private scheme is as follows:</p>

    <p class="text-gray-300"><span class="math">\\text{Setup}(1^{\\lambda},1^{N-1})</span>. Run <span class="math">\\text{Setup}_{0}(1^{\\lambda},1^{N})</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\text{Commit}(\\mathbf{m};r\\leftarrow\\mathbb{Z}_{p})</span>. Run $\\text{Commit}_{0}(\\mathbf{m}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">The remaining algorithms Verify and Aggregate are exactly as before.</p>

    <p class="text-gray-300">Proof of binding. Follows from binding of the underlying scheme.</p>

    <p class="text-gray-300">Proof of privacy. We construct the simulator as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Setup}^{*}(1^{\\lambda},1^{N-1})</span>. Same as Setup with <span class="math">\\mathsf{td}=(\\alpha)</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Commit}^{*}(;r\\leftarrow\\mathbb{Z}_{p})</span>. Outputs <span class="math">C\\leftarrow g_{1}^{r}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Prove}^{*}(\\alpha,r,i,m_{i})</span>. Computes <span class="math">C\\leftarrow g_{1}^{r}</span> and outputs</p>

    <p class="text-gray-300"><span class="math">\\pi_{i}=C^{\\alpha^{N+1-i}}\\cdot g_{1}^{-\\alpha^{N+1}m_{i}}</span></p>

    <p class="text-gray-300">This simulator is perfect, in the sense that the real and the simulated distributions are identical, rather than merely close, as can be seen by the following simple hybrid argument:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First, we replace <span class="math">(\\mathsf{Setup},\\mathsf{Prove})</span> with <span class="math">(\\mathsf{Setup}^{<em>},\\mathsf{Prove}^{</em>})</span>. Here, we think of <span class="math">\\mathsf{Prove}^{<em>}</span> as taking input the commitment <span class="math">C</span> (as output by Commit) instead of <span class="math">r</span>. This follows from the fact that <span class="math">\\mathsf{Setup},\\mathsf{Setup}^{</em>}</span> are identically distributed, and the output of <span class="math">\\mathsf{Prove}^{*}</span> is identical to the output of <span class="math">\\mathsf{Prove}</span> for every given <span class="math">\\mathsf{pp},C,i,m_{i}</span> (because it is the only input that will pass verification).</li>

      <li>Next, we replace Commit with Commit^{∗}. This follows from the fact that the output of each Commit is a uniformly random group element in <span class="math">\\mathbb{G}_{1}</span>; this extends readily to the setting with multiple commitments.</li>

    </ul>

    <p class="text-gray-300">Rerandomization Note that a commitment can be rerandomized via multiplication by <span class="math">(g_{1}^{\\alpha^{N}})^{r^{\\prime}}</span>. This procedure will allow us, in particular, to hide the fact that a pre- and a post-update commitment are related.</p>

    <h2 id="sec-13" class="text-2xl font-bold">5 Pointproofs in Blockchains</h2>

    <p class="text-gray-300">In this section, we describe how Pointproofs can result in significant efficiency improvements in blockchain applications and empirically evaluate their performance.</p>

    <p class="text-gray-300">Background on Blockchains For our purposes, a blockchain is an append-only public ledger that consists of blocks, with every block containing some number of transactions. The fundamental problem in blockchains is to agree on a new block. Regardless of how this problem is solved, this agreement involves someone proposing a block, and then multiple parties, whom we will call validators, verifying that the transactions included in the proposed block are valid. Who these validators are is not essential for our purposes: they may be chosen by some selection method (as is often the case in the proof-of-stake blockchains) or self-selected (as in the proof-of-work blockchains). Similarly, the underlying consensus protocol may be randomized and select a committee to certify each block of transactions (as in Algorand <em>[GHM^{+}17]</em>, Ouroboros <em>[x10]</em>, Snow White <em>[x11]</em>, Thunderella <em>[x23]</em>) or mine based on the heuristic longest-chain rule (as in Bitcoin <em>[x24]</em> and Ethereum <em>[x3]</em>).</p>

    <p class="text-gray-300">Simple transactions send money from one account to another. More complex transactions may be verified by a complicated piece of code, known as a smart contract. Execution of the smart contract may also depend on its memory. For example, a smart contract may implement the rules of a securities exchange, and its memory may be used to store the holdings of various entities in the exchange. A transaction may be valid or invalid depending on the values stored in some of the memory locations; it may also modify memory locations upon successful execution.</p>

    <p class="text-gray-300">Thus, to validate transactions, validators need to know the current state of the account balances, or, more generally, of the values stored in the memory of various smart contracts. Some participants (so-called “archival nodes”) may choose to maintain the entire state of all balances and smart contracts and perhaps even provide access to it as a service. However, maintaining this state increases the memory requirements on transaction validators, making participation in the consensus protocol more costly. We would like to permit participation by some validators who are not archival node and thus do not incur the high storage cost.</p>

    <p class="text-gray-300">To reduce the amount of storage required of validators, many authors (including <em>[x21, x15, x17, x14, x1, x6, x3]</em>)) proposed that validators instead store commitments to vectors of relevant values instead of the values themselves. (These proposals are sometimes referred to as “stateless clients” or “stateless blockchains.”) Transactions would then include the values on which they depend, together with the proofs of correctness of these values with respect to the commitments stored by the validators (which the validators would update after successful transactions). This approach suggests a natural tradeoff between storage, bandwidth, and computation. Ideal commitment schemes for this application would have small commitments and proof sizes and add little computation and bandwidth overheads to the validators.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">5.1 Accounts with large memory for smart contracts</h3>

    <p class="text-gray-300">We now focus on smart-contract-based transactions. We abstract the model of computation and describe how to apply Pointproofs to save on storage and bandwidth requirements. Subsequently, in Section 5.2, we compare our application of Pointproofs in smart contracts with alternative designs.</p>

    <p class="text-gray-300">Modeling smart contracts We abstract smart contracts using the following model.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The system has multiple accounts. Each account <span class="math">a</span> is associated with a smart contract <span class="math">P_{a}</span> (a predicate) and account memory <span class="math">\\mathbf{m}_{a}=(m_{1},\\ldots,m_{N})</span> (a sequence of values).</li>

      <li>A transaction <span class="math">T</span> involves one or more accounts. If it involves account <span class="math">a</span>, it may need to read and perhaps modify <span class="math">\\mathbf{m}_{a}</span> at some locations <span class="math">S\\subseteq[N]</span>, changing those entries from <span class="math">\\mathbf{m}_{a}[S]</span> to <span class="math">\\mathbf{m}_{a}^{\\prime}[S]</span>. The transaction <span class="math">T</span> is valid only if <span class="math">P_{a}(T,\\mathbf{m}_{a}[S])=1</span>; if so, the transaction computes possibly new values for <span class="math">\\mathbf{m}_{a}^{\\prime}[S]</span>.</li>

    </ul>

    <p class="text-gray-300">In a basic implementation without commitments, each validator would store account memory <span class="math">\\mathbf{m}_{a}</span> for every account <span class="math">a</span> in order to be able to validate the transactions; the validators would update this memory whenever a transaction modifies it.</p>

    <p class="text-gray-300">Using Pointproofs in smart contracts. We can use Pointproofs to reduce validator storage as follows (see Figure 1):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The public parameters are generated as discussed in Section 4.1 and either hard-coded into the software or posted on the blockchain.</li>

      <li>The owner of account <span class="math">a</span> holds <span class="math">(P_{a},\\mathbf{m}_{a})</span> and generates a commitment <span class="math">C_{a}</span> to <span class="math">\\mathbf{m}_{a}</span> using Commit.</li>

      <li>Each validator stores <span class="math">(P_{a},C_{a})</span> instead of <span class="math">(P_{a},\\mathbf{m}_{a})</span>. Here we assume the predicate <span class="math">P_{a}</span> is small and can be stored on-chain or hardcoded in the blockchain platform and called by “reference”. (Alternatively, it may be included in the memory of the account <span class="math">\\mathbf{m}_{a}</span>.)</li>

    </ul>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: Using Pointproofs for smart-contract-based transactions  <span class="math">\\mathrm{tx}_a</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A transaction  <span class="math">T</span>  that reads and/or modifies  <span class="math">\\mathbf{m}_a</span>  at locations  <span class="math">S</span>  must be submitted with  <span class="math">(S, \\mathbf{m}_a[S])</span>  and the proof  <span class="math">\\hat{\\pi}</span>  for these values (computed using Prove and Aggregate). This proof can be generated by the owner of  <span class="math">a</span>  (or the computation may be delegated to someone else).</li>

      <li>A block proposer generates a block  <span class="math">B</span>  of  <span class="math">\\ell</span>  transactions, and cross-commitment aggregates all  <span class="math">\\ell</span>  proofs into a single proof  <span class="math">\\pi</span>  by running AggregateAcross algorithm. (If transactions need to be verified before being included in a block—for example, to protect against denial of service attacks—this is done by using Verify to check the correctness of  <span class="math">\\mathbf{m}_a[S]</span> , and then running  <span class="math">P</span> .) The block  <span class="math">B</span>  includes  <span class="math">\\{T, S, \\mathbf{m}_a[S]\\}</span>  and the single aggregated proof  <span class="math">\\pi</span> , but single-commitment proofs  <span class="math">\\hat{\\pi}</span>  are omitted. The block is then passed to the validators specified by the consensus.</li>

      <li>Each validator receives  <span class="math">(\\{T, S, \\mathbf{m}_a[S]\\}, \\pi)</span>  and checks the correctness of all  <span class="math">\\mathbf{m}_a[S]</span>  values using the aggregate proof  <span class="math">\\pi</span>  by calling VerifyAcross. Each validator then verifies all individual transactions  <span class="math">T</span>  in the block using the relevant smart contracts  <span class="math">P_a</span>  and the already verified values  <span class="math">\\mathbf{m}_a[S]</span> .</li>

      <li>Once the block is agreed upon (whatever consensus mechanism is used), validators update the commitments for all accounts affected by the transactions in the block, by running the transactions to figure out the new memory values  <span class="math">\\mathbf{m}_a^\\prime [S]</span>  and using UpdateCommit.</li>

    </ul>

    <p class="text-gray-300">We briefly summarize how our design compares with two alternative designs for smart contracts.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Naive Approach: all validators store cleartext data  <span class="math">\\mathbf{m}_a</span>  for all accounts. The main advantage of this approach is that there are zero bandwidth and computation overheads. In this design, the validators' storage grows significantly with the total number of accounts. In Table 4, we show an example with the total storage for  <span class="math">10^{8}</span>  accounts at almost 3 TB.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>One global commitment: in this design, all validators store a single commitment for all accounts memories:  <span class="math">C = \\text{Commit}(\\{\\mathbf{m}_a\\})</span> . Also, there is a single entity (or a collection of entities) that is responsible for generating proofs for individual transactions. That is, when a user of an account  <span class="math">a</span>  wants to submit a transaction  <span class="math">T</span>  that depends on  <span class="math">\\mathbf{m}_a[S]</span> , the user requests a proof  <span class="math">\\pi</span>  from the central entity and submits the tuple  <span class="math">(T, \\mathbf{m}_a[S], S, \\pi)</span>  to the network. The validators check the transaction and update the global commitment. One could use a variety of commitment schemes, such as Merkle Trees, [LM19] or [BBF19] commitments. The advantage of this design is the minimal storage requirements from the validators: they store one short commitment to the entire state of the system. However, a major drawback of this design is that it relies on a central entity to generate proofs for all users. In the solution we described above, where validators store one commitment per account, we already reduce the validators' storage to a few gigabytes (4.5 GB using Pointproofs for  <span class="math">10^8</span>  accounts), which is small enough for most modern computers. We believe it is not justified to reduce this storage even further at the expense of introducing a central entity to the system that must be trusted for data availability.</li>

    </ul>

    <p class="text-gray-300">We implemented Pointproofs in Rust [Alg20b] and evaluated their performance. Our timing benchmarks were on Ubuntu running on Intel(R) Xeon(R) CPU E5-2686 v4 at 2.30 GHz. Our implementation is single-threaded, but all functions can easily be parallelized over multiple threads. For algebraic operations we enhanced [Alg20a] the Rust pairing library [ZkC19]. More recent implementation of pairings (such as [SL20] and [Sup20]) are likely to provide a noticeable speed-up to our benchmarks.</p>

    <p class="text-gray-300">Storage. We start by evaluating the storage savings introduced, applying Pointproofs to commit to accounts memory as described in Section 5.1. In all experiments, we assume every account memory holds  <span class="math">N = 1000</span>  variables. Each variable stores a 32 bytes value. We compare the schemes of Lai and Malavolta [LM19] over pairing and class-groups (LM-CDH, LM-CG), scheme of Boneh, Bunz, and Fisch [BBF19] based on RSA (BBF), and Pointproofs. For LM-CDH and Pointproofs, we place the commitment and proofs in  <span class="math">\\mathbb{G}_1</span> , since that results in smaller commitments and proof sizes. Table 3 shows the sizes of commitments, openings, and public parameters of various schemes. For class groups, we use a 2048-bit group. For pairing groups, we use BLS12-381.</p>

    <p class="text-gray-300">Table 4 shows the storage requirements for storing all data in the clear vs. replacing it with a</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Opening size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Commitment size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Public parameters</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Merkle Tree</td>

            <td class="px-3 py-2 border-b border-gray-700">320</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BBF [BBF19]</td>

            <td class="px-3 py-2 border-b border-gray-700">1312</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">2·256 = 512</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">LM-CG [LM19, Fig 1]</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">1002·256 ≈ 257 × 103</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">LM-CDH [LM19, Fig 2]</td>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">10002·48 + 1000·96 ≈ 48 × 106</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Pointproofs (this work)</td>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">1999·48 + 1000·96 ≈ 192 × 103</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3: Concrete lengths (in bytes) at 128-bit security for  <span class="math">N = 1000</span>  and 256-bit messages. For class groups, we use a 2048-bit group. (A BBF proof consists of 5 group elements [BBF19, Section 1.1] and a 256-bit integer [BBF18, Section 3.3].) We omit  <span class="math">e_i</span> s from LM-CG parameters, as they can be reconstructed by anyone. For pairing groups, we use BLS12-381. For Merkle Trees we assume paths of length 10 and 256-bit hashes.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">106accounts</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">107accounts</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">108accounts</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">savings</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Plaintext</td>

            <td class="px-3 py-2 border-b border-gray-700">29.8</td>

            <td class="px-3 py-2 border-b border-gray-700">298.0</td>

            <td class="px-3 py-2 border-b border-gray-700">2980.2</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BBF and LM-CG</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2</td>

            <td class="px-3 py-2 border-b border-gray-700">2.4</td>

            <td class="px-3 py-2 border-b border-gray-700">23.8</td>

            <td class="px-3 py-2 border-b border-gray-700">99.2%</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">LM-CDH and Pointproofs</td>

            <td class="px-3 py-2 border-b border-gray-700">0.04</td>

            <td class="px-3 py-2 border-b border-gray-700">0.45</td>

            <td class="px-3 py-2 border-b border-gray-700">4.5</td>

            <td class="px-3 py-2 border-b border-gray-700">99.8%</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 4: Storage requirements (in GB) for storing plaintext data vs. commitments for various number of accounts in the system. Each account memory has  <span class="math">N = 1000</span>  locations storing 32-bytes values.</p>

    <p class="text-gray-300">commitment per account. In a naive solution, users store</p>

    <p class="text-gray-300">accounts  <span class="math">\\cdot 1000</span>  variables  <span class="math">\\cdot 32</span>  bytes.</p>

    <p class="text-gray-300">With commitments, the storage requirements are reduced to</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">accounts  $\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  is the size of a commitment. All commitment schemes reduce storage requirements significantly (over 99%).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Bandwidth. Figure 2 measures block bandwidth overheads for stateless blockchain model for subvector openings of size 1 with respect to each commitment (i.e.,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{a}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1<span class="math"> ). Assuming there are  </span>\\ell$  transactions in a block, applying a commitment scheme that supports subvector openings (such as LM-CDH, LM-CG, or BBF) results in overheads of</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\ell \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\ell \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{m}_a[S_a]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_a</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Pointproofs result in the smallest overheads since  <span class="math">\\ell</span>  proofs across transactions can be aggregated into a single proof.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> 1000 Txs</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> 2000 Txs</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> 3000 Txs</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 2: Per block bandwidth overhead between a block proposer and validators in stateless blockchain for retrieving  <span class="math">\\mathbf{m}_a[S_a]</span>  and corresponding proofs, assuming  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{a}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1<span class="math"> . The four plots represent a different number of transactions in a block  </span>\\ell<span class="math"> . The bottom part of each graph (blue) corresponds to cleartext overheads for transmitting  </span>\\mathbf{m}_a[S_a]<span class="math"> , and the top part (red) corresponds to overheads for proofs. Pointproofs add only 48 bytes to the cleartext data that must be transmitted (and hence are invisible on the plots). Note that if  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{a}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  grows, the blue bar will grow proportionately as the amount of transmitted cleartext data increases, while the red bar will remain the same, thus reducing the relative cost of proofs.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> 4000 Txs</p>

    <p class="text-gray-300">Computation. We now turn our attention to running times (as already mentioned, more recent implementations of the underlying algebra, such as [SL20], will likely provide a noticeable speed-up).</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 3: Total runtime for proving (separately followed by aggregation, or all at once) and verification algorithms with respect to a single commitment for various sizes of  <span class="math">S</span> . The runtime of the first and last algorithms grows roughly linearly with  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ , while for all-at-once proving it does not grow much.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 4: Total runtime of cross-commitment aggregation AggregateAcross and Verify algorithms for the various number of commitments  <span class="math">\\ell</span>  (= # transactions in a block). The plots for AggregateAcross function for  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1<span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 8<span class="math">  overlap since its runtime is independent of the size of  </span>S$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The initial Commit to 1000 values representing the memory  <span class="math">\\mathbf{m}</span>  of a single account (done by the account owner) runs in  <span class="math">54\\mathrm{ms}</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The combined cost of Prove and Aggregate to produce  <span class="math">\\hat{\\pi}</span>  for  <span class="math">\\mathbf{m}_a[S]</span>  for  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1<span class="math">  (done during submission of the transaction) is  </span>54\\mathrm{ms}<span class="math"> . For  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 8<span class="math"> , it goes up to  </span>280\\mathrm{ms}<span class="math"> , which means the per-value cost goes down to  </span>35\\mathrm{ms}<span class="math"> . The cost of computing a same-commitment aggregated proof all at once (instead of separate invocations of Prove followed by Aggregate) is only  </span>83\\mathrm{ms}<span class="math">  for  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 8$ . See Figure 3 for more details.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The block proposer can aggregate proofs across multiple commitment  <span class="math">\\hat{\\pi}^1, \\dots, \\hat{\\pi}^\\ell</span>  into a single proof  <span class="math">\\pi</span>  using AggregateAcross at the cost  <span class="math">0.06 - 0.07\\mathrm{ms}</span>  per proof, with the per-proof cost decreasing as the number of proofs in a block grows. Aggregation is highly parallelizable because the main cost is one exponentiation per the commitment. See Figure 4 for more details.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- A validator can verify the aggregated proof  <span class="math">\\pi</span>  using VerifyAcross at the cost of 1.9ms per commitment for  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1<span class="math">  and 5.7ms per commitment (0.72ms per value proven) for  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 8$ . The per commitment cost does not change noticeably as the number of commitments grows from 1000 to 5000. Verification is highly parallelizable because the main cost is the per-commitment Miller loop of one pairing operation. See Figure 4 for more details.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Applied in the Algorand blockchain, for instance, a 64-thread parallelized version of the Verify algorithm would add 0.45 seconds (or  <span class="math">70\\%</span> ) to the block verification time for 5000 transactions (Figure 5, plot "5000 txs; Pixel" [DGNW20]).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Anyone storing the commitments can update them with the new values in <span class="math">\\mathbf{m}_{n}^{\\prime}[S]</span> at the cost of 0.3 ms per proof for $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1<span class="math"> and 0.2 ms per proof for </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=8$. One-time precomputation on the public parameters (storing 256 values per parameter) can speed this up by a factor of 3–5.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Acknowledgments.</p>

    <p class="text-gray-300">We thank Derek Leung and Nickolai Zeldovich for numerous insightful discussions on using vector commitments on the blockchain; Shai Halevi, Craig Gentry, and Ariel Gabizon for conversations on polynomial commitments; Adam Suhl for insights into parameter generation; and Dario Fiore for help understanding the parameters of prior work. This work was done while HW and SG were at Algorand.</p>

    <h2 id="sec-17" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AGH10] Jae Hyun Ahn, Matthew Green, and Susan Hohenberger. Synchronized aggregate signatures: new definitions, constructions and applications. In Ehab Al-Shaer, Angelos D. Keromytis, and Vitaly Shmatikov, editors, ACM CCS 2010, pages 473–484. ACM Press, October 2010.</li>

      <li>[Alg20a] Algorand. Pairing plus library, 2020. https://github.com/algorand/pairing-plus.</li>

      <li>[Alg20b] Algorand. Source code for pointproofs, 2020. https://github.com/algorand/pointproofs.</li>

      <li>[BBF18] Dan Boneh, Benedikt Bünz, and Ben Fisch. A survey of two verifiable delay functions. Cryptology ePrint Archive, Report 2018/712, 2018. https://eprint.iacr.org/2018/712.</li>

      <li>[BBF19] Dan Boneh, Benedikt Bünz, and Ben Fisch. Batching techniques for accumulators with applications to IOPs and stateless blockchains. In Alexandra Boldyreva and Daniele Micciancio, editors, CRYPTO 2019, Part I, volume 11692 of LNCS, pages 561–586. Springer, Heidelberg, August 2019.</li>

      <li>[BBG05] Dan Boneh, Xavier Boyen, and Eu-Jin Goh. Hierarchical identity based encryption with constant size ciphertext. In Ronald Cramer, editor, EUROCRYPT 2005, volume 3494 of LNCS, pages 440–456. Springer, Heidelberg, May 2005.</li>

      <li>[BDFG20] Dan Boneh, Justin Drake, Ben Fisch, and Ariel Gabizon. Efficient polynomial commitment schemes for multiple points and polynomials. Cryptology ePrint Archive, Report 2020/081, 2020.</li>

      <li>[BDN18] Dan Boneh, Manu Drijvers, and Gregory Neven. Compact multi-signatures for smaller blockchains. In Thomas Peyrin and Steven Galbraith, editors, ASIACRYPT 2018, Part II, volume 11273 of LNCS, pages 435–464. Springer, Heidelberg, December 2018.</li>

      <li>[BGM17] Sean Bowe, Ariel Gabizon, and Ian Miers. Scalable multi-party computation for zk-SNARK parameters in the random beacon model. Cryptology ePrint Archive, Report 2017/1050, 2017. http://eprint.iacr.org/2017/1050.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[BGR12] Kyle Brogle, Sharon Goldberg, and Leonid Reyzin. Sequential aggregate signatures with lazy verification from trapdoor permutations - (extended abstract). In Xiaoyun Wang and Kazue Sako, editors, ASIACRYPT 2012, volume 7658 of LNCS, pages 644–662. Springer, Heidelberg, December 2012.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BGW05] Dan Boneh, Craig Gentry, and Brent Waters. Collusion resistant broadcast encryption with short ciphertexts and private keys. In Victor Shoup, editor, CRYPTO 2005, volume 3621 of LNCS, pages 258–275. Springer, Heidelberg, August 2005.</li>

      <li>[BM^{+}19] Benedikt Bünz, Mary Maller, , Pratyush Mishra, and Noah Vesely. Proofs for inner pairing products and applications. Cryptology ePrint Archive, Report 2019/1177, 2019. https://eprint.iacr.org/2019/1177.</li>

      <li>[BR93] Mihir Bellare and Phillip Rogaway. Random oracles are practical: A paradigm for designing efficient protocols. In Dorothy E. Denning, Raymond Pyle, Ravi Ganesan, Ravi S. Sandhu, and Victoria Ashby, editors, ACM CCS 93, pages 62–73. ACM Press, November 1993.</li>

      <li>[But14] Vitalik Buterin. Ethereum: A next-generation smart contract and decentralized application platform, 2014.</li>

      <li>[But17] Vitalik Buterin. The stateless client concept. Ethereum Blog, 2017. https://ethresear.ch/t/the-stateless-client-concept/172.</li>

      <li>[CF13] Dario Catalano and Dario Fiore. Vector commitments and their applications. In Kaoru Kurosawa and Goichiro Hanaoka, editors, PKC 2013, volume 7778 of LNCS, pages 55–72. Springer, Heidelberg, February / March 2013.</li>

      <li>[CFG^{+}20] Matteo Campanelli, Dario Fiore, Nicola Greco, Dimitris Kolonelos, and Luca Nizzardo. Vector commitment techniques and applications to verifiable decentralized storage. Cryptology ePrint Archive, Report 2020/149, 2020. https://eprint.iacr.org/2020/149.</li>

      <li>[Che06] Jung Hee Cheon. Security analysis of the strong Diffie-Hellman problem. In Serge Vaudenay, editor, EUROCRYPT 2006, volume 4004 of LNCS, pages 1–11. Springer, Heidelberg, May / June 2006.</li>

      <li>[CKS09] Jan Camenisch, Markulf Kohlweiss, and Claudio Soriente. An accumulator based on bilinear maps and efficient revocation for anonymous credentials. In Stanislaw Jarecki and Gene Tsudik, editors, PKC 2009, volume 5443 of LNCS, pages 481–500. Springer, Heidelberg, March 2009.</li>

      <li>[CPZ18] Alexander Chepurnoy, Charalampos Papamanthou, and Yupeng Zhang. Edrax: A cryptocurrency with stateless transaction validation. Cryptology ePrint Archive, Report 2018/968, 2018. https://eprint.iacr.org/2018/968.</li>

      <li>[DGKR18] Bernardo David, Peter Gazi, Aggelos Kiayias, and Alexander Russell. Ouroboros praos: An adaptively-secure, semi-synchronous proof-of-stake blockchain. In Jesper Buus Nielsen and Vincent Rijmen, editors, EUROCRYPT 2018, Part II, volume 10821 of LNCS, pages 66–98. Springer, Heidelberg, April / May 2018.</li>

    </ul>

    <p class="text-gray-300">[DGNW20] Manu Drijvers, Sergey Gorbunov, Gregory Neven, and Hoeteck Wee. Pixel: Multi-signatures for consensus. In USENIX Security, 2020. https://eprint.iacr.org/2019/514.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[DPS19] Phil Daian, Rafael Pass, and Elaine Shi. Snow white: Robustly reconfigurable consensus and applications to provably secure proof of stake. In Ian Goldberg and Tyler Moore, editors, FC 2019, volume 11598 of LNCS, pages 23–41. Springer, Heidelberg, February 2019.</li>

      <li>[Dra17] Justin Drake. History, state, and asynchronous accumulators in the stateless model. Ethereum Blog, 2017. https://ethresear.ch/t/history-state-and-asynchronous-accumulators-in-the-stateless-model/287.</li>

      <li>[FKL18] Georg Fuchsbauer, Eike Kiltz, and Julian Loss. The algebraic group model and its applications. In Hovav Shacham and Alexandra Boldyreva, editors, CRYPTO 2018, Part II, volume 10992 of LNCS, pages 33–62. Springer, Heidelberg, August 2018.</li>

      <li>[Gab20] Ariel Gabizon. Private communication, April 2020.</li>

      <li>[GHM^{+}17] Yossi Gilad, Rotem Hemo, Silvio Micali, Georgios Vlachos, and Nickolai Zeldovich. Algorand: Scaling byzantine agreements for cryptocurrencies. In Proceedings of the 26th Symposium on Operating Systems Principles, 2017.</li>

      <li>[GWC19] Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru. PLONK: Permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge. Cryptology ePrint Archive, Report 2019/953, 2019. https://eprint.iacr.org/2019/953.</li>

      <li>[KZG10] Aniket Kate, Gregory M. Zaverucha, and Ian Goldberg. Constant-size commitments to polynomials and their applications. In Masayuki Abe, editor, ASIACRYPT 2010, volume 6477 of LNCS, pages 177–194. Springer, Heidelberg, December 2010.</li>

      <li>[LM19] Russell W. F. Lai and Giulio Malavolta. Subvector commitments with application to succinct arguments. In Alexandra Boldyreva and Daniele Micciancio, editors, CRYPTO 2019, Part I, volume 11692 of LNCS, pages 530–560. Springer, Heidelberg, August 2019.</li>

      <li>[LRY16] Benoît Libert, Somindu C. Ramanna, and Moti Yung. Functional commitment schemes: From polynomial commitments to pairing-based accumulators from simple assumptions. In Ioannis Chatzigiannakis, Michael Mitzenmacher, Yuval Rabani, and Davide Sangiorgi, editors, ICALP 2016, volume 55 of LIPIcs, pages 30:1–30:14. Schloss Dagstuhl, July 2016.</li>

      <li>[LY10] Benoît Libert and Moti Yung. Concise mercurial vector commitments and independent zero-knowledge sets with short proofs. In Daniele Micciancio, editor, TCC 2010, volume 5978 of LNCS, pages 499–517. Springer, Heidelberg, February 2010.</li>

      <li>[MBKM19] Mary Maller, Sean Bowe, Markulf Kohlweiss, and Sarah Meiklejohn. Sonic: Zero-knowledge SNARKs from linear-size universal and updatable structured reference strings. In Lorenzo Cavallaro, Johannes Kinder, XiaoFeng Wang, and Jonathan Katz, editors, ACM CCS 2019, pages 2111–2128. ACM Press, November 2019.</li>

      <li>[Mer88] Ralph C. Merkle. A digital signature based on a conventional encryption function. In Carl Pomerance, editor, CRYPTO’87, volume 293 of LNCS, pages 369–378. Springer, Heidelberg, August 1988.</li>

    </ul>

    <p class="text-gray-300">[Mil12] Andrew Miller. Storing UTXOs in a balanced Merkle tree (zero-trust nodes with O(1)-storage), 2012. https://bitcointalk.org/index.php?topic=101734.msg1117428.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Nak09] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system, 2009.</li>

      <li>[Pip80] Nicholas Pippenger. On the evaluation of powers and monomials. SIAM J. Comput., 9(2):230–250, 1980.</li>

      <li>[PS18] Rafael Pass and Elaine Shi. Thunderella: Blockchains with optimistic instant confirmation. In Jesper Buus Nielsen and Vincent Rijmen, editors, EUROCRYPT 2018, Part II, volume 10821 of LNCS, pages 3–33. Springer, Heidelberg, April / May 2018.</li>

      <li>[RMCI17] Leonid Reyzin, Dmitry Meshkov, Alexander Chepurnoy, and Sasha Ivanov. Improving authenticated dynamic dictionaries, with applications to cryptocurrencies. In Aggelos Kiayias, editor, FC 2017, volume 10322 of LNCS, pages 376–392. Springer, Heidelberg, April 2017.</li>

      <li>[SL20] SCIPR-Lab. Zexe, 2020. https://github.com/scipr-lab/zexe.</li>

      <li>[ST99] Tomas Sander and Amnon Ta-Shma. Auditable, anonymous electronic cash. In Michael J. Wiener, editor, CRYPTO’99, volume 1666 of LNCS, pages 555–572. Springer, Heidelberg, August 1999.</li>

      <li>[Suh19] Adam Suhl. Private communication, 2019. https://github.com/algorand/pointproofs-paramgen/blob/master/consistencycheck.pdf.</li>

      <li>[Sup20] Supranational. blst, 2020. https://github.com/supranational/blst.</li>

      <li>[TAB^{+}20] Alin Tomescu, Ittai Abraham, Vitalik Buterin, Justin Drake, Dankrad Feist, and Dmitry Khovratovich. Aggregatable subvector commitments for stateless cryptocurrencies. Cryptology ePrint Archive, Report 2020/527, 2020. https://eprint.iacr.org/2020/527.</li>

      <li>[Tha19] Steve Thakur. Batching non-membership proofs with bilinear accumulators. Cryptology ePrint Archive, Report 2019/1147, 2019. https://eprint.iacr.org/2019/1147.</li>

      <li>[Tod16] Peter Todd. Making UTXO set growth irrelevant with low-latency delayed TXO commitments, 2016. https://petertodd.org/2016/delayed-txo-commitments.</li>

      <li>[Wag02] David Wagner. A generalized birthday problem. In Moti Yung, editor, CRYPTO 2002, volume 2442 of LNCS, pages 288–303. Springer, Heidelberg, August 2002.</li>

      <li>[Whi15] Bill White. A theory for lightweight cryptocurrency ledgers. Available at http://qeditas.org/lightcrypto.pdf, 2015.</li>

      <li>[ZkC19] ZkCrypto. Pairing library, 2019. https://github.com/zkcrypto/pairing.</li>

    </ul>

    <p class="text-gray-300">A Same-Commitment Aggregation from CDH-like Assumption</p>

    <p class="text-gray-300">We sketch a same-commitment aggregation scheme with <span class="math">O(N^{2})</span>-size public parameters from the following CDH-like static assumption: given <span class="math">g_{1}^{u},g_{1}^{v},g_{2}^{v}</span>, it is hard to compute <span class="math">g_{T}^{uv^{2}}</span>. The efficiency and underlying hardness assumption of this scheme matches that of LM-CDH (<em>[x18, Fig 2]</em>), while additionally supporting aggregation.</p>

    <p class="text-gray-300">The scheme. Here, both Commit and Prove are deterministic.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}(1^{\\lambda},1^{N}).</span> Samples <span class="math">u_{i},v_{i}\\leftarrow\\mathbb{Z}_{p}</span> for <span class="math">i=1,\\ldots,N</span> and outputs</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\{g_{1}^{u_{i}},g_{2}^{v_{i}}\\}_{i\\in[N]},\\{g_{1}^{u_{j}v_{i}}\\}_{i\\neq j}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Commit}(\\mathbf{m}).</span> Outputs</li>

    </ul>

    <p class="text-gray-300"><span class="math">C:=g_{1}^{\\sum_{i\\in[N]}m_{i}u_{i}}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{UpdateCommit}(C,S,\\mathbf{m}[S],\\mathbf{m}^{\\prime}[S]).</span> Outputs</li>

    </ul>

    <p class="text-gray-300"><span class="math">C^{\\prime}:=C\\cdot g_{1}^{\\sum_{i\\in S}(m_{i}^{\\prime}-m_{i})u_{i}}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Prove}(i,\\mathbf{m}).</span> Outputs</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\pi_{i}:=g_{1}^{\\sum_{j\\neq i}m_{j}u_{j}v_{i}}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Aggregate}(C,S,\\mathbf{m}[S],\\{\\pi_{i}:i\\in S\\}).</span> Outputs</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\hat{\\pi}:=\\prod_{i\\in S}\\pi_{i}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Verify}(C,S,\\mathbf{m}[S],\\hat{\\pi}).</span> Checks that</li>

    </ul>

    <p class="text-gray-300"><span class="math">e(C,g_{2}^{\\sum_{i\\in S}v_{i}})\\stackrel{{\\scriptstyle?}}{{=}}e(\\hat{\\pi},g_{2})\\cdot g_{T}^{\\sum_{i\\in S}m_{i}u_{i}v_{i}}</span></p>

    <p class="text-gray-300">Comparison with LM-CDH We do not know how to support aggregation in LM-CDH (which corresponds to the special case <span class="math">u_{i}=v_{i}</span>) <em>[x18, Fig 2]</em>. In particular, the verification equation there is given by:</p>

    <p class="text-gray-300"><span class="math">e(C,g_{2}^{\\sum_{i\\in S}v_{i}})\\stackrel{{\\scriptstyle?}}{{=}}e(\\hat{\\pi},g_{2})\\cdot g_{T}^{(\\sum_{i\\in S}m_{i}u_{i})(\\sum_{i\\in S}v_{i})}</span></p>

    <p class="text-gray-300">An earlier version of <em>[x18]</em> claims security from CDH, but we found a mistake in the proof of binding, where they incorrectly assume that <span class="math">e(C,g_{2}^{\\sum_{i\\in S^{0}}v_{i}})=e(C,g_{2}^{\\sum_{i\\in S^{1}}v_{i}})</span>. The mistake has since been fixed.</p>

    <p class="text-gray-300">Proof of correctness. Follows readily from</p>

    <p class="text-gray-300"><span class="math">(\\sum_{j\\in[N]}m_{j}u_{j})\\cdot v_{i}=m_{i}u_{i}v_{i}+\\sum_{j\\neq i}m_{j}u_{j}v_{i}</span></p>

    <p class="text-gray-300">and then summing over <span class="math">i\\in S</span></p>

    <p class="text-gray-300">Proof of binding. Now, consider the output of a winning adversary</p>

    <p class="text-gray-300"><span class="math">C,\\{S^{b},\\mathbf{m}^{b}[S^{b}],\\hat{\\pi}^{b}\\}_{b=0,1}</span></p>

    <p class="text-gray-300">along with <span class="math">i^{<em>}</span> such that <span class="math">m_{i^{</em>}}^{0}\\neq m_{i^{<em>}}^{1}</span>. The reduction proceeds as follows: embeds <span class="math">u,v</span> from the computational problem into <span class="math">u_{i^{</em>}},v_{i^{<em>}}</span>, and samples <span class="math">u_{i},v_{i}\\leftarrow\\mathbb{Z}_{p},i\\neq i^{</em>}</span> (formally, the reduction picks a random <span class="math">i^{<em>}\\leftarrow\\mathbb{Z}_{N}</span> and aborts if <span class="math">m_{i^{</em>}}^{0}=m_{i^{<em>}}^{1}</span>). Simulating <span class="math">\\mathsf{pp}</span> is straight-forward since we know <span class="math">g_{1}^{u_{i^{</em>}}},g_{1}^{v_{i^{*}}}</span>.</p>

    <p class="text-gray-300">Next, let us write <span class="math">v_{S}:=\\sum_{i\\in S}v_{i}</span>. Raising the verification equations to <span class="math">v_{S^{0}},v_{S^{1}}</span> respectively and using <span class="math">e(C,g_{2}^{v_{S^{0}}})^{v_{S^{1}}}=e(C,g_{2}^{v_{S^{1}}})^{v_{S^{0}}}</span>, we have:</p>

    <p class="text-gray-300"><span class="math">e(\\hat{\\pi}^{0},g_{2}^{v_{S^{1}}})\\cdot g_{T}^{v_{S^{1}}\\sum_{i\\in S^{0}}m_{i}^{0}u_{i}v_{i}}=e(\\hat{\\pi}^{1},g_{2}^{v_{S^{0}}})\\cdot g_{T}^{v_{S^{0}}\\sum_{i\\in S^{1}}m_{i}^{1}u_{i}v_{i}}</span></p>

    <p class="text-gray-300">Rearranging the terms so that <span class="math">g_{T}^{u_{i^{<em>}}v_{i^{</em>}}^{2}}</span> appears on the RHS,</p>

    <p class="text-gray-300"><span class="math">e(\\hat{\\pi}^{0},g_{2}^{v_{S^{1}}})\\cdot e(\\hat{\\pi}^{1},g_{2}^{v_{S^{0}}})^{-1}</span> <span class="math">\\cdot g_{T}^{v_{i^{<em>}}\\sum_{i\\in S^{0}\\setminus\\{i^{</em>}\\}}m_{i}^{0}u_{i}v_{i}}\\cdot g_{T}^{-v_{i^{<em>}}\\sum_{i\\in S^{1}\\setminus\\{i^{</em>}\\}}m_{i}^{1}u_{i}v_{i}}</span> <span class="math">\\cdot g_{T}^{(v_{S^{1}}-v_{i^{<em>}})\\sum_{i\\in S^{0}}m_{i}^{0}u_{i}v_{i}}\\cdot g_{T}^{-(v_{S^{0}}-v_{i^{</em>}})\\sum_{i\\in S^{1}}m_{i}^{1}u_{i}v_{i}}</span> <span class="math">=g_{T}^{(m_{i^{<em>}}^{1}-m_{i^{</em>}}^{0})u_{i^{<em>}}v_{i^{</em>}}^{2}}</span></p>

    <p class="text-gray-300">We can now extract <span class="math">g_{T}^{u_{i^{<em>}}v_{i^{</em>}}^{2}}</span> using the fact that <span class="math">m_{i^{<em>}}^{1}-m_{i^{</em>}}^{0}\\neq 0</span>, since we can compute the terms on the LHS given <span class="math">\\hat{\\pi}^{0},\\hat{\\pi}^{1},g_{1}^{u_{i^{<em>}}},g_{2}^{v_{i^{</em>}}}</span> and <span class="math">\\{u_{i},v_{i}\\}_{i\\neq i^{*}}</span>.</p>

    <h2 id="sec-18" class="text-2xl font-bold">Appendix B Weak binding</h2>

    <p class="text-gray-300">In this section, we describe a weaker notion of binding, in which the commitment <span class="math">C</span> must be honestly computed by <span class="math">\\mathsf{Commit}</span> (on some, possibly adversarially chosen, messages) rather than chosen arbitrarily by the adversary. This notion often suffices in blockchain applications. We then sketch how our scheme achieves this notion without the restriction to algebraic adversaries.</p>

    <p class="text-gray-300">Weak binding. For every <span class="math">N</span> and every adversary running in time polynomial in <span class="math">\\lambda</span>, the probability of finding</p>

    <p class="text-gray-300"><span class="math">C,\\mathbf{m},r,(\\hat{\\pi},S,\\mathbf{m}^{*}[S])</span></p>

    <p class="text-gray-300">such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">C=\\mathsf{Commit}(\\mathbf{m};r)</span>;</li>

      <li><span class="math">\\mathsf{Verify}(C,S,\\mathbf{m}^{*}[S],\\hat{\\pi})=1</span>;</li>

      <li><span class="math">\\mathbf{m}[S]\\neq\\mathbf{m}^{*}[S]</span></li>

    </ul>

    <p class="text-gray-300">(assuming parameters generated by <span class="math">\\mathsf{Setup}(1^{\\lambda},1^{N})</span>) is negligible in <span class="math">\\lambda</span>.</p>

    <p class="text-gray-300">Realizing weak binding. To establish weak binding, it suffices to show that any efficient adversary wins the following game with negligible probability:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>challenger sends <span class="math">g^{\\alpha},\\ldots,g^{\\alpha^{N}}\\in\\mathbb{G}</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>adversary sends <span class="math">C\\in\\mathbb{G},S,\\{m^{*}_{i}\\}_{i\\in S}</span></li>

      <li>challenger sends <span class="math">t_{1},\\ldots,t_{N}\\leftarrow\\mathbb{Z}_{p}</span></li>

      <li>adversary sends <span class="math">m_{1},\\ldots,m_{N}</span></li>

    </ol>

    <p class="text-gray-300">Adversary wins if</p>

    <p class="text-gray-300"><span class="math">C=g^{\\sum\\alpha^{i}m_{i}}\\bigwedge\\sum_{i\\in S}(m_{i}-m^{<em>}_{i})t_{i}=0\\bigwedge\\exists i^{</em>}\\in S,m_{i^{<em>}}\\neq m^{</em>}_{i^{*}}</span></p>

    <p class="text-gray-300">If adversary wins game with probability <span class="math">\\epsilon</span>, then it breaks strong DH with probability <span class="math">\\epsilon^{2}/4-1/p</span>.</p>

    <p class="text-gray-300">Proof sketch. By an averaging argument, w.p. <span class="math">\\epsilon/2</span> over steps 1,2, the adversary wins with probability <span class="math">\\epsilon/2</span> over steps 3,4 (conditioned on steps 1,2). We run the adversary on steps 1,2,3,4 to get some winning <span class="math">t_{i},m_{i}</span> and then rewind steps 3,4 to get another winning <span class="math">t^{\\prime}_{i},m^{\\prime}_{i}</span>. We proceed via a case analysis:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">(m^{\\prime}_{1},\\ldots,m^{\\prime}_{N})=(m_{1},\\ldots,m_{N})</span>, then we have as before</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr_{t^{\\prime}_{1},\\ldots,t^{\\prime}_{N}}\\biggl{[}\\sum m_{i}t^{\\prime}_{i}=0\\biggr{]}\\leq 1/p</span></p>

    <p class="text-gray-300">this step uses the fact that <span class="math">t^{\\prime}_{1},\\ldots,t^{\\prime}_{N}</span> are independent of <span class="math">m_{1},\\ldots,m_{N}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">(m^{\\prime}_{1},\\ldots,m^{\\prime}_{N})\\neq(m_{1},\\ldots,m_{N})</span>, then we have</li>

    </ul>

    <p class="text-gray-300"><span class="math">g^{\\sum\\alpha^{i}(m^{\\prime}_{i}-m_{i})}=1</span></p>

    <p class="text-gray-300">This yields a non-trivial univariate polynomial equation in <span class="math">\\alpha</span>, which we can use to solve for <span class="math">\\alpha</span>.</p>

    <h2 id="sec-19" class="text-2xl font-bold">Appendix C Cross-Commitment Aggregation from Polynomial Commitments</h2>

    <p class="text-gray-300">We sketch how the recent and independent work of Boneh, Drake, Fisch, and Gabizon <em>[x1]</em> on polynomial commitments (building upon <em>[x11, x14]</em>) also yields a vector commitment that supports cross-commitment aggregation. The scheme we present below is the same as the scheme in <em>[x1, Section 3]</em> with the Fiat-Shamir transform and the following additional changes applied. First, a commitment to a polynomial <span class="math">P</span> of degree <span class="math">N-1</span> can be thought of as commitment to the vector <span class="math">(P(1),\\ldots,P(N))</span>. Second, we explicitly show both a same-commitment and a cross-commitment aggregation mechanism; that is, we show how to decompose the batch opening algorithm of <em>[x1]</em> into single openings followed by aggregation. Third, we modify the verification equation in the cross-commitment case to use independent random <span class="math">t_{j}</span> values rather than powers of a single random value <span class="math">\\gamma</span>, for consistency with our scheme (note that we could, instead, have used powers of a single random value in our scheme, too, with slight changes to the proof and exact security bounds; see <em>[x10, footnote 5]</em>).</p>

    <p class="text-gray-300">Although polynomial commitments were not initially designed for efficient updates, as pointed out to us by Gabizon <em>[x7]</em>, updates can made as efficient as in our scheme with a bit of precomputation (see the Setup and UpdateCommit algorithms below). Other efficiency parameters are comparable (up to constant factors), except VerifyAcross, which can take up to <span class="math">\\Theta(\\ell N)</span> more exponentiations depending on the exact subsets being aggregated.</p>

    <p class="text-gray-300">Unfortunately, the more efficient scheme presented in <em>[x1, Section 4]</em> does not seem to support cross-commitment aggregation, because the second element of the proof (denoted <span class="math">W^{\\prime}</span> in <em>[x1]</em>) depends on a random value that itself depends on the first element of the aggregated proof (denote <span class="math">\\pi</span> the description of AggregateAcross below and <span class="math">W</span> in <em>[x1]</em>).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Overview. Given <span class="math">\\mathbf{m}=(m_{1},\\ldots,m_{N})</span> and a subset <span class="math">S\\subseteq[N]</span>, let <span class="math">\\phi_{S}</span> is the unique polynomial of degree at most $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1<span class="math"> such that </span>\\phi_{S}(i)=m_{i}<span class="math"> for all </span>i\\in[S]<span class="math">. Let </span>\\phi=\\phi_{[N]}$. Observe that the polynomial</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\phi(X)-\\phi_{S}(X)</span></p>

    <p class="text-gray-300">evaluates to <span class="math">0</span> at all <span class="math">i\\in[S]</span>, and is therefore divisible by <span class="math">z_{S}(X):=\\prod_{j\\in S}(X-j)</span>. We will let <span class="math">\\phi(\\alpha)</span> (in the exponent) be the commitment and the fraction</p>

    <p class="text-gray-300"><span class="math">\\frac{\\phi(\\alpha)-\\phi_{S}(\\alpha)}{z_{S}(\\alpha)}</span></p>

    <p class="text-gray-300">(again, in the exponent) be the proof for <span class="math">S</span>.</p>

    <p class="text-gray-300">Same-commitment aggregation.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}(1^{\\lambda},1^{N})</span>. Samples <span class="math">\\alpha\\leftarrow\\{N+1,\\ldots,p\\}</span> and outputs</li>

    </ul>

    <p class="text-gray-300"><span class="math">(g_{1},g_{1}^{\\alpha},\\ldots,g_{1}^{\\alpha^{N-1}}),~{}(g_{2},g_{2}^{\\alpha},\\ldots,g_{2}^{\\alpha^{N-1}})</span></p>

    <p class="text-gray-300">In addition, if desired to enable fast UpdateCommit, precomputes and outputs values <span class="math">u_{i}=g_{1}^{\\phi_{i}(\\alpha)}</span> for <span class="math">i\\in[N]</span>, where <span class="math">\\phi_{i}</span> is the unique degree <span class="math">N-1</span> polynomial such that <span class="math">\\phi_{i}(i)=1</span> and <span class="math">\\phi(j)=0</span> for all <span class="math">j\\in[N]-\\{i\\}</span>. This one-time precomputation can be done easily in time <span class="math">O(N^{2})</span>; it can also be done in time <span class="math">O(N\\log N)</span> using Fast Fourier Transform (FFT). It is faster if <span class="math">\\alpha</span> is available, but can be done with just <span class="math">\\mathsf{pp}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Commit}(\\mathbf{m})</span>. Outputs</li>

    </ul>

    <p class="text-gray-300"><span class="math">C:=g_{1}^{\\phi(\\alpha)}</span></p>

    <p class="text-gray-300">where <span class="math">\\phi</span> is the unique degree <span class="math">N-1</span> polynomial such that <span class="math">\\phi(i)=m_{i}</span> for all <span class="math">i\\in[N]</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{UpdateCommit}(C,S,\\mathbf{m}[S],\\mathbf{m}^{\\prime}[S])</span>. Outputs</li>

    </ul>

    <p class="text-gray-300"><span class="math">C^{\\prime}:=C\\cdot\\prod_{i\\in S}u_{i}^{m_{i}^{\\prime}-m_{i}}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Prove}(i,\\mathbf{m})</span>. Outputs</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\pi_{i}:=g_{1}^{\\frac{\\phi(\\alpha)-m_{i}}{\\alpha-i}}</span></p>

    <p class="text-gray-300">where <span class="math">\\phi</span> is the same as for Commit.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Aggregate}(C,S,\\mathbf{m}[S],\\{\\pi_{i}:i\\in S\\})</span>. Outputs</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\hat{\\pi}:=\\prod_{i\\in S}\\pi_{i}^{\\lambda_{i}}</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">\\lambda_{i}:=\\prod_{j\\in S\\setminus\\{i\\}}\\frac{1}{i-j}</span></p>

    <p class="text-gray-300">are the Langrangian coefficients (see Proof of Correctness, below, for an explanation).</p>

    <p class="text-gray-300"><span class="math">\\operatorname{Verify}(C,S,\\mathbf{m}[S],\\hat{\\pi})</span>. Checks that</p>

    <p class="text-gray-300"><span class="math">e\\left(C\\cdot g_{1}^{-\\phi_{S}(\\alpha)},g_{2}\\right)\\stackrel{{\\scriptstyle?}}{{=}}e\\left(\\hat{\\pi},g_{2}^{\\prod_{i\\in S}(\\alpha-i)}\\right)</span></p>

    <p class="text-gray-300">Cross-commitment aggregation. We describe the following additional algorithms:</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">AggregateAcross(<span class="math">\\{\\,C_{j},S_{j},\\mathbf{m}_{j}[S_{j}],\\hat{\\pi}_{j}\\,\\}_{j\\in[\\ell]}</span>).</h6>

    <p class="text-gray-300">Outputs</p>

    <p class="text-gray-300"><span class="math">\\pi:=\\prod_{j=1}^{\\ell}\\hat{\\pi}_{j}^{t_{j}}\\,,</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">t_{j}=H(j,\\{C_{j},S_{j},\\mathbf{m}_{j}[S_{j}]\\}_{j\\in[\\ell]})\\,.</span></p>

    <h6 id="sec-21" class="text-base font-medium mt-4">VerifyAcross(<span class="math">\\{\\,C_{j},S_{j},\\mathbf{m}_{j}[S_{j}]\\,\\}_{j\\in[\\ell]},\\pi</span>).</h6>

    <p class="text-gray-300">Checks that</p>

    <p class="text-gray-300"><span class="math">\\prod_{j}e\\left(C_{j}\\cdot g_{1}^{-\\phi_{j,S_{j}}(\\alpha)},g_{2}^{t_{j}\\cdot z_{T\\setminus S_{j}}(\\alpha)}\\right)\\stackrel{{\\scriptstyle?}}{{=}}e\\left(\\pi,g_{2}^{z_{T}(\\alpha)}\\right)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">T=\\cup_{j}S_{j}</span> and <span class="math">\\phi_{j,S}</span> is the unique degree $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1<span class="math"> polynomial such that </span>\\phi_{j,S}(i)=m_{j,i}<span class="math"> for all </span>i\\in[S]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof of correctness. Recall the definition <span class="math">z_{S}(X)=\\prod_{j\\in S}(X-j)</span> and observe that <span class="math">\\lambda_{i}=1/z_{S\\setminus\\{i\\}}(i)</span>. We claim that <span class="math">\\hat{\\pi}</span> output by Aggregate is equal to</p>

    <p class="text-gray-300"><span class="math">g_{1}^{\\frac{\\phi(\\alpha)-\\phi_{S}(\\alpha)}{z_{S}(\\alpha)}}</span></p>

    <p class="text-gray-300">This claim immediately shows the correctness of Verify, because both sides, by bilinearity, are equal to <span class="math">g_{T}^{\\phi(\\alpha)-\\phi_{S}(\\alpha)}</span>.</p>

    <p class="text-gray-300">The claim follows from the following relation:</p>

    <p class="text-gray-300"><span class="math">\\sum_{i\\in S}\\lambda_{i}\\cdot\\frac{\\phi(X)-m_{i}}{X-i}=\\frac{\\phi(X)-\\phi_{S}(X)}{z_{S}(X)}\\,.</span></p>

    <p class="text-gray-300">The relation can be shown by the following two steps. First,</p>

    <p class="text-gray-300"><span class="math">\\sum_{i\\in S}\\lambda_{i}\\cdot\\frac{1}{X-i}=\\frac{1}{z_{S}(X)}\\,,</span></p>

    <p class="text-gray-300">which is true because, when we bring the fractions to a common denominator, we obtain</p>

    <p class="text-gray-300"><span class="math">\\sum_{i\\in S}\\lambda_{i}\\cdot\\frac{1}{X-i}=\\frac{\\sum_{i\\in S}\\lambda_{i}\\cdot z_{S\\setminus\\{i\\}}(X)}{z_{S}(X)}\\,,</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and the numerator of the right-hand side is a polynomial of degree at most $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1<span class="math"> that evaluates to 1 at all </span>i\\in S$ and therefore must be the constant 1. Second,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\sum_{i\\in S}\\lambda_{i}\\cdot\\frac{m_{i}}{X-i}=\\frac{\\phi_{S}(X)}{z_{S}(X)}\\,,</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300">which is true because</p>

    <p class="text-gray-300"><span class="math">\\sum_{i\\in S}\\lambda_{i}\\cdot\\frac{m_{i}}{X-i}=\\frac{\\sum_{i}\\lambda_{i}\\cdot m_{i}\\cdot z_{S\\setminus\\{i\\}}(X)}{z_{S}(X)}\\,,</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and the numerator of the right-hand side is a polynomial of degree at most $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1<span class="math"> that evaluates to </span>m_{i}<span class="math"> at all </span>i\\in S<span class="math"> and therefore must be the constant </span>\\phi_{S}(X)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For the correctness of VerifyAcross, observe that we can obtain the verification equation by (1) raising the <span class="math">\\mathbb{G}_{2}</span> element on both sides of the <span class="math">j</span>th-commitment verification equation to the power <span class="math">z_{T\\setminus S_{j}}(\\alpha)</span>; (2) raising the <span class="math">\\mathbb{G}_{2}</span> element on the left-hand side and the <span class="math">\\mathbb{G}_{1}</span> element on the right-hand side of each resulting equation to the power <span class="math">t_{j}</span>; (3) multiplying all <span class="math">\\ell</span> resulting equations together.</p>

    <p class="text-gray-300">Proof of binding. Binding holds under a <span class="math">q</span>-type assumption in the AGM+ROM model as shown in <em>[x1, Section 3]</em>.</p>

    <p class="text-gray-300">##</p>`;
---

<BaseLayout title="Pointproofs: Aggregating Proofs for Multiple Vector Commitme... (2020/419)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/419
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
