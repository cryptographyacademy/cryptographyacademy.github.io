---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2024/886';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'A New Security Evaluation Method Based on Resultant for Arithmetic-Oriented Algorithms';
const AUTHORS_HTML = 'Hong-Sen Yang, Qun-Xiong Zheng, Jing Yang, Quan-feng Liu, Deng Tang';

const CONTENT = `    <p class="text-gray-300">Hong-Sen Yang<span class="math">^{1}</span>, Qun-Xiong Zheng<span class="math">^{1(\\text{SS})}</span>, Jing Yang<span class="math">^{1(\\text{SS})}</span>, Quan-Feng Liu<span class="math">^{1}</span>, and Deng Tang<span class="math">^{2(\\text{SS})}</span></p>

    <p class="text-gray-300"><span class="math">^{1}</span> Information Engineering University, Zhengzhou 450001, China moonlight0833@outlook.com qunxiong_zheng@163.com yangjingfi@163.com liuquanfeng1022@163.com</p>

    <p class="text-gray-300"><span class="math">^{2}</span> Shanghai Jiao Tong University, Shanghai 200240, China dengtang@sjtu.edu.cn</p>

    <p class="text-gray-300">Abstract. The rapid development of advanced cryptographic applications like multi-party computation (MPC), fully homomorphic encryption (FHE), and zero-knowledge (ZK) proofs have motivated the designs of the so-called arithmetic-oriented (AO) primitives. Efficient AO primitives typically build over large fields and use large S-boxes. Such design philosophy brings difficulties in the cryptanalysis of these primitives as classical cryptanalysis methods do not apply well. The generally recognized attacks against these primitives are algebraic attacks, especially Gröbner basis attacks. Thus, the numbers of security rounds are usually derived through the complexity of solving the system of algebraic equations using Gröbner bases. In this paper, we propose a novel framework for algebraic attacks against AO primitives. Instead of using Gröbner basis, we use <em>resultants</em> to solve a system of multivariate equations that can better exploit the algebraic structures of AO primitives. We employ several techniques to reduce the dimensions of the resultants and avoid rapid increases in degrees, including start-from-the-middle modeling, variable substitutions, and fast Lagrange interpolation. We apply our attack to three mainstream AO cryptographic primitives: Rescue-Prime, Anemoi, and Jarvis. For Rescue-Prime, we theoretically prove that the final univariate equation has a degree of at most a specific power of three and practically attack five rounds for the first time. We attack the full-round Anemoi with complexity <span class="math">2^{110.10}</span>, which has been claimed to provide 127 bits of security. We also give the first practical attack against eight rounds of Anemoi over a 55-bit prime field. For Jarvis, we improve the existing practical attack of six rounds by a factor of 100 and practically attack eight rounds for the first time. Therefore, we point out that our analysis framework can be used as a new evaluation method for AO designs.</p>

    <p class="text-gray-300">Keywords: Resultant- arithmetic-oriented primitives <span class="math">\\cdot</span> Rescue-Prime <span class="math">\\cdot</span> Anemoi <span class="math">\\cdot</span> Jarvis <span class="math">\\cdot</span> new evaluation method.</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">In recent years, with multi-party computation (MPC), fully homomorphic encryption (FHE), zero-knowledge (ZK) proofs, and other privacy computing techniques having been applied on the ground, many underlying privacy computing-friendly symmetric cryptographic primitives have emerged. While traditional symmetric ciphers like AES <em>[24]</em> and SHA-3 <em>[18]</em> are often designed and optimized for efficient software or hardware implementations, these constructions, usually referred to as arithmetic-oriented (AO), mainly focus on minimizing the number of non-linear arithmetic operations <em>[23]</em>. This is because non-linear operations pose the largest performance bottleneck in those advanced protocols, while linear computations are much cheaper compared to the former.</p>

    <p class="text-gray-300">Till now, quite a few AO primitives have been proposed. LowMC <em>[3]</em> and MiMC <em>[1]</em> can be regarded as the first generation of AO primitives. LowMC uses partial S-box layers while MiMC works over large fields to decrease the number of multiplications. In July 2018, the Ethereum Foundation gave StarkWare a 2-year milestone-based grant to select a STARK-friendly hash (SFH) function <em>[9]</em>. STARK is one of the most efficient and recognized ZK proof systems. Two families of primitives received much attention in the evaluation, which are: MARVELlous – a family that includes Jarvis <em>[5]</em>, Vision (over the binary field), Pepper, and Rescue (over prime fields) <em>[4]</em>; and HadesMiMC – a family that includes Starkad (over the binary field) and Poseidon (over prime fields) <em>[22]</em>.</p>

    <p class="text-gray-300">After the evaluation of security and efficiency, Rescue_{122} was recommended as the SFH candidate for standardization by the Ethereum Foundation. Several other AO primitives have been proposed afterwards, e.g., Ciminion <em>[17]</em> and Anemoi <em>[11]</em>. Most of these primitives are constructed over <span class="math">\\mathbb{F}_{p}</span> (<span class="math">p</span> is typically a large prime number) to be consistent with many MPC/FHE/ZK-protocols that natively support operations in <span class="math">\\mathbb{F}_{p}</span> to improve implementation performance. To reduce the computation overhead of nonlinear operations, many AO primitives use low-degree round functions. This introduces the most significant difference to classical symmetric ciphers that these AO primitives typically work with large S-boxes over the whole states instead of individual bytes or cells.</p>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">Cryptanalysis</h4>

    <p class="text-gray-300">Compared to the wide attention in the design of efficient AO primitives, the security analysis methods of these primitives are not mature. Classical cryptanalysis techniques, like linear and differential cryptanalysis, do not apply well to these primitives due to the adoption of large prime fields and S-boxes. To better understand the security of AO hash functions, in November 2021, Ethereum foundation initiated bounties rewarding the best practical attacks against four round-reduced AO hash functions. These four hash functions are all sponge-based, which are Reinforced Concrete <em>[21]</em>, Feistel–MiMC <em>[1]</em>, Poseidon <em>[22]</em>, and Rescue-Prime <em>[27]</em>.</p>

    <p class="text-gray-300">The security of AO primitives typically relies on the hardness of solving the constrained-input constrained-output (CICO) problem. Due to their native algebraic properties, algebraic attacks typically outperform other known cryptanalytic techniques against AO primitives. One example is the Gröbner basis attacks, which model the underlying primitive as a system of multivariate equations and solve it using off-the-shelf Gröbner basis algorithms. For instance, Gröbner basis attacks against Jarvis and Friday <em>[5]</em> were presented in <em>[2]</em>, illustrating that AO primitives for MPC/FHE/ZK applications may be particularly vulnerable to algebraic attacks. The authors proposed a smart way of constructing equations that made the solving step much more efficient than initially thought and further broke the security claim of Jarvis. Therefore, the number and quality of constructed equations greatly influence the attack complexity. For some AO primitives based on the Substitution-Permutation Network (SPN) structure, authors in <em>[8]</em> proposed a technique that can remove all the equation modeling of the first two layers of S-boxes. Such a technique is used to analyze the security of the four AO hash functions considered in the Ethereum Foundation challenge. Recently, a new type of algebraic attack named FreeLunch was proposed in <em>[7]</em>, which chose the monomial ordering so that the natural polynomial system encoding the CICO problem is already a Gröbner basis. The authors claimed that the FreeLunch approach challenges the security of full-round instances of Anemoi <em>[11]</em>, Arion <em>[25]</em>, and Griffin <em>[20]</em>. Other algebraic attacks include integral attacks against GMiMC and HadesMiMC <em>[10]</em>, higher order differential cryptanalysis of Ciminion <em>[28]</em>, etc.</p>

    <p class="text-gray-300">Contributions. Since the Gröbner basis algorithms are generic solving methods that usually ignore some specific algebraic properties of a cryptographic primitive, using them to evaluate the attack complexities may overestimate the security of a certain primitive. In this paper, we propose a new analysis framework for algebraic attacks against typical AO primitives, which makes full use of the algebraic properties and employs the resultant tool to solve the system of multivariate equations. Compared to Gröbner basis attacks, our attack is much more efficient and accurate. Table 1 presents a comparison of our algebraic attacks with existing ones on three AO primitives, where the theoretical complexities are measured by numbers of basic arithmetic operations in a finite field. Our main contributions are as below.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We develop a novel analysis framework for analyzing the security of AO primitives. We note that typical AO primitives have special algebraic structures that are not considered in Gröbner basis attacks. We make full use of such algebraic structures and propose to use the resultant to solve the system of multivariate equations. To avoid a rapid increase in the degrees of variables when computing the resultants, we propose the substitution theory to deal with the non-linear operations, and the dimensions of the resultants are much reduced. Such substitutions also enable us to accurately estimate the degrees of variables and equations, thus the estimation of the attack complexity is much more accurate than that in Gröbner basis attacks. We</li>

    </ol>

    <p class="text-gray-300">also propose to use the start-from-the-middle (SFTM) modeling technique to further simplify the resultants and use fast Lagrange interpolation to parallelize the computation. Therefore, our algebraic attack is a comprehensive analysis framework that is much more efficient than existing ones. Besides, the path of variable elimination is quite clear compared to that when using Gröbner bases, which helps to better understand the security of an AO primitive. We think the analysis framework can be used as an efficient evaluation method for new AO designs.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We apply the new analysis framework and techniques to the AO primitive Rescue-Prime. We propose the cubic substitution theory for Rescue-Prime and theoretically prove that the final univariate equation has a degree of at most a specific power of three. With the cubic substitution theory, we can control the degree of the equation at each step and give a more accurate security evaluation of Rescue-Prime. We find a 5-round collision which was originally thought to be “hard” in the Ethereum Foundation challenge. We also achieve a 100-fold increase in finding the 4-round collision of Rescue-Prime over the results in <em>[8]</em>.</li>

      <li>We attack the full-round of an specific instantiation of Anemoi with complexity <span class="math">2^{110.10}</span>, while the version is claimed to provide 127 bits of security. We also provide an practical attack against 7-round Anemoi which improves the best-known practical attack by a factor of fifty <em>[7]</em>. Moreover, we propose a practical attack against eight rounds for the first time.</li>

      <li>We further apply our attack to six rounds of Jarvis and provide a 100-fold increase in practically solving the equation system compared to the results in <em>[2]</em>. Moreover, we practically attack eight rounds of Jarvis for the first time.</li>

    </ol>

    <p class="text-gray-300">Organization. We start by introducing the necessary mathematical background and security definitions in Sect.2. In Sect.3, we give an introduction to Rescue-Prime and review the work in <em>[8]</em>. We propose our analysis framework and instantiate it on Rescue-Prime in detail in Sect.4. After that, we apply our attack to Anemoi and Jarvis in Sect.5 and Sect.6, respectively. We finally conclude the paper in Sect.7 by discussing some shortcomings and potential improvements in the current design of AO primitives.</p>

    <h2 id="sec-3" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}_{q}</span> be the finite field with <span class="math">q</span> elements and <span class="math">\\mathbb{F}_{q}[x_{1},x_{2},\\ldots,x_{s}]</span> the polynomial ring over <span class="math">\\mathbb{F}_{q}</span> with indeterminates <span class="math">x_{1},x_{2},\\ldots,x_{s}</span>, where <span class="math">q</span> is a prime power and <span class="math">s</span> is a positive integer. Any polynomial <span class="math">f(x_{1},x_{2},\\ldots,x_{s})\\in\\mathbb{F}_{q}[x_{1},x_{2},\\ldots,x_{s}]</span> can be represented in the form</p>

    <p class="text-gray-300"><span class="math">f(x_{1},x_{2},\\ldots,x_{s})=\\sum_{(k_{1},k_{2},\\ldots,k_{s})\\in K}c_{k_{1},k_{2},\\ldots,k_{s}}x_{1}^{k_{1}}x_{2}^{k_{2}}\\cdots x_{s}^{k_{s}},</span></p>

    <p class="text-gray-300">where <span class="math">K</span> is a set of finitely many <span class="math">s</span>-tuples <span class="math">(k_{1},k_{2},\\ldots,k_{s})</span> of nonnegative integers and <span class="math">c_{k_{1},k_{2},\\ldots,k_{s}}\\in\\mathbb{F}_{q}</span>. If <span class="math">c_{k_{1},k_{2},\\ldots,k_{s}}\\neq 0</span>, then <span class="math">x_{1}^{k_{1}}x_{2}^{k_{2}}\\cdots x_{s}^{k_{s}}</span> is called a term of <span class="math">f</span></p>

    <p class="text-gray-300">Table 1: Comparison of the algebraic attacks against Rescue-Prime, Anemoi, and JARVIS</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Primitives</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Attacked rounds</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Running time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theoretical Complexities*</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">References</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Rescue-Prime</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">258500s</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">[8]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">885.5s</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">Sect.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">255</td>

            <td class="px-3 py-2 border-b border-gray-700">[8]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ one day</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">Sect.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">259.96</td>

            <td class="px-3 py-2 border-b border-gray-700">Sect.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Anemoi</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">167201s</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">[7]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">2968.55s</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">Sect.5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">10575.61s**</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">[12]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">38749.182s</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">Sect.5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">2118</td>

            <td class="px-3 py-2 border-b border-gray-700">[7]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">2110.10</td>

            <td class="px-3 py-2 border-b border-gray-700">Sect.5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">JARVIS</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">99989s</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">[2]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">368.96s</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">Sect.6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">455650.53s</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">Sect.6</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The unit of complexities throughout the paper is one basic arithmetic operation in a finite field.</li>

    </ul>

    <p class="text-gray-300">** The practical attack was performed over  <span class="math">\\mathbb{F}_{2^{16} + 1}</span>  in [12], while our attacks are performed over the same 55-bit prime field as that in [7].</p>

    <p class="text-gray-300">and its degree is  <span class="math">k_{1} + k_{2} + \\dots + k_{s}</span> . The set of all terms of  <span class="math">f</span>  is denoted by  <span class="math">T(f)</span> . For  <span class="math">f \\neq 0</span> , the degree of  <span class="math">f</span> , denoted by  <span class="math">\\deg(f)</span> , is the maximum of the degrees of the terms of  <span class="math">f</span> , that is,</p>

    <div class="my-4 text-center"><span class="math-block">\\deg \\left(f\\right) = \\max  \\left\\{\\sum_ {j = 1} ^ {s} k _ {j} \\mid x _ {1} ^ {k _ {1}} x _ {2} ^ {k _ {2}} \\dots x _ {s} ^ {k _ {s}} \\in T (f) \\right\\}.</span></div>

    <p class="text-gray-300">The so-called CICO (constrained-input constrained-output) problem, which is usually used to evaluate the security of AO algorithms, is defined as below.</p>

    <p class="text-gray-300">Definition 1 (CICO problem). Let  <span class="math">s &amp;gt; 1</span>  be an integer and  <span class="math">u</span>  a given positive integer smaller than  <span class="math">s</span> . Let  <span class="math">F\\colon \\mathbb{F}_q^s\\to \\mathbb{F}_q^s</span>  be a permutation. The CICO problem of  <span class="math">F</span>  is to find a vector  <span class="math">(x_{1},\\ldots ,x_{s - u},y_{1},\\ldots ,y_{s - u})\\in \\mathbb{F}_{q}^{2(s - u)}</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">F \\left(x _ {1}, \\ldots , x _ {s - u}, \\underbrace {0 , \\ldots , 0} _ {u}\\right) = \\left(y _ {1}, \\ldots , y _ {s - u}, \\underbrace {0 , \\ldots , 0} _ {u}\\right).</span></div>

    <h2 id="sec-5" class="text-2xl font-bold">2.2 Resultant</h2>

    <p class="text-gray-300">The resultant is a powerful tool for solving systems of polynomial equations. As it will be seen in Sect.4–6, the polynomial equations modeled in algebraic attacks against AO algorithms (such as Rescue-Prime, Anemoi, and JARVIS) are particularly suitable to be solved through the resultant-based method. Compared with the Gröbner basis method, using resultants tends to give a more precise estimation of the time complexity.</p>

    <p class="text-gray-300"><strong>Definition 2 (Resultant).</strong> Let <span class="math">f(\\pmb{x}, y), g(\\pmb{x}, y) \\in \\mathbb{F}_q[\\pmb{x}, y]</span> with <span class="math">\\pmb{x} = (x_1, \\dots, x_s)</span>. The resultant of <span class="math">f(\\pmb{x}, y)</span> and <span class="math">g(\\pmb{x}, y)</span> with respect to the indeterminant <span class="math">y</span>, denoted by <span class="math">R(f, g, y)</span>, is defined as the determinant of the Sylvester matrix of <span class="math">f(\\pmb{x}, y)</span> and <span class="math">g(\\pmb{x}, y)</span> when considered as polynomials in the single indeterminate <span class="math">y</span>. That is, if <span class="math">f(\\pmb{x}, y) = \\sum_{i=0}^{m} f_i y^i</span> and <span class="math">g(\\pmb{x}, y) = \\sum_{i=0}^{n} g_i y^i</span>, where <span class="math">f_i, g_i \\in \\mathbb{F}_q[\\pmb{x}]</span>, then</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R(f, g, y) = \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{cccccc}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">f_m &amp; f_{m-1} &amp; \\cdots &amp; f_0 &amp; &amp; &amp; \\\\ &amp; f_m &amp; f_{m-1} &amp; \\cdots &amp; f_0 &amp; &amp; \\\\ &amp; &amp; \\ddots &amp; \\ddots &amp; \\ddots &amp; \\ddots &amp; \\\\ &amp; &amp; &amp; \\ddots &amp; \\ddots &amp; \\ddots &amp; \\ddots \\\\ &amp; &amp; &amp; &amp; f_m &amp; f_{m-1} &amp; \\cdots &amp; f_0 \\\\ g_n &amp; g_{n-1} &amp; \\cdots &amp; \\cdots &amp; g_0 &amp; &amp; \\\\ &amp; g_n &amp; g_{n-1} &amp; \\cdots &amp; \\cdots &amp; g_0 &amp; \\\\ &amp; &amp; \\ddots &amp; \\ddots &amp; \\ddots &amp; \\ddots &amp; \\ddots \\\\ &amp; &amp; &amp; &amp; g_n &amp; g_{n-1} &amp; \\cdots &amp; \\cdots &amp; g_0</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\end{array} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">It is well-known that the resultant is non-zero if and only if the two polynomials are algebraically independent. In this case, the resultant yields a new polynomial <span class="math">h(\\pmb{x})</span>, such that if <span class="math">(\\pmb{x_0}, y_0)</span> is a root of both <span class="math">f(\\pmb{x}, y)</span> and <span class="math">g(\\pmb{x}, y)</span>, then <span class="math">h(\\pmb{x_0}) = 0</span>. In this way, we can remove one variable from two polynomials while retaining information about the roots of the original polynomials. Given <span class="math">\\ell</span> polynomials in <span class="math">s</span> variables, we can repeatedly compute resultants of the polynomials until we get a univariate polynomial. Solving for the roots of that polynomial and repeatedly substituting them back, we can derive the roots that the polynomials have in common.</p>

    <p class="text-gray-300">The computation of a resultant involves multiplications of multivariate polynomials over <span class="math">\\mathbb{F}_q</span>. Lemma 1 can be used to give an estimation of the running time of the resultant-based method, of which the proof is omitted as it is clearly true.</p>

    <p class="text-gray-300"><strong>Lemma 1.</strong> Let <span class="math">f, g \\in \\mathbb{F}_q[x_1, x_2, \\ldots, x_s]</span> with</p>

    <div class="my-4 text-center"><span class="math-block">f = \\sum_{\\substack{0\\leq i_{u}\\leq n_{u}\\\\ u = 1,2,\\ldots ,s}}a_{i_{1},i_{2},\\ldots ,i_{s}}x_{1}^{i_{1}}x_{2}^{i_{2}}\\dots x_{s}^{i_{s}}, \\quad g = \\sum_{\\substack{0\\leq j_{u}\\leq m_{u}\\\\ u = 1,2,\\ldots ,s}}b_{j_{1},j_{2},\\ldots ,j_{s}}x_{1}^{j_{1}}x_{2}^{j_{2}}\\dots x_{s}^{j_{s}},</span></div>

    <p class="text-gray-300"><span class="math">n_{1},n_{2},\\ldots,n_{s}</span> and <span class="math">m_{1},m_{2},\\ldots,m_{s}</span> are positive integers. Then the multiplication <span class="math">fg</span> can be computed in <span class="math">\\mathcal{O}\\left(d_{1}d_{2}\\right)</span> field operations, where <span class="math">d_{1}=\\prod_{u=1}^{s}(n_{u}+1)</span> and <span class="math">d_{2}=\\prod_{u=1}^{s}(m_{u}+1)</span>.</p>

    <p class="text-gray-300">It can be easily seen that when using the resultant-based method to solve a system of multivariate equations, each time we eliminate a variable by computing a resultant, the degrees of other variables will increase. Repeatedly computing resultants of the polynomials, we will finally get two polynomials, say <span class="math">f(x,y)</span> and <span class="math">g(x,y)</span>. The degrees of <span class="math">x</span> and <span class="math">y</span> in <span class="math">f(x,y)</span> and <span class="math">g(x,y)</span> will inevitably be very high, especially when attacking a high-round AO algorithm. To get a univariate polynomial, one can directly compute the resultant <span class="math">R(f,g,y)</span> of <span class="math">f(x,y)</span> and <span class="math">g(x,y)</span>. However, the degree of <span class="math">x</span> may become extremely high, which introduces unaffordable memory consumption in practical attacks. To solve that, we propose to use Lagrange interpolation to compute <span class="math">R(f,g,y)</span>, which also enables parallelization. We note that an upper bound on the degree of <span class="math">x</span> in <span class="math">R(f,g,y)</span> can always be estimated in advance.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">2.3 Fast Lagrange interpolation</h3>

    <p class="text-gray-300">Using interpolation to compute polynomial resultants was suggested by Collins <em>[14]</em>. We now give a brief introduction to fast Lagrange interpolation based on fast multi-point evaluation. For more details, we refer to <em>[19, Chapter 10]</em>.</p>

    <p class="text-gray-300">Let <span class="math">R(x)</span> be a given but unknown polynomial of degree less than <span class="math">n</span> over <span class="math">\\mathbb{F}_{q}</span>. Let <span class="math">u_{0},u_{1},\\ldots,u_{n-1}</span> be <span class="math">n</span> distinct elements over <span class="math">\\mathbb{F}_{q}</span> and <span class="math">v_{0},v_{1},\\ldots,v_{n-1}\\in\\mathbb{F}_{q}</span> satisfying that <span class="math">R(u_{i})=v_{i}</span> for <span class="math">i\\in\\{0,1,\\ldots,n-1\\}</span>. Then <span class="math">R(x)</span> can be uniquely determined by the Lagrange interpolation formula as below</p>

    <p class="text-gray-300"><span class="math">R(x)=\\sum_{i=0}^{n-1}v_{i}\\cdot\\prod_{j=0,j\\neq i}^{n-1}\\frac{x-u_{j}}{u_{i}-u_{j}}.</span></p>

    <p class="text-gray-300">Furthermore, let <span class="math">s_{i}=\\prod_{j=0,j\\neq i}^{n-1}\\frac{1}{u_{i}-u_{j}}</span> for <span class="math">i\\in\\{0,1,\\ldots,n-1\\}</span>, then <span class="math">R(x)</span> can be rewritten as</p>

    <p class="text-gray-300"><span class="math">R(x)=\\sum_{i=0}^{n-1}v_{i}s_{i}\\cdot\\prod_{j=0,j\\neq i}^{n-1}(x-u_{j}).</span></p>

    <p class="text-gray-300">Let <span class="math">M(x)=\\prod_{j=0}^{n-1}(x-u_{j})</span>, then it is clear that <span class="math">M^{\\prime}(u_{i})=1/s_{i}</span> for <span class="math">i\\in\\{0,1,\\ldots,n-1\\}</span>, where <span class="math">M^{\\prime}(x)</span> is the derivative of <span class="math">M(x)</span>. Using a fast multi-point evaluation algorithm (see <em>[19, Section 10.1]</em>), <span class="math">s_{0},s_{1},\\ldots,s_{n-1}</span> can be computed in <span class="math">\\mathcal{O}(n\\log n)</span> operations over <span class="math">\\mathbb{F}_{q}</span>, we call this step the precomputation process. Finally, with a divide-and-conquer strategy (see <em>[19, Section 10.2]</em>), <span class="math">R(x)</span> can be computed in <span class="math">\\mathcal{O}(n\\log n)</span> operations over <span class="math">\\mathbb{F}_{q}</span>.</p>

    <p class="text-gray-300">Now we go back to see how we compute <span class="math">R(f,g,y)</span> in Sect.2.2 using the fast Lagrange interpolation. Let <span class="math">f(x,y),g(x,y)</span> be as defined in Sect.2.2 and let <span class="math">R(x)=R(f,g,y)\\in\\mathbb{F}_{q}[x]</span> where the degree of <span class="math">R(x)</span> is less than <span class="math">n</span>. We first choose <span class="math">n</span> distinct elements <span class="math">u_{0},u_{1},\\ldots,u_{n-1}\\in\\mathbb{F}_{q}</span> and compute the polynomials</p>

    <p class="text-gray-300"><span class="math">f(u_{0},y),f(u_{1},y),\\ldots,f(u_{n-1},y)</span> and <span class="math">g(u_{0},y),g(u_{1},y),\\ldots,g(u_{n-1},y)</span> in parallel. Afterwards, we compute the values <span class="math">R(u_{0}),R(u_{1}),\\ldots,R(u_{n-1})</span> with the definition of resultant. Finally, we compute <span class="math">R(x)</span> using the fast Lagrange interpolation with <span class="math">u_{0},u_{1},\\ldots,u_{n-1}</span> and <span class="math">R(u_{0}),R(u_{1}),\\ldots,R(u_{n-1})</span>.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.4 Finding Roots of Univariate Polynomials over <span class="math">\\mathbb{F}_{q}</span></h3>

    <p class="text-gray-300">Finding roots of univariate polynomials over <span class="math">\\mathbb{F}_{q}</span> plays a crucial role in solving a system of multivariate polynomials over <span class="math">\\mathbb{F}_{q}</span> with the resultant-based method. The authors in <em>[8]</em> showed that the roots of a univariate polynomial <span class="math">R(x)\\in\\mathbb{F}_{q}[x]</span> can be found in <span class="math">\\mathcal{O}(d\\log(d)(\\log(d)+\\log(q))\\log(\\log(d)))</span> field operations, provided that the multiplication of two univariate polynomials of degree <span class="math">d</span> over <span class="math">\\mathbb{F}_{q}</span> can be done in <span class="math">\\mathcal{O}(d\\log(d)\\ \\log(\\log(d)))</span> field operations using an FFT (Fast Fourier Transform) algorithm. The process consists of three main steps.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">Q(x)=x^{q}-x\\mod R(x)</span>. The complexity of this step mainly lies in computing <span class="math">x^{q}\\mod R(x)</span>, which requires <span class="math">\\mathcal{O}(d\\log(d)\\log(q)\\log(\\log(d)))</span> field operations using a double-and-add algorithm.</li>

      <li>Compute <span class="math">P(x)=\\gcd(R(x),Q(x))</span>. This step requires <span class="math">\\mathcal{O}(d\\log^{2}(d)\\log(\\log(d)))</span> field operations.</li>

      <li>Factor <span class="math">P(x)</span>. The complexity of this step is negligible since <span class="math">P(x)</span> is of degree one or two in general.</li>

    </ol>

    <p class="text-gray-300">By using a fast gcd algorithm called half-gcd (see <em>[19, Section 11.1]</em>), the complexity of the second step can be reduced to <span class="math">\\mathcal{O}(d\\log^{2}(d))</span>. Then the complexity of finding roots of univariate polynomials over <span class="math">\\mathbb{F}_{q}</span> can be reduced to <span class="math">\\mathcal{O}(d\\log(d)(\\log(d)+\\log(q)\\log(\\log(d))))</span> field operations.</p>

    <h2 id="sec-8" class="text-2xl font-bold">3 Review of Rescue-Prime and a recent algebraic attack</h2>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">3.1 Description of Rescue-Prime</h3>

    <p class="text-gray-300">Rescue-Prime <em>[27]</em> is a family of AO hash functions of which the round function is shown in Fig.1, where <span class="math">x_{2i},y_{2i},\\ldots</span> and <span class="math">x_{2i+2},y_{2i+2},\\ldots</span> are the inputs and outputs of the <span class="math">i</span>-th round, respectively. Each round of Rescue-Prime consists of two similar steps: the first step involves low-degree S-box <span class="math">S</span>, an MDS (Maximum Distance Separable) matrix <span class="math">M</span>, and the addition of the round constants AddC; the second step differs in replacing <span class="math">S</span> by <span class="math">S^{-1}</span> and using other round constants. There is an additional AddC operation before the first round. Denote <span class="math">t</span> the number of S-boxes involved in each step. The challenges from the Ethereum Foundation use <span class="math">t=3</span> or <span class="math">t=2</span> and <span class="math">S:x\\mapsto x^{3}</span> (and so <span class="math">S^{-1}:x\\mapsto x^{1/3}</span>). Let <span class="math">F:\\mathbb{F}_{q}^{3}\\to\\mathbb{F}_{q}^{3}</span> be the permutation representing the <span class="math">r</span>-round Rescue-Prime, the challenge initiated by the Ethereum Foundation for Rescue-Prime with <span class="math">t=3</span> is to find two pairs <span class="math">\\left(X_{1},X_{2}\\right),\\left(Y_{1},Y_{2}\\right)\\in\\mathbb{F}_{q}^{2}</span> satisfying <span class="math">F(X_{1},X_{2},0)=(Y_{1},Y_{2},0)</span>. In this paper, we mainly focus on <span class="math">t=3</span>.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1: The  <span class="math">i</span> -th round function of Rescue-Prime</p>

    <p class="text-gray-300">The authors of [8] introduce a smart technique to bypass the first two layers of S-boxes (two steps) of Rescue-Prime with little or even no overhead. We now give a brief review of this work.</p>

    <p class="text-gray-300">Construction of equations. There are  <span class="math">2r</span>  steps for solving the CICO problem of a  <span class="math">r</span> -round Rescue-Prime, which are referred to as the 0-th step, the 1-th step, ..., the  <span class="math">(2r - 1)</span> -th step. Since the MDS matrix is the same in each step, it can be uniformly denoted by  <span class="math">M</span> . Let  <span class="math">AddC_k</span>  be the addition of the round constants in the  <span class="math">k</span> -th step and  <span class="math">L_k = AddC_k \\circ M</span>  be the composition of  <span class="math">M</span>  and  <span class="math">AddC_k</span> , where  <span class="math">0 \\leq k \\leq 2r - 1</span> . Let  <span class="math">L_{k,j}</span>  be the  <span class="math">j</span> -th output of  <span class="math">L_k</span>  with  <span class="math">0 \\leq j \\leq t - 1</span> . Since  <span class="math">S^{-1}</span>  and  <span class="math">S</span>  have high degrees in the forward and backward directions, respectively, some intermediate variables can be introduced to build low-degree equations. More concretely, let  <span class="math">x_{2i}, y_{2i}, z_{2i}</span>  and  <span class="math">x_{2i + 2}, y_{2i + 2}, z_{2i + 2}</span>  be the input and output of the  <span class="math">i</span> -th round, respectively, where  <span class="math">0 \\leq i \\leq r - 1</span> , they can be connected through the equations below as shown in Fig.2:</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 2: One round of Rescue-Prime with  <span class="math">t = 3</span></p>

    <p class="text-gray-300"><span class="math">L_{2i,j}(x_{2i}^{3},y_{2i}^{3},z_{2i}^{3})-\\left(L_{2i+1,j}^{-1}(x_{2i+2},y_{2i+2},z_{2i+2})\\right)^{3}=0,j\\in\\{0,1,2\\},</span> (1)</p>

    <p class="text-gray-300">where <span class="math">L_{2i+1,j}^{-1}</span> is the <span class="math">j</span>-th output of the inverse of <span class="math">L_{2i+1}</span>. It is clear that each equation in Eq.(1) is of degree three since both <span class="math">L_{2i,j}</span> and <span class="math">L_{2i+1,j}^{-1}</span> are of degree one. The variables <span class="math">z_{0}</span> and <span class="math">z_{2r}</span> are both set to zero in the CICO problem, i.e. <span class="math">z_{0}=z_{2r}=0</span>. Therefore, a system of <span class="math">3r</span> equations in <span class="math">3r+1</span> variables is derived.</p>

    <p class="text-gray-300">Bypassing the first two S-box layers. As having been observed in <em>[8]</em>, the first two nonlinear layers can be skipped when launching an algebraic attack against Rescue-Prime. The main reason for this is the lack of a linear diffusion layer before the S-box layer. More specifically, as shown in Fig.3, let <span class="math">C_{-1,0},C_{-1,1},C_{-1,2}</span> be the three constants of the additional AddC operation before the first round, and let <span class="math">C_{0,0},C_{0,1},C_{0,2}</span> be the three constants of <span class="math">AddC_{0}</span>, and let <span class="math">X,Y,Z</span> be the outputs of S-boxes in the 1-th step. To satisfy the CICO problem, the output of the third S-box in the 0-th step is <span class="math">(C_{-1,2})^{3}</span>, which yields</p>

    <p class="text-gray-300"><span class="math">(C_{-1,2})^{3}=\\alpha_{2,0}(X^{3}-C_{0,0})+\\alpha_{2,1}(Y^{3}-C_{0,1})+\\alpha_{2,2}(Z^{3}-C_{0,2}),</span> (2)</p>

    <p class="text-gray-300">where <span class="math">M^{-1}=(\\alpha_{i,j})_{0\\leq i\\leq 2,0\\leq j\\leq 2}</span>. It is easy to see that there are many three tuples <span class="math">(X,Y,Z)</span> satisfying Eq.(2). For example, if one sets <span class="math">Z=c</span>, where</p>

    <p class="text-gray-300"><span class="math">c^{3}=\\alpha_{2,2}^{-1}(\\alpha_{2,0}C_{0,0}+\\alpha_{2,1}C_{0,1}+\\alpha_{2,2}C_{0,2}+(C_{-1,2})^{3}),</span> (3)</p>

    <p class="text-gray-300">then Eq.(2) is simplified as <span class="math">\\alpha_{2,0}X^{3}+\\alpha_{2,1}Y^{3}=0</span>, and so <span class="math">Y=(-\\frac{\\alpha_{2,0}}{\\alpha_{2,1}})^{1/3}X</span>. The analysis above implies that if one sets</p>

    <p class="text-gray-300"><span class="math">(X,Y,Z)=(X,(-\\frac{\\alpha_{2,0}}{\\alpha_{2,1}})^{1/3}X,c),</span> (4)</p>

    <p class="text-gray-300">then the inputs of Rescue-Prime naturally have the form <span class="math">(<em>,</em>,0)</span>. As a result, if there exists <span class="math">X\\in\\mathbb{F}_{q}</span> such that the image of <span class="math">(X,(-\\frac{\\alpha_{2,0}}{\\alpha_{2,1}})^{1/3}X,c)</span> through <span class="math">(r-1)</span>-round Rescue-Prime is equal to <span class="math">(<em>,</em>,0)</span>, then it is able to deduce an original input <span class="math">(<em>,</em>,0)</span> of <span class="math">r</span>-round Rescue-Prime with an image of the form <span class="math">(<em>,</em>,0)</span>.</p>

    <p class="text-gray-300">Fig. 3: Main idea of <em>[8]</em> on how to bypass the first round of Rescue-Prime.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Remark 1</h6>

    <p class="text-gray-300">It is worth noting that such <span class="math">X</span> does not always exist since the mapping from <span class="math">X</span> to the third output of <span class="math">r</span>-round Rescue-Prime is not necessarily one-to-one. Then one may instead assign a value <span class="math">c</span> to <span class="math">X</span> (or <span class="math">Y</span>), and similarly deduce a linear relation for the other two variables, say <span class="math">Y=\\alpha Z</span> (or <span class="math">X=\\alpha Z</span>). Finally, find <span class="math">Z\\in\\mathbb{F}_{q}</span> such that the image of <span class="math">(c,\\alpha Z,Z)</span> (or <span class="math">(\\alpha Z,c,Z)</span>) through <span class="math">(r-1)</span>-round Rescue-Prime is equal to <span class="math">(<em>,</em>,0)</span>. However, the existence of such <span class="math">X</span> or <span class="math">Z</span> is closely related to the constants used in Rescue-Prime. Moreover, there do exist constants (constructable) such that desired <span class="math">X</span> or <span class="math">Z</span> are nonexistent.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">Solving a system of equations.</h4>

    <p class="text-gray-300">With the technique of bypassing the first round, Rescue-Prime can usually be attacked one more step (the first layer of S-boxes can be skipped naturally) with little to no cost. For <span class="math">r</span>-round Rescue-Prime, the authors of <em>[8]</em> obtain a system of <span class="math">3(r-1)</span> equations of degrees 3 in <span class="math">3(r-1)</span> variables. Theoretically, the system can be solved using the F5 and FGLM algorithms together, and the complexity can be estimated. Moreover, practical attacks on 3-round and 4-round Rescue-Prime are implemented with Magma in <em>[8]</em> (using F4 algorithm, not F5 algorithm, to find the grevlex Gröbner basis), which take 9.18 seconds and 258500 seconds, respectively. The time complexity for attacking 5-round Rescue-Prime is roughly estimated as <span class="math">2^{57}</span> while the memory complexity is unknown. We refer to <em>[8, Section 3.2 and Table 3]</em> for more details. The authors also found that the final univariate polynomial has a degree of <span class="math">3^{3(r-1)}</span> but did not give a proof. We will fill in the gap in the next section.</p>

    <h2 id="sec-13" class="text-2xl font-bold">4 Optimized algebraic attacks against Rescue-Prime based on resultant</h2>

    <p class="text-gray-300">In this section, we will give optimized algebraic attacks against Rescue-Prime based on resultant. We note that previous algebraic attacks against Rescue-Prime primarily relied on the Gröbner basis method. Compared with the Gröbner basis method, the resultant-based method tends to give more precise estimation of the time complexity. As it will be seen, the system of equations constructed in an algebraic attack has a very special structure, which clearly indicates a path for eliminating the variables by computing corresponding resultants. Based on this special structure, we propose the cubic substitution theory, with which the degrees of all but two variables at most in a multivariate polynomial derived by each resultant can be forced to remain at most equal to 2. The benefits of this are at least twofold: (1) most of the resultants can be computed with determinants of 5 by 5 matrices; (2) a tight upper bound on the degree of a multivariate polynomial obtained by each resultant can be clearly given, which together make the estimation of the time complexity more accurate. More importantly, when combining resultants with the cubic substitution theory and the fast Lagrange interpolation, practical algebraic attacks on higher rounds of Rescue-Prime become possible. For example, the existing best-known practical attack was against 4-round Rescue-Prime (with <span class="math">t=3</span>), which took</p>

    <p class="text-gray-300">258500 seconds [8]. However, with the resultant-based method, we can successfully attack 4-round Rescue-Prime (with  <span class="math">t = 3</span> ) in 885.5 seconds. Moreover, we can practically attack 5-round Rescue-Prime in about one day, which was originally thought to be "hard" in the Ethereum Foundation challenge. For details, see the comparison in Table 5.</p>

    <p class="text-gray-300">As done in Sect.3.2, the  <span class="math">2r</span>  steps of  <span class="math">r</span> -round Rescue-Prime are referred to as the 0-th step, the 1-th step, ..., the  <span class="math">(2r - 1)</span> -th step.</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 4: Forward modeling of Rescue-Prime</p>

    <p class="text-gray-300">Construction of Equations. The construction of equations roughly follows the method introduced in [8], but with the variables set at different locations (see Fig. 2 and Fig. 4 for a comparison). For  <span class="math">0 \\leq i \\leq r - 1</span> , let  <span class="math">x_{2i + 1}, y_{2i + 1}, z_{2i + 1}</span>  be the outputs of the three S-boxes  <span class="math">(S^{-1})</span>  in the  <span class="math">(2i + 1)</span> -th step. We denote by  <span class="math">SSS</span>  the three S-boxes arranged in parallel — that is,</p>

    <div class="my-4 text-center"><span class="math-block">S S S (x, y, z) = \\left(S (x), S (y), S (z)\\right) = \\left(x ^ {3}, y ^ {3}, z ^ {3}\\right).</span></div>

    <p class="text-gray-300">Then it can be seen from Fig. 4 that</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{l} x _ {2 i + 3} ^ {3} = L _ {2 i + 2, 0} \\circ S S S \\circ L _ {2 i + 1} \\left(x _ {2 i + 1}, y _ {2 i + 1}, z _ {2 i + 1}\\right) \\\\ y _ {2 i + 3} ^ {3} = L _ {2 i + 2, 1} \\circ S S S \\circ L _ {2 i + 1} \\left(x _ {2 i + 1}, y _ {2 i + 1}, z _ {2 i + 1}\\right) \\\\ z _ {2 i + 3} ^ {3} = L _ {2 i + 2, 2} \\circ S S S \\circ L _ {2 i + 1} \\left(x _ {2 i + 1}, y _ {2 i + 1}, z _ {2 i + 1}\\right) \\end{array} \\right. \\text {f o r} i \\in \\{0, 1, \\dots , r - 2 \\},</span></div>

    <p class="text-gray-300">where “ <span class="math">\\circ</span> ” denotes the composition of mappings and  <span class="math">L_{2i+2,j}</span>  is the  <span class="math">j</span> -th output of  <span class="math">L_{2i+2}</span>  with  <span class="math">j \\in \\{0,1,2\\}</span> .</p>

    <p class="text-gray-300">Remark 2. There are  <span class="math">\\binom{6}{3}=20</span>  terms at most in the expansion of</p>

    <div class="my-4 text-center"><span class="math-block">L _ {2 i + 2, j} \\circ S S S \\circ L _ {2 i + 1} \\left(x _ {2 i + 1}, y _ {2 i + 1}, z _ {2 i + 1}\\right).</span></div>

    <p class="text-gray-300">Next, we use the technique of bypassing the first round of Rescue-Prime reviewed in Sect.3.2 to construct two more equations. Specifically, as shown in Eq.(4), to make the inputs of Rescue-Prime are of the form <span class="math">(<em>,</em>,0)</span>,</p>

    <p class="text-gray-300"><span class="math">(x_{1},y_{1},z_{1})=(X,(-\\frac{\\alpha_{2,0}}{\\alpha_{2,1}})^{1/3}X,c),</span></p>

    <p class="text-gray-300">where <span class="math">c</span> is some fixed element in <span class="math">\\mathbb{F}_{q}</span> and <span class="math">X</span> is any element in <span class="math">\\mathbb{F}_{q}</span>. Then, we get</p>

    <p class="text-gray-300"><span class="math">y_{1}=(-\\frac{\\alpha_{2,0}}{\\alpha_{2,1}})^{1/3}x_{1}\\text{ and }z_{1}=c.</span> (6)</p>

    <p class="text-gray-300">Finally, the output of the <span class="math">r</span>-round Rescue-Prime should be of the form <span class="math">(<em>,</em>,0)</span> in the CICO problem, so there is one more equation, which is</p>

    <p class="text-gray-300"><span class="math">L_{2r-1,2}\\left(x_{2r-1},y_{2r-1},z_{2r-1}\\right)=0.</span> (7)</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">Solving the system of equations with the resultant-based method.</h4>

    <p class="text-gray-300">It can be seen from Eqs.(5)-(7) that the system of equations has <span class="math">3r-2</span> equations in <span class="math">3r-2</span> unknowns (here we omit <span class="math">z_{1}</span> and <span class="math">y_{1}</span> since <span class="math">z_{1}=c</span> is known and <span class="math">y_{1}=(-\\frac{\\alpha_{2,0}}{\\alpha_{2,1}})^{1/3}x_{1}</span>): <span class="math">3r-3</span> equations are of degree 3 and one equations is of degree 1. Such a system of equations has a special structure: (1) it can be seen from Eq.(5) that the variable <span class="math">x_{2i+3}</span> (or <span class="math">y_{2i+3}</span>, or <span class="math">z_{2i+3}</span>) is only associated with three other lower-subscript variables <span class="math">x_{2i+1},y_{2i+1},z_{2i+1}</span>; (2) the variable <span class="math">x_{2r-1}</span> (or <span class="math">y_{2r-1}</span>, or <span class="math">z_{2r-1}</span>) are involved only in Eq.(5) for the case <span class="math">i=r-2</span> and Eq.(7). This special structure makes the system of equations especially suitable for solving by the resultant-based method, since it clearly indicates a path for elimination of the variables. Specifically, let</p>

    <p class="text-gray-300"><span class="math">f_{x_{2i+3}}=x_{2i+3}^{3}-L_{2i+2,0}\\circ SSS\\circ L_{2i+1}(x_{2i+1},y_{2i+1},z_{2i+1}),</span> <span class="math">f_{y_{2i+3}}=y_{2i+3}^{3}-L_{2i+2,1}\\circ SSS\\circ L_{2i+1}(x_{2i+1},y_{2i+1},z_{2i+1}),</span> <span class="math">f_{z_{2i+3}}=z_{2i+3}^{3}-L_{2i+2,2}\\circ SSS\\circ L_{2i+1}(x_{2i+1},y_{2i+1},z_{2i+1}),</span></p>

    <p class="text-gray-300">for <span class="math">i\\in\\{0,1,\\ldots,r-2\\}</span>, and let</p>

    <p class="text-gray-300"><span class="math">f_{h}=L_{2r-1,2}\\left(x_{2r-1},y_{2r-1},z_{2r-1}\\right).</span></p>

    <p class="text-gray-300">Only <span class="math">f_{h}</span> and <span class="math">f_{z_{2r-1}}</span> contain the variable <span class="math">z_{2r-1}</span>, and it can be eliminated by computing the resultant <span class="math">R(f_{h},f_{z_{2r-1}},z_{2r-1})</span>. Update <span class="math">f_{h}</span> with <span class="math">R(f_{h},f_{z_{2r-1}},z_{2r-1})</span>, then only the updated <span class="math">f_{h}</span> and <span class="math">f_{y_{2r-1}}</span> contain the variable <span class="math">y_{2r-1}</span>. Then <span class="math">y_{2r-1}</span> can be eliminated in the same way. Generally, following Algorithm 1, we can eliminate one variable in each computation of a resultant, and derive a univariate polynomial in <span class="math">\\mathbb{F}_{q}[x_{1}]</span> in the end. Solving the roots of the derived univariate polynomial and substituting back, the roots of the original system of equations will be found.</p>

    <p class="text-gray-300">|  Algorithm 1: Get the univariate polynomial for r-round Rescue-Prime  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Input: fx2i+3, fy2i+3, fz2i+3, fh with i ∈ {0,1,...,r-2}.  |   |</p>

    <p class="text-gray-300">|  Output: a univariate polynomial in Fq[x1].  |   |</p>

    <p class="text-gray-300">|  1 i← r-2;  |   |</p>

    <p class="text-gray-300">|  2 while i ≥ 1 do  |   |</p>

    <p class="text-gray-300">|  3 fh← R(fh, fz2i+3, z2i+3);  |   |</p>

    <p class="text-gray-300">|  4 apply the cubic substitution to fh;  |   |</p>

    <p class="text-gray-300">|  5 fh← R(fh, fy2i+3, y2i+3);  |   |</p>

    <p class="text-gray-300">|  6 apply the cubic substitution to fh;  |   |</p>

    <p class="text-gray-300">|  7 fh← R(fh, fx2i+3, x2i+3);  |   |</p>

    <p class="text-gray-300">|  8 apply the cubic substitution to fh;  |   |</p>

    <p class="text-gray-300">|  9 i← i-1;  |   |</p>

    <p class="text-gray-300">|  10 end  |   |</p>

    <p class="text-gray-300">|  11 fh← R(fh, fz2i+3, z3);  |   |</p>

    <p class="text-gray-300">|  12 apply the cubic substitution to fh;  |   |</p>

    <p class="text-gray-300">|  13 fh← R(fh, fy2i+3, y3);  |   |</p>

    <p class="text-gray-300">|  14 apply the cubic substitution to fh;  |   |</p>

    <p class="text-gray-300">|  15 fh← R(fh, fy2i+3, x3);  |   |</p>

    <p class="text-gray-300">|  16 return fh.  |   |</p>

    <p class="text-gray-300">Cubic substitution theory. We note that the degrees of variables in the multivariate polynomial obtained by each resultant in Algorithm 1 will increase. However, by making use of the special structure in Eq.(5), the degrees of all variables except  <span class="math">x_{1}</span>  can be forced to remain at most equal to 2. In fact, Eq.(5) has two properties: (1) the variables  <span class="math">x_{2i+3}, y_{2i+3}, z_{2i+3}</span>  are separated in the sense that they are not mixed with the lower-subscript variables  <span class="math">x_{2i+1}, y_{2i+1}, z_{2i+1}</span> ; (2) the degree of  <span class="math">x_{2i+3}</span>  (or  <span class="math">y_{2i+3}</span> , or  <span class="math">z_{2i+3}</span> ) is exactly 3. For the first resultant  <span class="math">R(f_{h}, f_{z_{2r-1}}, z_{2r-1})</span>  in Algorithm 1, it is a multivariate polynomial in  <span class="math">y_{2r-1}, x_{2r-1}, x_{2r-3}, y_{2r-3}, z_{2r-3}</span>  with the degree of each variable at most 3. By using the following substitutions in order, i.e.,</p>

    <div class="my-4 text-center"><span class="math-block">y _ {2 r - 1} ^ {3} = L _ {2 r - 2, 1} \\circ S S S \\circ L _ {2 r - 3} (x _ {2 r - 3}, y _ {2 r - 3}, z _ {2 r - 3}),</span></div>

    <div class="my-4 text-center"><span class="math-block">x _ {2 r - 1} ^ {3} = L _ {2 r - 2, 0} \\circ S S S \\circ L _ {2 r - 3} (x _ {2 r - 3}, y _ {2 r - 3}, z _ {2 r - 3}),</span></div>

    <div class="my-4 text-center"><span class="math-block">z _ {2 r - 3} ^ {3} = L _ {2 r - 4, 2} \\circ S S S \\circ L _ {2 r - 5} (x _ {2 r - 5}, y _ {2 r - 5}, z _ {2 r - 5}),</span></div>

    <div class="my-4 text-center"><span class="math-block">y _ {2 r - 3} ^ {3} = L _ {2 r - 4, 1} \\circ S S S \\circ L _ {2 r - 5} (x _ {2 r - 5}, y _ {2 r - 5}, z _ {2 r - 5}),</span></div>

    <div class="my-4 text-center"><span class="math-block">x _ {2 r - 3} ^ {3} = L _ {2 r - 4, 0} \\circ S S S \\circ L _ {2 r - 5} (x _ {2 r - 5}, y _ {2 r - 5}, z _ {2 r - 5}),</span></div>

    <div class="my-4 text-center"><span class="math-block">z _ {3} ^ {3} = L _ {2, 2} \\circ S S S \\circ L _ {1} (x _ {1}, k x _ {1}, c),</span></div>

    <div class="my-4 text-center"><span class="math-block">y _ {3} ^ {3} = L _ {2, 1} \\circ S S S \\circ L _ {1} (x _ {1}, k x _ {1}, c),</span></div>

    <div class="my-4 text-center"><span class="math-block">x _ {3} ^ {3} = L _ {2, 0} \\circ S S S \\circ L _ {1} (x _ {1}, k x _ {1}, c),</span></div>

    <p class="text-gray-300"><span class="math">c</span> and <span class="math">k=(-\\frac{\\alpha_{2,0}}{\\alpha_{2,1}})^{1/3}</span> are two fixed elements in <span class="math">\\mathbb{F}_{q}</span> as defined in Eq.(3) and Eq.(4), respectively, <span class="math">R(f_{h},f_{z_{2r-1}},z_{2r-1})</span> is transformed into a multivariate polynomial in <span class="math">y_{2r-1}</span>, <span class="math">x_{2r-1}</span>, <span class="math">z_{2r-3}</span>, <span class="math">y_{2r-3}</span>, <span class="math">x_{2r-3}</span>, <span class="math">\\ldots</span>, <span class="math">z_{3}</span>, <span class="math">y_{3}</span>, <span class="math">x_{3}</span>, <span class="math">x_{1}</span> with the degree of each variable except <span class="math">x_{1}</span> less than 3. The substitutions above are called cubic substitutions for convenience.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Remark 3</h6>

    <p class="text-gray-300">We note that if there is a variable, say <span class="math">x_{2i+1}</span>, of which the degree is larger than 3, then we may need to use multiple substitutions of the form <span class="math">x_{2i+1}^{3}=L_{2i,0}\\circ SSS\\circ L_{2i-1}(x_{2i-1},y_{2i-1},z_{2i-1})</span> to reduce its degree less than 3. For example, let <span class="math">f_{h}=x_{2i+1}^{7}+x_{2i+1}^{3}+1</span> and <span class="math">x_{2i+1}^{3}=x_{2i-1}^{3}+y_{2i-1}^{3}+z_{2i-1}^{3}</span>, then we need two substitutions for <span class="math">x_{2i+1}^{\\prime}</span> and one for <span class="math">x_{2i+1}^{3}</span>, and derive <span class="math">f_{h}=(x_{2i-1}^{3}+y_{2i-1}^{3}+z_{2i-1}^{3})^{2}*x_{2i+1}+x_{2i-1}^{3}+y_{2i-1}^{3}+z_{2i-1}^{3}+1</span>. The degree of <span class="math">x_{2i+1}</span> in <span class="math">f_{h}</span> now becomes less than 3.</p>

    <p class="text-gray-300">Now we consider the second resultant <span class="math">R(f_{h},f_{y_{2r-1}},y_{2r-1})</span> in Algorithm 1. Since the degree of <span class="math">y_{2r-1}</span> in <span class="math">f_{h}</span> is less than 3 after the cubic substitutions, the resultant <span class="math">R(f_{h},f_{y_{2r-1}},y_{2r-1})</span> can be computed with the determinant of a 5 by 5 matrix. By cubic substitutions, <span class="math">R(f_{h},f_{y_{2r-1}},y_{2r-1})</span> is changed into a multivariate polynomial in <span class="math">x_{2r-1}</span>, <span class="math">z_{2r-3}</span>, <span class="math">y_{2r-3}</span>, <span class="math">x_{2r-3},\\ldots,z_{3}</span>, <span class="math">y_{3}</span>, <span class="math">x_{3}</span>, <span class="math">x_{1}</span> with the degree of each variable less than 3 except <span class="math">x_{1}</span>. Similarly, when applying cubic substitutions to all the other resultants, the resultants are changed into multivariate polynomials with the degree of each variable less than 3 except <span class="math">x_{1}</span>.</p>

    <p class="text-gray-300">The cubic substitution has the following basic properties, which are useful for getting a tight upper bound on the degree of a polynomial obtained by each resultant.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Lemma 2</h6>

    <p class="text-gray-300">With the notations defined above, let <span class="math">f_{h}^{\\prime}</span> be the polynomial obtained by cubic substitutions of <span class="math">f_{h}</span> such that the degree of each variable in <span class="math">f_{h}^{\\prime}</span> is less than 3 except <span class="math">x_{1}</span>, then we have <span class="math">\\deg(f_{h}^{\\prime})\\leq\\deg(f_{h})</span>.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Proof</h6>

    <p class="text-gray-300">From the cubic substitutions of the first resultant <span class="math">R(f_{h},f_{z_{2r-1}},z_{2r-1})</span>, it can be seen that a term of degree 3 (say <span class="math">y_{2r-1}^{3}</span>) is substituted by a polynomial (say <span class="math">L_{2r-2,1}\\circ SSS\\circ L_{2r-3}(x_{2r-3},y_{2r-3},z_{2r-3})</span>) of degree at most 3 in each substitution, so <span class="math">\\deg(f_{h}^{\\prime})\\leq\\deg(f_{h})</span>.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Remark 4</h6>

    <p class="text-gray-300">We note that the base field of Rescue-Prime is a large finite field, therefore, <span class="math">\\deg(f_{h}^{\\prime})=\\deg(f_{h})</span> holds with a high probability. Moreover, we have experimentally verified that <span class="math">\\deg(f_{h}^{\\prime})=\\deg(f_{h})</span> always holds for the parameters used in Rescue-Prime.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Lemma 3</h6>

    <p class="text-gray-300">Let <span class="math">R_{k}</span> be the multivariate polynomial computed from the <span class="math">k</span>-th resultant in Algorithm 1 with <span class="math">1\\leq k\\leq 3(r-1)</span>, then <span class="math">\\deg(R_{k})\\leq 3^{k}</span>.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Proof</h6>

    <p class="text-gray-300">Let <span class="math">\\omega_{k}</span> be the variable to be eliminated by the <span class="math">k</span>-th resultant in Algorithm 1 for <span class="math">1\\leq k\\leq 3(r-1)</span>, for example, <span class="math">\\omega_{1}=z_{2r-1}</span>, <span class="math">\\omega_{2}=y_{2r-1}</span>, <span class="math">\\omega_{4}=z_{2r-3}</span>, and so on. Now we consider the <span class="math">k</span>-th resultant <span class="math">R(f_{h},f_{\\omega_{k}},\\omega_{k})</span> in Algorithm 1. As the degree of <span class="math">\\omega_{k}</span> in <span class="math">f_{h}</span> after cubic substitutions is less than 3, we can assume that</p>

    <p class="text-gray-300"><span class="math">f_{h}=u_{2}\\omega_{k}^{2}+u_{1}\\omega_{k}+u_{0},\\ \\ f_{\\omega_{k}}=\\omega_{k}^{3}-u_{3},</span></p>

    <p class="text-gray-300">where <span class="math">u_{0},u_{1},u_{2},u_{3}\\in\\mathbb{F}_{q}[\\omega_{k+1},\\ldots,\\omega_{3r-3},x_{1}]</span> with</p>

    <p class="text-gray-300"><span class="math">\\deg(u_{0})\\leq\\deg(f_{h}),\\deg(u_{1})\\leq\\deg(f_{h})-1,\\deg(u_{2})\\leq\\deg(f_{h})-2,\\text{ and }\\deg(u_{3})\\leq 3.</span></p>

    <p class="text-gray-300">Then, it is clear that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ R_{k}=R\\left(f_{h},f_{\\omega_{k}},\\omega_{k}\\right)=\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{cccccc}u_{2}&u_{1}&u_{0}&0&0\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">0&u_{2}&u_{1}&u_{0}&0\\\\ 0&0&u_{2}&u_{1}&u_{0}\\\\ 1&0&0&-u_{3}&0\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0&1&0&0&-u_{3}\\end{array}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{cccccc}u_{0}&u_{2}u_{3}&u_{1}u_{3}\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">u_{1}&u_{0}&u_{2}u_{3}\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{2}&u_{1}&u_{0}\\end{array}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\] (8)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and so <span class="math">R_{k}=u_{2}^{3}u_{3}^{2}-3u_{0}u_{1}u_{2}u_{3}+u_{1}^{3}u_{3}+u_{0}^{3}</span>. It is easy to check that</p>

    <p class="text-gray-300"><span class="math">\\deg(R_{k})\\leq 3\\deg(f_{h}).</span> (9)</p>

    <p class="text-gray-300">Together with Lemma 2, this implies that the degree of <span class="math">f_{h}</span> in Algorithm 1 after each update is increased over the original <span class="math">f_{h}</span> by a factor of three. Since the input polynomial <span class="math">f_{h}</span> of Algorithm 1 is <span class="math">L_{2r-1,2}\\left(x_{2r-1},y_{2r-1},z_{2r-1}\\right)</span>, which is of degree 1, the desired result immediately follows from (9) and Lemma 2.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Remark 5.</h6>

    <p class="text-gray-300">Since the base field of Rescue-Prime is a large finite field, it follows that <span class="math">\\deg(R_{k})=3^{k}</span> with high probability. We have also experimentally verified that <span class="math">\\deg(R_{k})=3^{k}</span> always holds for the parameters used in Rescue-Prime.</p>

    <p class="text-gray-300">Combining Lemmas 2 and 3, it is clear that the output of Algorithm 1 is a univariate polynomial over <span class="math">\\mathbb{F}_{q}[x_{1}]</span> with a degree at most <span class="math">3^{3r-3}</span>. In our practical attack against round-reduced Rescue-Prime, the maximum possible degree <span class="math">3^{3r-3}</span> is always achievable. We note that a similar result has been found by experiments (without proof) in <em>[8, Page 87]</em>, which says “In our experiments, the system behaves like a generic system and has <span class="math">d=3^{3(r-1)}</span> solutions in the algebraic closure of the field.”</p>

    <h4 id="sec-23" class="text-lg font-semibold mt-6">Complexity analysis.</h4>

    <p class="text-gray-300">It can be seen from Algorithm 1 that the time complexity of our attack consists of three parts: (1) the cubic substitutions; (2) the computations of resultants; (3) finding roots of univariate polynomials. The unit of the time complexity is one basic arithmetic operation in the finite field, which is a widely used metric for evaluating complexities for attacking AO primitives.</p>

    <h5 id="sec-24" class="text-base font-semibold mt-4">The cubic substitution.</h5>

    <p class="text-gray-300">For <span class="math">r</span>-round Rescue-Prime, Algorithm 1 involves a total of <span class="math">3r-3</span> computations of resultants and <span class="math">3r-4</span> cubic substitutions (we note that some cubic substitutions may involve multiple substitutions as explained in Remark 3. Let <span class="math">\\omega_{k}</span> be the variable to be eliminated by the <span class="math">k</span>-th resultant <span class="math">R_{k}</span> in Algorithm 1 for <span class="math">1\\leq k\\leq 3(r-1)</span>. Recall that <span class="math">R_{k}\\in\\mathbb{F}_{q}[\\omega_{k+1},\\omega_{k+2},\\ldots,\\omega_{3r-3},x_{1}]</span> and the purpose of performing cubic substitutions for <span class="math">R_{k}</span> is to reduce the degrees of <span class="math">\\omega_{k+1},\\omega_{k+2},\\ldots,\\omega_{3r-3}</span> to less than 3. The time complexity of all cubic substitutions in Algorithm 1 is given in Theorem 1.</p>

    <p class="text-gray-300">Theorem 1. The time complexity of performing all the cubic substitutions in Algorithm 1 is</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {O} \\left(\\sum_ {k = 1} ^ {3 r - 4} 1 0 \\cdot \\left(1 3 ^ {3} \\cdot \\binom {d _ {k} + 3 r - k - 4} {3 r - k - 3} \\cdot (3 ^ {k} + 1) + 1 2 1 7 4 5\\right) \\cdot (3 r - k - 3)\\right),</span></div>

    <p class="text-gray-300">where <span class="math">d_{k} = \\min (3^{k} - 12,18r - 6k - 24)</span></p>

    <p class="text-gray-300">Proof. Let <span class="math">R_{k} = R(f_{h},f_{\\omega_{k}},\\omega_{k})</span> be the <span class="math">k</span>-th resultant in Algorithm 1 for <span class="math">1\\leq k\\leq 3(r - 1)</span>, where <span class="math">\\omega_{k}</span> is the variable to be eliminated by <span class="math">R_{k}</span> and</p>

    <div class="my-4 text-center"><span class="math-block">f _ {h} = u _ {2} \\omega_ {k} ^ {2} + u _ {1} \\omega_ {k} + u _ {0}, f _ {\\omega_ {k}} = \\omega_ {k} ^ {3} - u _ {3}.</span></div>

    <p class="text-gray-300">Since the cubic substitution only care about the degree of <span class="math">\\omega_{k + 1},\\ldots ,\\omega_{3r - 3}</span>, we view <span class="math">u_0,u_1,u_2,u_3</span> as polynomials over <span class="math">\\mathbb{F}_q[x_1]</span>, that is</p>

    <div class="my-4 text-center"><span class="math-block">u _ {0}, u _ {1}, u _ {2}, u _ {3} \\in \\mathbb {F} _ {q} [ x _ {1} ] [ \\omega_ {k + 1}, \\dots , \\omega_ {3 r - 3} ].</span></div>

    <p class="text-gray-300">We note that <span class="math">\\deg_{\\omega_j}(u_0) \\leq 2</span>, <span class="math">\\deg_{\\omega_j}(u_1) \\leq 2</span>, <span class="math">\\deg_{\\omega_j}(u_2) \\leq 2</span>, <span class="math">\\deg_{\\omega_j}(u_3) \\leq 3</span> for <span class="math">k + 1 \\leq j \\leq 3r - 3</span>, where <span class="math">\\deg_{\\omega_j}(u_i)</span> denote the degree of <span class="math">\\omega_j</span> in <span class="math">u_i</span>, and so it follows from Eq. (8) that</p>

    <div class="my-4 text-center"><span class="math-block">\\deg (R _ {k}) = \\deg \\left(u _ {2} ^ {3} u _ {3} ^ {2} - 3 u _ {0} u _ {1} u _ {2} u _ {3} + u _ {1} ^ {3} u _ {3} + u _ {0} ^ {3}\\right) \\leq 6 \\cdot (3 r - k - 2) \\tag {10}</span></div>

    <p class="text-gray-300">and <span class="math">\\deg_{\\omega_{k + 1}}(R_k)\\leq 12</span> (the equality holds if and only if <span class="math">\\omega_{k + 1}^3</span> appears in <span class="math">u_{3}</span>). Therefore, there are at most 10 substitutions for <span class="math">\\omega_{k + 1}</span></p>

    <p class="text-gray-300">Let <span class="math">R_{k} = \\sum_{i=0}^{12} \\eta_{i} \\omega_{k+1}^{i}</span>. Then it immediately follows from (10) and Theorem 3 that</p>

    <div class="my-4 text-center"><span class="math-block">\\deg (\\eta_ {i}) \\leq \\min (3 ^ {k} - 1 2, 6 \\cdot (3 r - k - 2) - i) \\mathrm {for} 0 \\leq i \\leq 1 2.</span></div>

    <p class="text-gray-300">We first consider the substitution of <span class="math">\\omega_{k+1}^{12}</span>, which consists of two parts. The first part is to expand <span class="math">\\left(\\left(\\omega_{k+1}^3\\right)^2\\right)^2</span>, the complexity of the expansion is <span class="math">4^3 \\cdot 4^3 + 7^3 \\cdot 7^3 = 121745</span> by Theorem 1. Since the degree of three variables in the expansion of <span class="math">\\omega_{k+1}^{12}</span> is no more than 12, there are at most <span class="math">13^3</span> terms in the expansion of <span class="math">\\omega_{k+1}^{12}</span>. The second part is to multiply the expansion of <span class="math">\\omega_{k+1}^{12}</span> with <span class="math">\\eta_{12}</span>. Since <span class="math">\\deg(\\eta_{12}) \\leq d_k = \\min(3^k - 12, 18r - 6k - 24)</span>, the number of terms in the expansion of <span class="math">\\eta_{12}</span> over <span class="math">\\mathbb{F}_q[x_1]</span> is <span class="math">\\binom{d_k+3r-k-4}{3r-k-3}</span> at most. We note that each coefficient of <span class="math">\\eta_{12}</span> belongs to <span class="math">\\mathbb{F}_q[x_1]</span> and the highest degree of <span class="math">x_1</span> in each coefficient is no more than <span class="math">3^k</span>, and so the number of terms in the expansion of <span class="math">\\eta_{12}</span> over <span class="math">\\mathbb{F}_q</span> (not over <span class="math">\\mathbb{F}_q[x_1]</span>) is at most <span class="math">\\binom{d_k+3r-k-4}{3r-k-3} \\cdot (3^k + 1)</span>. Therefore, by Theorem 1, the complexity of the second part is <span class="math">13^3 \\cdot \\binom{d_k+3r-k-4}{3r-k-3} \\cdot (3^k + 1)</span>.</p>

    <p class="text-gray-300">The time complexities of substitutions for <span class="math">\\omega_{k + 1}^{11},\\omega_{k + 1}^{10},\\dots ,\\omega_{k + 1}^{3}</span> are almost equal to that of <span class="math">\\omega_{k + 1}^{12}</span>, so we use</p>

    <div class="my-4 text-center"><span class="math-block">1 0 \\cdot \\left(1 3 ^ {3} \\cdot \\binom {d _ {k} + 3 r - k - 4} {3 r - k - 3} \\cdot \\left(3 ^ {k} + 1\\right) + 1 2 1 7 4 5\\right) \\tag {11}</span></div>

    <p class="text-gray-300">as an estimation of the time complexity of the cubic substitution for  <span class="math">\\omega_{k + 1}</span></p>

    <p class="text-gray-300">Finally, we come to estimate the time complexity of the cubic substitution for  <span class="math">\\omega_{j}</span> , where  <span class="math">k + 2 \\leq j \\leq 3r - 3</span> . It can be seen from (11) that the time complexity is mainly dominated by the combinatorial number, which implies the cubic substitution for  <span class="math">\\omega_{j}</span>  is faster than the cubic substitution for  <span class="math">\\omega_{k + 1}</span> . Therefore, the time complexity of the cubic substitution for  <span class="math">R_{k}</span>  is  <span class="math">10 \\cdot \\left(13^{3} \\cdot \\binom{d + 3r - k - 4}{3r - k - 3} \\cdot (3^{k} + 1) + 121745\\right) \\cdot (3r - 3 - k)</span> . This completes the proof.</p>

    <p class="text-gray-300">Computation of the resultant. We have the following Theorem 2 to estimate the time complexities of all the computations of resultants in Algorithm 1.</p>

    <p class="text-gray-300">Theorem 2. The time complexity of the computation of all the resultants in Algorithm 1 is</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {O} \\left(\\sum_ {k = 1} ^ {3 r - 3} 1 5 \\cdot \\max  \\left((3 ^ {k} + 1) \\cdot 7 ^ {3 r - k}, (2 \\cdot 3 ^ {k - 1} + 1) (3 ^ {k - 1} + 1) \\cdot 1 5 ^ {3 r - 3 - k}\\right)\\right).</span></div>

    <p class="text-gray-300">Proof. By Eq.(8), we have  <span class="math">R_{k} = u_{2}^{3}u_{3}^{2} - 3u_{0}u_{1}u_{2}u_{3} + u_{1}^{3}u_{3} + u_{0}^{3}</span> . There are 3 additions and 12 multiplications for computing  <span class="math">R_{k}</span>  including  <span class="math">u_{i}\\cdot u_{i}, i\\in \\{0,1,2,3\\}, u_{j}^{2}\\cdot u_{j}, j\\in \\{0,1,2\\}, u_{0}\\cdot u_{1},(u_{0}u_{1})\\cdot u_{2},(u_{0}u_{1}u_{2})\\cdot u_{3},u_{1}^{3}\\cdot u_{3}</span> , and  <span class="math">u_{2}^{3}\\cdot u_{3}^{2}</span> . We use  <span class="math">\\mathcal{T}_{\\mathrm{max}}</span>  to denote the maximum of the time complexities for computing a set of operations. For example,  <span class="math">\\mathcal{T}_{\\mathrm{max}}\\{u_i\\cdot u_i,i = 0,1,2,3\\}</span>  denotes the maximum of the time complexities for computing  <span class="math">u_0\\cdot u_0,u_1\\cdot u_1,u_2\\cdot u_2</span> , and  <span class="math">u_{3}\\cdot u_{3}</span> . Since  <span class="math">\\deg (u_3)\\leq 3</span>  and there is at most three variables in  <span class="math">u_{3}</span> , it is clear that  <span class="math">\\mathcal{T}_{\\mathrm{max}}\\{u_i\\cdot u_i,i = 0,1,2,3\\} \\leq \\mathcal{T}_{\\mathrm{max}}\\{u_j^2\\cdot u_j,j = 0,1,2\\}</span>  and  <span class="math">\\mathcal{T}_{\\mathrm{max}}(u_0\\cdot u_1)\\leq \\mathcal{T}_{\\mathrm{max}}\\{(u_0u_1)\\cdot u_2,(u_0u_1u_2)\\cdot u_3,u_1^3\\cdot u_3\\} \\leq \\mathcal{T}_{\\mathrm{max}}(u_2^3\\cdot u_3^2)^4</span> . Then the time complexity of computing  <span class="math">R_{k}</span>  is  <span class="math">15\\cdot \\mathcal{T}_{\\mathrm{max}}\\{u_2^3\\cdot u_3^2,u_0^2\\cdot u_0\\}</span> . Through cubic substitutions, we have  <span class="math">\\deg_{\\omega_j}(u_2^3)\\leq 6</span>  for  <span class="math">k + 1\\leq j\\leq 3r - 3</span>  and  <span class="math">\\deg_{x_1}(u_2^3)\\leq 3^k</span> . There are three variables in  <span class="math">u_{3}^{2}</span>  with degrees less than 6. Besides,  <span class="math">\\deg_{\\omega_j}(u_0^2)\\leq 4</span>  for  <span class="math">k + 1\\leq j\\leq 3r - 3</span>  and  <span class="math">\\deg_{x_1}(u_0^2)\\leq 2\\cdot 3^{k - 1}</span> . Let  <span class="math">d_1,d_2,d_3</span> , and  <span class="math">d_4</span>  be the numbers of terms of  <span class="math">u_{2}^{3},u_{3}^{2},u_{0}^{2}</span> , and  <span class="math">u_{0}</span> , respectively, then  <span class="math">d_1 = (3^k +1)\\cdot 7^{3r - 3 - k}</span> ,  <span class="math">d_2 = 7^3</span> ,  <span class="math">d_3 = (2\\cdot 3^{k - 1} + 1)\\cdot 5^{3r - 3 - k}</span> , and  <span class="math">d_4 = (3^{k - 1} + 1)\\cdot 3^{3r - 3 - k}</span> . Therefore, the time complexity of computing  <span class="math">R_{k}</span>  is  <span class="math">15\\cdot \\max (d_1\\cdot d_2,d_3\\cdot d_4)</span> . This completes the proof.</p>

    <p class="text-gray-300">Finding roots of a univariate polynomial. Since the output of Algorithm 1 is a univariate polynomial over  <span class="math">\\mathbb{F}_q[x_1]</span>  with degree  <span class="math">d \\leq 3^{3r-3}</span> , all the roots of such a univariate polynomial can be found in  <span class="math">\\mathcal{O}(d\\log(d)(\\log(d) + \\log(q))\\log(\\log(d)))</span> . Once a root of  <span class="math">x_1</span>  is found, the corresponding CICO problem is solved.</p>

    <p class="text-gray-300">The time complexities of the different steps of our attack against Rescue-Prime under forward modeling are presented in Table 2.</p>

    <p class="text-gray-300">Table 2: Time complexities of our attack against Rescue-Prime under forward modeling, where  <span class="math">f_{h}</span>  is the output of Algorithm 1.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Complexity of resultants</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Complexity of cubic substitutions</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">deg(fh)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Complexity of roots solving</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Complexity of forward modeling</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">238.45</td>

            <td class="px-3 py-2 border-b border-gray-700">240.09</td>

            <td class="px-3 py-2 border-b border-gray-700">39</td>

            <td class="px-3 py-2 border-b border-gray-700">226.12</td>

            <td class="px-3 py-2 border-b border-gray-700">240.49</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">250.17</td>

            <td class="px-3 py-2 border-b border-gray-700">252.77</td>

            <td class="px-3 py-2 border-b border-gray-700">312</td>

            <td class="px-3 py-2 border-b border-gray-700">231.45</td>

            <td class="px-3 py-2 border-b border-gray-700">252.99</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">261.90</td>

            <td class="px-3 py-2 border-b border-gray-700">265.47</td>

            <td class="px-3 py-2 border-b border-gray-700">315</td>

            <td class="px-3 py-2 border-b border-gray-700">236.65</td>

            <td class="px-3 py-2 border-b border-gray-700">265.58</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">273.62</td>

            <td class="px-3 py-2 border-b border-gray-700">276.51</td>

            <td class="px-3 py-2 border-b border-gray-700">318</td>

            <td class="px-3 py-2 border-b border-gray-700">241.76</td>

            <td class="px-3 py-2 border-b border-gray-700">276.69</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">285.34</td>

            <td class="px-3 py-2 border-b border-gray-700">288.10</td>

            <td class="px-3 py-2 border-b border-gray-700">321</td>

            <td class="px-3 py-2 border-b border-gray-700">246.82</td>

            <td class="px-3 py-2 border-b border-gray-700">288.30</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In this subsection, we use the SFTM (start-from-the-middle) modeling to build a system of equations for  <span class="math">r</span> -round (consists of  <span class="math">2r</span>  steps) Rescue-Prime. The SFTM modeling can be regarded as a reverse application of the meet-in-the-middle (MITM) modeling. The MITM technique is a generic cryptanalytic approach for symmetric-key primitives, which was first introduced by Diffie and Hellman in 1977 [16] for the cryptanalysis of DES. Different from the MITM modeling that starts from the two sides and meets in the middle, the SFTM modeling starts from the middle and models the constraints on the input and output as actual equations.</p>

    <p class="text-gray-300">Since the case of  <span class="math">r = 1</span>  is trivial, we always assume that  <span class="math">r \\geq 2</span> . It is clear that the S-boxes involved in the  <span class="math">i</span> -th step are  <span class="math">S^{-1}</span>  if  <span class="math">i</span>  is odd and  <span class="math">S</span>  if  <span class="math">i</span>  is even. Note that  <span class="math">S^{-1}</span>  has a very high degree in the forward direction while  <span class="math">S</span>  has a very high degree in the backward direction. To build low-degree equations, the main idea is to balance the number of  <span class="math">S^{-1}</span>  layers in the forward direction and the number of  <span class="math">S</span>  layers in the backward direction. Therefore, the constructed equations are categorized into two cases: one for odd  <span class="math">r</span>  and the others for even  <span class="math">r</span> .</p>

    <p class="text-gray-300">The SFTM modeling of Rescue-Prime when  <span class="math">r</span>  is odd As shown in Fig.5a, let  <span class="math">x_{r}, y_{r}, z_{r}</span>  be the outputs of the three S-boxes  <span class="math">(S^{-1})</span>  in the  <span class="math">r</span> -th step. Now we will construct equations from the backward direction and the forward direction, respectively.</p>

    <p class="text-gray-300">In the backward direction, for each even  <span class="math">i</span>  with  <span class="math">0 &amp;lt; i \\leq r - 1</span> , let  <span class="math">x_{i}, y_{i}, z_{i}</span>  be the inputs of the three S-boxes  <span class="math">(S)</span>  in the  <span class="math">i</span> -th step. Then it can be seen from Fig.5b and Fig.5a that</p>

    <p class="text-gray-300"><span class="math">\\left\\{ \\begin{array}{l}x_{r}^{3} = L_{i,0}^{-1}\\circ SSS\\circ L_{i + 1}^{-1}(x_{i + 2},y_{i + 2},z_{i + 2})\\\\ y_{r}^{3} = L_{i,1}^{-1}\\circ SSS\\circ L_{i + 1}^{-1}(x_{i + 2},y_{i + 2},z_{i + 2})\\\\ z_{r}^{3} = L_{i,2}^{-1}\\circ SSS\\circ L_{i + 1}^{-1}(x_{i + 2},y_{i + 2},z_{i + 2}) \\end{array} \\right.</span>  for  <span class="math">i\\in \\{2,4,\\ldots ,r - 3\\}</span>  (12)</p>

    <p class="text-gray-300"><span class="math">\\left\\{ \\begin{array}{l}x_{r - 1}^{3} = L_{r - 1,0}^{-1}(x_{r}^{3},y_{r}^{3},z_{r}^{3})\\\\ y_{r - 1}^{3} = L_{r - 1,1}^{-1}(x_{r}^{3},y_{r}^{3},z_{r}^{3}),\\\\ z_{r - 1}^{3} = L_{r - 1,2}^{-1}(x_{r}^{3},y_{r}^{3},z_{r}^{3}) \\end{array} \\right.</span>  (13)</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> (a) Eq.(13) modeling</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> (b) Eq.(12) modeling</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> (c) Eq.(14) modeling Fig. 5: SFTM modeling for odd  <span class="math">r</span></p>

    <p class="text-gray-300">where  <span class="math">L_{i}^{-1}</span>  is the inverse of the affine transformation  <span class="math">L_{i}</span> , and  <span class="math">L_{i,j}^{-1}</span>  is the  <span class="math">j</span> -th output of  <span class="math">L_{i}^{-1}</span>  with  <span class="math">j \\in \\{0,1,2\\}</span> .</p>

    <p class="text-gray-300">Similarly, in the forward direction, for each odd  <span class="math">i</span>  with  <span class="math">r &amp;lt; i \\leq 2r - 1</span> , let  <span class="math">x_{i}, y_{i}, z_{i}</span>  be the outputs of the three S-boxes  <span class="math">(S^{-1})</span>  in the  <span class="math">i</span> -th step. Then it can be seen from Fig.5c that</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{l} x _ {i} ^ {3} = L _ {i - 1, 0} \\circ S S S \\circ L _ {i - 2} \\left(x _ {i - 2}, y _ {i - 2}, z _ {i - 2}\\right) \\\\ y _ {i} ^ {3} = L _ {i - 1, 1} \\circ S S S \\circ L _ {i - 2} \\left(x _ {i - 2}, y _ {i - 2}, z _ {i - 2}\\right) \\\\ z _ {i} ^ {3} = L _ {i - 1, 2} \\circ S S S \\circ L _ {i - 2} \\left(x _ {i - 2}, y _ {i - 2}, z _ {i - 2}\\right) \\end{array} \\right. \\text {f o r} i \\in \\{r + 2, r + 4, \\dots , 2 r - 1 \\}. \\tag {14}</span></div>

    <p class="text-gray-300">The inputs and outputs of  <span class="math">r</span> -round Rescue-Prime are of the form  <span class="math">(<em>,</em>,0)</span>  in the CICO problem, with the same notations defined above, there are two more equations,</p>

    <div class="my-4 text-center"><span class="math-block">\\left(C _ {- 1, 2}\\right) ^ {3} = L _ {0, 2} ^ {- 1} \\circ S S S \\circ L _ {1} ^ {- 1} \\left(x _ {2}, y _ {2}, z _ {2}\\right), \\tag {15}</span></div>

    <div class="my-4 text-center"><span class="math-block">L _ {2 r - 1, 2} \\left(x _ {2 r - 1}, y _ {2 r - 1}, z _ {2 r - 1}\\right) = 0, \\tag {16}</span></div>

    <p class="text-gray-300">where  <span class="math">C_{-1,2}</span>  is the third constant of the additional AddC operation before the first round of Rescue-Prime.</p>

    <p class="text-gray-300">The SFTM modeling of Rescue-Prime when  <span class="math">r</span>  is even As shown in Fig.6, let  <span class="math">x_{r}, y_{r}, z_{r}</span>  be the inputs of the three S-boxes (S) in the  <span class="math">r</span> -th step. For each</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> (a) Eq.(18) modeling</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> (b) Eq.(17) modeling</p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a> (c) Eq.(19) modeling Fig. 6: SFTM modeling for even  <span class="math">r</span></p>

    <p class="text-gray-300">even  <span class="math">i</span>  with  <span class="math">0 &amp;lt; i &amp;lt; r - 1</span> , let  <span class="math">x_{i},y_{i},z_{i}</span>  be the inputs of the three S-boxes  <span class="math">(S)</span>  in the  <span class="math">i</span> -th step; while for each odd  <span class="math">i</span>  with  <span class="math">r &amp;lt; i &amp;lt; 2r - 1</span> , let  <span class="math">x_{i},y_{i},z_{i}</span>  be the outputs of the three S-boxes  <span class="math">(S^{-1})</span>  in the  <span class="math">i</span> -step. Then in a similar argument to Case odd, we can obtain</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{l} x _ {i} ^ {3} = L _ {i, 0} ^ {- 1} \\circ S S S \\circ L _ {i + 1} ^ {- 1} \\left(x _ {i + 2}, y _ {i + 2}, z _ {i + 2}\\right) \\\\ y _ {i} ^ {3} = L _ {i, 1} ^ {- 1} \\circ S S S \\circ L _ {i + 1} ^ {- 1} \\left(x _ {i + 2}, y _ {i + 2}, z _ {i + 2}\\right) \\quad \\text {f o r} i \\in \\{2, 4, \\dots , r - 2 \\}, \\\\ z _ {i} ^ {3} = L _ {i, 2} ^ {- 1} \\circ S S S \\circ L _ {i + 1} ^ {- 1} \\left(x _ {i + 2}, y _ {i + 2}, z _ {i + 2}\\right) \\end{array} \\right. \\tag {17}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{l} x _ {r + 1} ^ {3} = L _ {r, 0} \\left(x _ {r} ^ {3}, y _ {r} ^ {3}, z _ {r} ^ {3}\\right) \\\\ y _ {r + 1} ^ {3} = L _ {r, 1} \\left(x _ {r} ^ {3}, y _ {r} ^ {3}, z _ {r} ^ {3}\\right), \\\\ z _ {r + 1} ^ {3} = L _ {r, 2} \\left(x _ {r} ^ {3}, y _ {r} ^ {3}, z _ {r} ^ {3}\\right) \\end{array} \\right. \\tag {18}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{l} x _ {i} ^ {3} = L _ {i - 1, 0} \\circ S S S \\circ L _ {i - 2} \\left(x _ {i - 2}, y _ {i - 2}, z _ {i - 2}\\right) \\\\ y _ {i} ^ {3} = L _ {i - 1, 1} \\circ S S S \\circ L _ {i - 2} \\left(x _ {i - 2}, y _ {i - 2}, z _ {i - 2}\\right) \\\\ z _ {i} ^ {3} = L _ {i - 1, 2} \\circ S S S \\circ L _ {i - 2} \\left(x _ {i - 2}, y _ {i - 2}, z _ {i - 2}\\right) \\end{array} \\right. \\text {f o r} i \\in \\{r + 3, r + 5, \\dots , 2 r - 1 \\}, \\tag {19}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(C _ {- 1, 2}\\right) ^ {3} = L _ {0, 2} ^ {- 1} \\circ S S S \\circ L _ {1} ^ {- 1} \\left(x _ {2}, y _ {2}, z _ {2}\\right), \\tag {20}</span></div>

    <div class="my-4 text-center"><span class="math-block">L _ {2 r - 1, 2} \\left(x _ {2 r - 1}, y _ {2 r - 1}, z _ {2 r - 1}\\right) = 0. \\tag {21}</span></div>

    <p class="text-gray-300">Table 3: The polynomials in SFTM modeling</p>

    <p class="text-gray-300">|  r is odd  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  {fxi=x3i-1i0i0SSS∘Li+1(xi+2,yi+2,zi+2)fyi=y3i-1i0i0SSS∘Li+1(xi+2,yi+2,zi+2) for i∈{2,4,...,r-3},fzi=zi3i-1i0i0SSS∘Li+1(xi+2,yi+2,zi+2){fxi=x3i-1i0i0SSS∘Li+1(xi+2,yi+2,zi+2)fyi=y3i-1i0i0SSS∘Li+1(xi+2,yi+2,zi+2)fzi=zi3i-1i0i0SSS∘Li+1(xi+2,yi+2,zi+2)}  |</p>

    <p class="text-gray-300">|  {fxi=x3i-1i0i0SSS∘Li+1(xi+2,yi+2,zi+2)fyi=y3i-1i0i0SSS∘Li+1(xi+2,yi+2,zi+2) for i∈{r+2,r+4,...,2r-1},fzi=zi3i-1i0i0SSS∘Li+1(xi+2,yi+2,zi+2)  |</p>

    <p class="text-gray-300">|  r is even  |</p>

    <p class="text-gray-300">|  {fxi=x3i-1i0i0SSS∘Li+1(xi+2,yi+2,zi+2)fyi=y3i-1i0i0SSS∘Li+1(xi+2,yi+2,zi+2) for i∈{2,4,...,r-2},fzi=zi3i-1i0i0SSS∘Li+1(xi+2,yi+2,zi+2)fxi=x3i-1i0i0SSS∘Li+1(xi+2,yi+2,zi+2)fzi=zi3i-1i0i0SSS∘Li+1(xi+2,yi+2,zi+2)  |</p>

    <p class="text-gray-300">|  {fxi=x3i-1i0i0SSS∘Li+1(xi+2,yi+2,zi+2)fyi=y3i-1i0i0SSS∘Li+1(xi+2,yi+2,zi+2) for i∈{r+3,r+5,...,2r-1},fzi=zi3i-1i0i0SSS∘Li+1(xi+2,yi+2,zi+2)  |</p>

    <p class="text-gray-300">Solving the system of equations with the resultant-based method. It can be seen from Eqs.(12)-(16) that the system of equations has  <span class="math">3r - 1</span>  equations  <span class="math">(3r - 2</span>  equations are of degree 3 and one equation is of degree 1) in  <span class="math">3r</span>  unknowns in total. Since the number of unknowns is one more than that of equations, the system of equations always has solutions. We can then randomly assign a value to one of the variables, say  <span class="math">x_{r}</span> , and solve the remaining variables to speed up the solving process in a practical attack. If the system has no solutions for this assignment, we can repeatedly (usually not too many times) assign another random value to  <span class="math">x_{r}</span>  until we can get a solution. Similar to the case in Sect.4.1, such a system of equations also has a special structure that clearly gives a path for the elimination of variables when solved by resultants. As presented in Algorithm 2, we will get two bivariate polynomials  <span class="math">f_{l}, f_{h} \\in \\mathbb{F}_{q}[y_{r}, z_{r}]</span>  and further use them to compute  <span class="math">R(f_{l}, f_{h}, z_{r})</span>  to eliminate  <span class="math">z_{r}</span> . When the number of rounds is high, the two polynomials would be quite complicated and directly computing the resultant  <span class="math">R(f_{l}, f_{h}, z_{r})</span>  usually suffers from memory overflow. Instead, we can assign a number of values to the variable  <span class="math">y_{r}</span>  and get many interpolation pairs, and further use the fast Lagrange interpolation introduced in Sect.2.3 to recover the univariate polynomial. Another benefit of using the fast Lagrange interpolation</p>

    <p class="text-gray-300">is that it can be computed in parallel, which can further reduce the attack time if there are enough threads. Once a root of the final univariate polynomial is found, the corresponding CICO problem can be solved by substituting back.</p>

    <p class="text-gray-300">|  Algorithm 2: Get two bivariate polynomials for r-round Rescue-Prime  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Input: fl, fh, fxi, fyi, fzi as defined in Table 3.  |   |</p>

    <p class="text-gray-300">|  Output: two bivariate polynomials.  |   |</p>

    <p class="text-gray-300">|  1 i← 2r-1;  |   |</p>

    <p class="text-gray-300">|  2 while i > r do  |   |</p>

    <p class="text-gray-300">|  3 fh← R(fh, fzi, zi);  |   |</p>

    <p class="text-gray-300">|  4 apply the cubic substitution to fh;  |   |</p>

    <p class="text-gray-300">|  5 fh← R(fh, fyi, yi);  |   |</p>

    <p class="text-gray-300">|  6 apply the cubic substitution to fh;  |   |</p>

    <p class="text-gray-300">|  7 fh← R(fh, fxi, xi);  |   |</p>

    <p class="text-gray-300">|  8 apply the cubic substitution to fh;  |   |</p>

    <p class="text-gray-300">|  9 i← i-2;  |   |</p>

    <p class="text-gray-300">|  10 end  |   |</p>

    <p class="text-gray-300">|  11 i← 2;  |   |</p>

    <p class="text-gray-300">|  12 while i < r do  |   |</p>

    <p class="text-gray-300">|  13 fl← R(fl, fzi, zi);  |   |</p>

    <p class="text-gray-300">|  14 apply the cubic substitution to fl;  |   |</p>

    <p class="text-gray-300">|  15 fl← R(fl, fyi, yi);  |   |</p>

    <p class="text-gray-300">|  16 apply the cubic substitution to fl;  |   |</p>

    <p class="text-gray-300">|  17 fl← R(fl, fxi, xi);  |   |</p>

    <p class="text-gray-300">|  18 apply the cubic substitution to fl;  |   |</p>

    <p class="text-gray-300">|  19 i← i+2;  |   |</p>

    <p class="text-gray-300">|  20 end  |   |</p>

    <p class="text-gray-300">|  21 return fh, fl.  |   |</p>

    <p class="text-gray-300">Complexity analysis. Similar to the case under forward modeling, the time complexity of solving the CICO problem under SFTM modeling consists of four parts: (1) the cubic substitutions in Algorithm 2; (2) the computations of resultants in Algorithm 2; (3) the computation of the final resultant  <span class="math">R(f_{l},f_{h},z_{r})</span> ; (4) finding roots of univariate polynomials.</p>

    <p class="text-gray-300">It can be seen from Algorithm 2 that, for  <span class="math">r</span> -round Rescue-Prime, there are at most  <span class="math">3 \\cdot \\lfloor r / 2 \\rfloor</span>  variables to be eliminated in the first (lines 2-10) or the second (lines 12-20) loop. Similar to the case under forward modeling, the degree of  <span class="math">f_{l}</span>  (resp.  <span class="math">f_{h}</span> ) in Algorithm 2 after each update is increased over the original  <span class="math">f_{l}</span>  (resp.  <span class="math">f_{h}</span> ) by a factor of three.</p>

    <p class="text-gray-300">The time complexities of the first two parts are given in Theorems 3 and 4. As the deduction and proof are pretty similar to those for Theorems 1 and 2, we omit the proof here.</p>

    <p class="text-gray-300">Theorem 3. The time complexity of performing all the cubic substitutions in Algorithm 2 is</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {O} \\left(\\sum_ {k = 1} ^ {\\lambda} 2 0 \\cdot \\left(1 3 ^ {3} \\cdot \\binom {d _ {k} + \\lambda - k - 1} {\\lambda - k} \\cdot (3 ^ {k} + 1) ^ {2} + 1 2 1 7 4 5\\right) \\cdot (\\lambda - k)\\right),</span></div>

    <p class="text-gray-300">where  <span class="math">\\lambda = 3\\cdot \\lfloor r / 2\\rfloor</span>  and  <span class="math">d_{k} = \\min \\left(3^{k} - 12,6\\cdot (\\lambda -k - 1)\\right)</span></p>

    <p class="text-gray-300">Theorem 4. The time complexity of the computation of all the resultants in Algorithm 2 is</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {O} \\left(\\sum_ {k = 1} ^ {\\lambda} 3 0 \\cdot \\max  \\left((3 ^ {k} + 1) ^ {2} \\cdot 7 ^ {\\lambda - k + 3}, (2 \\cdot 3 ^ {k - 1} + 1) ^ {2} (3 ^ {k - 1} + 1) ^ {2} \\cdot 1 5 ^ {\\lambda - k}\\right)\\right),</span></div>

    <p class="text-gray-300">where  <span class="math">\\lambda = 3\\cdot \\lfloor r / 2\\rfloor</span></p>

    <p class="text-gray-300">For the third part of computing the final resultant  <span class="math">R(f_{l},f_{h},z_{r})</span> , the situation is slightly different. Theorem 5 gives the time complexity of this part with a proof.</p>

    <p class="text-gray-300">Theorem 5. Let  <span class="math">f_{l}</span>  and  <span class="math">f_{h}</span>  be the output polynomials of Algorithm 2 of which the degrees are denoted as  <span class="math">d_{l}</span>  and  <span class="math">d_{h}</span> , respectively. Then the time complexity of computing the resultant  <span class="math">R(f_{l},f_{h},z_{r})</span>  is</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {O} \\left(d _ {l} d _ {h} \\cdot \\left(\\mathcal {T} _ {1} + \\mathcal {T} _ {2}\\right) + \\mathcal {T} _ {3}\\right),</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathcal{T}_1 = \\big(d_l^2\\log (d_l) + d_h^2\\log (d_h)\\big)</span> ,  <span class="math">\\mathcal{T}_2 = (d_l + d_h)^\\omega</span> ,  <span class="math">\\mathcal{T}_3 = (d_ld_h\\log (d_ld_h))</span> , and  <span class="math">\\omega</span>  is the linear algebra exponent.</p>

    <p class="text-gray-300">Proof. The time complexity of computing the resultant  <span class="math">R(f_{l},f_{h},z_{r})</span>  consists of three steps: (1) assigning a value to  <span class="math">y_{r}</span> ; (2) computing  <span class="math">R(f_{l},f_{h},z_{r})</span> ; (3) using the fast Lagrange interpolation to recover the final univariate polynomial.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Assigning a value to  <span class="math">y_{r}</span> . Let  <span class="math">f_{l} = u_{d_{l}}(y_{r})z_{r}^{d_{l}} + \\dots + u_{1}(y_{r})z_{r} + u_{0}(y_{r})</span> , where  <span class="math">u_{j}(y_{r}) \\in \\mathbb{F}_{q}[y_{r}]</span>  with a degree no more than  <span class="math">d_{l} - j</span>  for  <span class="math">0 \\leq j \\leq d_{l}</span> . For each assignment  <span class="math">a</span>  to  <span class="math">y_{r}</span> , we need to compute each  <span class="math">u_{j}(a)</span>  which requires at most  <span class="math">d_{l}\\log d_{l}</span>  field operations using the square-and-multiply technique. As there are  <span class="math">d_{l} + 1</span>  such polynomials, the overall complexity is  <span class="math">d_{l}(d_{l} + 1)\\log d_{l}</span> . Similarly,  <span class="math">d_{h}(d_{h} + 1)\\log d_{h}</span>  field operations are required to assign a value for  <span class="math">f_{h}</span> . Therefore, the time complexity of this step is around  <span class="math">\\mathcal{T}_1 = (d_l^2\\cdot \\log (d_l) + d_h^2\\cdot \\log (d_h))</span>  for each assignment.</li>

      <li>Computing  <span class="math">R(f_{l}, f_{h}, z_{r})</span> . The time complexity of computing  <span class="math">R(f_{l}, f_{h}, z_{r})</span>  is equal to that of computing a determinate of  <span class="math">(d_{l} + d_{h})</span> -dimension Sylvester matrix which takes  <span class="math">(d_{l} + d_{h})^{\\omega}</span>  filed operations. Therefore, the time complexity of this step per interpolation point is  <span class="math">\\mathcal{T}_{2} = (d_{l} + d_{h})^{\\omega}</span> .</li>

    </ul>

    <p class="text-gray-300">5 A result of Coppersmith and Winograd [15] yields <span class="math">\\omega = 2.376</span>, which is asymptotic since it involves extremely large constant overheads. From a practical point-of-view, the best achievable result for <span class="math">\\omega</span> is given by Strassen’s algorithm[26], where <span class="math">\\omega = 2.807</span>.</p>

    <p class="text-gray-300">24</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Fast Lagrange interpolation. The degree of the final univariate polynomial is upper bound by  <span class="math">d_{l} \\cdot d_{h}</span> , and so the time complexity of this step is  <span class="math">\\mathcal{T}_3 = (d_l \\cdot d_h \\cdot \\log (d_l \\cdot d_h))</span> .</li>

    </ul>

    <p class="text-gray-300">Therefore, the time complexity of the final resultant computation is</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {O} \\left(d _ {l} \\cdot d _ {h} \\cdot \\left(\\mathcal {T} _ {1} + \\mathcal {T} _ {2}\\right) + \\mathcal {T} _ {3}\\right).</span></div>

    <p class="text-gray-300">The time complexities of the different steps of our attack against Rescue-Prime under SFTM modeling are presented in Table 4.</p>

    <p class="text-gray-300">Table 4: Time complexities of algebraic attacks under SFTM modeling against Rescue-Prime and the degrees of  <span class="math">f_{l}, f_{h}</span> , and  <span class="math">f</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Complexity of resultants</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Complexity of cubic substitutions</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">dl</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">dh</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">deg(f)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Complexity of SFTM attacks</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">238.94</td>

            <td class="px-3 py-2 border-b border-gray-700">235.62</td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

            <td class="px-3 py-2 border-b border-gray-700">36</td>

            <td class="px-3 py-2 border-b border-gray-700">310</td>

            <td class="px-3 py-2 border-b border-gray-700">240.31</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">238.94</td>

            <td class="px-3 py-2 border-b border-gray-700">235.62</td>

            <td class="px-3 py-2 border-b border-gray-700">37</td>

            <td class="px-3 py-2 border-b border-gray-700">36</td>

            <td class="px-3 py-2 border-b border-gray-700">313</td>

            <td class="px-3 py-2 border-b border-gray-700">248.37</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">257.92</td>

            <td class="px-3 py-2 border-b border-gray-700">247.84</td>

            <td class="px-3 py-2 border-b border-gray-700">37</td>

            <td class="px-3 py-2 border-b border-gray-700">39</td>

            <td class="px-3 py-2 border-b border-gray-700">316</td>

            <td class="px-3 py-2 border-b border-gray-700">259.96</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">257.92</td>

            <td class="px-3 py-2 border-b border-gray-700">247.84</td>

            <td class="px-3 py-2 border-b border-gray-700">310</td>

            <td class="px-3 py-2 border-b border-gray-700">39</td>

            <td class="px-3 py-2 border-b border-gray-700">319</td>

            <td class="px-3 py-2 border-b border-gray-700">268.95</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">276.94</td>

            <td class="px-3 py-2 border-b border-gray-700">260.77</td>

            <td class="px-3 py-2 border-b border-gray-700">310</td>

            <td class="px-3 py-2 border-b border-gray-700">312</td>

            <td class="px-3 py-2 border-b border-gray-700">322</td>

            <td class="px-3 py-2 border-b border-gray-700">280.57</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Now we give a summary about the proposed algebraic attack on AO primitives, which consists of four ingredients with the following four steps.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Construct a system of equations using forward modeling or SFTM modeling.</li>

      <li>Combine the resultant and the cubic substitution theory to eliminate variables in a specific order and finally get two bivariate polynomials.</li>

      <li>When the number of rounds is small, one can directly compute the resultant of the last two bivariate polynomials to derive the ultimate univariate polynomial. While when the number of rounds is high, the resultant of the last two bivariate polynomials is usually hard to compute directly. Instead, one can assign several values to one of the two variables and get many interpolation pairs. Then, the fast Lagrange interpolation is used to recover the univariate polynomial.</li>

      <li>Find all the roots of the derived univariate polynomial and then substitute the root values back to the original system of equations to find the collision of the algorithm.</li>

    </ol>

    <p class="text-gray-300">In this section, we present the experimental results of our algebraic attack on Rescue-Prime. The experiments were performed on a workstation: the operating</p>

    <p class="text-gray-300">system is Windows 10, the CPU circuit is Intel(R) Xeon(R) Gold 6248R CPU 3.00GHz with 48 cores, and the maximum memory is 256G. We use SageMath 9.2 to construct equations for Rescue-Prime and use Maple 2023 to solve the system of equations. Finally, we use the "FpX_halfgcd" command of PARI/GP to find all the roots of a univariate polynomial.</p>

    <p class="text-gray-300">Table 5: Attack complexities of Rescue-Prime</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ethereum r Foundation's time complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Best theoretical complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Time complexity of SFTM</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Time complexity forward modeling</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Best practical time in [8]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Practical time of SFTM</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Practical time of forward modeling</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">237.5</td>

            <td class="px-3 py-2 border-b border-gray-700">243</td>

            <td class="px-3 py-2 border-b border-gray-700">243.02</td>

            <td class="px-3 py-2 border-b border-gray-700">240.49</td>

            <td class="px-3 py-2 border-b border-gray-700">258500s</td>

            <td class="px-3 py-2 border-b border-gray-700">2256.7s</td>

            <td class="px-3 py-2 border-b border-gray-700">885.5s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">245</td>

            <td class="px-3 py-2 border-b border-gray-700">257</td>

            <td class="px-3 py-2 border-b border-gray-700">252.93</td>

            <td class="px-3 py-2 border-b border-gray-700">252.99</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ one day</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As mentioned, we mainly focus on the instance of  <span class="math">t = 3</span>  and the total number of rounds in this case is 11, which is derived using the code in [27, page 9, Algorithm 7]. We mainly compare our results to the benchmark results in [8], so we also use the challenge parameters published by the Ethereum foundation with</p>

    <div class="my-4 text-center"><span class="math-block">p = 1 8 4 4 6 7 4 4 0 7 3 7 0 9 5 5 1 5 5 7 = 2 ^ {6 4} - 5 9.</span></div>

    <p class="text-gray-300">We succeed to solve the CICO problem of 4-round Rescue-Prime, in which two models (forward modeling and SFTM modeling) are considered to construct the equations. Practical attacks under SFTM modeling and forward modeling take 2256.7s and 885.5s, respectively, introducing 100-fold improvement over the results in [8]. We also find a 5-round collision of Rescue-Prime under SFTM modeling which was originally thought as "hard" in the Ethereum Foundation challenge. For 5-round Rescue-Prime, the system of equations constructed under SFTM modeling has 14 equations in total. The 14 polynomials involved in the system are  <span class="math">f_{l}</span> ,  <span class="math">f_{x_{2}}</span> ,  <span class="math">f_{y_{2}}</span> ,  <span class="math">f_{z_{2}}</span> ,  <span class="math">f_{x_{4}}</span> ,  <span class="math">f_{y_{4}}</span> ,  <span class="math">f_{z_{4}}</span> ,  <span class="math">f_{x_{7}}</span> ,  <span class="math">f_{y_{7}}</span> ,  <span class="math">f_{z_{7}}</span> ,  <span class="math">f_{x_{9}}</span> ,  <span class="math">f_{y_{9}}</span> ,  <span class="math">f_{z_{9}}</span> , and  <span class="math">f_{h}</span> . Using Algorithm 2, we get two bivariate polynomials  <span class="math">f_{l}</span>  and  <span class="math">f_{h}</span> , of which the degrees are  <span class="math">3^{7}</span>  and  <span class="math">3^{6}</span> , respectively. Since the memory cost of computing  <span class="math">R(f_{l}, f_{h}, z_{5})</span>  is too high, we use 16 threads to compute Lagrange interpolation points. Each thread computes 100,000 points, which takes an average of 70,000 seconds. We use 32 threads and combine a fast multi-point evaluation algorithm to finish the pre-computation, which takes 9385.285s. Recovering the univariate polynomial using the fast Lagrange interpolation takes 2486.71s. It takes less than 10 seconds to solve the final single-variable equation of degree  <span class="math">3^{13}</span> . The time cost of each part is shown in Fig.7, where "Final resultant", "Other resultants", "Cubic substitutions" and "Total time" mean the time consumed for the final resultant, for the rest of resultants, for cubic substitutions and the overall attack, respectively. Experimental results are shown in Table 5.</p>

    <p class="text-gray-300">!<a href="img-9.jpeg">img-9.jpeg</a> Fig. 7: Comparison of time consumed by each part for solving the CICO problem of Rescue-Prime under SFTM modeling</p>

    <p class="text-gray-300">We now apply our methods to a new class of AO primitives Anemoi [11], and provide better cryptanalysis results than existing ones.</p>

    <p class="text-gray-300">Anemoi is a new family of ZK-friendly permutations that works over  <span class="math">\\mathbb{F}_q^{2l}(l\\geq 1)</span> , where  <span class="math">q</span>  is either a prime number or  <span class="math">q = 2^n</span>  with  <span class="math">n</span>  being an odd positive integer. Different choices of parameters would affect how Anemoi works, and we mainly focus on the version of  <span class="math">l = 1</span>  and  <span class="math">q</span>  being a prime number  <span class="math">p</span> . The original paper [11] gives two hash function instances based on Anemoi with  <span class="math">l = 1</span> : AnemoiSponge-BN-254, with a 254-bit prime  <span class="math">p</span> , and AnemoiSponge-BLS12-381, with a 381-bit prime  <span class="math">p</span> . Both instances are claimed to achieve 127 bits of security.</p>

    <p class="text-gray-300">The round function of Anemoi has the structure of a classical substitution-permutation network, which consists of three components: the constant addition  <span class="math">\\mathcal{A}</span> , the linear layer  <span class="math">\\mathcal{M}</span> , and the nonlinear layer  <span class="math">\\mathcal{H}</span> . The linear layer includes a diffusion layer and a pseudo-Hadamard transform, while for the version we considered ( <span class="math">l = 1</span> ), there is a unique column in the internal state, and the diffusion layer can be removed. For given  <span class="math">q</span> , number of rounds  <span class="math">r</span> , and  <span class="math">l = 1</span> , the Anemoi permutation over  <span class="math">\\mathbb{F}_q^2</span>  is described as</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A n e m o i} = \\mathcal {M} \\circ R _ {r - 1} \\circ \\dots \\circ R _ {0},</span></div>

    <p class="text-gray-300">where  <span class="math">R_{i} = \\mathcal{H}\\circ \\mathcal{M}\\circ \\mathcal{A}_{i}</span>  for  <span class="math">0\\leq i\\leq r - 1</span> . The  <span class="math">i</span> -th round of Anemoi is illustrated in Fig.8 and we below give more details about the three operations  <span class="math">\\mathcal{A}_i,\\mathcal{M}</span> , and  <span class="math">\\mathcal{H}</span> .</p>

    <p class="text-gray-300">!<a href="img-10.jpeg">img-10.jpeg</a> Fig. 8: Illustration of the <span class="math">i</span>-th round of Anemoi</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Constant Additions <span class="math">\\mathcal{A}_i</span>. The operation adds round constants <span class="math">(c_i, d_i)</span> to the input vector <span class="math">(x_i, y_i)</span> of the <span class="math">i</span>-th round.</li>

      <li>Linear Layer <span class="math">\\mathcal{M}</span>: The Pseudo-Hadamard transform is applied to destroy some undesirable involutive patterns in the nonlinear layer, which is defined as <span class="math">\\mathcal{M}(x,y) = (2x + y, x + y)</span>.</li>

      <li>Nonlinear Layer <span class="math">\\mathcal{H}</span>. The schematic of <span class="math">\\mathcal{H}</span> is illustrated in Fig.9. Let <span class="math">u_i, v_i \\in \\mathbb{F}_q</span> and <span class="math">x_{i+1}, y_{i+1} \\in \\mathbb{F}_q</span> be the inputs and outputs of <span class="math">\\mathcal{H}</span>, respectively. Then the nonlinear layer <span class="math">\\mathcal{H}</span> can be expressed as</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{H}(u_i, v_i) = (u_i + g z_i^2 - 2 g v_i z_i - g^{-1}, v_i - z_i), \\tag{22}</span></div>

    <p class="text-gray-300">where <span class="math">g</span> is a generator of the multiplicative subgroup of the field <span class="math">\\mathbb{F}_q</span> and <span class="math">z_i</span> is an intermediate variable output of the operation <span class="math">x^{1/\\alpha}</span> (<span class="math">\\alpha</span> usually takes values 3, 5, 7, or 11 if <span class="math">q</span> is an odd prime number).</p>

    <p class="text-gray-300">The CICO problem of Anemoi, which is denoted by <span class="math">\\mathcal{P}_{\\mathrm{CICO}}</span> in [12], consisting of finding <span class="math">(y_{in}, y_{out}) \\in \\mathbb{F}_q^2</span> such that <span class="math">\\mathsf{Anemoi}(0, y_{in}) = (0, y_{out})</span>.</p>

    <p class="text-gray-300">!<a href="img-11.jpeg">img-11.jpeg</a> Fig. 9: The <span class="math">\\mathcal{H}</span> function of Anemoi (<span class="math">q</span> is odd).</p>

    <p class="text-gray-300">!<a href="img-12.jpeg">img-12.jpeg</a> Fig. 10: The <span class="math">\\mathcal{H}^{-1}</span> function of Anemoi (<span class="math">q</span> is odd)</p>

    <p class="text-gray-300">28</p>

    <p class="text-gray-300">We mainly focus on the Anemoi instance of  <span class="math">\\alpha = 3</span>  with  <span class="math">r</span>  rounds. Let the notations  <span class="math">x_{i},y_{i},c_{i},d_{i},u_{i},v_{i},z_{i},x_{i + 1},y_{i + 1}</span>  be as in Sect.5.1 for  <span class="math">0\\leq i\\leq r - 1</span> . Then it is clear that</p>

    <div class="my-4 text-center"><span class="math-block">(u _ {i}, v _ {i}) = \\mathcal {M} \\circ \\mathcal {A} _ {i} (x _ {i}, y _ {i}) = (2 x _ {i} + y _ {i} + 2 c _ {i} + d _ {i}, x _ {i} + y _ {i} + c _ {i} + d _ {i}).</span></div>

    <p class="text-gray-300">Since  <span class="math">(x_{i + 1},y_{i + 1}) = (u_i + gz_i^2 -2gv_iz_i - g^{-1},v_i - z_i)</span> , a simple computation yields</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{l} x _ {i + 1} = 2 x _ {i} + y _ {i} + g z _ {i} ^ {2} - 2 g z _ {i} \\cdot \\left(x _ {i} + y _ {i} + c _ {i} + d _ {i}\\right) + \\delta_ {i} \\\\ y _ {i + 1} = x _ {i} + y _ {i} - z _ {i} + c _ {i} + d _ {i} \\\\ z _ {i} ^ {3} = 2 x _ {i} + y _ {i} - g \\cdot \\left(x _ {i} + y _ {i} + c _ {i} + d _ {i}\\right) ^ {2} + \\delta_ {i} \\end{array} , \\right. \\tag {23}</span></div>

    <p class="text-gray-300">where  <span class="math">\\delta_{i} = 2c_{i} + d_{i} - g^{-1}</span>  is a constant. Since the functions  <span class="math">\\mathcal{A}_i</span> ,  <span class="math">\\mathcal{M}</span> , and  <span class="math">\\mathcal{H}</span>  (the schematic of  <span class="math">\\mathcal{H}^{-1}</span>  is illustrated in Fig.10) in Anemoi are all invertible, with a similar discussion as above, we can get that</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{l} x _ {i} = x _ {i + 1} + g z _ {i} ^ {2} + 2 g z _ {i} y _ {i + 1} + g ^ {- 1} - z _ {i} - y _ {i + 1} - c _ {i} \\\\ y _ {i} = 2 z _ {i} + 2 y _ {i + 1} - x _ {i + 1} - g z _ {i} ^ {2} - 2 g z _ {i} y _ {i + 1} - g ^ {- 1} - d _ {i}. \\\\ z _ {i} ^ {3} = x _ {i + 1} - g y _ {i + 1} ^ {2} \\end{array} \\right. \\tag {24}</span></div>

    <p class="text-gray-300">!<a href="img-13.jpeg">img-13.jpeg</a> Fig. 11: SFTM modeling for Anemoi</p>

    <p class="text-gray-300">Construction of Equations. Inspired by the analysis of Rescue-Prime, we still use the SFTM technique to construct the equations of the CICO problem of Anemoi. Due to the  <span class="math">x \\to x^{\\frac{1}{3}}</span>  operation in  <span class="math">\\mathcal{H}</span> , the cubic substitution method is also applicable. For  <span class="math">r</span> -round Anemoi, we set intermediate variables  <span class="math">x_{\\lfloor r / 2 \\rfloor} = x, y_{\\lfloor r / 2 \\rfloor} = y</span>  as illustrated in Fig.11. If  <span class="math">i &amp;gt; \\lfloor r / 2 \\rfloor</span> , then by repeatedly using (23), those variables  <span class="math">x_i, y_i, z_i</span>  can be repeatedly expressed by intermediate variables of the lower rounds, and in the end can be expressed in variables</p>

    <p class="text-gray-300"><span class="math">x,y,z_{\\lfloor r/2\\rfloor},z_{\\lfloor r/2\\rfloor+1},\\ldots,z_{r-1}</span>. On the other hand, if <span class="math">i &amp;lt; \\lfloor r/2\\rfloor</span>, then by repeatedly using (24), those variables <span class="math">x_i,y_i,z_i</span> can be repeatedly expressed by intermediate variables of the higher rounds, and in the end can be expressed in variables <span class="math">x,y,z_0,z_1,\\ldots,z_{\\lfloor r/2\\rfloor-1}</span>.</p>

    <p class="text-gray-300">To solve the CICO problem of Anemoi, we need to find <span class="math">(y_{in}, y_{out}) \\in \\mathbb{F}_q^2</span> such that <span class="math">\\text{Anemoi}(0, y_{in}) = (0, y_{out})</span>, which immediately follows that <span class="math">x_0 = 0</span>. Since</p>

    <div class="my-4 text-center"><span class="math-block">\\text{Anemoi}(0, y_{in}) = \\mathcal{M}(x_r, y_r) = (2x_r + y_r, x_r + y_r),</span></div>

    <p class="text-gray-300">it follows that <span class="math">2x_r + y_r = 0</span>. The above discussion implies that <span class="math">x_0</span> and <span class="math">2x_r + y_r</span> can be expressed in variables <span class="math">x, y, z_0, z_1, \\ldots, z_{\\lfloor r/2 \\rfloor - 1}</span> and <span class="math">x, y, z_{\\lfloor r/2 \\rfloor}, z_{\\lfloor r/2 \\rfloor + 1}, \\ldots, z_{r-1}</span>, respectively. For convenience, let us denote</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} x_0 \\triangleq f_l(x, y, z_0, z_1, \\ldots, z_{\\lfloor r/2 \\rfloor - 1}), \\\\ 2x_r + y_r \\triangleq f_h(x, y, z_{\\lfloor r/2 \\rfloor}, z_{\\lfloor r/2 \\rfloor + 1}, \\ldots, z_{r-1}). \\end{array}</span></div>

    <p class="text-gray-300">Similarly, let us denote</p>

    <div class="my-4 text-center"><span class="math-block">z_i^3 - x_{i+1} + g y_{i+1}^2 \\triangleq g_i(x, y, z_i, z_{i+1}, \\ldots, z_{\\lfloor r/2 \\rfloor - 1})</span></div>

    <p class="text-gray-300">for <span class="math">0 \\leq i \\leq \\lfloor r/2 \\rfloor - 1</span>, and</p>

    <div class="my-4 text-center"><span class="math-block">z_i^3 - (2x_i + y_i - g \\cdot (x_i + y_i + c_i + d_i)^2 + \\delta_i) \\triangleq g_i(x, y, z_{\\lfloor r/2 \\rfloor}, z_{\\lfloor r/2 \\rfloor + 1}, \\ldots, z_i)</span></div>

    <p class="text-gray-300">for <span class="math">\\lfloor r/2 \\rfloor &amp;lt; i \\leq r - 1</span>.</p>

    <p class="text-gray-300">Then the CICO problem of Anemoi can be modeled with the following system of equations</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{l} f_l(x, y, z_0, z_1, \\ldots, z_{\\lfloor r/2 \\rfloor - 1}) = 0 \\\\ g_0(x, y, z_0, z_1, \\ldots, z_{\\lfloor r/2 \\rfloor - 1}) = 0 \\\\ g_1(x, y, z_1, z_2, \\ldots, z_{\\lfloor r/2 \\rfloor - 1}) = 0 \\\\ \\ldots \\\\ g_{\\lfloor r/2 \\rfloor - 1}(x, y, z_{\\lfloor r/2 \\rfloor - 1}) = 0 \\\\ g_{\\lfloor r/2 \\rfloor}(x, y, z_{\\lfloor r/2 \\rfloor}) = 0 \\\\ \\ldots \\\\ g_{r-2}(x, y, z_{\\lfloor r/2 \\rfloor}, z_{\\lfloor r/2 \\rfloor + 1}, \\ldots, z_{r-2}) = 0 \\\\ g_{r-1}(x, y, z_{\\lfloor r/2 \\rfloor}, z_{\\lfloor r/2 \\rfloor + 1}, \\ldots, z_{r-1}) = 0 \\\\ f_h(x, y, z_{\\lfloor r/2 \\rfloor}, z_{\\lfloor r/2 \\rfloor + 1}, \\ldots, z_{r-1}) = 0 \\end{array} \\right., \\tag{25}</span></div>

    <p class="text-gray-300">which has <span class="math">r + 2</span> equations with <span class="math">r + 2</span> unknowns in total.</p>

    <p class="text-gray-300">Solving the system of equations with resultant-based method. Equations in Eq. (25) indicate a path for eliminating the intermediate variables by the resultant. Following Algorithm 3, we can get two bivariate polynomials <span class="math">f_l</span> and <span class="math">f_h</span> only in variables <span class="math">x</span> and <span class="math">y</span> in the end. Then, we compute the roots of the univariate polynomial <span class="math">R(f_l, f_h, y)</span>, and the CICO problem is solved.</p>

    <p class="text-gray-300">|  Algorithm 3: Get two bivariate polynomials for r-round Anemoi  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Input: fl, fh, g0, g1, ..., gr-1.  |   |</p>

    <p class="text-gray-300">|  Output: two bivariate polynomials.  |   |</p>

    <p class="text-gray-300">|  1 i←0;  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2 while i <</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">do</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  3 fl←R(fl, gi, zi);  |   |</p>

    <p class="text-gray-300">|  4 applying the cubic substitution to fl;  |   |</p>

    <p class="text-gray-300">|  5 i←i+1;  |   |</p>

    <p class="text-gray-300">|  6 end  |   |</p>

    <p class="text-gray-300">|  7 i←r-1;  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">8 while i ≥</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">do</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  9 fh←R(fl, gi, zi);  |   |</p>

    <p class="text-gray-300">|  10 applying the cubic substitution to fh;  |   |</p>

    <p class="text-gray-300">|  11 i←i-1;  |   |</p>

    <p class="text-gray-300">|  12 end  |   |</p>

    <p class="text-gray-300">|  13 return fl, fh.  |   |</p>

    <p class="text-gray-300">Complexity analysis. As computing  <span class="math">R(f_{l}, f_{h}, y)</span>  takes far more time than the other resultants, we take its time complexity as the main time complexity (a comparison of time consumed by each step is shown in Fig. 12). The authors in [13] proved that the degree of the ideal induced by  <span class="math">\\mathcal{P}_{\\mathrm{CICO}}</span>  of  <span class="math">r</span> -round Anemoi is  <span class="math">(\\alpha + 2)^{r}</span> . For the case  <span class="math">\\alpha = 3</span> , we have a similar observation that  <span class="math">\\deg(f_{l}) = 5^{\\lfloor r/2 \\rfloor}</span>  and  <span class="math">\\deg(f_{h}) = 5^{\\lceil r/2 \\rceil}</span> , which is also confirmed by our experiments. By Theorem 5, the time complexities of our attacks are presented in Table 6.</p>

    <p class="text-gray-300">The experiment environment for Anemoi is exactly the same to that for RescuePrime. We use the same prime number  <span class="math">p = 0\\mathrm{x}64\\mathrm{ec}6\\mathrm{dd}0392073</span>  as that in [7]. For 8-round Anemoi, the system of equations constructed under SFTM modeling in total has 10 equations in 10 unknowns. The 10 polynomials corresponding to the system are  <span class="math">f_{l}, g_{0}, \\ldots, g_{7}, f_{h}</span> . Following Algorithm 3, we compute the resultants of  <span class="math">f_{l}</span>  with  <span class="math">g_{0}, g_{1}, g_{2}, g_{3}</span>  in turn and  <span class="math">f_{h}</span>  with  <span class="math">g_{7}, g_{6}, g_{5}, g_{4}</span>  in turn. After the computations of above resultants,  <span class="math">\\deg(f_{l}) = \\deg(f_{h}) = 3^{4}</span> , and then the univariate polynomial obtained by the final resultant  <span class="math">R(f_{l}, f_{h}, y)</span>  is of degree  <span class="math">5^{8}</span> . We use four threads to compute Lagrange interpolation points, each of which computes 100,000 points. The running time of the four threads is 29642.521s, 27547.542s, 27853.072s, and 27785.910s, respectively. We use eight threads and combine a fast multi-point evaluation algorithm to finish the precomputation, which takes 9535.405s. Recovering the univariate polynomial using the fast Lagrange interpolation takes 1006.516s. The practical attack time is presented in Table 7, which greatly improves the running time compared to that in [7]. Fig.12 compares the time consumed for "Final resultant", "Other resultants", "Cubic substitutions" and "Total time".</p>

    <p class="text-gray-300">Table 6: Time complexities of our attack against Anemoi using SFTM modeling and the degrees of  <span class="math">f_{l}, f_{h}</span> , and  <span class="math">f</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Number of equations</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Highest degree of fl</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Highest degree of fh</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Degree of a single f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Time complexity</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">51</td>

            <td class="px-3 py-2 border-b border-gray-700">52</td>

            <td class="px-3 py-2 border-b border-gray-700">53</td>

            <td class="px-3 py-2 border-b border-gray-700">219.56</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">52</td>

            <td class="px-3 py-2 border-b border-gray-700">52</td>

            <td class="px-3 py-2 border-b border-gray-700">54</td>

            <td class="px-3 py-2 border-b border-gray-700">223.32</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">52</td>

            <td class="px-3 py-2 border-b border-gray-700">53</td>

            <td class="px-3 py-2 border-b border-gray-700">55</td>

            <td class="px-3 py-2 border-b border-gray-700">229.60</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">53</td>

            <td class="px-3 py-2 border-b border-gray-700">53</td>

            <td class="px-3 py-2 border-b border-gray-700">56</td>

            <td class="px-3 py-2 border-b border-gray-700">233.38</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">53</td>

            <td class="px-3 py-2 border-b border-gray-700">54</td>

            <td class="px-3 py-2 border-b border-gray-700">57</td>

            <td class="px-3 py-2 border-b border-gray-700">239.58</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">54</td>

            <td class="px-3 py-2 border-b border-gray-700">54</td>

            <td class="px-3 py-2 border-b border-gray-700">58</td>

            <td class="px-3 py-2 border-b border-gray-700">243.42</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">54</td>

            <td class="px-3 py-2 border-b border-gray-700">55</td>

            <td class="px-3 py-2 border-b border-gray-700">59</td>

            <td class="px-3 py-2 border-b border-gray-700">249.57</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">55</td>

            <td class="px-3 py-2 border-b border-gray-700">55</td>

            <td class="px-3 py-2 border-b border-gray-700">510</td>

            <td class="px-3 py-2 border-b border-gray-700">253.46</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">55</td>

            <td class="px-3 py-2 border-b border-gray-700">56</td>

            <td class="px-3 py-2 border-b border-gray-700">511</td>

            <td class="px-3 py-2 border-b border-gray-700">259.59</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">56</td>

            <td class="px-3 py-2 border-b border-gray-700">56</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">263.53</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">56</td>

            <td class="px-3 py-2 border-b border-gray-700">57</td>

            <td class="px-3 py-2 border-b border-gray-700">513</td>

            <td class="px-3 py-2 border-b border-gray-700">269.64</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">57</td>

            <td class="px-3 py-2 border-b border-gray-700">57</td>

            <td class="px-3 py-2 border-b border-gray-700">514</td>

            <td class="px-3 py-2 border-b border-gray-700">273.63</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

            <td class="px-3 py-2 border-b border-gray-700">57</td>

            <td class="px-3 py-2 border-b border-gray-700">58</td>

            <td class="px-3 py-2 border-b border-gray-700">515</td>

            <td class="px-3 py-2 border-b border-gray-700">279.72</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">58</td>

            <td class="px-3 py-2 border-b border-gray-700">58</td>

            <td class="px-3 py-2 border-b border-gray-700">516</td>

            <td class="px-3 py-2 border-b border-gray-700">283.74</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

            <td class="px-3 py-2 border-b border-gray-700">19</td>

            <td class="px-3 py-2 border-b border-gray-700">58</td>

            <td class="px-3 py-2 border-b border-gray-700">59</td>

            <td class="px-3 py-2 border-b border-gray-700">517</td>

            <td class="px-3 py-2 border-b border-gray-700">289.83</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">59</td>

            <td class="px-3 py-2 border-b border-gray-700">59</td>

            <td class="px-3 py-2 border-b border-gray-700">518</td>

            <td class="px-3 py-2 border-b border-gray-700">293.87</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">19</td>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

            <td class="px-3 py-2 border-b border-gray-700">59</td>

            <td class="px-3 py-2 border-b border-gray-700">510</td>

            <td class="px-3 py-2 border-b border-gray-700">519</td>

            <td class="px-3 py-2 border-b border-gray-700">299.96</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

            <td class="px-3 py-2 border-b border-gray-700">510</td>

            <td class="px-3 py-2 border-b border-gray-700">510</td>

            <td class="px-3 py-2 border-b border-gray-700">520</td>

            <td class="px-3 py-2 border-b border-gray-700">2104.01</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

            <td class="px-3 py-2 border-b border-gray-700">23</td>

            <td class="px-3 py-2 border-b border-gray-700">510</td>

            <td class="px-3 py-2 border-b border-gray-700">511</td>

            <td class="px-3 py-2 border-b border-gray-700">521</td>

            <td class="px-3 py-2 border-b border-gray-700">2110.10</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 7: Comparison with [7] in practical attack time of Anemoi</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The attacks in [7]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our attacks</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">< 0.01s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.423s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">0.34s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.973s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">23.3s</td>

            <td class="px-3 py-2 border-b border-gray-700">7.113s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">2127s</td>

            <td class="px-3 py-2 border-b border-gray-700">296.568s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">167201s</td>

            <td class="px-3 py-2 border-b border-gray-700">2968.55s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">38749.182s</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In this section, we apply our algebraic attack on the block cipher JARVIS, which is one member of the MARVELous family of cryptographic primitives that are specifically designed for STARK efficiency [5].</p>

    <p class="text-gray-300">!<a href="img-14.jpeg">img-14.jpeg</a> Figure 12: Comparison of time consumed by each part for solving the CICO problem of Anemoi</p>

    <h3 id="sec-33" class="text-xl font-semibold mt-8">6.1 Design Description of Jarvis</h3>

    <p class="text-gray-300">The design of Jarvis is inspired by the design of AES, but adapts each step to be more STARK-friendly. The most significant change is that it works with large S-boxes over the whole state instead of individual bytes.</p>

    <p class="text-gray-300">Jarvis <em>[5]</em> works over the finite field <span class="math">\\mathbb{F}_{2^{n}}</span>, where <span class="math">n</span> can take 128, 160, 192, and 256. The round function of Jarvis is shown in Fig. 13, which consists of a non-linear layer, a linear layer, and a key addition operation. The non-linear layer is a large S-box defined as the generalized inverse function <span class="math">S:\\mathbb{F}_{2^{n}}\\rightarrow\\mathbb{F}_{2^{n}}</span> with</p>

    <p class="text-gray-300">\\[ S(x)=\\left\\{\\begin{array}[]{ll}x^{-1}\\text{, if }x\\neq 0;\\\\ 0,\\quad\\text{ if }x=0.\\end{array}\\right. \\] (26)</p>

    <p class="text-gray-300">The authors mention that the function performs especially well over ZK-STARKs as its transition constraint is <span class="math">x^{2}S(x)+x=0</span>.</p>

    <p class="text-gray-300">The linear layer is a composite function expressed as <span class="math">A=C\\circ B^{-1}</span>, where the affine monic permutation polynomials have the following forms</p>

    <p class="text-gray-300"><span class="math">B(X)=X^{4}+b_{2}X^{2}+b_{1}X+b_{0},</span></p>

    <p class="text-gray-300"><span class="math">C(X)=X^{4}+c_{2}X^{2}+c_{1}X+c_{0},</span></p>

    <p class="text-gray-300">with <span class="math">b_{2},b_{1},b_{0},c_{2},c_{1},c_{0}\\in\\mathbb{F}_{2^{n}}</span>. The linear layer is designed in such a way to be STARK-friendly and also provide high efficiency.</p>

    <p class="text-gray-300">A round key addition is followed after the linear layer. The key schedule of Jarvis shares the similar structure with the round function, but without the linear layer.</p>

    <p class="text-gray-300">!<a href="img-15.jpeg">img-15.jpeg</a> Fig. 13: The <span class="math">i</span>-th round of the Jarvis block cipher.</p>

    <h2 id="sec-34" class="text-2xl font-bold">6.2 Construction of equations and attack against Jarvis.</h2>

    <p class="text-gray-300">The authors instantiate versions of Jarvis offering 128, 160, 192, and 256-bit security. However, the security claims are broken by Gröbner basis attacks [2] using a smart equation modeling technique. We also investigate the algebraic properties of Jarvis and present a faster algebraic attack using the resultant. We mention that we use the same equation modeling techniques in [2] and mainly present better results for solving the nonlinear equations. For <span class="math">r</span>-round Jarvis, set <span class="math">x_{i}</span> as one intermediate variable in the middle of each round as shown in Fig. 13. Then two rounds of Jarvis can be connected with high probability by</p>

    <div class="my-4 text-center"><span class="math-block">\\left(C \\left(x _ {i}\\right) + k _ {i}\\right) \\cdot B \\left(x _ {i + 1}\\right) = 1</span></div>

    <p class="text-gray-300">for <span class="math">i \\in \\{0,1,\\ldots,r-1\\}</span>. The subkeys of two consecutive are linked by</p>

    <div class="my-4 text-center"><span class="math-block">\\left(k _ {i + 1} + c _ {i}\\right) \\cdot k _ {i} = 1. \\tag {27}</span></div>

    <p class="text-gray-300">In [2], the authors constructed two monic affine polynomials <span class="math">D(x)</span> and <span class="math">E(x)</span> with degrees of four which satisfy <span class="math">D(B) = E(C)</span>.</p>

    <p class="text-gray-300">We rewrite the forms of the equations in the <span class="math">i</span>-th round as</p>

    <div class="my-4 text-center"><span class="math-block">B \\left(x _ {i}\\right) = \\frac {1}{C \\left(x _ {i - 1}\\right) + k _ {i - 1}}, C \\left(x _ {i}\\right) = \\frac {1}{B \\left(x _ {i + 1}\\right)} + k _ {i}.</span></div>

    <p class="text-gray-300">Then these two equations can be reduced to one equation by</p>

    <div class="my-4 text-center"><span class="math-block">D \\left(\\frac {1}{C (x _ {i - 1}) + k _ {i - 1}}\\right) = D (B (x _ {i})) = E (C (x _ {i})) = E \\left(\\frac {1}{B (x _ {i + 1})} + k _ {i}\\right). \\tag {28}</span></div>

    <p class="text-gray-300">For <span class="math">i \\in \\{2,3,\\ldots,r-1\\}</span>, an equation of the form of Eq. (28) has a degree of 36. The plaintext <span class="math">p</span> and ciphertext <span class="math">c</span> are related to <span class="math">x_{2}</span> and <span class="math">x_{r}</span>, respectively, with equations</p>

    <div class="my-4 text-center"><span class="math-block">D \\left(\\frac {1}{p + k _ {0}}\\right) = E \\left(\\frac {1}{B (x _ {2})} + k _ {1}\\right), \\tag {29}</span></div>

    <div class="my-4 text-center"><span class="math-block">C \\left(x _ {r}\\right) + k _ {r} = c. \\tag {30}</span></div>

    <p class="text-gray-300">Two consecutive subkeys in Jarvis are connected by the relation below according to Eq. (27)</p>

    <div class="my-4 text-center"><span class="math-block">k _ {i + 1} = \\frac {1}{k _ {i}} + c _ {i}.</span></div>

    <p class="text-gray-300">The probability of <span class="math">k_{i}\\neq 0</span> is high over large fields. Therefore, each <span class="math">k_{i},i\\in\\{1,2,\\ldots,r\\}</span>, can be related to <span class="math">k_{0}</span> by</p>

    <p class="text-gray-300"><span class="math">k_{i}=\\frac{\\alpha_{i}\\cdot k_{0}+\\beta_{i}}{\\gamma_{i}\\cdot k_{0}+\\delta_{i}},</span></p>

    <p class="text-gray-300">where the four coefficients <span class="math">\\alpha_{i},\\beta_{i},\\gamma_{i},\\delta_{i}</span> are given in <em>[2]</em>.</p>

    <p class="text-gray-300">Assuming that the number of rounds <span class="math">r</span> is even, then the equations would take the following forms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\frac{r}{2}-1</span> equations have degrees of 40 in Eq. (28);</li>

      <li>one equation has a degree of 24 in Eq. (29);</li>

      <li>one equation has a degree of 5 in Eq. (30).</li>

    </ul>

    <p class="text-gray-300">We take 6-round Jarvis as an example. It contains four polynomials <span class="math">F_{0},F_{1},F_{2},F_{3}</span> of which the degrees are as below:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\deg(F_{0}(k_{0},x_{2}))=24</span> with <span class="math">\\deg_{x_{2}}(F_{0})=16</span> and <span class="math">\\deg_{k_{0}}(F_{0})=8</span>;</li>

      <li><span class="math">\\deg(F_{1}(k_{0},x_{2},x_{4}))=40</span> with <span class="math">\\deg_{x_{2}}(F_{1})=16</span>, <span class="math">\\deg_{x_{4}}(F_{1})=16</span>, and <span class="math">\\deg_{k_{0}}(F_{1})=8</span>;</li>

      <li><span class="math">\\deg(F_{2}(k_{0},x_{4},x_{6}))=40</span> with <span class="math">\\deg_{x_{4}}(F_{2})=16</span>, <span class="math">\\deg_{x_{6}}(F_{2})=16</span>, and <span class="math">\\deg_{k_{0}}(F_{2})=8</span>;</li>

      <li><span class="math">\\deg(F_{3}(k_{0},x_{6}))=5</span> with <span class="math">\\deg_{x_{6}}(F_{3})=4</span> and <span class="math">\\deg_{k_{0}}(F_{3})=1</span>.</li>

    </ul>

    <p class="text-gray-300">We can get a univariate polynomial <span class="math">f_{k_{0}}</span> in <span class="math">k_{0}</span> by computing the following resultant:</p>

    <p class="text-gray-300"><span class="math">R\\left(R\\left(F_{0},F_{1},x_{2}\\right),R\\left(F_{3},F_{2},x_{6}\\right),x_{4}\\right).</span></p>

    <p class="text-gray-300">Solving <span class="math">f_{k_{0}}</span> and we will get the key <span class="math">k_{0}</span>.</p>

    <h3 id="sec-35" class="text-xl font-semibold mt-8">6.3 Experimental results for Jarvis</h3>

    <p class="text-gray-300">The experiment environment for Jarvis is the same to that for Rescue-Prime, except that we use Magma V2.28-3 to solve the system of equations. We use the same finite field <span class="math">\\mathbb{F}_{2^{128}}=\\mathbb{F}_{2}[y]/(p(y))</span> of Jarvis-128 as defined in <em>[5]</em>, where <span class="math">p(y)=y^{128}+y^{7}+y^{2}+y+1</span>. We construct the equations using the method given in <em>[5]</em> but use the resultant-based method instead of the Gröbner basis method to solve the system of equations. For the practical attack on six rounds of Jarvis, a 100-fold increase in the running time is achieved over that in <em>[2]</em>. We also practically attack eight rounds of Jarvis for the first time, which consumes about 5.27 days (the memory consumption is about 68 GB). The comparison of the running time with that in <em>[5]</em> is presented in Table 8.</p>

    <h2 id="sec-36" class="text-2xl font-bold">7 Conclusions and Discussions</h2>

    <p class="text-gray-300">This paper presents a novel analysis framework of algebraic attacks against AO primitives that we think can serve as a new evaluation method. We make full use of the algebraic properties of AO primitives and propose to use resultants to</p>

    <p class="text-gray-300">Table 8: Comparison with [5] in practical attack time of JARVIS</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Time for other resultants</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Time for the final resultant</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Total practical time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Time in [5]</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">11.2s</td>

            <td class="px-3 py-2 border-b border-gray-700">357.76s</td>

            <td class="px-3 py-2 border-b border-gray-700">368.96s</td>

            <td class="px-3 py-2 border-b border-gray-700">99989.0s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">606.76s</td>

            <td class="px-3 py-2 border-b border-gray-700">455043.77s</td>

            <td class="px-3 py-2 border-b border-gray-700">455650.53s</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">solve systems of multivariate equations. We further use SFTM modeling, variable substitutions, and the fast Lagrange interpolation to simplify the derived multivariate system and accelerate the solving procedure. We apply the analysis framework to analyze the security of Rescue-Prime, Anemoi, and JARVIS, and achieve much faster practical attacks than existing ones for all the three primitives. Besides, the estimation of time complexity is more accurate than that in Gröbner basis attacks as the degrees of variables can be estimated more accurately and the elimination path for variables is definite.</p>

    <p class="text-gray-300">Based on our analysis and experiments, we have the following discussions that may deserve some attention.</p>

    <p class="text-gray-300">We take the 4-round Rescue-Prime as an example. In SFTM modeling, the resultant of the final two bivariate polynomials takes up most of the time (about  <span class="math">99.8\\%</span> ), but in forward modeling, the time spent for the cubic substitutions is the major cost (about  <span class="math">76.4\\%</span> ). In forward modeling, there are a total of 10 variables in the system of equations, and to get a univariate polynomial, 9 resultant computations and 36 cubic substitutions are required. However, each operation involves all the uneliminated variables that will increase memory and time consumption. It is the memory overflow problem that hinders higher-round attacks against Rescue-Prime under forward modeling even if it can bypass one round with no cost. Under SFTM modeling, it takes 3 resultant computations and 3 cubic substitutions to get  <span class="math">f_{l}</span> , 6 resultant computations and 15 cubic substitutions to get  <span class="math">f_{h}</span> . Each operation involves fewer variables than that under the forward modeling. For the most challenging part to compute  <span class="math">R(f_{l}, f_{h}, z_{4})</span> , it can be parallelized using the fast Lagrange interpolation. Therefore, memory and time consumption are reduced, making practical higher-round attacks possible.</p>

    <p class="text-gray-300">We now show how to do it if we want to combine SFTM modeling with the idea of bypassing the first round. We use the notations defined in Sect.3 and take the SFTM modeling for 4-round Rescue-Prime as an example, in which case we have 12 variables  <span class="math">x_{i}, y_{i}, z_{i}</span> ,  <span class="math">i \\in [2,4,5,7]</span> . As shown in Fig.3 and Eq.4, to bypass the first round, the output of the  <span class="math">x^{1/3}</span>  operations, denoted as  <span class="math">(X,Y,Z)</span> , should</p>

    <p class="text-gray-300">have the following form,</p>

    <p class="text-gray-300"><span class="math">(X,Y,Z)=(X,(-\\frac{\\alpha_{2,0}}{\\alpha_{2,1}})^{1/3}X,c).</span> (31)</p>

    <p class="text-gray-300">The variables <span class="math">X,Y,Z</span> also denote the input of the <span class="math">L_{1}</span> operation, i.e., <span class="math">X=L_{1,0}^{-1}(x_{2},y_{2},z_{2}),Y=L_{1,1}^{-1}(x_{2},y_{2},z_{2})</span>, and <span class="math">Z=L_{1,2}^{-1}(x_{2},y_{2},z_{2})</span>. Then we can get two polynomials <span class="math">f_{l1}</span> and <span class="math">f_{l2}</span> defined as</p>

    <p class="text-gray-300"><span class="math">f_{l1}=L_{1,1}^{-1}(x_{2},y_{2},z_{2})/L_{1,0}^{-1}(x_{2},y_{2},z_{2})-(-\\frac{\\alpha_{2,0}}{\\alpha_{2,1}})^{1/3},</span> <span class="math">f_{l2}=L_{1,2}^{-1}(x_{2},y_{2},z_{2})-c.</span></p>

    <p class="text-gray-300">To get the final univariate polynomial, we need to first get three polynomials <span class="math">f_{h},f_{l1},f_{l2}</span> in variables <span class="math">x_{4},y_{4},z_{4}</span>. For <span class="math">f_{h}</span>, we repeatedly use resultants to eliminate <span class="math">z_{7},y_{7},x_{7},z_{5},y_{5},x_{5}</span> in order and <span class="math">f_{h}</span> turns into a polynomial in the three variables. Each resultant computation will eliminate one variable. While for <span class="math">f_{l1}</span> and <span class="math">f_{l2}</span>, we need to first compute <span class="math">R(f_{l1},f_{z_{2}},z_{2})</span> and <span class="math">R(f_{l2},f_{z_{2}},z_{2})</span> to eliminate <span class="math">z_{2}</span> (one can also eliminate <span class="math">y_{2}</span> or <span class="math">x_{2}</span> instead), which takes two resultant computations. Therefore, the first disadvantage of combining the two methods is the increase in resultant computations.</p>

    <p class="text-gray-300">Now, we target to get the univariate polynomial based on <span class="math">f_{h},f_{l1}</span>, and <span class="math">f_{l2}</span>. In the original SFTM modeling, we have two bivariate polynomials and use fast Lagrange interpolation to get the univariate polynomial. But here, we need to perform one more resultant computation to eliminate one more variable of <span class="math">x_{4},y_{4},z_{4}</span> to get the bivariate polynomials. What is worse, the degrees of <span class="math">x_{4},y_{4},z_{4}</span> are all high and the resultant computation involves high overhead, and this gives the second reason for not combining the SFTM modeling with the idea of bypassing the first round.</p>

    <h3 id="sec-39" class="text-xl font-semibold mt-8">7.3 Discussion on our attack</h3>

    <p class="text-gray-300">We present some potential weaknesses of AO primitives that are susceptible to our attacks and give some potential improvements.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The time complexities of different steps in SFTM modeling are not balanced. For example, in our resultant-based attack, the most challenging part of attacking the algorithm is to compute the final resultant. However, the fast Lagrange interpolation can parallelize this step, and the practical result can be better than the theoretical estimation if there are enough threads in parallel.</li>

      <li>The variable isolation and substitution are very critical techniques in our attack, AO primitives that do not suffer from such problems can potentially resist our attack. Using nonlinear structures that do not result in variable isolation and substitution, e.g., Toffoli-like gates <em>[17]</em> and big S-boxes over extension finite fields <em>[6]</em>, may be a feasible design idea that deserves further investigation.</li>

      <li>The round constant add operation <span class="math">+</span> can be replaced by <span class="math">\\oplus</span>, which will add difficulties in establishing and solving equations.</li>

    </ol>

    <p class="text-gray-300">Acknowledgements. We would like to thank the anonymous reviewers for their positive reviews, valuable comments and questions. We would like to thank Topsec Technologies Group Inc for organizing the National Crypto-Math Challenge and Jiamin Cui from Shandong University for bringing us into the field of Arithmetic-Oriented algorithms. Thanks also go to Zhongxiao Wang and Ruijie Wang for their inspiration of interpolation ideas. This work was supported by the National Natural Science Foundation of China (Nos.12371526,62202492,and 62272303) and by the National Key Research and Development Program of China (No.2024YFB4504700).</p>

    <h2 id="sec-40" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Albrecht, M., Grassi, L., Rechberger, C., Roy, A., Tiessen, T.: Mimc: Efficient encryption and cryptographic hashing with minimal multiplicative complexity. In: International Conference on the Theory and Application of Cryptology and Information Security. pp. 191–219. Springer (2016)</li>

      <li>[2] Albrecht, M.R., Cid, C., Grassi, L., Khovratovich, D., Lüftenegger, R., Rechberger, C., Schofnegger, M.: Algebraic cryptanalysis of stark-friendly designs: application to marvellous and mimic. In: Advances in Cryptology–ASIACRYPT 2019: 25th International Conference on the Theory and Application of Cryptology and Information Security, Kobe, Japan, December 8–12, 2019, Proceedings, Part III 25. pp. 371–397. Springer (2019)</li>

      <li>[3] Albrecht, M.R., Rechberger, C., Schneider, T., Tiessen, T., Zohner, M.: Ciphers for mpc and fhe. In: Advances in Cryptology–EUROCRYPT 2015: 34th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Sofia, Bulgaria, April 26-30, 2015, Proceedings, Part I 34. pp. 430–454. Springer (2015)</li>

      <li>[4] Aly, A., Ashur, T., Ben-Sasson, E., Dhooghe, S., Szepieniec, A.: Design of symmetric-key primitives for advanced cryptographic protocols. IACR Transactions on Symmetric Cryptology pp. 1–45 (2020)</li>

      <li>[5] Ashur, T., Dhooghe, S.: Marvellous: a stark-friendly family of cryptographic primitives. Cryptology ePrint Archive (2018)</li>

      <li>[6] Ashur, T., Kindi, A., Mahzoun, M., Bhati, A.S.: Xhash8 and xhash12: Efficient stark-friendly hash functions. Cryptology ePrint Archive (2023)</li>

      <li>[7] Bariant, A., Boeuf, A., Lemoine, A., Ayala, I.M., Øygarden, M., Perrin, L., Raddum, H.: The algebraic freelunch efficient gröbner basis attacks against arithmetization-oriented primitives. Annual International Cryptology Conference, CRYPTO 2024, accepted (2024), https://eprint.iacr.org/2024/347, https://crypto.iacr.org/2024/acceptedpapers.php</li>

      <li>[8] Bariant, A., Bouvier, C., Leurent, G., Perrin, L.: Algebraic attacks against some arithmetization-oriented primitives. IACR Transactions on Symmetric Cryptology pp. 73–101 (2022)</li>

      <li>[9] Ben-Sasson, E., Goldberg, L., Levit, D.: Stark friendly hash–survey and recommendation. Cryptology ePrint Archive (2020)</li>

      <li>[10] Beyne, T., Canteaut, A., Dinur, I., Eichlseder, M., Leander, G., Leurent, G., Naya-Plasencia, M., Perrin, L., Sasaki, Y., Todo, Y., et al.: Out of oddity–new cryptanalytic techniques against symmetric primitives optimized for integrity proof systems.</li>

    </ul>

    <p class="text-gray-300">In: Advances in Cryptology–CRYPTO 2020: 40th Annual International Cryptology Conference, CRYPTO 2020, Santa Barbara, CA, USA, August 17–21, 2020, Proceedings, Part III 40. pp. 299–328. Springer (2020)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[11] Bouvier, C., Briaud, P., Chaidos, P., Perrin, L., Salen, R., Velichkov, V., Willems, D.: New design techniques for efficient arithmetization-oriented hash functions: anemoi permutations and jive compression mode. In: Annual International Cryptology Conference. pp. 507–539. Springer (2023)</li>

      <li>[12] Bouvier, C., Briaud, P., Chaidos, P., Perrin, L., Salen, R., Velichkov, V., Willems, D.: New design techniques for efficient arithmetization-oriented hash functions:anemoi permutations and jive compression mode. Cryptology ePrint Archive, Paper 2022/840 (2022), https://eprint.iacr.org/2022/840</li>

      <li>[13] Briaud, P.: A note of Anemoi gröbner bases. Cryptology ePrint Archive (2024)</li>

      <li>[14] Collins, G.E.: The calculation of multivariate polynomial resultants. Journal of the Acm 18(4), 515–532 (1971)</li>

      <li>[15] Coppersmith, D., Winograd, S.: Matrix multiplication via arithmetic progressions. In: Proceedings of the nineteenth annual ACM symposium on Theory of computing. pp. 1–6 (1987)</li>

      <li>[16] Diffie, W., Hellman, M.: Special feature exhaustive cryptanalysis of the nbs data encryption standard. Computer 10(6), 74–84 (1977). https://doi.org/10.1109/C-M.1977.217750</li>

      <li>[17] Dobraunig, C., Grassi, L., Guinet, A., Kuijsters, D.: Ciminion: symmetric encryption based on toffoli-gates over large finite fields. In: Annual International Conference on the Theory and Applications of Cryptographic Techniques. pp. 3–34. Springer (2021)</li>

      <li>[18] Dworkin, M.J.: Sha-3 standard: Permutation-based hash and extendable-output functions (2015)</li>

      <li>[19] von zur Gathen, J., Gerhard, J.: Modern computer algebra. Cambridge: Cambridge University Press, 2nd ed. edn. (2003)</li>

      <li>[20] Grassi, L., Hao, Y., Rechberger, C., Schofnegger, M., Walch, R., Wang, Q.: Horst meets fluid-spn: Griffin for zero-knowledge applications. In: Annual International Cryptology Conference. pp. 573–606. Springer (2023)</li>

      <li>[21] Grassi, L., Khovratovich, D., Lüftenegger, R., Rechberger, C., Schofnegger, M., Walch, R.: Reinforced concrete: a fast hash function for verifiable computation. In: Proceedings of the 2022 ACM SIGSAC Conference on Computer and Communications Security. pp. 1323–1335 (2022)</li>

      <li>[22] Grassi, L., Khovratovich, D., Rechberger, C., Roy, A., Schofnegger, M.: Poseidon: A new hash function for {Zero-Knowledge} proof systems. In: 30th USENIX Security Symposium (USENIX Security 21). pp. 519–535 (2021)</li>

      <li>[23] Grassi, L., Khovratovich, D., Schofnegger, M.: Poseidon2: A faster version of the poseidon hash function. In: International Conference on Cryptology in Africa. pp. 177–203. Springer (2023)</li>

      <li>[24] Rijmen, V., Daemen, J.: Advanced encryption standard. Proceedings of federal information processing standards publications, national institute of standards and technology 19, 22 (2001)</li>

      <li>[25] Roy, A., Steiner, M.J., Trevisani, S.: Arion: Arithmetization-oriented permutation and hashing from generalized triangular dynamical systems (2023)</li>

      <li>[26] Strassen, V.: Gaussian elimination is not optimal. Numerische mathematik 13(4), 354–356 (1969)</li>

      <li>[27] Szepieniec, A., Ashur, T., Dhooghe, S.: Rescue-prime: a standard specification (sok). Cryptology ePrint Archive, Paper 2020/1143 (2020), https://eprint.iacr.org/2020/1143</li>

    </ul>

    <p class="text-gray-300">28] Zhang, L., Liu, M., Li, S., Lin, D.: Cryptanalysis of ciminion. In: International Conference on Information Security and Cryptology. pp. 234–251. Springer (2022)</p>`;
---

<BaseLayout title="A New Security Evaluation Method Based on Resultant for Arit... (2024/886)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2024 &middot; eprint 2024/886
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
