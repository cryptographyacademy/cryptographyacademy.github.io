---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2018/1119';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Parallel Chains: Improving Throughput and Latency of Blockchain Protocols via Parallel Composition';
const AUTHORS_HTML = 'Matthias Fitzi, Peter Ga{ž}i, Aggelos Kiayias, Alexander Russell';

const CONTENT = `    <p class="text-gray-300">Matthias Fitzi<em>, Peter Gaži<strong>, Aggelos Kiayias</strong></em>, and Alexander Russell†</p>

    <p class="text-gray-300">November 30, 2018</p>

    <p class="text-gray-300">Abstract. Two of the most significant challenges in the design of blockchain protocols is increasing their transaction processing throughput and minimising latency in terms of transaction settlement. In this work we put forth for the first time a formal execution model that enables to express transaction throughput while supporting formal security arguments regarding safety and liveness. We then introduce parallel-chains, a simple yet powerful non-black-box composition technique for blockchain protocols. We showcase our technique by providing two parallel-chains protocol variants, one for the PoS and one for PoW setting, that exhibit optimal throughput under adaptive fail-stop corruptions while they retain their resiliency in the face of Byzantine adversity assuming honest majority of stake or computational power, respectively. We also apply our parallel-chains composition method to improve settlement latency; combining parallel composition with a novel transaction weighing mechanism we show that it is possible to scale down the time required for a transaction to settle by any given constant while maintaining the same level of security.</p>

    <h2 id="sec-2" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Blockchain protocols exhibit an inherent speed-security trade-off that depends on the latency of the underlying communication network. This was first formally illustrated in [18] by expressing how block production per round of message-passing, denoted <span class="math">f</span>, needs to be relatively small for security theorems to be meaningful. This was further refined in [33] where block production per unit of time was similarly restricted with respect to <span class="math">1/\\Delta</span>, where <span class="math">\\Delta</span> is the delay of the network, while for arbitrary delays a generic attack was formulated. The main conclusion of these theoretical analyses is that in order to achieve safety, a blockchain protocol must be operated at a relatively slow pace with respect to network latency. It is frequently observed (e.g., [18]), that Bitcoin's actual parameterisation sets the block production rate conservatively to be once every 30 (or so) rounds of message passing.</p>

    <p class="text-gray-300">This state of affairs severely impacts two critical performance characteristics of a distributed ledger that is implemented via a blockchain protocol; specifically, (i) its throughput, since long periods of silence between blocks result in an underutilisation of the available network bandwidth, and (ii) its settlement time, since blockchain protocols provide transaction safety with an exponential error in the number of blocks accumulated beyond the block that registers the transaction.</p>

    <p class="text-gray-300">Rectifying the above two performance issues lead to a number of developments in protocol design that adopted one of two possible strategies. The first one took a hybrid approach, using a blockchain protocol as a secure "back-end" while leaving transaction processing to a less secure or less decentralised "front-end" that, using more standard cryptographic techniques, provides better throughput and settlement times (at least in optimistic environments). This is exemplified by works such as Hybrid Consensus [34], Bitcoin-NG [16] and Thunderella [36]. The second approach redefines the underlying blockchain protocol, frequently radically deviating from the original blockchain protocol structure. This is exemplified by numerous Block-"Tree" or</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>IOHK. matthias.fitzi@iohk.io.</li>

    </ul>

    <p class="text-gray-300"><strong> IOHK. peter.gazi@iohk.io. </strong>* University of Edinburgh and IOHK. akiayias@inf.ed.ac.uk.. This research was partially supported by H2020 project PRIVILEDGE # 780477. † University of Connecticut and IOHK. acr@cse.uconn.edu.</p>

    <p class="text-gray-300">“DAG” protocol proposals such as GHOST <em>[39]</em>, Spectre <em>[38]</em>, Phantom <em>[41]</em>, GraphChain <em>[8]</em>, Tangle <em>[37]</em>, Conflux <em>[27]</em>, and Swirlds <em>[3]</em>.</p>

    <p class="text-gray-300">Despite the above developments the current state of the art is still lacking in terms of both a thorough modeling of transaction throughput and latency as well as a provable answer to the fundamental questions posed above, namely whether it is possible to provably achieve permissionless ledger consensus with honest majority that has optimal throughput and settlement time.</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">Our results.</h4>

    <p class="text-gray-300">We study a simple yet, as we show, very powerful composition operator over blockchain protocols: parallel composition. Our parallel-chains protocol composition technique is described as follows: given an underlying blockchain protocol, either in the proof-of-work (PoW) or the proof-of-stake (PoS) setting, we execute <span class="math">m</span> instances of it in parallel, while ensuring that the same mining, or staking respectively, operation can be used across all the <span class="math">m</span> instances. At any given moment, a combine algorithm can be invoked that processes the contents of the <span class="math">m</span> blockchains in the view of an honest party and organises them into a single ledger. Our results are summarised as follows.</p>

    <p class="text-gray-300">A theoretical framework for optimistic throughput. We put forth a new formal model that formally captures for the first time a concept of throughput for distributed ledger protocols. This is achieved by a novel fine-grained network diffusion functionality that reflects network communication with far greater precision compared to previous work. Specifically, our network functionality abstracts the uplink, transit queue as well as the downlink of each single party in the network. Whenever a message is transmitted, it is placed via a party’s uplink into the transit queue for all recipients. The uplink for each party is by definition one message per unit of time (we use the term “slot”) while the transit queue for each recipient can be arbitrarily manipulated by the adversary (for simplicity the parties in our model are symmetric). Messages in our setting are restricted to a fixed packet length and as such may be insufficient to carry all the transactions that are available in a party’s pool of pending transactions. At any given moment, messages may be placed by the adversary in a party’s downlink and become available to the party subject to a restriction that sets an upper bound on the number of messages that may be accessed from the downlink per slot. Using this network abstraction we introduce the following notion for block-based distributed-ledger protocol throughput: it is the ratio of blocks added in the common prefix of all honest parties divided by the number of slots – during any slot interval of some minimal length within the protocol execution. Armed with our framework, we analyse some standard proposals for scaling Bitcoin’s throughput. These proposals call for increasing the block production rate, increasing the block size, or letting the most recent block producer continuously process new transactions (a proposal that is embodied by Bitcoin-NG <em>[16]</em>). We illustrate that with the first two of these proposals it is impossible to bring the protocol’s throughput close to 1, a finding that formally affirms the folklore understanding that the Bitcoin blockchain protocol is inherently limited in terms of scaling its transaction processing capability and highlights the value of our formal framework as a yardstick for determining a protocol’s ability to achieve high throughput. Finally, Bitcoin-NG is capable of achieving near-optimal throughput assuming all parties are honest, nevertheless, its throughput becomes effectively zero in the setting of adaptive fail-stop corruptions; the reason stems from the fact that the protocol achieves its high throughput via centralising processing to block producers; an adaptive fail-stop adversary can simply shut down the servers once they are selected and thus effectively zero the throughput. Given this, the main question we ask is whether it is possible to achieve Byzantine resilience in the setting of honest majority, while simultaneously achieve (near) optimal throughput for fail-stop corruptions.</p>

    <p class="text-gray-300">A near optimal throughput PoS-based distributed ledger. We employ the parallel composition technique on a PoS blockchain. Each protocol participant proceeds in parallel across all <span class="math">m</span> blockchains utilising the total stake that exists for PoS block production. Note that multiple blocks may be emitted in each round depending on how many blocks have been found to extend the underlying blockchains. Parsing the <span class="math">m</span> blockchains into a single ledger is achieved by ordering transactions lexicographically according to the index of the block and the rank of the blockchain it belongs to (from 1 to <span class="math">m</span>). We demonstrate that the</p>

    <p class="text-gray-300">protocol achieves near optimal throughput, that can be made arbitrarily close to 1, while enjoying the same security guarantees as the underlying blockchain protocol. We make our construction explicit by applying the parallel composition mechanism on the Ouroboros-Praos PoS protocol <em>[13]</em>.</p>

    <p class="text-gray-300">A near optimal throughput PoW-based distributed ledger. We employ the parallel composition technique on a PoW blockchain. As with the PoS case, participants maintain <span class="math">m</span> blockchains, attempting to mine blocks simultaneously for all of them. Mining simultaneously for all <span class="math">m</span> chains requires to pack all possible ways to extend the blockchains, storing them in a Merkle root, and then revealing the appropriate path once the blockchain to be extended is discovered. An additional complication arises in the PoW setting as blocks do not carry a verifiable time-stamp (that, in the PoS setting, is provided for “free” by our construction). This prohibits the use of the same simple blockchain combine algorithm used in the PoS setting. Instead, we use the following mechanism: we identify one of the <span class="math">m</span> blockchains as the synchronisation chain and we have every block refer to a block of that chain which will play the role of a timestamp. Subsequently, roughly speaking, a block is stabilised as soon as both itself and its stabilisation block are confirmed with respect to their respective blockchains. For stable blocks, a total ordering of blocks can now easily be extracted. As in the PoS setting, we prove that our protocol achieves optimal throughput while enjoying essentially the same security guarantees as the underlying PoW-based blockchain protocol. Furthermore, composing <span class="math">m</span> blockchain protocols with full independence requires a PoW composition method; in order to achieve this (as required by our amplification technique) we generalize the 2-for-1 POWs technique introduced in <em>[18]</em> using a hash chain (or, alternatively, a PRG), yielding an <span class="math">m</span>-for-1 POW primitive that may be of independent interest.</p>

    <p class="text-gray-300">A settlement-time amplification technique. We finally employ the parallel composition technique to improve settlement time. Our technique applies to both the PoW and the PoS setting. Given as a starting point a blockchain protocol with exponentially small persistence error in a security parameter <span class="math">d</span> that expresses the time required to wait for a transaction to be settled, we show how the <span class="math">m</span>-fold parallel composition of the protocol can achieve a wait time <span class="math">d/m</span> for any constant <span class="math">m</span> for (roughly) the same level of safety error. This is achieved by a novel weighing mechanism that evaluates whether a transaction has been stabilised by combining depth information from all the blockchains that include the transactions. The transaction weighing mechanism combines via an exponential sum the weights of the transaction in each individual blockchain into a single cross-blockchain weight; subsequently settlement is determined via the difference of this weight with respect to the maximum weight that exists in the ledger for any transaction.</p>

    <p class="text-gray-300">Transaction sharding. As in all DAG-type proposals for distributed ledgers, the same transaction may be processed by multiple nodes during distributed ledger maintenance when the parallel-composition operator is applied. While this may be beneficial (as illustrated by our amplification techniques for settlement time), it may not be desirable in settings where we wish to avoid double processing of transactions to maximise throughput. In order to reduce overall network traffic in favor of higher throughput, we use a transaction sharding mechanism that partitions the set of possible transactions and assigns each respective subset to a different chain who will be responsible for mining the respective transactions. This has the desirable side-effect that a blockchain user may follow only one of the chains if they are interested in addresses that are clustered in that chain hence reducing the total amount of data that are required to be handled for keeping up to date.</p>

    <p class="text-gray-300">As a final note, in this paper we focus on the case where the number of chains <span class="math">m</span> is carefully selected at the onset as a parameter of the protocol and is constant throughout the execution. It is conceivable though that parallel chain composition could be adjusted to vary the number of active chains according to the evolving throughput needs (somewhat akin to the Bitcoin difficulty adjustment). We leave investigating this more general variant to future work.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Related work.</h4>

    <p class="text-gray-300">The hybrid approach that decouples (fast) transaction processing from (slow) blockchain protocol maintenance is intrinsic in the proposal by Eyal et al. <em>[16]</em> (Bitcoin-NG). Applying sortition to form committees in context of blockchain protocols was first proposed by Decker et al. <em>[14]</em> and further developed in different lines of work, e.g., <em>[23, 30, 34, 5]</em>. The impossibility of achieving settlement times that are constant in terms of the actual (unknown) protocol delay in the honest majority setting was put forth in <em>[34]</em>.</p>

    <p class="text-gray-300">Generalizing the chain structure of <em>[32]</em> to more general graphs was first considered by Sompolinsky et al. <em>[40]</em> and Lerner <em>[25]</em>. The former generalization (GHOST) still extracts a single chain to represent the ledger but the blocks of the complete block tree (including all forks) remain to contribute to this selection process in an attempt to preserve the PoW of the blocks outside the main chain. The latter suggests to organize the blocks in a directed acyclic graph (DAG) whereas a single block references multiple previous blocks. The first DAG protocols involving some type of formal analysis were proposed by Boyen et al. <em>[8]</em>, Sompolinsky et al. <em>[38, 41]</em> and Bentov et al. <em>[5]</em>. However, these proposals only involve qualitative arguments of eventual transaction safety without giving a full formal model for arguing about both safety, liveness and throughput. Other examples of DAG protocols are described by Popov <em>[37]</em> (IOTA) and Baird <em>[3]</em> (Hashgraph) — both not thoroughly analysed in the Byzantine permissionless setting. In <em>[27]</em>, Li et al. proposed the first DAG protocol that directly allows for a detailed analysis. As their protocol is basically an extension of the GHOST rule that additionally allows for the inclusion of the transactions of the off-chain blocks, maximal respective throughput is limited by the conditions under which the GHOST protocol can safely operate.</p>

    <p class="text-gray-300">Sharding in context of distributed ledgers was first suggested by Danezis et al. <em>[12]</em>, and by Croman et al. <em>[11]</em>. In the protocol by Gencer et al. <em>[20]</em> each miner operates over the full set of transactions whereas user nodes only need to observe shards of their interest as each shard maintains its own chain. In contrast, the protocol by Luu et al. <em>[28]</em> divides mining with respect to the different shards to different committees but still maintains one single chain such that user nodes must follow the complete history of the ledger. Kokoris-Kogias et al. <em>[24]</em> and Zamani et al. <em>[42]</em> proposed protocols where sharding is achieved with respect to miner and user by maintaining one dedicated chain per transaction class and also dividing mining respectively.</p>

    <p class="text-gray-300">Martino et al. <em>[29]</em> proposed to maintain a set of parallel chains wherein blocks permanently cross-reference blocks of some other chains based on special chain-neighborship properties, claiming to achieve better throughput than in the single-chain case — without giving a detailed analysis. Kiffer et al. <em>[22]</em> analysed the clique special case of <em>[29]</em> where each chain cross-references all other chains, and demonstrated its security when operated under the same overall block-generation rate as the single-chain case; whereas throughput under increased block-generation rate is not analysed. Similarly to the clique case above, Forestier et al. <em>[17]</em> suggest to maintain a set of parallel chains where each block cross-references the most recent block of every chain. Whereas, for PoS, they state that mining can be randomly assigned to the different chains, they propose no respective solution for PoW. No rigorous analysis of the protocol is given.</p>

    <p class="text-gray-300">We recently learned of concurrent, independent work by Bagaria et al. <em>[2]</em> achieving near-optimal transaction throughput and settlement times for proof-of-work blockchains. We defer a full comparison to their work to the next version of this paper.</p>

    <h5 id="sec-5" class="text-base font-semibold mt-4">Organisation.</h5>

    <p class="text-gray-300">In Section 2 we present preliminaries, definitions of standard security properties and notations. We then proceed to Section 3 to introduce our new and refined network model as well as our modeling of transaction throughput. After a warm-up investigation of the basic Bitcoin-scaling proposals in Section 4, in Section 5 we put forth our PoS parallel-composition method and apply it on Ouroboros Praos PoS. In Section 6 we apply the parallel-composition method to PoW-based blockchains. Finally, in Section 7 we present our settlement-time acceleration method via parallel composition.</p>

    <h2 id="sec-6" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">Basic Notation. For <span class="math">n\\in\\mathbb{N}</span> we use the notation <span class="math">[n]</span> to refer to the set <span class="math">\\{1,\\ldots,n\\}</span>. For brevity, we often write <span class="math">\\{x_{i}\\}_{i=1}^{n}</span> and <span class="math">(x_{i})_{i=1}^{n}</span> to denote the set <span class="math">\\{x_{1},\\ldots,x_{n}\\}</span> and the tuple <span class="math">(x_{1},\\ldots,x_{n})</span>, respectively.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Execution Model. We divide time into discrete units called slots. Parties are equipped with (roughly) synchronized clocks that indicate the current slot: we assume that any clock drift is subsumed in the slot length. Each slot is indexed by an integer <span class="math">t\\in\\{1,2,\\ldots\\}</span>. For an interval of slots <span class="math">I=[t_{1},t_{2}]</span> we denote its length as $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\triangleq t_{2}-t_{1}+1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We consider a UC-style <em>[9]</em> execution of a protocol <span class="math">\\Pi</span>, involving an environment <span class="math">\\mathcal{Z}</span>, a number of parties <span class="math">\\mathsf{P}_{i}</span>, functionalities that these parties can access while running the protocol (such as the functionality <span class="math">\\mathcal{F}_{\\text{diff}}</span> used for</p>

    <p class="text-gray-300">communication), and an adversary <span class="math">\\mathcal{A}</span>. All these entities are interactive algorithms. The environment controls the execution by activating parties via inputs it provides to them. The parties, unless corrupted, respond to such activations by following the protocol <span class="math">\\Pi</span> and invoking the available functionalities as needed. We denote by <span class="math">\\mathsf{Exec}\\left(\\Pi,\\mathcal{A},\\mathcal{Z}\\right)</span> the random variable containing the full transcript of an execution of the protocol <span class="math">\\Pi</span> with adversary <span class="math">\\mathcal{A}</span> and environment <span class="math">\\mathcal{Z}</span>.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Adaptive Corruptions.</h4>

    <p class="text-gray-300">The adversary influences the protocol execution by interacting with the available functionalities, and by corrupting parties. To corrupt a party, the adversary has to first ask the environment <span class="math">\\mathcal{Z}</span> for a permission. If the corruption is approved by <span class="math">\\mathcal{Z}</span> (via a special message from <span class="math">\\mathcal{Z}</span> to <span class="math">\\mathcal{A}</span>), the adversary corrupts <span class="math">\\mathsf{P}_{i}</span> immediately. We distinguish two types of corruption, Byzantine and fail-stop. A Byzantine corrupted party <span class="math">\\mathsf{P}_{i}</span> will relinquish its entire state to <span class="math">\\mathcal{A}</span>; from this point on, the adversary will be activated in place of the party <span class="math">\\mathsf{P}_{i}</span>. A fail-stop corrupted party, on the other hand, will simply stop executing its program and, whenever activated, will return an empty message <span class="math">\\bot</span>. We denote by <span class="math">\\mathbb{A}_{\\mathsf{fs}}</span> the class of adversaries that only perform fail-stop corruptions, and by <span class="math">\\mathbb{A}_{\\mathsf{b}}</span> those that also use Byzantine corruptions.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">Semi-synchronous Communication.</h4>

    <p class="text-gray-300">Our model allows for semi-synchronous communication among honest parties, where messages are guaranteed to be delivered within <span class="math">\\Delta</span> slots. This is formally captured by the functionality <span class="math">\\mathcal{F}_{\\mathsf{diff}}</span> that also models bandwidth-restricted communication, we describe it in Section 3. Note that the value <span class="math">\\Delta</span> is unknown to the protocol itself.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">Blockchains and Ledgers.</h4>

    <p class="text-gray-300">A <em>blockchain</em> (or a <em>chain</em>) (denoted e.g. <span class="math">\\mathsf{C}</span>) is a sequence of blocks where each block is connected to the previous one by containing its hash. The first block of a chain <span class="math">\\mathsf{C}</span> is called a <em>genesis block</em> and denoted by <span class="math">\\mathcal{G}</span>. The last block of <span class="math">\\mathsf{C}</span> is denoted by <span class="math">\\mathsf{head}(\\mathsf{C})</span>. By <span class="math">\\mathsf{C}^{\\lceil k}</span> we denote <span class="math">\\mathsf{C}</span> where the last <span class="math">k</span> blocks have been removed. We denote the extension of a chain <span class="math">\\mathsf{C}</span> by a block <span class="math">B</span> as <span class="math">\\mathsf{C}^{\\prime}=\\mathsf{C}\\parallel B</span>. For simplicity, we write <span class="math">B\\in\\mathsf{C}</span> iff <span class="math">\\mathsf{C}</span> contains block <span class="math">B</span>. By <span class="math">\\mathsf{len}(\\mathsf{C})</span> we denote the number of blocks in <span class="math">\\mathsf{C}</span>.</p>

    <p class="text-gray-300">A <em>ledger</em> (denoted in bold-face, e.g., <span class="math">\\mathbf{L}</span>) is a mechanism for maintaining a sequence of transactions, often stored in the form of a blockchain. We slightly abuse the language by letting <span class="math">\\mathbf{L}</span> (without further qualifiers) interchangeably refer to the algorithms used to maintain the sequence, and all the views of the participants of the state of these algorithms when being executed. For example, the (existing) ledger Bitcoin consists of the set of all transactions that ever took place in the Bitcoin network, the current UTXO set, as well as the local views of all the participants.</p>

    <p class="text-gray-300">In contrast, we call a <em>ledger state</em> a concrete sequence of transactions <span class="math">\\mathrm{tx}_{1},\\mathrm{tx}_{2},\\ldots</span> stored in the <em>stable</em> part of a ledger <span class="math">\\mathbf{L}</span>, typically as viewed by a particular party. Hence, in every blockchain-based ledger <span class="math">\\mathbf{L}</span>, every fixed chain <span class="math">\\mathsf{C}</span> defines a concrete ledger state by applying the interpretation rules given as a part of the description of <span class="math">\\mathbf{L}</span> (for example, the ledger state is obtained from the blockchain by dropping the last <span class="math">k</span> blocks and serializing the valid transactions in the remaining blocks). We maintain the typographic convention that a ledger state (e.g. <span class="math">\\mathsf{L}</span>) always belongs to the bold-face ledger of the same name (e.g. <span class="math">\\mathbf{L}</span>). We denote by <span class="math">\\mathbf{L}^{\\mathsf{P}}[t]</span> the ledger state of a ledger <span class="math">\\mathbf{L}</span> as viewed by a party <span class="math">\\mathsf{P}</span> at the end of a time slot <span class="math">t</span>. We say that a party <span class="math">\\mathsf{P}</span> reports a transaction <span class="math">\\mathrm{tx}</span> as <em>stable</em> during time slot <span class="math">t</span> iff <span class="math">\\mathrm{tx}\\in\\mathbf{L}^{\\mathsf{P}}[t]</span>. In contrast, <span class="math">\\tilde{\\mathbf{L}}^{\\mathsf{P}}[t]</span> denotes the ledger that contains additionally any transactions that are valid but still pending according to the view of party <span class="math">\\mathsf{P}</span>. For any <span class="math">t,\\mathsf{P}</span> it holds that <span class="math">\\mathbf{L}^{\\mathsf{P}}[t]\\preceq\\tilde{\\mathbf{L}}^{\\mathsf{P}}[t]</span> where <span class="math">\\preceq</span> denotes the prefix relation.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Finally, we introduce a specific class of transaction-ledger protocols that have the following structure: transactions are grouped into blocks, and the stable ledger state is determined by the protocol at any time <span class="math">t</span> by selecting which of the blocks seen so far are <em>stable</em>, ordering them according to some protocol-specific rule, interpreting them as a sequence of the transactions they contain, and sequentially removing all transactions from this sequence that would not be valid with respect to the remaining transactions that are preceeding them. We call such transaction ledger protocols <em>block-based</em> and remark that all protocols considered in this paper are block-based. Note that for a block-based ledger protocol <span class="math">\\mathbf{L}</span>, it is well-defined to treat a ledger state <span class="math">\\mathbf{L}^{\\mathsf{P}}[t]</span> as the sequence of the stable blocks that form it, allowing for notational shorthands such as for example $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{L}^{\\mathsf{P}}[t]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denoting the number of stable blocks for </span>\\mathsf{P}<span class="math"> at time </span>t<span class="math">, and </span>B\\in\\mathbf{L}^{\\mathsf{P}}[t]<span class="math"> to indicate that </span>B<span class="math"> is a stable block at time </span>t<span class="math"> for a party </span>\\mathsf{P}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Recall the definitions of persistence and liveness of a robust public transaction ledger adapted from the most recent version of <em>[18]</em>:</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 1.</h6>

    <p class="text-gray-300">A protocol <span class="math">\\Pi</span> implements a <em>robust transaction ledger (with respect to parameter <span class="math">u</span>)</em> iff it organizes the ledger as a sequence of transactions by satisfying the following properties:</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Persistence.</h6>

    <p class="text-gray-300">For any two honest parties <span class="math">\\mathsf{P}_{1},\\mathsf{P}_{2}</span> and time slots <span class="math">t_{1}\\leq t_{2}</span>, it holds that <span class="math">\\mathbf{L}^{\\mathsf{P}_{1}}[t_{1}]\\preceq\\tilde{\\mathbf{L}}^{\\mathsf{P}_{2}}[t_{2}]</span>. If all honest parties in the system attempt to include a transaction then, at any slot <span class="math">t</span> after <span class="math">u</span> slots (called the liveness parameter), any honest party <span class="math">\\mathsf{P}</span>, if queried, will report <span class="math">\\mathrm{tx}\\in\\mathbf{L}^{\\mathsf{P}}[t]</span>.</p>

    <p class="text-gray-300">When a ledger is implemented by a single blockchain, each party <span class="math">\\mathsf{P}</span> at time <span class="math">t</span> holds a single chain <span class="math">\\mathsf{C}</span> as its state. If we want to make <span class="math">\\mathsf{P}</span> and <span class="math">t</span> explicit, we denote this chain as <span class="math">\\mathsf{C}^{\\mathsf{P}}[t]</span>. For such blockchain-based ledger protocols, robustness is known to be implied by the following blockchain properties:</p>

    <p class="text-gray-300">A blockchain protocol achieves <em>common-prefix with parameter <span class="math">k\\in\\mathbb{N}</span></em> if for any pair of honest parties <span class="math">\\mathsf{P}_{0},\\mathsf{P}_{1}</span> and time slots <span class="math">t_{0},t_{1}</span> such that <span class="math">t_{0}\\leq t_{1}</span>, it holds that <span class="math">\\mathsf{C}^{\\mathsf{P}_{0}}[t_{0}]^{\\lceil k}\\preceq\\mathsf{C}^{\\mathsf{P}_{1}}[t_{1}]</span>. A blockchain protocol achieves <em>chain growth with parameters <span class="math">\\tau\\in\\mathbb{R}</span> and <span class="math">s\\in\\mathbb{N}</span></em> if for any honest party <span class="math">\\mathsf{P}</span>, for slots <span class="math">t_{1},t_{2}</span> such that <span class="math">t_{1}+s\\leq t_{2}\\leq t</span> the chain <span class="math">\\mathsf{C}^{\\mathsf{P}}[t]</span> contains at least <span class="math">\\tau\\cdot s</span> blocks from the time interval <span class="math">(t_{1},t_{2}]</span>. A blockchain protocol achieves <em>chain quality with parameters <span class="math">\\mu\\in\\mathbb{R}</span> and <span class="math">\\ell\\in\\mathbb{N}</span></em> if for any honest party <span class="math">\\mathsf{P}</span> and any time slot <span class="math">t</span>, it holds that among any <span class="math">\\ell</span> consecutive blocks in <span class="math">\\mathsf{C}^{\\mathsf{P}}[t]</span> the ratio of adversarial blocks is at most <span class="math">1-\\mu</span>.</p>

    <h2 id="sec-12" class="text-2xl font-bold">3 Modeling Bandwidth Limitations</h2>

    <p class="text-gray-300">Our communication model is based on the model from <em>[13]</em>, but extends it to capture bandwidth limitations of the protocol participants and the efficiency of the protocol in terms of throughput. The network model is formally captured by the “diffuse” functionality <span class="math">\\mathcal{F}_{\\mathsf{diff}}</span> given in Figure 1.</p>

    <p class="text-gray-300">We start by fixing a block size <span class="math">b</span> and defining a <em>slot</em> to be the time interval in which a party can “push” a block of this size to the network, given its bandwidth (we assume the bandwidth limitations to be uniform for all parties).</p>

    <p class="text-gray-300">We now allow parties to diffuse messages to all other parties at the maximum rate of one block per slot. If a party attempts to diffuse more than one block in a given slot, these blocks are queued locally and sent one by one. After being sent, the messages are delayed arbitrarily (and independently for each recipient) by the adversary, and upon delivery they are pushed into the recipient’s inbox queue, from which they can be fetched by the recipient at the maximum speed of <span class="math">\\mu\\in\\mathbb{N}</span> blocks per slot. Here <span class="math">\\mu</span> is the <em>bandwidth-asymmetry parameter</em> of our model and unless stated otherwise, we will consider the symmetric case <span class="math">\\mu=1</span>.</p>

    <p class="text-gray-300">The adversary is also allowed to submit arbitrary additional messages for diffusion. These messages do not suffer from the initial queuing (we assume the adversary has unlimited uplink available), but will also queue on the recipients’ side. Importantly, the adversarially-diffused messages are also sent to all participating parties–this reflects the nature of peer-to-peer gossip protocols, where even adversarial messages, once entering the system, are propagated to all participants. Note that in line with the UC communication model we also allow the adversary to send direct messages to parties, but as parties can see that these messages were not received via <span class="math">\\mathcal{F}_{\\mathsf{diff}}</span>, they drop them as no such messages are expected by the protocol. This again reflects the behavior of peer-to-peer gossip networks underlying existing blockchain protocols.</p>

    <p class="text-gray-300">Of course, we need to put some restrictions on the adversarial capability of delaying messages, as blockchain protocols are known to be insecure in settings with unbounded delays, cf. <em>[33]</em>. In any fixed execution transcript <span class="math">T</span> (that implicitly specifies a protocol, an adversary, and an environment) and a message <span class="math">M</span> with corresponding message identifier <span class="math">\\mathsf{mid}</span> diffused in <span class="math">T</span> via the functionality <span class="math">\\mathcal{F}_{\\mathsf{diff}}</span>, we denote by <span class="math">\\mathsf{delay}_{T}(\\mathsf{mid})</span> the amount of slots that passed between <span class="math">M</span> being submitted for diffusion and being fetched from the inbox by all its honest recipients (or the end of the execution, whichever comes first), decreased by <span class="math">1</span>. Furthermore, we let <span class="math">\\mathsf{maxdelay}(T)\\triangleq\\max_{\\mathsf{mid}\\in T}\\mathsf{delay}_{T}(\\mathsf{mid})</span>, where the maximum is taken over all message identifiers <span class="math">\\mathsf{mid}</span> diffused by honest parties in <span class="math">T</span>.</p>

    <p class="text-gray-300">Fig. 1. Functionality <span class="math">\\mathcal{F}_{\\mathrm{diff}}</span>.</p>

    <p class="text-gray-300">The functionality <span class="math">\\mathcal{F}_{\\mathrm{diff}}</span> is parameterized by <span class="math">\\mu \\in \\mathbb{N}</span>. It keeps rounds, executing one round per slot. <span class="math">\\mathcal{F}_{\\mathrm{diff}}</span> interacts with the environment <span class="math">\\mathcal{Z}</span>, stakeholders <span class="math">\\mathsf{P}_1, \\ldots, \\mathsf{P}_n</span> and an adversary <span class="math">\\mathcal{A}</span>, working as follows for each round:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{F}_{\\mathrm{diff}}</span> maintains three lists of messages for each party <span class="math">\\mathsf{P}_i</span> that participates: <span class="math">\\text{outbox}_i</span>, <span class="math">\\text{delayed}_i</span> and <span class="math">\\text{inbox}_i</span>, and one message list <span class="math">\\text{outbox}_A</span> for the adversary; initially all empty. Each <span class="math">\\text{outbox}_i</span> and <span class="math">\\text{inbox}_i</span> for <span class="math">i \\neq \\mathcal{A}</span> operate as queues, keeping the messages in the order in which they were added.</li>

      <li>In each round, for each party <span class="math">\\mathsf{P}_i</span> at most one message is marked as pending, and retains this status until the end of round: If <span class="math">\\text{outbox}_i</span> is non-empty at the beginning of the round then the first message it contains is marked as pending, otherwise it is the first message <span class="math">\\mathsf{P}_i</span> submits for diffusion (see Item 3) in this round.</li>

      <li>Whenever activated, a party <span class="math">\\mathsf{P}_i</span> is allowed to submit for diffusion a sequence of messages of size up to <span class="math">b</span> bits, each. Each message is assigned a unique message identifier <span class="math">\\mathsf{mid}</span>. These messages are appended to <span class="math">\\text{outbox}_i</span> in the order of submission.</li>

      <li>When the adversary <span class="math">\\mathcal{A}</span> is activated, it is allowed to:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Read all lists <span class="math">\\text{delayed}_i</span> and <span class="math">\\text{inbox}_i</span> and all pending messages, with corresponding <span class="math">\\mathsf{mid}</span> values.</li>

      <li>Create arbitrary messages and submit them for diffusion, these messages are put into <span class="math">\\text{outbox}_A</span>. This list is not a queue, all messages in it are immediately considered to be pending.</li>

      <li>For any <span class="math">j \\in \\{1, \\dots, n, \\mathcal{A}\\}</span> and any pending message <span class="math">\\mathsf{mid}</span> still in <span class="math">\\text{outbox}_j</span>, <span class="math">\\mathcal{A}</span> can remove the corresponding message <span class="math">M</span> from <span class="math">\\text{outbox}_j</span> and put it into <span class="math">\\text{delayed}_i</span> for all <span class="math">i \\in [n]</span>.</li>

      <li>For any party <span class="math">\\mathsf{P}_i</span>, <span class="math">\\mathcal{A}</span> can remove any message from the list <span class="math">\\text{delayed}_i</span> and push it to the queue <span class="math">\\text{inbox}_i</span>.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At the end of each round, the functionality ensures that every pending message still present in <span class="math">\\text{outbox}_j</span> for <span class="math">j \\in \\{1, \\dots, n, \\mathcal{A}\\}</span> is removed from <span class="math">\\text{outbox}_j</span> and pushed into <span class="math">\\text{delayed}_i</span> for all <span class="math">i \\in [n]</span>.</li>

      <li>A party is once per round (if activated) allowed to pop at most <span class="math">\\mu</span> oldest messages from <span class="math">\\text{inbox}_i</span>. These messages are given to <span class="math">\\mathsf{P}_i</span> and removed from <span class="math">\\text{inbox}_i</span>.</li>

    </ol>

    <p class="text-gray-300"><strong>Definition 2 (MaxDelay<span class="math">_\\Delta</span>).</strong> For a protocol <span class="math">\\Pi</span>, an adversary <span class="math">\\mathcal{A}</span>, and an environment <span class="math">\\mathcal{Z}</span>, we define the event <span class="math">\\text{MaxDelay}_\\Delta(\\Pi, \\mathcal{A}, \\mathcal{Z})</span> (or just <span class="math">\\text{MaxDelay}_\\Delta</span> for brevity) to be the event that <span class="math">\\text{maxdelay}(\\text{Exec}(\\Pi, \\mathcal{A}, \\mathcal{Z})) \\leq \\Delta</span>.</p>

    <p class="text-gray-300">Looking ahead, our security analysis will provide meaningful guarantees in adversarial settings where the probability of the event <span class="math">\\neg \\text{MaxDelay}_\\Delta</span> remains negligible for some <span class="math">\\Delta</span> (which may not be necessarily known explicitly to the participants).</p>

    <p class="text-gray-300">However, note that since our model bounds the downlink throughput of the parties, some protocols may induce message delays even when operating in a non-adversarial environment. Definition 3 captures this; to present it we first need to formalize such non-adversarial executions. To this end, we denote by <span class="math">\\mathcal{A}_{\\perp}</span> the dummy adversary that does not corrupt any parties, and does not delay or inject any messages, i.e., the adversary pushes pending outbox messages directly in the <span class="math">\\text{inbox}_i</span> of party <span class="math">\\mathsf{P}_i</span> for all <span class="math">i</span>.</p>

    <p class="text-gray-300"><strong>Definition 3 (<span class="math">\\kappa</span>-Boundedness).</strong> A protocol <span class="math">\\Pi</span> is <span class="math">(\\kappa, \\varepsilon)</span>-bounded if for the adversary <span class="math">\\mathcal{A}_{\\perp}</span> and for any environment <span class="math">\\mathcal{Z}</span> we have <span class="math">\\operatorname*{Pr}[\\neg \\mathsf{MaxDelay}_{\\kappa}(\\Pi, \\mathcal{A}, \\mathcal{Z})] \\leq \\varepsilon</span>.</p>

    <p class="text-gray-300">For a protocol <span class="math">\\Pi</span> being <span class="math">\\kappa</span>-bound means that assuming the network suffers of no additional (adversary-induced) delays, the protocol itself does not cause a delay beyond <span class="math">\\kappa</span>.</p>

    <p class="text-gray-300">Finally, we describe how to quantify the throughput of a block-based transaction ledger protocol in this model. Our definition is akin to the standard definition of the chain growth property, applied to a ledger instead of a single blockchain.</p>

    <p class="text-gray-300"><strong>Definition 4 (Throughput (TP)).</strong> A block-based transaction-ledger protocol achieves <span class="math">(\\theta, L_0)</span>-throughput for parameters <span class="math">L_0 \\in \\mathbb{N}</span> and <span class="math">\\theta \\in [0,1]</span> if for any honest party <span class="math">\\mathsf{P}</span>, for slots <span class="math">t_1, t_2</span> such that <span class="math">t_1 + L_0 \\leq t_2 \\leq t</span> the ledger <span class="math">\\mathbf{L}^{\\mathsf{P}}[t]</span> contains at least <span class="math">\\theta \\cdot (t_2 - t_1)</span> blocks from the time interval <span class="math">(t_1, t_2]</span>.</p>

    <h2 id="sec-13" class="text-2xl font-bold">4 Assessing Bitcoin Scaling Proposals</h2>

    <p class="text-gray-300">As a warm-up, we use our definitional framework to give a quantitative assessment of several natural proposals that have appeared in the Bitcoin scaling debate. The purpose is to familiarize the reader with our model and illustrate its expressiveness, hence for simplicity this section only provides informal claims without proofs and focuses on throughput in the non-adversarial setting (with <span class="math">\\mathcal{A}_{\\perp}</span>).</p>

    <h5 id="sec-14" class="text-base font-semibold mt-4">Plain Bitcoin</h5>

    <p class="text-gray-300">First, let us consider Bitcoin with blocks of size <span class="math">b</span>, i.e., such that a block can be submitted for diffusion by a party in a single slot. In a typical Bitcoin execution without adversarial interference, a successful miner of a block <span class="math">B</span> spends a single slot diffusing <span class="math">B</span>, this block is then delivered within <span class="math">\\Delta</span> slots to the future miner of the next block (along with all other miners), and finally this miner spends <span class="math">d</span> slots mining for the successor of <span class="math">B</span>. During these <span class="math">\\Delta+d</span> slots, the “available bandwidth” is not used productively, contributing to the rather unsatisfactory throughput of <span class="math">\\approx 1/(1+\\Delta+d)</span> with <span class="math">1\\ll\\Delta\\ll d</span>. If a block is considered stable after <span class="math">k</span> blocks are mined on top of it, the expected confirmation time (latency) of this protocol is <span class="math">\\approx k\\cdot(1+\\Delta+d)</span>.</p>

    <h5 id="sec-15" class="text-base font-semibold mt-4">Larger Blocks</h5>

    <p class="text-gray-300">Consider the Bitcoin protocol with each “logical” block consisting of <span class="math">s</span> network-level blocks, i.e., a block that can be submitted for diffusion in <span class="math">s</span> slots (we neglect the details of the mechanism for splitting the block into parts). As above, we arrive at an expected throughput of <span class="math">\\approx s/(s+\\Delta+d)</span> and latency <span class="math">\\approx k\\cdot(s+\\Delta+d)</span>. However, note that <span class="math">s+\\Delta\\ll d</span> is still necessary to maintain a low forking rate even in the non-adversarial setting, limiting the achievable throughput.</p>

    <h5 id="sec-16" class="text-base font-semibold mt-4">Shorter Block Intervals</h5>

    <p class="text-gray-300">As above, the effect of shortening block interval <span class="math">s+\\Delta+d</span> (by lowering the mining difficulty and hence <span class="math">d</span>) is limited due to the condition <span class="math">s+\\Delta\\ll d</span> necessary to prevent accidental forks.</p>

    <h5 id="sec-17" class="text-base font-semibold mt-4">Bitcoin-NG</h5>

    <p class="text-gray-300">This proposal exploits a part of the available throughput between the diffusion of (“key”) blocks to produce and diffuse so-called microblocks created by the miner of the last key block. Therefore, out of the <span class="math">1+\\Delta+d</span> slots that represent the time interval between two consecutive key blocks, only the bandwidth of the last <span class="math">\\Delta</span> slots are wasted, as the microblocks produced in these slots will not be received in time by the miner of the next key block. This results in a throughput of <span class="math">\\approx(1+d)/(1+\\Delta+d)</span>, with a latency of <span class="math">\\approx k\\cdot(1+\\Delta+d)</span>. Hence, increasing <span class="math">d</span> improves throughput but hurts latency. Also, increasing <span class="math">d</span> leads to greater centralization (due to less frequent key blocks and hence more variance in rewards) and weaker adaptive security guarantees (each leader is a target for corruption—such as a DoS attack—until the next key block is selected).</p>

    <h2 id="sec-18" class="text-2xl font-bold">5 PoS Parallel Chains</h2>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">5.1 Ouroboros Praos</h3>

    <p class="text-gray-300">We present our construction using Ouroboros Praos <em>[13]</em> as our underlying proof-of-stake blockchain protocol. Nonetheless, note that other similar protocols (e.g. <em>[21, 6, 1]</em>) could be easily used instead. We now provide a brief overview of Ouroboros Praos to serve as a reference for our exposition.</p>

    <p class="text-gray-300">The protocol operates (and was analyzed) in the semi-synchronous model with fully adaptive corruptions, described in Section 2. We will denote it here as <span class="math">\\Pi_{\\mathsf{Praos}}</span>. In each slot, each of the parties can determine whether she qualifies as a so-called <em>slot leader</em> for this slot. The event of a particular party becoming a slot leader occurs with a probability roughly proportional to the stake controlled by that party and is independent for two different slots and two different parties. More concretely, each party for each slot locally evaluates a verifiable random function (VRF, <em>[15]</em>) using the secret key associated with their stake, and providing as inputs to the VRF both the slot index and so-called <em>epoch randomness</em> (we will discuss shortly where this randomness comes from). If the VRF output is below a certain threshold that depends on the party’s stake, then the party is an eligible slot leader and is allowed to create, sign, and broadcast a block for that slot (containing transactions that move stake among stakeholders). Each leader then includes into the block it creates also the VRF output and a proof of its validity to certify her eligibility to act as a slot leader. Note that the local nature of the leader election implies that there will inevitably be some slots with no, or several, slot leaders.</p>

    <p class="text-gray-300">More precisely, the threshold <span class="math">T_{i}^{j}</span> for a party <span class="math">\\mathsf{P}_{i}</span> to become a slot leader in a fixed slot of epoch <span class="math">j</span> is</p>

    <p class="text-gray-300"><span class="math">T_{i}^{j}\\triangleq 2^{\\ell_{\\mathsf{VRF}}}\\phi_{f}(\\alpha_{i}^{j})</span> (1)</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300">for a stakeholder <span class="math">\\mathsf{P}_{i}</span> for epoch <span class="math">e_{j}</span>, where <span class="math">\\alpha_{i}^{j}</span> is the relative stake of stakeholder <span class="math">\\mathsf{P}_{i}</span> in the stake distribution <span class="math">\\mathbb{S}_{j}</span>, <span class="math">\\ell_{\\mathsf{VRF}}</span> denotes the output length of <span class="math">\\mathcal{F}_{\\mathsf{vrf}}</span>, <span class="math">f\\in(0,1)</span> is the so-called <em>active slots coefficient</em>, and <span class="math">\\phi_{f}</span> is the mapping</p>

    <p class="text-gray-300"><span class="math">\\phi_{f}(\\alpha)\\triangleq 1-(1-f)^{\\alpha}\\;.</span></p>

    <p class="text-gray-300">Parties participating in the protocol are collecting such valid blocks and always update their current state to reflect the longest chain they have seen so far that did not fork from their previous state by too many blocks into the past (as captured by procedure maxvalid in Fig. 3).</p>

    <p class="text-gray-300">Multiple slots are collected into <em>epochs</em>, each of which contains <span class="math">R\\in\\mathbb{N}</span> slots. Each epoch is indexed by an index <span class="math">j\\in\\mathbb{N}</span>. During an epoch <span class="math">j</span>, the stake distribution that is used for slot leader election corresponds to the distribution recorded in the ledger up to the last block of epoch <span class="math">j-2</span>. Additionally, the <em>epoch randomness</em> for epoch <span class="math">j</span> is derived as a hash of additional VRF-values that were included into blocks from the first two thirds of epoch <span class="math">j-1</span> for this purpose by the respective slot leaders.</p>

    <p class="text-gray-300">Finally, the protocol uses <em>key-evolving signatures (KES)</em> for block signing, and in each slot the honest parties are mandated to update their private key, contributing to their resilience to adaptive corruptions.</p>

    <p class="text-gray-300">As mandated by the protocol operation, every block in the Ouroboros Praos blockchain has the format <span class="math">B=(st,d,sl,\\pi_{B},\\rho,\\sigma)</span>. Here <span class="math">st</span> is the hash of the previous block; <span class="math">d</span> denotes the transaction-carrying data; and <span class="math">sl</span> is the index of the slot this block belongs to. <span class="math">\\pi_{B}</span> is a triple <span class="math">(\\mathsf{P}_{i},y,\\pi)</span> where <span class="math">(y,\\pi)</span> is the VRF output-proof pair certifying that <span class="math">\\mathsf{P}_{i}</span> is an eligible slot leader for slot <span class="math">sl</span>; <span class="math">\\rho=(y_{\\rho},\\pi_{\\rho})</span> is an independent VRF output-proof pair used for randomness generation. Finally, <span class="math">\\sigma</span> is a key-evolving signature of the block by its creator.</p>

    <p class="text-gray-300">We now note the security statement about <span class="math">\\Pi_{\\mathsf{Praos}}</span> from <em>[13]</em>, expressed in our model. Here <em>honest stake ratio</em> denotes the stake (as recorded in the current view of the ledger) controlled by uncorrupted parties as a proportion of the total stake. Moreover, <em>stake shift</em> between two slots <span class="math">t_{1}&lt;t_{2}</span> denotes the statistical distance of the stake distributions corresponding to <span class="math">t_{1}</span> and <span class="math">t_{2}</span>. Since the stake distribution used for sampling slot leaders in <span class="math">\\Pi_{\\mathsf{Praos}}</span> is at most 2 epochs old, in all statements below it is necessary to consider <span class="math">\\alpha_{\\mathcal{H}}-\\nu</span> as the lower bound on effective honest stake ratio, see <em>[21, 13]</em> for a more detailed treatment.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Theorem 1 (<em>[13]</em>)</h6>

    <p class="text-gray-300">Fix parameters <span class="math">k,R,\\Delta,L\\in\\mathbb{N}</span>; <span class="math">\\xi_{1},\\nu\\in(0,1)</span>. Let <span class="math">R=24k/f</span> be the epoch length, let <span class="math">L</span> denote the total lifetime of the system. Let <span class="math">\\mathcal{A}\\in\\mathbb{A}_{\\mathsf{b}}</span> be a Byzantine-corruption adversary, let <span class="math">\\alpha_{\\mathcal{H}}</span> be a lower bound on the honest stake ratio throughout the execution. Let <span class="math">\\nu</span> and <span class="math">q</span> be upper bounds on the maximum stake shift over <span class="math">2R</span> slots, and the number of adversarial random oracle queries, respectively. If</p>

    <p class="text-gray-300"><span class="math">(\\alpha_{\\mathcal{H}}-\\nu)(1-f)^{\\Delta}\\geq(1+\\xi_{1})/2</span></p>

    <p class="text-gray-300">then <span class="math">\\Pi_{\\mathsf{Praos}}</span> implements a robust transaction ledger against <span class="math">\\mathcal{A}</span> with liveness parameter <span class="math">u_{\\mathsf{Praos}}=8k/f</span> throughout a period of <span class="math">L</span> slots except with probability <span class="math">\\varepsilon_{\\mathsf{Praos}}=\\exp\\left(\\ln L+\\Delta-\\Omega(k-\\log qk)\\right)+\\Pr\\left[\\neg\\textsf{MaxDelay}_{\\Delta}\\right]</span>.</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">5.2 The Construction</h3>

    <p class="text-gray-300">We denote our protocol <span class="math">\\Pi_{\\mathsf{pc-pos}}^{m}</span>, where <span class="math">\\mathsf{pc}</span> stands for “parallel chains” and <span class="math">\\mathsf{pos}</span> denotes the proof-of-stake case. On a high level, the protocol <span class="math">\\Pi_{\\mathsf{pc-pos}}^{m}</span> consists of running <span class="math">m</span> copies of a slightly adapted Ouroboros Praos protocol in parallel, such that these copies together maintain a joint ledger (describing a joint distribution of stake). We sometimes omit <span class="math">m</span> from the notation and simply write <span class="math">\\Pi_{\\mathsf{pc-pos}}</span>. The protocol <span class="math">\\Pi_{\\mathsf{pc-pos}}</span> is spelled out in Figure 2, we now focus on describing the differences from a single-chain execution of Ouroboros Praos. The protocol assumes the availability of functionalities <span class="math">\\mathcal{F}_{\\mathsf{init}}</span>, <span class="math">\\mathcal{F}_{\\mathsf{diff}}</span>, <span class="math">\\mathcal{F}_{\\mathsf{vrf}}</span>, <span class="math">\\mathcal{F}_{\\mathsf{sig}}</span>, <span class="math">\\mathcal{F}_{\\mathsf{kes}}</span>, <span class="math">\\mathcal{F}_{\\mathsf{ro}}</span> as described in <em>[13]</em> and surveyed in Appendix B for completeness. We treat it in the symmetric-bandwidth model with <span class="math">\\mu=1</span> (cf. Section 3), a different bandwidth profile (with better downlink bandwidth <span class="math">\\mu&gt;1</span>) could be handled similarly and would lead to an increase in the number of chains <span class="math">m</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In <span class="math">\\Pi_{\\mathsf{pc-pos}}</span> we extend the block format of <span class="math">\\Pi_{\\mathsf{Praos}}</span> to also contain the index of a chain <span class="math">c\\in[m]</span> as the first coordinate, we sometimes call a block <em><span class="math">c</span>-block</em> to refer to its chain index. We refer to a chain <span class="math">\\mathsf{C}</span> as a <span class="math">c</span>-chain if all blocks in <span class="math">\\mathsf{C}</span> except the genesis block contain <span class="math">c\\in[m]</span> as their first coordinate. Since each block <span class="math">B</span> contains its slot number, we denote it by <span class="math">\\mathsf{slot}(B)</span>, and $\\mathsf{C}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t}<span class="math"> denotes the chain </span>\\mathsf{C}<span class="math"> truncated to only contain blocks up to slot </span>t$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 2. Protocol  <span class="math">\\Pi_{\\mathrm{pc - pos}}^{m}</span></p>

    <p class="text-gray-300">The protocol  <span class="math">\\Pi_{\\mathrm{pc - pos}}</span>  is run by stakeholders, initially equal to  <span class="math">\\mathsf{P}_1,\\ldots ,\\mathsf{P}_n</span> , interacting among themselves and with ideal functionalities  <span class="math">\\mathcal{F}_{\\mathrm{init}}</span> ,  <span class="math">\\mathcal{F}_{\\mathrm{diff}}</span> ,  <span class="math">\\mathcal{F}_{\\mathrm{vrf}}</span> ,  <span class="math">\\mathcal{F}_{\\mathrm{sig}}</span> ,  <span class="math">\\mathcal{F}_{\\mathrm{kes}}</span> ,  <span class="math">\\mathcal{F}_{\\mathrm{ro}}</span>  over a sequence of  <span class="math">L = ER</span>  slots  <span class="math">S = (sl_1,\\dots,sl_L)</span>  consisting of  <span class="math">E</span>  epochs with  <span class="math">R</span>  slots each. Define  <span class="math">T_i^j</span>  as in (1). Then  <span class="math">\\Pi_{\\mathrm{pc - pos}}</span>  proceeds as follows for each stakeholder  <span class="math">\\mathsf{P}_i</span> :</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initialization.</li>

    </ol>

    <p class="text-gray-300">(a)  <span class="math">\\mathsf{P}_i</span>  sends (KeyGen,  <span class="math">sid</span> ,  <span class="math">\\mathsf{P}_i</span> ) to  <span class="math">\\mathcal{F}_{\\mathrm{vrf}}</span> ,  <span class="math">\\mathcal{F}_{\\mathrm{kes}}</span>  and  <span class="math">\\mathcal{F}_{\\mathrm{sig}}</span> ; receiving (VerificationKey,  <span class="math">sid</span> ,  <span class="math">v_i</span> ) for  <span class="math">v_i \\in \\{v_i^{\\mathrm{vrf}}, v_i^{\\mathrm{kes}}, v_i^{\\mathrm{sig}}\\}</span> , respectively. If this is the first round,  <span class="math">\\mathsf{P}_i</span>  sends (ver_keys,  <span class="math">sid</span> ,  <span class="math">\\mathsf{P}_i</span> ,  <span class="math">v_i^{\\mathrm{vrf}}</span> ,  <span class="math">v_i^{\\mathrm{kes}}</span> ,  <span class="math">v_i^{\\mathrm{sig}}</span> ) to  <span class="math">\\mathcal{F}_{\\mathrm{init}}</span>  to claim stake from the genesis block. In any case, it terminates the round by returning  <span class="math">(\\mathsf{P}_i, v_i^{\\mathrm{vrf}}, v_i^{\\mathrm{kes}}, v_i^{\\mathrm{sig}})</span>  to  <span class="math">\\mathcal{Z}</span> . (b) In the next round,  <span class="math">\\mathsf{P}_i</span>  sends (genblock_req,  <span class="math">sid</span> ,  <span class="math">\\mathsf{P}_i</span> ) to  <span class="math">\\mathcal{F}_{\\mathrm{init}}</span> , receiving (genblock,  <span class="math">sid</span> ,  <span class="math">\\mathbb{S}_0</span> ,  <span class="math">\\eta</span> ). If  <span class="math">\\mathsf{P}_i</span>  is initialized in the first round, it sets the local blockchains  <span class="math">\\mathcal{C} = (\\mathsf{C}_c)_{c=1}^m</span>  to  <span class="math">\\mathsf{C}_c := \\mathcal{G} \\triangleq (\\mathbb{S}_0, \\eta)</span> . otherwise it receives the local blockchains  <span class="math">\\mathcal{C} = (\\mathsf{C}_c)_{c=1}^m</span>  from the environment.</p>

    <p class="text-gray-300">After initialization, in each slot  <span class="math">sl^<em> \\in S</span>  (of epoch  <span class="math">e_{j^</em>}</span> ),  <span class="math">\\mathsf{P}_i</span>  performs the following:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Epoch Update. If a new epoch  <span class="math">e_{j^<em>}</span>  with  <span class="math">j^</em> \\geq 2</span>  has started,  <span class="math">\\mathsf{P}_i</span>  computes  <span class="math">\\mathbb{S}_{j^<em>}</span>  and  <span class="math">\\eta_{j^</em>}</span>  as follows:</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(a)  <span class="math">\\mathbb{S}_{j^*}</span>  is the stake distribution recorded in the state GetValidTX  $\\left(\\mathcal{C}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t_{j^* - 2}}\\right)<span class="math">  where  </span>\\mathcal{C}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t_{j^* - 2}} \\triangleq \\left(\\mathsf{C}_c^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t_{j^<em> - 2}}\\right)_{c = 1}^m<span class="math">  are the currently held chains truncated up to slot  </span>t_{j^</em> - 2}<span class="math"> , which denotes the last slot of epoch  </span>j^* - 2$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Chains Update. For all  <span class="math">c \\in [m]</span> ,  <span class="math">\\mathsf{P}_i</span>  performs the following steps:</li>

    </ol>

    <p class="text-gray-300">(a)  <span class="math">\\mathsf{P}_i</span>  collects all  <span class="math">c</span> -blocks newly received via diffusion, and collects all new  <span class="math">c</span> -chains that can be constructed (respecting the previous-block hashes  <span class="math">st</span> ) from these and past  <span class="math">c</span> -blocks into a set  <span class="math">\\mathbb{C}_c</span> , pruning blocks belonging to future slots and verifying that for every chain  <span class="math">\\mathsf{C}_c&#x27; \\in \\mathbb{C}_c</span>  and every block  <span class="math">B = (c, st, d, sl, \\pi_B, \\rho, \\sigma) \\in \\mathsf{C}_c&#x27;</span>  where  <span class="math">sl</span>  belongs to epoch  <span class="math">e_j</span> , parsing  <span class="math">\\pi_B</span>  as  <span class="math">(\\mathsf{P}_s, y, \\pi)</span>  for some  <span class="math">s</span>  and  <span class="math">\\rho</span>  as  <span class="math">(y_\\rho, \\pi_\\rho)</span> , it holds that:</p>

    <p class="text-gray-300">(i)  <span class="math">y &amp;lt;   T_s^j</span> (ii)  <span class="math">\\mathcal{F}_{\\mathrm{vrf}}</span>  responds to (Verify,  <span class="math">sid,\\eta_j\\parallel c\\parallel sl\\parallel</span>  TEST,  <span class="math">y,\\pi ,v_{s}^{\\mathrm{vrf}})</span>  by (Verified,  <span class="math">sid,\\eta_j\\parallel c\\parallel sl\\parallel</span>  TEST,  <span class="math">y,\\pi ,1)</span> (iii)  <span class="math">\\mathcal{F}_{\\mathrm{vrf}}</span>  responds to (Verify,  <span class="math">sid,\\eta_j\\parallel c\\parallel sl\\parallel</span>  NONCE,  <span class="math">y_{\\rho},\\pi_{\\rho},v_{s}^{\\mathrm{vrf}})</span>  by (Verified,  <span class="math">sid,\\eta_j\\parallel c\\parallel sl\\parallel</span>  NONCE,  <span class="math">y_{\\rho},\\pi_{\\rho},1)</span> (iv)  <span class="math">\\mathcal{F}_{\\mathrm{kes}}</span>  responds to (Verify,  <span class="math">sid,(c,st,d,sl,\\pi_B,\\rho),sl,\\sigma ,v_s^{\\mathrm{kes}})</span>  by (Verified,  <span class="math">sid,(c,st,d,sl,\\pi_B,\\rho),sl,1)</span> (b)  <span class="math">\\mathsf{P}_i</span>  computes  <span class="math">\\mathsf{C}_c\\coloneqq \\mathsf{maxvalid}(\\mathsf{C}_c,\\mathbb{C}_c)</span> , and updates  <span class="math">\\mathcal{C} = (\\mathsf{C}_c)_{c = 1}^m</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Chains Extension.  <span class="math">\\mathsf{P}_i</span>  receives from the environment the transaction data  <span class="math">d^{<em>}\\in \\{0,1\\}^{</em>}</span>  to be inserted into the ledger. For all  <span class="math">c\\in [m]</span> ,  <span class="math">\\mathsf{P}_i</span>  performs the following steps:</li>

    </ol>

    <p class="text-gray-300">(a) Send (EvalProve,  <span class="math">sid</span> ,  <span class="math">\\eta_j \\parallel c \\parallel sl^<em> \\parallel</span>  NONCE) to  <span class="math">\\mathcal{F}_{\\mathrm{vrf}}</span> , get (Evaluated,  <span class="math">sid</span> ,  <span class="math">y_\\rho^c, \\pi_\\rho^c</span> ). (b) Send (EvalProve,  <span class="math">sid</span> ,  <span class="math">\\eta_j \\parallel c \\parallel sl^</em> \\parallel</span>  TEST) to  <span class="math">\\mathcal{F}_{\\mathrm{vrf}}</span> , get (Evaluated,  <span class="math">sid</span> ,  <span class="math">y^c</span> ,  <span class="math">\\pi^c</span> ). (c)  <span class="math">\\mathsf{P}_i</span>  checks whether  <span class="math">y^c &amp;lt; T_i^j</span> . If yes, it chooses a maximal sequence  <span class="math">d&#x27;</span>  of  <span class="math">c</span> -transactions in  <span class="math">d^<em></span>  that can be appended to GetValidTX  <span class="math">(\\mathcal{C})</span>  without invalidating it, and attempts to include  <span class="math">d&#x27;</span>  into  <span class="math">\\mathsf{C}_c</span>  as follows: It generates a new block  <span class="math">B = (c, st_c, d&#x27;, sl^</em>, \\pi_B, \\rho, \\sigma)</span>  where  <span class="math">st_c = H(\\text{head}(\\mathsf{C}_c))</span> ,  <span class="math">\\pi_B = (\\mathsf{P}_i, y^c, \\pi^c)</span> ,  <span class="math">\\rho = (y_\\rho^c, \\pi_\\rho^c)</span>  and  <span class="math">\\sigma</span>  is a signature obtained by sending (USign, sid,  <span class="math">\\mathsf{P}_i</span> ,  <span class="math">(c, st_c, d&#x27;, sl^<em>, \\pi_B, \\rho)</span> ,  <span class="math">sl^</em></span> ) to  <span class="math">\\mathcal{F}_{\\mathrm{kes}}</span>  and receiving (Signature, sid,  <span class="math">(c, st_c, d&#x27;, sl^<em>, \\pi_B, \\rho)</span> ,  <span class="math">sl^</em>, \\sigma</span> ).  <span class="math">\\mathsf{P}_i</span>  computes  <span class="math">\\mathsf{C}_c := \\mathsf{C}_c \\parallel B</span> , sets  <span class="math">\\mathsf{C}_c</span>  as the new local  <span class="math">c</span> -chain and diffuses  <span class="math">B</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Signing Transactions. Upon receiving (sign_tx, sid', tx) from the environment,  <span class="math">\\mathsf{P}_i</span>  sends (Sign, sid,  <span class="math">\\mathsf{P}_i</span> , tx) to  <span class="math">\\mathcal{F}_{\\mathrm{sig}}</span> , receiving (Signature, sid, tx,  <span class="math">\\sigma</span> ). Then,  <span class="math">\\mathsf{P}_i</span>  sends (signed_tx, sid', tx,  <span class="math">\\sigma</span> ) back to the environment.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Drop all chains  <span class="math">\\mathsf{C}&#x27;</span>  from  <span class="math">\\mathbb{C}</span>  that fork from  <span class="math">\\mathsf{C}</span>  more than  <span class="math">k</span>  blocks (i.e., more than  <span class="math">k</span>  blocks of  <span class="math">\\mathsf{C}</span>  would be discarded if  <span class="math">\\mathsf{C}&#x27;</span>  was adopted).</li>

      <li>Return the longest of the remaining chains. If multiple such chains remain, return either  <span class="math">\\mathsf{C}</span>  if this is one of them, or return the one that is listed first in  <span class="math">\\mathbb{C}</span> .</li>

    </ol>

    <p class="text-gray-300">Towards transaction sharding, we assume a fixed function chain(tx) that for each transaction tx returns a chain index  <span class="math">c \\in [m]</span>  of the only chain in which tx can be inserted. We refer to all tx such that chain(tx) =  <span class="math">c</span>  as  <span class="math">c</span> -transactions, and assume that chain(·) is reasonably balanced (consider for example chain(tx) =  <span class="math">H(\\mathrm{tx})</span>  mod  <span class="math">m</span> ).</p>

    <p class="text-gray-300">Fig. 4. Procedure GetValidTX(<span class="math">\\mathsf{C}_{1},\\ldots,\\mathsf{C}_{m}</span>).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Take all the transactions included in all blocks of the chains <span class="math">\\mathsf{C}_{1},\\ldots,\\mathsf{C}_{m}</span>.</li>

      <li>Order these transactions in an increasing order according to the following following criteria, listed in decreasing priority:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>slot index sl from the block <span class="math">B</span> containing the transaction;</li>

      <li>chain number <span class="math">c</span> from the block <span class="math">B</span>;</li>

      <li>position of the transaction within <span class="math">B</span>.</li>

      <li>Process all the transactions in the above-obtained order and remove all transactions that are invalid with respect to the ledger state formed by all the preceding transactions.</li>

    </ol>

    <p class="text-gray-300">Each party <span class="math">\\mathsf{P}_{i}</span> executing <span class="math">\\Pi_{\\mathsf{pc}\\text{-}\\mathsf{pos}}</span> starts by requesting its verification keys for a VRF, a KES, and an ordinary signature scheme, just like in the single-chain protocol. She claims its stake in the genesis block <span class="math">\\mathcal{G}</span> (if she participates from the first round) and initializes all <span class="math">m</span> chains to either consist of <span class="math">\\mathcal{G}</span> only (if this is the first round), or adopts chains received from the environment.</p>

    <p class="text-gray-300">The sequences of transactions stored in the <span class="math">m</span> individual blockchains are merged using the procedure GetValidTX given in Figure 4. Any party <span class="math">\\mathsf{P}_{i}</span> obtains the ledger state <span class="math">\\mathbf{L}^{\\mathsf{P}_{i}}[t]</span> containing the transactions considered stable at time <span class="math">t</span> as follows: given its current view of chains <span class="math">\\mathsf{C}_{1},\\ldots,\\mathsf{C}_{m}</span>, she computes <span class="math">t_{\\mathsf{stable}}</span> as the maximum slot up to which all <span class="math">m</span> chains are stable, i.e., the minimum slot index of a <span class="math">k</span>-blocks-deep block in any of the chains. <span class="math">\\mathbf{L}^{\\mathsf{P}_{i}}[t]</span> is then computed by merging the chains up to this slot using GetValidTX. Formally,</p>

    <p class="text-gray-300"><span class="math">t_{\\mathsf{stable}}\\triangleq\\min_{c\\in[m]}\\mathsf{slot}\\left(\\mathsf{head}\\left(\\mathsf{C}_{c}^{\\lceil k}\\right)\\right)\\quad\\text{ and }\\quad\\mathbf{L}^{\\mathsf{P}_{i}}[t]\\triangleq\\mathsf{GetValidTX}\\left(\\left(\\mathsf{C}_{c}^{\\lceil t_{\\mathsf{stable}}}\\right)_{c=1}^{m}\\right)\\ .</span></p>

    <p class="text-gray-300">The stake distribution <span class="math">\\mathbb{S}_{j}</span> and epoch randomness <span class="math">\\eta_{j}</span> for determining slot leaders in epoch <span class="math">j</span> are derived in conceptually the same way as in the single-chain case. Namely, the stake distribution used is taken from the end of epoch <span class="math">j-2</span>, by looking at all chains up to that point and merging them using GetValidTX. The randomness <span class="math">\\eta_{j}</span> is obtained by hashing together all the <span class="math">y_{\\rho}</span> values included in all <span class="math">m</span> chains in all blocks in epoch <span class="math">j-1</span> up to its slot <span class="math">2R/3</span>. Slot leadership is determined independently for each party, each slot, and each chain, via the same VRF-based threshold mechanism as in Ouroboros Praos, and verified in the same way. Eligible slot leaders (for a particular chain <span class="math">\\mathsf{C}_{c}</span>) simply create a block for this chain, and include all pending <span class="math">c</span>-transactions that are consistent with the current view of the chains.</p>

    <p class="text-gray-300">Validity of a chain received from the network is determined as in the single-chain case, except that the transactions themselves are not validated at this point. Their validity can only be determined based on the state of the other chains.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">5.3 Analysis</h3>

    <p class="text-gray-300">Robustness. We first establish the security of <span class="math">\\Pi_{\\mathsf{pc}\\text{-}\\mathsf{pos}}^{m}</span> by proving that it implements a robust transaction ledger against Byzantine adversaries with the same liveness as <span class="math">\\Pi_{\\mathsf{Praos}}</span> and the error probability scaled by the number of chains <span class="math">m</span>.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Theorem 2 (Robustness).</h6>

    <p class="text-gray-300">Fix parameters <span class="math">k,\\Delta\\in\\mathbb{N}</span>; <span class="math">\\xi_{1}\\in(0,1)</span>; let <span class="math">f</span> denote the active slot coefficient in <span class="math">\\Pi_{\\mathsf{pc}\\text{-}\\mathsf{pos}}^{m}</span>, let <span class="math">R=24k/f</span> be the epoch length, let <span class="math">L</span> denote the total lifetime of the system. Let <span class="math">\\mathcal{A}\\in\\mathbb{A}_{\\mathsf{b}}</span> be a Byzantine-corruption adversary, let <span class="math">\\alpha_{\\mathcal{H}}</span> be a lower bound on the honest stake ratio throughout the execution. Let <span class="math">\\nu</span> and <span class="math">q</span> be upper bounds on the maximum stake shift over <span class="math">2R</span> slots, and the number of adversarial random oracle queries, respectively. Let <span class="math">u_{\\mathsf{Praos}}</span> and <span class="math">\\varepsilon_{\\mathsf{Praos}}</span> be as in Theorem 1. If</p>

    <p class="text-gray-300"><span class="math">(\\alpha_{\\mathcal{H}}-\\nu)(1-f)^{\\Delta}\\geq(1+\\xi_{1})/2</span></p>

    <p class="text-gray-300">then the protocol <span class="math">\\Pi_{\\mathsf{pc}\\text{-}\\mathsf{pos}}^{m}</span> implements a robust transaction ledger with liveness parameter <span class="math">u_{\\mathsf{Praos}}</span> against <span class="math">\\mathcal{A}</span> except with error probability at most <span class="math">\\varepsilon_{\\mathsf{rob}}=m\\cdot\\varepsilon_{\\mathsf{Praos}}+\\Pr\\left[\\neg\\mathsf{MaxDelay}_{\\Delta}\\right]</span>.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Proof (sketch).</h6>

    <p class="text-gray-300">Observe that each of the <span class="math">m</span> chains produced during the execution of <span class="math">\\Pi_{\\mathsf{pc}\\text{-}\\mathsf{pos}}^{m}</span> can be seen as an outcome of an independent execution of <span class="math">\\Pi_{\\mathsf{Praos}}</span>, except that the leader selection in epoch <span class="math">j</span> is based on:</p>

    <p class="text-gray-300">1.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the stake distribution <span class="math">\\mathbb{S}_{j}</span> taken from the state of <em>all</em> <span class="math">m</span> chains at the end of epoch <span class="math">j-2</span>;</li>

      <li>the epoch randomness <span class="math">\\eta_{j}</span> derived from VRF-values <span class="math">y_{\\rho}</span> collected from appropriate blocks of <em>all</em> <span class="math">m</span> chains.</li>

    </ul>

    <p class="text-gray-300">An analysis of the robustness argument for single-chain <span class="math">\\Pi_{\\mathsf{Praos}}</span> given in <em>[13]</em> shows that the argument is not violated by these changes, the error probability merely needs to be adjusted by an additional factor <span class="math">m</span> to account for a union bound over the failure probability for each of the chains. Since the analysis in <em>[13]</em> is performed in a model where all message delays are bounded by <span class="math">\\Delta</span>, an additional additive term <span class="math">\\Pr\\left[\\neg\\mathsf{MaxDelay}_{\\Delta}\\right]</span> accounts for the occurrence of longer delays in our model.</p>

    <p class="text-gray-300">More concretely, the robustness of the single-chain <span class="math">\\Pi_{\\mathsf{Praos}}</span> is derived from the simpler chain-specific properties of common prefix (<span class="math">\\mathsf{CP}</span>), chain growth (<span class="math">\\mathsf{CG}</span>), and chain quality (<span class="math">\\mathsf{CQ}</span>), as defined in Section 2. First, <span class="math">\\mathsf{CP}</span>, <span class="math">\\mathsf{CG}</span> and <span class="math">\\mathsf{CQ}</span> are established for a single-epoch execution of the protocol with a static-corruption adversary. As these arguments assume a fixed stake distribution and perfect epoch randomness, they can also be directly applied to a single-epoch execution of each of the <span class="math">m</span> chains of <span class="math">\\Pi_{\\mathsf{pc}\\text{-}\\mathsf{pos}}^{m}</span> under these assumptions. Second, it is shown that any adaptive adversary is dominated by a particular static adversary, hence extending the single-epoch guarantees to adaptive adversaries as well: this argument can also be applied to <span class="math">\\Pi_{\\mathsf{pc}\\text{-}\\mathsf{pos}}</span> without modification. Finally, the analysis is extended to multiple epochs by analyzing the subprotocol for updating the stake distribution and randomness used for leader sampling. This analysis relies on the single-epoch bounds on <span class="math">\\mathsf{CP}</span>, <span class="math">\\mathsf{CG}</span> and <span class="math">\\mathsf{CQ}</span> violations obtained above. Since in <span class="math">\\Pi_{\\mathsf{pc}\\text{-}\\mathsf{pos}}^{m}</span> this subprotocol depends on all <span class="math">m</span> chains, we need to assume that single-epoch <span class="math">\\mathsf{CP}</span>, <span class="math">\\mathsf{CG}</span> and <span class="math">\\mathsf{CQ}</span> are maintained on each of them, leading to the additional factor <span class="math">m</span> in the final security bound. <span class="math">\\Box</span></p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Remark 1</h6>

    <p class="text-gray-300">Theorems 1 and 2 contain an error term <span class="math">\\Pr\\left[\\neg\\mathsf{MaxDelay}_{\\Delta}\\right]</span> that, rougly speaking, restricts our security claims to adversaries that only induce <span class="math">\\Delta</span>-limited message delays. However, note that for very small <span class="math">\\Delta</span>, this probability may be non-negligible simply because the protocol itself (without adversarial interference) induces <span class="math">\\Delta</span>-exceeding message delays due to message queuing in the recipients’ mailboxes. To understand the security guarantees provided for such small <span class="math">\\Delta</span>, observe that both theorems hold in our model for an arbitrary value of <span class="math">\\mu\\in\\mathbb{N}</span>. Considering the execution for higher values of <span class="math">\\mu</span> (than <span class="math">\\mu=1</span> for which the protocol is designed) decreases queuing times of the honest protocol messages, and as <span class="math">\\mu\\to\\infty</span>, the probability of violating <span class="math">\\Pr\\left[\\neg\\mathsf{MaxDelay}_{\\Delta}\\right]</span> purely by non-adversarial queuing delays becomes zero also for arbitrarily small <span class="math">\\Delta</span>. This moves our model towards the throughput-unaware model of <em>[13]</em> and provides the best possible guarantees also for such small <span class="math">\\Delta</span>.</p>

    <h4 id="sec-27" class="text-lg font-semibold mt-6"><span class="math">\\kappa</span>-Boundedness.</h4>

    <p class="text-gray-300">We now investigate the delays caused by non-adversarial message queuing for our construction. Namely, we show that <span class="math">\\Pi_{\\mathsf{pc}\\text{-}\\mathsf{pos}}^{m}</span> is <span class="math">\\kappa</span>-bounded except with probability negligible in <span class="math">\\kappa</span>, as long as the number of chains <span class="math">m</span> does not exceed a particular threshold. Intuitively, exceeding it would cause a block creation rate in the system to go too close to (or exceed) 1 and hence overload the recipients’ bandwidth.</p>

    <p class="text-gray-300">First, we establish a general queuing lemma that will be used in our argument.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Lemma 1</h6>

    <p class="text-gray-300">Assume an <span class="math">L</span>-slot execution of <span class="math">m\\geq 1</span> queues each with service rate <span class="math">1</span> per slot wherein, during any <span class="math">r</span> slots, at most <span class="math">r</span> overall messages get added to the queues. Then there is no slot where, at its very beginning, all queues together contain <span class="math">r+1</span> or more messages.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Proof</h6>

    <p class="text-gray-300">Consider the single-queue case — whereas the multi-queue case directly follows as the overall service is at least as large as in the single-queue case. For the sake of contradiction, consider the first slot <span class="math">t</span> where the queue contains at least <span class="math">r+1</span> messages at its very beginning. Consider the oldest one of these <span class="math">r+1</span> messages and consider the first slot <span class="math">t^{\\prime}</span> where this message was present at the beginning of the slot. It must hold that <span class="math">t^{\\prime}\\geq t-r+1</span> as, otherwise, there were <span class="math">r+1</span> messages in the queue at the beginning of slot <span class="math">t^{\\prime}&lt;t</span> where <span class="math">t</span> is assumed to be the first such slot. This implies that all <span class="math">r+1</span> messages must have arrived within the <span class="math">r</span> slots <span class="math">t-r,\\ldots,t-1</span>, in contradiction to the assumption. <span class="math">\\Box</span></p>

    <p class="text-gray-300">Now we apply Lemma 1 to upper-bound the number of messages waiting in the outbox and inbox queues at any point during an execution of <span class="math">\\Pi_{\\mathsf{pc}\\text{-}\\mathsf{pos}}</span> with <span class="math">\\mathcal{A}_{\\bot}</span>, this is done respectively in Lemmas 2 and 3.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Lemma 2.</h6>

    <p class="text-gray-300">Let <span class="math">\\kappa\\in\\mathbb{N}</span> and <span class="math">\\xi_{2}\\in(0,1/2)</span>, let <span class="math">f</span> denote the active slot coefficient in <span class="math">\\Pi^{m}_{p\\mathsf{c}\\text{-}\\mathsf{pos}}</span>. For any</p>

    <p class="text-gray-300"><span class="math">m\\leq(1-\\xi_{2})(1-f)/f\\;,</span> (2)</p>

    <p class="text-gray-300">the probability that during an <span class="math">L</span>-slot execution of <span class="math">\\Pi^{m}_{p\\mathsf{c}\\text{-}\\mathsf{pos}}</span> with <span class="math">\\mathcal{A}_{\\perp}</span> there is a slot where all parties’ outbox queues together contain at least <span class="math">\\xi_{2}\\kappa/3</span> blocks at the beginning of the slot is bounded by</p>

    <p class="text-gray-300"><span class="math">P_{\\mathsf{out}}\\leq L\\cdot\\exp\\left(-\\frac{\\xi_{2}^{2}(\\xi_{2}\\kappa-3)}{9}\\right)\\ .</span></p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">For any fixed slot, let <span class="math">(\\alpha_{i})_{i=1}^{n}</span> denote the relative stakes of all currently participating parties, as recorded in the stake distribution used for determining slot leaders for this slot. We first note that the expected number of blocks created in this slot (by all parties on all chains) is</p>

    <p class="text-gray-300"><span class="math">m\\cdot\\sum_{i=1}^{n}\\phi_{f}(\\alpha_{i})=m\\cdot\\sum_{i=1}^{n}\\left(1-(1-f)^{\\alpha_{i}}\\right)\\stackrel{{\\scriptstyle(a)}}{{\\leq}}m\\cdot\\ln\\frac{1}{1-f}\\leq m\\cdot\\frac{f}{1-f}\\leq 1-\\xi_{2}\\,,</span></p>

    <p class="text-gray-300">where the inequality (a) follows from Jensen inequality and the observations that <span class="math">g(n)\\triangleq n\\left(1-(1-f)^{1/n}\\right)</span> is increasing and converges to <span class="math">-\\ln(1-f)</span> for <span class="math">n\\to\\infty</span>.</p>

    <p class="text-gray-300">Moreover, block-generation can be viewed as elementary independent experiments (one per slot, party, and chain) with respect to an indicator random variable <span class="math">X_{i}\\in\\{0,1\\}</span> where <span class="math">X_{i}=1</span> denotes the respective success. Thus, the probability <span class="math">P_{\\mathsf{out}}</span> that, during any <span class="math">\\ell_{\\mathsf{out}}=\\xi_{2}\\kappa/3-1</span> rounds, at least <span class="math">\\ell_{\\mathsf{out}}</span> blocks are generated, can be estimated by the Chernoff bound of Theorem 10 with <span class="math">\\mu=(1-\\xi_{2})\\ell_{\\mathsf{out}}</span> and <span class="math">\\delta=\\xi_{2}/(1-\\xi_{2})</span>. The lemma now follows by a union bound over the length of the execution and Lemma 1. ∎</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Lemma 3.</h6>

    <p class="text-gray-300">Let <span class="math">\\kappa\\in\\mathbb{N}</span> and <span class="math">\\xi_{2}\\in(0,1/2)</span>, let <span class="math">f</span> denote the active slot coefficient in <span class="math">\\Pi^{m}_{p\\mathsf{c}\\text{-}\\mathsf{pos}}</span> and let <span class="math">m</span> satisfy (2). Consider an <span class="math">L</span>-round execution of <span class="math">\\Pi^{m}_{p\\mathsf{c}\\text{-}\\mathsf{pos}}</span> with <span class="math">\\mathcal{A}_{\\perp}</span>. Given that there is no round where all outbox queues together contain at least <span class="math">\\xi_{2}\\kappa/3</span> blocks at the beginning of the round, the probability that there is a round where a party’s inbox queue contains at least <span class="math">(1-\\xi_{2}/3)\\kappa</span> blocks at the beginning of the round is bounded by</p>

    <p class="text-gray-300"><span class="math">P_{\\mathsf{in}}\\leq L\\cdot\\exp\\left(-\\frac{\\xi_{2}^{2}}{3}\\left(\\kappa-\\frac{1}{1-\\xi_{2}}\\right)\\right)\\ .</span></p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Note that under <span class="math">\\mathcal{A}_{\\perp}</span>, all parties’ inboxes behave identically. Along the lines of Lemma 2, we observe that the probability <span class="math">P_{\\mathsf{in}}</span> that, during any <span class="math">\\ell_{\\mathsf{in}}=(1-2\\xi_{2}/3)k-1</span> rounds, at least <span class="math">\\ell_{\\mathsf{in}}</span> blocks are generated, is upper bounded as above by the Chernoff bound (<span class="math">\\mu=(1-\\xi_{2})\\ell_{\\mathsf{in}}</span> and <span class="math">\\delta=\\xi_{2}/(1-\\xi_{2})</span>) and the union bound. Additionally, at most <span class="math">\\xi_{2}\\kappa/3</span> blocks that were already present in the outbox queues might get added to each inbox during these <span class="math">\\ell_{\\mathsf{in}}</span> rounds. We can hence conclude by Lemma 1 that the inbox never contains <span class="math">(1-\\xi_{2}/3)\\kappa</span> blocks at the beginning of a round — except for the above probability. ∎</p>

    <p class="text-gray-300">The above lemmas allow us to establish the <span class="math">\\kappa</span>-boundedness of the protocol <span class="math">\\Pi^{m}_{p\\mathsf{c}\\text{-}\\mathsf{pos}}</span>.</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Theorem 3 (<span class="math">\\kappa</span>-Boundedness).</h6>

    <p class="text-gray-300">Let <span class="math">\\kappa\\in\\mathbb{N}</span> and <span class="math">\\xi_{2}\\in(0,1/2)</span>, let <span class="math">f</span> denote the active slot coefficient in <span class="math">\\Pi^{m}_{p\\mathsf{c}\\text{-}\\mathsf{pos}}</span> and let <span class="math">m</span> satisfy (2). The probability that, during an <span class="math">L</span>-round execution of <span class="math">\\Pi^{m}_{p\\mathsf{c}\\text{-}\\mathsf{pos}}</span> with <span class="math">\\mathcal{A}_{\\perp}</span>, there is a block that incurs a delay of at least <span class="math">\\kappa</span> rounds, is bounded by</p>

    <p class="text-gray-300"><span class="math">\\varepsilon_{\\kappa}\\leq P_{\\mathsf{out}}+(1-P_{\\mathsf{out}})P_{\\mathsf{in}}\\leq 2L\\cdot\\exp\\left(-\\frac{\\xi_{2}^{2}(\\xi_{2}\\kappa-3)}{9}\\right)\\ .</span></p>

    <p class="text-gray-300">Hence, the protocol <span class="math">\\Pi^{m}_{p\\mathsf{c}\\text{-}\\mathsf{pos}}</span> executed over a period of <span class="math">L</span> slots is <span class="math">(\\kappa,\\varepsilon_{\\kappa})</span>-bounded.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Assume that some block has delay at least <span class="math">\\kappa=t_{\\mathsf{out}}+t_{\\mathsf{in}}</span> spending <span class="math">t_{\\mathsf{out}}</span> rounds in the outbox queue and <span class="math">t_{\\mathsf{in}}</span> rounds in the inbox queue. Thus, <span class="math">t_{\\mathsf{out}}\\geq\\xi_{2}\\kappa/3</span> or <span class="math">t_{\\mathsf{in}}\\geq(1-\\xi_{2}/3)\\kappa</span>. The respective probabilities are given by Lemmas 2 and 3, and the lemma follows.</p>

    <p class="text-gray-300">hroughput.</p>

    <p class="text-gray-300">Now we focus on the throughput achieved by <span class="math">\\Pi^{m}_{\\mathsf{pc}\\text{-}\\mathsf{pos}}</span>, and express it as a parameter of the number of chains <span class="math">m</span>.</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Theorem 4 (Throughput).</h6>

    <p class="text-gray-300">Fix parameters <span class="math">k,\\Delta\\in\\mathbb{N}</span>, <span class="math">\\xi_{3}\\in(0,1/2]</span>, let <span class="math">f\\in(0,1)</span> denote the active slot coefficient in <span class="math">\\Pi^{m}_{\\mathsf{pc}\\text{-}\\mathsf{pos}}</span>, assume that <span class="math">(1-f)^{\\Delta}\\geq 1/2</span>, and let <span class="math">\\widehat{f}\\triangleq f(1-f)^{\\Delta}</span>. Let <span class="math">\\mathcal{A}\\in\\mathbb{A}_{\\mathsf{fs}}</span> be a fail-stop adversary, let <span class="math">\\alpha_{\\mathcal{H}}\\in[0,1]</span> be a lower bound on the honest stake ratio throughout the execution, let <span class="math">\\nu</span> be upper bound on the maximum stake shift over <span class="math">2R</span> slots, and assume <span class="math">\\widehat{\\alpha_{\\mathcal{H}}}\\triangleq\\alpha_{\\mathcal{H}}-\\nu&gt;0</span>. The protocol <span class="math">\\Pi^{m}_{\\mathsf{pc}\\text{-}\\mathsf{pos}}</span> achieves <span class="math">(\\theta,L_{0})</span>-throughput for any <span class="math">L_{0}\\geq(2k+3\\Delta)/((1-\\xi_{3})^{2}\\widehat{\\alpha_{\\mathcal{H}}}\\widehat{f})</span> and for</p>

    <p class="text-gray-300"><span class="math">\\theta=(1-\\xi_{3})^{2}\\cdot\\left(1-\\frac{k+4\\Delta}{(1-\\xi_{3})^{2}\\widehat{\\alpha_{\\mathcal{H}}}\\widehat{f}L_{0}}\\right)\\cdot\\widehat{\\alpha_{\\mathcal{H}}}\\cdot\\widehat{f}\\cdot m</span> (3)</p>

    <p class="text-gray-300">against <span class="math">\\mathcal{A}</span> except with error probability <span class="math">\\varepsilon_{\\mathsf{tp}}\\triangleq 4\\cdot m\\cdot\\exp\\left(-\\xi_{3}^{2}\\widehat{\\alpha_{\\mathcal{H}}}fk/4\\right)+\\Pr\\left[\\neg\\mathsf{MaxDelay}_{\\Delta}\\right]</span>.</p>

    <p class="text-gray-300">Before we prove Theorem 4, a brief discussion of the bound (3) is in order. Intuitively, the expected optimal throughput of <span class="math">\\Pi^{m}_{\\mathsf{pc}\\text{-}\\mathsf{pos}}</span> is roughly <span class="math">\\widehat{\\alpha_{\\mathcal{H}}}\\cdot f\\cdot m</span>, as each of the <span class="math">m</span> chains contains a block with at least one slot leader on expectation once in <span class="math">1/f</span> slots, and with probability at least <span class="math">\\widehat{\\alpha_{\\mathcal{H}}}</span> this leader is not corrupted. There are three factors that separate the bound (3) from this optimum: First, the term <span class="math">1-\\xi_{3}</span> allows us to use a concentration bound (twice) and can be made arbitrarily small at the expense of increasing the minimum duration <span class="math">L_{0}</span> to achieve the promised throughput. Second, the term <span class="math">1-(k+4\\Delta)/(cL_{0})</span> pays for the fact that the last <span class="math">k</span> blocks in each chain are not stable and hence if the investigated interval is at the end of the execution, these blocks don’t contribute towards the throughput. This term also diminishes with increasing <span class="math">L_{0}</span>. Finally, <span class="math">f</span> is replaced by <span class="math">\\widehat{f}</span> to account for possible occurrence of forks that are caused by the probabilistic leader selection in <span class="math">\\Pi_{\\mathsf{Praos}}</span> in combination with message delays. Note that the assumption <span class="math">(1-f)^{\\Delta}\\geq 1/2</span> is natural: we are not interested in a parametrization that does not satisfy it, as (3) would result in a throughput below <span class="math">1/2</span> anyway.</p>

    <p class="text-gray-300">Finally, note that the observation from Remark 1 applies to Theorem 4 as well.</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Proof (of Theorem 4).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider an environment <span class="math">\\mathcal{Z}</span>, let <span class="math">T\\xleftarrow{\\mathsf{s}}\\mathsf{Exec}\\left(\\Pi,\\mathcal{A},\\mathcal{Z}\\right)</span>, and let <span class="math">I</span> be a slot interval of length $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=L\\geq L_{0}<span class="math">. We will split the interval </span>I<span class="math"> into a <em>prefix interval</em> </span>I_{\\mathsf{pref}}<span class="math"> consisting of its first </span>L_{\\mathsf{pref}}<span class="math"> slots of </span>I<span class="math"> (for </span>L_{\\mathsf{pref}}<span class="math"> given below), and a <em>suffix interval</em> </span>I_{\\mathsf{suf}}<span class="math"> of </span>L_{\\mathsf{suf}}=L-L_{\\mathsf{pref}}$ slots. We then argue that with overwhelming probability:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>each chain contains at least <span class="math">(1-\\xi_{3})^{2}\\cdot\\widehat{\\alpha_{\\mathcal{H}}}\\cdot\\widehat{f}\\cdot L_{\\mathsf{pref}}-2\\Delta</span> blocks in <span class="math">I_{\\mathsf{pref}}</span>;</li>

      <li>all <span class="math">m</span> chains produced by <span class="math">\\Pi^{m}_{\\mathsf{pc}\\text{-}\\mathsf{pos}}</span> contain at least <span class="math">k</span> blocks in <span class="math">I_{\\mathsf{suf}}</span>, hence all blocks contained in all <span class="math">m</span> chains in <span class="math">I_{\\mathsf{pref}}</span> are stable.</li>

    </ol>

    <p class="text-gray-300">Both parts will rely on establishing a lower bound on the chain growth of a single Ouroboros Praos chain in the presence of a fail-stop adversary <span class="math">\\mathcal{A}</span>, assuming message delays bounded by <span class="math">\\Delta</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We will consider, along the lines of <em>[19, 13]</em>, <span class="math">\\Delta</span>-right isolated succcessful slots: these are slots that have at least one (uncorrupted) slot leader and the following <span class="math">\\Delta</span> slots do not have any leaders at all. We will call these slots <em>good</em> for brevity and denote by <span class="math">\\mathsf{good}(t)</span> a function that returns <span class="math">1</span> if <span class="math">t</span> is good and <span class="math">0</span> otherwise. Moreover, let <span class="math">I^{\\prime}_{\\mathsf{pref}}\\triangleq[t_{1},t_{2}]</span> denote the interval <span class="math">I_{\\mathsf{pref}}</span> without its first <span class="math">\\Delta</span> slots and let $L^{\\prime}_{\\mathsf{pref}}\\triangleq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I^{\\prime}_{\\mathsf{pref}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I_{\\mathsf{pref}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-\\Delta=t_{2}-t_{1}+1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For simplicity, we first consider the case without any fail-stop corruptions. Observe that in this case, the growth corresponding to the interval <span class="math">I_{\\mathsf{pref}}</span> in a chain held by any party at the end of the execution is lower-bounded by the number of good slots appearing in <span class="math">I^{\\prime}_{\\mathsf{pref}}</span>. This is because any slot leader <span class="math">\\mathsf{P}_{i}</span> of the first good slot of <span class="math">I^{\\prime}_{\\mathsf{pref}}</span> must have already seen all blocks in the chains held by all parties before the start of <span class="math">I_{\\mathsf{pref}}</span>, as this was at least <span class="math">\\Delta</span> slots ago. Hence, the block <span class="math">\\mathsf{P}_{i}</span> creates will extend a chain that is at least as long as any of those chains (thanks to the <span class="math">\\mathsf{maxvalid}</span> chain-selection rule). By the definition of a good slot, this block will be propagated to any slot leader of the next good slot in <span class="math">I^{\\prime}_{\\mathsf{pref}}</span> in time to be taken into account; therefore by the same argument, the longest chain (that will eventually represent the state of the ledger) will grow in <span class="math">I_{\\mathsf{pref}}</span> by at least one block for every good slot in <span class="math">I^{\\prime}_{\\mathsf{pref}}</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Let us now consider the effect of adaptive fail-stop corruptions. For a fixed chain <span class="math">c\\in[m]</span>, let <span class="math">W_{t}^{(c)}</span> be a random variable that takes the value <span class="math">0</span> if the slot <span class="math">t</span> has at least one (uncorrupted) slot leader, and <span class="math">\\bot</span> otherwise (the symbols are chosen for consistency with <em>[1]</em>). Given the slot-leader selection rules of <span class="math">\\Pi_{\\mathsf{Praos}}</span> (and <span class="math">\\Pi_{\\mathsf{pc}\\text{-}\\mathsf{pos}}</span>) described in Section 5.1, the probability that a particular slot has at least one slot leader for chain <span class="math">c</span> is exactly <span class="math">f</span>. Thanks to the local nature of the VRF-based leader-selection, <span class="math">\\mathcal{A}</span> has no advantage in predicting a slot leader until he acts, and hence <span class="math">\\widehat{\\alpha_{\\mathcal{H}}}f\\leq\\Pr\\left[W_{t}=0\\right]\\leq f</span>.</p>

    <p class="text-gray-300">To lower-bound the number of good slots in <span class="math">I^{\\prime}_{\\mathsf{pref}}</span>, we will rely on a concentration bound for this quantity derived in <em>[1]</em> and detailed in Appendix C. More concretely, observe that the sequence of random variables <span class="math">W_{t_{1}}^{(c)},\\ldots,W_{t_{2}}^{(c)}</span> corresponding to the interval <span class="math">I^{\\prime}_{\\mathsf{pref}}</span> satisfies the <span class="math">(f,1)</span>-characteristic condition according to Definition 7 and we can invoke Lemma 8 with <span class="math">\\gamma=1</span> and <span class="math">a=\\widehat{\\alpha_{\\mathcal{H}}}f</span> to bound the probability of having too few good slots by</p>

    <p class="text-gray-300"><span class="math">p_{\\mathsf{pref}}\\triangleq\\Pr\\left[\\sum_{t\\in I^{\\prime}_{\\mathsf{pref}}}\\mathsf{good}(t)\\leq(1-\\xi_{3})^{2}\\cdot\\widehat{\\alpha_{\\mathcal{H}}}\\cdot\\widehat{f}\\cdot L^{\\prime}_{\\mathsf{pref}}-\\Delta\\right]\\leq 2\\exp\\left(-\\frac{\\xi_{3}^{2}\\cdot\\widehat{\\alpha_{\\mathcal{H}}}^{2}\\cdot f^{2}\\cdot L^{\\prime}_{\\mathsf{pref}}}{4}\\right)\\;.</span></p>

    <p class="text-gray-300">Since <span class="math">L^{\\prime}_{\\mathsf{pref}}=L_{\\mathsf{pref}}-\\Delta</span> and <span class="math">(1-\\xi_{3})^{2}\\cdot\\widehat{\\alpha_{\\mathcal{H}}}\\cdot\\widehat{f}\\leq 1</span>, this establishes (i).</p>

    <p class="text-gray-300">We now consider the interval <span class="math">I_{\\mathsf{suf}}</span> for <span class="math">L_{\\mathsf{suf}}\\triangleq(k+\\Delta)/(1-\\xi_{3})^{2}\\widehat{\\alpha_{\\mathcal{H}}}\\widehat{f}+\\Delta</span>, and similarly as before, we define <span class="math">I^{\\prime}_{\\mathsf{suf}}</span> to denote the interval of <span class="math">L_{\\mathsf{suf}}-\\Delta</span> slots obtained when removing the first <span class="math">\\Delta</span> slots from <span class="math">I_{\\mathsf{suf}}</span>. By the same argument as above, we observe that <span class="math">I^{\\prime}_{\\mathsf{suf}}</span> will contain at least <span class="math">k</span> good slots with an uncorrupted leader (and hence <span class="math">I_{\\mathsf{suf}}</span> will contain at least <span class="math">k</span> blocks) except with error <span class="math">p_{\\mathsf{suf}}\\triangleq 2\\exp\\left(-\\xi_{3}^{2}\\widehat{\\alpha_{\\mathcal{H}}}fk/4\\right)</span>, establishing (ii).</p>

    <p class="text-gray-300">Hence we can conclude that for <span class="math">L_{\\mathsf{suf}}</span> given above and <span class="math">L_{\\mathsf{pref}}\\triangleq L-L_{\\mathsf{suf}}</span>, the interval <span class="math">I_{\\mathsf{pref}}</span> contains at least <span class="math">(1-\\xi_{3})^{2}\\cdot\\widehat{\\alpha_{\\mathcal{H}}}\\cdot\\widehat{f}\\cdot m\\cdot L^{\\prime}_{\\mathsf{pref}}-\\Delta</span> <em>stable</em> blocks in all <span class="math">m</span> chains except with probability <span class="math">m\\cdot(p_{\\mathsf{pref}}+p_{\\mathsf{suf}})</span>, resulting in the throughput parameter <span class="math">\\theta</span> in (3). Under the assumption <span class="math">L_{0}\\geq(2k+3\\Delta)/((1-\\xi_{3})^{2}\\widehat{\\alpha_{\\mathcal{H}}}\\widehat{f})</span> we have <span class="math">p_{\\mathsf{pref}}\\leq p_{\\mathsf{suf}}</span> and the bound on <span class="math">\\varepsilon_{\\mathsf{tp}}</span> in the theorem statement follows. ∎</p>

    <p class="text-gray-300">Finally, we instantiate the result of Theorem 4 with the maximum number of chains <span class="math">m</span> that still guarantees <span class="math">\\kappa</span>-boundedness of the resulting protocol <span class="math">\\Pi_{\\mathsf{pc}\\text{-}\\mathsf{pos}}^{m}</span> according to Theorem 3.</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Corollary 1.</h6>

    <p class="text-gray-300">Under the notation and assumptions introduced in Theorems 3 and 4. the protocol <span class="math">\\Pi_{\\mathsf{pc}\\text{-}\\mathsf{pos}}^{m}</span> for <span class="math">m=(1-\\xi_{2})(1-f)/f</span> is <span class="math">(\\kappa,\\varepsilon_{\\kappa})</span>-bounded for any <span class="math">\\kappa</span> and achieves <span class="math">(\\theta,L_{0})</span>-throughput against fail-stop adversaries for any <span class="math">L_{0}\\geq(2k+3\\Delta)/((1-\\xi_{3})^{2}\\widehat{\\alpha_{\\mathcal{H}}}\\widehat{f})</span> and</p>

    <p class="text-gray-300"><span class="math">\\theta=(1-\\xi_{2})\\cdot(1-\\xi_{3})^{2}\\cdot(1-f)^{\\Delta+1}\\cdot\\left(1-\\frac{k+4\\Delta}{(1-\\xi_{3})^{2}\\widehat{\\alpha_{\\mathcal{H}}}\\widehat{f}L_{0}}\\right)\\cdot\\widehat{\\alpha_{\\mathcal{H}}}</span></p>

    <p class="text-gray-300">except with error probability <span class="math">\\varepsilon_{\\mathsf{tp}}</span>.</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Remark 2.</h6>

    <p class="text-gray-300">Note that, above, throughput optimality was only demonstrated in presence of a fail-stop adversary. In <em>[2]</em>, with respect to PoW, the important observation was made that separating transaction (or fruit) mining from the mining of structural blockchain blocks (called proposer blocks in <em>[2]</em>) along the lines of <em>[18, 35]</em> not only gives you fairness but can also be applied in order to optimize throughput in presence of a Byzantine adversary. This is basically achieved by having the transaction blocks mined at a fast rate to make full use of the network bandwidth while having the proposer blocks still mined at a small rate to guarantee robustness of the ledger, and by additionally applying randomized transaction sharding.</p>

    <p class="text-gray-300">We note that, along the same lines, also our PoS parallel-chains construction can be adapted in order to achieve throughput optimality in presence of a Byzantine adversary. For this, we can apply the input-endorser construction of <em>[21]</em> to every individual chain where a party is randomly elected to be either a slot leader or an input endorser. Note that, as a main difference to <em>[2]</em>, endorser and leader election will both still run at the same (slow) rate while bandwidth utilization is optimized by chain parallelism.</p>

    <p class="text-gray-300">Alternatively to the above approach to achieve Byzantine throughput optimality, we can also apply the inclusive-blockchain idea from <em>[26]</em> for each individual chain by having blocks additionally reference</p>

    <p class="text-gray-300">anticipated orphan blocks, and by adding those respective transactions to the ledger as well. Note that, opposite to the previously mentioned DAG protocols (e.g. <em>[27]</em>), this has no degrading effect on liveness, as the per-chain block rate is not accelerated but kept at a safe level.</p>

    <h2 id="sec-40" class="text-2xl font-bold">6 PoW Parallel Chains Without Synchronized Clocks</h2>

    <p class="text-gray-300">We now turn our attention to the proof-of-work setting. We first remark that if parties are assumed to have access to (roughly) synchronized clocks, one can construct a parallel-chains protocol fully analogous to <span class="math">\\Pi_{\\mathsf{pc}\\text{-}\\mathsf{pos}}</span> given in Section 5, where slot indices are replaced by timestamps.</p>

    <p class="text-gray-300">Namely, each block will contain the local timestamp of the miner at the time of composing the block. A party adopts a block added to a particular chain <span class="math">\\mathsf{C}_{c}</span> only if the block’s timestamp is larger than the timestamp of its predecessor, and, if its timestamp lies in the past of the local time. Finally, to produce the ledger state, the blocks of all chains get sorted primarily by timestamp and secondarily by the chain index, and most recent blocks are again dropped. The assumed bound on local clock skew (together with the single-chain properties <span class="math">\\mathsf{CP}</span>, <span class="math">\\mathsf{CG}</span>, and <span class="math">\\mathsf{CQ}</span> from Section 2) will then ensure that blocks of sufficient depth in their local chains will be guaranteed to have a lower timestamp than any block that will be accepted in the future.</p>

    <p class="text-gray-300">Although the assumption of roughly synchronized clocks is standard in the PoS literature, it is known that the PoW-based consensus can be (in the setting with constant difficulty) achieved also without this assumption (cf. the consensus protocols in <em>[18]</em>). Therefore, we refrain from discussing further details of this construction; instead, in this section we present a more elaborate construction for the PoW setting that does not rely on the synchronized clocks assumption (but does assume constant difficulty).</p>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">6.1 Elements of Bitcoin</h3>

    <p class="text-gray-300">We describe an abstraction of the Bitcoin blockchain along the lines of <em>[19]</em>. The Bitcoin blockchain <span class="math">\\mathsf{C}</span> consists of blocks <span class="math">B=\\langle\\langle r,x\\rangle,ctr\\rangle</span> where <span class="math">r</span> is a reference to the predecessor block of <span class="math">B</span>, <span class="math">x</span> is the block payload containing the transactions, and <span class="math">ctr</span> is a counter. The protocol involves a cryptographic hash function <span class="math">H:\\{0,1\\}^{<em>}\\rightarrow\\{0,1\\}^{\\kappa}</span> used for referencing a block from within another block, and used for generating proofs of work. We model <span class="math">H</span> as a random oracle </em>[4]<em>. The chain <span class="math">\\mathsf{C}</span> is a sequence of <span class="math">n</span> blocks <span class="math">(B_{i})_{i=1}^{n}</span> such that <span class="math">B_{1}=\\mathcal{G}</span>, and, for <span class="math">i&gt;1</span>, <span class="math">B_{i}=\\langle y_{i}=\\langle r_{i},x_{i}\\rangle,ctr_{i}\\rangle</span> satisfies that <span class="math">r_{i}=H(B_{i-1})\\triangleq H(H(y_{i-1}),ctr_{i-1})</span>. The actual block <span class="math">B_{i-1}</span> referenced by <span class="math">H(B_{i-1})</span> from <span class="math">B_{i}</span> is denoted by <span class="math">R(B_{i})</span>. Additionally, for some predefined number <span class="math">\\ell\\in\\mathbb{N}</span>, a non-genesis block <span class="math">B</span> must satisfy that the value <span class="math">H(B)</span> contains <span class="math">\\ell</span> leading zeroes, i.e., <span class="math">H(B)&lt;M\\triangleq 2^{\\kappa-\\ell}</span>. We call <span class="math">p=2^{-\\ell}</span> the </em>mining-hardness parameter*.</p>

    <p class="text-gray-300">In order to mine a new block containing payload <span class="math">x</span>, a party must assemble his block <span class="math">B=\\langle y=\\langle r,x\\rangle,ctr\\rangle</span> such that <span class="math">r=H(\\mathsf{head}(\\mathsf{C}))</span> whereas the value <span class="math">ctr</span> is initialized to some value and incremented until <span class="math">H(B)&lt;M</span> — constituting the proof of work. Once such a block has been found it can be published to be included in the other parties’ views of the blockchain.</p>

    <p class="text-gray-300">A block is valid if it is composed as described above and the payload is well-formed and semantically self-consistent. A blockchain is valid if it is composed as described above, and all involved blocks are valid whereas their payloads do not contradict each other. The ledger <span class="math">\\mathbf{L}</span> as a sequence of transactions is extracted from the longest observed valid chain <span class="math">\\mathsf{C}</span> by listing all transactions of <span class="math">\\mathsf{C}^{\\lceil k}</span> in order of appearance where <span class="math">k</span> is a protocol parameter. Along the lines of stable transactions, a block <span class="math">B\\in\\mathsf{C}^{\\lceil k}</span> is called stable.</p>

    <p class="text-gray-300">We assume that there are <span class="math">n</span> mining parties in the protocol, all having equal hashing power, whereas we assume <span class="math">t</span> of them to be controlled by the adversary. The protocol proceeds in rounds whereas each round corresponds to a time slot as defined in Section 2. For the argumentation from a global view, we still assign each round a unique slot number. Note, however, that the parties do not have synchronized clocks, and thus, this global slot number is not known to the parties. Along the lines of <em>[19]</em>, during a single round, every party executes <span class="math">q\\in\\mathbb{N}</span> queries to the PoW instance in an attempt to mine a new block whereas <span class="math">q</span> is the maximal</p>

    <p class="text-gray-300">number of queries executable within the time bounds of one slot.³ At the end of the round, the party is instructed to execute the diffusion of all successfully mined blocks.</p>

    <h2 id="sec-42" class="text-2xl font-bold">6.2 The Construction</h2>

    <p class="text-gray-300">We start with a brief overview of the construction. Our protocol <span class="math">\\Pi_{\\mathsf{pc-pow}}^m</span> involves a tuple <span class="math">\\mathcal{C} = (\\mathsf{C}_c)_{c=1}^m</span> of individual Bitcoin chains that are operated in parallel involving transaction sharding whereas only <span class="math">c</span>-transactions are allowed to be part of chain <span class="math">\\mathsf{C}_c</span> as in Section 5.2. In order to mine a block, the miner prepares a metablock <span class="math">\\mathcal{B}</span> to simultaneously represent a block <span class="math">B_c</span> consisting of <span class="math">c</span>-transactions for every single one of the <span class="math">m</span> chains. The miner then computes his PoW on the metablock whereas the PoW may be successful with respect to at most one of the chains. If the PoW on the metablock has been successful with respect to chain index <span class="math">c</span>, the miner extracts the respective block <span class="math">B_c</span>, appends it to his local chain <span class="math">\\mathsf{C}_c</span>, and diffuses the block to the network. As a substitute for missing synchronized clocks, we make use of a dedicated synchronization chain that gets loosely cross-referenced from blocks of the remaining chains.</p>

    <p class="text-gray-300">For simplicity, we assume <span class="math">m = 2^z</span> for some <span class="math">z \\in \\mathbb{N}</span>. Each chain <span class="math">\\mathsf{C}_c</span> is initialized with a genesis block <span class="math">\\mathcal{G}_c</span>. The first chain, <span class="math">\\mathsf{C}_1</span>, is called synchronization chain. A block in the synchronization chain is called a synchronization block. Each block extends exactly one chain — the index of the chain a block <span class="math">B</span> extends is denoted by <span class="math">\\mathsf{ch}(B) \\in [m]</span>. For a block <span class="math">B \\in \\mathsf{C}_{\\mathsf{ch}(B)}</span>, we denote its height by <span class="math">\\pi(B)</span> whereas <span class="math">\\pi(\\mathcal{G}_c) = 1</span>.</p>

    <p class="text-gray-300">Similar to Bitcoin, a block can be viewed as having the structure <span class="math">B = \\langle y = \\langle r,x,c,s\\rangle ,ctr,aux\\rangle</span> whereas <span class="math">r</span> is a reference-by-hash to the predecessor block of <span class="math">B</span> in <span class="math">\\mathsf{C}_{\\mathsf{ch}(B)}</span>, <span class="math">x</span> is the payload, <span class="math">c = \\mathsf{ch}(B)</span>, and <span class="math">ctr</span> is a counter as above. In order to facilitate transaction sharding, <span class="math">y</span> is in fact only a hash value whereas <span class="math">\\langle r,x,c,s\\rangle</span> is to be recovered from <span class="math">y</span> together with the auxiliary information in <span class="math">aux</span> — the respective details as well as the definition of the metablock are given later. We denote by <span class="math">R(B)</span> the predecessor block referenced from <span class="math">B</span> in chain <span class="math">\\mathsf{C}_{\\mathsf{ch}(B)}</span> by means of <span class="math">r</span>.</p>

    <p class="text-gray-300">Entry <span class="math">s</span> (also denoted by <span class="math">s(B)</span> in the following context) is to contain the length of the synchronization chain that was observed by the party mining the block at the point it was mined. The reference is used as a variable reference from <span class="math">B</span> to a block in the synchronization chain that is robust against block pruning (as opposed to using a hash reference). We define the synchronization block of <span class="math">B</span> as</p>

    <div class="my-4 text-center"><span class="math-block">\\sigma (B) = \\left\\{ \\begin{array}{l l} R (B) &amp;amp; \\text{if } B \\in \\mathsf {C} _ {1}, \\\\ B _ {1} &amp;amp; \\text{if } B \\notin \\mathsf {C} _ {1} \\text{ and } \\exists B _ {1} \\in \\mathsf {C} _ {1}, \\text{ such that } \\pi (B _ {1}) = s (B), \\\\ \\bot &amp;amp; \\text{otherwise}. \\end{array} \\right.</span></div>

    <p class="text-gray-300">Note that <span class="math">\\sigma(B)</span> is well-defined, as the block <span class="math">B_1</span>, if it exists, is unique.</p>

    <p class="text-gray-300">Extending our set notation, we write <span class="math">B \\in \\mathcal{C}</span> iff there is an index <span class="math">j</span> such that <span class="math">B \\in \\mathbb{C}_j</span>. By <span class="math">\\mathcal{C}^{\\lceil k \\rceil}</span> we denote <span class="math">\\mathcal{C}</span> where the last <span class="math">k</span> blocks of each involved chain have been removed: <span class="math">\\mathcal{C}^{\\lceil k \\rceil} = \\left(\\mathsf{C}_c^{\\lceil k \\rceil}\\right)_{c=1}^m</span>.</p>

    <p class="text-gray-300">Proof-of-work makes use of the same hash function as the underlying single-chain protocol, <span class="math">H: \\{0,1\\}^* \\to \\{0,1\\}^\\kappa</span> (modeled as an RO) with the goal that PoW not only tells a miner whether he is allowed to add a block but also which chain the block has to be appended to. We set <span class="math">\\ell_m \\triangleq \\ell - \\log(m)</span>, <span class="math">M_m \\triangleq 2^{\\kappa - \\ell_m}</span>, and thereby adjust the (overall) mining hardness to <span class="math">p_m = mp</span>. PoW now uniformly assigns successes over all <span class="math">m</span> chains as follows — yielding the same per-chain mining hardness as in Bitcoin.⁴ For genesis blocks we define <span class="math">\\mathsf{ch}(\\mathcal{G}_c) := c</span> whereas, for a non-genesis block <span class="math">B</span> (represented by a metablock <span class="math">\\mathcal{B}</span> with <span class="math">H(\\mathcal{B}) &amp;lt; M_m</span>), we define <span class="math">\\mathsf{ch}(\\mathcal{B}) := 1 + H(\\mathcal{B}) \\mod m</span>. Modeling <span class="math">H</span> as an RO makes this assignment uniformly random, and known to the miner only after the PoW has been completed (with overwhelming probability).</p>

    <p class="text-gray-300">To summarize, a block is eligible to be mined for chain <span class="math">\\mathsf{C}_c</span> iff its metablock <span class="math">\\mathcal{B}</span> satisfies <span class="math">\\mathsf{ch}(\\mathcal{B}) = c</span> whereas, as given by the involved RO, the value of <span class="math">\\mathsf{ch}(\\mathcal{B})</span> is random and becomes known to the miner only after the</p>

    <p class="text-gray-300">³ Note that, in order to facilitate our analysis in context of network-bandwidth limitations, we deviate from the Δ-bound model of [19] by defining one round by the length of the time slot required to send a block to the network (cf. Section 3) — instead of the time required to perform one single PoW query. Along the lines of their synchronous model, we thus allow each party to perform some <span class="math">q \\in \\mathbb{N}</span> queries per round.</p>

    <p class="text-gray-300">⁴ Note that we can safely assume that <span class="math">\\ell \\geq \\log m</span> as the opposite is ruled out by our Bound (5) on <span class="math">m</span> under which the protocol can be demonstrated secure.</p>

    <p class="text-gray-300">PoW has been completed. It still remains to show how a metablock <span class="math">\\mathcal{B}</span> can be prepared such that it allows for the extraction of a respective <span class="math">c</span>-block — a way to achieve this is given later.</p>

    <p class="text-gray-300">The local view over all longest chains can be represented by a directed graph <span class="math">G=(V,E)</span> with <span class="math">V=\\{B\\mid B\\in\\mathcal{C}\\cup\\{\\bot\\}\\}</span> and</p>

    <p class="text-gray-300"><span class="math">E=\\{(x,y)\\in V\\times V\\mid R(x)=y\\ \\vee\\ (x\\notin\\mathsf{C}_{1}\\wedge y\\in\\mathsf{C}_{1}\\wedge s(x)=\\pi(y))\\ \\ .</span></p>

    <p class="text-gray-300">We write <span class="math">B_{0}\\prec_{G}B_{1}</span> iff there is a path from block <span class="math">B_{1}</span> to block <span class="math">B_{0}</span> in <span class="math">G</span>. We write <span class="math">B_{0}\\preceq_{G}B_{1}</span> iff either <span class="math">B_{0}\\prec_{G}B_{1}</span> or <span class="math">B_{0}=B_{1}</span>.</p>

    <p class="text-gray-300">Our analysis of the overall protocol will rely on the block-based security guarantees (<span class="math">\\mathsf{CP}</span>, <span class="math">\\mathsf{CQ}</span>, and <span class="math">\\mathsf{CG}</span>) of each involved single Bitcoin chain when operated in an isolated way under an equivalent single-chain parameterization. In particular, we can disregard the payloads of such blocks — until we argue about the security of the resulting ledger on the transaction level. For this purpose we introduce the notion of an implied single-chain execution as follows.</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Definition 5 (Implied single-chain execution).</h6>

    <p class="text-gray-300">For each <span class="math">\\mathsf{C}_{c}\\in\\mathcal{C}</span>, we define the implied single-chain (<span class="math">L</span>-round) execution of <span class="math">\\mathsf{C}_{c}</span> from <span class="math">\\Pi^{m}_{\\mathsf{pc-pow}}</span> as the (<span class="math">L</span>-round) protocol execution of <span class="math">\\Pi^{m}_{\\mathsf{pc-pow}}</span> when restricted to the parties’ views of <span class="math">\\mathsf{C}_{c}</span> on the block level (and ignoring the semantics of transactions).</p>

    <h4 id="sec-44" class="text-lg font-semibold mt-6">Adapting the PoW to achieve independence of the single-chains.</h4>

    <p class="text-gray-300">A minor drawback of the above use of PoW is that a single PoW query cannot be simultaneously successful for multiple chains, thereby introducing a small statistical dependence of the mining for the different chains. Although this is not relevant for our analysis in this section, the amplification technique in Section 7 assumes full independence of the chains. We now sketch a PoW variation to achieve fully independent parallel mining which may also be of independent interest. For this, we generalize the 2-for-1-PoW idea from <em>[19]</em> to <span class="math">m</span>-for-1-PoW, yielding a PoW variant that can be simultaneously successful with respect to all <span class="math">m</span> instances.</p>

    <p class="text-gray-300">One possible way to implement <span class="math">m</span>-for-1-PoW is by applying a pseudo-random generator (PRG) <span class="math">\\Gamma:\\{0,1\\}^{\\kappa}\\to\\{0,1\\}^{m\\ell}</span> to the metablock hash, <span class="math">\\Gamma(H(\\mathcal{B}))</span>, and the PoW is defined to be successful with respect to chain index <span class="math">c</span> iff the <span class="math">c</span>-th <span class="math">\\ell</span>-bit segment of the resulting string is all-zero. Depending on the particular construction or building blocks, the computational complexity of computing the PRG might have to be accounted for the PoW along with the computational complexity of the hash function. In this case, in order to avoid that the adversary can bias his mining towards particular chains by incomplete computation of the PRG part, the miner additionally has to prove knowledge of <span class="math">\\Gamma(H(\\mathcal{B}))</span>, e.g., by providing a hash thereof.</p>

    <p class="text-gray-300">Alternatively, a hash chain of length <span class="math">m</span> can be applied to the metablock whereas success with respect to chain index <span class="math">c</span> is defined to be satisfied iff <span class="math">H^{c}(\\mathcal{B})&lt;M</span> and <span class="math">H^{m}(\\mathcal{B})</span> is included in the <span class="math">aux</span>-part of the respective block <span class="math">B_{c}</span>. Additionally, the mining hardness has to be adapted to compensate for the chained execution of the hash function. It is crucial that the final element of the hash chain is delivered by the miner (and respectively verified) as a proof of complete computation over all chains as, otherwise, the adversary could bias mining towards chains with small index. This second construction has the analytical advantage that it does not involve any cryptographic construction around the use of the random oracle.</p>

    <p class="text-gray-300">Note that, of course, the above constructions are unnecessary if <span class="math">m\\ell\\leq\\kappa</span> as, then, the hash function <span class="math">H</span> directly implements <span class="math">m</span>-for-1-PoW.</p>

    <h4 id="sec-45" class="text-lg font-semibold mt-6">Chains extension with transaction sharding.</h4>

    <p class="text-gray-300">In order to avoid the inclusion of the same transaction in blocks that are being concurrently mined in different chains, and as already described in Section 5.2, we partition the set of transactions available for mining along the lines of “sharding.”</p>

    <p class="text-gray-300">As the miner does not a-priori know for which chains the mined block will be eligible, for each one of the <span class="math">m</span> chains he calculates the hash reference <span class="math">r_{c}=H(\\mathsf{head}(\\mathsf{C}_{c}))</span> and a set <span class="math">x_{c}=\\{\\text{tx}\\mid\\mathsf{chain}(\\text{tx})=c\\}</span> of pending <span class="math">c</span>-transactions such that the current transactions in <span class="math">\\mathcal{C}</span> together with the transactions in <span class="math">\\cup_{c=1}^{m}x_{c}</span> are not in conflict with each other. The miner now forms a Merkle tree where, for all <span class="math">c\\in[m]</span>, the <span class="math">c</span>-th leaf node</p>

    <p class="text-gray-300">corresponds to <span class="math">H(\\langle r_c, x_c, c, s \\rangle)</span> where <span class="math">s = \\pi(\\mathsf{head}(\\mathsf{C}_1))</span> is the observed length of the synchronization chain <span class="math">\\mathsf{C}_1</span>. Let <span class="math">y</span> be the resulting Merkle-tree root. The metablock is now defined as <span class="math">\\mathcal{B} \\triangleq \\langle y, ctr \\rangle</span>.</p>

    <p class="text-gray-300">Upon successful completion of the PoW with respect to chain index <span class="math">c</span>, the block <span class="math">B_{c}</span> is composed as <span class="math">B_{c} \\triangleq \\langle \\mathcal{B}, aux_{c} \\rangle</span> where <span class="math">aux_{c}</span> includes <span class="math">\\langle r_{c}, x_{c}, c, s \\rangle</span> and those nodes of the Merkle tree necessary for verification. Finally, we define <span class="math">\\mathsf{ch}(B_{c}) \\triangleq \\mathsf{ch}(\\mathcal{B})</span>. At the end of a round with successful chain extensions, all respective block instances <span class="math">B_{c}</span> are submitted for diffusion.</p>

    <p class="text-gray-300">Chains update. Collect all new blocks received via diffusion, and for <span class="math">c \\in [m]</span>, set <span class="math">\\mathsf{C}_c</span> to the longest observed chain starting with <span class="math">\\mathcal{G}_c</span> such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>all involved blocks <span class="math">B</span> have the form <span class="math">B = \\langle \\mathcal{B} = \\langle y, ctr \\rangle, aux \\rangle</span> and satisfy</li>

      <li><span class="math">H(\\mathcal{B}) &amp;lt; M_m</span> and <span class="math">\\mathsf{ch}(\\mathcal{B}) = c</span>, and</li>

      <li><span class="math">aux</span> correctly verifies the Merkle root <span class="math">y</span> (with <span class="math">aux</span> containing <span class="math">\\langle r_c, x_c, c, s \\rangle</span> as the preimage of the <span class="math">c</span>-th leaf of the Merkle tree), and</li>

      <li><span class="math">r_c</span> references a block in <span class="math">\\mathsf{C}_c</span>, and</li>

      <li><span class="math">x_c</span> exclusively consists of transactions tx that satisfy <span class="math">\\mathsf{chain}(\\mathrm{tx}) = c</span>, and</li>

      <li><span class="math">s \\leq \\mathsf{len}(\\mathsf{C}_1)</span>; and</li>

      <li>the order of any two involved blocks is preserved with respect to their synchronization blocks: <span class="math">\\forall B, \\bar{B} \\in \\mathsf{C}_c : B \\prec_G \\bar{B} \\Rightarrow \\sigma(B) \\preceq_G \\sigma(\\bar{B})</span>.</li>

    </ul>

    <p class="text-gray-300">In case that multiple longest chains are present for some index <span class="math">c</span> and that one of them has already been present during the previous round then the pre-existing one is given preference — whereas, otherwise, the particular selection does not matter. Note that, over all candidate chains, the <span class="math">\\mathsf{C}_c</span> can be computed efficiently.</p>

    <p class="text-gray-300">Confirmation, stabilization, and ordering. A total order over all eventual transactions will be derived by establishing a total order over all eventual blocks and by sorting the involved transactions, first, by the order of their blocks, and, second, by order of their appearance in the respective block.</p>

    <p class="text-gray-300">We distinguish between block confirmation and block stabilization. Confirmation of a block (with respect to <span class="math">H_{\\mathsf{pc-pow}}^m</span>) means that a block will remain part of <span class="math">\\mathcal{C}</span> forever — it is directly implied by a block's stability with respect to its individual chain. However, confirmation is not sufficient to derive a block's position with respect to the total order over all eventual blocks. We thus additionally define the "stabilization" of a block as a predicate for which we will show that is allows for the determination of a block's position in the final order over all eventual blocks.</p>

    <p class="text-gray-300">Let <span class="math">k \\in \\mathbb{N}</span> be the single-chain prefix parameter to specify the minimal depth a block must have in the chain in order to be declared confirmed in the individual chain. A block <span class="math">B</span> is confirmed iff <span class="math">B \\in \\mathcal{C}^{\\lceil k \\rceil}</span>.</p>

    <p class="text-gray-300">Informally, a confirmed synchronization block gets stabilized as soon as it is referenced by a confirmed block of all other chains (see Figure 5). A block <span class="math">B_1 \\in \\mathsf{C}_1</span> is stable iff</p>

    <div class="my-4 text-center"><span class="math-block">\\psi_ {1} (B _ {1}) \\quad \\triangleq \\quad B _ {1} \\in \\mathsf {C} _ {1} ^ {\\lceil k} \\quad \\wedge \\quad \\forall j \\in \\{2, \\ldots , m \\} \\exists B _ {j} \\in \\mathsf {C} _ {j} ^ {\\lceil k}: B _ {1} \\prec_ {G} B _ {j}.</span></div>

    <p class="text-gray-300">Informally, a non-synchronization block <span class="math">B_{c}</span> gets stabilized as soon as a successor of <span class="math">B_{c}</span>'s synchronization block gets stable. A block <span class="math">B_{c} \\in \\mathcal{C} \\setminus \\mathbb{C}_{1}</span> is stable iff</p>

    <div class="my-4 text-center"><span class="math-block">\\psi_ {2} (B _ {c}) \\quad \\triangleq \\quad B _ {c} \\in \\mathcal {C} ^ {\\lceil k} \\setminus \\mathsf {C} _ {1} \\wedge \\exists B _ {1} \\in \\mathsf {C} _ {1}: \\sigma (B _ {c}) \\prec_ {G} B _ {1} \\wedge \\psi_ {1} (B _ {1}).</span></div>

    <p class="text-gray-300">Accordingly, a block is defined to be stable iff</p>

    <div class="my-4 text-center"><span class="math-block">B \\in \\mathbf {L} \\triangleq \\psi_ {1} (B) \\vee \\psi_ {2} (B),</span></div>

    <p class="text-gray-300">and a transaction is stable, denoted by <span class="math">\\mathrm{tx} \\in \\mathbf{L}</span>, iff it is contained in a stable block and does not conflict with its own history.</p>

    <p class="text-gray-300">It remains to be defined how blocks get ordered, and how their transactions get ordered in the final ledger, respectively. As all blocks sharing the same synchronization block become stable during the same round (in a single party's view), any complete order of the respective blocks is admissible as long as it</p>

    <p class="text-gray-300">19</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 5. Block stabilization in the PoW case. Dashed arrows represent a  <span class="math">\\prec_{G}</span>  relation, i.e., that there is a respective path in Graph  <span class="math">G</span> . Blue blocks indicate that they are at least  <span class="math">k</span>  blocks deep in the individual chain. As soon as this situation occurs, both,  <span class="math">B_{1}</span>  and  <span class="math">B_{c}</span>  become stable — whereas  <span class="math">S</span>  is the synchronization block of  <span class="math">B_{1}</span>  and  <span class="math">B_{c}</span> .</p>

    <p class="text-gray-300">respects the partial order of the graph  <span class="math">G</span> . In order to facilitate an order relation that also reflects the blocks' approximate timing, we define a block's rank as the number of prior blocks in its chain with respect to the same synchronization group:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r k (B) = \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{\\bar {B} \\in \\mathsf {C} _ {\\mathsf {c h} (B)} \\mid \\sigma (\\bar {B}) = \\sigma (B) \\wedge \\bar {B} \\prec_ {G} B \\right\\} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">The order relation  <span class="math">\\prec_{\\beta}</span>  on blocks is now defined as the unique relation to satisfy, for all blocks  <span class="math">B,\\bar{B}\\in \\mathcal{C}</span> , that</p>

    <div class="my-4 text-center"><span class="math-block">B \\prec_ {\\beta} \\bar {B} \\quad \\Leftrightarrow \\quad \\left\\{ \\begin{array}{l l} (\\sigma (B) \\prec_ {G} \\sigma (\\bar {B})) &amp;amp; \\vee \\\\ (\\sigma (B) = \\sigma (\\bar {B}) \\wedge r k (B) &amp;lt;   r k (\\bar {B})) &amp;amp; \\vee \\\\ (\\sigma (B) = \\sigma (\\bar {B}) \\wedge r k (B) = r k (\\bar {B}) \\wedge \\operatorname {c h} (B) &amp;lt;   \\operatorname {c h} (\\bar {B})) &amp;amp; . \\end{array} \\right. \\tag {4}</span></div>

    <p class="text-gray-300">As  <span class="math">\\prec_{\\beta}</span>  defines a total order over all blocks in  <span class="math">\\mathcal{C}</span> , during any round  <span class="math">t</span> , a party  <span class="math">\\mathsf{P}</span>  can extract  <span class="math">\\tilde{\\mathbf{L}}^{\\mathsf{P}}[t]</span>  from his view as the sequence of the transactions contained in a block  <span class="math">B \\in \\mathcal{C}</span> , first, by the order of appearance with respect to  <span class="math">\\prec_{\\beta}</span>  of the block that contains the transaction, and, second, by the transaction's position in the respective block. The stable part of the ledger can then be extracted by  <span class="math">\\mathsf{P}</span>  as  <span class="math">\\mathbf{L}^{\\mathsf{P}}[t]</span>  from his view as the respective sequence of transactions restricted to blocks  <span class="math">B \\in \\mathcal{C}</span>  such that  <span class="math">B \\in \\mathbf{L}^{\\mathsf{P}}[t]</span> .</p>

    <p class="text-gray-300">For a compact description of the protocol  <span class="math">\\varPi_{\\mathrm{pc - pow}}</span>  (and the assumed functionalities), see Figures 6-9.</p>

    <h2 id="sec-46" class="text-2xl font-bold">6.3 Analysis</h2>

    <p class="text-gray-300">We first establish the robustness of  <span class="math">\\Pi_{\\mathrm{pc - pow}}</span>  against Byzantine corruptions. We give a security reduction of  <span class="math">\\Pi_{\\mathrm{pc - pow}}^{m}</span>  involving  <span class="math">m</span>  parallel chains to the security of single-chain Bitcoin — whereas we call this single-chain Bitcoin protocol the corresponding Bitcoin protocol of  <span class="math">\\Pi_{\\mathrm{pc - pow}}</span> .</p>

    <p class="text-gray-300"><strong>Reduction.</strong> We first prove persistence (Definition 1) of  <span class="math">\\Pi_{\\mathrm{pc - pow}}^{m}</span>  given that its implied single-chain executions achieve CP with respect to  <span class="math">k</span> .</p>

    <p class="text-gray-300"><strong>Lemma 4.</strong> If all  <span class="math">m</span>  implied single-chain executions of  <span class="math">\\Pi_{\\mathrm{pc - pow}}^{m}</span>  achieve CP with respect to parameter  <span class="math">k</span>  then  <span class="math">\\Pi_{\\mathrm{pc - pow}}^{m}</span>  satisfies persistence of Definition 1.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Consider an honest party  <span class="math">\\mathsf{P}_1</span>  that computes  <span class="math">\\mathrm{tx} \\in \\mathbf{L}^{\\mathsf{P}_1}[t]</span>  implying that there is a block  <span class="math">B \\in \\mathbf{L}^{\\mathsf{P}_1}[t]</span>  satisfying  <span class="math">\\mathrm{tx} \\in B</span> . Note that  <span class="math">B \\in \\mathbf{L}^{\\mathsf{P}_1}[t]</span>  implies that there exist  <span class="math">B_1 \\in \\mathsf{C}_1^{\\mathsf{P}_1 \\lceil k}[t]</span>  with  <span class="math">\\pi(B_1) = s(B) + 1</span> , and, for all  <span class="math">c &amp;gt; 1</span> ,  <span class="math">B_c \\in \\mathsf{C}_c^{\\mathsf{P}_1 \\lceil k}[t]</span>  with  <span class="math">s(B_c) &amp;gt; s(B)</span> . As  <span class="math">\\mathsf{CP}</span>  with respect to parameter  <span class="math">k</span>  holds for all implied single-chain executions, these blocks remain persistent, and, by the chains-update rule, all eventual blocks  <span class="math">B&#x27;</span>  such that  <span class="math">s(B&#x27;) = s(B)</span>  are already seen by all honest parties — relating to each other with respect to the same partial order. By definition of  <span class="math">\\prec_{\\beta}</span> , the order of these blocks (and their respective transactions) is already immutably fixed with respect to every honest party  <span class="math">\\mathsf{P}_2</span> , and  <span class="math">\\mathbf{L}^{\\mathsf{P}_1}[t] \\preceq \\tilde{\\mathbf{L}}^{\\mathsf{P}_2}[t]</span>  follows.</p>

    <p class="text-gray-300">The protocol  <span class="math">\\Pi_{\\mathrm{pc - pow}}</span>  is run by  <span class="math">n</span>  parties  <span class="math">\\mathsf{P}_1,\\ldots ,\\mathsf{P}_n</span> , interacting among themselves and with ideal functionalities  <span class="math">\\mathcal{F}_{\\mathrm{init}},\\mathcal{F}_{\\mathrm{ro}},\\mathcal{F}_{\\mathrm{diff}}</span>  over a sequence of  <span class="math">L</span>  rounds. Then  <span class="math">\\Pi_{\\mathrm{pc - pow}}</span>  proceeds as follows for each party  <span class="math">\\mathsf{P}_i</span> :</p>

    <p class="text-gray-300">(i) If  <span class="math">\\mathsf{P}_i</span>  is initialized in the first round, it sends (genblocks_req, sid,  <span class="math">\\mathsf{P}_i</span> ) to  <span class="math">\\mathcal{F}_{\\mathrm{init}}</span> , receiving (genblocks, sid,  <span class="math">(\\mathsf{C}_c)_{c=1}^m</span> ), and assigns  <span class="math">\\mathcal{C} := (\\mathsf{C}_c)_{c=1}^m</span> . (ii) If  <span class="math">\\mathsf{P}_i</span>  is initialized after the first round, it receives the local blockchains  <span class="math">\\mathcal{C} = (\\mathsf{C}_c)_{c=1}^m</span>  from the environment. After initialization, during every round,  <span class="math">\\mathsf{P}_i</span>  performs the following steps:</p>

    <p class="text-gray-300">(a)  <span class="math">\\mathsf{P}_i</span>  collects all blocks newly received via diffusion, and collects all new  <span class="math">c</span> -chains starting with  <span class="math">\\mathcal{G}_c</span>  that can be constructed from them and past  <span class="math">c</span> -blocks into  <span class="math">\\mathbb{C}_c</span>  such that, for each such chain, all involved blocks  <span class="math">B</span>  have the form  <span class="math">B = \\langle \\mathcal{B} = \\langle y, c t r \\rangle, a u x \\rangle</span>  and satisfy:</p>

    <p class="text-gray-300">(i)  <span class="math">H(\\mathcal{B}) &amp;lt; M_m</span>  and  <span class="math">\\mathsf{ch}(\\mathcal{B}) = c</span> , and (ii) aux correctly verifies the Merkle root  <span class="math">y</span>  (with aux containing  <span class="math">\\langle r_c, x_c, c, s \\rangle</span>  as the preimage of the  <span class="math">c</span> -th leaf of the Merkle tree), and (iii)  <span class="math">r_c</span>  references a block in  <span class="math">\\mathsf{C}_c</span> , and (iv)  <span class="math">x_{c}</span>  exclusively consists of transactions tx that satisfy chain(tx) = c, and (v)  <span class="math">s\\leq \\mathsf{len}(\\mathsf{C}_1)</span>  ; and (vi) the order of any two involved blocks is preserved with respect to their synchronization blocks:  <span class="math">\\forall B, \\tilde{B} \\in \\mathbb{C}_c : B \\prec_G \\tilde{B} \\Rightarrow \\sigma(B) \\preceq_G \\sigma(\\tilde{B})</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Chains Extension.  <span class="math">\\mathsf{P}_i</span>  receives from the environment the transaction data  <span class="math">d^{<em>}\\in \\{0,1\\}^{</em>}</span>  to be inserted into the ledger and extracts from if a sequence  <span class="math">d\\in \\{0,1\\} ^*</span>  that can be appended to GetValidTX  <span class="math">(\\mathcal{C})</span>  without invalidating it.</li>

    </ol>

    <p class="text-gray-300">(a) For all  <span class="math">c \\in [m]</span> ,  <span class="math">\\mathsf{P}_i</span>  extracts the  <span class="math">c</span> -transactions in  <span class="math">d</span>  as  <span class="math">x_c</span>  and composes  <span class="math">t_c := \\langle r_c, x_c, c, s \\rangle</span>  where  <span class="math">r_c = H(\\mathsf{head}(\\mathsf{C}_c))</span> , and  <span class="math">s = \\pi (\\mathsf{head}(\\mathsf{C}_1))</span> . (b)  <span class="math">\\mathsf{P}_i</span>  composes a Merkle tree from the  <span class="math">m</span>  hashes  <span class="math">H(t_{c})</span>  with root  <span class="math">y</span> . (c)  <span class="math">\\mathsf{P}_i</span>  sets  <span class="math">ctr = 0</span>  and repeats</p>

    <p class="text-gray-300">i. increase  <span class="math">ctr</span>  and compute metablock  <span class="math">\\mathcal{B} \\coloneqq \\langle y, ctr \\rangle</span> .</p>

    <p class="text-gray-300">ii. if  <span class="math">H(\\mathcal{B}) &amp;lt; M_m</span> :</p>

    <p class="text-gray-300">A.  <span class="math">c\\coloneqq \\mathsf{ch}(\\mathcal{B}) = 1 + H(\\mathcal{B})</span>  mod  <span class="math">m</span> B. compute  <span class="math">aux_{c}</span>  as consisting of  <span class="math">t_{c}</span>  and all Merkle-tree nodes necessary for the verification with respect to  <span class="math">y</span> , and compute  <span class="math">B_{c} \\coloneqq \\langle \\mathcal{B}, aux_{c} \\rangle</span> . C. compute  <span class="math">\\mathsf{C}_c\\coloneqq \\mathsf{C}_c\\parallel B_c</span>  , and recompute  <span class="math">\\mathcal{C}</span> D. prepare  <span class="math">B_{c}</span>  for distribution by use of  <span class="math">\\mathcal{F}_{\\mathrm{diff}}</span></p>

    <p class="text-gray-300">(d) until  <span class="math">ctr = q</span> (e)  <span class="math">\\mathsf{P}_i</span>  diffuses all blocks prepared for diffusion.</p>

    <p class="text-gray-300">Upon a request from some party  <span class="math">\\mathsf{P}_i</span>  of the form (genblocks_req, sid,  <span class="math">\\mathsf{P}_i</span> ) it returns (genblocks, sid,  <span class="math">(\\mathsf{C}_c)_{c=1}^m</span> ) where  <span class="math">\\mathsf{C}_c = (\\mathcal{G}_c)</span> .</p>

    <p class="text-gray-300">Return the longest chain from  <span class="math">\\mathbb{C}</span>  whereas preference is given to  <span class="math">\\mathbb{C}</span>  in case of multiple longest chains.</p>

    <p class="text-gray-300">For liveness, consider a transaction tx that is given as an input to all honest parties for some sufficient number  <span class="math">u&#x27;</span>  of consecutive rounds (whereas  <span class="math">u&#x27;</span>  is to be determined) and consider the first such round. Then transaction tx gets stable in all honest parties' views (the latest) after the following events have happened (see also Figure 5) — we only sketch the more complicated case where the transaction gets added to a non-synchronization chain ( <span class="math">c &amp;gt; 1</span> ):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The transaction is included in an honest block  <span class="math">B_{c}</span>  that gets added to some chain  <span class="math">\\mathsf{C}_c</span>  of  <span class="math">\\mathcal{C}</span>  and confirmed by all honest parties. Note that a block  <span class="math">S \\in \\mathsf{C}_1</span>  such that  <span class="math">s(B_{c}) = \\pi (S)</span>  now exists with respect to all parties but that this  <span class="math">S</span>  might still change over time due to forks.</li>

    </ol>

    <p class="text-gray-300">Fig. 9. Procedure GetValidTX(C₁, ..., Cₘ).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the order relation <span class="math">\\prec_{\\beta}</span> over all blocks of the chains C₁, ..., Cₘ.</li>

      <li>Extract all respective transactions.</li>

      <li>Order these transactions in an increasing order according to the following following criteria, listed in decreasing priority:</li>

    </ol>

    <p class="text-gray-300">(a) order of its containing block B with respect to <span class="math">\\prec_{\\beta}</span>; (b) position of the transaction within B.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Process all the transactions in the above-obtained order and remove all transactions that are invalid with respect to the ledger state formed by all the preceding transactions.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The synchronization chain C₁ gets added a block B₁ of height π(S) + 1 in every honest party’s view (if not already present).</li>

      <li>After the above events have happened, each chain C_j (j &gt; 1) gets added a block B_j that references a synchronization block of height larger than π(S), and all these B_j get confirmed by all honest parties. Concurrently, the synchronization block B₁ gets confirmed by all honest parties.</li>

    </ol>

    <p class="text-gray-300">Assume that the implied executions satisfy CP prefix with respect to parameter k, CG with respect to parameters τ and s, and CQ with respect to parameters μ &gt; 0 and ℓ, and 0 &lt; s · τ ≤ min(k, ℓ). Then, for a respective execution of Πₙₑ₌ₙₒₒₑ, we can estimate the following (deterministic) upper bound on the number of rounds required for each of the three above events to happen.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>and 2. ⌊ℓ + k/τ⌋ rounds. During these rounds, ℓ blocks get added — at least one of them honest due to chain quality — and k additional blocks on top implying the confirmation of such an honest block. Due to chain growth, during the rounds where the additional k blocks are added, the synchronization chain is guaranteed to be added a block of height larger than s(B_c).</li>

      <li>⌊ℓ + k/τ⌋ rounds — along the above lines.</li>

    </ol>

    <p class="text-gray-300"><strong>Lemma 5.</strong> If all implied executions from Πₙₑ₌ₙₒₒₑ achieve CP, CQ, and CG as parameterized above then Πₙₑ₌ₙₒₒₑ satisfies liveness with respect to parameter u' = 2⌊ℓ + k/τ⌋.</p>

    <p class="text-gray-300"><strong>Proof.</strong> The lemma follows from the above discussion.</p>

    <p class="text-gray-300"><strong>Robustness.</strong> We follow the Bitcoin analysis in [19] as summarized below. Consider the following parameters as defined in [19]:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let f = 1 - (1 - p)^{q(n - t)} denote the probability that, during one round, at least one honest party obtains a PoW.</li>

      <li>Let η ∈ ℝ, the block-to-round translation parameter, be fixed such that the expected number of rounds with honest PoW successes during η · κ rounds is fηκ = Ω(κ).</li>

      <li>Let ε ∈ ℝ (used for Chernoff bounds) satisfy 3Δf + 5ε + 3Δ/ηκ ≤ n-2t/n-t.</li>

    </ul>

    <p class="text-gray-300"><strong>Proposition 1 ([19]).</strong> When parameterized as above, an L-round execution of Bitcoin, where L is polynomially bounded by κ, achieves the following properties except for an error probability ε_B negligible in κ:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>CP: Common prefix for k ≥ 2fηκ + 2Δ.</li>

      <li>CG: Chain growth with respect to s ≥ ηκ and τ = (1 - ε)f(1 - f)Δ.</li>

      <li>CQ: Chain quality with respect to ℓ ≥ 2fηκ + Δ and μ &gt; 0 (a weaker bound than in [19] but sufficient for our purposes).</li>

    </ul>

    <p class="text-gray-300">6 This ensures that the properties demanded for their typical executions are satisfied except for an error probability negligible in the security parameter κ.</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Lemma 6.</h6>

    <p class="text-gray-300">Let the parameters be as above. Then, except for an error probability <span class="math">\\varepsilon\\leq m\\cdot\\varepsilon_{B}+\\Pr\\left[\\neg\\textsf{MaxDelay}_{\\Delta}\\right]</span>, an <span class="math">L</span>-round execution of <span class="math">\\Pi^{m}_{\\textsf{pc-pow}}</span> achieves liveness with respect to parameter</p>

    <p class="text-gray-300"><span class="math">u^{\\prime}=2u=2\\left\\lfloor\\frac{\\ell+k}{\\tau}\\right\\rfloor=2\\left\\lfloor\\frac{4f\\eta\\kappa+3\\Delta}{(1-\\epsilon)f(1-f)^{\\Delta}}\\right\\rfloor\\ ,</span></p>

    <p class="text-gray-300">whereas <span class="math">u</span> is the liveness parameter of Bitcoin as derived in <em>[19]</em>, and <span class="math">\\varepsilon_{B}</span> the respective error probability.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The stochastic process for block-generation of each individual chain is equivalent to the respective process in the corresponding Bitcoin protocol. Furthermore, block scheduling with respect to an implied single-chain execution in <span class="math">\\Pi^{m}_{\\textsf{pc-pow}}</span> can be efficiently simulated by the adversary in the corresponding Bitcoin protocol, implying that violating any of the properties CP, CQ, or CG in <span class="math">\\Pi^{m}_{\\textsf{pc-pow}}</span> could be equivalently achieved in Bitcoin. Thus, the lemma follows by a union bound over the error probabilities of the respective Bitcoin executions. ∎</p>

    <p class="text-gray-300">Theorem 5 below follows from Lemmas 4 (persistence) and 6 (liveness).</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Theorem 5 (Robustness).</h6>

    <p class="text-gray-300">Except for an error probability <span class="math">\\varepsilon_{\\textsf{rob}}\\leq m\\cdot\\varepsilon_{B}+\\Pr\\left[\\neg\\textsf{MaxDelay}_{\\Delta}\\right]</span>, an <span class="math">L</span>-round execution of <span class="math">\\Pi^{m}_{\\textsf{pc-pow}}</span> implements a robust transaction ledger with liveness parameter <span class="math">u^{\\prime}=2u</span> where <span class="math">u</span> is the liveness parameter of the corresponding Bitcoin protocol as derived in <em>[19]</em>, and <span class="math">\\varepsilon_{B}</span> is the respective error probability (negligible in the security parameter).</p>

    <h3 id="sec-55" class="text-xl font-semibold mt-8"><span class="math">\\kappa</span>-Boundedness.</h3>

    <p class="text-gray-300">For our estimations on <span class="math">\\kappa</span>-boundedness and throughput, for the corresponding Bitcoin protocol (or, the chain of an implied single-chain execution) we define <span class="math">f</span> as the probability that at least one uncorrupted party makes a successful PoW query during a given round: <span class="math">f=1-(1-p)^{nq}</span>. In order to demonstrate <span class="math">\\kappa</span>-boundedness, we can directly reuse Lemmas 2 and 3 from Section 5 under the following modified bound (2) on <span class="math">m</span> (bounding away from <span class="math">1</span> the expected number of overall blocks created during one protocol round):</p>

    <p class="text-gray-300"><span class="math">m\\leq(1-\\xi_{2})/(npq)\\ .</span> (5)</p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Theorem 6 (<span class="math">\\kappa</span>-Boundedness).</h6>

    <p class="text-gray-300">Let <span class="math">\\kappa\\in\\mathbb{N}</span> and <span class="math">\\xi_{2}\\in(0,1/2)</span>, let <span class="math">n</span>, <span class="math">p</span>, <span class="math">q</span>, and <span class="math">f</span> be as defined above for the corresponding Bitcoin protocol, and let <span class="math">m</span> satisfy (5). The probability that, during an <span class="math">L</span>-round execution of <span class="math">\\Pi^{m}_{\\textsf{pc-pow}}</span> with <span class="math">\\mathcal{A}_{\\perp}</span>, there is a block that incurs a delay of at least <span class="math">\\kappa</span> rounds, is bounded by</p>

    <p class="text-gray-300"><span class="math">\\varepsilon_{\\kappa}\\leq 2L\\cdot\\exp\\left(-\\frac{\\xi_{2}^{2}(\\xi_{2}\\kappa-3)}{9}\\right)\\ .</span></p>

    <p class="text-gray-300">Hence, the protocol <span class="math">\\Pi^{m}_{\\textsf{pc-pos}}</span> executed over a period of <span class="math">L</span> slots is <span class="math">(\\kappa,\\varepsilon_{\\kappa})</span>-bounded.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof follows along the lines of the proof of Theorem 3. ∎</p>

    <h3 id="sec-58" class="text-xl font-semibold mt-8">Throughput.</h3>

    <p class="text-gray-300">A sufficient condition for a mined block <span class="math">B</span> to eventually become stable in <span class="math">\\mathsf{C}_{c}</span> is that a block gets mined for <span class="math">\\mathsf{C}_{c}</span> during a <span class="math">\\Delta</span>-right isolated successful round along the lines of the proof of Theorem 4. We denote this probability by <span class="math">\\widehat{f}=f(1-f)^{\\Delta}</span>.</p>

    <h6 id="sec-59" class="text-base font-medium mt-4">Theorem 7 (Throughput).</h6>

    <p class="text-gray-300">Fix parameters <span class="math">n,q,k,\\Delta\\in\\mathbb{N}</span>, <span class="math">\\xi_{3},p\\in(0,1/2]</span>, <span class="math">f=1-(1-p)^{nq}</span>, assume that <span class="math">(1-f)^{\\Delta}\\geq 1/2</span>, and let <span class="math">\\widehat{f}=f(1-f)^{\\Delta}</span>. Let <span class="math">\\mathcal{A}\\in\\mathbb{A}_{\\textsf{fs}}</span> be a fail-stop adversary that, for <span class="math">\\widehat{\\alpha_{\\mathcal{H}}}\\in(0,1]</span>, corrupts any fraction <span class="math">1-\\widehat{\\alpha_{\\mathcal{H}}}</span> of the <span class="math">n</span> parties. The protocol <span class="math">\\Pi^{m}_{\\textsf{pc-pow}}</span> achieves <span class="math">(\\theta,L_{0})</span>-throughput for any <span class="math">L_{0}\\geq(2k+2+3\\Delta)/((1-\\xi_{3})^{2}\\widehat{\\alpha_{\\mathcal{H}}}\\widehat{f})</span> and for</p>

    <p class="text-gray-300"><span class="math">\\theta=(1-\\xi_{3})^{2}\\cdot\\left(1-\\frac{k+1+4\\Delta}{(1-\\xi_{3})^{2}\\widehat{\\alpha_{\\mathcal{H}}}\\widehat{f}L_{0}}\\right)\\cdot\\widehat{\\alpha_{\\mathcal{H}}}\\cdot\\widehat{f}\\cdot m</span> (6)</p>

    <p class="text-gray-300">against <span class="math">\\mathcal{A}</span> except with error <span class="math">\\varepsilon_{\\mathsf{tp}}\\triangleq 4\\cdot m\\cdot\\exp\\left(-\\xi_{3}^{2}\\widehat{\\alpha_{\\mathcal{H}}}\\widehat{f}(k+1)/4\\right)+\\Pr\\left[\\neg\\textsf{MaxDelay}_{\\Delta}\\right]</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Proof.</p>

    <p class="text-gray-300">The proof proceeds along the lines of the proof of Theorem 4 by partitioning the respective interval of <span class="math">L</span> rounds into intervals <span class="math">I_{\\mathsf{pref}}</span> and <span class="math">I_{\\mathsf{suf}}</span>, and demonstrating that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>each chain contains at least <span class="math">(1-\\xi_{3})^{2}\\cdot\\widehat{\\alpha_{\\mathcal{H}}}\\cdot\\widehat{f}\\cdot L_{\\mathsf{pref}}-2\\Delta</span> blocks in <span class="math">I_{\\mathsf{pref}}</span>;</li>

      <li>all <span class="math">m</span> chains produced by <span class="math">\\Pi_{\\mathsf{pc-pow}}^{m}</span> contain at least <span class="math">k+1</span> blocks in <span class="math">I_{\\mathsf{suf}}</span>.</li>

    </ol>

    <p class="text-gray-300">Note the difference of Property (ii) with respect to the PoS case: One additional block besides the <span class="math">k</span> blocks is required to imply that each chain <span class="math">\\mathsf{C}_{c}</span> received a confirmed block in the suffix interval that (indirectly) references the last synchronization block in the prefix interval, and, that the respective synchronization block got confirmed in the suffix interval; i.e., that all blocks in the prefix interval are stable as defined in Section 6.2.</p>

    <p class="text-gray-300">Again we define <span class="math">I_{\\mathsf{pref}}^{\\prime}</span> (<span class="math">I_{\\mathsf{suf}}^{\\prime}</span>) as the interval <span class="math">I_{\\mathsf{pref}}</span> (<span class="math">I_{\\mathsf{suf}}</span>) without its first <span class="math">\\Delta</span> slots, and <span class="math">L_{\\mathsf{pref}}^{\\prime}=L_{\\mathsf{pref}}-\\Delta</span> (<span class="math">L_{\\mathsf{suf}}^{\\prime}=L_{\\mathsf{suf}}-\\Delta</span>). Exactly as in Section 5, we can show that Property (i) holds except for probability</p>

    <p class="text-gray-300"><span class="math">p_{\\mathsf{pref}}\\triangleq\\Pr\\left[\\sum_{t\\in I_{\\mathsf{pref}}^{\\prime}}\\mathsf{good}(t)\\leq(1-\\xi_{3})^{2}\\cdot\\widehat{\\alpha_{\\mathcal{H}}}\\cdot\\widehat{f}\\cdot L_{\\mathsf{pref}}^{\\prime}-\\Delta\\right]\\leq 2\\exp\\left(-\\frac{\\xi_{3}^{2}\\cdot\\widehat{\\alpha_{\\mathcal{H}}}^{2}\\cdot f^{2}\\cdot L_{\\mathsf{pref}}^{\\prime}}{4}\\right)\\;.</span></p>

    <p class="text-gray-300">Interval <span class="math">I_{\\mathsf{suf}}</span> is now extended to compensate for an additional block as opposed to the PoS case, <span class="math">L_{\\mathsf{suf}}\\triangleq(k+1+\\Delta)/(1-\\xi_{3})^{2}\\widehat{\\alpha_{\\mathcal{H}}}\\widehat{f}+\\Delta</span>, yielding that <span class="math">I_{\\mathsf{suf}}^{\\prime}</span> will contain at least <span class="math">k+1</span> good slots except for error probability <span class="math">p_{\\mathsf{suf}}\\triangleq 2\\exp\\left(-\\xi_{3}^{2}\\widehat{\\alpha_{\\mathcal{H}}}f(k+1)/4\\right)</span>, establishing (ii).</p>

    <p class="text-gray-300">Hence we can conclude that for <span class="math">L_{\\mathsf{suf}}</span> given above and <span class="math">L_{\\mathsf{pref}}\\triangleq L-L_{\\mathsf{suf}}</span>, the interval <span class="math">I_{\\mathsf{pref}}</span> contains at least <span class="math">(1-\\xi_{3})^{2}\\cdot\\widehat{\\alpha_{\\mathcal{H}}}\\cdot\\widehat{f}\\cdot m\\cdot L_{\\mathsf{pref}}^{\\prime}-\\Delta</span> <em>stable</em> blocks in all <span class="math">m</span> chains except with probability <span class="math">m\\cdot(p_{\\mathsf{pref}}+p_{\\mathsf{suf}})</span>, resulting in the throughput parameter <span class="math">\\theta</span> in (6). Under the assumption <span class="math">L_{0}\\geq(2k+2+3\\Delta)/((1-\\xi_{3})^{2}\\widehat{\\alpha_{\\mathcal{H}}}\\widehat{f})</span> we have <span class="math">p_{\\mathsf{pref}}\\leq p_{\\mathsf{suf}}</span> and the bound on <span class="math">\\varepsilon_{\\mathsf{tp}}</span> in the theorem statement follows. ∎</p>

    <p class="text-gray-300">Noting that <span class="math">npq\\leq f/(1-f)</span> we get the following corollary.</p>

    <h6 id="sec-60" class="text-base font-medium mt-4">Corollary 2.</h6>

    <p class="text-gray-300">Under the notation and assumptions in Theorems 6 and 7 the protocol <span class="math">\\Pi_{\\mathsf{pc-pow}}^{m}</span> for <span class="math">m=(1-\\xi_{2})(1-f)/f\\leq(1-\\xi_{2})/(npq)</span> is <span class="math">(\\kappa,\\varepsilon_{\\kappa})</span>-bounded for any <span class="math">\\kappa</span> and achieves <span class="math">(\\theta,L_{0})</span>-throughput against fail-stop adversaries for any <span class="math">L_{0}\\geq(2k+2+3\\Delta)/((1-\\xi_{3})^{2}\\widehat{\\alpha_{\\mathcal{H}}}\\widehat{f})</span> and</p>

    <p class="text-gray-300"><span class="math">\\theta=(1-\\xi_{2})\\cdot(1-\\xi_{3})^{2}\\cdot(1-f)^{\\Delta+1}\\cdot\\left(1-\\frac{k+1+4\\Delta}{(1-\\xi_{3})^{2}\\widehat{\\alpha_{\\mathcal{H}}}\\widehat{f}L_{0}}\\right)\\cdot\\widehat{\\alpha_{\\mathcal{H}}}</span></p>

    <p class="text-gray-300">except with error probability <span class="math">\\varepsilon_{\\mathsf{tp}}</span>.</p>

    <h6 id="sec-61" class="text-base font-medium mt-4">Remark 3.</h6>

    <p class="text-gray-300">Note that, above, throughput optimality was only demonstrated in presence of a fail-stop adversary. As remarked for the PoS case, our PoW construction can be adapted along the same lines in order to achieve Byzantine throughput optimality — a property first achieved in <em>[2]</em>.</p>

    <h3 id="sec-62" class="text-xl font-semibold mt-8">6.4 Comparison to Prior Parallel-Chains Constructions</h3>

    <p class="text-gray-300"><em>Committee-based sharding, e.g., </em>[28, 24, 42]<em>.</em> As each shard (or chain) is assigned a subset of the nodes, such protocols tolerate at most <span class="math">n/3</span> active corruptions and are not secure against fully adaptive corruption. Our construction is adaptively secure against a faulty minority.</p>

    <p class="text-gray-300"><em>Chainweb </em>[29]<em>.</em> The protocol enforces that a block of a given height <span class="math">h</span> in a particular chain can only be mined if blocks of height <span class="math">h-1</span> of all <span class="math">m</span> chains have already been mined. Furthermore, nodes are free to decide which chains to allocate their mining power to. Thus, honest nodes will always concentrate their mining towards the chains that still miss a block of maximal height.</p>

    <p class="text-gray-300">Despite the specific security properties demonstrated in <em>[22]</em>, the ability of the adversary to concentrate her mining power to a single chain implies that she can considerably reduce the quality of the respective</p>

    <p class="text-gray-300">chain. Furthermore, as, in Chainweb, the chains are somewhat independent (or, at least are responsible for different partition subsets with respect to transaction sharding) this has a similar effect on liveness. In particular, we argue that liveness is only achieved with respect to a liveness parameter in <span class="math">\\Omega(m^{2})</span>, i.e., that there is an adversary strategy to make confirmation times depend quadratically in the number <span class="math">m</span> of chains.</p>

    <p class="text-gray-300">Consider a transaction of a kind that must be published on the chain with index <span class="math">1</span>, and consider an adversary that invests all her mining power in order to delay a respective transaction submitted for mining. The adversary proceeds as follows for each block layer of same height:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The full mining power is invested into chain <span class="math">1</span> in order to pre-publish a block not containing the transaction. If successful, the honest miners will not work on this chain until the current block layer is completed.</li>

      <li>In case an honest block <span class="math">B</span> was published before the adversary was successful, the adversary invests all mining power into chain <span class="math">1</span> in order to create as many forks as possible that extend <span class="math">B</span>’s parent block by a sibling block for <span class="math">B</span> (not containing the transaction) — until the current block layer is completed.</li>

    </ol>

    <p class="text-gray-300">Assuming that the adversary possesses roughly the same amount of mining power as the honest nodes, we observe that, per layer, the probability that the adversary fails in Step 1 is roughly <span class="math">p_{\\textsf{pub}}=m^{-1}</span> as her mining power for chain <span class="math">1</span> is about <span class="math">m</span> times that of the honest nodes (who, for an empty layer, uniformly distribute their mining over all chains). Furthermore, assume that an honest node managed to publish a block <span class="math">B</span> on chain <span class="math">1</span> on a given layer. Such a block must have been published as one of the first blocks of this layer with high probability, implying that roughly <span class="math">m</span> blocks remain to be mined for this layer. Thus, during the time the honest miners complete the pending layer, the adversary will manage to mine roughly <span class="math">m</span> sibling forks for block <span class="math">B</span>. That is, given that an honest party published a block <span class="math">B</span> on chain <span class="math">1</span>, the probability that <span class="math">B</span> will be referenced by the next layer is (at most) roughly <span class="math">p_{\\textsf{ref}}=m^{-1}</span>.</p>

    <p class="text-gray-300">Thus, the per-layer probability that the given transaction gets published in a block that will be referenced by the next layer is roughly <span class="math">p_{\\textsf{pub}}\\cdot p_{\\textsf{ref}}=m^{-2}</span>, and Chainweb achieves liveness with a liveness parameter that is <span class="math">\\Omega(m^{2})</span> whereas our construction achieves liveness with respect to parameter <span class="math">2u</span> where <span class="math">u</span> is the liveness parameter of the single chain.</p>

    <h5 id="sec-63" class="text-base font-semibold mt-4">Blockclique <em>[17]</em></h5>

    <p class="text-gray-300">Also in this protocol, the adversary can concentrate her mining power to a single chain. It is thus conceivable that a similar tradeoff for liveness has to be tolerated — but expectedly to a lesser extent than for Chainweb, as the honest miners are not incentivized to exclude particular chains from mining. As of now, we know of no analysis to demonstrate any upper bounds on liveness for this protocol.</p>

    <h2 id="sec-64" class="text-2xl font-bold">7 Security Amplification and Latency Reduction</h2>

    <p class="text-gray-300">We consider security amplification—and the related issue of reducing settlement times and latency—in blockchain protocols. Roughly, we describe a general construction which uses <span class="math">m</span> underlying blockchains to provide a new transaction settlement mechanism in which transactions settle <span class="math">\\Theta(m)</span> times faster. (The <span class="math">\\Theta(\\cdot)</span> notation hides a constant independent of <span class="math">m</span>.) In fact, the construction provides a flexible means to trade off settlement time against the number of underlying blockchains in which a transaction should be logged. In the natural setting where there is a cost associated with including a transaction in a blockchain, this yields a trade off between cost and settlement time.</p>

    <p class="text-gray-300">More specifically, by logging a transaction in <em>all</em> of the underlying blockchains, users can be promised a <span class="math">\\Theta(m)</span> (multiplicative) reduction in settlement time; on the other hand, by logging a transaction in a single one of the underlying blockchains, users can be promised a settlement time roughly consistent with the original settlement time of the underlying blockchains.</p>

    <h5 id="sec-65" class="text-base font-semibold mt-4">The underlying blockchains</h5>

    <p class="text-gray-300">We describe the construction in a concrete setting, such as might arise if one wished to improve the settlement time of an established blockchain protocol like Bitcoin, Ethereum, or Ouroboros. In this case, the construction calls for simultaneous operation of <span class="math">m</span> independent blockchains which share a common transaction environment. Specifically, while each individual blockchain is executed independently, transactions are settled across the entire family of chains (with a mechanism that we describe</p>

    <p class="text-gray-300">below). We assume that the underlying blockchains provide <em>exponential</em> security, which is to say that the probability that a block currently appearing in the blockchain can be later abandoned is no more than <span class="math">\\exp(-\\alpha k+\\beta)</span>, where <span class="math">k</span> is the number of time slots that have elapsed since the block was broadcast. Here <span class="math">\\alpha,\\beta&gt;0</span> are two real numbers that depend on the dynamics of the blockchain and the power of the adversary. (Note that typical PoW blockchains indeed provide such exponential security <em>[18]</em> and recent results have shown that PoS-blockchains can obtain similar guarantees <em>[7]</em>.) We further assume that the <span class="math">m</span> underlying blockchains are <em>independent</em>, in the sense that the probability that an adversary can engineer common prefix (persistence) violations in a collection of blockchains is no more than the product of the individual violation probabilities. Indeed, this is satisfied by the PoS construction given in Section 5.2, and also can be achieved in the PoW setting by a mechanism we discussed in Section 6.2.</p>

    <h5 id="sec-66" class="text-base font-semibold mt-4">Settlement time and validity</h5>

    <p class="text-gray-300">Note that the time to settle a transaction, in general, is a sum of both the time it takes for the transaction to appear in the system (after being broadcasted), and the time it needs to to stabilize (i.e., become immutable). For simplicity, in this section we focus explicitly on the latter, ignoring the time taken for the transaction to appear in the underlying blockchain(s) in the first place. With this picture, our study of “settlement” yields a quantitative guarantee that transactions are eventually “permanent” and hence cannot be removed from the system by future processing.</p>

    <p class="text-gray-300">A significant complication arises from <em>conflicting</em> transactions; in particular, the system must eventually declare any transaction <em>valid</em> or <em>invalid</em> in such a way that (i.) two conflicting transactions are never declared valid, and (ii.) transactions without immediate conflicts will be persistently declared as valid. Assuming a UTXO-style convention for expressing transactions (which explicitly identifies the previous transactions relevant to a particular transaction), it is easy to determine if two transactions conflict without any further context. Note that under the promise that no conflicting transactions are ever submitted to the blockchains, there would be an immediate rule for interpreting the transactions that appear across the family of blockchains: simply declare valid all transactions appearing in the stable parts of (all) the blockchains. Note, furthermore, that this system would actually provide a remarkable improvement in persistence (and hence latency): Specifically, if a given transaction tx is included “<span class="math">k</span>-slots ago” in <em>all</em> <span class="math">m</span> blockchains, the probability that each of these independent chains is reverted is approximately <span class="math">\\epsilon_{k}^{m}</span>, where <span class="math">\\epsilon_{k}</span> is the probability of a <span class="math">k</span>-common prefix (time) violation in a single chain. In this case, the system can provide a significant improvement in security for the same common prefix time bound (<span class="math">k</span>) or, alternatively, offer a significant improvement in settlement time for a desired failure probability. As mentioned above, this simple mechanism does not provide a means for settling conflicts; the major challenge, then, is to simultaneously provide such settlement acceleration and unambiguously resolve all conflicts.</p>

    <h5 id="sec-67" class="text-base font-semibold mt-4">The construction</h5>

    <p class="text-gray-300">The simple protocol mentioned above does not provide a means for managing conflicting transactions (as it places all transactions included in the underlying blockchains on equal footing). For this purpose, we describe a more sophisticated convention which assigns to every transaction in the system a <em>weight</em>, as follows.</p>

    <h6 id="sec-68" class="text-base font-medium mt-4">Definition 6 (Weight and the partial order <span class="math">\\prec_{L}</span>).</h6>

    <p class="text-gray-300">Let <span class="math">L&gt;0</span>. For a transaction <span class="math">\\mathrm{tx}</span> and a blockchain <span class="math">\\mathcal{B}</span>, we say that <span class="math">\\mathrm{tx}</span> is <em>dominant in</em> <span class="math">\\mathcal{B}</span> if it appears prior to any conflicting transaction in <span class="math">\\mathcal{B}</span>. For a transaction <span class="math">\\mathrm{tx}</span>, let <span class="math">\\eta_{i}(\\mathrm{tx})</span> denote the height at which <span class="math">\\mathrm{tx}</span> appears in the <span class="math">i</span>th blockchain, where <em>height</em> refers to the time slot associated with the first block containing <span class="math">\\mathrm{tx}</span>; if <span class="math">\\mathrm{tx}</span> does not appear in the blockchain, we define <span class="math">\\eta_{i}(\\mathrm{tx})=\\infty</span>. For a transaction <span class="math">\\mathrm{tx}</span>, define</p>

    <p class="text-gray-300">\\[ h_{i}(\\mathrm{tx})\\triangleq\\begin{cases}\\eta_{i}(\\mathrm{tx})&\\text{if <span class="math">\\mathrm{tx}</span> is dominant in the <span class="math">i</span>th blockchain,}\\\\ \\infty&\\text{otherwise.}\\end{cases} \\]</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">Let <span class="math">h(\\mathrm{tx})\\triangleq\\min_{i}h_{i}(\\mathrm{tx})</span>. Then define</p>

    <p class="text-gray-300"><span class="math">\\mathrm{weight}_{L}(\\mathrm{tx})\\triangleq\\sum_{\\stackrel{{\\scriptstyle i\\text{ such that}}}{{h_{i}(\\mathrm{tx})&lt;h(\\mathrm{tx})+L\\ln m}}}\\exp(-h_{i}(\\mathrm{tx})/L)\\,.</span></p>

    <p class="text-gray-300">Finally, define <span class="math">\\mathrm{tx}_{1}\\prec_{L}\\mathrm{tx}_{2}</span> if (and only if) <span class="math">\\mathrm{weight}_{L}(\\mathrm{tx}_{1})&gt;\\mathrm{weight}_{L}(\\mathrm{tx}_{2})</span>. Observe that <span class="math">\\prec_{L}</span> is a partial order.</p>

    <p class="text-gray-300">We are now in a position to describe the construction.</p>

    <h6 id="sec-69" class="text-base font-medium mt-4">Construction 1</h6>

    <p class="text-gray-300">Consider <span class="math">m</span> blockchains possessing exponential security <span class="math">k\\mapsto\\exp(-\\alpha k+\\beta)</span>, as above. With <em>weight</em> defined as above, we define a transaction <span class="math">\\mathrm{tx}</span> to be <em>valid</em> if <span class="math">\\mathrm{tx}\\prec_{L}\\mathrm{tx}^{\\prime}</span> for all conflicting transactions <span class="math">\\mathrm{tx}^{\\prime}</span> appearing in any of the blockchains. Otherwise <span class="math">\\mathrm{tx}</span> is <em>invalid</em>.</p>

    <p class="text-gray-300">A few remarks are in order. Note that the weight of a transaction is determined entirely by the first <span class="math">h(\\mathrm{tx})+L\\ln m</span> timeslots over the <span class="math">m</span> blockchains; in particular, this quantity is eventually fixed for all transactions (that appear in stable portions of the blockchains). Note, furthermore, that if a transaction <span class="math">\\mathrm{tx}</span> (dominant in at least one blockchain) first appears at height <span class="math">h=h(\\mathrm{tx})</span>, then its weight satisfies</p>

    <p class="text-gray-300"><span class="math">\\exp(-h/L)\\leq\\mathrm{weight}_{L}(\\mathrm{tx})\\leq m\\cdot\\exp(-h/L)\\,.</span></p>

    <p class="text-gray-300">It follows that if <span class="math">h(\\mathrm{tx}_{1})+L\\ln m&lt;h(\\mathrm{tx}_{2})</span> then <span class="math">\\mathrm{weight}_{L}(\\mathrm{tx}_{1})&gt;\\mathrm{weight}_{L}(\\mathrm{tx}_{2})</span> and, hence, that a transaction’s classification as either <em>valid</em> or <em>invalid</em> is entirely determined by the portions of the blockchains of height no more than <span class="math">h(\\mathrm{tx})+L\\ln m</span>. Critically, no transaction appearing more than <span class="math">L\\ln m</span> timeslots after a given transaction <span class="math">\\mathrm{tx}</span> can invalidate <span class="math">\\mathrm{tx}</span>.</p>

    <p class="text-gray-300">Settlement times. In light of the discussion above, it is clear that if a transaction appeared sufficiently far in the past (in any of the blockchains), it can be classified as valid or invalid and, furthermore, this classification will be stable for the future of the protocol. We now consider, in detail, two particular scenarios of interest: slow settlement, where a transaction is placed in a single blockchain, and fast settlement, where a transaction is placed in all <span class="math">m</span> blockchains. These two results are expressed in the following two statements.</p>

    <h6 id="sec-70" class="text-base font-medium mt-4">Theorem 8 (Slow settlement).</h6>

    <p class="text-gray-300">Consider a transaction <span class="math">\\mathrm{tx}</span> appearing in one of the blockchains at height <span class="math">h=h(\\mathrm{tx})</span>. Suppose that no competing transaction has appeared in any of the other blockchains by a later time <span class="math">T&gt;h+k</span>. Then for any <span class="math">k\\geq L(\\ln 2m)</span>, the probability that <span class="math">\\mathrm{tx}</span> is either removed from the system or declared invalid (due to inclusion of a conflicting transaction with equal or larger weight) is no more than <span class="math">\\exp(-\\alpha(k-L)+m(\\beta+\\ln k))</span>.</p>

    <h6 id="sec-71" class="text-base font-medium mt-4">Theorem 9 (Fast settlement).</h6>

    <p class="text-gray-300">Consider a transaction <span class="math">\\mathrm{tx}</span> appearing at height <span class="math">h=h(\\mathrm{tx})</span> in all <span class="math">m</span> blockchains. Suppose that no competing transaction has appeared in any of the blockchains at time <span class="math">T&gt;h+k</span>, with <span class="math">k=3L/m</span> and <span class="math">m\\geq 3</span>. Then the probability that <span class="math">\\mathrm{tx}</span> is either removed from the system or declared invalid (due to inclusion of a conflicting transaction with equal or larger weight) is no more than <span class="math">2\\exp(-\\alpha L+m(\\beta+\\ln(16L\\ln m)))</span>. Note that with this value of <span class="math">k\\approx L/m</span>, the system achieves an error bound commensurate with that achieved by <span class="math">k^{\\prime}\\approx L</span> in the underlying blockchains. In particular, for this regime of <span class="math">k</span>, the system settles transactions <span class="math">\\approx m</span> times faster.</p>

    <p class="text-gray-300">In preparation for the proofs of these two statements, we establish a general lemma that bounds the probability that a transaction which does not occur in any of the <span class="math">m</span> blockchains can be inserted so as to achieve a given weight.</p>

    <h6 id="sec-72" class="text-base font-medium mt-4">Lemma 7.</h6>

    <p class="text-gray-300">Consider a system of <span class="math">m</span> chains, as above. The probability that an adversary, at time <span class="math">T</span>, can inject a transaction <span class="math">\\mathrm{tx}</span> that has not yet appeared in any of the chains so as to achieve</p>

    <p class="text-gray-300"><span class="math">\\mathrm{weight}_{L}(\\mathrm{tx})\\geq G\\cdot\\exp(-T/L)</span></p>

    <p class="text-gray-300">is no more than <span class="math">\\left(L\\ln(G-m+1)e^{\\beta}\\right)^{m}(G-m+1)^{-\\alpha L}</span>. We note also the upper bound <span class="math">\\left(L\\ln(G)e^{\\beta}\\right)^{m}(G-m)^{-\\alpha L}</span>.</p>

    <p class="text-gray-300">######</p>

    <h6 id="sec-73" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose that for some subset <span class="math">I\\subset\\{1,\\ldots,m\\}</span> and for each <span class="math">i\\in I</span> the adversary could inject the transaction into chain <span class="math">i</span> at “depth” <span class="math">d_{i}</span> (so that in blockchain <span class="math">i</span> the transaction appears in the block associated with time slot <span class="math">T-d_{i}</span>). Then the resulting weight of the transaction would be</p>

    <p class="text-gray-300"><span class="math">\\text{weight}_{L}(\\text{tx})\\leq\\sum_{i\\in I}\\exp(-(T-d_{i})/L)=\\exp(-T/L)\\sum_{i}\\exp(d_{i}/L)\\,,</span></p>

    <p class="text-gray-300">and the “gap” parameter <span class="math">G</span> associated with this particular placement satisfies</p>

    <p class="text-gray-300"><span class="math">G=W/\\exp(-T/L)\\leq\\sum_{i}\\exp(d_{i}/L)\\stackrel{{\\scriptstyle(*)}}{{\\leq}}(m-1)+\\exp\\left(\\sum_{i}d_{i}/L\\right)\\,.</span> (7)</p>

    <p class="text-gray-300">The inequality <span class="math">\\stackrel{{\\scriptstyle(*)}}{{\\leq}}</span> above follows from the fact that for any <span class="math">a_{i}\\geq 0</span>,</p>

    <p class="text-gray-300"><span class="math">\\sum_{i=1}^{\\ell}\\exp(a_{i})\\leq(\\ell-1)+\\exp\\left(\\sum a_{i}\\right)\\,.</span></p>

    <p class="text-gray-300">We conclude from (7) that</p>

    <p class="text-gray-300"><span class="math">\\sum_{i}d_{i}\\geq L\\ln(G-m+1)\\,.</span></p>

    <p class="text-gray-300">As we assume prefix violations occur in the underlying chains with independent probability, the probability that this <em>particular</em> placement can occur is no more than</p>

    <p class="text-gray-300"><span class="math">\\prod_{i\\in I}\\exp(-\\alpha d_{i}+\\beta)</span> <span class="math">\\leq\\exp\\left(m\\beta-\\alpha\\sum d_{i}\\right)</span> <span class="math">\\leq\\exp\\bigl{(}m\\beta-\\alpha L\\ln(G-m+1)\\bigr{)}=e^{m\\beta}(G-m+1)^{-\\alpha L}\\,.</span></p>

    <p class="text-gray-300">Note, additionally, that if the adversary is capable of placing a transaction at depths <span class="math">(d_{1},\\ldots,d_{m})</span>, then any tuple of depths <span class="math">(d_{1}^{\\prime},\\ldots,d_{m}^{\\prime})</span> for which <span class="math">d_{i}^{\\prime}\\leq d_{i}</span> is also available to the adversary. It follows that the probability that the adversary can achieve a placement achieving parameter <span class="math">G</span> is no more than the probability that it can achieve a placement achieving depths for which <span class="math">\\sum_{i}d_{i}</span> is exactly (the floor of) <span class="math">L\\ln(G-m+1)</span>. This is no more than</p>

    <p class="text-gray-300"><span class="math">e^{\\beta m}\\cdot[L\\ln(G-m+1)]^{m}\\cdot(G-m+1)^{-\\alpha L}\\leq e^{\\beta m}\\cdot[L\\ln(G)]^{m}\\cdot(G-m+1)^{-\\alpha L}</span></p>

    <p class="text-gray-300">as desired. ∎</p>

    <p class="text-gray-300">Having established Lemma 7 above, we are now ready to prove Theorems 8 and 9.</p>

    <h6 id="sec-74" class="text-base font-medium mt-4">Proof (of Theorem 8).</h6>

    <p class="text-gray-300">Observe that the weight of the existing transaction <span class="math">\\text{tx}</span> is <span class="math">\\text{weight}_{L}(\\text{tx})=\\exp(-(T-k)/L)</span>, so it suffices to bound the probability that an adversary can inject a new transaction with this weight. (Note that if no such transaction can be inserted, then <span class="math">\\text{tx}</span> must remain in the system.) Writing <span class="math">\\text{weight}_{L}(\\text{tx})=G\\exp(-T/L)</span>, we may apply Lemma 7 with gap <span class="math">G=\\exp(k/L)</span> to conclude that the probability that an adversary can inject a (conflicting) transaction with this weight is</p>

    <p class="text-gray-300"><span class="math">\\bigl{(}L\\ln(\\exp(k/L))e^{\\beta}\\bigr{)}^{m}(\\exp(k/L)-m+1)^{-\\alpha L}\\leq(ke^{\\beta})^{m}(\\exp(k/L)-m+1)^{-\\alpha L}\\,.</span></p>

    <p class="text-gray-300">Consider now a depth <span class="math">k\\geq L\\ln 2m</span>; then <span class="math">\\exp(k/L)-m+1\\geq(1/e)\\exp(k/L)</span> and the probability above is no more than</p>

    <p class="text-gray-300"><span class="math">(ke^{\\beta})^{m}[(1/e)\\exp(k/L)]^{-\\alpha L}=\\exp(-\\alpha(k-L)+m(\\beta+\\ln k))\\,,</span></p>

    <p class="text-gray-300">as desired. ∎</p>

    <p class="text-gray-300">Thus settlement time for the slow procedure (that is, include the transaction in a single blockchain) is linearly related with the original settlement time of the blockchain(s). Specifically, if depth <span class="math">k</span> was sufficient in the underlying blockchains to guarantee that a <span class="math">k</span>-prefix violation occurs with probability no more than <span class="math">\\epsilon</span>, then this same <span class="math">\\epsilon</span> can be achieved in the new system, under “slow” settlement, with depth <span class="math">k^{\\prime}=(1+o(1))k</span>.</p>

    <h6 id="sec-75" class="text-base font-medium mt-4">Proof (of Theorem 9).</h6>

    <p class="text-gray-300">The probability that an adversary can inject a competing transaction into more than <span class="math">m/3</span> of the blockchains in such a way that it precedes tx (and hence is dominant in these blockchains) is no more than</p>

    <p class="text-gray-300">\\[ \\begin{split}\\binom{m}{m/3}\\exp(-\\alpha k+\\beta)^{m/3}&\\leq 2^{m}\\exp(-\\alpha mk/3+m\\beta/3)\\\\ &\\leq\\exp(-\\alpha mk/3+m(\\beta+\\ln 2))\\,.\\end{split} \\] (8)</p>

    <p class="text-gray-300">We condition on the negation of this event for the remainder of the proof: We assume that at least <span class="math">(2/3)m</span> of the initial appearances of tx in the blockchains remain (and remain dominant); thus the weight of tx satisfies</p>

    <p class="text-gray-300"><span class="math">\\text{weight}_{L}(\\text{tx})\\geq(2/3)m\\exp(-(T-k)/L)\\,.</span></p>

    <p class="text-gray-300">Writing <span class="math">\\text{weight}_{L}(\\text{tx})=G\\exp(-T/L)</span> the relevant gap <span class="math">G</span> is at least <span class="math">(2/3)m\\exp(k/L)</span> and, by Lemma 7, the probability that an adversary can inject a (conflicting) transaction with this weight into some subcollection of <span class="math">m/3</span> blockchains is no more than</p>

    <p class="text-gray-300">\\[ \\begin{split}\\binom{m}{m/3}\\big{(}L\\ln(G)e^{\\beta}\\big{)}^{m/3}\\big{(}(2/3)m\\exp(k/L)-m/3\\big{)}^{-\\alpha L}\\\\ &\\leq 2^{m}\\big{(}L\\ln(m\\exp(k/L))e^{\\beta}\\big{)}^{m/3}\\big{(}(2/3)m(1+k/L)-m/3\\big{)}^{-\\alpha L}\\\\ &=2^{m}\\big{(}L\\ln(m\\exp(k/L))e^{\\beta}\\big{)}^{m/3}\\big{(}(2/3)mk/L+m/3\\big{)}^{-\\alpha L}\\,,\\end{split} \\] (9)</p>

    <p class="text-gray-300">where we use the fact that <span class="math">\\exp(x)\\geq 1+x</span> for positive <span class="math">x</span>. Selecting <span class="math">k=3L/m</span>, note that <span class="math">(2/3)mk/L+m/3\\geq 2+m/3\\geq e</span> and <span class="math">k\\leq L</span> for <span class="math">m\\geq 3</span>. In this case, the probability of (9) is no more than</p>

    <p class="text-gray-300">\\[ \\begin{split}\\big{(}2^{3}L\\ln(m\\exp(k/L))e^{\\beta}\\big{)}^{m/3}\\exp(-\\alpha L)&\\leq\\big{(}8L(\\ln(m)+1)e^{\\beta}\\big{)}^{m/3}\\exp(-\\alpha L)\\\\ &\\leq\\big{(}16L\\ln(m)e^{\\beta}\\big{)}^{m/3}\\exp(-\\alpha L)\\\\ &=\\exp(-\\alpha L+(m/3)(\\beta+\\ln(16L\\ln m)))\\,.\\end{split} \\] (10)</p>

    <p class="text-gray-300">We conclude from (8) and (10) that the probability that the transaction is invalidated is no more than</p>

    <p class="text-gray-300"><span class="math">\\exp(-\\alpha L</span> <span class="math">+(m/3)(\\beta+\\ln(16L\\ln m)))+\\exp(-\\alpha mk/3+m(\\beta+\\ln 2))</span> <span class="math">\\leq\\exp(-\\alpha L+m(\\beta+\\ln(16L\\ln m)))+\\exp(-\\alpha L+m(\\beta+\\ln 2))</span> <span class="math">\\leq 2\\exp(-\\alpha L+m(\\beta+\\ln(16L\\ln m)))\\,,</span></p>

    <p class="text-gray-300">as desired. ∎</p>

    <h2 id="sec-76" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] C. Badertscher, P. Gaži, A. Kiayias, A. Russell, and V. Zikas. Ouroboros genesis: Composable proof-of-stake blockchains with dynamic availability. Cryptology ePrint Archive, Report 2018/378, 2018. https://eprint.iacr.org/2018/378.</li>

      <li>[2] V. Bagaria, S. Kannan, D. Tse, G. C. Fanti, and P. Viswanath. Deconstructing the blockchain to approach physical limits. CoRR, abs/1810.08092, 2018.</li>

      <li>[3] L. Baird. The swirlds hashgraph consensus algorithm: Fair, fast, byzantine fault tolerance. Swirlds Tech Report SWIRLDS-TR-2016-01, 2016. https://www.swirlds.com/downloads/SWIRLDS-TR-2016-01.pdf.</li>

    </ul>

    <p class="text-gray-300">4] M. Bellare and P. Rogaway. Random oracles are practical: A paradigm for designing efficient protocols. In V. Ashby, editor, ACM CCS 93, pages 62–73. ACM Press, Nov. 1993.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[5] I. Bentov, P. Hubáček, T. Moran, and A. Nadler. Tortoise and hares consensus: the meshcash framework for incentive-compatible, scalable cryptocurrencies. Cryptology ePrint Archive, Report 2017/300, 2017. http://eprint.iacr.org/2017/300.</li>

      <li>[6] I. Bentov, R. Pass, and E. Shi. Snow white: Provably secure proofs of stake. Cryptology ePrint Archive, Report 2016/919, 2016. http://eprint.iacr.org/2016/919.</li>

      <li>[7] E. Blum, A. Kiayias, C. Moore, S. Quader, and A. Russell. Linear consistency for proof-of-stake blockchains. Cryptology ePrint Archive, Report 2017/241, 2017. https://eprint.iacr.org/2017/241.</li>

      <li>[8] X. Boyen, C. Carr, and T. Haines. Graphchain: a blockchain-free scalable decentralised ledger. In S. V. Lokam, S. Ruj, and K. Sakurai, editors, Proceedings of the 2nd ACM Workshop on Blockchains, Cryptocurrencies, and Contracts, BCC@AsiaCCS 2018, Incheon, Republic of Korea, June 4, 2018, pages 21–33. ACM, 2018.</li>

      <li>[9] R. Canetti. Universally composable security: A new paradigm for cryptographic protocols. In 42nd FOCS, pages 136–145. IEEE Computer Society Press, Oct. 2001.</li>

      <li>[10] R. Canetti. Universally composable signature, certification, and authentication. In 17th IEEE Computer Security Foundations Workshop, page 219, 2004.</li>

      <li>[11] K. Croman, C. Decker, I. Eyal, A. E. Gencer, A. Juels, A. E. Kosba, A. Miller, P. Saxena, E. Shi, E. G. Sirer, D. Song, and R. Wattenhofer. On scaling decentralized blockchains - (A position paper). In J. Clark, S. Meiklejohn, P. Y. A. Ryan, D. S. Wallach, M. Brenner, and K. Rohloff, editors, Financial Cryptography and Data Security - FC 2016 International Workshops, BITCOIN, VOTING, and WAHC, Christ Church, Barbados, February 26, 2016, Revised Selected Papers, volume 9604 of Lecture Notes in Computer Science, pages 106–125. Springer, 2016.</li>

      <li>[12] G. Danezis and S. Meiklejohn. Centrally banked cryptocurrencies. In NDSS 2016. The Internet Society, Feb. 2016.</li>

      <li>[13] B. David, P. Gazi, A. Kiayias, and A. Russell. Ouroboros praos: An adaptively-secure, semi-synchronous proof-of-stake blockchain. In J. B. Nielsen and V. Rijmen, editors, EUROCRYPT 2018, Part II, volume 10821 of LNCS, pages 66–98. Springer, Heidelberg, Apr. / May 2018.</li>

      <li>[14] C. Decker, J. Seidel, and R. Wattenhofer. Bitcoin meets strong consistency. In Proceedings of the 17th International Conference on Distributed Computing and Networking, Singapore, January 4-7, 2016, pages 13:1–13:10. ACM, 2016.</li>

      <li>[15] Y. Dodis and A. Yampolskiy. A verifiable random function with short proofs and keys. In S. Vaudenay, editor, PKC 2005, volume 3386 of LNCS, pages 416–431. Springer, Heidelberg, Jan. 2005.</li>

      <li>[16] I. Eyal, A. E. Gencer, E. G. Sirer, and R. Renesse. Bitcoin-ng: A scalable blockchain protocol. In 13th USENIX Symposium on Networked Systems Design and Implementation (NSDI 16), pages 45–59, Santa Clara, CA, 2016. USENIX Association.</li>

      <li>[17] S. Forestier and D. Vodenicarevic. Blockclique: scaling blockchains through transaction sharding in a multi-threaded block graph. CoRR, abs/1803.09029v4, 2018.</li>

      <li>[18] J. A. Garay, A. Kiayias, and N. Leonardos. The bitcoin backbone protocol: Analysis and applications. In E. Oswald and M. Fischlin, editors, EUROCRYPT 2015, Part II, volume 9057 of LNCS, pages 281–310. Springer, Heidelberg, Apr. 2015.</li>

      <li>[19] J. A. Garay, A. Kiayias, and N. Leonardos. The bitcoin backbone protocol with chains of variable difficulty. Cryptology ePrint Archive, Report 2016/1048, 2016. http://eprint.iacr.org/2016/1048.</li>

      <li>[20] A. E. Gencer, R. Renesse, and E. Sirer. Service-oriented sharding with aspen. CoRR, abs/1611.06816, 2016.</li>

      <li>[21] A. Kiayias, A. Russell, B. David, and R. Oliynykov. Ouroboros: A provably secure proof-of-stake blockchain protocol. In J. Katz and H. Shacham, editors, CRYPTO 2017, Part I, volume 10401 of LNCS, pages 357–388. Springer, Heidelberg, Aug. 2017.</li>

      <li>[22] L. Kiffer, R. Rajaraman, and A. Shelat. A better method to analyze blockchain consistency. In D. Lie, M. Mannan, M. Backes, and X. Wang, editors, Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security, CCS 2018, Toronto, ON, Canada, October 15-19, 2018, pages 729–744. ACM, 2018.</li>

      <li>[23] E. Kokoris-Kogias, P. Jovanovic, N. Gailly, I. Khoffi, L. Gasser, and B. Ford. Enhancing bitcoin security and performance with strong consistency via collective signing. In T. Holz and S. Savage, editors, 25th USENIX Security Symposium, USENIX Security 16, Austin, TX, USA, August 10-12, 2016., pages 279–296. USENIX Association, 2016.</li>

      <li>[24] E. Kokoris-Kogias, P. Jovanovic, L. Gasser, N. Gailly, E. Syta, and B. Ford. Omniledger: A secure, scale-out, decentralized ledger via sharding. In 2018 IEEE Symposium on Security and Privacy, SP 2018, Proceedings, 21-23 May 2018, San Francisco, California, USA, pages 583–598. IEEE, 2018.</li>

    </ul>

    <p class="text-gray-300">25] S. Lerner. Dagcoin draft. Manuscript, 2015. https://bitslog.files.wordpress.com/2015/09/dagcoin-v41.pdf.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[26] Y. Lewenberg, Y. Sompolinsky, and A. Zohar. Inclusive block chain protocols. In R. Böhme and T. Okamoto, editors, FC 2015, volume 8975 of LNCS, pages 528–547. Springer, Heidelberg, Jan. 2015.</li>

      <li>[27] C. Li, P. Li, W. Xu, F. Long, and A. C. Yao. Scaling nakamoto consensus to thousands of transactions per second. CoRR, abs/1805.03870, 2018.</li>

      <li>[28] L. Luu, V. Narayanan, C. Zheng, K. Baweja, S. Gilbert, and P. Saxena. A secure sharding protocol for open blockchains. In E. R. Weippl, S. Katzenbeisser, C. Kruegel, A. C. Myers, and S. Halevi, editors, Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security, Vienna, Austria, October 24-28, 2016, pages 17–30. ACM, 2016.</li>

      <li>[29] W. Martino, M. Quaintance, and S. Popejoy. Chainweb: A proof-of-work parallel-chain architecture for massive throughput. Manuscript, 2018. http://kadena.io/docs/chainweb-v15.pdf.</li>

      <li>[30] S. Micali. ALGORAND: the efficient and democratic ledger. CoRR, abs/1607.01341, 2016.</li>

      <li>[31] R. Motwani and P. Raghavan. Randomized Algorithms. Cambridge University Press, New York, NY, USA, 1995.</li>

      <li>[32] S. Nakamoto. Bitcoin: A peer-to-peer electronic cash system,” http://bitcoin.org/bitcoin.pdf, 2008.</li>

      <li>[33] R. Pass, L. Seeman, and A. Shelat. Analysis of the blockchain protocol in asynchronous networks. In J. Coron and J. B. Nielsen, editors, EUROCRYPT 2017, Part II, volume 10211 of LNCS, pages 643–673. Springer, Heidelberg, Apr. / May 2017.</li>

      <li>[34] R. Pass and E. Shi. Hybrid consensus: Efficient consensus in the permissionless model. Cryptology ePrint Archive, Report 2016/917, 2016. http://eprint.iacr.org/2016/917.</li>

      <li>[35] R. Pass and E. Shi. FruitChains: A fair blockchain. In E. M. Schiller and A. A. Schwarzmann, editors, 36th ACM PODC, pages 315–324. ACM, July 2017.</li>

      <li>[36] R. Pass and E. Shi. Thunderella: Blockchains with optimistic instant confirmation. In J. B. Nielsen and V. Rijmen, editors, EUROCRYPT 2018, Part II, volume 10821 of LNCS, pages 3–33. Springer, Heidelberg, Apr. / May 2018.</li>

      <li>[37] S. Popov. The tangle. Manuscript, 2017. https://iotatoken.com/IOTA_Whitepaper.pdf.</li>

      <li>[38] Y. Sompolinsky, Y. Lewenberg, and A. Zohar. SPECTRE: A fast and scalable cryptocurrency protocol. Cryptology ePrint Archive, Report 2016/1159, 2016. http://eprint.iacr.org/2016/1159.</li>

      <li>[39] Y. Sompolinsky and A. Zohar. Accelerating Bitcoin’s transaction processing. Fast money grows on trees, not chains. Cryptology ePrint Archive, Report 2013/881, 2013. http://eprint.iacr.org/2013/881.</li>

      <li>[40] Y. Sompolinsky and A. Zohar. Secure high-rate transaction processing in bitcoin. In R. Böhme and T. Okamoto, editors, FC 2015, volume 8975 of LNCS, pages 507–527. Springer, Heidelberg, Jan. 2015.</li>

      <li>[41] Y. Sompolinsky and A. Zohar. Phantom: A scalable blockdag protocol. Cryptology ePrint Archive, Report 2018/104, 2018. https://eprint.iacr.org/2018/104.</li>

      <li>[42] M. Zamani, M. Movahedi, and M. Raykova. Rapidchain: A fast blockchain protocol via full sharding. IACR Cryptology ePrint Archive, 2018:460, 2018.</li>

    </ul>

    <h2 id="sec-77" class="text-2xl font-bold">Appendix A Concentration Bounds</h2>

    <p class="text-gray-300">We record here a form of concentration bounds that we use in our arguments. See, e.g., <em>[31]</em> for proofs and further discussion.</p>

    <h6 id="sec-78" class="text-base font-medium mt-4">Theorem 10 (Chernoff bound).</h6>

    <p class="text-gray-300">Let <span class="math">X_{1},\\ldots,X_{T}</span> be independent random variables with <span class="math">\\mathsf{E}\\left[X_{i}\\right]=p_{i}</span> and <span class="math">X_{i}\\in[0,1]</span>. Let <span class="math">X=\\sum_{i=1}^{T}X_{i}</span> and <span class="math">\\mu=\\sum_{i=1}^{T}p_{i}=\\mathsf{E}\\left[X\\right]</span>. Then for all <span class="math">\\delta\\geq 0</span> we have</p>

    <p class="text-gray-300"><span class="math">\\Pr[X\\geq(1+\\delta)\\mu]\\leq e^{-\\frac{\\delta^{2}}{2+\\delta}\\mu}\\;,</span></p>

    <p class="text-gray-300">and for all <span class="math">0\\leq\\delta\\leq 1</span> we have</p>

    <p class="text-gray-300"><span class="math">\\Pr[X\\leq(1-\\delta)\\mu]\\leq e^{-\\frac{\\delta^{2}}{2}\\mu}\\;.</span></p>

    <h6 id="sec-79" class="text-base font-medium mt-4">Theorem 11 (Azuma’s inequality (Azuma; Hoeffding)).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">X_{0},\\ldots,X_{n}</span> be a sequence of real-valued random variables so that, for all <span class="math">t</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X_{t+1}-X_{t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq c<span class="math"> for some constant </span>c<span class="math">. If </span>\\mathsf{E}\\left[X_{t+1}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,X_{0},\\ldots,X_{t}\\right]\\leq X_{t}<span class="math"> for all </span>t<span class="math"> then for every </span>\\Lambda\\geq 0$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\Pr[X_{n}-X_{0}\\geq\\Lambda]\\leq\\exp\\left(-\\frac{\\Lambda^{2}}{2nc^{2}}\\right)\\,.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Alternatively, if $\\mathsf{E}\\left[X_{t+1}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,X_{0},\\ldots,X_{t}\\right]\\geq X_{t}<span class="math"> for all </span>t<span class="math"> then for every </span>\\Lambda\\geq 0$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\Pr[X_{n}-X_{0}\\leq-\\Lambda]\\leq\\exp\\left(-\\frac{\\Lambda^{2}}{2nc^{2}}\\right)\\,.</span></p>

    <p class="text-gray-300">Fig. 10. Functionality  <span class="math">\\mathcal{F}_{\\mathrm{sig}}</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{F}_{\\mathrm{sig}}</span>  interacts with a signer  <span class="math">\\mathsf{P}_S</span>  and stakeholders  <span class="math">\\mathsf{P}_1,\\ldots ,\\mathsf{P}_n</span>  as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Key Generation. Upon receiving a message (KeyGen,  <span class="math">sid, \\mathsf{P}_S</span> ) from a stakeholder  <span class="math">\\mathsf{P}_S</span> , hand (KeyGen,  <span class="math">sid, \\mathsf{P}_S</span> ) to the adversary. Upon receiving (VerificationKey,  <span class="math">sid, \\mathsf{P}_S, v</span> ) from the adversary, output (VerificationKey,  <span class="math">sid, v</span> ) to  <span class="math">\\mathsf{P}_i</span> , and record the triple  <span class="math">(sid, \\mathsf{P}_S, v)</span> .</li>

      <li>Signature Generation. Upon receiving a message (Sign,  <span class="math">sid, \\mathsf{P}_S, m</span> ) from  <span class="math">\\mathsf{P}_S</span> , verify that  <span class="math">(sid, \\mathsf{P}_S, v)</span>  is recorded for some  <span class="math">sid</span> . If not, then ignore the request. Else, send (Sign,  <span class="math">sid, \\mathsf{P}_S, m</span> ) to the adversary. Upon receiving (Signature,  <span class="math">sid, \\mathsf{P}_S, m, \\sigma</span> ) from the adversary, verify that no entry  <span class="math">(m, \\sigma, v, 0)</span>  is recorded. If it is, then output an error message to  <span class="math">\\mathsf{P}_S</span>  and halt. Else, output (Signature,  <span class="math">sid, m, \\sigma</span> ) to  <span class="math">\\mathsf{P}_S</span> , and record the entry  <span class="math">(m, \\sigma, v, 0)</span> .</li>

      <li>Signature Verification. Upon receiving a message (Verify,  <span class="math">sid, m, \\sigma, v&#x27;</span> ) from some stakeholder  <span class="math">\\mathsf{P}_i</span> , hand (Verify,  <span class="math">sid, m, \\sigma, v&#x27;</span> ) to the adversary. Upon receiving (Verified,  <span class="math">sid, m, \\phi</span> ) from the adversary do:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If  <span class="math">v&#x27; = v</span>  and the entry  <span class="math">(m, \\sigma, v, 1)</span>  is recorded, then set  <span class="math">f = 1</span> . (This condition guarantees completeness: If the verification key  <span class="math">v&#x27;</span>  is the registered one and  <span class="math">\\sigma</span>  is a legitimately generated signature for  <span class="math">m</span> , then the verification succeeds.)</li>

      <li>Else, if  <span class="math">v&#x27; = v</span> , the signer is not corrupted, and no entry  <span class="math">(m, \\sigma&#x27;, v, 1)</span>  for any  <span class="math">\\sigma&#x27;</span>  is recorded, then set  <span class="math">f = 0</span>  and record the entry  <span class="math">(m, \\sigma, v, 0)</span> . (This condition guarantees unforgeability: If  <span class="math">v&#x27;</span>  is the registered one, the signer is not corrupted, and never signed  <span class="math">m</span> , then the verification fails.)</li>

      <li>Else, if there is an entry  <span class="math">(m,\\sigma ,v^{\\prime},f^{\\prime})</span>  recorded, then let  <span class="math">f = f^{\\prime}</span>  . (This condition guarantees consistency: All verification requests with identical parameters will result in the same answer.)</li>

      <li>Else, let  <span class="math">f = \\phi</span>  and record the entry  <span class="math">(m, \\sigma, v&#x27;, \\phi)</span> .</li>

    </ol>

    <p class="text-gray-300">Output (Verified,  <span class="math">sid, m, f</span> ) to  <span class="math">\\mathsf{P}_i</span> .</p>

    <p class="text-gray-300">Fig. 11. Functionality  <span class="math">\\mathcal{F}_{\\mathrm{init}}</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{F}_{\\mathrm{init}}</span>  is parameterized by the number of initial stakeholders  <span class="math">n</span>  and their respective stakes  <span class="math">s_1, \\ldots, s_n</span> .  <span class="math">\\mathcal{F}_{\\mathrm{init}}</span>  interacts with stakeholders  <span class="math">\\mathsf{P}_1, \\ldots, \\mathsf{P}_n</span>  as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In the first round, upon a request from some stakeholder  <span class="math">\\mathsf{P}_i</span>  of the form (ver_keys,  <span class="math">sid, \\mathsf{P}_i, v_i^{\\mathrm{vrf}}, v_i^{\\mathrm{kes}}, v_i^{\\mathrm{sig}}</span> ), it stores the verification keys tuple  <span class="math">(\\mathsf{P}_i, v_i^{\\mathrm{vrf}}, v_i^{\\mathrm{kes}}, v_i^{\\mathrm{sig}})</span>  and acknowledges its receipt. If any of the  <span class="math">n</span>  stakeholders does not send a request of this form to  <span class="math">\\mathcal{F}_{\\mathrm{init}}</span> , or if two different stakeholders provide two identical keys, it halts. Otherwise, it samples and stores a random value  <span class="math">\\eta \\stackrel{\\lambda}{\\leftarrow} \\{0,1\\}^{\\lambda}</span>  and constructs a genesis block  <span class="math">(\\mathbb{S}_0, \\eta)</span> , where  <span class="math">\\mathbb{S}_0 = \\left((\\mathsf{P}_1, v_1^{\\mathrm{vrf}}, v_1^{\\mathrm{kes}}, v_1^{\\mathrm{sig}}, s_1), \\ldots, (\\mathsf{P}_n, v_n^{\\mathrm{vrf}}, v_n^{\\mathrm{kes}}, v_n^{\\mathrm{sig}}, s_n)\\right)</span> .</li>

      <li>In later rounds, upon a request of the form (genblock_req,  <span class="math">sid, \\mathsf{P}_i</span> ) from some stakeholder  <span class="math">\\mathsf{P}_i</span> ,  <span class="math">\\mathcal{F}_{\\mathrm{init}}</span>  sends (genblock,  <span class="math">sid, \\mathbb{S}_0, \\eta</span> ) to  <span class="math">\\mathsf{P}_i</span> .</li>

    </ul>

    <p class="text-gray-300">In Figure 10 we present the functionality  <span class="math">\\mathcal{F}_{\\mathrm{sig}}</span>  as defined in [10], where it is also shown that EUF-CMA signature schemes realize  <span class="math">\\mathcal{F}_{\\mathrm{sig}}</span> . This functionality is used in [13] to model signatures on transactions.</p>

    <p class="text-gray-300">Figure 11 contains the functionality  <span class="math">\\mathcal{F}_{\\mathrm{init}}</span>  that determines the genesis stake distribution  <span class="math">\\mathbb{S}_0</span>  and the nonce  <span class="math">\\eta</span>  (to be written in the genesis block).  <span class="math">\\mathcal{F}_{\\mathrm{init}}</span>  also takes stakeholders' public keys from them and packages them into the genesis block at the outset of the protocol. Note that  <span class="math">\\mathcal{F}_{\\mathrm{init}}</span>  halts if it is not possible to create a genesis block; all security guarantees we provide later in the paper are conditioned on a successful creation of the genesis block.</p>

    <p class="text-gray-300">In Figures 12-13 we give a description of the hybrid functionalities  <span class="math">\\mathcal{F}_{\\mathrm{vrf}}</span> ,  <span class="math">\\mathcal{F}_{\\mathrm{kes}}</span> , used by  <span class="math">\\Pi_{\\mathrm{pc - pos}}</span> , these are taken from [13]. Finally, the functionality  <span class="math">\\mathcal{F}_{\\mathrm{ro}}</span>  represents a random oracle an its description is omitted.</p>

    <p class="text-gray-300">Here we present a technical result from [1] (Lemma 8 below) that will be useful for the throughput analysis of our PoS-based construction in Section 5. First, we need to introduce some notation and terminology. We keep the definitions below in their full generality as presented in [1,13], even though, looking ahead, we will only use them in a setting where the random variables  <span class="math">W_{i}</span>  contain no 1-symbols (i.e.,  <span class="math">\\gamma = 1</span> ).</p>

    <p class="text-gray-300">Fig. 12. Functionality  <span class="math">\\mathcal{F}_{\\mathrm{vrf}}</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{F}_{\\mathrm{vrf}}</span>  interacts with stakeholders  <span class="math">\\mathsf{P}_1,\\ldots ,\\mathsf{P}_n</span>  as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Key Generation. Upon receiving a message (KeyGen, sid) from a stakeholder  <span class="math">\\mathsf{P}_i</span> , hand (KeyGen, sid,  <span class="math">\\mathsf{P}_i</span> ) to the adversary. Upon receiving (VerificationKey, sid,  <span class="math">\\mathsf{P}_i, v</span> ) from the adversary, if  <span class="math">\\mathsf{P}_i</span>  is honest, verify that  <span class="math">v</span>  is unique, record the pair  <span class="math">(\\mathsf{P}_i, v)</span>  and return (VerificationKey, sid,  <span class="math">v</span> ) to  <span class="math">\\mathsf{P}_i</span> . Initialize the table  <span class="math">T(v, \\cdot)</span>  to empty.</li>

      <li>Malicious Key Generation. Upon receiving a message (KeyGen, sid, v) from  <span class="math">S</span> , verify that  <span class="math">v</span>  has not been recorded before; in this case initialize table  <span class="math">T(v, \\cdot)</span>  to empty and record the pair  <span class="math">(S, v)</span> .</li>

      <li>VRF Evaluation. Upon receiving a message (Eval, sid, m) from  <span class="math">\\mathsf{P}_i</span> , verify that some pair  <span class="math">(\\mathsf{P}_i, v)</span>  is recorded. If not, then ignore the request. Then, if the value  <span class="math">T(v, m)</span>  is undefined, pick a random value  <span class="math">y</span>  from  <span class="math">\\{0, 1\\}^{\\ell_{\\mathrm{VRF}}}</span>  and set  <span class="math">T(v, m) = (y, \\emptyset)</span> . Then output (Evaluated, sid, y) to  <span class="math">\\mathsf{P}_i</span> , where  <span class="math">y</span>  is such that  <span class="math">T(v, m) = (y, S)</span>  for some  <span class="math">S</span> .</li>

      <li>VRF Evaluation and Proof. Upon receiving a message (EvalProve, sid, m) from  <span class="math">\\mathsf{P}_i</span> , verify that some pair  <span class="math">(\\mathsf{P}_i, v)</span>  is recorded. If not, then ignore the request. Else, send (EvalProve, sid,  <span class="math">\\mathsf{P}_i, m</span> ) to the adversary. Upon receiving (EvalProve, sid, m,  <span class="math">\\pi</span> ) from the adversary, if value  <span class="math">T(v, m)</span>  is undefined, verify that  <span class="math">\\pi</span>  is unique, pick a random value  <span class="math">y</span>  from  <span class="math">\\{0, 1\\}^{\\ell_{\\mathrm{VRF}}}</span>  and set  <span class="math">T(v, m) = (y, \\{\\pi\\})</span> . Else, if  <span class="math">T(v, m) = (y, S)</span> , set  <span class="math">T(v, m) = (y, S \\cup \\{\\pi\\})</span> . In any case, output (Evaluated, sid,  <span class="math">y, \\pi</span> ) to  <span class="math">\\mathsf{P}_i</span> .</li>

      <li>Malicious VRF Evaluation. Upon receiving a message (Eval, sid, v, m) from  <span class="math">S</span>  for some  <span class="math">v</span> , do the following. First, if  <span class="math">(S, v)</span>  is recorded and  <span class="math">T(v, m)</span>  is undefined, then choose a random value  <span class="math">y</span>  from  <span class="math">\\{0, 1\\}^{\\ell_{\\mathrm{VRF}}}</span>  and set  <span class="math">T(v, m) = (y, \\emptyset)</span> . Then, if  <span class="math">T(v, m) = (y, S)</span>  for some  <span class="math">S \\neq \\emptyset</span> , output (Evaluated, sid, y) to  <span class="math">S</span> , else ignore the request.</li>

      <li>Verification. Upon receiving a message (Verify, sid, m, y, π, v') from some party  <span class="math">P</span> , send (Verify, sid, m, y, π, v') to the adversary. Upon receiving (Verified, sid, m, y, π, v') from the adversary do:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If  <span class="math">v&#x27; = v</span>  for some  <span class="math">(\\mathsf{P}_i, v)</span>  and the entry  <span class="math">T(v, m)</span>  equals  <span class="math">(y, S)</span>  with  <span class="math">\\pi \\in S</span> , then set  <span class="math">f = 1</span> .</li>

      <li>Else, if  <span class="math">v&#x27; = v</span>  for some  <span class="math">(\\mathsf{P}_i, v)</span> , but no entry  <span class="math">T(v, m)</span>  of the form  <span class="math">(y, \\{\\ldots, \\pi, \\ldots\\})</span>  is recorded, then set  <span class="math">f = 0</span> .</li>

      <li>Else, initialize the table  <span class="math">T(v&#x27;, \\cdot)</span>  to empty, and set  <span class="math">f = 0</span> .</li>

    </ol>

    <p class="text-gray-300">Output (Verified, sid, m, y, π, f) to  <span class="math">P</span> .</p>

    <p class="text-gray-300">Definition 7 (The characteristic conditions [1]). Consider a family of random variables  <span class="math">W_{1}, \\ldots, W_{n}</span>  taking values in  <span class="math">\\{0,1,\\bot\\}</span> . We say that they satisfy the  <span class="math">(f; \\gamma)</span> -characteristic conditions if, for each  <span class="math">k \\geq 1</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ W _ {k} = \\bot \\mid W _ {1}, \\dots , W _ {k - 1} \\right] \\geq (1 - f),</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ W _ {k} = 0 \\mid W _ {1}, \\dots , W _ {k - 1}, W _ {k} \\neq \\bot \\right] \\geq \\gamma , a n d h e n c e</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ W _ {k} = 1 \\mid W _ {1}, \\dots , W _ {k - 1}, W _ {k} \\neq \\bot \\right] \\leq 1 - \\gamma .</span></div>

    <p class="text-gray-300">In the expressions above, conditioning on a collection of random variables indicates that the statement is true for any conditioning on the values taken by variables.</p>

    <p class="text-gray-300">Definition 8 (Reduction mapping [13]). For  <span class="math">\\Delta \\in \\mathbb{N}</span> , we define the function  <span class="math">\\rho_{\\Delta} \\colon \\{0,1,\\bot\\}^<em> \\to \\{0,1\\}^</em></span>  inductively as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\rho_ {\\Delta} (\\epsilon) = \\epsilon ,</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho_ {\\Delta} (\\bot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w ^ {\\prime}) = \\rho_ {\\Delta} (w ^ {\\prime}),</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">\\rho_ {\\Delta} (1 \\parallel w ^ {\\prime}) = 1 \\parallel \\rho_ {\\Delta} (w ^ {\\prime}),</span></div>

    <div class="my-4 text-center"><span class="math-block">\\rho_ {\\Delta} (0 \\parallel w ^ {\\prime}) = \\left\\{ \\begin{array}{l l} 0 \\parallel \\rho_ {\\Delta} (w ^ {\\prime}) &amp;amp; \\text {i f} w ^ {\\prime} \\in \\bot^ {\\Delta} \\parallel \\{0, 1, \\bot \\} ^ {*}, \\\\ 1 \\parallel \\rho_ {\\Delta} (w ^ {\\prime}) &amp;amp; \\text {o t h e r w i s e}. \\end{array} \\right.</span></div>

    <p class="text-gray-300">We call  <span class="math">\\rho_{\\Delta}</span>  the reduction mapping for delay  <span class="math">\\Delta</span></p>

    <p class="text-gray-300">For our purposes, it is important that when the reduction mapping of Definition 8 is applied to a sequence  <span class="math">W</span>  of symbols 0 and  <span class="math">\\bot</span>  representing slots with and without an uncorrupted leader respectively, then every</p>

    <p class="text-gray-300">Fig. 13. Functionality <span class="math">\\mathcal{F}_{\\mathrm{kes}}</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{F}_{\\mathrm{kes}}</span> is parameterized by the total number of signature updates <span class="math">T</span>, interacting with a signer <span class="math">\\mathsf{P}_S</span> and stakeholders <span class="math">\\mathsf{P}_i</span> as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Key Generation. Upon receiving a message <span class="math">(\\mathsf{KeyGen}, sid, \\mathsf{P}_S)</span> from a stakeholder <span class="math">\\mathsf{P}_S</span>, send <span class="math">(\\mathsf{KeyGen}, sid, \\mathsf{P}_S)</span> to the adversary. Upon receiving <span class="math">(\\mathsf{VerificationKey}, sid, \\mathsf{P}_S, v)</span> from the adversary, send <span class="math">(\\mathsf{VerificationKey}, sid, v)</span> to <span class="math">\\mathsf{P}_S</span>, record the triple <span class="math">(sid, \\mathsf{P}_S, v)</span> and set counter <span class="math">\\mathsf{k}_{\\mathrm{ctr}} = 1</span>.</li>

      <li>Sign and Update. Upon receiving a message <span class="math">(\\mathsf{USign}, sid, \\mathsf{P}_S, m, j)</span> from <span class="math">\\mathsf{P}_S</span>, verify that <span class="math">(sid, \\mathsf{P}_S, v)</span> is recorded for some <span class="math">sid</span> and that <span class="math">\\mathsf{k}_{\\mathrm{ctr}} \\leq j \\leq T</span>. If not, then ignore the request. Else, set <span class="math">\\mathsf{k}_{\\mathrm{ctr}} = j + 1</span> and send <span class="math">(\\mathsf{Sign}, sid, \\mathsf{P}_S, m, j)</span> to the adversary. Upon receiving <span class="math">(\\mathsf{Signature}, sid, \\mathsf{P}_S, m, j, \\sigma)</span> from the adversary, verify that no entry <span class="math">(m, j, \\sigma, v, 0)</span> is recorded. If it is, then output an error message to <span class="math">\\mathsf{P}_S</span> and halt. Else, send <span class="math">(\\mathsf{Signature}, sid, m, j, \\sigma)</span> to <span class="math">\\mathsf{P}_S</span>, and record the entry <span class="math">(m, j, \\sigma, v, 1)</span>.</li>

      <li>Signature Verification. Upon receiving a message (Verify, sid, m, j, <span class="math">\\sigma</span>, <span class="math">v&#x27;</span> ) from some stakeholder <span class="math">\\mathsf{P}_i</span> do:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">v&#x27; = v</span> and the entry <span class="math">(m, j, \\sigma, v, 1)</span> is recorded, then set <span class="math">f = 1</span>. (This condition guarantees completeness: If the verification key <span class="math">v&#x27;</span> is the registered one and <span class="math">\\sigma</span> is a legitimately generated signature for <span class="math">m</span>, then the verification succeeds.)</li>

      <li>Else, if <span class="math">v&#x27; = v</span>, the signer is not corrupted, and no entry <span class="math">(m, j, \\sigma&#x27;, v, 1)</span> for any <span class="math">\\sigma&#x27;</span> is recorded, then set <span class="math">f = 0</span> and record the entry <span class="math">(m, j, \\sigma, v, 0)</span>. (This condition guarantees unforgeability: If <span class="math">v&#x27;</span> is the registered one, the signer is not corrupted, and never signed <span class="math">m</span>, then the verification fails.)</li>

      <li>Else, if there is an entry <span class="math">(m, j, \\sigma, v&#x27;, f&#x27;)</span> recorded, then let <span class="math">f = f&#x27;</span>. (This condition guarantees consistency: All verification requests with identical parameters will result in the same answer.)</li>

      <li>Else, if <span class="math">j &amp;lt; \\mathsf{k}_{\\mathrm{ctr}}</span>, let <span class="math">f = 0</span> and record the entry <span class="math">(m, j, \\sigma, v, 0)</span>. Otherwise, if <span class="math">j = \\mathsf{k}_{\\mathrm{ctr}}</span>, hand (Verify, sid, m, j, <span class="math">\\sigma</span>, <span class="math">v&#x27;</span> ) to the adversary. Upon receiving (Verified, sid, m, j, <span class="math">\\phi</span>) from the adversary let <span class="math">f = \\phi</span> and record the entry <span class="math">(m, j, \\sigma, v&#x27;, \\phi)</span>. (This condition guarantees that the adversary is only able to forge signatures under keys belonging to corrupted parties for time periods corresponding to the current or future slots.)</li>

    </ol>

    <p class="text-gray-300">Output (Verified, sid, m, j, f) to <span class="math">\\mathsf{P}_i</span>.</p>

    <p class="text-gray-300">good slot results in a 0-symbol in <span class="math">\\rho(W)</span>. Note that the definition from [13] was slightly adjusted to have this property in our context where we need to isolate good slots by at least <span class="math">\\Delta</span> empty slots, the statement below was adjusted accordingly.</p>

    <p class="text-gray-300">Let <span class="math">\\#_s(X)</span> denote the number of occurrences of the symbol <span class="math">s</span> in the string <span class="math">X</span>. The following lemma is a minor technical adaptation of Lemma 8(iv) from [1], where a constant <span class="math">1/4</span> is replaced by <span class="math">1 - \\xi_3</span> in the application of concentration bounds and <span class="math">\\varepsilon</span> is set to 0.</p>

    <p class="text-gray-300"><strong>Lemma 8 ([1], Lemma 8(iv)).</strong> Let <span class="math">W = W_{1} \\cdots W_{n}</span> be a sequence of random variables, each taking values in <span class="math">\\{\\bot, 0, 1\\}</span>, which satisfy the <span class="math">(f; \\gamma)</span>-characteristic conditions and let</p>

    <div class="my-4 text-center"><span class="math-block">X = X _ {1} \\cdots X _ {\\ell} = \\rho_ {\\Delta} (W _ {1} \\cdots W _ {n})</span></div>

    <p class="text-gray-300">be the random variables obtained by applying the reduction mapping (for delay <span class="math">\\Delta</span>) to <span class="math">W</span>. If</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ W _ {i} = \\bot \\mid W _ {1}, \\dots , W _ {i - 1} \\right] \\leq (1 - a) \\quad \\text{and} \\quad \\gamma (1 - f) ^ {\\Delta} \\geq 1 / 2</span></div>

    <p class="text-gray-300">then for any <span class="math">\\xi_3 \\leq 1/2</span> we have</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\# _ {0} (X) &amp;lt;   (1 - \\xi_ {3}) ^ {2} \\gamma (1 - f) ^ {\\Delta} a n - \\Delta \\right] \\leq 2 \\exp \\left(- \\frac {\\xi_ {3} ^ {2} a ^ {2} n}{4}\\right).</span></div>`;
---

<BaseLayout title="Parallel Chains: Improving Throughput and Latency of Blockch... (2018/1119)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2018 &middot; eprint 2018/1119
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
