---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2021/694';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'On Interactive Oracle Proofs for Boolean R1CS Statements';
const AUTHORS_HTML = 'Ignacio Cascudo, Emanuele Giunta';

const CONTENT = `    <p class="text-gray-300">On Interactive Oracle Proofs for Boolean R1CS Statements</p>

    <p class="text-gray-300">Ignacio Cascudo¹* and Emanuele Giunta¹,²</p>

    <p class="text-gray-300">¹ IMDEA Software Institute, Madrid, Spain. {ignacio.cascudo, emanuele.giunta}@imdea.org ² Scuola Superiore di Catania, Italy.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Abstract. The framework of interactive oracle proofs (IOP) has been used with great success to construct a number of efficient transparent zk-SNARKs in recent years. However, these constructions are based on Reed-Solomon codes and can only be applied directly to statements given in the form of arithmetic circuits or R1CS over large fields <span class="math">\\mathbb{F}</span> since their soundness error is at least $1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This motivates the question of what is the best way to apply these IOPs to statements that are naturally written as R1CS over small fields, and more concretely, the binary field <span class="math">\\mathbb{F}_2</span>. While one can just see the system as one over an extension field <span class="math">\\mathbb{F}_{2^e}</span> containing <span class="math">\\mathbb{F}_2</span>, this seems wasteful, as it uses <span class="math">e</span> bits to encode just one "information" bit. In fact, the recent BooLigero has devised a way to apply the well-known Ligero while being able to encode <span class="math">\\sqrt{e}</span> bits into one element of <span class="math">\\mathbb{F}_{2^e}</span>.</p>

    <p class="text-gray-300">In this paper, we introduce a new protocol for <span class="math">\\mathbb{F}_2</span>-R1CS which among other things relies on a more efficient embedding which (for practical parameters) allows to encode <span class="math">\\geq e/4</span> bits into an element of <span class="math">\\mathbb{F}_{2^e}</span>. Our protocol makes then black box use of lincheck and rowcheck protocols for the larger field. Using the lincheck and rowcheck introduced in Aurora and Ligero respectively we obtain <span class="math">1.31 - 1.65 \\times</span> smaller proofs for Aurora and <span class="math">3.71 \\times</span> for Ligero. We also estimate the reduction of prover time by a factor of <span class="math">24.7 \\times</span> for Aurora and between <span class="math">6.9 - 32.5 \\times</span> for Ligero without interactive repetitions.</p>

    <p class="text-gray-300">Our methodology uses the notion of reverse multiplication friendly embeddings introduced in the area of secure multiparty computation, combined with a new IOPP to test linear statements modulo a subspace <span class="math">V \\leq \\mathbb{F}_{2^e}</span> which may be of independent interest.</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">A zero-knowledge proof is a protocol in which a prover convinces a verifier that a statement is true, while conveying no other information apart from its truth. Zero-knowledge proofs have been among the most useful and studied primitives</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Research partially funded by the Spanish Government under the project SecuRing (ref. PID2019-110873RJ-I00) and by a research grant from Nomadic Labs and the Tezos Foundation.</li>

    </ul>

    <p class="text-gray-300">in cryptography since their advent in the 80s. Their popularity has increased even more in recent times, propelled by new applications motivated by blockchain technologies. This context has highlighted the relevance of a particular flavour of zero-knowledge proof, known as zero-knowledge succinct non-interactive argument of knowledge, or zk-SNARK.</p>

    <p class="text-gray-300">Here succinct means that communication complexity is sublinear with respect to the witness length. Non-interactiveness means that the proof consists of one message from prover to verifier, while being an argument of knowledge stands for the fact that in order for the prover to reliably convince the verifier, she has to know a witness for the statement. Because of succinctness, soundness necessarily relies on computational assumptions <em>[x10]</em> thus the proof is called <em>argument</em>.</p>

    <p class="text-gray-300">The flexibility and efficiency of zk-SNARKs allow to provide practical arguments of knowledge for relations that lack any kind of algebraic structure, for instance the preimage relation for a one-way function. However, it is well known <em>[x24]</em> that under standard complexity assumptions, succinct non-interactive arguments do not exist unless some kind of setup is assumed, such as a common reference string. This either requires a trusted third party or the execution of heavy MPC protocols if the setup relies on secret randomness.</p>

    <p class="text-gray-300">For this reason, <em>transparent</em> SNARKs have been proposed, whose setup involves only publicly generated randomness. Many constructions of transparent setup SNARKs have been proposed in recent years, both based on asymmetric cryptography <em>[BCC^{+}16]</em>, <em>[WTS^{+}18]</em>, <em>[BBB^{+}18]</em>, <em>[x2]</em> and on symmetric cryptographic techniques <em>[x1]</em>, <em>[x1]</em>, <em>[BBHR18b]</em>, <em>[BCR^{+}19]</em>, <em>[x11]</em>, <em>[x12]</em>, <em>[BFH^{+}20]</em>.</p>

    <p class="text-gray-300">In this work we focus on this latter type of constructions and remark that all cited works in this category are built in (variants of) the Interactive Oracle Proof framework presented in <em>[x3]</em> and independently in <em>[x21]</em> as “interactive PCP”. Moreover they all address directly or indirectly the <span class="math">\\mathsf{NP}</span>-complete rank 1 constraint system satisfiability problem. An easier to state variant asks to prove, given <span class="math">A,B,C\\in\\mathbb{F}^{m,n}</span> and <span class="math">\\mathbf{b}\\in\\mathbb{F}^{m}</span>, the existence of a vector <span class="math">\\mathbf{z}\\in\\mathbb{F}^{n}</span> such that <span class="math">A\\mathbf{z}<em>B\\mathbf{z}=C\\mathbf{z}+\\mathbf{b}</span>, where <span class="math"></em></span> is the component-wise multiplication of vectors in <span class="math">\\mathbb{F}^{m}</span>. An IOP is an interactive proof where the verifier has oracle access to some strings provided by the prover. Its relation to zk-SNARKs stems from the results in <em>[x3]</em> where it was shown that any IOP can be efficiently compiled into a non-interactive argument in the random oracle model by using Merkle trees <em>[x18]</em>, and the transformation in addition preserves zero knowledge and knowledge soundness. In particular, IOPs can be used to construct zk-SNARKs.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Unfortunately, the IOP constructions above cannot be <em>directly</em> instantiated for every field choice as they extensively use Reed-Solomon codes, that requires the existence of enough points in <span class="math">\\mathbb{F}</span> and, even worse, the soundness error is always greater than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-1}<span class="math"> which implies </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>2^{\\lambda}<span class="math"> with </span>\\lambda<span class="math"> security parameter. This leaves out for example the case of R1CS over </span>\\mathbb{F}_{2}<span class="math">. This case is actually interesting as some hash functions and encryption schemes can be interpreted as boolean circuits with relative ease, and then translated to a R1CS. A straight-forward way to overcome this problem, mentioned in <em>[x1]</em>, is to simply embed </span>\\mathbb{F}_{2}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">a larger field <span class="math">\\mathbb{F}_{2^e}</span>, for large enough <span class="math">e</span> (where at least <span class="math">e &amp;gt; \\lambda</span>) and add constraints of the kind <span class="math">z_i^2 = z_i</span> for <span class="math">i = 1, \\dots, n</span> to ensure that the witness entries belong to <span class="math">\\mathbb{F}_2</span>,<span class="math">^3</span> and then execute the protocol for R1CS over the larger field.</p>

    <p class="text-gray-300">However this approach seems wasteful, as elements of <span class="math">\\mathbb{F}_{2^e}</span> which in principle could encode up to <span class="math">e</span> bits of information are used to represent only one element of <span class="math">\\mathbb{F}_2</span>. Also, operations over <span class="math">\\mathbb{F}_{2^e}</span> are more expensive than those over <span class="math">\\mathbb{F}_2</span>. Finally one needs the aforementioned additional constraints on the witness, which increase the size of the system. Since <span class="math">\\mathbb{F}_{2^e}</span> is an <span class="math">e</span>-dimensional vector space over <span class="math">\\mathbb{F}_2</span>, one attempt to improve this would be to interpret vectors in <span class="math">\\mathbb{F}_2^e</span> as elements over the larger field <span class="math">\\mathbb{F}_{2^e}</span>. While this would work for systems that only involve additions, it fails in general when multiplications are considered too.<span class="math">^4</span> The technical issue is that for <span class="math">e &amp;gt; 1</span>, the ring <span class="math">\\mathbb{F}_2^e</span>, considered with component-wise addition and multiplication, cannot be embedded via a ring homomorphism in <span class="math">\\mathbb{F}_{2^e}</span> (nor into any other finite field) since <span class="math">\\mathbb{F}_2^e</span> contains zero divisors while fields do not.</p>

    <p class="text-gray-300">The issue was recently addressed for the case of Ligero[AHIV17] in BooLigero [GSV21] with a technique that allows to roughly encode <span class="math">e</span> bits into <span class="math">\\sqrt{e}</span> field elements in <span class="math">\\mathbb{F}_{2^e}</span>, meaning that approximately <span class="math">\\sqrt{e}</span> bits are encoded per field element, in a manner that one can use Ligero over <span class="math">\\mathbb{F}_{2^e}</span> while adding little overhead. This however motivates the following question: can we find embeddings of <span class="math">\\mathbb{F}_2^k</span> into <span class="math">\\mathbb{F}_{2^e}</span> with a larger embedding rate <span class="math">k / e</span> which allow to produce more efficient IOPs for R1CS over <span class="math">\\mathbb{F}_2</span> given an IOP for R1CS over <span class="math">\\mathbb{F}_{2^e}</span>?</p>

    <h2 id="sec-1" class="text-2xl font-bold">1.1 Our contributions</h2>

    <p class="text-gray-300">In this work we answer the above question in the affirmative using a more efficient embedding that allows us to encode <span class="math">k \\geq e / 4</span> bits into an element of <span class="math">\\mathbb{F}_{2^e}</span>. We then present a construction of an IOP for <span class="math">\\mathbb{F}_2</span>-R1CS satisfiability which makes black-box use of any IOP satisfying mild assumptions for R1CS over larger fields. This leads us to reducing Aurora's argument size up to <span class="math">1.31 - 1.65 \\times</span> and Ligero's argument size up to <span class="math">3.71 \\times</span>.</p>

    <p class="text-gray-300">More concretely, we can use any Reed Solomon encoded IOP, a variant of IOP introduced in [BCR⁺19], that provides two commonly used sub-protocols: a generalised lincheck, which tests linear relations of the form <span class="math">A_{1}\\mathbf{x}_{1} + \\ldots + A_{n}\\mathbf{x}_{n} = \\mathbf{b}</span> when the verifier has only oracle access to Reed Solomon codewords encoding <span class="math">\\mathbf{x}_i</span>, and a rowcheck, which tests quadratic relations <span class="math">\\mathbf{x}*\\mathbf{y} = \\mathbf{z}</span> when the verifier has oracle access to encodings of <span class="math">\\mathbf{x}, \\mathbf{y}, \\mathbf{z}</span>. This includes Ligero<span class="math">^5</span> and Aurora [BCR⁺19]<span class="math">^6</span> up to minor manipulations to transform their lincheck, see Appendix C.</p>

    <p class="text-gray-300">To obtain our results we use the notion of reverse multiplication friendly embedding (RMFE), introduced in the MPC literature in [CCXY18] and inde</p>

    <p class="text-gray-300"><span class="math">^3</span> This is necessary as, for example, <span class="math">x^2 + x + 1 = 0</span> is satisfiable over <span class="math">\\mathbb{F}_4</span> but not over <span class="math">\\mathbb{F}_2</span>, despite the fact that the constraint only involves constants over <span class="math">\\mathbb{F}_2</span>.</p>

    <p class="text-gray-300"><span class="math">^4</span> This not only includes coordinate-wise products of secret vectors, but also the linear operations <span class="math">A\\mathbf{x}</span> in the R1CS system, where <span class="math">A</span> is a public matrix over the larger field.</p>

    <p class="text-gray-300"><span class="math">^5</span> See [BCR⁺19] for how to see Ligero as an IOP with these characteristics</p>

    <p class="text-gray-300"><span class="math">^6</span> We cannot however apply our techniques to IOPs with preprocessing, see comment in Section 1.3.</p>

    <p class="text-gray-300">pendently in <em>[x1]</em>, and used in several subsequent works <em>[x12, x13, x20, x16, ACE^{+}21]</em>. Such device allows to embed <span class="math">\\mathbb{F}_{2}^{k}</span> into a larger field <span class="math">\\mathbb{F}_{q}=\\mathbb{F}_{2^{e}}</span> in a manner such that field additions and products of two encodings in <span class="math">\\mathbb{F}_{q}</span> still encode (in a precise way described later) the component-wise additions and products of the originally vectors from <span class="math">\\mathbb{F}_{2}^{k}</span>. For parameters up to <span class="math">k&lt;100</span>, we can embed <span class="math">k</span> bits in a field <span class="math">\\mathbb{F}_{2^{e}}</span>, with <span class="math">e\\approx 3.3k</span> if we take the most convenient extension field, or <span class="math">e=4k</span> if we insist on <span class="math">e</span> being a power of <span class="math">2</span> or more generally having small Hamming weight (e.g. <span class="math">e=192</span>) which is usually a prefered choice in practice. The constructions are based on polynomial interpolation. See Section 2.2 and Appendix A.2 for asymptotical statements.</p>

    <p class="text-gray-300">However, even with this tool in hand we still face some hurdles when attempting to reduce proving satisfiability for a <span class="math">\\mathbb{F}_{2}</span>-R1CS statement to a proof for a smaller <span class="math">\\mathbb{F}_{q}</span>-R1CS statement. One such obstacle is that the RMFE embedding map (which we call <span class="math">\\varphi</span>) cannot be surjective. Since the first thing we will do in the proof is to embed the witness in a larger field by using the map <span class="math">\\varphi</span>, we will need to come up with a mechanism to convince the verifier that a given vector has entries in the image <span class="math">\\operatorname{Im}\\varphi</span>. In addition, the transformation of the R1CS system over <span class="math">\\mathbb{F}_{2}</span> into one over <span class="math">\\mathbb{F}_{q}</span> via this embedding introduces a few more obstacles. These eventually come from the fact that the embedding map <span class="math">\\varphi</span> is not a ring homomorphism, even though the <span class="math">\\mathbb{F}_{q}</span>-field product <span class="math">\\varphi(\\mathbf{x})\\cdot\\varphi(\\mathbf{y})</span> still contains all information about <span class="math">\\mathbf{x}<em>\\mathbf{y}</span>. In handling that we need to introduce some additional equations that are in principle foreign to the <span class="math">\\mathbb{F}_{q}</span>-R1CS template, in the sense that they capture <span class="math">\\mathbb{F}_{2}</span>-linear relations that are not linear over <span class="math">\\mathbb{F}_{q}</span> (this is just another manifestation of a phenomenon that </em>[x15, x16, x20, ACE^{+}21]* needed to deal with in various ways).</p>

    <p class="text-gray-300">It turns out that all of these can be dealt with by means of a notion we introduce in Section 3.3: the <em>modular lincheck</em>, an IOPP that we believe is of independent interest, to test linear relations modulo an <span class="math">\\mathbb{F}_{2}</span> vector space, i.e. equations of the form <span class="math">A\\mathbf{x}=\\mathbf{b}\\mod V^{n}</span>.</p>

    <p class="text-gray-300">In conclusion we compare the resulting argument system, using the compiler in <em>[x5]</em>, with Aurora and Ligero both in terms of argument size and prover complexity. Regarding the proof size we estimate the aforementioned improvement factors numerically, see our Python implementation at <em>[x14]</em>. Regarding prover time we estimate it to be asymptotically reduced by a factor of <span class="math">24.7\\times</span> for Aurora and between <span class="math">6.9-32.5\\times</span> for Ligero without interactive repetitions.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">1.2 Techniques</h3>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">Reverse multiplication friendly embeddings.</h4>

    <p class="text-gray-300">Given a finite field <span class="math">\\mathbb{F}_{p}</span> (in this article we focus on the case <span class="math">p=2</span>), and an integer <span class="math">e</span>, a <span class="math">(k,e)_{p}</span>-RMFE, introduced in <em>[x15, x1]</em> in the context of secure multiparty computation, is a pair of <span class="math">\\mathbb{F}_{2}</span>-linear maps <span class="math">\\varphi:\\mathbb{F}_{p}^{k}\\to\\mathbb{F}_{p^{e}}</span> and <span class="math">\\psi:\\mathbb{F}_{p^{e}}\\to\\mathbb{F}_{p}^{k}</span> satisfying <span class="math">\\mathbf{x}<em>\\mathbf{y}=\\psi(\\varphi(\\mathbf{x})\\cdot\\varphi(\\mathbf{y}))</span> for all <span class="math">\\mathbf{x},\\mathbf{y}\\in\\mathbb{F}_{p}^{k}</span>, where <span class="math"></em></span> denotes the component-wise product. The properties automatically imply that <span class="math">\\varphi</span> is injective, which justifies the name embedding.</p>

    <p class="text-gray-300">We extend the notation and denote by <span class="math">\\varPhi</span> the map that splits a long vector in blocks of <span class="math">k</span> coordinates and applies <span class="math">\\varphi</span> to each block, namely let <span class="math">\\varPhi:(\\mathbb{F}_p^k)^n\\to \\mathbb{F}_{p^e}^n</span> given by <span class="math">\\varPhi(\\mathbf{x}_1,\\ldots ,\\mathbf{x}_n)=(\\varphi (\\mathbf{x}_1),\\ldots ,\\varphi (\\mathbf{x}_n))</span> and consequently let <span class="math">\\varPsi:\\mathbb{F}_{p^e}^n\\to (\\mathbb{F}_p^k)^n</span> given by <span class="math">\\varPsi(x_1,\\dots,x_n)=(\\psi (x_1),\\dots,\\psi (x_n))</span>, which then satisfy <span class="math">\\mathbf{x}<em>\\mathbf{y} = \\varPsi(\\varPhi(\\mathbf{x})</em>\\varPhi(\\mathbf{y}))</span> for all <span class="math">\\mathbf{x},\\mathbf{y}\\in (\\mathbb{F}_p^k)^n = \\mathbb{F}_p^{kn}</span>, where the component-wise product on the right side is on <span class="math">\\mathbb{F}_{p^e}^n</span>.</p>

    <p class="text-gray-300">From <span class="math">\\mathbb{F}_2</span>-R1CS to a system of statements over <span class="math">\\mathbb{F}_q</span>. Our first step is to translate the statement that there exists <span class="math">\\mathbf{w}</span> such that <span class="math">A_{1}\\mathbf{w} <em> A_{2}\\mathbf{w} = A_{3}\\mathbf{w} + \\mathbf{b}</span> into satisfiability of an equivalent system consisting of quadratic and (modular) linear relations over <span class="math">\\mathbb{F}_q</span>. One well known reformulation of the above relation is that there exist <span class="math">\\mathbf{w} \\in \\mathbb{F}_2^n</span> and <span class="math">\\mathbf{x}_i \\in \\mathbb{F}_2^m</span> for <span class="math">i \\in \\{1, 2, 3\\}</span> such that <span class="math">A_i\\mathbf{w} = \\mathbf{x}_i</span> and <span class="math">\\mathbf{x}_1 </em> \\mathbf{x}_2 = \\mathbf{x}_3 + \\mathbf{b}</span>.</p>

    <p class="text-gray-300">We rephrase the above by embedding <span class="math">\\widetilde{\\mathbf{w}} = \\varPhi(\\mathbf{w}) \\in \\mathbb{F}_q^{n/k}</span> and <span class="math">\\widetilde{\\mathbf{x}}_i = \\varPhi(\\mathbf{x}_i)</span> (assuming for simplicity <span class="math">n, m</span> are divisible by <span class="math">k</span>), and setting <span class="math">\\mathbf{t} = \\widetilde{\\mathbf{x}}_1 <em> \\widetilde{\\mathbf{x}}_2</span>. First we deal with the quadratic relation. The key observation is that, if <span class="math">\\mathbf{1}</span> denotes the vector whose entries are all ones, <span class="math">\\mathbf{x}_1 </em> \\mathbf{x}_2 = \\mathbf{x}_3 + \\mathbf{b}</span> is equivalent to <span class="math">\\mathbf{x}_1 <em> \\mathbf{x}_2 = \\mathbf{1} </em> (\\mathbf{x}_3 + \\mathbf{b})</span>. Applying now the RMFE properties this is satisfiable if and only if <span class="math">\\varPsi(\\widetilde{\\mathbf{x}}_1 <em> \\widetilde{\\mathbf{x}}_2 - \\varPhi(\\mathbf{1}) </em> (\\widetilde{\\mathbf{x}}_3 + \\varPhi(\\mathbf{b}))) = 0</span>, that is, if and only if each entry of <span class="math">\\mathbf{t} - \\varPhi(\\mathbf{1}) * (\\widetilde{\\mathbf{x}}_3 + \\varPhi(\\mathbf{b}))</span> lies in <span class="math">\\mathrm{Ker} \\, \\psi</span>.</p>

    <p class="text-gray-300">Next we deal with linear relations. Let us restrict at first to one of the form <span class="math">\\mathbf{a}^{\\top}\\mathbf{x} = 0</span> with <span class="math">\\mathbf{a},\\mathbf{x}\\in \\mathbb{F}_2^k</span>. The idea, calling <span class="math">S</span> the map that sums all the components of a vector, is to rewrite it as <span class="math">S(\\mathbf{a}*\\mathbf{x}) = 0</span>. In this way we can apply the RMFE properties, obtaining <span class="math">S(\\psi (\\varphi (\\mathbf{a})\\cdot \\varphi (\\mathbf{x})) = 0</span>. Finally, since <span class="math">S\\circ \\psi</span> is linear, this is equivalent to <span class="math">\\varphi (\\mathbf{a})\\cdot \\varphi (\\mathbf{x})\\in \\mathrm{Ker}S\\circ \\psi</span>. In general, when the given vectors have length a multiple of <span class="math">k</span>, one can prove that <span class="math">\\mathbf{a}^{\\top}\\mathbf{x} = 0</span> is equivalent to <span class="math">\\varPhi(\\mathbf{a})^{\\top}\\varPhi(\\mathbf{x})\\in \\mathrm{Ker}S\\circ \\psi</span>.</p>

    <p class="text-gray-300">Given now a matrix <span class="math">A</span> with rows <span class="math">\\mathbf{a}_1, \\ldots, \\mathbf{a}_m</span>, observe that the entries of <span class="math">A\\mathbf{x}</span> are inner products of the form <span class="math">\\mathbf{a}_i^\\top \\mathbf{x}</span>. Applying the idea above we conclude that <span class="math">A\\mathbf{x} = \\mathbf{0}</span> is equivalent to show that all the entries of <span class="math">\\widetilde{A} \\cdot \\varPhi(\\mathbf{x})</span> lies in <span class="math">\\mathrm{Ker} S \\circ \\psi</span> with <span class="math">\\widetilde{A}</span> the result of applying <span class="math">\\varPhi</span> to <span class="math">A</span> row-wise. In conclusion, the three linear relations <span class="math">A_i\\mathbf{w} = \\mathbf{x}_i = I_m\\mathbf{x}_i</span> in the R1CS over <span class="math">\\mathbb{F}_2</span> are equivalent to three modular linear relations <span class="math">\\widetilde{A}\\widetilde{\\mathbf{w}} - \\widetilde{I}_m\\widetilde{\\mathbf{x}}_i \\in (\\mathrm{Ker} S \\circ \\psi)^m</span>. Finally, as observed, the fact that <span class="math">\\widetilde{\\mathbf{w}}, \\mathbf{x}_i</span> belonging to the image of <span class="math">\\varPhi</span> is equivalent to the constraints <span class="math">I_{n/k} \\cdot \\widetilde{\\mathbf{w}} \\in (\\operatorname{Im} \\varphi)^{n/k}</span> and <span class="math">I_{m/k} \\cdot \\widetilde{\\mathbf{x}}_i \\in (\\operatorname{Im} \\varphi)^{m/k}</span>.</p>

    <p class="text-gray-300">Modular linear test The sketched characterization above implies that providing a way to test linear modular relations over <span class="math">\\mathbb{F}_q</span> yields the desired IOP as the prover could provide oracle access to encodings of <span class="math">\\widetilde{\\mathbf{w}},\\widetilde{\\mathbf{x}}_1,\\widetilde{\\mathbf{x}}_2,\\widetilde{\\mathbf{x}}_3,\\mathbf{t}</span> and then convince the verifier that all those constraints are satisfied. The basic idea of our construction is that, to test <span class="math">\\mathbf{x} = \\mathbf{0}\\mod V^n</span> or equivalently <span class="math">\\mathbf{x}\\in V^n</span>, a standard approach would be to prove that a random linear combination of its coordinates belongs to <span class="math">V</span>. However, as in our case <span class="math">V\\subseteq \\mathbb{F}_q</span> is an <span class="math">\\mathbb{F}_2</span>-vector space, the coefficients of this linear combination have to lie in <span class="math">\\mathbb{F}_2</span>, granting only soundness <span class="math">1 / 2</span>. In order to decrease it we could check several independent linear combinations by sampling</p>

    <p class="text-gray-300">5</p>

    <p class="text-gray-300"><span class="math">R\\sim U(\\mathbb{F}_{2}^{\\lambda,n})</span> and testing <span class="math">R\\mathbf{x}\\in V^{\\lambda}</span>. Hence the prover first sends <span class="math">\\mathbf{v}=R\\mathbf{x}</span> to the verifier who checks <span class="math">\\mathbf{v}\\in V^{\\lambda}</span> and then both parties run a lincheck to test the correctness of <span class="math">\\mathbf{v}</span>. In Section 3.3 we describe how to achieve zero knowledge by adding a masking term and how to reduce the required random bits to <span class="math">\\Theta(\\lambda)</span> by using certain family of almost universal linear hash functions. In Section 4.1 we generalise this idea to efficiently proving several statements at the same time.</p>

    <h5 id="sec-4" class="text-base font-semibold mt-4">Optimizations</h5>

    <p class="text-gray-300">The above techniques require a total of 8 modular linchecks and a rowcheck. In Section 4, we introduce several modifications, the main of which is to reduce the number of modular linchecks to just 3. The observation is that we can test several equations of the form <span class="math">A\\mathbf{x}_{i}=\\mathbf{b}_{i}\\mod V^{n_{i}}</span> (with common <span class="math">V</span>) all at once by checking <span class="math">\\sum R_{i}(A\\mathbf{x_{i}}-\\mathbf{b}_{i})\\in V^{\\lambda}</span> for appropriately chosen matrices <span class="math">R_{i}</span>. We also note that the communication can be further reduced by noticing that the prover is sending vectors which should be in certain subspaces, and hence admit a succinct representation; we find a way to use the properties of RMFEs to efficiently compress and decompress this information.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.3 Other related work</h3>

    <p class="text-gray-300">As mentioned, our work compares favourably with <em>[x10]</em> showing significantly better improvement factors for Ligero’s proof size. In particular our work improves on Ligero by a factor of <span class="math">3.71\\times</span> for <span class="math">2^{20}</span> constraints, while BooLigero only improves on Ligero by a factor <span class="math">2.8\\times</span> on a circuit consisting on <span class="math">2^{16}-1</span> execution of SHA3, i.e. for a much larger number of constraints in the associated R1CS. We remark that the encoding used in <em>[x10]</em>, which essentially embeds the bit vectors into elements in the field extension in such a way that all of the bit products can be recovered directly as coordinates of the product of the two field elements, is similar to one considered in <em>[x5]</em> in the context of secure computation, which was subsequently improved in the same paper and later in <em>[x5]</em>, where a similar embedding as <em>[x11]</em> was considered. We also stress that in contrast to <em>[x10]</em> we present a general reduction that can be applied to a larger class of protocols.</p>

    <p class="text-gray-300">Regarding the use of RMFE, to the best of our knowledge only the recent work <em>[x12]</em> applied this tool in the IOP framework (see their Appendix A). However, their use is restricted to their own protocol, which follows the MPC-in-the-head paradigm introduced in <em>[x16]</em>, and cannot be applied directly to other existing IOPs such as Aurora. Furthermore, this optimisation is only considered in the multi-instance case while in our work we manage to integrate the RMFE also for a single instance. It is an interesting question to determine if the approach in <em>[x12]</em> can be applied to a single instance, as in the context of MPC, <em>[x11]</em> has shown that RMFE can also be used to improve the complexity of a single evaluation of a sufficiently “well behaved” boolean circuit.</p>

    <p class="text-gray-300">We also remark that even though our construction captures essentially any IOPs that provides a lincheck and a rowcheck, it still cannot be applied out of the box to preprocessing zk-SNARKs, such as <em>[x13, x23]</em>. The reason behind this limitation lies in the fact that we use the given lincheck to test a randomised</p>

    <p class="text-gray-300">relation, depending on the random coin of the verifier. This significantly affects the usefulness of any pre-computation. We believe however that this issue can be overcome in a non black-box way with different technique, a problem that we leave for future work. Finally, [DLS20] introduced the notion of Circuit Amortization-Friendly embedding or CAFE, a generalization of RMFE which allows to construct better encodings with respect to certain operations such as inner products. We have considered its use in this problem because it naturally fits well with linchecks, but rowchecks become too expensive to prove in this way and it does not yield immediate improvements. We leave it as an open question whether it is possible to improve our construction using CAFEs.</p>

    <h2 id="sec-6" class="text-2xl font-bold">2 Preliminaries</h2>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.1 Notation</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For an integer <span class="math">n</span>, <span class="math">[n] = \\{1, \\dots, n\\}</span>. Boldface font (e.g. <span class="math">\\mathbf{v}</span>) denotes vectors over a ring <span class="math">R</span>. <span class="math">\\mathbf{1}_k \\in R^k</span> is the vector whose entries are all 1. Given vectors <span class="math">\\mathbf{v}, \\mathbf{w} = (w_1, \\dots, w_n) \\in R^n</span>, <span class="math">\\mathbf{v} * \\mathbf{w}</span> is their coordinate-wise (also called Hadamard or Schur) product and $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{v} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is the Hamming weight of </span>\\mathbf{v}<span class="math">, i.e. the number of its non-zero entries. </span>R^{m,n}<span class="math"> is the space of matrices with </span>m<span class="math"> rows, </span>n<span class="math"> columns and entries in </span>R<span class="math">. </span>I_n \\in R^{n,n}<span class="math"> is the identity matrix. Given </span>A \\in R^{m,n}<span class="math">, </span>A^\\top \\in R^{n,m}$ is its transpose.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Given <span class="math">q</span> a prime power, <span class="math">\\mathbb{F}_q</span> is the only field of cardinality <span class="math">q</span> up to isomorphisms. If <span class="math">q = p^e</span> then we identify <span class="math">\\mathbb{F}_p \\subseteq \\mathbb{F}_q</span> as usual and <span class="math">\\mathbb{F}_q</span> is an <span class="math">\\mathbb{F}_p</span> vector space of dimension <span class="math">e</span>. <span class="math">V \\leq \\mathbb{F}_q</span> means that <span class="math">V</span> is an <span class="math">\\mathbb{F}_p</span>-vector subspace of <span class="math">\\mathbb{F}_q</span>. Two elements <span class="math">a, b \\in \\mathbb{F}_q</span> are equal modulo <span class="math">V</span>, or <span class="math">a = b \\mod V</span>, if <span class="math">a - b \\in V</span>. For vectors <span class="math">\\mathbf{a}, \\mathbf{b} \\in \\mathbb{F}_q^m</span>, <span class="math">\\mathbf{a} = \\mathbf{b} \\mod V^m</span> if <span class="math">\\mathbf{a} - \\mathbf{b} \\in V^m</span>, i.e. <span class="math">a_i = b_i \\mod V</span> at each coordinate <span class="math">i \\in [m]</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given a polynomial <span class="math">\\widehat{f} \\in \\mathbb{F}_q[x]</span> and <span class="math">L \\subseteq \\mathbb{F}_q</span> we denote $\\widehat{f}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L} = (\\widehat{f}(\\alpha))_{\\alpha \\in L}<span class="math"> its evaluation over </span>L<span class="math">. The Reed-Solomon code over </span>L<span class="math"> of rate </span>\\rho \\in [0,1]<span class="math"> is the set </span>\\mathsf{RS}_{\\mathbb{F}_q,L,\\rho} \\coloneqq \\{\\widehat{f}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L} : \\widehat{f} \\in \\mathbb{F}_q[x], \\deg \\widehat{f} &lt; \\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}<span class="math">. When clear from the context we will omit the field </span>\\mathbb{F}_q<span class="math">. For any </span>f \\in \\mathsf{RS}_{\\mathbb{F}_q,L,\\rho}<span class="math"> we keep the convention that </span>\\widehat{f}<span class="math"> is the polynomial of smallest degree (the only one of degree </span>&lt; \\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">) such that </span>\\widehat{f}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L} = f$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We will typically encode vectors <span class="math">\\mathbf{v}</span> of length $m &lt; \\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> as codewords from </span>\\mathsf{RS}_{\\mathbb{F}_q,L,\\rho}<span class="math">. To do so, given a subset </span>H \\subseteq \\mathbb{F}_q<span class="math"> of size </span>m<span class="math">, we identify </span>\\mathbb{F}_q^H<span class="math">, i.e. vectors indexed by </span>H<span class="math">, and </span>\\mathbb{F}_q^m<span class="math"> by choosing a bijection between </span>H<span class="math"> and </span>[m]<span class="math"> so that </span>\\mathbf{v} \\in \\mathbb{F}_q^H<span class="math">. Then the encoding happens by sampling a </span>f \\in \\mathsf{RS}_{L,\\rho}<span class="math"> such that </span>\\widehat{f}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H} = \\mathbf{v}<span class="math">. In a similar fashion </span>\\mathbb{F}_q^{H_1 \\times H_2}<span class="math"> will be used for matrices with coordinates in </span>\\mathbb{F}_q<span class="math"> with rows and columns indexed by </span>H_1<span class="math"> and </span>H_2<span class="math"> respectively. </span>I_H<span class="math"> is the identity matrix in </span>\\mathbb{F}_q^{H \\times H}<span class="math">. For all the notations in this paragraph, replacing </span>\\mathbb{F}_q<span class="math"> by </span>V<span class="math"> means that the coordinates of the vectors or matrices are restricted to </span>V$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally with <span class="math">\\mathrm{FFT}(\\mathbb{F}, n)</span> we denote the number of field operations required to perform a (binary) fast Fourier transform over a set of size <span class="math">n</span>, see [GM10].</p>

    <p class="text-gray-300">7</p>

    <p class="text-gray-300">8</p>

    <h2 id="sec-8" class="text-2xl font-bold">2.2 Reverse multiplication friendly embedding</h2>

    <p class="text-gray-300">We now recall the notion of reverse multiplication friendly embedding from [CCXY18]. Its purpose is to ‘reconcile’ the coordinate-wise multiplicative structure of a ring <span class="math">\\mathbb{F}_p^k</span> and the finite field structure of an extension <span class="math">\\mathbb{F}_{p^e}</span> of <span class="math">\\mathbb{F}_p</span>.</p>

    <p class="text-gray-300"><strong>Definition 1.</strong> Given a prime power <span class="math">p</span> and <span class="math">k, e \\in \\mathbb{N}</span> a Reverse Multiplication-Friendly Embedding, denoted <span class="math">(k,e)_p</span>-RMFE, is a pair of <span class="math">\\mathbb{F}_p</span>-linear maps <span class="math">\\varphi : \\mathbb{F}_p^k \\to \\mathbb{F}_{p^e}</span>, <span class="math">\\psi : \\mathbb{F}_{p^e} \\to \\mathbb{F}_p^k</span> such that for all <span class="math">\\mathbf{x}, \\mathbf{y} \\in \\mathbb{F}_p^k</span>, it holds that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{x} * \\mathbf{y} = \\psi(\\varphi(\\mathbf{x}) \\cdot \\varphi(\\mathbf{y})).</span></div>

    <p class="text-gray-300">That is, one can embed <span class="math">\\mathbb{F}_p^k</span> into <span class="math">\\mathbb{F}_{p^e}</span> via a linear map <span class="math">\\varphi</span> so that the product in <span class="math">\\mathbb{F}_{p^e}</span> of the images of any two vectors <span class="math">\\mathbf{x},\\mathbf{y}</span> carries information about their component-wise product <span class="math">\\mathbf{x}*\\mathbf{y}</span>, and this can be recovered applying <span class="math">\\psi</span> to that field product. For notational convenience, we extend both <span class="math">\\varphi</span> and <span class="math">\\psi</span> to maps <span class="math">\\varPhi</span>, <span class="math">\\varPsi</span> as follows. Given vectors <span class="math">\\mathbf{x} = (\\mathbf{x}_1,\\dots ,\\mathbf{x}_n)\\in (\\mathbb{F}_p^k)^n</span> and <span class="math">\\mathbf{z} = (z_{1},\\ldots ,z_{n})\\in (\\mathbb{F}_{p^{e}})^{n}</span> we define</p>

    <div class="my-4 text-center"><span class="math-block">\\Phi(\\mathbf{x}) := (\\varphi(\\mathbf{x}_1), \\dots, \\varphi(\\mathbf{x}_n)) \\in (\\mathbb{F}_{p^e})^n, \\quad \\Psi(\\mathbf{z}) := (\\psi(z_1), \\dots, \\psi(z_n)) \\in (\\mathbb{F}_p^k)^n.</span></div>

    <p class="text-gray-300">and identify <span class="math">(\\mathbb{F}_p^k)^n = \\mathbb{F}_p^{nk}</span>. We will need a number of properties that are direct consequences of the definition.</p>

    <p class="text-gray-300"><strong>Lemma 1.</strong> The following holds for all positive <span class="math">n \\in \\mathbb{N}</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The maps <span class="math">\\varphi</span> and <span class="math">\\Phi</span> are injective. The maps <span class="math">\\psi</span> and <span class="math">\\Psi</span> are surjective.</li>

      <li>For all <span class="math">\\mathbf{x}</span>, <span class="math">\\mathbf{y} \\in (\\mathbb{F}_p^k)^n</span>, <span class="math">\\mathbf{x} <em> \\mathbf{y} = \\varPsi(\\varPhi(\\mathbf{x}) </em> \\varPhi(\\mathbf{y}))</span> where the *product in the right-hand side is component-wise in <span class="math">(\\mathbb{F}_{p^e})^n</span>, i.e., in each component we use the field product in <span class="math">\\mathbb{F}_{p^e}</span>.</li>

      <li>Let <span class="math">u = \\varphi(\\mathbf{1}_k) \\in \\mathbb{F}_{p^e}</span>. Then for all <span class="math">\\mathbf{x} \\in (\\mathbb{F}_p^k)^n</span> we have <span class="math">\\mathbf{x} = \\varPsi(u \\cdot \\varPhi(\\mathbf{x}))</span>.</li>

      <li>Let <span class="math">S: \\mathbb{F}_p^k \\to \\mathbb{F}_p</span> be given by <span class="math">S(x_1, x_2, \\ldots, x_k) = x_1 + x_2 + \\dots + x_k</span>. Then for all <span class="math">\\mathbf{x}, \\mathbf{y} \\in (\\mathbb{F}_p^k)^n</span>, the inner product <span class="math">\\mathbf{x}^\\top \\mathbf{y}</span> can be written as</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{x}^\\top \\mathbf{y} = S \\circ \\psi(\\Phi(\\mathbf{x})^\\top \\Phi(\\mathbf{y}))</span></div>

    <p class="text-gray-300"><strong>Lemma 1</strong> is proved in Section A.3. As for the existence of RMFEs, we know the following: first of all, unless <span class="math">k = 1</span>, we will need <span class="math">e \\geq 2k - 1 &amp;gt; k</span> (in particular <span class="math">\\varphi</span>, <span class="math">\\Phi</span> are not surjective maps and <span class="math">\\psi, \\Psi</span> are not injective). If <span class="math">k \\leq p + 1</span>, then <span class="math">e = 2k - 1</span> is achievable. Asymptotically, it is shown in [CCXY18] that for all <span class="math">p</span>, there exists an infinite family of <span class="math">(k, \\Theta(k))_p</span>-RMFE, where <span class="math">k \\to \\infty</span>. This result relies on algebraic geometry. On the other hand, as we note in Appendix A.2, we can achieve <span class="math">(k, O(k2^{\\log^<em> k}))_2</span>-RMFEs using concatenation of purely polynomial-interpolation based techniques, where <span class="math">\\log^</em> k</span> is the iterated log, a function with a very slow growth. <span class="math">^9</span></p>

    <p class="text-gray-300">For concrete parameters, and using concatenation of polynomial-interpolation based techniques, one can get RMFEs with good parameters. For example, for our case of interest <span class="math">p = 2</span>:</p>

    <p class="text-gray-300">8 Note that <span class="math">u</span> is not necessarily equal to 1.</p>

    <p class="text-gray-300">9 In fact <span class="math">2^{\\log^* k} = o(\\log \\log \\dots \\log k)</span> for any finite number of applications of <span class="math">\\log</span> on the right.</p>

    <p class="text-gray-300">Lemma 2. For all <span class="math">r \\leq 33</span>, there exists a <span class="math">(3r, 10r - 5)_2</span>-RMFE. For all <span class="math">a \\leq 17</span> there exists a <span class="math">(2a, 8a)_2</span>-RMFE. For all <span class="math">b \\leq 65</span> there exists a <span class="math">(3b, 12b)_2</span>-RMFE.</p>

    <p class="text-gray-300">Note that the rate <span class="math">k / e</span> is larger in the first case as it is lower bounded by <span class="math">3 / 10</span> while in the other cases <span class="math">k / e = 1 / 4</span>. However, we mention the last two results as they include cases in which the dimension of the larger field is a power of two up to 128, and the <span class="math">(48,192)_2</span>-RMFE that we use to compare with Aurora. Although some of these results were not explicitly mentioned in [CCXY18], they can easily be deduced from the results there. We justify all of this in Appendix A.1. Moreover, explicit constructions of generator matrices for <span class="math">\\varphi, \\psi</span> and other data we use in this paper for selected RMFEs of interest are included in the implementation at [Git21b].</p>

    <h2 id="sec-9" class="text-2xl font-bold">2.3 R1CS, Lincheck and Rowcheck</h2>

    <p class="text-gray-300">We now recall the main relations used in recent IOP-based SNARKs like [BCR⁺19, AHIV17]. The first one is the rank 1 constraints system, or R1CS, that defines an NP-complete language closely related to arithmetic circuit satisfiability. Here we present an equivalent affine version that requires for <span class="math">A_{1}, A_{2}, A_{3} \\in \\mathbb{F}^{m,n}</span> and <span class="math">\\mathbf{b} \\in \\mathbb{F}^{m}</span> to exhibit a vector <span class="math">\\mathbf{w} \\in \\mathbb{F}^{n}</span> such that <span class="math">A_{1}\\mathbf{w} * A_{2}\\mathbf{w} = A_{3}\\mathbf{w} + \\mathbf{b}</span>. Formally</p>

    <p class="text-gray-300">Definition 2. We define the affine R1CS relation as the set</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\mathrm {R 1 C S}} = \\left\\{\\left(\\left(\\mathbb {F}, m, n, A _ {1}, A _ {2}, A _ {3}, \\mathbf {b}\\right), \\mathbf {w}\\right): A _ {i} \\in \\mathbb {F} ^ {m, n}, A _ {1} \\mathbf {w} * A _ {2} \\mathbf {w} = A _ {3} \\mathbf {w} + \\mathbf {b} \\right\\}.</span></div>

    <p class="text-gray-300">Instead of directly providing a proof system for R1CS, two intermediate relations, lincheck and rowcheck, are defined and for which [BCR⁺19] constructs RS-encoded IOPPs; these are then used as building blocks to produce a RS-encoded IOP for the R1CS relation, which in turn can be combined with a low degree test, such as [BBHR18a, BGKS20], to make a standard IOP for R1CS.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The lincheck relation requires that the witnesses <span class="math">f_{1}, f_{2} \\in \\mathsf{RS}_{L,\\rho}</span> encode over <span class="math">H_{1}, H_{2} \\subseteq \\mathbb{F}_{q}</span> two vectors <span class="math">\\mathbf{x}_{1}, \\mathbf{x}_{2}</span> (i.e. $\\widehat{f}_{i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_i} = \\mathbf{x}_i<span class="math">) which satisfy a given linear constraint. The rowcheck relation requires that witnesses </span>f_{1}, f_{2}, f_{3} \\in \\mathsf{RS}_{L,\\rho}<span class="math"> encode over </span>H \\subseteq \\mathbb{F}_{q}<span class="math"> three vectors </span>\\mathbf{x}_{1}, \\mathbf{x}_{2}, \\mathbf{x}_{3}<span class="math"> such that </span>\\mathbf{x}_1 * \\mathbf{x}_2 = \\mathbf{x}_3<span class="math">. For efficiency reasons, depending on the concrete instantiations of Aurora and FRI, both definitions given below require </span>L, H_{1}, H_{2}, H<span class="math"> to be </span>\\mathbb{F}_2<span class="math">-affine subspaces of </span>\\mathbb{F}_q$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Definition 3. We define <span class="math">\\mathcal{R}_{\\mathrm{Lin}}</span> as the set of tuples <span class="math">((\\mathbb{F}_q,L,H_1,H_2,\\rho ,M),(f_1,f_2))</span> such that <span class="math">L,H_{i}\\subseteq \\mathbb{F}_{q}</span> are affine subspaces, <span class="math">H_{i}\\cap L = \\varnothing</span> for <span class="math">i\\in \\{1,2\\}</span>, <span class="math">f_{i}\\in \\mathsf{RS}_{L,\\rho}</span>, <span class="math">M\\in \\mathbb{F}_{q}^{H_{1}\\times H_{2}}</span> and the linear relationship $\\widehat{f}_{1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_1} = M\\cdot \\widehat{f}_{2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_2}$ holds.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Definition 4. We define <span class="math">\\mathcal{R}_{\\mathrm{Row}}</span> as the set of tuples <span class="math">((\\mathbb{F}_q,L,H,\\rho),(f_1,f_2,f_3))</span> such that <span class="math">L,H\\subseteq \\mathbb{F}_q</span> are disjoint affine subspaces, <span class="math">f_{i}\\in \\mathsf{RS}_{L,\\rho}</span> for <span class="math">i\\in \\{1,2,3\\}</span> and the quadratic relationship $\\widehat{f}_{1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H}*\\widehat{f}_{2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H} = \\widehat{f}_{3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H}$ holds.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">¹⁰ see Section B for an informal definition of IOP or [BCS16, BCR⁺19] for a more formal one</p>

    <p class="text-gray-300">As said RS-encoded IOPPs <span class="math">(\\mathsf{P}_{\\mathrm{Lin}},\\mathsf{V}_{\\mathrm{Lin}})</span> and <span class="math">(\\mathsf{P}_{\\mathrm{Row}},\\mathsf{V}_{\\mathrm{Row}})</span> for the two relations above are provided in [BCR+19] and in [AHIV17] up to minor adaptations in the second case. In our work we will need a generalisation of <span class="math">\\mathcal{R}_{\\mathrm{Lin}}</span> that tests relations of the form <span class="math">A_{1}\\mathbf{x}_{1} + \\ldots +A_{h}\\mathbf{x}_{h} = \\mathbf{b}</span>. Observe that for <span class="math">h = 2</span>, <span class="math">A_{1} = -I</span> and <span class="math">\\mathbf{b} = \\mathbf{0}</span> we get back the standard lincheck.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 5.</strong> <span class="math">\\mathcal{R}_{\\mathrm{Lin}_h}</span> is the set of tuples <span class="math">((\\mathbb{F}_q,L,H_0,H_i,\\rho ,M_i,\\mathbf{b})_{i = 1}^h,(f_i)_{i = 1}^h)</span> such that <span class="math">L,H_0,H_i\\leq \\mathbb{F}_q</span>, <span class="math">L\\cap H_0 = L\\cap H_i = \\emptyset</span> for all <span class="math">i\\in \\{1,\\ldots ,h\\}</span>, <span class="math">f_{i}\\in \\mathsf{RS}_{L,\\rho}</span>, <span class="math">M\\in \\mathbb{F}_q^{H_0\\times H_i}</span> and the linear relationship $\\sum_{i = 1}^{h}M_{i}\\cdot \\widehat{f}_{i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{H_{i}}} = \\mathbf{b}$ holds.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The lincheck protocol presented in Aurora can be generalised to capture this variant, as shown in the appendix Section C. More precisely we claim that</p>

    <p class="text-gray-300"><strong>Proposition 1.</strong> There exists a RS-encoded IOPP <span class="math">(\\mathsf{P}_{\\mathrm{Lin}_h},\\mathsf{V}_{\\mathrm{Lin}_h})</span> for <span class="math">\\mathcal{R}_{\\mathrm{Lin}_h}</span> with the following parameters:</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\text{Rounds} = 2 \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{Proof Length} = 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\text{Randomness} = 2\\log q \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{Soundness} =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">q^{-1} \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\text{Verifier Time} =</td>

            <td class="px-3 py-2 border-b border-gray-700">H_0</td>

            <td class="px-3 py-2 border-b border-gray-700">+ O\\left(\\sum_{i=1}^{h} \\</td>

            <td class="px-3 py-2 border-b border-gray-700">M_i\\</td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700">H</td>

            <td class="px-3 py-2 border-b border-gray-700">\\right) + T_{\\text{Sum}}^{\\mathsf{V}} \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\text{Max Rates} = \\left(\\rho, \\rho +</td>

            <td class="px-3 py-2 border-b border-gray-700">H</td>

            <td class="px-3 py-2 border-b border-gray-700">\\cdot</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">^{-1}\\right) \\\\</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">where <span class="math">T_{\\text{Sum}}^{\\mathsf{P}}, T_{\\text{Sum}}^{\\mathsf{V}}</span> are respectively the prover and verifier complexity for the Univariate Sumcheck, see [BCR+19], and <span class="math">H = \\text{span}(H_0, H_1, \\ldots, H_h)</span></p>

    <p class="text-gray-300">The main goal we pursue in this section and the next one is to describe an efficient RS-encoded IOP for the R1CS language over <span class="math">\\mathbb{F}_2</span>. This will be based on two RS-encoded IOPP: <span class="math">(\\mathsf{P}_{\\mathrm{Lin}_h},\\mathsf{V}_{\\mathrm{Lin}_h})</span> for the generalised lincheck and <span class="math">(\\mathsf{P}_{\\mathrm{Row}},\\mathsf{V}_{\\mathrm{Row}})</span> for the rowcheck both over a large field <span class="math">\\mathbb{F}_q</span>, see Section 2.3. The first step we take in this direction (in Section 3.1) is to characterise satisfiable R1CSs over <span class="math">\\mathbb{F}_2</span> in terms of one quadratic relation over <span class="math">\\mathbb{F}_q</span> and a set of linear relations modulo some vector space <span class="math">V\\leq \\mathbb{F}_q</span>. An RS-encoded IOPP to test the latter is provided in Section 3.3 while Section 3.2 provides basic tools for this construction. Finally a simple solution that makes a naive usage of the modular lincheck is provided. Even if suboptimal, we see this as a useful stepping stone to better present the efficient version in Section 4.3</p>

    <p class="text-gray-300">In the following we assume <span class="math">(\\varphi, \\psi)</span> to be a <span class="math">(k, e)_2</span>-RMFE, where <span class="math">q = 2^e</span>, and recall that <span class="math">\\varPhi, \\varPsi</span> denote the block-wise application of <span class="math">\\varphi</span> and <span class="math">\\psi</span>, cf. Section 2.2.</p>

    <p class="text-gray-300">Theorem 1. Let <span class="math">A_{1}, A_{2}, A_{3} \\in \\mathbb{F}_{2}^{m,n}</span>, <span class="math">\\mathbf{b} \\in \\mathbb{F}_{2}^{m}</span> with <span class="math">m, n</span> multiples of <span class="math">k</span>. Then there exists <span class="math">\\mathbf{w} \\in \\mathbb{F}_{2}^{n}</span> such that <span class="math">((\\mathbb{F}_{2}, m, n, A_{1}, A_{2}, A_{3}, \\mathbf{b}), \\mathbf{w}) \\in \\mathcal{R}_{\\mathsf{R1CS}}</span> if and only if there exist <span class="math">\\widetilde{\\mathbf{w}} \\in \\mathbb{F}_{q}^{n/k}</span> and <span class="math">\\widetilde{\\mathbf{x}}_{1}, \\widetilde{\\mathbf{x}}_{2}, \\widetilde{\\mathbf{x}}_{3}, \\mathbf{t} \\in \\mathbb{F}_{q}^{m/k}</span> satisfying</p>

    <div class="my-4 text-center"><span class="math-block">\\widetilde {\\mathbf {x}} _ {1} * \\widetilde {\\mathbf {x}} _ {2} = \\mathbf {t} \\tag {1}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\widetilde {\\mathbf {w}} = \\mathbf {0} \\mod (\\operatorname {I m} \\varphi) ^ {n / k} \\tag {2}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\widetilde {\\mathbf {x}} _ {i} = \\mathbf {0} \\mod (\\operatorname {I m} \\varphi) ^ {m / k} \\quad \\forall i \\in \\{1, 2, 3 \\} \\tag {3}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\widetilde {A} _ {i} \\widetilde {\\mathbf {w}} - \\widetilde {I} _ {m} \\widetilde {\\mathbf {x}} _ {i} = \\mathbf {0} \\mod (\\operatorname {K e r} S \\circ \\psi) ^ {m} \\quad \\forall i \\in \\{1, 2, 3 \\} \\tag {4}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {t} - u \\widetilde {\\mathbf {x}} _ {3} = u \\widetilde {\\mathbf {b}} \\mod (\\operatorname {K e r} \\psi) ^ {m / k} \\tag {5}</span></div>

    <p class="text-gray-300">where <span class="math">\\widetilde{\\mathbf{b}} = \\Phi (\\mathbf{b})\\in \\mathbb{F}_q^{m / k}</span>, <span class="math">u = \\varphi (\\mathbf{1}_k)\\in \\mathbb{F}_q</span>, <span class="math">\\widetilde{A}_i\\in \\mathbb{F}_q^{m,n / k}</span> is the matrix obtained by applying <span class="math">\\varPhi</span> row-wise to <span class="math">A_{i}</span>, and <span class="math">\\widetilde{I}_m\\in \\mathbb{F}_q^{m,m / k}</span> is the matrix obtained by applying <span class="math">\\varPhi</span> row-wise to the identity matrix <span class="math">I_{m}\\in \\mathbb{F}_{2}^{m,m}</span>. Moreover if <span class="math">\\mathbf{w}</span> is a witness for the R1CS then <span class="math">\\widetilde{\\mathbf{w}} = \\varPhi (\\mathbf{w})</span>, <span class="math">\\widetilde{\\mathbf{x}}_i = \\varPhi (A_i\\mathbf{w})</span>, <span class="math">\\mathbf{t} = \\widetilde{\\mathbf{x}}_1*\\widetilde{\\mathbf{x}}_2</span> satisfy the conditions above.</p>

    <p class="text-gray-300">Proof. In one direction, assume the existence of <span class="math">\\mathbf{w}</span>. For <span class="math">i \\in \\{1,2,3\\}</span> let <span class="math">\\mathbf{x}_i = A_i\\mathbf{w}</span>, <span class="math">\\widetilde{\\mathbf{x}}_i = \\varPhi(\\mathbf{x}_i)</span>, <span class="math">\\widetilde{\\mathbf{w}} = \\varPhi(\\mathbf{w})</span> and <span class="math">\\mathbf{t} = \\widetilde{\\mathbf{x}}_1 <em> \\widetilde{\\mathbf{x}}_2</span>. Conditions 1, 2, 3 are automatically satisfied. Next, for each <span class="math">i</span>, condition 4 is equivalent to <span class="math">A_i\\mathbf{w} = \\mathbf{x}_i</span>. Indeed, rewriting this as <span class="math">A_i\\mathbf{w} = I_m\\mathbf{x}_i</span>, we can interpret it as <span class="math">m</span> equations, one for each row of <span class="math">A_i</span> and <span class="math">I_m</span>, of inner-products of the form <span class="math">\\mathbf{a}_{i,j}^{\\top}\\mathbf{w} = \\mathbf{e}_j^{\\top}\\mathbf{x}_i</span> where <span class="math">\\mathbf{a}_{i,j}</span> is the <span class="math">j</span>-th row of <span class="math">A_i</span> and <span class="math">\\mathbf{e}_j</span> is the <span class="math">j</span>-th unit vector. Applying 1 to both sides this is equivalent to <span class="math">S \\circ \\psi(\\widetilde{\\mathbf{a}}_{i,j}^{\\top}\\widetilde{\\mathbf{w}}) = S \\circ \\psi(\\widetilde{\\mathbf{e}}_j^{\\top}\\widetilde{\\mathbf{x}}_i)</span> with <span class="math">\\widetilde{\\mathbf{a}}_j = \\varPhi(\\mathbf{a}_j)</span> and <span class="math">\\widetilde{\\mathbf{e}}_j = \\varPhi(\\mathbf{e}_j)</span>. By <span class="math">\\mathbb{F}_2</span>-linearity <span class="math">S \\circ \\psi(\\widetilde{\\mathbf{a}}_j^{\\top}\\widetilde{\\mathbf{w}} - \\widetilde{\\mathbf{e}}_j^{\\top}\\widetilde{\\mathbf{x}}_i) = 0</span> i.e. the <span class="math">j</span>-th component of <span class="math">\\widetilde{A}_i\\widetilde{\\mathbf{w}} - \\widetilde{I}_m\\widetilde{\\mathbf{x}}_i</span> lies in the kernel of <span class="math">S \\circ \\psi</span>. Condition 4 must therefore be satisfied. Finally we show that condition 5 is equivalent to <span class="math">\\mathbf{x}_1 </em> \\mathbf{x}_2 = \\mathbf{x}_3 + \\mathbf{b}</span>, which in turn holds by the definition of <span class="math">\\mathbf{x}_i</span> and the assumption on <span class="math">\\mathbf{w}</span>. First we rewrite it using Lemma 1 as <span class="math">\\varPsi(\\varPhi(\\mathbf{x}_1) <em> \\varPhi(\\mathbf{x}_2)) = \\varPsi(u\\varPhi(\\mathbf{x}_3)) + \\varPsi(u\\varPhi(\\mathbf{b}))</span> or, with our notation, <span class="math">\\varPsi(\\widetilde{\\mathbf{x}}_1 </em> \\widetilde{\\mathbf{x}}_2) = \\varPsi(u\\widetilde{\\mathbf{x}}_3) - \\varPsi(u\\widetilde{\\mathbf{b}})</span>. By <span class="math">\\mathbb{F}_2</span> linearity of <span class="math">\\varPsi</span> this is ultimately equivalent to <span class="math">\\widetilde{\\mathbf{x}}_1 <em> \\widetilde{\\mathbf{x}}_2 - u(\\widetilde{\\mathbf{x}}_3 + \\widetilde{\\mathbf{b}}) \\in (\\mathrm{Ker} \\psi)^{m/k}</span>. This concludes the first half of the proof. For the other direction, suppose there exist <span class="math">\\widetilde{\\mathbf{w}}, \\widetilde{\\mathbf{x}}_1, \\widetilde{\\mathbf{x}}_2, \\widetilde{\\mathbf{x}}_3, \\mathbf{t}</span> satisfying conditions above. By 2, 3 there exist <span class="math">\\mathbf{w} \\in \\mathbb{F}_2^n</span> and <span class="math">\\mathbf{x}_1, \\mathbf{x}_2, \\mathbf{x}_3 \\in \\mathbb{F}_2^m</span> with <span class="math">\\varPhi(\\mathbf{w}) = \\widetilde{\\mathbf{w}}</span> and <span class="math">\\varPhi(\\mathbf{x}_i) = \\widetilde{\\mathbf{x}}_i</span> for <span class="math">i = 1, 2, 3</span>. Now as showed before 4 is equivalent to <span class="math">A_i\\mathbf{w} = \\mathbf{x}_i</span> for <span class="math">i = 1, 2, 3</span> and, as condition 1 ensures <span class="math">\\mathbf{t} = \\widetilde{\\mathbf{x}}_1 </em> \\widetilde{\\mathbf{x}}_2</span>, 5 is equivalent to <span class="math">\\mathbf{x}_1 <em> \\mathbf{x}_2 = \\mathbf{x}_3 + \\mathbf{b}</span>. Putting everything together we have that <span class="math">A_1\\mathbf{w} </em> A_2\\mathbf{w} = A_3\\mathbf{w} + \\mathbf{b}</span>.</p>

    <p class="text-gray-300">We finally remark that when <span class="math">n, m</span> are not multiple of <span class="math">k</span>, Theorem 1 can still be applied by properly padding matrices <span class="math">A_{i}</span> and <span class="math">\\mathbf{b}</span> with zeroes.</p>

    <h2 id="sec-12" class="text-2xl font-bold">3.2 Linear Hashing</h2>

    <p class="text-gray-300">One common technique used to efficiently test that some encoded vector satisfies a set of linear equations is to prove it satisfies a random linear combination of them. More specifically to verify that <span class="math">A\\mathbf{x} = \\mathbf{b}</span>, one can sample a random vector <span class="math">\\mathbf{r} \\in \\mathbb{F}_q^m</span> and check <span class="math">\\mathbf{r}^\\top A\\mathbf{x} = \\mathbf{r}^\\top \\mathbf{b}</span>. This must hold true if the original statement does, while it fails with high probability (specifically <span class="math">1 - 1/q</span>) if the</p>

    <p class="text-gray-300">original statement is false. This is used for example in [AHIV17]. In order to use less randomness one could sample <span class="math">r \\gets^{\\S} \\mathbb{F}_q</span> and perform the test above with <span class="math">\\mathbf{r} = (1, r, \\ldots, r^{m-1})</span>. This works analogously, albeit with a higher soundness error, because if <span class="math">A\\mathbf{x} - \\mathbf{b} \\neq \\mathbf{0}</span>, then <span class="math">\\mathbf{r}^{\\top}(A\\mathbf{x} - \\mathbf{b}) = 0</span> if and only if <span class="math">r</span> is a root of the degree <span class="math">m-1</span> polynomial whose coefficients are the entries of <span class="math">A\\mathbf{x} - \\mathbf{b}</span>. This happens with probability smaller than <span class="math">(m-1)/q</span> as <span class="math">r</span> is uniformly random.</p>

    <p class="text-gray-300">When the field has small size the above techniques have a too large soundness error (e.g. for <span class="math">q = 2</span>, this error is <span class="math">1/2</span> in the first case, while the second case is useless for <span class="math">m &amp;gt; 2</span>). Therefore they need to be adapted. With this aim in mind, let <span class="math">\\vartheta: \\mathbb{F}_q^\\lambda \\to \\mathbb{F}_{2^\\lambda}</span> be an isomorphism of <span class="math">\\mathbb{F}_2</span>-linear spaces<span class="math">^{11}</span>. For any <span class="math">\\alpha \\in \\mathbb{F}_{2^\\lambda}</span> we define <span class="math">R_{\\alpha}^{(m)}: \\mathbb{F}_2^{\\lambda m} \\to \\mathbb{F}_2^\\lambda</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">R _ {\\alpha} ^ {(m)} (\\mathbf {x} _ {1}, \\dots , \\mathbf {x} _ {m}) = \\vartheta^ {- 1} \\big (\\alpha \\vartheta (\\mathbf {x} _ {1}) + \\dots + \\alpha^ {m} \\vartheta (\\mathbf {x} _ {m}) \\big).</span></div>

    <p class="text-gray-300">For ease of notation we will identify the linear function <span class="math">R_{\\alpha}^{(m)}</span> with the associated matrix in <span class="math">\\mathbb{F}_2^{\\lambda, \\lambda m}</span> with respect to the canonical base, and since all its entries are in <span class="math">\\mathbb{F}_2</span>, we can apply it to vectors in <span class="math">\\mathbb{F}_q^{\\lambda m}</span>. In other words if <span class="math">R_{\\alpha}^{(m)} = (r_{i,j}) \\in \\mathbb{F}_2^{\\lambda, \\lambda m}</span> and <span class="math">\\mathbf{x} = (x_1, \\ldots, x_{\\lambda m}) \\in \\mathbb{F}_q^{\\lambda m}</span> then</p>

    <div class="my-4 text-center"><span class="math-block">R _ {\\alpha} ^ {(m)} \\mathbf {x} = \\left(\\sum_ {j = 1} ^ {\\lambda m} r _ {i, j} x _ {j}\\right) _ {i = 1} ^ {\\lambda}</span></div>

    <p class="text-gray-300">Furthermore, this definition can be extended to vectors whose length is not a multiple of <span class="math">\\lambda</span> by padding with zeroes.</p>

    <p class="text-gray-300">These definitions allow us to state the results below in a form that facilitates their application to test linear relation modulo an <span class="math">\\mathbb{F}_2</span> vector space <span class="math">V\\leq \\mathbb{F}_q</span>.</p>

    <p class="text-gray-300"><strong>Proposition 2.</strong> Let <span class="math">V \\leq \\mathbb{F}_q</span> be an <span class="math">\\mathbb{F}_2</span> vector subspace, <span class="math">\\mathbf{y} \\in \\mathbb{F}_q^\\lambda</span>, <span class="math">\\mathbf{x} \\in \\mathbb{F}_q^{\\lambda m} \\setminus V^{\\lambda m}</span> and <span class="math">\\alpha \\sim U(\\mathbb{F}_{2^{\\lambda}})</span>, then <span class="math">\\operatorname*{Pr}\\left[R_{\\alpha}^{(m)}\\mathbf{x} = \\mathbf{y} \\mod V^{\\lambda}\\right] \\leq \\frac{m}{2^{\\lambda}}</span>.</p>

    <p class="text-gray-300"><strong>Proposition 3.</strong> Let <span class="math">V \\leq \\mathbb{F}_q</span> be an <span class="math">\\mathbb{F}_2</span> vector subspace, <span class="math">\\mathbf{y} \\in \\mathbb{F}_q^\\lambda</span>, <span class="math">\\mathbf{x}_i \\in \\mathbb{F}_q^{\\lambda m_i}</span> for <span class="math">i \\in [h]</span> such that <span class="math">\\mathbf{x}_j \\notin V^{\\lambda m_j}</span> for some <span class="math">j</span>. Then <span class="math">\\alpha_i \\sim U(\\mathbb{F}_{2^\\lambda})</span> implies</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ R _ {\\alpha_ {1}} ^ {(m _ {1})} \\mathbf {x} _ {1} + \\ldots + R _ {\\alpha_ {h}} ^ {(m _ {h})} \\mathbf {x} _ {h} = \\mathbf {y} \\mod V ^ {\\lambda} \\right] \\leq \\frac {\\max \\{m _ {i} : i \\in [ h ] \\}}{2 ^ {\\lambda}}.</span></div>

    <h2 id="sec-13" class="text-2xl font-bold">3.3 Modular Lincheck</h2>

    <p class="text-gray-300">In this section we provide an RS-encoded IOPP that generalises the Lincheck to linear relations of the form <span class="math">M_1\\mathbf{x}_1 + \\ldots + M_h\\mathbf{x}_h = \\mathbf{b}</span> modulo an <span class="math">\\mathbb{F}_2</span> vector space <span class="math">V \\leq \\mathbb{F}_q</span>, where the verifier has oracle access to an encoding of <span class="math">\\mathbf{x}_i</span> for each <span class="math">i</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 6.</strong> The Modular Lincheck relation is the set <span class="math">\\mathcal{R}_{\\mathrm{Miln}_h}</span> of all tuples <span class="math">((\\mathbb{F}_q,L,H_0,H_i,\\rho ,M_i,\\mathbf{b},V)_{i = 1}^h,(f_i)_{i = 1}^h)</span> such that <span class="math">L,H_0,H_i\\subseteq \\mathbb{F}_q</span> are affine <span class="math">\\mathbb{F}_2</span>-spaces with <span class="math">L\\cap H_{i} = \\varnothing</span>, <span class="math">\\rho \\in [0,1)</span>, <span class="math">M_{i}\\in \\mathbb{F}_{q}^{H_{0}\\times H_{i}}</span>, <span class="math">f_{i}\\in \\mathsf{RS}_{L,\\rho}</span> and $\\sum_{i = 1}^{h}M_{i}\\widehat{f}_{i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{i}} = \\mathbf{b}\\mod V^{H_{0}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">^{11}</span> Observe here we do not worry about their multiplicative structures</p>

    <p class="text-gray-300">12</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If we restrict our attention to prove simpler statements of the form  <span class="math">\\mathbf{x} = \\mathbf{0}</span>  mod  <span class="math">V^H</span> , i.e.  <span class="math">\\mathbf{x} \\in V^H</span> , for  $\\mathbf{x} = \\widehat{f}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H}<span class="math">  we could sample a random  </span>R \\sim U(\\mathbb{F}_2^{H_0' \\times H})<span class="math">  and test  </span>R\\mathbf{x} \\in V^{H_0'}<span class="math"> . This can be done by having the prover send  </span>\\mathbf{v} = R\\mathbf{x}<span class="math">  to the verifier, who first checks that  </span>\\mathbf{v} \\in V^{H_0'}<span class="math">  and then runs a lincheck. However, the resulting protocol is not Zero Knowledge as the verifier learns  </span>R\\mathbf{x}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To address this issue we add a masking codeword  <span class="math">g</span>  sampled from the set</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname {M a s k} (L, \\rho , H _ {0} ^ {\\prime}, V) = \\{f \\in \\mathsf {R S} _ {L, \\rho}: \\widehat {f} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H _ {0} ^ {\\prime}} \\in V ^ {H _ {0} ^ {\\prime}} \\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The prover initially provides oracle access to  <span class="math">g</span> , then waits for the matrix  <span class="math">R</span>  from the verifier, and replies with  $\\mathbf{v} = R\\mathbf{x} + \\widehat{g}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_0'}<span class="math">  sent in plain, after which parties execute a lincheck to convince the verifier that  </span>\\mathbf{v}<span class="math">  was computed correctly. The masking term does not affect soundness as it is independent from  </span>R$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the general case we replace  <span class="math">\\mathbf{x}</span>  with  $\\sum_{i=1}^{h} M_i \\widehat{f}_{i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_i} - \\mathbf{b}<span class="math">  and, for efficiency reasons, the random matrix  </span>R<span class="math">  with  </span>R_\\alpha<span class="math">  for a uniform  </span>\\alpha \\in \\mathbb{F}_{2^{\\lambda}}<span class="math"> , cf. Section 3.2. Finally we set the rate of the masking term to be  </span>\\rho +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_0'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-1}$  to achieve Zero Knowledge against unbounded queries.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_Mlin_h((pp,Mi,b,V,fi)_i=1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V^f_1,...,fh_Mlin_h((pp,Mi,b,V)_i=1)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Agree on H0' ⊆ Fq: H0' ∩ L = ∅</td>

            <td class="px-3 py-2 border-b border-gray-700">Agree on H0' ⊆ Fq: H0' ∩ L = ∅</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Mh+1 ← IH0', Hh+1 ← H0'</td>

            <td class="px-3 py-2 border-b border-gray-700">Mh+1 ← IH0', Hh+1 ← H0'</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ρ' ← ρ +</td>

            <td class="px-3 py-2 border-b border-gray-700">H0'</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">^-1</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ' ← ρ +</td>

            <td class="px-3 py-2 border-b border-gray-700">H0'</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">^-1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">pp' ← (Fq,L,H0',Hi,ρ')^h+1</td>

            <td class="px-3 py-2 border-b border-gray-700">pp' ← (Fq,L,H0',Hi,ρ')^h+1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">fh+1 ←$ Mask(L,ρ',H0',V)</td>

            <td class="px-3 py-2 border-b border-gray-700">fh+1</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | α ←$ F2^h  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v ← Rα [∑i=1^h M_i f_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_i - b] + f_h+1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_0'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | If v∉ V^H_0' return ⊥  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M' ← ((RαMi)^h_i=1, IH_0')</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M' ← ((RαMi)^h_i=1, IH_0')</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">P_Lin_h+1(pp',M',Rαb+v,(fi)^h+1)</td>

            <td class="px-3 py-2 border-b border-gray-700">V^f_1,...,fh+1_Lin_h+1(pp',M',Rαb+v)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 1. RS-encoded IOPP for  <span class="math">\\mathcal{R}_{\\mathrm{Mlin}_h}</span>  with  <span class="math">\\mathsf{pp} = (\\mathbb{F}_q,L,H_0,H_i,\\rho)_{i = 1}^h</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 2. Protocol 1 is an RS-encoded IOPP for the relation <span class="math">\\mathcal{R}_{\\mathrm{Mfin}_h}</span> that upon setting $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_0^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\lambda$ has the following parameters:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\text{Rounds} = 2</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{Proof Length} = 3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">\\text{Randomness} = \\lambda + 2\\log q</span></div>

    <div class="my-4 text-center"><span class="math-block">\\text{Soundness} = \\lceil m / \\lambda \\rceil 2^{-\\lambda} + \\lambda q^{-1}</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{Prover Time} = \\mathrm{FFT}(\\mathbb{F}_q,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) + \\sum_{i=1}^{h} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M_i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{b}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\lambda \\sum_{i=1}^{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ T_{\\mathrm{Lin}_{h+1}}^{\\mathbb{P}}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{Verifier Time} = \\lambda \\dim V + \\sum_{i=1}^{h} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M_i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{b}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ T_{\\mathrm{Lin}_{h+1}}^{\\mathcal{V}}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{Max Rates} = \\left(\\rho + \\lambda</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-1}, \\rho + (\\lambda +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-1}\\right)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where <span class="math">H = \\operatorname{span}(H_1, \\ldots, H_h, H_0&#x27;)</span> and <span class="math">T_{\\mathrm{Lin}_{h+1}}^{\\mathbb{P}}, T_{\\mathrm{Lin}_{h+1}}^{\\mathcal{V}}</span> denotes the costs of running respectively <span class="math">\\mathbb{P}_{\\mathrm{Lin}_{h+1}}</span> and <span class="math">\\mathcal{V}_{\\mathrm{Lin}_{h+1}}</span>.</p>

    <p class="text-gray-300">Proof sketch. Completeness holds because <span class="math">\\mathbf{v} \\in V^{H_0&#x27;}</span>, as its first term is the product of a vector in <span class="math">V^{H_0}</span> and a matrix with entries in <span class="math">\\mathbb{F}_2</span>, and the second term lies in <span class="math">V^{H_0&#x27;}</span> by construction. Moreover, from our definition of <span class="math">\\mathbf{v}</span> the tested linear relation is satisfied.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For soundness, by Proposition 3 the vector <span class="math">\\mathbf{v}</span> honestly computed lies in <span class="math">V^{H_0&#x27;}</span> with probability <span class="math">\\lceil m / \\lambda \\rceil \\cdot 2^{-\\lambda}</span>. If this does not happen, calling <span class="math">\\mathbf{v}^<em></span> the vector sent by a malicious prover, either <span class="math">\\mathbf{v}^</em> \\in V^{H_0&#x27;}</span> or the verifier rejects. In the first case <span class="math">\\mathbf{v} \\neq \\mathbf{v}^*</span> so the relation tested is not satisfied and the verifier reject with probability <span class="math">\\lambda q^{-1}</span>. Finally, for Zero Knowledge the vector $\\widehat{f}_{h+1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_0'}<span class="math"> is uniform in </span>V^{H_0'}<span class="math"> and so is </span>\\mathbf{v}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As <span class="math">\\widehat{f}</span> has degree $\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1 + \\lambda<span class="math">, if the malicious verifier queries positions in </span>Q<span class="math"> with </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; \\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1<span class="math"> a simulator can reply to those queries with random field elements and send a uniform </span>\\mathbf{v}<span class="math">. If the number of queries ever reaches </span>\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> the verifier can query </span>f_{1},\\ldots ,f_{h}<span class="math"> in </span>\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> points and interpolate. In particular, it can compute </span>\\mathbf{y} = \\sum_{i = 1}^{h}M_{i}\\widehat{f}_{i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{i}} - \\mathbf{v}\\in V^{H_{0}^{\\prime}}<span class="math"> and find a </span>\\widehat{g}<span class="math"> that agrees on </span>Q<span class="math"> with </span>\\widehat{f}_{h + 1}<span class="math"> and such that </span>\\widehat{g}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_0^{\\prime}} = \\mathbf{y}<span class="math">. Replacing </span>g<span class="math"> with </span>f_{h + 1}$ allows the simulator to keep replies consistent.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-14" class="text-2xl font-bold">3.4 An RS-encoded IOP for R1CS from Modular Lincheck</h2>

    <p class="text-gray-300">Given RS-encoded IOPPs for Modular Lincheck and Rowcheck, we show how to construct an RS-encoded IOP for the R1CS relation over <span class="math">\\mathbb{F}_2</span>. From Theorem 1 we know that a given R1CS <span class="math">A_1, A_2, A_3, \\mathbf{b}</span> over <span class="math">\\mathbb{F}_2</span> is satisfiable if and only if there exist <span class="math">\\widetilde{\\mathbf{x}}_1, \\widetilde{\\mathbf{x}}_2, \\widetilde{\\mathbf{x}}_3, \\mathbf{t} \\in \\mathbb{F}_q^{m/k}</span> and <span class="math">\\widetilde{\\mathbf{w}} \\in \\mathbb{F}_q^{n/k}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{t} = \\widetilde{\\mathbf{x}}_1 * \\widetilde{\\mathbf{x}}_2</span></div>

    <div class="my-4 text-center"><span class="math-block">\\widetilde{\\mathbf{w}} = \\mathbf{0} \\quad \\mod (\\operatorname{Im} \\varphi)^{n/k}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\widetilde{\\mathbf{x}}_i = \\mathbf{0} \\quad \\mod (\\operatorname{Im} \\varphi)^{m/k} \\quad \\text{for } i = 1, 2, 3</span></div>

    <div class="my-4 text-center"><span class="math-block">\\widetilde{A}_i \\widetilde{\\mathbf{w}} - \\widetilde{I}_m \\widetilde{\\mathbf{x}}_i = \\mathbf{0} \\quad \\mod (\\operatorname{Ker} S \\circ \\psi)^m \\quad \\text{for } i = 1, 2, 3</span></div>

    <div class="my-4 text-center"><span class="math-block">I_{m/k} \\mathbf{t} - u I_{m/k} \\widetilde{\\mathbf{x}}_3 = u \\widetilde{\\mathbf{b}} \\quad \\mod (\\operatorname{Ker} \\psi)^{m/k}</span></div>

    <p class="text-gray-300">where we recall that <span class="math">\\widetilde{A}_i</span> and <span class="math">\\widetilde{I}_m</span> are obtained applying <span class="math">\\Phi</span> to <span class="math">A_i</span> and <span class="math">I_m</span> row-wise respectively and <span class="math">\\widetilde{\\mathbf{b}} = \\Phi(\\mathbf{b})</span>. In Protocol 2 we split the proof in the parallel</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">execution of a Rowcheck to test the first condition and 8 Modular Linchecks to test the other equations. To do this we fix three  <span class="math">\\mathbb{F}_2</span> -affine spaces  <span class="math">H_0, H_1, H_2 \\subseteq \\mathbb{F}_q</span>  such that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= m<span class="math"> ,  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= m / k<span class="math"> ,  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n / k<span class="math">  and an affine space  </span>L \\subseteq \\mathbb{F}_q<span class="math">  disjoint from the previous ones. Then, given a witness  </span>\\mathbf{w}<span class="math">  for the R1CS, we encode  </span>\\widetilde{\\mathbf{x}}_i = \\varPhi(A_i\\mathbf{w})<span class="math">  and  </span>\\mathbf{t} = \\widetilde{\\mathbf{x}}_1 * \\widetilde{\\mathbf{x}}_2<span class="math">  in codewords  </span>f_{\\widetilde{\\mathbf{x}}_i}, f_{\\mathbf{t}}<span class="math">  over  </span>H_1<span class="math">  and  </span>\\widetilde{\\mathbf{w}} = \\varPhi(\\mathbf{w})<span class="math">  in  </span>f_{\\widetilde{\\mathbf{w}}}<span class="math">  over  </span>H_2<span class="math"> , i.e., such that  </span>\\widehat{f}_{\\widetilde{\\mathbf{x}}_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_1} = \\widetilde{\\mathbf{x}}_i<span class="math"> ,  </span>\\widehat{f}_{\\mathbf{t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_1} = \\mathbf{t}<span class="math">  and  </span>\\widehat{f}_{\\widetilde{\\mathbf{w}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_2} = \\widetilde{\\mathbf{w}}<span class="math"> . These codewords are sent and used as oracles in the respective sub-protocol. To obtain Zero Knowledge against  </span>\\beta<span class="math">  queries we fix the rate of  </span>f_{\\widetilde{\\mathbf{x}}_i}, f_{\\mathbf{t}}<span class="math">  to  </span>\\frac{m / k + \\beta}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  and the rate of  </span>f_{\\widetilde{\\mathbf{w}}}<span class="math">  to  </span>\\frac{n / k + \\beta}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PR1CS(Fq,m,n,A1,A2,A3,b,w)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">VR1CS(Fq,m,n,A1,A2,A3,b)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">u := φ(1k), m' := m/k, n' := n/k</td>

            <td class="px-3 py-2 border-b border-gray-700">Compute u, m', n'</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ρ1 := (m' + β)/</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">, ρ2 := (n' + β)/</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ1 := (m' + β)/</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">I_m ← (Φ(e_j)^T)_{j=1}^m</td>

            <td class="px-3 py-2 border-b border-gray-700">I_m ← (Φ(e_j)^T)_{j=1}^m</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Parse A_i = (a_i^T)_{j=1}^m</td>

            <td class="px-3 py-2 border-b border-gray-700">Parse A_i = (a_i^T)_{j=1}^m</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">A_i ← (Φ(a_i,j)^T)_{j=1}^m</td>

            <td class="px-3 py-2 border-b border-gray-700">A_i ← (Φ(a_i,j)^T)_{j=1}^m</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">b ← Φ(b)</td>

            <td class="px-3 py-2 border-b border-gray-700">b ← Φ(b)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  x_i ← A_i w, t ← Φ(x_1) * Φ(x_2) |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_w ←^$ {f ∈ RS_L,ρ2 : f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H2 = Φ(w)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">f_t ←^$ {f ∈ RS_L,ρ1 : f</td>

            <td class="px-3 py-2 border-b border-gray-700">H1 = t}</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  f_w, f_{\\widetilde{x}_i}, f_t  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Run:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Run:</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PMlin2(Im', -uIm', u\\widetilde{b}, Ker ψ, f_t, f_{\\widetilde{x}_3})</td>

            <td class="px-3 py-2 border-b border-gray-700">Vt,f_{\\widetilde{x}_3}Mlin2(Im', -uIm', u\\widetilde{b}, Ker ψ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PMlin1(In', 0, Im φ, f_{\\widetilde{w}})</td>

            <td class="px-3 py-2 border-b border-gray-700">Vf_{\\widetilde{w}}Mlin1(In', 0, Im φ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Run for all i ∈ {1,2,3}:</td>

            <td class="px-3 py-2 border-b border-gray-700">Run for all i ∈ {1,2,3}:</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PMlin1(Im', 0, Im φ, f_{\\widetilde{x}_i})</td>

            <td class="px-3 py-2 border-b border-gray-700">Vf_{\\widetilde{x}_i}Mlin1(Im', 0, Im φ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PMlin2(A_i, I_m, 0, Ker S o ψ, f_{\\widetilde{w}}, f_{\\widetilde{x}_i})</td>

            <td class="px-3 py-2 border-b border-gray-700">Vf_{\\widetilde{w},f_{\\widetilde{x}_i}}Mlin2(A_i, I_m, 0, Ker S o ψ)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 2. RS-encoded IOP for R1CS. Fixed a linear order on  <span class="math">H_0, H_1, H_2</span>  we assume  <span class="math">\\widetilde{A}_i \\in \\mathbb{F}_q^{H_0 \\times H_2}</span> ,  <span class="math">\\widetilde{I}_m \\in \\mathbb{F}_q^{H_0 \\times H_1}</span> ,  <span class="math">I_{m&#x27;} \\in \\mathbb{F}_q^{H_1 \\times H_1}</span>  and  <span class="math">I_{n&#x27;} \\in \\mathbb{F}_q^{H_2 \\times H_2}</span> . The first three steps can be preprocessed knowing the input size.</p>

    <p class="text-gray-300">Theorem 3. Protocol 2 is an RS-encoded IOP for the relation <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}</span> with the following parameters</p>

    <p class="text-gray-300">Rounds = 3</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof Length = $24</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Randomness = <span class="math">8\\lambda + 16\\log q</span></p>

    <p class="text-gray-300">Soundness = <span class="math">\\max(\\lceil m / \\lambda \\rceil, \\lceil n / k\\lambda \\rceil) \\cdot 2^{-\\lambda} + \\lambda q^{-1}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover Time = $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log (n + m) + \\sum_{i=1}^{3} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{b}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) + 56 \\cdot \\mathrm{FFT}(\\mathbb{F}_q,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier Time = $O\\left(\\sum_{i=1}^{3} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{b}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ n + m\\right)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Max Rates = $\\left(\\frac{\\max(m / k, n / k, \\lambda) + 2\\beta}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}, \\frac{2\\max(m / k, n / k, \\lambda) + 2\\beta + \\lambda}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof sketch. Completeness follows as by Theorem 1 all the statements tested with the sub protocols are true. For soundness, if the given R1CS is not satisfiable, again by Theorem 1 at least one of the statements tested is false and acceptance probability is upper bounded by the maximum soundness error of these tests. Finally Zero-Knowledge against <span class="math">\\beta</span> queries follows as <span class="math">f_{\\widetilde{\\mathbf{x}}_i}, f_{\\mathbf{t}}</span> are evaluations over <span class="math">L</span> of random polynomials of degree <span class="math">m / k + \\beta</span> encoding respectively <span class="math">\\widetilde{\\mathbf{x}}_i, \\mathbf{t} \\in \\mathbb{F}_q^{H_1}</span>. By polynomial interpolation, if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta<span class="math">, then </span>\\widehat{f}_{\\widetilde{\\mathbf{x}}_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q}<span class="math"> and </span>\\widehat{f}_{\\mathbf{t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q}<span class="math"> are uniform over </span>\\mathbb{F}_q^Q<span class="math">. Therefore replies to these queries can be simulated with random field elements. The same argument applies to </span>f_{\\widetilde{\\mathbf{w}}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-15" class="text-2xl font-bold">4 Efficient Construction</h2>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">4.1 Batching Modular Linchecks</h3>

    <p class="text-gray-300">The main efficiency loss in Protocol 2 comes from the parallel execution of 8 modular Linchecks, which affects both time and communication complexity. Regarding the latter, observe that in each execution a vector in <span class="math">\\mathbb{F}_q^\\lambda</span> is sent, which for concrete parameters like <span class="math">\\lambda = 128</span> and <span class="math">q = 2^{192}</span> translates to a overhead of roughly 24KB total overhead. In this section we show how to reduce the number of required modular linchecks to three, by batching proofs of relations modulo the same vector space.</p>

    <p class="text-gray-300">More in detail assume a sequence of matrices <span class="math">A_{1},\\ldots ,A_{h}</span> and vectors <span class="math">\\mathbf{b}_1,\\dots ,\\mathbf{b}_h</span> <span class="math">\\mathbf{x}_1,\\ldots ,\\mathbf{x}_h</span> is given. We aim at designing an RS-encoded IOPP for the relation <span class="math">A_{i}\\mathbf{x}_{i} = \\mathbf{b}_{i}\\mod V^{m_{i}}</span> for all <span class="math">i\\in [h]</span>.</p>

    <p class="text-gray-300">Recall that in Section 3.3 the idea for a single equation <span class="math">A\\mathbf{x} = \\mathbf{b} \\mod V^m</span> was to first make the prover commit to a masking term <span class="math">\\mathbf{y}</span>, then let the verifier choose an <span class="math">\\mathbb{F}_2</span> linear map <span class="math">R_{\\alpha}</span> and finally have the prover send <span class="math">\\mathbf{v} = R_{\\alpha}(A\\mathbf{x} - \\mathbf{b}) + \\mathbf{y}</span> whose correctness can be tested through a standard linear check.</p>

    <p class="text-gray-300">For the general case we propose a similar solution. As before the prover begins by sending a codeword that encodes a masking term <span class="math">\\mathbf{y} \\sim U(V^{\\lambda})</span>. The verifier then chooses <span class="math">h</span> matrices <span class="math">R_{\\alpha_1}, \\ldots, R_{\\alpha_h}</span> and the prover replies by sending</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {v} = \\sum_ {i = 1} ^ {h} R _ {\\alpha_ {i}} \\left(A _ {i} \\mathbf {x} _ {i} - \\mathbf {b} _ {i}\\right) + \\mathbf {y}.</span></div>

    <p class="text-gray-300">Finally the verifier checks if <span class="math">\\mathbf{v} \\in V^{\\lambda}</span> and both parties execute a lincheck to test the above relation.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Informally (for details we refer to the proof of Theorem 4) this protocol is complete because if <span class="math">A_{i}\\mathbf{x}_{i} - \\mathbf{b}_{i} \\in V^{m_{i}}</span> then applying <span class="math">R_{\\alpha_{i}}</span> the result lies in <span class="math">V^{\\lambda}</span>, which implies <span class="math">\\mathbf{v} \\in V^{\\lambda}</span>. Soundness follows by Proposition 3 which says that if at least one of the relations is not satisfied then with high probability <span class="math">\\sum_{i=1}^{h} R_{\\alpha_{i}}(A_{i}\\mathbf{x}_{i} - \\mathbf{b}_{i}) + \\mathbf{y} \\notin V^{\\lambda}</span> and in this case either <span class="math">\\mathbf{v}</span> is not in the right space or the relation tested with the lincheck does not hold. Finally Zero Knowledge against unbounded queries is proven as in Theorem 2 as long as the codeword encoding <span class="math">\\mathbf{y}</span> has rate $(\\rho + \\lambda)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-1}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-17" class="text-2xl font-bold">4.2 Packing Vectors</h2>

    <p class="text-gray-300">To further improve Protocol 2 we show how to reduce the size of vectors sent in plain by the prover in the (batched) modular lincheck. The key observation is that all those vectors should have entries in <span class="math">\\operatorname{Im}\\varphi</span>, <span class="math">\\operatorname{Ker}S\\circ \\psi</span> or <span class="math">\\operatorname{Ker}\\psi</span> whose dimensions over <span class="math">\\mathbb{F}_2</span> are respectively <span class="math">k</span>, <span class="math">\\log q - 1</span> and <span class="math">\\log q - k</span>. Therefore fixing a base for each of these spaces it is possible to replace each component with its base representation, which requires less than <span class="math">\\log q</span> bits. We take a slightly different approach to perform this conversion more efficiently by using the properties of the RMFE.</p>

    <p class="text-gray-300">First recalling <span class="math">u = \\varphi(\\mathbf{1}_k)</span> we point out <span class="math">\\mathrm{Ker}\\psi</span> and <span class="math">u\\cdot \\mathrm{Im}\\varphi</span> intersect only in 0, because <span class="math">\\psi (u\\cdot \\varphi (\\mathbf{v})) = \\mathbf{1}_k*\\mathbf{v} = \\mathbf{v}</span>, and have dimension <span class="math">\\log q - k</span> and <span class="math">k</span> respectively. Therefore <span class="math">\\mathbb{F}_q = (u\\cdot \\mathrm{Im}\\varphi)\\oplus \\mathrm{Ker}\\psi</span>. The idea is then, given <span class="math">\\mathbf{x}\\in (\\mathrm{Im}\\varphi)^n</span> and <span class="math">\\mathbf{y}\\in (\\mathrm{Ker}\\psi)^n</span>, to only send <span class="math">\\mathbf{z} = u\\mathbf{x} + \\mathbf{y}</span>. Since <span class="math">\\mathbb{F}_q = (u\\cdot \\mathrm{Im}\\varphi)\\oplus \\mathrm{Ker}\\psi</span>, it is possible with simple linear algebra to extract <span class="math">\\mathbf{x}</span> and <span class="math">\\mathbf{y}</span> from <span class="math">\\mathbf{z}</span>. This can be also done efficiently. Calling <span class="math">\\mathbf{v}\\in \\mathbb{F}_2^{kn}</span> such that <span class="math">\\mathbf{x} = \\varPhi(\\mathbf{v})</span> we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\Phi (\\Psi (\\mathbf {z})) = \\Phi (\\Psi (u \\mathbf {x} + \\mathbf {y})) = \\Phi (\\Psi (u \\cdot \\Phi (\\mathbf {v}))) = \\Phi (\\mathbf {v}) = \\mathbf {x}</span></div>

    <p class="text-gray-300">where the second equality follows as <span class="math">\\mathbf{y} \\in (\\mathrm{Ker}\\psi)^n</span> and the third one from Lemma 1. Thus we can efficiently recover <span class="math">\\mathbf{x}</span> and consequently set <span class="math">\\mathbf{y} = \\mathbf{z} - u\\mathbf{x}</span>. We summarize the discussion above in the following Lemma</p>

    <p class="text-gray-300"><strong>Lemma 3.</strong> Given <span class="math">(\\varphi, \\psi)</span> a <span class="math">(k, e)_2</span>-RMFE, <span class="math">q = 2^e</span>, and calling <span class="math">u = \\varphi(\\mathbf{1}_k)</span>, the maps</p>

    <div class="my-4 text-center"><span class="math-block">\\eta : (\\operatorname {I m} \\varphi) ^ {n} \\oplus (\\operatorname {K e r} \\psi) ^ {n} \\rightarrow \\mathbb {F} _ {q} ^ {n} \\quad : \\quad \\eta (\\mathbf {x}, \\mathbf {y}) = u \\mathbf {x} + \\mathbf {y},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\eta^ {\\prime}: \\mathbb {F} _ {q} ^ {n} \\rightarrow (\\operatorname {I m} \\varphi) ^ {n} \\oplus (\\operatorname {K e r} \\psi) ^ {n} \\quad : \\quad \\eta^ {\\prime} (\\mathbf {z}) = (\\Phi \\circ \\Psi (\\mathbf {z}), \\mathbf {z} - u \\cdot \\Phi \\circ \\Psi (\\mathbf {z}))</span></div>

    <p class="text-gray-300">are isomorphisms and <span class="math">\\eta&#x27; = \\eta^{-1}</span>.</p>

    <h2 id="sec-18" class="text-2xl font-bold">4.3 An Efficient RS-encoded IOP for R1CS</h2>

    <p class="text-gray-300">We now use the ideas presented so far to improve the RS-encoded IOP of Section 3.4. We batch the 8 modular linchecks in three groups testing linear conditions</p>

    <p class="text-gray-300">17</p>

    <p class="text-gray-300">modulo <span class="math">\\operatorname{Im}\\varphi</span>, <span class="math">\\operatorname{Ker}S\\circ\\psi</span> and <span class="math">\\operatorname{Ker}\\psi</span> as shown in Section 4.1. This is further optimised by sending only two (instead of three) vectors, as detailed in the previous section. Moreover, instead of providing oracle access to three masking codewords in the first round, one for each (batched) modular lincheck, we only send one that encodes three masking terms over disjoint affine spaces <span class="math">H_1&#x27;, H_2&#x27;, H_3&#x27;</span>. More formally we define the set of masking codewords <span class="math">\\mathsf{BMask}(L,\\rho,H_1&#x27;,H_2&#x27;,H_3&#x27;,\\varphi,\\psi)</span> as</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{f \\in \\mathsf{RS}_{L,\\rho} : \\widehat{f}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_1'} \\in (\\operatorname{Im}\\varphi)^{H_1'}, \\widehat{f}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_2'} \\in (\\operatorname{Ker}S\\circ\\psi)^{H_2'}, \\widehat{f}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_3'} \\in (\\operatorname{Ker}\\psi)^{H_3'} \\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For this reason in the construction below we assume that <span class="math">H_1&#x27;, H_2&#x27;, H_3&#x27;, H_0, H_1, H_2 \\subseteq \\mathbb{F}_q</span> are affine subspaces such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_i'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\lambda<span class="math">, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= m<span class="math">, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= m/k<span class="math">, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n/k<span class="math">, </span>H_1', H_2', H_3'<span class="math"> are disjoint and </span>L \\subseteq \\mathbb{F}_q<span class="math"> is an affine subspace disjoint from the others. Moreover for ease of notation we call </span>\\rho_1 = (m/k + \\beta)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-1}<span class="math">, </span>\\rho_2 = (n/k + \\beta)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-1}<span class="math"> and </span>\\rho_3 = (3\\lambda + \\beta)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-1}$ the three rates used across the protocol.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Theorem 4.</strong> Protocol 3 is an RS-encoded IOP for the relation <span class="math">\\mathcal{R}_{\\mathsf{RICS}}</span> with the following parameters</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\text{Rounds} = 3 \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{Proof Length} = 8</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\text{Randomness} = 8\\lambda + 5\\log q \\\\ \\text{Soundness} = \\max(\\lceil m/\\lambda \\rceil, \\lceil n/k\\lambda \\rceil) \\cdot 2^{-\\lambda} + \\lambda q^{-1} \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{Prover Time} = O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log(m + n) + \\sum_{i=1}^{3} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{b}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) + 35 \\cdot \\mathrm{FFT}(\\mathbb{F}_q,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\text{Max Rates} = \\left(\\frac{\\max(m/k, n/k, 3\\lambda) + 2\\beta}{</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">}, \\frac{\\max(2m/k, 2n/k, 3\\lambda) + 2\\beta}{</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">}\\right) \\\\</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300"><strong>Proof.</strong> <strong>Completeness</strong> A tuple in <span class="math">\\mathcal{R}_{\\mathsf{RICS}}</span> satisfies conditions 1-5 in Theorem 1. This already implies that the rowcheck always passes by condition 1.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next we show that <span class="math">\\mathbf{v}_1 \\in (\\operatorname{Im}\\varphi)^{H_1&#x27;}</span>, <span class="math">\\mathbf{v}_2 \\in (\\operatorname{Ker}S \\circ \\psi)^{H_2&#x27;}</span> and <span class="math">\\mathbf{v}_3 \\in (\\operatorname{Ker}\\psi)^{H_3&#x27;}</span>. For ease of notation we call $\\mathbf{y}_i = \\widehat{g}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_i'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> for </span>i = 1,2,3$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By conditions 2 and 3 we have <span class="math">\\widetilde{\\mathbf{x}}_i \\in (\\operatorname{Im}\\varphi)^{H_1}</span> and <span class="math">\\widetilde{\\mathbf{w}} \\in (\\operatorname{Im}\\varphi)^{H_2}</span>. Since <span class="math">R_{\\alpha_i}</span> has all its entries in <span class="math">\\mathbb{F}_2</span> it preserves <span class="math">\\mathbb{F}_2</span>-linear subspaces and in particular <span class="math">R_{\\alpha_i}\\widetilde{\\mathbf{x}}_i, R_{\\alpha_4}\\widetilde{\\mathbf{w}} \\in (\\operatorname{Im}\\varphi)^{H_1&#x27;}</span>. On the other side <span class="math">\\mathbf{y}_1</span> lies in the same space, therefore the sum of all these terms <span class="math">\\mathbf{v}_1</span> lies in <span class="math">(\\operatorname{Im}\\varphi)^{H_1&#x27;}</span>.</li>

      <li>By condition 4 we have <span class="math">\\widetilde{A}_i\\widetilde{\\mathbf{w}} - \\widetilde{I}_m\\widetilde{\\mathbf{x}}_i \\in (\\mathrm{Ker}S \\circ \\psi)^{H_0}</span>. Since <span class="math">R_{\\gamma_i}</span> is <span class="math">\\mathbb{F}_2</span>-linear, <span class="math">R_{\\gamma_i}(\\widetilde{A}_i\\widetilde{\\mathbf{w}} - \\widetilde{I}_m\\widetilde{\\mathbf{x}}_i)</span> lies in <span class="math">(\\mathrm{Ker}S \\circ \\psi)^{H_2&#x27;}</span>. Hence <span class="math">\\mathbf{v}_2</span> lies in this vector space as well because all its terms do.</li>

      <li>By 5 we have <span class="math">\\mathbf{t} - u(\\widetilde{\\mathbf{x}}_3 + \\widetilde{\\mathbf{b}}) \\in (\\mathrm{Ker}\\psi)^{H_1}</span> and in particular <span class="math">R_{\\delta}(\\mathbf{t} - u(\\widetilde{\\mathbf{x}}_3 + \\widetilde{\\mathbf{b}})) \\in (\\mathrm{Ker}\\psi)^{H_3&#x27;}</span>. As <span class="math">\\mathbf{y}_3</span> belongs by construction to the same space, <span class="math">\\mathbf{v}_3 \\in (\\mathrm{Ker}\\psi)^{H_3&#x27;}</span>.</li>

    </ul>

    <p class="text-gray-300">18</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PR1CS(Fq,m,n,A1,A2,A3,b,w)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">VR1CS(Fq,m,n,A1,A2,A3,b)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">u := φ(1k)</td>

            <td class="px-3 py-2 border-b border-gray-700">u := φ(1k)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  g ←$ BMask (L,ρ3,H1',H2',H3',φ,ψ) |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I_m ← (Φ(e_j)^T)^m_j=1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I_m ← (Φ(e_j)^T)^m_j=1</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">b ← Φ(b), w ← Φ(w)</td>

            <td class="px-3 py-2 border-b border-gray-700">b ← Φ(b)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  x̅i ← Φ(A_i w), t ← x̅1 * x̅2 |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_w ← $ {f ∈ RS_L,ρ2 : f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H2 = w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">f_t ← $ {f ∈ RS_L,ρ1 : f</td>

            <td class="px-3 py-2 border-b border-gray-700">H1 = t}</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | f_w, f_x̅i, f_t, g  |</p>

    <p class="text-gray-300">|   | (αi)i=1 ← $ F2λ  |</p>

    <p class="text-gray-300">|   | (γi)i=1 ← <span class="math"> F2λ, δ ← </span> F2λ  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M1 ← (Rαi, Iλ)i=1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Compute M1</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">M3 ← (Rδ, -uRδ, Iλ)</td>

            <td class="px-3 py-2 border-b border-gray-700">Compute M3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">v1 ← ∑i=13 Rαi x̅i + Rα4 w̅ + g</td>

            <td class="px-3 py-2 border-b border-gray-700">H1'</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">v2 ← ∑i=13 Rγi (A̅i w̅ - I̅m x̅i) + g</td>

            <td class="px-3 py-2 border-b border-gray-700">H2'</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">v3 ← Rδt - uRδ (x̅3 + b̅) + g</td>

            <td class="px-3 py-2 border-b border-gray-700">H3'</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">v0 ← v3 + uv1</td>

            <td class="px-3 py-2 border-b border-gray-700">v0, v2</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | If v2∉ (Ker S ∘ ψ)H0'  |</p>

    <p class="text-gray-300">|   | Return ⊥  |</p>

    <p class="text-gray-300">|   | v1' ← Φ(Ψ(v0))  |</p>

    <p class="text-gray-300">|   | v3' ← v0 - uv1  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Run: PLin5(M1, v1, (f_x̅i)i=1, f_w, g)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Run: V(Lin5)(f_x̅i)i=1, f_w, g(M1, v1')</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PLin3(M3, uRδ b̅ + v3, f_t, f_x̅3, g)</td>

            <td class="px-3 py-2 border-b border-gray-700">V(Lin3)(f_t, f_x̅3, g(M3, uRδ b̅ + v3')</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PRow(Fq, L, H1, ρ1, f_x̅1, f_x̅2, f_t)</td>

            <td class="px-3 py-2 border-b border-gray-700">V(Row)(f_x̅1, f_x̅2, f_t(Fq, L, H1, ρ1)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 3. RS-encoded IOP for R1CS. Fixed a linear order on  <span class="math">H_0, H_1, H_2</span>  we assume  <span class="math">\\widetilde{A}_i \\in \\mathbb{F}_q^{H_0 \\times H_2}</span> ,  <span class="math">\\widetilde{I}_m \\in \\mathbb{F}_q^{H_0 \\times H_1}</span> . The first three steps can be precomputed knowing the input size.</p>

    <p class="text-gray-300">Consequently the verifier does not halt after testing <span class="math">\\mathbf{v}_2</span> and, from Lemma 3, <span class="math">\\mathbf{v}_1&#x27; = \\mathbf{v}_1</span> and <span class="math">\\mathbf{v}_3&#x27; = \\mathbf{v}_3</span>. Finally this implies that the three linchecks return accepting constraints because the tested linear relations are satisfied by construction.</p>

    <p class="text-gray-300"><strong>Soundness</strong>: Given an unsatisfiable R1CS and a malicious <span class="math">\\widetilde{\\mathbf{P}}</span>, let the codewords sent in the first round <span class="math">f_{\\widetilde{\\mathbf{w}}}, f_{\\widetilde{\\mathbf{x}}_i}, f_{\\mathbf{t}}, g</span> encode respectively <span class="math">\\widetilde{\\mathbf{w}}, \\widetilde{\\mathbf{x}}_i, \\mathbf{t}, \\mathbf{y}_i</span> and call <span class="math">\\mathbf{v}_1 = \\mathbf{v}_1&#x27;</span>, <span class="math">\\mathbf{v}_3 = \\mathbf{v}_3&#x27;</span>. By Theorem 1, since the R1CS system is not satisfiable, at least one of the following cases occurs:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{t} \\neq \\widetilde{\\mathbf{x}}_1 * \\widetilde{\\mathbf{x}}_2</span>, which implies that the rowcheck returns a non-satisfiable constraint.</li>

      <li><span class="math">\\widetilde{\\mathbf{x}}_i \\notin (\\operatorname{Im} \\varphi)^{H_1}</span> or <span class="math">\\widetilde{\\mathbf{w}} \\notin (\\operatorname{Im} \\varphi)^{H_2}</span>. Since <span class="math">\\mathbf{y}_1</span> is independent from <span class="math">\\alpha_i \\sim U(\\mathbb{F}_{2^{\\lambda}})</span> for <span class="math">i \\in [4]</span>, by Proposition 3</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\sum_{i=1}^{3} R_{\\alpha_i} \\widetilde{\\mathbf{x}}_i + R_{\\alpha_4} \\widetilde{\\mathbf{w}} + \\mathbf{y}_1 \\in (\\operatorname{Im} \\varphi)^{H_1&#x27;} \\right] \\leq \\left\\lceil \\frac{\\max(m,n)}{k\\lambda} \\right\\rceil \\frac{1}{2^{\\lambda}}.</span></div>

    <p class="text-gray-300">If the above event does not happen, observing that <span class="math">\\mathbf{v}_1 \\in (\\operatorname{Im} \\varphi)^{H_0&#x27;}</span> by construction, the relation tested by the first lincheck is not satisfied and the verifier accepts with probability smaller than <span class="math">\\lambda q^{-1}</span>. By a union bound the proof is accepted with probability smaller than</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\lceil \\frac{\\max(m,n)}{k\\lambda} \\right\\rceil \\frac{1}{2^{\\lambda}} + \\frac{\\lambda}{q} \\leq \\frac{\\max(\\lceil m/\\lambda \\rceil, \\lceil n/k\\lambda \\rceil)}{2^{\\lambda}} + \\frac{\\lambda}{q}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For some <span class="math">i \\in \\{1,2,3\\}</span>, <span class="math">\\widetilde{A}_i \\widetilde{\\mathbf{w}} - \\widetilde{I}_m \\widetilde{\\mathbf{x}}_i \\notin (\\mathrm{Ker} S \\circ \\psi)^{H_0}</span>. Since <span class="math">\\gamma_1, \\gamma_2, \\gamma_3 \\sim U(\\mathbb{F}_{2^{\\lambda}})</span> are distributed independently from <span class="math">\\mathbf{y}_2</span>, by Proposition 3</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\sum_{i=1}^{3} R_{\\alpha_i} (\\widetilde{A}_i \\widetilde{\\mathbf{w}} - \\widetilde{I}_m \\widetilde{\\mathbf{x}}_i) + \\mathbf{y}_2 \\in (\\mathrm{Ker} S \\circ \\psi)^{H_2&#x27;} \\right] \\leq \\frac{\\lceil m/\\lambda \\rceil}{2^{-\\lambda}}.</span></div>

    <p class="text-gray-300">Assume that event above does not occur. Either <span class="math">\\mathbf{v}_2 \\notin (\\mathrm{Ker} S \\circ \\psi)^{H_0&#x27;}</span>, in which case the verifier always rejects, or <span class="math">\\mathbf{v}_2 \\in (\\mathrm{Ker} S \\circ \\psi)^{H_2&#x27;}</span> which implies that the statement proved through the second lincheck does not hold. Therefore the verifier accepts in this case with probability smaller than <span class="math">\\lambda q^{-1}</span>. With a union bound the soundness error is at most</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{\\lceil m/\\lambda \\rceil}{2^{-\\lambda}} + \\frac{\\lambda}{q} \\leq \\frac{\\max(\\lceil m/\\lambda \\rceil, \\lceil n/k\\lambda \\rceil)}{2^{\\lambda}} + \\frac{\\lambda}{q}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{t} - u(\\widetilde{\\mathbf{x}} + \\widetilde{\\mathbf{b}}) \\notin (\\mathrm{Ker} \\psi)^{H_1}</span>. Once again, since <span class="math">\\delta</span> is independent from <span class="math">\\mathbf{y}_3</span> we have by Proposition 2 that <span class="math">\\Pr \\left[R_{\\delta}(\\mathbf{t} - u \\widetilde{\\mathbf{x}}_3 - u \\widetilde{\\mathbf{b}}) + \\mathbf{y}_3 \\in (\\mathrm{Ker} \\psi)^{H_2&#x27;} \\right]</span> is smaller than <span class="math">\\lceil m/k\\lambda \\rceil \\cdot 2^{-\\lambda}</span>. Assuming that this event does not occur, we first observe that <span class="math">\\mathbf{v}_3</span> have entries in the kernel of <span class="math">\\psi</span> because</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Psi(\\mathbf{v}_3) = \\Psi(\\mathbf{v}_0 - u \\cdot \\Phi \\circ \\Psi(\\mathbf{v}_0)) \\\\ = \\Psi(\\mathbf{v}_0) - \\Psi(u \\cdot \\Phi(\\Psi(\\mathbf{v}_0))) \\\\ = \\Psi(\\mathbf{v}_0) - \\Psi(\\mathbf{v}_0) = \\mathbf{0}. \\end{array}</span></div>

    <p class="text-gray-300">20</p>

    <p class="text-gray-300">As a consequence  <span class="math">R_{\\delta}(\\mathbf{t} - u\\widetilde{\\mathbf{x}}_3 - u\\widetilde{\\mathbf{b}}) + \\mathbf{y}_3 \\neq \\mathbf{v}_3</span>  and the last lincheck produces a satisfiable set of constraints with probability smaller than  <span class="math">\\lambda q^{-1}</span> . The soundness error in this case is therefore less than</p>

    <div class="my-4 text-center"><span class="math-block">\\frac {\\lceil m / \\lambda \\rceil}{2 ^ {\\lambda}} + \\frac {\\lambda}{q} \\leq \\frac {\\max (\\lceil m / \\lambda \\rceil , \\lceil n / k \\lambda \\rceil)}{2 ^ {\\lambda}} + \\frac {\\lambda}{q}.</span></div>

    <p class="text-gray-300">Soundness is thus proven.</p>

    <p class="text-gray-300">Zero Knowledge against  <span class="math">\\beta</span>  queries: We detail a simulator  <span class="math">S_{\\text{RICS}}</span>  in Figure 4 keeping the same notation for  <span class="math">\\rho_1, \\rho_2, \\rho_3</span>  and suppressing for clarity part of the public input for the simulated linchecks.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{S}_{\\mathsf{RICS}}(\\mathbb{F}_q,m,n,A_1,A_2,A_3,\\mathbf{b})</span></p>

    <p class="text-gray-300">1: Parse  <span class="math">A_{i} = (\\mathbf{a}_{i,j}^{\\top})_{j = 1}^{m}</span>  and compute  <span class="math">\\widetilde{A}_i\\gets (\\varPhi (\\mathbf{a}_{i,j})^\\top)_{j = 1}^m</span> <span class="math">\\widetilde{I}_m\\gets (\\varPhi (\\mathbf{e}_j)^\\top)_{j = 1}^m</span> 2: Set  <span class="math">u \\gets \\varphi(\\mathbf{1}_k)</span> ,  <span class="math">\\widetilde{\\mathbf{b}} \\gets \\varPhi(\\mathbf{b})</span>  and sample  <span class="math">f_{\\widetilde{\\mathbf{w}}}^{\\prime}, f_{\\widetilde{\\mathbf{x}}_i}^{\\prime}, f_{\\mathbf{t}}^{\\prime}, g^{\\prime} \\gets {}^{8}\\mathbb{F}_{q}^{L}</span>  for  <span class="math">i \\in \\{1, 2, 3\\}</span> 3: Give  <span class="math">\\widetilde{\\mathbf{V}}</span>  oracle access to  <span class="math">f_{\\widetilde{\\mathbf{w}}}^{\\prime}, f_{\\widetilde{\\mathbf{x}}_i}^{\\prime}, f_{\\mathbf{t}}^{\\prime}, g^{\\prime}</span> 4: When  <span class="math">(\\alpha_{i},\\gamma_{i},\\delta)_{i = 1}^{3}\\gets \\widetilde{\\mathbf{V}}</span> 5: Sample  <span class="math">\\mathbf{v}_0^{\\prime}\\gets^{8}\\mathbb{F}_{q}^{\\lambda}</span>  and  <span class="math">\\mathbf{v}_2^\\prime \\gets^8 (\\mathrm{Ker}S\\circ \\psi)^{H_2^\\prime}</span> 6: Compute  <span class="math">\\mathbf{v}_1&#x27; \\gets \\varPhi(\\varPsi(\\mathbf{v}_0&#x27;))</span> ,  <span class="math">\\mathbf{v}_3&#x27; \\gets \\mathbf{v}_0&#x27; - u\\mathbf{v}_1&#x27;</span> ,  <span class="math">M_1 \\gets (R_{\\alpha_i}, I_\\lambda)_{i=1}^4</span> 7:  <span class="math">M_2 \\gets (\\sum_{j=1}^{3} R_{\\gamma_j} \\widetilde{A}_j, -R_{\\gamma_i} \\widetilde{I}_m, I_\\lambda)_{i=1}^3</span> ,  <span class="math">M_3 \\gets (R_\\delta, -uR_\\delta, I_\\lambda)</span> 8: Execute: 9:  <span class="math">\\mathsf{S}_{\\mathrm{Lin}_5}^{f_{\\tilde{\\mathbf{x}}_1}&#x27;f_{\\tilde{\\mathbf{x}}_2}&#x27;f_{\\tilde{\\mathbf{x}}_3}&#x27;f_{\\tilde{\\mathbf{w}}}&#x27;,g&#x27;}(\\mathsf{pp}_1&#x27;,M_1,\\mathbf{v}_1&#x27;),</span> 10:  <span class="math">\\mathsf{S}_{\\mathrm{Lin}_5}^{f_{\\tilde{\\mathbf{w}}}^{\\prime},f_{\\tilde{\\mathbf{x}}_1}^{\\prime},f_{\\tilde{\\mathbf{x}}_2}^{\\prime},f_{\\tilde{\\mathbf{x}}_3}^{\\prime},g^{\\prime}}(\\mathsf{pp}_2&#x27;,M_2,\\mathbf{v}_2&#x27;),</span> 11:  <span class="math">\\mathsf{S}_{\\mathrm{Lin}_3}^{f_{\\mathbf{t}}^{\\prime},f_{\\tilde{\\mathbf{x}}_3}^{\\prime},g^{\\prime}}(\\mathsf{pp}_3&#x27;,M_3,uR_{\\delta}\\widetilde{\\mathbf{b}} +\\mathbf{v}_3&#x27;),</span> 12:  <span class="math">\\mathsf{S}_{\\mathrm{Row}}^{f_{\\tilde{\\mathbf{w}}_1}&#x27;f_{\\tilde{\\mathbf{w}}_2}&#x27;f_{\\tilde{\\mathbf{t}}}&#x27;}(\\mathbb{F}_q,L,H_1,\\rho_1)</span></p>

    <p class="text-gray-300">Fig. 4. Description of zero knowledge simulator  <span class="math">S_{\\text{RICS}}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">First of all observe that in the real execution for any set  <span class="math">Q \\subseteq L</span>  of size at most  <span class="math">\\beta</span> ,  $\\widehat{f}_{\\widetilde{\\mathbf{w}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q}<span class="math">  is uniform over  </span>\\mathbb{F}_q^Q$ . To show this consider the map</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi : \\{f \\in \\mathsf {R S} _ {L, \\rho_ {2}}: \\widehat {f} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H _ {2}} = \\widetilde {\\mathbf {w}} \\} \\to \\mathbb {F} _ {q} ^ {Q} \\quad : \\quad \\pi (f) = \\widehat {f} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Where we recall  $\\rho_{2} = (n / k + \\beta)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-1}<span class="math"> . This is linear and surjective because for any vector over  </span>\\mathbb{F}_q^Q<span class="math">  by polynomial interpolation there exists a polynomial of degree smaller than  </span>n / k + \\beta<span class="math">  that evaluated over  </span>Q<span class="math">  returns the given vector and over  </span>H_{1}<span class="math">  returns  </span>\\widetilde{\\mathbf{w}}<span class="math"> . The evaluation of this polynomial over  </span>L<span class="math">  is a codeword of rate  </span>\\rho_{2}<span class="math">  whose projection through  </span>\\pi<span class="math">  returns the given vector. Since  </span>f_{\\widetilde{\\mathbf{w}}}$  is uniform</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">over the domain of <span class="math">\\pi</span>, <span class="math">\\pi(f_{\\widetilde{\\mathbf{w}}})</span> is uniform over <span class="math">\\mathbb{F}_q^Q</span>. The same arguments show that for <span class="math">i \\in \\{1,2,3\\}</span> evaluating <span class="math">f_{\\widetilde{\\mathbf{x}}_i}, f_{\\mathbf{t}}</span> over <span class="math">Q</span> returns a uniformly distributed vector of <span class="math">\\mathbb{F}_q^Q</span>.</p>

    <p class="text-gray-300">Regarding <span class="math">g</span>, calling <span class="math">Z = \\mathsf{BMask}(L, \\rho_3, H_1&#x27;, H_2&#x27;, H_3&#x27;, \\varphi, \\psi)</span> and <span class="math">V_1 = \\operatorname{Im} \\varphi</span>, <span class="math">V_2 = \\operatorname{Ker} S \\circ \\psi</span> and <span class="math">V_3 = \\operatorname{Ker} \\psi</span> we define</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi^{\\prime}: Z \\to \\mathbb{F}_q^Q \\times V_1^{vH_1'} \\times V_2^{H_2'} \\times V_3^{H_3'} \\quad : \\quad \\pi^{\\prime}(f) = (\\widehat{f}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q}, \\widehat{f}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_1'}, \\widehat{f}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_2'}, \\widehat{f}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_3'}).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Again this is linear and surjective because given a vector <span class="math">\\mathbf{u} \\in \\mathbb{F}_q^Q</span> and <span class="math">\\mathbf{y}_i \\in V_i^{H_i&#x27;}</span> by polynomial interpolation there exists <span class="math">\\widehat{f}</span> of degree smaller than <span class="math">3\\lambda + \\beta</span> such that $\\widehat{f}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q} = \\mathbf{u}<span class="math"> and </span>\\widehat{f}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_i'} = \\mathbf{y}_i<span class="math">. Evaluating this polynomial over </span>L<span class="math"> defines a codeword of rate </span>\\rho_3<span class="math"> that lies in </span>Z<span class="math"> and whose projection through </span>\\pi'<span class="math"> is </span>(\\mathbf{u}, \\mathbf{y}_1, \\mathbf{y}_2, \\mathbf{y}_3)<span class="math">. Since </span>g<span class="math"> is uniformly sampled from </span>Z<span class="math"> we proved that calling </span>\\mathbf{y}_i = \\widehat{g}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_i'}<span class="math">, the vector </span>(\\widehat{g}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q}, \\mathbf{y}_1, \\mathbf{y}_2, \\mathbf{y}_3)<span class="math"> is uniform over the domain of </span>\\pi<span class="math">. In particular this implies that </span>\\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{v}_3<span class="math"> are uniform over their respective spaces and so is </span>\\mathbf{v}_0 = \\eta(\\mathbf{v}_1, \\mathbf{v}_3)<span class="math"> as </span>\\eta$ is an isomorphism.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Next we study the view with the simulator. Here queries to the given codewords are answered by construction with uniform and mutually independent field elements, <span class="math">\\mathbf{v}_2</span> is uniform over <span class="math">(\\mathrm{Ker}S\\circ \\psi)^{H_2&#x27;}</span> and <span class="math">\\mathbf{v}_0</span> is uniform over <span class="math">\\mathbb{F}_q^\\lambda</span>.</p>

    <p class="text-gray-300">To conclude it is enough to show that the simulators invoked produce the correct view. By definition of Zero Knowledge, this is only guaranteed to happen when the oracles they have access to and the public input belong to the associated relation, which is likely not true in our case because all codewords are random. However calling <span class="math">\\widetilde{\\mathbf{w}},\\widetilde{\\mathbf{x}}_i,\\mathbf{t}</span> the extended witness produced by the honest prover and</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{y}_1 = \\mathbf{v}_1 - \\sum_{i=1}^{3} R_{\\alpha_i} \\widetilde{\\mathbf{x}}_i + R_{\\alpha_4} \\widetilde{\\mathbf{w}}, \\quad \\mathbf{y}_2 = \\mathbf{v}_2 - \\sum_{i=1}^{3} R_{\\gamma_i} (\\widetilde{A}_i \\widetilde{\\mathbf{w}} - \\widetilde{I}_m \\widetilde{\\mathbf{x}}_i),</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{y}_3 = R_{\\delta} \\mathbf{t} - u R_{\\delta} (\\widetilde{\\mathbf{x}}_3 + \\widetilde{\\mathbf{b}})</span></div>

    <p class="text-gray-300">by polynomial interpolation there exist (unique) <span class="math">f_{\\widetilde{\\mathbf{w}}}, f_{\\widetilde{\\mathbf{x}}_i}, f_{\\mathbf{t}}, g</span> encoding respectively <span class="math">\\widetilde{\\mathbf{w}}, \\widetilde{\\mathbf{x}}_i, \\mathbf{t}, \\mathbf{y}_i</span> and agreeing on <span class="math">Q</span> with <span class="math">f_{\\widetilde{\\mathbf{w}}}&#x27;, f_{\\widetilde{\\mathbf{x}}_i}&#x27;, f_{\\mathbf{t}}&#x27;, g&#x27;</span>. Since all the simulators only depend on their oracles' values in <span class="math">Q</span>, their behaviour does not change replacing the random codewords with the correct one. This completes the proof.</p>

    <p class="text-gray-300">Efficiency On the prover side we first list the costs of operations performed before running any subroutine, measured in terms of number of multiplications over <span class="math">\\mathbb{F}_q</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_2\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_3\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ m + \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{b}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> to compute </span>\\widetilde{A}_i, \\widetilde{I}_m, \\widetilde{\\mathbf{b}}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">4m + n + m / k</span> to get <span class="math">\\varPhi(\\mathbf{x}_i),\\varPhi(\\mathbf{w})</span> and <span class="math">\\mathbf{t} = \\varPhi(\\mathbf{x}_1)*\\varPhi(\\mathbf{x}_2)</span></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $12\\cdot \\mathrm{FFT}(\\mathbb{F}_q,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> to sample </span>f_{\\widetilde{\\mathbf{x}}_i},f_{\\widetilde{\\mathbf{w}}},f_{\\mathbf{t}},g<span class="math"> for </span>i\\in 1,2,3$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Nothing to compute <span class="math">M_1</span></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $\\sum_{i=1}^{3} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 3m<span class="math"> for </span>M_2$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\lambda m / k</span> to compute <span class="math">M_3</span></li>

      <li><span class="math">3\\lambda m / k + \\lambda n / k + \\lambda</span> to produce <span class="math">\\mathbf{v}_1</span></li>

    </ul>

    <p class="text-gray-300">22</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\lambda n / k + 3\\lambda m / k</span> to compute <span class="math">\\mathbf{v}_2</span> as it is the sum of <span class="math">(\\sum_{j=1}^{3} R_{\\gamma_j} \\widetilde{A}_j) \\mathbf{w}</span>, <span class="math">R_{\\gamma_j} \\widetilde{I}_m</span> and $\\widehat{g_{2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_0'}}$ where the first matrix was previously computed</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">2\\lambda m / k + m / k + \\lambda</span> to compute <span class="math">\\mathbf{v}_3</span></li>

      <li><span class="math">2\\lambda</span> to get the linear combination <span class="math">\\mathbf{v}_0 = \\mathbf{v}_3 + u\\mathbf{v}_1</span></li>

    </ul>

    <p class="text-gray-300">Next we list the costs of the three linchecks</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $\\lambda + (3\\lambda m / k + \\lambda n / k + \\lambda) + \\lambda + 5</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 10 \\cdot \\mathrm{FFT}(\\mathbb{F}_q,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- $\\lambda + (\\lambda m / k + \\lambda m / k + \\lambda) + \\lambda + 3</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">+ 6 \\cdot \\mathrm{FFT}(\\mathbb{F}_q,</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">)$</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Using optimisations from [BCR⁺19] we can save 4FFT using the same randomness across the three linchecks and 2FFT in the last lincheck as <span class="math">R_{\\delta}</span> and <span class="math">-uR_{\\delta}</span> are multiples of each other. Finally, adding the cost of one batched sumcheck, amounting to $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log(n + m)) + 3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 3\\mathrm{FFT}(\\mathbb{F}_q,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$, and summing up we obtain that the prover's time complexity is as claimed.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">On the verifier side instead <span class="math">\\widetilde{A}_i, \\widetilde{I}_m, \\widetilde{\\mathbf{b}}</span> are computed in $O(\\sum_{i=1}^{3} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{b}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ m)<span class="math">, the time required to compute </span>M_1, M_2, M_3<span class="math"> is as above, while checking </span>\\mathbf{v}_2 \\notin (\\mathrm{Ker}S \\circ \\psi)^{H_0'}<span class="math"> requires </span>\\lambda \\log q<span class="math"> bit operations if the verifier has access to the only element of </span>\\mathbb{F}_q = \\mathbb{F}_2^{\\log q}<span class="math"> orthogonal to </span>\\mathrm{Ker}S \\circ \\psi<span class="math">. Computing </span>\\mathbf{v}_1'<span class="math"> and </span>\\mathbf{v}_3'<span class="math"> requires </span>2\\lambda^2 \\log q$ bit operations. Finally the subroutines add the following costs</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">O(n + m)</span> for the first lincheck</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $O\\left(\\sum_{i=1}^{3} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ n + m\\right)$ for the second lincheck</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">O(n + m)</span> for the third lincheck</li>

    </ul>

    <p class="text-gray-300">plus an amortized execution of the sumcheck which adds <span class="math">O(\\log^2 (n + m) + 3)</span>. Summing all this terms yields the claimed value.</p>

    <p class="text-gray-300">In this section we compare our construction with [BCR⁺19, AHIV17] when proving satisfiability of an R1CS over <span class="math">\\mathbb{F}_2</span> using the naïve embedding <span class="math">\\mathbb{F}_2 \\subseteq \\mathbb{F}_q</span> in the first case and interactive repetitions in the second one, see Appendix F for more details. In all cases we assume [BCS16] is used to compile IOP into NIZKP. Our focus will be on the proof size, which we compute through a parameter optimiser, available at [Git21a], based on [lib], the open source implementation of Aurora and R1CS-Ligero, and on prover efficiency, which we only estimate theoretically. Regarding verifier time instead we don't expect significant improvements or overhead, as asymptotic costs are the same with roughly the same constants, and leave a precise estimate of it as future work.</p>

    <p class="text-gray-300"><strong>Proof size:</strong> In the case of Aurora call <span class="math">n, m</span> the number of variables and constraints respectively and fix <span class="math">\\rho</span> the rate of the RS code. Assuming all spaces are linearly ordered by inclusion, i.e. <span class="math">H_i \\subseteq H_j</span> or <span class="math">H_j \\subseteq H_i</span>, we have that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">the maximum degree tested equals  <span class="math">2\\max(n, m) + 2\\beta</span> , i.e. the block length is  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2(\\max(n, m) + \\beta) / \\rho<span class="math">  which scales linearly in  </span>n, m<span class="math"> . As a consequence, when  </span>2\\max(n, m) / k \\geq \\lambda<span class="math">  the block length required in our construction is approximately  </span>k<span class="math">  times smaller. This affects the NIZKP size because in the BCS transform replying to each query requires  </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  hash values per oracle. As we assumed  </span>\\rho<span class="math">  to be constant, FRI requires  </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  rounds, with one oracle codeword sent in each round. Hence each query requires  </span>O(\\log^2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  hash values. Reducing  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  by a factor of  </span>k<span class="math">  allows us to reduce this cost by a term  </span>O(2\\log k\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Moreover FRI's query phase soundness, proven in [BBHR18a] and later improved in [BSKS18], depends on  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , implying that in our case the low degree test requires a slightly lower number of queries to achieve the same soundness bound. To measure our improvements we derived from Aurora&#x27;s open source implementation a parameters optimiser estimating the proof size for an  </span>\\mathbb{F}_2<span class="math"> -R1CS of  </span>2^n<span class="math">  variables and constraints, remarking that in case of plain Aurora for each variable  </span>x<span class="math">  the constraint  </span>x^2 = x<span class="math">  is required. This is shown in Fig. 5 where the results displayed in the graph on the left are obtained using proven soundness bounds, while in the graph on the right using optimistic (but not proven) bounds, see Appendix F for more details. The improvement factor for  </span>2^{20}<span class="math">  constraints with a  </span>(48,192)_2$ -RMFE and 128 security bits amounts in the first case to 1.65, in the second case to 1.31.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 5. Argument Size with respect to the number of constraints for 128 security bit in Aurora with proven soundness bounds (left) and with optimistic bounds (right). Our work uses a  <span class="math">(48,192)_2</span> -RMFE</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a></p>

    <p class="text-gray-300">Prover time: Using again the fact that the block length is reduced by a factor of  <span class="math">k</span>  with a  <span class="math">(k, e)_2</span> -RMFE observe that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- In the RS-encoded IOP, the cost is dominated by the $18 \\cdot \\mathrm{FFT}(\\mathbb{F}_q,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. In our case we perform 35 fast Fourier transforms over a set </span>k<span class="math"> times smaller, leading to an improvement factor of </span>18k / 35$.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- In the BSC transform, computing the Merkle tree from an oracle of size $</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math"> requires </span>2</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">- 1<span class="math"> hashes. Using column hashing our construction requires the same amount of trees as in plain Aurora. Moreover, calling </span>f_{i}<span class="math"> FRI&#x27;s </span>i<span class="math">-th oracle, the length of </span>f_{i}<span class="math"> is </span></td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">\\cdot 2^{-i\\eta}<span class="math"> for a constant </span>\\eta<span class="math">, i.e. it scales linearly in </span></td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">. Therefore our protocol requires </span>k$ times less hash function evaluations.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In conclusion, we estimate that deploying a <span class="math">(48,192)_2</span>-RMFE leads to <span class="math">a \\approx 24.7 \\times</span> speed up asymptotically.</p>

    <h2 id="sec-21" class="text-2xl font-bold">5.2 Ligero</h2>

    <p class="text-gray-300"><strong>Proof size</strong>: Since our protocol uses in a black-box way IOPPs for linear and quadratic test, we can use the one introduced for R1CS-Ligero in <span class="math">\\left[\\mathrm{BCR}^{+}19\\right]</span> and compare it to Ligero. First we confront with the naïve construction, i.e. over a large field as <span class="math">\\mathbb{F}_{2^{160}}</span> for 128 security bit. In this case communication complexity is <span class="math">O(\\sqrt{n})</span> for an R1CS with <span class="math">n</span> variables and <span class="math">n</span> constrains. As our protocol execute all IOPPs with input reduced by a factor <span class="math">k</span>, we can expect asymptotically <span class="math">\\sqrt{k}</span>-times smaller proofs. Using a <span class="math">(48,160)_2</span>-RMFE, we will get <span class="math">\\sqrt{k} \\approx 6.93</span>.</p>

    <p class="text-gray-300">However in [AHIV17] a version for smaller fields which improves the interactive soundness error through repetitions is presented. As this version is harder to analyse theoretically, we numerically estimate the argument size for 128 security bit and compare it with our construction using a <span class="math">(48,160)_2</span>-RMFE, Fig. 6. We measure a reduction in the argument size up to a factor <span class="math">3.71 \\times</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Prover time</strong>: For simplicity we only compare our construction to Ligero without repetitions, as in this case operations are performed over the same extension of <span class="math">\\mathbb{F}_2</span>, for a R1CS over <span class="math">\\mathbb{F}_2</span> with <span class="math">n</span> variables and <span class="math">n</span> constraints. Recall that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\Theta(\\sqrt{n})<span class="math"> and each vector is divided in </span>m<span class="math"> blocks of length </span>\\ell<span class="math">, both growing asymptotically as </span>\\sqrt{n}$. As in Aurora we split the prover time in three terms:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- In the IOP, costs are dominated asymptotically by $21m \\cdot \\mathrm{FFT}(\\mathbb{F}_q,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. In our cases we would need </span>31m'<span class="math"> fast Fourier transform but with </span>m' \\sim m / \\sqrt{k}<span class="math"> and over a set </span>\\sqrt{k}<span class="math"> times smaller, leading to an improvement factor of </span>21k / 31$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>As Ligero performs a direct low degree test no extra computation is performed for testing proximity</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- In the BSC transform, using column hashing only one tree with $2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1<span class="math"> nodes has to be computed. Hence in our construction this step is performed </span>\\sqrt{k}<span class="math"> times faster. Notice however that asymptotically this cost is </span>\\Theta(\\sqrt{n})$ and is therefore dominated by the cost of computing the FFTs.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In conclusion we expect an improvement factor between <span class="math">6.9 - 32.5</span> with a <span class="math">(48,160)_2</span>-RMFE. We leave comparison with the more efficient version of Ligero that allows repetitions as future work.</p>

    <p class="text-gray-300">25</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 6. Argument Size w.r.t. the number of constraints for 128 security bit in Ligero with interactive repetitions. Our work uses a  <span class="math">(48,160)_2</span> -RMFE</p>

    <p class="text-gray-300">ACE+21. Mark Abspoel, Ronald Cramer, Daniel Escudero, Ivan Damgård, and Chaoping Xing. Improved single-round secure multiplication using regenerating codes. IACR Cryptol. ePrint Arch., 2021:253, 2021. AHIV17. Scott Ames, Carmit Hazay, Yuval Ishai, and Muthuramakrishnan Venkitasubramaniam. Ligero: Lightweight sublinear arguments without a trusted setup. In Bhavani M. Thuraisingham, David Evans, Tal Malkin, and Dongyan Xu, editors, ACM CCS 2017, pages 2087-2104. ACM Press, October / November 2017. <span class="math">\\mathrm{BBB}^{+}18</span> . Benedikt Bünz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Greg Maxwell. Bulletproofs: Short proofs for confidential transactions and more. In 2018 IEEE Symposium on Security and Privacy, pages 315-334. IEEE Computer Society Press, May 2018. BBHR18a. Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Fast reed-solomon interactive oracle proofs of proximity. In Ioannis Chatzigiannakis, Christos Kaklamanis, Daniel Marx, and Donald Sannella, editors, ICALP 2018, volume 107 of LIPIcs, pages 14:1-14:17. Schloss Dagstuhl, July 2018. BBHR18b. Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable, transparent, and post-quantum secure computational integrity. Cryptology ePrint Archive, Report 2018/046, 2018. https://eprint.iacr.org/2018/046. BCC+16. Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe Petit. Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In Marc Fischlin and Jean-Sébastien Coron, editors, EUROCRYPT 2016, Part II, volume 9666 of LNCS, pages 327-357. Springer, Heidelberg, May 2016. <span class="math">\\mathrm{BCI}^{+}20</span> . Eli Ben-Sasson, Dan Carmon, Yuval Ishai, Swastik Kopparty, and Shubhangi Saraf. Proximity gaps for reed-solomon codes. In 61st FOCS, pages 900-909. IEEE Computer Society Press, November 2020.</p>

    <p class="text-gray-300">BCR^{+}19. Eli Ben-Sasson, Alessandro Chiesa, Michael Riabzev, Nicholas Spooner, Madars Virza, and Nicholas P. Ward. Aurora: Transparent succinct arguments for R1CS. In Yuval Ishai and Vincent Rijmen, editors, EUROCRYPT 2019, Part I, volume 11476 of LNCS, pages 103–128. Springer, Heidelberg, May 2019.</p>

    <p class="text-gray-300">BCS16. Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. Interactive oracle proofs. In Martin Hirt and Adam D. Smith, editors, TCC 2016-B, Part II, volume 9986 of LNCS, pages 31–60. Springer, Heidelberg, October / November 2016.</p>

    <p class="text-gray-300">BFH^{+}20. Rishabh Bhadauria, Zhiyong Fang, Carmit Hazay, Muthuramakrishnan Venkitasubramaniam, Tiancheng Xie, and Yupeng Zhang. Ligero++: A new optimized sublinear iop. In Proceedings of the 2020 ACM SIGSAC Conference on Computer and Communications Security, pages 2025–2038, 2020.</p>

    <p class="text-gray-300">BFS20. Benedikt Bünz, Ben Fisch, and Alan Szepieniec. Transparent SNARKs from DARK compilers. In Anne Canteaut and Yuval Ishai, editors, EUROCRYPT 2020, Part I, volume 12105 of LNCS, pages 677–706. Springer, Heidelberg, May 2020.</p>

    <p class="text-gray-300">BGKS20. Eli Ben-Sasson, Lior Goldberg, Swastik Kopparty, and Shubhangi Saraf. DEEP-FRI: Sampling outside the box improves soundness. In Thomas Vidick, editor, ITCS 2020, volume 151, pages 5:1–5:32. LIPIcs, January 2020.</p>

    <p class="text-gray-300">BMN17. Alexander R. Block, Hemanta K. Maji, and Hai H. Nguyen. Secure computation based on leaky correlations: High resilience setting. In Jonathan Katz and Hovav Shacham, editors, CRYPTO 2017, Part II, volume 10402 of LNCS, pages 3–32. Springer, Heidelberg, August 2017.</p>

    <p class="text-gray-300">BMN18. Alexander R. Block, Hemanta K. Maji, and Hai H. Nguyen. Secure computation with constant communication overhead using multiplication embeddings. In Debrup Chakraborty and Tetsu Iwata, editors, INDOCRYPT 2018, volume 11356 of LNCS, pages 375–398. Springer, Heidelberg, December 2018.</p>

    <p class="text-gray-300">BSKS18. Eli Ben-Sasson, Swastik Kopparty, and Shubhangi Saraf. Worst-case to average case reductions for the distance to a code. In 33rd Computational Complexity Conference (CCC 2018). Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik, 2018.</p>

    <p class="text-gray-300">CCXY18. Ignacio Cascudo, Ronald Cramer, Chaoping Xing, and Chen Yuan. Amortized complexity of information-theoretically secure MPC revisited. In Hovav Shacham and Alexandra Boldyreva, editors, CRYPTO 2018, Part III, volume 10993 of LNCS, pages 395–426. Springer, Heidelberg, August 2018.</p>

    <p class="text-gray-300">CG20. Ignacio Cascudo and Jaron Skovsted Gundersen. A secret-sharing based MPC protocol for boolean circuits with good amortized complexity. In Rafael Pass and Krzysztof Pietrzak, editors, TCC 2020, Part II, volume 12551 of LNCS, pages 652–682. Springer, Heidelberg, November 2020.</p>

    <p class="text-gray-300">COS20. Alessandro Chiesa, Dev Ojha, and Nicholas Spooner. Fractal: Post-quantum and transparent recursive proofs from holography. In Anne Canteaut and Yuval Ishai, editors, EUROCRYPT 2020, Part I, volume 12105 of LNCS, pages 769–793. Springer, Heidelberg, May 2020.</p>

    <p class="text-gray-300">DGOT21. Cyprien Delpech, Saint Guilhem, Emmanuela Orsini, and Titouan Tanguy. Limbo: Efficient zero-knowledge mpcith-based arguments. Cryptology ePrint Archive, Report 2021/215, 2021. https://eprint.iacr.org/2021/215.</p>

    <p class="text-gray-300">28</p>

    <p class="text-gray-300">DLN19. Ivan Damgård, Kasper Green Larsen, and Jesper Buus Nielsen. Communication lower bounds for statistically secure MPC, with or without preprocessing. In Alexandra Boldyreva and Daniele Micciancio, editors, CRYPTO 2019, Part II, volume 11693 of LNCS, pages 61-84. Springer, Heidelberg, August 2019.</p>

    <p class="text-gray-300">DLS20. Anders P. K. Dalskov, Eysa Lee, and Eduardo Soria-Vazquez. Circuit amortization friendly encodings and their application to statistically secure multiparty computation. In Shiho Moriai and Huaxiong Wang, editors, ASIACRYPT 2020, Part III, volume 12493 of LNCS, pages 213-243. Springer, Heidelberg, December 2020.</p>

    <p class="text-gray-300">GH98. Oded Goldreich and Johan Håstad. On the complexity of interactive proofs with bounded communication. Inf. Process. Lett., 67(4):205-214, 1998.</p>

    <p class="text-gray-300">Git21a. zk-SNARKs argument size comparison. https://github.com/emanuelegiunta/snarks_comparison, 2021.</p>

    <p class="text-gray-300">Git21b. Implementation of polynomial-evaluation based Reverse Multiplication Friendly Embeddings. https://github.com/icascudo/RMFE, 2021.</p>

    <p class="text-gray-300">GM10. Shuhong Gao and Todd Mateer. Additive fast fourier transforms over finite fields. IEEE Transactions on Information Theory, 56(12):6265-6272, 2010.</p>

    <p class="text-gray-300">GSV21. Yaron Gvili, Sarah Scheffler, and Mayank Varia. Booligero: Improved sublinear zero knowledge proofs for boolean circuits. Cryptology ePrint Archive, Report 2021/121, 2021.</p>

    <p class="text-gray-300">IKOS07. Yuval Ishai, Eyal Kushilevitz, Rafail Ostrovsky, and Amit Sahai. Zero-knowledge from secure multiparty computation. In David S. Johnson and Uriel Feige, editors, 39th ACM STOC, pages 21-30. ACM Press, June 2007.</p>

    <p class="text-gray-300">lib. libiop: a c++ library for iop-based zksnarks. https://github.com/scipr-lab/libiop.</p>

    <p class="text-gray-300">Mer90. Ralph C. Merkle. A certified digital signature. In Gilles Brassard, editor, CRYPTO'89, volume 435 of LNCS, pages 218-238. Springer, Heidelberg, August 1990.</p>

    <p class="text-gray-300">PS20. Antigoni Polychroniadou and Yifan Song. Constant-overhead unconditionally secure multiparty computation over binary fields. Cryptology ePrint Archive, Report 2020/1412, 2020. https://eprint.iacr.org/2020/1412. To appear at Eurocrypt 2021.</p>

    <p class="text-gray-300">RRR16. Omer Reingold, Guy N. Rothblum, and Ron D. Rothblum. Constant-round interactive proofs for delegating computation. In Daniel Wichs and Yishay Mansour, editors, 48th ACM STOC, pages 49-62. ACM Press, June 2016.</p>

    <p class="text-gray-300">Set20. Srinath Setty. Spartan: Efficient and general-purpose zkSNARKs without trusted setup. In Daniele Micciancio and Thomas Ristenpart, editors, CRYPTO 2020, Part III, volume 12172 of LNCS, pages 704-737. Springer, Heidelberg, August 2020.</p>

    <p class="text-gray-300">Wee05. Hoeteck Wee. On round-efficient argument systems. In Luís Caires, Giuseppe F. Italiano, Luís Monteiro, Catuscia Palamidessi, and Moti Yung, editors, ICALP 2005, volume 3580 of LNCS, pages 140-152. Springer, Heidelberg, July 2005.</p>

    <p class="text-gray-300">WTS⁺18. Riad S Wahby, Ioanna Tzialla, Abhi Shelat, Justin Thaler, and Michael Walfish. Doubly-efficient zksnarks without trusted setup. In 2018 IEEE Symposium on Security and Privacy (SP), pages 926-943. IEEE, 2018.</p>

    <p class="text-gray-300">In this appendix we give details about constructions of reverse multiplication friendly embeddings based only on polynomial interpolation. We begin by recalling that if  <span class="math">\\mathbb{F}_p</span>  is a finite field of cardinality  <span class="math">p</span> , and  <span class="math">e &amp;gt; 1</span>  is an integer then an extension field of order  <span class="math">p^e</span>  can be obtained by selecting an irreducible polynomial  <span class="math">h</span>  of degree  <span class="math">e</span>  in  <span class="math">\\mathbb{F}_p[X]</span> , and setting  <span class="math">\\mathbb{F}_{p^e} = \\mathbb{F}_p[X] / (h)</span> . If we call  <span class="math">\\alpha</span>  the equivalence class modulo  <span class="math">h</span>  of  <span class="math">X</span>  in  <span class="math">\\mathbb{F}_{p^e}</span> , then  <span class="math">\\{1, \\alpha, \\ldots, \\alpha^{e-1}\\}</span>  is a basis of  <span class="math">\\mathbb{F}_{p^e}</span>  over  <span class="math">\\mathbb{F}_p</span>  and every element  <span class="math">\\beta</span>  in  <span class="math">\\mathbb{F}_{p^e}</span>  can be written uniquely as  <span class="math">f(\\alpha)</span>  for  <span class="math">f</span>  a polynomial in  <span class="math">\\mathbb{F}_p[X]_{&amp;lt; e}</span> . If  <span class="math">k</span>  is an integer satisfying  <span class="math">k \\leq p+1</span>  and  <span class="math">2k-1 \\leq e</span> , we can construct a  <span class="math">(k, e)_p</span> -RMFE as in Figure 7 below</p>

    <p class="text-gray-300">Let:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\infty_{t+1}</span>  be a formal symbol, and  <span class="math">f(\\infty_{t+1})</span>  be the coefficient of  <span class="math">X^t</span>  in  <span class="math">f \\in \\mathbb{F}_p[X]_{\\leq t}</span> .</li>

      <li><span class="math">x_0, \\ldots, x_{k-1}</span>  be pairwise distinct elements in  <span class="math">\\mathbb{F}_p \\cup \\{\\infty_k\\}</span>  (note that this requires  <span class="math">k \\leq p+1</span> ).</li>

      <li><span class="math">x_{i}^{\\prime}</span>  be defined as  <span class="math">x_{i}^{\\prime} = x_{i}</span>  if  <span class="math">x_{i} \\in \\mathbb{F}_{p}</span>  and  <span class="math">x_{i}^{\\prime} = \\infty_{2k - 1}</span>  if  <span class="math">x_{i} = \\infty_{k}</span> .</li>

      <li><span class="math">\\alpha \\in \\mathbb{F}_{p^e}</span>  be such that  <span class="math">\\mathbb{F}_{p^e} = \\mathbb{F}_p(\\alpha)</span> .</li>

    </ul>

    <p class="text-gray-300">Then we construct:</p>

    <div class="my-4 text-center"><span class="math-block">\\varphi : \\mathbb {F} _ {p} ^ {k} \\to \\mathbb {F} _ {p ^ {e}}, \\qquad (u _ {0}, \\ldots , u _ {k - 1}) \\mapsto f (\\alpha)</span></div>

    <p class="text-gray-300">where  <span class="math">f</span>  is the unique polynomial in  <span class="math">f\\in \\mathbb{F}_p[X]_{&amp;lt; k}</span>  s.t.  <span class="math">f(x_{i}) = u_{i}</span>  for all  <span class="math">i\\leq k - 1</span>  , and</p>

    <div class="my-4 text-center"><span class="math-block">\\psi : \\mathbb {F} _ {p ^ {e}} \\to \\mathbb {F} _ {p} ^ {k}, \\qquad \\beta \\mapsto (f (x _ {0} ^ {\\prime}), \\ldots , f (x _ {k - 1} ^ {\\prime}))</span></div>

    <p class="text-gray-300">where  <span class="math">f</span>  is the unique polynomial in  <span class="math">\\mathbb{F}_p[X]_{&amp;lt; e}</span>  such that  <span class="math">\\beta = f(\\alpha)</span> .</p>

    <p class="text-gray-300">Fig. 7. Direct polynomial-interpolation based RMFE</p>

    <p class="text-gray-300">Theorem 5. If  <span class="math">k \\leq p + 1</span>  and  <span class="math">e \\geq 2k - 1</span> , then the pair  <span class="math">(\\varphi, \\psi)</span>  from Figure 7 is a  <span class="math">(k, e)_p</span> -RMFE.</p>

    <p class="text-gray-300">The proof can be found in [CCXY18], but the intuition is that the image of  <span class="math">\\varphi</span>  is the set of elements  <span class="math">\\beta</span>  in  <span class="math">\\mathbb{F}_{p^e}</span>  that are written as  <span class="math">f(\\alpha)</span>  where  <span class="math">\\deg f \\leq k - 1</span> . Therefore the product of two elements  <span class="math">f(\\alpha), g(\\alpha) \\in \\operatorname{Im} \\varphi</span>  is represented as  <span class="math">(f \\cdot g)(\\alpha)</span>  because  <span class="math">\\deg f \\cdot g \\leq 2(k - 1) &amp;lt; e</span> , i.e. no modular reduction by  <span class="math">h</span>  occurs. Finally applying  <span class="math">\\psi</span>  will simply evaluate  <span class="math">f \\cdot g</span>  in the points  <span class="math">x_i&#x27;</span>  which is the product of the evaluations of  <span class="math">f</span>  and  <span class="math">g</span>  in  <span class="math">x_i</span> . It is not difficult to prove that the rates  <span class="math">k / e</span>  of these constructions are optimal (as large as they can be for that value of  <span class="math">k</span> ). However, since the construction above is limited by  <span class="math">k \\leq p + 1</span> , we will need a second building block, namely the concatenation or RMFE.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Theorem 6.</h6>

    <p class="text-gray-300">Assume that <span class="math">(\\varphi_{1},\\psi_{1})</span> is an <span class="math">(k_{1},e_{1})_{p^{e_{2}}}</span>-RMFE and <span class="math">(\\varphi_{2},\\psi_{2})</span> is an <span class="math">(k_{2},e_{2})_{p}</span>-RMFE. Then the maps</p>

    <p class="text-gray-300"><span class="math">\\varphi:\\ \\mathbb{F}_{p}^{k_{1}k_{2}}\\to\\mathbb{F}_{p^{e_{1}e_{2}}},</span> <span class="math">(\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{k_{1}})\\ \\mapsto\\ (\\varphi_{2}(\\mathbf{x}_{1}),\\ldots,\\varphi_{2}(\\mathbf{x}_{n_{1}}))\\in\\mathbb{F}_{p^{e_{2}}}^{k_{1}}\\ \\mapsto\\ \\varphi_{1}(\\varphi_{2}(\\mathbf{x}_{1}),\\ldots,\\varphi_{2}(\\mathbf{x}_{k_{1}}))</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">\\psi:\\ \\mathbb{F}_{p^{e_{1}e_{2}}}\\to\\mathbb{F}_{p}^{k_{1}k_{2}},</span> <span class="math">y\\ \\mapsto\\ \\psi_{1}(y)=(y_{1},\\ldots,y_{k_{1}})\\in\\mathbb{F}_{p^{e_{2}}}^{k_{1}}\\ \\mapsto\\ (\\psi_{2}(y_{1}),\\ldots,\\psi_{2}(y_{k_{1}}))</span></p>

    <p class="text-gray-300">give an <span class="math">(k_{1}k_{2},e_{1}e_{2})_{p}</span>-RMFE.</p>

    <p class="text-gray-300">Again the proof can be found in <em>[x10]</em>. These two results combined allow to construct <span class="math">(k,e)_{p}</span>-RMFEs for arbitrarily large <span class="math">k</span> (independent of <span class="math">p</span>) by concatenating enough RMFEs. We call such constructions polynomial-interpolation based RMFEs. As a result of this concatenation, the rate <span class="math">k/e</span> worsens, but the decrease is extremely slow, as we will see below. First, we give some concrete parameters for our case of interest <span class="math">q=2</span>. Using both of the theorems above</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for all <span class="math">r\\leq 33</span> and <span class="math">s\\geq 2r-1</span> there exists a <span class="math">(3r,5s)_{2}</span>-RMFE, obtained by concatenation of <span class="math">(3,5)_{2}</span> and <span class="math">(r,s)_{32}</span>-RMFEs, both promised by Theorem 5.</li>

      <li>for all <span class="math">a\\leq 17</span> there exists a <span class="math">(2a,8a)_{2}</span>-RMFE obtained by concatenation of <span class="math">(2,4)_{2}</span> and <span class="math">(a,2a)_{16}</span>-RMFEs, both existing by Theorem 5.</li>

      <li>for all <span class="math">b\\leq 65</span> there exists a <span class="math">(3b,12b)_{2}</span>-RMFE obtained by concatenation of <span class="math">(3,6)_{2}</span> and <span class="math">(b,2b)_{32}</span>-RMFEs, both implied by Theorem 5.</li>

    </ol>

    <p class="text-gray-300">This proves Lemma 2. Note that the <span class="math">(2,4)_{2}</span> and <span class="math">(3,6)_{2}</span>-RMFEs, and consequently all the RMFEs in the last two families, are clearly not optimal with respect to the rates. We decided to present them nonetheless because the degree of the output field is of a convenient form to use in practice. For instance by choosing <span class="math">a</span> and <span class="math">b</span> powers of <span class="math">2</span>, <span class="math">8a</span> is a power of <span class="math">2</span> up to <span class="math">128</span>, while <span class="math">12b</span> have binary representation of weight <span class="math">2</span> up to <span class="math">768</span>.</p>

    <p class="text-gray-300">The construction above is based on polynomial interpolation and therefore efficient to compute. Nevertheless, given that <span class="math">\\varphi,\\psi</span> are linear functions for the RMFE, that we use concrete fixed relatively small parameters and that we will use them multiple times (keep in mind that we are going to apply <span class="math">\\Phi</span> and <span class="math">\\Psi</span> which are blockwise applciations of <span class="math">\\varphi</span> and <span class="math">\\psi</span>, to vectors with many blocks) it is better in practice to precompute the generator matrices of <span class="math">\\varphi</span> and <span class="math">\\psi</span> (by computing <span class="math">\\varphi</span> and <span class="math">\\psi</span> on a <span class="math">\\mathbb{F}_{2}</span>-basis of <span class="math">\\mathbb{F}_{2}^{k}</span> and <span class="math">\\mathbb{F}_{2^{c}}</span> respectively) as <span class="math">\\mathbb{F}_{2}</span>-linear maps and then compute <span class="math">\\varphi</span> and <span class="math">\\psi</span> on a given input as a matrix-vector multiplication. Precomputed generator matrices of <span class="math">\\varphi</span> and <span class="math">\\psi</span>, as well as bases for <span class="math">\\operatorname{Im}\\varphi,\\operatorname{Ker}\\psi,\\operatorname{Ker}S\\circ\\psi</span> and <span class="math">\\varphi(\\mathbf{1}_{k})</span>, which are other elements needed in our protocols, can be found in <em>[x14]</em> for diverse values of <span class="math">(k,e)</span> that can be obtained as concatenation of two direct polynomial-interpolation based RMFE.</p>

    <p class="text-gray-300">A.2 A note on asymptotical complexity</p>

    <p class="text-gray-300">In <em>[x10]</em>, it was shown that an asymptotical family of constant rate, i.e. a family of <span class="math">(k,\\Theta(k))_{p}</span>-RMFEs where <span class="math">p</span> is fixed and <span class="math">k\\to\\infty</span>, can be constructed for any prime power <span class="math">p</span> by algebraic geometric methods <em>[x10]</em>. For example in the case of <span class="math">p=2</span> one can achieve a family of <span class="math">(k,e(k))_{2}</span>-RMFEs, where for an inifinite number of <span class="math">k</span>, <span class="math">e(k)&lt;5k</span></p>

    <p class="text-gray-300">One unfortunately cannot get, solely from the concatenation of interpolation-based techniques above the same constant rate result. Nevertheless, we remark that the rate of concatenation of polynomial-interpolation based RMFEs decreases <em>extremely</em> slowly and therefore, for all practical purposes, these RMFEs present very good rates. We show this more precisely next.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Definition 7.</h6>

    <p class="text-gray-300">For <span class="math">q\\in\\mathbb{R}_{+},y\\in\\mathbb{N}</span>, the tetration <span class="math">q\\uparrow\\uparrow y</span> is defined as</p>

    <p class="text-gray-300"><span class="math">q\\uparrow\\uparrow y=\\underbrace{q^{q^{\\top}}}_{y},</span></p>

    <p class="text-gray-300">where the exponentiations are operated right-to-left, i.e., <span class="math">q\\uparrow\\uparrow 0=1</span>, and <span class="math">q\\uparrow\\uparrow y=q^{q\\uparrow\\uparrow(y-1)}</span> for <span class="math">y\\geq 1</span>.</p>

    <p class="text-gray-300">We define the iterated logarithm <span class="math">\\log_{q}^{*}:\\mathbb{R}\\to\\mathbb{N}</span> as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">k\\leq 1</span>, then <span class="math">\\log_{q}^{*}k=0</span></li>

      <li>If <span class="math">k&gt;1</span>, then <span class="math">\\log_{q}^{*}k=y</span> where <span class="math">y</span> is the only natural number such that <span class="math">q\\uparrow\\uparrow(y-1)&lt;k\\leq q\\uparrow\\uparrow y</span>.</li>

    </ul>

    <h6 id="sec-27" class="text-base font-medium mt-4">Theorem 7.</h6>

    <p class="text-gray-300">For every prime power <span class="math">p</span> there exists a sequence of polynomial-interpolation based <span class="math">(k,e)_{p}</span>-RMFE with <span class="math">k\\to\\infty</span> such that <span class="math">e\\leq k\\cdot 2^{\\log_{p}^{<em>}k}</span> for <span class="math">p&gt;2</span> and asymptotically <span class="math">e\\leq k\\cdot 2^{\\log_{2}^{</em>}\\log k}</span> for <span class="math">p=2</span>.</p>

    <p class="text-gray-300">The proof of Theorem 7 is obtained by combining Theorems 5 and 6 as follows. For <span class="math">n&gt;0</span>, we consider the concatenation of <span class="math">(p_{i},2p_{i})_{p_{i}}</span>-RMFEs, <span class="math">i=1,...,n</span> where <span class="math">p_{i+1}=p_{i}^{2p_{i}}</span>, and for the first step <span class="math">p_{1}=p</span>. Such concatenation yields a <span class="math">(k,e)</span>-RMFE which satisfies <span class="math">k=\\prod_{i=1}^{n}p_{i}</span>, <span class="math">e=2^{n}k</span>. For general <span class="math">p</span> it is easy to show by induction that <span class="math">k\\geq p\\uparrow\\uparrow n</span> which implies <span class="math">n\\leq\\log^{<em>}k</span>. When <span class="math">p=2</span> instead for <span class="math">n\\geq 2</span> one can show by induction that <span class="math">k\\geq 2\\uparrow\\uparrow(n+1)=2^{2\\uparrow\\uparrow n}</span> which implies <span class="math">n\\leq\\log\\log^{</em>}k</span>.</p>

    <p class="text-gray-300">The function <span class="math">\\log^{<em>}</span> grows extremely slowly, in fact asymptotically <span class="math">\\log^{</em>}k=o(\\log\\dots\\log k)</span> for any fixed number of applications of the <span class="math">\\log</span> function on the right side.</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">A.3 Properties</h3>

    <p class="text-gray-300">We conclude this section with a proof of Lemma 1 stating a few fundamental properties of RMFEs</p>

    <p class="text-gray-300">Proof of Lemma 1.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\psi</span> is surjective because from the identity <span class="math">\\psi(\\varphi(\\mathbf{x}) \\cdot \\varphi(\\mathbf{y})) = \\mathbf{x} * \\mathbf{y}</span>, fixing <span class="math">\\mathbf{y} = \\mathbf{1}_k</span> we deduce <span class="math">\\psi(\\varphi(\\mathbf{1}_k) \\cdot \\varphi(\\mathbf{x})) = \\mathbf{x}</span> for all <span class="math">\\mathbf{x} \\in \\mathbb{F}_2^k</span>. Similarly if <span class="math">\\varphi(\\mathbf{x}) = 0</span> for some vector then <span class="math">\\psi(\\varphi(\\mathbf{1}_k) \\cdot \\varphi(\\mathbf{x})) = \\mathbf{0}</span> by linearity which implies <span class="math">\\mathbf{x} = \\mathbf{0}</span>. This also implies that <span class="math">\\varPhi</span> is injective and <span class="math">\\varPsi</span> is surjective.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Call <span class="math">\\mathbf{x} = (\\mathbf{x}_1, \\ldots, \\mathbf{x}_n)</span> and <span class="math">\\mathbf{y} = (\\mathbf{y}_1, \\ldots, \\mathbf{y}_n)</span>. By definition</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\varPsi(\\varPhi(\\mathbf{x}) * \\varPhi(\\mathbf{y})) = \\varPsi\\left((\\varphi(\\mathbf{x}_1), \\ldots, \\varphi(\\mathbf{x}_n)) * (\\varphi(\\mathbf{y}_1), \\ldots, \\varphi(\\mathbf{y}_n))\\right) \\\\ = \\varPsi(\\varphi(\\mathbf{x}_1) \\cdot \\varphi(\\mathbf{y}_1), \\ldots, \\varphi(\\mathbf{x}_n) \\cdot \\varphi(\\mathbf{y}_n)) \\\\ = (\\psi(\\varphi(\\mathbf{x}_1) \\cdot \\varphi(\\mathbf{y}_1)), \\ldots, \\psi(\\varphi(\\mathbf{x}_n) \\cdot \\varphi(\\mathbf{y}_n))) \\\\ = (\\mathbf{x}_1 * \\mathbf{y}_1, \\ldots, \\mathbf{x}_n * \\mathbf{y}_n) = \\mathbf{x} * \\mathbf{y}. \\end{array}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>As in point 1 follows by definition.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Calling <span class="math">\\mathbf{x} = (\\mathbf{x}_1, \\ldots, \\mathbf{x}_n) \\in (\\mathbb{F}_2^k)^n</span>, <span class="math">\\mathbf{y} = (\\mathbf{y}_1, \\ldots, \\mathbf{y}_n) \\in (\\mathbb{F}_2^k)^n</span> and <span class="math">\\mathbf{x}_i = (x_{i,j})_{j=1}^k</span>, <span class="math">\\mathbf{y}_i = (y_{i,j})_{j=1}^k</span> we have that <span class="math">\\mathbf{x}^\\top \\mathbf{y} =</span></li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} = \\sum_{i=1}^{n} \\sum_{j=1}^{k} x_{i,j} y_{i,j} = \\sum_{i=1}^{n} S(\\mathbf{y}_i * \\mathbf{x}_i) = \\sum_{i=1}^{n} S \\circ \\psi(\\varphi(\\mathbf{x}_i) \\cdot \\varphi(\\mathbf{y}_i)) \\\\ = S \\circ \\psi\\left(\\sum_{i=1}^{n} \\varphi(\\mathbf{x}_i) \\cdot \\varphi(\\mathbf{y}_i)\\right) = S \\circ \\psi\\left(\\Phi(\\mathbf{x})^\\top \\Phi(\\mathbf{y})\\right). \\end{array}</span></div>

    <h2 id="sec-29" class="text-2xl font-bold">B IOPs, RS-encoded IOPs and their proximity versions</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We recall the concepts of interactive oracle proofs (IOP) [BCS16], RS-encoded interactive oracle proofs [BCR⁺19], and their proximity versions. For reasons of space we keep the description informal, and refer to the cited works for details. For a relation <span class="math">\\mathcal{R} \\subseteq X \\times W</span>, we denote its associated language as <span class="math">\\mathcal{L}(\\mathcal{R}) = \\{x \\in X : \\exists (x, w) \\in \\mathcal{R}\\}</span> and, given <span class="math">x \\in X</span>, we define $\\mathcal{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_x = \\{w \\in W : (x, w) \\in \\mathcal{R}\\}$ which could be empty.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>IOPs.</strong> A k-round public-coin IOP for a relation <span class="math">\\mathcal{R}</span> is a protocol between a prover <span class="math">\\mathsf{P}(x,w)</span> and a verifier <span class="math">\\mathsf{V}(x)</span> where at round <span class="math">i \\in [\\mathbf{k}]</span>, the verifier sends a uniformly random bit-string <span class="math">m_i \\in \\{0,1\\}^{u_i}</span>, and the prover replies by sending a message <span class="math">m_i&#x27; \\in \\{0,1\\}^{u_i&#x27;}</span> and giving the verifier oracle access to a string <span class="math">\\pi_i \\in \\{0,1\\}^{\\ell_i}</span>. After the k-th round, the verifier makes queries to the oracles <span class="math">\\pi_i</span>, i.e. he asks to see some coordinates of the string, and either accepts or rejects. We speak about the <em>randomness complexity</em> <span class="math">u_1 + \\ldots + u_k</span> and <em>proof length</em> <span class="math">\\ell_1 + \\ldots + \\ell_k</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Correctness requires that if <span class="math">(x, w) \\in \\mathcal{R}</span> then the verifier accepts with probability 1. Soundness requires that if <span class="math">x \\notin \\mathcal{L}(\\mathcal{R})</span> (equivalently $\\mathcal{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_x = \\emptyset<span class="math">) for any malicious prover </span>\\widetilde{\\mathsf{P}}<span class="math"> the verifier accepts with negligible probability. In fact, we consider the stronger notion of proof of knowledge: there exists an extractor interacting with </span>\\widetilde{\\mathsf{P}}<span class="math"> which returns a witness </span>w \\in \\mathcal{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_x$ with almost the same probability that the verifier accepts the proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">An IOP has zero knowledge against <span class="math">\\beta</span> queries if for every malicious verifier <span class="math">\\widetilde{\\mathsf{V}}</span></p>

    <p class="text-gray-300">reading at most <span class="math">\\beta</span> entries of the prover's messages there exists an efficient simulator with straight-line access to <span class="math">\\widehat{V}</span> such that the verifier's view when executed with <span class="math">P</span> or with the simulator follows the same probability distribution.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>IOPPs.</strong> A k-round public-coin IOP of proximity (IOPP) is an IOP where the verifier has oracle access to a purported witness <span class="math">w</span> and has to decide if $w \\in \\mathcal{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_x<span class="math"> under the promise that </span>w<span class="math"> is either in </span>\\mathcal{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_x<span class="math"> or far from it i.e. </span>d(w, \\mathcal{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_x) \\geq \\delta<span class="math"> where </span>d$ is some distance function; we will consider here the Hamming distance.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">While correctness is as above, soundness only requires the verifier to reject with overwhelming probability when $d(w, \\mathcal{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_x) \\geq \\delta<span class="math">. Finally an IOPP has Zero Knowledge against unbounded queries if for any </span>\\widehat{\\mathbf{V}}<span class="math"> there exists a simulator S with straight-line access to </span>\\widehat{\\mathbf{V}}<span class="math"> such that the view of </span>\\widehat{\\mathbf{V}}<span class="math"> interacting with </span>\\mathsf{P}<span class="math"> together with the number of queries performed by </span>\\widehat{\\mathbf{V}}$ has the same distribution as the view obtained interacting with S together with the number of queries performed by the simulator.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>RS-encoded IOPs.</strong> Reed-Solomon encoded IOPs are IOPs for which the soundness guarantees only holds if the messages sent by the prover are codewords in Reed Solomon codes of specified rate. Moreover the verifier, after the interaction and the queries, returns a set of <em>rational constraints</em> (instead of a bit), i.e. tuples of the form <span class="math">(N,D,\\sigma)</span> with <span class="math">N,D</span> (multivariate) polynomials and <span class="math">\\sigma \\in [0,1]</span>. A set of codewords <span class="math">f_{1},\\ldots ,f_{n}\\in \\mathsf{RS}_{L,\\rho}</span> satisfy a rational constraint if</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\frac {N (\\alpha , f _ {1} (\\alpha) , \\ldots , f _ {n} (\\alpha))}{D (\\alpha , f _ {1} (\\alpha) , \\ldots , f _ {n} (\\alpha))}\\right) _ {\\alpha \\in L} \\in \\mathsf {R S} _ {L, \\sigma}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">that is, if the associated rational function <span class="math">N / D</span> coincides on <span class="math">L</span> with a polynomial of degree $&lt; \\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. We say that the verifier accepts if the codewords sent by the prover satisfies all the rational constraints sent by the verifier.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Completeness requires that if <span class="math">(x, w) \\in \\mathcal{R}</span> then the verifier accepts. Soundness holds if, for any <span class="math">x \\notin \\mathcal{L}(\\mathcal{R})</span> and malicious prover <span class="math">\\widetilde{\\mathsf{P}}</span>, the verifier accepts with negligible probability. Furthermore the protocol is a proof of knowledge if there exists an extractor interacting with <span class="math">\\widetilde{\\mathsf{P}}</span> which for any <span class="math">x</span> returns a witness $w \\in \\mathcal{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_x$ with almost the same probability that the verifier accepts. Finally zero knowledge for RS-IOPs is as in the case of IOPs.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>RS-encoded IOPPs.</strong> In an Reed Solomon-encoded IOP of proximity the verifier has oracle access to a purported witness <span class="math">w</span> and have to decide if $w \\in \\mathcal{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_x<span class="math"> provided that </span>w<span class="math"> lies in a RS code with the specified parameters. Note that despite the name &quot;proximity&quot;, in this case (as opposed to IOPPs) the soundness does not take into account the distance between the purported witness and </span>\\mathcal{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_x$ [13]. Zero knowledge for RS-encoded IOPPs is defined as in the case of IOPPs.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">13 The name is motivated by the fact that, as in the case of IOPPs, the verifier has oracle access to the witness.</p>

    <p class="text-gray-300">33</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For RS-encoded IOPs or IOPPs we also introduce the maximum rates. Given a multivariate polynomial <span class="math">F</span> in <span class="math">n + 1</span> variables, <span class="math">\\deg(F, (k_1, \\ldots, k_n))</span> is the maximum degree attained by <span class="math">F(x, p_1(x), \\ldots, p_n(x))</span> for <span class="math">p_i \\in \\mathbb{F}[x]_{&amp;lt;k_i}</span>. Thus, if in an RS-encoded protocol the purposed codewords have rates <span class="math">\\rho_1, \\ldots, \\rho_n</span> and the verifier returns constraints <span class="math">(N_j, D_j, \\sigma_j)_{j=1}^m</span> then, calling $\\mathbf{k} = (\\rho_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)_{i=1}^n<span class="math">, we define </span>\\sigma^<em><span class="math"> as the maximum among </span>\\rho_i<span class="math"> and </span>\\sigma_j<span class="math"> and </span>\\rho^</em><span class="math"> as the maximum among </span>\\deg(N_j, \\mathbf{k})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-1}<span class="math"> and </span>\\sigma_j + \\deg(D_j, \\mathbf{k})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-1}<span class="math">. The maximum rates are then </span>(\\sigma^<em>, \\rho^</em>)<span class="math">. Note that if for any codeword there is a constraint that depends on it, then </span>\\sigma^<em> \\leq \\rho^</em>$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-30" class="text-2xl font-bold">C Generalised Lincheck</h2>

    <p class="text-gray-300">In this section we detail an RS-encoded IOPP for <span class="math">\\mathcal{R}_{\\mathrm{Lin}_h}</span> that generalise the Lincheck to linear relations of the form <span class="math">M_1\\mathbf{x}_1 + \\ldots + M_n\\mathbf{x}_h = \\mathbf{b}</span> given oracle access to an encoding of <span class="math">\\mathbf{x}_i</span>, see Definition 5. In order to present the protocol we recall that Aurora's Lincheck is based on the Suncheck protocol that, given a witness <span class="math">f \\in \\mathsf{RS}_{\\mathbb{F},\\rho}</span> and <span class="math">H \\subseteq \\mathbb{F}_q</span> test if the sum of <span class="math">\\widehat{f}(a)</span> for <span class="math">a \\in H</span> is equal to a given value. More precisely</p>

    <p class="text-gray-300"><strong>Definition 8.</strong> We define <span class="math">\\mathcal{R}_{\\mathrm{Sum}}</span> as the set of all tuples <span class="math">((\\mathbb{F}_q, L, H, \\rho, b), f)</span> such that <span class="math">L, H \\subseteq \\mathbb{F}_q</span> are disjoint affine subspaces, <span class="math">f \\in \\mathsf{RS}_{L,\\rho}</span>, and</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{a \\in H} \\widehat{f}(a) = b.</span></div>

    <p class="text-gray-300">In [BCR⁺19] they provide an RS-encoded IOPP for the sumcheck relation as stated in the following</p>

    <p class="text-gray-300"><strong>Proposition 4.</strong> There exists an RS-encoded IOPP for <span class="math">\\mathcal{R}_{\\mathrm{Sum}}</span> with the following parameters</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\text{Rounds} = 1 \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{Proof Length} = 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\text{Randomness} = 2\\log q \\\\ \\text{Soundness} = q^{-1} \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{Prover Time} = O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) + 3 \\cdot \\operatorname{FFT}(\\mathbb{F}_q,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\text{Max Rates} = (\\rho, \\rho) \\\\ \\end{array} $$</p>

    <p class="text-gray-300">Given a Sumcheck protocol we detail our generalised linear check in Figure 1</p>

    <p class="text-gray-300"><strong>Proposition 5.</strong> Protocol 8 is an RS-encoded IOPP for <span class="math">\\mathcal{R}_{\\mathrm{Lin}_h}</span> with the parameters of Proposition 1</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Fig. 8. RS-encoded IOPP for  <span class="math">\\mathcal{R}_{\\mathrm{Lin}_h}</span>  with  <span class="math">\\mathsf{pp} = (\\mathbb{F}_q,L,H_0,H_i,\\rho)_{i = 1}^h</span></p>

    <p class="text-gray-300">Proof. Correctness: Given a tuple in  <span class="math">\\mathcal{R}_{\\mathrm{Lin}_h}</span> ,  <span class="math">\\sum_{i=1}^{h} M_i f_i = \\mathbf{b}</span>  implies that for all  <span class="math">\\sum_{i=1}^{h} \\mathbf{r}^\\top M_i f_i = \\mathbf{r}^\\top \\mathbf{b}</span>  for all  <span class="math">\\mathbf{r} \\in \\mathbb{F}_q^{H_0}</span> . In particular</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sum_ {\\alpha \\in H} \\widehat {f} (\\alpha) = \\sum_ {i = 1} ^ {h} \\sum_ {\\alpha \\in H} \\widehat {p _ {i}} (\\alpha) \\widehat {f _ {i}} (\\alpha) = \\\\ = \\sum_ {i = 1} ^ {h} \\sum_ {\\alpha \\in H _ {i}} (\\mathbf {r} ^ {\\top} M _ {i}) _ {\\alpha} \\widehat {f _ {i}} (\\alpha) = \\sum_ {i = 1} ^ {h} \\mathbf {r} ^ {\\top} M _ {i} f _ {i} = \\mathbf {r} ^ {\\top} \\mathbf {b}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Correctness thus follows by correctness of the underlying sumcheck protocol.</p>

    <p class="text-gray-300">Soundness: If a given tuple does not belong to  <span class="math">\\mathcal{R}_{\\mathrm{Lin}_h}</span>  then  <span class="math">\\sum_{i=1}^{h} M_i f_i \\neq \\mathbf{b}</span> . Therefore</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\mathbf {r} ^ {\\top} \\left(\\sum_ {i = 1} ^ {h} M _ {i} f _ {i} - \\mathbf {b}\\right) = \\mathbf {0} \\right] \\leq (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H _ {0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1) q ^ {- 1}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and in particular when the above event occurs  <span class="math">\\sum_{\\alpha \\in H} f(\\alpha) \\neq \\mathbf{r}^{\\top} \\mathbf{b}</span> . By the  <span class="math">q^{-1}</span>  soundness of the underlying sumcheck protocol, the verifier outputs a rejecting constraint with probability  <span class="math">q^{-1}</span> . With a union bound we conclude that the verifier rejects with probability smaller than  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">q^{-1}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Zero Knowledge: Let  <span class="math">S_{\\text{Sum}}</span>  be a simulator for the sumcheck protocol. We define  <span class="math">S_{\\text{Lin}_h}</span>  against a malicious verifier  <span class="math">\\widetilde{V}</span>  as follows</p>

    <p class="text-gray-300">First notice that  <span class="math">\\mathsf{S}_{\\mathrm{Lin}_h}</span>  correctly replies to any request from  <span class="math">\\widetilde{\\mathsf{V}}</span>  and  <span class="math">\\mathsf{S}_{\\mathrm{Sum}}</span> . Since the sumcheck protocol has HVZK fro unbounded queries, we deduce that  <span class="math">\\mathsf{S}_{\\mathrm{Sum}}</span>  produce a transcript indistinguishable from the one generated by  <span class="math">\\mathsf{P}_{\\mathrm{Sum}}</span> . The thesis follows.</p>

    <p class="text-gray-300">Efficiency The costs for the prover comes from the following operations:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1 \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  multiplications to compute  </span>\\mathbf{r} = (1, \\dots, r^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1})$</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">-  <span class="math">h</span>  times  $\\mathrm{FFT}(\\mathbb{F}_q,</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">)<span class="math">  to interpolate  </span>\\widehat{p}_i<span class="math">  for  </span>i \\in [h]$</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{S}_{\\mathrm{Sim}_h}^{f_1,\\dots,f_h}((\\mathbb{F}_q,L,H_0,H_i,\\rho,M_i,\\mathbf{b})_{i=1}^h)</span></div>

    <p class="text-gray-300">1: When <span class="math">\\widetilde{\\mathbf{V}}</span> queries <span class="math">f_i</span> in <span class="math">\\alpha</span>: Send <span class="math">\\widetilde{\\mathbf{V}} \\gets f_i(\\alpha)</span> 2: When <span class="math">r \\gets^{\\</span>} \\widetilde{\\mathbf{V}}$:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3: <span class="math">H \\gets \\operatorname{span}(H_1, \\ldots, H_h)</span>, $\\mathbf{r} \\gets (1, \\ldots, r^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">5: Execute <span class="math">\\mathsf{S}_{\\mathsf{Sum}}^f (\\mathbb{F}_q,L,H,\\rho ,\\mathbf{r}^\\top \\mathbf{b})</span> 6: When <span class="math">\\mathsf{S}_{\\mathsf{Sum}}^f</span> request <span class="math">f(\\alpha)</span>: send <span class="math">\\mathsf{S}_{\\mathsf{Sum}} \\gets \\sum_{i=1}^{h} f_i(\\alpha) \\cdot \\widehat{p}_i(\\alpha)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $h \\cdot \\mathrm{FFT}(\\mathbb{F}_q,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) + h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> to evaluate </span>p_i = \\widehat{p}_{i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L}<span class="math"> and compute the products </span>f_i * p_i$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">T_{\\mathrm{Sum}}^p</span> to run the sumcheck subroutine</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For what regards the verifier instead it requires $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> products to compute </span>\\mathbf{r}<span class="math"> and time </span>O(\\sum_{i=1}^{h} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M_i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> to simulate access to </span>f$ as explained in [BCR+19] plus the time it takes to run the sumcheck subroutine.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-31" class="text-2xl font-bold">D Affine R1CS</h2>

    <p class="text-gray-300">The way we define the satisfiability of rank one constraint system, see Definition 2 as said differs from the one used in related works. In this section we provide the canonical definition and prove that the two problem are equivalent up to a linear-time rearrangement of the system.</p>

    <p class="text-gray-300"><strong>Definition 9.</strong> We define <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}^<em></span> the set of tuples <span class="math">((\\mathbb{F},k,n,m,A_1,A_2,A_3,\\mathbf{v}),\\mathbf{w})</span> where <span class="math">\\mathbb{F}</span> is a finite field, <span class="math">k,n,m\\in \\mathbb{N}\\setminus \\{0\\}</span> are positive integers, <span class="math">A_{i}\\in \\mathbb{F}^{m,1 + n}</span>, <span class="math">\\mathbf{v}\\in \\mathbb{F}^k</span>, <span class="math">\\mathbf{w}\\in \\mathbb{F}^{n - k}</span> and calling <span class="math">\\mathbf{z} = (1,\\mathbf{v},\\mathbf{w})\\in \\mathbb{F}^{1 + n}</span> it satisfies the relation <span class="math">A_{1}\\mathbf{z}</em>A_{2}\\mathbf{z} = A_{3}\\mathbf{z}</span>.</p>

    <p class="text-gray-300"><strong>Proposition 6.</strong> There exist a reduction <span class="math">\\mathcal{V}</span> of <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}^*</span> to <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}</span> that on input <span class="math">(\\mathbb{F}, k, n, m, A_1, A_2, A_3, \\mathbf{v})</span>, executes less than</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 2 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 2 m</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">operations over <span class="math">\\mathbb{F}_2</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> <span class="math">\\mathcal{V}</span> is detailed in Protocol 9 where given a vector <span class="math">\\mathbf{x} \\in \\mathbb{F}_2^m</span> and a matrix <span class="math">A \\in \\mathbb{F}_2^{m,n}</span> by <span class="math">\\mathbf{x} * A</span> we mean the Hadamard product of <span class="math">\\mathbf{x}</span> applied to each column of <span class="math">A</span>.</p>

    <p class="text-gray-300">As a general observation, for all <span class="math">\\mathbf{x} \\in F_2^m</span>, calling <span class="math">D_{\\mathbf{x}} = (d_{i,j})</span> the diagonal matrix such that <span class="math">d_{i,i} = x_i</span>, then</p>

    <div class="my-4 text-center"><span class="math-block">\\forall \\mathbf{y} \\in \\mathbb{F}_2^m \\quad \\mathbf{x} * \\mathbf{y} = D_{\\mathbf{x}} \\mathbf{y}, \\quad \\forall A \\in \\mathbb{F}_2^{m,n} \\quad \\mathbf{x} * A = D_{\\mathbf{x}} A.</span></div>

    <p class="text-gray-300"><span class="math">\\mathcal{Y}(\\mathbb{F},k,n,m,A_1,A_2,A_3,\\mathbf{v})</span>  ：</p>

    <p class="text-gray-300">1: For  <span class="math">i \\in \\{1, 2, 3\\}</span> :</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2: Parse  $A_{i} = A_{i,l}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{i,r}<span class="math">  with  </span>A_{i,l}\\in \\mathbb{F}^{k + 1,m}<span class="math"> </span>A_{i,r}\\in \\mathbb{F}^{n - k,m}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">3:  <span class="math">\\mathbf{u}_i\\gets A_{i,l}\\cdot (1,\\mathbf{v})</span> 4:  <span class="math">A_1&#x27; \\gets A_{1,r}</span> ,  <span class="math">A_2&#x27; \\gets A_{2,r}</span> ,  <span class="math">A_3&#x27; \\gets A_{3,r} - (\\mathbf{u}_2 <em> A_{1,r} + \\mathbf{u}_1 </em> A_{2,r})</span> 5:  <span class="math">\\mathbf{b}&#x27;\\gets \\mathbf{u}_3 - (\\mathbf{u}_1*\\mathbf{u}_2)</span> 6: Return  <span class="math">(\\mathbb{F},m,n - k,A_1&#x27;,A_2&#x27;,A_3&#x27;,\\mathbf{b})</span></p>

    <p class="text-gray-300">Fig. 9. Description of  <span class="math">\\mathcal{V}</span>  where  <span class="math">A, B, C \\in \\mathbb{F}_2^{m,n&#x27; + n}</span> ,  <span class="math">A_l, B_l, C_l \\in \\mathbb{F}_2^{m,n&#x27;}</span> ,  <span class="math">A_r, B_r, C_r \\in \\mathbb{F}_2^{m,n}</span>  and  <span class="math">\\mathbf{v} \\in \\mathbb{F}_2^{n&#x27;}</span></p>

    <p class="text-gray-300">Since the matrix product is associative it follows that  <span class="math">\\mathbf{x} <em> (A\\mathbf{y}) = (\\mathbf{x} </em> A)\\mathbf{y}</span> . We deduce that  <span class="math">\\mathcal{V}</span>  maps  <span class="math">\\mathcal{L}(\\mathcal{R}_{\\mathsf{R1CS}}^<em>) \\to \\mathcal{L}(\\mathcal{R}_{\\mathsf{R1CS}})</span> , i.e. transform a satisfiable canonical R1CS in a satisfiable affine R1CS, because for all  <span class="math">\\mathbf{w} \\in \\mathbb{F}_2^n</span> , calling  <span class="math">\\mathbf{z} = (1, \\mathbf{v}, \\mathbf{w})</span> ,  <span class="math">A_1\\mathbf{z} </em> A_2\\mathbf{z} = A_3\\mathbf{z}</span>  if and only if</p>

    <p class="text-gray-300"><span class="math">\\Leftrightarrow (A_{1,l}\\cdot (1,\\mathbf{v}) + A_{1,r}\\mathbf{w})<em>(A_{2,l}\\cdot (1,\\mathbf{v}) + A_{2,r}\\mathbf{w}) = A_{3,l}\\cdot (1,\\mathbf{v}) + A_{3,r}\\mathbf{w}</span> <span class="math">\\Leftrightarrow \\mathbf{u}_1</em>\\mathbf{u}_2 + \\mathbf{u}_1<em>(A_{2,r}\\mathbf{w}) + \\mathbf{u}_2</em>(A_{1,r}\\mathbf{w}) + A_{1,r}\\mathbf{w}<em>A_{2,r}\\mathbf{w} = \\mathbf{u}_3 + A_{3,r}\\mathbf{w}</span> <span class="math">\\Leftrightarrow A_{1,r}\\mathbf{w}</em>A_{1,r}\\mathbf{w} = (A_{3,r} - (\\mathbf{u}_2<em>A_{1,r} + \\mathbf{u}_1</em>A_{2,r}))\\mathbf{w} + (\\mathbf{u}_3 - (\\mathbf{u}_1<em>\\mathbf{u}_2))</span> <span class="math">\\Leftrightarrow A^{\\prime}\\mathbf{w}</em>B^{\\prime}\\mathbf{w} = C^{\\prime}\\mathbf{w} + \\mathbf{b}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Finally the running time is as specified because step 3 requires  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{1,l}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> ,  </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{2,l}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> ,  </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{3,l}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  respectively for each matrix multiplication, in step 4, the two Hadamard product can be computed in  </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{1,r}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{2,r}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  multiplications and the two sums in less than</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A _ {3, r} \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {u} _ {2} * A _ {1, r} \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {u} _ {1} * B _ {r} \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A _ {3, r} \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A _ {1, r} \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A _ {2, r} \\right\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">additions. Step 5 requires  <span class="math">m</span>  multiplications and  <span class="math">m</span>  additions leaving a total cost of</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_ {i = 1} ^ {3} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A _ {i, l} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 2 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A _ {1, r} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 2 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A _ {2, r} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A _ {3, l} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 2 n ^ {\\prime} \\leq 2 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A _ {1} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 2 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A _ {2} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A _ {3} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 2 m</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">operations, where we used the fact that  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{i,l}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{i,r}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  which in turn implies  </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{i,r}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-33" class="text-2xl font-bold">E.1 Linear Hashing</h2>

    <p class="text-gray-300">In this section we provide a proof of Propositions 2.3. First of all we prove the following Lemmata that reinterpret the first proposition over  <span class="math">\\mathbb{F}_{2^{\\lambda}}</span>  and  <span class="math">\\mathbb{F}_2^\\lambda</span> .</p>

    <p class="text-gray-300">Lemma 4. Let <span class="math">\\mathbf{x} \\in \\mathbb{F}_{2^{\\lambda}}^{m}</span>, <span class="math">y \\in \\mathbb{F}_{2^{\\lambda}}</span> and <span class="math">\\alpha \\sim U(\\mathbb{F}_{2^{\\lambda}})</span>. Calling <span class="math">\\mathbf{a} = (\\alpha, \\alpha^{2}, \\ldots, \\alpha^{m})</span>, if <span class="math">\\mathbf{x} \\neq 0</span> then</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\mathbf {a} ^ {\\top} \\mathbf {x} = y \\right] \\leq \\frac {m}{2 ^ {\\lambda}}</span></div>

    <p class="text-gray-300">Proof. Let <span class="math">\\mathbf{x} = (x_{1},\\ldots ,x_{m})</span> and <span class="math">f(t) = -y + x_{1}t + \\ldots +x_{m}t^{m}\\in \\mathbb{F}_{2^{\\lambda}}[t]</span> be a polynomial. Since <span class="math">f</span> has degree <span class="math">m</span> it can have at most <span class="math">m</span> roots. In particular the probability that <span class="math">\\alpha</span> is a root of <span class="math">f</span> is <span class="math">m2^{\\lambda}</span> and therefore</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\mathbf {a} ^ {\\top} \\mathbf {x} = y \\right] = \\Pr \\left[ - y + x _ {1} \\alpha + \\dots + x _ {m} \\alpha^ {m} = 0 \\right] = \\Pr \\left[ f (\\alpha) = 0 \\right] \\leq \\frac {m}{2 ^ {\\lambda}}.</span></div>

    <p class="text-gray-300">Lemma 5. Let <span class="math">\\mathbf{x} \\in \\mathbb{F}_2^{\\lambda m}</span>, <span class="math">\\mathbf{y} \\in \\mathbb{F}_2^{\\lambda}</span> and <span class="math">\\alpha \\sim U(\\mathbb{F}_{2^{\\lambda}})</span>. If <span class="math">\\mathbf{x} \\neq \\mathbf{0}</span> then</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ R _ {\\alpha} \\mathbf {x} = \\mathbf {y} \\right] \\leq \\frac {m}{2 ^ {\\lambda}}.</span></div>

    <p class="text-gray-300">Proof. Call <span class="math">\\mathbf{x} = (\\mathbf{x}_1, \\ldots, \\mathbf{x}_m)</span> with <span class="math">\\mathbf{x}_i \\in \\mathbb{F}_2^\\lambda</span>. From the hypothesis at least one of these vectors is non-zero. Since <span class="math">\\vartheta: \\mathbb{F}_2^\\lambda \\to \\mathbb{F}_{2^\\lambda}</span> is an isomorphism we have that at least one of <span class="math">\\vartheta(\\mathbf{x}_1), \\ldots, \\vartheta(\\mathbf{x}_m)</span> is non-zero and in particular <span class="math">\\mathbf{z} = (\\vartheta(\\mathbf{x}_1), \\ldots, \\vartheta(\\mathbf{x}_m)) \\in \\mathbb{F}_{2^\\lambda}^m</span> is not the zero vector. In conclusion calling <span class="math">\\mathbf{a} = (\\alpha, \\ldots, \\alpha^m)</span> we have that <span class="math">\\operatorname*{Pr}\\left[R_{\\alpha}\\mathbf{x} = \\mathbf{y}\\right] =</span></p>

    <div class="my-4 text-center"><span class="math-block">= \\Pr \\left[ \\vartheta^ {- 1} \\left(\\alpha \\vartheta \\left(\\mathbf {x} _ {1}\\right) + \\dots + \\alpha^ {m} \\vartheta \\left(\\mathbf {x} _ {m}\\right)\\right) = \\mathbf {y} \\right] = \\Pr \\left[ \\mathbf {a} ^ {\\top} \\mathbf {z} = \\vartheta (\\mathbf {y}) \\right] \\leq \\frac {m}{2 ^ {\\lambda}}</span></div>

    <p class="text-gray-300">where the last inequality follows as <span class="math">\\alpha \\sim U(\\mathbb{F}_{2^{\\lambda}})</span> and <span class="math">\\mathbf{z} \\neq \\mathbf{0}</span>.</p>

    <p class="text-gray-300">We are now ready to prove the claimed Propositions</p>

    <p class="text-gray-300">Proof of Proposition 2. Let <span class="math">R_{\\alpha} = (r_{i,j}) \\in \\mathbb{F}_2^{\\lambda, \\lambda m}</span>, <span class="math">\\mu = \\log q</span> be the dimension over <span class="math">\\mathbb{F}_2</span> of <span class="math">\\mathbb{F}_q</span> and <span class="math">k = \\dim V</span>. By base completion we can find a base <span class="math">e_1, \\ldots, e_\\mu</span> of <span class="math">\\mathbb{F}_q</span> such that <span class="math">e_1, \\ldots, e_k</span> is a base of <span class="math">V</span>. Calling <span class="math">\\mathbf{x} = (x_1, \\ldots, x_{\\lambda m}) \\in \\mathbb{F}_q^{\\lambda m}</span> and <span class="math">\\mathbf{y} = (y_1, \\ldots, y_\\lambda) \\in \\mathbb{F}_q^\\lambda</span> we can express this element in the larger fields with respect to the base <span class="math">e_1, \\ldots, e_\\mu</span>, that is there exists a unique <span class="math">b_{j,h}, c_{i,h} \\in \\mathbb{F}_2</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">x _ {j} = \\sum_ {h = 1} ^ {\\mu} b _ {j, h} e _ {h}, \\qquad y _ {i} = \\sum_ {h = 1} ^ {\\mu} c _ {i, h} e _ {h}.</span></div>

    <p class="text-gray-300">Next we express the <span class="math">i</span>-th coordinate of <span class="math">R_{\\alpha}\\mathbf{x} - \\mathbf{y} \\in \\mathbb{F}_q^\\lambda</span> with respect to this base</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left(R _ {\\alpha} \\mathbf {x} - \\mathbf {y}\\right) _ {i} = \\sum_ {j = 1} ^ {\\lambda m} r _ {i, j} x _ {j} - y _ {i} \\\\ = \\sum_ {j = 1} ^ {\\lambda m} \\sum_ {h = 1} ^ {\\mu} r _ {i, j} b _ {j, h} e _ {h} - \\sum_ {j = 1} ^ {\\lambda} c _ {i, h} e _ {h} \\\\ = \\sum_ {h = 1} ^ {\\mu} e _ {h} \\cdot \\left(\\sum_ {j = 1} ^ {\\lambda m} r _ {i, j} b _ {j, h} - c _ {i, h}\\right). \\end{array}</span></div>

    <p class="text-gray-300">In particular, calling <span class="math">\\mathbf{b}_h = (b_{1,h},\\ldots ,b_{\\lambda m,h})\\in \\mathbb{F}_2^{\\lambda m}</span> and <span class="math">\\mathbf{c}_h = (c_{1,h},\\dots ,c_{\\lambda ,h})</span>, we deduce <span class="math">R_{\\alpha}\\mathbf{x} - \\mathbf{y} = \\sum_{h = 1}^{\\mu}e_{h}(R_{\\alpha}\\mathbf{b}_{h} - \\mathbf{c}_{h})</span>. From the hypothesis <span class="math">\\mathbf{x}\\notin V^{\\lambda m}</span>, therefore there exists a <span class="math">j^{\\prime}</span> with <span class="math">x_{j^{\\prime}}\\notin V</span> and consequently an <span class="math">h^\\prime &amp;gt;k</span> such that</p>

    <p class="text-gray-300">38</p>

    <p class="text-gray-300"><span class="math">b_{j&#x27;,h&#x27;} \\neq 0</span>. Thus <span class="math">\\mathbf{b}_{h&#x27;} \\neq \\mathbf{0}</span>. In conclusion observe that if <span class="math">R_{\\alpha} \\mathbf{x} - \\mathbf{y} \\in V^{\\lambda}</span> then each entry of this vector is a <span class="math">\\mathbb{F}_2</span>-linear combination of <span class="math">e_1, \\ldots, e_k</span> and in particular the coefficient of <span class="math">e_{h&#x27;}</span> in its base representation is 0. It follows that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ R _ {\\alpha} \\mathbf {x} - \\mathbf {y} \\in V ^ {\\lambda} \\right] \\leq \\Pr \\left[ R _ {\\alpha} \\mathbf {b} _ {h ^ {\\prime}} - \\mathbf {c} _ {h ^ {\\prime}} = \\mathbf {0} \\right] \\leq \\frac {m}{2 ^ {\\lambda}}.</span></div>

    <p class="text-gray-300">Proof of Proposition 3. Follows from Proposition 2 because, if <span class="math">\\mathbf{x}_j \\notin V^{\\lambda m_j}</span> then</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\sum_ {i = 1} ^ {h} R _ {\\alpha_ {i}} ^ {(m _ {i})} \\mathbf {x} _ {i} = \\mathbf {y} \\mod V ^ {\\lambda} \\right] \\leq \\\\ \\leq \\Pr \\left[ R _ {\\alpha_ {j}} ^ {(m _ {j})} \\mathbf {x} _ {j} = \\mathbf {y} - \\sum_ {i \\neq j} R _ {\\alpha_ {i}} ^ {(m _ {i})} \\mathbf {x} _ {i} \\mod V ^ {\\lambda} \\right] \\leq \\frac {m _ {i}}{2 ^ {\\lambda}} \\leq \\frac {\\max  \\{m _ {i} : i \\in [ h ] \\}}{2 ^ {\\lambda}}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">We remark in conclusion that the above properties are not satisfied in general by any almost universal linear hash function. For instance consider the family of maps <span class="math">f_{\\alpha}:\\mathbb{F}_{2^{\\lambda}}^{m}\\to \\mathbb{F}_{2^{\\lambda}}</span> for <span class="math">\\alpha \\in \\mathbb{F}_{2^{\\lambda}}</span> such that <span class="math">f_{\\alpha}(\\mathbf{x}) = \\mathbf{a}^{\\top}\\mathbf{x}</span> with <span class="math">\\mathbf{a} = (1,\\dots ,\\alpha^{m - 1})</span>. This is <span class="math">(m - 1)2^{-\\lambda}</span>-almost universal, however, given <span class="math">\\mathbf{x} = (1,0,\\ldots ,0)</span> and <span class="math">y = 1</span></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ f _ {\\alpha} (\\mathbf {x}) = y \\right] = 1</span></div>

    <h2 id="sec-34" class="text-2xl font-bold">E.2 Modular Lincheck</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof of Theorem 2. Completeness: if $\\sum_{i=1}^{h} M_i \\widehat{f}_{i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_i} = \\mathbf{b} \\mod V^{H_0}<span class="math"> then, since </span>V<span class="math"> is an </span>\\mathbb{F}_2<span class="math"> vector space and </span>R_\\alpha \\in \\mathbb{F}_2^{H_0' \\times H_0}<span class="math"> for any </span>\\alpha \\in \\mathbb{F}_{2^\\lambda}<span class="math">, the equality is preserved after multiplying by </span>R_\\alpha<span class="math">, i.e. </span>\\sum_{i=1}^{h} R_\\alpha M_i \\widehat{f}_{i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_i} - R_\\alpha \\mathbf{b} \\in V^{H_0'}<span class="math">. By construction we also have that </span>\\widehat{f}_{h+1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_0'} \\in V^{H_0'}<span class="math"> and in particular </span>\\mathbf{v} \\in V^{H_0'}<span class="math">. In conclusion by completeness of the underlying Lincheck protocol, the verifier returns a set of accepting constraints because by construction </span>R_\\alpha \\mathbf{b} + \\mathbf{v} = \\sum_{i=1}^{h} R_\\alpha M_i \\widehat{f}_{i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_i} + \\widehat{f}_{h+1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_0'}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Soundness: If $\\mathbf{x} \\coloneqq \\sum_{i=1}^{h} M_i \\widehat{f}_{i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_i} - \\mathbf{b} \\neq \\mathbf{0} \\mod V^{H_0}<span class="math">, call </span>f_{h+1}^<em><span class="math"> and </span>\\mathbf{v}^</em><span class="math"> the messages sent by a malicious prover and </span>\\mathbf{y}^* = \\widehat{f}_{h+1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_0'}^<em><span class="math">. Since </span>\\alpha<span class="math"> is independent from </span>f_{h+1}^</em>$, then by Proposition 3</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ R _ {\\alpha} \\mathbf {x} + \\mathbf {y} ^ {*} = \\mathbf {0} \\mod V ^ {H _ {0} ^ {\\prime}} \\right] \\leq \\frac {\\lceil m / \\lambda \\rceil}{2 ^ {\\lambda}}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Up to this probability we can assume that <span class="math">R_{\\alpha} \\mathbf{x} + \\mathbf{y}^{<em>} \\notin V^{H_0&#x27;}</span>. If <span class="math">\\mathbf{v}^{</em>} = R_{\\alpha} \\mathbf{x} + \\mathbf{y}^{<em>}</span> then <span class="math">\\mathbf{v}^{</em>} \\notin V^{H_0&#x27;}</span> and the verifier returns an unsatisfiable constraint. Otherwise <span class="math">\\mathbf{v}^{<em>} \\neq R_{\\alpha} \\mathbf{x} + \\mathbf{y}^{</em>}</span> and by the soundness of the underlying Lincheck the verifier returns an accepting set of constraints with probability smaller than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_0'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">q^{-1} = \\lambda q^{-1}<span class="math">. With a union bound, the soundness error is at most </span>\\lceil m / \\lambda \\rceil \\cdot 2^{-\\lambda} + \\lambda q^{-1}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Zero Knowledge: Given a malicious verifier <span class="math">\\widetilde{\\mathbf{V}}</span> and <span class="math">\\mathsf{S}_{\\mathrm{Lin}_{h + 1}}</span> a simulator for the Lincheck protocol, we construct <span class="math">\\mathsf{S}_{\\mathsf{M}\\mathsf{lin}_h}</span> as in Figure 10:</p>

    <p class="text-gray-300">\\mathsf{S}_{\\mathsf{M}\\mathsf{l}\\mathsf{i}\\mathsf{n}_{\\mathsf{h}}}^{f_1,\\dots ,f_h}((\\mathbb{F}_q,L,H_0,H_i,\\rho ,M_i,\\mathbf{b},V)_{i = 1}^h)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1: Sample  $f_{h+1}^{\\prime} \\gets {}^{8} \\operatorname{Mask}(L, \\rho +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_0'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-1}, H_0', V)<span class="math">  and set  </span>Q \\gets \\emptyset$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">2: When  <span class="math">\\widetilde{\\mathbf{V}}</span>  queries  <span class="math">f_{i}</span>  in  <span class="math">\\xi</span> ,  <span class="math">i \\leq h</span> : Query  <span class="math">f_{i}(\\xi)</span>  and send  <span class="math">\\widetilde{\\mathbf{V}} \\gets f_{i}(\\xi)</span> 3: When  <span class="math">\\widetilde{\\mathbf{V}}</span>  queries  <span class="math">f_{h + 1}^{\\prime}</span>  in  <span class="math">\\xi</span> : Send  <span class="math">\\widetilde{\\mathbf{V}}\\gets f_{h + 1}^{\\prime}(\\xi)</span>  and update  <span class="math">Q\\gets Q\\cup \\{\\xi \\}</span> 4: When  <span class="math">\\widetilde{\\mathbf{V}}</span>  returns  <span class="math">\\alpha \\in \\mathbb{F}_{2^{\\lambda}}</span> :</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5: If  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; \\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> : Sample  </span>\\mathbf{v}' \\gets^8 V^{H_0'}<span class="math">  and send  </span>\\widetilde{\\mathbf{V}} \\gets \\mathbf{v}'$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">6: Else: Query  <span class="math">f_{i}(\\xi)</span>  for all  <span class="math">\\xi \\in Q</span>  and set  <span class="math">\\widehat{f}_i</span>  their interpolation over  <span class="math">Q</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">7: Set  $\\mathbf{v}' \\gets R_{\\alpha}\\left[\\sum_{i=1}^{h} M_i \\widehat{f}_{i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_i} - \\mathbf{b}\\right] + \\widehat{f}_{h+1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_0'}'<span class="math">  and send  </span>\\widetilde{\\mathbf{V}} \\gets \\mathbf{v}'$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">9: Run  <span class="math">\\mathsf{S}_{\\mathrm{Lin}_{h + 1}}^{f_1,\\dots ,f_h,f_{h + 1}&#x27;}(\\mathsf{pp}&#x27;,M&#x27;,R_\\alpha \\mathbf{b} + \\mathbf{v})</span> 10: When  <span class="math">\\widetilde{\\mathbf{V}}</span>  or  <span class="math">\\mathsf{S}_{\\mathrm{Lin}_{h + 1}}</span>  queries  <span class="math">f_{h + 1}^{\\prime}</span>  in  <span class="math">\\xi</span> : update  <span class="math">Q\\gets Q\\cup \\{\\xi \\}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">11: If  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; \\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> : send  </span>\\widetilde{\\mathbf{V}} \\gets f_{h + 1}'(\\xi)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">12: Else: Query  <span class="math">f_{i}(\\xi)</span>  for all  <span class="math">\\xi \\in Q</span>  and set  <span class="math">\\widehat{f}_i</span>  their interpolation over  <span class="math">Q</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">13:  $\\mathbf{x}\\gets \\sum_{i = 1}^{h}M_{i}\\widehat{f}_{i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{i}} - \\mathbf{b}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">15: Send  <span class="math">\\widetilde{\\mathbf{V}}\\gets g(\\xi)</span></p>

    <p class="text-gray-300">Fig. 10. Zero knowledge simulator for the Modular Lincheck RS-IOPP from Figure 1</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We confront real and simulated transcripts on input a tuple in  <span class="math">\\mathcal{R}_{\\mathrm{Mlin}_h}</span>  studying three cases. If  <span class="math">\\widetilde{\\mathbf{V}}</span>  queries  <span class="math">f_{h + 1}^{\\prime}</span>  in less than  $\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  entries, until  </span>\\alpha<span class="math">  is sent the simulator behaves as the prover. By construction and polynomial interpolation observe that for any set  </span>Q\\subseteq L<span class="math">  with  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; \\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , the projection of  </span>\\operatorname {Mask}(L,\\rho +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_0^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-1},H_0^{\\prime},V)<span class="math">  over  </span>V^{H_0^{\\prime}}\\times \\mathbb{F}_q^Q<span class="math">  defined evaluating the associated polynomial is  </span>\\mathbb{F}_2<span class="math"> -linear and surjective. Therefore after  </span>\\alpha<span class="math">  is sent, calling  </span>\\mathbf{x} = \\left[\\sum_{i = 1}^{h}M_{i}\\widehat{f}_{i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{i}} - \\mathbf{b}\\right]<span class="math">  we have that conditioning on  </span>\\alpha$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta \\left((\\mathbf {v}, \\widehat {f} _ {h + 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q}), (\\mathbf {v} ^ {\\prime}, \\widehat {f} _ {h + 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q} ^ {\\prime})\\right) = \\Delta \\left((R _ {\\alpha} \\mathbf {x} + \\widehat {f} _ {h + 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H _ {0} ^ {\\prime}}, \\widehat {f} _ {h + 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q}), (\\mathbf {v} ^ {\\prime}, \\widehat {f} _ {h + 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q} ^ {\\prime})\\right)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since  <span class="math">f_{h+1}</span>  and  <span class="math">f_{h+1}&#x27;</span>  are uniform over  $\\mathsf{Mask}(L, \\rho +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_0'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-1}, H_0', V)<span class="math"> , and  </span>R_\\alpha \\mathbf{x} \\in V^{H_0'}<span class="math">  we conclude that both vectors are uniform over  </span>V^{H_0'} \\times \\mathbb{F}_q^Q$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If  <span class="math">\\widetilde{\\mathbf{V}}</span>  performs more than  $\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  total queries to  </span>f_{h + 1}^{\\prime}<span class="math">  after sending  </span>R_{\\alpha}<span class="math">  then call  </span>Q_{0}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">the first $\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1<span class="math"> and </span>Q_{1}<span class="math"> the others. Conditioning on </span>R_{\\alpha}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta \\left(\\left(\\mathbf {v}, \\widehat {f} _ {h + 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q}\\right), \\left(\\mathbf {v} ^ {\\prime}, \\widehat {f} _ {h + 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q _ {0}} ^ {\\prime}, \\widehat {g} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q _ {1}}\\right)\\right) \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\leq \\Delta \\left(\\left(R _ {\\alpha} \\mathbf {x} + \\widehat {f} _ {h + 1</td>

            <td class="px-3 py-2 border-b border-gray-700">H _ {0} ^ {\\prime}}, \\widehat {f} _ {h + 1</td>

            <td class="px-3 py-2 border-b border-gray-700">Q _ {0}}\\right), \\left(\\mathbf {v} ^ {\\prime}, \\widehat {f} _ {h + 1</td>

            <td class="px-3 py-2 border-b border-gray-700">Q _ {0}} ^ {\\prime}\\right)\\right) = 0 \\\\</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">where the inequality comes from the fact that in both vectors the last component is a function of the others and last equality as both vectors are uniform.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Finally if the malicious verifier performs $\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> queries to </span>f_{h + 1}^{\\prime}<span class="math"> before sending </span>R_{\\alpha}$, the simulator behaves exactly as the prover.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Efficiency</strong>: On the prover side <span class="math">f_{h+1}</span> can be sampled by choosing a random vector <span class="math">\\mathbf{y} \\in V^{H_0&#x27;}</span> and <span class="math">\\mathbf{r} \\in \\mathbb{F}_q^S</span> with <span class="math">S \\subseteq L</span> of size $\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1<span class="math"> and then interpolating with an FFT. </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M_i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> operations are required to compute </span>R_{\\alpha}M_{i}<span class="math"> and </span>R_{\\alpha}\\mathbf{b}<span class="math"> respectively. Computing </span>(R_{\\alpha}M_{i})\\widehat{f}_{i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{i}}<span class="math"> assuming </span>\\widehat{f}_{i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_i}<span class="math"> is given takes at most </span>\\lambda</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Finally </span>T_{\\mathrm{Lin}_{h + 1}}^{\\mathrm{P}}$ steps are required to run the subroutine.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">On the verifier side the costs $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M_i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{b}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> comes from the products </span>R_{\\alpha}M_{i}<span class="math"> and </span>R_{\\alpha}\\mathbf{b}<span class="math"> as well. In addition the verifier checks that each entry of </span>\\mathbf{v}<span class="math"> lies in </span>V<span class="math"> by choosing a base and projecting on </span>V<span class="math">, which takes </span>\\dim V<span class="math"> inner products of binary vectors of length </span>\\log q<span class="math">. Assuming that the cost for each of these inner products is smaller than a multiplication in </span>\\mathbb{F}_q<span class="math"> we have that this check is performed in less than </span>\\lambda \\dim V$ operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-35" class="text-2xl font-bold">E.3 First Construction</h2>

    <p class="text-gray-300"><strong>Proof of Theorem 3.</strong> <strong>Completeness</strong>: Given in input a tuple in <span class="math">\\mathcal{R}_{\\mathsf{R1CS}}</span> with witness <span class="math">\\mathbf{w}</span> all the condition tested are satisfied because of Theorem 1 because <span class="math">f_{\\widetilde{\\mathbf{w}}}, f_{\\widetilde{\\mathbf{x}}_i}, f_{\\mathbf{t}}</span> respectively encode <span class="math">\\varPhi(\\mathbf{w}), \\varPhi(A_i\\mathbf{w})</span> and <span class="math">\\varPhi(A_1\\mathbf{w}) * \\varPhi(A_2\\mathbf{w})</span>. Therefore the verifier accepts with probability 1.</p>

    <p class="text-gray-300"><strong>Soundness</strong>: Let <span class="math">\\widetilde{\\mathbf{P}}</span> be a malicious verifier, <span class="math">(\\mathbb{F}_q, m, n, A_1, A_2, A_3, \\mathbf{b})</span> not in the language associated to <span class="math">\\mathcal{R}_{\\mathsf{R1CS}}</span> and <span class="math">f_{\\widetilde{\\mathbf{w}}}^<em>, f_{\\widetilde{\\mathbf{x}}_i}^</em>, f_{\\mathbf{t}}^*</span> the codewords sent by <span class="math">\\widetilde{\\mathbf{P}}</span>. Moreover let <span class="math">\\widetilde{\\mathbf{w}}</span> be the evaluation of <span class="math">\\widetilde{f}_{\\widetilde{\\mathbf{w}}}</span> over <span class="math">H_2</span> and <span class="math">\\widetilde{\\mathbf{x}}_i, \\mathbf{t}</span> the evaluation of <span class="math">\\widetilde{f}_{\\widetilde{\\mathbf{x}}_i}, \\widetilde{f}_{\\mathbf{t}}</span> respectively over <span class="math">H_1</span>.</p>

    <p class="text-gray-300">If all the statements associated to the sub protocols are satisfied by Theorem 1 the given R1CS is satisfiable, which is a contradiction. Therefore at least one of those statements is false and from the soundness of the sub protocols invoked the verifier accepts with probability at most <span class="math">\\max (\\lceil m / \\lambda k\\rceil ,\\lceil n / \\lambda k\\rceil ,\\lceil m / k\\rceil)\\cdot 2^{-\\lambda} + \\lambda q^{-1}</span> that is the claimed bound.</p>

    <p class="text-gray-300"><strong>Zero Knowledge against <span class="math">\\beta</span> queries</strong>: Given a tuple in <span class="math">\\mathcal{R}_{\\mathsf{R1CS}}</span> we define a simulator <span class="math">\\mathsf{S}_{\\mathsf{R1CS}}</span> interacting without rewinding with a malicious verifier <span class="math">\\widehat{\\mathbf{V}}</span> that performs at most <span class="math">\\beta</span> queries.</p>

    <p class="text-gray-300">41</p>

    <p class="text-gray-300">\\mathbf{S}_{\\mathsf{RICS}}(\\mathbb{F}_q,m,n,A_1,A_2,A_3,\\mathbf{b})}</p>

    <p class="text-gray-300">1: Sample  <span class="math">f_{\\widetilde{\\mathbf{w}}}, f_{\\widetilde{\\mathbf{x}}_i}, f_{\\mathbf{t}} \\gets^{\\S} \\mathbb{F}_q^L</span> 2: Parse  <span class="math">A_{i} = (\\mathbf{a}_{i,j}^{\\top})</span>  and set  <span class="math">\\widetilde{A}_i\\gets (\\varPhi (\\mathbf{a})_{i,j}^\\top)</span> <span class="math">\\widetilde{I}_m\\gets (\\mathbf{e}_j^\\top)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3: Set  <span class="math">u \\gets \\Phi(\\mathbf{1}_k)</span> ,  <span class="math">\\widetilde{\\mathbf{b}} \\gets \\Phi(\\mathbf{b})</span> ,  $\\rho_1 \\gets (m / k + \\beta) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> ,  </span>\\rho_2 \\gets (n / k + \\beta) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">4: Send  <span class="math">\\widetilde{\\mathbf{V}}\\gets f_{\\widetilde{\\mathbf{w}}},f_{\\widetilde{\\mathbf{x}}_i},f_{\\mathbf{t}}</span>  and execute 5:  <span class="math">\\mathbf{S}_{\\mathrm{Row}}^{f_{\\widetilde{\\mathbf{w}}_1},f_{\\widetilde{\\mathbf{w}}_2},f_{\\mathbf{t}}}(\\mathbb{F}_q,L,H_1,\\rho_1)</span> 6:  <span class="math">\\mathbf{S}_{\\mathrm{Mlin}_2}^{f_{\\mathbf{t}},f_{\\widetilde{\\mathbf{w}}_2}}(\\mathbb{F}_q,L,H_1,H_1,H_1,\\rho_1,I_{m / k}, - uI_{m / k},u\\widetilde{\\mathbf{b}},\\mathrm{Ker}\\psi)</span> 7:  <span class="math">\\mathbf{S}_{\\mathrm{Mlin}_1}^{f_{\\widetilde{\\mathbf{w}}}}(\\mathbb{F}_q,L,H_2,H_2,\\rho_2,I_{n / k},\\mathbf{0},\\mathrm{Im}\\varphi)</span> 8: For  <span class="math">i \\in \\{1, 2, 3\\}</span>  execute: 9:  <span class="math">\\mathbf{S}_{\\mathrm{Mlin}_2}^{f_{\\widetilde{\\mathbf{x}}_i}}(\\mathbb{F}_q,L,H_1,H_1,\\rho_1,I_{m / k},\\mathbf{0},\\mathrm{Im}\\varphi)</span> 10:  <span class="math">\\mathbf{S}_{\\mathrm{Mlin}_2}^{f_{\\widetilde{\\mathbf{w}}},f_{\\widetilde{\\mathbf{x}}_i}}(\\mathbb{F}_q,L,H_0,H_2,H_1,\\max (\\rho_1,\\rho_2),\\widetilde{A}_i,\\widetilde{I}_{m / k},\\mathbf{0},\\mathrm{Ker}S\\circ \\psi)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  <span class="math">Q, Q&#x27; \\subseteq L</span>  be the sets of positions requested by  <span class="math">\\widetilde{\\mathbf{V}}</span>  respectively in the real and simulated protocol. Observe that, in the first case, by polynomial interpolation  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; \\beta<span class="math"> ,  </span>\\rho_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; m + \\beta<span class="math"> ,  </span>\\rho_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; n + \\beta<span class="math">  imply that  </span>\\widetilde{f}_{\\widetilde{\\mathbf{w}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q}, \\widetilde{f}_{\\widetilde{\\mathbf{x}}_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q}, \\widetilde{f}_{\\mathbf{t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q}<span class="math">  are uniform and mutually independent over  </span>\\mathbb{F}_q^Q<span class="math"> . The same holds by construction in the second one. In conclusion, since  </span>S_{\\mathrm{Row}}<span class="math">  and  </span>S_{\\mathrm{Mlin}_1}, S_{\\mathrm{Mlin}_2}$  receive correctly distributed oracles, they perfectly simulate the associated RS-encoded IOPP.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Efficiency: We upper bound computational costs in terms of multiplications over  <span class="math">\\mathbb{F}_q</span> . In this setting, assuming that  <span class="math">\\varphi(e_1), \\ldots, \\varphi(e_k)</span>  were precomputed before, computing  <span class="math">\\varphi(\\mathbf{x})</span>  for  <span class="math">\\mathbf{x} \\in \\mathbb{F}_2^k</span>  requires  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  additions, i.e. less than  </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  multiplications. Observe also that since  </span>\\varPhi<span class="math">  acts block-wise we have that for any vector  </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varPhi(\\mathbf{x})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">With this in mind the prover's costs before sending his codewords are</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_i<span class="math">  and  </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{b} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  to compute respectively  </span>\\widetilde{A}_i<span class="math">  and  </span>\\widetilde{\\mathbf{b}}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">m</span>  operations to compute  <span class="math">\\widetilde{I}_m</span></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varPhi(\\mathbf{b})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{b}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  to produce  </span>u\\widetilde{\\mathbf{b}}$ , used later</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">3m + n</span>  for  <span class="math">\\varPhi(\\mathbf{x}_i),\\varPhi(\\mathbf{w})</span>  and  <span class="math">m / k</span>  to get  <span class="math">\\varPhi(\\mathbf{x}_1)*\\varPhi(\\mathbf{x}_2)</span></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  $5 \\cdot \\mathrm{FFT}(\\mathbb{F}_q,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  to compute  </span>f_{\\widetilde{\\mathbf{w}}}, f_{\\widetilde{\\mathbf{x}}_i}, f_{\\mathbf{t}}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Next the costs coming from the sub-protocols, assuming RS-encoded IOPPs from  <span class="math">\\mathrm{[BCR^{+}19]}</span>  are used, are</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Nothing for the rowcheck as the verifier directly output a rational constraint</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  $7 \\cdot \\mathrm{FFT}(\\mathbb{F}_q,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) + 2m / k + \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 4\\lambda m / k + 3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 3\\lambda<span class="math">  for the first modular lincheck. Observe that we used  </span>2\\lambda m / k + \\lambda$  as an upper bound on the weight of the matrices and vectors used in lincheck subroutine.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $5 \\cdot \\mathrm{FFT}(\\mathbb{F}_q,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) + m / k + 2\\lambda m / k + 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 2\\lambda$ for each modular lincheck in the first block</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Finally, using an optimisation from [BCR⁺19] we can batch the sumchecks protocols used in each lincheck. This last cost amount to $3 \\cdot \\mathrm{FFT}(\\mathbb{F}_q,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) + O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log(n + m)) + 8</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. Summing up these terms yields the claimed complexity. On the verifier side, computation before receiving the codewords consists of</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_i<span class="math"> and </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{b}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> to compute </span>\\widetilde{A}_i<span class="math"> and </span>\\widetilde{\\mathbf{b}}$ respectively</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">m</span> operations to compute <span class="math">\\widetilde{I}_m</span>.</li>

    </ul>

    <p class="text-gray-300">Finally the costs coming from sub-protocols are</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>nothing for the rowcheck - as in the specific case of Aurora the constraint sent is independent from the verifier's input.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $\\lambda (\\log q - k) + 2m / k + \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{b}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\lambda +O(m + n)<span class="math"> from the first modular lincheck where </span>\\log q - k = \\dim \\mathrm{Ker}\\psi$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\lambda k + n / k + \\lambda + O(m + n)</span> from the second modular lincheck where we remind <span class="math">k = \\dim \\operatorname{Im} \\varphi</span>.</li>

      <li><span class="math">\\lambda k + m / k + \\lambda + O(m + n)</span> for each modular lincheck in the third block.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $\\lambda k + \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ m + \\lambda + O(m + n)$ for each execution of a modular lincheck in the last block.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">O(\\log^2(m + n) + 8)</span> from a batched execution of the sumcheck protocol, invoked by the 8 linear check.</li>

    </ul>

    <p class="text-gray-300">This concludes the proof.</p>

    <h2 id="sec-36" class="text-2xl font-bold">F Technical details on our comparison</h2>

    <p class="text-gray-300">We now provide additional informations on how we estimated numerically the argument size in section 5. For both Ligero and Aurora we consider the plain description in the respective papers with the following optimisations:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Column Hashing</strong>: When multiple oracles <span class="math">f_{1}, \\ldots, f_{n} \\in \\mathbb{F}_{q}^{\\ell}</span> of the same length are sent in the same round we interpret this as a single interleaved codeword over <span class="math">\\mathbb{F}_q^\\ell</span>. In this way it is not possible to open a single <span class="math">f_{i}</span> in a certain position without opening the other codewords, however this is not an issue in both Ligero and Aurora.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. <strong>Path Pruning</strong>: Instead of upper-bounding the number of hash values required to open <span class="math">f_{i} \\in \\mathbb{F}^{n}</span> on <span class="math">Q \\subseteq [n]</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log n<span class="math">, we omit redundant values in common between the accepting paths. As the resulting amount depends on </span>Q<span class="math"> (not only on </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$) we estimate the expected number of hash values required through a Monte Carlo simulation.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">43</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. Queries Collision: In FRI, in each repetitions of the QUERY procedure, queries are chosen with fresh randomness, meaning that they can possibly collide. We take this into account estimating the number of distinct queries through a Monte Carlo simulation. Observe however that this technique cannot be applied to Ligero, where $t =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ directly affects the resulting soundness.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Coset Hashing: In FRI, to show that <span class="math">f \\in \\mathbb{F}^L</span> has low degree the argument recursively reduces the size of <span class="math">L</span> and the degree of <span class="math">f</span>, creating a sequence of codeword <span class="math">f = f_0, \\ldots, f_r</span>, linear spaces <span class="math">L = L_0, \\ldots, L_r</span> and <span class="math">\\mathbb{F}_2</span>-linear maps <span class="math">q_0, \\ldots, q_r</span> such that <span class="math">L_{i+1} = q_i(L_i)</span>. To test consistency between the various oracles, <span class="math">f_i</span> is queried (multiple times) on a coset of <span class="math">\\operatorname{Ker} q_i</span>. For this reason we see <span class="math">f_i</span> as a codeword in <span class="math">\\mathbb{F}_q^{\\mathrm{Ker} q_i}</span> with smaller proof length, requiring therefore less hash values for openings.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5. Earlier direct LDT: As opposed to the version of FRI presented in [BBHR18a] where the reduction step is applied until the last codeword has small constant degree, after which the coefficients are sent in plain, we interrupt the reductions at step <span class="math">i</span> if the number of points queried in <span class="math">L_i</span> is larger than $\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, as in this case the verifier could recover </span>f_i$ through interpolation. This allows to reduce slightly the proof length, round complexity and the overall number of field elements sent.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In the case of Aurora, in order to present costs matching the one provided in [BCR⁺19], in Fig. 5 we distinguish two cases. The first one on the left uses values for the soundness proven in the original papers, in particular, the query soundness error for FRI with relative distance <span class="math">\\delta</span> is</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varepsilon_{\\mathbf{q}}(\\delta) = 1 - \\min(\\delta, \\delta_0), \\quad \\delta_0 = \\frac{1 - 3\\rho - 2^{\\eta} \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-1/2}}{4}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">On the right instead we use <span class="math">\\varepsilon_{\\mathbf{q}} = 1 - \\delta</span> as in libiop, that is the best possible value not in contradiction with currently known bounds, which leads to less queries. The second difference between the two graphs lies in the relative distance tested. In the graph on the left, calling <span class="math">(\\sigma^{<em>}, \\rho^{</em>})</span> the maximum rates,</p>

    <div class="my-4 text-center"><span class="math-block">\\delta \\leq \\min \\left(\\frac{1 - 2\\sigma^{*}}{2}, \\frac{1 - \\sigma^{*}}{3}, 1 - \\rho^{*}\\right),</span></div>

    <p class="text-gray-300">while in the graph on the right <span class="math">\\delta \\leq \\min(1 - \\rho^{<em>}, 1 - \\sigma^{</em>})</span> as in libiop. We stress that testing for a larger <span class="math">\\delta</span> significantly affects <span class="math">\\varepsilon_{\\mathbf{q}}</span> and so the proof size.</p>

    <p class="text-gray-300">In the case of Ligero we use used the parameters of Strong-Ligero due to recent improvements [BCI⁺20], i.e. we set the absolute proximity parameter as</p>

    <div class="my-4 text-center"><span class="math-block">e = \\left\\lfloor \\frac{n - 2k + 1}{3} \\right\\rfloor</span></div>

    <p class="text-gray-300">assuming the RS-code <span class="math">\\mathsf{RS}_{n,k/n}</span> is used to encode the extended witness. Moreover, as suggested in the paper, we estimate the query soundness error with the finer</p>

    <p class="text-gray-300">44</p>

    <p class="text-gray-300">bound</p>

    <div class="my-4 text-center"><span class="math-block">\\varepsilon_{\\mathbf{q}} \\leq \\max \\left( \\binom{n - e - 1}{t} \\binom{n}{t}^{-1}, \\binom{e + 2k - 2}{t} \\binom{n}{t}^{-1} \\right).</span></div>

    <p class="text-gray-300">Notice that in this expression we excluded the soundness error associated to linear tests as it is always smaller than the error associated to quadratic tests, that is the second term.</p>

    <p class="text-gray-300">45</p>`;
---

<BaseLayout title="On Interactive Oracle Proofs for Boolean R1CS Statements (2021/694)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2021 &middot; eprint 2021/694
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
