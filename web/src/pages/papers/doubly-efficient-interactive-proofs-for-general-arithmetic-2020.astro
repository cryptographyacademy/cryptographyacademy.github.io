---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/1247';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Doubly Efficient Interactive Proofs for General Arithmetic Circuits with Linear Prover Time';
const AUTHORS_HTML = 'Jiaheng Zhang, Tianyi Liu, Weijie Wang, Yinuo Zhang, Dawn Song, Xiang Xie, Yupeng Zhang';

const CONTENT = `    <p class="text-gray-300">JIAHENG ZHANG<em>, TIANYI LIU<strong>, WELJIE WANG</strong></em>, YINUO ZHANG<em>, DAWN SONG</em>, XIANG XIE†, YUPENG ZHANG**.</p>

    <p class="text-gray-300">Abstract. We propose a new doubly efficient interactive proof protocol for general arithmetic circuits. The protocol generalizes the interactive proof for layered circuits proposed by Goldwasser, Kalai and Rothblum to arbitrary circuits, while preserving the optimal prover complexity that is strictly linear to the size of the circuits. The proof size remains succinct for low depth circuits and the verifier time is sublinear for structured circuits. We then construct a new zero knowledge argument scheme for general arithmetic circuits using our new interactive proof protocol together with polynomial commitments.</p>

    <p class="text-gray-300">Our key technique is a new sumcheck equation that reduces a claim about the output of one layer to claims about its input only, instead of claims about all the layers above which inevitably incurs an overhead proportional to the depth of the circuit. We developed efficient algorithms for the prover to run this sumcheck protocol and to combine multiple claims back into one in linear time in the size of the circuit.</p>

    <p class="text-gray-300">Not only does our new protocol achieve optimal prover complexity asymptotically, but it is also efficient in practice. Our experiments show that it only takes 0.3 seconds to generate the proof for a circuit with more than 600,000 gates, which is 13 times faster than the original interactive proof protocol on the corresponding layered circuit. The proof size is 208 kilobytes and the verifier time is 66 milliseconds. Our implementation can take general arithmetic circuits directly, without transforming them to layered circuits with a high overhead on the size of the circuit.</p>

    <h2 id="sec-2" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Interactive proofs allow a powerful yet untrusted prover to convince a verifier through a sequence of interactions that the result of a computation is correctly computed. Since they were introduced by Goldwasser, Micali, and Rackoff [15] in the 1980s, interactive proofs have expanded people's understanding on traditional static mathematical proofs and led to many important theoretical results in complexity theory, such as IP=PSPACE [16, 20] and MIP=NEXP [7].</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>University of California, Berkeley. Email: {jiaheng_zhang,yinuo, dawnsong}@berkeley.edu.</li>

    </ul>

    <p class="text-gray-300"><strong> Texas A&amp;M University. Email: {tianyi,zhangyp}@tamu.edu. </strong>* Shanghai Jiao Tong University. Email: wangnick@sjtu.edu.cn. † Shanghai Key Laboratory of Privacy-Preserving Computation. Email: xiexiang@matrixelements.com.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In recent years, there is great progress on turning interactive proofs from purely theoretical constructions to practical schemes with efficient implementations. In the seminal work of <em>[14]</em>, Goldwasser, Kalai and Rothblum proposed doubly efficient interactive proofs where the prover can convince the verifier the correctness of the evaluation of a layered arithmetic circuit with addition gates and multiplication gates of fan-in two. The time for the prover to generate all the messages during the protocol (prover time) is a polynomial on the size of the circuit, and the time to validate the result (verifier time) is close to linear in the size of the input for log-space uniform circuits, thus the name “doubly efficient”. The total communication between the prover and the verifier is only poly-logarithmic in the size of the circuit and linear in the depth of the circuit, which is <em>succinct</em> for bounded-depth circuits. We refer the protocol in <em>[14]</em> as the GKR protocol in this paper. Later, researchers spent great effort improving the concrete efficiency of the GKR protocol. The prover time was improved to quasi-linear ($O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">) in <em>[13]</em>, and then to close to linear for various circuits with different structures <em>[21, 23, 30]</em>. Finally, in <em>[26]</em>, Xie et al. proposed an algorithm to improve the prover time to strictly linear (</span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$) for layered arithmetic circuits without assuming any structures, which is asymptotically optimal and very efficient in practice.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Another important advance of interactive proofs is using them to construct efficient zero knowledge argument schemes. In <em>[28]</em>, Zhang et al. first proposed to combine the GKR protocol with polynomial commitments to build argument systems, where the prover can further prove to the verifier the computations on the prover’s witness, without sending the witness directly to the verifier. Following the framework, there are many subsequent zero knowledge argument constructions based on interactive proofs, including <em>[18, 24, 26, 27, 29]</em>. These schemes demonstrate great prover efficiency and can achieve sublinear verifier time for structured circuits, thanks to the advantages of the interactive proofs and the GKR protocol.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Despite the progress of the GKR protocol, a major drawback is that the protocol only works for layered arithmetic circuits. Each gate can only connect to the layer above, due to the layer-by-layer reduction of the GKR protocol. In practice, it introduces a high overhead to pad general circuits to layered circuits using relay gates. Asymptotically, the circuit size increases from $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> to </span>O(d</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> where </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is the size of the general circuit and </span>d$ is the depth of the circuit. This is easily 1-2 orders of magnitude larger in practice as we show in our experiments, and introduces a big overhead on the prover time. Moreover, it is also inconvenient to implement circuits in a strictly layered way, and most existing tools such as rank-1-constraint-system (R1CS) cannot be used directly. Therefore, in this paper we ask the following question:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Is it possible to generalize the GKR protocol to directly support general circuits, without introducing any overhead on the prover time?</p>

    <p class="text-gray-300">1.1 Our Contributions</p>

    <p class="text-gray-300">We answer the above question affirmatively by proposing a generalized doubly efficient interactive proofs for arbitrary arithmetic circuits, where each gate can take the output of any gate as input. The prover time is still linear to the size of the circuit, and is very efficient in practice. In particular, our contributions are:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- We generalize the GKR protocol to work on arbitrary arithmetic circuits efficiently for the first time. For a general circuit of size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and depth </span>d<span class="math">, the prover time is </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, the same as the original GKR protocol on a layered circuit with the same size. The overhead on the proof size and the verifier time is minimal. The proof size in our new protocol is </span>\\min\\{O(d\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+d^{2}),O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\}<span class="math">. For structured circuits, the verifier time is also </span>\\min\\{O(d\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+d^{2}),O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\}<span class="math">. Those in the original GKR are </span>\\min\\{O(d\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">),O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Together with zero knowledge polynomial commitments, we construct zero knowledge arguments for general arithmetic circuits. The zero knowledge version of our interactive proof protocols does not incur any overhead asymptotically on the prover time, the proof size and the verifier time compared to the plain version without zero knowledge.</li>

      <li>We fully implement a system, <span class="math">\\mathsf{virgo}++</span>, for our new interactive proof protocols and zero knowledge arguments. We show that on random circuits with <span class="math">d=50</span> and <span class="math">d=75</span>, our new protocols are 9-13<span class="math">\\times</span> faster than the state-of-the-art GKR protocol on the corresponding layered circuits. The prover time per gate (the constant in the linear complexity) is only 1.3<span class="math">\\times</span> more than the original GKR protocol on layered circuits. Therefore, as long as padding the general circuit to layered circuit makes the size 1.3<span class="math">\\times</span> or larger, our new protocol will have faster prover time. The verifier time of our new protocols is 17-25<span class="math">\\times</span> faster, while the proof size is only slightly larger than GKR on layered circuits.</li>

    </ul>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.2 Technical Overview</h3>

    <p class="text-gray-300">The key idea of the GKR protocol is to write the values in the <span class="math">i</span>-th layer of the circuit as an equation of the values in the previous layer <span class="math">i+1</span>. Then starting from the output layer (layer 0), <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> reduce the correctness of the values in layer <span class="math">i</span> to the correctness of the values in layer <span class="math">i+1</span> recursively, and eventually to the correctness of the input. <span class="math">\\mathcal{V}</span> can then validates the correctness of the input on her own, which completes the reduction and guarantees that the output is correctly computed. To do so, we use the notation of multilinear extension <span class="math">\\tilde{V}_{i}()</span> of the <span class="math">i</span>-th layer in <em>[22]</em>, which is a multilinear polynomial that agrees with all the values in the <span class="math">i</span>-th layer on the Boolean hypercube, i.e., <span class="math">\\tilde{V}_{i}(0,0,\\ldots,0)=\\mathbf{V}_{i}[0],\\tilde{V}_{i}(0,0,\\ldots,1)=\\mathbf{V}_{i}[1],\\ldots</span> where <span class="math">\\mathbf{V}_{i}</span> is the array representing the values in the <span class="math">i</span>-th layer of the circuit. Assuming for simplicity that all layers have <span class="math">S</span> gates and <span class="math">\\tilde{V}</span> takes <span class="math">s=\\log S</span> variables, we can write <span class="math">\\tilde{V}_{i}()</span> as a equation of <span class="math">\\tilde{V}_{i+1}()</span>:</p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(z)=\\sum_{x,y\\in\\{0,1\\}^{z}}(\\overset{-}{a\\overset{-}{d}}d_{i+1}(z,x,y)(\\tilde{V}_{i+1}(x)+\\tilde{V}_{i+1}(y))+\\overset{-}{m\\overset{-}{u}}lt_{i+1}(z,x,y)\\tilde{V}_{i+1}(x)\\tilde{V}_{i+1}(y))</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">for all <span class="math">z\\in\\{0,1\\}^{s}</span>, where <span class="math">\\tilde{a}\\tilde{d}d_{i+1}(z,x,y)</span> and <span class="math">\\tilde{m}\\tilde{u}lt_{i+1}(z,x,y)</span> are polynomials describing the addition/multiplication gates and their connections in the circuit between layer <span class="math">i</span> and layer <span class="math">i+1</span>. With this equation, the GKR protocol invokes the sumcheck protocol (See Section 2.2), which reduces the correctness of <span class="math">\\tilde{V}_{i}(g)</span> at a random point <span class="math">g\\in\\mathbb{F}^{s}</span> to the correctness of <span class="math">\\tilde{V}_{i+1}(u)</span> and <span class="math">\\tilde{V}_{i+1}(v)</span> at two random points <span class="math">u,v\\in\\mathbb{F}^{s}</span>. Then <span class="math">\\tilde{V}_{i+1}(u)</span> and <span class="math">\\tilde{V}_{i+1}(v)</span> can be combined back to a single evaluation of <span class="math">\\tilde{V}_{i+1}(w)</span> for <span class="math">w\\in\\mathbb{F}^{s}</span>. At this point, <span class="math">\\tilde{V}_{i+1}(w)</span> can be further reduced to an evaluation of <span class="math">\\tilde{V}_{i+2}</span> using the same equation and protocol for layer <span class="math">i+1</span>. Therefore, starting from the output layer, <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> perform the reduction layer by layer to the input layer, which can be validated by <span class="math">\\mathcal{V}</span> directly. The prover time is <span class="math">O(S)</span> in each layer <em>[26]</em> and the proof size is only <span class="math">O(\\log S)</span>. Therefore, the total prover time is $O(dS)=O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> and the proof size is </span>O(d\\log S)=O(d\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Extending GKR to general circuits naively. The above equation relies on the fact that gates in layer <span class="math">i</span> can only take input from gates in layer <span class="math">i+1</span>. In a general circuit, a gate in layer <span class="math">i</span> can take input from any gate in layer <span class="math">j</span> for <span class="math">j&gt;i</span>. As circuits cannot contain cycles (otherwise we cannot get outputs of the circuit), we can still assign a layer number to each gate in the topological order. Thus a gate can take input from any gate in layers above, but not below. More interestingly, every gate in layer <span class="math">i</span> has to have at least one input from layer <span class="math">i+1</span>, otherwise it cannot belong to layer <span class="math">i</span> in the topological order. Because of this generalization, we can write <span class="math">\\tilde{V}_{i}()</span> as:</p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(z)</span> <span class="math">=\\sum_{x,y\\in\\{0,1\\}^{s}}(\\tilde{a}\\tilde{d}d_{i+1,i+1}(z,x,y)(\\tilde{V}_{i+1}(x)+\\tilde{V}_{i+1}(y))</span> <span class="math">+\\tilde{m}\\tilde{u}lt_{i+1,i+1}(z,x,y)(\\tilde{V}_{i+1}(x)\\tilde{V}_{i+1}(y))</span> <span class="math">+\\tilde{a}\\tilde{d}d_{i+1,i+2}(z,x,y)(\\tilde{V}_{i+1}(x)+\\tilde{V}_{i+2}(y))+\\tilde{m}\\tilde{u}lt_{i+1,i+2}(z,x,y)(\\tilde{V}_{i+1}(x)\\tilde{V}_{i+2}(y))</span> <span class="math">+\\ldots+\\tilde{a}\\tilde{d}d_{i+1,d}(z,x,y)(\\tilde{V}_{i+1}(x)+\\tilde{V}_{d}(y))+\\tilde{m}\\tilde{u}lt_{i+1,d}(z,x,y)(\\tilde{V}_{i+1}(x)\\tilde{V}_{d}(y))).</span></p>

    <p class="text-gray-300">Namely, we have multiple parts in the summation, one for each layer <span class="math">j=i+1,i+2,\\ldots,d</span>. <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> run the sumcheck protocol on this equation, which reduces the correctness of <span class="math">\\tilde{V}_{i}(g)</span> at a random point <span class="math">g\\in\\mathbb{F}^{s}</span> to the correctness of <span class="math">\\tilde{V}_{i+1}(u)</span> and <span class="math">\\tilde{V}_{i+1}(v),\\tilde{V}_{i+2}(v),\\ldots,\\tilde{V}_{d}(v)</span> at random points <span class="math">u,v\\in\\mathbb{F}^{s}</span>. Moreover, when reaching layer <span class="math">i+1</span>, now <span class="math">\\mathcal{V}</span> has many evaluations about <span class="math">\\tilde{V}_{i+1}</span> instead of just two. In the sumcheck protocols of all layers below, <span class="math">\\mathcal{V}</span> has received one evaluation of <span class="math">\\tilde{V}_{i+1}</span> from the sumcheck of layer <span class="math">k=0,\\ldots,i-1</span>, and two evaluations from layer <span class="math">i</span>. Nevertheless, <span class="math">\\mathcal{V}</span> can combine all these evaluations into one evaluation <span class="math">\\tilde{V}_{i+1}(w)</span> using the original protocol multiple times with <span class="math">\\mathcal{P}</span>. <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> can then run the protocol recursively layer by layer just as the original GKR protocol to reduce the correctness of the output layer to the input layer.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">It is not hard to show that the generalized protocol is secure. However, it introduces a big overhead on the prover time. The size of all the polynomials in the generalized equation becomes <span class="math">O((d-i)S)</span>, and the total prover time for the sumcheck protocol of all layers becomes $O(dS+(d-1)S+\\ldots+S)=O(d^{2}S)=O(d</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. This is as bad as padding the general circuit to a layered circuit and running the original GKR protocol on it. Even worse, the second step of combining multiple evaluations into one also introduces a prover time of </span>O(d</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, because there are now </span>i+1$ evaluations to combine instead of two.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Extending GKR to general circuits with optimal prover time. In order to preserve the linear prover time, we introduce two new techniques. First, we observe that the key reason why the prover time of the sumcheck protocol on the generalized equation becomes <span class="math">O((d-i)S)</span> is that the multilinear extension <span class="math">\\tilde{V}_{j}</span> of the entire layer <span class="math">j</span> for <span class="math">j&gt;i</span> is used. As layer <span class="math">j</span> has <span class="math">S</span> gates and its multilinear extension is uniquely defined by these gates, merely writing out all the polynomials <span class="math">\\tilde{V}_{j}</span> for <span class="math">j&gt;i</span> takes <span class="math">O((d-i)S)</span> time. There is no hope to reduce the prover time if we define the equation in this way. Meanwhile, it is also not necessary to use all the gates in layers above, because gates in layer <span class="math">i</span> can at most take input from <span class="math">2S</span> gates in total. Therefore, we propose a new equation to write <span class="math">\\tilde{V}_{i}</span> as a function of multilinear extensions define by <em>only those values used by layer <span class="math">i</span></em> from layer <span class="math">j&gt;i</span>. In particular, we have</p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(z)</span> <span class="math">=\\sum\\nolimits_{x,y\\in\\{0,1\\}^{s^{\\prime}}}(a\\tilde{d}d_{i+1,i+1}(z,x,y)(\\tilde{V}_{i,i+1}(x)+\\tilde{V}_{i,i+1}(y))</span> <span class="math">+\\hat{mutl}t_{i+1,i+1}(z,x,y)(\\tilde{V}_{i,i+1}(x)\\tilde{V}_{i,i+1}(y))</span> <span class="math">+\\hat{a}\\tilde{d}d_{i+1,i+2}(z,x,y)(\\tilde{V}_{i,i+1}(x)+\\tilde{V}_{i,i+2}(y))+\\hat{mutl}t_{i+1,i+2}(z,x,y)\\tilde{V}_{i,i+1}(x)\\tilde{V}_{i,i+2}(y)</span> <span class="math">+\\ldots+\\hat{a}\\tilde{d}d_{i+1,d}(z,x,y)(\\tilde{V}_{i,i+1}(x)+\\tilde{V}_{i,d}(y))+\\hat{mutl}t_{i+1,d}(z,x,y)\\tilde{V}_{i,i+1}(x)\\tilde{V}_{i,d}(y)),</span></p>

    <p class="text-gray-300">where <span class="math">\\tilde{V}_{i,j}</span> is the multilinear extension of values used by layer <span class="math">i</span> from layer <span class="math">j</span> for <span class="math">j&gt;i</span> arranged in a pre-defined order, i.e., a subset of the values in the entire layer <span class="math">j</span>. Now the total size of the all these polynomials is bounded by <span class="math">2S</span>. We also change the range of the summation from <span class="math">\\{0,1\\}^{s}</span> to <span class="math">\\{0,1\\}^{s^{\\prime}}</span> to informally denote that now the number of variables is smaller. We will show how to deal with different sizes from different layers in our formal protocols. We then design a new algorithm for the prover to run the sumcheck protocol on the equation above with time complexity <span class="math">O(S)</span> by utilizing the sparsity of the polynomials <span class="math">\\hat{a}\\tilde{d}d</span> and <span class="math">\\hat{mutl}</span>. The formal algorithms are presented in Section 3.2.</p>

    <p class="text-gray-300">Combining evaluations of different multilinear extensions. At the end of the sumcheck protocol on the equation above, <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> reduce the correctness of <span class="math">\\tilde{V}_{i}(g)</span> at a random point <span class="math">g\\in\\mathbb{F}^{s}</span> to the correctness of <span class="math">\\tilde{V}_{i,i+1}(u)</span> and <span class="math">\\tilde{V}_{i,i+1}(v),\\tilde{V}_{i,i+2}(v),\\ldots,\\tilde{V}_{i,d}(v)</span> at random points <span class="math">u,v\\in\\mathbb{F}^{s^{\\prime}}</span>. When reaching layer <span class="math">i+1</span>, <span class="math">\\mathcal{V}</span> has many evaluations of multilinear extensions of <em>subsets</em> of <span class="math">\\mathbf{V}_{i+1}</span>. Now we cannot even use the original protocol to combine these points into one, as they are evaluations of <em>different</em> multilinear extensions, not to mention that we want to reduce the complexity of the prover time in this step. Our second technique is to compute them using a layered arithmetic circuit and reduce these evaluations to a single evaluation of <span class="math">\\tilde{V}_{i}</span> through the original GKR protocol. At this point, the random points in these evaluations are already fixed by the verifier. We construct a circuit whose input is the values <span class="math">\\mathbf{V}_{i+1}</span> of the entire layer <span class="math">i+1</span>, and all the random points in the evaluations, denoted as <span class="math">v^{(0)},v^{(1)},\\ldots,v^{(i)}</span> and <span class="math">u^{(i)}</span>. The output of the circuit is exactly the evaluations of the multilinear extensions of the subsets, received from the sumcheck protocols for all layers below, i.e., <span class="math">\\tilde{V}_{0,i+1}(v^{(0)}),\\tilde{V}_{1,i+1}(v^{(1)}),\\ldots,\\tilde{V}_{i,i+1}(v^{(i)})</span> and <span class="math">\\tilde{V}_{i,i+1}(u^{(i)})</span>. To compute the output, the circuit selects all the subsets from input <span class="math">\\mathbf{V}_{i}</span> and arrange them in the predefined order, which can be determined by the structure of</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">the general circuit. The circuit then evaluates the multilinear extensions defined by these subsets at points from input <span class="math">v^{(0)},v^{(1)},\\ldots,v^{(i)}</span> and <span class="math">u^{(i)}</span>. By executing the original GKR protocol on this circuit, <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> reduce the correctness of <span class="math">\\tilde{V}_{0,i+1}(v^{(0)}),\\tilde{V}_{1,i+1}(v^{(1)}),\\ldots,\\tilde{V}_{i,i+1}(v^{(i)})</span> and <span class="math">\\tilde{V}_{i,i+1}(u^{(i)})</span> to a single evaluation of the input. As part of the input <span class="math">v^{(0)},v^{(1)},\\ldots,v^{(i)}</span> and <span class="math">u^{(i)}</span> are known to the verifier, it is easy to subtract it from the evaluation and obtain <span class="math">\\tilde{V}_{i}(w)</span>, a single evaluation of the multilinear extension <span class="math">\\tilde{V}_{i}</span> at a random point <span class="math">w\\in\\mathbb{F}^{s}</span>. With this single evaluation, <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> can continue the sumcheck for layer <span class="math">i+1</span> recursively and proceed all the way to the input layer. With proper design, we are able to bound the total size of this circuit in all rounds by $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Therefore, the prover complexity in this step is also </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$. See Figure 1 and Section 3.3 for the design of the circuit and the details of the protocol.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Furthermore, inspired by the structure of this circuit, we are able to design a single sumcheck protocol to combine multiple claims on the subsets to a single evaluation of <span class="math">\\tilde{V}_{i}</span> at a random point. This second approach further improves the prover time, the proof size and the verifier time. Putting the two steps together, we are able to construct a generalized GKR protocol for arbitrary arithmetic circuits while maintaining the optimal prover time of $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Building zero knowledge arguments. Finally, following the framework of <em>[12, 24, 26, 27, 28]</em>, we build zero knowledge arguments for general arithmetic circuits using our new protocol. We use the standard techniques of zero knowledge sumcheck and low degree extensions in <em>[12, 26]</em> to lift our generalized GKR protocol to be zero knowledge, and use the polynomial commitment scheme in <em>[27]</em> to make the protocol a zero knowledge argument.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.3 Related Work</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Interactive proofs were formalized by Goldwasser, Micali, and Rackoff in <em>[15]</em>. In the seminal work of <em>[14]</em>, Goldwasser et al. proposed the doubly efficient interactive proof for layered arithmetic circuits. Later, Cormode et al. improved the prover time of the GKR protocol from $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{3})<span class="math"> to </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> using multilinear extensions instead of low degree extensions in <em>[13]</em>. Several follow-up papers further reduce the prover time for circuits with special structures. Justin Thaler <em>[21]</em> introduced a protocol with </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> prover time for regular circuits where the wiring pattern can be described in constant space and time. In the same work, a protocol with prove time </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> was proposed for data parallel circuits with many copies of small circuits of size </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. The complexity was further improved to </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> by Wahby et al. in <em>[23]</em>. For circuits with many non-connected but different copies, Zhang et al. <em>[30]</em> showed a protocol with </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> prover time. Eventually, Xie et al. <em>[26]</em> proposed a variant of the GKR protocol with </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ prover time for arbitrary layered arithmetic circuits. All these existing works follow the layered structure of the GKR protocol and doubly efficient interactive proofs for general arithmetic circuits have not been considered before.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In <em>[28]</em>, Zhang et al. extended the GKR protocol to an argument system using polynomial commitments. Subsequent works <em>[18, 24, 26, 27, 29]</em> followed the</p>

    <p class="text-gray-300">framework and constructed efficient zero knowledge argument schemes based on interactive proofs. We follow the approach of <em>[12, 26, 27]</em> and constructs zero knowledge arguments for general circuits instead of layered circuits. Notably, there is a recent work <em>[18]</em> on constructing interactive proof-based zero knowledge arguments for R1CS. The protocol reduces the R1CS to a polynomial commitment on the entire extended witness of all the values in the circuit using one sumcheck. On the contrary, the GKR protocols reduce the evaluation of the circuit to only the input of the circuit. As the polynomial commitments are usually the overhead of the zero knowledge argument schemes, we expect that our scheme has faster prover time, while the scheme in <em>[18]</em> has smaller proof size. We give detailed comparisons in Section 5.2. In addition, the scheme in <em>[18]</em> cannot be used for delegation of computations, which is the original goal of the GKR protocols. In a recent manuscript <em>[19]</em>, the proof size of the scheme in <em>[18]</em> is improved from square-root to logarithmic in the size of the R1CS instance, but the prover time is <span class="math">3.8\\times</span> slower. In a different setting, Blumberg et al. <em>[10]</em> construct argument schemes using interactive proofs with two provers.</p>

    <p class="text-gray-300">There is a rich literature of zero knowledge arguments other than schemes based on interactive proofs. Categorized by their underlying techniques, there are schemes based on quadratic arithmetic programs (QAP) <em>[17]</em>, interactive oracle proofs (IOP) <em>[9]</em>, discrete-log <em>[11]</em>, MPC-in-the-head <em>[6]</em> and lattice <em>[8]</em>. We refer the readers to surveys <em>[25]</em> and recent papers <em>[18]</em> on zero knowledge proofs and arguments for a more comprehensive list of schemes.</p>

    <h2 id="sec-5" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">We use <span class="math">\\mathsf{negl}(\\cdot):\\mathbb{N}\\to\\mathbb{N}</span> to denote the negligible function, where for each positive polynomial <span class="math">f(\\cdot)</span>, <span class="math">\\mathsf{negl}(k)&lt;\\frac{1}{f(k)}</span> for sufficiently large integer <span class="math">k</span>. Let <span class="math">\\lambda</span> denote the security parameter. “PPT” stands for probabilistic polynomial time. We use <span class="math">f(),g()</span> for polynomials, <span class="math">x,y,z</span> for vectors of variables and <span class="math">g,u,v</span> for vectors of values. <span class="math">x_{i}</span> denotes the <span class="math">i</span>-th variable in <span class="math">x</span>. We use bold letters such as <span class="math">\\mathbf{A}</span> to represent arrays. For a multivariate polynomial <span class="math">f</span>, its “variable-degree” is the maximum degree of <span class="math">f</span> in any of its variables.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">2.1 Interactive Proofs</h3>

    <p class="text-gray-300">Interactive proofs. An interactive proof allows a prover <span class="math">\\mathcal{P}</span> to convince a verifier <span class="math">\\mathcal{V}</span> the validity of some statement. The interactive proof runs in several rounds, allowing <span class="math">\\mathcal{V}</span> to ask questions in each round based on <span class="math">\\mathcal{P}</span>’s answers of previous rounds. We phrase this in terms of <span class="math">\\mathcal{P}</span> trying to convince <span class="math">\\mathcal{V}</span> that <span class="math">C(x)=y</span>. We formalize interactive proofs in the following:</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Definition 1.</h6>

    <p class="text-gray-300">Let <span class="math">C</span> be a function. A pair of interactive machines <span class="math">\\langle\\mathcal{P},\\mathcal{V}\\rangle</span> is an interactive proof for <span class="math">f</span> with soundness <span class="math">\\epsilon</span> if the following holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. For every <span class="math">x</span> such that <span class="math">C(x)=y</span> it holds that <span class="math">\\Pr[\\langle\\mathcal{P},\\mathcal{V}\\rangle(x)=accept]=1</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\epsilon</span>-Soundness. For any <span class="math">x</span> with <span class="math">C(x) \\neq y</span> and any <span class="math">\\mathcal{P}^<em></span> it holds that <span class="math">\\operatorname</em>{Pr}[\\langle \\mathcal{P}^*, \\mathcal{V} \\rangle = \\text{accept}] \\leq \\epsilon</span></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We say an interactive proof scheme has succinct proof size (verifier time) if the total communication (verifier time) is $O(\\mathsf{polylog}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-8" class="text-2xl font-bold">2.2 Doubly Efficient Interactive Proofs for Layered Circuits</h2>

    <p class="text-gray-300">In [14], Goldwasser et al. proposed an efficient interactive proof protocol for layered arithmetic circuits. We present the details of the protocol here.</p>

    <p class="text-gray-300"><strong>Sumcheck Protocol</strong> The GKR protocol uses the sumcheck protocol as a major building block. The problem is to sum a multivariate polynomial <span class="math">f: \\mathbb{F}^{\\ell} \\to \\mathbb{F}</span> on the Boolean hypercube: <span class="math">\\sum_{b_1, b_2, \\ldots, b_\\ell \\in \\{0, 1\\}} f(b_1, b_2, \\ldots, b_\\ell)</span>. Directly computing the sum requires exponential time in <span class="math">\\ell</span>, as there are <span class="math">2^{\\ell}</span> combinations of <span class="math">b_1, \\ldots, b_\\ell</span>. Lund et al. [16] proposed a <em>sumcheck</em> protocol that allows a verifier <span class="math">\\mathcal{V}</span> to delegate the computation to a computationally unbounded prover <span class="math">\\mathcal{P}</span>, who can convince <span class="math">\\mathcal{V}</span> that <span class="math">H</span> is the correct sum. We provide a description of the sumcheck protocol in Protocol 1.</p>

    <p class="text-gray-300"><strong>Protocol 1 (Sumcheck).</strong> The protocol proceeds in <span class="math">\\ell</span> rounds.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In the first round, <span class="math">\\mathcal{P}</span> sends a univariate polynomial</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">f _ {1} \\left(x _ {1}\\right) \\stackrel {\\text {d e f}} {=} \\sum_ {b _ {2}, \\dots , b _ {\\ell} \\in \\{0, 1 \\}} f \\left(x _ {1}, b _ {2}, \\dots , b _ {\\ell}\\right),</span></div>

    <p class="text-gray-300"><span class="math">\\mathcal{V}</span> checks <span class="math">H = f_{1}(0) + f_{1}(1)</span>. Then <span class="math">\\mathcal{V}</span> sends a random challenge <span class="math">r_1\\in \\mathbb{F}</span> to <span class="math">\\mathcal{P}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In the <span class="math">i</span>-th round, where <span class="math">2 \\leq i \\leq \\ell - 1</span>, <span class="math">\\mathcal{P}</span> sends a univariate polynomial</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">f _ {i} \\left(x _ {i}\\right) \\stackrel {\\text {d e f}} {=} \\sum_ {b _ {i + 1}, \\dots , b _ {\\ell} \\in \\{0, 1 \\}} f \\left(r _ {1}, \\dots , r _ {i - 1}, x _ {i}, b _ {i + 1}, \\dots , b _ {\\ell}\\right),</span></div>

    <p class="text-gray-300"><span class="math">\\mathcal{V}</span> checks <span class="math">f_{i - 1}(r_{i - 1}) = f_i(0) + f_i(1)</span>, and sends a random challenge <span class="math">r_i\\in \\mathbb{F}</span> to <span class="math">\\mathcal{P}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In the <span class="math">\\ell</span>-th round, <span class="math">\\mathcal{P}</span> sends a univariate polynomial</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">f _ {\\ell} \\left(x _ {\\ell}\\right) \\stackrel {\\text {d e f}} {=} f \\left(r _ {1}, r _ {2}, \\dots , r _ {l - 1}, x _ {\\ell}\\right),</span></div>

    <p class="text-gray-300"><span class="math">\\mathcal{V}</span> checks <span class="math">f_{\\ell -1}(r_{\\ell -1}) = f_{\\ell}(0) + f_{\\ell}(1)</span>. The verifier generates a random challenge <span class="math">r_\\ell \\in \\mathbb{F}</span>. Given oracle access to an evaluation <span class="math">f(r_1,r_2,\\ldots ,r_\\ell)</span> of <span class="math">f</span>, <span class="math">\\mathcal{V}</span> will accept if and only if <span class="math">f_{\\ell}(r_{\\ell}) = f(r_{1},r_{2},\\dots,r_{\\ell})</span>. The instantiation of the oracle access depends on the application of the sumcheck protocol.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The proof size of the sumcheck protocol is <span class="math">O(\\tau \\ell)</span>, where <span class="math">\\tau</span> is the variable-degree of <span class="math">f</span>, as in each round, <span class="math">\\mathcal{P}</span> sends a univariate polynomial of one variable in <span class="math">f</span>, which can be uniquely defined by <span class="math">\\tau + 1</span> points. The verifier time of the protocol is <span class="math">O(\\tau \\ell)</span>. The prover time depends on the degree and the sparsity of <span class="math">f</span>, and we will give the complexity later in our scheme. The sumcheck protocol is complete and sound with $\\epsilon = \\frac{\\tau \\ell}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">8</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Definition 2 (Multi-linear Extension).</h6>

    <p class="text-gray-300">Let <span class="math">V:\\{0,1\\}^{\\ell}\\to\\mathbb{F}</span> be a function. The multilinear extension of <span class="math">V</span> is the unique polynomial <span class="math">\\tilde{V}:\\mathbb{F}^{\\ell}\\to\\mathbb{F}</span> such that <span class="math">\\tilde{V}(x_{1},x_{2},...,x_{\\ell})=V(x_{1},x_{2},...,x_{\\ell})</span> for all <span class="math">x_{1},x_{2},\\ldots,x_{\\ell}\\in\\{0,1\\}</span>. <span class="math">\\tilde{V}</span> can be expressed as:</p>

    <p class="text-gray-300"><span class="math">\\tilde{V}(x_{1},x_{2},...,x_{\\ell})=\\sum\\nolimits_{b\\in\\{0,1\\}^{\\ell}}\\prod\\nolimits_{i=1}^{\\ell}((1-x_{i})(1-b_{i})+x_{i}b_{i}))\\cdot V(b)\\,,</span></p>

    <p class="text-gray-300">where <span class="math">b_{i}</span> is <span class="math">i</span>-th bit of <span class="math">b</span>.</p>

    <p class="text-gray-300">Multilinear extensions of arrays. Inspired by the closed-form equation of the multilinear extension given above, we can view an array <span class="math">\\mathbf{A}=(a_{0},a_{1},\\ldots,a_{n-1})</span> as a function <span class="math">A:\\{0,1\\}^{\\log n}\\to\\mathbb{F}</span> such that <span class="math">\\forall i\\in[0,n-1],A(i_{1},\\ldots,i_{\\log n})=a_{i}</span>. Here we assume <span class="math">n</span> is a power of <span class="math">2</span>. Therefore, in this paper, we abuse the use of multilinear extension on an array as the multilinear extension <span class="math">\\tilde{A}</span> of <span class="math">A</span>.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 3 (Identity function).</h6>

    <p class="text-gray-300">Let <span class="math">\\beta:\\{0,1\\}^{\\ell}\\times\\{0,1\\}^{\\ell}\\to\\{0,1\\}</span> be the identity function such that <span class="math">\\beta(x,y)=1</span> if <span class="math">x=y</span>, and <span class="math">\\beta(x,y)=0</span> otherwise. Suppose <span class="math">\\tilde{\\beta}</span> is the multilinear extension of <span class="math">\\beta</span>. Then <span class="math">\\tilde{\\beta}</span> can be expressed as: <span class="math">\\tilde{\\beta}(x,y)=\\prod_{i=1}^{\\ell}((1-x_{i})(1-y_{i})+x_{i}y_{i})</span>.</p>

    <p class="text-gray-300">GKR Protocol. Using the sumcheck protocol as a building block, Goldwasser et al. <em>[14]</em> showed an interactive proof protocol for layered arithmetic circuits. Let <span class="math">C</span> be a layered arithmetic circuit with depth <span class="math">d</span> over a finite field <span class="math">\\mathbb{F}</span>. Each gate in the <span class="math">i</span>-th layer takes inputs from two gates in the <span class="math">(i+1)</span>-th layer; layer <span class="math">0</span> is the output layer and layer <span class="math">d</span> is the input layer. The protocol proceeds layer by layer. Upon receiving the claimed output from <span class="math">\\mathcal{P}</span>, in the first round, <span class="math">\\mathcal{V}</span> and <span class="math">\\mathcal{P}</span> run the sumcheck protocol to reduce the claim about the output to a claim about the values in the layer above. In the <span class="math">i</span>-th round, both parties reduce a claim about layer <span class="math">i-1</span> to a claim about layer <span class="math">i</span> through the sumcheck protocol. Finally, the protocol terminates with a claim about the input layer <span class="math">d</span>, which can be checked directly by <span class="math">\\mathcal{V}</span>. If the check passes, <span class="math">\\mathcal{V}</span> accepts the claimed output.</p>

    <p class="text-gray-300">Notation. We follow the convention in prior works of GKR protocols <em>[13, 21, 26, 27, 28]</em>. We denote the number of gates in the <span class="math">i</span>-th layer as <span class="math">S_{i}</span> and let <span class="math">s_{i}=\\lceil\\log S_{i}\\rceil</span>. (For simplicity, we assume <span class="math">S_{i}</span> is a power of <span class="math">2</span>, and we can pad the layer with dummy gates otherwise.) We then define a function <span class="math">V_{i}:\\{0,1\\}^{s_{i}}\\to\\mathbb{F}</span> that takes a binary string <span class="math">b\\in\\{0,1\\}^{s_{i}}</span> and returns the output of gate <span class="math">b</span> in layer <span class="math">i</span>, where <span class="math">b</span> is called the gate label. With this definition, <span class="math">V_{0}</span> corresponds to the output of the circuit, and <span class="math">V_{d}</span> corresponds to the input layer. Finally, we define two additional functions <span class="math">add_{i},mult_{i}:\\{0,1\\}^{s_{i-1}+2s_{i}}\\to\\{0,1\\}</span>, referred to as wiring predicates in the literature. <span class="math">add_{i}</span> (<span class="math">mult_{i}</span>) takes one gate label <span class="math">z\\in\\{0,1\\}^{s_{i-1}}</span> in layer <span class="math">i-1</span> and two gate labels <span class="math">x,y\\in\\{0,1\\}^{s_{i}}</span> in layer <span class="math">i</span>, and outputs <span class="math">1</span> if and only if gate <span class="math">z</span> is an addition (multiplication) gate that takes the output of gate <span class="math">x,y</span> as input. With these definitions, for any <span class="math">z\\in\\{0,1\\}^{s_{i}}</span>, <span class="math">V_{i}</span> can be written as:</p>

    <p class="text-gray-300">\\[ \\begin{split}V_{i}(z)=\\sum\\nolimits_{x,y\\in\\{0,1\\}^{s_{i+1}}}(&add_{i+1}(z,x,y)(V_{i+1}(x)+V_{i+1}(y))\\\\ &+mult_{i+1}(z,x,y)V_{i+1}(x)V_{i+1}(y))\\end{split} \\] (1)</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300">In the equation above, <span class="math">V_{i}</span> is expressed as a summation, so <span class="math">\\mathcal{V}</span> can use the sumcheck protocol to check that it is computed correctly. As the sumcheck protocol operates on polynomials defined on <span class="math">\\mathbb{F}</span>, we rewrite the equation with their multilinear extensions:</p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(g)=</span> <span class="math">\\sum\\nolimits_{x,y\\in\\{0,1\\}^{s_{i+1}}}f_{i}(g,x,y)</span> <span class="math">=</span> <span class="math">\\sum\\nolimits_{x,y\\in\\{0,1\\}^{s_{i+1}}}(a\\tilde{d}d_{i+1}(g,x,y)(\\tilde{V}_{i+1}(x)+\\tilde{V}_{i+1}(y))</span> <span class="math">+\\tilde{mult}_{i+1}(g,x,y)\\tilde{V}_{i+1}(x)\\tilde{V}_{i+1}(y))\\,,</span> (2)</p>

    <p class="text-gray-300">where <span class="math">g\\in\\mathbb{F}^{s_{i}}</span> is a random vector.</p>

    <p class="text-gray-300">Protocol. With Equation 2, the GKR protocol proceeds as following. The prover <span class="math">\\mathcal{P}</span> first sends the claimed output of the circuit to <span class="math">\\mathcal{V}</span>. From the claimed output, <span class="math">\\mathcal{V}</span> defines polynomial <span class="math">\\tilde{V}_{0}</span> and computes <span class="math">\\tilde{V}_{0}(g)</span> for a random <span class="math">g\\in\\mathbb{F}^{s_{0}}</span>. <span class="math">\\mathcal{V}</span> and <span class="math">\\mathcal{P}</span> then invoke a sumcheck protocol on Equation 2 with <span class="math">i=0</span>. As described in Section 2.2, at the end of the sumcheck, <span class="math">\\mathcal{V}</span> needs an oracle access to <span class="math">f_{i}(g,u,v)</span>, where <span class="math">u,v</span> are randomly selected in <span class="math">\\mathbb{F}^{s_{i+1}}</span>. To compute <span class="math">f_{i}(g,u,v)</span>, <span class="math">\\mathcal{V}</span> computes <span class="math">\\tilde{a}\\tilde{d}d_{i+1}(g,u,v)</span> and <span class="math">\\tilde{mult}_{i+1}(g,u,v)</span> locally (they only depend on the wiring pattern of the circuit, not on the values), asks <span class="math">\\mathcal{P}</span> to send <span class="math">\\tilde{V}_{1}(u)</span> and <span class="math">\\tilde{V}_{1}(v)</span> and computes <span class="math">f_{i}(g,u,v)</span> to complete the sumcheck protocol. In this way, <span class="math">\\mathcal{V}</span> and <span class="math">\\mathcal{P}</span> reduce a claim about the output to two claims about values in layer 1. <span class="math">\\mathcal{V}</span> and <span class="math">\\mathcal{P}</span> could invoke two sumcheck protocols on <span class="math">\\tilde{V}_{1}(u)</span> and <span class="math">\\tilde{V}_{1}(v)</span> recursively to layers above, but the number of the sumcheck protocols would increase exponentially.</p>

    <p class="text-gray-300">Combining two claims using a random linear combination. One way to combine two claims <span class="math">\\tilde{V}_{i}(u)</span> and <span class="math">\\tilde{V}_{i}(v)</span> is using random linear combinations, as proposed in <em>[12, 24]</em>. Upon receiving the two claims <span class="math">\\tilde{V}_{i}(u)</span> and <span class="math">\\tilde{V}_{i}(v)</span>, <span class="math">\\mathcal{V}</span> selects <span class="math">\\alpha_{i,1},\\alpha_{i,2}\\in\\mathbb{F}</span> randomly and computes <span class="math">\\alpha_{i,1}\\tilde{V}_{i}(u)+\\alpha_{i,2}\\tilde{V}_{i}(v)</span>. Based on Equation 2, this random linear combination can be written as</p>

    <p class="text-gray-300"><span class="math">\\alpha_{i,1}\\tilde{V}_{i}(u)+\\alpha_{i,2}\\tilde{V}_{i}(v)</span> <span class="math">=</span> <span class="math">\\alpha_{i,1}\\sum_{x,y\\in\\{0,1\\}^{s_{i+1}}}(a\\tilde{d}d_{i+1}(u,x,y)(\\tilde{V}_{i+1}(x)+\\tilde{V}_{i+1}(y))+\\tilde{mult}_{i+1}(u,x,y)\\tilde{V}_{i+1}(x)\\tilde{V}_{i+1}(y))</span> <span class="math">+</span> <span class="math">\\alpha_{i,2}\\sum_{x,y\\in\\{0,1\\}^{s_{i+1}}}(a\\tilde{d}d_{i+1}(v,x,y)(\\tilde{V}_{i+1}(x)+\\tilde{V}_{i+1}(y))+\\tilde{mult}_{i+1}(v,x,y)\\tilde{V}_{i+1}(x)\\tilde{V}_{i+1}(y))</span> <span class="math">=</span> <span class="math">\\sum_{x,y\\in\\{0,1\\}^{s_{i+1}}}((\\alpha_{i,1}\\tilde{a}\\tilde{d}d_{i+1}(u,x,y)+\\alpha_{i,2}\\tilde{a}\\tilde{d}d_{i+1}(v,x,y))(\\tilde{V}_{i+1}(x)+\\tilde{V}_{i+1}(y))</span> <span class="math">+</span> <span class="math">(\\alpha_{i,1}\\tilde{mult}_{i+1}(u,x,y)+\\alpha_{i,2}\\tilde{mult}_{i+1}(v,x,y))\\tilde{V}_{i+1}(x)\\tilde{V}_{i+1}(y))</span> (3)</p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}</span> and <span class="math">\\mathcal{P}</span> then execute the sumcheck protocol on Equation 3 instead of Equation 2. At the end of the sumcheck protocol, <span class="math">\\mathcal{V}</span> still receives two claims about <span class="math">\\tilde{V}_{i+1}</span>, computes their random linear combination and proceeds to the layer above recursively until the input layer.</p>

    <p class="text-gray-300">The formal GKR protocol is presented in Protocol 4 in Appendix A. With the optimal algorithms with a linear prover time proposed in <em>[26]</em>, we have the following theorem:</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Theorem 1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em>[26]</em>. Let <span class="math">C:\\mathbb{F}^{n}\\to\\mathbb{F}^{k}</span> be a depth-<span class="math">d</span> layered arithmetic circuit. Protocol 4 is an interactive proof for the function computed by <span class="math">C</span> with soundness $O(d\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. It uses </span>O(d\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> rounds of interaction and the running time of the prover </span>\\mathcal{P}<span class="math"> is </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Let </span>T<span class="math"> be the time to evaluate all </span>\\hat{add_{i}}<span class="math"> and </span>\\hat{mult_{i}}<span class="math"> at the corresponding random points, the running time of </span>\\mathcal{V}<span class="math"> is </span>O(n+k+d\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+T)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-12" class="text-2xl font-bold">3 Generalizing GKR to Arbitrary Arithmetic Circuits</h2>

    <p class="text-gray-300">Though the GKR protocol has great prover efficiency as demonstrated in <em>[21, 23, 26, 27]</em> and is used as a major building block to construct fast zero knowledge proof schemes, one major drawback is that the protocol only works for layered arithmetic circuits, i.e., each gate can only take input from the layer above. In this section, we show how to generalize the GKR protocol to arbitrary circuits with no overhead on the prover time.</p>

    <p class="text-gray-300">We consider a general arithmetic circuit <span class="math">C</span> with fan-in <span class="math">2</span>, which can be viewed as a directed acyclic graph (DAG), <span class="math">G_{C}</span>. Each gate in <span class="math">C</span> is a vertex in <span class="math">G_{C}</span> and each wire is a directed edge in <span class="math">G_{C}</span>. The in-degree of each vertex is at most <span class="math">2</span>. The depth of the circuit <span class="math">d</span> is defined as the length of the longest path in the DAG. Without loss of generality, we assume that all input gates are at layer <span class="math">d</span>, and all output gates are at layer <span class="math">0</span>. Following the order to evaluate the circuit, we can actually assign a layer number to each gate topologically. In particular, if gate <span class="math">g</span> is not an input, suppose gate <span class="math">u</span> and gate <span class="math">v</span> are the input gates of <span class="math">g</span>, then <span class="math">\\mathsf{layer}(g)=\\min(\\mathsf{layer}(u),\\mathsf{layer}(v))-1</span>, where the function <span class="math">\\mathsf{layer}(x)</span> represents the layer of the gate <span class="math">x</span>. Because of this definition, an interesting observation is that a gate at layer <span class="math">i</span> must take at least one input from layer <span class="math">i+1</span>, otherwise it cannot be labeled as in layer <span class="math">i</span>. Also obviously, a gate at layer <span class="math">i</span> can only take input from layer <span class="math">j</span> such that <span class="math">j&gt;i</span>.</p>

    <p class="text-gray-300">Same as the original GKR protocol, we use <span class="math">S_{i}</span> as the number of gates in the <span class="math">i</span>-th layer and <span class="math">s_{i}=\\lceil\\log S_{i}\\rceil</span>. For simplicity, we assume <span class="math">S_{i}</span> is a power of <span class="math">2</span>, and we can pad the layer with dummy gates otherwise. The function <span class="math">V_{i}</span> takes a binary string <span class="math">b</span> and outputs the <span class="math">b</span>-th gate value in layer <span class="math">i</span> of <span class="math">C</span>. As now every gate can take input from any layer above, we generalize the notations naturally and define <span class="math">add_{i,j},mult_{i,j}:\\{0,1\\}^{s_{i-1},s_{i},s_{j}}\\to\\{0,1\\}</span> as the wiring-predicate functions for the general circuit <span class="math">C</span>. <span class="math">add_{i,j}</span> takes one gate label <span class="math">z\\in\\{0,1\\}^{s_{i-1}}</span> in layer <span class="math">i-1</span>, one gate label <span class="math">x\\in\\{0,1\\}^{s_{i}}</span> in layer <span class="math">i</span> and one gate label <span class="math">y\\in\\{0,1\\}^{s_{j}}</span> in layer <span class="math">j</span> for <span class="math">j\\geq i</span>, and outputs <span class="math">1</span> if and only if gate <span class="math">z</span> is an addition gate that takes the output of gate <span class="math">x,y</span> as input. <span class="math">mult_{i,j}</span> is defined similarly for multiplication gates. We still use <span class="math">\\tilde{f}</span> to represent the multilinear extensions of the function <span class="math">f</span>.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">3.1 A Naive Generalization of the GKR Protocol</h3>

    <p class="text-gray-300">With these definitions, we first describe a naive generalization of the GKR protocol to general arithmetic circuits. We follow the core idea of the GKR protocol</p>

    <p class="text-gray-300">to reduce the claim about <span class="math">V_{i}</span> layer by layer via the sumcheck protocol. In a general circuit, a gate in layer <span class="math">i</span> can take the output of any gate in layer <span class="math">i+1</span> to <span class="math">d</span>, thus we simply extend Equation 2 to have one <span class="math">add</span> and one <span class="math">mult</span> for each layer above. Recall from above that every gate at layer <span class="math">i</span> must have at least one input from layer <span class="math">i+1</span>, we assume that this is the left input and rewrite the sumcheck equation in Equation 2 as:</p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(g)=\\sum_{x\\in\\{0,1\\}^{s_{i+1}}}\\big{(}\\sum_{y\\in\\{0,1\\}^{s_{i+1}}}a\\tilde{d}d_{i+1,i+1}(g,x,y)(\\tilde{V}_{i+1}(x)+\\tilde{V}_{i+1}(y))</span> (4) <span class="math">+\\sum_{y\\in\\{0,1\\}^{s_{i+2}}}a\\tilde{d}d_{i+1,i+2}(g,x,y)(\\tilde{V}_{i+1}(x)+\\tilde{V}_{i+2}(y))</span> <span class="math">+\\ldots+\\sum_{y\\in\\{0,1\\}^{s_{d}}}a\\tilde{d}d_{i+1,d}(g,x,y)(\\tilde{V}_{i+1}(x)+\\tilde{V}_{d}(y))</span> <span class="math">+\\sum_{y\\in\\{0,1\\}^{s_{i+1}}}m\\tilde{u}lt_{i+1,i+1}(g,x,y)(\\tilde{V}_{i+1}(x)\\tilde{V}_{i+1}(y))</span> <span class="math">+\\sum_{y\\in\\{0,1\\}^{s_{i+2}}}m\\tilde{u}lt_{i+1,i+2}(g,x,y)(\\tilde{V}_{i+1}(x)\\tilde{V}_{i+2}(y))</span> <span class="math">+\\ldots+\\sum_{y\\in\\{0,1\\}^{s_{d}}}m\\tilde{u}lt_{i+1,d}(g,x,y)(\\tilde{V}_{i+1}(x)\\tilde{V}_{d}(y))\\big{)}</span></p>

    <p class="text-gray-300">for any <span class="math">g\\in\\mathbb{F}^{s_{i}}</span>. With this equation, starting from the output layer, in round <span class="math">i</span>, the first step is that <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> engage the sumcheck protocol on Equation 4 to reduce one claim about layer <span class="math">i</span> to claims about previous layers. At the end of the sumcheck protocol, <span class="math">\\mathcal{P}</span> sends <span class="math">\\mathcal{V}</span> evaluations of <span class="math">\\tilde{V}_{i+1}(u),\\tilde{V}_{i+1}(v),\\tilde{V}_{i+2}(v),\\ldots,\\tilde{V}_{d}(v)</span> on the randomness of <span class="math">u</span> and <span class="math">v</span>. <span class="math">\\mathcal{V}</span> evaluates all <span class="math">add</span> and <span class="math">mult</span> on her own and completes the last round of the sumcheck protocol.</p>

    <p class="text-gray-300">In the second step, when going to a new layer, <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> need to combine multiple claims about this layer. Here in the naive approach, we use the same method of random linear combinations. When reaching layer <span class="math">i</span>, <span class="math">\\mathcal{V}</span> has received the claims about <span class="math">\\tilde{V}_{i}</span> from layer <span class="math">0,1,\\ldots,i-1</span> (twice for <span class="math">i-1</span>). Denote the randomness of these claims as <span class="math">g^{(0)},g^{(1)},\\ldots,g^{(i)}</span>. <span class="math">\\mathcal{V}</span> picks a random number <span class="math">\\alpha_{i,j}</span> for each claim, and we can rewrite Equation 4 as:</p>

    <p class="text-gray-300"><span class="math">\\alpha_{i,0}\\tilde{V}_{i}(g^{(0)})+\\alpha_{i,1}\\tilde{V}_{i}(g^{(1)})+\\ldots+\\alpha_{i,i}\\tilde{V}_{i}(g^{(i)})</span> (5) <span class="math">=\\sum\\nolimits_{j=0}^{i}\\alpha_{i,j}\\big{(}\\sum\\nolimits_{x\\in\\{0,1\\}^{s_{i+1}}}(\\sum_{y\\in\\{0,1\\}^{s_{i+1}}}a\\tilde{d}d_{i+1,i+1}(g^{(j)},x,y)(\\tilde{V}_{i+1}(x)+\\tilde{V}_{i+1}(y))</span> <span class="math">+\\ldots+\\sum\\nolimits_{y\\in\\{0,1\\}^{s_{d}}}a\\tilde{d}d_{i+1,d}(g^{(j)},x,y)(\\tilde{V}_{i+1}(x)+\\tilde{V}_{d}(y))</span> <span class="math">+\\sum\\nolimits_{y\\in\\{0,1\\}^{s_{i+1}}}m\\tilde{u}lt_{i+1,i+1}(g^{(j)},x,y)(\\tilde{V}_{i+1}(x)\\tilde{V}_{i+1}(y))</span> <span class="math">+\\ldots+\\sum\\nolimits_{y\\in\\{0,1\\}^{s_{d}}}m\\tilde{u}lt_{i+1,d}(g^{(j)},x,y)(\\tilde{V}_{i+1}(x)\\tilde{V}_{d}(y)))\\big{)}</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}</span> and <span class="math">\\mathcal{P}</span> then execute the sumcheck protocol on Equation 5 instead of Equation 4. At the end of the sumcheck protocol, <span class="math">\\mathcal{V}</span> still receives claims about <span class="math">\\tilde{V}_{i+1},\\tilde{V}_{i+2},\\ldots,\\tilde{V}_{d}</span>. For layer <span class="math">i+1</span>, <span class="math">\\mathcal{V}</span> computes their random linear combination and proceeds to the sumcheck protocol for layer <span class="math">i+1</span> recursively.</p>

    <p class="text-gray-300">This protocol is a direct generalization of the GKR protocol in Protocol 4, and it is not hard to see that the protocol is sound. Unfortunately, it introduces a big overhead on the prover time. First, in the beginning of the sumcheck protocol on Equation 4, the equation is defined over the multilinear extensions</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\tilde{V}_{i+1},\\tilde{V}_{i+2},\\ldots,\\tilde{V}_{d}</span>. Hence, the prover time in this step is at least <span class="math">O(S_{i+1}+S_{i+2}+\\ldots+S_{d})</span>. In fact, merely listing these polynomials and evaluating them at random points already take <span class="math">O(S_{i+1}+S_{i+2}+\\ldots+S_{d})</span> time, not to mention the prover time of the sumcheck protocol. Therefore, the total prover time is $O(dS_{d}+(d-1)S_{d-1}+\\ldots+S_{1})=O(d</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> for all layers. There is a multiplicative overhead of </span>d<span class="math"> on the prover time, which is in fact as bad as transforming the general circuit to a layered circuit. Second, in the step of random linear combinations, as shown in Equation 5, </span>\\mathcal{V}<span class="math"> combines </span>i+1<span class="math"> claims together for layer </span>i<span class="math">. On the right hand side of the equation, each </span>\\hat{a}\\hat{d}d<span class="math"> and </span>\\hat{mult}<span class="math"> has to be evaluated on </span>i+1<span class="math"> different random points </span>g^{(j)}<span class="math">. This again introduces a prover time of </span>O(d</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Therefore, overall the prover time of this naive generalized GKR protocol is </span>O(d</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$, as slow as naively transforming the general circuit to a layered circuit.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In the next two subsections, we will show how to remove the overhead of each of the two steps.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">3.2 Sumcheck with Linear Prover Time</h3>

    <p class="text-gray-300">As explained above, the main overhead of the sumcheck on Equation 4 in the first step comes from the fact that each layer can connect to all layers above in a general circuit, and defining <span class="math">\\tilde{V}_{i+1},\\tilde{V}_{i+2},\\ldots,\\tilde{V}_{d}</span> already blows up the complexity. Therefore, instead of using the multilinear extension of the entire layer, we define the multilinear extension of <em>only those gates used in layer <span class="math">i</span></em> from a previous layer. As each gate only has two input gates, there are at most <span class="math">2S_{i}</span> gates connecting to gates in layer <span class="math">i</span> in total. In this way, the total size of these multilinear extensions is bounded by <span class="math">O(S_{i})</span>.</p>

    <p class="text-gray-300">Formally speaking, we also generalize the definitions of <span class="math">S</span> and <span class="math">s</span> such that <span class="math">S_{i,j}</span> denotes the number of gates connecting from layer <span class="math">j</span> (<span class="math">j&gt;i</span>) to layer <span class="math">i</span>, and <span class="math">s_{i,j}=\\lceil\\log S_{i,j}\\rceil</span>. We then introduce a new function <span class="math">V_{i,j}:\\{0,1\\}^{s_{i,j}}\\to\\mathbb{F}</span>, which is defined by the subset of gates from layer <span class="math">j</span> connecting to layer <span class="math">i</span> in a pre-defined order. The function takes a binary string <span class="math">b\\in\\{0,1\\}^{s_{i,j}}</span> and returns the <span class="math">b</span>-th value in this subset. We also re-define <span class="math">add_{i,j},mult_{i,j}:\\{0,1\\}^{s_{i-1}+s_{i-1,i}+s_{i-1,j}}\\to\\{0,1\\}</span> to take labels from the subsets instead of the labels of the entire layers. In particular, <span class="math">add_{i,j}(z,x,y)=1</span> (<span class="math">multi_{i,j}(z,x,y)=1</span>) if and only if gate <span class="math">z</span> in layer <span class="math">i-1</span> is the addition (multiplication) of value <span class="math">V_{i-1,i}(x)</span> and <span class="math">V_{i-1,j}(y)</span>. With these definitions, by taking their multilinear extensions, we can rewrite Equation 4 as</p>

    <p class="text-gray-300">\\[ \\begin{split}\\tilde{V}_{i}(g)=\\sum\\nolimits_{x\\in\\{0,1\\}^{s_{i,i+1}}}(\\sum_{y\\in\\{0,1\\}^{s_{i,i+1}}}\\hat{a}\\hat{d}d_{i+1,i+1}(g,x,y)(\\tilde{V}_{i,i+1}(x)+\\tilde{V}_{i,i+1}(y))+\\\\ +\\ldots+\\sum\\nolimits_{y\\in\\{0,1\\}^{s_{i,d}}}\\hat{a}\\hat{d}d_{i+1,d}(g,x,y)(\\tilde{V}_{i,i+1}(x)+\\tilde{V}_{i,d}(y))\\\\ +\\sum\\nolimits_{y\\in\\{0,1\\}^{s_{i,i+1}}}\\hat{mult}_{i+1,i+1}(g,x,y)(\\tilde{V}_{i,i+1}(x)\\tilde{V}_{i,i+1}(y))\\\\ +\\ldots+\\sum\\nolimits_{y\\in\\{0,1\\}^{s_{i,d}}}\\hat{mult}_{i+1,d}(g,x,y)(\\tilde{V}_{i,i+1}(x)\\tilde{V}_{i,d}(y)))\\end{split} \\] (6)</p>

    <p class="text-gray-300">In Equation 6, the size of <span class="math">\\tilde{V}_{i,i+1},\\ldots,\\tilde{V}_{i,d}</span> are bounded by <span class="math">O(S_{i})</span>. Moreover, the <span class="math">\\hat{a}\\hat{d}d</span> and <span class="math">\\hat{mult}</span> polynomials are still sparse. In fact, the total number of nonzer</p>

    <p class="text-gray-300">in all <span class="math">\\tilde{a}\\tilde{d}d</span> and <span class="math">\\tilde{mult}</span> together is <span class="math">S_{i}</span>. Therefore, using similar ideas proposed in <em>[26]</em>, we are able to develop an algorithm for the prover to run the sumcheck in linear time <span class="math">O(S_{i})</span>, instead of <span class="math">O(S_{i}+S_{i+1}+\\ldots+S_{d})</span>.</p>

    <p class="text-gray-300">Before presenting the linear-time algorithm, we make one more refinement on the equation. Note that Equation 6 consists of multiple sums, because the number of gates connecting from layer <span class="math">j&gt;i</span> to layer <span class="math">i</span> is different for each <span class="math">j</span>. We cannot pad them to the same length, as it would introduce an overhead asymptotically. We combine them into a single sum in the following way. Without loss of generality, we suppose <span class="math">s_{i,i+1}</span> is the largest. We can then rewrite Equation 6 as:</p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(g)=\\sum\\nolimits_{x,y\\in\\{0,1\\}^{s_{i,i+1}}}(\\tilde{a}\\tilde{d}d_{i+1,i+1}(g,x,y)(\\tilde{V}_{i,i+1}(x)+\\tilde{V}_{i,i+1}(y_{1},\\ldots,y_{s_{i,i+1}}))</span> <span class="math">+y_{s_{i,i+2}+1}\\cdot\\ldots\\cdot y_{s_{i,i+1}}\\tilde{a}\\tilde{d}d_{i+1,i+2}(g,x,y_{1},\\ldots,y_{s_{i,i+2}})(\\tilde{V}_{i,i+1}(x)+\\tilde{V}_{i,i+2}(y_{1},\\ldots,y_{s_{i,i+2}}))</span> <span class="math">+\\ldots+y_{s_{i,d}+1}\\cdot\\ldots\\cdot y_{s_{i,i+1}}\\tilde{a}\\tilde{d}d_{i+1,d}(g,x,y_{1},\\ldots,y_{s_{i,d}})(\\tilde{V}_{i,i+1}(x)+\\tilde{V}_{i,d}(y_{1},\\ldots,y_{s_{i,d}}))</span> <span class="math">+\\tilde{mult}_{i+1,i+1}(g,x,y)(\\tilde{V}_{i,i+1}(x)\\tilde{V}_{i,i+1}(y_{1},\\ldots,y_{s_{i,i+1}}))</span> <span class="math">+y_{s_{i,i+2}+1}\\cdot\\ldots\\cdot y_{s_{i,i+1}}\\tilde{mult}_{i+1,i+2}(g,x,y_{1},\\ldots,y_{s_{i,i+2}})\\tilde{V}_{i,i+1}(x)\\tilde{V}_{i,i+2}(y_{1},\\ldots,y_{s_{i,i+2}})</span> <span class="math">+\\ldots+y_{s_{i,d}+1}\\cdot\\ldots\\cdot y_{s_{i,i+1}}\\tilde{mult}_{i+1,d}(g,x,y_{1},\\ldots,y_{s_{i,d}})\\tilde{V}_{i,i+1}(x)\\tilde{V}_{i,d}(y_{1},\\ldots,y_{s_{i,d}}))</span> (7)</p>

    <p class="text-gray-300">Note that the only difference between Equation 6 and 7 is that in Equation 7 all the sums are over <span class="math">y\\in\\{0,1\\}^{s_{i,i+1}}</span>, the longest binary string. For <span class="math">j=i+2,\\ldots,d</span>, as <span class="math">\\tilde{a}\\tilde{d}d_{i+1,j},\\tilde{mult}_{i+1,j}</span> and <span class="math">\\tilde{V}_{i,j}</span> only take <span class="math">y_{1},\\ldots,y_{s_{i,j}}</span>, we multiply each term with <span class="math">y_{s_{i,j}+1}\\cdot y_{s_{i,j}+2}\\cdot\\ldots\\cdot y_{s_{i,i+1}}</span>. This guarantees that the term only appears once in the sum, when <span class="math">y_{s_{i,j}+1}=y_{s_{i,j}+2}=\\ldots=y_{s_{i,i+1}}=1</span>, and thus Equation 7 holds. In fact, <span class="math">y_{s_{i,j}+1}\\cdot y_{s_{i,j}+2}\\cdot\\ldots\\cdot y_{s_{i,i+1}}</span> is exactly the identity polynomial <span class="math">\\tilde{\\beta}((y_{s_{i,j}+1},y_{s_{i,j}+2},\\ldots,y_{s_{i,i+1}}),\\bm{1})</span>. In this way, we do not have to pad all the polynomials to the same size. We only pad the size of each subset to the nearest power of <span class="math">2</span>, which incurs at most an overhead of <span class="math">2</span>.</p>

    <p class="text-gray-300">Next, we present an algorithm for <span class="math">\\mathcal{P}</span> to run the sumcheck protocol on Equation 7 in linear time. We start with an algorithm to run sumcheck for the product of two multilinear polynomials in the literature, which we will use as a major building block.</p>

    <p class="text-gray-300">Linear-time sumcheck for products of multilinear functions <em>[21]</em>. In <em>[21]</em>, Thaler proposed a linear-time algorithm for the prover of the sumcheck protocol on the product of two multilinear polynomials <span class="math">f</span> and <span class="math">g</span> with <span class="math">\\ell</span> variables (the algorithm runs in <span class="math">O(2^{\\ell})</span> time). We present the algorithm in Algorithm 2. Algorithm 2 invokes Algorithm 1 FunctionEvaluations() as a subroutine. The algorithms are exactly the same as Algorithm 1 and 3 in <em>[26]</em>. Both Algorithm 1 and Algorithm 2 run in time <span class="math">O(2^{\\ell})</span> and the formal proof can be found in <em>[21, 26]</em>. We have a lemma as follows:</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Lemma 1.</h6>

    <p class="text-gray-300">Given multilinear functions <span class="math">f</span> and <span class="math">g</span> on <span class="math">\\ell</span> variables and a <em>bookkeeping table</em> <span class="math">\\bm{A}_{f}</span> for <span class="math">f</span> and a <em>bookkeeping table</em> <span class="math">\\bm{A}_{g}</span> for <span class="math">g</span>, the prover in Protocol 1 for <span class="math">f\\cdot g</span> runs in <span class="math">O(2^{\\ell})</span> time. <span class="math">\\bm{A}_{f}=(f(0,\\ldots,0),\\ldots,f(1,\\ldots,1))</span> and <span class="math">\\bm{A}_{g}=(g(0,\\ldots,0),\\ldots,g(1,\\ldots,1))</span> are initialized with evaluations of <span class="math">f</span> and <span class="math">g</span> on the Boolean hypercube, respectively.</p>

    <p class="text-gray-300">|  Algorithm 1 F← FunctionEvaluations(f,A,r1,...,rl)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Input: Multilinear f on ℓ variables, initial bookkeeping table A, random r1,...,rl;  |   |</p>

    <p class="text-gray-300">|  Output: All function evaluations f(r1,...,ri-1,t,bi+1,...,bl);  |   |</p>

    <p class="text-gray-300">|  1: for i=1,...,ℓ do  |   |</p>

    <p class="text-gray-300">|  2: for b∈{0,1}ℓ-i do // b is both a number and its binary representation.  |   |</p>

    <p class="text-gray-300">|  3: for t=0,1,2 do  |   |</p>

    <p class="text-gray-300">|  4: Let f(r1,...,ri-1,t,b)=A[b]·(1-t)+A[b+2ℓ-i]·t  |   |</p>

    <p class="text-gray-300">|  5: A[b]=A[b]·(1-ri)+A[b+2ℓ-i]·ri  |   |</p>

    <p class="text-gray-300">|  6: Let F contain all function evaluations f(.) computed at Step 4  |   |</p>

    <p class="text-gray-300">|  7: return F  |   |</p>

    <p class="text-gray-300">|  Algorithm 2 {a1,...,aℓ}← SumCheckProduct(f,Af,g,Ag,r1,...,rl)  |   |</p>

    <p class="text-gray-300">|  Input: Multilinear f and g, initial bookkeeping tables Af and Ag, random r1,...,rl;  |   |</p>

    <p class="text-gray-300">|  Output: ℓ sumcheck messages for ∑x∈{0,1}ℓ f(x)g(x). Each message ai consists of 3 elements (ai0,ai1,ai2);  |   |</p>

    <p class="text-gray-300">|  1: F← FunctionEvaluations(f,Af,r1,...,rl)  |   |</p>

    <p class="text-gray-300">|  2: G← FunctionEvaluations(g,Ag,r1,...,rl)  |   |</p>

    <p class="text-gray-300">|  3: for i=1,...,ℓ do  |   |</p>

    <p class="text-gray-300">|  4: for t∈{0,1,2} do  |   |</p>

    <p class="text-gray-300">|  5: ai t=∑b∈{0,1}ℓ-i f(r1,...,ri-1,t,b)·g(r1,...,ri-1,t,b) // All evaluations needed are in F and G.  |   |</p>

    <p class="text-gray-300">|  6: return {a1,...,aℓ};  |   |</p>

    <p class="text-gray-300">Linear-time sumcheck for Equation 7. The idea of the prover algorithm is similar to that proposed in [26]. The algorithm proceeds in two phases, one summing  <span class="math">x</span>  and the other summing  <span class="math">y</span> . For the ease of presentation, let us consider the sumcheck on a particular class of equations:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sum_ {x, y \\in \\{0, 1 \\} ^ {\\ell}} y _ {k _ {1} + 1} \\dots y _ {\\ell} f _ {1} (g, x, y _ {1}, \\dots , y _ {k _ {1}}) s _ {1} (y _ {1}, \\dots , y _ {k _ {1}}) t (x) + \\\\ y _ {k _ {2} + 1} \\dots y _ {\\ell} f _ {2} (g, x, y _ {1}, \\dots , y _ {k _ {2}}) s _ {2} \\left(y _ {1}, \\dots , y _ {k _ {2}}\\right) t (x) + \\dots + \\tag {8} \\\\ y _ {k _ {m} + 1} \\dots y _ {\\ell} f _ {m} (g, x, y _ {1}, \\dots , y _ {k _ {m}}) s _ {m} (y _ {1}, \\dots , y _ {k _ {m}}) t (x), \\\\ \\end{array}</span></div>

    <p class="text-gray-300">for a fixed point  <span class="math">g \\in \\mathbb{F}^{\\ell}</span> , where  <span class="math">t(x): \\mathbb{F}^{\\ell} \\to \\mathbb{F}</span>  and  <span class="math">s_i(x): \\mathbb{F}^{k_i} \\to \\mathbb{F}</span>  are multilinear extensions of arrays  <span class="math">\\mathbf{A}_t</span>  and  <span class="math">\\mathbf{A}_{s_i}</span> , and all functions of  <span class="math">f_i(x): \\mathbb{F}^{2\\ell + k_i} \\to \\mathbb{F}</span>  are multilinear extensions of sparse arrays with  <span class="math">O(2^{\\ell})</span>  nonzero elements in total. In addition, we require that  <span class="math">2^{k_1} + 2^{k_2} + \\ldots + 2^{k_m} = 2^{\\ell}</span> . It is not hard to see that Equation 7 satisfies these properties, as there are at most  <span class="math">S_i</span>  left input gates and  <span class="math">S_i</span>  right input gates connected to layer  <span class="math">i</span>  in the circuit  <span class="math">C</span> . If we set  <span class="math">\\ell = s_i = \\lceil \\log S_i \\rceil</span> , we have  <span class="math">2^{k_1} + 2^{k_2} + \\ldots + 2^{k_m} = O(S_i)</span>  in Equation 7.</p>

    <p class="text-gray-300">We use the same intuition in [26] of dividing the sumcheck process into two phases, one is for  <span class="math">x</span>  and the other is for  <span class="math">y</span> . We rewrite Equation 8 as follows</p>

    <p class="text-gray-300">Algorithm 3 <span class="math">\\mathbf{A}_{h_g} \\gets \\text{Initialize\\_PhaseOne}(f_1, \\ldots, f_m, s_1, \\ldots, s_m, \\mathbf{A}_{s_1}, \\ldots, \\mathbf{A}_{s_m}, g)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Input: Multilinear <span class="math">f_1, \\ldots, f_m</span> and <span class="math">s_1, \\ldots, s_m</span>, initial bookkeeping tables <span class="math">\\mathbf{A}_{s_1}, \\ldots, \\mathbf{A}_{s_m}</span>, random <span class="math">g = g_1, \\ldots, g_\\ell</span>; We have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{A}_{s_1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\ldots +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{A}_{s_m}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^\\ell$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Output: Bookkeeping table <span class="math">\\mathbf{A}_{h_g}</span>;</p>

    <p class="text-gray-300">1: procedure <span class="math">\\mathbf{G} \\gets \\text{Precompute}(g)</span>  // <span class="math">\\mathbf{G}</span> is an array of size <span class="math">2^{\\ell}</span>. 2: Set <span class="math">\\mathbf{G}[0] = 1</span> 3: for <span class="math">i = 0, \\ldots, \\ell - 1</span> do 4:   for <span class="math">b \\in \\{0, 1\\}^i</span> do 5:         <span class="math">\\mathbf{G}[b, 0] = \\mathbf{G}[b] \\cdot (1 - g_{i+1})</span> 6:         <span class="math">\\mathbf{G}[b, 1] = \\mathbf{G}[b] \\cdot g_{i+1}</span> 7: <span class="math">\\forall x \\in \\{0, 1\\}^\\ell</span>, set <span class="math">\\mathbf{A}_{h_g}[x] = 0</span> 8: for every <span class="math">(z,x,y)</span> such that <span class="math">f_i&#x27;(z,x,y)</span> is non-zero do 9:         <span class="math">\\mathbf{A}_{h_g}[x] = \\mathbf{A}_{h_g}[x] + \\mathbf{G}[z] \\cdot f_i&#x27;(z,x,y) \\cdot \\mathbf{A}_{s_i}[y_1, \\ldots, y_{k_i}]</span> 10: return <span class="math">\\mathbf{A}_{h_g}</span>;</p>

    <p class="text-gray-300"><span class="math">\\sum_{x \\in \\{0,1\\}^\\ell} t(x) h_g(x)</span>, where</p>

    <div class="my-4 text-center"><span class="math-block">h_g(x) = \\sum_{y \\in \\{0,1\\}^\\ell} (y_{k_1+1} \\ldots y_\\ell f_1(g, x, y_1, \\ldots, y_{k_1}) s_1(y_1, \\ldots, y_{k_1}) + \\\\ y_{k_2+1} \\ldots y_\\ell f_2(g, x, y_1, \\ldots, y_{k_2}) s_2(y_1, \\ldots, y_{k_2}) + \\ldots + \\tag{9} \\\\ y_{k_m+1} \\ldots y_\\ell f_m(g, x, y_1, \\ldots, y_{k_m}) s_m(y_1, \\ldots, y_{k_m})</span></div>

    <p class="text-gray-300">Phase one. With the formula above, in the first <span class="math">\\ell</span> rounds, the prover and the verifier are running exactly a sumcheck on the product of two multilinear polynomials <span class="math">t(x) \\cdot h_g(x)</span>, since functions <span class="math">t</span> and <span class="math">h_g</span> can be viewed as functions only in <span class="math">x</span>, and <span class="math">y</span> can be considered constant (it is always summed on the Boolean hypercube). To compute the sumcheck messages for the first <span class="math">\\ell</span> rounds, given their bookkeeping tables, this will take <span class="math">O(2^\\ell)</span> time by Lemma 1. It remains to show how to initialize the bookkeeping tables in linear time.</p>

    <p class="text-gray-300"><strong>Initializing the bookkeeping tables:</strong></p>

    <p class="text-gray-300">Initializing the bookkeeping table for <span class="math">t</span> in <span class="math">O(2^\\ell)</span> time is trivial, since <span class="math">t</span> is a multilinear extension of an array and therefore the evaluations on the hypercube are known. Initializing the bookkeeping table for <span class="math">h_g</span> in <span class="math">O(2^\\ell)</span> time is more challenging, but we can take advantage of the sparsity of <span class="math">f_i</span>.</p>

    <p class="text-gray-300"><strong>Lemma 2.</strong> Let <span class="math">\\mathcal{N}_x</span> be the set of <span class="math">(z,y) \\in \\{0,1\\}^{2\\ell}</span> such that <span class="math">f_i&#x27;(z,x,y) = y_{k_i+1} \\ldots y_\\ell f_i(z,x,y_1, \\ldots, y_{k_i})</span> is non-zero for some <span class="math">1 \\leq i \\leq m</span>. Then for all <span class="math">x \\in \\{0,1\\}^\\ell</span>, it is <span class="math">h_g(x) = \\sum_{(z,y) \\in \\mathcal{N}_x} \\tilde{\\beta}(g,z) \\cdot \\left( \\sum_{i=1}^m f_i&#x27;(z,x,y) \\cdot s_i(y_1, \\ldots, y_{k_i}) \\right)</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Since <span class="math">f_i</span> is a multilinear extension, as shown in [21], we have <span class="math">f_i&#x27;(g,x,y) = \\sum_{z\\in \\{0,1\\}^\\ell} \\tilde{\\beta}(g,z) f_i&#x27;(z,x,y)</span>. Therefore,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} h_g(x) &amp;amp;= \\sum_{z \\in \\{0,1\\}^\\ell} \\tilde{\\beta}(g,z) \\cdot \\left( \\sum_{i=1}^m f_i&#x27;(z,x,y) \\cdot s_i(y_1, \\ldots, y_{k_i}) \\right) \\\\ &amp;amp;= \\sum_{(z,y) \\in \\mathcal{N}_x} \\tilde{\\beta}(g,z) \\cdot \\left( \\sum_{i=1}^m f_i&#x27;(z,x,y) \\cdot s_i(y_1, \\ldots, y_{k_i}) \\right) \\end{aligned}</span></div>

    <h6 id="sec-16" class="text-base font-medium mt-4">Lemma 3.</h6>

    <p class="text-gray-300">The bookkeeping table <span class="math">\\bm{A}_{h_{g}}</span> can be initialized in time <span class="math">O(2^{\\ell})</span>.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As <span class="math">f_{i}</span> is sparse, $\\sum_{x\\in\\{0,1\\}^{\\ell}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{N}_{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O(2^{\\ell})<span class="math">. From Lemma 2, given the evaluations of </span>\\tilde{\\beta}(g,z)<span class="math"> for all </span>z\\in\\{0,1\\}^{\\ell}<span class="math">, the prover can iterate through all </span>(z,y)\\in\\mathcal{N}_{x}<span class="math"> for all </span>x<span class="math"> to compute </span>\\mathbf{A}_{h_{g}}<span class="math">. The full algorithm is presented in Algorithm 3. Since each </span>s_{i}<span class="math"> is the multilinear extension of an array, its evaluations on the Boolean hypercube are known. Therefore, we use </span>\\mathbf{A}_{s_{1}},\\ldots,\\mathbf{A}_{s_{m}}<span class="math"> as the input of Algorithm 3. </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{A}_{s_{1}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\ldots+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{A}_{s_{m}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{\\ell}<span class="math"> as </span>2^{k_{1}}+2^{k_{2}}+\\ldots+2^{k_{m}}=2^{\\ell}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Procedure <span class="math">\\mathsf{Precompute}(g)</span> is to evaluate <span class="math">\\mathbf{G}[z]=\\tilde{\\beta}(g,z)=\\prod_{i=1}^{\\ell}((1-g_{i})(1-z_{i})+g_{i}z_{i}))</span> for <span class="math">z\\in\\{0,1\\}^{\\ell}</span>. By the closed-form of <span class="math">\\tilde{\\beta}(g,z)</span>, the procedure iterates each bit of <span class="math">z</span>, and multiples <span class="math">1-g_{i}</span> for <span class="math">z_{i}=0</span> and multiples <span class="math">g_{i}</span> for <span class="math">z_{i}=1</span>. In this way, the size of <span class="math">\\mathbf{G}</span> doubles in each iteration, and the total complexity is <span class="math">O(2^{\\ell})</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Step 8-9 computes <span class="math">h_{g}(x)</span> using Lemma 2. When <span class="math">f_{i}^{\\prime}</span> is represented as a map of <span class="math">((z,x,y),f_{i}^{\\prime}(z,x,y))</span> for non-zero values, the complexity of these steps is <span class="math">O(2^{\\ell})</span> since $\\sum_{x\\in\\{0,1\\}^{\\ell}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{N}_{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O(2^{\\ell})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In Protocol 3, the map above is exactly the representation of a gate in the circuit, where <span class="math">z,x,y</span> are labels of the gate, its left input and its right input, and <span class="math">f_{i}^{\\prime}(z,x,y)=1</span>.</p>

    <p class="text-gray-300">With the bookkeeping tables, the prover runs Algorithm 2 for the product of multilinear polynomials and the total complexity for phase one is <span class="math">O(2^{\\ell})</span>.</p>

    <p class="text-gray-300">Phase two. At this point, the variable <span class="math">x</span> is bounded to random numbers <span class="math">u\\in\\mathbb{F}^{\\ell}</span>. In the second phase, the equation to sum on becomes</p>

    <p class="text-gray-300"><span class="math">t(u)\\sum\\nolimits_{y\\in\\{0,1\\}^{\\ell}}(\\sum\\nolimits_{i=1}^{m}y_{k_{i}+1}\\ldots y_{\\ell}f_{i}(g,u,y_{1},\\ldots,y_{k_{i}})s_{i}(y_{1},\\ldots,y_{k_{i}}))</span></p>

    <p class="text-gray-300">Note here that <span class="math">t(u)</span> is merely a constant which the prover already computed in phase one. For the part behind the summation symbol on <span class="math">y</span>, it has <span class="math">m</span> products of two multilinear functions to sum. If we naively apply Algorithm 2 to each product, the prover runs in <span class="math">O(m\\cdot 2^{\\ell})</span> time instead of only <span class="math">O(2^{\\ell})</span>. Fortunately, we observe that we can merge some products dynamically during the sumcheck process, which reduces the number of products and removes the <span class="math">m</span> factor in the complexity. To achieve the linear prover time, we generalize Lemma 1 to Lemma 4 for the summation of multiple products of multilinear functions.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Lemma 4.</h6>

    <p class="text-gray-300">Suppose we have <span class="math">2m</span> multilinear functions <span class="math">f_{1},f_{2},\\ldots,f_{m}</span> and <span class="math">g_{1}</span> , <span class="math">g_{2}</span>, …, <span class="math">g_{m}</span>. Both <span class="math">g_{i}</span> and <span class="math">f_{i}</span> have <span class="math">k_{i}</span> variables. Without loss of generality, suppose <span class="math">\\ell\\geq k_{m}\\geq k_{m-1}\\geq k_{1}</span>. If <span class="math">2^{k_{1}}+2^{k_{2}}+\\ldots+2^{k_{m}}=2^{\\ell}</span>, given the bookkeeping tables <span class="math">\\bm{A}_{f_{1}},\\ldots,\\bm{A}_{f_{m}}</span> for <span class="math">f_{1},\\ldots,f_{m}</span> and <span class="math">\\bm{A}_{g_{1}},\\cdot,\\bm{A}_{g_{m}}</span> for <span class="math">g_{1},\\ldots,g_{m}</span>, the prover in Protocol 1 for <span class="math">\\sum_{i=1}^{m}\\sum_{y\\in\\{0,1\\}^{k_{i}}}f_{i}(y)\\cdot g_{i}(y)=\\sum_{y\\in\\{0,1\\}^{\\ell}}\\sum_{i=1}^{m}y_{k_{i}+1}\\ldots y_{\\ell}f_{i}(y_{1},\\ldots,y_{k_{i}})\\cdot g_{i}(y_{1},\\ldots,y_{k_{i}})</span> runs in <span class="math">O(2^{\\ell})</span> time.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We present Algorithm 4 for the prover in the sumcheck. <span class="math">\\mathcal{P}</span> runs in <span class="math">O(2^{\\ell})</span> for step 1-3 as $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{A}_{f_{1}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\ldots+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{A}_{f_{m}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{A}_{g_{1}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\ldots+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{A}_{g_{m}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{\\ell}<span class="math">. </span>\\mathcal{P}<span class="math"> runs in </span>O(2^{\\ell})<span class="math"> for step 5-12 as the total number of the operations is </span>O(2^{k_{1}}+2^{k_{2}}+\\ldots+2^{k_{m}})=O(2^{\\ell})<span class="math">. So </span>\\mathcal{P}<span class="math"> runs in </span>O(2^{\\ell})$ time for Algorithm 4.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Algorithm 4 {a1, ..., aℓ} ← SumCheckProduct2(f1, A_{f1}, g1, A_{g1}, ..., fm, A_{fm}, gm, A_{gm}, r1, ..., rℓ)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  1: for i = 1, ..., m do  |   |</p>

    <p class="text-gray-300">|  2: F_i ← FunctionEvaluations(fi, Afi, r1, ..., rki)  |   |</p>

    <p class="text-gray-300">|  3: G_i ← FunctionEvaluations(gi, Ag_i, r1, ..., rki)  |   |</p>

    <p class="text-gray-300">|  4: temp = 0  |   |</p>

    <p class="text-gray-300">|  5: for i = 0, ..., m do  |   |</p>

    <p class="text-gray-300">|  6: if i > 0 then  |   |</p>

    <p class="text-gray-300">|  7: temp = temp + fi(r1, ..., rki) · gi(r1, ..., rki)  |   |</p>

    <p class="text-gray-300">|  8: for j = ki + 1, ..., ki+1 do // Suppose k0 = 0 < k1 ≤ ... ≤ km ≤ km+1 = ℓ  |   |</p>

    <p class="text-gray-300">|  9: if j ≤ ℓ then  |   |</p>

    <p class="text-gray-300">|  10: for q ∈ {0,1,2} do  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">11: ajq = g_i(r1, ..., rj-1, q, b) + q · temp</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">∑t=i+1m ∑b∈{0,1}kt-j ft(r1, ..., rj-1, q, b) · // All evaluations needed are in F_i and G_i.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  12: temp = temp · rj  |   |</p>

    <p class="text-gray-300">|  13: return {a1, ..., aℓ};  |   |</p>

    <p class="text-gray-300">The sumcheck polynomial for phase two has the same form in Lemma 4. To compute the sumcheck messages for the last  <span class="math">\\ell</span>  rounds, given their bookkeeping tables, this will take  <span class="math">O(2^{\\ell})</span>  time by Lemma 4. We now show how to initialize the bookkeeping tables in linear time.</p>

    <p class="text-gray-300">Initializing the bookkeeping table for each  <span class="math">s_i</span>  in  <span class="math">O(2^{k_i})</span>  time is trivial, since each  <span class="math">s_i</span>  is a multilinear extension of an array and therefore the evaluations on the hypercube are known. We also know  <span class="math">2^{k_1} + 2^{k_2} + \\ldots + 2^{k_m} = O(2^\\ell)</span> . It remains to initialize bookkeeping tables for all  <span class="math">f_i</span>  in  <span class="math">O(2^\\ell)</span>  time. Similar to phase one, we can leverage the sparsity of  <span class="math">f_i</span>  and we have the lemma as follows:</p>

    <p class="text-gray-300">Lemma 5. Let  <span class="math">\\mathcal{N}_y</span>  be the set of  <span class="math">(z,x)\\in \\{0,1\\}^{2\\ell}</span>  such that  <span class="math">f_{i}^{\\prime}(z,x,y) = y_{k_{1} + 1}\\ldots</span> <span class="math">y_{\\ell}f_{i}(z,x,y_{1},\\ldots ,y_{k_{i}})</span>  is non-zero for some  <span class="math">1\\leq i\\leq m</span> . Then for all  <span class="math">y\\in \\{0,1\\}^{\\ell}</span> , it is  <span class="math">f_{i}^{\\prime}(g,u,y) = \\sum_{(z,x)\\in \\mathcal{N}_{y}}\\tilde{\\beta} (g,z)\\tilde{\\beta} (u,x)f^{\\prime}(z,x,y)</span></p>

    <p class="text-gray-300">Lemma 5 is a generalization of Lemma 2 and we omit the proof.</p>

    <p class="text-gray-300">Lemma 6. The bookkeeping table  <span class="math">A_{f_1},\\ldots ,A_{f_m}</span>  can be initialized in time  <span class="math">O(2^{\\ell})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. As  <span class="math">f_{i}</span>  is sparse,  $\\sum_{y\\in \\{0,1\\}^{\\ell}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{N}_y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= O(2^{\\ell})<span class="math"> . From Lemma 2, given the evaluations of  </span>\\tilde{\\beta}(g,z)<span class="math">  and  </span>\\tilde{\\beta}(u,x)<span class="math">  for all  </span>z,x\\in \\{0,1\\}^{\\ell}<span class="math"> , the prover can iterate all  </span>(z,x)\\in \\mathcal{N}_x<span class="math">  for all  </span>y<span class="math">  to compute  </span>\\mathbf{A}_{f_1},\\ldots,\\mathbf{A}_{f_m}$ . The full algorithm is presented in Algorithm 5.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathcal{P}</span>  runs procedure Precompute  <span class="math">(g)</span>  and Precompute  <span class="math">(u)</span>  in  <span class="math">O(2^{\\ell})</span>  time as we have shown in the proof of Lemma 3. Step 4-5 computes  <span class="math">f_{i}(y_{1},\\ldots ,y_{k_{i}})</span>  using</p>

    <p class="text-gray-300">|  Algorithm 5 Afl, ..., Afm← Initialize_PhaseTwo(fl, ..., fm, g, u)  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  Input: Multilinear fl, ..., fm, random g = gl, ..., gm and u = u1, ..., uℓ;  |</p>

    <p class="text-gray-300">|  Output: Bookkeeping tables Afl, ..., Afm;  |</p>

    <p class="text-gray-300">|  1: G ← Precompute(g)  |</p>

    <p class="text-gray-300">|  2: U ← Precompute(u)  |</p>

    <p class="text-gray-300">|  3: ∀y ∈ {0,1}ℓ, set Afl[yl, ..., yki] = 0 for all i  |</p>

    <p class="text-gray-300">|  4: for every (z, x, y) such that fl(z, x, y1, ..., yki) is non-zero do  |</p>

    <p class="text-gray-300">|  5: Afl[yl, ..., yki] = Afl[yl, ..., yki] + G[z] · U[x] · fl(z, x, y1, ..., yki)  |</p>

    <p class="text-gray-300">|  6: return Afl, Af2, ..., Afm;  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma 5. It takes  <span class="math">O(2^{\\ell})</span>  time as  $\\sum_{y\\in \\{0,1\\}^{\\ell}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{N}_y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= O(2^{\\ell})<span class="math"> . Therefore,  </span>\\mathcal{P}<span class="math">  runs in  </span>O(2^{\\ell})$  time for Algorithm 5.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">With the bookkeeping tables, the prover runs SumCheckProduct2  <span class="math">(f_{1},\\mathbf{A}_{f_{1}}</span> <span class="math">g_{1},\\mathbf{A}_{g_{1}},\\ldots ,f_{m},\\mathbf{A}_{f_{m}},g_{m},\\mathbf{A}_{g_{m}},r_{1},\\ldots ,r_{\\ell})</span>  in Algorithm 4 and the total complexity for phase two is  <span class="math">O(2^{\\ell})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Combining phase one and phase two, we know that  <span class="math">\\mathcal{P}</span>  runs in  $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$  time for the sumcheck protocol on Equation 8.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Step one with linear prover time. Finally, the sumcheck protocol for Equation 7 can be decomposed into several instances that have the form of Equation 8. The term</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sum_ {x, y \\in \\{0, 1 \\} ^ {s _ {i, i + 1}} (m u l t _ {i + 1, i + 1} (z, x, y) (\\tilde {V} _ {i, i + 1} (x) \\tilde {V} _ {i, i + 1} (y)) + \\dots \\\\ + y _ {s _ {i, d} + 1} \\dots y _ {s _ {i, i + 1}} m \\tilde {u} l t _ {i + 1, d} (z, x, y _ {1}, y _ {2}, \\dots , y _ {s _ {i, d}}) (\\tilde {V} _ {i, i + 1} (x) \\tilde {V} _ {i, d} (y _ {1}, y _ {2}, \\dots , y _ {s _ {i, d}})) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">is exactly the same as Equation 8. The term</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sum_ {x, y \\in \\{0, 1 \\} ^ {s _ {i, i + 1}} a \\tilde {d} d _ {i + 1, i + 1} (z, x, y) (\\tilde {V} _ {i, i + 1} (x) + \\tilde {V} _ {i, i + 1} (y)) + \\dots \\\\ + y _ {s _ {i, d} + 1} \\dots y _ {s _ {i, i + 1}} a \\tilde {d} d _ {i + 1, d} (z, x, y _ {1}, \\dots , y _ {s _ {i, d}}) (\\tilde {V} _ {i, i + 1} (x) + \\tilde {V} _ {i, d} (y _ {1}, \\dots , y _ {s _ {i, d}})) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">can be rewritten as the sum of</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sum_ {x, y \\in \\{0, 1 \\} ^ {s _ {i, i + 1}} a \\tilde {d} d _ {i + 1, i + 1} (z, x, y) \\tilde {V} _ {i, i + 1} (x) + \\dots \\\\ + y _ {s _ {i, d} + 1} \\dots y _ {s _ {i, i + 1}} a \\tilde {d} d _ {i + 1, d} (z, x, y _ {1}, \\dots , y _ {s _ {i, d}}) \\tilde {V} _ {i, i + 1} (x) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sum_ {x, y \\in \\{0, 1 \\} ^ {s _ {i, i + 1}} a \\tilde {d} d _ {i + 1, i + 1} (z, x, y) \\tilde {V} _ {i, i + 1} (y) + \\dots \\\\ + y _ {s _ {i, d} + 1} \\dots y _ {s _ {i, i + 1}} a \\tilde {d} d _ {i + 1, d} (z, x, y _ {1}, \\dots , y _ {s _ {i, d}}) \\tilde {V} _ {i, d} (y _ {1}, \\dots , y _ {s _ {i, d}}). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">The first sum is the same as Equation 8 with  <span class="math">s_i(x) = 1</span> , and the second sum is the same as Equation 8 with  <span class="math">t(x) = 1</span> . The complexity for both cases remains</p>

    <p class="text-gray-300">linear. Due to linearity of the sumcheck protocol, the prover can execute these 3 instances simultaneously in every round, sum up the individual messages and send them to the verifier.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier time and proof size for all sumcheck protocols on Equation 7. The verifier time for all sumcheck protocols on Equation 7 is the same as Protocol 4. <span class="math">\\mathcal{V}</span> still runs in $O(d\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> time to verify all sumcheck statements based on Equation 7. The proof size is also </span>O(d\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Note that this excludes the claims of </span>\\tilde{V}_{i,j}$ at random points at the end of the sumcheck protocol in each layer, and we will count them in the next section combining these claims.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">3.3 Combining Multiple Claims in Linear Time</h3>

    <p class="text-gray-300">By executing the sumcheck protocol on Equation 7, <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> reduce an evaluation of the multiliear extension of a layer to multiple evaluations of multilinear extensions defined by values in the layers above. As we explained in Section 3.1, when reaching layer <span class="math">i</span>, <span class="math">\\mathcal{V}</span> has received multiple evaluations about this layer and combining these evaluations using a random linear combination would introduce an overhead on the prover. Even worse, with the refined sumcheck on Equation 7 in Section 3.2, now the verifier has received multiple evaluations of <em>different</em> multilinear extensions defined by subsets of gates in layer <span class="math">i</span> used by different layers below. Now even combining these evaluations becomes challenging, let alone reducing the overhead of the prover.</p>

    <p class="text-gray-300">In this section, we propose two different approaches that not only combine these evaluations to a single evaluation of the multilinear extension of the entire layer <span class="math">i</span>, but also incur only a linear prover time in the size of the circuit.</p>

    <p class="text-gray-300">Combining multiple claims by an arithmetic circuit. The key idea of the first approach is that instead of trying to come up with a complicated protocol to do the combination, we simply model the computation as an arithmetic circuit! The circuit takes the values <span class="math">\\mathbf{V}_{i}</span> of the entire layer <span class="math">i</span> as the input. In addition, it also takes the randomness to compute these evaluations of subsets from the verifier. At this point, these randomness are already chosen by the verifier and can merely be viewed as constants known both to <span class="math">\\mathcal{V}</span> and <span class="math">\\mathcal{P}</span>. The circuit then selects multiple subsets from <span class="math">\\mathbf{V}_{i}</span> according to the wiring of the circuit (i.e., gates used by layer <span class="math">j&lt;i</span> from layer <span class="math">i</span>), arrange them in the pre-defined order. The circuit then computes the multilinear extensions of these subsets, and evaluates them on the corresponding points from the input. The structure of the circuit <span class="math">C_{i}</span> is given in Figure 1.</p>

    <p class="text-gray-300">The output of the circuit is exactly the multiple evaluations of the multilinear extensions, which are known to the verifier. The verifier then executes the original GKR protocol for layered arithmetic circuits (Protocol 4) on this circuit, which reduces the output to a single evaluation of the multilinear extension of the input. This can further be expressed as the evaluation of the multilinear extension of <span class="math">\\mathbf{V}_{i}</span>, together with the multilinear extension of all the randomnesses used to compute the output. As the latter is known to <span class="math">\\mathcal{V}</span>, <span class="math">\\mathcal{V}</span> can compute it locally. In this way, using the circuit, <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> reduce multiple claims about subsets of layer <span class="math">i</span> to one claim about <span class="math">\\tilde{V}_{i}</span>.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig.1: Circuit  <span class="math">C_i</span>  computing  <span class="math">\\tilde{V}_{0,i}(r^{(0,i)}),\\tilde{V}_{i - 1,i}(r^{(i - 1,i)}),\\tilde{V}_{i - 1,i}(r^{(i - 1,i)&#x27;})</span></p>

    <p class="text-gray-300">Another tricky part is that the size of the circuit is not optimal if implemented naively. As shown in Figure 1, the circuit expands the randomness to the bookkeeping tables exactly as described in Algorithm 1, which has logarithmic layers  <span class="math">\\log S_{i}</span> . If the circuit also takes  <span class="math">\\mathbf{V}_i</span>  as input at the same layer as the randomness,  <span class="math">\\mathbf{V}_i</span>  has to be relayed by logarithmic layers and the size of the circuit is  <span class="math">O(S_{i}\\log S_{i})</span> . Instead, we feed  <span class="math">\\mathbf{V}_i</span>  as input to one layer above the bookkeeping tables, as shown on the left side of Figure 1. The circuit selects multiple subsets out of it in one layer, and then computes the inner product between a subset and its corresponding bookkeeping table, which gives the evaluation of its multilinear extension. Now the size of the circuit is linear to the total size of all the subsets. The GKR protocol can support inputs from different layers with such a structure, as proposed in [28]. We give the formal protocol in Protocol 2.</p>

    <p class="text-gray-300">Protocol 2. Let  <span class="math">C_i</span>  be the circuit in Figure 1 with input in consisting of two parts:  <span class="math">V_i = (V_i(0), \\ldots, V_i(S_i - 1))</span>  and  <span class="math">R = (r^{(0,i)}, \\ldots, r^{(i-1,i)}, r^{(i-1,i)&#x27;})</span> , and the output out =  <span class="math">(\\tilde{V}_{0,i}(r^{(0,i)}), \\ldots, \\tilde{V}_{i-1,i}(r^{(i-1,i)}), \\tilde{V}_{i-1,i}(r^{(i-1,i)&#x27;}))</span> . We use  <span class="math">V = (V_{0,i}, \\ldots, V_{i-1,i}, V_{i-1,i})</span>  to represent subsets of  <span class="math">V_i</span>  used in layer  <span class="math">j</span>  ( <span class="math">j &amp;lt; i</span> ), and  <span class="math">T_R = (T_{r^{(0,i)}}, \\ldots, T_{r^{(i-1,i)}}, T_{r^{(i-1,i)&#x27;}})</span>  to represent bookkeeping tables after expanding  <span class="math">r^{(0,i)}, \\ldots, r^{(i-1,i)}, r^{(i-1,i)&#x27;}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  invoke Protocol 4 on inner products to reduce the claim about out to the claim about the layer of  <span class="math">\\mathbf{V}</span>  and  <span class="math">\\mathbf{T}_R</span> :  <span class="math">q = r_1 \\cdot \\mathbf{V}(r) + (1 - r_1) \\cdot \\mathbf{T}_R(r)</span></li>

      <li><span class="math">\\mathcal{V}</span>  requires  <span class="math">\\mathcal{P}</span>  to provide values of  <span class="math">\\mathbf{V}(r)</span>  and  <span class="math">\\mathbf{T}_R(r)</span>  to check  <span class="math">q = r_1 \\cdot \\mathbf{V}(r) + (1 - r_1) \\cdot \\mathbf{T}_R(r)</span> .</li>

      <li><span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  invoke Protocol 4 on the left part and the right part of  <span class="math">C_i</span>  as shown in Figure 1, separately. For the left part, it reduces the claim about  <span class="math">\\mathbf{V}(r)</span>  to the claim about  <span class="math">\\mathbf{V}_i(r^{(i)})</span>  in one layer. For the right part, it reduces the claim about  <span class="math">\\mathbf{T}_R(r)</span>  to the claim about  <span class="math">\\mathbf{R}(r^{(i)})</span> .</li>

      <li><span class="math">\\mathcal{V}</span>  asks  <span class="math">\\mathcal{P}</span>  to send  <span class="math">V_{i}(r^{(i)})</span>  and checks the reduction for the left part.  <span class="math">\\mathcal{V}</span>  computes  <span class="math">\\pmb{R}(r^{(i)})</span>  itself and checks the reduction for the right part. If both checks pass, output 1; otherwise, output 0.</li>

    </ul>

    <p class="text-gray-300">Efficiency. In order to analyze the prover time for Protocol 2, we consider the specific structure of  <span class="math">C_i</span> , as shown in Figure 1. For layer  <span class="math">k &amp;lt; i</span> , there are  <span class="math">S_{k,i}</span>  gates from layer  <span class="math">i</span>  connected to layer  <span class="math">k</span> . The number of gates in  <span class="math">C_i</span>  is</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">at most $8</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{V}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, which is </span>8\\sum_{k=0}^{i-1}S_{k,i}<span class="math">. By Theorem 1, the prover time for the circuit </span>C_i<span class="math"> is </span>O(\\sum_{k=0}^{i-1}S_{k,i})<span class="math">. So the total prover time for circuits </span>C_1,\\ldots,C_d<span class="math"> is </span>8\\sum_{i=1}^{d}\\sum_{k=0}^{i-1}S_{k,i}=O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> as </span>\\sum_{i=1}^{d}\\sum_{k=0}^{i-1}S_{k,i}<span class="math"> equals to the number of all output wires in the circuit, which is at most </span>2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The size of <span class="math">C_i</span> is $O(S_{0,i} + \\ldots + S_{i-1,i}) = O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, the depth of </span>C_i<span class="math"> is </span>O(\\log S_i) = O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> and the size of input </span>\\mathbf{R}_i<span class="math"> is at most </span>s_{0,i} + s_{1,i} + \\ldots + s_{i-1,i} + s_{i-1,i} \\leq d\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Let </span>Q_i<span class="math"> be the time to evaluate all </span>\\widetilde{add}<span class="math"> and </span>\\widetilde{mult}<span class="math"> at the corresponding random points in </span>C_i<span class="math">. Therefore, the verifier time for </span>C_i<span class="math"> is </span>O(\\log^2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ d\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ Q_i)<span class="math"> and the proof size is </span>O(\\log^2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> by Theorem 1. In total for all layers, </span>\\mathcal{V}<span class="math"> runs in </span>\\min\\{O(d\\log^2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ d^2\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ Q),</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}<span class="math"> time and the proof size is </span>\\min\\{O(d\\log^2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">),</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}<span class="math">, where </span>Q = Q_1 + Q_2 + \\ldots + Q_d$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Combining multiple claims by a sumcheck protocol. Though the prover time of the first method is optimal asymptotically, the overhead in practice is still relatively high. As we will show in Section 5, the cost per gate is around <span class="math">5 \\times</span> slower than that of the original GKR protocol on layered circuits. In addition, it introduces an overhead of $O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ on the proof size and the verifier time. Therefore, inspired by the design of the circuit in Figure 1, we propose the second method to combine multiple claims through a single sumcheck protocol.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The key idea is to define a function to connect the gate in <span class="math">V_{i}</span> with the same gate in a subset <span class="math">V_{k,i}</span>. Formally speaking, we define <span class="math">C_{k,i}(z,x):\\{0,1\\}^{s_{k,i}}\\times \\{0,1\\}^{s_i}\\to \\mathbb{F}</span> such that it takes two gate labels, one in the subset <span class="math">V_{k,i}</span> and the other in the entire layer <span class="math">V_{i}</span>, and <span class="math">C_{k,i}(z,x) = 1</span> if the gate <span class="math">z</span> in <span class="math">V_{k,i}</span> is exactly the gate <span class="math">x</span> in <span class="math">V_{i}</span>. Otherwise <span class="math">C_{k,i}(z,x) = 0</span>. Note that the function <span class="math">C_{k,i}</span> serves exactly the same purpose as the circuit in Figure 1 selecting subsets from <span class="math">\\mathbf{V}_i</span>.</p>

    <p class="text-gray-300">With the definition of <span class="math">C_{k,i}</span>, given <span class="math">\\tilde{V}_{0,i}(r^{(0,i)}),\\ldots ,\\tilde{V}_{i - 1,i}(r^{(i - 1,i)}),\\tilde{V}_{i - 1,i}(r^{(i - 1,i)&#x27;})</span>, <span class="math">\\mathcal{V}</span> can combine them through a random linear combination. In particular, <span class="math">\\mathcal{V}</span> chooses <span class="math">i + 1</span> random values <span class="math">\\alpha_{0,i},\\dots,\\alpha_{i - 1,i},\\alpha_{i - 1,i}&#x27;</span>. Then we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sum_{k = 0}^{i - 1} \\alpha_{k, i} \\tilde{V}_{k, i} (r^{(k, i)}) + \\alpha_{i - 1, i}&#x27; \\tilde{V}_{i - 1, i} (r^{(i - 1, i)&#x27;}) \\\\ = \\sum_{k = 0}^{i - 1} \\alpha_{k, i} \\left(\\sum_{x \\in \\{0, 1\\}^{s_i}} \\tilde{C}_{k, i} \\left(r^{(k, i)}, x\\right) \\tilde{V}_{i} (x)\\right) + \\alpha_{i - 1, i}&#x27; \\sum_{x \\in \\{0, 1\\}^{s_i}} \\tilde{C}_{i - 1, i} \\left(r^{(i - 1, i)&#x27;}, x\\right) \\tilde{V}_{i} (x) \\\\ = \\sum_{x \\in \\{0, 1\\}^{s_i}} \\tilde{V}_{i} (x) \\left(\\sum_{k = 0}^{i - 1} \\alpha_{k, i} \\tilde{C}_{k, i} \\left(r^{(k, i)}, x\\right) + \\alpha_{i - 1, i}&#x27; \\tilde{C}_{i - 1, i} \\left(r^{(i - 1, i)&#x27;}, x\\right)\\right) \\\\ = \\sum_{x \\in \\{0, 1\\}^{s_i}} \\tilde{V}_{i} (x) g_{i} (x), \\end{array} \\tag{10}</span></div>

    <p class="text-gray-300">where <span class="math">\\tilde{C}_{k,i}</span> is the multilinear extension of <span class="math">C_{k,i}</span> and <span class="math">\\tilde{C}_{k,i}(r^{(k,i)},x) = \\sum_{z\\in \\{0,1\\}^{s_{k,i}}}\\tilde{\\beta} (r^{(k,i)},z)C_{k,i}(z,x)</span>.</p>

    <p class="text-gray-300">We define <span class="math">g_{i}(x) = \\sum_{k = 0}^{i - 1}\\alpha_{k,i}\\tilde{C}_{k,i}(r^{(k,i)},x) + \\alpha_{i - 1,i}&#x27;\\tilde{C}_{i - 1,i}(r^{(i - 1,i)&#x27;},x)</span>. As <span class="math">g_{i}(x)</span> only depends on the structure of the circuit, <span class="math">\\mathcal{V}</span> can compute <span class="math">g_{i}(r^{(i)})</span> herself given the randomness of <span class="math">r^{(i)}</span>. <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> can execute a sumcheck protocol on Equation 10, which reduces multiple claims of subsets to a single evaluation of <span class="math">\\tilde{V}_i(r^{(i)})</span> for the randomness of <span class="math">r^{(i)}</span>.</p>

    <p class="text-gray-300">22</p>

    <p class="text-gray-300">Algorithm 6 <span class="math">\\mathbf{A}_{g_i}\\gets</span> Initialize<span class="math">(r^{(0,i)},\\dots,r^{(i-1,i)},r^{(i-1,i)&#x27;})</span> 0: <span class="math">r^{(0,i)},\\dots,r^{(i-1,i)},r^{(i-1,i)&#x27;}</span>; 0: <span class="math">r^{(0,i)},\\dots,r^{(i-1,i)},r^{(i-1,i)&#x27;}</span>; 0: <span class="math">r^{(0,i)},\\dots,r^{(i-1,i)},r^{(i-1,i)&#x27;}</span>; 0: <span class="math">r^{(0,i)},\\dots,r^{(i-1,i)},r^{(i-1,i)&#x27;}</span>; 0: <span class="math">r^{(0,i)},\\dots,r^{(i-1,i)},r^{(i-1,i)}&#x27;</span></p>

    <p class="text-gray-300">Input: <span class="math">r^{(0,i)},\\dots,r^{(i-1,i)},r^{(i-1,i)&#x27;}</span>; Output: <span class="math">\\mathbf{A}_{g_{i}}</span>;</p>

    <p class="text-gray-300">1: <span class="math">\\forall x\\in\\{0,1\\}^{s_{i}}</span>, set <span class="math">\\mathbf{A}_{g_{i}}[x]=0</span> 2: for <span class="math">k=0,\\cdots,i-1</span> do 3: <span class="math">\\mathbf{G}\\leftarrow\\text{Precompute}(r^{(k,i)})</span> 4: for <span class="math">t\\in\\{0,1\\}^{s_{k,i}}</span> such that <span class="math">C_{k,i}(t,x)=1</span> do 5: <span class="math">\\mathbf{A}_{g_{i}}[x]=\\mathbf{A}_{g_{i}}[x]+\\alpha_{k,i}\\cdot\\mathbf{G}[t]</span> 6: <span class="math">\\mathbf{G}\\leftarrow\\text{Precompute}(r^{(i-1,i)&#x27;})</span> 7: for <span class="math">t\\in\\{0,1\\}^{s_{i-1,i}}</span> such that <span class="math">C_{i-1,i}(t,x)=1</span> do 8: <span class="math">\\mathbf{A}_{g_{i}}[x]=\\mathbf{A}_{g_{i}}[x]+\\alpha_{i-1,i}^{\\prime}\\cdot\\mathbf{G}[t]</span> 9: return <span class="math">\\mathbf{A}_{g_{i}}</span>;</p>

    <p class="text-gray-300">It remains to show that the sumcheck can be executed by the prover in linear time. Recall that given the bookkeeping tables of two multilinear polynomials, the prover can run the sumcheck protocol in linear time using Algorithm 2. In the equation above, the bookkeeping table <span class="math">\\mathbf{A}_{\\tilde{V}_{i}}</span> for <span class="math">\\tilde{V}_{i}</span> is already known by the prove as the values of the gates in layer <span class="math">i</span>. We further describe a linear time algorithm to initialize the bookkeeping table <span class="math">\\mathbf{A}_{g_{i}}</span> for <span class="math">g_{i}(x)</span> in Algorithm 6.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Lemma 7.</h6>

    <p class="text-gray-300">The bookkeeping table <span class="math">\\mathbf{A}_{g_{i}}</span> can be initialized in <span class="math">O(S_{0,i}+\\cdots+S_{i-1,i})</span> time.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">It takes <span class="math">O(S_{0,i}+\\ldots+S_{i-1,i}+S_{i-1,i})</span> time to run procedure <span class="math">\\text{Precompute}(r^{(0,i)})</span>, <span class="math">\\ldots</span>, <span class="math">\\text{Precompute}(r^{(i-1,i)})</span> and <span class="math">\\text{Precompute}(r^{(i-1,i)&#x27;})</span>. There are at most <span class="math">S_{0,i}+\\ldots+S_{i-1,i}+S_{i-1,i}</span> entries such that <span class="math">C_{k,i}(t,x)=1</span>. Therefore, the running time of Algorithm 6 is <span class="math">O(S_{0,i}+\\ldots+S_{i-1,i})</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Efficiency. Next we analyze the efficiency of the second scheme to combine multiple claims to one claim. The prover costs $O(S_{1}+\\ldots+S_{d})=O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> to compute all bookkeeping tables of </span>A_{\\tilde{V}_{i}}<span class="math">. By Lemma 7, the prover runs Algorithm 6 to compute all bookkeeping tables of </span>\\mathcal{A}_{g_{i}}<span class="math"> in </span>O(\\sum_{i=1}^{d}\\sum_{k=0}^{i-1}S_{k,i})=O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> time. By Lemma 1, the prover runs the sumcheck protocol on Equation 10 for layer 1 to layer </span>d<span class="math"> in </span>O(\\sum_{i=1}^{d}S_{i})=O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ time. So the total prover time of the second scheme is also linear in the circuit size.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By the efficiency of the sumcheck protocol in Protocol 1, it takes <span class="math">O(\\log S_{i})</span> for the verifier to validate the sumcheck protocol on Equation 10 in round <span class="math">i</span>. She also needs to generate <span class="math">i+1</span> random numbers and computes <span class="math">g_{i}(r^{(i)})</span> in round <span class="math">i</span>. Suppose <span class="math">\\mathcal{V}</span> costs <span class="math">T_{i}</span> to compute <span class="math">g_{i}(r^{(i)})</span> and <span class="math">T=T_{1}+\\ldots+T_{d}</span>, the total verifier time is $O(\\log S_{1}+\\ldots+\\log S_{d})+O(2+\\ldots+d+1)+T_{1}+\\ldots+T_{d}=O(d\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+d^{2}+T)<span class="math">. The total proof size is </span>O(d\\log C+d^{2})<span class="math">. Finally, by a similar analysis to the prover time, the term </span>O(d^{2})<span class="math"> in the complexity is always bounded by </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. This is because in order for the prover to send a claim about </span>\\tilde{V}_{i,j}<span class="math">, there has to be a gate in layer </span>i<span class="math"> connecting to layer </span>j$, thus the number of claims cannot be more than</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Therefore, the proof size of our protocol is </span>\\min\\{O(d\\log C+d^{2}),O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\}<span class="math"> and the verifier time is </span>\\min\\{O(d\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+d^{2}+T),O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-24" class="text-xl font-semibold mt-8">3.4 The Full Protocol for General Arithmetic Circuits</h3>

    <p class="text-gray-300">Combining the first step and the sumcheck scheme of the second step together, we give the full protocol of the generalized GKR for arbitrary arithmetic circuits in Protocol 3. As the prover time, proof size and the verifier time of the second method to combine multiple points are all better than those of the first method, we state the protocol and the theorem using the second method.</p>

    <p class="text-gray-300">Protocol 3. Let <span class="math">\\mathbb{F}</span> be a prime field. Let <span class="math">C\\colon\\mathbb{F}^{n}\\to\\mathbb{F}^{k}</span> be a <span class="math">d</span>-depth unlayered arithmetic circuit. <span class="math">\\mathcal{P}</span> wants to convince that <span class="math">C(\\textbf{in})=\\textbf{out}</span> where in is the input from <span class="math">\\mathcal{V}</span>, and out is the output. Without loss of generality, assume <span class="math">n</span> is the power of 2 and both parties can pad them if not.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define the multilinear extension of array out as <span class="math">\\tilde{V}_{0}</span>. <span class="math">\\mathcal{V}</span> chooses a random <span class="math">g\\in\\mathbb{F}^{s_{0}}</span> and sends it to <span class="math">\\mathcal{P}</span>. Both parties compute <span class="math">\\tilde{V}_{0}(g)</span>.</li>

      <li><span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> run a sumcheck protocol on Equation 7 for <span class="math">i=0</span>. At the end of the protocol, <span class="math">\\mathcal{V}</span> receives <span class="math">\\tilde{V}_{0,1}(r^{(0,1)^{\\prime}})</span>, <span class="math">\\tilde{V}_{0,1}(r^{(0,1)})</span>, <span class="math">\\tilde{V}_{0,2}(r^{(0,2)})</span>, <span class="math">\\ldots</span>, <span class="math">\\tilde{V}_{0,d}(r^{(0,d)})</span>. <span class="math">\\mathcal{V}</span> computes left side of the above equation by removing the summation symbol and replacing <span class="math">x,y</span> with <span class="math">r^{(0,1)^{\\prime}},r^{(0,1)}</span>. If it does not equal to the last message of the sumcheck, <span class="math">\\mathcal{V}</span> outputs <span class="math">\\mathtt{0}</span> and aborts.</li>

      <li>For <span class="math">i=1,...,d-1,d</span>:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Given <span class="math">\\tilde{V}_{0,i}(r^{(0,i)}),\\ldots,\\tilde{V}_{i-1,i}(r^{(i-1,i)^{\\prime}}),V_{i-1,i}(r^{(i-1,i)})</span> and <span class="math">r^{(0,i)},r^{(1,i)}</span>, <span class="math">\\ldots</span>, <span class="math">r^{(i-1,i)^{\\prime}}</span>, <span class="math">r^{(i-1,i)}</span>, <span class="math">\\mathcal{V}</span> chooses <span class="math">i+1</span> random elements <span class="math">\\alpha_{0,i},\\ldots,\\alpha_{i-1,i},\\alpha_{i-1,i}^{\\prime}</span> in <span class="math">\\mathbb{F}</span> and sends them to <span class="math">\\mathcal{P}</span>. Then <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> run the sumcheck protocol on Equation 10. If <span class="math">\\mathcal{V}</span> does not abort in the sumcheck protocol, he receives <span class="math">\\tilde{V}_{i}(r^{(i)})</span> for some randomness <span class="math">r^{(i)}\\in\\mathbb{F}^{s_{i}}</span> in the last round.</li>

      <li>If <span class="math">i&lt;d</span>, <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> run the sumcheck on Equation 7 by replacing <span class="math">g</span> with <span class="math">r^{(i)}</span>. At the end of the sumcheck protocol, <span class="math">\\mathcal{P}</span> sends <span class="math">\\mathcal{V}</span> <span class="math">\\tilde{V}_{i,i+1}(r^{(i,i+1)^{\\prime}})</span>, <span class="math">\\tilde{V}_{i,i+1}(r^{(i,i+1)})</span>, <span class="math">\\ldots</span>, <span class="math">\\tilde{V}_{i,d}(r^{(i,d)})</span>.</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathcal{V}</span> computes the left side of the above equation by removing the summation symbol and replacing <span class="math">x,y</span> with <span class="math">r^{(i,i+1)^{\\prime}},r^{(i,i+1)}</span> and checks it equals to the last message of the sumcheck. If all checks in the sumcheck pass, <span class="math">V</span> uses <span class="math">\\tilde{V}_{i,i+1}(r^{(i,i+1)^{\\prime}})</span> and <span class="math">\\tilde{V}_{i,i+1}(r^{(i,i+1)})</span> to proceed to the <span class="math">(i+1)</span>-th layer. Otherwise, <span class="math">\\mathcal{V}</span> outputs <span class="math">\\mathtt{0}</span> and aborts.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At the input layer <span class="math">d</span>, <span class="math">\\mathcal{V}</span> has one claim of <span class="math">\\tilde{V}_{d}(r^{(d)})</span>. <span class="math">\\mathcal{V}</span> computes it locally or queries the oracle of evaluations of <span class="math">\\tilde{V}_{d}</span> at <span class="math">r^{(d)}</span> and checks that it is the same as the claim. If yes, output <span class="math">\\mathtt{1}</span>; otherwise, output <span class="math">\\mathtt{0}</span>.</li>

    </ol>

    <h6 id="sec-25" class="text-base font-medium mt-4">Theorem 2.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">C:\\mathbb{F}^{n}\\to\\mathbb{F}^{k}</span> be a depth-<span class="math">d</span> general arithmetic circuit. Protocol 3 is an interactive proof for the function computed by <span class="math">C</span> with soundness $O(d\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. The running time of the prover </span>\\mathcal{P}<span class="math"> is </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. The proof size is </span>\\min\\{O(d\\log C+d^{2}),O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\}<span class="math">. Let the time to evaluate all </span>add_{i,j}<span class="math"> and </span>mult_{i,j}<span class="math"> at random points be </span>T^{\\prime}<span class="math">, the time to evaluate </span>g_{i}(r^{(i)})<span class="math"> be </span>T_{i}<span class="math"> in Equation 10, and </span>T=T_{1}+\\ldots+T_{d}<span class="math">, the running time of </span>\\mathcal{V}<span class="math"> is </span>\\min\\{O(n+d\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+d^{2}+T+T^{\\prime}),O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If in addition $d=\\mathsf{polylog}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, </span>T<span class="math"> and </span>T^{\\prime}<span class="math"> are in </span>\\mathsf{polylog}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ time in Theorem 2, Protocol 3 is an interactive proof with succinct proof size and verifier time.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We give the formal proof in Appendix B.</p>

    <h2 id="sec-26" class="text-2xl font-bold">4 Zero Knowledge Arguments from Generalized GKR</h2>

    <p class="text-gray-300">In this section, we build a new zero knowledge argument protocol for general arithmetic circuits based on Protocol 3. The construction follows the same ideas proposed in <em>[12, 26]</em>. In particular, as proposed in <em>[28]</em>, we combine the GKR protocol with a (zero knowledge) polynomial commitment scheme on the witness to build an argument scheme. In order to achieve zero knowledge, we apply the zero knowledge sumcheck protocol <em>[12, 26]</em> on Equation 7 and 10 to eliminate the leakage during the sumcheck. We then use the low degree extensions instead of multilinear extensions of <span class="math">V_{i}</span> and <span class="math">V_{i,j}</span> so that their evaluations sent from the prover to the verifier do not leak information about the values in the circuit. The only difference is that for the values <span class="math">V_{i}</span> in each layer <span class="math">i</span> of the circuit, the verifier receives multiple claims, one for each of the subsets <span class="math">V_{i,j}</span>, instead of two claims about <span class="math">V_{i}</span> in the original GKR protocol. Thus, we use the low degree extensions of both <span class="math">V_{i}</span> and <span class="math">V_{i,j}</span> with a different random masking polynomial for each. In this way, these claims leak no information about the values.</p>

    <p class="text-gray-300">For completeness, we present the formal definitions and protocols in Appendix C. As the second approach to combine multiple claims in Section 3.3 is better on all aspects, we focus on building zero knowledge arguments using the second approach. The first approach can also be lifted to a zero knowledge argument with similar ideas by applying a zero knowledge GKR protocol on circuit <span class="math">C_{i}</span> in Figure 1. We state the theorem of our zero knowledge argument here and give the proof in Appendix C.4.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Theorem 3.</h6>

    <p class="text-gray-300">For an input size <span class="math">n</span> and a finite field <span class="math">\\mathbb{F}</span>, let <span class="math">\\mathcal{C}_{\\mathbb{F}}</span> represent the set of general arithmetic circuits of depth <span class="math">d</span> on <span class="math">\\mathbb{F}</span>, then there exists a zero knowledge argument for the relation</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathcal{R}=\\{(C,x;w):C\\in\\mathcal{C}_{\\mathbb{F}}\\wedge</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq n\\wedge C(x;w)=1\\},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">as defined in Definition 4. Moreover, using the polynomial commitment scheme (Definition 5) in <em>[27]</em>, for every <span class="math">(C,x;w)\\in\\mathcal{R}</span>, the running time of <span class="math">\\mathcal{P}</span> is $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+n\\log n)<span class="math">. The running time of </span>\\mathcal{V}<span class="math"> is </span>\\min\\{O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\log^{2}n+d\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+d^{2}+T^{\\prime\\prime}_{-}),O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\}<span class="math">, where </span>T^{\\prime\\prime}<span class="math"> is the total time to compute all functions of </span>\\hat{add}<span class="math"> and </span>\\hat{mult}<span class="math"> and all functions of </span>g_{i}(r^{(i)})<span class="math"> in the second step. The total proof size is </span>\\min\\{O(d\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+d^{2}),O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\}<span class="math">. In case </span>d<span class="math"> is </span>\\mathsf{polylog}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> and </span>T^{\\prime\\prime}<span class="math"> is also </span>\\mathsf{polylog}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$, the protocol is a succinct argument with succinct verifier time.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-28" class="text-2xl font-bold">5 Implementations and Evaluations</h2>

    <p class="text-gray-300">We fully implement our new interactive proof protocols for general arithmetic circuits and use them to build a zero knowledge argument system for general</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover time (s)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier time (s)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof size (KB)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">29</td>

            <td class="px-3 py-2 border-b border-gray-700">211</td>

            <td class="px-3 py-2 border-b border-gray-700">213</td>

            <td class="px-3 py-2 border-b border-gray-700">29</td>

            <td class="px-3 py-2 border-b border-gray-700">211</td>

            <td class="px-3 py-2 border-b border-gray-700">213</td>

            <td class="px-3 py-2 border-b border-gray-700">29</td>

            <td class="px-3 py-2 border-b border-gray-700">211</td>

            <td class="px-3 py-2 border-b border-gray-700">213</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">d=50</td>

            <td class="px-3 py-2 border-b border-gray-700">GKR</td>

            <td class="px-3 py-2 border-b border-gray-700">0.118</td>

            <td class="px-3 py-2 border-b border-gray-700">0.465</td>

            <td class="px-3 py-2 border-b border-gray-700">1.908</td>

            <td class="px-3 py-2 border-b border-gray-700">0.052</td>

            <td class="px-3 py-2 border-b border-gray-700">0.206</td>

            <td class="px-3 py-2 border-b border-gray-700">0.838</td>

            <td class="px-3 py-2 border-b border-gray-700">83</td>

            <td class="px-3 py-2 border-b border-gray-700">95</td>

            <td class="px-3 py-2 border-b border-gray-700">107</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Our Scheme 1</td>

            <td class="px-3 py-2 border-b border-gray-700">0.043</td>

            <td class="px-3 py-2 border-b border-gray-700">0.154</td>

            <td class="px-3 py-2 border-b border-gray-700">0.576</td>

            <td class="px-3 py-2 border-b border-gray-700">0.013</td>

            <td class="px-3 py-2 border-b border-gray-700">0.042</td>

            <td class="px-3 py-2 border-b border-gray-700">0.151</td>

            <td class="px-3 py-2 border-b border-gray-700">280</td>

            <td class="px-3 py-2 border-b border-gray-700">397</td>

            <td class="px-3 py-2 border-b border-gray-700">535</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Our Scheme 2</td>

            <td class="px-3 py-2 border-b border-gray-700">0.012</td>

            <td class="px-3 py-2 border-b border-gray-700">0.049</td>

            <td class="px-3 py-2 border-b border-gray-700">0.197</td>

            <td class="px-3 py-2 border-b border-gray-700">0.003</td>

            <td class="px-3 py-2 border-b border-gray-700">0.011</td>

            <td class="px-3 py-2 border-b border-gray-700">0.044</td>

            <td class="px-3 py-2 border-b border-gray-700">93</td>

            <td class="px-3 py-2 border-b border-gray-700">106</td>

            <td class="px-3 py-2 border-b border-gray-700">120</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">d=75</td>

            <td class="px-3 py-2 border-b border-gray-700">GKR</td>

            <td class="px-3 py-2 border-b border-gray-700">0.244</td>

            <td class="px-3 py-2 border-b border-gray-700">0.973</td>

            <td class="px-3 py-2 border-b border-gray-700">3.954</td>

            <td class="px-3 py-2 border-b border-gray-700">0.100</td>

            <td class="px-3 py-2 border-b border-gray-700">0.404</td>

            <td class="px-3 py-2 border-b border-gray-700">1.608</td>

            <td class="px-3 py-2 border-b border-gray-700">129</td>

            <td class="px-3 py-2 border-b border-gray-700">147</td>

            <td class="px-3 py-2 border-b border-gray-700">166</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Our Scheme 1</td>

            <td class="px-3 py-2 border-b border-gray-700">0.069</td>

            <td class="px-3 py-2 border-b border-gray-700">0.243</td>

            <td class="px-3 py-2 border-b border-gray-700">0.910</td>

            <td class="px-3 py-2 border-b border-gray-700">0.021</td>

            <td class="px-3 py-2 border-b border-gray-700">0.066</td>

            <td class="px-3 py-2 border-b border-gray-700">0.237</td>

            <td class="px-3 py-2 border-b border-gray-700">416</td>

            <td class="px-3 py-2 border-b border-gray-700">593</td>

            <td class="px-3 py-2 border-b border-gray-700">803</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Our Scheme 2</td>

            <td class="px-3 py-2 border-b border-gray-700">0.019</td>

            <td class="px-3 py-2 border-b border-gray-700">0.075</td>

            <td class="px-3 py-2 border-b border-gray-700">0.304</td>

            <td class="px-3 py-2 border-b border-gray-700">0.004</td>

            <td class="px-3 py-2 border-b border-gray-700">0.017</td>

            <td class="px-3 py-2 border-b border-gray-700">0.066</td>

            <td class="px-3 py-2 border-b border-gray-700">168</td>

            <td class="px-3 py-2 border-b border-gray-700">188</td>

            <td class="px-3 py-2 border-b border-gray-700">208</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Comparison of our scheme 1, our scheme 2 and the original GKR on random circuits.</p>

    <p class="text-gray-300">arithmetic circuits. We name our new system Virgo++. The implementation is in C++. There are around 1900 lines of code for Protocol 3 and 1600 lines for building the arithmetic circuit to combine multiple evaluations into one (Protocol 2). We implement two variants of combining multiple claims to one claim in step 3(b) of Protocol 3 as described in Section 3.3. One is building the arithmetic circuit to make the reduction as shown in Figure 1 and the other is running the sumcheck protocol on Equation 10. Our protocols work on any finite field, and we choose the extension field  <span class="math">\\mathbb{F}_{p^2}</span>  for the Mersenne prime  <span class="math">p = 2^{61} - 1</span> . This is the same as in [27], and we choose it so that our interactive proof protocols can be compatible with the polynomial commitments in [27] to build zero knowledge arguments. The choice of the finite field does not affect our comparison to the original GKR protocol in the next Section. Our protocols provide  <span class="math">100+</span>  bits of security. We plan to make our implementation open-source.</p>

    <p class="text-gray-300">Hardware. We ran all of the experiments on an AWS EC2 c5a.2xlarge instance with an AMD EPYC 7R32 CPU with 3.512Ghz, 8 cores and 16GB of RAM. Our current implementation is not parallelized and we only utilize a single CPU core in the experiments. We report the average running time of 10 executions.</p>

    <p class="text-gray-300">In this section, we compare the performance of our new protocols with the original GKR protocol. For a fair comparison, we re-implement the GKR protocol for layered arithmetic circuits with the same field and libraries in  <span class="math">\\mathrm{C + + }</span> . We generate random general circuits with depth  <span class="math">d = 50</span>  and  <span class="math">d = 75</span> . We vary the number of gates in each layer from  <span class="math">2^{9}</span>  to  <span class="math">2^{13}</span> . Our schemes can easily go beyond  <span class="math">2^{13}</span> , but the original GKR protocol on the corresponding layered circuits runs out of memory on our machine. We randomly sample the type of each gate, input value and the wiring patterns. We execute our new protocols directly on these general circuits. We refer the one using the arithmetic circuit to combine multiple claims to one claim in Protocol 2 as scheme 1 and the one using the sumcheck protocol on Equation 10 to combine multiple claims for step 3(b) in Protocol 3 as scheme 2. We then transform the general circuits to layered circuits by relaying necessary values layer by layer, and execute the original GKR protocol on the layered circuits. We report the prover time, verifier time and proof size in Table 1.</p>

    <p class="text-gray-300">First, when we transform the general circuits to layered circuits, the size of the circuit increases by  <span class="math">13 \\times</span>  for  <span class="math">d = 50</span>  and by  <span class="math">19 \\times</span>  for  <span class="math">d = 75</span> . This roughly</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">agrees with the blowup of $O(d</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> and justifies the high overhead of transforming general circuits to layered circuits. As shown in Table 1, when the depth is 50, the prover time of our scheme 1 is faster by 2-4</span>\\times<span class="math"> than the original GKR protocol, while our scheme 2 is faster by 9-10</span>\\times<span class="math">. When the depth is 75, the speedup increases to 3-5</span>\\times<span class="math"> for scheme 1 and 12-13</span>\\times<span class="math"> for scheme 2. Finally, the prover time in all schemes grows linearly with the size of the circuit, and is very efficient in practice. The cost per gate in scheme 2 is only 0.49</span>\\mu$s.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To further justify the improvement, the prover of the original GKR protocol for layered circuits takes around 21 field multiplications per gate. In the implementation of our new protocols, the cost per gate of the prover is around 120 field multiplications for scheme 1 and around 27 field multiplications for scheme 2. The average cost per gate of our scheme 2 is only 1.29<span class="math">\\times</span> of the original GKR protocol. In other words, as long as the layered circuit has 22% or more relay gates, it is faster to remove those relay gates and run our new protocol of scheme 2 on the corresponding general circuit. The speedup in our experiments above matches the analysis here.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our protocols introduce an overhead on the proof size compared to the original GKR protocol. In particular, the proof size of our first scheme is 3-5<span class="math">\\times</span> larger than the GKR protocol, matching the $\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> overhead in the complexity of the proof size. However, the proof size of our second scheme is very close to the GKR protocol. It is only 1.1-1.3</span>\\times<span class="math"> larger, showing that this variant reduces the proof size significantly upon scheme 1. In fact, this overhead is introduced by the second sumcheck protocol to combine multiple points. The term </span>d^{2}$ in the complexity has minimal impact on the total proof size. In all cases, the proof size is succinct. The largest proof size is still less than 1MB and the proof size is always much smaller than the size of the circuit.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As the circuits are generated randomly, the verifier time in all schemes are linear in the circuit size. Therefore, the comparisons on the verifier time of the three protocols are similar to the comparisons on the prover time. As shown in Table 1, our scheme 1 is faster by 4-6<span class="math">\\times</span> than the original GKR protocol on circuits with <span class="math">d=50</span>, and 5-7<span class="math">\\times</span> faster for <span class="math">d=75</span>. Our scheme 2 is 17-19<span class="math">\\times</span> faster on circuits with <span class="math">d=50</span>, and 23-25<span class="math">\\times</span> faster for <span class="math">d=75</span>. Therefore, we observe in the experiments that our scheme 2 improves the performance of scheme 1 on all the aspects on random circuits, proving our statement in Section 3.3. Compared to the original GKR protocol, our scheme 2 is much faster on the prover time and the verifier time, and incurs only a small overhead on the proof size.</p>

    <h3 id="sec-30" class="text-xl font-semibold mt-8">5.2 Evaluations of Our Zero Knowledge Argument</h3>

    <p class="text-gray-300">In this section, we present the performance of our new zero knowledge argument for general arithmetic circuits, as described in Section 4. We use the zero knowledge polynomial commitment scheme in <em>[27]</em> to lift our new interactive proofs to zero knowledge arguments. We import the open-source code of zero knowledge polynomial commitment scheme in <em>[5]</em>. We also compare our zero knowledge proof system with Spartan <em>[4]</em>.</p>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> (a)  <span class="math">\\mathcal{P}</span>  time</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> (b)  <span class="math">\\mathcal{V}</span>  time</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> (c) Proof size Fig. 2: Comparison of Virgo++ and Spartan.</p>

    <p class="text-gray-300">We do experiments on the benchmark of computing the hash functions of SHA-256. For our protocol, we modify the circuit generation file of [1, 2] to obtain the general arithmetic circuit for SHA-256. In fact, the code first generates the general circuit of SHA-256 and then pads it to the layered circuit, and our new protocol makes the circuit design even simpler. The circuit contains other types of gates such as subtraction, bit decomposition and reconstruction. We modify our protocols to support all these types of gates. Each SHA-256 circuit has 99,949 gates in total (around  <span class="math">2^{17}</span> ), with the input size of 7,226 (around  <span class="math">2^{13}</span> ). In the experiments, we vary the number of SHA-256 from 1 to 64.</p>

    <p class="text-gray-300">Figure 2 shows the performance of our system (red line with circle markers). As shown in the figure, Virgo++ achieves good efficiency in practice. It only takes 0.15s to generate the proof of one SHA-256 circuit, and 0.014s to verify. In the largest instance of 64 hashes, our system takes 10.8s to generate the proof, the verifier time is 0.016s and the proof size is 209KB. The verifier time only grows slightly with the number of hashes, as the verifier time of our new GKR protocol is only linear in the size of a single hash in the data-parallel circuit, and logarithmic in the size of the entire circuit.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Comparing to Spartan. We then compare the performance of our system with Spartan [18], which also combines the sumcheck protocol and the polynomial commitments to construct zero knowledge arguments on R1CS. As described in [18, Section 5], the sumcheck protocol is executed on a equation defined by the extended witness  <span class="math">z</span>  and the matrices  <span class="math">A, B, C</span>  in an R1CS instance. The size of the extended witness roughly maps to the number of multiplication gates in a circuit, and the number of nonzero elements in the matrices roughly maps to the number of addition gates. As Spartan is also using the linear time sumcheck protocol proposed in [26], the prover time of the sumcheck protocol is expected to be similar to the sumcheck protocol in our zero knowledge argument ( <span class="math">O(n)</span>  in Spartan, where  <span class="math">n</span>  is the number of nonzeros in the matrices [18], and  $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$  in Virgo++.). The major improvement of Virgo++ comes from the polynomial commitment part. In our scheme, the polynomial commitment is only on the witness of the circuit, while in Spartan, the polynomial commitment is on the extended witness, which is always larger than the size of the real witness of the circuit. The improvement comes at the cost of larger proof size. In our scheme, we reduce the correctness of the output layer by layer to the real witness and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">the proof size is linear in the depth, while in Spartan, the sumcheck is executed on one “layer” to check the correctness of the extended witness.</p>

    <p class="text-gray-300">We demonstrate the comparison in our experiments. We download the open-source code of Spartan from <em>[4]</em>. We use the highly-optimized R1CS for SHA-256 generated by jsnark <em>[3]</em>. Each SHA-256 has 25,656 (around <span class="math">2^{15}</span>) constraints and 25,546 (around <span class="math">2^{15}</span>) witnesses. The number of nonzero elements is 87,689 in <span class="math">A</span>, 54,968 in <span class="math">B</span> and 78,232 in <span class="math">C</span>. Note that the size of the extended witness is <span class="math">3.5\\times</span> larger than the witness of our general circuit for the same function of SHA-256, while the number of nonzeros in the matrices is roughly the same as the size of the circuit, matching our analysis above. As the open-source code of Spartan only works on randomly generated R1CS instances, we generate random R1CS instances with exactly the same number of constraints, witnesses and nonzero elements as SHA-256.</p>

    <p class="text-gray-300">Figure 2 shows the performance of Spartan (blue line with star markers). As shown in the figure, the prover time of Virgo++ is 1.2–1.8<span class="math">\\times</span> faster than Spartan. The verifier of Spartan grows linearly with the number of hashes and is significantly slower than Virgo++. We believe its verifier time can also be made sublinear for data-parallel circuits, but it is not considered in <em>[18]</em> and its implementation. In contrast, the proof size of Virgo++ is 4.1–7.9<span class="math">\\times</span> larger than Spartan. Other than the reason explained above, this is also partly because we are using the polynomial commitment in <em>[27]</em> based on interactive oracle proofs (IOP). It is known that IOP-based schemes have larger proof size compared to discrete-log based schemes including the one used in Spartan, but are plausibly post-quantum secure.</p>

    <p class="text-gray-300">The evaluations of Spartan are in the NIZK mode. There is a SNARK mode of Spartan that has sublinear verifier time in the holographic model, but the prover time is <span class="math">9\\times</span> slower. Finally, as described in Section 1.3, our new GKR protocol can also be used for delegation of computations. Spartan does not work in this setting as the size of the extended witness is always asymptotically the same as the size of the computation and the verifier does not save anything by delegating the computation using Spartan. In a recent manuscript <em>[19]</em>, the proof size of Spartan is improved from square-root to logarithmic in the size of the R1CS instance, but the prover time is <span class="math">3.8\\times</span> slower. We do not include the comparison as its implementation is not available.</p>

    <h2 id="sec-31" class="text-2xl font-bold">Acknowledgment</h2>

    <p class="text-gray-300">We greatly thank Yuval Ishai for proposing the interesting problem of interactive proofs for general circuits and for the helpful discussions on the paper. This material is based upon work supported by DARPA under Contract No. HR001120C0087. Any opinions, findings and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of DARPA.</p>

    <p class="text-gray-300">##</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Hyrax reference implementation. https://github.com/hyraxZK/hyraxZK</li>

      <li>[2] Libra implementation. https://github.com/sunblaze-ucb/fastZKP/tree/Libra</li>

      <li>[3] jsnark. https://github.com/akosba/jsnark (2015)</li>

      <li>[4] Spartan. https://github.com/microsoft/Spartan (2020)</li>

      <li>[5] Virgo implementation. https://github.com/sunblaze-ucb/Virgo (2020)</li>

      <li>[6] Ames, S., Hazay, C., Ishai, Y., Venkitasubramaniam, M.: Ligero: Lightweight sublinear arguments without a trusted setup. In: Proceedings of the ACM SIGSAC Conference on Computer and Communications Security (2017)</li>

      <li>[7] Babai, L., Fortnow, L., Lund, C.: Non-deterministic exponential time has two-prover interactive protocols. Computational complexity 1(1), 3–40 (1991)</li>

      <li>[8] Baum, C., Bootle, J., Cerulli, A., Del Pino, R., Groth, J., Lyubashevsky, V.: Sublinear lattice-based zero-knowledge arguments for arithmetic circuits. In: Annual International Cryptology Conference. pp. 669–699. Springer (2018)</li>

      <li>[9] Ben-Sasson, E., Chiesa, A., Riabzev, M., Spooner, N., Virza, M., Ward, N.P.: Aurora: Transparent succinct arguments for r1cs. In: Annual international conference on the theory and applications of cryptographic techniques. pp. 103–128. Springer (2019)</li>

      <li>[10] Blumberg, A.J., Thaler, J., Vu, V., Walfish, M.: Verifiable computation using multiple provers. Cryptology ePrint Archive, Report 2014/846 (2014), https://eprint.iacr.org/2014/846</li>

      <li>[11] Bünz, B., Bootle, J., Boneh, D., Poelstra, A., Wuille, P., Maxwell, G.: Bulletproofs: Short proofs for confidential transactions and more. In: Proceedings of the Symposium on Security and Privacy (SP), 2018. vol. 00, pp. 319–338</li>

      <li>[12] Chiesa, A., Forbes, M.A., Spooner, N.: A Zero Knowledge Sumcheck and its Applications. CoRR abs/1704.02086 (2017), http://arxiv.org/abs/1704.02086</li>

      <li>[13] Cormode, G., Mitzenmacher, M., Thaler, J.: Practical Verified Computation with Streaming Interactive Proofs. In: Proceedings of the 3rd Innovations in Theoretical Computer Science Conference. ITCS ’12</li>

      <li>[14] Goldwasser, S., Kalai, Y.T., Rothblum, G.N.: Delegating Computation: Interactive Proofs for Muggles. J. ACM 62(4), 27:1–27:64 (Sep 2015)</li>

      <li>[15] Goldwasser, S., Micali, S., Rackoff, C.: The knowledge complexity of interactive proof systems. SIAM Journal on computing 18(1), 186–208 (1989)</li>

      <li>[16] Lund, C., Fortnow, L., Karloff, H., Nisan, N.: Algebraic Methods for Interactive Proof Systems. J. ACM 39(4), 859–868 (Oct 1992)</li>

      <li>[17] Parno, B., Howell, J., Gentry, C., Raykova, M.: Pinocchio: Nearly practical verifiable computation. In: S&amp;P 2013. pp. 238–252 (2013)</li>

      <li>[18] Setty, S.: Spartan: Efficient and general-purpose zksnarks without trusted setup. In: Annual International Cryptology Conference. pp. 704–737. Springer (2020)</li>

      <li>[19] Setty, S., Lee, J.: Quarks: Quadruple-efficient transparent zksnarks. Cryptology ePrint Archive, Report 2020/1275 (2020), https://eprint.iacr.org/2020/1275</li>

      <li>[20] Shamir, A.: Ip= pspace. Journal of the ACM (JACM) 39(4), 869–877 (1992)</li>

      <li>[21] Thaler, J.: Time-Optimal Interactive Proofs for Circuit Evaluation. In: Canetti, R., Garay, J.A. (eds.) Advances in Cryptology – CRYPTO 2013 (2013)</li>

      <li>[22] Thaler, J.: A note on the GKR protocol (2015), available at http://people.cs.georgetown.edu/jthaler/GKRNote.pdf</li>

      <li>[23] Wahby, R.S., Ji, Y., Blumberg, A.J., Shelat, A., Thaler, J., Walfish, M., Wies, T.: Full accounting for verifiable outsourcing. In: Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security. ACM (2017)</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[24] Wahby, R.S., Tzialla, I., Shelat, A., Thaler, J., Walfish, M.: Doubly-efficient zk-SNARKs without trusted setup. In: 2018 IEEE Symposium on Security and Privacy (SP). pp. 926–943. IEEE (2018)</li>

      <li>[25] Walfish, M., Blumberg, A.J.: Verifying computations without reexecuting them. Commun. ACM 58(2), 74–84 (2015)</li>

      <li>[26] Xie, T., Zhang, J., Zhang, Y., Papamanthou, C., Song, D.: Libra: Succinct zero-knowledge proofs with optimal prover computation. In: Annual International Cryptology Conference. pp. 733–764. Springer (2019)</li>

      <li>[27] Zhang, J., Xie, T., Zhang, Y., Song, D.: Transparent polynomial delegation and its applications to zero knowledge proof. In: S&P 2020</li>

      <li>[28] Zhang, Y., Genkin, D., Katz, J., Papadopoulos, D., Papamanthou, C.: vSQL: Verifying arbitrary SQL queries over dynamic outsourced databases. In: Security and Privacy (SP), 2017 IEEE Symposium on. pp. 863–880. IEEE (2017)</li>

      <li>[29] Zhang, Y., Genkin, D., Katz, J., Papadopoulos, D., Papamanthou, C.: A Zero-Knowledge version of vSQL. Cryptology ePrint (2017)</li>

      <li>[30] Zhang, Y., Genkin, D., Katz, J., Papadopoulos, D., Papamanthou, C.: vRAM: Faster verifiable RAM with program-independent preprocessing. In: Proceeding of IEEE Symposium on Security and Privacy (S&P) (2018)</li>

    </ul>

    <p class="text-gray-300">Protocol 4. Let  <span class="math">\\mathbb{F}</span>  be a finite field. Let  <span class="math">C\\colon \\mathbb{F}^n\\to \\mathbb{F}^k</span>  be a  <span class="math">d</span> -depth layered arithmetic circuit.  <span class="math">\\mathcal{P}</span>  wants to convince that  <span class="math">\\mathbf{out} = C(\\mathbf{in})</span>  where  <span class="math">\\mathbf{in}</span>  is the input from  <span class="math">\\mathcal{V}</span> , and  <span class="math">\\mathbf{out}</span>  is the output. Without loss of generality, assume  <span class="math">n</span>  and  <span class="math">k</span>  are both powers of 2 and we can pad them if not.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define the multilinear extension of array out as  <span class="math">\\tilde{V}_0</span> .  <span class="math">\\mathcal{V}</span>  chooses a random  <span class="math">g \\in \\mathbb{F}^{s_0}</span>  and sends it to  <span class="math">\\mathcal{P}</span> . Both parties compute  <span class="math">\\tilde{V}_0(g)</span> .</li>

      <li><span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  run a sumcheck protocol on</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\tilde {V} _ {0} (g ^ {(0)}) = \\sum_ {x, y \\in \\{0, 1 \\} ^ {s _ {1}}} (\\tilde {a d d} _ {1} (g ^ {(0)}, x, y) (\\tilde {V} _ {1} (x) + \\tilde {V} _ {1} (y)) + \\tilde {m u l t} _ {1} (g ^ {(0)}, x, y) \\tilde {V} _ {1} (x) \\tilde {V} _ {1} (y))</span></div>

    <p class="text-gray-300">At the end of the protocol,  <span class="math">\\mathcal{V}</span>  receives  <span class="math">\\tilde{V}_1(u^{(1)})</span>  and  <span class="math">\\tilde{V}_1(v^{(1)})</span> .  <span class="math">\\mathcal{V}</span>  computes  <span class="math">\\tilde{mult}_1(g^{(0)},u^{(1)},v^{(1)})</span> ,  <span class="math">\\tilde{add}_1(g^{(0)},u^{(1)},v^{(1)})</span>  and checks that  <span class="math">\\tilde{add}_1(g^{(0)},u^{(1)},v^{(1)})</span>  ( <span class="math">\\tilde{V}_1(u^{(1)}) + \\tilde{V}_1(v^{(1)}) + \\tilde{mult}_1(g^{(0)},u^{(1)},v^{(1)})</span> )  <span class="math">\\tilde{V}_1(u^{(1)})\\tilde{V}_1(v^{(1)})</span>  equals to the last message of the sumcheck.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">i = 1,\\dots,d - 1</span> :</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  randomly selects  <span class="math">\\alpha_{i,1},\\alpha_{i,2}\\in \\mathbb{F}</span>  and sends them to  <span class="math">\\mathcal{P}</span> .</li>

      <li><span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  run the sumcheck on the equation</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\alpha_ {i, 1} \\tilde {V} _ {i} (u ^ {(i)}) + \\alpha_ {i, 2} \\tilde {V} _ {i} (v ^ {(i)}) = \\\\ \\sum_ {x, y \\in \\{0, 1 \\} ^ {s _ {i + 1}}} \\left(\\left(\\alpha_ {i, 1} \\tilde {a d d} _ {i + 1} \\left(u ^ {(i)}, x, y\\right) + \\alpha_ {i, 2} \\tilde {a d d} _ {i + 1} \\left(v ^ {(i)}, x, y\\right)\\right) \\left(\\tilde {V} _ {i + 1} (x) + \\tilde {V} _ {i + 1} (y)\\right) \\right. \\\\ + \\left(\\alpha_ {i, 1} \\tilde {m u l t} _ {i + 1} \\left(u ^ {(i)}, x, y\\right) + \\alpha_ {i, 2} \\tilde {m u l t} _ {i + 1} \\left(v ^ {(i)}, x, y\\right)\\right) \\tilde {V} _ {i + 1} (x) \\tilde {V} _ {i + 1} (y)) \\\\ \\end{array}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At the end of the sumcheck protocol,  <span class="math">\\mathcal{P}</span>  sends  <span class="math">\\mathcal{V} \\tilde{V}_{i+1}(u^{(i+1)})</span>  and  <span class="math">\\tilde{V}_{i+1}(v^{(i+1)})</span> .</li>

      <li><span class="math">\\mathcal{V}</span>  computes the following and checks if it equals to the last message of the sumcheck. For simplicity, let  <span class="math">Mult_{i+1}(x) = \\tilde{mult}_{i+1}(x, u^{(i+1)}, v^{(i+1)})</span>  and  <span class="math">Add_{i+1}(x) = \\tilde{add}_{i+1}(x, u^{(i+1)}, v^{(i+1)})</span> .</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left(\\alpha_ {i, 1} \\text {M u l t} _ {i + 1} \\left(u ^ {(i)}\\right) + \\alpha_ {i, 2} \\text {M u l t} _ {i + 1} \\left(v ^ {(i)}\\right) \\left(\\tilde {V} _ {i + 1} \\left(u ^ {(i + 1)}\\right) \\tilde {V} _ {i + 1} \\left(v ^ {(i + 1)}\\right)\\right) + \\right. \\\\ \\left. \\left(\\alpha_ {i, 1} A d d _ {i + 1} \\left(u ^ {(i)}\\right) + \\alpha_ {i, 2} A d d _ {i + 1} \\left(v ^ {(i)}\\right) \\left(\\tilde {V} _ {i + 1} \\left(u ^ {(i + 1)}\\right) + \\tilde {V} _ {i + 1} \\left(v ^ {(i + 1)}\\right)\\right) \\right. \\right. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">If all checks in the sumcheck pass,  <span class="math">V</span>  uses  <span class="math">\\tilde{V}_{i+1}(u^{(i+1)})</span>  and  <span class="math">\\tilde{V}_{i+1}(v^{(i+1)})</span>  to proceed to the  <span class="math">(i+1)</span> -th layer. Otherwise,  <span class="math">\\mathcal{V}</span>  outputs 0 and aborts.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At the input layer  <span class="math">d</span> ,  <span class="math">\\mathcal{V}</span>  has two claims  <span class="math">\\tilde{V}_d(u^{(d)})</span>  and  <span class="math">\\tilde{V}_d(v^{(d)})</span> .  <span class="math">\\mathcal{V}</span>  evaluates  <span class="math">\\tilde{V}_d</span>  at  <span class="math">u^{(d)}</span>  and  <span class="math">v^{(d)}</span>  using the input and checks that they are the same as the two claims. If yes, output 1; otherwise, output 0.</li>

    </ol>

    <p class="text-gray-300">Proof. Completeness. The completeness is straightforward by the completeness of the sumcheck protocol.</p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(r^{(i)})=\\tilde{V}_{i}^{\\prime}(r^{(i)}).</span></p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(r^{(i)})=\\tilde{V}_{i}^{\\prime}(r^{(i)}).</span></p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(r^{(i)})</span></p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(r^{(i)})</span></p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(r^{(i)})</span></p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(r^{(i)})</span></p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(r^{(i)})</span></p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(r^{(i)})</span></p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(r^{(i)})</span></p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(r^{(i)})</span></p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(r^{(i)})</span></p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(r^{(i)})</span></p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(r^{(i)})</span></p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(r^{(i)})</span></p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(r^{(i)})</span></p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(r^{(i)})</span></p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(r^{(i)})</span></p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(r^{(i)})</span></p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(r^{(i)})</span></p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(r^{(i)})</span></p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(r^{(i)})</span></p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(r^{(i)})</span></p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(r^{(i)})</span></p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(r^{(i)})</span></p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(r^{(i)})</span></p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(r^{(i)})</span></p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(r^{(i)})</span></p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(r^{(i)})</span></p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(r^{(i)})</span></p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(r^{(i)})</span></p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(r^{(i)})</span></p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(r^{(i)})</span></p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(r^{(i)})</span></p>

    <p class="text-gray-300">such that <span class="math">(x;w)\\in R</span> for some input <span class="math">x</span>. We focus on arguments of knowledge which have the stronger property that if the prover convinces the verifier of the statement validity, then the prover must know <span class="math">w</span>. We use <span class="math">\\mathcal{G}</span> to represent the generation phase of the public parameters <span class="math">\\mathsf{pp}</span>. Formally, consider the definition below, where we assume <span class="math">R</span> is known to <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span>.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Definition 4.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{R}</span> be an NP relation. A tuple of algorithm <span class="math">(\\mathcal{G},\\mathcal{P},\\mathcal{V})</span> is a zero knowledge argument of knowledge for <span class="math">\\mathcal{R}</span> if the following holds.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Correctness. For every <span class="math">\\mathsf{pp}</span> output by <span class="math">\\mathcal{G}(1^{\\lambda})</span> and <span class="math">(x,w)\\in R</span>,</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\langle\\mathcal{P}(\\mathsf{pp},w),\\mathcal{V}(\\mathsf{pp})\\rangle(x)=\\mathtt{1}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Knowledge Soundness. For any PPT prover <span class="math">\\mathcal{P}^{<em>}</span>, there exists a PPT extractor <span class="math">\\mathcal{E}</span> such that given the access to the entire executing process and the randomness of <span class="math">\\mathcal{P}^{</em>}</span>, <span class="math">\\mathcal{E}</span> can extract a witness <span class="math">w</span> such that <span class="math">\\mathsf{pp}\\leftarrow\\mathcal{G}(1^{\\lambda})</span>, <span class="math">\\pi^{<em>}\\leftarrow\\mathcal{P}^{</em>}(x,\\mathsf{pp})</span> and <span class="math">w\\leftarrow\\mathcal{E}^{\\mathcal{P}^{<em>}}(\\mathsf{pp},x,\\pi^{</em>})</span>, the following probability is <span class="math">\\mathsf{negl}(\\lambda)</span>:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr[(x;w)\\notin\\mathcal{R}\\land\\mathcal{V}(x,\\pi^{*},\\mathsf{pp})=\\mathtt{1}]</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Zero knowledge. There exists a PPT simulator <span class="math">\\mathcal{S}</span> such that for any PPT algorithm <span class="math">\\mathcal{V}^{<em>}</span>, auxiliary input <span class="math">z\\in\\{0,1\\}^{</em>}</span>, <span class="math">(x;w)\\in\\mathcal{R}</span>, <span class="math">\\mathsf{pp}</span> output by <span class="math">\\mathcal{G}(1^{\\lambda})</span>, it holds that</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{View}(\\langle\\mathcal{P}(\\mathsf{pp},w),\\mathcal{V}^{<em>}(z,\\mathsf{pp})\\rangle(x))\\approx\\mathcal{S}^{\\mathcal{V}^{</em>}}(x,z)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We say that <span class="math">(\\mathcal{G},\\mathcal{P},\\mathcal{V})</span> is a succinct argument system if the total communication between <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> (proof size) are $\\mathsf{poly}(\\lambda,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In the definition of zero knowledge, <span class="math">\\mathcal{S}^{\\mathcal{V}^{<em>}}</span> denotes that the simulator <span class="math">\\mathcal{S}</span> is given the randomness of <span class="math">\\mathcal{V}^{</em>}</span> sampled from polynomial-size space. This definition is commonly used in existing transparent zero knowledge proof schemes <em>[6, 9, 11, 24, 26, 27]</em>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Zero knowledge polynomial commitment. Let <span class="math">\\mathbb{F}</span> be a finite field, <span class="math">\\mathcal{F}</span> be a family of <span class="math">\\ell</span>-variate polynomial over <span class="math">\\mathbb{F}</span>, and <span class="math">D</span> be a variable-degree parameter. We use <span class="math">\\mathcal{W}_{\\ell,d}</span> to denote the collection of all monomials in <span class="math">\\mathcal{F}</span> and $N=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{W}_{\\ell,D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=(D+1)^{\\ell}<span class="math">. A zero knowledge verifiable polynomial commitment (zkPC) for </span>f\\in\\mathcal{F}<span class="math"> and </span>t\\in\\mathbb{F}^{\\ell}$ consists of the following algorithms:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{pp}\\leftarrow\\mathsf{zkPC}.\\mathsf{KeyGen}(1^{\\lambda})</span>,</li>

      <li><span class="math">\\mathsf{com}\\leftarrow\\mathsf{zkPC}.\\mathsf{Commit}(f,r_{f},\\mathsf{pp})</span>,</li>

      <li><span class="math">((y,\\pi);\\{0,1\\})\\leftarrow\\langle\\mathsf{zkPC}.\\mathsf{Open}(f,r_{f}),\\mathsf{zkPC}.\\mathsf{Verify}(\\mathsf{com})\\rangle(t,\\mathsf{pp})</span></li>

    </ul>

    <h6 id="sec-36" class="text-base font-medium mt-4">Definition 5.</h6>

    <p class="text-gray-300">A zkPC scheme satisfies the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. For any polynomial <span class="math">f\\in\\mathcal{F}</span> and value <span class="math">t\\in\\mathbb{F}^{\\ell}</span>, <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{zkPC}.\\mathsf{KeyGen}(1^{\\lambda})</span>, <span class="math">\\mathsf{com}\\leftarrow\\mathsf{zkPC}.\\mathsf{Commit}(f,r_{f},\\mathsf{pp})</span>, it holds that</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\langle\\mathsf{zkPC}.\\mathsf{Open}(f,r_{f}),\\mathsf{zkPC}.\\mathsf{Verify}(\\mathsf{com})\\rangle(t,\\mathsf{pp})=\\mathtt{1}\\right]=\\mathtt{1}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Knowledge Soundness. For any PPT adversary  <span class="math">\\mathcal{A}</span> ,  <span class="math">\\mathsf{pp} \\gets \\mathsf{zkPC.KeyGen}(1^{\\lambda})</span> , there exists a PPT extractor  <span class="math">\\mathcal{E}</span> . Given any tuple  <span class="math">(pp, \\mathsf{com}^{<em>})</span>  and the executing process of  <span class="math">\\mathcal{A}</span> ,  <span class="math">\\mathcal{E}</span>  can extract a function  <span class="math">f^{</em>} \\in \\mathcal{F}</span>  and the randomness  <span class="math">r_{f^{<em>}}</span>  such that  <span class="math">(f^{</em>}, r_{f^{<em>}}) \\gets \\mathcal{E}^{\\mathcal{A}}(\\mathsf{pp}, \\mathsf{com}^{</em>})</span>  and  <span class="math">\\mathsf{com}^{<em>} \\gets \\mathsf{zkPC.Commit}(f^{</em>}, r_{f^{*}}, \\mathsf{pp})</span> . The following probability is negligible of  <span class="math">\\lambda</span> :</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\operatorname<em>{Pr}\\left[((y^{</em>},\\pi^{<em>});1)\\leftarrow \\langle \\mathcal{A}(),\\mathsf{zkPC.Verify}(\\mathsf{com}^{</em>})\\rangle (t,\\mathsf{pp})\\wedge (f^{<em>},r_{f^{</em>}})\\leftarrow \\mathcal{E}^{\\mathcal{A}}(\\mathsf{pp},\\mathsf{com}^{<em>})\\wedge f^{</em>}(t)\\neq y^{*}\\right]</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Zero Knowledge. For security parameter  <span class="math">\\lambda</span> , polynomial  <span class="math">f \\in \\mathcal{F}</span> ,  <span class="math">\\mathsf{pp} \\gets \\mathsf{zkPC.KeyGen}(1^{\\lambda})</span> , PPT algorithm  <span class="math">\\mathcal{A}</span> , and simulator  <span class="math">\\mathcal{S} = (\\mathcal{S}_1, \\mathcal{S}_2)</span> , consider the following two experiments:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">RealA,f(pp): 1. com ← zkPC.Commit(f,rf,pp) 2. t ← A(com,pp) 3. (y,π) (zkPC.Open(f,rf),A)(t,pp) 4. b ← A(com,y,π,pp) 5. Output b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">IdealA,SA(pp): 1. com ← S1(1^λ,pp) 2. t ← A(com,pp) 3. (y,π) ← ⟨S2,A⟩(ti,pp), given ora- cle access to y = f(t). 4. b ← A(com,y,π,pp) 5. Output b</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For any PPT algorithm  <span class="math">\\mathcal{A}</span>  and all polynomial  <span class="math">f\\in \\mathbb{F}</span> , there exists simulator  <span class="math">\\mathcal{S}</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr [ \\operatorname {R e a l} _ {\\mathcal {A}, f} (\\mathrm {p p}) = 1 ] - \\Pr [ \\operatorname {I d e a l} _ {\\mathcal {A}, \\mathcal {S} ^ {\\mathcal {A}}} (\\mathrm {p p}) = 1 ]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\operatorname {n e g l} (\\lambda).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">To build a zero knowledge argument for arbitrary arithmetic circuit using Protocol 3, we follow the same blueprint of [26] using zkPC, zero knowledge sumcheck and low degree extensions. In the following, we present the zero knowledge version of step 3(b) and step 3(a) in Protocol 3, followed by the whole zero knowledge argument.</p>

    <p class="text-gray-300">In step 3(b) of the full protocol,  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  execute a sumcheck protocol on Equation 7, during which  <span class="math">\\mathcal{P}</span>  sends  <span class="math">\\mathcal{V}</span>  evaluations of the polynomial at several random points chosen by  <span class="math">\\mathcal{V}</span> . These evaluations leak information about the values in the circuit, as they can be viewed as weighted sums of these values.</p>

    <p class="text-gray-300">To prevent the leakage, we take the zero knowledge sumcheck proposed by Xie et al. in [26]. To prove</p>

    <div class="my-4 text-center"><span class="math-block">H = \\sum_ {x _ {1}, x _ {2}, \\dots , x _ {\\ell} \\in \\{0, 1 \\}} f (x _ {1}, x _ {2}, \\dots , x _ {\\ell}),</span></div>

    <p class="text-gray-300">the prover generates a random polynomial  <span class="math">g</span>  such that  <span class="math">g(x_{1},\\ldots ,x_{\\ell}) = a_{0} + g_{1}(x_{1}) + g_{2}(x_{2}) + \\ldots +g_{\\ell}(x_{\\ell})</span> , where  <span class="math">g_{i}(x_{i}) = a_{i,1}x_{i} + a_{i,2}x_{i}^{2} + \\ldots +a_{i,\\tau}x_{i}^{\\tau}</span>  is a random univariate polynomial of degree  <span class="math">\\tau</span>  ( <span class="math">\\tau</span>  is the variable degree of  <span class="math">f</span> ). Note here that the size of  <span class="math">g</span>  is only  <span class="math">O(\\tau \\ell)</span> , while the size of  <span class="math">f</span>  is exponential in  <span class="math">\\ell</span> .  <span class="math">\\mathcal{P}</span>  commits to the polynomial  <span class="math">g</span>  using zkPC.Commit, and sends the verifier a claim  <span class="math">G = \\sum_{x_1,x_2,\\dots,x_\\ell \\in \\{0,1\\}}g(x_1,x_2,\\dots,x_\\ell)</span> . The verifier picks a random number  <span class="math">\\rho \\in \\mathbb{F}</span> , and execute a sumcheck protocol with the prover on</p>

    <div class="my-4 text-center"><span class="math-block">H + \\rho G = \\sum_ {x _ {1}, x _ {2}, \\dots , x _ {\\ell} \\in \\{0, 1 \\}} (f (x _ {1}, x _ {2}, \\dots , x _ {\\ell}) + \\rho g (x _ {1}, x _ {2}, \\dots , x _ {\\ell})).</span></div>

    <p class="text-gray-300">At the last round of this sumcheck, the prover opens the commitment of <span class="math">g</span> at <span class="math">g(r_{1},\\ldots,r_{\\ell})</span> using zkPC.Open, and the verifier computes <span class="math">f(r_{1},\\ldots,r_{\\ell})</span> by subtracting <span class="math">\\rho g(r_{1},\\ldots,r_{\\ell})</span> from the last message, and compares it with the oracle access of <span class="math">f</span>. It is shown that as long as the polynomial commitment is zero knowledge, the protocol is zero knowledge. Intuitively, this is because the information of <span class="math">f</span> transmitted in the sumcheck protocol is exactly masked by the randomness of <span class="math">g</span>. We present the protocol in Protocol 5 and we have the following theorem:</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Protocol 5.</h6>

    <p class="text-gray-300">We assume the existence of a zkPC protocol defined in Section C.1. For simplicity, we omit the randomness <span class="math">r_{f}</span> and public parameters <span class="math">\\mathsf{pp},\\mathsf{vp}</span> without any ambiguity. To prove the claim <span class="math">H=\\sum\\limits_{x_{1},x_{2},\\ldots,x_{\\ell}\\in\\{0,1\\}}f(x_{1},x_{2},\\ldots,x_{\\ell})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span> selects a polynomial <span class="math">g(x_{1},\\ldots,x_{\\ell})=a_{0}+g_{1}(x_{1})+g_{2}(x_{2})+\\ldots+g_{\\ell}(x_{\\ell})</span>, where <span class="math">g_{i}(x_{i})=a_{i,1}x_{i}+a_{i,2}x_{i}^{2}+\\ldots+a_{i,r}x_{i}^{r}</span> and all <span class="math">a_{i,j}</span>s are uniformly random. <span class="math">\\mathcal{P}</span> sends <span class="math">H=\\sum\\limits_{x_{1},x_{2},\\ldots,x_{\\ell}\\in\\{0,1\\}}f(x_{1},x_{2},\\ldots,x_{\\ell})</span>, <span class="math">G=\\sum\\limits_{x_{1},x_{2},\\ldots,x_{\\ell}\\in\\{0,1\\}}g(x_{1},x_{2},\\ldots,x_{\\ell})</span> and <span class="math">\\mathsf{com}_{g}=\\mathsf{zkPC.Commit}(g,r_{g},\\mathsf{pp})</span> to <span class="math">\\mathcal{V}</span>.</li>

      <li><span class="math">\\mathcal{V}</span> uniformly selects <span class="math">\\rho\\in\\mathbb{F}^{*}</span>, computes <span class="math">H+\\rho G</span> and sends <span class="math">\\rho</span> to <span class="math">\\mathcal{P}</span>.</li>

      <li><span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> run the sumcheck protocol on</li>

    </ol>

    <p class="text-gray-300"><span class="math">H+\\rho G=\\sum\\limits_{x_{1},x_{2},\\ldots,x_{\\ell}\\in\\{0,1\\}}(f(x_{1},x_{2},\\ldots,x_{\\ell})+\\rho g(x_{1},x_{2},\\ldots,x_{\\ell}))</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At the last round of the sumcheck protocol, <span class="math">\\mathcal{V}</span> obtains a claim <span class="math">h_{\\ell}(r_{\\ell})=f(r_{1},r_{2},\\ldots,r_{\\ell})+\\rho g(r_{1},r_{2},\\ldots,r_{\\ell})</span>. <span class="math">\\mathcal{P}</span> opens the commitment of <span class="math">g</span> at <span class="math">r=(r_{1},\\ldots,r_{\\ell})</span> and <span class="math">\\mathcal{V}</span> verifies by using zkPC.Open and zkPC.Verify. If the verification fails, <span class="math">\\mathcal{V}</span> aborts.</li>

      <li><span class="math">\\mathcal{V}</span> computes <span class="math">h_{\\ell}(r_{\\ell})-\\rho g(r_{1},\\ldots,r_{\\ell})</span> and compares it with the oracle access of <span class="math">f(r_{1},\\ldots,r_{\\ell})</span>.</li>

    </ol>

    <h6 id="sec-39" class="text-base font-medium mt-4">Theorem 4 (<em>[26]</em>)</h6>

    <p class="text-gray-300">Protocol 5 is complete and sound for the relationship of <span class="math">H=\\sum\\limits_{x_{1},x_{2},\\ldots,x_{\\ell}\\in\\{0,1\\}}f(x_{1},x_{2},\\ldots,x_{\\ell})</span>. In addition, for every verifier <span class="math">\\mathcal{V}^{<em>}</span> and every <span class="math">\\ell</span>-variate polynomial <span class="math">f:\\mathbb{F}^{\\ell}\\to\\mathbb{F}</span> with variable degree <span class="math">d</span>, there exists a simulator <span class="math">\\mathcal{S}</span> such that given access to <span class="math">H=\\sum_{x_{1},x_{2},\\ldots,x_{\\ell}\\in\\{0,1\\}}f(x_{1},x_{2},\\ldots,x_{\\ell})</span>, <span class="math">\\mathcal{S}</span> is able to simulate the partial view of <span class="math">\\mathcal{V}^{</em>}</span> in Protocol 5. The efficiency of prover time, verifier time and proof size in Protocol 5 retain the same as in Protocol 1.</p>

    <p class="text-gray-300">We apply the zero knowledge sumcheck directly on the sumcheck equation (Equation 7 and 10) of our new GKR protocol. It eliminates all the leakage during the sumcheck protocol.</p>

    <h3 id="sec-40" class="text-xl font-semibold mt-8">C.3 Zero Knowledge GKR</h3>

    <p class="text-gray-300">Even with the zero knowledge sumcheck, the protocol still leaks information about values in the circuit. In particular, at the end of the zero knowledge sumcheck, <span class="math">\\mathcal{V}</span> still needs an oracle access to <span class="math">f(r_{\\underline{1}},\\ldots,r_{\\ell})</span>. When executed on Equation 7, the verifier evaluates all <span class="math">\\hat{add}</span> and <span class="math">\\hat{mult}</span> at the random point, and</p>

    <p class="text-gray-300">queries the prover for the evaluations of <span class="math">\\tilde{V}_{0,i},\\cdots,\\tilde{V}_{i-1,i}</span>. These evaluations reveal information about values in the circuit.</p>

    <p class="text-gray-300">To prevent this leakage, we use the same idea in <em>[26]</em> to replace them with their low-degree extensions <span class="math">\\dot{V}_{0,i},\\cdots,\\dot{V}_{i-1,i}</span>. Let</p>

    <p class="text-gray-300"><span class="math">\\dot{V}_{j,i}(x)\\stackrel{{\\scriptstyle def}}{{=}}\\tilde{V}_{j,i}(x)+Z_{j,i}(x)\\cdot\\sum_{w\\in\\{0,1\\}}R_{j,i}(x_{1},w),</span> (11)</p>

    <p class="text-gray-300">where <span class="math">Z_{j,i}(x)=\\prod_{k=1}^{s_{j,i}}x_{k}(1-x_{k})</span> is the vanishing polynomial, i.e., <span class="math">Z_{j,i}(x)=0</span> for all <span class="math">x\\in\\{0,1\\}^{s_{j,i}}</span>, and <span class="math">R_{j,i}</span> is the mask polynomial with only two variables generated by <span class="math">\\mathcal{P}</span>.</p>

    <p class="text-gray-300">Additionally, in the last round of the sumcheck on Equation 10, <span class="math">\\mathcal{V}</span> asks for <span class="math">\\tilde{V}(r^{(i)})</span>, which leaks information about <span class="math">V_{i}</span>. With exactly the same idea as above, we replace it with its low-degree extension <span class="math">\\dot{V}_{i}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\dot{V}_{i}(x_{1},\\ldots,x_{s_{i}})\\stackrel{{\\scriptstyle def}}{{=}}\\tilde{V}_{i}(x_{1},\\ldots,x_{s_{i}})+Z_{i}(x_{1},\\ldots,x_{s_{i}})\\sum_{w\\in\\{0,1\\}}R_{i}(x_{1},w),</span> (12)</p>

    <p class="text-gray-300">where <span class="math">Z_{i}(x)=\\prod_{i=1}^{s_{i}}x_{i}(1-x_{i})</span> is still the vanishing polynomial, and <span class="math">R_{i}</span> is still a mask multilinear polynomial with only two variables. As <span class="math">R_{0,i},\\cdots,R_{i-1,i}</span> and <span class="math">R_{i}</span> are randomly selected by <span class="math">\\mathcal{P}</span>, revealing several evaluations of them does not leak information about <span class="math">V_{0,i},\\cdots,V_{i-1,i}</span> and <span class="math">V_{i}</span> thus the values in the circuit. The zero knowledge polynomial commitment scheme is used to commit to these masking polynomials and later open them at random points. With these changes, Equation 7 becomes</p>

    <p class="text-gray-300"><span class="math">\\dot{V}_{i}(g)=\\sum_{x,y\\in\\{0,1\\}^{s_{i,i+1}}_{w\\in\\{0,1\\}}[\\tilde{\\beta}(w,\\mathbf{1})(\\tilde{add}_{i+1,i+1}(g,x,y)(\\dot{V}_{i,i+1}^{\\prime}(x)+\\dot{V}_{i,i+1}(y_{1},\\ldots,y_{s_{i,i+1}}))</span> <span class="math">+y_{s_{i,i+2}+1}\\cdot\\ldots\\cdot y_{s_{i,i+1}}\\tilde{add}_{i+1,i+2}(g,x,y_{1},\\ldots,y_{s_{i,i+2}})(\\dot{V}_{i,i+1}^{\\prime}(x)+\\dot{V}_{i,i+2}(y_{1},\\ldots,y_{s_{i,i+2}}))</span> <span class="math">+\\ldots+y_{s_{i,d}+1}\\cdot\\ldots\\cdot y_{s_{i,i+1}}\\tilde{add}_{i+1,d}(g,x,y_{1},\\ldots,y_{s_{i,d}})(\\dot{V}_{i,i+1}^{\\prime}(x)+\\dot{V}_{i,d}(y_{1},\\ldots,y_{s_{i,d}}))</span> <span class="math">+\\tilde{mult}_{i+1,i+1}(g,x,y)(\\dot{V}_{i,i+1}^{\\prime}(x)\\dot{V}_{i,i+1}(y_{1},\\ldots,y_{s_{i,i+1}}))</span> <span class="math">+y_{s_{i,i+2}+1}\\cdot\\ldots\\cdot y_{s_{i,i+1}}\\tilde{mult}_{i+1,i+2}(g,x,y_{1},\\ldots,y_{s_{i,i+2}})(\\dot{V}_{i,i+1}^{\\prime}(x)\\dot{V}_{i,i+2}(y_{1},\\ldots,y_{s_{i,i+2}}))</span> <span class="math">+\\ldots+y_{s_{i,d}+1}\\cdot\\ldots\\cdot y_{s_{i,i+1}}\\tilde{mult}_{i+1,d}(g,x,y_{1},\\ldots,y_{s_{i,d}})(\\dot{V}_{i,i+1}^{\\prime}(x)\\dot{V}_{i,d}(y_{1},\\ldots,y_{s_{i,d}}))</span> <span class="math">+\\tilde{\\beta}((x,y),\\mathbf{1})Z_{i}(g)R_{i}(g_{1},w)]</span> (13)</p>

    <p class="text-gray-300">The equation holds because <span class="math">\\dot{V}_{j,i}</span> agrees with <span class="math">\\tilde{V}_{j,i}</span> on the Boolean hypercube <span class="math">\\{0,1\\}^{s_{i,j}}</span>, as <span class="math">Z_{j,i}(z)=0</span> for binary inputs.</p>

    <p class="text-gray-300">Now <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> instead execute the zero knowledge sumcheck protocol on Equation 13. At the end of the protocol, <span class="math">\\mathcal{V}</span> receives <span class="math">\\dot{V}_{i,i+1}(r^{(i,i+1)^{\\prime}}),\\dot{V}_{i,i+1}(r^{(i,i+1)}),\\ldots,</span> <span class="math">\\dot{V}_{i,d}(r^{(i,d)})</span> for random points <span class="math">r^{(i,i+1)^{\\prime}},r^{(i,i+1)},\\ldots,r^{(i,d)}</span> chosen by <span class="math">\\mathcal{V}</span>. They no longer leak information about <span class="math">V_{i,i+1},\\ldots,V_{i,d}</span>. <span class="math">\\mathcal{V}</span> then evaluates <span class="math">\\tilde{mult}_{i,j}</span> and <span class="math">\\tilde{add}_{i,j}</span> on the randomness as before, computes <span class="math">Z_{i}(g),\\tilde{\\beta}(c,1),\\tilde{\\beta}((r^{(i,i+1)^{\\prime}},r^{(i,i+1)}),\\mathbf{1})</span> where <span class="math">c\\in\\mathbb{F}</span> is a random point chosen by <span class="math">\\mathcal{V}</span> for the variable <span class="math">w</span>. <span class="math">\\mathcal{V}</span> also opens <span class="math">R_{i}(g_{1},w)</span> at point <span class="math">c</span> with <span class="math">\\mathcal{P}</span> using zkPC, and checks that together with the points received</p>

    <p class="text-gray-300">from <span class="math">\\mathcal{P}</span>, they are consistent with the last message of the sumcheck, i.e., the oracle access to the evaluation of the polynomial in the zero knowledge sumcheck. <span class="math">\\mathcal{V}</span> then uses these values to proceed to the second step of combining multiple evaluations, i.e., step 3(a) in Protocol 3. We have the following theorem.</p>

    <p class="text-gray-300"><strong>Theorem 5.</strong> For every verifier <span class="math">\\mathcal{V}^<em></span>, there exists a simulator <span class="math">\\mathcal{S}</span> such that given oracle access to <span class="math">\\hat{V}_i(g)</span> and <span class="math">\\hat{V}_{i,i+1}(r^{(i,i+1)&#x27;})</span>, <span class="math">\\hat{V}_{i,i+1}(r^{(i,i+1)}), \\ldots, \\hat{V}_{i,d}(r^{(i,d)})</span>, <span class="math">\\mathcal{S}</span> is able to simulate the partial view of <span class="math">\\mathcal{V}^</em></span> in the zero knowledge sumcheck protocol on Equation 13.</p>

    <p class="text-gray-300"><strong>Proof sketch.</strong> The completeness and the soundness inherits from the zero knowledge sumcheck protocol and zkPC. For zero knowledge, we combine the simulator <span class="math">\\mathcal{S}_1</span> in zkPC and the simulator <span class="math">\\mathcal{S}_2</span> in the zero knowledge sumcheck protocol to construct the simulator <span class="math">\\mathcal{S}</span>. Therefore, <span class="math">\\mathcal{V}</span> only learns <span class="math">\\hat{V}_{i,i+1}(r^{(i,i+1)&#x27;})</span>, <span class="math">\\hat{V}_{i,i+1}(r^{(i,i+1)}), \\ldots, \\hat{V}_{i,d}(r^{(i,d)})</span> at the end of the protocol, which leaks no information about <span class="math">\\tilde{V}_{i,i+1}, \\dots, \\tilde{V}_{i,d}</span> because of mask polynomials of <span class="math">R_{i,i+1}, \\dots, R_{i,d}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Efficiency.</strong> Compared with the plain sumcheck protocol in step 3(a) of Protocol 3, the prover costs extra <span class="math">O(1)</span> time to compute zkPC.Commit and zkPC.Open for <span class="math">R_{i}(g_{1},w)</span> and $O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> compute zkPC.Commit and zkPC.Open for the mask polynomial in Protocol 5. Therefore, the total prover time is still </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. The verifier time is </span>\\min \\{O(d\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ d^2), O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\}<span class="math"> while the proof size is also </span>\\min \\{O(d\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ d^2), O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Combine multiple evaluations in zero knowledge.</strong> With low degree extensions of <span class="math">V_{0,i}, \\ldots, V_{i-1,i}</span> and <span class="math">V_i</span>, we modify Equation 10 to</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} &amp;amp; \\sum_{k=0}^{i-1} \\alpha_{k,i} \\hat{V}_{k,i}(r^{(k,i)}) + \\alpha_{i-1,i}&#x27; \\hat{V}_{i-1,i}(r^{(i-1,i)&#x27;}) \\\\ &amp;amp; = \\sum_{k=0}^{i-1} \\alpha_{k,i} \\left( \\sum_{x \\in \\{0,1\\}^{s_i}} \\tilde{C}_{k,i}(r^{(k,i)}, x) \\hat{V}_i(x) \\right) + \\alpha_{i-1,i}&#x27; \\sum_{x \\in \\{0,1\\}^{s_i}} \\tilde{C}_{i-1,i}(r^{(i-1,i)&#x27;}, x) \\hat{V}_i(x) + \\\\ &amp;amp; \\sum_{k=0}^{i-1} \\alpha_{k,i} Z_{k,i}(r^{(k,i)}) \\sum_{w \\in \\{0,1\\}} R_{k,i}(r_1^{(k,i)}, w) + \\alpha_{i-1,i}&#x27; Z_{i-1,i}(r^{(i-1,i)&#x27;}) \\sum_{w \\in \\{0,1\\}} R_{i-1,i}(r_1^{(i-1,i)&#x27;}, w) \\\\ &amp;amp; = \\sum_{x \\in \\{0,1\\}^{s_i}, w \\in \\{0,1\\}} \\left[ \\tilde{\\beta}(w,1) \\hat{V}_i(x) \\left( \\sum_{k=0}^{i-1} \\alpha_{k,i} \\tilde{C}_{k,i}(r^{(k,i)}, x) + \\alpha_{i-1,i}&#x27; \\tilde{C}_{i-1,i}(r^{(i-1,i)&#x27;}, x) \\right) + \\right. \\\\ &amp;amp; \\left. \\left. \\tilde{\\beta}(\\boldsymbol{x}, \\mathbf{1}) \\left( \\sum_{k=0}^{i-1} \\alpha_{k,i} Z_{k,i}(r^{(k,i)}) R_{j,i}(r_1^{(k,i)}, w) + \\alpha_{i-1,i}&#x27; Z_{i-1,i}(r^{(i-1,i)&#x27;}) R_{i-1,i}(r_1^{(i-1,i)&#x27;}, w) \\right) \\right]. \\end{aligned} \\tag{14}</span></div>

    <p class="text-gray-300">The equation holds because <span class="math">\\hat{V}_i</span> agrees with <span class="math">\\tilde{V}_i</span> on the Boolean hypercube <span class="math">\\{0,1\\}^{s_i}</span>, as <span class="math">Z_i(z) = 0</span> for binary inputs. To execute the second step, the prover commits to mask polynomials of <span class="math">R_{0,i}, \\ldots, R_{i-1,i}</span> using zkPC. <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> then run the zero knowledge sumcheck protocol on Equation 14. At the end of the protocol, the verifier receives evaluations of <span class="math">R_{0,i}(r_1^{(0,i)}, c), \\ldots, R_{i-1,i}(r_1^{(i-1,i)}, c)</span> on a random point <span class="math">c</span> chosen by <span class="math">\\mathcal{V}</span> for the variable <span class="math">w</span>. He opens <span class="math">R_{0,i}(r_1^{(0,i)}, c), \\ldots,</span></p>

    <p class="text-gray-300"><span class="math">R_{i-1,i}(r_{1}^{(i-1,i)},c)</span> using the zkPC. Then <span class="math">\\mathcal{V}</span> evaluates <span class="math">g_{i}(r^{(i)})</span> as before, computes all <span class="math">Z_{k,i}(r^{(k,i)})</span>, <span class="math">Z_{i-1,i}(r^{(i-1,i)^{\\prime}})</span>, <span class="math">\\beta(c,1)</span>, <span class="math">\\beta(r^{(i)},\\mathbf{1})</span>, shaves them off to obtain the evaluation of <span class="math">\\dot{V}_{i}(r^{(i)})</span>. We have the following theorem.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Theorem 6.</h6>

    <p class="text-gray-300">For every verifier <span class="math">\\mathcal{V}^{<em>}</span>, there exists a simulator <span class="math">\\mathcal{S}</span> such that given oracle access to <span class="math">\\dot{V}_{i}(r^{(i)})</span> and <span class="math">\\dot{V}_{0,i}(r^{(0,i)}),\\ldots,\\dot{V}_{i-1,i}(r^{(i-1,i)}),\\dot{V}_{i-1,i}(r^{(i-1,i)^{\\prime}})</span>, <span class="math">\\mathcal{S}</span> is able to simulate the partial view of <span class="math">\\mathcal{V}^{</em>}</span> in the zero knowledge sumcheck protocol on Equation 14.</p>

    <p class="text-gray-300">Proof sketch. The completeness and the soundness inherits from the zero knowledge sumcheck protocol and zkPC. For zero knowledge, we combine the simulator <span class="math">\\mathcal{S}_{1}</span> in zkPC and the simulator <span class="math">\\mathcal{S}_{2}</span> in the zero knowledge sumcheck protocol to construct the simulator <span class="math">\\mathcal{S}</span>. Therefore, <span class="math">\\mathcal{V}</span> only learns <span class="math">\\dot{V}_{i}(r^{(i)})</span> at the end of the protocol, which leaks no information about <span class="math">\\tilde{V}_{i}</span> because of the mask polynomail of <span class="math">R_{i}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Efficiency. Compared with the plain sumcheck protocol in the second step, the prover costs extra <span class="math">O(i)</span> time to compute zkPC.Commit and zkPC.Open for <span class="math">i</span> constant size polynomials of <span class="math">R_{0,i},\\ldots,R_{i-1,i}</span> and $O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> compute zkPC.Commit and zkPC.Open for the mask polynomial in Protocol 5. Therefore, the total prover time is </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+1+\\ldots+d)=O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. The verifier time is </span>\\min\\{O(d\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+d^{2}),O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\}<span class="math"> while the proof size is also </span>\\min\\{O(d\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+d^{2}),O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-42" class="text-xl font-semibold mt-8">C.4 Putting Everything Together</h3>

    <p class="text-gray-300">Combining the zero knowledge variants of step 3(a) and 3(b) in Protocol 3 with the zkPC scheme, we get a zero knowledge argument protocol for general arithmetic circuits.</p>

    <p class="text-gray-300">Proof Sketch of Theorem 3. The correctness and the soundness follow from those of the three building blocks, by Theorem 5, 6 and Definition 5.</p>

    <p class="text-gray-300">To prove zero knowledge, consider a simulator <span class="math">\\mathcal{S}</span> that calls the simulator <span class="math">\\mathcal{S}_{1}</span> of zero knowledge sumcheck given in Theorem 5 for step 1, the simulator <span class="math">\\mathcal{S}_{2}</span> of combining multiply claims to one claim with zero knowledge given in Theorem 6 for step 2 and the simulator <span class="math">\\mathcal{S}_{3}</span> of zkPC in Definition 5 for committing and opening of all hiding polynomials as subroutines. Then <span class="math">\\mathcal{S}</span> can simulate the partial view of every verifier <span class="math">\\mathcal{V}^{*}</span> for any general arithmetic circuit <span class="math">C</span> only given oracle access to <span class="math">x</span>.</p>

    <p class="text-gray-300">The complexity of our zero knowledge argument scheme follows from the efficency of Protocol 5 and the extra complexity of applying zkPC.Commit to the input layer demonstrated in <em>[27]</em>.</p>

    <h2 id="sec-43" class="text-2xl font-bold">Appendix</h2>`;
---

<BaseLayout title="Doubly Efficient Interactive Proofs for General Arithmetic C... (2020/1247)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/1247
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
