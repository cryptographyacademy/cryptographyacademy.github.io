---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2021/930';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Darlin: Recursive Proofs using Marlin';
const AUTHORS_HTML = 'Ulrich Hab&ouml;ck, Alberto Garoffolo, Daniele Di Benedetto';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">This document describes Darlin, a succinct zero-knowledge argument of knowledge based on the Marlin SNARK (Chiesa et al., Eurocrypt 2020) and the \`dlog&#x27; polynomial commitment scheme from Bootle et al. EUROCRYPT 2016.
Darlin addresses recursive proofs by integrating the amortization technique from Halo (IACR eprint 2019/099) for the non-succinct parts of the dlog verifier, and we adapt their strategy for bivariate circuit encoding polynomials to aggregate Marlin&#x27;s inner sumchecks across the nodes the recursive scheme.
We estimate the performance impact of inner sumcheck aggregation by about 30% in a tree-like scheme of in-degree 2, and beyond when applied to linear recursion.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> R1CS &middot; SNARKs &middot; recursive proofs &middot; aggregation schemes</p>
    </section>

      <h3 id="sec-5.3" class="text-xl font-semibold mt-8">5.3 Accumulating the dlog hard parts</h3>

    <p class="text-gray-300">The aggregation strategy for the non-succinct part of the dlog verifier is identical to that in [BCMS20]. The opening proof for the dlog commitment is an inner product argument that uses the folding technique from [BCC+16] to gradually reduce the opening claim on the initial full-length polynomial to one of half the size, until ending up with the opening claim of a single coefficient polynomial. The final committer key  <span class="math">G_f</span>  of the opening proof is a single group element which is the result of a corresponding folding procedure on the full-length committer key of the dlog scheme. It equals the commitment of the succinct reduction polynomial</p>

    <p class="text-gray-300"><span class="math">$h(\\vec{\\xi}, X) = \\prod_{i=0}^{k-1} (1 - \\xi_{k-1-i} \\cdot X^{2^i}), \\tag{26}</span>$</p>

    <p class="text-gray-300">where  <span class="math">k = \\log |H| = n</span>  is the number of reduction steps and  <span class="math">\\vec{\\xi} = (\\xi_i)_{i=0}^{k-1}</span>  their challenges. The dlog accumulator is of the form</p>

    <p class="text-gray-300"><span class="math">$acc_{dlog} = (\\vec{\\xi}, C),</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\vec{\\xi} \\in F^k</span>  and C is from the commitment group, and the corresponding accumulator predicate  <span class="math">\\phi_{dlog}</span>  is satisfied if and only if C is the commitment of  <span class="math">h(\\vec{\\xi}, X)</span> , using blinding randomness zero.</p>

    <p class="text-gray-300">As Protocol 2, the aggregation strategy is regarded as a subprotocol of the complete recursive argument Protocol 4, and for efficiency reasons we reuse the challenge  <span class="math">\\gamma</span>  from the inner sumcheck aggregation. We again restrict to the case of a single previous accumulator.</p>

    <p class="text-gray-300"><strong>Protocol 3</strong> (dlog hard parts aggregation). Suppose that  <span class="math">acc&#x27;_{dlog} = (\\vec{\\xi}&#x27;, [h&#x27;(X)])</span>  is a previous dlog accumulator, with [h'(X)] representing an oracle for  <span class="math">h&#x27;(X) = h(\\vec{\\xi}&#x27;, X)</span> . The following step is part of the complete recursive argument and processed immediately after Protocol 2:</p>

    <p class="text-gray-300">(1) The verifier queries [h'(X)] at for its value v' at  <span class="math">X = \\gamma</span>  from step (2) of Protocol 2.</p>

    <p class="text-gray-300">If  <span class="math">v&#x27; = h(\\vec{\\xi}&#x27;, \\gamma)</span>  then the verifier accepts. The new accumulator  <span class="math">acc&#x27;&#x27;_{dlog} = (\\vec{\\xi}&#x27;&#x27;, C&#x27;&#x27;)</span>  is the one from the dlog opening proof at the end of the complete protocol.</p>

      <h3 id="sec-5.4" class="text-xl font-semibold mt-8">5.4 The main recursive argument</h3>

    <p class="text-gray-300">The complete recursive argument is a composition of Coboundary Marlin's outer sumcheck for the 'current' circuit, choosing 'zero-knowledge bound' b = 1, the aggregation rounds from the cross-circuit variant of Protocol 2, and Protocol 3. As in Section 5.2 we assume that the bivariate circuit polynomials  <span class="math">A_i(X,Y)</span> ,  <span class="math">B_i(X,Y)</span> ,  <span class="math">C_i(X,Y)</span>  are over the same domain  <span class="math">H \\times H</span> , where |H| = n.</p>

    <p class="text-gray-300">The query phases of these subprotocols are gathered at the end of the protocol, which is then concluded by the batch evaluation argument from [BDFG20].</p>

    <p class="text-gray-300">We formulate the complete argument with oracles for polynomials replaced by their dlog commitments, while keeping with the same notation [p(X)]. For simplicity, we again restrict to the case of a single previous accumulator. The general case is straight-forward.</p>

    <p class="text-gray-300"><strong>Protocol 4</strong> (Complete recursive argument). Given a composed accumulator  <span class="math">acc&#x27; = (acc&#x27;_{\\mathcal{C}}, acc&#x27;_{dlog})</span> , where  <span class="math">acc_{\\mathcal{C}} = (\\alpha&#x27;, H&#x27;, C&#x27;_{T})</span>  is a cross-circuit accumulator for the collection  <span class="math">\\mathcal{C} = \\{\\mathcal{C}_1, \\ldots, \\mathcal{C}_L\\}</span>  and  <span class="math">acc&#x27;_{dlog} = (\\vec{\\xi}, C&#x27;)</span>  is a dlog accumulator. The recursive argument for an instance (x, w) of the 'current' circuit  <span class="math">\\mathcal{C}_k</span>  from  <span class="math">\\mathcal{C}</span>  is composed by the following steps.</p>

    <p class="text-gray-300">(1) Intitialization for  <span class="math">C_k</span> : The prover computes the gauged witness polynomial w(X),  <span class="math">z_A(X)</span> , and  <span class="math">z_B(X)</span>  from  <span class="math">F[X]/(X^n - 1)</span>  and chooses random representants</p>

    <p class="text-gray-300"><span class="math">$\\hat{w}(X), \\hat{z}_A(X), \\hat{z}_B(X) \\in F^{&lt; n+1}[X]</span>$</p>

    <p class="text-gray-300">as described in Section 4. It sends their dlog commitments  <span class="math">[\\hat{w}(X)]</span> ,  <span class="math">[\\hat{z}_A(X)]</span> , and  <span class="math">[\\hat{z}_B(X)]</span>  to the verifier, who responds with  <span class="math">\\eta, \\alpha \\leftarrow sF</span> .</p>

    <p class="text-gray-300">(2) Outer sumcheck for  <span class="math">C_k</span> : The prover computes</p>

    <p class="text-gray-300"><span class="math">$T_{\\vec{\\eta}}(\\alpha, X) = \\eta_A \\cdot A(\\alpha, X) + \\eta_B \\cdot B(\\alpha, X) + \\eta_C \\cdot C(\\alpha, X) \\in F[Y]/(X^n - 1)</span>$</p>

    <p class="text-gray-300">of the current circuit, using  <span class="math">\\vec{\\eta} = (\\eta_A, \\eta_B, \\eta_C) = (1, \\eta, \\eta^2)</span> , and</p>

    <p class="text-gray-300"><span class="math">$\\hat{U}_1(X) \\in F^{&lt; n+2}[Y], h_1(X) \\in F^{&lt; 2 \\cdot n+1}[X]</span>$</p>

    <p class="text-gray-300">subject to the outer sumcheck identity (22). It sends  <span class="math">[T_{\\vec{\\eta}}(\\alpha, X)]</span> ,  <span class="math">[\\hat{U}_1(X)]</span> ,  <span class="math">[h_1(X)]</span>  to the verifier, who returns another random challenge  <span class="math">\\beta \\leftarrow F</span> .</p>

    <p class="text-gray-300">(3) Inner sumcheck aggregation, Step 1: The prover computes the 'bridging' polynomials for</p>

    <p class="text-gray-300"><span class="math">$T_{\\vec{\\eta}}(X,\\beta), T_{H&#x27;}(X,\\beta) \\in F[X]/(X^n-1),</span>$</p>

    <p class="text-gray-300">and sends  <span class="math">[T_{\\vec{\\eta}}(X,\\beta)], [T_{H&#x27;}(X,\\beta)]</span>  to the verifier, who answers with another random  <span class="math">\\lambda, \\gamma \\leftarrow F</span> .</p>

    <p class="text-gray-300">(4) Inner sumcheck aggregation, Step 2: The prover computes the cross-circuit linear combination</p>

    <p class="text-gray-300"><span class="math">$T_{H&#x27;&#x27;}(\\gamma,Y) = T_{\\vec{\\eta}}(\\gamma,Y) + \\lambda \\cdot T_{H&#x27;}(\\gamma,Y) \\in F[Y]/(Y^n-1),</span>$</p>

    <p class="text-gray-300">and  <span class="math">[T_{H&#x27;&#x27;}(\\gamma, Y)]</span>  to the verifier.</p>

    <p class="text-gray-300">After these steps, both prover and verifier engage in the batch evaluation argument from [BDFG20] for the dlog commitment scheme, applied to the queries as listed below. If the queried values pass the checks of the outer sumcheck, Protocol 2 and Protocol 3, and if  <span class="math">(acc&#x27;_{\\mathcal{C}}, acc&#x27;_{dlog})</span>  match with the public input x of the circuit, then the verifier accepts. The new accumulator is  <span class="math">acc&#x27;&#x27; = (acc&#x27;&#x27;_{\\mathcal{C}}, acc&#x27;&#x27;_{dlog})</span>  with<sup>7</sup></p>

    <p class="text-gray-300"><span class="math">$acc_{\\mathcal{C}}^{&quot;} = (\\gamma, H^{&quot;}, C^{&quot;}) = (\\gamma, \\vec{\\eta} \\cdot \\delta_k + \\lambda \\cdot H^{\\prime}, [T_{H^{&quot;}}(\\gamma, Y)]),</span>$</p>

    <p class="text-gray-300">and  <span class="math">acc&#x27;&#x27;_{dlog} = (\\vec{\\xi}, G_f)</span>  from the above batch evaluation proof.</p>

    <p class="text-gray-300">The multi-point queries to be proven by the batch evaluation argument are as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">[\\hat{w}(X)], [\\hat{z}_A(X)], [\\hat{z}_B(X)], [\\hat{U}_1(X)], [h_1(X)], [T_{\\bar{\\eta}}(\\alpha, X)]</span>  at  <span class="math">\\beta</span> , as well as  <span class="math">[\\hat{U}_1(X)]</span>  at  <span class="math">g \\cdot \\beta</span> ,</li>
      <li><span class="math">[T_{\\vec{\\eta}}(X,\\beta)]</span>  at  <span class="math">\\alpha</span> ,  <span class="math">[T_{H&#x27;}(X,\\beta)]</span>  at  <span class="math">\\alpha&#x27;</span> , and  <span class="math">[T_{H&#x27;&#x27;}(\\gamma,Y)]</span> ,  <span class="math">C&#x27;_T</span>  from  <span class="math">acc&#x27;_C</span>  at  <span class="math">\\beta</span> ,</li>
      <li><span class="math">[T_{\\vec{\\eta}}(X,\\beta)] + \\lambda \\cdot [T_{H&#x27;}(X,\\beta)]</span>  at  <span class="math">\\gamma</span> , and C' from  <span class="math">acc&#x27;_{dlog}</span>  at  <span class="math">\\gamma</span> .</li>
    </ul>

    <p class="text-gray-300">For the sake of completeness we summarize the batch evaluation argument in Section A.8.</p>

    <p class="text-gray-300">The following theorem states that the main recursive argument, i.e. Protocol 4 extended by the predicate check on  <span class="math">acc_{\\mathcal{C}}&#x27;&#x27;</span> , is a zero-knowledge argument of knowledge. We point out that we use the Halevi-Micali [HM98] notion of proof of knowledge for negligible soundness error, see Definition 4 and Defintion 5.</p>

    <p class="text-gray-300"><strong>Theorem 2.</strong> If the dlog commitment scheme is computationally binding (Definition 8) then Protocol 4, extended by the predicate verification on the resulting inner sumcheck accumulator  <span class="math">acc_{\\mathcal{C}}&#x27;&#x27;</span> , is a perfectly honest verifier zero-knowledge (Definition 6) argument of knowledge (Definition 5) for the relation</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{R} = \\left\\{ ((\\mathcal{C}, acc&#x27;_{\\mathcal{C}}, acc&#x27;_{dlog}, x), w) : (x, w) \\in R_{\\mathcal{C}_k} \\land \\phi(acc&#x27;_{\\mathcal{C}}) = 1 \\right.</span>$
<span class="math">$\\land \\phi_{dlog}(acc&#x27;_{dlog}) = 1 \\land (acc&#x27;_{\\mathcal{C}}, acc&#x27;_{dlog}) \\text{ is consistent with } x \\right\\},</span>$</p>

    <p class="text-gray-300">where  <span class="math">C = \\{C_1, \\ldots, C_L\\}</span>  is a collection of rank-one constraint systems. Here,  <span class="math">R_{C_k}</span>  denotes the R1CS relation given by the circuit  <span class="math">C_k</span> , and  <span class="math">\\phi</span>  and  <span class="math">\\phi_{dlog}</span>  are as in Section 5.2 and Section 5.3</p>

    <p class="text-gray-300">The proof of Theorem 2 is given in Section A.4. In practice we use the Fiat-Shamir transform to turn Protocol 4 into a non-interactive argument of knowledge which is zero-knowledge against arbitrary polynomial time adversaries.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;7</sup>Here,  <span class="math">\\vec{\\eta} \\cdot \\delta_k</span>  denotes the vector which is  <span class="math">\\vec{\\eta}</span>  at the position of the current circuit  <span class="math">C_k</span>  in the cross-circuit accumulator, and zero elsewhere.</p>

      <h3 id="sec-5.5" class="text-xl font-semibold mt-8">5.5 A note on performance</h3>

    <p class="text-gray-300">Inner sumcheck aggregation is particularly effective when the number of previous accumulators is low, as seen from the operations counts in Table 3. For a single previous accumulator ( <span class="math">\\ell=1</span> ) representing the case of linear recursion, the prover effort for the recursive argument is comparable to that of standard Marlin for a circuit of R1CS density d=1. Having  <span class="math">\\ell=4</span>  previous accumulators, as in our Darlin PCD scheme, the equivalent density is about d=1.5.</p>

    <p class="text-gray-300">Table 3: Recursion prover with and without inner sumcheck aggregation in terms of FFT operations and multi-scalar multiplications, for in-degree  <span class="math">\\ell</span>  (without opening proof).</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">polynomial arith.</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">commit</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">intial round</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3  FFT(n)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3 MSM(n)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">outer sumcheck</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">$ \\begin{array}{c} 2 \\text{ FFT}(n) + 2 \\text{ FFT}(2n) \\ +3 \\text{ FFT}(3n) \\end{array} $</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 MSM(n) + 1 MSM(2n)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">aggregation rounds</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(4+\\ell) \\ FFT(n)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(2+\\ell) MSM(n)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">overall</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\approx (15 + \\ell) \\cdot FFT(n)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\approx (9 + \\ell) MSM(n)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">without aggregation</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\approx (15 + 5 \\cdot d) \\text{ FFT}(n)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\approx (7 + 4 \\cdot d) MSM(n)</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Compared to a standard Marlin prover for circuits with density d=2 the performance improvement is estimated at 27%, as indicated by our estimates from Table 1 in Section 1. The timing estimates from this table are based on a detailed simulation of a Darlin prover (in terms of MSM, FFT, vector and vector-matrix operations), run on an Amazon EC2 G4dn instance (with 4 Intel Xeon@2.5 GHz and 1 NVIDIA T4) currently offered at a rate of 0.526 USD per hour. The number of constraints for verifying two previous proofs stem from detailed paper-and-pencil counts, where our circuit design follows the 'deferred arithmetics' technique from [BGH19], which postpones non-native arithmetic checks to the 'next' circuit in recursion, in which these operations are again native. (We moreover apply their endomorphism-based scalar multiplication which reduces the number of constraints significantly.) We vary over different segment sizes for the dlog commitment scheme (cf. Section A.9 on segmentation of homomorphic polynomial commitment schemes) starting with the smallest possible domain size  <span class="math">|H| = 2^{19}</span>  to cover the two verifier, and then reducing the committer key to  <span class="math">2^{18}</span>  and  <span class="math">2^{17}</span> . Consequently, the prover times decrease at the cost of increasing proof sizes and the number of constraints for the verifier circuit.</p>

    <section id="sec-6" class="mb-10">
      <h2 class="text-2xl font-bold">6 Future work</h2>

    <p class="text-gray-300">We will implement Darlin as the recursive main argument of our upcoming Darlin proof carrying data suite [HB21], using a 2-cycle of ordinary elliptic</p>

    <p class="text-gray-300">curves such as the Pasta curves <a href="#page-21-8">[HBG]</a>. The full suite will cover pure proof merging nodes (for in-degree 1 and 2) as well as special purpose nodes with additional consensus specific logic. Beyond that a separate transformation chain of arguments for converting Darlin proofs into ordinary Marlin proofs will be provided. A formal description, including an in-depth security analysis will be given in <a href="#page-21-11">[HB21]</a>.</p>

    <p class="text-gray-300">The first author is indebted to Maus and Bowie for their appreciated feedback. Without them, the main recursive argument would miss its most important feature, the whisker feedback loop in the cross-meal aggregation of fish, chicken and beef. One of the first readers is also grateful to Peperita, that helped moving away from pairings in exchange for tasty kibble.</p>

    <h3 id="sec-misc-1" class="text-xl font-semibold mt-8">Bibliography</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">[BBB<sup>+</sup> 18] Benedikt B&uuml;nz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Greg Maxwell. Bulletproofs: Short proofs for confidential transactions and more. In in IEEE Symposium on Security and Privacy, pages 315&ndash;334, 2018.</p></li>
      <li><p class="text-gray-300">[BBCGI19] Dan Boneh, Elette Boyle, Henry Corrigan-Gibbs, and Yuval Ishai. Zero-knowledge proofs on secret-shared data via fully linear pcps. In CRYPTO 2019, volume 11694 of LNCS, pages 67&ndash;97. Springer, 2019. full version:<a href="https://eprint.iacr.org/2019/188.pdf" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2019/188.pdf</a>.</p></li>
      <li><p class="text-gray-300">[BCC<sup>+</sup> 16] Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe Petit. Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In M. Fischlin and J.S. Coron, editors, EUROCRYPT 2016, volume 9666 of LNCS. Springer, 2016. Full version: <a href="https://eprint.iacr.org/2016/263" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2016/</a> <a href="https://eprint.iacr.org/2016/263" target="_blank" rel="noopener noreferrer">263</a>.</p></li>
      <li><p class="text-gray-300">[BCCT13] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. Recursive composition and bootstrapping for SNARKs and proofcarrying data. In STOC'13, 2013.</p></li>
      <li><p class="text-gray-300">[BCL<sup>+</sup> 20] Benedikt B&uuml;nz, Alessandro Chiesa, William Lin, Pratyush Mishra, and Nicholas Spooner. Proof-carrying data without succinct arguments. In IACR preprint archive 2020/1618, 2020. <a href="https://eprint.iacr.org/2020/1618" target="_blank" rel="noopener noreferrer">https:</a> <a href="https://eprint.iacr.org/2020/1618" target="_blank" rel="noopener noreferrer">//eprint.iacr.org/2020/1618</a>.</p></li>
      <li><p class="text-gray-300">[BCMS20] Benedikt B&uuml;nz, Alessandro Chiesa, Pratyush Mishra, and Nicholas Spooner. Proof-carrying data from accumulation schemes. In IACR preprint archive 2020/499, 2020. <a href="https://eprint.iacr.org/2020/499" target="_blank" rel="noopener noreferrer">https://eprint.iacr.</a> <a href="https://eprint.iacr.org/2020/499" target="_blank" rel="noopener noreferrer">org/2020/499</a>.</p></li>
      <li><p class="text-gray-300">[BDFG20] Dan Boneh, Justin Drake, Ben Fisch, and Ariel Gabizon. Halo Infinite: recursive zk-snarks from any additive polynomial commitment scheme. In IACR preprint archive 2020/1536, 2020. <a href="https://eprint.iacr.org/2020/1536" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2020/1536</a>.</p></li>
      <li><p class="text-gray-300">[BGH19] Sean Bowe, Jack Grigg, and Daira Hopwood. Recursive proof composition without a trusted setup. In IACR preprint archive 2019/1021, 2019. <a href="https://eprint.iacr.org/2019/1021" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2019/1021</a>.</p></li>
      <li><p class="text-gray-300">[BLH<sup>+</sup> ] Sean Bowe, Ying Tong Lai, Daira Hopwood, Jack Grigg, and Steven Smith. Halo 2. <a href="https://github.com/zcash/halo2" target="_blank" rel="noopener noreferrer">https://github.com/zcash/halo2</a>.</p></li>
      <li><p class="text-gray-300">[BMRS20] Joseph Bonneau, Izaak Meckler, Vanishree Rao, and Evan Shapiro. Coda: Decentralized cryptocurrency at scale. In IACR preprint archive 2020/352, 2020. <a href="https://eprint.iacr.org/2020/352" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2020/352</a>.</p></li>
      <li><p class="text-gray-300">[BSCR<sup>+</sup> 19] Eli Ben-Sasson, Alessandro Chiesa, Michael Riabzev, Nicholas Spooner, Madars Virza, and Nicholas P. Ward. Aurora: Transparent succinct arguments for R1CS. In Y. Ishai and Vincent Rijmen, editors, EUROCRYPT 2019, volume 11476 of LNCS. Springer, 2019.</p></li>
      <li><p class="text-gray-300">[CCW18] Alessandro Chiesa, Lyn Chua, and Matthew Weidner. On cycles of pairing-friendly elliptic curves. In SIAM Journal on Applied Algebra and Geometry, volume 3(2), 2018.</p></li>
      <li><p class="text-gray-300">[CFF<sup>+</sup> 20] Matteo Campanelli, Antonio Faonio, Dario Fiore, Ana&iuml; s Querol, and H&aacute;drian Rodr&iacute;guez. Lunar: a toolbox for more efficient and updatable zkSNARKs and commit-and-prove extensions. In IACR preprint archive 2020/1069, 2020. <a href="https://eprint.iacr.org/2020/1069" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/</a> <a href="https://eprint.iacr.org/2020/1069" target="_blank" rel="noopener noreferrer">2020/1069</a>.</p></li>
      <li><p class="text-gray-300">[CHM<sup>+</sup> 20] Alessandro Chiesa, Yuncong Hu, Mary Maller, Pratyush Mishra, Noah Vesely, and Nicholas Ward. Marlin: Preprocessing zk-SNARKs with universal and updatable SRS. In EUROCRYPT 2020, volume 12105 of LNCS, 2020.</p></li>
      <li><p class="text-gray-300">[CT10] Alessandro Chiesa and Eran Tromer. Proof-carrying data and hearsay arguments from signature cards. In ICS'10. Tsinghua University Press, 2010.</p></li>
      <li><p class="text-gray-300">[GGPR13] Rosario Gennaro, Craig Gentry, Brian Parno, and Mariana Raykova. Quadratic span programs and succinct NIZKs without PCPs. In Nguyen P.Q., editor, EUROCRYPT 2013, volume 7881 of LNCS. Springer, 2013.</p></li>
      <li><p class="text-gray-300">[GKO20] Alberto Garoffolo, Dmytro Kaidalov, and Roman Oliynykov. Zendoo: a zk-SNARK verifiable cross-chain transfer protocol enabling decoupled and decentralized sidechains. In IACR preprint archive 2020/123, 2020. <a href="https://eprint.iacr.org/2020/123" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2020/123</a>.</p></li>
      <li><p class="text-gray-300">[GKR<sup>+</sup> 21] Lorenzo Grassi, Dmitry Khovratovich, Christian Rechberger, Arnab Roz, and Markus Schofnegger. POSEIDON: A new hash function for zero-knowledge proof systems. In USENIX Security Symposium 2021, 2021.</p></li>
      <li><p class="text-gray-300">[GM17] Jens Groth and Mary Maller. Snarky Signatures: Minimal signatures of knowledge from simulation-extractable snarks. In Shacham H. Katz J., editor, CRYPTO 2017, volume 10402 of LNCS. Springer, 2017.</p></li>
      <li><p class="text-gray-300">[Gro10] Jens Groth. Short pairing-based non-interactive zero-knowledge arguments. In Abe M., editor, ASIACRYPT 2010, volume 6477 of LNCS. Springer, 2010.</p></li>
      <li><p class="text-gray-300">[Gro16] Jens Groth. On the size of pairing-based non-interactive arguments. In M. Fischlin and J.S. Coron, editors, EUROCRYPT 2016, volume 9666 of LNCS. Springer, 2016.</p></li>
      <li><p class="text-gray-300">[GS19] Aurore Guillevic and Shashank Singh. On the alpha value of polynomials in the tower number field sieve algorithm. In <a href="https://hal.inria.fr/hal-02263098" target="_blank" rel="noopener noreferrer">https:</a> <a href="https://hal.inria.fr/hal-02263098" target="_blank" rel="noopener noreferrer">// hal. inria. fr/ hal-02263098</a> , 2019.</p></li>
      <li><p class="text-gray-300">[Gui20] Aurore Guillevic. A note on MNT4 and MNT6 curves: Estimation of STNFS cost. (personal communication), 2020.</p></li>
      <li><p class="text-gray-300">[GWC19] Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru. PLONK: Permutations over Lagrange-bases for oecumenical noninteractive arguments of knowledge. In IACR preprint archive 2019/953, 2019. <a href="https://eprint.iacr.org/2019/953" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2019/953</a>.</p></li>
      <li><p class="text-gray-300">[HB21] Ulrich Hab&ouml;ck and Daniele Di Benedetto. The Darlin proof carrying data protocol suite. in preparation, 2021.</p></li>
      <li><p class="text-gray-300">[HBG] Daira Hopwood, Sean Bowe, and Jack Grigg. The Pasta Curves for Halo 2 and beyond. <a href="https://electriccoin.co/blog/the-pasta-curves-for-halo-2-and-beyond/" target="_blank" rel="noopener noreferrer">https://electriccoin.co/blog/</a> <a href="https://electriccoin.co/blog/the-pasta-curves-for-halo-2-and-beyond/" target="_blank" rel="noopener noreferrer">the-pasta-curves-for-halo-2-and-beyond/</a>.</p></li>
      <li><p class="text-gray-300">[HM98] Shai Halevi and Silvio Micali. More on proofs of knowledge. In IACR preprint archive 1998/015, 1998. Appeared in the THEORY OF CRYPTOGRAPHY LIBRARY and has been included in the ePrint Archive. <a href="https://eprint.iacr.org/1998/015" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/1998/015</a>.</p></li>
      <li><p class="text-gray-300">[MBKM19] Mary Maller, Sean Bowe, Markulf Kohlweiss, and Sarah Meiklejohn. Sonic: Zero-knowledge SNARKs from linear-size universal and updatable structured reference strings. In ACM SIGSAC Conference on Computer and Communication Security, pages 2111&ndash; 2128, 2019.</p></li>
      <li><p class="text-gray-300">[Ol] O1-labs. Mina Protocol. <a href="https://minaprotocol.com" target="_blank" rel="noopener noreferrer">https://minaprotocol.com</a>.</p></li>
      <li><p class="text-gray-300">[PHGR13] Bryan Parno, Jon Howell, Craig Gentry, and Mariana Raykova. Pinocchio: Nearly practical verifiable computation. In <em>in IEEE Symposium on Security and Privacy</em>, pages 238&ndash;252, 2013.</p></li>
      <li><p class="text-gray-300">[SS11] Joseph H. Silverman and Katherine E. Stange. Amicable pairs and aliquot cycles for elliptic curves. In <em>Experimental Mathematics</em>, volume 20(3), 2011.</p></li>
      <li><p class="text-gray-300">[WTS+18] R. S. Wahby, I. Tzialla, A. Shelat, J. Thaler, and M. Walfish. Doubly-efficient zk-SNARKs without trusted setup. In 2018 IEEE Symposium on Security and Privacy (SP), pages 926&ndash;943, 2018.</p></li>
    </ul>

    </section>

    <section id="app-a" class="mb-10">
      <h2 class="text-2xl font-bold">A Appendix</h2>

      <h3 id="app-a.1" class="text-xl font-semibold mt-8">A.1 Notation</h3>

    <p class="text-gray-300">We denote the security parameter by  <span class="math">\\lambda</span> , where we throughout consider it in unary representation. A function  <span class="math">f(\\lambda)</span>  is negligible if for every polynomial  <span class="math">p(\\lambda)</span> , it holds that  <span class="math">\\lim_{\\lambda\\to\\infty} f(\\lambda) \\cdot p(\\lambda) = 0</span> , or in short  <span class="math">f(\\lambda) = o(1/p(\\lambda))</span> .</p>

    <p class="text-gray-300">Probabilistic algorithms are denoted by capital letters A, B, etc., and we write  <span class="math">y \\leftarrow A(x)</span>  if an algorithm A ouputs a string y given an input string x while using some internal random coins x uniformly sampled from  <span class="math">\\{0,1\\}^*</span> . Whenever we need to refer to the used random coins x, we shall explicitly write y = A(x; r). We say that A is probabilistic polynomial time (p.p.t.), if its run time  <span class="math">T_{x,r}</span>  on input x and internal random coins x is bounded by some fixed polynomial p(|x|) independent of the random coins, where |x| denotes the length of its input. We say that A is expected polynomial time if the expected run time  <span class="math">E(T_{x,r})</span> , where the expectation is taken over all random coins x, is bounded by some polynomial in the length of the input. The interaction of two interactive probabilistic algorithms A and B is denoted (A, B), where we explicitly clarify what are the inputs and outputs of both algorithms.</p>

      <h3 id="app-a.2" class="text-xl font-semibold mt-8">A.2 Interactive arguments</h3>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{R}</span>  be a polynomial time decidable binary relation. An interactive argument system for  <span class="math">\\mathcal{R}</span>  consists of three probabilistic polynomial time algorithms</p>

    <p class="text-gray-300">(Setup, Prove, Vf).</p>

    <p class="text-gray-300">Given the security parameter  <span class="math">\\lambda</span>  in unary representation,  <span class="math">\\mathsf{Setup}(\\lambda)</span>  outputs a common reference string crs which supports all statement-witness pairs (x, w) up to a certain maximum length  <span class="math">N = N(\\lambda)</span> , which we write in short  <span class="math">(x, w) \\in \\mathcal{R}_N</span> . Given  <span class="math">(x, w) \\in \\mathcal{R}_N</span> , the algorithms Prove and Vf are used to interactively reason about whether x belongs to the language defined by  <span class="math">\\mathcal{R}</span>  or not. We denote their interaction by  <span class="math">tr \\leftarrow \\langle \\mathsf{Prove}(x, w), \\mathsf{Vf}(x) \\rangle</span>  with tr as the transcript</p>

    <p class="text-gray-300">of the interaction, and we assume that both algorithms have access to the crs without explicitly declaring them as inputs. After at most polynomially many steps the verifier accepts or rejects, and we say that tr is accepting or rejecting.</p>

    <p class="text-gray-300"><strong>Definition 3</strong> (Perfect completeness). An interactive argument system (Setup, Prove, Vf) satisfies <em>perfect completeness</em> if</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[ \\begin{array}{l} \\langle \\mathsf{Prove}(x,w), \\mathsf{Vf}(x) \\rangle \\middle| \\begin{array}{l} \\mathit{crs} \\leftarrow \\mathsf{Setup}(\\lambda), \\\\ (x,w) \\leftarrow \\mathcal{A}(\\lambda), \\text{ with } \\\\ (x,w) \\in \\mathcal{R}_N \\end{array} \\right] = 1.</span>$</p>

    <p class="text-gray-300">We define knowledge-soundness in the style of [HM98]. However we do not dwell on the structure or the message distribution of the blackbox extractor. The reason for this choice of definition is the modularity of our proof of Theorem 2, which refers to the security result on the batch evaluation argument from [BDFG20].</p>

    <p class="text-gray-300"><strong>Definition 4</strong> (Knowledge-soundness). An interactive argument system (Setup, Prove, Vf) for the relation  <span class="math">\\mathcal{R}</span>  is <em>knowledge sound</em> if for every x from  <span class="math">\\mathcal{L}_{\\mathcal{R}}</span>  and every adversary  <span class="math">\\mathcal{A}</span>  which makes  <span class="math">\\langle \\mathcal{A}, \\mathsf{Vf}(x) \\rangle</span>  accept with non-negligible probability  <span class="math">\\varepsilon(x) &gt; \\mathsf{negl}(\\lambda)</span> , there is a strict polynomial time algorithm  <span class="math">\\mathcal{E} = \\mathcal{E}^{\\mathcal{A}}</span>  with blackbox access to  <span class="math">\\mathcal{A}</span>  which does at most  <span class="math">\\mathsf{poly}(|x|, \\lambda)/\\mathsf{poly}(\\varepsilon)</span>  calls, and overwhelmingly outputs a witness w such that  <span class="math">(x, w) \\in \\mathcal{R}</span> .</p>

    <p class="text-gray-300"><strong>Definition 5.</strong> We say that an interactive argument system (Setup, Prove, Vf) is an <em>argument of knowledge</em>, if it is perfectly complete and knowledge sound as defined above. It is said to be <em>succinct</em>, if the size of the transcript is sublinear in the size of  <span class="math">(x, w) \\in \\mathcal{R}</span> .</p>

    <p class="text-gray-300">As we do not require any trust assumptions for the setup, our definition of zero-knowledge does not make use of trapdoors.</p>

    <p class="text-gray-300"><strong>Definition 6</strong> (Perfect honest verifier zero-knowledge). An interactive argument system (Setup, Prove, Vf) is <em>perfect honest verifier zero-knowledge</em> if there is a p.p.t. algorithm Sim such that for every p.p.t. algorithm  <span class="math">\\mathcal{A}</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr \\begin{bmatrix} (x,w) \\in \\mathcal{R}_N &amp; crs \\leftarrow \\mathsf{Setup}(\\lambda), \\\\ \\wedge &amp; (x,w) \\leftarrow \\mathcal{A}(crs), \\\\ A(tr&#x27;) = 1 &amp; tr&#x27; \\leftarrow \\mathsf{Sim}(crs,x) \\end{bmatrix}</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\Pr \\begin{bmatrix} (x,w) \\in \\mathcal{R}_N &amp; crs \\leftarrow \\mathsf{Setup}(\\lambda), \\\\ \\wedge &amp; (x,w) \\leftarrow \\mathcal{A}(crs), \\\\ \\mathcal{A}(tr) = 1 &amp; tr \\leftarrow (\\mathsf{Prove}(x,w), \\mathsf{Vf}(x)) \\end{bmatrix}.</span>$</p>

      <h3 id="app-a.3" class="text-xl font-semibold mt-8">A.3 Forking Lemmas</h3>

    <p class="text-gray-300">We use the forking Lemma from  <span class="math">[BCC^+16]</span>  and we obtain strict polynomial time of the sampling algorithm by truncation. Assume that (Setup, Prove, Vf)</p>

    <p class="text-gray-300">is an (2r+1)-move public-coin argument, by which we mean that in each round the verifier messages are chosen uniformly at random from a sample space S. Given a transcript tr resulting from the interaction of  <span class="math">\\mathcal{A}(\\cdot)</span>  with the verifier  <span class="math">\\mathsf{Vf}(crs,x)</span> , we denote by  <span class="math">tr|_{\\leq i}</span> , with  <span class="math">i=0,\\ldots,r</span> , the partial transcript consisting of the prover and verifier messages of the first 2i+1 moves. An  <span class="math">(n_1,\\ldots,n_r)</span> -tree of accepting transcripts is a tree of depth r which is rooted in a prover's first message  <span class="math">tr|_{\\leq 0}</span>  and in which each node at level  <span class="math">i \\in \\{0,\\ldots,r-1\\}</span>  represents a partial transcript  <span class="math">tr|_{\\leq i-1}</span>  and has exactly  <span class="math">n_i</span>  children nodes extending this transcript. The tree has overall  <span class="math">K(\\lambda) = \\prod_{i=1}^r n_i</span>  leafs standing for complete transcripts in which the verifier eventually accepts. We assume that the size of S grows superpolynomially in  <span class="math">\\lambda</span> , so that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[x_1 \\neq x_2 | x_1, x_2 \\leftarrow S] &gt; 1 - \\mathsf{negl}(\\lambda).</span>$</p>

    <p class="text-gray-300"><strong>Lemma 2</strong> ([BCC<sup>+</sup>16]). Let (Setup, Prove, Vf) be a (2r+1)-move public-coin interactive proof, and  <span class="math">\\mathcal{A}</span>  a p.p.t. adversary which runs in expected time  <span class="math">t_{\\mathcal{A}}</span>  and succeeds  <span class="math">\\langle \\mathcal{A}(\\,\\cdot\\,), \\mathsf{Vf}(crs,x) \\rangle</span>  with non-negligible probability  <span class="math">\\varepsilon = \\varepsilon(x)</span>  on public input x. If  <span class="math">n_1, \\ldots, n_r \\geq 2</span>  are such that  <span class="math">K(\\lambda) = \\prod_{i=1}^r n_i</span>  is polynomially bounded, then there exists a p.p.t. algorithm  <span class="math">\\mathcal{T}</span>  that calls the next message function of  <span class="math">\\mathcal{A}</span>  at most  <span class="math">2 \\cdot K(\\lambda)/\\varepsilon</span>  times and with non-negligible probability  <span class="math">\\varepsilon/2</span>  outputs an  <span class="math">(n_1, \\ldots, n_r)</span> -tree of accepting transcripts in which all pairs of sibling-node challenges  <span class="math">x_1, x_2</span>  are subject to  <span class="math">x_1 \\neq x_2</span> .</p>

    <p class="text-gray-300">For the sake of completeness we shortly sketch the construction of  <span class="math">\\mathcal{T}</span>  as claimed in Lemma 2. The tree finder algorithm  <span class="math">\\mathcal{T}&#x27;</span>  from [BCC<sup>+</sup>16] is a rejection sampler which is allowed to fail at every first completion of  <span class="math">\\langle \\mathcal{A}, \\mathsf{Vf}(crs, x) \\rangle</span>  on a given partial transcript  <span class="math">tr|_{\\leq i}</span> . It succeeds with probability</p>

    <p class="text-gray-300"><span class="math">$p_{tr|\\leq i} = \\Pr[\\mathcal{T}&#x27; \\text{ completes subtree for } tr|_{\\leq i}]</span>$</p>

    <p class="text-gray-300">=  <span class="math">\\Pr[\\langle \\mathcal{A}(.), \\mathsf{Vf}(crs, x) \\rangle \\text{ succeeds on } tr|_{\\leq i}].</span></p>

    <p class="text-gray-300">and runs in expected polynomial time</p>

    <p class="text-gray-300"><span class="math">$\\mathbb{E}[\\# \\text{ of } \\mathcal{A} \\text{ calls given } tr|_{\\leq i}] \\leq n_i \\cdot n_{i+1} \\cdot \\ldots \\cdot n_r.</span>$</p>

    <p class="text-gray-300">Overall  <span class="math">\\mathcal{T}&#x27;</span>  is of expected polynomial time calling  <span class="math">\\mathcal{A}</span>  at most  <span class="math">K(\\lambda)</span>  times on average, and  <span class="math">\\mathcal{T}&#x27;</span>  succeeds in producing a complete  <span class="math">(n_1, ..., n_r)</span> -tree of accepting transcript with probability  <span class="math">\\varepsilon</span> . The probability that such a complete tree of accepting transcripts has collisions (i.e. two sibling challenges coincide) is negligible, see the full version of [BCC<sup>+</sup>16]. Finally limiting the run time of  <span class="math">\\mathcal{T}&#x27;</span>  to  <span class="math">2 \\cdot K(\\lambda)/\\varepsilon</span>  calls of  <span class="math">\\mathcal{A}</span>  (and returning  <span class="math">\\bot</span>  in that case) yields a strict polynomial time algorithm which still succeeds with a probability of at least  <span class="math">\\varepsilon/2</span> .</p>

    <p class="text-gray-300"><strong>Lemma 3</strong> ([BDFG20]). Let  <span class="math">\\delta</span>  be such that  <span class="math">0 &lt; \\delta \\le \\frac{\\varepsilon^2}{8K(\\lambda)}</span> . Then with probability at least  <span class="math">\\varepsilon/4</span>  the tree finding algorithm  <span class="math">\\mathcal{T}</span>  from Lemma 2 outputs a tree of accepting transcripts with the following property: For every partial transcript  <span class="math">tr|_{\\le i}</span>  of length i in the tree, the conditional success probability for  <span class="math">\\mathcal{A}(.)</span>  continuing the partial transcript  <span class="math">tr|_{\\le i}</span>  is at least  <span class="math">\\delta</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> The tree sampler  <span class="math">\\mathcal{T}</span>  from Lemma 2 tests at most  <span class="math">2 \\cdot K(\\lambda)/\\varepsilon</span>  partial transcripts  <span class="math">tr|_{\\leq i}</span> . Such transcript succeeds with the probability  <span class="math">p_{tr|_{\\leq i}}</span>  as above. Therefore, the probability that one of these  <span class="math">p_{tr|_{\\leq i}}</span>  is smaller than a given  <span class="math">\\delta</span>  is at most  <span class="math">2 \\cdot K(\\lambda)/\\varepsilon \\cdot \\delta</span> . Choosing the latter of at most  <span class="math">\\varepsilon/4</span>  yields the assertion of the lemma.</p>

    <p class="text-gray-300">We note that the factors 1/2 in Lemma 2 and 1/8 in Lemma 3 are arbitrary. Any other choice of these factors  <span class="math">&gt; 1 - 1/\\mathsf{poly}(\\lambda)</span>  is possible.</p>

      <h3 id="app-a.4" class="text-xl font-semibold mt-8">A.4 Proof of Theorem 2</h3>

    <p class="text-gray-300">Theorem 2 is subject to Protocol 4, extended by the verification of the resulting  <span class="math">acc&#x27;&#x27; = (\\gamma, H&#x27;&#x27;, [T_{H&#x27;&#x27;}(\\gamma, Y)])</span> . We refer to this extended protocol as the full protocol. The batch evaluation proof Eval is regarded as a subprotocol, and we use knowledge soundness and honest verifier zero-knowledge of it (Theorem 11 and Theorem 10) to infer the same properties for the full protocol.</p>

    <h2 id="sec-misc-2" class="text-2xl font-bold">Knowledge soundness</h2>

    <p class="text-gray-300">Assume maximum degree for the polynomial commitment scheme is  <span class="math">d = \\mathsf{poly}(\\lambda)</span>  with  <span class="math">d \\ge 2 \\cdot n + b</span> . The proof is divided into two steps. In the first one, we special soundness of the algebraic oracle proof. The second step uses the transcript sampler from Lemma 2 to construct a strict polynomial time extractor from the strict polynomial time extractor of the batch evaluation argument.</p>

    <h4 id="sec-misc-3" class="text-lg font-semibold mt-6">Step 1. Special soundness.</h4>

    <p class="text-gray-300">Consider the protocol as an interactive oracle proof where the oracles are guaranteed having a degree of at most  <span class="math">d = \\text{poly}(\\lambda)</span> . Besides the arithmetic checks on the evaluation claims, the verifier checks the oracle for  <span class="math">T_{H&#x27;&#x27;}(\\gamma, Y)</span>  by reading it in full length<sup>8</sup> and compare it against the polynomial described by H'' as computed in the protocol. We claim that this 'algebraic oracle proof' is  <span class="math">(m_1, m_2, m_3, m_4)</span> -special sound, with</p>

    <p class="text-gray-300"><span class="math">$(m_1, m_2, m_3, m_4, m_5) = (3, n, 2 \\cdot d + 1, 2, d + 1),</span>$</p>

    <p class="text-gray-300">in the following sense: Given an  <span class="math">(m_1, m_2, m_3, m_4, m_5)</span> -tree of accepting transcripts with pairwise distinct verifier challenges for  <span class="math">\\eta \\in F, \\alpha, \\beta \\in F \\setminus H, \\lambda \\in F, \\gamma \\in F</span> , respectively, then</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the polynomial in the oracle from  <span class="math">acc&#x27;_{dlog}</span>  is the claimed reduction polynomial  <span class="math">h(\\vec{\\xi}&#x27;, X)</span> ,</li>
      <li>the oracles intended for  <span class="math">T_{H&#x27;}(\\gamma&#x27;, Y)</span>  and  <span class="math">T_{\\eta}(\\alpha, Y)</span>  in fact carry the correct polynomials, and</li>
    </ul>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^8&lt;/sup&gt;</span> Equivalently, the verifier may query the oracle at d+1 different points and reconstructs the polynomial from the values.</p>

    <p class="text-gray-300">&bull; the polynomial  <span class="math">y(X) = x(X) + (X^{\\ell} - 1) \\cdot \\hat{w}(X) \\mod (X^n - 1)</span>  with  <span class="math">\\hat{w}(X)</span>  from  <span class="math">[\\hat{w}(X)]</span>  satisfies the R1CS identities (10), (11), (12).</p>

    <p class="text-gray-300">This is true for the following reasons:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">m_1 = 3</span>  pairwise distinct  <span class="math">\\eta_1, \\eta_2, \\eta_3 \\in F</span>  are sufficient to derive the R1CS identities (10), (11), (12) from the 'lincheck' identity (19). (The Vandermonde matrix for different choices of  <span class="math">\\eta</span>  is invertible.)</li>
      <li><span class="math">m_2 = n</span>  pairwise distinct  <span class="math">\\alpha_1, \\ldots, \\alpha_n \\in F \\setminus H</span>  allow inverting the reduction of the lincheck identity (19) to the sumcheck identity (1) by means of the Lagrange kernel. (Recall that the sumcheck is obtained from the lincheck by applying  <span class="math">\\langle L_n(X,\\alpha), . \\rangle</span> . By Lemma 5 the inner products for any n different values of  <span class="math">\\alpha</span>  allow to uniquely reconstruct the lincheck polynomial modulo  <span class="math">(X^n 1)</span> .)</li>
      <li><span class="math">m_3 = 2 \\cdot d + 1</span>  pairwise distinct  <span class="math">\\beta_1, \\ldots, \\beta_{2d+1} \\in F \\setminus H</span>  are sufficient to infer the outer sumcheck identity on the full domain F, as well as the identity for the first step of the inner sumcheck aggregation. (The polynomials are of degree at most d.)</li>
      <li><span class="math">m_4 = 2</span>  distinct  <span class="math">\\lambda_1, \\lambda_2 \\in F</span>  allow for reconstructing the component polynomials from their linear combination  <span class="math">T_{\\vec{\\eta}}(X,\\beta) + \\lambda \\cdot T_{H&#x27;}(X,\\beta)</span>  in the second step of the inner sumcheck aggregation. (Again, since the Vandermonde matrix is invertible.)</li>
      <li>and  <span class="math">m_5 = d+1</span>  pairwise distinct  <span class="math">\\gamma_1, \\ldots, \\gamma_{d+1} \\in F</span>  are sufficient to infer both the correctness of the polynomial behind the linear combination  <span class="math">[T_{\\vec{\\eta}}(X,\\beta)] + \\lambda \\cdot [T_{H&#x27;}(X,\\beta)]</span> , and the polynomial behind the oracle in  <span class="math">acc&#x27;_{dlog}</span> . (Again, all polynomials are of degree at most d.)</li>
    </ul>

    <h4 id="sec-misc-4" class="text-lg font-semibold mt-6">Step 2. Extractor.</h4>

    <p class="text-gray-300">Suppose that  <span class="math">\\mathcal{A}</span>  is a probabilistic polynomial time adversary which succeeds the complete verifier with non-negligible probability  <span class="math">\\varepsilon</span>  on given inputs  <span class="math">(\\mathcal{C}, acc&#x27;_{\\mathcal{C}}, acc&#x27;_{dlog}, x)</span> . As  <span class="math">K(\\lambda) = m_1 \\cdot \\ldots \\cdot m_5</span>  is polynomial in  <span class="math">\\lambda</span> , Lemma 2 guarantees a strict polynomial time algorithm  <span class="math">\\mathcal{T}</span>  which calls  <span class="math">\\mathcal{A}</span>  at most  <span class="math">2 \\cdot K(\\lambda)/\\varepsilon = \\text{poly}(\\lambda)</span>  times and succeeds with a non-negligible probability of  <span class="math">\\varepsilon/2</span>  in sampling an  <span class="math">(m_1, m_2, m_3, m_4, m_5)</span> -tree of accepting transcripts as needed for Step 1. Each partial transcript  <span class="math">tr|_{i\\leq 5}</span>  records the messages until and including the sampling of the last verifier challenge  <span class="math">\\gamma</span> , before entering the batch evaluation protocol Eval. By Lemma 3 we may assume that for each of these partial transcripts  <span class="math">tr|_{i\\leq 5}</span> , the probability that  <span class="math">\\mathcal{A}</span>  succeeds on it is at least  <span class="math">\\delta = \\frac{\\varepsilon^2}{8 \\cdot K(\\lambda)} &gt; \\text{negl}(\\lambda)</span> . By knowledge-soundness of the batch evaluation argument Eval, there is a strict polynomial time extractor which calls  <span class="math">\\mathcal{A}</span>  at most  <span class="math">\\text{poly}(\\lambda)/\\text{poly}(\\delta)</span>  times on each of the transcripts  <span class="math">tr|_{i\\leq 5}</span>  and outputs the witness polynomials from  <span class="math">F^{&lt; d+1}[X]</span>  (including commitment randomnesses) for</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">[\\hat{w}(X)], [\\hat{z}_A(X)], [\\hat{z}_B(X)], [\\hat{U}_1(X)], [h_1(X)], [T_{\\vec{n}}(\\alpha, X)],</span></li>
      <li><span class="math">[T_{H&#x27;}(\\alpha&#x27;, X)]</span>  from  <span class="math">acc&#x27;_{\\mathcal{C}}</span> , as well as  <span class="math">[T_{\\vec{n}}(X, \\beta)]</span> ,  <span class="math">[T_{H&#x27;}(X, \\beta)]</span> ,</li>
      <li><span class="math">[T_{\\vec{\\eta}}(X,\\beta)] + \\lambda \\cdot [T_{H&#x27;}(X,\\beta)]</span> , and  <span class="math">[h(\\vec{\\xi}&#x27;,X)]</span>  from  <span class="math">acc&#x27;_{dlog}</span> ,</li>
    </ul>

    <p class="text-gray-300">of each of the  <span class="math">(\\eta, \\alpha, \\beta, \\lambda, \\gamma) = (\\eta_{i_1}, \\alpha_{i_2}, \\beta_{i_3}, \\lambda_{i_4}, \\gamma_{i_5})</span>  in the transcript tree. These polynomials have values which pass all the verifier checks of the protocol. Assuming the dlog commitment is computationally binding, the witness polynomials and commitment randomnesses for  <span class="math">[\\hat{w}(X)], [\\hat{z}_A(X)], [\\hat{z}_B(X)], [\\hat{U}_1(X)], [h_1(X)]</span> , as well as the witness polynomials for the accumulator commitments  <span class="math">[T_{H&#x27;}(X,\\beta)], [h(\\vec{\\xi}&#x27;,X)]</span>  overwhelmingly coincide for all the verifier challenges  <span class="math">(\\eta_{i_1},\\alpha_{i_2},\\beta_{i_3},\\lambda_{i_4},\\gamma_{i_5}),</span>  and for the same reason the polynomials for  <span class="math">[T_{\\bar{\\eta}}(\\alpha,X)]</span>  do not depend on  <span class="math">(\\beta_{i_3},\\lambda_{i_4},\\gamma_{i_5})</span> . Hence if we replace the commitments by these polynomials we obtain an  <span class="math">(m_1,m_2,m_3,m_4,m_5)</span> -tree of accepting transcripts as needed for Step 1 to conclude that  <span class="math">y(X) = x(X) + (X^{\\ell} - 1) \\cdot \\hat{w}(X) \\mod (X^n - 1)</span>  satisfies the R1CS identities for  <span class="math">\\mathcal{C}_k</span> , and both  <span class="math">acc_T&#x27;</span>  and  <span class="math">acc_{dlog}&#x27;</span>  are correct. The overall run-time of the extractor is strictly bounded by  <span class="math">K(\\lambda) \\cdot \\operatorname{poly}(\\lambda)/\\operatorname{poly}(\\delta) = \\operatorname{poly}(\\lambda)/\\operatorname{poly}(\\varepsilon)</span>  and succeeds with a non-negligible probability of at least  <span class="math">\\varepsilon/4</span> . By amplification we obtain the claimed extractor for knowledge-soundness.</p>

    <h4 id="sec-misc-5" class="text-lg font-semibold mt-6">Zero-knowledge</h4>

    <p class="text-gray-300">Perfect honest verifier zero-knowledge of Protocol 4 is an immediate consequence of perfect honest verifier zero-knowledge of the batch evaluation argument (Theorem 11) and the same property for the coboundary outer sumcheck. The latter is obtained from the following auxiliary lemma. The proof of it is straightforward, and we leave it to the reader.</p>

    <p class="text-gray-300"><strong>Lemma 4.</strong> Assume that P follows Protocol 4. Then the conditional distribution of  <span class="math">(v_1, v_2, v_3, v_4, v_5, v_6) = (\\hat{w}(\\beta), \\hat{y}_A(\\beta), \\hat{y}_B(\\beta), \\hat{U}(g \\cdot \\beta), \\hat{U}(\\beta), h(\\beta))</span> , conditional to  <span class="math">(\\eta, \\alpha, \\beta)</span> , is uniform on the relation  <span class="math">\\mathcal{R}_{\\eta, \\alpha, \\beta}</span>  of all  <span class="math">(v_1, v_2, v_3, v_4, v_5, v_6)</span>  satisfying the outer sumcheck equation</p>

    <p class="text-gray-300"><span class="math">$T_{\\eta}(\\alpha,\\beta) \\cdot (x(\\beta) + (\\beta^{\\ell} - 1) \\cdot v_1) - L_n(\\beta,\\alpha) \\cdot (v_2 + \\eta \\cdot v_3 + \\eta^2 \\cdot v_2 \\cdot v_3) - v_4 + v_5 = v_6 \\cdot (\\beta^n - 1).</span>$</p>

    <p class="text-gray-300">Using Lemma 4 the simulator for the outer sumcheck is constructed as follows. Given a consistent previous accumulator  <span class="math">acc&#x27; = (acc&#x27;_{\\mathcal{C}}, acc&#x27;_{dlog})</span>  and any circuit input  <span class="math">x \\in F^{\\ell}</span> , it first samples  <span class="math">\\eta</span>  and  <span class="math">(\\alpha, \\beta)</span>  uniformly from F and  <span class="math">(F \\setminus H)^2</span> , respectively, and  <span class="math">(v_1, v_2, v_3, v_4, v_5, v_6)</span>  uniformly from  <span class="math">\\mathcal{R}_{\\eta,\\alpha,\\beta}</span>  (by choosing  <span class="math">v_1, \\ldots, v_5</span>  uniformly from F and  <span class="math">v_6</span>  as determined by the outer sumcheck equation), and then crafts arbitrary polynomials  <span class="math">\\hat{w}(X)</span> ,  <span class="math">\\hat{y}_A(X)</span> ,  <span class="math">\\hat{y}_B(X)</span> ,  <span class="math">\\hat{U}(X)</span>  and h(X) of degree less than d which evaluate at  <span class="math">X = \\beta</span>  (and  <span class="math">\\hat{U}(X)</span>  also at  <span class="math">X = g \\cdot \\beta</span> ) to the corresponding values. All these polynomials are committed using hiding randomnesses, and the aggregation rounds Step (3) and Step (4) of Protocol 4 are performed as in an honest prover-verifier interaction. Since</p>

    <p class="text-gray-300">the dlog commitment scheme is perfectly hiding, the resulting conversation is identically distributed as in an ordinary honest prover-verifier interaction for Step (1-4). These conversations are completed by calling the simulator for the batch evaluation argument on the collected commitments. Since the latter partial transcripts are identically distributed to an honest prover-verifier interaction, so are the completed conversations.</p>

      <h3 id="app-a.5" class="text-xl font-semibold mt-8">A.5 Proof of Theorem 1</h3>

    <p class="text-gray-300">The proof of Theorem 1 is almost identical to that of Theorem 2, hence we only point out the differences. We assume that the indexer polynomial  <span class="math">row_M(X)</span> ,  <span class="math">col_M(X)</span> ,  <span class="math">row.col_M(X)</span>  and  <span class="math">val.row.col_M(X)</span> , M = A, B, C, as defined in Section 4 are verified against their commitments in a precomputation phase of the protocol.</p>

    <p class="text-gray-300">For knowledge-soundness, observe that Coboundary Marlin viewed as an algebraic oracle proof, is  <span class="math">(m_1, m_2, m_3, m_4)</span> -special sound with</p>

    <p class="text-gray-300"><span class="math">$(m_1, m_2, m_3, m_4) = (3, n, 2 \\cdot d + 1, 4 \\cdot m - 3).</span>$</p>

    <p class="text-gray-300">Here,  <span class="math">d = \\mathsf{poly}(\\lambda)</span>  is the maximum degree of the oracle polynomials, n and m are the sizes of the domains H and K, and  <span class="math">m_1, m_2, m_3, m_4</span>  correspond to the verifier challenges  <span class="math">\\eta \\in F</span> ,  <span class="math">\\alpha, \\beta, \\gamma \\in F \\setminus H</span> , respectively. The reasoning for  <span class="math">m_1, m_2, m_3</span>  is as befor, and  <span class="math">m_2 = 4 \\cdot m - 2</span>  by the degree of the inner sumcheck identity (24). Based on these modified soundness numbers, the strict polynomial time extractor is constructed as in Section A.4 by using the forking lemma (Lemma 2) and the extractor for the batch evaluation argument.</p>

    <p class="text-gray-300">The proof for perfect honest verifier zero-knowledge can be taken over almost verbatim, replacing completing of the simulated transcript for the outer sumcheck by an honest prover-verifier run of the inner sumcheck instead of the aggregation rounds.</p>

      <h3 id="app-a.6" class="text-xl font-semibold mt-8">A.6 Polynomial commitment schemes</h3>

    <p class="text-gray-300">We regard a polynomial commitment scheme consisting of four probabilistic polynomial time algorithms</p>

    <p class="text-gray-300">Given the security parameter  <span class="math">\\lambda</span> ,  <span class="math">(ck, vk) \\leftarrow \\mathsf{Setup}(\\lambda)</span>  generates a common reference string consisting of a committer key ck and a verifier key vk supporting polynomials over some finite field F having degree of at most  <span class="math">N = N(\\lambda)</span> , where N is polynomial in  <span class="math">\\lambda</span> . Given the committer key ck, the commitment of a polynomial p(X) of degree at most N is computed by  <span class="math">C = \\mathsf{Com}(p(X); r)</span> , where r denotes the used random coins. (We again omit ck from the inputs for brevity.)</p>

    <p class="text-gray-300">We regard  <span class="math">(\\mathsf{Setup}, \\mathsf{Prove}, \\mathsf{Vf})</span>  as a succinct interactive argument system for the relation</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{R} = \\{ ((C, x, v), (p(X), r)) : C = \\mathsf{Com}(p(X); r) \\land p(x) = v \\},\\</span>$</p>

    <p class="text-gray-300">and call the polynomial commitment scheme to satisfy completeness, zero-knowledge and witness-extended emulation if the interactive argument system does. We refer to the interaction  <span class="math">(\\mathsf{Open}, \\mathsf{Vf})</span>  as opening proof for the polynomial p(X) at the point  <span class="math">x \\in F</span> .</p>

    <p class="text-gray-300">The security notions <em>computational binding</em> and <em>perfect hiding</em> are as for general non-interactive commitment schemes (Setup, Com). For the sake of brevity, we directly cite them applied to polynomial commitment schemes:</p>

    <p class="text-gray-300"><strong>Definition 7</strong> (Perfect Hiding). We say that a polynomial commitment scheme (Setup, Com, Open, Vf) is <em>perfectly hiding</em> if every polynomial adversary  <span class="math">\\mathcal{A}</span>  has no advantage over pure guessing when distinguishing the commitments of two adversarially chosen polynomials,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\begin{array}{l} b^{\\star} = b \\\\ b^{\\star} = b \\end{array} \\middle| \\begin{array}{l} (ck, vk) \\leftarrow \\mathsf{Setup}(\\lambda), \\\\ \\text{for } i = 1, 2 \\\\ p_i(X) \\leftarrow \\mathcal{A}(ck, vk), \\ \\deg(p_i(X)) \\leq N(\\lambda), \\\\ C_i \\leftarrow \\mathsf{Com}(p_i(X)) \\\\ b \\leftarrow \\</span> \\left{0, 1\\right}, \\ b^{\\star} \\leftarrow \\mathcal{A}(C_b, C_{1-b}) \\end{array} \\right] = \\frac{1}{2}.$$</p>

    <p class="text-gray-300"><strong>Definition 8</strong> (Computational Binding). A polynomial commitment scheme (Setup, Com, Open, Vf) is <em>computationally binding</em> if for every p.p.t. adversary A, the probability to find two different messages  <span class="math">(p_i(X), r_i)</span> , i = 1, 2, having the same commitment is negligible:</p>

    <p class="text-gray-300"><span class="math">$\\Pr \\left[ \\begin{array}{c|c} \\mathsf{Com}(p_1(X); r_1) = \\mathsf{Com}(p_2(X); r_2) \\\\ \\land \\\\ (p_1(X), r_1) \\neq (p_2(X), r_2) \\end{array} \\middle| \\begin{array}{c} (ck, vk) \\leftarrow \\mathsf{Setup}(\\lambda), \\\\ (r_1, p_1(X), r_2, p_2(X)) \\leftarrow \\mathcal{A}(ck, vk) \\end{array} \\right] \\\\ = \\mathsf{negl}(\\lambda).</span>$</p>

    <p class="text-gray-300">We further make use the notion of a homomorphic schemes, again directly applied to polynomial commitment schemes:</p>

    <p class="text-gray-300"><strong>Definition 9</strong> (Homomorphic commitment). A polynomial commitment scheme (Setup, Com, Open, Vf) with commitments in a <em>commitment group</em>  <span class="math">(\\mathcal{G}, +)</span>  is <em>homomorphic</em> (or, <em>linear</em>), if</p>

    <p class="text-gray-300"><span class="math">$Com(p_1(X); r_1) + Com(p_2(X); r_2) = Com(p_1(X) + p_2(X); r_1 + r_2).</span>$</p>

    <p class="text-gray-300">The dlog polynomial commitment scheme from [BCMS20] is an ordinary Pedersen vector commitment. Given the coefficient vector  <span class="math">\\vec{c} = (c_i)_{i=0}^{d-1}</span>  of a polynomial</p>

    <p class="text-gray-300">p(X) from F[X] of degree at most d, its commitment is the Pedersen linear combination</p>

    <p class="text-gray-300"><span class="math">$Com(p(X); r) = r \\cdot S + c_0 \\cdot G_0 + \\ldots + c_{d-1} \\cdot G_{d-1},</span>$</p>

    <p class="text-gray-300">where S and  <span class="math">(G_i)</span>  is the committer key, and the optional hiding randomness r is uniformly drawn from F. As in [BCC<sup>+</sup>16], [BBB<sup>+</sup>18], or [WTS<sup>+</sup>18], the opening proof is an inner product argument, which uses  <span class="math">k = \\log(d)</span>  rounds to gradually reduce the size polynomial in question by one half until ending up with a single-coefficient instance. In the course of the reduction the committer key is repeatedly folded into a final committer key  <span class="math">G_f</span>  for the single-coefficient claim, which depends linearly on the initial committer key by</p>

    <p class="text-gray-300"><span class="math">$G_f = h_0 \\cdot G_0 + \\ldots + h_{d-1} \\cdot G_{d-1},</span>$</p>

    <p class="text-gray-300">where  <span class="math">(h_i)</span>  are the coefficients of the reduction polynomial</p>

    <p class="text-gray-300"><span class="math">$h(\\vec{\\xi}, X) = \\prod_{i=0}^{k-1} (1 - \\xi_{k-1-i} \\cdot X^{2^i}),</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\vec{\\xi} = (\\xi_i)_{i=0}^{k-1}</span>  are the random challenges of the reduction steps. See [BCMS20] for a detailed description.</p>

    <p class="text-gray-300"><strong>Theorem 10</strong> ([BCC<sup>+</sup>16, BCMS20]). Under the assumption that the dlog commitment scheme is computationally binding, the opening argument is an honest verifier zero-knowledge (Definition 6) argument of knowledge (Definition 5).</p>

    <p class="text-gray-300">Zero-knowledge is proven in [BCMS20]. To obtain a strict polynomial time extractor as demanded by Definition 5, one proceeds as in [BCC<sup>+</sup>16] to construct an expected polynomial time extractor with average runtime  <span class="math">\\mu</span>  inverse proportional to the success probability  <span class="math">\\varepsilon</span>  of the adversary. Truncating it to strict polynomial time  <span class="math">2 \\cdot \\mu/\\varepsilon</span>  zields a running time bounded by  <span class="math">poly(\\lambda)/poly(\\varepsilon)</span>  calls of  <span class="math">\\mathcal{A}</span>  and still maintains a success probability of  <span class="math">\\varepsilon/2</span> .</p>

    <p class="text-gray-300">We give an informal description of the protocol from [BDFG20], Section 5.2, for proving a multi-point opening claim</p>

    <p class="text-gray-300"><span class="math">$p_i(x_i) = y_i, \\quad i = 1, ..., m,</span>$</p>

    <p class="text-gray-300">of given polynomials  <span class="math">p_i(X)</span> ,  <span class="math">i=1,\\ldots,m</span> , for a linear commitment scheme (Setup, Com, Open, Vf). The multi-point evaluation claim is equivalent to the following system of algebraic identities over the set  <span class="math">\\Omega = \\{x_1, \\ldots, x_m\\}</span> ,</p>

    <p class="text-gray-300"><span class="math">$p_i(X) \\cdot L_m(x_i, X) - y_i = 0 \\mod z(X), \\quad i = 1, \\dots, m,</span>$</p>

    <p class="text-gray-300">where  <span class="math">L_m(x_i, X)</span>  is the Lagrange polynomial for  <span class="math">\\Omega</span> , and  <span class="math">z(X) = \\prod_{x \\in \\Omega} (X - x)</span>  is the vanishing polynomial of  <span class="math">\\Omega</span> . A more practical system of identities is achieved if we replace the Lagrange polynomials by their non-normalized variant</p>

    <p class="text-gray-300"><span class="math">$z_i(X) = \\frac{z(X)}{X - x_i} = \\prod_{x \\in \\Omega \\setminus \\{x_i\\}} (X - x).</span>$</p>

    <p class="text-gray-300">These m identities are reduced to a single identity over  <span class="math">\\Omega</span>  in the usual manner: The prover receives a random scalar  <span class="math">\\rho \\leftarrow F</span>  from the verifier, and shows the combined identity</p>

    <p class="text-gray-300"><span class="math">$\\sum_{i=1}^{m} \\rho^{i-1} \\cdot (p_i(X) - y_i) \\cdot z_i(X) = 0 \\mod z(X)</span>$</p>

    <p class="text-gray-300">instead. For this, the verifier provides an oracle for the quotient polynomial q(X) in the non-modular identity</p>

    <p class="text-gray-300"><span class="math">$\\sum_{i=1}^{m} \\rho^{i-1} \\cdot (p_i(X) - y_i) \\cdot z_i(X) = q(X) \\cdot z(X),</span>$</p>

    <p class="text-gray-300">which is probed at a fresh random point  <span class="math">x \\leftarrow F</span> . This identity is verified by showing that the linear combination  <span class="math">\\sum_{i=1}^{m} \\rho^{i-1} \\cdot z_i(x) \\cdot p_i(X) - z(x) \\cdot q(X)</span>  opens at x to the expected value  <span class="math">v = \\sum_{i=1}^{m} \\rho^{i-1} \\cdot y_i \\cdot z_i(x)</span> .</p>

    <p class="text-gray-300"><strong>Theorem 11</strong> ([BDFG20], Theorem 6). Assume that the commitment scheme is computationally binding. If the opening argument for the polynomial commitment scheme is a perfect honest verifier zero-knowledge argument of knowledge (Definition 5), then the same holds for the batch evaluation protocol.</p>

      <h3 id="app-a.9" class="text-xl font-semibold mt-8">A.9 Segmentation of linear commitment schemes</h3>

    <p class="text-gray-300">Segmentation of a homomorphic polynomial commitment scheme is a useful technique to improve the computational effort of the prover at the cost of increasing the commitment size<sup>9</sup>. One chooses an undersized committer key  <span class="math">ck = (G_0, \\ldots, G_{s-1})</span> , where the segment size s is typically magnitudes smaller than the targeted maximum degree d, and extends its domain beyond degree s-1 by decomposing a polynomial p(X) into</p>

    <p class="text-gray-300"><span class="math">$p(X) = p_0(X) + X^s \\cdot p_1(X) + \\ldots + X^{(k-1)\\cdot s} \\cdot p_k(X),</span>$</p>

    <p class="text-gray-300">with each  <span class="math">p_i(X)</span> , i = 1,...,k, of degree at most s. (If d is the degree of p(X) then the number k of segment polynomials is equal to  <span class="math">\\lceil (d+1)/s \\rceil</span> .) The commitment of p(X) is then defined as the vector of the commitments of its segment polynomials using ck,</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Com}(p(X)) \\coloneqq (\\mathsf{Com}(p_0(X)), \\dots, \\mathsf{Com}(p_k(X))).</span>$</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;9</sup>We learned this technique from [Ol] but believe that it is commonly known.</p>

    <p class="text-gray-300">Every evaluation claim p(x) = v of the full-size polynomial is translated to the same claim on the linear combination of its segment polynomials,</p>

    <p class="text-gray-300"><span class="math">$LC_x(p_0(X),...,p_k(X)) = p_0(X) + x^s \\cdot p_1(X) + ... + x^{(k-1)\\cdot s} \\cdot p_k(X),</span>$</p>

    <p class="text-gray-300">which is efficiently proven by leveraging the homomorphic property of the scheme.</p>

    <p class="text-gray-300">Let  <span class="math">H = \\{x : x^n - 1 = 0\\}</span>  be an order n subgroup of the multiplicative group of a finite field F. The Lagrange kernel</p>

    <p class="text-gray-300"><span class="math">$L_n(X,Y) = \\frac{1}{n} \\cdot \\left(1 + \\sum_{i=1}^{n-1} X^i \\cdot Y^{n-i}\\right)</span>$</p>

    <p class="text-gray-300">is the unique bivariate symmetric polynomial of individual degree at most n-1, such that for  <span class="math">y \\in H</span>  the function L(X,y) restricted to H equals the Lagrange function  <span class="math">L_y(X)</span> , which evaluates to one at X = y, and zero otherwise. The kernel has the succinct representation</p>

    <p class="text-gray-300"><span class="math">$L_n(X,Y) = \\frac{1}{n} \\cdot \\frac{Y \\cdot Z_H(X) - X \\cdot Z_H(Y)}{X - Y},</span>$</p>

    <p class="text-gray-300">where  <span class="math">Z_H(X) = X^n - 1</span>  is the vanishing polynomial of H. Lagrange kernels represent point evaluation, as characterized by the following simple Lemma.</p>

    <p class="text-gray-300"><strong>Lemma 5.</strong> Suppose that  <span class="math">H \\subset F^*</span>  is a multiplicative subgroup of order n and p(X) is a polynomial of degree  <span class="math">deg(p(X)) \\le n-1</span> . Then for every z in F,</p>

    <p class="text-gray-300"><span class="math">$\\langle L_n(X,z),p(X)\\rangle_H = \\sum_{x\\in H} L_n(z,x)\\cdot p(x) = p(z).</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> Since  <span class="math">p(X) = \\sum_{y \\in H} p(y) \\cdot L_n(X, y)</span> , it suffices to show the claim for  <span class="math">p(X) = L_n(X, y)</span> , with  <span class="math">y \\in H</span> . By the property of  <span class="math">L_n(X, y)</span> , we have  <span class="math">\\langle L_n(X, z), L_n(X, y) \\rangle_H = L_n(y, z)</span> , which by symmetry is equal to  <span class="math">L_n(X, y)</span>  at X = z. This completes the proof of the Lemma.</p>

    <p class="text-gray-300">Marlin [CHM<sup>+</sup>20] uses the generalized derivative</p>

    <p class="text-gray-300"><span class="math">$u_H(X,Y) = \\frac{Z_H(X) - Z_H(Y)}{X - Y}</span>$</p>

    <p class="text-gray-300">instead of  <span class="math">L_n(X,Y)</span>  (again as element from  <span class="math">F[X,Y]/\\langle X^n-1,Y^n-1\\rangle</span> ). For the generalized derivative a similar inner product formula holds: For every  <span class="math">z \\in F</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\langle u_H(X,z), p(X) \\rangle_H = \\langle u_H(X,X) \\cdot L_H(X,z), p(X) \\rangle_H</span>$
<span class="math">$= \\langle L_n(X,z), u_H(X,X) \\cdot p(X) \\rangle_H = p^*(z),</span>$</p>

    <p class="text-gray-300">where  <span class="math">p^*(X) = u_H(X, X) \\cdot p(X) \\mod (X^n - 1)</span> .</p>

    </section>
`;
---

<BaseLayout title="Darlin: Recursive Proofs using Marlin (2021/930)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2021 &middot; eprint 2021/930
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#abstract" class="hover:text-white">Abstract</a></li>
        <li><a href="#sec-1" class="hover:text-white">Introduction</a></li>
        <li><a href="#sec-2" class="hover:text-white">Preliminary notes</a></li>
        <li><a href="#sec-3" class="hover:text-white">A cohomological sumcheck argument</a></li>
        <li>
          <a href="#sec-4" class="hover:text-white">Coboundary Marlin</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-4.1" class="hover:text-white">Arithmetization</a></li>
            <li><a href="#sec-4.2" class="hover:text-white">The protocol</a></li>
            <li><a href="#sec-4.3" class="hover:text-white">A note on performance</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-5" class="hover:text-white">Recursion</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-5.1" class="hover:text-white">Inner sumcheck aggregation</a></li>
            <li><a href="#sec-5.2" class="hover:text-white">Generalization to several circuits</a></li>
            <li><a href="#sec-5.3" class="hover:text-white">Accumulating the dlog hard parts</a></li>
            <li><a href="#sec-5.4" class="hover:text-white">The main recursive argument</a></li>
            <li><a href="#sec-5.5" class="hover:text-white">A note on performance</a></li>
          </ol>
        </li>
        <li><a href="#sec-6" class="hover:text-white">Future work</a></li>
        <li><a href="#sec-7" class="hover:text-white">Acknowledgements</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li>
          <a href="#app-a" class="hover:text-white">Appendix</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-a.1" class="hover:text-white">Notation</a></li>
            <li><a href="#app-a.2" class="hover:text-white">Interactive arguments</a></li>
            <li><a href="#app-a.3" class="hover:text-white">Forking Lemmas</a></li>
            <li><a href="#app-a.4" class="hover:text-white">Proof of Theorem 2</a></li>
            <li><a href="#app-a.5" class="hover:text-white">Proof of Theorem 1</a></li>
            <li><a href="#app-a.6" class="hover:text-white">Polynomial commitment schemes</a></li>
            <li><a href="#app-a.7" class="hover:text-white">The dlog commitment scheme from [BCMS20]</a></li>
            <li><a href="#app-a.8" class="hover:text-white">The batch evaluation protocol from [BDFG20]</a></li>
            <li><a href="#app-a.9" class="hover:text-white">Segmentation of linear commitment schemes</a></li>
            <li><a href="#app-a.10" class="hover:text-white">Facts on the Lagrange kernel</a></li>
          </ol>
        </li>
      </ol>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="darlin-recursive-proofs-using-marlin-2021" />
  </article>
</BaseLayout>
