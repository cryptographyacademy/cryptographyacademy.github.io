---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2021/930';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Darlin: Recursive Proofs using Marlin';
const AUTHORS_HTML = 'Ulrich Haböck, Alberto Garoffolo, Daniele Di Benedetto';

const CONTENT = `    <p class="text-gray-300">Haböck, Ulrich ulrich@horizenlabs.io</p>

    <p class="text-gray-300">Garoffolo, Alberto alberto@horizenlabs.io</p>

    <p class="text-gray-300">Di Benedetto, Daniele daniele@horizenlabs.io</p>

    <p class="text-gray-300">October 1, 2021</p>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">Abstract</h4>

    <p class="text-gray-300">This document<a href="#page-0-0">1</a> describes Darlin, a succinct zero-knowledge argument of knowledge based on the Marlin SNARK <a href="#page-20-0">\\[CHM</a><sup>+</sup> 20] and the 'dlog' polynomial commitment scheme from <a href="#page-19-0">\\[BCC</a><sup>+</sup> 16, <a href="#page-19-1">BBB</a><sup>+</sup> 18]. Darlin addresses recursive proofs by integrating the amortization technique from Halo [\\[BGH19\\]](#page-20-1) for the non-succinct parts of the dlog verifier, and we adapt their strategy for bivariate circuit encoding polynomials to aggregate Marlin's inner sumchecks across the nodes the recursive scheme. We estimate the performance impact of inner sumcheck aggregation by about 30% in a tree-like scheme of in-degree 2, and beyond when applied to linear recursion.</p>

    <h2 id="sec-3" class="text-2xl font-bold">Contents</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Introduction</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">Preliminary notes</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">A cohomological sumcheck argument</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">Coboundary Marlin</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4.1<br>Arithmetization</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4.2<br>The protocol<br></td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4.3<br>A note on performance<br></td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-0-0"></span><sup>1</sup>This paper is the full version of the previously published extended abstract 'Darlin: A proof-carrying data scheme based on Marlin'.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Recursion</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">12</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">5.1</td>

            <td class="px-3 py-2 border-b border-gray-700">Inner sumcheck aggregation<br></td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">5.2</td>

            <td class="px-3 py-2 border-b border-gray-700">Generalization to several circuits<br></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">5.3</td>

            <td class="px-3 py-2 border-b border-gray-700">Accumulating the dlog hard parts</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">5.4</td>

            <td class="px-3 py-2 border-b border-gray-700">The main recursive argument<br></td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">5.5</td>

            <td class="px-3 py-2 border-b border-gray-700">A note on performance<br></td>

            <td class="px-3 py-2 border-b border-gray-700">19</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Future work</td>

            <td class="px-3 py-2 border-b border-gray-700">19</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Acknowledgements</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Bibliography</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Appendix</td>

            <td class="px-3 py-2 border-b border-gray-700">23</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">A.1</td>

            <td class="px-3 py-2 border-b border-gray-700">Notation</td>

            <td class="px-3 py-2 border-b border-gray-700">23</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">A.2</td>

            <td class="px-3 py-2 border-b border-gray-700">Interactive arguments</td>

            <td class="px-3 py-2 border-b border-gray-700">23</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">A.3</td>

            <td class="px-3 py-2 border-b border-gray-700">Forking Lemmas<br></td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">A.4</td>

            <td class="px-3 py-2 border-b border-gray-700">Proof of Theorem 2<br></td>

            <td class="px-3 py-2 border-b border-gray-700">26</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">A.5</td>

            <td class="px-3 py-2 border-b border-gray-700">Proof of Theorem 1<br></td>

            <td class="px-3 py-2 border-b border-gray-700">29</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">A.6</td>

            <td class="px-3 py-2 border-b border-gray-700">Polynomial commitment schemes<br></td>

            <td class="px-3 py-2 border-b border-gray-700">29</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">A.7</td>

            <td class="px-3 py-2 border-b border-gray-700">The dlog commitment scheme from [BCMS20]<br></td>

            <td class="px-3 py-2 border-b border-gray-700">30</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">A.8</td>

            <td class="px-3 py-2 border-b border-gray-700">The batch evaluation protocol from [BDFG20]<br></td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">A.9</td>

            <td class="px-3 py-2 border-b border-gray-700">Segmentation of linear commitment schemes<br></td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">A.10 Facts on the Lagrange kernel</td>

            <td class="px-3 py-2 border-b border-gray-700">33</td>

          </tr>

        </tbody>

      </table>

    </div>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1 Introduction</h3>

    <p class="text-gray-300">Succinct non-interactive arguments of knowledge (SNARKs) are the basis for secure decentralized computations, allowing to verify the correctness of a large number of operations by a single succinct and easy to verify cryptographic proof. Since the advent of SNARKs <a href="#page-21-0">\\[Gro10,</a> [GGPR13\\]](#page-20-3) practical proof systems followed soon after, e.g. Pinocchio [\\[PHGR13\\]](#page-22-3), Groth16 [\\[Gro16\\]](#page-21-1), and Groth17 [\\[GM17\\]](#page-21-2). Whereas the first SNARKs are intrinsically connected to pairings via non-standard knowledge commitments, proof systems from the second wave, such as Sonic [\\[MBKM19\\]](#page-21-3), Aurora <a href="#page-20-4">\\[BSCR</a><sup>+</sup> 19], Marlin <a href="#page-20-0">\\[CHM</a><sup>+</sup> 20], or Plonk [\\[GWC19\\]](#page-21-4), are built in a modular way on any polynomial commitment scheme.</p>

    <p class="text-gray-300">To scale over large amounts of data to be processed, recursive arguments or more generally proof-carrying data (PCD) schemes <a href="#page-20-5">\\[CT10,</a> [BCCT13\\]](#page-19-5), are inevitable. Recursive arguments verify the existence of a previous such, and their performance is largely dependent on how efficient the verifier itself is translated into an argument. The issue of such a translation step is that typically the assertion to be proven is arithmetized (as a relation or circuit) over a field of a different characteristic than the proof itself, and simulating the arithmetics of a 'foreign' field is costly. The most common approach to tackle the problem is using a 2-cycle of elliptic curves <a href="#page-22-4">\\[SS11,</a> [CCW18\\]](#page-20-6). Such cycles are pairs of elliptic curves in which the subgroup of one curve is of the same prime order as the base field of the other. Applied to pairing-based SNARKs the cycle approach requires high field sizes. The only known cycles are based on MNT curves of low embedding degree [\\[CCW18\\]](#page-20-6), and as such they demand field sizes beyond 1, 000 bit to meet a reasonable level of security [\\[GS19\\]](#page-21-5)<a href="#page-2-0">2</a> . Second wave SNARKs are not necessarily bound to pairings, hence allow to use cycles of non pairing-friendly curves <a href="#page-20-1">\\[BGH19,</a> <a href="#page-20-7">BLH</a><sup>+</sup> ], or such in which at least one of the curves is not pairing-friendly [\\[Ol\\]](#page-21-6). Although allowing for smaller field sizes, the use of non pairing-friendly cycles introduces another issue. Due to a lack of better alternatives, such constructions apply (a variant of) the 'dlog' polynomial commitment scheme from <a href="#page-19-0">\\[BCC</a><sup>+</sup> 16] the verifier of which is linear in the size of the circuit to be proven; a serious obstacle for efficient recursion. In their seminal work [\\[BGH19\\]](#page-20-1), Bowe et al. showed how to overcome the problem of linear verifier size by a novel approach called nested amortization. In nested amortization the proof system aggregates the computational 'hard parts' of the verifier outside the circuit, reducing the verification of all of them to a single expensive check at the recursion end.</p>

    <p class="text-gray-300">Since [\\[BGH19\\]](#page-20-1) amortization schemes became an active field of research. Bünz et al. [\\[BCMS20\\]](#page-19-4) gave a more modular approach to the [\\[BGH19\\]](#page-20-1) concept of amortization (named accumulation scheme therein). However, their approach is less performant than the one in [\\[BGH19\\]](#page-20-1), which directly integrates the amortization rounds into the argument system. Boneh et al. [\\[BDFG20\\]](#page-20-2) extend the concept of amortization to private aggregation schemes for polynomial commitments, which allow to aggregate entire opening proofs along the nodes of a PCD scheme. An even more radical approach for rank one constraint systems (R1CS) is followed by <a href="#page-19-6">\\[BCL</a><sup>+</sup> 20], who aggregate entire R1CS solutions over recursion. Although both approaches lead to a significant speedup of recursion, they come at the cost of increased proof sizes for the PCD. The private witnesses aggregated across the nodes are as large as the circuit itself. For a Marlin verifier it is at about 1 MiB at minimum, and multiples of that in typical applications <a href="#page-19-6">\\[BCL</a><sup>+</sup> 20].</p>

    <p class="text-gray-300">In this document we describe the Darlin proof carrying data scheme, the recursive SNARK for a Latus sidechain of Zendoo [\\[GKO20\\]](#page-20-8), a blockchain system which supports cross-chain communication. Latus sidechains are highly customizable blockchains which share the same token as the Zendoo mainchain they are bootstrapped from, and the Darlin scheme is used to provide succinct proofs of correct side chain state transitions. Darlin is based on the Marlin argument system, modified in order to handle the aggregation of both Marlin's inner sumchecks and the 'dlog' hard parts. According to our estimates, we expect the advantage of Darlin over standard Marlin (without inner sumcheck aggregation) to be about 30% when 'merging' two previous proofs, at the cost of only tripling the proof size, cf. Table <a href="#page-3-1">1.</a></p>

    <p class="text-gray-300"><span id="page-2-0"></span><sup>2</sup> [\\[BMRS20\\]](#page-20-9) uses a cycle of MNT4/MNT6 curves with 753 bit field sizes targeting a security level of 128 bit. However, improvements on the towered number field sieve <a href="#page-21-5">\\[GS19,</a> [Gui20\\]](#page-21-7) enforce to increase the field size up to 1, 000 bits.</p>

    <p class="text-gray-300"><span id="page-3-1"></span>Table 1: The impact of inner sumcheck amortization: Comparison of Marlin/dlog [CHM <span class="math">^+</span> 20] versus Darlin for a PCD node which verifies two previous proofs, both using the Pasta curves [HBG], and using the optimization techniques from [BGH19] to reduce the size of the verifier in circuit. We "segmentize" dlog commitments to speed up the prover. See Section 5.5 for details. As our implementation is not ready yet, the prover times are <em>estimates</em> for an Amazon EC2 G4dn instance (4 Intel Xeon@2.5 GHz + 1 NVIDIA T4).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">dlog segment size <sup>†</sup></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">2^{19}</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">2^{18}</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">2^{17}</span></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">constraints</td>

            <td class="px-3 py-2 border-b border-gray-700">Marlin*</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 320 k</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 384 k</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 520 k</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Constraints</td>

            <td class="px-3 py-2 border-b border-gray-700">Darlin</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 290 k</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 320 k</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 390 k</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">nroof size</td>

            <td class="px-3 py-2 border-b border-gray-700">Marlin*</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 4.2 kB</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 4.6 kB</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 5.3 kB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">proof size</td>

            <td class="px-3 py-2 border-b border-gray-700">Darlin</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 15.3 kB</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 15.7 kB</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 16.8 kB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">nyovov timo</td>

            <td class="px-3 py-2 border-b border-gray-700">Marlin*</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 16.5 s</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 15.9 s</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 15.38 s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">prover time</td>

            <td class="px-3 py-2 border-b border-gray-700">Darlin</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\approx 12.3 \\text{ s } (9.6 \\text{ s}^{**})</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\approx 11.7 \\text{ s } (9.1 \\text{ s**})</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\approx 11.4 \\ (8.8 \\ s^{**})</span></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><sup>\\*</sup>Assuming R1CS density d = 2, which is large enough in our applications.</p>

    <p class="text-gray-300">The document is organized as follows. In Section 3 we describe a variant of the univariate sumcheck argument from [BSCR<sup>+</sup>19, CHM<sup>+</sup>20], inspired by the grand product argument of Plonk [GWC19]. This variant does not rely on degree bound proofs and allows a more lightweight zero-knowledge randomization. In Section 4 we informally describe our variant of Marlin, which besides using a slightly different matrix arithmetization applies the sumcheck argument from Section 3. In Section 5 we recapitulate the amortization strategy for the dlog hard parts, explain the aggregation of Marlin's inner sumcheck across multiple circuits, and summarize the main recursive argument. All formal definitions and proofs are postponed to the appendix, Section A.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">2 Preliminary notes</h4>

    <p class="text-gray-300">Whenever appropriate, we formulate our protocols as algebraic oracle proofs, with oracles as an information-theoretic model for homomorphic polynomial commitments. An algebraic oracle proof is a multi-round protocol in which the prover responds to verifier challenges with oracles for some low-degree polynomials, receives another challenge from the verifier. The prover replies with some other oracles, and so on. The verifier is allowed to query these oracles for the values of any linear combination of their polynomials at any point she chooses. As in algebraic holographic proofs [CHM+20], the verifier may access some of the inputs only via oracle queries, but we do not assume that these oracles stem from a (circuit-specific) setup phase. Algebraic oracle proofs can be viewed as a variant of fully linear interactive oracle protocols [BBCGI19], considering</p>

    <p class="text-gray-300"><sup>\\<em>\\</em></sup>only at the two lowest levels of a proof tree, where aggregation is trivial.</p>

    <p class="text-gray-300">an evaluation query as a linear functional of the polynomial to be queried. However, we shall not dwell on their separate information-theoretic security properties, nor we explicitly provide the compiler which transforms these into their corresponding ones for the resulting interactive argument systems when instantiating the oracles by a polynomial commitment scheme. Instead, the proof of our main recursive argument from Section 5.4 relies on a compiler as used implicitly in the security analysis of the batch evaluation protocol from [BDFG20].</p>

    <p class="text-gray-300">Let F be a finite field, H be a multiplicative subgroup of order n, and assume that p(X) is a polynomial of arbitrary degree. The univariate sumcheck argument from [BSCR<sup>+</sup>19, CHM<sup>+</sup>20] is an algebraic oracle proof for showing that</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{x \\in H} p(x) = 0.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The sumcheck argument is the key ingredient to Marlin's way of proving a witness polynomial satisfying the rules of a given circuit (see Section 4). It is based on the fact that the above sum is equal to n times the constant term of the polynomial, if p(X) is of reduced form, i.e. of a degree strictly less than the domain size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n. Hence showing that the reduced form of p(X) has constant term zero, i.e.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-4-1"></span> <span class="math-block">p(X) = X \\cdot g(X) + h(X) \\cdot (X^n - 1), \\tag{1}</span></p>

    <p class="text-gray-300">for some polynomials h(X) and g(X) whereas deg(g(X)) < n-1, proves the claimed sum. To convince the verifier of (1) the prover provides the oracles for p(X) g(X) and h(X), which we denote by</p>

    <p class="text-gray-300">together with a proof that  <span class="math">deg(g(X)) \\le n-1</span> . In response the verifier samples a random challenge  <span class="math">z \\leftarrow F</span>  on which the oracles are queried for p(z), g(z), h(z). These evaluations are used to validate the identity (1) at X = z. In order to obtain (honest verifier) zero-knowledge, the prover samples a random 'mask' polynomial s(X) of degree at least n and proves that</p>

    <div class="my-4 text-center"><span class="math-block">\\hat{p}(X) = p(X) + s(X) \\tag{2}</span></div>

    <p class="text-gray-300">sums up to  <span class="math">\\sigma = \\sum_{z \\in H} s(z)</span> , which is done by an ordinary sumcheck argument for  <span class="math">\\hat{p}(X) - \\sigma/n</span> . See [CHM<sup>+</sup>20] for the details.</p>

    <p class="text-gray-300">Our sumcheck argument carries over the grand product argument from Plonk [GWC19] to the additive setting. Instead of using the reduced form of the polynomial p(X) in question, the prover shows that the additive <em>cocycle</em> with respect to the group action of  <span class="math">\\mathbb{Z}</span>  on H defined by g,</p>

    <p class="text-gray-300"><span class="math-block">f_p(k,X) = \\sum_{i=0}^{k-1} p(g^i \\cdot X)</span>  (3)</p>

    <p class="text-gray-300">is a coboundary, which is characterized by the following folklore Lemma.</p>

    <p class="text-gray-300"><strong>Lemma 1.</strong> Let H be a multiplicative subgroup of a finite field F and let g be a generator of H. For any univariate polynomial p(X) of arbitrary degree we have  <span class="math">\\sum_{z \\in H} p(z) = 0</span>  if and only if there exists a polynomial U(X) such that</p>

    <p class="text-gray-300"><span id="page-5-0"></span> <span class="math-block">U(g \\cdot X) - U(X) = p(X) \\mod (X^n - 1). \\tag{4}</span></p>

    <p class="text-gray-300"><em>Proof.</em> Suppose that  <span class="math">\\sum_{z \\in H} p(z) = 0</span> . Define U(X) on H by intitializing  <span class="math">U(g^0) = U(1)</span>  to any arbitrary value, and setting</p>

    <div class="my-4 text-center"><span class="math-block">U(g^k) = U(1) + \\sum_{i=0}^{k-1} p(g^i)</span></div>

    <p class="text-gray-300">for  <span class="math">k=1,\\ldots,n-1</span> . By definition  <span class="math">U(g^{k+1})=U(g^k)+p(g^k)</span>  for all  <span class="math">k, 0 \\le k \\le n-2</span> . The equation also holds for k=n-1, since the full cycle sum  <span class="math">\\sum_{i=0}^{n-1} p(g^i) = \\sum_{z \\in H} p(z)</span>  vanishes. This shows that  <span class="math">U(g \\cdot z) - U(z) = p(z)</span>  for all z in H, thus any extension U(X) beyond H satisfies the claimed identity  <span class="math">U(g \\cdot X) - U(X) = p(X) \\mod (X^n - 1)</span> . The other direction of the proof is obvious.</p>

    <p class="text-gray-300">The main advantage of the coboundary approach is that the algebraic oracle proof for equation (4) allows a more lightweight zero-knowledge randomization than that of equation (1): Since no reduced form is needed for U(X), we can simply randomize U(X) by means of the vanishing polynomial of H,</p>

    <p class="text-gray-300"><span id="page-5-2"></span> <span class="math-block">\\hat{U}(X) = U(X) + (c_0 + c_1 \\cdot X) \\cdot (X^n - 1), \\tag{5}</span></p>

    <p class="text-gray-300">with uniformly random  <span class="math">c_0</span> ,  <span class="math">c_1 \\leftarrow F</span> , assuming that  <span class="math">\\hat{U}(X)</span>  is not queried beyond the sumcheck protocol. We describe the sumcheck argument as an algebraic oracle proof for polynomials from  <span class="math">R = F[X]/(X^n - 1)</span>  with the aim to prove that the prover knows an element from R which is subject to the sumcheck  <span class="math">\\sum_{x \\in H} p(X) = 0</span> .</p>

    <p class="text-gray-300"><span id="page-5-4"></span><strong>Protocol 1</strong> (Coboundary sumcheck). Let H be a multiplicative subgroup of a finite field F, g be a generator of H having order n. The prover is given p(X) from  <span class="math">R = F[X]/(X^n - 1)</span>  subject to  <span class="math">\\sum_{x \\in H} p(x) = 0</span> , and the verifier is given the oracle of a random representant  <span class="math">\\hat{p}(X) = p(X) + r(X) \\cdot (X^n - 1)</span> , where r(X) is sampled uniformly from the set of polynomials of degree strictly less than b+1.</p>

    <p class="text-gray-300">(1) The prover P computes U(X) of deg(U(X)) < n according to the coboundary identity (4). It computes  <span class="math">\\hat{U}(X)</span>  as in (5), with  <span class="math">c_0, c_1 \\leftarrow sF</span> , and the quotient polynomial h(X) satisfying</p>

    <p class="text-gray-300"><span id="page-5-3"></span> <span class="math-block">\\hat{U}(g \\cdot X) - \\hat{U}(X) = \\hat{p}(X) + h(X) \\cdot (X^{n} - 1).</span>  (6)</p>

    <p class="text-gray-300">P then sends  <span class="math">[\\hat{U}(X)]</span> , [h(X)] to the verifier.</p>

    <p class="text-gray-300"><span id="page-5-1"></span><sup>&</sup>lt;sup>3</sup>The bound  <span class="math">b \\ge 0</span>  corresponds to the maximum number of allowed queries for  <span class="math">[\\hat{p}(X)]</span>  beyond the sumcheck protocol.</p>

    <p class="text-gray-300">(2) The verifier V samples a random challenge  <span class="math">z \\leftarrow sF \\setminus H</span>  and queries the oracles  <span class="math">[\\hat{U}(X)]</span> , [h(X)], and  <span class="math">[\\hat{p}(X)]</span>  for their values at z. (The oracle aborts, if  <span class="math">z \\in H</span> .) V uses these values to verify identity (6) at X = z, and accepts if valid. (Otherwise, the verifier rejects.)</p>

    <p class="text-gray-300">The security analysis of Protocol 1 (applied to a specific  <span class="math">\\hat{p}(X)</span> ) is given in the course of the proof of Theorem 2. As a separate algebraic oracle proof it is perfectly complete and computationally knowledge sound, assuming the size of H is negligible compared to the size of the field F. It is succinct and perfectly honest verifier zero-knowledge, assuming that each the oracles  <span class="math">[\\hat{p}(X)]</span>  is queried outside the protocol at most another b times (and  <span class="math">[\\hat{U}(X)]</span>  is not queried at all). The latter is an immediate consequence of the fact that the conditional distribution of</p>

    <div class="my-4 text-center"><span class="math-block">(v_1, v_2, v_3, v_4) = (\\hat{U}(g \\cdot z), \\hat{U}(z), \\hat{p}(z), h(z)),</span></div>

    <p class="text-gray-300">conditional to  <span class="math">z \\notin H</span> , is uniform on the relation  <span class="math">\\mathcal{R}_z = \\{(v_1, v_2, v_3, v_4) \\in F^4 : v_1 - v_2 - v_3 = v_4 \\cdot (z^n - 1)\\}</span> . If one instantiates the oracle with a computationally binding (Definition 8) and perfectly hiding (Definition 7) polynomial commitment scheme, the opening proof of which is an argument of knowledge (Definition 5), then the protocol is compiled into a succinct honest verifier zero-knowledge argument of knowledge.</p>

    <p class="text-gray-300">This section describes <em>Coboundary Marlin</em>, a slight variant of the Marlin SNARK [CHM<sup>+</sup>20]. We introduce two changes: First, we replace Marlin's sumcheck argument by the coboundary argument from Section 3. Second, we<sup>4</sup> make use of the Lagrange kernel</p>

    <div class="my-4 text-center"><span class="math-block">L_n(X,Y) = \\frac{1}{n} \\cdot \\frac{Y \\cdot (X^n - 1) - X \\cdot (Y^n - 1)}{X - Y} \\tag{7}</span></div>

    <p class="text-gray-300">instead of the non-normalized version  <span class="math">R(X,Y) = \\frac{X^n - Y^n}{X - Y}</span> . The Lagrange kernel shares the same key properties as R(X,Y). It can be evaluated <em>succinctly</em>, and allows a <em>practical</em> sumcheck representation for the bivariate circuit polynomials, as shown below. However, we point out that our favor for the Lagrange kernel is mainly for esthetic reasons. Using it allows us to argue directly with the bivariate circuit polynomials instead of a derivative in both of Marlin's sumcheck arguments as well as our aggregation strategy from Section 5.</p>

    <p class="text-gray-300"><span id="page-6-1"></span><sup>&</sup>lt;sup>4</sup>We would like to thank A. Querol for pointing out that [CFF<sup>+</sup>20] also choose the Lagrange kernel. As a consequence, our version of the lincheck is exactly the same as theirs.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">4.1 Arithmetization</h4>

    <p class="text-gray-300">We assume an arithmetic circuit  <span class="math">\\mathcal{C}</span>  over F being represented by a rank-one constraint system (R1CS), i.e.</p>

    <p class="text-gray-300"><span id="page-7-1"></span> <span class="math-block">(A \\cdot y) \\odot (B \\cdot y) = C \\cdot y, \\tag{8}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where we assume that A, B, C are  <span class="math">n \\times n</span>  matrices over  <span class="math">F, \\cdot</span>  is the vector matrix product and  <span class="math">\\odot</span>  denotes the entry-wise (Hadamard) product of vectors. The witness vector  <span class="math">y \\in F^n</span>  is composed of a public part x and a private part w, i.e. y = (x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w). Notice assuming quadratic matrices is no loss in generality, as the constraint system may always be padded with dummy constraints or variables. Moreover, we presume that</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1 is divisible by a high power of two, assuring the existence of sufficiently large multiplicative subgroups of 2-adic order. Subgroups of such smooth order allow for a fast Fourier transform which runs in time  <span class="math">O(n \\log(n))</span> , where n is the order of the subgroup. (In the sequel we call such subgroups FFT domains.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In Marlin the R1CS equations are expressed over the FFT domain  <span class="math">H = \\{z \\in F : z^n - 1 = 0\\}</span>  using Lagrange encoding. That is, given an arbitrary enumeration  <span class="math">\\{z_1, \\ldots, z_n\\}</span>  of H a vector  <span class="math">y = (y_k)_{k=1}^n</span>  is associated with the polynomial</p>

    <p class="text-gray-300"><span id="page-7-3"></span> <span class="math-block">y(X) = \\sum_{k} y_k \\cdot L(X, z_k). \\tag{9}</span></p>

    <p class="text-gray-300">In other words,  <span class="math">(y_k)</span>  is the vector of coordinates with respect to the Lagrange basis  <span class="math">(L(X, x_k))_k</span> . Therefore  <span class="math">y \\in F^n</span>  is a solution of (8) if and only if its associated polynomial  <span class="math">y(X) = \\sum_k y_k \\cdot L(X, z_k)</span>  satisfies</p>

    <div class="my-4 text-center"><span class="math-block">y_A(X) \\cdot y_B(X) = \\sum_{z \\in H} C(X, z) \\cdot y(z) \\mod (X^n - 1), \\tag{10}</span></div>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span id="page-7-4"></span> <span class="math-block">y_A(X) = \\sum_{z \\in H} A(X, z) \\cdot y(z) \\mod (X^n - 1), \\tag{11}</span></p>

    <p class="text-gray-300"><span id="page-7-5"></span> <span class="math-block">y_B(X) = \\sum_{z \\in H} B(X, z) \\cdot y(z) \\mod (X^n - 1). \\tag{12}</span></p>

    <p class="text-gray-300">In these equations, A(X,Y), B(X,Y), C(X,Y) are the bivariate polynomials with the entries of the R1CS matrices A, B, C respectively as Lagrange coordinates,</p>

    <p class="text-gray-300"><span id="page-7-2"></span> <span class="math-block">M(X,Y) = \\sum_{i,j=1}^{n} M_{i,j} \\cdot L(X,z_i) \\cdot L(Y,z_j),</span>  (13)</p>

    <p class="text-gray-300">for M = A, B, C. The double sum in (13) is made amenable to a univariate sumcheck argument by indexing its non-zero terms over yet another FFT domain  <span class="math">K = \\{w \\in F : w^m - 1 = 0\\}</span> , again assuming the existence of a sufficiently large smooth multiplicative subgroup. As in Marlin, we denote by</p>

    <p class="text-gray-300"><span class="math-block">val_M(X), row_M(X), col_M(X) \\in F[X]/(X^m - 1)</span> (14)</p>

    <p class="text-gray-300">the polynomials of degree < m which index M's non-zero values, their row and column indices (the latter two regarded as points from H, as in (13)), so that</p>

    <p class="text-gray-300"><span id="page-8-2"></span> <span class="math-block">M(X,Y) = \\sum_{w \\in K} val_M(w) \\cdot L(X,row_M(w)) \\cdot L(Y,col_M(w)).</span></p>

    <p class="text-gray-300">Since  <span class="math">L_n(X,z) = \\frac{1}{n} \\cdot \\frac{z \\cdot (X^n - 1)}{X - z}</span>  whenever z is from H, we have</p>

    <div class="my-4 text-center"><span class="math-block">M(X,Y) = \\frac{(X^{n}-1)\\cdot(Y^{n}-1)}{n}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\cdot \\sum_{w\\in K} \\frac{val_{M}(w)\\cdot row_{M}(w)\\cdot col_{M}(w)}{(X-row_{M}(w))\\cdot(Y-col_{M}(w))} \\mod (X^{m}-1). \\quad (15)</span></div>

    <p class="text-gray-300">This representation, which differs slightly from [CHM<sup>+</sup>20], is the one we use for the second sumcheck argument, the 'inner sumcheck'. We assume that for M = A, B, C, the precomputed polynomials</p>

    <p class="text-gray-300"><span class="math-block">row.col_M(X) = row_M(X) \\cdot col_M(X) \\mod (X^m - 1),</span>  (16)</p>

    <p class="text-gray-300"><span class="math-block">val.row.col_M(X) = val_M(X) \\cdot row_M(X) \\cdot col_M(X) \\mod (X^m - 1),</span>  (17)</p>

    <p class="text-gray-300">regarded of degree < m, are also part of the verifier key.</p>

    <p class="text-gray-300">In Marlin, public circuit inputs  <span class="math">x = (x_i)</span>  define the Lagrange representation of the <em>input polynomial</em></p>

    <p class="text-gray-300"><span id="page-8-3"></span> <span class="math-block">x(X) = \\sum_{i} x_i \\cdot L_{\\ell}(x_i, X) \\in F[X]/(X^{\\ell} - 1)</span></p>

    <p class="text-gray-300">over an properly sized input domain  <span class="math">I \\leq H</span>  of size  <span class="math">\\ell</span> , and the full circuit state polynomial y(X) is combined via</p>

    <p class="text-gray-300"><span class="math-block">y(X) = x(X) + (X^{\\ell} - 1) \\cdot w(X),</span>  (18)</p>

    <p class="text-gray-300">using a gauged witness polynomial  <span class="math">w(X) \\in F^{&lt; n-\\ell}[X]</span> . The prover provides the oracles for the private witness polynomial w(X),  <span class="math">y_A(X)</span> ,  <span class="math">y_B(X)</span>  and convinces the verifier of the R1CS identities (10), (11), and (12). These three identities are reduced to a single one by building a random linear combination based on a challenge  <span class="math">\\eta \\leftarrow F</span> , i.e.</p>

    <p class="text-gray-300"><span id="page-8-1"></span> <span class="math-block">y_{\\eta}(X) = \\sum_{z \\in H} T_{\\eta}(X, z) \\cdot y(z) \\mod (X^{n} - 1),</span>  (19)</p>

    <p class="text-gray-300">with</p>

    <div class="my-4 text-center"><span class="math-block">y_{\\eta}(X) = y_A(X) + \\eta \\cdot y_B(X) + \\eta^2 \\cdot y_A(X) \\cdot y_B(X),</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">T_{\\eta}(X,Y) = A(X,Y) + \\eta \\cdot B(X,Y) + \\eta^2 \\cdot C(X,Y).</span></div>

    <p class="text-gray-300">The linear identity (19) is reduced to a sumcheck over H by sampling a polynomial  <span class="math">R(X,\\alpha)</span>  using a suitable kernel R(X,Y),  <span class="math">\\alpha \\leftarrow F</span> , and applying it via scalar product to both sides of the equation. This yields</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{z \\in H} \\langle R(X, \\alpha), T_{\\eta}(X, z) \\rangle_{H} \\cdot y(z) = \\langle R(X, \\alpha), y_{\\eta}(X) \\rangle_{H},</span></div>

    <p class="text-gray-300">hence</p>

    <p class="text-gray-300"><span id="page-9-0"></span> <span class="math-block">\\sum_{z \\in H} \\langle R(X, \\alpha), T_{\\eta}(X, z) \\rangle_{H} \\cdot y(z) - R(z, \\alpha) \\cdot y_{\\eta}(z) = 0.</span>  (20)</p>

    <p class="text-gray-300">Choosing the Lagrange kernel  <span class="math">L_n(X,Y)</span>  for R(X,Y),  <span class="math">\\langle L_n(X,\\alpha), T_\\eta(X,z) \\rangle_H = T_\\eta(\\alpha,z)</span> , since  <span class="math">T_\\eta(X,z)</span>  is of degree less than n (see Appendix A.10). Hence equation (20) is equal to</p>

    <p class="text-gray-300"><span id="page-9-1"></span> <span class="math-block">\\sum_{z \\in H} T_{\\eta}(\\alpha, z) \\cdot y(z) - L_{\\eta}(z, \\alpha) \\cdot y_{\\eta}(z) = 0.</span> (21)</p>

    <p class="text-gray-300">Equation (21) is the central identity to be proven by the protocol.</p>

    <p class="text-gray-300">We describe the protocol as algebraic oracle proof.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">Initialization</h4>

    <p class="text-gray-300">In the first step the prover computes the polynomials<sup>5</sup> w(X),  <span class="math">y_A(X)</span> ,  <span class="math">y_B(X) \\in F[X]/(X^n-1)</span>  from their Lagrange representations, and chooses random representants</p>

    <div class="my-4 text-center"><span class="math-block">\\hat{w}(X), \\hat{z}_A(X), \\hat{z}_B(X) \\in F^{&lt; n+1}[X]</span></div>

    <p class="text-gray-300">according to the sampling rule  <span class="math">\\hat{p}(X) \\leftarrow p(X) + F \\cdot (X^n - 1)</span>  using randomizer polynomials of degree zero. It sends their oracles  <span class="math">[\\hat{w}(X)], [\\hat{y}_A(X)], [\\hat{y}_B(X)]</span>  to the verifier, who returns the randomnesses  <span class="math">\\eta \\leftarrow F</span>  and  <span class="math">\\alpha \\leftarrow F \\setminus H</span>  for Equation (21).</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">Outer sumcheck</h4>

    <p class="text-gray-300">To prove equation (21) we apply the coboundary argument from Section 3 to  <span class="math">\\hat{p}(X) := T_{\\eta}(\\alpha, X) \\cdot \\hat{y}(X) - L_{\\eta}(X, \\alpha) \\cdot \\hat{y}_{\\eta}(X)</span> , where</p>

    <div class="my-4 text-center"><span class="math-block">\\hat{y}(Y) := x(Y) + (Y^{\\ell} - 1) \\cdot \\hat{w}(Y),</span></div>

    <div class="my-4 text-center"><span class="math-block">\\hat{y}_{\\eta}(Y) := \\hat{y}_{A}(Y) + \\eta \\cdot \\hat{y}_{B}(Y) + \\eta^{2} \\cdot \\hat{y}_{A}(Y) \\cdot \\hat{y}_{B}(Y).</span></div>

    <p class="text-gray-300">The prover computes the boundary polynomial  <span class="math">U_1(X) \\in F[X]/(X^n-1)</span> , chooses a random representant</p>

    <div class="my-4 text-center"><span class="math-block">\\hat{U}_1(X) \\in F^{&lt; n+2}[Y]</span></div>

    <p class="text-gray-300"><span id="page-9-2"></span> <span class="math">&lt;sup&gt;^5 \\&lt;/sup&gt;mathrm{Unless}</span>  stated otherwise we assume polynomials p(X) from  <span class="math">F[X]/(X^n</span>  – 1) of reduced form, i.e. of degree < n.</p>

    <p class="text-gray-300">of it, and computes  <span class="math">h_1(X) \\in F^{&lt;2 \\cdot n+1}[X]</span>  for the outer sumcheck identity</p>

    <p class="text-gray-300"><span id="page-10-0"></span> <span class="math-block">T_{\\eta}(\\alpha, X) \\cdot \\hat{y}(X) - L_{n}(X, \\alpha) \\cdot \\hat{y}_{\\eta}(X)</span></p>

    <div class="my-4 text-center"><span class="math-block">= \\hat{U}_{1}(gX) - \\hat{U}_{1}(X) + h_{1}(X) \\cdot (X^{n} - 1), \\quad (22)</span></div>

    <p class="text-gray-300">where g is a generator of H. It then sends  <span class="math">[\\hat{U}_1(X)]</span> ,  <span class="math">[h_1(X)]</span>  together with  <span class="math">[T_{\\eta}(\\alpha, X)]</span>  to the verifier. The verifier samples another random challenge  <span class="math">\\beta \\leftarrow F \\setminus H</span>  and queries the oracles for  <span class="math">\\hat{w}(\\beta), \\hat{y}_A(\\beta), \\hat{y}_B(\\beta), T_{\\eta}(\\alpha, \\beta), \\hat{U}_1(g \\cdot \\beta), \\hat{U}_1(\\beta), h_1(\\beta)</span> , which are used for checking the identity (22) at  <span class="math">Z = \\beta</span> .</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">Inner sumcheck</h4>

    <p class="text-gray-300">To prove that  <span class="math">T_{\\eta}(\\alpha, \\beta)</span>  as provided by the oracle in fact stems from the circuit polynomials M(X,Y), M=A,B,C we adapt Marlin's inner sumcheck to our representation (15). Using these we obtain</p>

    <div class="my-4 text-center"><span class="math-block">T_{\\eta}(\\alpha, \\beta) = \\sum_{w \\in K} \\sum_{M=A,B,C} \\eta_M \\cdot \\frac{val.row.col_M(w)}{(\\alpha - row_M(w)) \\cdot (\\beta - col_M(w))}, \\tag{23}</span></div>

    <p class="text-gray-300">where  <span class="math">(\\eta_A, \\eta_B, \\eta_C) = \\frac{(1-\\alpha^n)\\cdot(1-\\beta^n)}{n^2} \\cdot (1, \\eta, \\eta^2)</span> . We apply the coboundary sumcheck to</p>

    <div class="my-4 text-center"><span class="math-block">p(X) = \\sum_{M=A,B,C} \\eta_M \\cdot \\frac{val.row.col_M(X)}{(\\alpha - row_M(X)) \\cdot (\\beta - col_M(X))},</span></div>

    <p class="text-gray-300">regarded as a reduced element from  <span class="math">F[X]/(X^m-1)</span> . The prover computes  <span class="math">U_2(X)</span>  from  <span class="math">F[X]/(X^m-1)</span>  satisfying</p>

    <p class="text-gray-300"><span id="page-10-1"></span> <span class="math-block">p(X) = \\frac{T_{\\eta}(\\alpha, \\beta)}{m} + U_2(g_K X) - U_2(X) \\mod (X^m - 1),</span></p>

    <p class="text-gray-300">and then multiplies both sides with the denominator</p>

    <div class="my-4 text-center"><span class="math-block">b(X) = \\prod_{M=A,B,C} (\\alpha - row_M(X)) \\cdot (\\beta - col_M(X))$$ $$= \\prod_{M=A,B,C} (\\alpha\\beta + \\beta \\cdot row_M(X) + \\alpha \\cdot col_M(X) + row.col_M(X)),</span></div>

    <p class="text-gray-300">where  <span class="math">row.col_M(X)</span>  are the precomputed products (16) from the prover key. This yields the <em>inner sumcheck</em> identity</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{M=A,B,C} \\eta_M \\cdot val.row.col_M(X)</span></div>

    <div class="my-4 text-center"><span class="math-block">= b(X) \\cdot \\left(\\frac{T_{\\eta}(\\alpha,\\beta)}{m} + U_2(g_K X) - U_2(X)\\right) + h_2(X) \\cdot (X^m - 1), \\quad (24)</span></div>

    <p class="text-gray-300">where  <span class="math">g_K</span>  is a generator of K and  <span class="math">h_2(X) \\in F^{&lt;3\\cdot m-3}[X]</span> . The prover sends the oracles  <span class="math">[U_2(X)]</span>  and  <span class="math">[h_2(X)]</span>  to the verifier, who samples a random challenge  <span class="math">\\gamma \\leftarrow F</span> , on which the oracles are queried for  <span class="math">row_M(\\gamma), col_M(\\gamma), row.col_M(\\gamma), val.row.col_M(\\gamma)</span> , where M = A, B, C, and  <span class="math">U_2(g_K \\cdot \\gamma), U_2(\\gamma), h_2(\\gamma)</span> . These values are used by the verifier to check the identity (24) at  <span class="math">X = \\gamma</span> .</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">Security</h3>

    <p class="text-gray-300">The security analysis of Coboundary Marlin is similar to that of our main recursive argument, Theorem 2. As for Theorem 2, we stress the fact that we use the Halevi-Micali [HM98] notion of proof of knowledge with negligible knowledge error. The proof can be found in the appendix, Section A.5.</p>

    <p class="text-gray-300"><span id="page-11-2"></span><strong>Theorem 1.</strong> Instantiating the oracle by a computationally binding and perfectly hiding polynomial commitment scheme (Definition 7 and 8, Coboundary Marlin is a succinct, perfect honest verifier zero-knowledge (Definition 6) argument of knowledge (Definition 5) for the R1CS relation</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R} = \\{ ((A, B, C, x), w) : y = (x, w) \\text{ satisfies } (A \\cdot y) \\odot (B \\cdot y) = C \\cdot y \\}.</span></div>

    <p class="text-gray-300">Using the Fiat-Shamir transform the interactive argument is transformed into a zk-SNARK with analog security properties in the random oracle model.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Marlin's outer sumcheck takes place over the FFT domain H, the size of which covers the number of constraints/variables of the constraint system. In practice circuits yield about the same number of variables as constraints, hence it is reasonable to take n the number of constraints as measure for the computational effort of the outer sumcheck, assuming a sufficiently smooth order of  <span class="math">F^*</span>  to optimally match n. The inner sumcheck runs over the FFT domain K of size  $m \\approx \\max_{M=A,B,C} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  ( </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  is the number of non-zero entries in M), again under the assumption of sufficient smoothness. This domain is by the factor</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$d = \\frac{\\max_{M=A,B,C} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{n}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">larger, where d is the R1CS density of the circuit. The R1CS density is the average number of variables per constraint. In practice, we observed values between d=1.5 and d=2 for the circuits we target. (These circuits implement elliptic curve arithmetics over non-extension fields and the  <span class="math">x^5</span> -Poseidon hash [GKR<sup>+</sup>21] with an internal state of 3 field elements.)</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">5 Recursion</h3>

    <p class="text-gray-300">Our recursive scheme is based on Coboundary Marlin and the [BCMS20] variant of the <em>dlog polynomial commitment scheme</em> from [BCC<sup>+</sup>16]. We take Coboundary Marlin without inner sumcheck as succinct argument, and we aggregate both the non-succinct parts of the opening proof verifier, as well as the correctness checks usually served by the inner sumchecks, which is verifying that the commitment intended for</p>

    <div class="my-4 text-center"><span class="math-block">T_{\\eta}(\\alpha, Y) = \\sum_{M=A,B,C} \\eta_M \\cdot M(\\alpha, Y)</span></div>

    <p class="text-gray-300">Table 2: Computational effort of the (coboundary) zk-Marlin prover, using an elliptic curve based linear polynomial commitment scheme. We only count fast Fourier transforms  <span class="math">\\mathsf{FFT}(a)</span>  in terms of their domain size a, and elliptic curve multi scalar multiplications  <span class="math">\\mathsf{MSM}(b)</span>  in terms of the number of scalars b. (Without opening proof.)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">polynomial arithm.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">commit</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">intial round</td>

            <td class="px-3 py-2 border-b border-gray-700">3  FFT(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">3 MSM(n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">outer sumcheck</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math"> \\begin{array}{c} 2 \\text{ FFT}(n) + 2 \\text{ FFT}(2n) \\\\ +3 \\text{ FFT}(3n) \\end{array} </span></td>

            <td class="px-3 py-2 border-b border-gray-700">2 MSM(n) + 1 MSM(2n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">inner sumcheck</td>

            <td class="px-3 py-2 border-b border-gray-700">1  FFT(m) + 1  FFT(4m)</td>

            <td class="px-3 py-2 border-b border-gray-700">1 MSM(m) + 1 MSM(3m)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">overall</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\approx (15 + 5 \\cdot d) \\; FFT(n)</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\approx (7 + 4 \\cdot d) \\text{ MSM(n)}</span></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">in fact carries these polynomials. Aggregation of the non-succinct part of the dlog verifier (the dlog hard parts) relies on the same principle as introduced by Halo [BGH19]. The way we aggregate the inner sumchecks is a generalization of Halo's strategy for their circuit encoding polynomial s(X,Y), and we extend it across circuits to serve a reasonable number of instances  <span class="math">\\mathcal{C}_i = \\{A_i, B_i, C_i\\}</span>  simultaneously. As a separate 'stand-alone' protocol, our strategy may be taken as public aggregation scheme in the sense of [BDFG20], or an (atomic) accumulation scheme according to [BCMS20, BCL+20]. However, for efficiency reasons we choose Halo's 'interleaved' approach instead of the blackbox constructions from [BCMS20, BCL+20, BDFG20], and let the rounds of both the argument system and the aggregation scheme share the same opening proof.</p>

    <p class="text-gray-300">In our recursive argument certain previous proof elements  <span class="math">(acc_i)_{i=1}^{\\ell}</span>  called accumulators are 'passed' through inputs of the 'current' circuit and post-processed within the run of the current argument. Formally,  <span class="math">(acc_i)_{i=1}^{\\ell}</span>  satisfy a given predicate  <span class="math">\\phi</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\phi(acc_i) = 1, \\quad i = 1, \\ldots, \\ell,</span></div>

    <p class="text-gray-300">and are mapped to dedicated inputs of the current circuit. Beyond the rounds for proving satisfiability of the current circuit, the accumulators  <span class="math">(acc_i)_{i=1}^{\\ell}</span>  are aggregated within some extra rounds into a new instance, the 'current' accumulator acc, which is again subject to  <span class="math">\\phi(acc) = 1</span> . Altogether our recursive argument is of the form</p>

    <div class="my-4 text-center"><span class="math-block">\\langle \\operatorname{Prove}((acc_i)_{i=1}^{\\ell}, (x, w), pk), \\operatorname{Vf}((acc_i)_{i=1}^{\\ell}, x, vk) \\rangle</span></div>

    <p class="text-gray-300">where (x, w) are public and private circuit witnesses, pk and vk are the prover and verifier key for both Marlin and the aggregation scheme, and the new acc is output to both prover and verifier.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">5.1 Inner sumcheck aggregation</h4>

    <p class="text-gray-300">Here, the accumulator consists of a commitment C and the succinct description of the circuit polynomial  <span class="math">T_{\\eta}(z,Y)</span>  intended to be represented by C, i.e. the</p>

    <p class="text-gray-300">point  <span class="math">z \\in F</span>  and the randomnesses  <span class="math">\\vec{\\eta} = (\\eta_A, \\eta_B, \\eta_C) \\in F^3</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">acc_T = (z, \\vec{\\eta}, C).</span></div>

    <p class="text-gray-300">The corresponding predicate  <span class="math">\\phi_T</span>  is satisfied if and only if C is the commitment of  <span class="math">T_{\\eta}(z,Y)</span>  (using commitment randomness zero). The prover reduces the correctness of several accumulator instances to that of a single new one, and the verifier validates the correctness of this reduction while keeping track of the polynomial descriptions (i.e. the point z and the coefficient vector  <span class="math">\\vec{\\eta}</span> ) by herself. We sketch the strategy assuming a single previous accumulator.</p>

    <p class="text-gray-300">There, a previous instance  <span class="math">(\\alpha&#x27;, \\vec{\\eta}&#x27;, C&#x27;)</span>  is 'merged' with  <span class="math">(\\alpha, \\vec{\\eta}, C)</span>  of the current outer sumcheck. In a first step, the prover reduces the 'multi-point', 'multi-polynomial' instance<sup>6</sup>  <span class="math">T_{\\vec{\\eta}&#x27;}(\\alpha&#x27;, Y)</span> ,  <span class="math">T_{\\vec{\\eta}}(\\alpha, Y)</span>  to a single-point, multi-polynomial instance</p>

    <div class="my-4 text-center"><span class="math-block">T_{\\vec{n}&#x27;}(X,\\beta), T_{\\vec{n}}(X,\\beta),</span></div>

    <p class="text-gray-300">with random  <span class="math">\\beta \\leftarrow \\</span>F<span class="math"> , by providing the commitments to these new polynomials and proving consistency via polynomial testing: If the old polynomials evaluate at the challenge  </span>\\beta$  to the same values as the new polynomials at the old point, respectively, then correctness of the new polynomials overwhelmingly implies that of the old ones. Using the same principle once again, correctness of the single-point multi-polynomial instance is then reduced in batch to a single-point single-polynomial instance</p>

    <div class="my-4 text-center"><span class="math-block">\\lambda \\cdot T_{\\vec{\\eta}&#x27;}(\\alpha&#x27;&#x27;, Y) + T_{\\vec{\\eta}}(\\alpha&#x27;&#x27;, Y) = T_{\\lambda \\cdot \\vec{\\eta}&#x27; + \\vec{\\eta}}(\\alpha&#x27;&#x27;, Y),</span></div>

    <p class="text-gray-300">where  <span class="math">\\lambda, \\alpha&#x27;&#x27; \\leftarrow F</span>  are random. Note that the resulting polynomial is again of the form  <span class="math">T_{\\vec{\\eta}&#x27;&#x27;}(\\alpha&#x27;&#x27;,Y)</span>  with  <span class="math">\\eta&#x27;&#x27; = \\lambda \\cdot \\vec{\\eta}&#x27; + \\vec{\\eta}</span> . For the reduction, the prover shows that the linear combination  <span class="math">\\lambda \\cdot T_{\\vec{\\eta}&#x27;}(X,\\beta) + T_{\\vec{\\eta}}(X,\\beta)</span>  opens at the new challenge  <span class="math">X = \\alpha&#x27;&#x27;</span>  to the same value as the new polynomial  <span class="math">\\lambda \\cdot T_{\\vec{\\eta}&#x27;}(\\alpha&#x27;&#x27;,Y) + T_{\\vec{\\eta}}(\\alpha&#x27;&#x27;,Y)</span>  at the old point  <span class="math">Y = \\beta</span> . Again, correctness of the new polynomial overwhelmingly implies correctness of the old ones.</p>

    <p class="text-gray-300">Protocol 2 is regarded as a subprotocol of our complete recursive argument Protocol 4, right after the outer sumcheck. We formulate it as an algebraic oracle protocol, considering commitments as oracles.</p>

    <p class="text-gray-300"><span id="page-13-1"></span><strong>Protocol 2</strong> (Inner sumcheck aggregation). Suppose that  <span class="math">acc&#x27;_T = (\\alpha&#x27;, \\vec{\\eta}&#x27;, [T&#x27;(Y)])</span>  is a previous accumulator, intended to represent an oracle for  <span class="math">T&#x27;(Y) = T_{\\vec{\\eta}&#x27;}(\\alpha&#x27;, Y)</span> , and  <span class="math">(\\alpha, \\vec{\\eta}, [T(Y)])</span>  is as provided by the prover in the current outer sumcheck, intended to represent an oracle for  <span class="math">T(Y) = T_{\\vec{\\eta}}(\\alpha, Y)</span> , with  <span class="math">\\vec{\\eta} = (1, \\eta, \\eta^2)</span> . Aggregation of  <span class="math">acc&#x27;_T</span>  and  <span class="math">(\\alpha, \\vec{\\eta}, [T(Y)])</span>  is done according to the following steps immediately processed after the outer sumcheck.</p>

    <p class="text-gray-300">(1) Given  <span class="math">\\beta</span> , the random challenge from the outer sumcheck, the prover sends the oracles for the 'bridging polynomials'</p>

    <div class="my-4 text-center"><span class="math-block">T_{\\vec{\\eta}}(X,\\beta), T_{\\vec{\\eta}&#x27;}(X,\\beta) \\in F[X]/(X^n-1),</span></div>

    <p class="text-gray-300"><span id="page-13-0"></span><sup>&</sup>lt;sup>6</sup>Here 'multi-point' refers to the different points  <span class="math">\\alpha</span> ,  <span class="math">\\alpha&#x27;</span> , and 'multi-polynomial' to the different polynomials defined by  <span class="math">\\vec{\\eta}</span> ,  <span class="math">\\vec{\\eta}&#x27;</span> .</p>

    <p class="text-gray-300">on which the verifier responds with random  <span class="math">\\lambda, \\gamma \\leftarrow sF</span> .</p>

    <p class="text-gray-300"><span id="page-14-1"></span>(2) Given  <span class="math">\\lambda, \\gamma</span>  from the verifier, the prover 'responds' with the oracle for</p>

    <div class="my-4 text-center"><span class="math-block">T&#x27;&#x27;(Y) = T_{\\vec{\\eta}}(\\gamma, Y) + \\lambda \\cdot T_{\\vec{\\eta}&#x27;}(\\gamma, Y).</span></div>

    <p class="text-gray-300">The verifier queries  <span class="math">[T_{\\vec{\\eta}}(X,\\beta)]</span> ,  <span class="math">[T_{\\vec{\\eta}&#x27;}(X,\\beta)]</span>  for their corresponding values  <span class="math">v_1</span> ,  <span class="math">v_2</span>  at  <span class="math">X = \\alpha</span>  and  <span class="math">\\alpha&#x27;</span> , and checks them against the values of [T(Y)], [T'(Y)] at  <span class="math">Y = \\beta</span> , respectively. It also queries [T''(Y)] at  <span class="math">Y = \\beta</span>  and checks its value against that of the linear combination  <span class="math">[T_{\\vec{\\eta}}(X,\\beta)] + \\lambda [T_{\\vec{\\eta}&#x27;}(X,\\beta)]</span>  at  <span class="math">X = \\gamma</span> . If these checks succeed, then the verifier accepts and the new accumulator is</p>

    <div class="my-4 text-center"><span class="math-block">acc_T&#x27;&#x27; = (\\alpha&#x27;&#x27;, \\vec{\\eta}&#x27;&#x27;, C&#x27;&#x27;) = (\\gamma, \\vec{\\eta} + \\lambda \\cdot \\vec{\\eta}&#x27;, [T&#x27;(Y)]).</span></div>

    <p class="text-gray-300">A formal analysis of Protocol 2 is given in the course of the security proof of the complete recursive argument. As a stand-alone argument having its own opening proof, the protocol defines a (perfectly) complete and sound accumulation scheme for the predicate  <span class="math">\\phi_T</span>  in the sense of [BCMS20]: If both  <span class="math">acc_T&#x27;</span>  and  <span class="math">(\\alpha, \\eta, C)</span>  satisfy the predicate  <span class="math">\\phi</span> , so does  <span class="math">acc_T&#x27;&#x27;</span> . And if  <span class="math">\\phi(acc_T&#x27;&#x27;) = 1</span> , then with overwhelming probability both  <span class="math">\\phi(acc_T&#x27;)</span>  and  <span class="math">\\phi(\\alpha, \\eta, C) = 1</span> .</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">5.2 Generalization to several circuits</h3>

    <p class="text-gray-300">The aggregation strategy from Section 5.1 is easily extended to serve multiple circuits  <span class="math">C_1, \\ldots, C_L</span>  simultaneously. This 'cross-circuit' generalization is especially useful in 'non-homogeneous' chemes which are composed by a variety of recursive circuits. Lets assume that the R1CS matrices  <span class="math">A_i, B_i, C_i</span>  of the circuits  <span class="math">C_i</span> ,  <span class="math">i = 1, \\ldots, L</span> , are padded to the same square dimension so that we may regard their</p>

    <div class="my-4 text-center"><span class="math-block">A_i(X,Y), B_i(X,Y), C_i(X,Y),</span></div>

    <p class="text-gray-300">as bivariate polynomials over the same domain  <span class="math">H \\times H</span> . As in the single-circuit setting we leverage the linearity of the commitment scheme and keep track of a single  <span class="math">cross-circuit\\ polynomial</span></p>

    <p class="text-gray-300"><span class="math-block">T_{H}(\\alpha, Y) = \\sum_{i=1}^{L} T_{i, \\vec{\\eta}_{i}}(z, Y) = \\sum_{i=1}^{L} \\sum_{M=A_{i}, B_{i}, C_{i}} \\eta_{M, i} \\cdot M(\\alpha, Y)</span>  (25)</p>

    <p class="text-gray-300">by means of the cross-circuit coefficient vector  <span class="math">H = (\\vec{\\eta}_1, \\vec{\\eta}_2, \\dots, \\vec{\\eta}_L)</span> . The <em>cross-circuit accumulator</em> for the collection  <span class="math">C = \\{C_1, \\dots, C_L\\}</span>  is of the form</p>

    <div class="my-4 text-center"><span class="math-block">acc_{\\mathcal{C}} = (\\alpha, H, C),</span></div>

    <p class="text-gray-300">with  <span class="math">\\alpha \\in F</span> , coefficient vector  <span class="math">H = (\\vec{\\eta}_1, \\dots, \\vec{\\eta}_L) \\in (F^3)^L</span> , and an element C from the commitment group. The corresponding predicate  <span class="math">\\phi_C</span>  is satisfied if and only if C is in fact the dlog commitment of  <span class="math">T_H(\\alpha, Y)</span> , using blinding randomness zero.</p>

    <h2 id="sec-18" class="text-2xl font-bold">5.3 Accumulating the dlog hard parts</h2>

    <p class="text-gray-300">The aggregation strategy for the non-succinct part of the dlog verifier is identical to that in [BCMS20]. The opening proof for the dlog commitment is an inner product argument that uses the folding technique from [BCC+16] to gradually reduce the opening claim on the initial full-length polynomial to one of half the size, until ending up with the opening claim of a single coefficient polynomial. The final committer key  <span class="math">G_f</span>  of the opening proof is a single group element which is the result of a corresponding folding procedure on the full-length committer key of the dlog scheme. It equals the commitment of the succinct reduction polynomial</p>

    <div class="my-4 text-center"><span class="math-block">h(\\vec{\\xi}, X) = \\prod_{i=0}^{k-1} (1 - \\xi_{k-1-i} \\cdot X^{2^i}), \\tag{26}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  $k = \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n<span class="math">  is the number of reduction steps and  </span>\\vec{\\xi} = (\\xi_i)_{i=0}^{k-1}$  their challenges. The dlog accumulator is of the form</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">acc_{dlog} = (\\vec{\\xi}, C),</span></div>

    <p class="text-gray-300">where  <span class="math">\\vec{\\xi} \\in F^k</span>  and C is from the commitment group, and the corresponding accumulator predicate  <span class="math">\\phi_{dlog}</span>  is satisfied if and only if C is the commitment of  <span class="math">h(\\vec{\\xi}, X)</span> , using blinding randomness zero.</p>

    <p class="text-gray-300">As Protocol 2, the aggregation strategy is regarded as a subprotocol of the complete recursive argument Protocol 4, and for efficiency reasons we reuse the challenge  <span class="math">\\gamma</span>  from the inner sumcheck aggregation. We again restrict to the case of a single previous accumulator.</p>

    <p class="text-gray-300"><span id="page-15-2"></span><strong>Protocol 3</strong> (dlog hard parts aggregation). Suppose that  <span class="math">acc&#x27;_{dlog} = (\\vec{\\xi}&#x27;, [h&#x27;(X)])</span>  is a previous dlog accumulator, with [h'(X)] representing an oracle for  <span class="math">h&#x27;(X) = h(\\vec{\\xi}&#x27;, X)</span> . The following step is part of the complete recursive argument and processed immediately after Protocol 2:</p>

    <p class="text-gray-300">(1) The verifier queries [h'(X)] at for its value v' at  <span class="math">X = \\gamma</span>  from step (2) of Protocol 2.</p>

    <p class="text-gray-300">If  <span class="math">v&#x27; = h(\\vec{\\xi}&#x27;, \\gamma)</span>  then the verifier accepts. The new accumulator  <span class="math">acc&#x27;&#x27;_{dlog} = (\\vec{\\xi}&#x27;&#x27;, C&#x27;&#x27;)</span>  is the one from the dlog opening proof at the end of the complete protocol.</p>

    <h2 id="sec-19" class="text-2xl font-bold">5.4 The main recursive argument</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The complete recursive argument is a composition of Coboundary Marlin's outer sumcheck for the 'current' circuit, choosing 'zero-knowledge bound' b = 1, the aggregation rounds from the cross-circuit variant of Protocol 2, and Protocol 3. As in Section 5.2 we assume that the bivariate circuit polynomials  <span class="math">A_i(X,Y)</span> ,  <span class="math">B_i(X,Y)</span> ,  <span class="math">C_i(X,Y)</span>  are over the same domain  <span class="math">H \\times H</span> , where</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The query phases of these subprotocols are gathered at the end of the protocol, which is then concluded by the batch evaluation argument from [BDFG20].</p>

    <p class="text-gray-300">We formulate the complete argument with oracles for polynomials replaced by their dlog commitments, while keeping with the same notation [p(X)]. For simplicity, we again restrict to the case of a single previous accumulator. The general case is straight-forward.</p>

    <p class="text-gray-300"><span id="page-16-0"></span><strong>Protocol 4</strong> (Complete recursive argument). Given a composed accumulator  <span class="math">acc&#x27; = (acc&#x27;_{\\mathcal{C}}, acc&#x27;_{dlog})</span> , where  <span class="math">acc_{\\mathcal{C}} = (\\alpha&#x27;, H&#x27;, C&#x27;_{T})</span>  is a cross-circuit accumulator for the collection  <span class="math">\\mathcal{C} = \\{\\mathcal{C}_1, \\ldots, \\mathcal{C}_L\\}</span>  and  <span class="math">acc&#x27;_{dlog} = (\\vec{\\xi}, C&#x27;)</span>  is a dlog accumulator. The recursive argument for an instance (x, w) of the 'current' circuit  <span class="math">\\mathcal{C}_k</span>  from  <span class="math">\\mathcal{C}</span>  is composed by the following steps.</p>

    <p class="text-gray-300">(1) Intitialization for  <span class="math">C_k</span> : The prover computes the gauged witness polynomial w(X),  <span class="math">z_A(X)</span> , and  <span class="math">z_B(X)</span>  from  <span class="math">F[X]/(X^n - 1)</span>  and chooses random representants</p>

    <div class="my-4 text-center"><span class="math-block">\\hat{w}(X), \\hat{z}_A(X), \\hat{z}_B(X) \\in F^{&lt; n+1}[X]</span></div>

    <p class="text-gray-300">as described in Section 4. It sends their dlog commitments  <span class="math">[\\hat{w}(X)]</span> ,  <span class="math">[\\hat{z}_A(X)]</span> , and  <span class="math">[\\hat{z}_B(X)]</span>  to the verifier, who responds with  <span class="math">\\eta, \\alpha \\leftarrow sF</span> .</p>

    <p class="text-gray-300">(2) Outer sumcheck for  <span class="math">C_k</span> : The prover computes</p>

    <div class="my-4 text-center"><span class="math-block">T_{\\vec{\\eta}}(\\alpha, X) = \\eta_A \\cdot A(\\alpha, X) + \\eta_B \\cdot B(\\alpha, X) + \\eta_C \\cdot C(\\alpha, X) \\in F[Y]/(X^n - 1)</span></div>

    <p class="text-gray-300">of the current circuit, using  <span class="math">\\vec{\\eta} = (\\eta_A, \\eta_B, \\eta_C) = (1, \\eta, \\eta^2)</span> , and</p>

    <div class="my-4 text-center"><span class="math-block">\\hat{U}_1(X) \\in F^{&lt; n+2}[Y], h_1(X) \\in F^{&lt; 2 \\cdot n+1}[X]</span></div>

    <p class="text-gray-300">subject to the outer sumcheck identity (22). It sends  <span class="math">[T_{\\vec{\\eta}}(\\alpha, X)]</span> ,  <span class="math">[\\hat{U}_1(X)]</span> ,  <span class="math">[h_1(X)]</span>  to the verifier, who returns another random challenge  <span class="math">\\beta \\leftarrow F</span> .</p>

    <p class="text-gray-300">(3) Inner sumcheck aggregation, Step 1: The prover computes the 'bridging' polynomials for</p>

    <div class="my-4 text-center"><span class="math-block">T_{\\vec{\\eta}}(X,\\beta), T_{H&#x27;}(X,\\beta) \\in F[X]/(X^n-1),</span></div>

    <p class="text-gray-300">and sends  <span class="math">[T_{\\vec{\\eta}}(X,\\beta)], [T_{H&#x27;}(X,\\beta)]</span>  to the verifier, who answers with another random  <span class="math">\\lambda, \\gamma \\leftarrow F</span> .</p>

    <p class="text-gray-300">(4) Inner sumcheck aggregation, Step 2: The prover computes the cross-circuit linear combination</p>

    <div class="my-4 text-center"><span class="math-block">T_{H&#x27;&#x27;}(\\gamma,Y) = T_{\\vec{\\eta}}(\\gamma,Y) + \\lambda \\cdot T_{H&#x27;}(\\gamma,Y) \\in F[Y]/(Y^n-1),</span></div>

    <p class="text-gray-300">and  <span class="math">[T_{H&#x27;&#x27;}(\\gamma, Y)]</span>  to the verifier.</p>

    <p class="text-gray-300">After these steps, both prover and verifier engage in the batch evaluation argument from [BDFG20] for the dlog commitment scheme, applied to the queries as listed below. If the queried values pass the checks of the outer sumcheck, Protocol 2 and Protocol 3, and if  <span class="math">(acc&#x27;_{\\mathcal{C}}, acc&#x27;_{dlog})</span>  match with the public input x of the circuit, then the verifier accepts. The new accumulator is  <span class="math">acc&#x27;&#x27; = (acc&#x27;&#x27;_{\\mathcal{C}}, acc&#x27;&#x27;_{dlog})</span>  with<sup>7</sup></p>

    <div class="my-4 text-center"><span class="math-block">acc_{\\mathcal{C}}^{&quot;} = (\\gamma, H^{&quot;}, C^{&quot;}) = (\\gamma, \\vec{\\eta} \\cdot \\delta_k + \\lambda \\cdot H^{\\prime}, [T_{H^{&quot;}}(\\gamma, Y)]),</span></div>

    <p class="text-gray-300">and  <span class="math">acc&#x27;&#x27;_{dlog} = (\\vec{\\xi}, G_f)</span>  from the above batch evaluation proof.</p>

    <p class="text-gray-300">The multi-point queries to be proven by the batch evaluation argument are as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">[\\hat{w}(X)], [\\hat{z}_A(X)], [\\hat{z}_B(X)], [\\hat{U}_1(X)], [h_1(X)], [T_{\\bar{\\eta}}(\\alpha, X)]</span>  at  <span class="math">\\beta</span> , as well as  <span class="math">[\\hat{U}_1(X)]</span>  at  <span class="math">g \\cdot \\beta</span> ,</li>

      <li><span class="math">[T_{\\vec{\\eta}}(X,\\beta)]</span>  at  <span class="math">\\alpha</span> ,  <span class="math">[T_{H&#x27;}(X,\\beta)]</span>  at  <span class="math">\\alpha&#x27;</span> , and  <span class="math">[T_{H&#x27;&#x27;}(\\gamma,Y)]</span> ,  <span class="math">C&#x27;_T</span>  from  <span class="math">acc&#x27;_C</span>  at  <span class="math">\\beta</span> ,</li>

      <li><span class="math">[T_{\\vec{\\eta}}(X,\\beta)] + \\lambda \\cdot [T_{H&#x27;}(X,\\beta)]</span>  at  <span class="math">\\gamma</span> , and C' from  <span class="math">acc&#x27;_{dlog}</span>  at  <span class="math">\\gamma</span> .</li>

    </ul>

    <p class="text-gray-300">For the sake of completeness we summarize the batch evaluation argument in Section A.8.</p>

    <p class="text-gray-300">The following theorem states that the main recursive argument, i.e. Protocol 4 extended by the predicate check on  <span class="math">acc_{\\mathcal{C}}&#x27;&#x27;</span> , is a zero-knowledge argument of knowledge. We point out that we use the Halevi-Micali [HM98] notion of proof of knowledge for negligible soundness error, see Definition 4 and Defintion 5.</p>

    <p class="text-gray-300"><span id="page-17-0"></span><strong>Theorem 2.</strong> If the dlog commitment scheme is computationally binding (Definition 8) then Protocol 4, extended by the predicate verification on the resulting inner sumcheck accumulator  <span class="math">acc_{\\mathcal{C}}&#x27;&#x27;</span> , is a perfectly honest verifier zero-knowledge (Definition 6) argument of knowledge (Definition 5) for the relation</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R} = \\left\\{ ((\\mathcal{C}, acc&#x27;_{\\mathcal{C}}, acc&#x27;_{dlog}, x), w) : (x, w) \\in R_{\\mathcal{C}_k} \\land \\phi(acc&#x27;_{\\mathcal{C}}) = 1 \\right.$$ $$\\land \\phi_{dlog}(acc&#x27;_{dlog}) = 1 \\land (acc&#x27;_{\\mathcal{C}}, acc&#x27;_{dlog}) \\text{ is consistent with } x \\right\\},</span></div>

    <p class="text-gray-300">where  <span class="math">C = \\{C_1, \\ldots, C_L\\}</span>  is a collection of rank-one constraint systems. Here,  <span class="math">R_{C_k}</span>  denotes the R1CS relation given by the circuit  <span class="math">C_k</span> , and  <span class="math">\\phi</span>  and  <span class="math">\\phi_{dlog}</span>  are as in Section 5.2 and Section 5.3</p>

    <p class="text-gray-300">The proof of Theorem 2 is given in Section A.4. In practice we use the Fiat-Shamir transform to turn Protocol 4 into a non-interactive argument of knowledge which is zero-knowledge against arbitrary polynomial time adversaries.</p>

    <p class="text-gray-300"><span id="page-17-1"></span><sup>&</sup>lt;sup>7</sup>Here,  <span class="math">\\vec{\\eta} \\cdot \\delta_k</span>  denotes the vector which is  <span class="math">\\vec{\\eta}</span>  at the position of the current circuit  <span class="math">C_k</span>  in the cross-circuit accumulator, and zero elsewhere.</p>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">5.5 A note on performance</h4>

    <p class="text-gray-300">Inner sumcheck aggregation is particularly effective when the number of previous accumulators is low, as seen from the operations counts in Table 3. For a single previous accumulator ( <span class="math">\\ell=1</span> ) representing the case of linear recursion, the prover effort for the recursive argument is comparable to that of standard Marlin for a circuit of R1CS density d=1. Having  <span class="math">\\ell=4</span>  previous accumulators, as in our Darlin PCD scheme, the equivalent density is about d=1.5.</p>

    <p class="text-gray-300"><span id="page-18-2"></span>Table 3: Recursion prover with and without inner sumcheck aggregation in terms of FFT operations and multi-scalar multiplications, for in-degree  <span class="math">\\ell</span>  (without opening proof).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">polynomial arith.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">commit</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">intial round</td>

            <td class="px-3 py-2 border-b border-gray-700">3  FFT(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">3 MSM(n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">outer sumcheck</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math"> \\begin{array}{c} 2 \\text{ FFT}(n) + 2 \\text{ FFT}(2n) \\\\ +3 \\text{ FFT}(3n) \\end{array} </span></td>

            <td class="px-3 py-2 border-b border-gray-700">2 MSM(n) + 1 MSM(2n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">aggregation rounds</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">(4+\\ell) \\ FFT(n)</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">(2+\\ell) MSM(n)</span></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">overall</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\approx (15 + \\ell) \\cdot FFT(n)</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\approx (9 + \\ell) MSM(n)</span></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">without aggregation</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\approx (15 + 5 \\cdot d) \\text{ FFT}(n)</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\approx (7 + 4 \\cdot d) MSM(n)</span></td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Compared to a standard Marlin prover for circuits with density d=2 the performance improvement is estimated at 27%, as indicated by our estimates from Table 1 in Section 1. The timing estimates from this table are based on a detailed simulation of a Darlin prover (in terms of MSM, FFT, vector and vector-matrix operations), run on an Amazon EC2 G4dn instance (with 4 Intel Xeon@2.5 GHz and 1 NVIDIA T4) currently offered at a rate of 0.526 USD per hour. The number of constraints for verifying two previous proofs stem from detailed paper-and-pencil counts, where our circuit design follows the 'deferred arithmetics' technique from [BGH19], which postpones non-native arithmetic checks to the 'next' circuit in recursion, in which these operations are again native. (We moreover apply their endomorphism-based scalar multiplication which reduces the number of constraints significantly.) We vary over different segment sizes for the dlog commitment scheme (cf. Section A.9 on segmentation of homomorphic polynomial commitment schemes) starting with the smallest possible domain size  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^{19}<span class="math">  to cover the two verifier, and then reducing the committer key to  </span>2^{18}<span class="math">  and  </span>2^{17}$ . Consequently, the prover times decrease at the cost of increasing proof sizes and the number of constraints for the verifier circuit.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">6 Future work</h4>

    <p class="text-gray-300">We will implement Darlin as the recursive main argument of our upcoming Darlin proof carrying data suite [HB21], using a 2-cycle of ordinary elliptic</p>

    <p class="text-gray-300">curves such as the Pasta curves [\\[HBG\\]](#page-21-8). The full suite will cover pure proof merging nodes (for in-degree 1 and 2) as well as special purpose nodes with additional consensus specific logic. Beyond that a separate transformation chain of arguments for converting Darlin proofs into ordinary Marlin proofs will be provided. A formal description, including an in-depth security analysis will be given in [\\[HB21\\]](#page-21-11).</p>

    <p class="text-gray-300">The first author is indebted to Maus and Bowie for their appreciated feedback. Without them, the main recursive argument would miss its most important feature, the whisker feedback loop in the cross-meal aggregation of fish, chicken and beef. One of the first readers is also grateful to Peperita, that helped moving away from pairings in exchange for tasty kibble.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">Bibliography</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-19-1"></span>[BBB<sup>+</sup> 18] Benedikt Bünz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Greg Maxwell. Bulletproofs: Short proofs for confidential transactions and more. In in IEEE Symposium on Security and Privacy, pages 315–334, 2018.</li>

      <li><span id="page-19-7"></span>[BBCGI19] Dan Boneh, Elette Boyle, Henry Corrigan-Gibbs, and Yuval Ishai. Zero-knowledge proofs on secret-shared data via fully linear pcps. In CRYPTO 2019, volume 11694 of LNCS, pages 67–97. Springer, 2019. full version:<https://eprint.iacr.org/2019/188.pdf>.</li>

      <li><span id="page-19-0"></span>[BCC<sup>+</sup> 16] Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe Petit. Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In M. Fischlin and J.S. Coron, editors, EUROCRYPT 2016, volume 9666 of LNCS. Springer, 2016. Full version: <a href="https://eprint.iacr.org/2016/263">https://eprint.iacr.org/2016/</a> <a href="https://eprint.iacr.org/2016/263">263</a>.</li>

      <li><span id="page-19-5"></span>[BCCT13] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. Recursive composition and bootstrapping for SNARKs and proofcarrying data. In STOC'13, 2013.</li>

      <li><span id="page-19-6"></span>[BCL<sup>+</sup> 20] Benedikt Bünz, Alessandro Chiesa, William Lin, Pratyush Mishra, and Nicholas Spooner. Proof-carrying data without succinct arguments. In IACR preprint archive 2020/1618, 2020. <a href="https://eprint.iacr.org/2020/1618">https:</a> <a href="https://eprint.iacr.org/2020/1618">//eprint.iacr.org/2020/1618</a>.</li>

      <li><span id="page-19-4"></span>[BCMS20] Benedikt Bünz, Alessandro Chiesa, Pratyush Mishra, and Nicholas Spooner. Proof-carrying data from accumulation schemes. In IACR preprint archive 2020/499, 2020. <a href="https://eprint.iacr.org/2020/499">https://eprint.iacr.</a> <a href="https://eprint.iacr.org/2020/499">org/2020/499</a>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-20-2"></span>[BDFG20] Dan Boneh, Justin Drake, Ben Fisch, and Ariel Gabizon. Halo Infinite: recursive zk-snarks from any additive polynomial commitment scheme. In IACR preprint archive 2020/1536, 2020. <https://eprint.iacr.org/2020/1536>.</li>

      <li><span id="page-20-1"></span>[BGH19] Sean Bowe, Jack Grigg, and Daira Hopwood. Recursive proof composition without a trusted setup. In IACR preprint archive 2019/1021, 2019. <https://eprint.iacr.org/2019/1021>.</li>

      <li><span id="page-20-7"></span>[BLH<sup>+</sup> ] Sean Bowe, Ying Tong Lai, Daira Hopwood, Jack Grigg, and Steven Smith. Halo 2. <https://github.com/zcash/halo2>.</li>

      <li><span id="page-20-9"></span>[BMRS20] Joseph Bonneau, Izaak Meckler, Vanishree Rao, and Evan Shapiro. Coda: Decentralized cryptocurrency at scale. In IACR preprint archive 2020/352, 2020. <https://eprint.iacr.org/2020/352>.</li>

      <li><span id="page-20-4"></span>[BSCR<sup>+</sup> 19] Eli Ben-Sasson, Alessandro Chiesa, Michael Riabzev, Nicholas Spooner, Madars Virza, and Nicholas P. Ward. Aurora: Transparent succinct arguments for R1CS. In Y. Ishai and Vincent Rijmen, editors, EUROCRYPT 2019, volume 11476 of LNCS. Springer, 2019.</li>

      <li><span id="page-20-6"></span>[CCW18] Alessandro Chiesa, Lyn Chua, and Matthew Weidner. On cycles of pairing-friendly elliptic curves. In SIAM Journal on Applied Algebra and Geometry, volume 3(2), 2018.</li>

      <li><span id="page-20-10"></span>[CFF<sup>+</sup> 20] Matteo Campanelli, Antonio Faonio, Dario Fiore, Anaï s Querol, and Hádrian Rodríguez. Lunar: a toolbox for more efficient and updatable zkSNARKs and commit-and-prove extensions. In IACR preprint archive 2020/1069, 2020. <a href="https://eprint.iacr.org/2020/1069">https://eprint.iacr.org/</a> <a href="https://eprint.iacr.org/2020/1069">2020/1069</a>.</li>

      <li><span id="page-20-0"></span>[CHM<sup>+</sup> 20] Alessandro Chiesa, Yuncong Hu, Mary Maller, Pratyush Mishra, Noah Vesely, and Nicholas Ward. Marlin: Preprocessing zk-SNARKs with universal and updatable SRS. In EUROCRYPT 2020, volume 12105 of LNCS, 2020.</li>

      <li><span id="page-20-5"></span>[CT10] Alessandro Chiesa and Eran Tromer. Proof-carrying data and hearsay arguments from signature cards. In ICS'10. Tsinghua University Press, 2010.</li>

      <li><span id="page-20-3"></span>[GGPR13] Rosario Gennaro, Craig Gentry, Brian Parno, and Mariana Raykova. Quadratic span programs and succinct NIZKs without PCPs. In Nguyen P.Q., editor, EUROCRYPT 2013, volume 7881 of LNCS. Springer, 2013.</li>

      <li><span id="page-20-8"></span>[GKO20] Alberto Garoffolo, Dmytro Kaidalov, and Roman Oliynykov. Zendoo: a zk-SNARK verifiable cross-chain transfer protocol enabling decoupled and decentralized sidechains. In IACR preprint archive 2020/123, 2020. <https://eprint.iacr.org/2020/123>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-21-10"></span>[GKR<sup>+</sup> 21] Lorenzo Grassi, Dmitry Khovratovich, Christian Rechberger, Arnab Roz, and Markus Schofnegger. POSEIDON: A new hash function for zero-knowledge proof systems. In USENIX Security Symposium 2021, 2021.</li>

      <li><span id="page-21-2"></span>[GM17] Jens Groth and Mary Maller. Snarky Signatures: Minimal signatures of knowledge from simulation-extractable snarks. In Shacham H. Katz J., editor, CRYPTO 2017, volume 10402 of LNCS. Springer, 2017.</li>

      <li><span id="page-21-0"></span>[Gro10] Jens Groth. Short pairing-based non-interactive zero-knowledge arguments. In Abe M., editor, ASIACRYPT 2010, volume 6477 of LNCS. Springer, 2010.</li>

      <li><span id="page-21-1"></span>[Gro16] Jens Groth. On the size of pairing-based non-interactive arguments. In M. Fischlin and J.S. Coron, editors, EUROCRYPT 2016, volume 9666 of LNCS. Springer, 2016.</li>

      <li><span id="page-21-5"></span>[GS19] Aurore Guillevic and Shashank Singh. On the alpha value of polynomials in the tower number field sieve algorithm. In <a href="https://hal.inria.fr/hal-02263098">https:</a> <a href="https://hal.inria.fr/hal-02263098">// hal. inria. fr/ hal-02263098</a> , 2019.</li>

      <li><span id="page-21-7"></span>[Gui20] Aurore Guillevic. A note on MNT4 and MNT6 curves: Estimation of STNFS cost. (personal communication), 2020.</li>

      <li><span id="page-21-4"></span>[GWC19] Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru. PLONK: Permutations over Lagrange-bases for oecumenical noninteractive arguments of knowledge. In IACR preprint archive 2019/953, 2019. <https://eprint.iacr.org/2019/953>.</li>

      <li><span id="page-21-11"></span>[HB21] Ulrich Haböck and Daniele Di Benedetto. The Darlin proof carrying data protocol suite. in preparation, 2021.</li>

      <li><span id="page-21-8"></span>[HBG] Daira Hopwood, Sean Bowe, and Jack Grigg. The Pasta Curves for Halo 2 and beyond. <a href="https://electriccoin.co/blog/the-pasta-curves-for-halo-2-and-beyond/">https://electriccoin.co/blog/</a> <a href="https://electriccoin.co/blog/the-pasta-curves-for-halo-2-and-beyond/">the-pasta-curves-for-halo-2-and-beyond/</a>.</li>

      <li><span id="page-21-9"></span>[HM98] Shai Halevi and Silvio Micali. More on proofs of knowledge. In IACR preprint archive 1998/015, 1998. Appeared in the THEORY OF CRYPTOGRAPHY LIBRARY and has been included in the ePrint Archive. <https://eprint.iacr.org/1998/015>.</li>

      <li><span id="page-21-3"></span>[MBKM19] Mary Maller, Sean Bowe, Markulf Kohlweiss, and Sarah Meiklejohn. Sonic: Zero-knowledge SNARKs from linear-size universal and updatable structured reference strings. In ACM SIGSAC Conference on Computer and Communication Security, pages 2111– 2128, 2019.</li>

      <li><span id="page-21-6"></span>[Ol] O1-labs. Mina Protocol. <https://minaprotocol.com>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-22-3"></span>[PHGR13] Bryan Parno, Jon Howell, Craig Gentry, and Mariana Raykova. Pinocchio: Nearly practical verifiable computation. In <em>in IEEE Symposium on Security and Privacy</em>, pages 238–252, 2013.</li>

      <li><span id="page-22-4"></span>[SS11] Joseph H. Silverman and Katherine E. Stange. Amicable pairs and aliquot cycles for elliptic curves. In <em>Experimental Mathematics</em>, volume 20(3), 2011.</li>

      <li><span id="page-22-5"></span>[WTS+18] R. S. Wahby, I. Tzialla, A. Shelat, J. Thaler, and M. Walfish. Doubly-efficient zk-SNARKs without trusted setup. In 2018 IEEE Symposium on Security and Privacy (SP), pages 926–943, 2018.</li>

    </ul>

    <h3 id="sec-24" class="text-xl font-semibold mt-8">A Appendix</h3>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">A.1 Notation</h4>

    <p class="text-gray-300">We denote the security parameter by  <span class="math">\\lambda</span> , where we throughout consider it in unary representation. A function  <span class="math">f(\\lambda)</span>  is negligible if for every polynomial  <span class="math">p(\\lambda)</span> , it holds that  <span class="math">\\lim_{\\lambda\\to\\infty} f(\\lambda) \\cdot p(\\lambda) = 0</span> , or in short  <span class="math">f(\\lambda) = o(1/p(\\lambda))</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Probabilistic algorithms are denoted by capital letters A, B, etc., and we write  <span class="math">y \\leftarrow A(x)</span>  if an algorithm A ouputs a string y given an input string x while using some internal random coins x uniformly sampled from  <span class="math">\\{0,1\\}^*</span> . Whenever we need to refer to the used random coins x, we shall explicitly write y = A(x; r). We say that A is probabilistic polynomial time (p.p.t.), if its run time  <span class="math">T_{x,r}</span>  on input x and internal random coins x is bounded by some fixed polynomial p(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) independent of the random coins, where</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">denotes the length of its input. We say that A is expected polynomial time if the expected run time  <span class="math">E(T_{x,r})</span> , where the expectation is taken over all random coins x, is bounded by some polynomial in the length of the input. The interaction of two interactive probabilistic algorithms A and B is denoted (A, B), where we explicitly clarify what are the inputs and outputs of both algorithms.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">A.2 Interactive arguments</h3>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{R}</span>  be a polynomial time decidable binary relation. An interactive argument system for  <span class="math">\\mathcal{R}</span>  consists of three probabilistic polynomial time algorithms</p>

    <p class="text-gray-300">(Setup, Prove, Vf).</p>

    <p class="text-gray-300">Given the security parameter  <span class="math">\\lambda</span>  in unary representation,  <span class="math">\\mathsf{Setup}(\\lambda)</span>  outputs a common reference string crs which supports all statement-witness pairs (x, w) up to a certain maximum length  <span class="math">N = N(\\lambda)</span> , which we write in short  <span class="math">(x, w) \\in \\mathcal{R}_N</span> . Given  <span class="math">(x, w) \\in \\mathcal{R}_N</span> , the algorithms Prove and Vf are used to interactively reason about whether x belongs to the language defined by  <span class="math">\\mathcal{R}</span>  or not. We denote their interaction by  <span class="math">tr \\leftarrow \\langle \\mathsf{Prove}(x, w), \\mathsf{Vf}(x) \\rangle</span>  with tr as the transcript</p>

    <p class="text-gray-300">of the interaction, and we assume that both algorithms have access to the crs without explicitly declaring them as inputs. After at most polynomially many steps the verifier accepts or rejects, and we say that tr is accepting or rejecting.</p>

    <p class="text-gray-300"><strong>Definition 3</strong> (Perfect completeness). An interactive argument system (Setup, Prove, Vf) satisfies <em>perfect completeness</em> if</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr\\left[ \\begin{array}{l} \\langle \\mathsf{Prove}(x,w), \\mathsf{Vf}(x) \\rangle \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathit{crs} \\leftarrow \\mathsf{Setup}(\\lambda), \\\\ (x,w) \\leftarrow \\mathcal{A}(\\lambda), \\text{ with } \\\\ (x,w) \\in \\mathcal{R}_N \\end{array} \\right] = 1.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We define knowledge-soundness in the style of [HM98]. However we do not dwell on the structure or the message distribution of the blackbox extractor. The reason for this choice of definition is the modularity of our proof of Theorem 2, which refers to the security result on the batch evaluation argument from [BDFG20].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-23-3"></span><strong>Definition 4</strong> (Knowledge-soundness). An interactive argument system (Setup, Prove, Vf) for the relation  <span class="math">\\mathcal{R}</span>  is <em>knowledge sound</em> if for every x from  <span class="math">\\mathcal{L}_{\\mathcal{R}}</span>  and every adversary  <span class="math">\\mathcal{A}</span>  which makes  <span class="math">\\langle \\mathcal{A}, \\mathsf{Vf}(x) \\rangle</span>  accept with non-negligible probability  <span class="math">\\varepsilon(x) &gt; \\mathsf{negl}(\\lambda)</span> , there is a strict polynomial time algorithm  <span class="math">\\mathcal{E} = \\mathcal{E}^{\\mathcal{A}}</span>  with blackbox access to  <span class="math">\\mathcal{A}</span>  which does at most  $\\mathsf{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\lambda)/\\mathsf{poly}(\\varepsilon)<span class="math">  calls, and overwhelmingly outputs a witness w such that  </span>(x, w) \\in \\mathcal{R}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-23-1"></span><strong>Definition 5.</strong> We say that an interactive argument system (Setup, Prove, Vf) is an <em>argument of knowledge</em>, if it is perfectly complete and knowledge sound as defined above. It is said to be <em>succinct</em>, if the size of the transcript is sublinear in the size of  <span class="math">(x, w) \\in \\mathcal{R}</span> .</p>

    <p class="text-gray-300">As we do not require any trust assumptions for the setup, our definition of zero-knowledge does not make use of trapdoors.</p>

    <p class="text-gray-300"><span id="page-23-2"></span><strong>Definition 6</strong> (Perfect honest verifier zero-knowledge). An interactive argument system (Setup, Prove, Vf) is <em>perfect honest verifier zero-knowledge</em> if there is a p.p.t. algorithm Sim such that for every p.p.t. algorithm  <span class="math">\\mathcal{A}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\begin{bmatrix} (x,w) \\in \\mathcal{R}_N &amp; crs \\leftarrow \\mathsf{Setup}(\\lambda), \\\\ \\wedge &amp; (x,w) \\leftarrow \\mathcal{A}(crs), \\\\ A(tr&#x27;) = 1 &amp; tr&#x27; \\leftarrow \\mathsf{Sim}(crs,x) \\end{bmatrix}</span></div>

    <div class="my-4 text-center"><span class="math-block">= \\Pr \\begin{bmatrix} (x,w) \\in \\mathcal{R}_N &amp; crs \\leftarrow \\mathsf{Setup}(\\lambda), \\\\ \\wedge &amp; (x,w) \\leftarrow \\mathcal{A}(crs), \\\\ \\mathcal{A}(tr) = 1 &amp; tr \\leftarrow (\\mathsf{Prove}(x,w), \\mathsf{Vf}(x)) \\end{bmatrix}.</span></div>

    <h4 id="sec-27" class="text-lg font-semibold mt-6">A.3 Forking Lemmas</h4>

    <p class="text-gray-300">We use the forking Lemma from  <span class="math">[BCC^+16]</span>  and we obtain strict polynomial time of the sampling algorithm by truncation. Assume that (Setup, Prove, Vf)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">is an (2r+1)-move public-coin argument, by which we mean that in each round the verifier messages are chosen uniformly at random from a sample space S. Given a transcript tr resulting from the interaction of  <span class="math">\\mathcal{A}(\\cdot)</span>  with the verifier  <span class="math">\\mathsf{Vf}(crs,x)</span> , we denote by  $tr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\leq i}<span class="math"> , with  </span>i=0,\\ldots,r<span class="math"> , the partial transcript consisting of the prover and verifier messages of the first 2i+1 moves. An  </span>(n_1,\\ldots,n_r)<span class="math"> -tree of accepting transcripts is a tree of depth r which is rooted in a prover&#x27;s first message  </span>tr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\leq 0}<span class="math">  and in which each node at level  </span>i \\in \\{0,\\ldots,r-1\\}<span class="math">  represents a partial transcript  </span>tr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\leq i-1}<span class="math">  and has exactly  </span>n_i<span class="math">  children nodes extending this transcript. The tree has overall  </span>K(\\lambda) = \\prod_{i=1}^r n_i<span class="math">  leafs standing for complete transcripts in which the verifier eventually accepts. We assume that the size of S grows superpolynomially in  </span>\\lambda$ , so that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr[x_1 \\neq x_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_1, x_2 \\leftarrow S] > 1 - \\mathsf{negl}(\\lambda).$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-24-0"></span><strong>Lemma 2</strong> ([BCC<sup>+</sup>16]). Let (Setup, Prove, Vf) be a (2r+1)-move public-coin interactive proof, and  <span class="math">\\mathcal{A}</span>  a p.p.t. adversary which runs in expected time  <span class="math">t_{\\mathcal{A}}</span>  and succeeds  <span class="math">\\langle \\mathcal{A}(\\,\\cdot\\,), \\mathsf{Vf}(crs,x) \\rangle</span>  with non-negligible probability  <span class="math">\\varepsilon = \\varepsilon(x)</span>  on public input x. If  <span class="math">n_1, \\ldots, n_r \\geq 2</span>  are such that  <span class="math">K(\\lambda) = \\prod_{i=1}^r n_i</span>  is polynomially bounded, then there exists a p.p.t. algorithm  <span class="math">\\mathcal{T}</span>  that calls the next message function of  <span class="math">\\mathcal{A}</span>  at most  <span class="math">2 \\cdot K(\\lambda)/\\varepsilon</span>  times and with non-negligible probability  <span class="math">\\varepsilon/2</span>  outputs an  <span class="math">(n_1, \\ldots, n_r)</span> -tree of accepting transcripts in which all pairs of sibling-node challenges  <span class="math">x_1, x_2</span>  are subject to  <span class="math">x_1 \\neq x_2</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For the sake of completeness we shortly sketch the construction of  <span class="math">\\mathcal{T}</span>  as claimed in Lemma 2. The tree finder algorithm  <span class="math">\\mathcal{T}&#x27;</span>  from [BCC<sup>+</sup>16] is a rejection sampler which is allowed to fail at every first completion of  <span class="math">\\langle \\mathcal{A}, \\mathsf{Vf}(crs, x) \\rangle</span>  on a given partial transcript  $tr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\leq i}$ . It succeeds with probability</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$p_{tr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq i} = \\Pr[\\mathcal{T}' \\text{ completes subtree for } tr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\leq i}]$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=  $\\Pr[\\langle \\mathcal{A}(.), \\mathsf{Vf}(crs, x) \\rangle \\text{ succeeds on } tr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\leq i}].$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and runs in expected polynomial time</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\mathbb{E}[\\# \\text{ of } \\mathcal{A} \\text{ calls given } tr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\leq i}] \\leq n_i \\cdot n_{i+1} \\cdot \\ldots \\cdot n_r.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Overall  <span class="math">\\mathcal{T}&#x27;</span>  is of expected polynomial time calling  <span class="math">\\mathcal{A}</span>  at most  <span class="math">K(\\lambda)</span>  times on average, and  <span class="math">\\mathcal{T}&#x27;</span>  succeeds in producing a complete  <span class="math">(n_1, ..., n_r)</span> -tree of accepting transcript with probability  <span class="math">\\varepsilon</span> . The probability that such a complete tree of accepting transcripts has collisions (i.e. two sibling challenges coincide) is negligible, see the full version of [BCC<sup>+</sup>16]. Finally limiting the run time of  <span class="math">\\mathcal{T}&#x27;</span>  to  <span class="math">2 \\cdot K(\\lambda)/\\varepsilon</span>  calls of  <span class="math">\\mathcal{A}</span>  (and returning  <span class="math">\\bot</span>  in that case) yields a strict polynomial time algorithm which still succeeds with a probability of at least  <span class="math">\\varepsilon/2</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-24-1"></span><strong>Lemma 3</strong> ([BDFG20]). Let  <span class="math">\\delta</span>  be such that  <span class="math">0 &lt; \\delta \\le \\frac{\\varepsilon^2}{8K(\\lambda)}</span> . Then with probability at least  <span class="math">\\varepsilon/4</span>  the tree finding algorithm  <span class="math">\\mathcal{T}</span>  from Lemma 2 outputs a tree of accepting transcripts with the following property: For every partial transcript  $tr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\le i}<span class="math">  of length i in the tree, the conditional success probability for  </span>\\mathcal{A}(.)<span class="math">  continuing the partial transcript  </span>tr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\le i}<span class="math">  is at least  </span>\\delta$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em>Proof.</em> The tree sampler  <span class="math">\\mathcal{T}</span>  from Lemma 2 tests at most  <span class="math">2 \\cdot K(\\lambda)/\\varepsilon</span>  partial transcripts  $tr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\leq i}<span class="math"> . Such transcript succeeds with the probability  </span>p_{tr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\leq i}}<span class="math">  as above. Therefore, the probability that one of these  </span>p_{tr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\leq i}}<span class="math">  is smaller than a given  </span>\\delta<span class="math">  is at most  </span>2 \\cdot K(\\lambda)/\\varepsilon \\cdot \\delta<span class="math"> . Choosing the latter of at most  </span>\\varepsilon/4$  yields the assertion of the lemma.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We note that the factors 1/2 in Lemma 2 and 1/8 in Lemma 3 are arbitrary. Any other choice of these factors  <span class="math">&gt; 1 - 1/\\mathsf{poly}(\\lambda)</span>  is possible.</p>

    <h4 id="sec-28" class="text-lg font-semibold mt-6">A.4 Proof of Theorem 2</h4>

    <p class="text-gray-300">Theorem 2 is subject to Protocol 4, extended by the verification of the resulting  <span class="math">acc&#x27;&#x27; = (\\gamma, H&#x27;&#x27;, [T_{H&#x27;&#x27;}(\\gamma, Y)])</span> . We refer to this extended protocol as the full protocol. The batch evaluation proof Eval is regarded as a subprotocol, and we use knowledge soundness and honest verifier zero-knowledge of it (Theorem 11 and Theorem 10) to infer the same properties for the full protocol.</p>

    <h2 id="sec-29" class="text-2xl font-bold">Knowledge soundness</h2>

    <p class="text-gray-300">Assume maximum degree for the polynomial commitment scheme is  <span class="math">d = \\mathsf{poly}(\\lambda)</span>  with  <span class="math">d \\ge 2 \\cdot n + b</span> . The proof is divided into two steps. In the first one, we special soundness of the algebraic oracle proof. The second step uses the transcript sampler from Lemma 2 to construct a strict polynomial time extractor from the strict polynomial time extractor of the batch evaluation argument.</p>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">Step 1. Special soundness.</h4>

    <p class="text-gray-300">Consider the protocol as an interactive oracle proof where the oracles are guaranteed having a degree of at most  <span class="math">d = \\text{poly}(\\lambda)</span> . Besides the arithmetic checks on the evaluation claims, the verifier checks the oracle for  <span class="math">T_{H&#x27;&#x27;}(\\gamma, Y)</span>  by reading it in full length<sup>8</sup> and compare it against the polynomial described by H'' as computed in the protocol. We claim that this 'algebraic oracle proof' is  <span class="math">(m_1, m_2, m_3, m_4)</span> -special sound, with</p>

    <div class="my-4 text-center"><span class="math-block">(m_1, m_2, m_3, m_4, m_5) = (3, n, 2 \\cdot d + 1, 2, d + 1),</span></div>

    <p class="text-gray-300">in the following sense: Given an  <span class="math">(m_1, m_2, m_3, m_4, m_5)</span> -tree of accepting transcripts with pairwise distinct verifier challenges for  <span class="math">\\eta \\in F, \\alpha, \\beta \\in F \\setminus H, \\lambda \\in F, \\gamma \\in F</span> , respectively, then</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the polynomial in the oracle from  <span class="math">acc&#x27;_{dlog}</span>  is the claimed reduction polynomial  <span class="math">h(\\vec{\\xi}&#x27;, X)</span> ,</li>

      <li>the oracles intended for  <span class="math">T_{H&#x27;}(\\gamma&#x27;, Y)</span>  and  <span class="math">T_{\\eta}(\\alpha, Y)</span>  in fact carry the correct polynomials, and</li>

    </ul>

    <p class="text-gray-300"><span id="page-25-1"></span> <span class="math">&lt;sup&gt;^8&lt;/sup&gt;</span> Equivalently, the verifier may query the oracle at d+1 different points and reconstructs the polynomial from the values.</p>

    <p class="text-gray-300">• the polynomial  <span class="math">y(X) = x(X) + (X^{\\ell} - 1) \\cdot \\hat{w}(X) \\mod (X^n - 1)</span>  with  <span class="math">\\hat{w}(X)</span>  from  <span class="math">[\\hat{w}(X)]</span>  satisfies the R1CS identities (10), (11), (12).</p>

    <p class="text-gray-300">This is true for the following reasons:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">m_1 = 3</span>  pairwise distinct  <span class="math">\\eta_1, \\eta_2, \\eta_3 \\in F</span>  are sufficient to derive the R1CS identities (10), (11), (12) from the 'lincheck' identity (19). (The Vandermonde matrix for different choices of  <span class="math">\\eta</span>  is invertible.)</li>

      <li><span class="math">m_2 = n</span>  pairwise distinct  <span class="math">\\alpha_1, \\ldots, \\alpha_n \\in F \\setminus H</span>  allow inverting the reduction of the lincheck identity (19) to the sumcheck identity (1) by means of the Lagrange kernel. (Recall that the sumcheck is obtained from the lincheck by applying  <span class="math">\\langle L_n(X,\\alpha), . \\rangle</span> . By Lemma 5 the inner products for any n different values of  <span class="math">\\alpha</span>  allow to uniquely reconstruct the lincheck polynomial modulo  <span class="math">(X^n 1)</span> .)</li>

      <li><span class="math">m_3 = 2 \\cdot d + 1</span>  pairwise distinct  <span class="math">\\beta_1, \\ldots, \\beta_{2d+1} \\in F \\setminus H</span>  are sufficient to infer the outer sumcheck identity on the full domain F, as well as the identity for the first step of the inner sumcheck aggregation. (The polynomials are of degree at most d.)</li>

      <li><span class="math">m_4 = 2</span>  distinct  <span class="math">\\lambda_1, \\lambda_2 \\in F</span>  allow for reconstructing the component polynomials from their linear combination  <span class="math">T_{\\vec{\\eta}}(X,\\beta) + \\lambda \\cdot T_{H&#x27;}(X,\\beta)</span>  in the second step of the inner sumcheck aggregation. (Again, since the Vandermonde matrix is invertible.)</li>

      <li>and  <span class="math">m_5 = d+1</span>  pairwise distinct  <span class="math">\\gamma_1, \\ldots, \\gamma_{d+1} \\in F</span>  are sufficient to infer both the correctness of the polynomial behind the linear combination  <span class="math">[T_{\\vec{\\eta}}(X,\\beta)] + \\lambda \\cdot [T_{H&#x27;}(X,\\beta)]</span> , and the polynomial behind the oracle in  <span class="math">acc&#x27;_{dlog}</span> . (Again, all polynomials are of degree at most d.)</li>

    </ul>

    <h4 id="sec-31" class="text-lg font-semibold mt-6">Step 2. Extractor.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose that  <span class="math">\\mathcal{A}</span>  is a probabilistic polynomial time adversary which succeeds the complete verifier with non-negligible probability  <span class="math">\\varepsilon</span>  on given inputs  <span class="math">(\\mathcal{C}, acc&#x27;_{\\mathcal{C}}, acc&#x27;_{dlog}, x)</span> . As  <span class="math">K(\\lambda) = m_1 \\cdot \\ldots \\cdot m_5</span>  is polynomial in  <span class="math">\\lambda</span> , Lemma 2 guarantees a strict polynomial time algorithm  <span class="math">\\mathcal{T}</span>  which calls  <span class="math">\\mathcal{A}</span>  at most  <span class="math">2 \\cdot K(\\lambda)/\\varepsilon = \\text{poly}(\\lambda)</span>  times and succeeds with a non-negligible probability of  <span class="math">\\varepsilon/2</span>  in sampling an  <span class="math">(m_1, m_2, m_3, m_4, m_5)</span> -tree of accepting transcripts as needed for Step 1. Each partial transcript  $tr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{i\\leq 5}<span class="math">  records the messages until and including the sampling of the last verifier challenge  </span>\\gamma<span class="math"> , before entering the batch evaluation protocol Eval. By Lemma 3 we may assume that for each of these partial transcripts  </span>tr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{i\\leq 5}<span class="math"> , the probability that  </span>\\mathcal{A}<span class="math">  succeeds on it is at least  </span>\\delta = \\frac{\\varepsilon^2}{8 \\cdot K(\\lambda)} > \\text{negl}(\\lambda)<span class="math"> . By knowledge-soundness of the batch evaluation argument Eval, there is a strict polynomial time extractor which calls  </span>\\mathcal{A}<span class="math">  at most  </span>\\text{poly}(\\lambda)/\\text{poly}(\\delta)<span class="math">  times on each of the transcripts  </span>tr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{i\\leq 5}<span class="math">  and outputs the witness polynomials from  </span>F^{< d+1}[X]$  (including commitment randomnesses) for</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">[\\hat{w}(X)], [\\hat{z}_A(X)], [\\hat{z}_B(X)], [\\hat{U}_1(X)], [h_1(X)], [T_{\\vec{n}}(\\alpha, X)],</span></li>

      <li><span class="math">[T_{H&#x27;}(\\alpha&#x27;, X)]</span>  from  <span class="math">acc&#x27;_{\\mathcal{C}}</span> , as well as  <span class="math">[T_{\\vec{n}}(X, \\beta)]</span> ,  <span class="math">[T_{H&#x27;}(X, \\beta)]</span> ,</li>

      <li><span class="math">[T_{\\vec{\\eta}}(X,\\beta)] + \\lambda \\cdot [T_{H&#x27;}(X,\\beta)]</span> , and  <span class="math">[h(\\vec{\\xi}&#x27;,X)]</span>  from  <span class="math">acc&#x27;_{dlog}</span> ,</li>

    </ul>

    <p class="text-gray-300">of each of the  <span class="math">(\\eta, \\alpha, \\beta, \\lambda, \\gamma) = (\\eta_{i_1}, \\alpha_{i_2}, \\beta_{i_3}, \\lambda_{i_4}, \\gamma_{i_5})</span>  in the transcript tree. These polynomials have values which pass all the verifier checks of the protocol. Assuming the dlog commitment is computationally binding, the witness polynomials and commitment randomnesses for  <span class="math">[\\hat{w}(X)], [\\hat{z}_A(X)], [\\hat{z}_B(X)], [\\hat{U}_1(X)], [h_1(X)]</span> , as well as the witness polynomials for the accumulator commitments  <span class="math">[T_{H&#x27;}(X,\\beta)], [h(\\vec{\\xi}&#x27;,X)]</span>  overwhelmingly coincide for all the verifier challenges  <span class="math">(\\eta_{i_1},\\alpha_{i_2},\\beta_{i_3},\\lambda_{i_4},\\gamma_{i_5}),</span>  and for the same reason the polynomials for  <span class="math">[T_{\\bar{\\eta}}(\\alpha,X)]</span>  do not depend on  <span class="math">(\\beta_{i_3},\\lambda_{i_4},\\gamma_{i_5})</span> . Hence if we replace the commitments by these polynomials we obtain an  <span class="math">(m_1,m_2,m_3,m_4,m_5)</span> -tree of accepting transcripts as needed for Step 1 to conclude that  <span class="math">y(X) = x(X) + (X^{\\ell} - 1) \\cdot \\hat{w}(X) \\mod (X^n - 1)</span>  satisfies the R1CS identities for  <span class="math">\\mathcal{C}_k</span> , and both  <span class="math">acc_T&#x27;</span>  and  <span class="math">acc_{dlog}&#x27;</span>  are correct. The overall run-time of the extractor is strictly bounded by  <span class="math">K(\\lambda) \\cdot \\operatorname{poly}(\\lambda)/\\operatorname{poly}(\\delta) = \\operatorname{poly}(\\lambda)/\\operatorname{poly}(\\varepsilon)</span>  and succeeds with a non-negligible probability of at least  <span class="math">\\varepsilon/4</span> . By amplification we obtain the claimed extractor for knowledge-soundness.</p>

    <h4 id="sec-32" class="text-lg font-semibold mt-6">Zero-knowledge</h4>

    <p class="text-gray-300">Perfect honest verifier zero-knowledge of Protocol 4 is an immediate consequence of perfect honest verifier zero-knowledge of the batch evaluation argument (Theorem 11) and the same property for the coboundary outer sumcheck. The latter is obtained from the following auxiliary lemma. The proof of it is straightforward, and we leave it to the reader.</p>

    <p class="text-gray-300"><span id="page-27-0"></span><strong>Lemma 4.</strong> Assume that P follows Protocol 4. Then the conditional distribution of  <span class="math">(v_1, v_2, v_3, v_4, v_5, v_6) = (\\hat{w}(\\beta), \\hat{y}_A(\\beta), \\hat{y}_B(\\beta), \\hat{U}(g \\cdot \\beta), \\hat{U}(\\beta), h(\\beta))</span> , conditional to  <span class="math">(\\eta, \\alpha, \\beta)</span> , is uniform on the relation  <span class="math">\\mathcal{R}_{\\eta, \\alpha, \\beta}</span>  of all  <span class="math">(v_1, v_2, v_3, v_4, v_5, v_6)</span>  satisfying the outer sumcheck equation</p>

    <div class="my-4 text-center"><span class="math-block">T_{\\eta}(\\alpha,\\beta) \\cdot (x(\\beta) + (\\beta^{\\ell} - 1) \\cdot v_1) - L_n(\\beta,\\alpha) \\cdot (v_2 + \\eta \\cdot v_3 + \\eta^2 \\cdot v_2 \\cdot v_3) - v_4 + v_5 = v_6 \\cdot (\\beta^n - 1).</span></div>

    <p class="text-gray-300">Using Lemma 4 the simulator for the outer sumcheck is constructed as follows. Given a consistent previous accumulator  <span class="math">acc&#x27; = (acc&#x27;_{\\mathcal{C}}, acc&#x27;_{dlog})</span>  and any circuit input  <span class="math">x \\in F^{\\ell}</span> , it first samples  <span class="math">\\eta</span>  and  <span class="math">(\\alpha, \\beta)</span>  uniformly from F and  <span class="math">(F \\setminus H)^2</span> , respectively, and  <span class="math">(v_1, v_2, v_3, v_4, v_5, v_6)</span>  uniformly from  <span class="math">\\mathcal{R}_{\\eta,\\alpha,\\beta}</span>  (by choosing  <span class="math">v_1, \\ldots, v_5</span>  uniformly from F and  <span class="math">v_6</span>  as determined by the outer sumcheck equation), and then crafts arbitrary polynomials  <span class="math">\\hat{w}(X)</span> ,  <span class="math">\\hat{y}_A(X)</span> ,  <span class="math">\\hat{y}_B(X)</span> ,  <span class="math">\\hat{U}(X)</span>  and h(X) of degree less than d which evaluate at  <span class="math">X = \\beta</span>  (and  <span class="math">\\hat{U}(X)</span>  also at  <span class="math">X = g \\cdot \\beta</span> ) to the corresponding values. All these polynomials are committed using hiding randomnesses, and the aggregation rounds Step (3) and Step (4) of Protocol 4 are performed as in an honest prover-verifier interaction. Since</p>

    <p class="text-gray-300">the dlog commitment scheme is perfectly hiding, the resulting conversation is identically distributed as in an ordinary honest prover-verifier interaction for Step (1-4). These conversations are completed by calling the simulator for the batch evaluation argument on the collected commitments. Since the latter partial transcripts are identically distributed to an honest prover-verifier interaction, so are the completed conversations.</p>

    <h3 id="sec-33" class="text-xl font-semibold mt-8">A.5 Proof of Theorem 1</h3>

    <p class="text-gray-300">The proof of Theorem 1 is almost identical to that of Theorem 2, hence we only point out the differences. We assume that the indexer polynomial  <span class="math">row_M(X)</span> ,  <span class="math">col_M(X)</span> ,  <span class="math">row.col_M(X)</span>  and  <span class="math">val.row.col_M(X)</span> , M = A, B, C, as defined in Section 4 are verified against their commitments in a precomputation phase of the protocol.</p>

    <p class="text-gray-300">For knowledge-soundness, observe that Coboundary Marlin viewed as an algebraic oracle proof, is  <span class="math">(m_1, m_2, m_3, m_4)</span> -special sound with</p>

    <div class="my-4 text-center"><span class="math-block">(m_1, m_2, m_3, m_4) = (3, n, 2 \\cdot d + 1, 4 \\cdot m - 3).</span></div>

    <p class="text-gray-300">Here,  <span class="math">d = \\mathsf{poly}(\\lambda)</span>  is the maximum degree of the oracle polynomials, n and m are the sizes of the domains H and K, and  <span class="math">m_1, m_2, m_3, m_4</span>  correspond to the verifier challenges  <span class="math">\\eta \\in F</span> ,  <span class="math">\\alpha, \\beta, \\gamma \\in F \\setminus H</span> , respectively. The reasoning for  <span class="math">m_1, m_2, m_3</span>  is as befor, and  <span class="math">m_2 = 4 \\cdot m - 2</span>  by the degree of the inner sumcheck identity (24). Based on these modified soundness numbers, the strict polynomial time extractor is constructed as in Section A.4 by using the forking lemma (Lemma 2) and the extractor for the batch evaluation argument.</p>

    <p class="text-gray-300">The proof for perfect honest verifier zero-knowledge can be taken over almost verbatim, replacing completing of the simulated transcript for the outer sumcheck by an honest prover-verifier run of the inner sumcheck instead of the aggregation rounds.</p>

    <h4 id="sec-34" class="text-lg font-semibold mt-6">A.6 Polynomial commitment schemes</h4>

    <p class="text-gray-300">We regard a polynomial commitment scheme consisting of four probabilistic polynomial time algorithms</p>

    <p class="text-gray-300">Given the security parameter  <span class="math">\\lambda</span> ,  <span class="math">(ck, vk) \\leftarrow \\mathsf{Setup}(\\lambda)</span>  generates a common reference string consisting of a committer key ck and a verifier key vk supporting polynomials over some finite field F having degree of at most  <span class="math">N = N(\\lambda)</span> , where N is polynomial in  <span class="math">\\lambda</span> . Given the committer key ck, the commitment of a polynomial p(X) of degree at most N is computed by  <span class="math">C = \\mathsf{Com}(p(X); r)</span> , where r denotes the used random coins. (We again omit ck from the inputs for brevity.)</p>

    <p class="text-gray-300">We regard  <span class="math">(\\mathsf{Setup}, \\mathsf{Prove}, \\mathsf{Vf})</span>  as a succinct interactive argument system for the relation</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R} = \\{ ((C, x, v), (p(X), r)) : C = \\mathsf{Com}(p(X); r) \\land p(x) = v \\},\\</span></div>

    <p class="text-gray-300">and call the polynomial commitment scheme to satisfy completeness, zero-knowledge and witness-extended emulation if the interactive argument system does. We refer to the interaction  <span class="math">(\\mathsf{Open}, \\mathsf{Vf})</span>  as opening proof for the polynomial p(X) at the point  <span class="math">x \\in F</span> .</p>

    <p class="text-gray-300">The security notions <em>computational binding</em> and <em>perfect hiding</em> are as for general non-interactive commitment schemes (Setup, Com). For the sake of brevity, we directly cite them applied to polynomial commitment schemes:</p>

    <p class="text-gray-300"><span id="page-29-2"></span><strong>Definition 7</strong> (Perfect Hiding). We say that a polynomial commitment scheme (Setup, Com, Open, Vf) is <em>perfectly hiding</em> if every polynomial adversary  <span class="math">\\mathcal{A}</span>  has no advantage over pure guessing when distinguishing the commitments of two adversarially chosen polynomials,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr\\left[\\begin{array}{l} b^{\\star} = b \\\\ b^{\\star} = b \\end{array} \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} (ck, vk) \\leftarrow \\mathsf{Setup}(\\lambda), \\\\ \\text{for } i = 1, 2 \\\\ p_i(X) \\leftarrow \\mathcal{A}(ck, vk), \\ \\deg(p_i(X)) \\leq N(\\lambda), \\\\ C_i \\leftarrow \\mathsf{Com}(p_i(X)) \\\\ b \\leftarrow \\$ \\left\\{0, 1\\right\\}, \\ b^{\\star} \\leftarrow \\mathcal{A}(C_b, C_{1-b}) \\end{array} \\right] = \\frac{1}{2}.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-29-1"></span><strong>Definition 8</strong> (Computational Binding). A polynomial commitment scheme (Setup, Com, Open, Vf) is <em>computationally binding</em> if for every p.p.t. adversary A, the probability to find two different messages  <span class="math">(p_i(X), r_i)</span> , i = 1, 2, having the same commitment is negligible:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr \\left[ \\begin{array}{c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c} \\mathsf{Com}(p_1(X); r_1) = \\mathsf{Com}(p_2(X); r_2) \\\\ \\land \\\\ (p_1(X), r_1) \\neq (p_2(X), r_2) \\end{array} \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} (ck, vk) \\leftarrow \\mathsf{Setup}(\\lambda), \\\\ (r_1, p_1(X), r_2, p_2(X)) \\leftarrow \\mathcal{A}(ck, vk) \\end{array} \\right] \\\\ = \\mathsf{negl}(\\lambda).$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We further make use the notion of a homomorphic schemes, again directly applied to polynomial commitment schemes:</p>

    <p class="text-gray-300"><strong>Definition 9</strong> (Homomorphic commitment). A polynomial commitment scheme (Setup, Com, Open, Vf) with commitments in a <em>commitment group</em>  <span class="math">(\\mathcal{G}, +)</span>  is <em>homomorphic</em> (or, <em>linear</em>), if</p>

    <div class="my-4 text-center"><span class="math-block">Com(p_1(X); r_1) + Com(p_2(X); r_2) = Com(p_1(X) + p_2(X); r_1 + r_2).</span></div>

    <p class="text-gray-300">The dlog polynomial commitment scheme from [BCMS20] is an ordinary Pedersen vector commitment. Given the coefficient vector  <span class="math">\\vec{c} = (c_i)_{i=0}^{d-1}</span>  of a polynomial</p>

    <p class="text-gray-300">p(X) from F[X] of degree at most d, its commitment is the Pedersen linear combination</p>

    <div class="my-4 text-center"><span class="math-block">Com(p(X); r) = r \\cdot S + c_0 \\cdot G_0 + \\ldots + c_{d-1} \\cdot G_{d-1},</span></div>

    <p class="text-gray-300">where S and  <span class="math">(G_i)</span>  is the committer key, and the optional hiding randomness r is uniformly drawn from F. As in [BCC<sup>+</sup>16], [BBB<sup>+</sup>18], or [WTS<sup>+</sup>18], the opening proof is an inner product argument, which uses  <span class="math">k = \\log(d)</span>  rounds to gradually reduce the size polynomial in question by one half until ending up with a single-coefficient instance. In the course of the reduction the committer key is repeatedly folded into a final committer key  <span class="math">G_f</span>  for the single-coefficient claim, which depends linearly on the initial committer key by</p>

    <div class="my-4 text-center"><span class="math-block">G_f = h_0 \\cdot G_0 + \\ldots + h_{d-1} \\cdot G_{d-1},</span></div>

    <p class="text-gray-300">where  <span class="math">(h_i)</span>  are the coefficients of the reduction polynomial</p>

    <div class="my-4 text-center"><span class="math-block">h(\\vec{\\xi}, X) = \\prod_{i=0}^{k-1} (1 - \\xi_{k-1-i} \\cdot X^{2^i}),</span></div>

    <p class="text-gray-300">where  <span class="math">\\vec{\\xi} = (\\xi_i)_{i=0}^{k-1}</span>  are the random challenges of the reduction steps. See [BCMS20] for a detailed description.</p>

    <p class="text-gray-300"><span id="page-30-1"></span><strong>Theorem 10</strong> ([BCC<sup>+</sup>16, BCMS20]). Under the assumption that the dlog commitment scheme is computationally binding, the opening argument is an honest verifier zero-knowledge (Definition 6) argument of knowledge (Definition 5).</p>

    <p class="text-gray-300">Zero-knowledge is proven in [BCMS20]. To obtain a strict polynomial time extractor as demanded by Definition 5, one proceeds as in [BCC<sup>+</sup>16] to construct an expected polynomial time extractor with average runtime  <span class="math">\\mu</span>  inverse proportional to the success probability  <span class="math">\\varepsilon</span>  of the adversary. Truncating it to strict polynomial time  <span class="math">2 \\cdot \\mu/\\varepsilon</span>  zields a running time bounded by  <span class="math">poly(\\lambda)/poly(\\varepsilon)</span>  calls of  <span class="math">\\mathcal{A}</span>  and still maintains a success probability of  <span class="math">\\varepsilon/2</span> .</p>

    <p class="text-gray-300">We give an informal description of the protocol from [BDFG20], Section 5.2, for proving a multi-point opening claim</p>

    <div class="my-4 text-center"><span class="math-block">p_i(x_i) = y_i, \\quad i = 1, ..., m,</span></div>

    <p class="text-gray-300">of given polynomials  <span class="math">p_i(X)</span> ,  <span class="math">i=1,\\ldots,m</span> , for a linear commitment scheme (Setup, Com, Open, Vf). The multi-point evaluation claim is equivalent to the following system of algebraic identities over the set  <span class="math">\\Omega = \\{x_1, \\ldots, x_m\\}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">p_i(X) \\cdot L_m(x_i, X) - y_i = 0 \\mod z(X), \\quad i = 1, \\dots, m,</span></div>

    <p class="text-gray-300">where  <span class="math">L_m(x_i, X)</span>  is the Lagrange polynomial for  <span class="math">\\Omega</span> , and  <span class="math">z(X) = \\prod_{x \\in \\Omega} (X - x)</span>  is the vanishing polynomial of  <span class="math">\\Omega</span> . A more practical system of identities is achieved if we replace the Lagrange polynomials by their non-normalized variant</p>

    <div class="my-4 text-center"><span class="math-block">z_i(X) = \\frac{z(X)}{X - x_i} = \\prod_{x \\in \\Omega \\setminus \\{x_i\\}} (X - x).</span></div>

    <p class="text-gray-300">These m identities are reduced to a single identity over  <span class="math">\\Omega</span>  in the usual manner: The prover receives a random scalar  <span class="math">\\rho \\leftarrow F</span>  from the verifier, and shows the combined identity</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=1}^{m} \\rho^{i-1} \\cdot (p_i(X) - y_i) \\cdot z_i(X) = 0 \\mod z(X)</span></div>

    <p class="text-gray-300">instead. For this, the verifier provides an oracle for the quotient polynomial q(X) in the non-modular identity</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=1}^{m} \\rho^{i-1} \\cdot (p_i(X) - y_i) \\cdot z_i(X) = q(X) \\cdot z(X),</span></div>

    <p class="text-gray-300">which is probed at a fresh random point  <span class="math">x \\leftarrow F</span> . This identity is verified by showing that the linear combination  <span class="math">\\sum_{i=1}^{m} \\rho^{i-1} \\cdot z_i(x) \\cdot p_i(X) - z(x) \\cdot q(X)</span>  opens at x to the expected value  <span class="math">v = \\sum_{i=1}^{m} \\rho^{i-1} \\cdot y_i \\cdot z_i(x)</span> .</p>

    <p class="text-gray-300"><span id="page-31-1"></span><strong>Theorem 11</strong> ([BDFG20], Theorem 6). Assume that the commitment scheme is computationally binding. If the opening argument for the polynomial commitment scheme is a perfect honest verifier zero-knowledge argument of knowledge (Definition 5), then the same holds for the batch evaluation protocol.</p>

    <h3 id="sec-37" class="text-xl font-semibold mt-8">A.9 Segmentation of linear commitment schemes</h3>

    <p class="text-gray-300">Segmentation of a homomorphic polynomial commitment scheme is a useful technique to improve the computational effort of the prover at the cost of increasing the commitment size<sup>9</sup>. One chooses an undersized committer key  <span class="math">ck = (G_0, \\ldots, G_{s-1})</span> , where the segment size s is typically magnitudes smaller than the targeted maximum degree d, and extends its domain beyond degree s-1 by decomposing a polynomial p(X) into</p>

    <div class="my-4 text-center"><span class="math-block">p(X) = p_0(X) + X^s \\cdot p_1(X) + \\ldots + X^{(k-1)\\cdot s} \\cdot p_k(X),</span></div>

    <p class="text-gray-300">with each  <span class="math">p_i(X)</span> , i = 1,...,k, of degree at most s. (If d is the degree of p(X) then the number k of segment polynomials is equal to  <span class="math">\\lceil (d+1)/s \\rceil</span> .) The commitment of p(X) is then defined as the vector of the commitments of its segment polynomials using ck,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{Com}(p(X)) \\coloneqq (\\mathsf{Com}(p_0(X)), \\dots, \\mathsf{Com}(p_k(X))).</span></div>

    <p class="text-gray-300"><span id="page-31-2"></span><sup>&</sup>lt;sup>9</sup>We learned this technique from [Ol] but believe that it is commonly known.</p>

    <p class="text-gray-300">Every evaluation claim p(x) = v of the full-size polynomial is translated to the same claim on the linear combination of its segment polynomials,</p>

    <div class="my-4 text-center"><span class="math-block">LC_x(p_0(X),...,p_k(X)) = p_0(X) + x^s \\cdot p_1(X) + ... + x^{(k-1)\\cdot s} \\cdot p_k(X),</span></div>

    <p class="text-gray-300">which is efficiently proven by leveraging the homomorphic property of the scheme.</p>

    <p class="text-gray-300">Let  <span class="math">H = \\{x : x^n - 1 = 0\\}</span>  be an order n subgroup of the multiplicative group of a finite field F. The Lagrange kernel</p>

    <div class="my-4 text-center"><span class="math-block">L_n(X,Y) = \\frac{1}{n} \\cdot \\left(1 + \\sum_{i=1}^{n-1} X^i \\cdot Y^{n-i}\\right)</span></div>

    <p class="text-gray-300">is the unique bivariate symmetric polynomial of individual degree at most n-1, such that for  <span class="math">y \\in H</span>  the function L(X,y) restricted to H equals the Lagrange function  <span class="math">L_y(X)</span> , which evaluates to one at X = y, and zero otherwise. The kernel has the succinct representation</p>

    <div class="my-4 text-center"><span class="math-block">L_n(X,Y) = \\frac{1}{n} \\cdot \\frac{Y \\cdot Z_H(X) - X \\cdot Z_H(Y)}{X - Y},</span></div>

    <p class="text-gray-300">where  <span class="math">Z_H(X) = X^n - 1</span>  is the vanishing polynomial of H. Lagrange kernels represent point evaluation, as characterized by the following simple Lemma.</p>

    <p class="text-gray-300"><span id="page-32-1"></span><strong>Lemma 5.</strong> Suppose that  <span class="math">H \\subset F^*</span>  is a multiplicative subgroup of order n and p(X) is a polynomial of degree  <span class="math">deg(p(X)) \\le n-1</span> . Then for every z in F,</p>

    <div class="my-4 text-center"><span class="math-block">\\langle L_n(X,z),p(X)\\rangle_H = \\sum_{x\\in H} L_n(z,x)\\cdot p(x) = p(z).</span></div>

    <p class="text-gray-300"><em>Proof.</em> Since  <span class="math">p(X) = \\sum_{y \\in H} p(y) \\cdot L_n(X, y)</span> , it suffices to show the claim for  <span class="math">p(X) = L_n(X, y)</span> , with  <span class="math">y \\in H</span> . By the property of  <span class="math">L_n(X, y)</span> , we have  <span class="math">\\langle L_n(X, z), L_n(X, y) \\rangle_H = L_n(y, z)</span> , which by symmetry is equal to  <span class="math">L_n(X, y)</span>  at X = z. This completes the proof of the Lemma.</p>

    <p class="text-gray-300">Marlin [CHM<sup>+</sup>20] uses the generalized derivative</p>

    <div class="my-4 text-center"><span class="math-block">u_H(X,Y) = \\frac{Z_H(X) - Z_H(Y)}{X - Y}</span></div>

    <p class="text-gray-300">instead of  <span class="math">L_n(X,Y)</span>  (again as element from  <span class="math">F[X,Y]/\\langle X^n-1,Y^n-1\\rangle</span> ). For the generalized derivative a similar inner product formula holds: For every  <span class="math">z \\in F</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\langle u_H(X,z), p(X) \\rangle_H = \\langle u_H(X,X) \\cdot L_H(X,z), p(X) \\rangle_H$$ $$= \\langle L_n(X,z), u_H(X,X) \\cdot p(X) \\rangle_H = p^*(z),</span></div>

    <p class="text-gray-300">where  <span class="math">p^*(X) = u_H(X, X) \\cdot p(X) \\mod (X^n - 1)</span> .</p>`;
---

<BaseLayout title="Darlin: Recursive Proofs using Marlin (2021/930)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2021 &middot; eprint 2021/930
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
