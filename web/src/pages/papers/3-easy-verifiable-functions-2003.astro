---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2003/107';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-17';
const TITLE_HTML = '3 Easy verifiable functions';
const AUTHORS_HTML = 'Firstly, recall the definition of a trapdoor one-way function family.';

const CONTENT = `    <h2 id="sec-1" class="text-2xl font-bold"><strong>Fujisaki-Okamoto IND-CCA hybrid encryption revisited</strong></h2>

    <p class="text-gray-300">David Galindo, Sebasti\`a Mart´ın, Paz Morillo and Jorge L. Villar</p>

    <p class="text-gray-300">Dep. Matem<code>atica Aplicada IV. Universitat Polit</code>ecnica de Catalunya Campus Nord, c/Jordi Girona, 1-3, 08034 Barcelona e-mail: {dgalindo,sebasm,paz,jvillar}@mat.upc.es</p>

    <h4 id="sec-2" class="text-lg font-semibold mt-6"><strong>Abstract</strong></h4>

    <p class="text-gray-300">At Crypto'99, Fujisaki and Okamoto [10] presented a nice generic transformation from weak asymmetric and symmetric schemes into an IND-CCA hybrid encryption scheme in the Random Oracle Model. From this transformation, two specific candidates to standardization were designed: EPOC-2 [9] and PSEC-2 [16], based on Okamoto-Uchiyama and El Gamal primitives, respectively. Since then, several cryptanalysis of EPOC have been published, one in the Chosen Ciphertext Attack game and others making use of a poor implementation that is vulnerable to reject timing attacks.</p>

    <p class="text-gray-300">The aim of this work is to avoid these attacks from the generic transformation, identifying the properties that an asymmetric scheme must hold to obtain a secure hybrid scheme. To achieve this, some ambiguities in the proof of the generic transformation [10] are described, which can lead to false claims. As a result the original conversion is modified and the range of asymmetric primitives that can be used is shortened.</p>

    <p class="text-gray-300">In second place, the concept of <em>Easy Verifiable Primitive</em> is formalized, showing its connection with the Gap problems. Making use of these ideas, a <em>new</em> security proof for the modified transformation is given. The good news is that the reduction is <em>tight</em>, improving the concrete security claimed in the original work for the Easy Verifiable Primitives. For the rest of primitives the concrete security is improved at the cost of stronger assumptions.</p>

    <p class="text-gray-300">Finally, the resistance of the new conversion against reject timing attacks is addressed.</p>

    <p class="text-gray-300"><strong>Keywords:</strong> public-key cryptography, chosen-ciphertext security, tight reduction, Random Oracle Model, Okamoto-Uchiyama scheme, reject timing attacks.</p>

    <h2 id="sec-3" class="text-2xl font-bold"><strong>1 Introduction</strong></h2>

    <p class="text-gray-300">When developing a new public key encryption scheme there are two basic criteria that a designer wants to reach: <em>security</em> and <em>efficiency</em>. Security is obviously the main concern, and it is expressed in terms of an attacker's goal against the scheme and the means it uses. The standard security notion for a general purpose cryptosystem is <em>indistinguishability against adaptive chosen ciphertext attacks</em>, IND-CCA for short. Although there are other security notions equivalent to the latter (cf. [1, 19]), it is preferred for technical reasons. Proofs of security are accepted only if they are in the <em>provable security</em> model, in which security is polynomially reduced to trusted mathematical assumptions. Regarding efficiency, there are two main aspects to consider. On one hand, the computational complexity of the algorithms involved in the scheme and, on the other hand, the concrete security of the scheme, that is, how the security of the scheme is related to the computational assumptions which it is based on. There are other features of relevance, as the design simplicity or the length of the messages that can be encrypted.</p>

    <p class="text-gray-300">However, to develop a practical provably secure cryptosystem in the sense of IND-CCA is a quite difficult task. In fact, few such schemes are known in the standard model, being the exceptions the schemes designed in the Cramer-Shoup paradigm [7]. In the idealized Random Oracle Model [2], several powerful generic constructions have been designed [10, 17, 14, 5], which provide practical IND-CCA schemes from weak asymmetric and symmetric schemes.</p>

    <p class="text-gray-300">Among these constructions, [14, 5] present a better security reduction than [10, 17]. This is mainly due to the use of the <em>Plaintext Checking Oracle</em> introduced in [13]. The cost of using this oracle is that the security of the encryption scheme is in general based on (stronger) gap assumptions, when the asymmetric primitive is probabilistic.</p>

    <p class="text-gray-300">In this paper we revisit the generic conversion by Fujisaki and Okamoto (FO) presented at Crypto'99. The particular instantiation of this conversion with the Okamoto-Uchiyama scheme [15], known as EPOC-2 [9], has found practical attacks that lead to a total break [12, 8, 18]. The most serious flaw was found in [12], where the secret key was recovered in the IND-CCA game itself. The authors of [12] pointed out that such a surprising result was related to the vagueness of the IND-CCA model when dealing with invalid ciphertexts. In the case of the original especification of EPOC-2, an attacker could obtain vital information about the system from that ciphertexts. The other attacks mentioned above ([8, 18]), take profit of extra information available at the real world, as the running time of the decryption algorithm. This enables to distinguish among the reasons to reject certain ciphertexts and it is used to launch an attack recovering again the secret key.</p>

    <p class="text-gray-300"><strong>Our results.</strong> We incorporate the comments made by EPOC's authors in [12] about FO conversion. Then we show that some ambiguities still remain in the proof of security, with the outcome that the security result claimed in [10] cannot be guaranteed in general. This forces to slightly modify the conversion and to shorten the range of asymmetric primitives that can be used.</p>

    <p class="text-gray-300">In second place, the concept of <em>Easy Verifiable Primitive</em> is formalized, and it is used to give a <em>new</em> security proof for the modified transformation. We show that the reduction is <em>tight</em>, improving the concrete security claimed in the original work for the Easy Verifiable Primitives. For the rest of primitives the concrete security is improved at the cost of a stronger assumption, that is, a gap assumption (see [13]).</p>

    <p class="text-gray-300">Finally, the resistance of the new conversion against reject timing attacks is addressed. Since the vulnerability of a scheme against these attacks is closely related to the design of the rejection rules in the decryption algorithm, we take care about this when drawing the modification.</p>

    <h2 id="sec-4" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">In this section we recall some technical details and notations that are used in the rest of the paper.</p>

    <p class="text-gray-300"><strong>Algorithmic notation.</strong> Assigning a value a to a variable x will be in general denoted by  <span class="math">x \\leftarrow a</span> . Nevertheless, this notation can be extended to allow different meanings. If A is a non-empty set, then  <span class="math">x \\leftarrow A</span>  denotes that x is uniformly chosen in A. If D is a probability distribution over A, then  <span class="math">x \\leftarrow D</span>  means that x is chosen in A by sampling the distribution D. Finally, if A is an (probabilistic) algorithm,  <span class="math">x \\leftarrow A</span>  means that A is executed on some specified input and its (random) output is assigned to the variable x.</p>

    <p class="text-gray-300"><strong>Negligible functions.</strong> The class of negligible functions on a parameter  <span class="math">\\ell \\in \\mathbb{Z}^+</span> , denoted as  <span class="math">\\operatorname{negl}(\\ell)</span> , is the set of the functions  <span class="math">\\epsilon : \\mathbb{Z}^+ \\to \\mathbb{R}^+</span>  such that for any polynomial  <span class="math">p \\in \\mathbb{R}[\\ell]</span> , there exist  <span class="math">C \\in \\mathbb{R}^+</span>  such that  <span class="math">\\epsilon(\\ell) &lt; \\frac{C}{p(\\ell)}</span> , for all  <span class="math">\\ell \\in \\mathbb{Z}^+</span> . Let  <span class="math">\\operatorname{poly}(\\ell)</span>  the class of functions  <span class="math">p : \\mathbb{Z}^+ \\to \\mathbb{R}^+</span>  upper bounded in  <span class="math">\\mathbb{Z}^+</span>  by some polynomial in  <span class="math">\\mathbb{R}[\\ell]</span> .</p>

    <p class="text-gray-300">Set sequences. As usual,  <span class="math">\\{0,1\\}^*</span>  and  <span class="math">\\{0,1\\}^\\ell</span>  will respectively denote the set of all finite binary strings and the set of binary strings with length  <span class="math">\\ell</span> . A string set sequence,  <span class="math">X = \\{X_\\ell\\}_{\\ell \\in \\mathbb{Z}^+}</span> , is a polynomial size set if there exist a integer valued function  <span class="math">p_X(\\ell) \\in \\mathsf{poly}(\\ell)</span>  such that  <span class="math">X_\\ell \\subseteq \\{0,1\\}^{p_X(\\ell)}</span>  for all  <span class="math">\\ell \\in \\mathbb{Z}^+</span> . A polynomial size set, X, is samplable if there exists a probabilistic polynomial time algorithm (PPT) that on input  <span class="math">1^\\ell</span> , outputs an uniformly distributed random element in  <span class="math">X_\\ell</span> . Moreover, X is recognizable if there exist a polynomial time algorithm (PT) that on input  <span class="math">1^\\ell</span>  and a string s, with size polynomial in  <span class="math">\\ell</span> , outputs 1 if and only if  <span class="math">s \\in X_\\ell</span> . The cardinality of a set sequence A (as a function of  <span class="math">\\ell</span> ) will be denoted by |A|.</p>

    <p class="text-gray-300">These notions can be easily extended to non-strings sets by using polynomial size injective encoding maps. In the sequel, the use of natural encodings (e.g. binary representations of integers) is assumed when necessary.</p>

    <p class="text-gray-300">Hereafter, the word 'sequence' in 'set sequence', 'map sequence' and 'probability distribution sequence' will be omitted.</p>

    <p class="text-gray-300"><strong>Keypair generators.</strong> Let PK and SK polynomial size sets such that the sets  <span class="math">PK_{\\ell}</span>  are all disjoint and there exists a PT algorithm that on input  <span class="math">sk \\in SK_{\\ell}</span>  outputs an element  <span class="math">pk \\in PK_{\\ell}</span> . Suppose that there also exists a PT algorithm that on input  <span class="math">pk \\in PK_{\\ell}</span>  outputs  <span class="math">\\ell</span> . Let I a polynomial time samplable probability distribution over  <span class="math">PK \\times SK</span> . The triple (PK, SK, I) will be called a keypair generator.</p>

    <p class="text-gray-300">Set and map families. Given a keypair generator, the family  <span class="math">\\{X_{pk}\\}_{pk\\in PK}</span>  is referred as the set family X. In the same way, a map family f is defined as  <span class="math">\\{f_{pk}: X_{pk} \\to Z_{pk}\\}_{pk\\in PK}</span> . Given a set family, X, the cardinality |X| as a function of  <span class="math">\\ell</span>  is defined to be the minimal value of  <span class="math">|X_{pk}|</span> , where  <span class="math">pk \\in PK_{\\ell}</span> .</p>

    <p class="text-gray-300">A set family X is recognizable if there exist a PT algorithm that on input  <span class="math">pk \\in PK</span>  and a string s, with size polynomial in  <span class="math">\\ell</span> , outputs 1 if and only if  <span class="math">s \\in X_{pk}</span> . A conjectured counterexample is the set family  <span class="math">X_{pk} = Q_n</span>  of the quadratic residues modulo n = pq (p, q) different primes with length  <span class="math">\\ell</span> ). However, if sk = (p, q) is also provided then there exist an efficient way to recognise the elements in  <span class="math">Q_n</span> .</p>

    <p class="text-gray-300">Firstly, recall the definition of a trapdoor one-way function family.</p>

    <p class="text-gray-300"><strong>Definition 1</strong> <em>Let</em> (PK, SK, I) <em>a keypair generator. Let</em> X <em>and</em> Z <em>be polynomial size set families. Let</em> f : X → Z <em>be a family of injective maps and</em> g = {gsk : Zpk → Xpk}sk∈SK <em>the family of their inverses, i.e.</em> gsk(fpk(x)) = x <em>for all possible pairs</em> (pk, sk) <em>generated by</em> I <em>and for all</em> x ∈ Xpk<em>. The map family,</em> f<em>, is called a</em> Trapdoor One-Way (TOW) <em>function family (with respect to the probability distribution</em> I<em>) if and only if</em></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>1. there exist a PT algorithm that on input</em> (pk, x) <em>outputs</em> fpk(x) <em>for all</em> pk ∈ PK <em>and</em> x ∈ Xpk<em>.</em></li>
      <li><em>2. there exist a PT algorithm that on input</em> (sk, z) <em>outputs</em> gsk(z) <em>for all</em> sk ∈ SK <em>and</em> z ∈ Zpk<em>.</em></li>
      <li><em>3. for any PPT algorithm</em> AOW(f)<em>,</em></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathcal{A}_{\\mathsf{OW}(f)}(pk, f_{pk}(x)) = x \\mid (pk, sk) \\leftarrow I_{\\ell}; \\ x \\leftarrow X_{pk}\\right] \\in \\mathsf{negl}(\\ell)</span>$</p>

    <p class="text-gray-300">The following definition, based on [17], is somewhat related to the notion of probabilistic one-way encryption.</p>

    <p class="text-gray-300"><strong>Definition 2</strong> <em>Let</em> (PK, SK, I) <em>a keypair generator. Let</em> X<em>,</em> Y <em>and</em> Z <em>be polynomial size set families. Let</em> f : X × Y → Z <em>be a family of injective maps and</em> g = {gsk : Zpk → Xpk}sk∈SK <em>the family of their partial inverses, i.e.</em> gsk(fpk(x, y)) = x <em>for all possible pairs</em> (pk, sk) <em>generated by</em> I <em>and for all</em> x ∈ Xpk <em>and</em> y ∈ Ypk<em>. The map family,</em> f<em>, is called a</em> Trapdoor Partial One-Way (TPOW) <em>function family (with respect to the probability distribution</em> I<em>) if and only if</em></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>1. there exist a PT algorithm that on input</em> (pk, x, y) <em>outputs</em> fpk(x, y) <em>for all</em> pk ∈ PK<em>,</em> x ∈ Xpk <em>and</em> y ∈ Ypk<em>.</em></li>
      <li><em>2. there exist a PT algorithm that on input</em> (sk, z) <em>outputs</em> gsk(z) <em>for all</em> sk ∈ SK <em>and</em> z ∈ Zpk<em>.</em></li>
      <li><em>3. for any PPT algorithm</em> APOW(f)<em>,</em></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathcal{A}_{\\mathsf{POW}(f)}(pk, f_{pk}(x, y)) = x \\mid (pk, sk) \\leftarrow I_{\\ell}; \\ x \\leftarrow X_{pk}; \\ y \\leftarrow Y_{pk}\\right] \\in \\mathsf{negl}(\\ell)</span>$</p>

    <p class="text-gray-300">The last condition can be reformulated in terms of the game</p>

    <p class="text-gray-300">Game POW()</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>&lt;sup&gt;1&lt;/sup&gt; (pk, sk) ← I</li>
      <li>&lt;sup&gt;2&lt;/sup&gt; x ← Xpk; y ← Ypk</li>
      <li>3 x-← APOW(f)(pk, fpk(x, y))</li>
    </ul>

    <p class="text-gray-300">and the probability Succ APOW(f) -= Pr [x-= x] ∈ negl().</p>

    <p class="text-gray-300">Notice that the concept of TOW function family can be seen as a particular case of TPOW, in which |Y | = 1.</p>

    <p class="text-gray-300">Starting from f, a probabilistic one-way cryptosystem, (KeyGen&lt;sup&gt;f&lt;/sup&gt; , Enc&lt;sup&gt;f&lt;/sup&gt; , Dec&lt;sup&gt;f&lt;/sup&gt; ), is obtained in the following way: the keys (pk, sk) = KeyGen&lt;sup&gt;f&lt;/sup&gt; (1) = I are generated by using the sampling algorithm for I, the ciphertext for a message x ∈ Xpk with randomness  <span class="math">y \\leftarrow Y_{pk}</span>  is  <span class="math">c = \\mathsf{Enc}^f(pk, x) = f_{pk}(x, y)</span>  and a valid ciphertext  <span class="math">z \\in Z_{pk}</span>  is decrypted by means of  <span class="math">\\mathsf{Dec}^f(sk, c) = g_{sk}(c)</span> . Note that we are implicitly assuming that Y is samplable. In this context, there is no need to specify what happens when an invalid ciphertext, i.e. a polynomial size string  <span class="math">z \\notin Z_{pk}</span> , is submitted to  <span class="math">\\mathsf{Dec}^f</span> .</p>

    <p class="text-gray-300">A new kind of attacks and computational problems have been introduced and found various applications in the context of probabilistic cryptosystems (cf [13, 14]). In this new scenario, the attacker has access to a <em>Plaintext-Checking Oracle</em> that checks if a given ciphertext z is an encryption of a given message x. This attack is called Plaintext-Checking Attack (PCA), and it can be reformulated in terms of trapdoor partial one-way functions.</p>

    <p class="text-gray-300"><strong>Definition 3</strong> A TPOW function family  <span class="math">f: X \\times Y \\to Z</span>  is Partial One-Way against Plaintext-Checking Attacks (POW-PCA) if it is a TPOW function even when access to a plaintext checking oracle  <span class="math">C_{pk}</span>  is given. For a query (x, z), where  <span class="math">x \\in X_{pk}</span>  and  <span class="math">z \\in Z_{pk}</span> ,  <span class="math">C_{pk}</span>  answers 1 if there exists  <span class="math">y \\in Y_{pk}</span>  such that  <span class="math">f_{pk}(x, y) = z</span> , and 0 otherwise. (It is assumed that if x or z are outside their domains, the oracle also answers 0.)</p>

    <p class="text-gray-300">This notion is stronger than partial one-wayness, since now the adversary is provided with extra computational resources. Now we formalize the concept of easy verifiability, informally described in [17], that captures the situation in which there exists an efficient algorithm that verifies if a pair (x, z) is correct, that is, the algorithm implements a plaintext checking oracle.</p>

    <p class="text-gray-300"><strong>Definition 4</strong> The TPOW map family  <span class="math">f: X \\times Y \\to Z</span>  is easy verifiable if and only if there exists a (deterministic) PT algorithm V, called plaintext checking algorithm, such that given any  <span class="math">pk \\in PK</span> , V(pk, x, z) = 1 if  <span class="math">x \\in X_{pk}</span> ,  <span class="math">z \\in Z_{pk}</span>  and there exists  <span class="math">y \\in Y_{pk}</span>  such that  <span class="math">f_{pk}(x, y) = z</span> , and 0 otherwise.</p>

    <p class="text-gray-300">Obviously, if f is easy verifiable then the Plaintext-Checking Oracle for f can be replaced by the algorithm  <span class="math">\\mathcal{V}</span> , without introducing any modification in the adversary's model of computation. These functions are very interesting, since</p>

    <p class="text-gray-300"><strong>Lemma 5</strong> If the map family  <span class="math">f: X \\times Y \\to Z</span>  is easy verifiable then it is POW-PCA.</p>

    <p class="text-gray-300">Note that the existence of the plaintext checking algorithm would imply that the set X is recognizable. This is due to the fact that the polynomial time algorithm that computes  <span class="math">f_{pk}(x,y)</span>  could work when x lies in a set  <span class="math">\\bar{X}_{pk}</span>  broader than  <span class="math">X_{pk}</span> . Then, by definition, the output of  <span class="math">\\mathcal{V}(pk,x,f_{pk}(x,y))</span> , for any choice of  <span class="math">y\\in Y_{pk}</span> , can be used to efficiently recognise if  <span class="math">x\\in \\bar{X}_{pk}</span>  is in  <span class="math">X_{pk}</span> . For instance, no easy verifiable function exists if  <span class="math">X_{pk}=Q_n</span>  (i.e. the set of quadratic residues modulo n=pq) unless the quadratic residuosity modulo n problem is solvable in deterministic polynomial time. Nevertheless, such a function can achieve POW-PCA under a computational gap assumption (e.g. the gap between the quadratic residuosity modulo n and the factoring n assumptions).</p>

    <p class="text-gray-300">It is straightforward to modify a TOW function family  <span class="math">f&#x27;: X \\to Z&#x27;</span>  to obtain a easy verifiable function family f. To do it, simply take  <span class="math">Y = \\{0,1\\}^{p(\\ell)}</span> , where  <span class="math">p(\\ell) \\in \\mathsf{poly}(\\ell)</span> , and define  <span class="math">f_{pk}(x,y) = (f&#x27;_{pk}(x),y)</span> , that is, leaving y &quot;in the clear&quot;.</p>

    <p class="text-gray-300">For an arbitrary TPOW function a plaintext checking algorithm could not exist. For instance, this is supposed to be the case for El Gamal and Okamoto-Uchiyama</p>

    <p class="text-gray-300">functions. In this situation, we are forced to base POW-PCA on a gap problem, which is a stronger assumption (cf [13, 14]).</p>

    <p class="text-gray-300">A non-trivial example of easy verifiable function is the RSA-Paillier trapdoor bijection defined in [4]. A generalization of that function is presented below.</p>

    <h2 id="sec-5" class="text-2xl font-bold">3.1 Non-trivial families of easy verifiable functions</h2>

    <p class="text-gray-300">Let n=pq, where p and q are different primes with equal length  <span class="math">\\ell</span> . Let e &lt; n be an integer such that  <span class="math">\\gcd(e,(p-1)(q-1)) = 1</span> . For any integer r &gt; 1 with size polynomial in  <span class="math">\\ell</span> , consider the subset  <span class="math">\\Omega_{n,r} \\subset \\mathbb{Z}_{nr}</span>  defined as  <span class="math">\\Omega_{n,r} = \\mathbb{Z}_n^* + n\\mathbb{Z}_r</span> . Then, the function</p>

    <p class="text-gray-300"><span class="math">$f_{n,r,e}: \\mathbb{Z}_n^* \\times \\mathbb{Z}_r \\longrightarrow \\Omega_{n,r}</span>$</p>

    <p class="text-gray-300"><span class="math">(x,y) \\longrightarrow x^e + ny \\operatorname{mod} nr</span></p>

    <p class="text-gray-300">is a trapdoor bijection family, for pk = (n, r, e) and sk = (p, q, r, d), where d is the inverse of e modulo (p-1)(q-1).</p>

    <p class="text-gray-300">Notice that this function is well defined since  <span class="math">z \\in \\Omega_{n,r}</span>  iff  <span class="math">z \\mod n \\in \\mathbb{Z}_n^*</span> . Let see that  <span class="math">f_{n,r,e}</span>  is a bijection. Suppose that  <span class="math">f_{n,r,e}(x_0,y_0) = f_{n,r,e}(x_1,y_1)</span>  for some  <span class="math">x_0</span> ,  <span class="math">y_0</span> ,  <span class="math">x_1</span>  and  <span class="math">y_1</span> . Reducing the equality modulo n we get  <span class="math">x_0^e = x_1^e \\mod n</span> , and then  <span class="math">x_0 = x_1 \\mod n</span> . This implies  <span class="math">ny_0 = ny_1 \\mod nr</span> , so  <span class="math">y_0 = y_1 \\mod r</span>  and the function  <span class="math">f_{n,r,e}</span>  is injective. Finally, given (p,q,r,d), to invert  <span class="math">f_{n,r,e}</span>  on input  <span class="math">z = f_{n,r,e}(x,y)</span> , it suffices to compute  <span class="math">x = z^d \\mod n</span> . Then, y is easily obtained from the equation  <span class="math">ny = z - x^e \\mod nr</span> . This shows  <span class="math">f_{n,r,e}</span>  is exhaustive, and therefore it is a bijection.</p>

    <p class="text-gray-300">The above implies there exist two PT algorithms that compute both  <span class="math">f_{n,r,e}</span>  and its partial inverse.</p>

    <p class="text-gray-300"><strong>Proposition 6</strong> The partial one-wayness of the bijection family  <span class="math">f_{n,r,e}</span>  is tightly equivalent to the one-wayness of RSA[n,e].</p>

    <p class="text-gray-300">Proof:</p>

    <p class="text-gray-300"><span class="math">\\Rightarrow</span> ) Assume that for some  <span class="math">\\ell</span>  there exist a PPT algorithm,  <span class="math">\\mathcal{A}</span> , breaking the partial one-wayness of  <span class="math">f_{n,r,e}</span>  in time T and probability  <span class="math">\\epsilon</span> , i.e.</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathcal{A}(n, r, e, x^e + ny \\bmod nr) = x \\mid x \\leftarrow \\mathbb{Z}_n^{\\star}; y \\leftarrow \\mathbb{Z}_r\\right] = \\epsilon</span>$</p>

    <p class="text-gray-300">The following PPT algorithm,  <span class="math">\\mathcal{B}</span> , can be used to invert the RSA[n, e] function (i.e.  <span class="math">RSA[n, e](x) = x^e \\mod n</span> ) in time  <span class="math">T + O(\\ell^2)</span>  with probability at least  <span class="math">\\epsilon</span> :</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{B}(n, e, z)</span>$
1  <span class="math">y \\leftarrow \\mathbb{Z}_r, z&#x27; = z + ny \\operatorname{mod} nr</span>
2  <span class="math">x \\leftarrow \\mathcal{A}(n, r, e, z&#x27;)</span>
3 return  <span class="math">x</span></p>

    <p class="text-gray-300">Then,
<span class="math">$\\Pr[\\mathcal{B}(n, x^e \\mod n) = x \\mid x \\leftarrow \\mathbb{Z}_n^*] \\ge \\epsilon</span>$
.  <span class="math">\\Leftarrow</span> ) Trivial.</p>

    <p class="text-gray-300"><strong>Proposition 7</strong> The bijection family  <span class="math">f_{n,r,e}</span>  is easy verifiable.</p>

    <p class="text-gray-300"><em>Proof</em>: Given (n, r, e), it is straightforward to design a plaintext checking algorithm. Firstly, verify if  <span class="math">x \\in \\mathbb{Z}_n^*</span>  and  <span class="math">z \\in \\Omega_{n,r}</span> , that is, z &lt; nr and  <span class="math">z \\mod n \\in \\mathbb{Z}_n^*</span> . Then, check if the equation  <span class="math">x^e \\equiv z \\pmod{n}</span>  holds.</p>

    <h2 id="sec-6" class="text-2xl font-bold">4 Encryption security</h2>

    <p class="text-gray-300">Let us briefly recall some standard definitions about the security of both symmetric and asymmetric encryption.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">4.1 Symmetric encryption</h3>

    <p class="text-gray-300">Let K and M be two (samplable and recognisable) polynomial size sets that respectively denote the key and message spaces. Consider a symmetric encryption scheme  <span class="math">\\mathcal{E}^{sym} = (\\mathsf{KeyGen}^{sym}, \\mathsf{Enc}^{sym}, \\mathsf{Dec}^{sym})</span>  over these sets with the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>KeyGen&lt;sup&gt;sym&lt;/sup&gt; is a PPT algorithm that on input  <span class="math">1^{\\ell}</span>  outputs an uniformly distributed element in  <span class="math">K_{\\ell}</span> .</li>
      <li>Enc&lt;sup&gt;sym&lt;/sup&gt; and Dec&lt;sup&gt;sym&lt;/sup&gt; are PT algorithms with inputs are in  <span class="math">K_{\\ell} \\times M_{\\ell}</span>  and outputs in  <span class="math">M_{\\ell}</span> . Denote  <span class="math">\\operatorname{Enc}_{k}^{sym}(m) = \\operatorname{Enc}^{sym}(k,m)</span>  and  <span class="math">\\operatorname{Dec}_{k}^{sym}(c) = \\operatorname{Dec}^{sym}(k,c)</span> . For each  <span class="math">k \\in K_{\\ell}</span> ,  <span class="math">\\operatorname{Enc}_{k}^{sym}</span>  is a bijection on  <span class="math">M_{\\ell}</span>  and  <span class="math">\\operatorname{Dec}_{k}^{sym}</span>  is its inverse.</li>
      <li>For each pair  <span class="math">(m, c) \\in M_{\\ell} \\times M_{\\ell}</span>  there are at most  <span class="math">\\gamma</span>  values of  <span class="math">k \\in K_{\\ell}</span>  such that  <span class="math">c = \\mathsf{Enc}_k^{sym}(m)</span> . (Most of the known symmetric cryptosystems have  <span class="math">\\gamma = 1</span> .)</li>
    </ul>

    <p class="text-gray-300">Such a cryptosystem has indistinguishability of encryptions (IND-SYM), also called Find-Guess security in [10], if any couple of PPT algorithms  <span class="math">\\mathcal{A}_{\\mathsf{IND-SYM}(\\mathcal{E}^{sym})} = (\\mathcal{A}_1, \\mathcal{A}_2)</span>  (called &quot;finding&quot; and &quot;guessing&quot; stages of the adversary) have negligible advantage in the following game:</p>

    <pre><code class="language-text">\\begin{aligned} &amp;\\mathsf{Game\\ IND\\text{-}SYM}()\\\\ &amp;\\mathtt{1}\\quad b \\leftarrow \\{0,1\\}\\\\ &amp;\\mathtt{2}\\quad (m_0,m_1,s) \\leftarrow \\mathcal{A}_1(1^\\ell)\\\\ &amp;\\mathtt{3}\\quad k \\leftarrow K_\\ell;\\ c^\\star = \\mathsf{Enc}_k^{sym}(m_b)\\\\ &amp;\\mathtt{4}\\quad b&#x27; \\leftarrow \\mathcal{A}_2(s,c^\\star) \\end{aligned}
</code></pre>

    <p class="text-gray-300">That is,  <span class="math">\\mathcal{E}^{sym}</span>  is IND-SYM if and only if for all  <span class="math">(\\mathcal{A}_1, \\mathcal{A}_2)</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Adv}\\left[\\mathcal{A}_{\\mathsf{IND-SYM}(\\mathcal{E}^{sym})}\\right] = \\left|2\\mathsf{Pr}\\left[b&#x27; = b\\right] - 1\\right| = \\left|\\mathsf{Pr}\\left[b&#x27; = b\\right] - \\mathsf{Pr}\\left[b&#x27; \\neq b\\right]\\right| \\in \\mathsf{negl}(\\ell)</span>$</p>

    <p class="text-gray-300">The messages  <span class="math">m_0</span>  and  <span class="math">m_1</span>  generated by  <span class="math">A_1</span>  must be in  <span class="math">M_{\\ell}</span> .</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">4.2 Asymmetric encryption</h3>

    <p class="text-gray-300">Let (PK, SK, I) a keypair generator, defined as in section 2. Let M, R and C be polynomial size set families. Consider an asymmetric encryption scheme  <span class="math">\\mathcal{E}^{sym} = (\\mathsf{KeyGen}, \\mathsf{Enc}, \\mathsf{Dec})</span>  over these sets with the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>KeyGen is a PPT sampling algorithm for I, that is,  <span class="math">(pk, sk) = \\text{KeyGen}(1^{\\ell})</span>  is distributed as  <span class="math">I_{\\ell}</span>  on  <span class="math">PK_{\\ell} \\times SK_{\\ell}</span> .</li>
      <li>Enc:  <span class="math">PK \\times M \\times R \\to C</span>  and  <span class="math">Dec: SK \\times C \\to M</span>  are PT algorithms such that for any pair (pk, sk) generated by  <span class="math">\\mathsf{KeyGen}(1^\\ell)</span> ,  <span class="math">\\mathsf{Dec}(sk, \\mathsf{Enc}(pk, m, r)) = m</span>  for any  <span class="math">m \\in M_{pk}</span>  and  <span class="math">r \\in R_{pk}</span> . In fact, Enc can be seen as a PPT algorithm with input in  <span class="math">PK \\times M</span>  and coins taken in R.</li>
    </ul>

    <p class="text-gray-300">Such a cryptosystem has indistinguishability of encryptions under a chosen ciphertext attack (IND-CCA), if any couple of PPT algorithms  <span class="math">\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})} = (\\mathcal{A}_1, \\mathcal{A}_2)</span>  have negligible advantage in trying to distinguish the encryptions of two (conveniently selected) messages, with access to two decryption oracles  <span class="math">\\mathcal{D}_{sk}</span>  and  <span class="math">\\mathcal{D}_{sk,c^*}</span> . When queried with a ciphertext c the first decription oracle answers  <span class="math">\\mathsf{Dec}(sk,c)</span> . The only difference between  <span class="math">\\mathcal{D}_{sk}</span>  and  <span class="math">\\mathcal{D}_{sk,c^*}</span>  is that  <span class="math">\\mathcal{D}_{sk,c^*}</span>  rejects the query  <span class="math">c^*</span> , answering the special reject symbol  <span class="math">\\bot</span> .</p>

    <p class="text-gray-300">More formally, consider the following game:</p>

    <pre><code class="language-text">\\begin{aligned} &amp; \\mathsf{Game\\ IND\\text{-}CCA}() \\\\ &amp; 1 \\quad (pk,sk) \\leftarrow \\mathsf{KeyGen}(1^\\ell) \\\\ &amp; 2 \\quad b \\leftarrow \\{0,1\\} \\\\ &amp; 3 \\quad (m_0,m_1,s) \\leftarrow \\mathcal{A}_1^{\\mathcal{D}_{sk}}(pk) \\\\ &amp; 4 \\quad c^\\star \\leftarrow \\mathsf{Enc}(pk,m_b) \\\\ &amp; 5 \\quad b&#x27; \\leftarrow \\mathcal{A}_2^{G,H,\\mathcal{D}_{sk,c^\\star}}(s,c^\\star) \\end{aligned}
</code></pre>

    <p class="text-gray-300">Then,  <span class="math">\\mathcal{E}</span>  is IND-CCA if and only if for all couples of PPT algorithms  <span class="math">\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})} = (\\mathcal{A}_1, \\mathcal{A}_2)</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Adv}\\left[\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}\\right] = \\left|2\\mathsf{Pr}\\left[b&#x27; = b\\right] - 1\\right| = \\left|\\mathsf{Pr}\\left[b&#x27; = b\\right] - \\mathsf{Pr}\\left[b&#x27; \\neq b\\right]\\right| \\in \\mathsf{negl}(\\ell)</span>$</p>

    <p class="text-gray-300">The messages  <span class="math">m_0</span>  and  <span class="math">m_1</span>  generated by  <span class="math">\\mathcal{A}_1</span>  must be in  <span class="math">M_{pk}</span> .</p>

    <p class="text-gray-300">Notice that the decryption oracle formalizes the access to a decryption machine. Thus, the adversary is free to submit any polynomially bounded string (except for the target ciphertext,  <span class="math">c^*</span> , in the guessing stage) to this oracle. This means that IND-CCA security depends not only on the encryption algorithm but also on the concrete implementation of the decryption algorithm, including its behaviour for inputs outside the set of valid ciphertexts (i.e. ciphertexts of the form Enc(pk, m, r) for  <span class="math">m \\in M_{pk}</span>  and  <span class="math">r \\in R_{pk}</span> ). This behaviour can give very useful information for an adversary.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">4.3 Random oracle model</h3>

    <p class="text-gray-300">There are some ways to define random functions or random oracles in the literature. In the seminal work [2], random oracles act as random functions from  <span class="math">\\{0,1\\}^*</span>  to  <span class="math">\\{0,1\\}^{\\infty}</span> , while in the influential paper [3] the random functions are collections of functions. Moreover, in the second definition for a given value of the complexity parameter,  <span class="math">\\ell</span> , the corresponding function goes from  <span class="math">\\{0,1\\}^{p_I(\\ell)}</span>  to  <span class="math">\\{0,1\\}^{p_O(\\ell)}</span> , where  <span class="math">p_I(\\ell), p_O(\\ell) \\in \\mathsf{poly}(\\ell)</span> . Furthermore, the security of some schemes (e.g. [11]) depends on which definition of random function is used.</p>

    <p class="text-gray-300">In this paper, a random oracle is viewed as a special type of random process or random sequence. The random oracle is defined through its idealised functionality, that is closely related to the random oracle simulations often used in the proofs of security.</p>

    <p class="text-gray-300">Let A be a samplable polynomial size set. A random function G over A is a sequence of uniformly distributed independent random variables over A, indexed by the elements of  <span class="math">\\{0,1\\}^*</span> . Notice that  <span class="math">\\{0,1\\}^*</span>  is an ordered set. A random oracle over A is an oracle that answers queries exactly as if the random function G was evaluated.</p>

    <p class="text-gray-300">The main property of a random function is that the joint distribution of q&lt;sup&gt;G&lt;/sup&gt; variables G(s) for distinct values of s is the same regardless which values of s are selected. Thus, an efficient probabilistic (interactive) algorithm can simulate this random function by means of a table T&lt;sup&gt;G&lt;/sup&gt; storing all previous queries along with their answers. Any new (yet unanswered) query will be answered with a &quot;fresh&quot; random value, that will be annotated in TG.</p>

    <pre><code class="language-text">G(s)
 1 if s ∈ TG; return TG(s); endif
 2 g ← A
 3 insert (s, g) in table TG
 4 return g
</code></pre>

    <p class="text-gray-300">Here, s ∈ T&lt;sup&gt;G&lt;/sup&gt; will denote the fact that s has been queried to G by some party and TG(s) will denote the answer given by G to that query.</p>

    <p class="text-gray-300">Notice that the above algorithm runs in polynomial time and space if,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A is a samplable polynomial size set</li>
      <li>during the game, in which the different parties have access to the random oracle, no more than a polynomial quantity, qG() ∈ poly(), of queries are made</li>
      <li>the size of each query is limited by a polynomial function in</li>
    </ul>

    <p class="text-gray-300">This last condition will be obviously fulfil if all parties are modeled by polynomial time machines.</p>

    <p class="text-gray-300">Finally, IND-CCA security in the Random Oracle Model (ROM) of an asymmetric cryptosystem E is defined in the same way as above, but providing the adversary with oracle access to one or more random functions. In order to formalize the random coins of the random functions, a step G ← R(A) will be added at the beginning of the IND-CCA game for each random function used.</p>

    <p class="text-gray-300">Obviously, in the real world random functions have to be adequately replaced by (hash) function families with a polynomial size description. This description will be included in the public data available to all parties in a protocol (e.g. the public key of an encryption scheme).</p>

    <p class="text-gray-300">In this section, the transformation introduced in [10] of weak symmetric and asymmetric schemes into an IND-CCA hybrid encryption scheme is revisited.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8"><strong>5.1 The original construction</strong></h3>

    <p class="text-gray-300">Let E&lt;sup&gt;f&lt;/sup&gt; = (KeyGen&lt;sup&gt;f&lt;/sup&gt; , Enc&lt;sup&gt;f&lt;/sup&gt; , Dec&lt;sup&gt;f&lt;/sup&gt; ) be a probabilistic asymmetric encryption scheme, defined from a TPOW function family f over the sets X, Y and Z, and Esym = (KeyGensym, Encsym, Decsym) be a symmetric encryption scheme over the sets K and M. Let G be a random function over K and H an independent random function over Y . The hybrid scheme, EF O = (KeyGenF O, EncF O, DecF O), proposed by Fujisaki and Okamoto works as follows.</p>

    <p class="text-gray-300"><strong>Key generation.</strong> The public and secret keys are generated as in  <span class="math">\\mathsf{Key}\\mathsf{Gen}^f</span> .</p>

    <p class="text-gray-300"><strong>Encryption.</strong> The ciphertext for a message  <span class="math">m \\in M_{\\ell}</span>  is  <span class="math">c = (f_{pk}(x, y), \\mathsf{Enc}_{G(x)}^{sym}(m))</span> , where y = H(x, m) and x is uniformly chosen in  <span class="math">X_{pk}</span> .</p>

    <p class="text-gray-300"><strong>Decryption.</strong> To decrypt a ciphertext  <span class="math">c=(c_1,c_2)</span> , firstly compute  <span class="math">x=g_{sk}(c_1)</span> . Then, compute  <span class="math">m=\\mathsf{Dec}^{sym}_{G(x)}(c_2)</span>  and return m if  <span class="math">c_1=f_{pk}(x,H(x,m))</span> . Otherwise, return the reject symbol  <span class="math">\\bot</span> . If it is not possible to compute  <span class="math">g_{sk}(c_1)</span>  or  <span class="math">\\mathsf{Dec}^{sym}_{G(x)}(c_2)</span> , return  <span class="math">\\bot</span> .</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}[T, \\epsilon, q_G, q_H, q_D]</span>  denote an adversary against the IND-CCA security of the above cryptosystem that runs in time T with advantage  <span class="math">\\epsilon</span> , doing no more than  <span class="math">q_G</span> ,  <span class="math">q_H</span>  and  <span class="math">q_D</span>  queries respectively to the random oracles G, H and to the decryption oracle,  <span class="math">\\mathcal{D}_{sk}</span> .</p>

    <p class="text-gray-300"><strong>Theorem 8</strong> If there exists for some values of  <span class="math">\\ell</span>  an adversary  <span class="math">\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}[T, \\epsilon, q_G, q_H, q_D]</span> , then there exist an adversary  <span class="math">\\mathcal{A}_{\\mathsf{POW}(f)}</span>  against the POW of f in time  <span class="math">T_1</span>  with success probability  <span class="math">\\epsilon_1</span>  and an adversary  <span class="math">\\mathcal{A}_{\\mathsf{IND-SYM}(\\mathcal{E}^{sym})}</span>  against the IND-SYM security of  <span class="math">\\mathcal{E}^{sym}</span>  in time  <span class="math">T_2</span>  with advantage  <span class="math">\\epsilon_2</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\epsilon \\le (2(q_G + q_H)\\epsilon_1 + \\epsilon_2 + 1)\\left(1 - 2\\epsilon_1 - 2\\epsilon_2 - \\frac{1}{|Y|} - \\frac{1}{|M|}\\right)^{-q_D} - 1</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$T = \\min(T_1, T_2) - O((q_G + q_H)\\log(|X||M|))</span>$</p>

    <p class="text-gray-300">The main drawback of this scheme is that the security reduction obtained in the proof is not tight, due to the quantity  <span class="math">q_G + q_H</span>  multiplying  <span class="math">\\epsilon_1</span> . However, the same authors improved in [11] this result for the particular case of the Okamoto-Uchiyama scheme [15] (known as EPOC-2) and claimed, without proof, that a tight reduction is obtained for <em>trivial</em> easy verifiable primitives, using our terminology.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">5.2 Identifying dangerous ambiguities</h3>

    <p class="text-gray-300">However, as pointed out in the introduction, several attacks against EPOC-2 have been found [12, 8, 18]. Despite the precisions introduced about FO conversion after [12], there are still some ambiguities in the scheme, as well as in the security proof, that compromise the validity of the theorem above.</p>

    <p class="text-gray-300">For instance, let us consider a TPOW function family f, and  <span class="math">X_{pk} \\subset \\bar{X}_{pk}</span>  such that  <span class="math">f_{pk}(x,y)</span>  is computable in polynomial time for any  <span class="math">x \\in \\bar{X}_{pk}</span>  and  <span class="math">y \\in Y_{pk}</span> . Then, some badly generated ciphertexts  <span class="math">c = (f_{pk}(x, H(x,m)), \\operatorname{Enc}_{G(x)}^{sym}(m))</span>  for  <span class="math">x \\in \\bar{X}_{pk} \\setminus X_{pk}</span>  may be accepted. This was the case for Okamoto-Uchiyama function in the original EPOC-2, where  <span class="math">\\bar{X}_{pk} = \\mathbb{Z}_{2^{\\ell}+1}</span>  and  <span class="math">X_{pk} = \\mathbb{Z}_{2^{\\ell}}</span> , for  <span class="math">2^{\\ell} . This information was used in [12] to obtain the secret value &lt;math&gt;p</span> .</p>

    <p class="text-gray-300">As Fujisaki and Okamoto proposed later in [11], this attack is avoided if all ciphertexts  <span class="math">(c_1, c_2)</span>  such that  <span class="math">g_{sk}(c_1) \\notin X_{pk}</span>  are rejected. However, when this change is included in the general conversion a problem of different kind arises. If X is not a recognizable set, the checking cannot be performed in polynomial time. In this case the simulation of the  <span class="math">\\mathcal{D}_{sk}</span>  in the proof is not correct.</p>

    <p class="text-gray-300">Yet one could manage to use an additional oracle to solve this problem. In this situation, an adversary can use the decryption oracle to solve a difficult decisional</p>

    <p class="text-gray-300">problem. As a result, we only could guarantee that breaking security of the cryptosystem is equivalent to solve a gap problem, that is, a stronger assumption than claimed.</p>

    <p class="text-gray-300">This is the case for the Blum-Williams one-way trapdoor bijection family (i.e. squaring quadratic residues modulo n=pq), where  <span class="math">X_{pk}=Q_n</span>  and  <span class="math">\\bar{X}_{pk}=\\mathbb{Z}_n</span> . Rejection of all ciphertexts  <span class="math">(c_1,c_2)</span>  such that  <span class="math">g_{sk}(c_1) \\notin X_{pk}</span>  means that the adversary will know if an arbitary  <span class="math">x \\in \\mathbb{Z}_n</span>  is a quadratic residue. Thus, the IND-CCA security of the hybrid cryptosystem will be based on the gap between the quadratic residuosity modulo n and factoring n assumptions.</p>

    <h2 id="sec-12" class="text-2xl font-bold">5.3 The new proposal</h2>

    <p class="text-gray-300">From the above discussion we know that, although it is necessary to check if  <span class="math">g_{sk}(c_1) \\in X_{pk}</span> , to avoid leaking vital information, this cannot be done in all cases. In this section we restrict the asymmetric primitives to that which admit a correct and unambiguous proof of security for the general transformation.</p>

    <p class="text-gray-300">We also take into account the results in [8, 18] that use the ability to distinguish among rejection rules in the hybrid scheme to launch a total break. Thus, we slightly modify the specification of the decryption algorithm in the conversion.</p>

    <p class="text-gray-300">Finally, the recent developments in [14, 5, 6] can be applied to this transformation, and together with the concept of easy verifiable primitives, they are used to give a new proof of security improving the concrete security result presented in the original work.</p>

    <p class="text-gray-300">As in the original transformation, let  <span class="math">\\mathcal{E}^f = (\\mathsf{Key}\\mathsf{Gen}^f, \\mathsf{Enc}^f, \\mathsf{Dec}^f)</span>  be a probabilistic asymmetric encryption scheme, defined from a TPOW function family f over the sets X, Y and Z, and  <span class="math">\\mathcal{E}^{sym} = (\\mathsf{Key}\\mathsf{Gen}^{sym}, \\mathsf{Enc}^{sym}, \\mathsf{Dec}^{sym})</span>  be a symmetric encryption scheme over the sets K and M. Let G be a random function over K and H an independent random function over Y.</p>

    <p class="text-gray-300">The first change we introduce is that the random functions G and H are defined with unrestricted inputs, as explained in subsection 4.3. We think it is not realistic to restrict the inputs of the random functions, as suggested in [10], since in a practical implementation random functions are replaced by cryptographic hash functions. Then, if a proof of security can be driven for unrestricted domains, this choice is preferable.</p>

    <p class="text-gray-300">The following modification to the original proposal shorten the range of asymmetric primitives that can be used. Now, X and M must be recognizable sets. This not an actual restriction for M, since almost always  <span class="math">M_{\\ell} = \\{0,1\\}^{p(\\ell)}</span> , for some polynomial p. It is not demmanded Z to be a recognizable set. Instead of this, it is assumed that there exists a recognizable set  <span class="math">\\bar{Z}</span>  such that  <span class="math">Z_{pk} \\subseteq \\bar{Z}_{pk}</span> , and that the partial inverse of  <span class="math">f_{pk}</span>  can also be computed (in polynomial time) on elements of the extended set  <span class="math">\\bar{Z}_{pk}</span> .</p>

    <p class="text-gray-300">The proposed hybrid cryptosystem,  <span class="math">\\mathcal{E} = (\\text{KeyGen}, \\text{Enc}, \\text{Dec})</span> , is almost the same as the original. The only but important change is that now two different reject symbols are produced in the decryption algorithm Dec. Thus, when a ciphertext is rejected, the adversary will know the reason, obtaining different reject symbols without mounting a timing attack. Then, if the computing time of each step in the algorithm is independent of the data, the scheme is closely to be robust against reject timing attacks.</p>

    <pre><code class="language-text">\\begin{array}{ll} \\operatorname{Dec}(sk,c) \\\\ &amp; \\text{1} &amp; \\text{if } c \\not\\in \\bar{Z}_{pk} \\times M_{\\ell}; \\text{ return } \\bot_1; \\text{ endif} \\\\ &amp; \\text{2} &amp; (c_1,c_2) = c \\\\ &amp; \\text{3} &amp; x \\leftarrow g_{sk}(c_1) \\\\ &amp; \\text{4} &amp; m \\leftarrow \\operatorname{Dec}_{G(x)}^{sym}(c_2) \\\\ &amp; \\text{5} &amp; y \\leftarrow H(x,m) \\\\ &amp; \\text{6} &amp; \\text{if } x \\not\\in X_{pk} \\text{ or } f_{pk}(x,y) \\neq c_1; \\text{ return } \\bot_2; \\text{ endif} \\end{array}
</code></pre>

    <p class="text-gray-300">We point out that in the or operation in step 6 of the algorithm both predicates have always to be evaluated, in order to prevent the adversary to detect an extra rejection reason.</p>

    <p class="text-gray-300">Now, the security results are stated. The first theorem is for the special case when f is an easy verifiable function family, while the second theorem works for general TPOW function families.</p>

    <p class="text-gray-300"><strong>Theorem 9</strong> If there exists for some values of  <span class="math">\\ell</span>  an adversary  <span class="math">\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}[T, \\epsilon, q_G, q_H, q_D]</span>  against the IND-CCA security of the proposed cryptosystem, then there exist an adversary  <span class="math">\\mathcal{A}_{\\mathsf{POW}(f)}</span>  that in time  <span class="math">T_1</span>  breaks the POW of f with success probability  <span class="math">\\epsilon_1</span>  and an adversary  <span class="math">\\mathcal{A}_{\\mathsf{IND-SYM}(\\mathcal{E}^{sym})}</span>  that in time T breaks IND-SYM security of  <span class="math">\\mathcal{E}^{sym}</span>  with advantage  <span class="math">\\epsilon_2</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\epsilon \\leq \\epsilon_1 + 3\\epsilon_2 + \\frac{2q_Dq_H\\gamma}{|K| - q_Dq_H\\gamma} + \\frac{2q_D}{|Y| - q_D}</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$T_1 \\leq (q_G + q_H + q_D + q_G q_D)T[\\mathcal{V}] + q_D \\Big(T[f] + T[\\mathsf{Dec}^{sym}]\\Big) + T[f] + T[\\mathsf{Dec}^{sym}] + T[f] + T[\\mathsf{Dec}^{sym}] + T[f] + T[\\mathsf{Dec}^{sym}] + T[f] + T[\\mathsf{Dec}^{sym}] + T[f] + T[\\mathsf{Dec}^{sym}] + T[f] + T[\\mathsf{Dec}^{sym}] + T[f] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{sym}] + T[\\mathsf{Dec}^{s</span>$</p>

    <p class="text-gray-300">where  <span class="math">T[\\mathcal{V}]</span>  is the time complexity of the plaintext checking algoritm for f and T[f] is the time complexity of f.</p>

    <p class="text-gray-300"><em>Proof</em>: The proof is delayed to the appendix.</p>

    <p class="text-gray-300">Notice that now the probabilities are tightly related.</p>

    <p class="text-gray-300">In the general case, there could not exist the plaintext checking algorithm. Using the access to a plaintext checking oracle instead, the following result is straightforward.</p>

    <p class="text-gray-300">Corollary 10 If there exists for some values of  <span class="math">\\ell</span>  an adversary  <span class="math">\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}[T, \\epsilon, q_G, q_H, q_D]</span>  against the IND-CCA security of the proposed cryptosystem, then there exist an adversary  <span class="math">\\mathcal{A}_{\\mathsf{POW-PCA}(f)}</span>  that in time  <span class="math">T_1</span>  breaks the POW-PCA of f with success probability  <span class="math">\\epsilon_1</span>  and an adversary  <span class="math">\\mathcal{A}_{\\mathsf{IND-SYM}(\\mathcal{E}^{\\mathit{sym}})}</span>  that in time T breaks IND-SYM security of  <span class="math">\\mathcal{E}^{\\mathit{sym}}</span>  with advantage  <span class="math">\\epsilon_2</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\epsilon \\le \\epsilon_1 + 3\\epsilon_2 + \\frac{2q_D q_H \\gamma}{|K| - q_D q_H \\gamma} + \\frac{2q_D}{|Y| - q_D}</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$T_1 \\le (q_G + q_H + q_D + q_G q_D) + q_D \\Big(T[f] + T[\\mathsf{Dec}^{sym}]\\Big) + T</span>$</p>

    <p class="text-gray-300">where T[f] is the time complexity of f.</p>

    <p class="text-gray-300"><em>Proof</em>: It suffices to invoke the PCA oracle into the plaintext checking algorithm  <span class="math">\\mathcal{V}</span>  for f. Thus, by definition of oracle access,  <span class="math">T[\\mathcal{V}] = 1</span> .</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">5.4 Particular cases</h3>

    <p class="text-gray-300">Both in the case of the trivial construction of partial one-way bijection families and in the non-trivial family defined in subsection 3.1, the simulation in the security proof can be improved introducing only technical modifications.</p>

    <p class="text-gray-300">In both cases, there exist a polynomial size set family Z' and two very efficiently computable function families  <span class="math">f&#x27;: X \\to Z&#x27;</span>  and  <span class="math">\\pi&#x27;: \\bar{Z} \\to Z&#x27;</span>  such that for all  <span class="math">pk \\in PK</span> ,  <span class="math">x \\in X_{pk}</span>  and  <span class="math">z \\in \\bar{Z}_{pk}</span> , V(pk, x, z) = 1 if and only if  <span class="math">f&#x27;_{pk}(x) = \\pi&#x27;_{pk}(z)</span> . Notice that this property implies the injectivity of f'. It is shown in the appendix that</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} T[\\mathcal{A}_{\\mathsf{POW}(f)}] &amp; \\leq (q_G + q_H + q_D)T[\\mathcal{V}] + q_G T[f&#x27;] + \\\\ &amp; + q_D \\Big(T[f] + T[\\pi&#x27;] + T[\\mathsf{Dec}^{sym}]\\Big) + T[\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}] \\end{split}</span>$</p>

    <p class="text-gray-300">then providing a very-tight security reduction.</p>

    <p class="text-gray-300">If the trivial constructions are considered,  <span class="math">f_{pk}(x,y)=(f&#x27;_{pk}(x),y)</span>  and  <span class="math">\\pi&#x27;_{pk}(z&#x27;,y)=z&#x27;</span> . Then,  <span class="math">T[\\pi&#x27;]</span>  can be neglected and  <span class="math">T[f]\\approx T[f&#x27;]\\approx T[\\mathcal{V}]</span> . So</p>

    <p class="text-gray-300"><span class="math">$T[\\mathcal{A}_{\\mathsf{POW}(f)}] \\leq (2q_G + q_H + 2q_D)T[f&#x27;] + q_DT[\\mathsf{Dec}^{sym}] + T[\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}]</span>$</p>

    <p class="text-gray-300">On the other hand, if the generalised RSA-Paillier function is used,  <span class="math">f&#x27;_{n,r,e}(x) = x^e \\mod n</span>  and  <span class="math">\\pi&#x27;_{n,r,e}(z) = z \\mod n</span> . Then,</p>

    <p class="text-gray-300"><span class="math">$T[\\mathcal{A}_{\\mathsf{POW}(f)}] \\le (2q_G + q_H + 2q_D)O(\\ell^2 \\log e) + q_D T[\\mathsf{Dec}^{sym}] + T[\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}]</span>$</p>

    <h2 id="sec-14" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">[1] M. Bellare, A. Desai, D. Pointcheval and P. Rogaway. Relations Among Notions of Security for Public-Key Encryption Schemes. <em>CRYPTO '98</em>, <em>LNCS</em> <strong>1462</strong> 26–45 (1998).</p></li>
      <li><p class="text-gray-300">[2] M. Bellare and P. Rogaway. Random Oracles are Practical: a Paradigm for Designing Efficient Protocols. ACM CCS 93, ACM Press (1993)</p></li>
      <li><p class="text-gray-300">[3] R. Canetti, O. Goldreich and S. Halevi. The random oracle methodology, revisited. In <em>Proceedings of the 32nd Annual ACM Symposium on Theory of Computing</em>, 209–218 (1998).</p></li>
      <li><p class="text-gray-300">[4] D. Catalano, R. Gennaro, N. Howgrave-Graham and P. Q. Nguyen. Paillier's Cryptosystem Revisited. ACM CCS '2001 ACM Press (2001).</p></li>
      <li><p class="text-gray-300">[5] J. Coron, H. Handschuh, M. Joye, P. Paillier, D. and C. Tymen. GEM: a Generic Chosen-Ciphertext Secure Encryption Method. CT-RSA' 02, LNCS 2271 263–276 (2002).</p></li>
      <li><p class="text-gray-300">[6] J. Coron, H. Handschuh, M. Joye, P. Paillier, D. Pointcheval and C. Tymen. Optimal Chosen-Ciphertext Secure Encryption of Arbitrary-Length Messages. PKC 2002, LNCS 2274 17–33 (2002).</p></li>
      <li><p class="text-gray-300">[7] R. Cramer and V. Shoup. Universal Hash Proofs and a Paradigm for Adaptive Chosen Ciphertext Secure Public-Key Encryption. <em>EUROCRYPT '2002, LNCS</em> <strong>2332</strong> 45–64 (2002).</p></li>
      <li><p class="text-gray-300">[8] A. W. Dent. An implementation attack against the EPOC-2 public-key cryptosystem. <em>Electronics Letters</em> VOL. 38 NO. 9 412–413 (2002).</p></li>
      <li><p class="text-gray-300">[9] EPOC, Efficient Probabilistic Public-Key Encryption. http://info.isl.ntt.co.jp/epoc/</p></li>
      <li><p class="text-gray-300">[10] E. Fujisaki and T. Okamoto. Secure Integration of Asymmetric and Symmetric Encryption Schemes. CRYPTO '99, LNCS 1666 537–554 (1999)</p></li>
      <li><p class="text-gray-300">[11] E. Fujisaki and T. Okamoto. A Chosen-Cipher Secure Encryption Scheme Tightly as Secure as Factoring. <em>IEICE Trans. Fundamentals</em> <strong>E84-A</strong>(1) 179–187 (2001).</p></li>
      <li><p class="text-gray-300">[12] M. Joye, J. J. Quisquater and M. Yung. On the Power of Misbehaving Adversaries and Security Analysis of the Original EPOC. CT-RSA' 01, LNCS 2020 208–222 (2001).</p></li>
      <li><p class="text-gray-300">[13] T. Okamoto and D. Pointcheval. The Gap-Problems: a New Class of Problems for the Security of Cryptographic Schemes. PKC' 01, LNCS 1992 104–118 (2001).</p></li>
      <li><p class="text-gray-300">[14] T. Okamoto and D. Pointcheval. REACT: Rapid Enhanced-security Asymmetric Cryptosystem Transform. CT-RSA' 01, LNCS 2020 159–175 (2001).</p></li>
      <li><p class="text-gray-300">[15] T. Okamoto and S. Uchiyama. A New Public-Key Cryptosystem as Secure as Factoring. EUROCRYPT-98, LNCS 1403 308–318 (1998)</p></li>
      <li><p class="text-gray-300">[16] PSEC, Provably Secure Encryption Scheme. http://info.isl.ntt.co.jp/psec/</p></li>
      <li><p class="text-gray-300">[17] D. Pointcheval. Chosen-Ciphertext Security for any One-Way Cryptosystem. Proc. PKC '2000 LNCS 1751 129–146 (2000).</p></li>
      <li><p class="text-gray-300">[18] K. Sakurai and T. Takagi. A Reject Timing Attack on an IND-CCA2 Public-Key Cryptosystem. ICISC '02, LNCS 2587 359–373 (2002).</p></li>
      <li><p class="text-gray-300">[19] Y. Watanabe, J. Shikata and H.Imai. Equivalence between Semantic Security and Indistinguishability against Chosen Ciphertext Attacks. PKC 2003, LNCS 2567 71–84 (2002).</p></li>
    </ul>

    <h2 id="sec-15" class="text-2xl font-bold">A Proof of theorem 9</h2>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}[T, \\epsilon, q_G, q_H, q_D] = (\\mathcal{A}_1, \\mathcal{A}_2)</span>  be the adversary aiming to attack the IND-CCA security of the hybrid encryption scheme,  <span class="math">\\mathcal{E} = (\\mathsf{KeyGen}, \\mathsf{Enc}, \\mathsf{Dec})</span>  described in subsection 5.3.</p>

    <p class="text-gray-300">In order to prove the theorem, some different games will be considered. In all games, the adversary  <span class="math">\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}</span>  uses the same coins, but the events defined as functions of the view of  <span class="math">\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}</span>  could occur with different probabilities in each game. Starting from the IND-CCA game we will design several intermediate games before designing the game for an adversary who tries to break the partial one-wayness (POW) of f. Each game will be obtained by introducing slight modifications to the previous game in such a way that the adversary success probabilities are easily related. We denote by  <span class="math">\\mathsf{Pr}_i[F]</span>  the probability of event F in game i.</p>

    <p class="text-gray-300">Each game will be described as a main algorithm along with some auxiliar algorithms used as oracles by  <span class="math">\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}</span> . The bulleted steps in the algorithms will indicate the main changes introduced in each game.</p>

    <p class="text-gray-300">The following trivial lemma will be very useful in this proof.</p>

    <p class="text-gray-300"><strong>Lemma 11</strong> Let  <span class="math">E_1</span> ,  <span class="math">F_1</span>  be two events defined in a probability space  <span class="math">\\mathcal{X}_1</span> , and  <span class="math">E_2</span> ,  <span class="math">F_2</span>  another two events defined in a probability space  <span class="math">\\mathcal{X}_2</span> , such that  <span class="math">p = \\Pr_{\\mathcal{X}_2}[F_2] = \\Pr_{\\mathcal{X}_1}[F_1]</span>  and  <span class="math">\\Pr_{\\mathcal{X}_2}[E_2 \\wedge \\neg F_2] = \\Pr_{\\mathcal{X}_1}[E_1 \\wedge \\neg F_1]</span> . Then</p>

    <p class="text-gray-300"><span class="math">$\\left| \\mathsf{Pr}_{\\mathcal{X}_2} \\left[ E_2 \\right] - \\mathsf{Pr}_{\\mathcal{X}_1} \\left[ E_1 \\right] \\right| \\le p</span>$</p>

    <p class="text-gray-300"><strong>Game0</strong>. The IND-CCA attack. There are some minor differences between Game0 and the standard IND-CCA game, described in subsection 4.2, but they do not modify any probability.</p>

    <pre><code class="language-text">\\begin{split} &amp;\\mathsf{Game0}() \\\\ &amp; \\quad 1 \\quad (pk,sk) \\leftarrow \\mathsf{KeyGen}(1^\\ell); \\ G \\leftarrow \\mathcal{R}(K_\\ell); \\ H \\leftarrow \\mathcal{R}(Y_{pk}) \\\\ &amp; \\quad 2 \\quad b \\leftarrow \\{0,1\\}; \\ x^\\star \\leftarrow X_{pk} \\\\ &amp; \\quad 3 \\quad (m_0,m_1,s) \\leftarrow \\mathcal{A}_1^{G,H,\\mathcal{D}_{sk}}(pk) \\\\ &amp; \\quad 4 \\quad y^\\star \\leftarrow H(x^\\star,m_b); \\ c^\\star \\leftarrow \\left(f_{pk}(x^\\star,y^\\star),\\mathsf{Enc}_{G(x^\\star)}^{sym}(m_b)\\right) \\\\ &amp; \\quad 5 \\quad b&#x27; \\leftarrow \\mathcal{A}_2^{G,H,\\mathcal{D}_{sk,c^\\star}}(s,c^\\star) \\end{split}
</code></pre>

    <p class="text-gray-300">where the oracle answer  <span class="math">\\mathcal{D}_{sk}(c)</span>  is exactly the same as the value returned by  <span class="math">\\mathsf{Dec}(sk,c)</span> , described in subsection 5.3.</p>

    <p class="text-gray-300">Let Askx be the event that, during the game, either  <span class="math">x^* \\in X</span>  is queried (by  <span class="math">\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}</span> ) to G or  <span class="math">(x^*, m)</span>  is queried to H, for some m. Then,</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathsf{Adv} \\left[ \\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})} \\right] &amp;= |\\mathsf{Pr_0} \\left[ b&#x27; = b \\right] - \\mathsf{Pr_0} \\left[ b&#x27; \\neq b \\right] | \\leq \\\\ &amp;\\leq |\\mathsf{Pr_0} \\left[ b&#x27; = b \\land \\mathsf{Askx} \\right] - \\mathsf{Pr_0} \\left[ b&#x27; \\neq b \\land \\mathsf{Askx} \\right] | + \\\\ &amp;+ |\\mathsf{Pr_0} \\left[ b&#x27; = b \\land \\neg \\mathsf{Askx} \\right] - \\mathsf{Pr_0} \\left[ b&#x27; \\neq b \\land \\neg \\mathsf{Askx} \\right] | \\leq \\\\ &amp;\\leq \\mathsf{Pr_0} \\left[ \\mathsf{Askx} \\right] + |\\mathsf{Pr_0} \\left[ b&#x27; = b \\land \\neg \\mathsf{Askx} \\right] - \\mathsf{Pr_0} \\left[ b&#x27; \\neq b \\land \\neg \\mathsf{Askx} \\right] | \\end{aligned}</span>$</p>

    <p class="text-gray-300">In order to improve the readability of the rest of the proof, let define  <span class="math">S_1 = \\mathsf{Askx}</span> ,  <span class="math">S_{01} = \\neg \\mathsf{Askx} \\land b&#x27; = b</span>  and  <span class="math">S_{00} = \\neg \\mathsf{Askx} \\land b&#x27; \\neq b</span> . The above equation can be rewritten as</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Adv}\\left[\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}\\right] \\leq \\mathsf{Pr}_{0}\\left[\\mathsf{S}_{1}\\right] + \\left|\\mathsf{Pr}_{0}\\left[\\mathsf{S}_{01}\\right] - \\mathsf{Pr}_{0}\\left[\\mathsf{S}_{00}\\right]\\right|</span>$</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{T}_G</span>  be a table in which all the queries made by  <span class="math">\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}</span>  to the oracle G are stored along with the corresponding answers. Notice that  <span class="math">\\mathcal{T}_G</span>  would not contain ALL the queries made to G. In the sequel,  <span class="math">x \\in \\mathcal{T}_G</span>  will denote the fact that x has been queried to G by  <span class="math">\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}</span>  and  <span class="math">\\mathcal{T}_G(x)</span>  will denote the answer given by G. Define  <span class="math">(x,m) \\in \\mathcal{T}_H</span> ,  <span class="math">\\mathcal{T}_H(x,m)</span>  and  <span class="math">c \\in \\mathcal{T}_D</span> ,  <span class="math">\\mathcal{T}_D(c)</span>  in a similar way respectively for the oracle calls to H and  <span class="math">\\mathcal{D}_{sk}</span> . Notice that the contents of these tables will vary during the game.</p>

    <p class="text-gray-300"><strong>Game1</strong>. In this game, the queries made by  <span class="math">\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}</span>  to the two random oracles are intercepted in order to immediately abort the execution of the game if  <span class="math">\\mathsf{Askx}</span>  (i.e.  <span class="math">\\mathsf{S}_1</span> ) occurs. The following functions will do this task:</p>

    <pre><code class="language-text">G1(x)
1 if x=x^\\star; exit Game; endif 2 return G(x)
H1(x,m)
1 if x=x^\\star; exit Game; endif 2 return H(x,m)
</code></pre>

    <p class="text-gray-300">and the new game is,</p>

    <pre><code class="language-text">\\begin{split} &amp;\\mathsf{Game1}() \\\\ &amp; \\quad 1 \\quad (pk,sk) \\leftarrow \\mathsf{KeyGen}(1^\\ell); \\ G \\leftarrow \\mathcal{R}(K_\\ell); \\ H \\leftarrow \\mathcal{R}(Y_{pk}) \\\\ &amp; \\quad 2 \\quad b \\leftarrow \\{0,1\\}; \\ b&#x27; \\leftarrow \\{0,1\\}; \\ x^\\star \\leftarrow X_{pk} \\\\ &amp; \\quad 3 \\quad (m_0,m_1,s) \\leftarrow \\mathcal{A}_1^{G1,H1,\\mathcal{D}_{sk}}(pk) \\\\ &amp; \\quad 4 \\quad y^\\star \\leftarrow H(x^\\star,m_b); \\ c^\\star \\leftarrow \\left(f_{pk}(x^\\star,y^\\star),\\mathsf{Enc}_{G(x^\\star)}^{sym}(m_b)\\right) \\\\ &amp; \\quad 5 \\quad b&#x27; \\leftarrow \\mathcal{A}_2^{G1,H1,\\mathcal{D}_{sk,c^\\star}}(s,c^\\star) \\end{split}
</code></pre>

    <p class="text-gray-300">Since the games are identical while  <span class="math">\\neg S_1</span> , the events  <span class="math">S_1</span> ,  <span class="math">S_{01}</span>  and  <span class="math">S_{00}</span>  remain unchanged in Game1. Then,</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Adv}\\left[\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}\\right] \\leq \\mathsf{Pr}_1\\left[\\mathsf{S}_1\\right] + \\left|\\mathsf{Pr}_1\\left[\\mathsf{S}_{01}\\right] - \\mathsf{Pr}_1\\left[\\mathsf{S}_{00}\\right]\\right|</span>$</p>

    <p class="text-gray-300"><strong>Game2</strong>. In this game, the decryption oracle is modified in such a way that it is disallowed to do new queries to the random oracle G. To do this, all ciphertexts  <span class="math">(c_1, c_2)</span>  submitted to the decryption oracle such that  <span class="math">g_{sk}(c_1) \\notin \\mathcal{T}_G \\cap X_{pk}</span>  are rejected by returning  <span class="math">\\bot_2</span> , even when some of them may be valid ciphertexts.</p>

    <pre><code class="language-text">\\begin{aligned} &amp;\\text{Game2}() \\\\ &amp;\\text{1} \\quad (pk,sk) \\leftarrow \\mathsf{KeyGen}(1^\\ell); \\ G \\leftarrow \\mathcal{R}(K_\\ell); \\ H \\leftarrow \\mathcal{R}(Y_{pk}) \\\\ &amp;\\text{2} \\quad b \\leftarrow \\{0,1\\}; \\ x^\\star \\leftarrow X_{pk} \\\\ &amp;\\text{3} \\quad (m_0,m_1,s) \\leftarrow \\mathcal{A}_1^{G1,H1,\\mathcal{D}2_{sk}}(pk) \\\\ &amp;\\text{4} \\quad y^\\star \\leftarrow H(x^\\star,m_b); \\ c^\\star \\leftarrow \\left(f_{pk}(x^\\star,y^\\star),\\mathsf{Enc}_{G(x^\\star)}^{sym}(m_b)\\right) \\\\ &amp;\\text{5} \\quad b&#x27; \\leftarrow \\mathcal{A}_2^{G1,H1,\\mathcal{D}2_{sk,c^\\star}}(s,c^\\star) \\\\ &amp;\\mathcal{D}2_{sk}(c) \\\\ &amp;\\text{1} \\quad \\text{if } c \\not\\in \\bar{Z}_{pk} \\times M_\\ell; \\ \\text{return } \\perp_1; \\ \\text{endif} \\\\ &amp;\\text{2} \\quad (c_1,c_2) = c \\\\ &amp;\\text{3} \\quad x \\leftarrow g_{sk}(c_1) \\\\ &amp;\\text{•} \\quad \\text{4} \\quad \\text{if } x \\not\\in X_{pk} \\ \\text{or } x \\not\\in \\mathcal{T}_G; \\ \\text{return } \\perp_2; \\ \\text{endif} \\\\ &amp;\\text{5} \\quad m \\leftarrow \\mathsf{Dec}_{G(x)}^{sym}(c_2) \\\\ &amp;\\text{6} \\quad y \\leftarrow H(x,m) \\\\ &amp;\\text{7} \\quad \\text{if } f_{pk}(x,y) \\neq c_1; \\ \\text{return } \\perp_2; \\ \\text{endif} \\\\ &amp;\\text{8} \\quad \\text{return } m \\end{aligned}
</code></pre>

    <p class="text-gray-300">Let  <span class="math">F_2</span>  be the event that, in some query to the decryption oracle, the ciphertext is accepted in Game1, but is rejected at step 4 of  <span class="math">\\mathcal{D}2_{sk}</span> . Before  <span class="math">F_2</span> , both games are indentical. Then, by lemma 11,</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} |\\mathsf{Pr}_2\\left[\\mathsf{S}_1\\right] - \\mathsf{Pr}_1\\left[\\mathsf{S}_1\\right]| &amp;\\leq \\mathsf{Pr}\\left[F_2\\right] \\\\ |\\mathsf{Pr}_2\\left[\\mathsf{S}_{01}\\right] - \\mathsf{Pr}_1\\left[\\mathsf{S}_{01}\\right]| &amp;\\leq \\mathsf{Pr}\\left[F_2\\right] \\\\ |\\mathsf{Pr}_2\\left[\\mathsf{S}_{00}\\right] - \\mathsf{Pr}_1\\left[\\mathsf{S}_{00}\\right]| &amp;\\leq \\mathsf{Pr}\\left[F_2\\right] \\end{aligned}</span>$</p>

    <p class="text-gray-300">From these inequalities, it can be easily shown that</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Adv}\\left[\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}\\right] \\leq \\mathsf{Pr}_2\\left[\\mathsf{S}_1\\right] + \\left|\\mathsf{Pr}_2\\left[\\mathsf{S}_{01}\\right] - \\mathsf{Pr}_2\\left[\\mathsf{S}_{00}\\right]\\right| + 2\\mathsf{Pr}\\left[F_2\\right]</span>$</p>

    <p class="text-gray-300">The following lemma gives an upper bound for  <span class="math">Pr[F_2]</span> .</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">Lemma 12</h4>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[F_2\\right] \\le \\frac{q_D q_H \\gamma}{|K| - q_D q_H \\gamma} + \\frac{q_D}{|Y| - q_D}</span>$</p>

    <p class="text-gray-300"><em>Proof</em>: Let  <span class="math">\\mathsf{Fail}_k</span>  be the event that  <span class="math">F_2</span>  occurs exactly at the k-th query to the decryption oracle. Let  <span class="math">\\mathsf{NoFail}_k = \\wedge_{j=1}^k \\neg \\mathsf{Fail}_j</span>  denote the event that  <span class="math">F_2</span>  does not occur during the first k queries to the decryption oracle, for  <span class="math">k = 1, \\ldots, q_D</span> . Let  <span class="math">\\mathsf{NoFail}_0</span>  be the certain event. Then,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[F_2] = 1 - \\Pr[\\mathsf{NoFail}_{q_D}] = 1 - \\Pr\\left[\\bigwedge_{k=1}^{q_D} \\neg \\mathsf{Fail}_k\\right] = 1 - \\prod_{k=1}^{q_D} \\Pr\\left[\\neg \\mathsf{Fail}_k \\mid \\mathsf{NoFail}_{k-1}\\right]</span>$</p>

    <p class="text-gray-300">and, if we denote by  <span class="math">p_k = \\Pr[\\mathsf{Fail}_k \\mid \\mathsf{NoFail}_{k-1}]</span> , then</p>

    <p class="text-gray-300"><span class="math">$\\Pr[F_2] = 1 - \\prod_{k=1}^{q_D} (1 - p_k) \\le \\sum_{k=1}^{q_D} p_k</span>$</p>

    <p class="text-gray-300">In order to compute  <span class="math">p_k</span> , let us suppose that Game1 and Game2 run identically just until  <span class="math">\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}</span>  is going to submit the k-th query,  <span class="math">\\bar{c}</span> , to the decryption oracle. This implies  <span class="math">\\mathsf{NoFail}_{k-1} \\land \\neg \\mathsf{Askx}</span> . Suppose for a while that  <span class="math">\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}</span>  is in the 'finding' stage. The only information available to the adversary, in order to generate the cyphertext  <span class="math">\\bar{c}</span>  is the view of the game at this execution point, that is  <span class="math">\\mathsf{View} = (pk, \\mathcal{T}_G, \\mathcal{T}_H, \\mathcal{T}_D)</span> . To find an upper bound for  <span class="math">p_k</span> , we will consider the best choice for  <span class="math">\\bar{c}</span> , for each possible  <span class="math">\\mathsf{View}</span>  compatible with  <span class="math">\\mathsf{NoFail}_{k-1}</span> .</p>

    <p class="text-gray-300">The event  <span class="math">\\mathsf{Fail}_k</span>  occurs if and only if  <span class="math">\\mathcal{D}2_{sk}(\\bar{c}) \\neq \\mathcal{D}_{sk}(\\bar{c})</span> , that is,  <span class="math">\\mathcal{D}2_{sk}</span>  rejects  <span class="math">\\bar{c}</span>  (returning  <span class="math">\\bot_2</span> ) while  <span class="math">\\mathcal{D}_{sk}</span>  accepts it. This means that  <span class="math">\\bar{c} = (f_{pk}(\\bar{x}, \\bar{y})), \\bar{c}_2)</span> , where  <span class="math">\\bar{x} \\in X_{pk} \\setminus \\mathcal{T}_G</span> ,  <span class="math">\\bar{y} \\in Y_{pk}</span> ,  <span class="math">\\bar{c}_2 \\in M_\\ell</span> , and the equation  <span class="math">\\bar{y} = H(\\bar{x}, \\mathsf{Dec}_{G(\\bar{x})}^{sym}(\\bar{c}_2))</span>  holds.</p>

    <p class="text-gray-300">If View and  <span class="math">\\bar{c}</span>  are fixed, then  <span class="math">p_k</span>  depends only on the joint probability distribution of  <span class="math">G(\\bar{x})</span>  and  <span class="math">H(\\bar{x}, \\mathsf{Dec}_{G(\\bar{x})}^{sym}(\\bar{c}_2))</span> . But this distribution is conditioned by the answers given by H to the queries  <span class="math">(\\bar{x}, m)</span>  for some m, and the answers given by  <span class="math">\\mathcal{D}_{sk}</span>  to the queries  <span class="math">(f_{pk}(\\bar{x}, y), c_2)</span>  for some  <span class="math">y \\in Y_{pk}</span>  and  <span class="math">c_2 \\in M_\\ell</span> . Notice that any queried ciphertext  <span class="math">c \\notin Z_{pk} \\times M_\\ell</span>  is rejected by  <span class="math">\\mathcal{D}_{sk}</span> , independently of the values taken by the random functions</p>

    <p class="text-gray-300">In the worst case, all queries in  <span class="math">\\mathcal{T}_H</span>  and  <span class="math">\\mathcal{T}_D</span>  are related to  <span class="math">\\bar{x}</span> , that is,  <span class="math">h_i = H(\\bar{x}, m_i)</span>  for  <span class="math">i = 1, \\ldots, q_H</span> , and  <span class="math">c^{(j)} = (f_{pk}(\\bar{x}, y_j), c_2^{(j)})</span>  for  <span class="math">j = 1, \\ldots, k-1</span> . Since  <span class="math">\\bar{x} \\notin \\mathcal{T}_G</span> , then  <span class="math">\\mathcal{D}_{sk}(c^{(j)}) = \\mathcal{D}_{sk}(c^{(j)}) = \\bot_2</span>  and then  <span class="math">y_j \\neq H(\\bar{x}, \\mathsf{Dec}_{G(\\bar{x})}^{sym}(c_2^{(j)}))</span> . These equations could be incompatible for some values of  <span class="math">G(\\bar{x})</span> , namely those  <span class="math">g \\in K_\\ell</span>  such that  <span class="math">m_i = \\mathsf{Dec}_g^{sym}(c_2^{(j)})</span>  and  <span class="math">h_i = y_j</span>  for some (i,j). In the (unfeasible) worst case, all  <span class="math">h_i</span>  and  <span class="math">y_j</span>  are equal and there can be up to  <span class="math">q_H(k-1)\\gamma</span>  forbidden values for  <span class="math">G(\\bar{x})</span> . Then, the random variable  <span class="math">G(\\bar{x})</span>  is uniformly distributed over a set of at least  <span class="math">|K_\\ell| - (k-1)q_H\\gamma</span>  elements.</p>

    <p class="text-gray-300">There are at most  <span class="math">q_H \\gamma</span>  different values of g such that  <span class="math">(\\bar{x}, \\mathsf{Dec}_g^{sym}(\\bar{c}_2)) \\in \\mathcal{T}_H</span> . For these values,  <span class="math">\\bar{y} = H(\\bar{x}, \\mathsf{Dec}_g^{sym}(\\bar{c}_2))</span>  can be ensured if all  <span class="math">h_i</span>  are equal to  <span class="math">\\bar{y}</span> . Thus,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathsf{Fail}_k \\wedge (\\bar{x}, \\mathsf{Dec}^{sym}_{G(\\bar{x})}(\\bar{c}_2)) \\in \\mathcal{T}_H \\mid \\mathsf{View}\\right] \\leq \\frac{q_H \\gamma}{|K_\\ell| - (k-1)q_H \\gamma}</span>$</p>

    <p class="text-gray-300">For any g such that  <span class="math">(\\bar{x}, \\mathsf{Dec}_g^{sym}(\\bar{c}_2)) \\not\\in \\mathcal{T}_H</span> , the variable  <span class="math">H(\\bar{x}, \\mathsf{Dec}_g^{sym}(\\bar{c}_2))</span>  is uniformly distributed over a set of at least  <span class="math">|Y_{pk}| - (k-1)</span>  elements, because if  <span class="math">\\bar{c}_2 = c_2^{(j)}</span> , then the value  <span class="math">y_j</span>  is forbidden. Consequently,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathsf{Fail}_k \\wedge (\\bar{x}, \\mathsf{Dec}_{G(x)}^{sym}(c_2)) \\not\\in \\mathcal{T}_H \\mid \\mathsf{View}\\right] \\leq \\frac{1}{|Y_{pk}| - (k-1)}</span>$</p>

    <p class="text-gray-300">and summing up, we obtain</p>

    <p class="text-gray-300"><span class="math">$p_k^{\\text{find}} \\le \\frac{q_H \\gamma}{|K_\\ell| - (k-1)q_H \\gamma} + \\frac{1}{|Y_{pk}| - (k-1)}</span>$</p>

    <p class="text-gray-300">If  <span class="math">\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}</span>  is in the 'guessing' stage, then  <span class="math">c^*</span>  holds valuable information. In fact, View =  <span class="math">(pk, \\mathcal{T}_G, \\mathcal{T}_H, \\mathcal{T}_D, c^*)</span> , but  <span class="math">c^*</span>  depends only on  <span class="math">G(x^*)</span>  and  <span class="math">H(x^*, m_b)</span> . Thus,</p>

    <p class="text-gray-300">if  <span class="math">\\bar{x} \\neq x^*</span> ,  <span class="math">c^*</span>  does not give any additional information about  <span class="math">\\mathsf{Fail}_k</span>  and everithing goes the same way as in the 'finding' stage.</p>

    <p class="text-gray-300">If  <span class="math">\\bar{x}=x^{\\star}</span> , also the restriction  <span class="math">\\bar{c}\\neq c^{\\star}</span>  must be considered. Moreover, there are no queries in  <span class="math">\\mathcal{T}_H</span>  related to  <span class="math">x^{\\star}</span> . Then, in the worst case, the joint distribution of  <span class="math">G(\\bar{x})</span>  and  <span class="math">H(\\bar{x},\\mathsf{Dec}^{sym}_{G(\\bar{x})}(\\bar{c}_2))</span>  is conditioned by the equations  <span class="math">y_j\\neq H(x^{\\star},\\mathsf{Dec}^{sym}_{G(x^{\\star})}(c_2^{(j)}))</span> , for  <span class="math">j=1\\ldots,k-1,\\,y^{\\star}=H(x^{\\star},m_b)</span>  and  <span class="math">m_b=\\mathsf{Dec}^{sym}_{G(x^{\\star})}(c_2^{\\star})</span> .</p>

    <p class="text-gray-300">The equality  <span class="math">y^* = H(x^*, m_b)</span>  is useless since the only valid ciphertext related to  <span class="math">H(x^*, m_b)</span>  is  <span class="math">c^*</span> . Nevertheless, from  <span class="math">m_b = \\mathsf{Dec}_{G(x^*)}^{sym}(c_2^*)</span> , only a reduced number of values of  <span class="math">G(x^*)</span>  remain possible, but, as above,  <span class="math">H(x^*, \\mathsf{Dec}_{G(x^*)}^{sym}(\\bar{c}_2))</span>  is uniformly</p>

    <p class="text-gray-300">distributed over a set of at least  <span class="math">|Y_{pk}| - (k-1)</span>  elements, and  <span class="math">p_k^{\\text{guess}} \\leq \\frac{1}{|Y_{pk}| - (k-1)}</span> .</p>

    <p class="text-gray-300">Finally,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[F_2\\right] \\leq \\sum_{k=1}^{q_D} \\left(\\frac{q_H \\gamma}{|K_\\ell| - (k-1)q_H \\gamma} + \\frac{1}{|Y_{pk}| - (k-1)}\\right) \\leq \\frac{q_D q_H \\gamma}{|K| - q_D q_H \\gamma} + \\frac{q_D}{|Y| - q_D}</span>$</p>

    <p class="text-gray-300"><strong>Game2'</strong>. In this game, oracles G and H are simulated by using tables  <span class="math">\\mathcal{T}_{G2&#x27;}</span>  and  <span class="math">\\mathcal{T}_{H2&#x27;}</span> , as described in subsection 4.3.</p>

    <p class="text-gray-300">Also, the generation of the ciphertext differs from the one in Game2. Here, in Game2', some values of the random functions are redefined, namely  <span class="math">G(x^*) = g</span>  and  <span class="math">H(x^*, m_b) = y^*</span> . But these changes in the oracles do not affect the probability distribution of the view of  <span class="math">\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}</span> , since in Game2 neither  <span class="math">x^*</span>  is queried to G nor  <span class="math">(x^*, m)</span>  is queried to H, for any m. (Note that, at step 6 of  <span class="math">\\mathcal{D}2_{sk}</span> ,  <span class="math">x \\neq x^*</span>  since  <span class="math">x^* \\notin \\mathcal{T}_G</span> .)</p>

    <pre><code class="language-text">\\begin{aligned} &amp; \\bullet &amp; 1 \\quad \\mathcal{T}_{G2&#x27;} \\leftarrow \\mathsf{empty} \\,; \\, \\mathcal{T}_{H2&#x27;} \\leftarrow \\mathsf{empty} \\\\ &amp; 2 \\quad (pk,sk) \\leftarrow \\mathsf{KeyGen}(1^\\ell) \\\\ &amp; 3 \\quad b \\leftarrow \\{0,1\\}; \\, \\, x^\\star \\leftarrow X_{pk} \\\\ &amp; 4 \\quad (m_0,m_1,s) \\leftarrow \\mathcal{A}_1^{G2&#x27;,H2&#x27;,\\mathcal{D}2&#x27;_{sk}}(pk) \\\\ &amp; \\bullet &amp; 5 \\quad g \\leftarrow K_\\ell; \\, \\, y^\\star \\leftarrow Y_{pk}; \\, \\, c^\\star \\leftarrow \\left(f_{pk}(x^\\star,y^\\star), \\mathsf{Enc}_g^{sym}(m_b)\\right) \\\\ &amp; 6 \\quad b&#x27; \\leftarrow \\mathcal{A}_2^{G2&#x27;,H2&#x27;,\\mathcal{D}2&#x27;_{sk,c^\\star}}(s,c^\\star) \\\\ &amp; \\mathcal{D}2&#x27;_{sk}(c) \\\\ &amp; 1 \\quad \\text{if } c \\not\\in \\bar{Z}_{pk} \\times M_\\ell; \\, \\, \\text{return } \\perp_1; \\, \\, \\text{endif} \\\\ &amp; 2 \\quad (c_1,c_2) = c \\\\ &amp; 3 \\quad x \\leftarrow g_{sk}(c_1) \\\\ &amp; \\bullet \\quad 4 \\quad \\text{if } x \\not\\in X_{pk} \\, \\text{or } x \\not\\in \\mathcal{T}_{G2&#x27;}; \\, \\, \\text{return } \\perp_2; \\, \\, \\text{endif} \\\\ &amp; 5 \\quad m \\leftarrow \\mathsf{Dec}_{S2&#x27;(x)}^{sym}(c_2) \\\\ &amp; 6 \\quad y \\leftarrow H2&#x27;(x,m) \\\\ &amp; 7 \\quad \\text{if } f_{pk}(x,y) \\neq c_1; \\, \\, \\text{return } \\perp_2; \\, \\, \\text{endif} \\\\ &amp; 8 \\quad \\text{return } m \\end{aligned}
</code></pre>

    <p class="text-gray-300">G2'(x)</p>

    <pre><code class="language-text">• 1 if x \\in T_{G2&#x27;}; return T_{G2&#x27;}(x); endif 2 if x = x^*; exit Game; endif • 3 r \\leftarrow K_\\ell • 4 insert (x,r) in table T_{G2&#x27;} 5 return r

H2&#x27;(x,m)
• 1 if (x,m) \\in T_{H2&#x27;}; return T_{H2&#x27;}(x,m); endif 2 if x = x^*; exit Game; endif • 3 r \\leftarrow Y_{pk} • 4 insert ((x,m),r) in table T_{H2&#x27;}
</code></pre>

    <p class="text-gray-300"><strong>Game3</strong>. In this game, we introduce some modifications to avoid the use of  <span class="math">m_b</span>  in the generation of the target ciphertext. In fact, the differences between using  <span class="math">m_b</span>  and using a random message can be tapped by a new adversary  <span class="math">\\mathcal{A}_{\\mathsf{IND-SYM}(\\mathcal{E}^{sym})} = (\\mathcal{A}_1^{sym}, \\mathcal{A}_2^{sym})</span>  who tries to break the IND-SYM security of  <span class="math">\\mathcal{E}^{sym}</span>  (see 4.1).</p>

    <pre><code class="language-text">1 \\beta \\leftarrow \\{0,1\\}
   2 (\\mu_0, \\mu_1, \\sigma) \\leftarrow \\mathcal{A}_1^{sym}(1^{\\ell})

3 g \\leftarrow K_{\\ell}; \\ \\kappa^{\\star} = \\operatorname{Enc}_g^{sym}(\\mu_{\\beta})

4 \\beta&#x27; \\leftarrow \\mathcal{A}_2^{sym}(\\sigma, \\kappa^{\\star})
\\mathcal{A}_1^{sym}(1^{\\ell})
    1 \\mathcal{T}_{G3} \\leftarrow \\mathsf{empty} \\; ; \\; \\mathcal{T}_{H3} \\leftarrow \\mathsf{empty}
     2 (pk, sk) \\leftarrow \\mathsf{KeyGen}(1^{\\ell})
   3 b \\leftarrow \\{0,1\\}; \\ x^* \\leftarrow X_{pk}
4 (m_0, m_1, s) \\leftarrow \\mathcal{A}_1^{G3,H3,\\mathcal{D}3_{sk}}(pk)
    6 \\sigma = (\\mathcal{T}_{G3}, \\mathcal{T}_{H3}, pk, sk, b, x^*, s)
    7 return (m_b, m, \\sigma)
\\mathcal{A}_2^{sym}(\\sigma,\\kappa^\\star)
     1 (T_{G3}, T_{H3}, pk, sk, b, x^*, s) = \\sigma
    2 y^{\\star} \\leftarrow Y_{pk}; c^{\\star} \\leftarrow (f_{pk}(x^{\\star}, y^{\\star}), \\kappa^{\\star})
3 b&#x27; \\leftarrow \\mathcal{A}_2^{G3,H3,\\mathcal{D}3_{sk,c^{\\star}}}(s, c^{\\star})
     4 \\beta&#x27;&#x27; \\leftarrow 0
    5 if b&#x27; = b
                    \\beta&#x27; \\leftarrow 0
             else
                    \\beta&#x27; \\leftarrow 1
           endif
\\mathcal{D}3_{sk}(c)
</code></pre>

    <p class="text-gray-300">Game3()</p>

    <pre><code class="language-text">1 if c \\notin \\bar{Z}_{pk} \\times M_{\\ell}; return \\perp_1; endif
    (c_1, c_2) = c
    x \\leftarrow g_{sk}(c_1)
• 4 if x \\notin X_{pk} or x \\notin T_{G3}; return \\perp_2; endif
   5 m \\leftarrow \\operatorname{Dec}_{G3(x)}^{sym}(c_2)
    6 y \\leftarrow H3(x,m)
    7 if f_{pk}(x,y) \\neq c_1; return \\perp_2; endif
    8 return m
 G3(x)
    1 if x \\in \\mathcal{T}_{G3}; return \\mathcal{T}_{G3}(x); endif
    2 if x = x^*
           \\beta&#x27; \\leftarrow \\{0,1\\}
            \\beta&#x27;&#x27; \\leftarrow 1
            exit Game
    6 endif
    7 r \\leftarrow K_{\\ell}
    8 insert (x,r) in table \\mathcal{T}_{G3}
        return r
 H3(x,m)
• 1 if (x,m) \\in \\mathcal{T}_{H3}; return \\mathcal{T}_{H3}(x,m); endif
    2 if x = x^*
           \\beta&#x27; \\leftarrow \\{0,1\\}
            \\beta&#x27;&#x27; \\leftarrow 1
            exit Game
    6 endif
    7 r \\leftarrow Y_{pk}
    8 insert ((x,m),r) in table \\mathcal{T}_{H3}
        return r
</code></pre>

    <p class="text-gray-300">Actually,  <span class="math">\\mathcal{A}_{\\mathsf{IND-SYM}(\\mathcal{E}^{sym})}</span>  uses two different ways to guess the value of  <span class="math">\\beta</span> :  <span class="math">\\beta&#x27;</span>  indicates if  <span class="math">\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}</span>  guesses the correct value of b and  <span class="math">\\beta&#x27;&#x27;</span>  indicates if  <span class="math">\\mathsf{S}_1</span>  occurs. Then, two different advantages can be taken into account:  <span class="math">\\mathsf{Adv}\\left[\\mathcal{A}_{\\mathsf{IND-SYM}(\\mathcal{E}^{sym})}\\right] = |\\mathsf{2Pr}_3\\left[\\beta&#x27; = \\beta\\right] - 1|</span>  and  <span class="math">\\mathsf{Adv}\\left[\\mathcal{A}_{\\mathsf{IND-SYM}(\\mathcal{E}^{sym})}\\right]&#x27; = |\\mathsf{2Pr}_3\\left[\\beta&#x27;&#x27; = \\beta\\right] - 1|</span> .</p>

    <p class="text-gray-300">If  <span class="math">\\beta=1</span> , the value of  <span class="math">m_b</span>  is used nowhere in the game. So, the view of  <span class="math">\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}</span>  is independent of b and  <span class="math">\\mathsf{Pr}_3\\left[\\beta&#x27;=1\\mid\\beta=1\\land\\neg\\mathsf{S}_1\\right]=\\mathsf{Pr}_3\\left[b&#x27;\\neq b\\mid\\beta=1\\land\\neg\\mathsf{S}_1\\right]=\\frac{1}{2}.</span>  Moreover,  <span class="math">\\mathsf{Pr}_3\\left[\\beta&#x27;=1\\mid\\beta=1\\land\\mathsf{S}_1\\right]=\\frac{1}{2}</span>  and then  <span class="math">\\mathsf{Pr}_3\\left[\\beta&#x27;=1\\mid\\beta=1\\right]=\\frac{1}{2}.</span></p>

    <p class="text-gray-300">If  <span class="math">\\beta = 0</span> , Game3 and Game2' are identical. Thus</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Pr}_{\\mathsf{3}}\\left[\\beta&#x27; = 0 \\land \\neg \\mathsf{S}_{\\mathsf{1}} \\mid \\beta = 0\\right] = \\mathsf{Pr}_{\\mathsf{3}}\\left[b&#x27; = b \\land \\neg \\mathsf{S}_{\\mathsf{1}} \\mid \\beta = 0\\right] = \\mathsf{Pr}_{\\mathsf{2}}\\left[\\mathsf{S}_{\\mathsf{01}}\\right]</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Pr}_{3}\\left[\\beta&#x27;=0 \\land \\mathsf{S}_{1} \\mid \\beta=0\\right] = \\frac{1}{2} \\mathsf{Pr}_{3}\\left[\\mathsf{S}_{1} \\mid \\beta=0\\right] = \\frac{1}{2} \\mathsf{Pr}_{2}\\left[\\mathsf{S}_{1}\\right]</span>$</p>

    <p class="text-gray-300">Putting altogether,</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{ll} \\mathsf{Adv}\\left[\\mathcal{A}_{\\mathsf{IND-SYM}(\\mathcal{E}^{sym})}\\right] &amp;= |2\\mathsf{Pr}_3\\left[\\beta&#x27; = 0 \\land \\beta = 0\\right] + 2\\mathsf{Pr}_3\\left[\\beta&#x27; = 1 \\land \\beta = 1\\right] - 1| = \\\\ &amp;= |\\mathsf{Pr}_3\\left[\\beta&#x27; = 0 \\mid \\beta = 0\\right] + \\mathsf{Pr}_3\\left[\\beta&#x27; = 1 \\mid \\beta = 1\\right] - 1| = \\\\ &amp;= |\\mathsf{Pr}_2\\left[\\mathsf{S}_{01}\\right] + \\frac{1}{2}\\mathsf{Pr}_2\\left[\\mathsf{S}_{1}\\right] - \\frac{1}{2}| = \\frac{1}{2}\\left|\\mathsf{Pr}_2\\left[\\mathsf{S}_{01}\\right] - \\mathsf{Pr}_2\\left[\\mathsf{S}_{00}\\right]\\right| \\end{array}</span>$</p>

    <p class="text-gray-300">If  <span class="math">\\beta&#x27;&#x27;</span>  is used instead of  <span class="math">\\beta&#x27;</span> , then</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{ll} \\mathsf{Adv} \\left[ \\mathcal{A}_{\\mathsf{IND-SYM}(\\mathcal{E}^{sym})} \\right]&#x27; &amp;= |2\\mathsf{Pr}_3 \\left[ \\mathsf{S}_1 \\wedge \\beta&#x27;&#x27; = \\beta \\right] + 2\\mathsf{Pr}_3 \\left[ \\neg \\mathsf{S}_1 \\wedge \\beta&#x27;&#x27; = \\beta \\right] - 1| = \\\\ &amp;= |2\\mathsf{Pr}_3 \\left[ \\mathsf{S}_1 \\wedge \\beta = 1 \\right] + 2\\mathsf{Pr}_3 \\left[ \\neg \\mathsf{S}_1 \\wedge \\beta = 0 \\right] - 1| = \\\\ &amp;= |\\mathsf{Pr}_3 \\left[ \\mathsf{S}_1 \\mid \\beta = 1 \\right] + (\\mathsf{Pr}_3 \\left[ \\neg \\mathsf{S}_1 \\mid \\beta = 0 \\right] - 1)| = \\\\ &amp;= |\\mathsf{Pr}_3 \\left[ \\mathsf{S}_1 \\mid \\beta = 1 \\right] - \\mathsf{Pr}_2 \\left[ \\mathsf{S}_1 \\right]| \\end{array}</span>$</p>

    <p class="text-gray-300">Finally,</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathsf{Adv}\\left[\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}\\right] &amp; \\leq \\mathsf{Pr}_2\\left[\\mathsf{S}_1\\right] + |\\mathsf{Pr}_2\\left[\\mathsf{S}_{01}\\right] - \\mathsf{Pr}_2\\left[\\mathsf{S}_{00}\\right]| + 2\\mathsf{Pr}\\left[F_2\\right] = \\\\ &amp; = \\mathsf{Pr}_2\\left[\\mathsf{S}_1\\right] + 2\\mathsf{Adv}\\left[\\mathcal{A}_{\\mathsf{IND-SYM}(\\mathcal{E}^{sym})}\\right] + 2\\mathsf{Pr}\\left[F_2\\right] \\leq \\\\ &amp; \\leq \\mathsf{Pr}_3\\left[\\mathsf{S}_1\\mid\\beta=1\\right] + 2\\mathsf{Adv}\\left[\\mathcal{A}_{\\mathsf{IND-SYM}(\\mathcal{E}^{sym})}\\right]&#x27; + 2\\mathsf{Pr}\\left[F_2\\right] \\\\ &amp; + \\mathsf{Adv}\\left[\\mathcal{A}_{\\mathsf{IND-SYM}(\\mathcal{E}^{sym})}\\right]&#x27; + 2\\mathsf{Pr}\\left[F_2\\right] \\end{split}</span>$</p>

    <p class="text-gray-300"><strong>Game4</strong>. Game3 (with  <span class="math">\\beta = 0</span> ) can be modified to obtain an implementation of an adversary,  <span class="math">\\mathcal{A}_{\\mathsf{POW}(f)}</span> , that try to break the partial one-wayness of f. This adversary will know neither sk nor  <span class="math">x^*</span> . The use of sk in the decryption oracle simulator and the use of  <span class="math">x^*</span>  in the random oracle simulators are avoided conveniently using the deterministic plaintext checking algorithm  <span class="math">\\mathcal{V}</span> . The value of  <span class="math">x^*</span>  is guessed by  <span class="math">\\mathcal{A}_{\\mathsf{POW}(f)}</span>  when possible (i.e. if  <span class="math">\\mathsf{S}_1</span>  occurs).</p>

    <p class="text-gray-300">These changes do not modify any probability. Moreover, the views of  <span class="math">\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}</span>  in games 3 (with  <span class="math">\\beta = 0</span> ) and 4 are identically distributed.</p>

    <pre><code class="language-text">Game4()
       1 (pk, sk) \\leftarrow \\mathsf{KevGen}(1^{\\ell})
       2 \\quad \\overset{\\leftarrow}{x^{\\star}} \\leftarrow \\overset{\\leftarrow}{X_{pk}}; \\ y^{\\star} \\leftarrow \\overset{\\leftarrow}{Y_{pk}}; \\ z \\leftarrow f_{pk}(x^{\\star}, y^{\\star})
       \\mathcal{A}_{\\mathsf{POW}(f)}(pk, z^{\\star})
   \\mathcal{A}_{\\mathsf{POW}(f)}(pk,z)
       1 b \\leftarrow \\{0, 1\\}
       2 m \\leftarrow M_{\\ell}; g \\leftarrow K_{\\ell}; c^{\\star} \\leftarrow (z, \\operatorname{Enc}_{q}^{sym}(m))
      3 T_{G4} \\leftarrow \\text{empty}; T_{H4} \\leftarrow \\text{empty}

4 (m_0, m_1, s) \\leftarrow \\mathcal{A}_1^{G4, H4, \\mathcal{D}4_{pk}}(pk)

5 b&#x27; \\leftarrow \\mathcal{A}_2^{G4, H4, \\mathcal{D}4_{pk, c^*}}(s, c^*)
• 6 x&#x27; \\leftarrow X_{nk}
   G4(x)
       if x \\in \\mathcal{T}_{G4}; return \\mathcal{T}_{G4}(x); endif
\\bullet \\quad \\text{2} \\quad \\text{if } x \\in X_{pk} \\text{ and } \\mathcal{V}(pk,x,z) = 1
                    x&#x27; \\leftarrow x
                     exitGame
       5 endif
       6 r \\leftarrow K_{\\ell}
</code></pre>

    <pre><code class="language-text">7 insert (x,r) in table \\mathcal{T}_{G4}
         return r
  H4(x,m)
    if (x,m) \\in \\mathcal{T}_{H4}; return \\mathcal{T}_{H4}(x,m); endif
   2 if x \\in X_{pk} and \\mathcal{V}(pk,x,z)=1
             x&#x27; \\leftarrow x
             exitGame
         endif
       r \\leftarrow Y_{pk}
       insert ((x,m),r) in table \\mathcal{T}_{H4}
         return r
  \\mathcal{D}4_{pk}(c)
    1 if c \\notin \\bar{Z}_{pk} \\times M_{\\ell}; return \\perp_1; endif
        (c_1, c_2) = c
   3 foreach x \\in \\mathcal{T}_{G4}
              \\begin{aligned} &amp;\\text{if } x \\in X_{pk} \\text{ and } \\mathcal{V}(pk, x, c_1) = 1 \\\\ &amp;m \\leftarrow \\mathsf{Dec}^{sym}_{\\mathcal{T}_{G4}(x)}(c_2) \\end{aligned}
                 y \\leftarrow H4(x,m)
                 if f_{pk}(x,y) \\neq c_1; return \\perp_2; endif
    7
    8
                  return m
              endif
• 10 endforeach
   11 return \\perp_2
</code></pre>

    <p class="text-gray-300">Now.</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Succ}\\left[\\mathcal{A}_{\\mathsf{POW}(f)}\\right] = \\mathsf{Pr_4}\\left[x&#x27; = x^\\star\\right] \\geq \\mathsf{Pr_4}\\left[\\mathsf{S_1}\\right] = \\mathsf{Pr_3}\\left[\\mathsf{S_1} \\mid \\beta = 1\\right]</span>$</p>

    <p class="text-gray-300">and, from the above results,</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathsf{Adv} \\left[ \\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})} \\right] &amp;\\leq \\mathsf{Succ} \\left[ \\mathcal{A}_{\\mathsf{POW}(f)} \\right] + 2 \\mathsf{Adv} \\left[ \\mathcal{A}_{\\mathsf{IND-SYM}(\\mathcal{E}^{sym})} \\right] + \\\\ &amp;+ \\mathsf{Adv} \\left[ \\mathcal{A}_{\\mathsf{IND-SYM}(\\mathcal{E}^{sym})} \\right]&#x27; + \\frac{2q_D q_H \\gamma}{|K| - q_D q_H \\gamma} + \\frac{2q_D}{|Y| - q_D} \\end{split}</span>$</p>

    <p class="text-gray-300">In terms of time complexity of the algorithms, the overhead introduced by the simulation of the random oracles, G and H, in games 3 and 4 can be reduced by using standard hashing techniques for table insertion and searching. In fact, in almost all security proofs in the Random Oracle Model in the literature, this time overhead is neglected. It is also supposed that the times needed to check if  <span class="math">c \\in \\bar{Z}_{pk} \\times M_{\\ell}</span>  and  <span class="math">x \\in X_{pk}</span>  are negligible.</p>

    <p class="text-gray-300">Neglecting lower order terms, the running time of  <span class="math">\\mathcal{A}_{\\mathsf{POW}(f)}</span>  in Game4 is bounded by</p>

    <p class="text-gray-300"><span class="math">$T[\\mathcal{A}_{\\mathsf{POW}(f)}] \\leq (q_G + q_H + q_D + q_G q_D) T[\\mathcal{V}] + q_D \\Big( T[f] + T[\\mathsf{Dec}^{sym}] \\Big) + T[\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}]</span>$</p>

    <p class="text-gray-300">where  <span class="math">T[\\mathcal{V}]</span>  is the time complexity of the plaintext checking algoritm and T[f] is the time complexity of f. Also,  <span class="math">T[\\mathcal{A}_{\\mathsf{IND-SYM}(\\mathcal{E}^{sym})}] = T[\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}]</span> .</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">A.1 Particular cases</h3>

    <p class="text-gray-300">Both in the case of the trivial construction of easy verifiable functions and in the non-trivial family in subsection 3.1, the algorithm  <span class="math">\\mathcal{D}4_{pk}</span>  can be improved, without modifying the behavior of the game, to avoid exhaustive search in  <span class="math">\\mathcal{T}_{G4}</span> . To do it, (f'(x), (x, G(x))) is stored in another table  <span class="math">\\mathcal{T}&#x27;_{G4}</span>  for each query  <span class="math">x \\in X_{pk}</span>  to G.</p>

    <pre><code class="language-text">G4&#x27;(x)
     1 if x \\in \\mathcal{T}_{G4}; return \\mathcal{T}_{G4}(x); endif
   2 if x \\in X_{pk} and \\mathcal{V}(pk,x,z)=1
              x&#x27; \\leftarrow x
              exitGame
     5 endif
     6 r \\leftarrow K_{\\ell}
     7 insert (x,r) in table \\mathcal{T}_{G4}
   8 if x \\in X_{pk}
           insert (f&#x27;(x), (x, r)) in table \\mathcal{T}&#x27;_{G4}
• 10 endif
   11 return r
  \\mathcal{D}4&#x27;_{nk}(c)
     1 if c \\notin \\bar{Z}_{pk} \\times M_{\\ell}; return \\perp_1; endif
     (c_1, c_2) = c
• 3 z&#x27; \\leftarrow \\pi&#x27;_{pk}(c_1)

• 4 if z&#x27; \\in T&#x27;_{G4}

• 5 (x,g) \\leftarrow T&#x27;_{G4}(z&#x27;)

6 m \\leftarrow \\mathsf{Dec}^{sym}(c_2)

7 y \\leftarrow H4(x,m)
              if f_{pk}(x,y) \\neq c_1; return \\perp_2; endif
              return m
   10
               endif
   11 return \\perp_2
</code></pre>

    <p class="text-gray-300">The same standard hashing techniques used in the simulation of G and H can be also used here to maintain  <span class="math">\\mathcal{T}&#x27;_{G4}</span> , so the time overhead of step 4 in  <span class="math">\\mathcal{D}4&#x27;_{pk}</span>  and step 9 in G4' can be neglected.</p>

    <p class="text-gray-300">Then,</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} T[\\mathcal{A}_{\\mathsf{POW}(f)}] &amp; \\leq (q_G + q_H + q_D)T[\\mathcal{V}] + q_G T[f&#x27;] + \\\\ &amp; + q_D \\Big(T[f] + T[\\pi&#x27;] + T[\\mathsf{Dec}^{sym}]\\Big) + T[\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}] \\end{split}</span>$</p>

`;
---

<BaseLayout title="3 Easy verifiable functions (2003/107)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2003 &middot; eprint 2003/107
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="3-easy-verifiable-functions-2003" />
  </article>
</BaseLayout>
