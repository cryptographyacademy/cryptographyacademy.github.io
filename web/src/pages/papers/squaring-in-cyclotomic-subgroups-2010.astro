---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2010/542';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-17';
---

<BaseLayout title="Squaring in cyclotomic subgroups (2010/542)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4">
        Squaring in cyclotomic subgroups
      </h1>
      <p class="text-gray-400 mb-2">
        Koray Karabina
      </p>
      <p class="text-gray-500 text-sm mb-4">
        2010 &middot; Full Version &middot; eprint 2010/542
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
        &middot; 367s on modal (Tesla T4)
        &middot; sha256:e31617807f8fe1eb...
      </p>
    </header>

    <section class="paper-content">
      <h4 id="koray-karabina" class="text-lg font-semibold mt-6 mb-2">KORAY KARABINA</h4>
      <p class="text-gray-300">ABSTRACT. We propose new squaring formulae for cyclotomic subgroups of certain finite fields. Our formulae use a compressed representation of elements having the property that decompression can be performed at a very low cost. The squaring formulae lead to new exponentiation algorithms in cyclotomic subgroups which outperform the fastest previously-known exponentiation algorithms when the exponent has low Hamming weight. Our algorithms can be adapted to accelerate the final exponentiation step of pairing computations.</p>
      <h4 id="1-introduction" class="text-lg font-semibold mt-6 mb-2">1. Introduction</h4>
      <p class="text-gray-300">One challenge in cryptography is to achieve a desired level of security in the most efficient way. The efficiency can generally be improved if one can implement a cryptosystem with more compact parameters. An example in the context of discrete logarithm cryptosystems is the performance of 256-bit elliptic curve groups defined over 256-bit finite fields versus 256-bit subgroups of 3072-bit finite field groups. Even though both systems are believed to provide 128-bit security with a careful choice of parameters, the former leads to a more efficient implementation than the latter mainly because the points in the corresponding elliptic curve group are represented with fewer bits than the elements in the subgroup of the corresponding finite field group.</p>
      <p class="text-gray-300">In recent years, there have been several proposals to represent the elements of cyclotomic subgroups of finite field groups with fewer bits than is required in their natural representation and to compute with the compressed representation of elements [26, 9, 5, 18, 8, 22, 30, 29, 25, 15, 16, 27, 14]. These methods help close the gap between the efficiency of elliptic curve cryptosystems and finite field based cryptosystems. A related research objective is to improve the efficiency of finite field arithmetic using the special structure of cyclotomic subgroups. The most recent work is by Granger and Scott [12] who improved and extended the results in [10] and [28]. They showed that if  <span class="math">q \equiv 1 \pmod&#123;6&#125;</span>  then the squaring operation in the order- <span class="math">(q^2 - q + 1)</span>  cyclotomic subgroup of  <span class="math">\mathbb&#123;F&#125;_&#123;q^6&#125;^*</span>  can be performed at a cost of only 6 multiplications in  <span class="math">\mathbb&#123;F&#125;_q</span>  (or 3 squarings in  <span class="math">\mathbb&#123;F&#125;_&#123;q^2&#125;</span> ).</p>
      <p class="text-gray-300">We should emphasize that there are squaring algorithms that work with compressed representations of elements and that are faster than the method proposed in [12] for the order- <span class="math">(q^2 - q + 1)</span>  cyclotomic subgroup G of  <span class="math">\mathbb&#123;F&#125;_&#123;q^6&#125;^*</span> . For example, if  <span class="math">g \in G</span>  then one can adapt the XTR technique [18] to compute  <span class="math">\mathrm&#123;Tr&#125;_&#123;\mathbb&#123;F&#125;_&#123;q^6&#125;/\mathbb&#123;F&#125;_&#123;q^2&#125;&#125;(g^2)</span>  from  <span class="math">\mathrm&#123;Tr&#125;_&#123;\mathbb&#123;F&#125;_&#123;q^6&#125;/\mathbb&#123;F&#125;_&#123;q^2&#125;&#125;(g)</span>  at a cost dominated by 2 multiplications in  <span class="math">\mathbb&#123;F&#125;_q</span> . However, since the trace function is not multiplicative, many cyptographic protocols that require multiplying more than two elements in G do not seem to benefit from this fast trace-based squaring method. In particular, given only the traces of elements, the cost of recovering the full representation of these elements (decompression) and also the cost of multiplication with the trace representation greatly dominate the cost of multiplying two elements given in their natural representations in  <span class="math">\mathbb&#123;F&#125;_&#123;q^6&#125;</span> . In addition, even though the trace-based methods yield single-exponentiation and double-exponentiation algorithms that are faster than their conventional counterparts, it is not known how to use trace-based methods in general multi-exponentiation</p>
      <p class="text-gray-300">Date: October 22, 2010.</p>
      <p class="text-gray-300">Key words and phrases. Cyclotomic subgroups, squaring, pairing-based cryptography.</p>
      <p class="text-gray-300">algorithms. Therefore, it is natural to look for squaring formulae that work with compressed representations and can be effectively incorporated into cryptographic applications.</p>
      <p class="text-gray-300">In Section 2 we classify the known squaring techniques for cyclotomic subgroups in two categories: those that work with natural representation of elements, and those that work with compressed representation of elements. We will focus on the order  <span class="math">(q^2 - q + 1)</span> -cyclotomic subgroup G of  <span class="math">\mathbb&#123;F&#125;_&#123;q^6&#125;^*</span>  as this seems to be the most interesting case with respect to some potential applications in pairing-based cryptography. In Section 3, we present a new formula for squaring elements in G when  <span class="math">q \equiv 1 \pmod&#123;6&#125;</span> . We first describe a function C that compresses elements  <span class="math">g \in G</span>  by a factor of 3/2, and describe a decompression function  <span class="math">\mathcal&#123;D&#125;</span>  that can be computed very efficiently and satisfies  <span class="math">\mathcal&#123;D&#125;(\mathcal&#123;C&#125;(q)) = q</span>  for all  <span class="math">q \in G</span> . Our new squaring method works with this compressed form of elements. Given  <span class="math">\mathcal&#123;C&#125;(g)</span> , the cost of computing  <span class="math">\mathcal&#123;C&#125;(g^2)</span>  is dominated by 4 multiplications in  <span class="math">\mathbb&#123;F&#125;_q</span>  (or 2 squarings in  <span class="math">\mathbb&#123;F&#125;_&#123;q^2&#125;</span> ). Note that this is 33% faster than the method described in [12]. The efficient decompression will permit us to effectively utilize the squaring formula in exponentiation algorithms, especially when the exponent has low Hamming weight. In Section 4, we discuss some applications of our squaring formula and provide some comparisons based on operation counts. In Section 5, we describe a more general technique to search for efficient squaring formulae. As a result, we discover other squaring formulae some of which seem to offer better performance in particular cases. Section 5 also shows that some of the previously-known squaring formulae can be obtained via our search method. In Section 6, we compare our new squaring formulae and the squaring formulae in [12]. We conclude in Section 7.</p>
      <p class="text-gray-300">Let  <span class="math">\mathbb&#123;F&#125;_q</span>  be a finite field with q elements and characteristic not equal to 2 or 3. For simplicity, we first assume that q=p is prime. We denote by  <span class="math">G_&#123;\Phi_6(p)&#125;</span>  the order- <span class="math">\Phi_6(p)</span>  cyclotomic subgroup of  <span class="math">\mathbb&#123;F&#125;_&#123;p^6&#125;^*</span> . Here,  <span class="math">\Phi_i(p)</span>  denotes the ith cyclotomic polynomial evaluated at p, and  <span class="math">|G_s|=s</span> . Note that  <span class="math">|G_&#123;\Phi_6(p)&#125;|=p^2-p+1</span> . Since  <span class="math">\mathbb&#123;F&#125;_&#123;p^6&#125;</span>  is the smallest extension of  <span class="math">\mathbb&#123;F&#125;_p</span>  that contains  <span class="math">G_&#123;\Phi_6(p)&#125;</span> , an element  <span class="math">g\in G_&#123;\Phi_6(p)&#125;</span>  is naturally represented with 6  <span class="math">\mathbb&#123;F&#125;_p</span> -elements. However, exploiting the algebraic structure of  <span class="math">G_&#123;\Phi_6(p)&#125;</span> , one can represent  <span class="math">g\in G_&#123;\Phi_6(p)&#125;</span>  with 3 or even with 2  <span class="math">\mathbb&#123;F&#125;_p</span> -elements yielding more compact representations by factor 2 or 3. Trace-based compression and torus-based compression are the two known methods to achieve factor 2 and 3 compression in  <span class="math">G_&#123;\Phi_6(p)&#125;</span> . [26, 18, 22]. We summarize next the fastest previously-known squaring algorithms in  <span class="math">G_&#123;\Phi_6(p)&#125;</span> . These algorithms fall into two categories: those that work with compressed representation of elements, and those that work with full representation of elements.</p>
      <h2 id="2-1-compressed-representations" class="text-2xl font-bold mt-10 mb-4">2.1. Compressed representations.</h2>
      <p class="text-gray-300">2.1.1. <strong>Trace-based squaring:</strong> Let  <span class="math">\operatorname&#123;Tr&#125;_&#123;p^i,p^j&#125;</span>  denote the trace function  <span class="math">\operatorname&#123;Tr&#125;_&#123;\mathbb&#123;F&#125;_&#123;p^i&#125;/\mathbb&#123;F&#125;_&#123;p^j&#125;&#125;: \mathbb&#123;F&#125;_&#123;p^i&#125; \to \mathbb&#123;F&#125;_&#123;p^j&#125;</span> . Elements  <span class="math">g \in G_&#123;\Phi_6(p)&#125;</span>  can be uniquely represented by their traces  <span class="math">\operatorname&#123;Tr&#125;_&#123;p^6,p^3&#125;(g)</span>  (upto conjugation over  <span class="math">\mathbb&#123;F&#125;_&#123;p^3&#125;</span> ) [26], or  <span class="math">\operatorname&#123;Tr&#125;_&#123;p^6,p^2&#125;(g)</span>  (upto conjugation over  <span class="math">\mathbb&#123;F&#125;_&#123;p^2&#125;</span> ) [18]. More interestingly, one can compute  <span class="math">\operatorname&#123;Tr&#125;_&#123;p^6,p^3&#125;(g^2)</span>  and  <span class="math">\operatorname&#123;Tr&#125;_&#123;p^6,p^2&#125;(g^2)</span>  given  <span class="math">\operatorname&#123;Tr&#125;_&#123;p^6,p^3&#125;(g)</span>  and  <span class="math">\operatorname&#123;Tr&#125;_&#123;p^6,p^2&#125;(g)</span> , respectively. The corresponding squaring algorithms are known as LUC squaring and XTR squaring, respectively.</p>
      <p class="text-gray-300"><strong>LUC-squaring:</strong>  <span class="math">\operatorname&#123;Tr&#125;_&#123;p^6,p^3&#125;(g^2) = \operatorname&#123;Tr&#125;_&#123;p^6,p^3&#125;(g)^2 - 2</span> . The cost of LUC-squaring is dominated by 1 squaring in  <span class="math">\mathbb&#123;F&#125;_&#123;p^3&#125;</span> .</p>
      <p class="text-gray-300"><strong>XTR-squaring:</strong>  <span class="math">\operatorname&#123;Tr&#125;_&#123;p^6,p^2&#125;(g^2) = \operatorname&#123;Tr&#125;_&#123;p^6,p^2&#125;(g)^2 - 2\operatorname&#123;Tr&#125;_&#123;p^6,p^2&#125;(g)^p</span> . The cost of XTR-squaring is dominated by 1 squaring in  <span class="math">\mathbb&#123;F&#125;_&#123;p^2&#125;</span>  (since the cost of the Frobenius  <span class="math">c \mapsto c^p</span>  is negligible for  <span class="math">c \in \mathbb&#123;F&#125;_&#123;p^2&#125;</span> ).</p>
      <p class="text-gray-300">2.1.2. <strong>Torus-based squaring:</strong> Let  <span class="math">\mathbb&#123;F&#125;_&#123;p^6&#125; = \mathbb&#123;F&#125;_&#123;p^3&#125;(\sigma)</span>  where  <span class="math">\sigma</span>  is a root of  <span class="math">x^2 - c</span>  for some quadratic non-residue  <span class="math">c \in \mathbb&#123;F&#125;_&#123;p^3&#125;</span> . Elements  <span class="math">g = g_0 + g_1 \sigma \in G_&#123;\Phi_6(p)&#125; \setminus \&#123;\pm 1\&#125;</span>  can be uniquely represented by  <span class="math">\alpha = (g_0 + 1)/g_1 \in \mathbb&#123;F&#125;_&#123;p^3&#125;</span> . In fact, if  <span class="math">\alpha \in \mathbb&#123;F&#125;_&#123;p^3&#125;</span>  is the compact representation of  <span class="math">g \in G_&#123;\Phi_6(p)&#125;</span>  then  <span class="math">g = (\alpha + \sigma)/(\alpha - \sigma)</span>  and  <span class="math">g^2 = (\alpha^2 + c + 2\alpha\sigma)/(\alpha^2 + c - 2\alpha c)</span> ; see [23]. Now, given  <span class="math">g^&#123;2^i&#125; = (x + y\sigma)/(x - y\sigma) \in G_&#123;\Phi_6(p)&#125;</span>  for some  <span class="math">x, y \in \mathbb&#123;F&#125;_&#123;p^3&#125;</span> , one can write  <span class="math">g^&#123;2^&#123;i+1&#125;&#125; = (x^2 + y^2c + 2xy\sigma)/(x^2 + y^2c - 2xy\sigma)</span> . In order to avoid the inversion operation in the squaring formula, one can encode an element  <span class="math">g = (x + y\sigma)/(x - y\sigma) \in G_&#123;\Phi_6(p)&#125; \setminus \&#123;\pm 1\&#125;</span>  with  <span class="math">\mathcal&#123;P&#125;(g) = [x, y]</span>  and compute  <span class="math">\mathcal&#123;P&#125;(g^2) = [x^2 + y^2c, 2xy]</span> , the (unique) representative of  <span class="math">g^2</span> . This is so-called squaring with mixed/projective coordinates; see, for example, [11]. We call this the TB2-squaring method as it uses factor-2 torus-based compression.</p>
      <p class="text-gray-300"><strong>TB2-squaring:</strong>  <span class="math">\mathcal&#123;P&#125;(g^2) = [x^2 + y^2c, 2xy]</span> , where  <span class="math">\mathcal&#123;P&#125;(g) = [x, y]</span> . The cost of TB2-squaring is dominated by 2 multiplications in  <span class="math">\mathbb&#123;F&#125;_&#123;p^3&#125;</span>  because  <span class="math">x^2 + y^2c = (x + yc)(x + y) - (c + 1)xy</span>  and we can ignore the cost of addition, subtraction, and multiplication by c.</p>
      <p class="text-gray-300">Remark 2.1. Given  <span class="math">g = (\alpha + \sigma)/(\alpha - \sigma) \in G_&#123;\Phi_6(p)&#125;</span>  for some  <span class="math">\alpha \in \mathbb&#123;F&#125;_&#123;p^3&#125;</span> , one can exploit the algebraic structure of  <span class="math">G_&#123;\Phi_6(p)&#125;</span>  to further compress  <span class="math">\alpha</span>  to two  <span class="math">\mathbb&#123;F&#125;_p</span> -elements [22, 11]. One can then define TB3-squaring analogous to TB2-squaring. However, to the author's knowledge, this extra structure hast not yet been exploited to derive efficient TB3-squaring formulae. For example, it was reported in [11] that the cost of a TB3-squaring that uses the factor-3 torus-based compressed representation of elements in  <span class="math">G_&#123;\Phi_6(p)&#125;</span>  is 21 multiplications, 38 additions and 1 inversion in  <span class="math">\mathbb&#123;F&#125;_p</span>  (when  <span class="math">p \equiv 2, 5 \pmod&#123;9&#125;</span> ). Even though the inversion can be eliminated by using mixed/projective coordinates as in TB2-squaring, the cost is still dominated by 21 multiplications in  <span class="math">\mathbb&#123;F&#125;_p</span> , which is more expensive than the above TB2-squaring.</p>
      <p class="text-gray-300">2.2. Full representations. The squaring formulae that work with the natural representation of g can be summarized as below.</p>
      <p class="text-gray-300"><strong>General squaring:</strong> Let  <span class="math">\mathbb&#123;F&#125;_&#123;p^6&#125; = \mathbb&#123;F&#125;_&#123;p^3&#125;(\sigma)</span> , where  <span class="math">\sigma</span>  is a root of  <span class="math">\sigma^2 - c</span>  for some quadratic non-residue in  <span class="math">\mathbb&#123;F&#125;_&#123;p^3&#125;</span> . Let  <span class="math">g = g_0 + g_1 \sigma \in \mathbb&#123;F&#125;_&#123;p^6&#125;^*</span> . Then  <span class="math">g^2 = (g_0^2 + g_1^2 c) + 2g_0 g_1 \sigma</span>  can be computed at a cost dominated by 2 multiplications in  <span class="math">\mathbb&#123;F&#125;_&#123;p^3&#125;</span>  because  <span class="math">g_0^2 + g_1^2 c = (g_0 + g_1 c)(g_0 + g_1) - (c+1)g_0 g_1</span>  and we may again ignore the cost of addition, subtraction, and multiplication by c.</p>
      <p class="text-gray-300"><strong>SL-squaring:</strong> Let  <span class="math">p \equiv 2, 5 \pmod&#123;9&#125;</span>  and  <span class="math">g \in G_&#123;\Phi_6(p)&#125; \subset \mathbb&#123;F&#125;_&#123;p^6&#125;^*</span> . Using the algebraic relations induced by  <span class="math">g^&#123;p^3+1&#125; = g^&#123;p^2-p+1&#125; = 1</span>  on the coefficients of the vector representation of g over  <span class="math">\mathbb&#123;F&#125;_p</span> , Stam and Lenstra [28] showed that  <span class="math">g^2</span>  can be computed at a cost dominated by 6 multiplications in  <span class="math">\mathbb&#123;F&#125;_p</span> . Moreover, when  <span class="math">p \equiv 2 \pmod&#123;3&#125;</span>  or  <span class="math">p \equiv 3 \pmod&#123;4&#125;</span> , the algebraic relations induced by  <span class="math">g^&#123;p^3+1&#125; = 1</span>  on the coefficients of the vector representation of g over  <span class="math">\mathbb&#123;F&#125;_&#123;p^3&#125;</span>  were used to compute  <span class="math">g^2</span>  at a cost dominated by 2 squarings in  <span class="math">\mathbb&#123;F&#125;_&#123;p^3&#125;</span> . We call the Stam-Lenstra methods SL1-squaring and SL2-squaring, respectively.</p>
      <p class="text-gray-300"><strong>GPS-squaring:</strong> Let  <span class="math">p \equiv 1 \pmod&#123;12&#125;</span>  and  <span class="math">g \in G_&#123;\Phi_6(p)&#125; \subset \mathbb&#123;F&#125;_&#123;p^6&#125;^*</span> . Using the algebraic relations induced by  <span class="math">g^&#123;p^3+1&#125; = g^&#123;p^2-p+1&#125; = 1</span>  on the coefficients of the vector representation of g over  <span class="math">\mathbb&#123;F&#125;_p</span> , Granger, Page and Stam [10] showed that  <span class="math">g^2</span>  can be computed at a cost dominated by 3 multiplications and 6 squarings in  <span class="math">\mathbb&#123;F&#125;_p</span> .</p>
      <p class="text-gray-300"><strong>GS-squaring:</strong> Let  <span class="math">q \equiv 1 \pmod&#123;6&#125;</span>  be a prime power and  <span class="math">g \in G_&#123;\Phi_6(q)&#125; \subset \mathbb&#123;F&#125;_&#123;q^6&#125;^*</span> . Granger and Scott [12], using the algebraic relations induced by  <span class="math">g^&#123;q^3+1&#125; = g^&#123;q^2-q+1&#125; = 1</span>  on the coefficients of the vector representation of g over  <span class="math">\mathbb&#123;F&#125;_&#123;q^2&#125;</span> , showed that  <span class="math">g^2</span>  can be computed at a cost dominated by 3 squarings in  <span class="math">\mathbb&#123;F&#125;_&#123;q^2&#125;</span> .</p>
      <p class="text-gray-300">Table 1 summarizes the dominating costs of the above-mentioned squaring algorithms. We let  <span class="math">M_i</span>  and  <span class="math">S_i</span>  denote multiplication and squaring costs in  <span class="math">\mathbb&#123;F&#125;_&#123;p^i&#125;</span> . We may assume a)  <span class="math">M_&#123;3i&#125; = 6M_i</span>  using</p>
      <p class="text-gray-300">Karatsuba's technique; b)  <span class="math">S_&#123;2i&#125; = 2M_i</span>  using general squaring as above; and c)  <span class="math">S_&#123;3i&#125; = M_i + 4S_i</span>  using Chung and Hasan's generalized Tom-Cook squaring formulae SQR<sub>3</sub> [6].</p>
      <p class="text-gray-300">Table 1. A summary of squaring algorithms in  <span class="math">G_&#123;\Phi_6(p)&#125;</span> .</p>
      <div class="overflow-x-auto my-4"><table class="text-sm text-gray-300 border-collapse w-full"><tbody>
        <tr><td class="border border-gray-700 px-3 py-1">Algorithms</td><td class="border border-gray-700 px-3 py-1">Cost</td><td class="border border-gray-700 px-3 py-1">Restriction</td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Compressed</td><td class="border border-gray-700 px-3 py-1">Compressed representation</td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">LUC</td><td class="border border-gray-700 px-3 py-1"><span class="math">1S_3 = 1M_1 + 4S_1</span></td><td class="border border-gray-700 px-3 py-1">decompression</td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">XTR</td><td class="border border-gray-700 px-3 py-1"><span class="math">1S_2 = 2M_1</span></td><td class="border border-gray-700 px-3 py-1">decompression</td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">TB2</td><td class="border border-gray-700 px-3 py-1"><span class="math">2M_3 = 12M_1</span></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Full represer</td><td class="border border-gray-700 px-3 py-1">Full representation</td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">General</td><td class="border border-gray-700 px-3 py-1"><span class="math">2M_3 = 12M_1</span></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">SL1</td><td class="border border-gray-700 px-3 py-1"><span class="math">6M_1</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">p \equiv 2, 5 \pmod&#123;9&#125;</span></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">SL2</td><td class="border border-gray-700 px-3 py-1"><span class="math">2S_3 = 2M_1 + 8S_1</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">p \equiv 2 \pmod&#123;3&#125;, p \equiv 3 \pmod&#123;4&#125;</span></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">GPS</td><td class="border border-gray-700 px-3 py-1"><span class="math">3M_1 + 6S_1</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">p \equiv 1 \pmod&#123;12&#125;</span></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">GS</td><td class="border border-gray-700 px-3 py-1"><span class="math">3S_2 = 6M_1</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">p \equiv 1 \pmod&#123;6&#125;</span></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
      </tbody></table></div>
      <p class="text-gray-300">We should note that the squaring algorithms described above for  <span class="math">G_&#123;\Phi_6(p)&#125;</span>  can be generalized to obtain squaring algorithms for  <span class="math">G_&#123;\Phi_6(p)&#125; \subset \mathbb&#123;F&#125;_&#123;p^&#123;6i&#125;&#125;^<em></span>  when all prime divisors of i divide 6. Indeed, one can replace p by  <span class="math">q = p^i</span>  in the arguments and note that  <span class="math">G_&#123;\Phi_6(p)&#125; = G_&#123;\Phi_6(q)&#125; \subset \mathbb&#123;F&#125;_q^&#123;</em>6&#125;</span> . The dominating costs of the corresponding squaring algorithms may be obtained by replacing each  <span class="math">M_j</span>  and  <span class="math">S_j</span>  in Table 1 by  <span class="math">M_&#123;j\cdot i&#125;</span>  and  <span class="math">S_&#123;j\cdot i&#125;</span> , respectively (and the restrictions on p in Table 1 should then be read as restrictions on q).</p>
      <p class="text-gray-300">Even though XTR-squaring seems to be the fastest squaring algorithm for  <span class="math">G_&#123;\Phi_&#123;6i&#125;(p)&#125; \subset \mathbb&#123;F&#125;_&#123;p^&#123;6i&#125;&#125;^<em></span>  (or,  <span class="math">G_&#123;\Phi_&#123;6&#125;(q)&#125; \subset \mathbb&#123;F&#125;_&#123;q^&#123;6&#125;&#125;^</em></span>  with  <span class="math">q=p^i</span> ) for  <span class="math">i \in \&#123;1,2,3,4\&#125;</span> , it suffers from the non-multiplicative property of the trace function as mentioned in Section 1. Consequently, GS-squaring and SL1-squaring seem to be the best squaring algorithms that can be easily deployed in cryptographic algorithms. In addition, GS-squaring has the extra advantage that it allows the use of pairing-friendly or towering-friendly fields for more efficient implementation of pairing-based cryptographic protocols; see [17, 3].</p>
      <h3 id="3-a-new-squaring-formula-in-cyclotomic-subgroups" class="text-xl font-semibold mt-8 mb-3">3. A NEW SQUARING FORMULA IN CYCLOTOMIC SUBGROUPS</h3>
      <p class="text-gray-300">Let  <span class="math">q = p^i \equiv 1 \pmod&#123;6&#125;</span>  be a prime power and  <span class="math">G_&#123;\Phi_6(q)&#125; \subset \mathbb&#123;F&#125;_&#123;q^6&#125;^*</span> . We let  <span class="math">\mathbb&#123;F&#125;_&#123;q^2&#125; = \mathbb&#123;F&#125;_q(w)</span>  where  <span class="math">w^2 = c</span>  for some sextic non-residue  <span class="math">c \in \mathbb&#123;F&#125;_q</span> ; and  <span class="math">\mathbb&#123;F&#125;_&#123;q^6&#125; = \mathbb&#123;F&#125;_&#123;q^2&#125;(\sigma)</span>  where  <span class="math">\sigma^3 = w</span> . Then it is easy to show that</p>
      <div class="math-block">(3.1) w^q = -w,</div>
      <div class="math-block">\sigma^q = m\sigma,</div>
      <p class="text-gray-300">where  <span class="math">m \in \mathbb&#123;F&#125;_q</span>  is some primitive sixth root of unity.</p>
      <p class="text-gray-300">If  <span class="math">g \in \mathbb&#123;F&#125;_&#123;q^6&#125;</span>  then we write</p>
      <div class="math-block">g = (g_0 + g_1 w) + (g_2 + g_3 w)\sigma + (g_4 + g_5 w)\sigma^2</div>
      <p class="text-gray-300">where  <span class="math">g_i \in \mathbb&#123;F&#125;_q</span> . In particular, if  <span class="math">g \in G_&#123;\Phi_6(q)&#125;</span>  then</p>
      <div class="math-block">(3.3) g^&#123;q^3+1&#125; = g^&#123;q^2-q+1&#125; = 1</div>
      <p class="text-gray-300">and using (3.3) together with (3.1) and (3.2) we obtain the following nine relations for  <span class="math">g_i</span> 's:</p>
      <div class="math-block">P_1:</div>
      <p class="text-gray-300"><span class="math">2g_0g_4 - g_2^2 - (2g_1g_5 - g_3^2)c = 0,</span> <span class="math">P_2:</span>   <span class="math">-2g_1g_2 + g_4^2 + 2g_0g_3 - g_5^2c = 0,</span></p>
      <sup>&</sup>lt;sup&gt;1</sup>Under this generalization the GPS-squaring algorithm seems to scale better than the one described in [10] for i = 2, 3 and 4.
      <div class="math-block">P_&#123;3&#125;: g_&#123;0&#125;^&#123;2&#125; - 1 - (g_&#123;1&#125;^&#123;2&#125; + 2g_&#123;2&#125;g_&#123;5&#125; - 2g_&#123;3&#125;g_&#123;4&#125;)c = 0,</div>
      <div class="math-block">P_&#123;4&#125;: (1 - g_&#123;0&#125;)g_&#123;5&#125; + 2g_&#123;2&#125;g_&#123;3&#125; - g_&#123;1&#125;g_&#123;4&#125; = 0,</div>
      <div class="math-block">P_&#123;5&#125;: (-1 - g_&#123;0&#125;)g_&#123;4&#125; + g_&#123;2&#125;^&#123;2&#125; + (g_&#123;3&#125;^&#123;2&#125; - g_&#123;1&#125;g_&#123;5&#125;)c = 0,</div>
      <div class="math-block">P_&#123;6&#125;: (g_&#123;0&#125; + 1)g_&#123;3&#125; + g_&#123;1&#125;g_&#123;2&#125; - g_&#123;4&#125;^&#123;2&#125; - g_&#123;5&#125;^&#123;2&#125;c = 0,</div>
      <div class="math-block">P_&#123;7&#125;: (g_&#123;0&#125; - 1)g_&#123;2&#125; + (g_&#123;3&#125;g_&#123;1&#125; - 2g_&#123;5&#125;g_&#123;4&#125;)c = 0,</div>
      <div class="math-block">P_&#123;8&#125;: (1 + 2g_&#123;0&#125;)g_&#123;1&#125; - g_&#123;2&#125;g_&#123;4&#125; - g_&#123;3&#125;g_&#123;5&#125;c = 0,</div>
      <div class="math-block">P_&#123;9&#125;: g_&#123;0&#125;(g_&#123;0&#125; - 1) + (g_&#123;1&#125;^&#123;2&#125; - g_&#123;2&#125;g_&#123;5&#125; - g_&#123;3&#125;g_&#123;4&#125;)c = 0.</div>
      <p class="text-gray-300">Note that each relation  <span class="math">P_i</span>  is independent of the choice of the primitive sixth root of unity m. Therefore, without loss of generality, we associate a 7-variate polynomial  <span class="math">P_i(X) = P_i(x_0, \ldots, x_5, y)</span>  to each relation  <span class="math">P_i</span>  above. That is, if  <span class="math">g = (g_0 + g_1 w) + (g_2 + g_3 w)\sigma + (g_4 + g_5 w)\sigma^2 \in G_&#123;\Phi_6(q)&#125;</span>  then  <span class="math">P_i(g_0, \ldots, g_5, c) = 0</span>  for all  <span class="math">i = 1, \ldots, 9</span> . Thus, every element in  <span class="math">G_&#123;\Phi_6(q)&#125;</span>  corresponds to an  <span class="math">\mathbb&#123;F&#125;_q</span> -point in the variety defined by the ideal  <span class="math">\langle P_1(X), \ldots, P_9(X) \rangle</span> .</p>
      <p class="text-gray-300">In fact, we may think of each  <span class="math">P_i(X)</span>  as a 7-variate polynomial defined over the field of rational numbers  <span class="math">\mathbb&#123;Q&#125;</span> , and define an ideal  <span class="math">\mathcal&#123;I&#125; = \langle P_1(X), \dots, P_9(X) \rangle</span>  over  <span class="math">\mathbb&#123;Q&#125;</span> . Next, we compute a Groebner basis over  <span class="math">\mathbb&#123;Q&#125;</span>  of  <span class="math">\mathcal&#123;I&#125;</span>  with respect to some fixed ordering on the set of monomials, which in turn yields a factor-3/2 compression function  <span class="math">\mathcal&#123;C&#125;</span>  for elements  <span class="math">g \in G_&#123;\Phi_6(q)&#125;</span>  with the property that given  <span class="math">\mathcal&#123;C&#125;(g)</span> , g can be recovered uniquely at a cost dominated by an inversion in  <span class="math">\mathbb&#123;F&#125;_q</span> . We describe the compression and decompression functions in the following theorem.</p>
      <p class="text-gray-300"><strong>Theorem 3.1.</strong> Let  <span class="math">q \equiv 1 \pmod&#123;6&#125;</span>  be a prime power. Let  <span class="math">\mathbb&#123;F&#125;_&#123;q^2&#125; = \mathbb&#123;F&#125;_q(w)</span>  where  <span class="math">w^2 = c</span>  for some sextic non-residue  <span class="math">c \in \mathbb&#123;F&#125;_q</span> , and let  <span class="math">\mathbb&#123;F&#125;_&#123;q^6&#125; = \mathbb&#123;F&#125;_&#123;q^2&#125;(\sigma)</span>  where  <span class="math">\sigma^3 = w</span> . Let  <span class="math">g = (g_0 + g_1w) + (g_2 + g_3w)\sigma + (g_4 + g_5w)\sigma^2 \in G_&#123;\Phi_6(q)&#125; \setminus \&#123;1\&#125; \subset \mathbb&#123;F&#125;_&#123;q^6&#125;^*</span> . Define the compression function C and the decompression function D as follows</p>
      <div class="math-block">\mathcal&#123;C&#125;(g) = [g_2, g_3, g_4, g_5],</div>
      <div class="math-block">\mathcal&#123;D&#125;([\tilde&#123;g&#125;_2, \tilde&#123;g&#125;_3, \tilde&#123;g&#125;_4, \tilde&#123;g&#125;_5]) = (\tilde&#123;g&#125;_0 + \tilde&#123;g&#125;_1 w) + (\tilde&#123;g&#125;_2 + \tilde&#123;g&#125;_3 w)\sigma + (\tilde&#123;g&#125;_4 + \tilde&#123;g&#125;_5 w)\sigma^2,</div>
      <p class="text-gray-300">where</p>
      <div class="math-block">\begin&#123;cases&#125; \tilde&#123;g&#125;_1 = \frac&#123;\tilde&#123;g&#125;_5^2 c + 3\tilde&#123;g&#125;_4^2 - 2\tilde&#123;g&#125;_3&#125;&#123;4\tilde&#123;g&#125;_2&#125;, & \tilde&#123;g&#125;_0 = (2\tilde&#123;g&#125;_1^2 + \tilde&#123;g&#125;_2\tilde&#123;g&#125;_5 - 3\tilde&#123;g&#125;_3\tilde&#123;g&#125;_4)c + 1, & \text&#123;if &#125; \tilde&#123;g&#125;_2 \neq 0; \\ \tilde&#123;g&#125;_1 = \frac&#123;2\tilde&#123;g&#125;_4\tilde&#123;g&#125;_5&#125;&#123;\tilde&#123;g&#125;_3&#125;, & \tilde&#123;g&#125;_0 = (2\tilde&#123;g&#125;_1^2 - 3\tilde&#123;g&#125;_3\tilde&#123;g&#125;_4)c + 1, & \text&#123;if &#125; \tilde&#123;g&#125;_2 = 0. \end&#123;cases&#125;</div>
      <p class="text-gray-300">Then  <span class="math">\mathcal&#123;D&#125;</span>  is well-defined for all  <span class="math">\mathcal&#123;C&#125;(g)</span>  with  <span class="math">g \in G_&#123;\Phi_6(q)&#125; \setminus \&#123;1\&#125;</span> , and  <span class="math">\mathcal&#123;D&#125;(\mathcal&#123;C&#125;(g)) = g</span>  for all  <span class="math">g \in G_&#123;\Phi_6(q)&#125; \setminus \&#123;1\&#125;</span> .</p>
      <p class="text-gray-300">Proof. Let  <span class="math">g = (g_0 + g_1 w) + (g_2 + g_3 w)\sigma + (g_4 + g_5 w)\sigma^2 \in G_&#123;\Phi_6(q)&#125; \setminus \&#123;1\&#125;</span> . If  <span class="math">g_2 = 0</span>  and  <span class="math">g_3 = 0</span>  then one can verify using the relations  <span class="math">P_i</span>  that  <span class="math">g_1 = g_4 = g_5 = 0</span>  and  <span class="math">g_0 = 1</span> . Therefore,  <span class="math">g_2</span>  and  <span class="math">g_3</span>  cannot both be zero proving that  <span class="math">\mathcal&#123;D&#125;</span>  is well-defined for all  <span class="math">\mathcal&#123;C&#125;(g)</span>  with  <span class="math">g \in G_&#123;\Phi_6(q)&#125; \setminus \&#123;1\&#125;</span> .</p>
      <p class="text-gray-300">To show that  <span class="math">\mathcal&#123;D&#125;(\mathcal&#123;C&#125;(g)) = g</span>  for all  <span class="math">g \in G_&#123;\Phi_6(q)&#125; \setminus \&#123;1\&#125;</span> , we compute a Groebner basis over  <span class="math">\mathbb&#123;Q&#125;</span>  of the ideal  <span class="math">\mathcal&#123;I&#125; = \langle P_1(X), \dots P_9(X) \rangle</span>  with respect to the lexicographical ordering of the monomials with  <span class="math">x_0 &gt; x_1 &gt; x_5 &gt; x_4 &gt; x_3 &gt; x_2 &gt; y</span> . It can be verified using Magma with the commands</p>
      <p class="text-gray-300"><span class="math">R &lt; x_0, x_1, x_5, x_4, x_3, x_2, y &gt; := PolynomialRing(RationalField(), 7);</span></p>
      <p class="text-gray-300"><span class="math">B1 := [R!P_1, R!P_2, R!P_3, R!P_4, R!P_5, R!P_6, R!P_7, R!P_8, R!P_9];</span></p>
      <p class="text-gray-300">I1 := ideal &lt; R|B1 &gt;;</p>
      <p class="text-gray-300">GB1 := GroebnerBasis(I1);</p>
      <p class="text-gray-300"><span class="math">B2 := [R!P_1, R!P_2, R!P_3, R!P_4, R!P_5, R!P_6, R!P_7, R!P_8, R!P_9, R!x_2];</span></p>
      <p class="text-gray-300">I2 := ideal &lt; R|B2 &gt;;</p>
      <p class="text-gray-300">GB2 := GroebnerBasis(I2):</p>
      <p class="text-gray-300">that</p>
      <div class="math-block">x_0 - (2x_1^2 + x_2x_5 - 3x_3x_4)y - 1,</div>
      <div class="math-block">x_1x_2 + \frac&#123;x_3&#125;&#123;2&#125; - \frac&#123;3x_4^2&#125;&#123;4&#125; - \frac&#123;x_5^2y&#125;&#123;4&#125;</div>
      <p class="text-gray-300">are two polynomials in the basis GB1; and</p>
      <div class="math-block">x_1x_3 - 2x_4x_5</div>
      <p class="text-gray-300">is a polynomial in the basis GB2.</p>
      <p class="text-gray-300">By Theorem 3.1, we know that if  <span class="math">g = (g_0 + g_1 w) + (g_2 + g_3 w)\sigma + (g_4 + g_5 w)\sigma^2 \in G_&#123;\Phi_6(q)&#125;</span>  then  <span class="math">\mathcal&#123;C&#125;(g) = [g_2, g_3, g_4, g_5]</span>  determines g uniquely. This suggests a squaring formula that uses the compressed representation of elements in  <span class="math">G_&#123;\Phi_6(q)&#125;</span>  which we present in Theorem 3.2.</p>
      <p class="text-gray-300"><strong>Theorem 3.2.</strong> Let  <span class="math">q \equiv 1 \pmod&#123;6&#125;</span>  be a prime power. Let  <span class="math">\mathbb&#123;F&#125;_&#123;q^2&#125; = \mathbb&#123;F&#125;_q(w)</span>  where  <span class="math">w^2 = c</span>  for some sextic non-residue  <span class="math">c \in \mathbb&#123;F&#125;_q</span> , and let  <span class="math">\mathbb&#123;F&#125;_&#123;q^6&#125; = \mathbb&#123;F&#125;_&#123;q^2&#125;(\sigma)</span>  where  <span class="math">\sigma^3 = w</span> . Let  <span class="math">g = (g_0 + g_1w) + (g_2 + g_3w)\sigma + (g_4 + g_5w)\sigma^2 \in G_&#123;\Phi_6(q)&#125; \subset \mathbb&#123;F&#125;_&#123;q^6&#125;^*</span> . Let  <span class="math">\mathcal&#123;C&#125;</span>  be the compression function defined in the statement of Theorem 3.1. Let  <span class="math">h = g^2</span> , where  <span class="math">h = (h_0 + h_1w) + (h_2 + h_3w)\sigma + (h_4 + h_5w)\sigma^2</span> . Then</p>
      <div class="math-block">C(g^2) = [h_2, h_3, h_4, h_5],</div>
      <p class="text-gray-300">where</p>
      <div class="math-block">h_2 = 2(g_2 + 3cB_&#123;4,5&#125;),</div>
      <div class="math-block">h_3 = 3(A_&#123;4,5&#125; - (c+1)B_&#123;4,5&#125;) - 2g_3,</div>
      <div class="math-block">h_4 = 3(A_&#123;2,3&#125; - (c+1)B_&#123;2,3&#125;) - 2g_4,</div>
      <div class="math-block">h_5 = 2(g_5 + 3B_&#123;2,3&#125;),</div>
      <div class="math-block">A_&#123;i,j&#125; = (g_i + g_j)(g_i + cg_j),</div>
      <div class="math-block">B_&#123;i,j&#125; = g_ig_j.</div>
      <p class="text-gray-300"><em>Proof.</em> Using  <span class="math">w^2 = c</span>  and  <span class="math">\sigma^3 = w</span> , we find that</p>
      <div class="math-block">\begin&#123;array&#125;&#123;rcl&#125; h_0 & = & g_0^2 + (g_1^2 + 2g_3g_4 + 2g_2g_5)c, \\ h_1 & = & 2(g_0g_1 + g_2g_4 + g_3g_5c), \\ h_2 & = & 2(g_0g_2 + (g_4g_5 + g_1g_3)c), \\ h_3 & = & 2(g_0g_3 + g_1g_2) + g_4^2 + g_5^2c, \\ h_4 & = & g_2^2 + 2g_0g_4 + (g_3^2 + 2g_1g_5)c, \\ h_5 & = & 2(g_0g_5 + g_2g_3 + g_1g_4). \end&#123;array&#125;</div>
      <p class="text-gray-300">Under the correspondence  <span class="math">x_i \leftrightarrow g_i</span>  and  <span class="math">y \leftrightarrow c</span> , we define the 7-variate polynomials  <span class="math">h_i(X)</span> . Next, we compute representatives of  <span class="math">h_i(X)</span> 's for  <span class="math">i \in \&#123;2,3,4,5\&#125;</span>  in the quotient ring  <span class="math">R/\mathcal&#123;I&#125;</span> , where  <span class="math">R = \mathbb&#123;Q&#125;[x_0,\ldots,x_5,y]</span>  with respect to the lexicographical ordering of monomials with  <span class="math">x_0 &gt; x_1 &gt; x_5 &gt; x_4 &gt; x_3 &gt; x_2 &gt; y</span> , and where  <span class="math">\mathcal&#123;I&#125; = \langle P_1(X),\ldots,P_9(X)\rangle</span>  is the ideal over  <span class="math">\mathbb&#123;Q&#125;</span>  defined earlier. It can be verified using Magma with the commands</p>
      <div class="math-block">R &lt; x_0, x_1, x_5, x_4, x_3, x_2, y &gt; := PolynomialRing(RationalField(), 7);</div>
      <p class="text-gray-300"><span class="math">B := [R!P_1, R!P_2, R!P_3, R!P_4, R!P_5, R!P_6, R!P_7, R!P_8, R!P_9];</span> <span class="math">I := ideal &lt; R|B &gt; ;</span> <span class="math">R2 := R/I;</span> <span class="math">R2!h_2; R2!h_3; R2!h_4; R2!h_5;</span></p>
      <p class="text-gray-300">that</p>
      <div class="math-block">h_2 = 2(g_2 + 3g_4g_5c) = 2(g_2 + 3cB_&#123;4,5&#125;),</div>
      <p class="text-gray-300"><span class="math">h_3 = 3(g_4^2 + g_5^2c) - 2g_3 = 3(A_&#123;4,5&#125; - (c+1)B_&#123;4,5&#125;) - 2g_3,</span></p>
      <div class="math-block">h_4 = 3(g_2^2 + g_3^2 c) - 2g_4 = 3(A_&#123;2,3&#125; - (c+1)B_&#123;2,3&#125;) - 2g_4,</div>
      <p class="text-gray-300"><span class="math">h_5 = 2(g_5 + 3g_2g_3) = 2(g_5 + 3B_&#123;2,3&#125;)</span></p>
      <p class="text-gray-300">in the quotient ring  <span class="math">R/\mathcal&#123;I&#125;</span> .</p>
      <p class="text-gray-300">Corollary 3.3. Let  <span class="math">q \equiv 1 \pmod&#123;6&#125;</span>  and  <span class="math">g \in G_&#123;\Phi_6(q)&#125; \subset \mathbb&#123;F&#125;_&#123;q^6&#125;^*</span> . Then  <span class="math">C(g^2)</span>  can be computed at a cost dominated by 4 multiplications in  <span class="math">\mathbb&#123;F&#125;_q</span> .</p>
      <h3 id="4-applications" class="text-xl font-semibold mt-8 mb-3">4. Applications</h3>
      <p class="text-gray-300">The squaring formula in Theorem 3.2 works with a compressed representation of elements in  <span class="math">G_&#123;\Phi_6(q)&#125;</span> . The decompression cost for this representation is far less than that of other compressed-squaring algorithms such as XTR-squaring (LUC-squaring) where decompression is performed by finding a root of a third (second) degree irreducible polynomial defined over  <span class="math">\mathbb&#123;F&#125;_&#123;q^2&#125;</span>  ( <span class="math">\mathbb&#123;F&#125;_&#123;q^3&#125;</span> ). When the full representation of a compressed element  <span class="math">\mathcal&#123;C&#125;(g)</span>  is needed (for example, in the multiplication step of square-and-multiply type exponentiation algorithms), the decompression function  <span class="math">\mathcal&#123;D&#125;</span>  can recover g uniquely at a cost dominated by an inversion in  <span class="math">\mathbb&#123;F&#125;_q</span> . Consequently, comparing Corollary 3.3 with Table 1, our compressed-squaring algorithm together with the decompression function yields an exponentiation algorithm which is especially fast when the exponent has low Hamming weight.</p>
      <p class="text-gray-300">4.1. <strong>Exponentiation in</strong>  <span class="math">G_&#123;\Phi_6(q)&#125;</span> . Let  <span class="math">q = p^i \equiv 1 \pmod&#123;6&#125;</span>  and  <span class="math">g \in G_&#123;\Phi_6(q)&#125; \subset \mathbb&#123;F&#125;_&#123;q^6&#125;^*</span> . We present an exponentiation algorithm that uses the squaring formula in Theorem 3.2.</p>
      <p class="text-gray-300">Let e be an  <span class="math">\ell</span> -bit exponent with binary representation</p>
      <div class="math-block">e = e_&#123;\ell-1&#125;e_&#123;\ell-2&#125;\dots e_2e_1e_0,</div>
      <p class="text-gray-300">where  <span class="math">e_&#123;\ell-1&#125; = 1</span> . Let  <span class="math">H_e = \&#123;i : 1 \le i \le \ell - 1 \text&#123; and &#125; e_i = 1\&#125;</span> . Then</p>
      <div class="math-block">g^e = \prod_&#123;i=0&#125;^&#123;\ell-1&#125; g^&#123;2^i&#125; = g^&#123;e_0&#125; \prod_&#123;i \in H_e&#125; \mathcal&#123;D&#125;(\mathcal&#123;C&#125;(g^&#123;2^i&#125;)).</div>
      <p class="text-gray-300">Now, if</p>
      <div class="math-block">g^&#123;2^&#123;i&#125;&#125; = (g_&#123;i,0&#125; + g_&#123;i,1&#125;w) + (g_&#123;i,2&#125; + g_&#123;i,3&#125;w)\sigma + (g_&#123;i,4&#125; + g_&#123;i,5&#125;w)\sigma^&#123;2&#125;</div>
      <p class="text-gray-300">then by Theorem 3.1</p>
      <div class="math-block">C(g^&#123;2^i&#125;) = [g_&#123;i,2&#125;, g_&#123;i,3&#125;, g_&#123;i,4&#125;, g_&#123;i,5&#125;]</div>
      <p class="text-gray-300">and, assuming without loss of generality that  <span class="math">g_&#123;i,2&#125; \neq 0</span> ,</p>
      <div class="math-block">\mathcal&#123;D&#125;(\mathcal&#123;C&#125;(g^&#123;2^&#123;i&#125;&#125;)) = (x_&#123;i&#125; + \frac&#123;y_&#123;i&#125;&#125;&#123;z_&#123;i&#125;&#125;w) + (g_&#123;i,2&#125; + g_&#123;i,3&#125;w)\sigma + (g_&#123;i,4&#125; + g_&#123;i,5&#125;w)\sigma^&#123;2&#125;,</div>
      <p class="text-gray-300">where</p>
      <div class="math-block">x_i = (2g_&#123;i,1&#125;^2 + g_&#123;i,2&#125;g_&#123;i,5&#125; - 3g_&#123;i,3&#125;g_&#123;i,4&#125;)c + 1</div>
      <p class="text-gray-300">,  <span class="math">y_i = g_&#123;i,5&#125;^2c + 3g_&#123;i,4&#125;^2 - 2g_&#123;i,3&#125;</span> , and  <span class="math">z_i = 4g_&#123;i,2&#125;</span> .</p>
      <p class="text-gray-300">Hence,  <span class="math">g^e</span>  can be computed as follows.</p>
      <ul class="list-disc list-inside text-gray-300 space-y-1 my-2">
        <li>(1) Compute  <span class="math">C(g^&#123;2^i&#125;)</span>  for  <span class="math">1 \le i \le \ell 1</span>  with  <span class="math">(\ell 1)</span>  successive squarings using Theorem 3.2 and store  <span class="math">C(g^&#123;2^i&#125;)</span>  for each  <span class="math">i \in H_e</span> .</li>
        <li>(2) Compute and store  <span class="math">(x_i, y_i, z_i)</span>  for each  <span class="math">i \in H_e</span> .</li>
        <li>(3) Compute  <span class="math">y_i/z_i</span>  for each  <span class="math">i \in H_e</span> .</li>
        <li>(4) Compute  <span class="math">g^e = g^&#123;e_0&#125; \prod_&#123;i \in H_s&#125; \mathcal&#123;D&#125;(\mathcal&#123;C&#125;(g^&#123;2^i&#125;))</span> .</li>
      </ul>
      <p class="text-gray-300">Now, let  <span class="math">|H_e| = N</span> , and let  <span class="math">M_i</span> ,  <span class="math">S_i</span>  and  <span class="math">I_i</span>  denote multiplication, squaring and inversion costs in  <span class="math">\mathbb&#123;F&#125;_q = \mathbb&#123;F&#125;_&#123;p^i&#125;</span> , respectively. By Corollary 3.3, step (1) in the above algorithm has cost dominated by  <span class="math">(4(\ell-1))M_i</span>  and requires storage of 4N  <span class="math">\mathbb&#123;F&#125;_q</span> -elements. Using Montgomery's simultaneous inversion trick [20, 13], steps (2) and (3) have cost dominated by  <span class="math">N((1S_i + 2M_i) + 2S_i) + 3(N - 1)M_i + 1I_i + (N)M_i</span>  and storage of 3N + 1  <span class="math">\mathbb&#123;F&#125;_q</span> -elements. Finally, step (4) can be computed at a cost of  <span class="math">(N)M_&#123;6i&#125;</span> .</p>
      <p class="text-gray-300">Corollary 4.1. Let  <span class="math">q = p^i \equiv 1 \pmod&#123;6&#125;</span>  and  <span class="math">g \in G_&#123;\Phi_6(q)&#125; \subset \mathbb&#123;F&#125;_&#123;q^6&#125;^*</span> . Let e be an  <span class="math">\ell</span> -bit exponent. Let  <span class="math">H_e = \&#123;i : 1 \leq i \leq \ell - 1 \text&#123; and &#125; e_i = 1\&#125;</span> , and let  <span class="math">|H_e| = N</span> . Then,  <span class="math">g^e</span>  can be computed at a cost dominated by</p>
      <div class="math-block">(4(\ell-1))M_i + (6N-3)M_i + (N)M_&#123;6i&#125; + (3N)S_i + 1I_i,</div>
      <p class="text-gray-300">with a storage of 7N + 1  <span class="math">\mathbb&#123;F&#125;_q</span> -elements.</p>
      <p class="text-gray-300">Note that the cost of exponentiation using GS-squaring (see [12] or Section 2) in the same setting as in Corollary 4.1 would be dominated by</p>
      <div class="math-block">(4.1) 6(\ell-1)M_i + (N)M_&#123;6i&#125;.</div>
      <p class="text-gray-300">Hence, by Corollary 4.1, we would expect a 33% speed-up over GS-exponentiation as  <span class="math">N/\ell \to 0</span> .</p>
      <p class="text-gray-300">4.2. Speeding up pairing computations. Let  <span class="math">E: y^2 = x^3 + b</span>  be a curve in the Barreto-Naehrig (BN) family of pairing-friendly curves with embedding degree k = 12 [2]. Then E is defined over  <span class="math">\mathbb&#123;F&#125;_p</span>  with  <span class="math">|E(\mathbb&#123;F&#125;_p)| = r</span> , where the primes p and r are parametrized as follows</p>
      <div class="math-block">p(u) = 36u^4 + 36u^3 + 24u^2 + 6u + 1,</div>
      <div class="math-block">r(u) = 36u^4 + 36u^3 + 18u^2 + 6u + 1.</div>
      <p class="text-gray-300">In general, a pairing computation on E is performed in two steps: Miller loop and final exponentiation. Scott [24] showed that the final exponentiation in the pairing computation can be done in two parts. In the first part, an element in  <span class="math">\mathbb&#123;F&#125;_&#123;p^&#123;12&#125;&#125;^<em></span>  is raised to the power  <span class="math">(p^6-1)(p^2+1)</span> . This is the so-called </em>easy part<em> and requires a small number of multiplications, pth powerings and a single inversion, and yields an element  <span class="math">g \in G_&#123;\Phi_6(p^2)&#125; = G_&#123;\Phi_&#123;12&#125;(p)&#125; \subset \mathbb&#123;F&#125;_&#123;p^&#123;12&#125;&#125;^</em></span> . In the second part of the final exponentiation, the so-called <em>hard part</em>, g is raised to the power</p>
      <div class="math-block">\Phi_&#123;12&#125;(p)/r = (p^4 - p^2 + 1)/r = \lambda_3 p^3 + \lambda_2 p^2 + \lambda_1 p + \lambda_0,</div>
      <p class="text-gray-300">where</p>
      <div class="math-block">\lambda_3(u) = 1,</div>
      <div class="math-block">\lambda_2(u) = 6u^2 + 1,</div>
      <div class="math-block">\lambda_1(u) = -36u^3 - 18u^2 - 12u + 1,</div>
      <div class="math-block">\lambda_0(u) = -36u^3 - 30u^2 - 18u - 2.</div>
      <p class="text-gray-300">Note that when the BN parameter u is chosen to have low Hamming weight, one can first compute  <span class="math">g^u</span> ,  <span class="math">g^&#123;u^2&#125; = (g^u)^u</span>  and  <span class="math">g^&#123;u^3&#125; = (g^&#123;u^2&#125;)^u</span>  to minimize the number of multiplications in the hard part of the final exponentiation.</p>
      <p class="text-gray-300">To be more concrete, one can choose  <span class="math">u = -(2^&#123;62&#125; + 2^&#123;55&#125; + 1)</span>  to obtain a BN-curve E defined over a 254-bit prime p with 254-bit prime order group  <span class="math">E(\mathbb&#123;F&#125;_p)</span>  [21]. In our operation counts, we will assume a)  <span class="math">M_2 = 3M_1</span>  and  <span class="math">M_&#123;12&#125; = 54M_1</span>  using Karatsuba's technique; b)  <span class="math">S_2 = 2M_1</span>  (see general squaring in Section 2.2); c)  <span class="math">I_2 = 1I_1 + 2M_1 + 2S_1</span>  [19]; and d)  <span class="math">M_1 = S_1</span>  and  <span class="math">I_1 = 50M_1</span>  (see [4, Section 3.1]).</p>
      <p class="text-gray-300">GS-exponentiation seems to be the fastest of the previously-known methods to compute the hard part of the final exponentiation in the pairing computation. Using this method, each of  <span class="math">g^&#123;-u&#125;</span> ,  <span class="math">g^&#123;-u^2&#125;</span>  and  <span class="math">g^&#123;-u^3&#125;</span>  can be computed at a cost dominated by (see (4.1))</p>
      <div class="math-block">(4.2) 6(\ell-1)M_i + (N)M_&#123;6i&#125; = 1224M_1,</div>
      <p class="text-gray-300">where ` = 63 and N = 2.</p>
      <p class="text-gray-300">Now, we describe an exponentiation algorithm similar to the one in Section 4.1 but avoiding the storage requirements. Instead of performing simultaneous inversion, we begin the algorithm by computing compressed-squarings and perform a one-time inversion (decompression) when a multiplication is required. Then we switch to GS-squaring. In summary, given g and u = 2 <sup>62</sup> + 2<sup>55</sup> + 1, g u can be computed as follows.</p>
      <ul class="list-disc list-inside text-gray-300 space-y-1 my-2">
        <li>(1) Compute C(g 2 <sup>55</sup> ) with 55 successive squarings using Theorem 3.2.</li>
        <li>(2) Decompress C(g 2 <sup>55</sup> ) to obtain g 2 55 = D(C(g 2 <sup>55</sup> )).</li>
        <li>(3) Compute g 2 <sup>62</sup> with 7 successive GS-squarings.</li>
        <li>(4) Compute g <sup></sup><sup>u</sup> = g  g 2 55  g 2 62 .</li>
      </ul>
      <p class="text-gray-300">The cost of step (2) is dominated by</p>
      <div class="math-block">(3S_2 + 2M_2) + 1I_2 + 1M_2 = 6M_1 + 6M_1 + 54M_1 + 3M_1 = 69M_1.</div>
      <p class="text-gray-300">Similar to our previous analysis, one can verify that the cost of the above hybrid exponentiation algorithm is dominated by</p>
      <div class="math-block">(55 \cdot 4)M_2 + (7 \cdot 6)M_2 + 69M_1 + 2M_&#123;12&#125; = 963M_1.</div>
      <p class="text-gray-300">Comparing (4.2) and (4.3), we would expect around a 21% speed-up for computing g u , g<sup>u</sup> 2 and g u 3 in the hard part of the final exponentiation. According to [4, Section 4.2 and Table 3], computing g u , g<sup>u</sup> 2 and g u 3 take 79% of the time of the final exponentiation, and the final exponentiation takes 42% of the time of the whole pairing computation. Hence, with our new exponentiation algorithm, we would expect a 17% speed-up for the final exponentiation, and a 7% speed-up for the pairing computation.</p>
      <p class="text-gray-300">Recently, Aranha et al. proposed and implemented a variant of the squaring algorithm in Theorem 3.2 for the pairing computation over a BN curve parametrized by u = (262+ 255+ 1) [1]. They reported overall 5%  7% speed-ups for the pairing computation.</p>
      <p class="text-gray-300">In this section, we describe a general method for finding efficient squaring formulae in cyclotomic subgroups G6(q) . While rediscovering some of the previously-known squaring formulae such as LUC-squaring, XTR-squaring and GS-squaring, our method yields new squaring formulae which might be good alternatives to the one in Section 3.</p>
      <p class="text-gray-300">We use the same notation as in Section 3. In particular, let</p>
      <div class="math-block">g = (g_0 + g_1 w) + (g_2 + g_3 w)\sigma + (g_4 + g_5 w)\sigma^2 \in G_&#123;\Phi_6(q)&#125;</div>
      <p class="text-gray-300">and</p>
      <div class="math-block">h = g^&#123;2&#125; = (h_&#123;0&#125; + h_&#123;1&#125;w) + (h_&#123;2&#125; + h_&#123;3&#125;w)\sigma + (h_&#123;4&#125; + h_&#123;5&#125;w)\sigma^&#123;2&#125;.</div>
      <p class="text-gray-300">Let I  &#123;0, 1, . . . , 5&#125;. In order to obtain squaring formulae similar one in Theorem 3.2 we first need a (compression) function C such that C(g) can be determined as a function of V<sup>I</sup> (g) = &#123;g<sup>i</sup> : i  I&#125;. Second, we need a family S<sup>I</sup> = &#123;S<sup>i</sup> : i  I&#125; of formulae to compute each h<sup>i</sup>  V<sup>I</sup> (h) as a function of V<sup>I</sup> (g), say h<sup>i</sup> = Si(V<sup>I</sup> (g)) for each i  I. Consequently, we might represent a squaring formula F : C(g) 7 C(g 2 ) = C(h) by a tuple</p>
      <div class="math-block">\mathcal&#123;F&#125; = \&#123;I, \mathcal&#123;C&#125;, \mathcal&#123;S&#125;_I\&#125;.</div>
      <p class="text-gray-300">For example, in Theorem 3.2 we had</p>
      <div class="math-block">I = \&#123;2, 3, 4, 5\&#125;, \ \mathcal&#123;C&#125;(g) = [g_2, g_3, g_4, g_5], \ \mathcal&#123;S&#125;_I = \&#123;S_2, S_3, S_4, S_5\&#125;,</div>
      <p class="text-gray-300"><span class="math">h_2 = S_2(V_I(g)) = 2(g_2 + 3g_4g_5c),</span></p>
      <div class="math-block">h_3 = S_3(V_I(g)) = 3(g_4^2 + g_5^2 c) - 2g_3,</div>
      <div class="math-block">h_4 = S_4(V_I(g)) = 3(g_2^2 + g_3^2 c) - 2g_4,</div>
      <div class="math-block">h_5 = S_5(V_I(g)) = 2(g_5 + 3g_2g_3).</div>
      <p class="text-gray-300">Remark 5.1. In the representation of F, it seems necessary to require that the inverse of C can be efficiently computed in order to get efficient multi-exponentiation algorithms based on F. However, we will relax this condition for now.</p>
      <p class="text-gray-300">We already know from the proof of Theorem 3.2 that if h = g 2 then</p>
      <div class="math-block">h_0 = g_0^2 + (g_1^2 + 2g_3g_4 + 2g_2g_5)c,</div>
      <div class="math-block">h_1 = 2(g_0g_1 + g_2g_4 + g_3g_5c),</div>
      <div class="math-block">h_2 = 2(g_0g_2 + (g_4g_5 + g_1g_3)c),</div>
      <div class="math-block">h_3 = 2(g_0g_3 + g_1g_2) + g_4^2 + g_5^2c,</div>
      <div class="math-block">h_4 = g_2^2 + 2g_0g_4 + (g_3^2 + 2g_1g_5)c,</div>
      <div class="math-block">h_5 = 2(g_0g_5 + g_2g_3 + g_1g_4).</div>
      <p class="text-gray-300">In fact, the squaring formula in Theorem 3.2, or in other words S<sup>I</sup> = &#123;S2, S3, S4, S5&#125;, was found by computing representatives of hi(X)'s for i  &#123;2, 3, 4, 5&#125; in the quotient ring R/I, where R = Q[x0, . . . , x5, y] with respect to the lexicographical ordering of monomials with x<sup>0</sup> &gt; x<sup>1</sup> &gt; x<sup>5</sup> &gt; x<sup>4</sup> &gt; x<sup>3</sup> &gt; x<sup>2</sup> &gt; y, and where I = hP1(X), . . . , P9(X)i.</p>
      <p class="text-gray-300">In order to capture a wider class of squaring formulae F = &#123;I, C, SI&#125;, we will compute representatives of hi(X) for i  &#123;0, . . . , 5&#125; in the quotient ring R/I by varying over all the 7! = 5040 orderings of the variables &#123;x0, . . . , x5, y&#125;. To do so, we let o be some fixed ordering in the set O of all orderings of the variables &#123;x0, . . . , x5, y&#125; and denote by R<sup>o</sup> the ring Q[x0, . . . , x5, y] with respect to the lexicographical ordering of monomials with ordering o.</p>
      <p class="text-gray-300">We define</p>
      <div class="math-block">\mathcal&#123;H&#125;_i = \&#123;\bar&#123;h&#125;_&#123;i,o&#125;: \ \bar&#123;h&#125;_&#123;i,o&#125; = h_i \in R_o/\mathcal&#123;I&#125;, o \in \mathcal&#123;O&#125;\&#125;.</div>
      <p class="text-gray-300">Since each h i,o defines a unique S<sup>i</sup> (on some subset V<sup>I</sup> (g)), we may replace, without loss of generality, h i,o's by Si,j 's in H<sup>i</sup> . We list H<sup>i</sup> for i = 0, 1, . . . , 5 in Appendix A.</p>
      <p class="text-gray-300">Note that for any I  &#123;0, 1, 2 . . . , 5&#125;, there is a squaring formula F = &#123;I, C, SI&#125; only if for each i  I there is some Si,j  H<sup>i</sup> that is defined on V<sup>I</sup> (g). From Appendix A, we deduce that S0,j  H<sup>0</sup> is well defined on a domain V<sup>I</sup> (g) only if V<sup>I</sup> (g) contains one of the subsets in the minimal domain set D<sup>0</sup> of H0, where</p>
      <div class="math-block">D_0 = \&#123;\&#123;g_0, g_1\&#125;, \&#123;g_0, g_2, g_5\&#125;, \&#123;g_0, g_3, g_4\&#125;, \&#123;g_1, g_2, g_5\&#125;, \&#123;g_0, g_1, g_2, g_3\&#125;, \&#123;g_0, g_1, g_3, g_4\&#125;, \&#123;g_0, g_1, g_4, g_5\&#125;, \&#123;g_0, g_2, g_3, g_4, g_5\&#125;\&#125;</div>
      <p class="text-gray-300">Similarly, we have</p>
      <div class="math-block">\begin&#123;array&#125;&#123;lll&#125; D_1 &=& \&#123;\&#123;g_0,g_1\&#125;,\&#123;g_1,g_2,g_5\&#125;,\&#123;g_1,g_2,g_3,g_4\&#125;,\&#123;g_1,g_2,g_3,g_5\&#125;,\\ && \&#123;g_1,g_2,g_4,g_5\&#125;,\&#123;g_1,g_3,g_4,g_5\&#125;,\&#123;g_0,g_1,g_2,g_3,g_5\&#125;,\\ && \&#123;g_0,g_1,g_2,g_4,g_5\&#125;,\&#123;g_1,g_2,g_3,g_4,g_5\&#125;\&#125;,\\ D_2 &=& \&#123;\&#123;g_2,g_4,g_5\&#125;,\&#123;g_0,g_1,g_2,g_3\&#125;,\&#123;g_1,g_2,g_3,g_5\&#125;,\&#123;g_1,g_2,g_3,g_4,g_5\&#125;\&#125;,\\ D_3 &=& \&#123;\&#123;g_0,g_3,g_4\&#125;,\&#123;g_0,g_3,g_5\&#125;,\&#123;g_1,g_2,g_5\&#125;,\&#123;g_3,g_4,g_5\&#125;,\\ && \&#123;g_0,g_1,g_2,g_3\&#125;,\&#123;g_1,g_2,g_3,g_4\&#125;,\&#123;g_1,g_2,g_3,g_5\&#125;\&#125;,\\ D_4 &=& \&#123;\&#123;g_0,g_2,g_4\&#125;,\&#123;g_0,g_3,g_4\&#125;,\&#123;g_1,g_2,g_5\&#125;,\&#123;g_2,g_3,g_4\&#125;,\\ && \&#123;g_0,g_1,g_4,g_5\&#125;,\&#123;g_1,g_2,g_4,g_5\&#125;,\&#123;g_1,g_3,g_4,g_5\&#125;\&#125;,\\ D_5 &=& \&#123;\&#123;g_2,g_3,g_5\&#125;,\&#123;g_0,g_1,g_4,g_5\&#125;,\&#123;g_1,g_2,g_4,g_5\&#125;,\&#123;g_1,g_2,g_3,g_4,g_5\&#125;\&#125;. \end&#123;array&#125;</div>
      <p class="text-gray-300">Now, from the minimal domain sets  <span class="math">D_i</span> 's and  <span class="math">\mathcal&#123;H&#125;_i</span> 's in Appendix A we can write other squaring formulae  <span class="math">\mathcal&#123;F&#125; = \&#123;I, \mathcal&#123;C&#125;, \mathcal&#123;S&#125;_I\&#125;</span>  as follows.</p>
      <p class="text-gray-300">5.1. SQR<sub>01</sub>:</p>
      <div class="math-block">\mathcal&#123;F&#125; = \&#123;I, \mathcal&#123;C&#125;, \mathcal&#123;S&#125;_I\&#125;</div>
      <p class="text-gray-300">with  <span class="math">|I| = 2</span> .</p>
      <div class="math-block">I = \&#123;0, 1\&#125;, \ \mathcal&#123;C&#125;(g) = [g_0, g_1], \ \mathcal&#123;S&#125;_I = \&#123;S_&#123;0,3&#125;, S_&#123;1,1&#125;\&#125;</div>
      <div class="math-block">h_0 = S_&#123;0,3&#125; = 3g_0^2 - 2g_0 + 3g_1^2c,</div>
      <p class="text-gray-300"><span class="math">h_1 = S_&#123;1,1&#125; = 6q_0q_1 + 2q_1.</span></p>
      <p class="text-gray-300">This formula is the only one with |I| = 2. Its cost is dominated by 2 multiplications in  <span class="math">\mathbb&#123;F&#125;_q</span>  as one can write</p>
      <div class="math-block">h_0 = 3((g_0 + g_1)(g_0 + g_1c) - (c+1)g_0g_1) - 2g_0.</div>
      <p class="text-gray-300">In fact, this formula is a rediscovery of the XTR-squaring because</p>
      <div class="math-block">\operatorname&#123;Tr&#125;_&#123;\mathbb&#123;F&#125;_&#123;a^6&#125;/\mathbb&#123;F&#125;_&#123;a^2&#125;&#125;(g) = 3(g_0 + g_1 w)</div>
      <p class="text-gray-300">can be uniquely determined using  <span class="math">V_I(g) = \&#123;g_0, g_1\&#125;</span> . Note that the compression function  <span class="math">\mathcal&#123;C&#125;</span>  in this case cannot have an inverse as  <span class="math">\mathcal&#123;C&#125;(g) = \mathcal&#123;C&#125;(g^&#123;q^2&#125;) = \mathcal&#123;C&#125;(g^&#123;q^4&#125;)</span> .</p>
      <p class="text-gray-300">5.2. <strong>SQR</strong><sub>034</sub>:</p>
      <div class="math-block">\mathcal&#123;F&#125; = \&#123;I, \mathcal&#123;C&#125;, \mathcal&#123;S&#125;_I\&#125;</div>
      <p class="text-gray-300">with  <span class="math">|I| = 3</span> .</p>
      <div class="math-block">I = \&#123;0, 3, 4\&#125;, \ \mathcal&#123;C&#125;(g) = [g_0, g_3, g_4], \ \mathcal&#123;S&#125;_I = \&#123;S_&#123;0,1&#125;, S_&#123;3,2&#125;, S_&#123;4,1&#125;\&#125;</div>
      <div class="math-block">h_0 = S_&#123;0,1&#125; = 2g_0^2 + 4g_3g_4c - 1,</div>
      <div class="math-block">h_3 = S_&#123;3,2&#125; = 4g_0g_3 + 2g_4^2,</div>
      <div class="math-block">h_4 = S_&#123;4,1&#125; = 4g_0g_4 + 2g_3^2c.</div>
      <p class="text-gray-300">This formula is the only one with |I|=3, and is a rediscovery of the LUC-squaring because</p>
      <div class="math-block">\operatorname&#123;Tr&#125;_&#123;\mathbb&#123;F&#125;_&#123;q^6&#125;/\mathbb&#123;F&#125;_&#123;q^3&#125;&#125;(g) = 2(g_0 + g_3 w \sigma + g_4 \sigma^2)</div>
      <p class="text-gray-300">can be uniquely determined using  <span class="math">V_I(g) = \&#123;g_0, g_3, g_4\&#125;</span> . In fact, using</p>
      <div class="math-block">\operatorname&#123;Tr&#125;_&#123;q^6,q^3&#125;(g^2) = \operatorname&#123;Tr&#125;_&#123;q^6,q^3&#125;(g)^2 - 2</div>
      <p class="text-gray-300">and the 3-way squaring formula in [6] one can show that</p>
      <div class="math-block">h_0 = 2(T_0 + T_1c) - 1,</div>
      <div class="math-block">h_3 = (T_1 + T_2) - 2(T_0 + T_4),</div>
      <div class="math-block">h_4 = 2(T_4c - T_3) + (T_1 - T_2).</div>
      <p class="text-gray-300">where</p>
      <div class="math-block">T_0 = g_0^2,</div>
      <div class="math-block">T_1 = (g_0 + g_3 + g_4)^2,</div>
      <div class="math-block">T_2 = (g_0 + g_3 - g_4)^2,</div>
      <div class="math-block">T_3 = 2g_3g_4,</div>
      <div class="math-block">T_4 = g_3^2.</div>
      <p class="text-gray-300">Hence, the total cost is dominated by 1 squaring in  <span class="math">\mathbb&#123;F&#125;_&#123;q^3&#125;</span> , or by 4 squarings and 1 multiplication in  <span class="math">\mathbb&#123;F&#125;_q</span> . Note that the compression function  <span class="math">\mathcal&#123;C&#125;</span>  in this case cannot have an inverse as  <span class="math">\mathcal&#123;C&#125;(g) = \mathcal&#123;C&#125;(g^&#123;q^3&#125;)</span> .</p>
      <p class="text-gray-300">5.3. <strong>SQR</strong><sub>2345</sub>:</p>
      <div class="math-block">\mathcal&#123;F&#125; = \&#123;I, \mathcal&#123;C&#125;, \mathcal&#123;S&#125;_I\&#125;</div>
      <p class="text-gray-300">with  <span class="math">|I| = 4</span> . <span class="math">I = \&#123;2, 3, 4, 5\&#125;, \ \mathcal&#123;C&#125;(g) = [g_2, g_3, g_4, g_5], \ \mathcal&#123;S&#125;_I = \&#123;S_&#123;2,1&#125;, S_&#123;3,4&#125;, S_&#123;4,5&#125;, S_&#123;5,1&#125;\&#125;</span> <span class="math">h_2 = S_&#123;2,1&#125; = 2g_2 + 6g_4g_5c,</span> <span class="math">h_3 = S_&#123;3,4&#125; = 3g_4^2 + 3g_5^2c - 2g_3,</span> <span class="math">h_4 = S_&#123;4,5&#125; = 3g_2^2 + 3g_3^2c - 2g_4,</span> <span class="math">h_5 = S_&#123;5,1&#125; = 2g_5 + 6g_2g_3.</span></p>
      <p class="text-gray-300">The above formula is a rediscovery of the squaring formula in Theorem 3.2, where we show that  <span class="math">\mathcal&#123;C&#125;(g^2)</span>  can be computed at a cost dominated by 4 multiplications in  <span class="math">\mathbb&#123;F&#125;_q</span> . Next, we observe that  <span class="math">\mathcal&#123;C&#125;(g^2)</span>  can also be computed at a cost dominated by 2 squarings in  <span class="math">\mathbb&#123;F&#125;_&#123;q^2&#125;</span> . This follows because, inspired by GS-squaring [12], we can write</p>
      <div class="math-block">h_2 + h_3 w = S_&#123;2,1&#125; + S_&#123;3,4&#125; w = 3w(g_4 + g_5 w)^2 + 2(g_2 - g_3 w),</div>
      <p class="text-gray-300"><span class="math">h_4 + h_5 w = S_&#123;4,5&#125; + S_&#123;5,2&#125; w = 3(g_2 + g_3 w)^2 - 2(g_4 - g_5 w),</span></p>
      <p class="text-gray-300">which requires 2 squarings in  <span class="math">\mathbb&#123;F&#125;_&#123;q^2&#125;</span> .</p>
      <p class="text-gray-300">5.4. <strong>SQR</strong><sub>0134</sub>:</p>
      <div class="math-block">\mathcal&#123;F&#125; = \&#123;I, \mathcal&#123;C&#125;, \mathcal&#123;S&#125;_I\&#125;</div>
      <p class="text-gray-300">with  <span class="math">|I| = 4</span> . <span class="math">I = \&#123;0, 1, 3, 4\&#125;, \ \mathcal&#123;C&#125;(g) = [g_0, g_1, g_3, g_4], \ \mathcal&#123;S&#125;_I = \&#123;S_&#123;0,1&#125;, S_&#123;1,1&#125;, S_&#123;3,2&#125;, S_&#123;4,1&#125;\&#125;</span> <span class="math">h_0 = S_&#123;0,1&#125; = 2g_0^2 + 4g_3g_4c - 1,</span> <span class="math">h_1 = S_&#123;1,1&#125; = 6g_0g_1 + 2g_1,</span> <span class="math">h_3 = S_&#123;3,2&#125; = 4g_0g_3 + 2g_4^2,</span> <span class="math">h_4 = S_&#123;4,1&#125; = 4g_0g_4 + 2g_2^2c.</span></p>
      <p class="text-gray-300">In this formula, one can compute  <span class="math">\&#123;h_0, h_3, h_4\&#125;</span>  at a cost dominated by 4 squarings and 1 multiplication in  <span class="math">\mathbb&#123;F&#125;_q</span>  (see Section 5.2). Hence,  <span class="math">\&#123;h_0, h_1, h_3, h_4\&#125;</span>  can be computed at a cost dominated by 4 squarings and 2 multiplications in  <span class="math">\mathbb&#123;F&#125;_q</span> . Similarly as in the proof of Theorem 3.1, we can show that an inverse to the compression function  <span class="math">\mathcal&#123;C&#125;</span>  can be given as follows.</p>
      <div class="math-block">\mathcal&#123;D&#125;([\tilde&#123;g&#125;_0, \tilde&#123;g&#125;_1, \tilde&#123;g&#125;_3, \tilde&#123;g&#125;_4]) = (\tilde&#123;g&#125;_0 + \tilde&#123;g&#125;_1 w) + (\tilde&#123;g&#125;_2 + \tilde&#123;g&#125;_3 w)\sigma + (\tilde&#123;g&#125;_4 + \tilde&#123;g&#125;_5 w)\sigma^2,</div>
      <p class="text-gray-300">where</p>
      <div class="math-block">\tilde&#123;g&#125;_&#123;2&#125; = \frac&#123;\tilde&#123;g&#125;_&#123;3&#125;(\tilde&#123;g&#125;_&#123;0&#125; - 1) + 2\tilde&#123;g&#125;_&#123;4&#125;^&#123;2&#125;&#125;&#123;3\tilde&#123;g&#125;_&#123;1&#125;&#125;,</div>
      <div class="math-block">\tilde&#123;g&#125;_&#123;5&#125; = \frac&#123;\tilde&#123;g&#125;_&#123;4&#125;(\tilde&#123;g&#125;_&#123;0&#125; - 1) + 2\tilde&#123;g&#125;_&#123;2&#125;^&#123;2&#125;c&#125;&#123;3\tilde&#123;g&#125;_&#123;1&#125;c&#125;.</div>
      <p class="text-gray-300">If  <span class="math">g \in G_&#123;\Phi_6(q)&#125; \setminus \&#123;1\&#125;</span>  then  <span class="math">g_1</span>  can never equal zero because</p>
      <div class="math-block">\operatorname&#123;Tr&#125;_&#123;\mathbb&#123;F&#125;_&#123;q^6&#125;/\mathbb&#123;F&#125;_&#123;q^2&#125;&#125;(g^2) = g_0 + g_1 w \in \mathbb&#123;F&#125;_&#123;q^2&#125; \setminus \mathbb&#123;F&#125;_q.</div>
      <p class="text-gray-300">Hence, the decompression function  <span class="math">\mathcal&#123;D&#125;</span>  is well defined and  <span class="math">\mathcal&#123;D&#125;(\mathcal&#123;C&#125;(g)) = g</span>  for all  <span class="math">g \in G_&#123;\Phi_6(q)&#125; \setminus \&#123;1\&#125;</span> . The decompression can be performed at a cost dominated by 4 multiplications, 2 squarings and 1 inversion in  <span class="math">\mathbb&#123;F&#125;_q</span> .</p>
      <p class="text-gray-300">5.5. Other formulae  <span class="math">\mathcal&#123;F&#125; = \&#123;I, \mathcal&#123;C&#125;, \mathcal&#123;S&#125;_I\&#125;</span>  with |I| = 4. There are 4 more classes of squaring formulae with |I| = 4 and we list one from each class that seems to be the most efficient one in its class.</p>
      <div class="math-block">I = \&#123;0, 1, 2, 3\&#125;, \ \mathcal&#123;C&#125;(g) = [g_0, g_1, g_2, g_3], \ \mathcal&#123;S&#125;_I = \&#123;S_&#123;0,3&#125;, S_&#123;1,1&#125;, S_&#123;2,2&#125;, S_&#123;3,3&#125;\&#125;</div>
      <div class="math-block">h_0 = S_&#123;0,3&#125; = 3g_0^2 - 2g_0 + 3g_1^2c,</div>
      <div class="math-block">h_1 = S_&#123;1,1&#125; = 6g_0g_1 + 2g_1,</div>
      <div class="math-block">h_2 = S_&#123;2,2&#125; = 3g_0g_2 + 3g_1g_3c - g_2,</div>
      <div class="math-block">\begin&#123;split&#125; h_3 &= S_&#123;3,3&#125; = 3g_0g_3 + 3g_1g_2 + g_3. \\ I &= \&#123;0,1,4,5\&#125;, \ \mathcal&#123;C&#125;(g) = [g_0,g_1,g_4,g_5], \ \mathcal&#123;S&#125;_I = \&#123;S_&#123;0,3&#125;,S_&#123;1,1&#125;,S_&#123;4,3&#125;,S_&#123;5,2&#125;\&#125; \\ h_0 &= S_&#123;0,3&#125; = 3g_0^2 + 3g_1^2c - 2g_0, \\ h_1 &= S_&#123;1,1&#125; = 6g_0g_1 + 2g_1, \\ h_4 &= S_&#123;4,3&#125; = 3g_0g_4 + 3g_1g_5c + g_4, \\ h_5 &= S_&#123;5,2&#125; = 3g_0g_5 + 3g_1g_4 - g_5. \\ I &= \&#123;1,2,3,5\&#125;, \ \mathcal&#123;C&#125;(g) = [g_1,g_2,g_3,g_5], \ \mathcal&#123;S&#125;_I = \&#123;S_&#123;1,5&#125;,S_&#123;2,1&#125;,S_&#123;3,1&#125;,S_&#123;5,1&#125;\&#125; \\ h_1 &= S_&#123;1,5&#125; = 12g_5^3c^2 + (12g_1^3 + 12g_1g_2g_5 - 36g_2g_3^2 - 24g_3g_5)c + 8g_1, \\ h_2 &= S_&#123;2,1&#125; = 2g_2 + 6g_4g_5c, \\ h_3 &= S_&#123;3,1&#125; = 4g_1g_2 + 2g_5^2c, \\ h_5 &= S_&#123;5,1&#125; = 6g_2g_3 + 2g_5. \\ I &= \&#123;1,2,4,5\&#125;, \ \mathcal&#123;C&#125;(g) = [g_1,g_2,g_4,g_5], \ \mathcal&#123;S&#125;_I = \&#123;S_&#123;1,3&#125;,S_&#123;2,1&#125;,S_&#123;4,2&#125;,S_&#123;5,3&#125;\&#125; \\ h_1 &= S_&#123;1,3&#125; = (12g_1g_2g_5 + 12g_1^3 - 36g_4^2g_5)c - 24g_2g_4 + 8g_1 + 12g_2^3, \\ h_2 &= S_&#123;2,1&#125; = 2g_2 + 6g_4g_5c, \\ h_4 &= S_&#123;4,2&#125; = 4g_1g_5c + 2g_2^2, \\ h_5 &= S_&#123;5,3&#125; = -12g_1g_2^2 + 9g_2g_4^2 + 3g_2g_5^2c + 2g_5. \end&#123;split&#125;</div>
      <p class="text-gray-300">For each of the above 4 formulae, one can write a decompression function  <span class="math">\mathcal&#123;D&#125;</span>  such that  <span class="math">\mathcal&#123;D&#125;</span>  is well defined and  <span class="math">\mathcal&#123;D&#125;(\mathcal&#123;C&#125;(g)) = g</span>  for all  <span class="math">g \in G_&#123;\Phi_6(q)&#125;</span> . Our analysis shows that in the first two squaring formulae, the decompression functions require 1 inversion in  <span class="math">\mathbb&#123;F&#125;_q</span> , and computing  <span class="math">\mathcal&#123;C&#125;(g^2)</span>  requires more than 4 multiplications in  <span class="math">\mathbb&#123;F&#125;_q</span> . Therefore, they do not seem to yield better algorithms than the squaring formula in Theorem 3.2. In the latter two squaring formulae, the decompression functions do not require an inversion, and they can be given as follows:</p>
      <div class="math-block">\mathcal&#123;D&#125;([g_1, g_2, g_3, g_5]) = (g_0 + g_1 w) + (g_2 + g_3 w)\sigma + (g_4 + g_5 w)\sigma^2,</div>
      <p class="text-gray-300">where</p>
      <div class="math-block">g_4 = 1/2(g_2^2 + 3g_3^2c) - 2g_1g_5c,</div>
      <div class="math-block">g_0 = (2g_1^2 + g_2g_5 - 3g_3g_4)c + 1,</div>
      <p class="text-gray-300">and</p>
      <div class="math-block">\mathcal&#123;D&#125;([g_1, g_2, g_4, g_5]) = (g_0 + g_1 w) + (g_2 + g_3 w)\sigma + (g_4 + g_5 w)\sigma^2,</div>
      <p class="text-gray-300">where</p>
      <div class="math-block">g_3 = 1/2(g_5^2c + 3g_4^2) - 2g_1g_2,</div>
      <div class="math-block">g_0 = (2g_1^2 + g_2g_5 - 3g_3g_4)c + 1,</div>
      <p class="text-gray-300">respectively. The above formulae yield factor-3/2 compression for elements  <span class="math">g \in G_&#123;\Phi_6(q)&#125;</span>  with the property that decompression can be performed at a cost dominated by 3 multiplications and 3 squarings in  <span class="math">\mathbb&#123;F&#125;_q</span> . However, computing  <span class="math">\mathcal&#123;C&#125;(g^2)</span>  requires more than 6 multiplications in  <span class="math">\mathbb&#123;F&#125;_q</span> . Therefore, they do not seem to yield better algorithms than GS-squaring.</p>
      <p class="text-gray-300">5.6. Squaring formulae  <span class="math">\mathcal&#123;F&#125; = \&#123;I, \mathcal&#123;C&#125;, \mathcal&#123;S&#125;_I\&#125;</span>  with |I| = 5. There are 6 classes of squaring formulae with |I| = 5. Our analysis shows in all of these formulae, computing  <span class="math">\mathcal&#123;C&#125;(g^2)</span>  requires more than 4 multiplications in  <span class="math">\mathbb&#123;F&#125;_q</span> . Therefore, there is no hope that they would yield better exponentiation algorithms than the formula in Theorem 3.2 unless decompression can be achieved without doing an inversion in  <span class="math">\mathbb&#123;F&#125;_q</span>  (recall that the decompression function of the squaring formula in Theorem 3.2 requires an inversion in  <span class="math">\mathbb&#123;F&#125;_q</span> ). We found one such formula, where  <span class="math">\mathcal&#123;C&#125;(g^2)</span>  can be computed at a cost dominated by 5 multiplications in  <span class="math">\mathbb&#123;F&#125;_q</span> , and the decompression can be performed at a cost dominated by 2 multiplications and 1 squaring in  <span class="math">\mathbb&#123;F&#125;_q</span> .</p>
      <p class="text-gray-300">The formula can be seen as an extension of the squaring formula in Theorem 3.2 and it is given as follows.</p>
      <div class="math-block">\begin&#123;split&#125; I &= \&#123;1,2,3,4,5\&#125;, \ \mathcal&#123;C&#125;(g) = [g_0,g_2,g_3,g_4,g_5], \\ \mathcal&#123;S&#125;_I &= \&#123;S_&#123;1,2&#125;,S_&#123;2,1&#125;,S_&#123;3,4&#125;,S_&#123;4,5&#125;,S_&#123;5,1&#125;\&#125;, \\ h_1 &= -g_1 + 3(C_&#123;2,3,4,5&#125; - B_&#123;4,5&#125; - B_&#123;2,3&#125;c), \\ h_2 &= 2(g_2 + 3cB_&#123;4,5&#125;), \\ h_3 &= 3(A_&#123;4,5&#125; - (c+1)B_&#123;4,5&#125;) - 2g_3, \\ h_4 &= 3(A_&#123;2,3&#125; - (c+1)B_&#123;2,3&#125;) - 2g_4, \\ h_5 &= 2(g_5 + 3B_&#123;2,3&#125;), \end&#123;split&#125;</div>
      <p class="text-gray-300">where</p>
      <div class="math-block">A_&#123;i,j&#125; = (g_i + g_j)(g_i + cg_j),</div>
      <div class="math-block">B_&#123;i,j&#125; = g_i g_j,</div>
      <div class="math-block">C_&#123;2,3,4,5&#125; = (g_2 + g_5)(g_3 c + g_4).</div>
      <p class="text-gray-300">It is clear from Theorem 3.1 that an inverse to the compression function C can be given as follows.</p>
      <div class="math-block">\tilde&#123;g&#125;_0 = (2\tilde&#123;g&#125;_1^2 + \tilde&#123;g&#125;_2\tilde&#123;g&#125;_5 - 3\tilde&#123;g&#125;_3\tilde&#123;g&#125;_4)c + 1.</div>
      <p class="text-gray-300">There is one class of squaring formulae with |I| = 6 and we list below two formulae that are the most efficient ones according to our analysis; the first can be seen as an extension of the squaring formula in Theorem 3.2, and the second one can be seen as an extension of the squaring formula in Section 5.4.</p>
      <div class="math-block">\begin&#123;split&#125; I &= \&#123;0,1,2,3,4,5\&#125;, \ \mathcal&#123;C&#125;(g) = [g_0,g_1,g_2,g_3,g_4,g_5], \\ \mathcal&#123;S&#125;_I &= \&#123;S_&#123;0,3&#125;,S_&#123;1,1&#125;,S_&#123;2,1&#125;,S_&#123;3,4&#125;,S_&#123;4,5&#125;,S_&#123;5,1&#125;\&#125;, \\ h_0 &= S_&#123;0,3&#125; = 3g_0^2 - 2g_0 + 3g_1^2 = 3(A_&#123;0,1&#125; - (c+1)B_&#123;0,1&#125;) - 2g_0, \\ h_1 &= S_&#123;1,1&#125; = 6g_0g_1 + 2g_1 = 2(g_1 + 3B_&#123;0,1&#125;), \\ h_2 &= S_&#123;2,1&#125; = 2g_2 + 6g_4g_5 = 2(g_2 + 3cB_&#123;4,5&#125;), \\ h_3 &= S_&#123;3,4&#125; = 3g_4^2 + 3g_5^2c - 2g_3 = 3(A_&#123;4,5&#125; - (c+1)B_&#123;4,5&#125;) - 2g_3, \\ h_4 &= S_&#123;4,5&#125; = 3g_2^2 + 3g_3^2c - 2g_4 = 3(A_&#123;2,3&#125; - (c+1)B_&#123;2,3&#125;) - 2g_4, \\ h_5 &= S_&#123;5,1&#125; = 2g_5 + 6g_2g_3 = 2(g_5 + 3B_&#123;2,3&#125;), \end&#123;split&#125;</div>
      <p class="text-gray-300">where</p>
      <div class="math-block">A_&#123;i,j&#125; = (g_i + g_j)(g_i + cg_j),</div>
      <div class="math-block">B_&#123;i,j&#125; = g_i g_j.</div>
      <p class="text-gray-300">Note that  <span class="math">C(g^2)</span>  can be computed at a cost dominated by 6 multiplications in  <span class="math">\mathbb&#123;F&#125;_q</span> , and there is no need of a decompression function. In fact, a closer look at the formulae [12] shows that the above formula is a rediscovery of GS-squaring.</p>
      <p class="text-gray-300">5.8.</p>
      <div class="math-block">\begin&#123;aligned&#125; \mathbf&#123;SQR&#125;_&#123;012345&#125;: \mathcal&#123;F&#125; &= \&#123;I, \mathcal&#123;C&#125;, \mathcal&#123;S&#125;_I\&#125; \ \mathbf&#123;with&#125; \ |I| = 6. \\ &I = \&#123;0, 1, 2, 3, 4, 5\&#125;, \ \mathcal&#123;C&#125;(g) = [g_0, g_1, g_2, g_3, g_4, g_5], \\ &\mathcal&#123;S&#125;_I = \&#123;S_&#123;0,1&#125;, S_&#123;1,1&#125;, S_&#123;2,1&#125;, S_&#123;3,2&#125;, S_&#123;4,1&#125;, S_&#123;5,1&#125;\&#125;, \\ &h_0 = S_&#123;0,1&#125; = 2g_0^2 + 4g_3g_4c - 1 = 2(T_0 + T_1c) - 1, \\ &h_1 = S_&#123;1,1&#125; = 6g_0g_1 + 2g_1 = 2(g_1 + 3B_&#123;0,1&#125;), \\ &h_2 = S_&#123;2,1&#125; = 2g_2 + 6g_4g_5c = 2(g_2 + 3cB_&#123;4,5&#125;), \\ &h_3 = S_&#123;3,2&#125; = 4g_0g_3 + 2g_4^2 = (T_1 + T_2) - 2(T_0 + T_4), \\ &h_4 = S_&#123;4,1&#125; = 4g_0g_4 + 2g_3^2c = 2(T_4c - T_3) + (T_1 - T_2), \\ &h_5 = S_&#123;5,1&#125; = 2g_5 + 6g_2g_3 = 2(g_5 + 3B_&#123;2,3&#125;), \end&#123;aligned&#125;</div>
      <p class="text-gray-300">where</p>
      <div class="math-block">T_0 = g_0^2,</div>
      <div class="math-block">T_1 = (g_0 + g_3 + g_4)^2,</div>
      <div class="math-block">T_2 = (g_0 + g_3 - g_4)^2,</div>
      <div class="math-block">T_3 = 2g_3g_4,</div>
      <div class="math-block">T_4 = g_3^2,</div>
      <div class="math-block">B_&#123;i,i&#125; = g_ig_i.</div>
      <p class="text-gray-300">Using the above formula,  <span class="math">C(g^2)</span>  can be computed at a cost dominated by 4 multiplications and 4 squarings in  <span class="math">\mathbb&#123;F&#125;_q</span> , and and there is no need of a decompression function.</p>
      <h2 id="6-comparisons" class="text-2xl font-bold mt-10 mb-4">6. Comparisons</h2>
      <p class="text-gray-300">In Tables 2, 3 and 4, we compare the most efficient squaring formulae in this paper with the squaring formula in [12] which is the fastest previously-known squaring formula that can be easily adapted for multi-exponentiation algorithms. We denote our squaring formula in Theorem 3.2 by  <span class="math">SQR_&#123;2345&#125;</span>  (also see Section 5.3) as it can be written as a function of  <span class="math">g_2</span> ,  <span class="math">g_3</span> ,  <span class="math">g_4</span> ,  <span class="math">g_5</span> . Similarly, we denote the squaring formulae in Sections 5.4, 5.6 and 5.8 by  <span class="math">SQR_&#123;0134&#125;</span> ,  <span class="math">SQR_&#123;12345&#125;</span>  and  <span class="math">SQR_&#123;012345&#125;</span> , respectively.</p>
      <p class="text-gray-300">As before, we let  <span class="math">M_i</span>  and  <span class="math">S_i</span>  denote multiplication and squaring costs in  <span class="math">\mathbb&#123;F&#125;_&#123;p^i&#125;</span> , and assume a)  <span class="math">M_&#123;2i&#125; = 3M_i</span> ,  <span class="math">M_&#123;3i&#125; = 6M_i</span> ; and b)  <span class="math">S_1 = M_1</span> ,  <span class="math">S_&#123;2i&#125; = 2M_i</span> ,  <span class="math">S_&#123;3i&#125; = M_i + 4S_i</span> .</p>
      <p class="text-gray-300">TABLE 2. A comparison of squaring algorithms in  <span class="math">G_&#123;\Phi_6(q)&#125; \subset \mathbb&#123;F&#125;_&#123;q^6&#125;^*</span> , where  <span class="math">q = p^i \equiv 1 \pmod&#123;6&#125;</span>  and  <span class="math">i = 2^a 3^b</span>  with a &gt; 0.</p>
      <div class="overflow-x-auto my-4"><table class="text-sm text-gray-300 border-collapse w-full"><tbody>
        <tr><td class="border border-gray-700 px-3 py-1">Algorithm</td><td class="border border-gray-700 px-3 py-1">Squaring cost</td><td class="border border-gray-700 px-3 py-1">Decompression cost</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"><span class="math">SQR_&#123;2345&#125;</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">(6^b \cdot 3^a \cdot 4)M_1</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">1I_i + (6^b \cdot 3^a \cdot 5)M_1</span></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"><span class="math">SQR_&#123;0134&#125;</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">(6^b \cdot 3^a \cdot 14/3) M_1</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">1I_i + (6^b \cdot 3^a \cdot 16/3)M_1</span></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"><span class="math">SQR_&#123;12345&#125;</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">(6^b \cdot 3^a \cdot 5)M_1</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">(6^b \cdot 3^a \cdot 8/3)M_1</span></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"><span class="math">SQR_&#123;012345&#125;</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">(6^b \cdot 3^a \cdot 20/3) M_1</span></td><td class="border border-gray-700 px-3 py-1">0</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">GS-squaring [12]</td><td class="border border-gray-700 px-3 py-1"><span class="math">(6^b \cdot 3^a \cdot 6)M_1</span></td><td class="border border-gray-700 px-3 py-1">0</td></tr>
      </tbody></table></div>
      <p class="text-gray-300">According to Table 2,  <span class="math">SQR_&#123;2345&#125;</span>  is the fastest squaring algorithm. In particular,  <span class="math">SQR_&#123;2345&#125;</span>  is 33% faster than GS-squaring. When evaluating the costs of squaring algorithms in Table 2, we</p>
      <p class="text-gray-300">assumed that  <span class="math">M_&#123;2^a3^b&#125; = (6^b \cdot 3^a) M_1</span>  and  <span class="math">S_&#123;2^a3^b&#125; = 2 M_&#123;2^&#123;a-1&#125;3^b&#125; = (6^b \cdot 3^a \cdot 2/3) M_1</span> . In particular, the costs of SQR<sub>2345</sub> and GS-squaring are computed as  <span class="math">2 S_&#123;2^&#123;a+1&#125;3^b&#125; = 4 M_&#123;2^a3^b&#125; = (6^b \cdot 3^a \cdot 4) M_1</span>  and  <span class="math">3 S_&#123;2^&#123;a+1&#125;3^b&#125; = 6 M_&#123;2^a3^b&#125; = (6^b \cdot 3^a \cdot 6) M_1</span> , respectively.</p>
      <p class="text-gray-300">It is possible to obtain better (asymptotic) running time estimates for the algorithms listed in Table 2 because using  <span class="math">S_&#123;3i&#125; = M_i + 4S_i</span>  repetitively, we can show that</p>
      <div class="math-block">S_&#123;2^a3^b&#125; = 6^b \cdot 3^a \cdot 1/2 \cdot (1 + (2^b/3^&#123;b+1&#125;))M_1 \text&#123; for &#125; a, b &gt; 0.</div>
      <p class="text-gray-300">Note that  <span class="math">(M_&#123;2^a3^b&#125;/S_&#123;2^a3^b&#125;) \to 2</span>  as  <span class="math">b \to \infty</span> . Then, for example, the costs of SQR<sub>2345</sub> and GS-squaring can be estimated as  <span class="math">2S_&#123;2^&#123;a+1&#125;3^b&#125; = (6^b \cdot 3^a \cdot 3)M_1</span>  and  <span class="math">3S_&#123;2^&#123;a+1&#125;3^b&#125; = (6^b \cdot 3^a \cdot 9/2)M_1</span> , respectively. We present an asymptotic comparison of the squaring algorithms in Table 3. According to Table 3, SQR<sub>2345</sub> is the fastest squaring algorithm, and is 33% faster than GS-squaring.</p>
      <p class="text-gray-300">TABLE 3. An asymptotic comparison of squaring algorithms in  <span class="math">G_&#123;\Phi_6(q)&#125; \subset \mathbb&#123;F&#125;_&#123;q^6&#125;^*</span> , where  <span class="math">q = p^i \equiv 1 \pmod&#123;6&#125;</span>  and  <span class="math">i = 2^a 3^b</span>  with a &gt; 0 and  <span class="math">b \to \infty</span> .</p>
      <div class="overflow-x-auto my-4"><table class="text-sm text-gray-300 border-collapse w-full"><tbody>
        <tr><td class="border border-gray-700 px-3 py-1">Algorithm</td><td class="border border-gray-700 px-3 py-1">Squaring cost</td><td class="border border-gray-700 px-3 py-1">Decompression cost</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"><span class="math">SQR_&#123;2345&#125;</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">(6^b \cdot 3^a \cdot 3)M_1</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">1I_i + (6^b \cdot 3^a \cdot 9/2)M_1</span></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"><span class="math">SQR_&#123;0134&#125;</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">(6^b \cdot 3^a \cdot 4)M_1</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">1I_i + (6^b \cdot 3^a \cdot 5)M_1</span></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"><span class="math">SQR_&#123;12345&#125;</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">(6^b \cdot 3^a \cdot 5)M_1</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">(6^b \cdot 3^a \cdot 5/2)M_1</span></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"><span class="math">SQR_&#123;012345&#125;</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">(6^b \cdot 3^a \cdot 6)M_1</span></td><td class="border border-gray-700 px-3 py-1">0</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">GS-squaring [12]</td><td class="border border-gray-700 px-3 py-1"><span class="math">(6^b \cdot 3^a \cdot 9/2)M_1</span></td><td class="border border-gray-700 px-3 py-1">0</td></tr>
      </tbody></table></div>
      <p class="text-gray-300">As we noted in Section 4, the decompression costs must be considered when adapting our squaring formulae in exponentiation algorithms. However, this does not seem to be a big issue when the exponent has low Hamming weight. For example, in Section 4.1 we discuss how  <span class="math">SQR_&#123;2345&#125;</span>  can be used to improve the efficiency of exponentiation in  <span class="math">G_&#123;\Phi_&#123;12&#125;(p)&#125; \subset \mathbb&#123;F&#125;_&#123;p^&#123;12&#125;&#125;^<em></span>  and the BN pairing computations. Similarly, from Table 4 we see that  <span class="math">SQR_&#123;2345&#125;</span>  can be used to improve the efficiency of exponentiation in  <span class="math">G_&#123;\Phi_k(p)&#125; \subset \mathbb&#123;F&#125;_&#123;p^k&#125;^</em></span>  and pairing computations that use elliptic curves with embedding degree k, for k = 18, 24.</p>
      <p class="text-gray-300">Table 4. A comparison of squaring algorithms in  <span class="math">G_&#123;\Phi_6(q)&#125; \subset \mathbb&#123;F&#125;_&#123;q^6&#125;^*</span> ,  <span class="math">q \equiv 1 \pmod&#123;6&#125;</span> .</p>
      <div class="overflow-x-auto my-4"><table class="text-sm text-gray-300 border-collapse w-full"><tbody>
        <tr><td class="border border-gray-700 px-3 py-1"><span class="math">q = p^i</span></td><td class="border border-gray-700 px-3 py-1">Squaring cost</td><td class="border border-gray-700 px-3 py-1">Decompression cost</td><td class="border border-gray-700 px-3 py-1">Squaring cost</td><td class="border border-gray-700 px-3 py-1">Decompression cost</td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"><span class="math">\mathrm&#123;SQR&#125;_&#123;2345&#125;</span></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"><span class="math">SQR_&#123;0134&#125;</span></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">i</td><td class="border border-gray-700 px-3 py-1"><span class="math">\min(4M_i, 2S_&#123;2i&#125;)</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">1I_i + 3M_i + 3S_i</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">2M_i + 4S_i</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">1I_i + 4M_i + 2S_i</span></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">i = 1</td><td class="border border-gray-700 px-3 py-1"><span class="math">4M_1</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">1I_1 + 6M_1</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">6M_1</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">1I_1 + 6M_1</span></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">i=2</td><td class="border border-gray-700 px-3 py-1"><span class="math">12M_1</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">1I_2 + 15M_1</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">14M_&#123;1&#125;</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">1I_2 + 16M_1</span></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">i = 3</td><td class="border border-gray-700 px-3 py-1"><span class="math">22M_1</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">1I_3 + 33M_1</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">32M_&#123;1&#125;</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">1I_3 + 34M_1</span></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">i = 4</td><td class="border border-gray-700 px-3 py-1"><span class="math">36M_1</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">1I_4 + 45M_1</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">42M_&#123;1&#125;</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">1I_4 + 48M_1</span></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"><span class="math">\overline&#123;\mathrm&#123;SQR&#125;&#125;_&#123;12345&#125;</span></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"><span class="math">SQR_&#123;012345&#125;</span></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">i</td><td class="border border-gray-700 px-3 py-1"><span class="math">5M_i</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">2M_i + 1S_i</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">4M_i + 4S_i</span></td><td class="border border-gray-700 px-3 py-1">0</td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">i = 1</td><td class="border border-gray-700 px-3 py-1"><span class="math">5M_1</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">3M_1</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">8M_1</span></td><td class="border border-gray-700 px-3 py-1">0</td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">i=2</td><td class="border border-gray-700 px-3 py-1"><span class="math">15M_&#123;1&#125;</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">8M_1</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">20M_&#123;1&#125;</span></td><td class="border border-gray-700 px-3 py-1">0</td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">i = 3</td><td class="border border-gray-700 px-3 py-1"><span class="math">30M_1</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">17M_1</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">44M_&#123;1&#125;</span></td><td class="border border-gray-700 px-3 py-1">0</td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">i=4</td><td class="border border-gray-700 px-3 py-1"><span class="math">45M_&#123;1&#125;</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">24M_1</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">60M_1</span></td><td class="border border-gray-700 px-3 py-1">0</td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">GS-squaring [12]</td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">i</td><td class="border border-gray-700 px-3 py-1"><span class="math">\min(6M_i, 3S_&#123;2i&#125;)</span></td><td class="border border-gray-700 px-3 py-1">0</td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">i = 1</td><td class="border border-gray-700 px-3 py-1"><span class="math">6M_1</span></td><td class="border border-gray-700 px-3 py-1">0</td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">i=2</td><td class="border border-gray-700 px-3 py-1"><span class="math">18M_1</span></td><td class="border border-gray-700 px-3 py-1">0</td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">i = 3</td><td class="border border-gray-700 px-3 py-1"><span class="math">33M_1</span></td><td class="border border-gray-700 px-3 py-1">0</td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">i=4</td><td class="border border-gray-700 px-3 py-1"><span class="math">54M_1</span></td><td class="border border-gray-700 px-3 py-1">0</td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
      </tbody></table></div>
      <sup>&</sup>lt;sup&gt;2</sup>Families of elliptic curves with embedding degree 18 and 24 are given in [7].
      <p class="text-gray-300">When the exponent is chosen at random in an exponentiation algorithm, it seems more advantageous to use one of SQR<sup>12345</sup> or GS-squaring because decompression is a relatively cheap operation. Let e be an exponent with `-bits. The width-w NAF representation of e contains on average `/(w + 1) nonzero digits which determines the number of multiplications and the number of decompression operations in the exponentiation algorithm. Then, the cost of computing g <sup>e</sup>  G6(<sup>p</sup> <sup>i</sup>)  F  p <sup>6</sup><sup>i</sup> using SQR<sup>12345</sup> and GS-squaring would be dominated by</p>
      <div class="math-block">\begin&#123;aligned&#125; & \text&#123;EXP&#125;_&#123;12345&#125;(i, w, \ell) = (5\ell)M_i + \frac&#123;\ell&#125;&#123;w+1&#125;(M_&#123;6i&#125;) + \frac&#123;\ell&#125;&#123;w+1&#125;(2M_i + 1S_i), \\ & \text&#123;EXP&#125;_&#123;GS&#125;(i, w, \ell) = (3\ell)(S_&#123;2i&#125;) + \frac&#123;\ell&#125;&#123;w+1&#125;M_&#123;6i&#125;, \end&#123;aligned&#125;</div>
      <p class="text-gray-300">respectively. Table 5 compares the exponentiation costs per bit of ` for particular cases of i and w.</p>
      <p class="text-gray-300">Table 5. A comparison of exponentiation costs in G6(q)  F  q <sup>6</sup> . exp<sup>12345</sup> and expGS are the exponentiation costs per bit of exponent, where the exponentiation is performed based on SQR<sup>12345</sup> and GS-squaring, respectively. The exponent is represented in width-w NAF and q = p <sup>i</sup>  1 (mod 6).</p>
      <div class="overflow-x-auto my-4"><table class="text-sm text-gray-300 border-collapse w-full"><tbody>
        <tr><td class="border border-gray-700 px-3 py-1">(i, w)</td><td class="border border-gray-700 px-3 py-1">(2, 2)</td><td class="border border-gray-700 px-3 py-1">(3, 2)</td><td class="border border-gray-700 px-3 py-1">(4, 2)</td><td class="border border-gray-700 px-3 py-1">(2, 3)</td><td class="border border-gray-700 px-3 py-1">(3, 3)</td><td class="border border-gray-700 px-3 py-1">(4, 3)</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">exp12345</td><td class="border border-gray-700 px-3 py-1">35.6</td><td class="border border-gray-700 px-3 py-1">71.6</td><td class="border border-gray-700 px-3 py-1">107</td><td class="border border-gray-700 px-3 py-1">30.5</td><td class="border border-gray-700 px-3 py-1">60.75</td><td class="border border-gray-700 px-3 py-1">91.5</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">expGS</td><td class="border border-gray-700 px-3 py-1">36</td><td class="border border-gray-700 px-3 py-1">69</td><td class="border border-gray-700 px-3 py-1">108</td><td class="border border-gray-700 px-3 py-1">31.5</td><td class="border border-gray-700 px-3 py-1">60</td><td class="border border-gray-700 px-3 py-1">94.5</td></tr>
      </tbody></table></div>
      <p class="text-gray-300">We proposed new squaring formulae for cyclotomic subgroups G6(p)  F  q <sup>6</sup> , where q  1 (mod 6), and demonstrated that the formulae can be used to speed up cryptographic protocols. Our operation counts ignored the cost of addition, subtraction and the cost of multiplying a finite field element by a small integer. Therefore, it would be desirable to implement the algorithms to verify their relative efficiency.</p>
      <h2 id="acknowledgment" class="text-2xl font-bold mt-10 mb-4">Acknowledgment</h2>
      <p class="text-gray-300">The author would like to thank Diego F. Aranha and Alfred Menezes for fruitful discussion and for their useful comments on the paper.</p>
      <h2 id="references" class="text-2xl font-bold mt-10 mb-4">References</h2>
      <ul class="list-disc list-inside text-gray-300 space-y-1 my-2">
        <li>[1] D. Aranha, K. Karabina, P. Longa, C. Gebotys, and J. Lopez. Faster explicit formulas for computing pairings over ordinary curves. 2010. Available at http://eprint.iacr.org/2010/526.</li>
        <li>[2] P. Barreto and M. Naehrig. Pairing-friendly elliptic curves of prime order. Selected Areas in Cryptography  SAC 2005, Lecture Notes in Computer Science, 3897:319331, 2006.</li>
        <li>[3] N. Benger and M. Scott. Constructing tower extensions of finite fields for implementation of pairing-based cryptography. Arithmetic of Finite Fields  WAIFI 2010, Lecture Notes in Computer Science, 6087:180195, 2010.</li>
        <li>[4] J. Beuchat, J. Daz, S. Mitsunari, E. Okamoto, F. Rodrguez-Henrquez, and T. Teruya. High-speed software implementation of the optimal Ate pairing over Barreto-Naehrig curves. 2010. Available at http://eprint. iacr.org/2010/354.</li>
        <li>[5] A. Brouwer, R. Pellikaan, and E. Verheul. Doing more with fewer bits. Advances in Cryptology ASI-ACRYPT '99, Lecture Notes in Computer Science, 1716:321332, 1999.</li>
        <li>[6] J. Chung and M. Hasan. Asymmetric squaring formulae. 18th IEEE Symposium on Computer Arithmetic  ARITH 2007, pages 113122, 2007.</li>
        <li>[7] D. Freeman, M. Scott, and E. Teske. A taxonomy of pairing-friendly elliptic curves. Journal of Cryptology, 23:224280, 2010.</li>
      </ul>
      <ul class="list-disc list-inside text-gray-300 space-y-1 my-2">
        <li>[8] K. Giuliani and G. Gong. Analogues to the Gong-Harn and XTR cryptosystems. Technical Report CORR 2003-34, University of Waterloo, 2003. Available at http://www.cacr.math.uwaterloo.ca/techreports/ 2003/corr2003-34.ps.</li>
        <li>[9] G. Gong and L. Harn. Public-key cryptosystems based on cubic finite field extensions. IEEE Transactions on Information Theory, 45:26012605, 1999.</li>
        <li>[10] R. Granger, D. Page, and N. Smart. High security pairing-based cryptography revisited. Curves over Finite Fields and Applications  Algorithmic Number Theory, Lecture Notes in Computer Science, 4076:480494, 2006.</li>
        <li>[11] R. Granger, D. Page, and M. Stam. A comparison of CEILIDH and XTR. Algorithmic Number Theory symposium  ANTS VI, Lecture Notes in Computer Science, 3076:235249, 2004.</li>
        <li>[12] R. Granger and M. Scott. Faster squaring in the cyclotomic subgroup of sixth degree extensions. Public Key Cryptography  PKC 2010, Lecture Notes in Computer Science, 6056:209223, 2010.</li>
        <li>[13] D. Harris. Simultaneous field divisions: an extension of Montgomery's trick. 2008. Available at http: //eprint.iacr.org/2008/199.</li>
        <li>[14] K. Karabina. Double-exponentiation in factor-4 groups and its applications. Twelfth IMA International Conference on Cryptography and Coding, Lecture Notes in Computer Science, 5921:336350, 2009.</li>
        <li>[15] K. Karabina. Factor-4 and 6 compression of cyclotomic subgroups of F  <sup>2</sup>4<sup>m</sup> and <sup>F</sup>  <sup>3</sup>6m. Journal of Mathematical Cryptology, 4:142, 2010.</li>
        <li>[16] K. Karabina. Torus-based compression by factor 4 and 6. 2010. Available at http://eprint.iacr.org/ 2010/525.</li>
        <li>[17] N. Koblitz and A. Menezes. Pairing-based cryptography at high security levels. Tenth IMA International Conference on Cryptography and Coding, Lecture Notes in Computer Science, 3796:1336, 2005.</li>
        <li>[18] A. Lenstra and E. Verheul. The XTR public key system. Advances in Cryptology CRYPTO 2000, Lecture Notes in Computer Science, 1880:119, 2000.</li>
        <li>[19] C. Lim and H. Hwang. Fast implementation of elliptic curve arithmetic in GF(p n ). Public Key Cryptography  PKC 2000, Lecture Notes in Computer Science, 1751:405421, 2000.</li>
        <li>[20] P. Montgomery. Speeding the Pollard and elliptic curve methods of factorization. Mathematics of Computation, 48:243264, 1987.</li>
        <li>[21] Y. Nogami, M. Akane, Yumi Sakemi, H. Kato, and Y. Morikawa. Integer variable -based ate pairing. Pairing-Based Cryptography  Pairing 2008, Lecture Notes in Computer Science, 5209:178191, 2008.</li>
        <li>[22] K. Rubin and A. Silverberg. Torus-based cryptography. Advances in Cryptology CRYPTO 2003, Lecture Notes in Computer Science, 2729:349365, 2003.</li>
        <li>[23] K. Rubin and A. Silverberg. Compression in finite fields and torus-based cryptography. SIAM Journal on Computing, 37:14011428, 2008.</li>
        <li>[24] M. Scott. Implementing cryptographic pairings. Pairing-Based Cryptography Pairing 2007, Lecture Notes in Computer Science, 4575:177196, 2007.</li>
        <li>[25] M. Shirase, D. Han, Y. Hibin, H. Kim, and T. Takagi. A more compact representation of XTR cryptosystem. IEICE Transactions on Fundamentals of Electronics, Communications and Computer Sciences, E91-A:28432850, 2008.</li>
        <li>[26] P. Smith and C. Skinner. A public-key cryptosystem and a digital signature system based on the Lucas function analogue to discrete logarithms. Advances in Cryptology  ASIACRYPT '94, Lecture Notes In Computer Science, 917:357364, 1994.</li>
        <li>[27] M. Stam and A. Lenstra. Speeding up XTR. Advances in Cryptology ASIACRYPT 2001, Lecture Notes in Computer Science, 2248:125143, 2001.</li>
        <li>[28] M. Stam and A. Lenstra. Efficient subgroup exponentiation in quadratic and sixth degree extensions. Cryptographic Hardware and Embedded Systems  CHES 2002, 2523:159174, 2003.</li>
        <li>[29] M. van Dijk, R. Granger, D. Page, K. Rubin, A. Silverberg, M. Stam, and D. Woodruff. Practical cryptography in high dimensional tori. Advances in Cryptology  EUROCRYPT 2005, Lecture Notes in Computer Science, 3494:234250, 2005.</li>
        <li>[30] M. van Dijk and D. Woodruff. Asymptotically optimal communication for torus-based cryptography. Advances in Cryptology  CRYPTO 2004, Lecture Notes in Computer Science, 3152:151178, 2004.</li>
      </ul>
      <p class="text-gray-300">A.1.</p>
      <div class="math-block">\mathcal&#123;H&#125;_0 = \&#123;S_&#123;0,j&#125;: j = 1, 2, \dots, 13\&#125;</div>
      <p class="text-gray-300">.</p>
      <div class="math-block">S_&#123;0,1&#125; = 2g_0^2 + 4g_3g_4c - 1</div>
      <div class="math-block">S_&#123;0,2&#125; = -6g_0^2 + 4g_0 + 12g_2g_5c + 3</div>
      <div class="math-block">S_&#123;0,3&#125; = 3g_0^2 - 2g_0 + 3g_1^2c</div>
      <div class="math-block">\begin&#123;array&#125;&#123;lll&#125; S_&#123;0,4&#125; &=& 1+(2g_1^2+4g_2g_5)c\\ S_&#123;0,5&#125; &=& (3g_2g_5+3g_3g_4)c+g_0\\ S_&#123;0,6&#125; &=& (-6g_1^2+12g_3g_4)c-3+4g_0\\ S_&#123;0,7&#125; &=& 27g_1^2g_3^2s^3+((-27g_1g_2g_3^2-72g_1^4)g_0+81g_1^2g_2^2g_3-48g_1^4\\ &+27g_1g_2g_3^2+18g_3^3)c^2+((-9g_1g_3^2-42g_1^2)g_0-36g_1^2\\ &+6g_2^2g_3+21g_1g_3^2)c-3+4g_0\\ S_&#123;0,8&#125; &=& -3/2g_1g_5^2c^3+(-9/2g_0g_4g_5^2-12g_1^4+21/2g_4g_5^2+63/2g_1g_4^2g_5)c\\ &+((12g_1^2-27/2g_4^3)g_0+27/2g_3^3-9g_1^2)c-3+4g_0\\ S_&#123;0,9&#125; &=& (63/2g_1g_2g_3^2-12g_1^4+27/2g_3^3-27/2g_0g_3^3)c^2\\ &+((-9/2g_2^2g_3+12g_1^2)g_0-3/2g_1g_2^2+21/2g_2^2g_3-9g_1^2)c\\ &-3+4g_0\\ S_&#123;0,10&#125; &=& -729/4g_1^2g_5^2c^5+(324g_1^4g_3^3+243/4g_1g_2g_3^5-243/2g_1^2g_2^2g_3^4\\ &+486g_0g_1^4g_3^3+243/16g_3^2-16g_1^2g_2g_3^2)c^4\\ &+(81g_0g_1^2g_3^3+144g_1^6+54g_1^4g_2^2g_3-513g_1^3g_2g_3^2\\ &+(81g_0g_1^2g_3^3+144g_1^6+54g_1^4g_2^2g_3-513g_1^3g_2g_3^2\\ &+(-81/4g_2^4g_3^2-297/2g_3^3)g_1^2+81/2g_1g_2^3g_3^3+81/8g_2^2g_3^4)c^3\\ &+((-144g_1^4+27/8g_3^3)g_0+132g_1^4+18g_1^3g_2^3-225/2g_1^2g_2g_3\\ &+((-144g_1^4+27/8g_3^3)g_1+27/16g_2^4g_3^2+117/8g_3^3)c^2\\ &+(6g_2^2g_3-96g_0g_1^2+12g_1g_3^3+18g_1^2)c-3+4g_0\\ S_&#123;0,11&#125; &=& (27/4g_1g_4g_5^2+81/2g_1g_3^3+18g_1^2)c^3+(-162g_1^5g_2g_5+54g_1^4g_3^2-243/2g_1^2g_4^4g_5^2\\ &+27/16g_4^2g_5^2+81/2g_1g_3^3g_3^2+18g_1^2)c^2+(-62g_1^2g_3^2g_3^2+72g_1^2g_3^2+3g_1^2g_3^2+3g_1^2+3g_1^2g_2^2+3g_1^2+3g_1^2g_2^2+3g_1^2+3g_1^2g_3^2+3g_1^2+3g_1^2g_2^2+3g_1^2+3g_1^2g_2^2+3g_1^2+3g_1^2g_2^2+3g_1^2+3g_1^2g_2^2+3g_1^2+3g_1^2g_2^2+3g_1^2+3g_1^2g_2^2+3g_1^2+3g_1^2g_2^2+3g_1^2+3g_1^2g_2^2+3g_1^2+3g_1^2g_2^2+3g_1^2+3g_1^2g_2^2+3g_1^2+3g_1^2g_2^2+3g_1^2+3g_1^2g_2^2+3g_1^2+3g_1^2g_2^2+3g_1^2+3g_1^2g_2^2+3g_1^2+3g_1^2g_2^2+3g_1^2+3g_1^2g_2^2+3g_1^2+3g_1^2+3g_1^2g_2^2+3g_1^2+3g_1^2g_2^2+3g_1^2+3g_1^2g_2^2+3g_1^2+3g_1^2+3g_1^2g_2^2+3g_1^2+3g_1^2g_2^2+3g_1^2+3g_1^2g_2^2+3g_1^2+3g_1^2+3g_1^2g_2^2+3g_1^2+3g_1^2g_2^2+3g_1^2+3g_1^2g_2^2+3g_1^2+3g_1^2+3g_1^2g_2^2+3g_1^2+3g_1^2g_2^2+3g_1^2+3g_1^2g_2^2+3g_1^2+3g_1^2+3g_1^2g_2^2+3g_1^2+3g_1^2g_1^2+3g_1^2+3g_1^2g_1^2+3g_1^2g_1^2+3g_1^2g_1^2+3g_1^2+3g_1^2g_1^2+3g_1^2+3g_1^2g_1^2+3g_1^2+3g_1^2</div>
      <div class="math-block">\begin&#123;aligned&#125; &+81/4g_1g_4^3g_5^3)c^4 + ((-9/4g_1g_5^3 - 1080g_1^6)g_0 - 1080g_1^6 + 486g_1^4g_4^3\\ &-243g_1^3g_4^2g_5 - 54g_1^2g_4g_5^2 + (243/8g_4^5g_5 + 57/4g_5^3)g_1)c^3\\ &+ (27g_1g_4^2g_5 + 6g_4g_5^2 + 168g_1^4 + 522g_0g_1^4 - 621/4g_1^2g_4^3)c^2\\ &+ (-165/2g_0g_1^2 + 18g_4^3 + 9/2g_1^2)c - 3 + 4g_0\end&#123;aligned&#125;</div>
      <p class="text-gray-300">A.2.</p>
      <div class="math-block">\mathcal&#123;H&#125;_1 = \&#123;S_&#123;1,j&#125;: j=1,2,\ldots,14\&#125;.</div>
      <div class="math-block">S_&#123;1,1&#125; = 6g_0g_1 + 2g_1</div>
      <div class="math-block">S_&#123;1,2&#125; = -g_1 + 3g_2g_4 + 3g_3g_5c</div>
      <div class="math-block">S_&#123;1,3&#125; = (12g_1g_2g_5 + 12g_1^3 - 36g_4^2g_5)c - 24g_2g_4 + 8g_1 + 12g_2^3</div>
      <div class="math-block">S_&#123;1,4&#125; = (-36g_1g_3g_4 + 12g_1^3 + 36g_4^2g_5)c + 24g_2g_4 + 8g_1 - 12g_2^3</div>
      <div class="math-block">S_&#123;1,5&#125; = 12g_5^3c^2 + (12g_1^3 + 12g_1g_2g_5 - 36g_2g_3^2 - 24g_3g_5)c + 8g_1</div>
      <div class="math-block">S_&#123;1,6&#125; = 3/2g_5^3c^2 + (-6g_1g_2g_5 + 9/2g_4^2g_5)c - g_1 + 3g_2g_4</div>
      <div class="math-block">S_&#123;1,7&#125; = 4/3g_5^3c^2 + (4/3g_1^3 - 4g_1g_2g_5)c + 4/3g_2^3</div>
      <div class="math-block">S_&#123;1,8&#125; = (-6g_1g_2g_5 + 9/2g_2g_3^2 + 3g_3g_5)c - g_1 + 3/2g_2^3</div>
      <div class="math-block">S_&#123;1,9&#125; = (12g_1^3 + 9/2g_2g_3^2 - 18g_1g_3g_4)c - 3g_2g_4 + 8g_1 + 3/2g_2^3</div>
      <div class="math-block">S_&#123;1,10&#125; = 12g_5^3c^2 + (-18g_0g_3g_5 + 9/2g_2g_3^2 - 3g_3g_5)c - g_1 + 3/2g_2^3</div>
      <div class="math-block">S_&#123;1,11&#125; = 3/2g_5^3c^2 + (12g_1^3 - 18g_1g_3g_4 - 3g_3g_5 + 9/2g_4^2g_5)c + 8g_1</div>
      <div class="math-block">S_&#123;1,12&#125; = -18g_0g_2g_4 - g_1 + 12g_2^3 - 3g_2g_4 + 9/2g_4^2g_5c + 3/2g_5^3c^2</div>
      <div class="math-block">S_&#123;1,13&#125; = (-9/2g_1g_4g_5^2 + 3/4g_5^3)c^2</div>
      <div class="math-block">+(-27/2g_1g_4^3 + 6g_1^3 + 18g_1^2g_2g_4 + 9/4g_4^2g_5)c</div>
      <div class="math-block">+7/2g_1 + 3/2g_2g_4</div>
      <div class="math-block">S_&#123;1,14&#125; = (18g_1^2g_3g_5 - 27/2g_1g_3^3)c^2</div>
      <div class="math-block">+(-9/2g_1g_2^2g_3 + 3/2g_3g_5 + 6g_1^3 + 9/4g_2g_3^2)c</div>
      <div class="math-block">+7/2g_1 + 3/4g_2^3</div>
      <p class="text-gray-300">A.3.</p>
      <div class="math-block">\mathcal&#123;H&#125;_2 = \&#123;S_&#123;2,j&#125;: j=1,2,\ldots,7\&#125;.</div>
      <div class="math-block">S_&#123;2,1&#125; = 2g_2 + 6g_4g_5c</div>
      <div class="math-block">S_&#123;2,2&#125; = 3g_0g_2 + 3g_1g_3c - g_2</div>
      <div class="math-block">S_&#123;2,3&#125; = (-12g_1g_5^2 + 9g_3^2g_5)c^2 + 3g_2^2g_5c + 2g_2</div>
      <div class="math-block">S_&#123;2,4&#125; = (3g_1g_3 + 3g_2^2g_5 - 9g_2g_3g_4 + 6g_1^2g_2)c + 2g_2</div>
      <div class="math-block">S_&#123;2,5&#125; = (18g_1g_2g_3g_5 - 27/2g_2g_3^3)c^2 + (6g_1^2g_2 - 9/2g_2^3g_3 + 3g_2^2g_5 + 3g_1g_3)c + 2g_2</div>
      <div class="math-block">S_&#123;2,6&#125; = (81/2g_1g_3^4 - 54g_1^2g_3^2g_5)c^3 + (-18g_1^3g_3 - 27/4g_2g_3^3 + 9/2g_3^2g_5 + 27/2g_1g_2^2g_3^2)c^2 + (-9/4g_2^3g_3 + 3g_2^2g_5 + 6g_1^2g_2 - 21/2g_1g_3)c + 2g_2</div>
      <div class="math-block">S_&#123;2,7&#125; = 2187/8g_3^8g_5c^6 + (243g_2^2g_3^6g_5 - 2187/2g_1^2g_2g_3^6 - 8019/8g_1g_3^7 + 486g_1^5g_3^4)c^5 + (-4293/4g_1g_2^2g_3^5 - 81g_1^4g_2g_3^3 + 1215/8g_2g_3^6 - 243/2g_1^2g_2^3g_3^4 + 567/8g_2^4g_3^4g_5 + 108g_1^5g_2^2g_3^2 + 1539/2g_1^3g_3^4 - 891/4g_3^5g_5)c^4 + (-216g_1^5g_3 - 18g_1^4g_2^3g_3 + 198g_1^3g_2^2g_3^2 + (27g_2^5g_3^2 + 1377/4g_2g_3^3)g_1^2 + (2997/4g_3^4 - 1593/8g_2^4g_3^3)g_1</div>
      <div class="math-block">+27/4g_2^6g_3^2g_5 - 603/4g_2^2g_3^3g_5 + 54g_2^3g_3^4)c^3</div>
      <div class="math-block">+((6g_2^4 - 342g_3)g_1^3 - 189/2g_1^2g_2^3g_3</div>
      <div class="math-block">+(6g_2^5g_5 + 2241/4g_2^2g_3^2 - 9/4g_2^6g_3)g_1</div>
      <div class="math-block">-57/2g_2^4g_3g_5 + 45g_3^2g_5 - 54g_2g_3^3 + 27/8g_2^5g_3^2)c^2</div>
      <div class="math-block">+(6g_1^2g_2 + (-132g_3 + 9/2g_2^4)g_1 + 18g_2^3g_3 - 3/4g_2^7 + 3g_2^2g_5)c + 2g_2</div>
      <p class="text-gray-300">A.4.</p>
      <div class="math-block">\mathcal&#123;H&#125;_3 = \&#123;S_&#123;3,j&#125;: j=1,2,\ldots,10\&#125;.</div>
      <div class="math-block">S_&#123;3,1&#125; = 4g_1g_2 + 2g_5^2c</div>
      <div class="math-block">S_&#123;3,2&#125; = 4g_0g_3 + 2g_4^2</div>
      <div class="math-block">S_&#123;3,3&#125; = 3g_0g_3 + 3g_1g_2 + g_3</div>
      <div class="math-block">S_&#123;3,4&#125; = -2g_3 + 3g_4^2 + 3g_5^2c</div>
      <div class="math-block">S_&#123;3,5&#125; = 12g_0g_3 + 4g_3 - 6g_5^2c</div>
      <div class="math-block">S_&#123;3,6&#125; = 12g_1g_2 + 4g_3 - 6g_4^2</div>
      <div class="math-block">S_&#123;3,7&#125; = (-27/2g_3^4 + 18g_1g_3^2g_5)c^2 + (6g_1^2g_3 - 9/2g_2^2g_3^2 + 3g_2g_3g_5)c</div>
      <div class="math-block">+3g_1g_2 + 4g_3</div>
      <div class="math-block">S_&#123;3,8&#125; = (6g_1^2g_3 + 9/2g_2^2g_3^2 - 18g_1g_2g_3g_4 - 9g_3^2g_4 + 12g_1^3g_2)c</div>
      <div class="math-block">+3/2g_4^4 - 6g_2^2g_4 + 12g_1g_2 + 4g_3</div>
      <div class="math-block">S_&#123;3,9&#125; = (54g_1^2g_3^2g_4 - 27/2g_1g_2g_3^3 + 27/4g_3^4 - 36g_1^4g_3)c^2</div>
      <div class="math-block">+(-9/2g_1g_3^2g_3 + 12g_1^3g_2 - 21g_1^2g_3 + 27/4g_2^2g_3^2 - 27/2g_3^2g_4)c</div>
      <div class="math-block">+3/2g_4^2 - 6g_2^2g_4 + 12g_1g_2 + 4g_3</div>
      <div class="math-block">S_&#123;3,10&#125; = (729/4g_1^2g_3^3 - 2187/8g_3^8g_4)c^5</div>
      <div class="math-block">+(-243g_2^2g_3^6g_4 + 81g_1^4g_3^4 - 243/8g_3^7 + 1053/2g_1^2g_2^2g_3^5</div>
      <div class="math-block">+243/2g_1g_2g_3^6 - 162g_1^5g_2g_3^3)c^4</div>
      <div class="math-block">+(-36g_1^5g_2^3g_3 + 72g_1^4g_2^2g_3^2 - 567/2g_1^3g_2g_3^3</div>
      <div class="math-block">+(351/4g_2^4g_3^3 - 81/4g_3^4)g_1^2 + 999/4g_1g_2^3d_3^4</div>
      <div class="math-block">-567/8g_2^4g_3^4g_4 - 513/4g_2^2g_3^5 + 891/4g_3^5g_4)c^3</div>
      <div class="math-block">+((12g_2^4 - 36g_3)g_1^4 - 81g_1^3g_2^3g_3 + (-9/2g_2^2g_3 + 27g_2^2g_3^2)g_1^2</div>
      <div class="math-block">+(-27g_2g_3^3 + 225/4g_2^5g_3^3g_1 - 459/8g_2^4g_3^3</div>
      <div class="math-block">+603/4g_2^2g_3^3g_4 - 27/4g_2^6g_3^2g_4 + 27/2g_3^3)c^2</div>
      <div class="math-block">+(12g_1^3g_2 + (-21g_3 + 9g_2^4)g_1^2 + (-45g_2^3g_3 + 3/2g_1^2 - 6g_2^5g_4)g_1</div>
      <div class="math-block">+27g_2^2g_3^2 - 54g_3^2g_4 + 57/2g_2^4g_3g_4 - 15/2g_2^6g_3)c</div>
      <div class="math-block">+3/2g_2^4 - 6g_2^2g_4 + 12g_1g_2 + 4g_3</div>
      <p class="text-gray-300">A.5.</p>
      <div class="math-block">\mathcal&#123;H&#125;_4 = \&#123;S_&#123;4,j&#125;: j = 1, 2, \dots, 10\&#125;</div>
      <p class="text-gray-300">.</p>
      <div class="math-block">S_&#123;4,1&#125; = 4g_0g_4 + 2g_3^2c</div>
      <div class="math-block">S_&#123;4,2&#125; = 4g_1g_5c + 2g_2^2</div>
      <div class="math-block">S_&#123;4,3&#125; = 3g_0g_4 + 3g_1g_5c + g_4</div>
      <div class="math-block">S_&#123;4,4&#125; = 12g_0g_4 - 6g_2^2 + 4g_4</div>
      <div class="math-block">S_&#123;4,5&#125; = 3g_2^2 + 3g_3^2c - 2g_4</div>
      <div class="math-block">S_&#123;4,6&#125; = (12g_1g_5 - 6g_3^2)c + 4g_4</div>
      <div class="math-block">S_&#123;4,7&#125; = -9/2g_4^2g_5^2c^2 + (6g_1^2g_4 + (3g_5 + 18g_2g_4^2)g_1</div>
      <div class="math-block">\begin&#123;array&#125;&#123;rcl&#125; &+3g_2g_4g_5-27/2g_4^4)c+4g_4\\ S_&#123;4,8&#125;&=&3/2g_5^4c^3+(-18g_1g_3g_4g_5+12g_1^3g_5-6g_3g_5^2+9/2g_4^2g_5^2)c^2\\ &+(-9g_3g_4^2+6g_1^2g_4+12g_1g_5)c+4g_4\\ S_&#123;4,9&#125;&=&(-9/2g_1g_4g_5^3+3/2g_5^4)c^3\\ &+(-36g_1^4g_4-27/2g_1g_4^3g_5+12g_1^3g_5\\ &+54g_1^2g_3g_4^2-6g_3g_5^2+27/4g_4^2g_5^2)c^2\\ &+(27/4g_4^4+12g_1g_5-21g_1^2g_4-27/2g_3g_4^2)c+4g_4\\ S_&#123;4,10&#125;&=&(-9/2g_1^2g_4g_5^6-27/4g_3g_4^2g_5^6+3/2g_1g_5^7)c^6\\ &+(-36g_1^5g_4g_5^3+12g_1^4g_5^4+351/4g_1^2g_4^3g_5^4\\ &+(-6g_3g_5^5+225/4g_4^2g_5^5)g_1-567/8g_3g_4^4g_5^4-15/2g_4g_5^6)c^5\\ &+(-162g_1^5g_4^3g_5+72g_1^4g_4^2g_2^2-81g_1^3g_4g_5^3\\ &+(9g_5^4+1053/2g_4^5g_5^2)g_1^2+999/4g_1g_4^4g_5^3\\ &+(81g_1^4g_4^4-567/2g_1^3g_4^3g_5+(729/4g_4^7+27g_4^2g_5^2)g_1^2\\ &+(-45g_4g_5^3+243/2g_4^6g_5)g_1+(-2187/8g_4^8+603/4g_4^3g_5^2)g_3\\ &+3/2g_5^4-513/4g_4^5g_5^2)c^3+(-36g_1^4g_4+12g_1^3g_5\\ &-81/4g_1^2g_4^4-27g_1g_4^3g_5+(-6g_5^2+891/4g_4^5)g_3\\ &+27g_4^2g_5^2-243/8g_4^7)c^2+(12g_1g_5+27/2g_4^4-21g_1^2g_4-54g_3g_4^2)c+4g_4 \end&#123;array&#125;</div>
      <p class="text-gray-300">A.6.</p>
      <div class="math-block">\mathcal&#123;H&#125;_&#123;5&#125; = \&#123;S_&#123;5,j&#125;: j=1,2,\ldots,7\&#125;.</div>
      <div class="math-block">S_&#123;5,1&#125; = 6g_&#123;2&#125;g_&#123;3&#125; + 2g_&#123;5&#125;</div>
      <div class="math-block">S_&#123;5,2&#125; = 3g_&#123;0&#125;g_&#123;5&#125; + 3g_&#123;1&#125;g_&#123;4&#125; - g_&#123;5&#125;</div>
      <div class="math-block">S_&#123;5,3&#125; = -12g_&#123;1&#125;g_&#123;2&#125;^&#123;2&#125; + 9g_&#123;2&#125;g_&#123;4&#125;^&#123;2&#125; + 3g_&#123;2&#125;g_&#123;5&#125;^&#123;2&#125;c + 2g_&#123;5&#125;</div>
      <div class="math-block">S_&#123;5,4&#125; = (3g_&#123;2&#125;g_&#123;5&#125;^&#123;2&#125; - 9g_&#123;3&#125;g_&#123;4&#125;g_&#123;5&#125; + 6g_&#123;1&#125;^&#123;2&#125;g_&#123;5&#125;)c + 2g_&#123;5&#125; + 3g_&#123;1&#125;g_&#123;4&#125;</div>
      <div class="math-block">S_&#123;5,5&#125; = -9/2g_&#123;4&#125;g_&#123;5&#125;^&#123;3&#125;c^&#123;2&#125; + (6g_&#123;1&#125;^&#123;2&#125;g_&#123;5&#125; + 18g_&#123;1&#125;g_&#123;2&#125;g_&#123;4&#125;g_&#123;5&#125; + 3g_&#123;2&#125;g_&#123;5&#125;^&#123;2&#125; - 27/2g_&#123;4&#125;^&#123;3&#125;g_&#123;5&#125;)c + 2g_&#123;5&#125; + 3g_&#123;1&#125;g_&#123;4&#125;</div>
      <div class="math-block">S_&#123;5,6&#125; = (27/2g_&#123;1&#125;g_&#123;4&#125;^&#123;2&#125;g_&#123;5&#125;^&#123;2&#125; - 9/4g_&#123;4&#125;g_&#123;5&#125;^&#123;3&#125;)c^&#123;2&#125; + (-18g_&#123;1&#125;^&#123;3&#125;g_&#123;4&#125; + (-54g_&#123;2&#125;g_&#123;4&#125;^&#123;2&#125; + 6g_&#123;5&#125;)g_&#123;1&#125;^&#123;2&#125; + 81/2g_&#123;1&#125;g_&#123;4&#125;^&#123;4&#125; + 3g_&#123;2&#125;g_&#123;5&#125;^&#123;2&#125; - 27/4g_&#123;4&#125;^&#123;3&#125;g_&#123;5&#125;)c - 21/2g_&#123;1&#125;g_&#123;4&#125; + 9/2g_&#123;2&#125;g_&#123;4&#125;^&#123;2&#125; + 2g_&#123;5&#125;</div>
      <div class="math-block">S_&#123;5,7&#125; = (27/4g_&#123;2&#125;g_&#123;4&#125;^&#123;2&#125;g_&#123;5&#125;^&#123;6&#125; + 27g_&#123;1&#125;^&#123;2&#125;g_&#123;4&#125;^&#123;2&#125;g_&#123;5&#125;^&#123;5&#125; - 3/4g_&#123;5&#125;^&#123;7&#125; - 9/4g_&#123;1&#125;g_&#123;4&#125;g_&#123;5&#125;^&#123;6&#125;)c^&#123;5&#125; + (108g_&#123;1&#125;^&#123;5&#125;g_&#123;4&#125;^&#123;2&#125;g_&#123;5&#125;^&#123;2&#125; - 18g_&#123;1&#125;^&#123;4&#125;g_&#123;4&#125;g_&#123;5&#125;^&#123;3&#125; + 243/2g_&#123;1&#125;^&#123;2&#125;g_&#123;4&#125;^&#123;4&#125;g_&#123;5&#125;^&#123;3&#125; + (-1593/8g_&#123;4&#125;^&#123;3&#125;g_&#123;5&#125;^&#123;4&#125; + 6g_&#123;2&#125;g_&#123;5&#125;^&#123;5&#125;)g_&#123;1&#125; + 27/8g_&#123;4&#125;^&#123;2&#125;g_&#123;5&#125;^&#123;5&#125; + 567/8g_&#123;2&#125;g_&#123;4&#125;^&#123;4&#125;g_&#123;5&#125;^&#123;4&#125;)c^&#123;4&#125; + (486g_&#123;1&#125;^&#123;5&#125;g_&#123;4&#125;^&#123;4&#125; + 81g_&#123;1&#125;^&#123;4&#125;g_&#123;3&#125;^&#123;4&#125;g_&#123;5&#125; + 198g_&#123;1&#125;^&#123;3&#125;g_&#123;4&#125;^&#123;2&#125;g_&#123;5&#125;^&#123;2&#125; + (-2187/2g_&#123;4&#125;^&#123;6&#125;g_&#123;5&#125; - 189/2g_&#123;4&#125;g_&#123;5&#125;^&#123;3&#125;)g_&#123;1&#125;^&#123;2&#125; + (9/2g_&#123;5&#125;^&#123;4&#125; - 4293/4g_&#123;5&#125;^&#123;4&#125;g_&#123;5&#125;^&#123;2&#125;)g_&#123;1&#125; + (-57/2g_&#123;4&#125;g_&#123;5&#125;^&#123;4&#125; + 243g_&#123;4&#125;^&#123;6&#125;g_&#123;5&#125;^&#123;2&#125;)g_&#123;2&#125; + 54g_&#123;4&#125;^&#123;4&#125;g_&#123;5&#125;^&#123;3&#125;)c^&#123;3&#125; + (-216g_&#123;1&#125;^&#123;5&#125;g_&#123;4&#125; + 1539/2g_&#123;1&#125;^&#123;3&#125;g_&#123;4&#125;^&#123;4&#125; + 1377/4g_&#123;1&#125;^&#123;2&#125;g_&#123;3&#125;^&#123;3&#125;g_&#123;5&#125; + (2241/4g_&#123;4&#125;^&#123;2&#125;g_&#123;5&#125;^&#123;2&#125; - 8019/8g_&#123;1&#125;^&#123;7&#125;)g_&#123;1&#125; + (-603/4g_&#123;4&#125;^&#123;3&#125;g_&#123;5&#125;^&#123;2&#125; + 2187/8g_&#123;4&#125;^&#123;8&#125;)g_&#123;2&#125; + 18g_&#123;4&#125;g_&#123;5&#125;^&#123;3&#125; + 1215/8g_&#123;4&#125;^&#123;6&#125;g_&#123;5&#125;)c^&#123;2&#125; + (-342g_&#123;1&#125;^&#123;3&#125;g_&#123;4&#125; + 6g_&#123;1&#125;^&#123;2&#125;g_&#123;5&#125; + 2997/4g_&#123;1&#125;g_&#123;4&#125;^&#123;4&#125; + (3g_&#123;5&#125;^&#123;2&#125; - 891/4g_&#123;5&#125;^&#123;4&#125;)g_&#123;2&#125; - 54g_&#123;3&#125;^&#123;3&#125;g_&#123;5&#125;)c + 2g_&#123;5&#125; - 132g_&#123;1&#125;g_&#123;4&#125; + 45g_&#123;2&#125;g_&#123;4&#125;^&#123;2&#125;</div>
      <p class="text-gray-300">Dept. of Combinatorics and Optimization, University of Waterloo, Waterloo, Ontario, Canada N2L 3G1</p>
      <p class="text-gray-300">E-mail address: kkarabin@uwaterloo.ca</p>
    </section>
    <PaperHistory slug="squaring-in-cyclotomic-subgroups-2010" />
  </article>
</BaseLayout>
