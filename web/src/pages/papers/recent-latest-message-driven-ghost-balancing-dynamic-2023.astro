---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2023/279';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Recent Latest Message Driven GHOST: Balancing Dynamic Availability With Asynchrony Resilience';
const AUTHORS_HTML = 'Francesco D&#x27;Amato, Luca Zanolini';

const CONTENT = `    <p class="text-gray-300">Francesco D’Amato Ethereum Foundation francesco.damato@ethereum.org Luca Zanolini Ethereum Foundation luca.zanolini@ethereum.org</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Dynamic participation has recently become a crucial requirement for devising permissionless consensus protocols. This notion, originally formalized by Pass and Shi (ASIACRYPT 2017) through their “sleepy model”, captures the essence of a system’s ability to handle participants joining or leaving during a protocol execution. A dynamically available consensus protocol preserves safety and liveness while allowing dynamic participation. Blockchain protocols, such as Bitcoin’s consensus protocol, have implicitly adopted this concept.</p>

    <p class="text-gray-300">In the context of Ethereum’s consensus protocol, Gasper, Neu, Tas, and Tse (S&P 2021) presented an attack against LMD-GHOST – the component of Gasper designed to ensure dynamic availability. Consequently, LMD-GHOST results unable to fulfill its intended function of providing dynamic availability for the protocol. Despite attempts to mitigate this issue, the modified protocol still does not achieve dynamic availability, highlighting the need for more secure dynamically available protocols.</p>

    <p class="text-gray-300">In this work, we present RLMD-GHOST, a synchronous consensus protocol that not only ensures dynamic availability but also maintains safety during bounded periods of asynchrony. This protocol is particularly appealing for practical systems where strict synchrony assumptions may not always hold, contrary to general assumptions in standard synchronous protocols.</p>

    <p class="text-gray-300">Additionally, we present the “generalized sleepy model”, within which our results are proven. Building upon the original sleepy model proposed by Pass and Shi, our model extends it with more generalized and stronger constraints on the corruption and sleepiness power of the adversary. This approach allows us to explore a wide range of dynamic participation regimes, spanning from complete dynamic participation to no dynamic participation, i.e., with every participant online. Consequently, this model provides a foundation for analyzing dynamically available protocols.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 Balancing dynamic availability and asynchrony resilience</h3>

    <p class="text-gray-300">Tolerating <em>dynamic participation</em> has emerged as a desirable feature of consensus protocols operating in the permissionless setting of blockchains. A <em>dynamically available</em> protocol preserves safety and liveness during events involving portions of the participants going offline. This concept, which was implicitly taken into account by the Bitcoin consensus protocol <em>[14]</em>, was later formalized by Pass and Shi <em>[18]</em> through the <em>sleepy model</em> of consensus. In particular, Pass and Shi model a system where participants can be either online or offline, with their online status adversarially controlled throughout the execution, subject to the honest and online participants always outnumbering the adversarial ones.</p>

    <p class="text-gray-300">A notable limitation of dynamically available consensus protocols is their inability to tolerate network partitions <em>[8, 18, 11]</em>. No consensus protocol can simultaneously satisfy liveness (under dynamic participation) and safety (under temporary network partitions, or temporary asynchrony). In other words, it is impossible for a consensus protocol (for state-machine replication) to yield a single output chain, while simultaneously offering dynamic availability and ensuring transaction finality, even during asynchronous periods or network partitions. As a result, dynamically available protocols are generally assumed to be synchronous <em>[18, 13, 12]</em>.</p>

    <p class="text-gray-300">Neu, Tas, and Tse <em>[16]</em>, while formalizing the security requirements of Ethereum’s consensus protocol, Gasper <em>[5]</em>, demonstrate that the original version of LMD-GHOST, Gasper’s dynamically available component,</p>

    <p class="text-gray-300">is not secure even in a context of full participation, <em>i.e.</em>, with all the participants in the protocol, or <em>validators</em>, being online. This finding is supported by the presentation of a <em>balancing</em> attack <em>[16, 20]</em>.</p>

    <p class="text-gray-300">D’Amato, Neu, Tas, and Tse <em>[7]</em> have proposed Goldfish as a solution to address the challenges posed by LMD-GHOST. Goldfish is synchronous consensus protocol that offers safety and liveness even when there is variable participation, making it dynamically available. However, the protocol’s lack of <em>resilience to temporary asynchrony</em> makes it impractical to replace LMD-GHOST in Ethereum: even a very short period of asynchrony can result in a catastrophic failure, jeopardizing the safety of any previously confirmed block.</p>

    <p class="text-gray-300">Our work acknowledges the limitations of both LMD-GHOST and Goldfish, and proposes a new family of synchronous consensus protocols, namely Recent Latest Message Driven GHOST (RLMD-GHOST), generalizing (variants of) LMD-GHOST and Goldfish. To analyze its properties, we introduce the <em>generalized sleepy model</em>, which can capture a broad spectrum of dynamic participation regimes falling between complete dynamic participation and no dynamic participation, and within which we formally define the concept of <em>asynchrony resilience</em>. Through the RLMD-GHOST family, we explore the trade-off space between resilience to temporary asynchrony and dynamic availability.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.2 Technical outline</h3>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">1.2.1 LMD-GHOST and its security</h4>

    <p class="text-gray-300">The consensus protocol of Ethereum, Gasper <em>[5]</em>, is defined by two <em>components</em> <em>[16]</em>: LMD-GHOST, a synchronous consensus protocol, and Casper <em>[4]</em>, a partially synchronous protocol (or <em>gadget</em>) that finalizes blocks on the chain output by LMD-GHOST and that keeps such finalized blocks safe during period of network asynchrony.</p>

    <p class="text-gray-300">LMD-GHOST is named after its key component, the Latest Message Driven Greediest Heaviest Observed Sub-Tree rule (LMD-GHOST) <em>fork-choice function</em> (Section 4.2), introduced by Zamfir <em>[23]</em>. This function takes as input the sequence of blocks and the votes from each validator <span class="math">v_{i}</span>, <em>i.e.</em>, a <em>local view</em> of <span class="math">v_{i}</span>, and outputs a <em>canonical chain</em>. To do so, it starts from the genesis block <span class="math">B_{\\text{genesis}}</span> and walks down the sequence of blocks: at each block <span class="math">B</span>, it chooses as the next block the child of <span class="math">B</span> with the <em>heaviest subtree</em>, <em>i.e.</em>, with most (stake weighted) <em>latest</em> votes on its descendants.</p>

    <p class="text-gray-300">LMD-GHOST can be thought of as a <em>propose-vote</em> protocol, proceeding in <em>slots</em>, each with an associated validator, a <em>proposer</em>, tasked with creating and proposing a new block. Votes are then cast by a randomly selected subset of the validator set, a <em>committee</em>. In other words, the protocol implements <em>subsampling</em> of validators. Both the proposer and voters utilize the output of the LMD-GHOST fork-choice function to decide what block to extend, and what block to vote for, respectively.</p>

    <h5 id="sec-7" class="text-base font-semibold mt-4">Balancing attack</h5>

    <p class="text-gray-300">Neu, Tas, and Tse <em>[16]</em> show that this protocol is vulnerable to a <em>balancing attack</em> <em>[16, 20]</em>, exploiting the fact that validators can have different local views, leading to conflicting votes. An adversarial proposer of slot <span class="math">t</span> can equivocate and produce two conflicting blocks, which it reveals to two equal-sized subsets of the honest validators in the committee of slot <span class="math">t</span>, so that their votes are split between the two blocks. In slot <span class="math">t+1</span>, it then releases withheld votes from the adversarial validators in the committees of slot <span class="math">t</span> to split validators of slot <span class="math">t+1</span> into two equal-sized subsets, one which sees one chain as leading and votes for it, and one which sees the other chain as leading and votes for it. This can be repeated indefinitely, maintaining the split between the two chains and preventing either liveness or safety of LMD-GHOST, as any decision made while the attack is ongoing would not be safe. The proposer boost technique <em>[3]</em> was later introduced as a mitigation to help <em>coordinate the voters in slots with an honest proposer</em>. It requires honest voters to temporarily grant extra weight to the current proposal.</p>

    <h5 id="sec-8" class="text-base font-semibold mt-4">Ex-ante reorgs</h5>

    <p class="text-gray-300">Still, the resulting protocol remains prone to <em>ex-ante reorgs</em> <em>[20]</em>, and has not been proven secure, even in a regime of full participation. Consider an adversary controlling a fraction <span class="math">\\beta</span> of the validators, among which the proposer for slot <span class="math">t+1</span>, which <em>privately</em> creates a block <span class="math">B^{\\prime}</span> on top of block <span class="math">B</span>, <em>i.e.</em>, the block for slot <span class="math">t</span>. Moreover, the adversary controls roughly a fraction <span class="math">\\beta</span> of the validators sampled to vote at slot <span class="math">t+1</span>, and they privately vote for <span class="math">B^{\\prime}</span>. Honest validators in the committee of slot <span class="math">t+1</span> do not see any block and thus vote for <span class="math">B</span>. In the next slot, <em>i.e.</em>, slot <span class="math">t+2</span>, an honest proposer publishes block <span class="math">B^{\\prime\\prime}</span> building on <span class="math">B</span>, which is the current tip of the canonical chain in their local view, and all honest validators in the committee of slot <span class="math">t+2</span></p>

    <p class="text-gray-300">vote for it, so <span class="math">B^{\\prime\\prime}</span> accrues roughly <span class="math">1-\\beta</span> of one committee’s weight, say <span class="math">(1-\\beta)W_{c}</span>. Afterwards, the adversary publishes block <span class="math">B^{\\prime}</span> and its votes from slot <span class="math">t+1</span> <em>and</em> <span class="math">t+2</span> for it. At this point, <span class="math">B</span> has weight roughly <span class="math">2\\beta W_{c}</span>. If <span class="math">2\\beta&gt;1-\\beta</span>, <em>i.e.</em>, if <span class="math">\\beta&gt;\\frac{1}{3}</span>, <span class="math">B^{\\prime}</span> becomes canonical, reorging <span class="math">B^{\\prime\\prime}</span>. More generally, an adversary controlling <span class="math">k</span> slots in a row (which happens with probability <span class="math">\\beta^{k}</span>) can withhold votes from those slots, and release them after one honest slot, resulting in <span class="math">(k+1)\\beta W_{c}</span> weight for a withheld adversarial block. If <span class="math">\\beta&gt;\\frac{1}{k+2}</span>, this result in a reorg of the honestly proposed block, so even relatively weak adversaries can perform ex-ante reorgs, albeit with low probability.</p>

    <p class="text-gray-300">Note that subsampling is crucial in the success of the attack, because the adversary is able to accumulate the votes of the validators it controls across the <span class="math">k</span> committees. Without subsampling, the adversarial votes from the last slot would simply replace the ones from the previous slots, due to the latest message rule. In other words, <em>without subsampling there is no way for the adversary to overcome the weight of all honest validators voting together in one slot</em>, as they are a majority over the entire validator set. We will later make use of this fact in our protocol.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">1.2.2 Goldfish</h4>

    <p class="text-gray-300">To cope with the problems of LMD-GHOST, D’Amato, Neu, Tas, and Tse <em>[7]</em> devise Goldfish (Section 4.3), a synchronous consensus protocol that enjoys safety and liveness <em>under fully variable participation</em>, and thus that is dynamically available. Moreover, Goldfish is <em>reorg resilient</em>: blocks proposed by honest validators are guaranteed inclusion in the chain. Goldfish is based on two techniques: <em>view-merge</em> <em>[6, 10]</em> and <em>vote expiry</em>. It inherits the propose-vote structure of LMD-GHOST, and it adds a third round dedicated to view-merge. This new structure can be generalized by a family of protocols which we call <em>propose-vote-merge</em> protocols (Section 3).</p>

    <p class="text-gray-300">View-merge is an improvement over the proposer boost technique, and serves the same purpose, <em>i.e.</em>, coordinating honest voters in slots with an honest proposer. In particular, it lets an honest proposer synchronize the local views of honest voters with its own, and <em>ensures</em> that they cast votes for the proposed block. With vote expiry, only votes from the latest slot influence the fork-choice. The adversary has then no way to accumulate weight <em>across committees</em>, and thus <em>no way to overpower the coordinated voting of the honest voters in a committee</em>. Therefore, vote expiry solves two problems at once: the ex-ante reorgs caused by subsampling, and the lack of dynamic availability due the adversary exploiting votes of offline validators, as these are now simply expired.</p>

    <p class="text-gray-300">As we now informally explain, view-merge and vote expiry together make for a reorg resilience protocol, under the assumption that in every committee a majority of all <em>online</em> validators are honest. View-merge ensures that an honest proposal <span class="math">B</span> from slot <span class="math">t</span> receives <em>all</em> votes from <em>honest and online</em> validators in the committee of slot <span class="math">t</span>, which by assumption outnumber the adversarial votes in it. By vote expiry, the votes from the committee of slot <span class="math">t</span> are the only ones which count in slot <span class="math">t+1</span>, <em>i.e.</em>, voters in slot <span class="math">t+1</span> use them as input to their fork-choice function when determining what to vote for. Since a majority of the votes which are considered are for <span class="math">B</span>, all votes from honest and online validators in slot <span class="math">t+1</span> are for <span class="math">B</span> as well. By induction, this is true for all future slots achieving reorg resilience of honest proposals. As we explore in Section 3, reorg resilience then immediately implies that the <span class="math">\\kappa</span>-deep confirmation rule is both safe and live, implying dynamic availability for Goldfish.</p>

    <p class="text-gray-300">Nonetheless, Goldfish is not considered practically viable to replace LMD-GHOST in Ethereum, due to its brittleness to temporary asynchrony: even a single slot of asynchrony can lead to a catastrophic failure, jeopardizing the safety of <em>any</em> previously confirmed block. In other words, Goldfish is not <em>asynchrony resilient</em>. This is simply due to the strict vote expiry, which can cause the weight supporting a block to drop to zero at any time, if no <em>new</em> votes supporting it are received within one slot.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">1.2.3 RLMD-GHOST</p>

    <p class="text-gray-300">Strict vote expiry does not seem compatible with any reasonable notion of resilience to asynchrony. On the other end, not expiring votes at all is not compatible with dynamic availability, as we have observed in LMD-GHOST, where votes of <em>honest but offline</em> validators can be exploited by the adversary to conclude long reorgs. A natural approach, and the one we take in this work, is then to <em>relax</em> vote expiry. In particular, we introduce Recent Latest Message Driven GHOST (RLMD-GHOST) (Section 5), <em>family</em> of propose-vote-merge consensus protocols parameterized by the <em>vote expiry period</em> <span class="math">\\eta</span>, <em>i.e.</em>, only votes from the most recent <span class="math">\\eta</span> slots are utilized in the protocol with parameter <span class="math">\\eta</span>. RLMD-GHOST extends and generalizes both LMD-GHOST and Goldfish. As LMD-GHOST, RLMD-GHOST implements the latest message rule (LMD). As Goldfish, it implements view-merge and vote expiry. Relaxing vote expiry forces us to do away with subsampling, since we want to avoid reintroducing the possibility of ex-ante reorgs through accumulating votes from multiple committees, as this would break the reorg resilience property upon which the security of both Goldfish and RLMD-GHOST rests (and which is itself highly desirable). Therefore, every validator votes in every slot of RLMD-GHOST. For <span class="math">\\eta=1</span>, RLMD-GHOST reduces to a variant of Goldfish without subsampling of validators. For <span class="math">\\eta=\\infty</span>, RLMD-GHOST reduces to LMD-GHOST. To be precise, we do not refer here to LMD-GHOST as currently implemented in Ethereum but to a variant, described in this work, without subsampling <em>and implementing the view-merge technique instead of proposer boost</em> (<em>i.e.</em>, also a propose-vote-merge protocol).</p>

    <p class="text-gray-300">Intuitively, considering votes from a longer period (<span class="math">\\eta&gt;1</span>) results in a protocol that is more tolerant of asynchrony, since a correspondingly longer period of asynchrony is needed for all votes to expire. On the other end, relaxing vote expiry should weaken dynamic availability because, as in LMD-GHOST, the fork-choice can now be affected by the (still unexpired) votes of offline validators. In the reorg resilience argument for Goldfish, after an honest slot <span class="math">t</span> with proposal <span class="math">B</span>, honest voters at slot <span class="math">t+1</span> still vote for <span class="math">B</span>, because the honest votes from slot <span class="math">t</span> outnumber adversarial votes, <em>and there are no further votes to consider</em>. With a longer expiry period <span class="math">\\eta&gt;1</span>, this is not the case anymore, because at slot <span class="math">t+1</span> all votes from slots <span class="math">[t+1-\\eta,t]</span> have to be considered.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">1.2.4 Generalized sleepy model</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In order to describe the security of RLMD-GHOST, we introduce an extension of the sleepy model, which we refer to as the <em>generalized sleepy model</em> (Section 2), that allows us to capture a weaker notion of dynamic availability and to precisely define a notion of <em>asynchrony resilience</em>. In defining this model, we again take inspiration from the reorg resilience argument for Goldfish. In particular, computing the fork-choice at slot <span class="math">t</span> now requires considering all votes from slots <span class="math">[t-\\eta,t-1]</span>. If there has been an honest proposal in slot <span class="math">t-1</span>, the only votes which are guaranteed to vote in support of it are those from honest validators which were online in slot <span class="math">t-1</span>, which we define as <span class="math">H_{t-1}</span>. All other votes are either adversarial or from offline validators, and potentially dangerous in both cases. Letting <span class="math">H_{s,t}</span> be the honest validators online in slots <span class="math">[s,t]</span>, and <span class="math">A_{t}</span> be the validators corrupted up to slot <span class="math">t</span>, we require that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{t-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{t}\\cup(H_{t-\\eta,t-2}\\setminus H_{t-1})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Observe that when </span>\\eta=1<span class="math">, we recover a standard majority assumption, <em>i.e.</em>, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{t-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, much like the one found in the sleepy model. The more general condition is precisely the key assumption of our <em>generalized sleepy model</em>, which allows us to describe a whole spectrum of dynamic participation regimes, by varying the parameter. If the assumption holds for a certain </span>\\eta$, then the corresponding RLMD-GHOST protocol is reorg resilient, and consequently secure. Finally, we extend the generalized sleepy model further, to allow for bounded periods of asynchrony, and define an associated notion of asynchrony resilience, which is satisfied by RLMD-GHOST. Limitations of RLMD-GHOST are analyzed in Appendix A.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Related works to this paper are discussed in Section 6, while conclusion and future work are presented in Section 7. Finally, in Appendix B we extend RLMD-GHOST achieving a faster confirmation time for proposals, <em>optimistically</em>. This is aligned with the way in which Goldfish also achieves fast confirmation, with the difference that we do not require an increase in the length of the slots, due to using a slightly different proposer selection mechanism.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">2 Model and Preliminary Notions</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">2.0.1.2.2.2.2.3.2.3.2.4</h4>

    <p class="text-gray-300">We consider a system of <span class="math">n</span> <em>validators</em> <span class="math">v_{1},\\ldots,v_{n}</span> that communicate with each other through exchanging messages. Every validator is identified by a unique cryptographic identity and the public keys are common knowledge. Validators are assigned a protocol to follow, consisting of a collection of programs with instructions for all validators.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">2.0.2.2.3.2.4.1</h4>

    <p class="text-gray-300">A validator that follows its protocol during an execution is called <em>honest</em>. On the other hand, a faulty validator may crash or even deviate arbitrarily from its specification, e.g., when corrupted by an adversary. We consider Byzantine faults here and assume the existence of a probabilistic poly-time adversary <span class="math">\\mathcal{A}</span> that can corrupt validators over the course of the entire protocol execution. Corrupted validators stay corrupted for the remaining duration of the protocol execution, and are thereafter called <em>adversarial</em>. The adversary <span class="math">\\mathcal{A}</span> knows the the internal state of adversarial validators. The adversary is <em>adaptive</em>: it chooses the corruption schedule dynamically, during the protocol execution.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">2.0.3.2.3.3.1</h4>

    <p class="text-gray-300">We assume that a best-effort gossip primitive that will reach all validators is available. Moreover, we assume that messages from honest validator to honest validator are eventually received and cannot be forged. This includes messages sent by Byzantine validators, once they have been received by some honest validator <span class="math">v_{i}</span> and gossiped by <span class="math">v_{i}</span>.</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">2.0.4. Time</h4>

    <p class="text-gray-300">Time is divided into discrete <em>rounds</em>. We consider a synchronous model in which validators have synchronized clocks and message delays are bounded by <span class="math">\\Delta</span> rounds. Moreover, we define the notion of <em>slot</em> as a collection of <span class="math">k</span> rounds, for a constant <span class="math">k</span>. We are interested in the case <span class="math">k=3\\Delta</span>, so our presentation will assume this length for slots, unless otherwise specified.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">2.0.5.1.2.1</h4>

    <p class="text-gray-300">The adversary <span class="math">\\mathcal{A}</span> can decide for each round which honest validator is <em>awake</em> or <em>asleep</em> at that round. Asleep validators do not execute the protocol and messages for that round are queued and delivered in the first round in which the validator is awake again. Honest validators that become awake at round <span class="math">r</span>, before starting to participate in the protocol, must first execute (and terminate) a <em>joining protocol</em> (see Section 3.4), after which they become <em>active</em> <em>[7]</em>. All adversarial validators are always awake, and are not prescribed to follow any protocol. Therefore, we always use active, awake, and asleep to refer to honest validators. As for corruptions, the adversary is adaptive also for sleepiness, <em>i.e.</em>, the sleepiness schedule is also chosen dynamically by the adversary. Note that awake and active validators coincide in the sleepy model <em>[18]</em>.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">2.0.6. Proposer election mechanism</h4>

    <p class="text-gray-300">In each slot <span class="math">t</span>, a validator <span class="math">v_{p}</span> is selected to be a <em>proposer</em> for <span class="math">t</span>, <em>i.e.</em>, to extend the chain with a new block. Observe that, when we want to highlight the fact that <span class="math">v_{p}</span> is a proposer for a specific slot <span class="math">t</span>, we use the notation <span class="math">v_{p}^{t}</span>. Otherwise, when it is clear from the context, we just drop the slot <span class="math">t</span>, to make the notation simpler. As the specification of a proposal mechanism is not within the goals of this work, we assume the existence of a proposer selection mechanism satisfying the requirements of a Single Secret Leader Election (SSLE) scheme <em>[2]</em>, <em>i.e.</em>, <em>uniqueness, unpredictability, and fairness</em>: <span class="math">v_{p}</span> is unique, the identity of <span class="math">v_{p}</span> is only known to other validators once <span class="math">v_{p}</span> reveals itself, and any validator has probability <span class="math">\\frac{1}{n}</span> of being elected to be a proposer at any slot. Such a mechanism has been researched for usage in the Ethereum consensus protocol <em>[9]</em>.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">2.0.7. View</h4>

    <p class="text-gray-300">Due to adversarial validators and message delays, validators may have different sets of received messages. A <em>view</em> (at a given round <span class="math">r</span>), denoted by <span class="math">\\mathcal{V}</span>, is a subset of all the messages that a validator has received until <span class="math">r</span>. Observe that the notion of view is <em>local</em> for the validators. For this reason, when we want to focus the attention on a specific view of a validator <span class="math">v_{i}</span>, we denote with <span class="math">\\mathcal{V}_{i}</span> the view of <span class="math">v_{i}</span> (at a round <span class="math">r</span>). There are validity conditions on messages, and we say that a view is valid if all messages within it are <em>verifiably valid within the view itself</em>, <em>i.e.</em>, all messages they reference are also contained in the view and themselves valid. In particular, a block contains a reference to its parent block, and verifying its validity requires also being able to verify the parent’s validity (and recursively that of the entire chain). We do not discuss questions of availability and validity further, and just leave it implicit that we only ever consider valid messages and views.</p>

    <h5 id="sec-18" class="text-base font-semibold mt-4">Blocks and chains</h5>

    <p class="text-gray-300">For two chains <span class="math">\\mathsf{ch}_{1}</span> and <span class="math">\\mathsf{ch}_{2}</span>, we say <span class="math">\\mathsf{ch}_{1}\\preceq\\mathsf{ch}_{2}</span> if <span class="math">\\mathsf{ch}_{1}</span> is a prefix of <span class="math">\\mathsf{ch}_{2}</span>. If block <span class="math">B</span> is the tip of chain <span class="math">\\mathsf{ch}</span>, we say that it is the <em>head of <span class="math">\\mathsf{ch}</span></em>, and we identify the whole chain with <span class="math">B</span>. Accordingly, if <span class="math">\\mathsf{ch}^{\\prime}\\preceq\\mathsf{ch}</span> and <span class="math">A</span> is the head of <span class="math">\\mathsf{ch}^{\\prime}</span>, we also say <span class="math">\\mathsf{ch}^{\\prime}\\preceq B</span> and <span class="math">A\\preceq B</span>.</p>

    <h5 id="sec-19" class="text-base font-semibold mt-4">Fork-choice functions</h5>

    <p class="text-gray-300">A fork-choice function is a deterministic function <span class="math">\\mathsf{FC}</span>, which takes as input a view <span class="math">\\mathcal{V}</span> and a slot <span class="math">t</span> and outputs a block <span class="math">B</span>, satisfying the following <em>consistency property</em>: if <span class="math">B</span> is a block extending <span class="math">\\mathsf{FC}(\\mathcal{V},t)</span>, then <span class="math">\\mathsf{FC}(\\mathcal{V}\\cup\\{B\\},t)=B</span>. We refer to the output of <span class="math">\\mathsf{FC}</span> as the <em>head of the canonical chain in <span class="math">\\mathcal{V}</span></em>, and to the chain whose head is <span class="math">B</span> as the <em>canonical chain in <span class="math">\\mathcal{V}</span></em>. Each validator keeps track of its canonical chain, which it updates using <span class="math">\\mathsf{FC}</span>, based on its local view. We refer to the canonical chain of validator <span class="math">v_{i}</span> at round <span class="math">r</span> as <span class="math">\\mathsf{ch}_{i}^{r}</span>. In this work we are mainly interested in a particular class of fork-choice functions based on GHOST <em>[22]</em>, which we denote with <span class="math">\\mathcal{G}_{f}</span> and introduce in Section 4.1.2.</p>

    <h5 id="sec-20" class="text-base font-semibold mt-4">Terminology</h5>

    <p class="text-gray-300">We often use the terms <em>honest proposal</em>, <em>honest slot</em>, and <em>honest view</em> to refer to a block proposal made by an honest validator, a slot with an honest proposer, and a view of an honest validator, respectively. We also use the term <em>pivot slot</em> to refer to a slot in which the proposer is active at proposal time, <em>i.e.</em>, to a slot in which an honest proposal is made, and we say that such a slot has an <em>active proposer</em>. Finally, we say <em>honest voters of slot <span class="math">t</span></em> to refer to the active validators at the voting round <span class="math">3\\Delta t+\\Delta</span> of slot <span class="math">t</span>.</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">2.1 Generalized sleepy model</h3>

    <p class="text-gray-300">We now specify how the adversary is constrained in using its corruption and sleepiness power. We do so by formulating first a one-parameter family of adversarial restrictions, which generalizes the usual sleepy model <em>[18, 7]</em>, and then a two-parameters family, which generalizes it further by introducing, and accounting for, <em>bounded</em> periods of asynchrony.</p>

    <h4 id="sec-22" class="text-lg font-semibold mt-6">2.1.1 <span class="math">\\tau</span>-sleepy model</h4>

    <p class="text-gray-300">We denote with <span class="math">h_{r}</span> the number of honest validators that are active at round <span class="math">r</span>, with <span class="math">h_{0}&gt;0</span> a lower bound on <span class="math">h_{r}</span>, and with <span class="math">f_{r}</span> the number of adversarial validators at round <span class="math">r</span>. In the sleepy model <em>[18]</em>, the adversary is constrained in its choice of sleepiness and corruption schedules by the requirement that awake validators outnumber adversarial validators in every round by a constant factor <span class="math">c&gt;1</span>. As awake and active validators coincide in this model, the requirement is <span class="math">h_{r}&gt;cf_{r}</span>.</p>

    <p class="text-gray-300">D’Amato, Neu, Tas, and Tse <em>[7]</em> introduce the notion of an active validator and assume a modified condition, <em>i.e.</em>, <span class="math">h_{r-3\\Delta}&gt;f_{r}</span>. In this condition, that is tailored to their protocol, Goldfish, <span class="math">h_{r-3\\Delta}</span> is considered instead of <span class="math">h_{r}</span> because, if <span class="math">r</span> is a voting round in Goldfish, validators corrupted after round <span class="math">r</span> can still retroactively broadcast votes for that round, and these votes are relevant until <span class="math">3\\Delta</span> rounds later (but no longer, due to vote expiry). In practice, all that is required is that <span class="math">h_{3\\Delta(t-1)+\\Delta}&gt;f_{3\\Delta t+\\Delta}</span> for any <em>slot</em> <span class="math">t</span>, <em>i.e.</em>, the condition only needs to hold for <em>voting rounds</em>.</p>

    <p class="text-gray-300">In this work, we follow this distinction between awake and active validators, and we use <span class="math">H_{t}</span> and <span class="math">A_{t}</span>, for a slot <span class="math">t</span>, to refer to the set of active and adversarial validators at round <span class="math">3\\Delta t+\\Delta</span>, respectively . Moreover, we define <span class="math">H_{s,t}</span> as the set of validators that are active <em>at some point</em> in slots <span class="math">[s,t]</span>, <em>i.e.</em>, <span class="math">H_{s,t}=\\bigcup_{i=s}^{t}H_{i}</span> (if <span class="math">i&lt;0</span> then <span class="math">H_{i}\\coloneqq\\emptyset</span>). We then require that, for some fixed parameter <span class="math">1\\leq\\tau\\leq\\infty</span>, the following condition, which we refer to as <em><span class="math">\\tau</span>-sleepiness at slot <span class="math">t</span></em>, holds for any slot <span class="math">t</span>:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{t-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{t}\\cup(H_{t-\\tau,t-2}\\setminus H_{t-1})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ (1)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Equation 1 requires that the number of active validators at slot <span class="math">t-1</span>, <em>i.e.</em>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{t-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, must exceed the number of adversarial validators, <em>i.e.</em>, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, together with all the other validators that have been active at some point in </span>[t-\\tau,t-2]<span class="math">, and that are not active at slot </span>t-1<span class="math">, <em>i.e.</em>, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{t-\\tau,t-2}\\setminus H_{t-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Intuitively, this condition is tailored to a protocol implementing vote expiry (with period </span>\\eta=\\tau<span class="math">) because the votes which are considered at slot </span>t<span class="math"> are those from slots </span>[t-\\tau,t-1]$. Out of these, the only honest votes which we can rely on are those</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">from <span class="math">H_{t-1}</span>, whereas unexpired votes from honest validators which were not active in slot <span class="math">t-1</span> might help the adversary.</p>

    <p class="text-gray-300">We refer to the sleepy model in which the adversary is constrained by <span class="math">\\tau</span>-sleepiness as the <em><span class="math">\\tau</span>-sleepy model</em>. Note that, for <span class="math">\\tau=1</span>, this reduces to the sleepy model from Goldfish, as this condition reduces to the majority condition <span class="math">h_{r-3\\Delta}&gt;f_{r}</span> of Goldfish for voting rounds <span class="math">r=3\\Delta t+\\Delta</span>, because <span class="math">H_{t-1,t-2}=\\emptyset</span>. We therefore also refer to the 1-sleepy model simply as sleepy model.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Definition 1 (<span class="math">\\tau</span>-compliant execution).</h6>

    <p class="text-gray-300">An execution is <em><span class="math">\\tau</span>-compliant</em> if it satisfies <span class="math">\\tau</span>-sleepiness. We refer to the set of such protocol executions as <span class="math">E_{\\tau}</span>. In other words, the <span class="math">\\tau</span>-sleepy model restricts the allowable set of executions to <span class="math">\\tau</span>-compliant executions, <em>i.e.</em>, to <span class="math">E_{\\tau}</span>, constraining the adversarial sleepiness and corruption power accordingly. We refer to 1-compliant executions simply as compliant executions.</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">Hierarchy of <span class="math">\\tau</span>-sleepy models</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As <span class="math">\\tau</span> increases, so do the restrictions that <span class="math">\\tau</span>-sleepy models put on the adversary, <em>i.e.</em>, the <span class="math">\\tau_{1}</span>-sleepy model makes stronger assumptions than the <span class="math">\\tau_{2}</span>-sleepy model for <span class="math">\\tau_{1}&gt;\\tau_{2}</span>. Another way to say this is that <span class="math">\\tau_{1}&gt;\\tau_{2}</span> implies <span class="math">E_{\\tau_{1}}\\subset E_{\\tau_{2}}</span>. This is immediate from <span class="math">\\tau</span>-sleepiness, <em>i.e.</em>, Equation 1. The only term that depends on <span class="math">\\tau</span> is $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{t-\\tau,t-2}\\setminus H_{t-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, which is monotonically increasing in </span>\\tau<span class="math">. Therefore, </span>\\tau_{1}<span class="math">-sleepiness implies </span>\\tau_{2}<span class="math">-sleepiness, so a </span>\\tau_{1}<span class="math">-compliant execution is also a </span>\\tau_{2}<span class="math">-compliant execution. In other words, increasing </span>\\tau<span class="math"> makes it harder for </span>\\tau$-sleepiness to be satisfied, <em>i.e.</em>, it constrains the adversarial corruption and sleepiness power more.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As we mentioned, <span class="math">\\tau=1</span> corresponds to sleepy model from Goldfish, which constrains the adversary in the minimum way that can allow for a secure protocol under dynamic participation. For <span class="math">\\tau=\\infty</span>, <span class="math">\\tau</span>-sleepiness requires that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{t-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{t}\\cup(H_{0,t-2}\\setminus H_{t-1})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, <em>i.e.</em>, all honest validators which are not active at round </span>3\\Delta(t-1)+\\Delta<span class="math">, and which have voted at least once in the past, are counted together with the adversarial ones. If all validators have voted at least once in slots </span>[0,s-1]<span class="math">, this requires that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>\\frac{n}{2}<span class="math"> for all slots </span>t>s$, <em>i.e.</em>, dynamic participation is allowed only in an extremely narrow sense.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">2.1.2 <span class="math">(\\tau,\\pi)</span>-sleepy model</h4>

    <p class="text-gray-300">We generalize the <span class="math">\\tau</span>-sleepy model further, by introducing the notion of a <em>temporary period of asynchrony of less than <span class="math">\\pi</span> slots</em>, abbreviated by <span class="math">\\pi</span>-tpa. In particular, we define a temporary period of asynchrony as it follows.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Definition 2 (Temporary period of asynchrony).</h6>

    <p class="text-gray-300">We say that an interval <span class="math">(t_{1},t_{2})</span> of consecutive slots is a <em>temporary period of asynchrony</em>, abbreviated by tpa, if synchrony does not hold in <span class="math">(t_{1},t_{2})</span>. If <span class="math">t_{2}-t_{1}\\leq\\pi</span>, we also refer to it as <span class="math">\\pi</span>-tpa.</p>

    <p class="text-gray-300">We consider a system where synchrony holds <em>except for one such <span class="math">\\pi</span>-tpa</em>, for some <span class="math">\\pi\\in\\mathbb{N}\\cup\\{\\infty\\}</span>. We refer to this network model as <em>synchronous network with a temporary period of asynchrony tpa</em>. Since a 1-tpa is empty, this is a generalization of the usual synchronous network model. We also specify a suitable notion of compliance for executions in this network model, which defines the <em><span class="math">(\\tau,\\pi)</span>-sleepy model</em>, generalizing the <span class="math">\\tau</span>-sleepy model.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Definition 3 (<span class="math">(\\tau,\\pi)</span>-compliant execution).</h6>

    <p class="text-gray-300">For <span class="math">\\tau&gt;\\pi</span>, or <span class="math">\\tau=\\pi=\\infty</span>, an execution in the synchronous network model with a tpa is <span class="math">(\\tau,\\pi)</span>-compliant if the tpa is in particular a <span class="math">\\pi</span>-tpa <span class="math">(t_{1},t_{2})</span> and the following conditions hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\tau</span>-sleepiness at slot <span class="math">t</span> holds for <span class="math">t\\not\\in(t_{1},t_{2}]</span></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{t_{1}}\\setminus A_{t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{t}\\cup(H_{t-\\tau,t-1}\\setminus H_{t_{1}})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> for </span>t\\in(t_{1},t_{2}+1]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">H_{t_{1}}</span> are awake at round <span class="math">3\\Delta t_{1}+2\\Delta</span></li>

    </ul>

    <p class="text-gray-300">We say that a <span class="math">(\\tau,\\pi)</span>-compliant execution satisfies <span class="math">(\\tau,\\pi)</span>-sleepiness, and call the set of <span class="math">(\\tau,\\pi)</span>-compliant executions <span class="math">E_{\\tau,\\pi}</span>. The <span class="math">(\\tau,\\pi)</span>-sleepy model restricts the allowable set of executions to <span class="math">E_{\\tau,\\pi}</span>.</p>

    <p class="text-gray-300">During the <span class="math">\\pi</span>-tpa, the network is asynchronous and <em>all</em> honest validators can be asleep. On the other hand, there are more restrictions on the adversary corruption schedule, <em>i.e.</em>, the adversary cannot corrupt too many validators in <span class="math">H_{t_{1}}</span>, because we rely on <span class="math">H_{t_{1}}</span> to preserve the canonical chain throughout this period.</p>

    <p class="text-gray-300">This is also why we have the third condition, as it guarantees that validators <span class="math">H_{t_1}</span> are able to observe the votes cast at round <span class="math">3\\Delta t_1 + \\Delta</span>, which inform any votes they might cast during the period of asynchrony. Moreover, not too many honest validators can be woken up during this period, because waking up during asynchrony allows the adversary to manipulate their votes. Note that, <span class="math">\\forall t &amp;gt; t_2</span>, <span class="math">\\tau</span>-sleepiness holds at slot <span class="math">t</span>, and the network is synchronous. Unless otherwise specified, we will mainly consider the <span class="math">\\tau</span>-sleepy model. The <span class="math">(\\tau, \\pi)</span>-sleepy model will be used when interested in analyzing the behaviour of a protocol under (bounded) asynchrony. In particular, we use it to define what it means for a synchronous protocol to be resilient to (temporary) asynchrony (Definition 7).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Hierarchy of <span class="math">(\\tau, \\pi)</span>-sleepy models</strong> Like <span class="math">E_{\\tau}</span>, <span class="math">E_{\\tau, \\pi}</span> is monotonically decreasing in <span class="math">\\tau</span>, i.e., <span class="math">\\tau_1 &amp;gt; \\tau_2</span> implies <span class="math">E_{\\tau_1, \\pi} \\subset E_{\\tau_2, \\pi}</span>. Moreover, it is monotonically <em>increasing</em> in <span class="math">\\pi</span>, i.e., <span class="math">\\pi_1 &amp;lt; \\pi_2</span> implies <span class="math">E_{\\tau, \\pi_1} \\subset E_{\\tau, \\pi_2}</span>, because a <span class="math">\\pi_1</span>-tpa is also a <span class="math">\\pi_2</span>-tpa. For <span class="math">\\pi \\leq 1</span>, a <span class="math">\\pi</span>-tpa is empty, and <span class="math">(\\tau, \\pi)</span>-compliance only requires <span class="math">\\tau</span>-sleepiness at all slots, i.e., <span class="math">E_{\\tau, \\pi} = E_{\\tau}</span>. The <span class="math">(\\tau, \\pi)</span>-sleepy model is then indeed a generalization of the <span class="math">\\tau</span>-sleepy model. For <span class="math">\\pi = \\infty</span>, a <span class="math">\\pi</span>-tpa can be an unbounded period of asynchrony starting after slot <span class="math">t_1</span>, and <span class="math">(\\tau, \\pi)</span>-compliance is only defined for <span class="math">\\tau = \\infty</span> as well. It requires $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{t_1} \\setminus A_\\infty</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_\\infty \\cup (H_{0,\\infty} \\setminus H_{t_1})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, where </span>A_\\infty<span class="math"> and </span>H_{0,\\infty}<span class="math"> are defined in the obvious way as limits. </span>H_{t_1} \\setminus A_\\infty<span class="math"> are the honest voters of slot </span>t_1<span class="math"> which are never corrupted, and </span>H_{0,\\infty}<span class="math"> are all honest validators which ever vote. If all validators vote at least once in the entire execution, then the requirement simply becomes </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{t_1} \\setminus A_\\infty</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; \\frac{n}{2}$, capturing the intuition that we can in principle get asynchronous safety as long as an honest majority of validators (which are never corrupted) agrees on something.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Aware validators</strong> Given a <span class="math">\\pi</span>-tpa <span class="math">(t_1, t_2)</span>, we say that a validator <span class="math">v_i</span> is <em>aware at round <span class="math">r</span></em> for <span class="math">r</span> in slots <span class="math">(t_1, t_2]</span> if <span class="math">v_i</span> is active at round <span class="math">r</span> and <span class="math">v_i \\in H_{t_1}</span>. For <span class="math">r</span> not in slots <span class="math">(t_1, t_2]</span>, we say that <span class="math">v_i</span> is aware at round <span class="math">r</span> simply if it is active at round <span class="math">r</span>. We motivate this notion after using it to define <em>asynchrony resilience</em> (Definition 7).</p>

    <h2 id="sec-28" class="text-2xl font-bold">2.2 Security</h2>

    <p class="text-gray-300"><strong>Security Parameters</strong> We largely follow here the notation and definitions of [7]. We consider <span class="math">\\lambda</span> and <span class="math">\\kappa</span> be the security parameter associated with the cryptographic components used by the protocol and the security parameter of the protocol itself, respectively. We consider a finite time horizon <span class="math">T_{\\mathrm{hor}}</span>, which is polynomial in <span class="math">\\kappa</span>. An event happens with <em>overwhelming probability</em>, or w.o.p, if it happens except with probability which is <span class="math">\\mathrm{negl}(\\kappa) + \\mathrm{negl}(\\lambda)</span>. Properties of cryptographic primitives hold except with probability <span class="math">\\mathrm{negl}(\\lambda)</span>, i.e., with overwhelming probability, but we leave this implicit in the remainder of this work.</p>

    <p class="text-gray-300"><strong>Confirmed chain</strong> The protocols which we consider always specify a <em>confirmation rule</em>, with whom validators can identify a <em>confirmed prefix</em> of the canonical chain. Alongside the canonical chain, validators then also keep track of a <em>confirmed chain</em>. We refer to the confirmed chain of validator <span class="math">v_i</span> at round <span class="math">r</span> as <span class="math">\\mathsf{Ch}_i^r</span> (cf. <span class="math">\\mathsf{ch}_i^r</span> for the canonical chain). This is the output of the protocol, for which safety properties should hold, and thus with respect to which the security of the protocol is defined.</p>

    <p class="text-gray-300"><strong>Definition 4 (Secure protocol [7])</strong> We say that a consensus protocol outputting a confirmed chain <span class="math">\\mathsf{Ch}</span> is secure, and has confirmation time <span class="math">T_{\\mathrm{conf}}</span>, if <span class="math">\\mathsf{Ch}</span> satisfies:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Safety</strong>: For any two rounds <span class="math">r, r&#x27;</span>, and any two honest validators <span class="math">v_i</span> and <span class="math">v_j</span> (possibly <span class="math">i = j</span>) at rounds <span class="math">r</span> and <span class="math">r&#x27;</span> respectively, either <span class="math">\\mathsf{Ch}_i^r \\preceq \\mathsf{Ch}_j^{r&#x27;}</span> or <span class="math">\\mathsf{Ch}_j^{r&#x27;} \\preceq \\mathsf{Ch}_i^r</span>.</li>

      <li><strong>Liveness</strong>: For any rounds <span class="math">r</span> and <span class="math">r&#x27; \\geq r + T_{\\mathrm{conf}}</span>, and any honest validator <span class="math">v_i</span> active at round <span class="math">r&#x27;</span>, <span class="math">\\mathsf{Ch}_i^{r&#x27;}</span> contains a block proposed by an honest validator at a round <span class="math">&amp;gt; r</span>.</li>

    </ul>

    <p class="text-gray-300">A protocol satisfies <span class="math">\\tau</span>-safety and <span class="math">\\tau</span>-liveness if it satisfies safety and liveness, respectively, in the <span class="math">\\tau</span>-sleepy model, i.e., in <span class="math">\\tau</span>-compliant executions <span class="math">E_{\\tau}</span>. A protocol satisfies <span class="math">\\tau</span>-security if it satisfies <span class="math">\\tau</span>-safety and <span class="math">\\tau</span>-liveness.</p>

    <p class="text-gray-300">5If the protocol satisfies liveness, then at least one honest proposal is added to the confirmed chain of all active validators every <span class="math">T_{\\mathrm{conf}}</span> slots. Since honest validators include all transactions they see, this ensures that transactions are confirmed within time <span class="math">T_{\\mathrm{conf}} + \\Delta</span> (assuming infinite block sizes or manageable transaction volume).</p>

    <p class="text-gray-300">Observe that, for <span class="math">\\tau_{1}&gt;\\tau_{2}</span>, since the <span class="math">\\tau_{1}</span>-sleepy model makes stronger assumptions than the <span class="math">\\tau_{2}</span>-sleepy model, security in the <span class="math">\\tau_{1}</span>-sleepy model is weaker than security in the <span class="math">\\tau_{2}</span>-sleepy model, i.e., <span class="math">\\tau_{2}</span>-security implies <span class="math">\\tau_{1}</span>-security. This is immediate from <span class="math">E_{\\tau_{1}}\\subset E_{\\tau_{2}}</span>, because <span class="math">\\tau_{2}</span>-security is precisely security in all executions <span class="math">E_{\\tau_{2}}</span>, which implies security in <span class="math">E_{\\tau_{1}}</span>.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Definition 5 (Dynamic availability).</h6>

    <p class="text-gray-300">We say that a consensus protocol is <span class="math">\\tau</span>-dynamically-available if and only if it satisfies <span class="math">\\tau</span>-security with confirmation time <span class="math">T_{\\mathsf{conf}}=O(\\kappa)</span>. Moreover, we say that a protocol is dynamically available if it is <span class="math">1</span>-dynamically-available, as this corresponds to the usual notion of dynamic availability.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Definition 6 (Reorg resilience).</h6>

    <p class="text-gray-300">An execution satisfies reorg resilience if any honest proposal <span class="math">B</span> from a slot <span class="math">t</span> is always in the canonical chain of all active validators at rounds <span class="math">\\geq 3\\Delta t+\\Delta</span>. A protocol is <span class="math">\\tau</span>-reorg-resilient if all <span class="math">\\tau</span>-compliant executions satisfy reorg resilience.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Definition 7 (Asynchrony resilience).</h6>

    <p class="text-gray-300">An execution in the synchronous network model with a <span class="math">\\mathsf{tpa}</span> <span class="math">(t_{1},t_{2})</span> satisfies asynchrony resilience if any honest proposal from a slot <span class="math">t\\leq t_{1}</span> is always in the canonical chain of all aware validators at rounds <span class="math">\\geq 3\\Delta t+\\Delta</span>. A protocol is <span class="math">(\\tau,\\pi)</span>-asynchrony-resilient if all <span class="math">(\\tau,\\pi)</span>-compliant executions satisfy asynchrony resilience.</p>

    <p class="text-gray-300">In Definition 3, we assume that validators <span class="math">H_{t_{1}}</span> are also awake at round <span class="math">3\\Delta t_{1}+2\\Delta</span>, so that they observe their own votes, i.e., each validator in <span class="math">H_{t_{1}}</span> has all honest votes from slot <span class="math">t_{1}</span> in their view going forward. They are then the only validators which we can require to see all honest proposals from before the <span class="math">\\mathsf{tpa}</span> as canonical during the <span class="math">\\mathsf{tpa}</span>. For example, we cannot require a validator which is asleep at slot <span class="math">t_{1}</span>, but active at slot <span class="math">t_{1}+1</span>, to see an honest proposal from slot <span class="math">t_{1}</span> as canonical, because asynchrony has already started and they might not have received the proposal at all. After the <span class="math">\\mathsf{tpa}</span>, the requirement can again apply to all active validators. In other words, we define asynchrony resilience as reorg resilience of proposals made before the <span class="math">\\mathsf{tpa}</span>, in the views of aware validators.</p>

    <h2 id="sec-32" class="text-2xl font-bold">3 Propose-vote-merge protocols</h2>

    <p class="text-gray-300">In this section we give a characterization of a class of protocols that we call propose-vote-merge protocols. These are protocols that proceed in slots consisting of <span class="math">k</span> rounds, each having a proposer <span class="math">v_{p}</span>, chosen through a proposer selection mechanism, e.g., the one outlined in Section 2. In this work, unless otherwise specified, we analyze the case <span class="math">k=3\\Delta</span>.</p>

    <p class="text-gray-300">At the beginning of each slot <span class="math">t</span>, a block is proposed by <span class="math">v_{p}</span>. All active validators (or voters) vote after <span class="math">\\Delta</span> rounds (what they vote for will become clear shortly). The last <span class="math">\\Delta</span> rounds of the slot are needed for the view-merge synchronization technique, as explained in Section 3.3. Every validator <span class="math">v_{i}</span> has a buffer <span class="math">\\mathcal{B}_{i}</span>, a collection of messages received from other validators, and a view <span class="math">\\mathcal{V}_{i}</span>, used to make consensus decisions, which admits messages from the buffer only at specific points in time.</p>

    <p class="text-gray-300">Propose-vote-merge protocols are equipped with a deterministic fork-choice function <span class="math">\\mathsf{FC}</span>, which is used by honest proposers and voters to decide how to propose and vote, respectively, based on their view at the round in which they are performing those actions. It is moreover used as the basis of a confirmation rule, as described in Section 3.5, with respect to which the security of the protocol is defined. We differentiate propose-vote-merge protocols based on which fork-choice they implement; in other words, these protocols are uniquely characterized by <span class="math">\\mathsf{FC}</span>. In section 3.6 we prove properties about propose-vote-merge protocols in a fork-choice-agnostic way. Then, we will instead focus on protocols using GHOST-based fork-choice functions.</p>

    <h3 id="sec-33" class="text-xl font-semibold mt-8">3.1 Message types</h3>

    <p class="text-gray-300">In propose-vote-merge protocols there are three message types, namely propose, block, and vote messages. We make no distinctions between network-level representation of blocks and votes, and their representation in a validator’s view, i.e., there is no difference between block and vote messages and blocks and votes, and we usually just refer to the latter. In the following description, <span class="math">t</span> is a slot and <span class="math">v_{i}</span> a validator. A block, or block message, is a tuple <span class="math">[\\text{{block}},\\,b,\\,t,\\,v_{i}]</span>, where <span class="math">b</span> is a block body, i.e., the protocol-specific content of the</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: Slot  <span class="math">t</span>  of a propose-vote-merge protocol, with its three phrases.</p>

    <p class="text-gray-300">block <span class="math">^6</span> . A vote, or VOTE message, is a tuple [VOTE,  <span class="math">B</span> ,  <span class="math">t</span> ,  <span class="math">v_i</span> ], where  <span class="math">B</span>  is a block. A proposal, or PROPOSE message, is a tuple [PROPOSE,  <span class="math">B</span> ,  <span class="math">\\mathcal{V}_i</span> ,  <span class="math">t</span> ,  <span class="math">v_i</span> ] where  <span class="math">B</span>  is a block and  <span class="math">\\mathcal{V}_i</span>  the view of validator  <span class="math">v_i</span> . Votes are gossiped at any time, and the same goes for blocks, regardless of whether they are received directly or as part of a vote or a proposal, i.e., a validator receiving a vote or proposal also gossips the block that it contains. Finally, a proposal from slot  <span class="math">t</span>  is gossiped only during the first  <span class="math">\\Delta</span>  rounds of slot  <span class="math">t</span> .</p>

    <p class="text-gray-300">We now define a propose-vote-merge protocol with a generic fork-choice function  <span class="math">\\mathsf{FC}</span> . Recall that a fork-choice function uniquely identifies a protocol of this family. A slot of the protocol proceeds in three phases, depicted in Figure 1 and implemented in Algorithm 1. Observe that validators (which have synchronized clocks) update the variables  <span class="math">t</span>  and  <span class="math">r</span>  representing slot and round, respectively, throughout the protocol's execution.</p>

    <p class="text-gray-300">PROPOSE: At round  <span class="math">3\\Delta t</span> , proposer  <span class="math">v_{p}</span>  merges its view  <span class="math">\\mathcal{V}_p</span>  with its buffer  <span class="math">\\mathcal{B}_p</span> , i.e.,  <span class="math">\\mathcal{V}_p \\gets \\mathcal{V}_p \\cup \\mathcal{B}_p</span> , and sets  <span class="math">\\mathcal{B}_p \\gets \\emptyset</span> . Then,  <span class="math">v_{p}</span>  runs the fork-choice function with inputs its view  <span class="math">\\mathcal{V}_p</span>  and slot  <span class="math">t</span> , obtaining the head of the chain  <span class="math">B&#x27; = \\mathsf{FC}(\\mathcal{V}_p, t)</span> . Proposer  <span class="math">v_{p}</span>  extends  <span class="math">B&#x27;</span>  with a new block  <span class="math">B</span> , and updates its canonical chain accordingly, setting  <span class="math">\\mathsf{ch}_p \\gets B</span> . Finally, it broadcasts [PROPOSE,  <span class="math">B</span> ,  <span class="math">\\mathcal{V}_p \\cup \\{B\\}</span> ,  <span class="math">t</span> ,  <span class="math">v_{p}</span> ].</p>

    <p class="text-gray-300">VOTE: In rounds  <span class="math">[3\\Delta, 3\\Delta t + \\Delta]</span> , every validator  <span class="math">v_{i}</span>  that receives a proposal message [PROPOSE,  <span class="math">B</span> ,  <span class="math">\\mathcal{V}</span> ,  <span class="math">t</span> ,  <span class="math">v_{p}</span> ] from  <span class="math">v_{p}</span>  merges its view with the proposed view  <span class="math">\\mathcal{V}</span>  by setting  <span class="math">\\mathcal{V}_{i} \\gets \\mathcal{V}_{i} \\cup \\mathcal{V}</span> . At round  <span class="math">3\\Delta t + \\Delta</span> , regardless of whether or not  <span class="math">v_{i}</span>  received a proposal message,  <span class="math">v_{i}</span>  broadcasts the vote message [VOTE,  <span class="math">\\mathsf{FC}(\\mathcal{V}_{i}, t)</span> ,  <span class="math">t</span> ,  <span class="math">v_{i}</span> ], and updates its canonical chain by setting  <span class="math">\\mathsf{ch}_{i} \\gets \\mathsf{FC}(\\mathcal{V}_{i}, t)</span> .</p>

    <p class="text-gray-300">MERGE: At round  <span class="math">3\\Delta t + 2\\Delta</span> , every validator  <span class="math">v_{i}</span>  merges its view with its buffer, i.e.,  <span class="math">\\mathcal{V}_i \\gets \\mathcal{V}_i \\cup \\mathcal{B}_i</span> , and sets  <span class="math">\\mathcal{B}_i \\gets \\emptyset</span> .</p>

    <p class="text-gray-300">The MERGE phase, along with all other operations involving views and buffers discussed in the previous section, are implementing the view-merge technique. View-merge has been introduced by Kane, Fackler, Gagol, and Straszak [10] to guarantee liveness of the Highway protocol, and then by D'Amato, Neu, Tas, and Tse [7] to ensure reorg resilience, i.e., proposals made by honest validators stay in the canonical chain, under synchrony. The core concept of the view-merge technique involves synchronizing the views of all honest validators with the view  <span class="math">\\mathcal{V}_p</span>  of the proposer for a specific slot before the validators broadcast their votes in that slot. To do so, view-merge works as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A validator's buffer is merged into its view only at one specific time, i.e.,  <span class="math">\\Delta</span>  rounds preceding the start of a new slot. Therefore, no new messages enter its view this way before voting in the next slot.</li>

      <li>The one exception to the above is the proposer of the next slot, which merges the buffer right before proposing,  <span class="math">\\Delta</span>  rounds after all other validators. It then proposes its resulting view  <span class="math">\\mathcal{V}_p</span>  and a block extending the canonical chain as determined by FC, according to  <span class="math">\\mathcal{V}_p</span> .</li>

    </ol>

    <p class="text-gray-300">Algorithm 1 Propose-vote-merge protocol for  <span class="math">v_{i}</span> 1: State 2:  <span class="math">\\mathcal{V}_i\\gets \\{\\mathcal{B}_{\\mathrm{genesis}}\\}</span>  : view of validator  <span class="math">v_{i}</span> 3:  <span class="math">\\mathcal{B}_i\\gets \\emptyset</span>  : buffer of validator  <span class="math">v_{i}</span> 4:  <span class="math">\\mathsf{ch}_i\\gets B_{\\mathrm{genesis}}</span>  : canonical chain of validator  <span class="math">v_{i}</span> 5:  <span class="math">t\\gets 0</span>  : the current slot 6:  <span class="math">r\\gets 0</span>  : the current round PROPOSE 7: at  <span class="math">r = 3\\Delta t</span>  do 8: if  <span class="math">v_{i} = v_{p}^{t}</span>  then 9:  <span class="math">\\mathcal{V}_i\\gets \\mathcal{V}_i\\cup \\mathcal{B}_i</span> 10:  <span class="math">\\mathcal{B}_i\\gets \\emptyset</span> 11:  <span class="math">B^{\\prime}\\gets \\mathsf{FC}(\\mathcal{V}_{i},t)</span> 12:  <span class="math">B\\gets \\mathsf{NewBlock}(B^{\\prime})</span> 13: // append a new block on top of  <span class="math">B^{\\prime}</span> 14:  <span class="math">\\mathsf{ch}_i\\gets B</span> 15: gossip message [PROPOSE,  <span class="math">B,\\mathcal{V}_i\\cup \\{B\\} ,t,v_i]</span> VOTE 16: at  <span class="math">r = 3\\Delta t + \\Delta</span>  do 17:  <span class="math">\\mathsf{ch}_i\\gets \\mathsf{FC}(\\mathcal{V}_i,t)</span> 18: gossip message [VOTE,  <span class="math">\\mathsf{FC}(\\mathcal{V}_i,t),t,v_i]</span> MERGE 19: at  <span class="math">r = 3\\Delta t + 2\\Delta</span>  do 20:  <span class="math">\\mathcal{V}_i\\gets \\mathcal{V}_i\\cup \\mathcal{B}_i</span> 21:  <span class="math">\\mathcal{B}_i\\gets \\emptyset</span> 22: upon receiving a message [PROPOSE,  <span class="math">B,\\mathcal{V},t,v_p^t ]</span>  do 23:  <span class="math">\\mathcal{B}_i\\gets \\mathcal{B}_i\\cup \\{B\\}</span> 24: if  <span class="math">r\\in [3\\Delta t,3\\Delta t + \\Delta ]</span>  then 25:  <span class="math">\\mathcal{V}_i\\gets \\mathcal{V}_i\\cup \\mathcal{V}</span> 26: upon receiving a message [VOTE,  <span class="math">B,t^{\\prime},v_{i}]</span>  from  <span class="math">v_{i}</span>  do 27:  <span class="math">\\mathcal{B}_i\\gets \\mathcal{B}_i\\cup \\{[\\mathrm{VOTE},B,t&#x27;,v_i]\\}</span> 28: upon receiving a message [BLOCK,  <span class="math">b,t^{\\prime},v_{i}]</span>  from  <span class="math">v_{i}</span>  do 29:  <span class="math">\\mathcal{B}_i\\gets \\mathcal{B}_i\\cup \\{[\\mathrm{BLOCK},b,t&#x27;,v_i]\\}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Validators merge the proposed view into their local view, execute FC based on this merged view, and vote.</li>

    </ol>

    <p class="text-gray-300">Observe that, if the network delay is less that <span class="math">\\Delta</span> rounds, the view of the proposer is a superset of the views of other validators, because all messages merged by validators in the first step will also be merged by the proposer <span class="math">\\Delta</span> rounds later. Then, the final merged view of all validators before voting is equal to the view of the proposer. If this is the case, since the output of the fork choice is a function of the view of a validator, every honest validator will have the same fork choice output, agreeing with the proposed block. As a consequence, active validators vote for honest proposals under synchrony. We refer to this as the <em>view-merge property</em>, and prove it here for <em>all propose-vote-merge protocols</em>.</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Lemma 1.</h6>

    <p class="text-gray-300">Suppose that <span class="math">t</span> is a pivot slot. Then, all honest voters of slot <span class="math">t</span>, <em>i.e.</em>, <span class="math">H_{t}</span>, vote for the honest proposal <span class="math">B</span> of slot <span class="math">t</span>.</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{V}_{p}\\cup\\{B\\}</span> be the view proposed with block <span class="math">B</span> by <span class="math">v_{p}</span>, the honest proposer of slot <span class="math">t</span>, <em>i.e.</em>, <span class="math">\\mathcal{V}_{p}</span> is the view of <span class="math">v_{p}</span> at round <span class="math">3\\Delta t</span>. Since <span class="math">v_{p}</span> is honest, <span class="math">B</span> extends <span class="math">\\textsf{FC}(\\mathcal{V}_{p},t)</span>, and thus <span class="math">\\textsf{FC}(\\mathcal{V}_{p}\\cup\\{B\\},t)=B</span> by the consistency property (see Section 2) of FC.</p>

    <p class="text-gray-300">Consider an honest voter of slot <span class="math">t</span>, <em>i.e.</em>, a validator <span class="math">v_{i}\\in H_{t}</span>, and let <span class="math">\\mathcal{V}_{i}</span> be its view at round <span class="math">3\\Delta t+\\Delta</span>, before merging <span class="math">\\mathcal{V}_{i}</span> with the proposed view <span class="math">\\mathcal{V}_{p}\\cup\\{B\\}</span>. Observe that, since <span class="math">v_{i}</span> is active in round <span class="math">3\\Delta t+\\Delta</span>, it must has already been awake at round <span class="math">3\\Delta(t-1)-2\\Delta</span>, because otherwise it would need to follow the joining protocol until round <span class="math">3\\Delta t+2\\Delta</span>, and would thus not currently be active.</p>

    <p class="text-gray-300">Therefore, <span class="math">v_{i}</span> was already active at round <span class="math">3\\Delta(t-1)-2\\Delta</span>, and in particular it merged its buffer <span class="math">\\mathcal{B}_{i}</span> in its local view then. So, <span class="math">\\mathcal{V}_{i}</span> is the view that <span class="math">v_{i}</span> had after merging the buffer <span class="math">\\mathcal{B}_{i}</span>. So, messages in <span class="math">\\mathcal{V}_{i}</span> are delivered to the proposer by round <span class="math">3\\Delta t</span>, so <span class="math">\\mathcal{V}_{i}\\subseteq\\mathcal{V}_{p}</span>.</p>

    <p class="text-gray-300">The proposal message is received by <span class="math">v_{i}</span> before voting. Then, <span class="math">v_{i}</span> merges the proposed view <span class="math">\\mathcal{V}_{p}\\cup\\{B\\}</span> with its view <span class="math">\\mathcal{V}_{i}</span>, resulting in the view <span class="math">\\mathcal{V}_{i}\\cup(\\mathcal{V}_{p}\\cup\\{B\\})=\\mathcal{V}_{p}\\cup\\{B\\}</span>. Validator <span class="math">v_{i}</span> votes for the output of its fork-choice at round <span class="math">3\\Delta t+\\Delta</span>, which is <span class="math">\\textsf{FC}(\\mathcal{V}_{p}\\cup\\{B\\},t)=B</span>. ∎</p>

    <h3 id="sec-38" class="text-xl font-semibold mt-8">3.4 Joining protocol</h3>

    <p class="text-gray-300">In Section 2 we described a model in which honest validators that become awake at round <span class="math">r</span>, before starting to participate in the protocol, must first execute (and terminate) a <em>joining protocol</em>, after which they become <em>active</em>. We now recall such a protocol, as presented in <em>[7]</em>.</p>

    <p class="text-gray-300">When an honest validator <span class="math">v_{i}</span> wakes up at some round <span class="math">r\\in(3\\Delta(t-1)+2\\Delta,3\\Delta t+2\\Delta]</span>, it immediately receives all the messages that were sent while it was asleep, and it adds them into its buffer <span class="math">\\mathcal{B}_{i}</span>, without actively participating in the protocol yet. All new messages which are received are added to the buffer <span class="math">\\mathcal{B}_{i}</span>, as usual. Validator <span class="math">v_{i}</span> then waits for the <em>next view-merge opportunity</em>, at round <span class="math">3\\Delta t+2\\Delta</span>, in order to merge its buffer <span class="math">B_{i}</span> into its view <span class="math">V_{i}</span>. At this point, <span class="math">v_{i}</span> starts executing the protocol. From this point on, validator <span class="math">v_{i}</span> becomes <em>active</em>, until either corrupted or put to sleep by the adversary.</p>

    <h3 id="sec-39" class="text-xl font-semibold mt-8">3.5 Confirmation rule</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In propose-vote-merge protocols, the confirmed chain Ch is the <span class="math">\\kappa</span>-deep prefix <em>in terms of slots</em> of the canonical chain ch, <em>i.e.</em>, its prefix corresponding to blocks proposed at slots <span class="math">\\leq t-\\kappa</span>, which we denote with $\\textsf{ch}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\kappa}<span class="math">. A validator </span>v_{i}<span class="math"> updates its confirmed chain </span>\\textsf{Ch}_{i}<span class="math"> whenever it updates its canonical chain </span>\\textsf{ch}_{i}<span class="math"> by computing the fork-choice, <em>i.e.</em>, at round </span>3\\Delta t+\\Delta<span class="math">, and possibly also </span>3\\Delta t<span class="math">, if they are the proposer of slot </span>t<span class="math">, so that at any time we have </span>\\textsf{Ch}_{i}=\\textsf{ch}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\kappa}_{i}<span class="math">. We show that, with overwhelming probability, all intervals </span>[t-\\kappa,t)<span class="math"> of </span>\\kappa<span class="math"> consecutive slots contain a <em>pivot slot</em>, <em>i.e.</em>, a slot with an honest proposer which is active at proposal time, and thus which makes a proposal. To achieve this, we rely on the lower bound </span>h_{0}<span class="math"> on the active validators </span>h_{r}<span class="math"> at any round, which guarantees that in any slot there is at least a probability </span>\\frac{h_{0}}{n}$ of an honest proposal being made.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-40" class="text-base font-medium mt-4">Lemma 2.</h6>

    <p class="text-gray-300">With overwhelming probability, all slot intervals of length <span class="math">\\kappa</span> contain at least a pivot slot.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">By assumption of <em>fairness</em> of the proposal mechanism, the proposer <span class="math">v_{p}</span> of slot <span class="math">t</span> is active at round <span class="math">3\\Delta t</span> with probability <span class="math">\\frac{h_{3\\Delta t}}{n}\\geq\\frac{h_{0}}{n}</span>, for <span class="math">h_{0}&gt;0</span>. Given any <span class="math">\\kappa</span> slots, the probability of none of the <span class="math">\\kappa</span> slots having an active proposer is <span class="math">\\leq(\\frac{n-h_{0}}{n})^{\\kappa}</span>, <em>i.e.</em>, negligible in <span class="math">\\kappa</span>. The number of slot intervals of length <span class="math">\\kappa</span> which we need to consider is equal to the time horizon <span class="math">T_{\\textsf{hor}}</span> over which the protocol is executed, which is polynomial in <span class="math">\\kappa</span>, so the probability of even one occurrence of <span class="math">\\kappa</span> consecutive slots without a pivot slot is also negligible. ∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">3.6 Properties</p>

    <p class="text-gray-300">We now prove properties that propose-vote-merge protocols with a generic fork-choice function FC satisfy. An important property is reorg resilience (Definition 6), which we show implies security (Definition 4) in Theorem 2. The two key ingredients for reorg resilience are the view-merge property (Lemma 1), and the following proposition. While the former holds for any propose-vote-merge protocol, the latter does only for some of them, and only in some <span class="math">\\tau</span>-sleepy model. In particular, we later prove that it holds for FC = GHOST-Eph, the fork-choice of Goldfish <em>[7]</em>, if <span class="math">1</span>-sleepiness is satisfied. More generally, we later show that it holds for FC = RLMD-GHOST with vote expiry parameter <span class="math">\\eta</span>, i.e., the fork-choice rule introduced in this work and presented in Section 5, if <span class="math">\\eta</span>-sleepiness is satisfied.</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Proposition 1.</h6>

    <p class="text-gray-300">Suppose that all honest voters of slot <span class="math">t-1</span> vote for a descendant of block <span class="math">B</span>. Then, <span class="math">B</span> is in the canonical chain of all active validators in rounds <span class="math">\\{3\\Delta t,3\\Delta t+\\Delta\\}</span>. In particular, all honest voters of slot <span class="math">t</span> vote for descendants of <span class="math">B</span>.</p>

    <p class="text-gray-300">We now show that, if Proposition 1 holds for an execution, then the execution satisfies reorg resilience. The idea is the following: by the view-merge property (Lemma 1), all active validators vote for honest proposals, and Proposition 1 ensures that this keeps holding also in future slots. We prove this result in the following theorem, which immediately implies that a protocol is <span class="math">\\tau</span>-reorg-resilient if Proposition 1 holds for it in the <span class="math">\\tau</span>-sleepy model.</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Theorem 1 (Reorg resilience).</h6>

    <p class="text-gray-300">Let us consider an execution of a propose-vote-merge protocol in which Proposition 1 holds. Then, this execution satisfies reorg resilience.</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider a honest proposal <span class="math">B</span> from slot <span class="math">t</span>. We prove reorg resilience by induction on the slot. Note that validators only ever update their canonical chain at rounds <span class="math">\\{3\\Delta s,3\\Delta s+\\Delta\\}</span>, for all slots <span class="math">s\\geq t</span>, upon computing the fork-choice. Therefore, the following statement holding for all <span class="math">s\\geq t</span> is sufficient for reorg resilience, as it implies that <span class="math">B</span> is canonical in all rounds <span class="math">\\geq 3\\Delta t+\\Delta</span>.</p>

    <p class="text-gray-300">Induction hypothesis: <span class="math">B</span> is canonical in the views of active validators at rounds <span class="math">r\\in\\{3\\Delta s,3\\Delta s+\\Delta\\}</span>, for a slot <span class="math">s\\geq t</span> and <span class="math">r\\geq 3\\Delta t+\\Delta</span>.</p>

    <p class="text-gray-300">Base case: The proposal slot <span class="math">t</span>. Lemma 1 applies and implies that all honest voters at slot <span class="math">t</span> vote for <span class="math">B</span>, which is in particular canonical in their views.</p>

    <p class="text-gray-300">Inductive step: Suppose now that the statement holds for <span class="math">s\\geq t</span>. In particular, all honest voters of slot <span class="math">s</span> vote for a descendant of <span class="math">B</span>, because it is canonical in their view in the voting round <span class="math">3\\Delta s+\\Delta</span>. Proposition 1 then implies the desired statement for <span class="math">s+1</span>. ∎</p>

    <p class="text-gray-300">If an execution satisfies reorg resilience we obtain that, by applying the same arguments as in <em>[7]</em>, the <span class="math">\\kappa</span>-deep confirmation rule is secure in it, in the sense that the confirmed chain satisfies Definition 4. In particular, <span class="math">\\tau</span>-reorg resilience implies <span class="math">\\tau</span>-dynamic-availability. Because of Thereom 1, we then only need to show that Proposition 1 holds for <span class="math">\\tau</span>-compliant executions in order to show that a protocol is <span class="math">\\tau</span>-dynamically-available.</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Theorem 2 (Dynamic-availability).</h6>

    <p class="text-gray-300">An execution of a propose-vote-merge protocol satisfying reorg resilience also satisfies security with overwhelming probability with <span class="math">T_{\\mathsf{conf}}=2\\kappa</span> slots. In particular, <span class="math">\\tau</span>-reorg-resilience implies <span class="math">\\tau</span>-dynamic-availability.</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Theorem 1 and Lemma 2 imply security (Definition 4) with overwhelming probability, as we now explain. For a round <span class="math">r</span>, denote by <span class="math">\\text{slot}(r)</span> the slot to which that round belongs. We show liveness with confirmation time <span class="math">T_{\\mathsf{conf}}=2\\kappa</span> slots. Consider a round <span class="math">r</span>, with <span class="math">t=\\text{slot}(r)</span>, a round <span class="math">r^{\\prime}</span> with <span class="math">t^{\\prime}=\\text{slot}(r^{\\prime})\\geq t+2\\kappa</span>, and an honest validator <span class="math">v_{i}</span> active at round <span class="math">r^{\\prime}</span>. By Lemma 2, w.o.p, there exists a pivot slot <span class="math">t^{\\prime\\prime}\\in[t+1,t+\\kappa]</span>. By Theorem 1, the proposal <span class="math">B</span> from slot <span class="math">t^{\\prime\\prime}</span> is in the canonical chain of all active validators in later slots, so in particular it is in <span class="math">\\mathsf{ch}_{i}^{r^{\\prime}}</span>. Since <span class="math">t^{\\prime\\prime}\\leq t+\\kappa\\leq t^{\\prime}-\\kappa</span>, <span class="math">B</span> is <span class="math">\\kappa</span>-deep in <span class="math">\\mathsf{ch}_{i}^{r^{\\prime}}</span>, and so it is in the confirmed chain <span class="math">\\mathsf{Ch}_{i}^{r^{\\prime}}</span> as well.</p>

    <p class="text-gray-300">To show safety, let us consider any two rounds <span class="math">r^{\\prime}\\geq r</span>, and any two honest validators <span class="math">v_{i}</span> and <span class="math">v_{j}</span>, active at rounds <span class="math">r</span> and <span class="math">r^{\\prime}</span>, respectively. Let also <span class="math">t=\\text{slot}(r)</span>. Lemma 2 implies that w.o.p. there is at least a pivot slot <span class="math">t^{\\prime}\\in[t-\\kappa,t)</span>, and by Theorem 1 its proposal <span class="math">B</span> is canonical in all active views from round <span class="math">3\\Delta t^{\\prime}+\\Delta</span>. Therefore, <span class="math">B</span> is in the canonical chain of <span class="math">v_{i}</span> at round <span class="math">r</span> and, since it is from a slot <span class="math">\\geq t-\\kappa</span>, <span class="math">\\mathsf{Ch}_{i}^{r}\\preceq B</span>. Block</p>

    <p class="text-gray-300"><span class="math">B</span> is also in the canonical chain of <span class="math">v_{j}</span> at round <span class="math">r^{\\prime}</span>, i.e., either <span class="math">B\\preceq \\mathsf{Ch}_{j}^{r^{\\prime}}</span> or <span class="math">\\mathsf{Ch}_j^{r&#x27;}\\preceq B</span>. In the first case, <span class="math">\\mathsf{Ch}_i^r\\preceq B\\preceq \\mathsf{Ch}_j^{r&#x27;}</span>. In the second case, we have both <span class="math">\\mathsf{Ch}_i^r\\preceq B</span> and <span class="math">\\mathsf{Ch}_j^{r&#x27;}\\preceq B</span>. Therefore, <span class="math">\\mathsf{Ch}_i^r</span> and <span class="math">\\mathsf{Ch}_j^{r&#x27;}</span> cannot be conflicting, it follows that either <span class="math">\\mathsf{Ch}_i^r\\preceq \\mathsf{Ch}_j^{r&#x27;}</span> or <span class="math">\\mathsf{Ch}_j^{r&#x27;}\\preceq \\mathsf{Ch}_i^r</span>.</p>

    <h2 id="sec-47" class="text-2xl font-bold">4 Propose-vote-merge protocols based on GHOST</h2>

    <h3 id="sec-48" class="text-xl font-semibold mt-8">4.1 Prerequisites</h3>

    <p class="text-gray-300">In this section we recall the LMD-GHOST fork-choice function as utilized in the Ethereum consensus protocol, Gasper [5]. We start by presenting the fork-choice function GHOST, the main building block of LMD-GHOST, and of all the fork-choice functions we consider in this work.</p>

    <h3 id="sec-49" class="text-xl font-semibold mt-8">4.1.1 GHOST</h3>

    <p class="text-gray-300">GHOST is a fork-choice function based on the fork-choice procedure introduced in [22] by Sompolinsky and Zohar, a greedy algorithm that grows a blockchain on sub-branches with the most activity. Except, this one is vote-based rather than block-based, i.e., here we weigh sub-trees based on number of votes rather than blocks. Given a set of votes <span class="math">M</span>, we define the weight function <span class="math">w(B,M)</span> to output the number of votes in <span class="math">M</span> for <span class="math">B</span> or descendants of <span class="math">B</span>, i.e., on the sub-tree rooted at <span class="math">B</span>. Starting at the first block of the canonical chain, i.e., <span class="math">B_{\\mathrm{genesis}}</span>, and considering the set <span class="math">M</span> of votes in <span class="math">\\mathcal{V}</span>, GHOST iterates over a sequence of blocks from <span class="math">\\mathcal{V}</span>, selecting as the next block the descendant of the current block with the highest weight. This continues until it reaches a block that does not have any descendant in <span class="math">\\mathcal{V}</span>, which is output. We now state and prove a simple property of the GHOST fork-choice, which we are going to repeatedly use throughout the work, without explicitly mentioning it, whenever wanting to prove that a block is in the canonical chain in some view.</p>

    <p class="text-gray-300"><strong>Lemma 3.</strong> Let <span class="math">\\mathcal{V}</span> be a view in which over a majority of the votes are for a descendant of a block <span class="math">B</span>. Then, <span class="math">\\mathrm{GHOST}(\\mathcal{V},t)</span> is a descendant of <span class="math">B</span>, i.e., <span class="math">B</span> is in the canonical chain output by the GHOST fork-choice.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> Let <span class="math">M</span> be all votes in <span class="math">\\mathcal{V}</span>. Consider any height less than or equal to the height of <span class="math">B</span>. In any fork at such a height, there is one branch that contains <span class="math">B</span>, and thus also the whole sub-tree rooted at <span class="math">B</span>. Say the block on that branch at that height is <span class="math">B&#x27;</span>, and consider any competing sibling <span class="math">B&#x27;&#x27;</span>. Since over a majority of the votes in <span class="math">M</span> are for the sub-tree rooted at <span class="math">B</span>, and all votes on the sub-tree rooted at <span class="math">B&#x27;</span> are not votes on the sub-tree rooted at <span class="math">B&#x27;&#x27;</span>, $w(B',M) &gt; \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{2} &gt; w(B'',M)<span class="math">. Thus, </span>B'<span class="math"> is selected by the GHOST fork-choice algorithm at that height. Therefore, </span>B \\preceq \\mathrm{GHOST}(\\mathcal{V},t)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Algorithm 2 GHOST Fork-Choice function</strong></p>

    <p class="text-gray-300">1: function GHOST(V,t) 2:  <span class="math">B \\gets B_{\\text{genesis}}</span> 3:  <span class="math">M \\gets</span> all votes in <span class="math">\\mathcal{V}</span> 4: while B has descendant blocks in <span class="math">\\mathcal{V}</span> do 5:  <span class="math">B \\gets \\arg \\max_{B&#x27; \\in \\mathcal{V}, \\text{child of } B} w(B&#x27;, M)</span> 6: // ties are broken according to a deterministic rule 7: return B</p>

    <h3 id="sec-50" class="text-xl font-semibold mt-8">4.1.2 Filtered GHOST</h3>

    <p class="text-gray-300">We define the family of GHOST-based fork-choice functions <span class="math">\\mathcal{G}_f</span>. A fork-choice function <span class="math">\\mathsf{FC} \\in \\mathcal{G}_f</span> is characterized by a view filter <span class="math">\\mathsf{FIL}</span>, which takes as input a view <span class="math">\\mathcal{V}</span> and a slot <span class="math">t</span>, and outputs <span class="math">(\\mathcal{V}&#x27;, t)</span>, where <span class="math">\\mathcal{V}&#x27;</span> is another view such that <span class="math">\\mathcal{V}&#x27; \\subseteq \\mathcal{V}</span>. Then, <span class="math">\\mathsf{FC}(\\mathcal{V}, t) := \\mathrm{GHOST}(\\mathsf{FIL}(\\mathcal{V}, t))</span>, i.e., <span class="math">\\mathsf{FC} := \\mathrm{GHOST} \\circ \\mathsf{FIL}</span>. GHOST itself is contained in <span class="math">\\mathcal{G}_f</span>, characterized by the identity filter.</p>

    <p class="text-gray-300">Equivocation discounting All fork-choice functions we consider from now on implement a technique to deal with equivocations, used in the Ethereum protocol, as a spam-resistance measure, i.e., equivocation discounting [1][7]. It consists of excluding votes from equivocating validators from one's view, before running the fork-choice function on it. We describe equivocation discounting using view filters. Consider the view filter  <span class="math">\\mathsf{FIL}_{eq}</span>  such that  <span class="math">\\mathsf{FIL}_{eq}(\\mathcal{V},t)</span>  removes all votes by equivocating validators in  <span class="math">\\mathcal{V}</span> , i.e., validators for which  <span class="math">\\mathcal{V}</span>  contains multiple, equivocating, votes for some slot  <span class="math">t</span> . Given a fork-choice function  <span class="math">\\mathsf{FC} \\in \\mathcal{G}_f</span> , characterized by the view filter  <span class="math">\\mathsf{FIL}</span> , we apply equivocation discounting to  <span class="math">\\mathsf{FC}</span>  by composing  <span class="math">\\mathsf{FIL}</span>  with  <span class="math">\\mathsf{FIL}_{eq}</span> , i.e., by considering the fork-choice function  <span class="math">\\mathsf{FC}_{eq} := \\mathsf{GHOST} \\circ \\mathsf{FIL} \\circ \\mathsf{FIL}_{eq}</span> . All fork-choice functions considered in the following sections implement equivocation discounting, even if not explicitly stated.</p>

    <p class="text-gray-300">LMD-GHOST is an adaptation of the original GHOST [22], in which the protocol considers only each validator's most recent vote (LMD), which is assumed to be the most meaningful. LMD-GHOST belongs to the class  <span class="math">\\mathcal{G}_f</span>  of fork-choice functions based on GHOST [22], and is characterized by a view filter  <span class="math">\\mathsf{FIL}_{\\mathrm{Imd}}</span> .  <span class="math">\\mathsf{FIL}_{\\mathrm{Imd}}(\\mathcal{V},t)</span>  removes all but the latest votes of every validator (possibly more than one) from  <span class="math">\\mathcal{V}</span>  and outputs the resulting view, i.e., it implements the latest message (LMD) rule.</p>

    <p class="text-gray-300">Algorithm 3 LMD-GHOST Fork-Choice function 1: function LMD-GHOST  <span class="math">(\\mathcal{V},t)</span> 2: return GHOST  <span class="math">(\\mathsf{FIL}_{\\mathrm{Imd}}(\\mathsf{FIL}_{\\mathrm{eq}}(\\mathcal{V},t)))</span> 3: function  <span class="math">\\mathsf{FIL}_{\\mathrm{Imd}}(\\mathcal{V},t)</span> 4:  <span class="math">\\mathcal{V}&#x27; \\gets \\mathcal{V}</span>  without all but the most recent (latest) votes 5: of each validator 6: return  <span class="math">(\\mathcal{V}&#x27;,t)</span> 7: function  <span class="math">\\mathsf{FIL}_{\\mathrm{eq}}(\\mathcal{V},t)</span> 8:  <span class="math">\\mathcal{V}&#x27; \\gets \\mathcal{V}</span>  without all votes by equivocators in  <span class="math">\\mathcal{V}</span> 9: return  <span class="math">(\\mathcal{V}&#x27;,t)</span></p>

    <p class="text-gray-300">The first propose-vote-merge protocol that we consider is a variation of the original LMD-GHOST protocol, with the addition of view-merge and without considering subsampling of validators, the latter in order to prevent ex-ante reorgs <span class="math">^7</span> .</p>

    <p class="text-gray-300">To specify a propose-vote-merge protocol, we only need to define the fork-choice function which uniquely characterizes it, which in this case is of course LMD-GHOST, as introduced in Section 4.1.3. From now on, we refer to this propose-vote-merge protocol simply as LMD-GHOST.</p>

    <p class="text-gray-300">We first introduce the following notation. We denote with  <span class="math">\\widetilde{H}_t</span>  the set of honest voters of slot  <span class="math">t</span>  that are never corrupted, i.e.,  <span class="math">\\widetilde{H}_t \\coloneqq \\lim_{s \\to \\infty} H_t \\setminus A_s = H_t \\setminus A_\\infty</span> . We refer to validators that are never corrupted as permanently honest, and to  <span class="math">\\widetilde{H}_t</span>  as the permanently honest voters of slot  <span class="math">t</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the following theorem we analyze the reorg resilience of LMD-GHOST. In particular, given  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\widetilde{H}_t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; \\frac{n}{2}<span class="math">  and an honest proposal  </span>B<span class="math">  from a slot  </span>t<span class="math"> , then  </span>B<span class="math">  is always canonical in all honest views that contain all slot  </span>t<span class="math">  votes from  </span>\\widetilde{H}_t$ , without requiring synchrony at any future slot. In other words, honest proposals made during synchrony immediately become asynchronously safe. This is much stronger than the usual notion of reorg resilience, which requires continued synchrony.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 3 (Strong reorg resilience). Consider an honest proposal  <span class="math">B</span>  from a slot  <span class="math">t</span>  in which network synchrony hold and  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\widetilde{H}_t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; \\frac{n}{2}<span class="math"> . Suppose that validators in  </span>\\widetilde{H}_t<span class="math">  do not fall asleep in rounds  </span>[3\\Delta t + \\Delta, 3\\Delta t + 2\\Delta]<span class="math"> . Then,  </span>B<span class="math">  is always canonical in all honest views which contain all slot  </span>t<span class="math">  votes from  </span>\\widetilde{H}_t$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. By Lemma 1, all honest voters of slot <span class="math">t</span> broadcast a vote for <span class="math">B</span> at round <span class="math">3\\Delta t + \\Delta</span>. Synchrony in the subsequent <span class="math">\\Delta</span> rounds means that all such votes are received by those same validators before they merge their buffers, since by assumption they do not fall asleep. Those votes are then in all of their views by the end of slot <span class="math">t</span> and the result follows.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">On the other hand LMD-GHOST is significantly limited in its support of dynamic participation, as shown in the following theorem. In particular, we present a scenario in which the adversary is able to cause a reorg of a confirmed block, compromising <span class="math">\\tau</span>-safety and, consequently, <span class="math">\\tau</span>-dynamic-availability, while never violating <span class="math">\\tau</span>-sleepiness. The reason why this attack is possible is due to the fact that <span class="math">\\tau</span>-sleepiness only considers votes from the last <span class="math">\\tau</span> slots, but LMD-GHOST does not have vote expiry, so all votes are relevant to the fork-choice. Since the <span class="math">\\infty</span>-sleepy model allows only an extremely restrictive form of dynamic participation, almost equivalent to requiring $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\widetilde{H}_t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; \\frac{n}{2}$ at all times, this is a fairly strong limitative result.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Theorem 4. LMD-GHOST is not <span class="math">\\tau</span>-dynamically-available for any finite <span class="math">\\tau</span> and any confirmation rule with finite confirmation time <span class="math">T_{\\mathrm{conf}}</span>.</p>

    <p class="text-gray-300">Proof. For some <span class="math">\\tau &amp;lt; \\infty</span> and a confirmation rule with confirmation time <span class="math">T_{\\mathrm{conf}}</span>, we show that <span class="math">\\tau</span>-safety and <span class="math">\\tau</span>-liveness are in conflict for LMD-GHOST. We look at a specific execution, which we assume satisfies liveness, and show that it does not satisfy safety. Moreover, we show that such execution is <span class="math">\\tau</span>-compliant. Therefore, there are <span class="math">\\tau</span>-compliant executions in which either liveness or safety is not satisfied, and consequently LMD-GHOST is not <span class="math">\\tau</span>-dynamically-available.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Without loss of generality, we fix a finite <span class="math">\\tau \\geq T_{\\mathrm{conf}}</span> (we do not need to consider <span class="math">\\tau &amp;lt; T_{\\mathrm{conf}}</span> since <span class="math">\\tau_{1}</span>-dynamic-availability implies <span class="math">\\tau_{2}</span>-dynamic-availability for <span class="math">\\tau_{1} \\leq \\tau_{2}</span>). We consider a validator set of size <span class="math">n = 2m + 1</span>, partitioned in three sets, <span class="math">V_{1}</span>, <span class="math">V_{2}</span>, and <span class="math">V_{3}</span>, with <span class="math">V_{1} = \\{v_{1}\\}</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= m + 1<span class="math">, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_{3}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= m - 1<span class="math">. Validators in </span>V_{2}<span class="math"> and </span>V_{3}<span class="math"> are all initially honest, while </span>v_{1}<span class="math"> is adversarial. Let </span>t - 1<span class="math"> and </span>t<span class="math"> be two adversarial slots, i.e., controlled by </span>v_{1}<span class="math">. In slot </span>t<span class="math">, validator </span>v_{1}<span class="math"> publishes conflicting blocks </span>A<span class="math"> and </span>B<span class="math">, one as a proposal for slot </span>t - 1<span class="math"> and the other for slot </span>t<span class="math">. By round </span>3\\Delta t + \\Delta<span class="math">, the adversary delivers only </span>A<span class="math"> to validators in </span>V_{2}<span class="math">, and only </span>B<span class="math"> to validators in </span>V_{3}<span class="math">, so that the former vote for </span>A<span class="math"> and the latter for </span>B<span class="math"> in slot </span>t^{8}<span class="math">. At this point, the adversary puts all validators in </span>V_{3}<span class="math"> to sleep, and then does nothing for </span>N \\gg \\tau<span class="math"> slots, i.e., until slot </span>t + N<span class="math">. Meanwhile, validators in </span>V_{2}<span class="math"> keep voting for </span>A<span class="math">, since </span>V_{2}<span class="math"> contains </span>m + 1 &gt; \\frac{n}{2}<span class="math"> validators, so </span>A<span class="math"> stays canonical in all of the views of every member of </span>V_{2}<span class="math">. Since </span>\\tau \\geq T_{\\mathrm{conf}}<span class="math">, this execution satisfying liveness implies that some honest proposal made after slot </span>t<span class="math"> is confirmed in this period, and thus that block </span>A<span class="math"> is confirmed, since all honest proposals made in this period are descendants of </span>A<span class="math">. For any slot </span>s \\in [0, t + 1]<span class="math">, we have that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{s-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_2 \\cup V_3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2m<span class="math">, so </span>\\tau<span class="math">-sleepiness is satisfied. For </span>s \\in [t + 2, t + \\tau]<span class="math">, we have that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{s-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= m + 1 &gt; m =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_1 \\cup V_3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_s \\cup (H_{s-\\tau, s-2} \\setminus H_{s-1})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, so </span>\\tau<span class="math">-sleepiness is also satisfied. For </span>s \\in [t + \\tau + 1, t + N - 1]<span class="math">, the first two terms are unchanged, while </span>H_{s-\\tau, s-2} \\setminus H_s = \\emptyset<span class="math">, because the last vote broadcast by the validators in </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is from slot </span>t &lt; s - \\tau<span class="math">. </span>\\tau<span class="math">-sleepiness is then still satisfied. At slot </span>t + N<span class="math">, the adversary corrupts a single validator </span>v_2 \\in V_2<span class="math">, and starts voting for </span>B<span class="math"> with both </span>v_1<span class="math"> and </span>v_2<span class="math">. Now, </span>B<span class="math"> has </span>m + 1<span class="math"> votes, and descendants of </span>A<span class="math"> only </span>m<span class="math">, so </span>B<span class="math"> becomes canonical and stay so. After </span>T_{\\mathrm{conf}}<span class="math"> slots, it is confirmed by all validators in </span>V_2<span class="math">, meaning we have a safety violation. The adversary does not perform any more corruptions nor puts to sleep any more validators, and does not wake up validators in </span>V_3<span class="math">. Therefore, for all slots </span>s \\geq t + N<span class="math">, we have </span>A_s = \\{v_1, v_2\\}<span class="math">, </span>V_2 \\setminus \\{v_2\\} \\subseteq H_{s-1}<span class="math"> and </span>H_{s-\\tau, s-2} \\setminus H_{s-1} = \\emptyset<span class="math">. </span>\\tau<span class="math">-sleepiness is then satisfied, because </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{s-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq m &gt; 2 =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_s \\cup H_{s-\\tau, s-2} \\setminus H_s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Therefore, the executions is </span>\\tau<span class="math">-compliant, and thus the protocol does not satisfy </span>\\tau$-security.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-53" class="text-2xl font-bold">4.3 Goldfish</h2>

    <p class="text-gray-300">Goldfish is a simplified variant of LMD-GHOST, introduced by D'Amato, Neu, Tas, and Tse [7], which very nearly belongs to the family of propose-vote-merge protocols. Goldfish can tolerate dynamic participation, it supports subsampling of validators, and it is 1-reorg-resilient and 1-dynamically-available in synchronous networks with dynamic participation. During each slot in Goldfish, only votes from the immediately preceding slot influence the protocol's behavior.</p>

    <p class="text-gray-300">In the following analysis, we depart slightly from the original formulation [7], and consider a version of Goldfish which fulfills the specification of a propose-view-merge protocol. This variant does not consider</p>

    <p class="text-gray-300">8In practice, such splitting of honest views can be done without targeting specific validators, and rather only aiming to get an approximate partition of the honest validators in two. This kind of attack method has been discussed at length in the context of balancing attacks [15].</p>

    <p class="text-gray-300">subsampling and replaces the VRF lottery considered in the original protocol with an SSLE proposer selection mechanism (see Section 2). Note that accommodating these features of the original Goldfish protocol would only require a small extension of the family of propose-vote-merge protocols, which we do not consider here for simplicity. In fact, the analysis of <em>[7]</em> is almost exactly identical to the analysis of this variant of Goldfish, in particular relying on reorg resilience in the same way. Crucially, in the case of Goldfish, Proposition 1 is true even if subsampling is considered, due to the strict vote expiry.</p>

    <p class="text-gray-300">Goldfish is characterized by GHOST-Eph, a fork-choice function in <span class="math">\\mathcal{G}_{f}</span> that takes a view <span class="math">\\mathcal{V}</span> and a slot <span class="math">t</span> as inputs, and finds the canonical chain determined by the votes within <span class="math">\\mathcal{V}</span> that were broadcast for slot <span class="math">t-1</span>.</p>

    <h4 id="sec-54" class="text-lg font-semibold mt-6">4.3.1 Vote Expiry</h4>

    <p class="text-gray-300">The notion of <em>vote expiry</em> has been introduced in the context of Goldfish, where all but the <em>most recent</em> votes are discarded. We generalize here this notion by introducing an <em>expiration period</em> <span class="math">\\eta</span>. In particular, given a slot <span class="math">t</span> and a constant <span class="math">\\eta\\in\\mathbb{N}</span> with <span class="math">\\eta\\geq 0</span>, the <em>expiration period</em> for slot <span class="math">t</span> is the interval <span class="math">[t-\\eta,t)</span>, and only votes broadcast within this period influence the protocol’s behavior at slot <span class="math">t</span>. In particular, by assuming an expiration period, the capabilities of the adversary are limited, as votes broadcast before slot <span class="math">t-\\eta</span> are not considered.</p>

    <p class="text-gray-300">Formally, we can define the GHOST <em>fork-choice function</em> with <em>expiry period</em> <span class="math">\\eta</span> as a fork-choice function in <span class="math">\\mathcal{G}_{f}</span>. It is characterized by the filter function <span class="math">\\mathsf{FIL}_{\\eta\\text{-exp}}(\\mathcal{V},t)</span> which removes all votes from slots <span class="math">&lt;t-\\eta</span> from <span class="math">\\mathcal{V}</span>, and outputs the resulting view. For <span class="math">\\eta=\\infty</span>, we get back the regular GHOST fork-choice function, whereas for <span class="math">\\eta=1</span>, we get GHOST-Eph.</p>

    <p class="text-gray-300">Algorithm 4 GHOST-Eph Fork-Choice function 1: function GHOST-Eph<span class="math">(\\mathcal{V},t)</span> 2: return GHOST<span class="math">(\\mathsf{FIL}_{1\\text{-exp}}(\\mathsf{FIL}_{\\text{eq}}(\\mathcal{V},t)))</span> 3: function <span class="math">\\mathsf{FIL}_{\\eta\\text{-exp}}(\\mathcal{V},t)</span> 4: <span class="math">\\mathcal{V}^{\\prime}\\leftarrow\\mathcal{V}</span> without all votes from slots <span class="math">&lt;t-\\eta</span> 5: return <span class="math">(\\mathcal{V}^{\\prime},t)</span></p>

    <p class="text-gray-300">Vote expiry allows the protocol to support dynamic participation.</p>

    <h4 id="sec-55" class="text-lg font-semibold mt-6">4.3.2 Properties and limitations</h4>

    <p class="text-gray-300">D’Amato, Neu, Tas, and Tse <em>[7]</em> show that Goldfish is 1-reorg-resilient and 1-dynamic-available, as also follows from Theorems 6 and 7 in our analysis of RLMD-GHOST, for the special case <span class="math">\\eta=1</span>. On the other hand, Goldfish is brittle to temporary asynchrony. Due to the expiry period being <span class="math">\\eta=1</span>, even a single violation of the bound of <span class="math">\\Delta</span> rounds on the network delay can lead to a catastrophic failure, jeopardizing the safety of <em>any</em> previously confirmed block. This holds even with a single adversarial validator, and with all validators awake. Suppose for example that network delay is <span class="math">&gt;\\Delta</span> rounds between rounds <span class="math">[3\\Delta t+\\Delta,3\\Delta t+2\\Delta]</span>. This causes all honest votes broadcast at round <span class="math">3\\Delta t+\\Delta</span> to not be delivered to any honest validator by round <span class="math">3\\Delta t+2\\Delta</span>. Then, such votes are not in any honest view after merging the buffer. Suppose also that the proposer of slot <span class="math">t+1</span> is malicious and proposes a block <span class="math">B</span> extending a block <span class="math">A</span> which is not in the canonical chain. Moreover, the proposed view contains no votes other than a single slot <span class="math">t</span> vote for <span class="math">A</span> from <span class="math">v_{p}^{t+1}</span> itself. Then, the view of an honest validator at the voting round <span class="math">3\\Delta(t+1)+\\Delta</span> contains only two slot <span class="math">t</span> votes: its own, and the one for <span class="math">A</span>. If <span class="math">A</span> wins the tiebreaker, all honest validators thus vote for <span class="math">B</span>, making it canonical and reorging all previously confirmed blocks. Since the period of asynchrony lasts for (less than) a single slot, all validators are always awake and there is a single adversarial validator, it is clear that the described execution is <span class="math">(\\infty,2)</span>-compliant. Since <span class="math">E_{\\tau,\\pi}</span> is monotonically decreasing in <span class="math">\\tau</span> and increasing in <span class="math">\\pi</span>, and thus <span class="math">E_{\\infty,2}\\subseteq E_{\\tau,\\pi}</span> for all <span class="math">\\tau&gt;\\pi\\geq 2</span>, the above amounts to a proof of the following theorem.</p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Theorem 5.</h6>

    <p class="text-gray-300">Goldfish is not <span class="math">(\\tau,\\pi)</span>-asynchrony-resilient for any <span class="math">\\tau&gt;\\pi\\geq 2</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">5 Recent Latest Message Driven (RLMD) GHOST</p>

    <p class="text-gray-300">In this section we present our propose-vote-merge protocol, RLMD-GHOST, which generalizes both LMD-GHOST and Goldfish. It is characterized by the GHOST-based fork-choice FC = RLMD-GHOST, which combines vote expiry (see Section 4.3.1) with the latest message driven (LMD) fork-choice (see Section 4.1.3). Its filter function <span class="math">\\mathsf{FIL}_{\\text{rlmd}}(\\mathcal{V},t)</span> removes all but the latest messages within the expiry period <span class="math">[t-\\eta,t)</span> for slot <span class="math">t</span>, i.e., <span class="math">\\mathsf{FIL}_{\\text{rlmd}}=\\mathsf{FIL}_{\\text{lmd}}\\circ\\mathsf{FIL}_{\\eta\\text{-exp}}\\circ\\mathsf{FIL}_{eq}</span>.</p>

    <p class="text-gray-300">For <span class="math">\\eta=1</span>, RLMD-GHOST coincides with GHOST-Eph, and thus RLMD-GHOST with Goldfish, because <span class="math">\\mathsf{FIL}_{1\\text{-exp}}</span> only considers votes from slot <span class="math">t-1</span>, which are a subset of the latest votes, so that the LMD rule does not add any further filtering. For <span class="math">\\eta=\\infty</span>, it coincides with LMD-GHOST, because no messages expire, so <span class="math">\\mathsf{FIL}_{\\infty\\text{-exp}}</span> does not perform any filtering. Unless specified, we henceforth refer to RLMD-GHOST with a generic parameter <span class="math">\\eta</span>.</p>

    <p class="text-gray-300">As Goldfish, RLMD-GHOST can support <em>fast confirmations</em> of honest proposals optimistically, i.e., when honest participation is high. Moreover, due to the proposer selection mechanism satisfying uniqueness, it can do so without increasing the slot length to <span class="math">4\\Delta</span> rounds, <em>if the optimistic assumption is expanded to also assume that network latency is <span class="math">\\frac{\\Delta}{2}</span></em>. We discuss this at length in Appendix B.</p>

    <p class="text-gray-300">Finally, observe that, if <span class="math">\\eta&gt;1</span>, enabling subsampling allows for ex-ante reorgs <em>[21]</em>. Since reorg resilience is central in the security analysis of propose-vote-merge protocols, this leads to entirely different security arguments being necessary, and consequently to reduced adversarial tolerance.</p>

    <p class="text-gray-300">Algorithm 5 RLMD-GHOST Fork-Choice function 1: function RLMD-GHOST(<span class="math">\\mathcal{V},t</span>) 2: return GHOST(<span class="math">\\mathsf{FIL}_{\\text{rlmd}}(\\mathcal{V},t),t</span>) 3: function <span class="math">\\mathsf{FIL}_{\\text{rlmd}}(\\mathcal{V},t)</span> 4: return <span class="math">\\mathsf{FIL}_{\\text{lmd}}(\\mathsf{FIL}_{\\eta\\text{-exp}}(\\mathsf{FIL}_{eq}(\\mathcal{V},t)))</span></p>

    <h3 id="sec-57" class="text-xl font-semibold mt-8">5.1 Tradeoff between dynamic availability and resilience to asynchrony</h3>

    <p class="text-gray-300">The expiry parameter <span class="math">\\eta</span> allows us to explore a tradeoff space between dynamic availability and resilience to asynchrony. At the extremes, <span class="math">\\eta=\\infty</span> gives us LMD-GHOST, a protocol which achieves asynchronous safety, but requires <span class="math">&gt;\\frac{n}{2}</span> honest participants to always be awake, and <span class="math">\\eta=1</span> gives us Goldfish, a dynamically available protocol which does not tolerate even a single slot of asynchrony. As we show in Section 5.2, RLMD-GHOST with <span class="math">1&lt;\\eta&lt;\\infty</span> sits somewhere in between, achieving weaker forms of both properties, namely <span class="math">\\eta</span>-dynamic-availability and <span class="math">(\\eta,\\eta-1)</span>-asynchrony-resilience, i.e., it can tolerate <span class="math">&lt;\\eta-1</span> slots of asynchrony, but it is only secure with the stronger assumptions of the <span class="math">\\eta</span>-sleepy model. The greater resilience to asynchrony is unsurprisingly due to the longer expiration period, which allows the latest messages of honest validators to persist even if periods of asynchrony prevent those validators from renewing their votes in the views of other validators. The same considerations apply to sudden drops in active participation, violating <span class="math">\\eta</span>-sleepiness assumptions. Even temporary violations of the basic 1-sleepiness assumption, i.e., a <em>temporary adversarial majority</em> (for example if all honest validators are asleep), can be tolerated. In all such cases, the longer expiry period prevents the set of active validators whose votes are unexpired, and thus relevant to the fork-choice function, from suddenly shrinking or disappearing altogether. On the other hand, taking into account votes of validators which might be asleep weakens dynamic availability, as we have seen for LMD-GHOST in Theorem 4, motivating why the <span class="math">\\eta</span>-sleepiness assumption is required.</p>

    <h3 id="sec-58" class="text-xl font-semibold mt-8">5.2 Properties</h3>

    <p class="text-gray-300">We start by showing that Proposition 1 holds in <span class="math">\\eta</span>-compliant executions of RLMD-GHOST.</p>

    <h6 id="sec-59" class="text-base font-medium mt-4">Lemma 4.</h6>

    <p class="text-gray-300">Proposition 1 holds for RLMD-GHOST in <span class="math">\\eta</span>-compliant executions.</p>

    <h6 id="sec-60" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{V}</span> be the view of an active validator at a round <span class="math">\\in\\{3\\Delta t,3\\Delta t+\\Delta\\}</span>. By the synchrony assumption, and since the buffer is merged at round <span class="math">3\\Delta(t-1)+2\\Delta</span>, all honest votes from slot <span class="math">t-1</span> are in <span class="math">\\mathcal{V}</span> and, by assumption, they are for descendants of <span class="math">B</span>. The only votes to consider in order to decide whether <span class="math">B</span> is</p>

    <p class="text-gray-300">canonical in <span class="math">\\mathcal{V}</span> are those from slots <span class="math">\\in[t-\\eta,t-1]</span>, because votes from slots prior to <span class="math">t-\\eta</span> are expired at slot <span class="math">t</span>. Votes that are not for descendants of <span class="math">B</span> might be those from adversarial validators in <span class="math">A_{t}</span>, or from validators in <span class="math">H_{t-\\eta,t-2}\\setminus H_{t-1}</span>, <em>i.e.</em>, those that have voted in at least some slot <span class="math">\\in[t-\\eta,t-2]</span>, but did not vote in slot <span class="math">s-1</span>. Observe that <span class="math">H_{t-1}\\cap A_{t}</span> might not be empty; there might be validators that were active in slot <span class="math">t-1</span> but were (shortly after) corrupted. Therefore, <span class="math">\\mathcal{V}</span> might contain more than one vote from slot <span class="math">t-1</span> from some of these validators.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">E\\subset H_{t-1}\\cap A_{t}</span> be the set of validators in <span class="math">H_{t-1}\\cap A_{t}</span> for which <span class="math">\\mathcal{V}</span> contains more than one vote from slot <span class="math">t-1</span>. Due to equivocation discounting, votes from validators in <span class="math">E</span> will not count. Observe that the number of votes that are not for descendants of <span class="math">B</span> and that are counted in <span class="math">\\mathcal{V}</span> is upper bounded by $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(A_{t}\\setminus E)\\cup(H_{t-\\eta,t-2}\\setminus H_{t-1})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(A_{t}\\cup(H_{t-\\eta,t-2}\\setminus H_{t-1}))\\setminus E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{t}\\cup(H_{t-\\eta,t-2}\\setminus H_{t-1})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, where the first equality follows from </span>E\\subset H_{t-1}<span class="math">. Since </span>\\mathcal{V}<span class="math"> contains votes for descendants of </span>B<span class="math"> for all validators in </span>H_{t-1}<span class="math">, the number of votes for descendants of </span>B<span class="math"> and that are counted in </span>\\mathcal{V}<span class="math"> is lower bounded by </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{t-1}\\setminus E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{t-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Since this is an </span>\\eta<span class="math">-compliant execution, </span>\\eta<span class="math">-sleepiness holds, <em>i.e.</em>, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{t-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{t}\\cup(H_{t-\\eta,t-2}\\setminus H_{t-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, so </span>B<span class="math"> is canonical in </span>\\mathcal{V}$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As shown in Section 3, since Proposition 1 holds for RLMD-GHOST in <span class="math">\\eta</span>-compliant executions, the next two theorems follow. Observe that, by the hierarchy of sleepy models (see Section 2), the following results are also satisfied for <span class="math">\\tau\\geq\\eta</span>. In Appendix A, we show that these results are tight.</p>

    <h6 id="sec-61" class="text-base font-medium mt-4">Theorem 6 (Reorg resilience).</h6>

    <p class="text-gray-300">RLMD-GHOST is <span class="math">\\eta</span>-reorg-resilient.</p>

    <h6 id="sec-62" class="text-base font-medium mt-4">Theorem 7 (Dynamic availability).</h6>

    <p class="text-gray-300">RLMD-GHOST is <span class="math">\\eta</span>-dynamically-available.</p>

    <h6 id="sec-63" class="text-base font-medium mt-4">Theorem 8 (Asynchrony resilience).</h6>

    <p class="text-gray-300">RLMD-GHOST is <span class="math">(\\eta,\\eta-1)</span>-asynchrony-resilient.</p>

    <h6 id="sec-64" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider an <span class="math">(\\eta,\\eta-1)</span>-compliant execution, with a <span class="math">(\\eta-1)</span>-tpa <span class="math">(t_{1},t_{2})</span>, and an honest proposal <span class="math">B</span> from a slot <span class="math">t\\leq t_{1}</span> after GST + <span class="math">\\Delta</span>. First, since synchrony holds for slots <span class="math">[t,t_{1}]</span>, and thus network synchrony holds until round <span class="math">3\\Delta t_{1}+2\\Delta</span>, all the properties of RLMD-GHOST hold until then, including reorg resilience. In particular, starting from round <span class="math">\\geq 3\\Delta t+\\Delta</span>, <span class="math">B</span> is in the canonical chain of all active validators in those slots, as they coincide with the aware validators. We then only need to consider aware validators at slots <span class="math">s&gt;t_{1}</span>. Suppose <span class="math">B</span> is in the canonical chain of all aware validators at all slots <span class="math">&lt;s</span>. In particular, <span class="math">B\\preceq\\mathsf{ch}_{i}^{r}</span> for a validator <span class="math">v_{i}\\in H_{t_{1}}</span> which is active at a round <span class="math">r\\in[3\\Delta t_{1}+\\Delta,3\\Delta(s-1)+\\Delta]</span>, because validators in <span class="math">H_{t_{1}}</span> are always aware when active. Therefore, validators in <span class="math">H_{t_{1}}\\setminus A_{s}</span> only ever broadcast votes for descendants of <span class="math">B</span> in slots <span class="math">[t_{1},s-1]</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider first the case <span class="math">s\\in(t_{1},t_{2}]</span>. Then, the aware validators at a round <span class="math">r\\in\\{3\\Delta s,3\\Delta s+\\Delta\\}</span> are exactly the validators <span class="math">H_{t_{1}}</span> which are active in <span class="math">r</span>. Consider then such a validator <span class="math">v_{i}\\in H_{t_{1}}</span>, and its view <span class="math">\\mathcal{V}_{i}</span> at round <span class="math">r</span>. View <span class="math">\\mathcal{V}_{i}</span> contains all honest votes from slot <span class="math">t_{1}</span> because, by definition of <span class="math">(\\eta-1)</span>-tpa, <span class="math">v_{i}</span> was awake at round <span class="math">3\\Delta t_{1}+2\\Delta</span>, at which point it received all honest votes from slot <span class="math">t_{1}</span> and merged them into its view. Such votes are not expired at slot <span class="math">s</span>, since <span class="math">t_{2}-t_{1}\\leq\\eta-1</span> implies <span class="math">t_{1}&gt;t_{2}-\\eta\\geq s-\\eta</span>, <em>i.e.</em>, <span class="math">t_{1}</span> is within the expiry period <span class="math">[s-\\eta,s-1]</span> for slot <span class="math">s</span>. All validators in <span class="math">H_{t_{1}}\\setminus A_{s}</span> are not equivocators in <span class="math">\\mathcal{V}_{i}</span>, since they are not corrupted by round <span class="math">3\\Delta s+\\Delta</span>. Therefore, their latest votes in <span class="math">\\mathcal{V}_{i}</span> all count for a descendant of <span class="math">B</span> in <span class="math">\\mathcal{V}_{i}</span>. The other votes which are counted in <span class="math">\\mathcal{V}_{i}</span> are those from <span class="math">A_{s}</span> and <span class="math">H_{s-\\eta,s-1}\\setminus H_{t_{1}}</span>. Since the execution is <span class="math">(\\eta,\\eta-1)</span>-compliant, we have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{t_{1}}\\setminus A_{s}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{s}\\cup(H_{s-\\eta,s-1}\\setminus H_{t_{1}})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and thus </span>B<span class="math"> is canonical in </span>\\mathcal{V}_{i}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider now the case <span class="math">s=t_{2}+1</span>. Now, aware views coincide with active views, so we let <span class="math">\\mathcal{V}_{j}</span> be the view of an active validator <span class="math">v_{j}</span> at a round <span class="math">r\\in\\{3\\Delta(t_{2}+1),3\\Delta(t_{2}+1)+\\Delta\\}</span>. Since synchrony holds from slot <span class="math">t_{2}</span>, view <span class="math">\\mathcal{V}_{j}</span> contains all latest votes from <span class="math">H_{t_{1}}\\setminus A_{t_{2}+1}</span>, which are all from slots <span class="math">[t_{1},t_{2}]</span>, and thus for descendants of <span class="math">B</span> by assumption. Moreover, <span class="math">t_{1}\\geq t_{2}-(\\eta-1)=(t_{2}+1)-\\eta</span>, so all such votes are not expired at slot <span class="math">t_{2}+1</span>. We can again conclude that <span class="math">B</span> is canonical in <span class="math">\\mathcal{V}_{j}</span>, because $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{t_{1}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{s}\\cup(H_{s-\\eta,s-1}\\setminus H_{t_{1}})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> holds for </span>s=t_{2}+1$ as well.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, suppose <span class="math">s&gt;t_{2}+1</span>. Since aware and active views coincide at slot <span class="math">s-1</span>, <span class="math">B</span> is canonical in all active views at slot <span class="math">s-1</span> by assumption, so all honest votes from slot <span class="math">s-1</span> are for a descendant of <span class="math">B</span>. Since synchrony holds as well, we can apply 1 and conclude that <span class="math">B</span> is canonical at all active views at slot <span class="math">s</span>. ∎</p>

    <p class="text-gray-300">For RLMD-GHOST with <span class="math">\\eta\\leq 2</span>, Theorem 8 does not say anything, because a <span class="math">\\pi</span>-tpa is empty for <span class="math">\\pi\\leq 1</span>. For <span class="math">\\eta=1</span>, this is entirely to be expected, given the limitations of Goldfish in this sense.</p>

    <p class="text-gray-300">6 Related works</p>

    <p class="text-gray-300">The sleepy model of consensus, introduced by Pass and Shi <em>[18]</em>, abstracts the functioning implicitly introduced by the Bitcoin protocol <em>[14]</em>, modeling a distributed system in which participants can be either online or offline; in other words, where the participation is dynamic, assuming only that at any given time a majority of online participants are honest. Moreover, Pass and Shi show that the longest chain protocol is safe and live within its model, i.e., that it is dynamically available. Longest chain protocols are also meaningfully resilient to temporary asynchrony: the deeper a block is in the longest chain, the longer the period of asynchrony required for it to be reorged. In other words, blocks accumulate safety over time. On the other end, longest chain protocols are not reorg resilient, as newly proposed blocks can displace those at the tip of the chain.</p>

    <p class="text-gray-300">Other than longest chain, to our knowledge only two other types of dynamically available protocols have been designed so far. One is Goldfish <em>[7]</em>, a variant of LMD-GHOST <em>[5, 23]</em> which we have discussed extensively in this work. Unlike longest chain protocols, Goldfish is reorg resilient, but not at all tolerant of asynchrony. Finally, another class of approaches to integrate dynamic participation within a consensus protocol has been recently devised <em>[13, 12]</em>. Similarly to Goldfish, these do not tolerate even temporary asynchrony, raising the same questions about the practicality of their usage.</p>

    <p class="text-gray-300">Momose and Ren <em>[13]</em> present a quorum-based atomic broadcast protocol in the sleepy model that simultaneously supports dynamic participation, albeit requiring periods of stable participation for liveness, and achieves constant latency. They extend the classic BFT approach from static quorum size to dynamic quorum size, i.e., according to the current participation level, while preserving properties of static quorum. In particular, their protocol is built upon a graded agreement protocol using a quorum-based design.</p>

    <p class="text-gray-300">Malkhi, Momose, and Ren <em>[12]</em> improves on the latency of Momose and Ren <em>[13]</em>, and present a synchronous protocol that is live under fully fluctuating participation. They present a Byzantine atomic broadcast protocol in the sleepy model <em>[18]</em> with 3 round latency, but tolerating only one-third Byzantine nodes, rather than one-half. This solution has been recently improved <em>[19]</em> achieving optimal <span class="math">\\frac{1}{2}</span> corruption threshold.</p>

    <h2 id="sec-65" class="text-2xl font-bold">7 Conclusion and future work</h2>

    <p class="text-gray-300">Dynamically available protocols have recently been explored in the context of blockchain protocols, based on (variants of) the sleepy model <em>[18]</em>. In this work we presented a generalization of this model, with more generalized and stronger constraints in the corruption and sleepiness power of the adversary, and we formally proved properties and limitations of (a variant of) LMD-GHOST <em>[23]</em>, the dynamically available component of Gasper <em>[5]</em>, Goldfish <em>[7]</em>, a synchronous dynamically available and reorg resilient protocol, and RLMD-GHOST, our novel protocol. Table 1 summarizes the properties achieved by these protocols. RLMD-GHOST results in a provably secure synchronous dynamically available protocol that can be regarded as a potential future substitute for the existing LMD-GHOST component in Gasper.</p>

    <p class="text-gray-300">A characterization through components of Gasper has been first formalized by Neu, Tas, and Tse <em>[16]</em>. Motivated by understanding Gasper <em>[5]</em> design goals, the authors introduce the partially synchronous sleepy model, and then define the desiderata of the Ethereum’s consensus protocol through the notion of an ebb-and-flow protocol. In the partially synchronous sleepy model, (i) before a global stabilization time (GST) message delays are chosen by an adversary, and after that the network becomes synchronous, with delay upper-bound <span class="math">\\Delta</span>, and (ii) before a global awake time (GAT) the adversary can set any sleeping schedule for the participants, and after that all honest participants become awake. In particular, a (secure) ebb-and-flow protocol is constituted by both a dynamically available protocol that, if GST = 0, i.e., under synchrony, is guaranteed to be safe and live at all times (according to Definition 4), and a finalizing protocol that is guaranteed to be safe at all times, and live after <span class="math">\\max\\{\\textsf{GST},\\textsf{GAT}\\}</span>. In the context of Gasper, the former is represented by LMD-GHOST, while the latter by Casper <em>[4]</em>. Understanding the interaction between RLMD-GHOST and a finality component is an interesting open problem, especially with respect to asynchrony. Specifically, we reserve for future research the development of a secure ebb-and-flow protocol which incorporates RLMD-GHOST as a dynamically available component, along with a partially synchronous finality component. Moreover, it is an open question whether the techniques of this work can be applied to the family of quorum-based dynamically</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Dynamic Availability</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Asynchrony Resilience</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">LMD-GHOST</td>

            <td class="px-3 py-2 border-b border-gray-700">X (only τ = ∞, Theorem 4)</td>

            <td class="px-3 py-2 border-b border-gray-700">✓ (τ, π = ∞, Theorem 8)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Goldfish</td>

            <td class="px-3 py-2 border-b border-gray-700">✓ (τ = 1, Theorem 7)</td>

            <td class="px-3 py-2 border-b border-gray-700">X (Theorem 5)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">RLMD-GHOST, expiry period η</td>

            <td class="px-3 py-2 border-b border-gray-700">✓ (τ = η, Theorem 7)</td>

            <td class="px-3 py-2 border-b border-gray-700">✓ (τ, π = η, η - 1, Theorem 8)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: The properties achieved by LMD-GHOST with view-merge and no subsampling (Section 4.2), Goldfish (Section 4.3), and RLMD-GHOST with expiry period  <span class="math">\\eta \\in (1,\\infty)</span>  (Section 5).</p>

    <p class="text-gray-300">available protocols [13, 12], to strengthen their resilience of asynchrony at the cost of weakened tolerance to dynamic participation, as we have done with Goldfish.</p>

    <p class="text-gray-300">[1] Aditya Asgaonkar. Remove equivocating placeholders from fork choice consideration. URL: https://github.com/ethereum/consensus-specs/pull/2845. [2] Dan Boneh, Saba Eskandarian, Lucjan Hanzlik, and Nicola Greco. Single secret leader election. In AFT '20: 2nd ACM Conference on Advances in Financial Technologies, New York, NY, USA, October 21-23, 2020, pages 12-24. ACM, 2020. doi:10.1145/3419614.3423258. [3] Vitalik Buterin. Proposal for mitigation against balancing attacks to lmd ghost. URL: https://notes.ethereum.org/@vbuterin/lmd_ghost_mitigation. [4] Vitalik Buterin and Virgil Griffith. Casper the friendly finality gadget. CoRR, abs/1710.09437, 2017. URL: http://arxiv.org/abs/1710.09437, arXiv:1710.09437. [5] Vitalik Buterin, Diego Hernandez, Thor Kamphefner, Khiem Pham, Zhi Qiao, Danny Ryan, Juhyeok Sin, Ying Wang, and Yan X Zhang. Combining GHOST and Casper. arXiv:2003.03052 [cs.CR], 2020. URL: https://arxiv.org/abs/2003.03052. [6] Francesco D'Amato. View-merge as a replacement for proposer boost. URL: https://ethresear.ch/t/view-merge-as-a-replacement-for-proposer-boost/13739. [7] Francesco D'Amato, Joachim Neu, Ertem Nusret Tas, and David Tse. No more attacks on proof-of-stake ethereum? CoRR, abs/2209.03255, 2022. arXiv:2209.03255, doi:10.48550/arXiv.2209.03255. [8] Seth Gilbert and Nancy A. Lynch. Brewer's conjecture and the feasibility of consistent, available, partition-tolerant web services. SIGACT News, 33(2):51-59, 2002. [9] George Kadianakis. Whisk: A practical shuffle-based ssle protocol for ethereum. URL: https://ethresear.ch/t/whisk-a-practical-shuffle-based-ssle-protocol-for-ethereum/11763. [10] Daniel Kane, Andreas Fackler, Adam Gagol, and Damian Straszak. Highway: Efficient consensus with flexible finality. CoRR, abs/2101.02159, 2021. URL: https://arxiv.org/abs/2101.02159, arXiv:2101.02159. [11] Andrew Lewis-Pye and Tim Roughgarden. Resource pools and the CAP theorem. CoRR, abs/2006.10698, 2020. URL: https://arxiv.org/abs/2006.10698. [12] Dahlia Malkhi, Atsuki Momose, and Ling Ren. Byzantine consensus under fully fluctuating participation. IACR Cryptol. ePrint Arch., page 1448, 2022. URL: https://eprint.iacr.org/2022/1448. [13] Atsuki Momose and Ling Ren. Constant latency in sleepy consensus. In Heng Yin, Angelos Stavrou, Cas Cremers, and Elaine Shi, editors, Proceedings of the 2022 ACM SIGSAC Conference on Computer and Communications Security, CCS 2022, Los Angeles, CA, USA, November 7-11, 2022, pages 2295-2308. ACM, 2022. doi:10.1145/3548606.3559347.</p>

    <p class="text-gray-300">[14] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system, Dec 2008. Accessed: 2015-07-01. URL: https://bitcoin.org/bitcoin.pdf.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[15] Joachim Neu, Ertem Nusret Tas, and David Tse. Attacking Gasper without adversarial network delay, 2021. URL: https://ethresear.ch/t/attacking-gasper-without-adversarial-network-delay/10187.</li>

      <li>[16] Joachim Neu, Ertem Nusret Tas, and David Tse. Ebb-and-flow protocols: A resolution of the availability-finality dilemma. In 42nd IEEE Symposium on Security and Privacy, SP 2021, San Francisco, CA, USA, 24-27 May 2021, pages 446–465. IEEE, 2021.</li>

      <li>[17] Joachim Neu, Ertem Nusret Tas, and David Tse. The availability-accountability dilemma and its resolution via accountability gadgets. In International Conference on Financial Cryptography and Data Security, FC ’22, 5 2022. URL: https://arxiv.org/abs/2105.06075.</li>

      <li>[18] Rafael Pass and Elaine Shi. The sleepy model of consensus. In ASIACRYPT (2), volume 10625 of Lecture Notes in Computer Science, pages 380–409. Springer, 2017.</li>

      <li>[19] Chainlink Labs Research. Minority corruption resilience in byzantine generals with unknown and fluctuating participation, 2022. URL: https://blog.chain.link/minority-corruption-resilience-in-byzantine-generals-with-unknown-and-fluctuating-participation/.</li>

      <li>[20] Caspar Schwarz-Schilling, Joachim Neu, Barnabé Monnot, Aditya Asgaonkar, Ertem Nusret Tas, and David Tse. Three attacks on proof-of-stake ethereum. In Ittay Eyal and Juan A. Garay, editors, Financial Cryptography and Data Security - 26th International Conference, FC 2022, Grenada, May 2-6, 2022, Revised Selected Papers, volume 13411 of Lecture Notes in Computer Science, pages 560–576. Springer, 2022.</li>

      <li>[21] Caspar Schwarz-Schilling, Joachim Neu, Barnabé Monnot, Aditya Asgaonkar, Ertem Nusret Tas, and David Tse. Three attacks on proof-of-stake ethereum. In International Conference on Financial Cryptography and Data Security, FC ’22, 2022. Forthcoming. URL: https://arxiv.org/abs/2110.10086.</li>

      <li>[22] Yonatan Sompolinsky and Aviv Zohar. Secure high-rate transaction processing in Bitcoin. In International Conference on Financial Cryptography and Data Security, pages 507–527. Springer, 2015.</li>

      <li>[23] Vlad Zamfir. Casper the friendly ghost. a correct-by-construction blockchain consensus protocol. URL: https://github.com/vladzamfir/research/blob/master/papers/CasperTFG/CasperTFG.pdf.</li>

    </ul>

    <h2 id="sec-67" class="text-2xl font-bold">Appendix A Limitations of RLMD-GHOST</h2>

    <p class="text-gray-300">We first show limitations on the reorg resilience of RLMD-GHOST when <span class="math">\\eta&gt;\\tau</span>, except for <span class="math">\\eta=1</span>, i.e., Goldfish. We construct a <span class="math">\\tau</span>-compliant execution in which old, unexpired votes of honest validators which are currently asleep are used by the adversary to fuel a reorg.</p>

    <h6 id="sec-68" class="text-base font-medium mt-4">Theorem 9.</h6>

    <p class="text-gray-300">RLMD-GHOST is not <span class="math">\\tau</span>-reorg-resilient for any <span class="math">1\\leq\\tau&lt;\\eta</span>.</p>

    <h6 id="sec-69" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We prove this theorem with an example. Let us consider a validator set of size <span class="math">n=2m+1</span>, partitioned in three sets, <span class="math">V_{1}</span>, <span class="math">V_{2}</span>, and <span class="math">V_{3}</span>, with <span class="math">V_{1}=\\{v_{1}\\}</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=m+1<span class="math">, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_{3}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=m-1<span class="math">. Validators in </span>V_{2}<span class="math"> and </span>V_{3}<span class="math"> are all initially honest, while </span>v_{1}<span class="math"> is adversarial. Let </span>t-1<span class="math"> and </span>t<span class="math"> be two adversarial slots, i.e., controlled by </span>v_{1}<span class="math">. In slot </span>t<span class="math">, validator </span>v_{1}<span class="math"> publishes conflicting blocks </span>A<span class="math"> and </span>B<span class="math">, one as a proposal for slot </span>t-1<span class="math"> and the other for slot </span>t<span class="math">. By round </span>3\\Delta t+\\Delta<span class="math">, the adversary delivers only </span>A<span class="math"> to validators in </span>V_{2}<span class="math">, and only </span>B<span class="math"> to validators in </span>V_{3}<span class="math">, so that the former vote for </span>A<span class="math"> and the latter for </span>B<span class="math"> in slot </span>t<span class="math">. At this point, the adversary puts all validators in </span>V_{3}<span class="math"> to sleep, and then does nothing until slot </span>t+\\eta-1<span class="math">. Meanwhile, validators in </span>V_{2}<span class="math"> keep voting for </span>A<span class="math">, since </span>V_{2}<span class="math"> contains </span>m+1>\\frac{n}{2}<span class="math"> validators, so </span>A<span class="math"> stays canonical in all of the views of every member of </span>V_{2}<span class="math">. Suppose in particular that the proposer of slot </span>t+1<span class="math"> is in </span>V_{2}<span class="math">, so that it makes a proposal </span>C<span class="math"> extending </span>A<span class="math">. We now show that the adversary can induce a reorg of </span>C<span class="math">, exploiting the votes of the asleep validators </span>V_{3}<span class="math">, so that reorg resilience is not satisfied in this execution. We then only have to show that the execution is </span>\\tau<span class="math">-compliant, in order to show that the protocol is not </span>\\tau$-reorg-resilient.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">At the voting round <span class="math">3\\Delta(t+\\eta-1)+\\Delta</span>, the adversary votes for <span class="math">B</span> with <span class="math">v_{1}</span>. After the voting round, it corrupts two validators <span class="math">v_{2},v_{3}\\in V_{2}</span>, and starts voting for <span class="math">B</span> with them, broadcasting late votes for slot <span class="math">t+\\eta-1</span>. These votes are delivered to all awake validators by round <span class="math">3\\Delta(t+\\eta-1)+2\\Delta</span>, and are therefore in all of their views at the voting round of slot <span class="math">t+\\eta</span>. The votes of <span class="math">v_{2}</span> and <span class="math">v_{3}</span> are equivocations, so they are discounted, both for <span class="math">B</span> and for <span class="math">A</span>. Slot <span class="math">t</span> is in <span class="math">[t,t+\\eta)</span>, the expiration period for slot <span class="math">t+\\eta</span>, so the votes of <span class="math">V_{3}</span> count at this slot. Therefore, in all views of the remaining honest validators in <span class="math">V_{2}</span>, <span class="math">B</span> has <span class="math">m</span> votes, i.e., those of <span class="math">V_{3}</span> and <span class="math">v_{1}</span>, and descendants of <span class="math">A</span> only <span class="math">m-1</span>, because two have been discounted. <span class="math">B</span> is then canonical in such views, and reorg resilience (of <span class="math">C</span>) is violated. The adversary does not perform any more corruptions nor puts to sleep any more validators, and does not wake up validators in <span class="math">V_{3}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We now show that this execution is <span class="math">\\tau</span>-compliant. For any slot <span class="math">s</span>, we show that <span class="math">\\tau</span>-sleepiness holds at slot <span class="math">s</span>, i.e., that Equation 1 holds. For any slot <span class="math">s\\leq t+1</span>, this is clear, because we have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{s-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_{2}\\cup V_{3}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2m>1=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{s}\\cup(H_{s-\\tau,s-2}\\setminus H_{s-1})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. For any slot </span>s\\in[t+2,t+\\eta-1]<span class="math">, we have </span>H_{s-1}=V_{2}<span class="math"> and </span>A_{s}=V_{1}<span class="math">, because the two corruptions only happen after round </span>3\\Delta(t+\\eta-1)+\\Delta<span class="math">. Therefore, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{s-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=m+1>m=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_{1}\\cup V_{3}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{s}\\cup(H_{s-\\tau,s-2}\\setminus H_{s-1})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, so </span>\\tau<span class="math">-sleepiness is satisfied. For any slot </span>s\\geq t+\\eta<span class="math">, we have </span>A_{s}=\\{v_{1},v_{2},v_{3}\\}<span class="math">, </span>V_{2}\\setminus\\{v_{2},v_{3}\\}\\subseteq H_{s-1}<span class="math"> and </span>H_{s-\\tau,s-2}\\setminus H_{s-1}=\\emptyset<span class="math">, because </span>\\eta>\\tau<span class="math"> implies </span>s-\\tau\\geq t+\\eta-\\tau>t<span class="math">, so </span>V_{3}\\cap H_{s-\\tau,s-2}=\\emptyset<span class="math">. </span>\\tau<span class="math">-sleepiness is then satisfied, because </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{s-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq m-1>3=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{s}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{s}\\cup H_{s-\\tau,s-2}\\setminus H_{s-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Since the execution is </span>\\tau<span class="math">-compliant, but does not satisfy reorg resilience, the protocol is not </span>\\tau$-reorg-resilient. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The second limitative result we present concerns dynamic availability. Unsurprisingly, an expiry period <span class="math">\\eta&gt;\\tau</span> means that RLMD-GHOST is also not <span class="math">\\tau</span>-dynamically-available.</p>

    <h6 id="sec-70" class="text-base font-medium mt-4">Theorem 10.</h6>

    <p class="text-gray-300">RLMD-GHOST is not <span class="math">\\tau</span>-dynamically-available for any <span class="math">1\\leq\\tau&lt;\\eta</span> and for any confirmation rule with <span class="math">T_{\\mathsf{conf}}&lt;\\lfloor\\frac{n-5}{4}\\rfloor\\eta=O(\\eta\\cdot n)</span> slots. In particular, it is not <span class="math">\\tau</span>-dynamically available with the <span class="math">\\kappa</span>-deep confirmation rule, for <span class="math">\\kappa&lt;\\lfloor\\frac{n-5}{4}\\rfloor\\eta</span>.</p>

    <h6 id="sec-71" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider a validator set of size <span class="math">n=2m+1</span>, partitioned in three sets, <span class="math">\\mathcal{C}_{0}</span>, <span class="math">\\mathcal{A}_{0}</span>, and <span class="math">\\mathcal{S}_{0}</span>, standing for corrupted, active, and sleepy, respectively, with <span class="math">\\mathcal{C}_{0}=\\{v_{1}\\}</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{A}_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=m+2<span class="math">, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{S}_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=m-2<span class="math">. Validators in </span>\\mathcal{A}_{0}<span class="math"> and </span>\\mathcal{S}_{0}<span class="math"> are all initially honest, while </span>v_{1}<span class="math"> is adversarial. Let </span>t-1<span class="math"> and </span>t<span class="math"> be two adversarial slots, i.e., controlled by </span>v_{1}<span class="math">. In slot </span>t<span class="math">, validator </span>v_{1}<span class="math"> publishes conflicting blocks </span>A<span class="math"> and </span>B<span class="math">, one as a proposal for slot </span>t-1<span class="math"> and the other for slot </span>t<span class="math">. By round </span>3\\Delta t+\\Delta<span class="math">, the adversary delivers only </span>A<span class="math"> to validators in </span>\\mathcal{A}_{0}<span class="math">, and only </span>B<span class="math"> to validators in </span>\\mathcal{S}_{0}<span class="math">, so that the former vote for </span>A<span class="math"> and the latter for </span>B<span class="math"> in slot </span>t$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">At this point, the adversary puts all validators in <span class="math">\\mathcal{S}_{0}</span> to sleep, and then does nothing until immediately after round <span class="math">3\\Delta(t+\\eta-2)+\\Delta</span>, i.e., the voting round of slot <span class="math">t+\\eta-2</span>, at which point it corrupts two validators <span class="math">\\{v_{2},v_{3}\\}\\in\\mathcal{A}_{0}</span>. Up until this point, all validators in <span class="math">\\mathcal{A}_{0}</span> have kept voting for <span class="math">A</span>, since $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{A}_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=m+2>\\frac{n}{2}<span class="math"> validators. At slot </span>t+\\eta-1<span class="math">, the adversarial validators initially do not broadcast votes. By round </span>3\\Delta(t+\\eta-1)+2\\Delta<span class="math">, the adversary wakes up validators in </span>\\mathcal{S}_{0}<span class="math">, so that they are active in slot </span>t+\\eta<span class="math">. At slot </span>t+\\eta<span class="math">, the adversary publishes three votes for </span>B<span class="math"> from slot </span>t+\\eta-1<span class="math">, from validators </span>\\{v_{1},v_{2},v_{3}\\}<span class="math">. By round </span>3\\Delta(t+\\eta)+\\Delta<span class="math">, it delivers these only to validators in </span>\\mathcal{A}_{0}<span class="math">. Since the expiration period </span>[t,t+\\eta-1]<span class="math"> for slot </span>t+\\eta<span class="math"> contains </span>t<span class="math">, the votes of </span>\\mathcal{S}_{0}<span class="math"> count at slot </span>t+\\eta<span class="math">. Therefore, in the views of the validators in </span>\\mathcal{S}_{0}<span class="math"> at slot </span>t+\\eta<span class="math">, descendants of </span>A<span class="math"> have a total of </span>m+2<span class="math"> votes, from all validators in </span>\\mathcal{A}_{0}<span class="math">, including the newly corrupted ones, while </span>B<span class="math"> only has </span>m-2<span class="math"> votes from </span>\\mathcal{S}_{0}<span class="math">. Thus, </span>A<span class="math"> is canonical in their views, and they vote for it. The views of the </span>m<span class="math"> remaining honest validators in </span>\\mathcal{A}_{0}<span class="math"> also include the three adversarial votes for </span>B<span class="math"> from slot </span>t+\\eta-1<span class="math">, so descendants of </span>A<span class="math"> only have </span>m<span class="math"> votes, while </span>B<span class="math"> has </span>m+1<span class="math">. </span>B<span class="math"> then is canonical in their views, and they vote for it. The three adversarial validators also do so, so </span>B<span class="math"> receives </span>m+3<span class="math"> votes and is canonical in the following slots. After the voting round of slot </span>t+\\eta<span class="math">, the adversary then puts all but two of the </span>m-2<span class="math"> validators in </span>\\mathcal{S}_{0}$ to sleep.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In slot <span class="math">t+\\eta+1</span>, there are then <span class="math">m+2</span> active validators: the two which are still active from <span class="math">\\mathcal{S}_{0}</span>, and <span class="math">m</span> which are still honest from <span class="math">\\mathcal{A}_{0}</span>. There are also three adversarial validators and <span class="math">m-4</span> validators from <span class="math">\\mathcal{S}_{0}</span> asleep from the previous slot. We are therefore in the same situation as in slot <span class="math">t+1</span>, except we have two more adversarial validators (from <span class="math">\\mathcal{A}_{0}</span>) and two less asleep validators (from <span class="math">\\mathcal{S}_{0}</span>). We let <span class="math">\\mathcal{C}_{1}</span> be the three adversarial validators, <span class="math">\\mathcal{A}_{1}</span> be the <span class="math">m+2</span> active validators and <span class="math">\\mathcal{S}_{1}</span> be the <span class="math">m-4</span> asleep validators. The adversary repeats the same pattern. It corrupts two more validators from <span class="math">\\mathcal{A}_{1}</span> after the voting round of slot <span class="math">(t+\\eta)+(\\eta-2)=t+2\\eta-2</span>, and at round <span class="math">3\\Delta(t+2\\eta-1)+2\\Delta</span> wakes up all validators in <span class="math">\\mathcal{S}_{0}</span> so that they are active by slot <span class="math">t+2\\eta</span>. It then votes with all of the five adversarial validators for the branch of <span class="math">A</span> at slot <span class="math">t+2\\eta-1</span>, but delivers such votes only to validators in <span class="math">\\mathcal{A}_{1}</span> by the voting round of slot <span class="math">t+2\\eta</span>. Then, at slot <span class="math">t+2\\eta</span>, the branch of <span class="math">A</span> has <span class="math">m+1</span></p>

    <p class="text-gray-300">votes in the views of validators in <span class="math">\\mathcal{A}_{1}</span>, <em>i.e.</em>, the adversarial votes plus the votes from the <span class="math">m-4</span> validators in <span class="math">\\mathcal{S}_{1}</span>, which were put to sleep after voting for <span class="math">A</span> at slot <span class="math">t+\\eta</span>. Therefore, it is canonical in their views and they vote for it, and so does the adversary. On the other hand, the views of validators in <span class="math">\\mathcal{S}_{1}</span> at that round do not include the adversarial votes for <span class="math">A</span>, and so all validators in <span class="math">\\mathcal{S}_{1}</span> vote for <span class="math">B</span>.</p>

    <p class="text-gray-300">All but <em>four</em> of them are now put to sleep, so that at slot <span class="math">t+2\\eta+1</span> there are <span class="math">m+2</span> active validators, <span class="math">m-6</span> asleep validators and five adversarial validators. We let these new sets of validators be <span class="math">\\mathcal{A}_{2},\\mathcal{S}_{2},\\mathcal{C}_{2}</span>, respectively. Again, the adversary has reorged from one branch to the other, while only needing to corrupt two asleep validators into two adversarial validators, and while otherwise preserving the same setup. They can repeat this until the number of adversarial validators reaches <span class="math">m-1</span>, which does not allow for two additional corruptions. After the <span class="math">k^{th}</span> reorg, at slot <span class="math">t+k\\eta+1</span>, there are <span class="math">m+2</span> active validators <span class="math">\\mathcal{A}_{k}</span>, <span class="math">2k+1</span> adversarial validators <span class="math">\\mathcal{C}_{k}</span>, and <span class="math">m-2(k+1)</span> asleep validators <span class="math">\\mathcal{S}_{k}</span>. Therefore, the adversary can repeat this up to <span class="math">k\\leq\\lfloor\\frac{m-2}{2}\\rfloor=\\lfloor\\frac{n-5}{4}\\rfloor</span> times. Each time they do so, they can reorg from one branch to the other after <span class="math">\\eta</span> slots, for a total of <span class="math">\\lfloor\\frac{n-5}{4}\\rfloor\\eta</span> slots. By assumption, <span class="math">T_{\\mathsf{conf}}&lt;\\lfloor\\frac{n-5}{4}\\rfloor\\eta</span> slots. If no confirmation has been made after <span class="math">T_{\\mathsf{conf}}</span> slots, then liveness is violated. If one has been made, then the confirmed block can still be reorged by slot <span class="math">\\lfloor\\frac{n-5}{4}\\rfloor\\eta</span>, and the conflicting branch eventually confirmed afterwards, violating safety.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To complete the proof, we only need to verify that <span class="math">\\tau</span>-sleepiness is satisfied. For slots <span class="math">s\\leq t</span>, we have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{s-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2m>1=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{s}\\cup(H_{s-\\tau,s-2}\\setminus H_{s-1})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, so it is indeed satisfied. Consider now some </span>1\\leq k\\leq\\frac{m-2}{2}<span class="math">, and slots </span>[t+(k-1)\\eta+1,t+k\\eta]<span class="math">. For </span>s\\in[t+(k-1)\\eta+1,t+k\\eta-1]<span class="math">, we have </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{s-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{A}_{k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=m+2<span class="math">, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{s}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2k+1<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{s-\\tau,s-2}\\setminus H_{s-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{S}_{k-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=m-2k<span class="math">, so </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{s-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq m+2>m+1=(2k+1)+(m-2k)\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{s}\\cup(H_{s-\\tau,s-2}\\setminus H_{s-1})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and </span>\\tau<span class="math">-sleepiness at slot </span>s<span class="math"> is satisfied. For </span>s=t+k\\eta<span class="math">, we have </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{s-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=m<span class="math">, because two more validators have been corrupted, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{s}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2k+1<span class="math">, and </span>H_{s-\\tau,s-2}\\setminus H_{s-1}=\\emptyset<span class="math">, because </span>\\tau<\\eta<span class="math"> implies </span>s-\\tau=t+k\\eta-\\tau>t+(k-1)\\eta<span class="math">, which is the last slot in which </span>\\mathcal{S}_{k-1}<span class="math"> were active . Since </span>2k+2\\leq m<span class="math">, we have that </span>2k+1<m<span class="math">, so </span>\\tau<span class="math">-sleepiness at slot </span>t+k\\eta<span class="math"> is indeed satisfied. In slots after the last reorg, all honest validators are active, and there are </span>\\geq m+2>\\frac{n}{2}<span class="math"> of them, so </span>\\tau$-sleepiness is also satisfied. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-72" class="text-base font-medium mt-4">Theorem 11.</h6>

    <p class="text-gray-300">RLMD-GHOST with finite <span class="math">\\eta</span> is not <span class="math">(\\tau,\\pi)</span>-asynchrony-resilient for any <span class="math">\\tau&gt;\\pi\\geq\\max(\\eta,2)</span>, nor for <span class="math">\\tau=\\pi=\\infty</span>.</p>

    <h6 id="sec-73" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We have to show that RLMD-GHOST is not asynchrony resilient for any <span class="math">\\tau&gt;\\pi\\geq\\eta</span>, which we do by showing that RLMD-GHOST is not <span class="math">(\\infty,\\pi)</span>-asynchrony-resilient, by constructing an <span class="math">(\\infty,\\eta)</span>-compliant execution in which asynchrony-resilience does not hold. Since <span class="math">E_{\\tau,\\pi}</span> is monotonically decreasing in <span class="math">\\tau</span> and monotonically increasing in <span class="math">\\pi</span>, <span class="math">E_{\\infty,\\eta}\\subset E_{\\tau,\\pi}</span> for any <span class="math">\\tau&gt;\\pi\\geq\\eta</span>, and similarly <span class="math">E_{\\infty,\\eta}\\subset E_{\\infty,\\infty}</span>, so the desired result follows. We consider a validator set <span class="math">\\{v_{1},v_{2},v_{3}\\}</span>, where all validators are honest at all times, and consider an execution with a <span class="math">\\eta</span>-tpa <span class="math">(t,t+\\eta)</span>, which is <span class="math">\\neq\\emptyset</span> since <span class="math">\\eta\\geq 2</span>. In particular, network synchrony does not hold at slot <span class="math">t+\\eta-1</span>. Before round <span class="math">3\\Delta(t+\\eta-1)+2\\Delta</span>, validator <span class="math">v_{3}</span> is asleep. It wakes up at that round, and stays awake thereafter, so <span class="math">v_{3}\\in H_{s}</span> for <span class="math">s\\geq t+\\eta</span>. Both validators <span class="math">v_{1}</span> and <span class="math">v_{2}</span> are active at all rounds <span class="math">\\leq 3\\Delta t+2\\Delta</span>, so <span class="math">H_{s}=\\{v_{1},v_{2}\\}</span> for <span class="math">s\\leq t</span>. Validator <span class="math">v_{1}</span> subsequently falls asleep, and only wakes up again in round <span class="math">3\\Delta(t+\\eta)+2\\Delta</span>, while validator <span class="math">v_{2}</span> is always awake. Upon waking up at round <span class="math">3\\Delta(t+\\eta-1)+2\\Delta</span>, validator <span class="math">v_{3}</span> does not see any message before merging the buffer into its view, due to asynchrony. Validator <span class="math">v_{3}</span> is the proposer of slot <span class="math">t+\\eta</span>, and, due to the lack of messages in its view, it proposes a block <span class="math">B</span> extending <span class="math">B_{\\text{genesis}}</span>, which conflicts with all previous honest proposals. Validator <span class="math">v_{3}</span> then also votes for <span class="math">B</span> at slot <span class="math">t+\\eta</span>, while <span class="math">v_{2}</span> does not. All three honest validators are active at round <span class="math">3\\Delta(t+\\eta)+2\\Delta</span>, so they receive these votes and merge them into their view. The latest vote from <span class="math">v_{1}</span> is from slot <span class="math">t</span>, and is expired at slot <span class="math">t+\\eta+1</span>. Therefore, the only unexpired latest votes at the voting round of slot <span class="math">t+\\eta+1</span> are those from <span class="math">v_{2}</span> and <span class="math">v_{3}</span> from slot <span class="math">t+\\eta</span>. If <span class="math">B</span> wins the tiebreaker, it is then canonical in the views of the three validators. All honest proposals from slots <span class="math">\\leq t</span> are then not canonical in these active views, which are also aware views since we are at a slot <span class="math">&gt;t+\\eta</span>, so asynchrony-resilience is not satisfied in this execution. In order to show the desired result, we then only need to show that the execution is <span class="math">(\\infty,\\eta)</span>-compliant. For slots <span class="math">s\\not\\in(t,t+\\eta]</span>, we have to show that <span class="math">\\infty</span>-sleepiness holds. It suffices to show that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{s-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 2>\\frac{n}{2}<span class="math">. For </span>s\\leq t<span class="math">, we have </span>H_{s-1}=\\{v_{1},v_{2}\\}<span class="math">, while for </span>s>t+\\eta<span class="math"> we have </span>\\{v_{2},v_{3}\\}\\subseteq H_{s-1}<span class="math"> , so this is indeed the case. For slots </span>s\\in(t,t+\\eta+1]<span class="math">, we have </span>H_{t}\\setminus A_{s}=H_{t}=\\{v_{1},v_{2}\\}<span class="math">, so the condition which needs to hold during the </span>\\eta<span class="math">-tpa is satisfied. Moreover, </span>H_{t}<span class="math"> are awake at round </span>3\\Delta t+2\\Delta<span class="math">, satisfying even the last condition of </span>(\\infty,\\eta)$-compliance. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">We specify the protocol with fast confirmations and then analyze its properties. It requires a small modification to the generic propose-vote-merge protocol, changing the vote behavior so that validators vote as soon as they see a proposal, or at round  <span class="math">3\\Delta t + \\Delta</span> , whichever comes first (which is also exactly the attestation behavior specified by the Ethereum consensus protocol). In the following,  <span class="math">\\mathsf{FC} = \\mathsf{RLMD}</span> -GHOST.</p>

    <p class="text-gray-300">In the following, and in Algorithm 6, we update the confirmed chain explicitly, contrary to Algorithm 1. This is because the confirmed chain  <span class="math">\\mathsf{Ch}_i</span>  in the latter is at any point simply a function of the canonical chain  <span class="math">\\mathsf{ch}_i</span> , i.e.,  <span class="math">\\mathsf{Ch}_i = \\mathsf{ch}_i^{[\\kappa]}</span> . With fast confirmations, this is no longer the case. Moreover, in Algorithm 6 we use  <span class="math">\\mathsf{FIL}(\\mathcal{V}, t)</span> .  <span class="math">\\mathcal{V}</span>  to refer to the view output by a filter. Observe that validators (which have synchronized clocks) update the variables  <span class="math">t</span>  and  <span class="math">r</span>  representing slot and round, respectively, through the protocol's execution.</p>

    <p class="text-gray-300">PROPOSE: Unchanged from Section 3.2</p>

    <p class="text-gray-300">VOTE: In rounds  <span class="math">[3\\Delta t, 3\\Delta t + \\Delta]</span> , a validator  <span class="math">v_{i}</span> , upon receiving a proposal message [PROPOSE,  <span class="math">B</span> ,  <span class="math">\\mathcal{V}</span> ,  <span class="math">t</span> ,  <span class="math">v_{p}</span> ] from  <span class="math">v_{p}</span> , merges its view with the proposed view  <span class="math">\\mathcal{V}</span> . After doing so, or at round  <span class="math">3\\Delta t + \\Delta</span>  if no proposal is received, it updates its canonical chain by setting  <span class="math">\\mathsf{ch}_i \\gets \\mathsf{FC}(\\mathcal{V}_i, t)</span> , and broadcasts the vote message [VOTE,  <span class="math">\\mathsf{FC}(\\mathcal{V}_i, t)</span> ,  <span class="math">t</span> ,  <span class="math">v_{i}</span> ].</p>

    <p class="text-gray-300">CONFIRM: At round  <span class="math">3\\Delta t + \\Delta</span> , a validator  <span class="math">v_{i}</span>  merges its view with its buffer, i.e.,  <span class="math">\\mathcal{V}_i \\gets \\mathcal{V}_i \\cup \\mathcal{B}_i</span> , and sets  <span class="math">\\mathcal{B}_i \\gets \\emptyset</span> . It then selects for fast confirmation the highest canonical block  <span class="math">B_{\\mathrm{fast}} \\prec \\mathsf{ch}_i</span>  such that  <span class="math">\\mathcal{B}_i</span>  contains  <span class="math">\\geq \\frac{2}{3} n</span>  votes from slot  <span class="math">t</span>  for descendants of  <span class="math">B_{\\mathrm{fast}}</span> , from distinct validators. It then updates its confirmed chain  <span class="math">\\mathsf{Ch}_i</span>  to the highest of  <span class="math">B_{\\mathrm{fast}}</span>  and  <span class="math">\\mathsf{ch}_i^{[\\kappa]}</span> , the  <span class="math">\\kappa</span> -deep prefix of its canonical chain, as long as this does not result in updating  <span class="math">\\mathsf{Ch}_i</span>  to some prefix of it (we do not needlessly revert confirmations).</p>

    <p class="text-gray-300">MERGE: At round  <span class="math">3\\Delta t + 2\\Delta</span> , every validator  <span class="math">v_{i}</span>  merges its view with its buffer, i.e.,  <span class="math">\\mathcal{V}_i \\gets \\mathcal{V}_i \\cup \\mathcal{B}_i</span> , and sets  <span class="math">\\mathcal{B}_i \\gets \\emptyset</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The protocol with fast confirmations is safe when both fast confirmations and standard ( <span class="math">\\kappa</span> -deep) confirmations are safe, and live whenever at least one is live. In particular, liveness is guaranteed by the liveness of the standard confirmations. On the other hand, the safety resilience of this protocol can be worse than  <span class="math">\\frac{n}{2}</span> , which is what the original protocol tolerates when all honest validators are awake, since  <span class="math">\\eta</span> -sleepiness reduces to  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{t-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . In the previous section we have in particular specified fast confirmations to require a quorum of size  </span>\\frac{2}{3}n<span class="math"> , which results in both liveness and safety resilience of fast confirmations of  </span>\\frac{n}{3}<span class="math"> . We have chosen this quorum size because we are interested in using RLMD-GHOST in combination with a finality gadget, following the pattern of [16, 17], in which confirmations of the available protocol are input to the gadget, to preserve dynamic availability of the combined protocol. In this setting, we then want fast confirmations to require no further assumptions compared to the finality gadget, so that they can be live whenever the conditions are right for the gadget to be live, speeding up its action  </span>^{10}<span class="math"> . Due to this choice, safety resilience of the resulting protocol is then reduced to  </span>\\frac{n}{3}<span class="math">  as well (cf. Goldfish, where the chosen quorum is  </span>\\frac{3}{4}n<span class="math"> , so that the final protocol is still safe for  </span>f &lt; \\frac{n}{2}<span class="math"> ). On the other hand, we show in the next section that violating safety of a fast confirmation with quorum  </span>\\frac{2}{3}n<span class="math">  requires  </span>\\frac{n}{3}<span class="math">  equivocations, thus also making  </span>\\frac{n}{3}<span class="math">  validators slashable. Therefore, the security guarantee of the resulting protocol under network synchrony is that a safety violation requires either safety of standard confirmations to be violated, implying a violation of  </span>\\eta<span class="math"> -sleepiness, and in particular  </span>f \\geq \\frac{n}{2}<span class="math">  if all honest validators are awake, or  </span>\\frac{n}{3}$  adversarial validators have to be slashable for equivocation. All safety results in the next section follow this formulation.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Algorithm 6 Propose-vote-merge protocol for validator  <span class="math">v_{i}</span> 1: State 2:  <span class="math">\\mathcal{V}_i\\gets \\{B_{\\mathrm{genesis}}\\}</span>  : view of validator  <span class="math">v_{i}</span> 3:  <span class="math">\\mathcal{B}_i\\gets \\emptyset</span>  : buffer of validator  <span class="math">v_{i}</span> 4:  <span class="math">\\mathsf{ch}_i\\gets B_{\\mathrm{genesis}}</span>  : canonical chain of validator  <span class="math">v_{i}</span> 5:  <span class="math">\\mathsf{Ch}_i\\gets B_{\\mathrm{genesis}}</span>  : confirmed chain of validator  <span class="math">v_{i}</span> 6:  <span class="math">t\\gets 0</span>  : the current slot 7:  <span class="math">r\\gets 0</span>  : the current round 8: sentvote  <span class="math">\\leftarrow</span>  FALSE: indicates whether  <span class="math">v_{i}</span>  has voted in slot t PROPOSE 9: at  <span class="math">r = 3\\Delta t</span>  do 10: if  <span class="math">v_{i} = v_{p}^{t}</span>  then 11:  <span class="math">\\mathcal{V}_i\\gets \\mathcal{V}_i\\cup \\mathcal{B}_i</span> 12:  <span class="math">\\mathcal{B}_i\\gets \\emptyset</span> 13:  <span class="math">B^{\\prime}\\gets \\mathsf{FC}(\\mathcal{V}_{i},t)</span> 14:  <span class="math">B\\gets \\mathsf{NewBlock}(B^{\\prime})</span>  // append a new block on top of  <span class="math">B^{\\prime}</span> 15:  <span class="math">\\mathsf{ch}_i\\gets B</span> 16: send message [PROPOSE,  <span class="math">B,\\mathcal{V}_i\\cup \\{B\\} ,t,v_i]</span>  through gossip VOTE AND CONFIRM 17: at  <span class="math">r = 3\\Delta t + \\Delta</span>  do 18: if  <span class="math">\\neg</span>  sentvote then 19:  <span class="math">\\mathsf{ch}_i\\gets \\mathsf{FC}(\\mathcal{V}_i,t)</span> 20: send message [VOTE,  <span class="math">\\mathsf{FC}(\\mathcal{V}_i,t),t,v_i]</span>  through gossip 21: sentvote  <span class="math">\\leftarrow</span>  TRUE 22:  <span class="math">\\mathcal{V}_i\\gets \\mathcal{V}_i\\cup \\mathcal{B}_i</span> 23:  <span class="math">\\mathcal{B}_i\\gets \\emptyset</span> 24:  <span class="math">B_{\\mathrm{fast}}\\gets B_{\\mathrm{genesis}}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">25:  $S_{\\mathrm{fast}}\\gets \\{B\\prec \\mathsf{ch}_i:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{v_i:\\exists B'\\succ B(\\mathrm{VOTE},B',t,v_i)\\in \\mathcal{V}_i\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\frac{2}{3} n\\}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">26: if  <span class="math">S_{\\mathrm{fast}}\\neq \\emptyset</span>  then:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">27:  $B_{\\mathrm{fast}}\\gets \\arg \\max_{S_{\\mathrm{fast}}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">28: if  <span class="math">\\neg (B_{\\mathrm{fast}}\\prec \\mathsf{Ch}_i\\land \\mathsf{ch}_i^{\\top \\kappa}\\prec \\mathsf{ch}_i)</span>  then: 29:  <span class="math">\\mathsf{Ch}_i\\gets \\arg \\max_{ch\\in \\{ch_i^{\\top \\kappa},B_{\\mathrm{fast}}\\}}</span> MERGE 30: at  <span class="math">r = 3\\Delta t + 2\\Delta</span>  do 31:  <span class="math">\\mathcal{V}_i\\gets \\mathcal{V}_i\\cup \\mathcal{B}_i</span> 32:  <span class="math">\\mathcal{B}_i\\gets \\emptyset</span> 33: sentvote  <span class="math">\\leftarrow</span>  FALSE 34: upon receiving a gossiped message [PROPOSE,  <span class="math">B,\\mathcal{V},t,v_p^t ]</span>  do 35:  <span class="math">\\mathcal{B}_i\\gets \\mathcal{B}_i\\cup \\{B\\}</span> 36: if  <span class="math">\\neg</span>  sentvote and  <span class="math">r\\in [3\\Delta t,3\\Delta t + \\Delta ]</span>  then 37:  <span class="math">\\mathcal{V}_i\\gets \\mathcal{V}_i\\cup \\mathcal{V}</span> 38:  <span class="math">\\mathsf{ch}_i\\gets \\mathsf{FC}(\\mathcal{V}_i,t)</span> 39: send message [VOTE,  <span class="math">\\mathsf{FC}(\\mathcal{V}_i,t),t,v_i]</span>  through gossip 40: sentvote  <span class="math">\\leftarrow</span>  TRUE 41: upon receiving a gossiped message  <span class="math">V = [\\mathrm{VOTE},B,t&#x27;,v_i]</span>  from  <span class="math">v_{i}</span>  do 42:  <span class="math">\\mathcal{B}_i\\gets \\mathcal{B}_i\\cup \\{V\\}</span> 43: upon receiving a gossiped message  <span class="math">B = [\\mathrm{BLOCK},b,t&#x27;,v_i]</span>  from  <span class="math">v_{i}</span>  do 44:  <span class="math">\\mathcal{B}_i\\gets \\mathcal{B}_i\\cup \\{B\\}</span></p>

    <p class="text-gray-300">Other than the small modifications we have made, the protocol with fast confirmation behaves exactly as the original protocol, because the confirmation rule does not in any way influence the protocol execution. Therefore, properties like reorg resilience and asynchrony resilience are preserved (up to accounting for those changes in the proofs). In the following, we then only discuss results for which the confirmation rule is relevant, i.e. security results. Firstly, we show a result that fulfills the same role of the view-merge property</p>

    <p class="text-gray-300">(Lemma 1) in our security analysis of fast confirmations, in the sense that it provides the base case for the induction of Theorem 1, allowing us to prove an analogous reorg resilience result for fast confirmations, which implies safety. Since liveness is obtained for free from the liveness of the protocol without fast confirmations, this shows <span class="math">\\eta</span>-dynamic-availability. Finally, we show that fast confirmations are themselves live when there are at least <span class="math">\\frac{2}{3}n</span> honest validators awake and the real network latency is <span class="math">\\leq\\frac{\\Delta}{2}</span>. To make it easier to state the results, we work here with a slightly modified definition of <span class="math">\\tau</span>-compliant execution. In addition to satisfying <span class="math">\\tau</span>-sleepiness, we require that in no honest view <span class="math">\\geq\\frac{n}{3}</span> validators are seen as equivocators. This is a very weak requirement, since equivocation is a slashable offense.</p>

    <h6 id="sec-78" class="text-base font-medium mt-4">Lemma 5.</h6>

    <p class="text-gray-300">Suppose network synchrony holds for rounds <span class="math">[3\\Delta t+\\Delta,3\\Delta t+2\\Delta]</span>, and that an honest validator fast confirms block <span class="math">B</span> at slot <span class="math">t</span>. Suppose also that, in the view of any active validator at slot <span class="math">t+1</span>, <span class="math">&lt;\\frac{n}{3}</span> validators are seen as equivocators. Then, all honest voters of slot <span class="math">t+1</span> vote for descendants of <span class="math">B</span>.</p>

    <h6 id="sec-79" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Upon fast confirming <span class="math">B</span> at round <span class="math">3\\Delta t+\\Delta</span>, the honest validator broadcasts <span class="math">B</span> and all votes <span class="math">\\geq\\frac{2}{3}n</span> votes which are responsible for the fast confirmation, so that they are in the view of all awake validators at round <span class="math">3\\Delta t+2\\Delta</span>, by synchrony. Therefore, they are also in the view of all active validators at round <span class="math">3\\Delta(t+1)+\\Delta</span>. Consider one such view <span class="math">\\mathcal{V}</span>. By assumption, <span class="math">&lt;\\frac{n}{3}</span> validators are seen as equivocators in <span class="math">\\mathcal{V}</span>, so over <span class="math">\\frac{n}{3}</span> out of the <span class="math">\\frac{2}{3}n</span> votes are not discounted. Since they are from slot <span class="math">t</span>, they are latest votes, and are the ones which count for the respective validators. Therefore, <span class="math">w(B,\\mathsf{FIL}_{ulmd}(\\mathcal{V},t+1).\\mathcal{V})&gt;\\frac{n}{3}</span>. On the other hand, <span class="math">\\mathcal{V}</span> contains at most <span class="math">\\frac{n}{3}</span> votes from slot <span class="math">t</span>, conflicting with <span class="math">B</span> and by a validator which is not seen as an equivocator in <span class="math">\\mathcal{V}</span>. Therefore, <span class="math">w(B^{\\prime},\\mathsf{FIL}_{ulmd}(\\mathcal{V},t+1).\\mathcal{V})\\leq\\frac{n}{3}</span> for any <span class="math">B^{\\prime}</span> conflicting with <span class="math">B</span>, so <span class="math">B</span> is canonical in <span class="math">\\mathcal{V}</span>, and an active validator with view <span class="math">\\mathcal{V}</span> votes for a descendant of <span class="math">B</span>. ∎</p>

    <h6 id="sec-80" class="text-base font-medium mt-4">Theorem 12 (Reorg resilience of fast confirmations).</h6>

    <p class="text-gray-300">Consider an <span class="math">\\eta</span>-compliant execution of RLMD-GHOST. A block fast confirmed by an honest validator at a slot <span class="math">t</span> after GST is always in the canonical chain of all active validators at rounds <span class="math">\\geq 3\\Delta(t+1)+\\Delta</span>.</p>

    <h6 id="sec-81" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof follows that of Theorem 1, using Lemma 5 instead of Lemma 1 as the base case. The assumption of Lemma 5 about equivocators is satisfied by (the new) definition of <span class="math">\\eta</span>-compliance. Proposition 1, which we have proven for <span class="math">\\eta</span>-compliant executions of RLMD-GHOST in Lemma 4, is still used for the inductive step. ∎</p>

    <h6 id="sec-82" class="text-base font-medium mt-4">Theorem 13 (Dynamic availability).</h6>

    <p class="text-gray-300">RLMD-GHOST with fast confirmations is <span class="math">\\eta</span>-dynamically-available.</p>

    <h6 id="sec-83" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300"><span class="math">\\eta</span>-liveness follows directly from Theorem 7, in particular from <span class="math">\\eta</span>-liveness of RLMD-GHOST without fast confirmations. This is because fast confirmations are not needed for the confirmed chain to make progress, and so liveness of the standard confirmations suffices. We then only need to show that it satisfies <span class="math">\\eta</span>-safety. If an honest validator fast confirms a block <span class="math">B</span> at slot <span class="math">t</span> in an <span class="math">\\eta</span>-compliant execution, then <span class="math">B</span> is in the canonical chain of all active validators at rounds <span class="math">\\geq 3\\Delta(t+1)+\\Delta</span>, by Theorem 12. At slot <span class="math">t+\\kappa</span>, <span class="math">B</span> is then in the <span class="math">\\kappa</span>-slots-deep prefix of the canonical chain of all active validators and thus confirmed by them with the standard confirmation rule. Therefore, a safety violation involving conflicting confirmed chains <span class="math">\\mathsf{Ch}_{i}^{r}</span> and <span class="math">\\mathsf{Ch}_{j}^{r^{\\prime}}</span> can be reduced to a safety violation for the standard confirmation rule, for rounds <span class="math">r+3\\Delta(\\kappa+1)</span> and <span class="math">r^{\\prime}+3\\Delta(\\kappa+1)</span>. Theorem 7 then implies the <span class="math">\\eta</span>-safety of the protocol. ∎</p>

    <h6 id="sec-84" class="text-base font-medium mt-4">Theorem 14 (Liveness of fast confirmations).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">An honest proposal <span class="math">B</span> from a slot <span class="math">t</span> after GST + <span class="math">\\Delta</span> in which $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\frac{2}{3}n<span class="math"> and network latency is </span>\\leq\\frac{\\Delta}{2}<span class="math"> is fast confirmed by all active validators at round </span>3\\Delta t+\\Delta$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-85" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Firstly, note that validators in <span class="math">H_{t}</span> are active in all rounds <span class="math">[3\\Delta(t_{1})+2\\Delta,3\\Delta t+\\Delta]</span>, because falling asleep at any point in those rounds would force them to go through the joining protocol again, and thus they would not be active prior to at least round <span class="math">3\\Delta t+2\\Delta</span>. Since network latency is <span class="math">\\leq\\frac{\\Delta}{2}</span>, all validators in <span class="math">H_{t}</span> receive the honest proposal by round <span class="math">3\\Delta t+\\frac{\\Delta}{2}</span>. By the view-merge property, Lemma 1, they all vote for <span class="math">B</span>. Again by the assumption on network latency, they all receive such votes by round <span class="math">3\\Delta t+\\Delta</span>, at which point they are merged into their views. Therefore, all of their views contain $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\frac{2}{3}n<span class="math"> votes for </span>B<span class="math"> from slot </span>t<span class="math">, and </span>B$ is fast confirmed.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>`;
---

<BaseLayout title="Recent Latest Message Driven GHOST: Balancing Dynamic Availa... (2023/279)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2023 &middot; eprint 2023/279
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
