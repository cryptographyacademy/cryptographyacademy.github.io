---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2018/985';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Efficient Arithmetic In (Pseudo-)Mersenne Prime Order Fields';
const AUTHORS_HTML = 'Kaushik Nath, Palash Sarkar';

const CONTENT = `    <p class="text-gray-300">Kaushik Nath and Palash Sarkar</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Elliptic curve cryptography requires efficient arithmetic over the underlying field. In particular, fast implementation of multiplication and squaring over the finite field is required for efficient projective coordinate based scalar multiplication as well as for inversion using Fermat’s little theorem. In the present work we consider the problem of obtaining efficient algorithms for field multiplication and squaring. From a theoretical point of view, we present a number of algorithms for multiplication/squaring and reduction which are appropriate for different settings. Our algorithms collect together and generalise ideas which are scattered across various papers and codes. At the same time, we also introduce new ideas to improve upon existing works. A key theoretical feature of our work, which is not present in previous works, is that we provide formal statements and detailed proofs of correctness of the different reduction algorithms that we describe. On the implementation aspect, a total of fourteen primes are considered, covering all previously proposed cryptographically relevant (pseudo-)Mersenne prime order fields at various security levels. For each of these fields, we provide 64-bit assembly implementations of the relevant multiplication and squaring algorithms targeted towards two different modern Intel architectures. We were able to find previous 64-bit implementations for six of the fourteen primes considered in this work. On the Haswell and Skylake processors of Intel, for all the six primes where previous implementations are available, our implementations outperform such previous implementations.</p>

    <p class="text-gray-300">Keywords: field multiplication, field squaring, reduction, inversion, constant-time computation, Fermat’s little theorem, elliptic curve cryptography, scalar multiplication.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Elliptic curve cryptography was independently introduced by Koblitz <em>[16]</em> and Miller <em>[19]</em>, and later cryptography based on hyper-elliptic curves was introduced by Koblitz <em>[17]</em>. Over the last three decades, there has been a tremendous amount of research on various aspects of secure and efficient curve based cryptography.</p>

    <p class="text-gray-300">Presently, there are several different approaches for choosing a suitable curve. The basic task for all such approaches is to choose the underlying finite field. This field can either have composite or prime order. Further, for a prime order field, the prime may be a Mersenne or a pseudo-Mersenne prime. Some well known examples are the Mersenne prime <span class="math">2^{127}-1</span> used in <em>[12, 5, 8, 10]</em>, and the pseudo-Mersenne primes <span class="math">2^{255}-19</span> and <span class="math">2^{256}-2^{32}-977</span> <em>[24]</em> used in Curve25519 <em>[3]</em> and the Bitcoin <em>[20]</em> protocol respectively. The NIST proposals <em>[11]</em>, on the other hand, provide examples of unstructured primes and efficient implementation of arithmetic using such primes have been studied in <em>[14]</em>. In this work, we will focus only on Mersenne and pseudo-Mersenne prime order fields.</p>

    <p class="text-gray-300">Two basic applications of curve-based cryptography are key agreement and signature schemes. Both of these schemes require scalar multiplications. The computation consists of two steps. In the first step, the scalar multiplication is computed using projective coordinates and in the second step, an inversion in the underlying finite field is required to convert the output to affine coordinates.</p>

    <p class="text-gray-300">Computing scalar multiplication using projective coordinates requires efficient algorithms for finite field arithmetic, especially multiplication and squaring. For performing an inversion, there are two approaches. Using Fermat’s little theorem (FLT), an inversion can be computed using an exponentiation</p>

    <p class="text-gray-300">which again requires efficient algorithms for multiplication and squaring. Alternatively, inversion can be computed using Euclid’s algorithm which requires additions and subtractions.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Our Contributions</h4>

    <p class="text-gray-300">The core technical contribution of the present work is to carry out a comprehensive study of multiplication and squaring algorithms over fields whose order is either a Mersenne or a pseudo-Mersenne prime. We concentrate on single multiplication and squaring algorithms and so the aspect of simultaneous multiplications using single instruction multiple data (SIMD) instructions is not considered in the present work.</p>

    <p class="text-gray-300">Field multiplication and squaring have two broad phases, namely, a multiplication phase and a reduction phase. Of the two, the reduction phase is relatively more complex. Let the prime <span class="math">p=2^{m}-\\delta</span>. Elements of <span class="math">\\mathbb{F}_{p}</span> fit within an <span class="math">m</span>-bit string. Such an <span class="math">m</span>-bit string is formatted into <span class="math">\\kappa</span> binary strings where the first <span class="math">\\kappa-1</span> strings are each <span class="math">\\eta</span> bits long and the last string is <span class="math">\\nu</span> bits long with <span class="math">0&lt;\\nu\\leq\\eta</span>. Following the usual convention, we call each of the individual <span class="math">\\kappa</span> binary strings to be limbs. For 64-bit arithmetic, each limb fits into a 64-bit word. Two kinds of representations have been considered in the literature. In the first kind of representation, <span class="math">\\eta=64</span>, and so the limbs (except possibly for the last one) are packed tightly into 64-bit words. In the second kind of representation, <span class="math">\\eta&lt;64</span>, and so the 64-bit words containing the limbs have some free or redundant bits. We call the first kind of representation to be saturated limb representation and the second kind to be unsaturated limb representation.</p>

    <p class="text-gray-300">We provide various algorithms for multiplication/squaring and reduction using both the saturated and the unsaturated limb representations. A brief summary of these contributions is as follows.</p>

    <p class="text-gray-300">Multiplication/squaring for saturated limb representation: We describe two sets of algorithms with each set consisting of an algorithm for multiplication and one for squaring. The first set of algorithms (which we call mulSLDCC/sqrSLDCC) generalizes the multiplication/squaring algorithms in the Intel white papers <em>[23, 22]</em> to work for <span class="math">64i</span>-bit integers for any <span class="math">i\\geq 2</span>. These algorithms use two independent carry chains and can be implemented in the newer generation of processors. The second set of algorithms (which we call mulSLa/sqrSLa) do not use double carry chains and can be implemented across all generation of processors. These algorithms combine an initial step of the reduction with the multiplication. The idea behind mulSLa/sqrSLa have not appeared earlier in the literature. Multiplication/squaring for unsaturated limb representation: We describe two sets of algorithms. The first set of algorithms (which we call mulUSL/sqrUSL) generalize the ideas used in <em>[6]</em> for the prime <span class="math">2^{255}-19</span>. These algorithms, however, lead to overflow for certain primes such as the Bitcoin prime <span class="math">2^{256}-2^{32}-977</span>. To handle such overflow issues, we describe a second set of algorithms (which we call mulUSLa/sqrUSLa) which have not appeared earlier in the literature. Reduction for saturated limb representation: We describe four reduction algorithms, namely, reduceSLMP, reduceSLPMP, reduceSLPMPa and reduceSL. Algorithms reduceSLMP, reduceSLPMP and reduceSLPMPa reduce the outputs of mulSLDCC/sqrSLDCC. Specifically, reduceSLMP works for all Mersenne primes and is a generalization of the ideas used in <em>[5]</em> for the prime <span class="math">2^{127}-1</span>. Algorithm reduceSLPMP works for a large class of pseudo-Mersenne primes and has not appeared earlier. Algorithm reduceSLPMPa works for a large class of pseudo-Mersenne primes and is a generalization of the ideas for 4-limb representation used in <em>[6]</em> for the prime <span class="math">2^{255}-19</span>. Algorithm reduceSL reduces the output mulSLa/sqrSLa and has not appeared earlier in the literature. Reduction for unsaturated limb representation: We describe three reduction algorithms, namely, reduceUSL, reduceUSLA and reduceUSLB. Algorithm reduceUSL works for a large class of pseudo-Mersenne primes and is a generalization of the ideas for 5-limb representation used in <em>[9]</em> for the prime <span class="math">2^{255}-19</span>. For certain primes, reduceUSLA is more efficient than reduceUSL and generalizes ideas used in <em>[6]</em> for the prime <span class="math">2^{255}-19</span>. For certain other primes, reduceUSLB is more efficient than both reduceUSL and reduceUSLA. The idea behind reduceUSLB has not appeared earlier in the literature.</p>

    <p class="text-gray-300">In Table 1, for each algorithm presented in this work, we state whether it is new or, the earlier work that it generalizes.</p>

    <p class="text-gray-300">There are two key theoretical features of our work.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>While previous works have developed code for a single prime, we describe the algorithms in their full generality.</li>

      <li>For each reduction algorithm, we state precise theorems about their correctness and provide detailed proofs of correctness. Such formal treatment of correctness of reduction algorithms does not appear earlier in the literature.</li>

    </ol>

    <p class="text-gray-300">The second aspect of our work is in the efficient implementation of the various multiplication and squaring algorithms.</p>

    <p class="text-gray-300">Assembly implementation: All the algorithms described in this paper, have been implemented in 64-bit assembly for Intel processors. The implementations are divided into two groups, namely maa and maax. For implementations in the maa group, the only arithmetic instructions used are mul, imul, add and adc, while for implementations in the maax group, the arithmetic instructions mulx, adcx and adox are also used. These second set of instructions are available from the Broadwell processor onwards.</p>

    <p class="text-gray-300">Library for field-arithmetic: Through our efficient 64-bit assembly implementations, we provide a library of field multiplication and squarings in cryptographically relevant prime order fields targeting the modern Intel processors. The efficient field arithmetic library can be used for the development of fast projective coordinate based scalar multiplication over appropriate elliptic curves.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">algorithm</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">feature</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">mulSLDCC/sqrSLDCC</td>

            <td class="px-3 py-2 border-b border-gray-700">generalizes [23, 22]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">mulSLa/sqrSLa</td>

            <td class="px-3 py-2 border-b border-gray-700">new</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">mulUSL/sqrUSL</td>

            <td class="px-3 py-2 border-b border-gray-700">generalizes [6]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">mulUSLa/sqrUSLa</td>

            <td class="px-3 py-2 border-b border-gray-700">new</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">reduceSLMP</td>

            <td class="px-3 py-2 border-b border-gray-700">generalizes [5]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">reduceSLPMP</td>

            <td class="px-3 py-2 border-b border-gray-700">new</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">reduceSLPMPa</td>

            <td class="px-3 py-2 border-b border-gray-700">generalizes [6, 4-limb]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">reduceSL</td>

            <td class="px-3 py-2 border-b border-gray-700">new</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">reduceUSL</td>

            <td class="px-3 py-2 border-b border-gray-700">generalizes [9, 5-limb]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">reduceUSLA</td>

            <td class="px-3 py-2 border-b border-gray-700">generalizes [6, 5-limb]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">reduceUSLB</td>

            <td class="px-3 py-2 border-b border-gray-700">new</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: The various algorithms for multiplication/squaring and reduction described in this paper.</p>

    <p class="text-gray-300">We have considered a total of fourteen primes which include all previously proposed cryptographically relevant (pseudo-)Mersenne primes at various security levels. These primes are shown in Table 2. For the prime  <span class="math">2^{255} - 19</span> , we have found earlier implementations of both maa and maax types and for five of the other primes, we have found implementations of maa type. So, for eight of the fourteen primes, we provide the first maa type implementation and for thirteen of the fourteen primes, we provide the first maax type implementations.</p>

    <p class="text-gray-300">Timings of the field operations for the new implementations and the existing implementations have been measured on the Haswell and Skylake processors. For each prime where a previous implementation is available, our implementation improves upon such previous implementations. A summary of the various speed-ups that were observed is as follows. Further details are provided later.</p>

    <p class="text-gray-300">maa type implementations:</p>

    <p class="text-gray-300">On Haswell: Speed-ups of about  <span class="math">10\\%</span> ,  <span class="math">3\\%</span> ,  <span class="math">4\\%</span> ,  <span class="math">36\\%</span> ,  <span class="math">2\\%</span>  and  <span class="math">18\\%</span>  were observed for the primes  <span class="math">2^{127} - 1</span> ,  <span class="math">2^{251} - 9</span> ,  <span class="math">2^{255} - 19</span> ,  <span class="math">2^{256} - 2^{32} - 977</span> ,  <span class="math">2^{266} - 3</span>  and  <span class="math">2^{521} - 1</span>  respectively.</p>

    <p class="text-gray-300">On Skylake: Speed-ups of about  <span class="math">10\\%</span> ,  <span class="math">12\\%</span> ,  <span class="math">4\\%</span> ,  <span class="math">28\\%</span> ,  <span class="math">8\\%</span>  and  <span class="math">16\\%</span>  were observed for the primes  <span class="math">2^{127} - 1</span> ,  <span class="math">2^{251} - 9</span> ,  <span class="math">2^{255} - 19</span> ,  <span class="math">2^{256} - 2^{32} - 977</span> ,  <span class="math">2^{266} - 3</span>  and  <span class="math">2^{521} - 1</span>  respectively.</p>

    <p class="text-gray-300">maax type implementations: On the Skylake processor, a speed-up of about  <span class="math">26\\%</span>  was observed for the prime  <span class="math">2^{255} - 19</span> .</p>

    <p class="text-gray-300">The speed-ups obtained for  <span class="math">2^{255} - 19</span>  and  <span class="math">2^{256} - 2^{32} - 977</span>  are particularly important. The prime  <span class="math">2^{255} - 19</span>  defines the underlying field for the famous Curve25519 while the prime  <span class="math">2^{256} - 2^{32} - 977</span>  defines the underlying field for the curve secp256k1 which is used in the Bitcoin protocol. The above</p>

    <p class="text-gray-300">mentioned improvements arises from use of new reduction algorithms as well as hand optimisations of the corresponding assembly codes.</p>

    <p class="text-gray-300">Source codes for all our implementations are publicly available at the following link.</p>

    <p class="text-gray-300">https://github.com/kn-cs/pmp-farith.</p>

    <p class="text-gray-300">For ease of reference, we provide a brief summary of the relevant Intel instructions in Section 2. The background on representation of elements of  <span class="math">\\mathbb{F}_p</span>  and the exponentiation based inversion algorithm are covered in Section 3. An overview of the various algorithms presented in this paper is provided in Section 4. Algorithms for integer multiplication and squaring using the saturated limb representation and using double independent carry chains are given in Section 5. Corresponding reduction algorithms along with formal statements of correctness are presented in Section 6. Multiplication using unsaturated limb representation is considered in Section 7 and the corresponding reduction algorithms are described in Section 8. Multiplication and reduction using saturated limb representation without using double carry chains are described in Section 9. Detailed timing results of the field operations and their consequences are presented in Section 10. Finally, Section 11 concludes the paper.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">prime</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">curve(s)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2127 - 1</td>

            <td class="px-3 py-2 border-b border-gray-700">Kummer2 [5], FourQ [10]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2221 - 3</td>

            <td class="px-3 py-2 border-b border-gray-700">M-221 [1]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2222 - 117</td>

            <td class="px-3 py-2 border-b border-gray-700">E-222 [1]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2251 - 9</td>

            <td class="px-3 py-2 border-b border-gray-700">Curve1174 [1], KL2519(81,20) [15]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2255 - 19</td>

            <td class="px-3 py-2 border-b border-gray-700">Curve25519 [3], KL25519(82,77) [15]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2256 - 232 - 977</td>

            <td class="px-3 py-2 border-b border-gray-700">secp256k1 [24]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2266 - 3</td>

            <td class="px-3 py-2 border-b border-gray-700">KL2663(260,139) [15]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2382 - 105</td>

            <td class="px-3 py-2 border-b border-gray-700">E-382 [1]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2383 - 187</td>

            <td class="px-3 py-2 border-b border-gray-700">M-383 [1]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2414 - 17</td>

            <td class="px-3 py-2 border-b border-gray-700">Curve41417 [4]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2511 - 187</td>

            <td class="px-3 py-2 border-b border-gray-700">M-511 [1]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2512 - 569</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2521 - 1</td>

            <td class="px-3 py-2 border-b border-gray-700">P-521 [1], E-521 [1]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2607 - 1</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: The primes considered in this work.</p>

    <p class="text-gray-300">The 64-bit architecture of the Intel x86 processors has sixteen 64-bit registers, namely rax, rbx, rcx, rdx, rsi, rdi, rsp, rbp, r8, r9, r10, r11, r12, r13, r14, r15. Except rsp (which is the stack pointer), all other registers can be used for storing data and operating on them. There is a register named FLAGS, which consists of various available flags. We note two of these flags. Bit 0 of FLAGS is the carry flag CF and bit 11 of FLAGS is the overflow flag OF. Integer addition and multiplication affect the states of these two flags and are relevant to our work.</p>

    <p class="text-gray-300">The basic 64-bit arithmetic operations in the x86 processors are mul, imul, add and adc. From the Broadwell processor onwards, Intel also provides another set of arithmetic instructions, namely, mulx, adcx and adox. The structure of multiplication and addition instructions and their operations are as follows.</p>

    <pre><code class="language-txt">mul src2; rdx:rax  $\\leftarrow$  src2·rax.
imul src1, src2, dst; dst  $\\leftarrow$  lsb64(src1·src2).
add src, dst; dst  $\\leftarrow$  src + dst.
adc src, dst; dst  $\\leftarrow$  src + dst + CF.
mulx src1, dstl, dsth; dsth:dstl  $\\leftarrow$  src1·rax.
adcx src, dst; dst  $\\leftarrow$  src + dst + CF.
adox src, dst; dst  $\\leftarrow$  src + dst + OF.</code></pre>

    <p class="text-gray-300">The operation mulx is available from the Haswell processor onwards; adcx and adox are available from the Broadwell processor onwards. Processors previous to Haswell had only mul, imul, add and adc.</p>

    <p class="text-gray-300">The effect on the carry and the overflow flags for the above mentioned arithmetic operations are the following.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>mul, imul, add and adc affect both CF and OF;</li>

      <li>mulx affects neither CF nor OF;</li>

      <li>adcx affects only CF but, not OF;</li>

      <li>adox affects only OF but, not CF.</li>

    </ul>

    <p class="text-gray-300">Suppose there is an interleaved sequence of multiplications and additions to be performed. The additions generate carries which need to be taken into consideration for subsequent additions. The mul and imul instructions affect the carry flag and so the carry out of the previous addition gets lost. On the other hand, a sequence of mulx and adc instructions can efficiently perform such an interleaved sequence of multiplications and additions. The mulx instruction does not affect the carry flag and so the sequence of adc instructions can carry out the instructions using a single carry chain.</p>

    <p class="text-gray-300">The combination of mulx, adcx and adox provides a more powerful tool. As mentioned above, the mulx instruction does not affect either CF or OF. A sequence of adcx instructions proceeds by using a carry chain using only CF, while a sequence of adox instructions proceeds by using a carry chain using only OF. So, in effect, it is possible to use two independent carry chains which we call double carry chain. This greatly facilitates arithmetic computations as we will see later.</p>

    <h5 id="sec-7" class="text-base font-semibold mt-4">Remark:</h5>

    <p class="text-gray-300">Let <span class="math">x</span> be an <span class="math">\\ell</span>-bit number and <span class="math">\\eta\\leq\\ell</span>. The operation <span class="math">x</span> mod <span class="math">2^{\\eta}</span> returns <span class="math">\\mathsf{lsb}_{\\eta}(x)</span>, i.e., the <span class="math">\\eta</span> least significant bits of <span class="math">x</span>, whereas the operation <span class="math">\\lfloor x/2^{\\eta}\\rfloor</span> returns the <span class="math">\\ell-\\eta</span> most significant bits of <span class="math">x</span>. It will be helpful to keep this simple observation in mind while going through the various algorithms given later.</p>

    <h2 id="sec-8" class="text-2xl font-bold">3 Representation of Elements in <span class="math">\\mathbb{F}_{p}</span></h2>

    <p class="text-gray-300">Let <span class="math">\\eta</span> be a positive integer and <span class="math">\\theta=2^{\\eta}</span>. Consider a polynomial</p>

    <p class="text-gray-300"><span class="math">h(\\theta)</span> <span class="math">=</span> <span class="math">h_{0}+h_{1}\\theta+\\cdots+h_{k-1}\\theta^{k-1}</span> (1)</p>

    <p class="text-gray-300">where <span class="math">h_{0},h_{1},\\ldots,h_{k-1}</span> are non-negative integers. The polynomial <span class="math">h(\\theta)</span> is given by the vector of coefficients <span class="math">(h_{0},h_{1},\\ldots,h_{k-1})</span>. We will call these coefficients to be the limbs of the polynomial. Note that we do not insist that the coefficients are less than <span class="math">2^{\\eta}</span>; in fact, at intermediate steps, the coefficients will not necessarily be less than <span class="math">2^{\\eta}</span>.</p>

    <p class="text-gray-300">Given positive integers <span class="math">m</span> and <span class="math">\\eta</span>, let <span class="math">\\kappa</span> and <span class="math">\\nu</span> be positive integers such that</p>

    <p class="text-gray-300"><span class="math">m</span> <span class="math">=</span> <span class="math">\\eta(\\kappa-1)+\\nu\\quad\\text{with }0&lt;\\nu\\leq\\eta.</span> (2)</p>

    <p class="text-gray-300">Given <span class="math">m</span> and <span class="math">\\eta</span>, the values of <span class="math">\\kappa</span> and <span class="math">\\nu</span> are uniquely determined. An integer in the range <span class="math">[0,\\ldots,2^{m}-1]</span> can be represented by an <span class="math">m</span>-bit string. From (2), an <span class="math">m</span>-bit string can be considered to be the concatenation of <span class="math">\\kappa</span> strings, where the first <span class="math">\\kappa-1</span> strings are each <span class="math">\\eta</span> bits long while the last string is <span class="math">\\nu</span> bits long. So, an <span class="math">m</span>-bit integer can be represented as <span class="math">h(\\theta)=h_{0}+h_{1}\\theta+\\cdots+h_{\\kappa-1}\\theta^{\\kappa-1}</span> where <span class="math">0\\leq h_{0},h_{1},\\ldots,h_{\\kappa-1}&lt;2^{\\eta}</span> and <span class="math">0\\leq h_{\\kappa-1}&lt;2^{\\nu}</span>. As mentioned above, each of the <span class="math">\\kappa</span> individual strings will be referred to as a limb. Given an <span class="math">m</span>-bit integer, by a <span class="math">(\\kappa,\\eta,\\nu)</span>-representation we will mean a <span class="math">\\kappa</span>-limb representation, where the first <span class="math">\\kappa-1</span> limbs are <span class="math">\\eta</span> bits long, the last limb is <span class="math">\\nu</span> bits long and <span class="math">m=\\eta(\\kappa-1)+\\nu</span>.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Proposition 1.</h6>

    <p class="text-gray-300">Let <span class="math">x</span> and <span class="math">y</span> be two <span class="math">m</span>-bit integers both having a <span class="math">(\\kappa,\\eta,\\nu)</span>-representation and let <span class="math">z=x\\cdot y</span>. Then <span class="math">z</span> has a <span class="math">(\\kappa^{\\prime},\\eta,\\nu^{\\prime})</span>-representation where</p>

    <p class="text-gray-300"><span class="math">\\kappa^{\\prime}=2\\kappa-1,\\ \\nu^{\\prime}=2\\nu\\ \\text{if }0&lt;\\nu\\leq\\eta/2;\\ \\ \\text{and}\\ \\ \\ \\kappa^{\\prime}=2\\kappa,\\ \\nu^{\\prime}=2\\nu-\\eta\\ \\text{if }\\eta/2&lt;\\nu\\leq\\eta.</span></p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We have <span class="math">m=\\eta(\\kappa-1)+\\nu</span>. The number of bits in <span class="math">z</span> is at most <span class="math">2m</span> and we may write <span class="math">2m=\\eta(2\\kappa-2)+2\\nu</span>. If <span class="math">0&lt;\\nu\\leq\\eta/2</span>, then <span class="math">z</span> has a <span class="math">(2\\kappa-1)</span>-limb representation where the first <span class="math">2\\kappa-2</span> limbs are each <span class="math">\\eta</span> bits long and the last limb is <span class="math">\\nu^{\\prime}=2\\nu</span> bits long. On the other hand, if <span class="math">\\eta/2&lt;\\nu\\leq\\eta</span>, then we may write <span class="math">2m=\\eta(2\\kappa-1)+2\\nu-\\eta</span> and so <span class="math">z</span> has a <span class="math">2\\kappa</span>-limb representation where the first <span class="math">2\\kappa-1</span> limbs are each <span class="math">\\eta</span> bits long and the last limb is <span class="math">2\\nu-\\eta</span> bits long. (Note that <span class="math">\\eta/2&lt;\\nu\\leq\\eta</span> implies <span class="math">0&lt;2\\nu-\\eta\\leq\\eta</span>.) ∎</p>

    <p class="text-gray-300">Consider a <span class="math">(\\kappa,\\eta,\\nu)</span>-representation of an <span class="math">m</span>-bit integer <span class="math">w</span>. Suppose that <span class="math">\\omega</span>-bit arithmetic will be used for implementation. Using <span class="math">\\omega</span>-bit arithmetic, <span class="math">w</span> will be represented by <span class="math">\\kappa</span> <span class="math">\\omega</span>-bit words <span class="math">w_{0},\\ldots,w_{\\kappa-1}</span> such that the binary representation of <span class="math">w</span> is given by</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{lsb}_{\\nu}(w_{\\kappa-1})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{lsb}_{\\eta}(w_{\\kappa-2})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{lsb}_{\\eta}(w_{0}).$ (3)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Here <span class="math">\\mathsf{lsb}_{i}(x)</span> denotes the <span class="math">i</span> least significant bits of the binary string <span class="math">x</span> and <span class="math">0&lt;\\nu\\leq\\eta\\leq\\omega</span>. Depending on the value of <span class="math">\\eta</span>, we identify two kinds of representation.</p>

    <p class="text-gray-300">Saturated limb representation: In this case <span class="math">\\eta = \\omega</span>. So, each of the <span class="math">\\omega</span>-bit words <span class="math">w_0, w_1, \\ldots, w_{\\kappa - 2}</span> are "saturated" in the sense that there are no leading redundant bits in these words. The <span class="math">\\omega</span>-bit word <span class="math">w_{\\kappa - 1}</span> is saturated or unsaturated depending on whether <span class="math">\\nu = \\eta</span> or <span class="math">\\nu &amp;lt; \\eta</span> respectively.</p>

    <p class="text-gray-300">Unsaturated limb representation: In this case <span class="math">\\eta &amp;lt; \\omega</span>. So, each of the <span class="math">\\omega</span>-bit words <span class="math">w_0, w_1, \\ldots, w_{\\kappa - 1}</span> are "unsaturated" in the sense that they contain some leading redundant bits. The word <span class="math">w_{\\kappa - 1}</span> contains the same or more leading redundant bits according as whether <span class="math">\\nu = \\eta</span> or <span class="math">\\nu &amp;lt; \\eta</span> respectively.</p>

    <p class="text-gray-300">Remark: In this work, we will consider 64-bit arithmetic and so <span class="math">\\omega = 64</span>. The general ideas of the algorithms apply to arbitrary values of <span class="math">\\omega</span>. The actual value of <span class="math">\\omega = 64</span> is used at some places in the (non-)overflow analysis of the correctness proofs.</p>

    <p class="text-gray-300">The primes <span class="math">p</span> that we consider are of the form</p>

    <div class="my-4 text-center"><span class="math-block">p = 2^m - \\delta, \\tag{4}</span></div>

    <p class="text-gray-300">where <span class="math">\\delta</span> is sufficiently small. Given <span class="math">(\\kappa, \\eta, \\nu)</span>-representation of <span class="math">m</span>-bit integers, we have</p>

    <div class="my-4 text-center"><span class="math-block">2^{\\eta(\\kappa - 1) + \\nu} = 2^m \\equiv \\delta \\bmod p. \\tag{5}</span></div>

    <p class="text-gray-300">For future reference, we define</p>

    <div class="my-4 text-center"><span class="math-block">c_p = 2^{\\eta - \\nu} \\delta. \\tag{6}</span></div>

    <p class="text-gray-300">The different values of <span class="math">m</span>, <span class="math">\\delta</span>, <span class="math">\\kappa</span>, <span class="math">\\eta</span> and <span class="math">\\nu</span> for the various primes <span class="math">p</span> considered in this work are given in Table 3. For each prime, two sets of values of <span class="math">\\kappa</span>, <span class="math">\\eta</span> and <span class="math">\\nu</span> are provided, one using saturated limb representation and the other using unsaturated limb representation.</p>

    <p class="text-gray-300">The main goal of obtaining a representation of <span class="math">m</span> of the form (2) is to minimize the value of <span class="math">\\kappa</span>. As the value of <span class="math">\\kappa</span> grows, so does the complexity of multiplication. Clearly the value of <span class="math">\\kappa</span> is minimized for the saturated limb representations. An issue with the saturated limb representations is that each limb has the maximum possible size and so handling overfull issues can be complex. It is for this reason that one considers the unsaturated limb representations. For the unsaturated limb representations, in Table 3 there is a column labeled "type". This column refers to the particular type of reduction algorithm which applies best to the corresponding prime and will be explained in details later.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">prime</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">δ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">unsaturated limb</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">saturated limb</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">κ</td>

            <td class="px-3 py-2 border-b border-gray-700">η</td>

            <td class="px-3 py-2 border-b border-gray-700">ν</td>

            <td class="px-3 py-2 border-b border-gray-700">type</td>

            <td class="px-3 py-2 border-b border-gray-700">κ</td>

            <td class="px-3 py-2 border-b border-gray-700">η</td>

            <td class="px-3 py-2 border-b border-gray-700">ν</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2^{127} - 1</td>

            <td class="px-3 py-2 border-b border-gray-700">127</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">43</td>

            <td class="px-3 py-2 border-b border-gray-700">41</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">63</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2^{221} - 3</td>

            <td class="px-3 py-2 border-b border-gray-700">221</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">56</td>

            <td class="px-3 py-2 border-b border-gray-700">53</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">29</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2^{222} - 117</td>

            <td class="px-3 py-2 border-b border-gray-700">222</td>

            <td class="px-3 py-2 border-b border-gray-700">117</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">56</td>

            <td class="px-3 py-2 border-b border-gray-700">54</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">30</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2^{251} - 9</td>

            <td class="px-3 py-2 border-b border-gray-700">251</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">51</td>

            <td class="px-3 py-2 border-b border-gray-700">47</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">59</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2^{255} - 19</td>

            <td class="px-3 py-2 border-b border-gray-700">255</td>

            <td class="px-3 py-2 border-b border-gray-700">19</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">51</td>

            <td class="px-3 py-2 border-b border-gray-700">51</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">63</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2^{256} - 2^{52} - 977</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">2^{52} + 977</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">52</td>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2^{266} - 3</td>

            <td class="px-3 py-2 border-b border-gray-700">266</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">54</td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2^{382} - 105</td>

            <td class="px-3 py-2 border-b border-gray-700">382</td>

            <td class="px-3 py-2 border-b border-gray-700">105</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">55</td>

            <td class="px-3 py-2 border-b border-gray-700">52</td>

            <td class="px-3 py-2 border-b border-gray-700">B</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">62</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2^{383} - 187</td>

            <td class="px-3 py-2 border-b border-gray-700">383</td>

            <td class="px-3 py-2 border-b border-gray-700">187</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">55</td>

            <td class="px-3 py-2 border-b border-gray-700">53</td>

            <td class="px-3 py-2 border-b border-gray-700">B</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">63</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2^{414} - 17</td>

            <td class="px-3 py-2 border-b border-gray-700">414</td>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">52</td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">30</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2^{511} - 187</td>

            <td class="px-3 py-2 border-b border-gray-700">511</td>

            <td class="px-3 py-2 border-b border-gray-700">187</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">57</td>

            <td class="px-3 py-2 border-b border-gray-700">55</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">63</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2^{512} - 569</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">569</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">57</td>

            <td class="px-3 py-2 border-b border-gray-700">56</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2^{521} - 1</td>

            <td class="px-3 py-2 border-b border-gray-700">521</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">58</td>

            <td class="px-3 py-2 border-b border-gray-700">57</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2^{607} - 1</td>

            <td class="px-3 py-2 border-b border-gray-700">607</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">61</td>

            <td class="px-3 py-2 border-b border-gray-700">58</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3: The primes considered in this work and their saturated and unsaturated limb representations.</p>

    <p class="text-gray-300">Suppose <span class="math">m</span>-bit integers have a <span class="math">(\\kappa, \\eta, \\nu)</span>-representation and <span class="math">\\theta = 2^{\\eta}</span>. The prime <span class="math">p = 2^m - \\delta</span> is represented as the polynomial <span class="math">\\mathfrak{p}(\\theta)</span>, defined as</p>

    <div class="my-4 text-center"><span class="math-block">\\mathfrak{p}(\\theta) = p_0 + p_1\\theta + \\cdots + p_{\\kappa - 1}\\theta^{\\kappa - 1}, \\tag{7}</span></div>

    <p class="text-gray-300">where <span class="math">p_0 = 2^{\\eta} - \\delta</span>, <span class="math">p_1 = p_2 = \\cdots = p_{\\kappa - 2} = 2^{\\eta} - 1</span>, and <span class="math">p_{\\kappa - 1} = 2^{\\nu} - 1</span>.</p>

    <p class="text-gray-300">2For the prime <span class="math">2^{414} - 17</span> an unsaturated limb representation with <span class="math">(\\kappa = 7, \\eta = 60, \\nu = 54)</span> is also possible. The corresponding multiplication, squaring and inversion algorithms are then mulUSLa, sqrUSLa and invUSLa respectively. We discuss this idea in Section 7.1.</p>

    <p class="text-gray-300"><span class="math">f(\\theta)</span> <span class="math">=</span> <span class="math">f_{0}+f_{1}\\theta+\\cdots+f_{\\kappa-1}\\theta^{\\kappa-1},</span> (8)</p>

    <p class="text-gray-300">where <span class="math">0\\leq f_{0},f_{1},\\ldots,f_{\\kappa-1}&lt;2^{\\eta}</span> and <span class="math">0\\leq f_{\\kappa-1}&lt;2^{\\nu}</span>.</p>

    <p class="text-gray-300">It should be noted that the polynomials <span class="math">f(\\theta)</span> are in one-one correspondence with the integers <span class="math">0,1,\\ldots,2^{m}-1</span>. This leads to a non-unique representation of <span class="math">\\delta</span> elements in <span class="math">\\mathbb{F}_{p}</span>, i.e., the elements <span class="math">0,1,\\ldots,\\delta-1</span> are also represented as <span class="math">2^{m}-\\delta,2^{m}-\\delta+1,\\ldots,2^{m}-1</span>. The non-unique representation does not affect the correctness of the computations. At the end of the computation, the final result is converted to a unique representation using a simple algorithm. This procedure is shown in Algorithm 1.</p>

    <p class="text-gray-300">Algorithm 1 Converts to unique representation in <span class="math">\\mathbb{F}_{p}</span>, where <span class="math">p=2^{m}-\\delta</span>. 1: function makeUnique(<span class="math">h^{(0)}(\\theta)</span>) 2: input: <span class="math">h^{(0)}(\\theta)=h_{0}^{(0)}+h_{1}^{(0)}\\theta+\\cdots+h_{\\kappa-1}^{(0)}\\theta^{\\kappa-1}</span>, where <span class="math">0\\leq h_{0}^{(0)},h_{1}^{(0)},\\ldots,h_{\\kappa-2}^{(0)}&lt;2^{\\eta}</span> and <span class="math">0\\leq h_{\\kappa-1}^{(0)}&lt;2^{\\nu}</span>. 3: output: <span class="math">h^{(1)}(\\theta)=h_{0}^{(1)}+h_{1}^{(1)}\\theta+\\cdots+h_{\\kappa-1}^{(1)}\\theta^{\\kappa-1}</span>, where <span class="math">0\\leq h_{0}^{(1)}&lt;2^{\\eta}-\\delta</span>, <span class="math">0\\leq h_{1}^{(1)},h_{2}^{(1)},\\ldots,h_{\\kappa-2}^{(1)}&lt;2^{\\eta}</span>, <span class="math">0\\leq h_{\\kappa-1}^{(0)}&lt;2^{\\nu}</span> and <span class="math">h^{(1)}(\\theta)\\equiv h^{(0)}(\\theta)\\bmod p</span>. 4: <span class="math">u\\leftarrow h_{0}^{(0)}\\geq p_{0}</span> 5: for <span class="math">i\\leftarrow 1</span> to <span class="math">\\kappa-2</span> do 6: <span class="math">u\\leftarrow u</span> & (<span class="math">h_{i}^{(0)}=2^{\\eta}-1</span>) 7: end for 8: <span class="math">u\\leftarrow u</span> & (<span class="math">h_{\\kappa-1}^{(0)}=p_{\\kappa-1}</span>) 9: <span class="math">v\\leftarrow-u</span>; <span class="math">u\\leftarrow\\neg v</span> 10: <span class="math">h_{0}^{(1)}\\leftarrow(h_{0}^{(0)}\\&amp;u)\\mid((h_{0}^{(0)}-p_{0})\\&amp;v)</span> 11: for <span class="math">i\\leftarrow 1</span> to <span class="math">\\kappa-1</span> do 12: <span class="math">h_{i}^{(1)}\\leftarrow(h_{i}^{(0)}\\&amp;u)\\mid(0\\&amp;v)</span> 13: end for 14: return <span class="math">h^{(1)}(\\theta)=h_{0}^{(1)}+h_{1}^{(1)}\\theta+\\cdots+h_{\\kappa-1}^{(1)}\\theta^{\\kappa-1}</span> 15: end function.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">3.1 Inversion in <span class="math">\\mathbb{F}_{p}</span></h3>

    <p class="text-gray-300">Fermat’s little theorem states that for a prime <span class="math">p</span> and any non-zero <span class="math">a\\in\\mathbb{F}_{p}</span>, <span class="math">a^{p-1}\\equiv 1\\bmod p</span>. So, <span class="math">a^{p-2}</span> is the inverse of <span class="math">a</span> in <span class="math">\\mathbb{F}_{p}</span>. Thus, the computation of inverse of any non-zero element in <span class="math">\\mathbb{F}_{p}</span> reduces to the problem of exponentiating <span class="math">a</span> to the power <span class="math">p-2</span>. The standard way to compute this exponentiation is to use the square-and-multiply algorithm. Since, the value <span class="math">p-2</span> is fixed, the numbers of squarings and multiplications are fixed and do not depend on the value of <span class="math">a</span>. So, if squaring and multiplication in <span class="math">\\mathbb{F}_{p}</span> are constant time algorithms, then the exponentiation based inversion is also a constant time algorithm.</p>

    <p class="text-gray-300">Till recently, FLT based inversion was considered to be the more efficient of the two methods for inversion in (pseudo-)Mersenne prime order fields. On the face of it, this seems counter-intuitive since the Fermat based approach uses multiplications and squarings, whereas the Euclid based approach uses only additions and logical shifts. The reason for Fermat based approach being faster for (pseudo-)Mersenne primes seems to be based on two factors, namely, the number of iterations in the Euclid based approach is more and the availability of very fast multiplication instructions in modern processors. Defying this reasoning, a recent work by Bernstein and Yang <em>[2]</em> showed that the Euclid based approach could indeed be faster for (pseudo-)Mersenne primes.</p>

    <p class="text-gray-300">Remark: In the rest of the paper, we will focus entirely on field multiplication and squaring. In comparison, field addition, negation and subtraction are much faster. We note one important difference in these operations which arises from the representation of the elements. For saturated limb representations, field addition/negation/subtraction can be implemented using add/adc/sub/sbb. On the other hand, for unsaturated limb representations, implementation of these operations also require shift operations.</p>

    <h2 id="sec-12" class="text-2xl font-bold">4 Overview of the Algorithms</h2>

    <p class="text-gray-300">All algorithms in this work are described keeping 64-bit arithmetic in mind.</p>

    <p class="text-gray-300">Meanings of various abbreviations:</p>

    <p class="text-gray-300">SL : saturated limb; USL : unsaturated limb; SCC : single carry chain; DCC : double (independent) carry chains; MP : Mersenne prime; PMP : pseudo-Mersenne prime; maa : algorithms implemented using only mul, imul, add and adc; maax : algorithms which also use mulx, adcx and adox.</p>

    <p class="text-gray-300">Brief descriptions of the tasks of the different algorithms that we consider are given below.</p>

    <p class="text-gray-300">Algorithms for the saturated limb representation:</p>

    <p class="text-gray-300">mulSCC: Multiply a word whose value is less than <span class="math">2^{64}</span> to an integer given by a saturated limb representation using a single carry chain. mulSLDCC: Multiply two integers given in saturated limb representations using double (independent) carry chains. sqrSLDCC: Square an integer given in saturated limb representation using double carry chains. reduceSLMP: Reduction algorithm to be applied to the outputs of mulSLDCC or sqrSLDCC when the underlying prime is a Mersenne prime. reduceSLPMP: Reduction algorithm to be applied to the outputs of mulSLDCC or sqrSLDCC when the underlying prime is a pseudo-Mersenne prime. reduceSLPMPa: A partial reduction algorithm to be applied to the outputs of mulSLDCC or sqrSLDCC when the underlying prime is a pseudo-Mersenne prime. mulSLa: Multiply two integers given in saturated limb representations and perform an initial step of the reduction. sqrSLa: Square an integer given in saturated limb representation and perform an initial step of the reduction. reduceSL: A generic reduction algorithm to be applied to the outputs of mulSLa/sqrSLa. farith-SLa: Denotes the algorithm triplet which computes a field multiplication, squaring and inverse using mulSLa, sqrSLa and reduceSL. farith-SLMP: Denotes the algorithm triplet which computes a field multiplication, squaring and inverse using mulSL, sqrSL and reduceSLMP. See the remark below for mulSL and sqrSL. farithx-SLMP: Denotes the algorithm triplet which computes a field multiplication, squaring and inverse using mulSLDCC, sqrSLDCC and reduceSLMP. farithx-SLPMP: Denotes the algorithm triplet which computes a field multiplication, squaring and inverse using mulSLDCC, sqrSLDCC and reduceSLPMP.</p>

    <p class="text-gray-300">Remark: The output of mulSLDCC is the product of the two integers and the output of sqrSLDCC is the square of an integer. Algorithms mulSLDCC/sqrSLDCC utilize double carry chains to perform the computations. The product of two integers in the saturated limb representation can also be performed without using double carry chains and similarly, the square of an integer in the saturated limb representation can be performed without using double carry chains. For the prime <span class="math">2^{255}-19</span>, the 4-limb algorithms in <em>[6]</em> perform such computations. The 4-limb algorithms in <em>[6]</em> can be extended to work for arbitrary limb representations. We will denote the resulting multiplication and squaring algorithms by mulSL and sqrSL. Note that mulSL/sqrSL are different from mulSLa/sqrSLa since mulSLa/sqrSLa also perform an initial step of reduction while this is not done by mulSL/sqrSL.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Algorithms for the unsaturated limb representation:</p>

    <p class="text-gray-300">multiply two integers given in unsaturated limb representations and perform an initial step of the reduction. square an integer given in unsaturated limb representation and perform an initial step of the reduction. multiply two integers given in unsaturated limb representations and perform an initial step of the reduction. This is a variant of mulUSL which is to be used when mulUSL leads to overflows. square an integer given in unsaturated limb representation and perform an initial step of the reduction. This is a variant of sqrUSL which is to be used when sqrUSL leads to overflows. A generic reduction algorithm to be applied to the outputs of mulUSL/sqrUSL or mulUSLa/sqrUSLa. An algorithm to be applied to the outputs of mulUSL/sqrUSL or mulUSLa/sqrUSLa when the prime is of type A. For such primes, reduceUSLA is more efficient than reduceUSL. An algorithm to be applied to the outputs of mulUSL/sqrUSL or mulUSLa/sqrUSLa when the prime is of type B. For such primes, reduceUSLB is more efficient than reduceUSL or reduceUSLA. Denotes the algorithm triplet which computes a field multiplication, squaring and inverse using mulUSL, sqrUSL and reduceUSL. Denotes the algorithm triplet which computes a field multiplication, squaring and inverse using mulUSLA, sqrSLA and reduceUSLA. Denotes the algorithm triplet which computes a field multiplication, squaring and inverse using mulUSLB, sqrUSLB and reduceUSLB. Denotes the algorithm triplet which computes a field multiplication, squaring and inverse using mulUSLB, sqrUSLB and reduceUSLB.</p>

    <p class="text-gray-300">The implementations of the various algorithms are divided into two groups.</p>

    <p class="text-gray-300">The algorithms farith-SLa, farith-USL, farith-USLA, farith-USLB and farith-USLa have been implemented in assembly using only the instructions mul, imul, add and adc to do arithmetic. These implementations are downward compatible with previous generations of Intel processors. The implementations of the algorithms farithx-SLMP and farithx-SLPMP also use the instructions mulx, adcx and adox for doing arithmetic. These implementations work on the Broadwell and later generation processors.</p>

    <p class="text-gray-300">Descriptions of the algorithms. We describe a number of algorithms. The descriptions of the algorithms are at a fairly high level. They are provided in a form which make it easy to understand the algorithms and present the proofs of correctness. For the various reduction algorithms, the input is considered to be a polynomial <span class="math">h^{(0)}(\\theta)</span>, with <span class="math">\\theta=2^{\\eta}</span>, and the output is <span class="math">h^{(k)}(\\theta)</span> for some <span class="math">k\\geq 1</span>, such that</p>

    <p class="text-gray-300"><span class="math">h^{(0)}(\\theta)\\equiv h^{(1)}(\\theta)\\equiv\\cdots\\equiv h^{(k)}(\\theta)\\bmod p.</span></p>

    <p class="text-gray-300">Conceptually, the algorithm proceeds in stages where the <span class="math">i</span>-th stage computes <span class="math">h^{(i)}(\\theta)</span> from <span class="math">h^{(i-1)}(\\theta)</span> for <span class="math">i=1,2,\\ldots,k</span>. The proofs of correctness show that <span class="math">h^{(i)}(\\theta)\\equiv h^{(i-1)}(\\theta)\\bmod p</span> and also provide precise bounds on the coefficients of <span class="math">h^{(i)}(\\theta)</span>. In order to define the polynomials <span class="math">h^{(i)}(\\theta)</span>, the algorithms use certain statements which simply copy some of the coefficients of <span class="math">h^{(i-1)}(\\theta)</span> to <span class="math">h^{(i)}(\\theta)</span>. Also, for ease of reference in the proofs, certain temporary variables are indexed by the loop counter creating the impression that a number of such variables are required, whereas in actual implementation one variable is sufficient.</p>

    <p class="text-gray-300">For actual assembly implementation, it is desirable to use the registers as much as possible and also to avoid using load/store instructions to the extent possible. As such, the strict distinction between the various stages of the algorithm is not maintained so that some of the copy statements become redundant and are not implemented. Also, the use of temporary variables are minimized as much as possible and such variables are reused whenever feasible. Modulo such routine simplifications, the implementations follow the general flow of the algorithms. For each of the algorithms, we provide efficient assembly implementations for a number of primes. Studying the code together with the algorithm descriptions will make the associations between them clear and lead to a better understanding of the code.</p>

    <p class="text-gray-300">5 Integer Multiplication/Squaring for Saturated Limb Representation Using Independent Carry Chains</p>

    <p class="text-gray-300">Let <span class="math">c</span> be an <span class="math">\\eta</span>-bit constant, <span class="math">\\theta=2^{\\eta}</span> and <span class="math">f(\\theta)</span> be a polynomial in <span class="math">\\theta</span> of degree at most <span class="math">d-1</span> whose coefficients are from <span class="math">\\mathbb{Z}_{\\theta}</span>. A basic step in the multiplication and squaring algorithms is the computation <span class="math">c\\cdot f(\\theta)</span>. The result is a polynomial <span class="math">h(\\theta)</span> of degree at most <span class="math">d</span> and whose coefficients are from <span class="math">\\mathbb{Z}_{\\theta}</span>. Function mulSCC given in Algorithm 2 performs this computation.</p>

    <p class="text-gray-300">Algorithm 2 Multiply <span class="math">f(\\theta)</span> with an <span class="math">\\eta</span>-bit constant <span class="math">c</span>; <span class="math">\\theta=2^{\\eta},\\eta=64</span>. 1: function mulSCC(<span class="math">f(\\theta),c</span>) 2: input: <span class="math">f(\\theta)=f_{0}+f_{1}\\theta+\\cdots+f_{d-1}\\theta^{d-1}</span>, <span class="math">c</span>, where <span class="math">0\\leq c,f_{0},f_{1},\\ldots,f_{d-1}&lt;2^{\\eta}</span> and <span class="math">d\\geq 1</span>. 3: output: <span class="math">h(\\theta)=h_{0}+h_{1}\\theta+\\cdots+h_{d}\\theta^{d}=c\\cdot f</span>, where <span class="math">0\\leq h_{0},h_{1},\\ldots,h_{d}&lt;2^{\\eta}</span>. 4: <span class="math">t\\leftarrow c\\cdot f_{0}</span>; <span class="math">h_{0}\\leftarrow t\\bmod 2^{\\eta}</span>; <span class="math">h_{1}\\leftarrow\\lfloor t/2^{\\eta}\\rfloor</span> 5: <span class="math">\\mathfrak{c}\\leftarrow 0</span> 6: for <span class="math">i\\leftarrow 1</span> to <span class="math">d-1</span> do 7: <span class="math">t\\leftarrow c\\cdot f_{i}</span>; <span class="math">h_{i+1}\\leftarrow\\lfloor t/2^{\\eta}\\rfloor</span> 8: <span class="math">t\\leftarrow h_{i}+t\\bmod 2^{\\eta}+\\mathfrak{c}</span>; <span class="math">h_{i}\\leftarrow t\\bmod 2^{\\eta}</span>; <span class="math">\\mathfrak{c}\\leftarrow\\lfloor t/2^{\\eta}\\rfloor</span> 9: end for 10: <span class="math">h_{d}\\leftarrow h_{d}+\\mathfrak{c}</span> 11: return <span class="math">h(\\theta)=h_{0}+h_{1}\\theta+\\cdots+h_{d}\\theta^{d}</span> 12: end function.</p>

    <p class="text-gray-300">The multiplication in Step 4 of mulSCC can be completed using a single mulx operation. The for loop in Steps 6 to 9 uses an interleaved sequence of multiplications and additions. The additions involve a carry propagation through the variable <span class="math">\\mathfrak{c}</span>. Step 4 can be completed using a single mulx instruction while Step 5 can be completed using an adc instruction. The single bit value of the carry variable <span class="math">\\mathfrak{c}</span> is carried through CF. Note that mulx does not affect CF and so it is possible to use adc instructions to implement the carry chain. Since the mul instruction affects CF, using mul instead of mulx would not have allowed an efficient implementation of the carry chain using adc instructions.</p>

    <p class="text-gray-300">The single carry chain of mulSCC is pictorially depicted in Figure 1(a). The horizontal rectangular boxes denote the two <span class="math">\\eta</span>-bit quantities arising out of the multiplication shown at the left end of the corresponding row. The vertical oval shape encapsulates the quantities that are added using the adc instruction. These consist of two <span class="math">\\eta</span>-bit quantities and the carry <span class="math">\\mathfrak{c}</span> whose value is available in the CF flag.</p>

    <p class="text-gray-300">In general, it is required to multiply two integers written as polynomials <span class="math">f(\\theta)</span> and <span class="math">g(\\theta)</span> having degrees <span class="math">d</span> and <span class="math">e</span> respectively. This is performed using Function mulSLDCC given in Algorithm 3. The algorithm is written in a manner so that there are two independent carry chains in action. This is illustrated in Figure 1(b).</p>

    <p class="text-gray-300">Algorithm 3 Multiply <span class="math">f(\\theta)</span> and <span class="math">g(\\theta)</span>; <span class="math">\\theta=2^{\\eta},\\eta=64</span>. 1: function mulSLDCC(<span class="math">f(\\theta),g(\\theta)</span>) 2: input: <span class="math">f(\\theta)=f_{0}+f_{1}\\theta+\\cdots+f_{d-1}\\theta^{d-1}</span> and <span class="math">g(\\theta)=g_{0}+g_{1}\\theta+\\cdots+g_{e-1}\\theta^{e-1}</span>, where <span class="math">0\\leq f_{0},f_{1},\\ldots,f_{d-1},g_{0},g_{1},\\ldots,g_{e-1}&lt;2^{\\eta}</span>, and <span class="math">d\\geq e\\geq 2</span>. 3: output: <span class="math">h(\\theta)=h_{0}+h_{1}\\theta+\\cdots+h_{d+e-1}\\theta^{d+e-1}=f\\cdot g</span>, where <span class="math">0\\leq h_{0},h_{1},\\ldots,h_{d+e-1}&lt;2^{\\eta}</span>. 4: <span class="math">h_{0}+h_{1}\\theta+\\cdots+h_{d}\\theta^{d}\\leftarrow</span> mulSCC(<span class="math">f(\\theta),g_{0}</span>) 5: for <span class="math">i\\leftarrow 1</span> to <span class="math">e-1</span> do 6: <span class="math">\\mathfrak{c}_{1}\\leftarrow 0</span>; <span class="math">\\mathfrak{c}_{2}\\leftarrow 0</span> 7: for <span class="math">j\\leftarrow 0</span> to <span class="math">d-1</span> do 8: <span class="math">t\\leftarrow g_{i}\\cdot f_{j}</span> 9: <span class="math">r\\leftarrow h_{i+j}+(t\\bmod 2^{\\eta})+\\mathfrak{c}_{1}</span> 10: <span class="math">s\\leftarrow h_{i+j+1}+\\lfloor t/2^{\\eta}\\rfloor+\\mathfrak{c}_{2}</span> 11: <span class="math">h_{i+j}\\leftarrow r\\bmod 2^{\\eta}</span>; <span class="math">\\mathfrak{c}_{1}\\leftarrow\\lfloor r/2^{\\eta}\\rfloor</span> 12: <span class="math">h_{i+j+1}\\leftarrow s\\bmod 2^{\\eta}</span>; <span class="math">\\mathfrak{c}_{2}\\leftarrow\\lfloor s/2^{\\eta}\\rfloor</span> 13: end for 14: <span class="math">h_{i+j+1}\\leftarrow h_{i+j+1}+\\mathfrak{c}_{1}</span> 15: end for 16: return <span class="math">h(\\theta)=h_{0}+h_{1}\\theta+\\cdots+h_{d+e-1}\\theta^{d+e-1}</span> 17: end function.</p>

    <p class="text-gray-300">The multiplications in mulSLDCC are independent and can be performed simultaneously. The two</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> (a) Single carry chain for mulSCC. (b) Two independent carry chains for mulSLDCC. Figure 1: Illustration of carry chains.</p>

    <p class="text-gray-300">additions are also independent and can be performed simultaneously. The additions, however, depend on the result of the previous multiplication. The mulx instruction is used to perform the multiplications. This instruction does not affect either CF or OF. The two independent carry chains arising in Function mulSLDCC (and as illustrated in Figure 1b) are implemented using a sequence of adcx and adox instructions. The adcx instruction uses CF to propagate the carry while the adox instruction uses OF to propagate the carry.</p>

    <p class="text-gray-300">Intel processors have multiple ALUs. So, the independent additions can be simultaneously executed on two separate ALUs. Further, subject to availability, the independent multiplications can be scheduled on separate ALUs and the multiplications and additions can be scheduled in a pipelined manner on separate ALUs such that the time for addition does not cause any delay in the overall computation.</p>

    <p class="text-gray-300">Squaring an integer of the form  <span class="math">f(\\theta)</span>  can be performed by setting both inputs in mulSLDCC to be equal to  <span class="math">f(\\theta)</span> . On the other hand, it is possible to reduce the number of multiplications. Function sqrSLDCC given in Algorithm 4 squares  <span class="math">f(\\theta)</span> . It consists of three phases. In the first phase, the cross product terms are computed; in the second phase, these are multiplied by 2 (which is a doubling operation); and in the third phase, the squares of the coefficients of  <span class="math">f(\\theta)</span>  are computed. Multiplications are performed in the first and the third phase. In the first phase, two independent carry chains arise in a manner similar to that of mulSLDCC. These two chains are implemented using the instructions mulx, adcx and adox. In the third phase, there is a single carry chain which is implemented using the instructions mulx and adc in a manner similar to that used in mulSCC.</p>

    <p class="text-gray-300">For  <span class="math">p = 2^m - \\delta</span> , elements of  <span class="math">\\mathbb{F}_p</span>  are  <span class="math">m</span> -bit integers and have a  <span class="math">(\\kappa, \\eta, \\nu)</span> -representation. In this section, we consider saturated limb representation and so  <span class="math">\\eta = 64</span> . As mentioned earlier, a multiplication/squaring in  <span class="math">\\mathbb{F}_p</span>  consists of an integer multiplication/squaring followed by a reduction. The integer multiplication and squaring operations are respectively performed by the functions mulSLDCC and sqrSLDCC described in Section 5. In both cases, two  <span class="math">m</span> -bit integers having  <span class="math">(\\kappa, \\eta, \\nu)</span> -representations are multiplied and the product is a  <span class="math">2m</span> -bit integer having  <span class="math">(\\kappa&#x27;, \\eta, \\nu&#x27;)</span> -representation where the values of  <span class="math">\\kappa&#x27;</span>  and  <span class="math">\\nu&#x27;</span>  are given by Proposition 1. The task of the reduction is to reduce the product modulo  <span class="math">p</span>  to an  <span class="math">m</span> -bit integer which again has a  <span class="math">(\\kappa, \\eta, \\nu)</span> -representation.</p>

    <p class="text-gray-300">We provide two reduction algorithms using the saturated limb representation, namely reduceSLMP which works for Mersenne primes and reduceSLPMP which works for pseudo-Mersenne primes. A</p>

    <p class="text-gray-300">Algorithm 4 Square  <span class="math">f(\\theta)</span> ;  <span class="math">\\theta = 2^{\\eta}</span> ,  <span class="math">\\eta = 64</span> . 1: function sqrSLDCC(f(θ)) 2: input:  <span class="math">f(\\theta) = f_0 + f_1\\theta + \\dots + f_{d-1}\\theta^{d-1}</span>  such that  <span class="math">0 \\leq f_0, f_1, \\ldots, f_{d-1} &amp;lt; 2^\\eta</span> . 3: output:  <span class="math">h = h_0 + h_1\\theta + \\dots + h_{2d-1}\\theta^{2d-1} = f^2</span>  such that  <span class="math">0 \\leq h_0, h_1, \\ldots, h_{2d-1} &amp;lt; 2^\\eta</span> . 4:  <span class="math">h_1 + h_2\\theta + \\dots + h_d\\theta^d \\gets \\text{mulSCC}(f_1 + f_2\\theta + \\dots + f_{d-1}\\theta^{d-2}, f_0)</span> 5: for  <span class="math">i \\gets 1</span>  to  <span class="math">d-3</span>  do  <span class="math">h_{d+i} \\gets 0</span>  end for 6: for  <span class="math">i \\gets 1</span>  to  <span class="math">d-3</span>  do 7:  <span class="math">\\mathfrak{c}_1 \\gets 0</span> ;  <span class="math">\\mathfrak{c}_2 \\gets 0</span> 8: for  <span class="math">j \\gets i+1</span>  to  <span class="math">d-1</span>  do 9:  <span class="math">t \\gets f_i \\cdot f_j</span> 10:  <span class="math">r \\gets h_{i+j} + (t \\bmod 2^\\eta) + \\mathfrak{c}_1</span> ;  <span class="math">s \\gets h_{i+j+1} + \\lfloor t/2^\\eta \\rfloor + \\mathfrak{c}_2</span> 11:  <span class="math">h_{i+j} \\gets r \\bmod 2^\\eta</span> ;  <span class="math">\\mathfrak{c}_1 \\gets \\lfloor r/2^\\eta \\rfloor</span> 12:  <span class="math">h_{i+j+1} \\gets s \\bmod 2^\\eta</span> ;  <span class="math">\\mathfrak{c}_2 \\gets \\lfloor s/2^\\eta \\rfloor</span> 13: end for 14:  <span class="math">h_{i+j+1} \\gets h_{i+j+1} + \\mathfrak{c}_1</span> 15: end for 16:  <span class="math">t \\gets f_{d-1} \\cdot f_{d-2}</span> 17:  <span class="math">r \\gets h_{2d-3} + (t \\bmod 2^\\eta)</span> ;  <span class="math">h_{2d-3} \\gets r \\bmod 2^\\eta</span> 18:  <span class="math">\\mathfrak{c} \\gets \\lfloor r/2^\\eta \\rfloor</span> ;  <span class="math">h_{2d-2} \\gets \\lfloor t/2^\\eta \\rfloor + \\mathfrak{c}</span> 19:  <span class="math">h_{2d-1} \\gets \\lfloor h_{2d-2}/2^{\\eta-1} \\rfloor</span> 20: for  <span class="math">i \\gets 2d-1</span>  down to 2 do  <span class="math">h_i \\gets (2h_i \\bmod 2^\\eta) + \\lfloor h_{i-1}/2^{\\eta-1} \\rfloor</span>  end for 21:  <span class="math">h_1 \\gets 2h_1 \\bmod 2^\\eta</span> 22:  <span class="math">t \\gets f_0 \\cdot f_0</span> 23:  <span class="math">h_0 \\gets t \\bmod 2^\\eta</span> ;  <span class="math">t \\gets h_1 + \\lfloor t/2^\\eta \\rfloor</span> 24:  <span class="math">h_1 \\gets t \\bmod 2^\\eta</span> ;  <span class="math">\\mathfrak{c} \\gets \\lfloor t/2^\\eta \\rfloor</span> 25: for  <span class="math">i \\gets 1</span>  to  <span class="math">d-1</span>  do 26:  <span class="math">t \\gets f_i \\cdot f_i</span> 27:  <span class="math">r \\gets h_{2i} + (t \\bmod 2^\\eta) + \\mathfrak{c}</span> ;  <span class="math">h_{2i} \\gets r \\bmod 2^\\eta</span> ;  <span class="math">\\mathfrak{c} \\gets \\lfloor r/2^\\eta \\rfloor</span> 28:  <span class="math">r \\gets h_{2i+1} + \\lfloor t/2^\\eta \\rfloor + \\mathfrak{c}</span> ;  <span class="math">h_{2i+1} \\gets r \\bmod 2^\\eta</span> ;  <span class="math">\\mathfrak{c} \\gets \\lfloor r/2^\\eta \\rfloor</span> 29: end for 30: return  <span class="math">h(\\theta) = h_0 + h_1\\theta + \\ldots + h_{2d-1}\\theta^{2d-1}</span> 31: end function.</p>

    <p class="text-gray-300">Algorithm 5 Reduction for saturated limb representation. Performs reduction modulo  <span class="math">p</span> , where  <span class="math">p = 2^m - 1</span>  is a Mersenne prime;  <span class="math">\\theta = 2^\\eta</span> . 1: function reduceSLMP(h(0)(θ)) 2: Input: h(0)(θ). 3: Output: h(3)(θ). 4: for i←2κ-1 down to κ do 5: h(1)←(2η-νh(0)) mod 2η + [h(0)/2ν]; h(1)←h(0) 6: end for 7: h(1)←h(0) mod 2ν 8: t←h(1) + h(1); h(2)←t mod 2η; c←[t/2η] 9: for i←1 to κ-2 do 10: t←h(1) + h(1) + c; h(2)←t mod 2η; c←[t/2η] 11: end for 12: h(2)←h(1) + h(1) + c 13: t←h(2) + [h(2)/2ν]; h(3)←t mod 2η; c←[t/2η] 14: for i←1 to κ-2 do 15: t←h(2) + c; h(3)←t mod 2η; c←[t/2η] 16: end for 17: h(3)←h(2) mod 2ν + c 18: FULL REDUCTION: return h(3)(θ) = h(3) + h(3)θ + ... + h(3)θκ-1 19: end function.</p>

    <p class="text-gray-300">Mersenne prime is also a pseudo-Mersenne prime and so reduceSLPMP also works for Mersenne primes, but, for such primes it will be slower than reduceSLMP. On the other hand, reduceSLMP does not work</p>

    <p class="text-gray-300">for pseudo-Mersenne primes.</p>

    <h2 id="sec-14" class="text-2xl font-bold">6.1 Mersenne Primes</h2>

    <p class="text-gray-300">Let <span class="math">p = 2^m - 1</span> and suppose <span class="math">m</span>-bit integers have a <span class="math">(\\kappa, \\eta, \\nu)</span>-representation. Function reduceSLMP given in Algorithm 5 takes as input the output of either mulSLDCC or sqrSLDCC and outputs an <span class="math">m</span>-bit integer in an <span class="math">(\\kappa, \\eta, \\nu)</span>-representation, which is congruent to the input modulo <span class="math">p</span>.</p>

    <p class="text-gray-300">The following result states the correctness of reduceSLMP</p>

    <p class="text-gray-300"><strong>Theorem 2.</strong> Let <span class="math">p = 2^m - 1</span> be a Mersenne prime and let <span class="math">\\kappa \\geq 2</span>, <span class="math">\\eta</span> and <span class="math">\\nu</span> be such that, <span class="math">m</span>-bit integers have a <span class="math">(\\kappa, \\eta, \\nu)</span>-representation. Suppose that the input <span class="math">h^{(0)}(\\theta)</span> to reduceSLMP is the output of either mulSLDCC <span class="math">(f(\\theta), g(\\theta))</span> or sqrSLDCC <span class="math">(f(\\theta))</span> where <span class="math">f(\\theta)</span> and <span class="math">g(\\theta)</span> represent <span class="math">m</span>-bit integers having <span class="math">(\\kappa, \\eta, \\nu)</span>-representations. Then the output <span class="math">h^{(3)}(\\theta)</span> of reduceSLMP has a <span class="math">(\\kappa, \\eta, \\nu)</span>-representation and <span class="math">h^{(3)}(\\theta) \\equiv h^{(0)}(\\theta) \\mod p</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Since <span class="math">m</span>-bit integers have a <span class="math">(\\kappa, \\eta, \\nu)</span>-representation, we have <span class="math">m = \\eta (\\kappa - 1) + \\nu</span> with <span class="math">0 &amp;lt; \\nu \\leq \\eta</span>. If <span class="math">\\nu = \\eta</span>, then <span class="math">m = \\kappa \\eta</span> and so <span class="math">p = 2^m - 1 = 2^{\\kappa \\eta} - 1 = (2^\\kappa)^\\eta - 1</span>, which has a factor <span class="math">2^\\kappa - 1</span> contradicting that <span class="math">p</span> is a prime. So, if <span class="math">p</span> is a Mersenne prime, then it necessarily follows that <span class="math">\\nu &amp;lt; \\eta</span>.</p>

    <p class="text-gray-300">The input <span class="math">h^{(0)}(\\theta)</span> to reduceSLMP is the product of two <span class="math">m</span>-bit integers each having a <span class="math">(\\kappa, \\eta, \\nu)</span>-representation. From Proposition 1, the <span class="math">2m</span>-bit integer <span class="math">h^{(0)}(\\theta)</span> has a <span class="math">(\\kappa&#x27;, \\eta, \\nu&#x27;)</span>-representation where the values of <span class="math">\\kappa&#x27;</span> and <span class="math">\\nu&#x27;</span> are given by Proposition 1. Using these values, we have the following bounds on the coefficients of <span class="math">h^{(0)}(\\theta)</span>.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} 0 \\leq h _ {0} ^ {(0)}, h _ {1} ^ {(0)}, \\dots , h _ {2 \\kappa - 3} ^ {(0)} &amp;lt; 2 ^ {\\eta}; \\quad \\text{and} \\\\ 0 \\leq h _ {2 \\kappa - 2} ^ {(0)} &amp;lt; 2 ^ {2 \\nu}, \\quad h _ {2 \\kappa - 1} ^ {(0)} = 0 \\quad \\text{if} \\quad 0 &amp;lt; \\nu \\leq \\eta / 2; \\tag {9} \\\\ 0 \\leq h _ {2 \\kappa - 2} ^ {(0)} &amp;lt; 2 ^ {\\eta}, \\quad 0 \\leq h _ {2 \\kappa - 1} ^ {(0)} &amp;lt; 2 ^ {2 \\nu - \\eta} \\quad \\text{if} \\quad \\eta / 2 &amp;lt; \\nu &amp;lt; \\eta. \\end{array}</span></div>

    <p class="text-gray-300">The input <span class="math">h^{(0)}(\\theta)</span> can be written as</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} h ^ {(0)} (\\theta) = h _ {0} ^ {(0)} + h _ {1} ^ {(0)} \\theta + \\dots + h _ {\\kappa - 1} ^ {(0)} \\theta^ {\\kappa - 1} + h _ {\\kappa} ^ {(0)} \\theta^ {\\kappa} + h _ {\\kappa + 1} ^ {(0)} \\theta^ {\\kappa + 1} + \\dots + h _ {2 \\kappa - 1} ^ {(0)} \\theta^ {2 \\kappa - 1}, \\\\ = \\left(h _ {0} ^ {(0)} + h _ {1} ^ {(0)} \\theta + \\dots + h _ {\\kappa - 1} ^ {(0)} \\theta^ {\\kappa - 1}\\right) + \\left(h _ {\\kappa} ^ {(0)} + h _ {\\kappa + 1} ^ {(0)} \\theta + \\dots + h _ {2 \\kappa - 1} ^ {(0)} \\theta^ {\\kappa - 1}\\right) \\theta^ {\\kappa}, \\\\ \\equiv \\left(h _ {0} ^ {(0)} + h _ {1} ^ {(0)} \\theta + \\dots + h _ {\\kappa - 1} ^ {(0)} \\theta^ {\\kappa - 1}\\right) + \\left(h _ {\\kappa} ^ {(0)} + h _ {\\kappa + 1} ^ {(0)} \\theta + \\dots + h _ {2 \\kappa - 1} ^ {(0)} \\theta^ {\\kappa - 1}\\right) 2 ^ {\\eta - \\nu} \\bmod p, \\tag {10} \\end{array}</span></div>

    <p class="text-gray-300">since using (5) and <span class="math">\\delta = 1</span>, we have <span class="math">\\theta^{\\kappa} = 2^{\\kappa \\eta} = 2^{(\\kappa -1)\\eta +\\nu}\\cdot 2^{\\eta -\\nu} = 2^{m}\\cdot 2^{\\eta -\\nu}\\equiv 2^{\\eta -\\nu}\\bmod p</span>. For <span class="math">j = \\kappa -1,\\kappa ,\\ldots ,2\\kappa -2</span>, define</p>

    <div class="my-4 text-center"><span class="math-block">h _ {j} ^ {(0)} = h _ {j, 0} ^ {(0)} + h _ {j, 1} ^ {(0)} 2 ^ {\\nu}, \\text{ where } h _ {j, 0} ^ {(0)} = h _ {j} ^ {(0)} \\bmod 2 ^ {\\nu}, \\text{ and } h _ {j, 1} ^ {(0)} = \\left[ h _ {j} ^ {(0)} / 2 ^ {\\nu} \\right]. \\tag {11}</span></div>

    <p class="text-gray-300">Using (9), we have the following bounds on <span class="math">h_{j,0}^{(0)}</span> and <span class="math">h_{j,1}^{(0)}</span>.</p>

    <p class="text-gray-300"><strong>Claim 1.</strong> <span class="math">0 \\leq h_{j,0}^{(0)} &amp;lt; 2^{\\nu}</span> for <span class="math">j = \\kappa - 1, \\kappa, \\ldots, 2\\kappa - 2</span>; <span class="math">0 \\leq h_{j,1}^{(0)} &amp;lt; 2^{\\eta - \\nu}</span> for <span class="math">j = \\kappa - 1, \\kappa, \\ldots, 2\\kappa - 3</span>; and <span class="math">0 \\leq h_{2\\kappa - 2,1}^{(0)} &amp;lt; 2^{\\nu}</span> if <span class="math">0 &amp;lt; \\nu \\leq \\eta / 2</span>; <span class="math">0 \\leq h_{2\\kappa - 2,1}^{(0)} &amp;lt; 2^{\\eta - \\nu}</span> if <span class="math">\\eta / 2 &amp;lt; \\nu &amp;lt; \\eta</span>.</p>

    <p class="text-gray-300">Substituting (11) into (10) we obtain</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} h ^ {(0)} (\\theta) \\\\ \\equiv \\left(h _ {0} ^ {(0)} + h _ {1} ^ {(0)} \\theta + \\dots + h _ {\\kappa - 2} ^ {(0)} \\theta^ {\\kappa - 2} + \\left(h _ {\\kappa - 1, 0} ^ {(0)} + h _ {\\kappa - 1, 1} ^ {(0)} 2 ^ {\\nu}\\right) \\theta^ {\\kappa - 1}\\right) + \\\\ \\left(\\left(h _ {\\kappa , 0} ^ {(0)} + h _ {\\kappa , 1} ^ {(0)} 2 ^ {\\nu}\\right) + \\left(h _ {\\kappa + 1, 0} ^ {(0)} + h _ {\\kappa + 1, 1} ^ {(0)} 2 ^ {\\nu}\\right) \\theta + \\dots + \\left(h _ {2 \\kappa - 2, 0} ^ {(0)} + h _ {2 \\kappa - 2, 1} ^ {(0)} 2 ^ {\\nu}\\right) \\theta^ {\\kappa - 2}\\right) + \\\\ h _ {2 \\kappa - 1} ^ {(0)} \\theta^ {\\kappa - 1}) 2 ^ {\\eta - \\nu} \\bmod p \\\\ = \\left(h _ {0} ^ {(0)} + h _ {1} ^ {(0)} \\theta + \\dots + h _ {\\kappa - 2} ^ {(0)} \\theta^ {\\kappa - 2} + h _ {\\kappa - 1, 0} ^ {(0)} \\theta^ {\\kappa - 1}\\right) + \\\\ \\left(h _ {\\kappa - 1, 1} ^ {(0)} 2 ^ {((\\kappa - 1) \\eta + \\nu)} + h _ {\\kappa , 0} ^ {(0)} 2 ^ {\\eta - \\nu} + h _ {\\kappa , 1} ^ {(0)} 2 ^ {\\eta} + h _ {\\kappa + 1, 0} ^ {(0)} 2 ^ {2 \\eta - \\nu} + h _ {\\kappa + 1, 1} ^ {(0)} 2 ^ {2 \\eta} + \\dots + \\right. \\tag {12} \\\\ h _ {2 \\kappa - 2, 0} ^ {(0)} 2 ^ {(\\kappa - 1) \\eta - \\nu} + h _ {2 \\kappa - 2, 1} ^ {(0)} 2 ^ {(\\kappa - 1) \\eta} + h _ {2 \\kappa - 1} ^ {(0)} 2 ^ {\\kappa \\eta - \\nu}) [ \\text{using } \\theta = 2 ^ {\\eta} ] \\tag {13} \\\\ \\equiv \\left(h _ {0} ^ {(0)} + h _ {1} ^ {(0)} \\theta + \\dots + h _ {\\kappa - 2} ^ {(0)} \\theta^ {\\kappa - 2} + h _ {\\kappa - 1, 0} ^ {(0)} \\theta^ {\\kappa - 1}\\right) + \\\\ \\left(h _ {\\kappa - 1, 1} ^ {(0)} + 2 ^ {\\eta - \\nu} h _ {\\kappa , 0} ^ {(0)}\\right) + \\left(h _ {\\kappa , 1} ^ {(0)} + 2 ^ {\\eta - \\nu} h _ {\\kappa + 1, 0} ^ {(0)}\\right) \\theta + \\left(h _ {\\kappa + 1, 1} ^ {(0)} + 2 ^ {\\eta - \\nu} h _ {\\kappa + 2, 0} ^ {(0)}\\right) \\theta^ {2} + \\dots + \\\\ \\left(h _ {2 \\kappa - 3, 1} ^ {(0)} + 2 ^ {\\eta - \\nu} h _ {2 \\kappa - 2, 0} ^ {(0)}\\right) \\theta^ {\\kappa - 2} + \\left(h _ {2 \\kappa - 2, 1} ^ {(0)} + 2 ^ {\\eta - \\nu} h _ {2 \\kappa - 1} ^ {(0)}\\right) \\theta^ {\\kappa - 1} \\bmod p [ \\text{using (5) and } \\delta = 1 ]. \\tag {14} \\end{array}</span></div>

    <p class="text-gray-300">In reduceSLMP, Steps 4 to 7 perform the computations in (14), giving us</p>

    <div class="my-4 text-center"><span class="math-block">h ^ {(0)} (\\theta) \\equiv \\underbrace {\\left(h _ {0} ^ {(1)} + h _ {1} ^ {(1)} \\theta + \\cdots + h _ {\\kappa - 1} ^ {(1)} \\theta^ {\\kappa - 1}\\right) + \\left(h _ {\\kappa} ^ {(1)} + h _ {\\kappa + 1} ^ {(1)} \\theta + \\cdots + h _ {2 \\kappa - 1} ^ {(1)} \\theta^ {\\kappa - 1}\\right)} _ {\\text {through Steps 4 to 7}} = h ^ {(1)} (\\theta), \\tag {15}</span></div>

    <p class="text-gray-300">where  <span class="math">h_j^{(1)} = h_j^{(0)}</span>  for  <span class="math">j = 1,2,\\ldots ,\\kappa -2</span> ,  <span class="math">h_{\\kappa -1}^{(1)} = h_{\\kappa -1,0}^{(0)}</span></p>

    <div class="my-4 text-center"><span class="math-block">h _ {j} ^ {(1)} = 2 ^ {\\eta - \\nu} h _ {j, 0} ^ {(0)} + h _ {j - 1, 1} ^ {(0)} \\mathrm {f o r} j = \\kappa , \\kappa + 1, \\ldots , 2 \\kappa - 2, \\mathrm {a n d} h _ {2 \\kappa - 1} ^ {(1)} = 2 ^ {\\eta - \\nu} h _ {2 \\kappa - 1} ^ {(0)} + h _ {2 \\kappa - 2, 1} ^ {(0)}.</span></div>

    <p class="text-gray-300">In (15), it directly follows that  <span class="math">0 \\leq h_0^{(1)}, h_1^{(1)}, \\ldots, h_{\\kappa - 2}^{(1)} &amp;lt; 2^\\eta</span>  and  <span class="math">h_{\\kappa - 1}^{(1)} &amp;lt; 2^\\nu</span> . The bounds on  <span class="math">h_\\kappa^{(1)}, h_{\\kappa + 1}^{(1)}, \\ldots, h_{2\\kappa - 1}^{(1)}</span>  are given in the following result.</p>

    <p class="text-gray-300"><strong>Claim 2.</strong>  <span class="math">0 \\leq h_{\\kappa}^{(1)}, h_{\\kappa + 1}^{(1)}, \\ldots, h_{2\\kappa - 2}^{(1)} &amp;lt; 2^{\\eta}</span>  and  <span class="math">0 \\leq h_{2\\kappa - 1}^{(1)} &amp;lt; 2^{\\nu}</span> .</p>

    <p class="text-gray-300"><strong>Proof.</strong> Using Claim 1, for  <span class="math">j = \\kappa, \\kappa + 1, \\ldots, 2\\kappa - 2</span>  we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} 0 \\leq h _ {j} ^ {(1)} = \\left\\lfloor h _ {j - 1} ^ {(0)} / 2 ^ {\\nu} \\right\\rfloor + \\left(2 ^ {\\eta - \\nu} h _ {j} ^ {(0)}\\right) \\bmod 2 ^ {\\eta} \\\\ = h _ {j - 1, 1} ^ {(0)} + \\left(2 ^ {\\eta - \\nu} h _ {j, 0} ^ {(0)} + 2 ^ {\\eta} h _ {j, 1} ^ {(0)}\\right) \\bmod 2 ^ {\\eta} \\\\ = h _ {j - 1, 1} ^ {(0)} + 2 ^ {\\eta - \\nu} h _ {j, 0} ^ {(0)}, \\\\ \\end{array}</span></div>

    <p class="text-gray-300">which implies  <span class="math">0 \\leq h_{j}^{(1)} &amp;lt; 2^{\\eta - \\nu} + 2^{\\eta - \\nu}(2^{\\nu} - 1) = 2^{\\eta}</span> . The argument for the bounds on  <span class="math">h_{2\\kappa - 1}^{(1)}</span>  is in two cases.</p>

    <p class="text-gray-300"><strong>Case 1:</strong>  <span class="math">0 &amp;lt; \\nu \\leq \\eta /2</span> . From (9) and Claim 1,  <span class="math">h_{2\\kappa -1}^{(1)} = 2^{\\eta -\\nu}h_{2\\kappa -1}^{(0)} + h_{2\\kappa -2,1}^{(0)} &amp;lt; 2^{\\nu}</span> .</p>

    <p class="text-gray-300"><strong>Case 2:</strong>  <span class="math">\\eta / 2 &amp;lt; \\nu &amp;lt; \\eta</span> . From (9) and Claim 1,  <span class="math">h_{2\\kappa - 1}^{(1)} = 2^{\\eta - \\nu} h_{2\\kappa - 1}^{(0)} + h_{2\\kappa - 2,1}^{(0)} &amp;lt; 2^{\\eta - \\nu} (2^{2\\nu - \\eta} - 1) + 2^{\\eta - \\nu} = 2^{\\nu}</span> .</p>

    <p class="text-gray-300">In Steps 8 to 12, we pairwise add the coefficients of  <span class="math">\\theta^0,\\theta^1,\\ldots ,\\theta^{\\kappa -1}</span>  sequentially in (15) by forwarding the 1-bit carry to the subsequent pair to get an intermediate  <span class="math">\\kappa</span>  -limb polynomial  <span class="math">h^{(2)}</span>  as</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} h ^ {(1)} (\\theta) = \\left(h _ {0} ^ {(1)} + h _ {\\kappa} ^ {(1)}\\right) + \\left(h _ {1} ^ {(1)} + h _ {\\kappa + 1} ^ {(1)}\\right) \\theta + \\dots + \\left(h _ {\\kappa - 1} ^ {(1)} + h _ {2 \\kappa - 1} ^ {(1)}\\right) \\theta^ {\\kappa - 1}, \\\\ = \\underbrace {h _ {0} ^ {(2)} + h _ {1} ^ {(2)} \\theta + \\cdots + h _ {\\kappa - 1} ^ {(2)} \\theta^ {\\kappa - 1}} _ {\\text {through Steps 8 to 12}} = h ^ {(2)} (\\theta). \\tag {16} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">From the computation done in the Steps 8 to 11 it follows that</p>

    <div class="my-4 text-center"><span class="math-block">0 \\leq h _ {0} ^ {(2)}, h _ {1} ^ {(2)}, \\dots , h _ {\\kappa - 2} ^ {(2)} &amp;lt;   2 ^ {\\eta}. \\tag {17}</span></div>

    <p class="text-gray-300">Also, since  <span class="math">0 \\leq h_{\\kappa - 1}^{(1)}, h_{2\\kappa - 1}^{(1)} \\leq 2^{\\nu} - 1</span>  and  <span class="math">0 \\leq \\mathfrak{c} \\leq 1</span> , we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} 0 \\leq h _ {\\kappa - 1} ^ {(2)} = h _ {\\kappa - 1} ^ {(1)} + h _ {2 \\kappa - 1} ^ {(1)} + \\mathfrak {c} \\leq 2 ^ {\\nu + 1} - 1 \\tag {18} \\\\ \\leq 2 ^ {\\eta} - 1 \\text {(using} \\nu &amp;lt;   \\eta). \\tag {19} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">From (15), (16), (17) and (18), we have  <span class="math">h^{(2)}(\\theta) \\equiv h^{(0)}(\\theta) \\mod p</span>  and  <span class="math">h^{(2)}(\\theta)</span>  has a  <span class="math">(\\kappa, \\eta, \\nu + 1)</span> -representation.</p>

    <p class="text-gray-300">Equation (19) proves that Step 12 does not lead to an overflow. Define</p>

    <div class="my-4 text-center"><span class="math-block">h _ {\\kappa - 1} ^ {(2)} = h _ {\\kappa - 1, 0} ^ {(2)} + h _ {\\kappa - 1, 1} ^ {(2)} 2 ^ {\\nu}, \\text { where } h _ {\\kappa - 1, 0} ^ {(2)} = h _ {\\kappa - 1} ^ {(2)} \\bmod 2 ^ {\\nu} \\text { and } h _ {\\kappa - 1, 1} ^ {(2)} = \\lfloor h _ {\\kappa - 1} ^ {(2)} / 2 ^ {\\nu} \\rfloor . \\tag {20}</span></div>

    <p class="text-gray-300">From (18), it follows that that  <span class="math">0 \\leq h_{\\kappa - 1,0}^{(2)} &amp;lt; 2^{\\nu}</span>  and  <span class="math">0 \\leq h_{\\kappa - 1,1}^{(2)} \\leq 1</span> . We write</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} h ^ {(2)} (\\theta) = h _ {0} ^ {(2)} + h _ {1} ^ {(2)} \\theta + \\dots + h _ {\\kappa - 2} ^ {(2)} \\theta^ {\\kappa - 2} + \\left(h _ {\\kappa - 1, 0} ^ {(2)} + h _ {\\kappa - 1, 1} ^ {(2)} 2 ^ {\\nu}\\right) \\theta^ {\\kappa - 1} \\\\ = h _ {0} ^ {(2)} + h _ {1} \\theta + \\dots + h _ {\\kappa - 2} ^ {(2)} \\theta^ {\\kappa - 2} + h _ {\\kappa - 1, 0} ^ {(2)} \\theta^ {\\kappa - 1} + h _ {\\kappa - 1, 1} ^ {(2)} 2 ^ {(\\kappa - 1) \\eta + \\nu} \\\\ \\equiv \\left(h _ {0} ^ {(2)} + h _ {\\kappa - 1, 1} ^ {(2)}\\right) + h _ {1} ^ {(2)} \\theta + \\dots + h _ {\\kappa - 2} ^ {(2)} \\theta^ {\\kappa - 2} + h _ {\\kappa - 1, 0} ^ {(2)} \\theta^ {\\kappa - 1} \\bmod p [ \\text {using (5) and} \\delta = 1 ]. \\tag {21} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">The following result is crucial in arguing that the carry will be absorbed at some point in the computation.</p>

    <p class="text-gray-300">Claim 3.</p>

    <p class="text-gray-300">If <span class="math">h^{(2)}_{\\kappa-1,1}=1</span>, then it is impossible to simultaneously have <span class="math">h^{(2)}_{0}=h^{(2)}_{1}=\\dots=h^{(2)}_{\\kappa-2}=2^{\\eta}-1</span> and <span class="math">h^{(2)}_{\\kappa-1,0}=2^{\\nu}-1</span>.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose <span class="math">h^{(2)}_{\\kappa-1,1}=1</span> and let if possible, <span class="math">h^{(2)}_{0}=h^{(2)}_{1}=\\dots=h^{(2)}_{\\kappa-2}=2^{\\eta}-1</span>, <span class="math">h^{(2)}_{\\kappa-1,0}=2^{\\nu}-1</span>. So, from (20), we have <span class="math">h^{(2)}_{\\kappa-1}=h^{(2)}_{\\kappa-1,0}+h^{(2)}_{\\kappa-1,1}2^{\\nu}=2^{\\nu+1}-1</span>. In this case, the polynomial <span class="math">h^{(2)}(\\theta)</span> is given as follows.</p>

    <p class="text-gray-300"><span class="math">h^{(2)}(\\theta)</span> <span class="math">=h^{(2)}_{0}+h^{(2)}_{1}\\theta+\\dots+h^{(2)}_{\\kappa-1}\\theta^{\\kappa-1},</span> <span class="math">=(2^{\\eta}-1)+(2^{\\eta}-1)2^{\\eta}+\\dots+(2^{\\nu+1}-1)2^{(\\kappa-1)\\eta},</span> <span class="math">=2^{(\\kappa-1)\\eta+\\nu+1}-1,</span> <span class="math">=2^{m+1}-1\\text{ [using \\eqref{eq:21}]}.</span> (22)</p>

    <p class="text-gray-300">From (16), <span class="math">h^{(2)}(\\theta)</span> is obtained by adding the polynomials <span class="math">(h^{(1)}_{0}+h^{(1)}_{1}\\theta+\\dots+h^{(1)}_{\\kappa-1}\\theta^{\\kappa-1})</span> and <span class="math">(h^{(1)}_{\\kappa}+h^{(1)}_{\\kappa+1}\\theta+\\dots+h^{(1)}_{2\\kappa-1}\\theta^{\\kappa-1})</span>, where <span class="math">0\\leq h^{(1)}_{0},h^{(1)}_{1},\\dots,h^{(1)}_{\\kappa-2},h^{(1)}_{\\kappa},\\dots,h^{(1)}_{2\\kappa-2}&lt;2^{\\eta}</span> and <span class="math">0\\leq h^{(1)}_{\\kappa-1},h^{(1)}_{2\\kappa-1}&lt;2^{\\nu}</span>. So, the maximum possible value of each of the polynomials is <span class="math">2^{m}-1</span> and hence the bounds of <span class="math">h^{(2)}(\\theta)</span> should be <span class="math">0\\leq h^{(2)}(\\theta)&lt;2^{m+1}-1</span>, which contradicts what is obtained in (22). Hence the result. ∎</p>

    <p class="text-gray-300">The computation <span class="math">h^{(3)}_{0}=(h^{(2)}_{0}+\\lfloor h^{(2)}_{\\kappa-1}/2^{\\nu}\\rfloor)\\bmod 2^{\\eta}</span> in (21) is performed in Step 13, and the 1-bit <span class="math">\\mathfrak{c}</span> is forwarded to the subsequent terms for addition, which are performed in Steps 14 to 17 producing the values of <span class="math">h^{(3)}_{1},h^{(3)}_{2},\\dots,h^{(3)}_{\\kappa-1}</span>. Hence, (21) can be written as</p>

    <p class="text-gray-300"><span class="math">h^{(2)}(\\theta)\\equiv\\underbrace{h^{(3)}_{0}+h^{(3)}_{1}\\theta+\\dots+h^{(3)}_{\\kappa-1}\\theta^{\\kappa-1}}_{\\text{through Steps 14 to 17}}\\bmod\\,p=h^{(3)}(\\theta).</span> (23)</p>

    <p class="text-gray-300">We now argue that either the <span class="math">\\mathfrak{c}</span> out of Step 13 is 0 or it is absorbed in one of the subsequent additions in Steps 15 or in the addition in Step 17. If <span class="math">h^{(2)}_{\\kappa-1,1}=0</span>, then the <span class="math">\\mathfrak{c}</span> out of Step 13 itself is 0. So, suppose that <span class="math">h^{(2)}_{\\kappa-1,1}=1</span>. From Claim 3, it follows that either there is a <span class="math">j\\in\\{0,1,\\dots,\\kappa-2\\}</span> such that <span class="math">h^{(2)}_{j}&lt;2^{\\eta}-1</span> or <span class="math">h^{(2)}_{\\kappa-1,0}&lt;2^{\\nu}-1</span>. In the former case, the <span class="math">\\mathfrak{c}</span> is absorbed by one of the additions in Step 15; if this does not happen, then the later case arises and the carry is absorbed by the addition in Step 17.</p>

    <p class="text-gray-300">This shows that the algorithm terminates without any overflow and at the end of the algorithm we have <span class="math">0\\leq h^{(3)}_{0},h^{(3)}_{1},\\dots,h^{(3)}_{\\kappa-2}&lt;2^{\\eta}</span> and <span class="math">0\\leq h^{(3)}_{\\kappa-1}&lt;2^{\\nu}</span> and so <span class="math">h^{(3)}(\\theta)</span> has a <span class="math">(\\kappa,\\eta,\\nu)</span>-representation. Further, By combining (15), (16), (21) and (23) we have <span class="math">h^{(3)}(\\theta)\\equiv h^{(0)}(\\theta)\\bmod p</span>, which proves the statement of the theorem on full reduction. ∎</p>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">6.2 Pseudo-Mersenne Primes</h3>

    <p class="text-gray-300">Let <span class="math">p=2^{m}-\\delta</span> and suppose <span class="math">m</span>-bit integers have a <span class="math">(\\kappa,\\eta,\\nu)</span>-representation. Function reduceSLPMP given in Algorithm 6 takes as input the output of either mulSLDCC or sqrSLDCC and outputs an <span class="math">m</span>-bit integer in an <span class="math">(\\kappa,\\eta,\\nu)</span>-representation which is congruent to the input modulo <span class="math">p</span>.</p>

    <p class="text-gray-300">As in the case of reduceSLMP, for the correctness of reduceSLPMP, it is not required to have <span class="math">\\eta=64</span>. The value of <span class="math">\\eta=64</span> is used for 64-bit implementation and the algorithm can equally well be used with <span class="math">\\eta</span>-bit arithmetic for any value of <span class="math">\\eta</span> (say <span class="math">\\eta=32</span> or <span class="math">\\eta=128</span>).</p>

    <p class="text-gray-300">We note that reduceSLMP does not work if <span class="math">\\delta&gt;1</span>. This may not be immediately obvious from the description of reduceSLMP. To see that reduceSLMP does not work when <span class="math">\\delta&gt;1</span>, one needs to consider the proof of correctness of the algorithm. In the proof of Theorem 2, the step from (13) to (14) uses <span class="math">2^{(\\kappa-1)\\eta+\\nu}=2^{m}\\equiv\\delta\\bmod p</span>. In the case of Mersenne primes, <span class="math">\\delta=1</span> and so the step from (13) to (14) works; for <span class="math">\\delta&gt;1</span>, this step does not work. Instead, we consider a multiplication of the upper half of the input by <span class="math">c_{p}=2^{\\eta-\\nu}\\delta</span> at the very beginning and then the resulting polynomial is reduced in several steps. Due to this multiplication, the number of iterations required to obtain the complete reduction in reduceSLPMP is one more than that required in reduceSLMP. Also, the termination argument (that after a certain stage there is no carry) is more complicated.</p>

    <h5 id="sec-17" class="text-base font-semibold mt-4">Remark:</h5>

    <p class="text-gray-300">The boolean condition in Step 22 of reduceSLPMP does not depend on the input <span class="math">h^{(0)}(\\theta)</span> and is determined entirely by <span class="math">\\eta</span>, <span class="math">\\nu</span> and <span class="math">\\alpha</span>. So, once the prime and the values of <span class="math">\\eta</span> and <span class="math">\\nu</span> are fixed, either the ‘then’ part of the ‘if’ statement will be required or, the ‘else’ part of the ‘if’ statement will be required. Among the primes considered in Table 3, the ‘else’ part is required only for the prime <span class="math">2^{256}-2^{32}-977</span>.</p>

    <p class="text-gray-300">We state a simple result which will be useful in arguing about the termination of reduceSLPMP.</p>

    <p class="text-gray-300">Algorithm 6 Reduction for saturated limb representation. Performs reduction modulo  <span class="math">p</span> , where  <span class="math">p = 2^m - \\delta</span>  is a pseudo-Mersenne prime;  <span class="math">c_p = 2^{\\eta - \\nu} \\delta</span> ,  <span class="math">2^{\\alpha - 1} \\leq \\delta &amp;lt; 2^\\alpha</span> ,  <span class="math">\\nu&#x27; = 2(1 - \\lfloor \\nu / \\eta \\rfloor)</span>  and  <span class="math">\\theta = 2^\\eta</span> . 1: function reduceSLPMP  <span class="math">(h_0^{(0)}(\\theta))</span> 2: input:  <span class="math">h^{(0)}(\\theta)</span> 3: output:  <span class="math">h^{(3)}(\\theta)</span>  or  <span class="math">h^{(4)}(\\theta)</span> 4: for  <span class="math">i \\gets 0</span>  to  <span class="math">\\kappa - 1</span>  do  <span class="math">h_i^{(1)} \\gets h_i^{(0)}</span>  end for 5:  <span class="math">h_\\kappa^{(1)} + h_{\\kappa + 1}^{(1)} \\theta + \\dots + h_{2\\kappa}^{(1)} \\theta^\\kappa \\gets \\text{mulSCC}(h_\\kappa^{(0)} + h_{\\kappa + 1}^{(0)} \\theta + \\dots + h_{2\\kappa - 1}^{(0)} \\theta^{\\kappa - 1}, c_p)</span> 6:  <span class="math">t \\gets h_0^{(1)} + h_\\kappa^{(1)}</span> ;  <span class="math">h_0^{(2)} \\gets t \\mod 2^\\eta</span> ;  <span class="math">\\mathfrak{c} \\gets \\lfloor t / 2^\\eta \\rfloor</span> 7: for  <span class="math">i \\gets 1</span>  to  <span class="math">\\kappa - 1</span>  do 8:  <span class="math">t \\gets h_i^{(1)} + h_{\\kappa + i}^{(1)} + \\mathfrak{c}</span> ;  <span class="math">h_i^{(2)} \\gets t \\mod 2^\\eta</span> ;  <span class="math">\\mathfrak{c} \\gets \\lfloor t / 2^\\eta \\rfloor</span> 9: end for 10:  <span class="math">h_\\kappa^{(2)} \\gets h_{2\\kappa}^{(1)} + \\mathfrak{c}</span> 11:  <span class="math">r \\gets 2^{\\eta - \\nu} h_\\kappa^{(2)} + \\lfloor h_{\\kappa - 1}^{(2)} / 2^\\nu \\rfloor</span> ;  <span class="math">h_{\\kappa - 1}^{(2)} \\gets h_{\\kappa - 1}^{(2)} \\mod 2^\\nu</span> 12:  <span class="math">u \\gets h_0^{(2)} + \\delta r</span> ;  <span class="math">h_0^{(3)} \\gets u \\mod 2^\\eta</span> ;  <span class="math">q \\gets \\lfloor u / 2^\\eta \\rfloor</span> 13:  <span class="math">v \\gets h_1^{(2)} + q</span> ;  <span class="math">h_1^{(3)} \\gets v \\mod 2^\\eta</span> ;  <span class="math">\\mathfrak{c} \\gets \\lfloor v / 2^\\eta \\rfloor</span> 14: for  <span class="math">i \\gets 2</span>  to  <span class="math">\\kappa - 2</span>  do 15:  <span class="math">t \\gets h_i^{(2)} + \\mathfrak{c}</span> ;  <span class="math">h_i^{(3)} \\gets t \\mod 2^\\eta</span> ;  <span class="math">\\mathfrak{c} \\gets \\lfloor t / 2^\\eta \\rfloor</span> 16: end for 17:  <span class="math">h_{\\kappa - 1}^{(3)} \\gets h_{\\kappa - 1}^{(2)} + \\mathfrak{c}</span> 18: PARTIAL REDUCTION FOR  <span class="math">\\nu &amp;lt; \\eta</span> : return  <span class="math">h^{(3)}(\\theta) = h_0^{(3)} + h_1^{(3)}\\theta + \\dots + h_{\\kappa - 1}^{(3)}\\theta^{\\kappa - 1}</span> 19:  <span class="math">t \\gets h_{\\kappa - 1}^{(3)}</span> ;  <span class="math">h_{\\kappa - 1}^{(3)} \\gets t \\mod 2^\\eta</span> ;  <span class="math">\\mathfrak{c} \\gets \\lfloor t / 2^\\eta \\rfloor</span> ;  <span class="math">h_\\kappa^{(3)} \\gets \\mathfrak{c}</span> 20:  <span class="math">s \\gets 2^{\\eta - \\nu} h_\\kappa^{(3)} + \\lfloor h_{\\kappa - 1}^{(3)} / 2^\\nu \\rfloor</span> ;  <span class="math">h_{\\kappa - 1}^{(3)} \\gets h_{\\kappa - 1}^{(3)} \\mod 2^\\nu</span> 21:  <span class="math">z = h_0^{(3)} + \\delta s</span> 22: if  <span class="math">\\max(2^{\\eta - \\nu + \\alpha}, 2^{2\\alpha + \\nu&#x27;}) + 2^{\\eta - \\nu + \\alpha} - 2^\\alpha \\leq 2^{\\eta - 1}</span>  then 23:  <span class="math">h_0^{(4)} \\gets z</span> ;  <span class="math">h_1^{(4)} \\gets h_1^{(3)}</span> 24: else 25:  <span class="math">h_0^{(4)} \\gets z \\mod 2^\\eta</span> ;  <span class="math">\\mathfrak{c} \\gets \\lfloor z / 2^\\eta \\rfloor</span> ;  <span class="math">h_1^{(4)} = h_1^{(3)} + \\mathfrak{c}</span> 26: end if 27: for  <span class="math">i \\gets 2</span>  to  <span class="math">\\kappa - 1</span>  do  <span class="math">h_i^{(4)} \\gets h_i^{(3)}</span>  end for 28: FULL REDUCTION: return  <span class="math">h^{(4)}(\\theta) = h_0^{(4)} + h_1^{(4)}\\theta + \\dots + h_{\\kappa - 1}^{(4)}\\theta^{\\kappa - 1}</span> 29: end function.</p>

    <p class="text-gray-300">Lemma 3. Let  <span class="math">x</span> ,  <span class="math">y_1</span>  and  <span class="math">y_2</span>  be two integers such that  <span class="math">0 \\leq x &amp;lt; 2^\\eta</span>  and  <span class="math">0 \\leq y_1, y_2 \\leq 2^{\\eta - 1}</span> . Then either  <span class="math">x + y_1 &amp;lt; 2^\\eta</span>  or  <span class="math">y_2 + (x + y_1 \\bmod 2^\\eta) &amp;lt; 2^\\eta</span> .</p>

    <p class="text-gray-300">Proof. If  <span class="math">0 \\leq x &amp;lt; 2^{\\eta} - y_{1}</span> , then  <span class="math">x + y_{1} &amp;lt; 2^{\\eta}</span>  and so the result holds. Otherwise, assume that  <span class="math">2^{\\eta} - y_{1} \\leq x &amp;lt; 2^{\\eta}</span> . In this case,  <span class="math">2^{\\eta} \\leq x + y_{1} &amp;lt; 2^{\\eta} + y_{1}</span> . So,  <span class="math">0 \\leq x + y_{1} \\bmod 2^{\\eta} &amp;lt; y_{1} \\leq 2^{\\eta - 1}</span> . Consequently,  <span class="math">y_{2} \\leq y_{2} + (x + y_{1} \\bmod 2^{\\eta}) &amp;lt; y_{2} + 2^{\\eta - 1} \\leq 2^{\\eta}</span> , which proves the result.</p>

    <p class="text-gray-300">The following result states the correctness of reduceSLPMP</p>

    <p class="text-gray-300">Theorem 4. Let  <span class="math">p = 2^m - \\delta</span>  be a prime and let  <span class="math">\\kappa \\geq 2</span> ,  <span class="math">\\eta</span>  and  <span class="math">\\nu</span>  be such that,  <span class="math">m</span> -bit integers have a  <span class="math">(\\kappa, \\eta, \\nu)</span> -representation. Let  <span class="math">\\alpha</span>  be such that  <span class="math">2^{\\alpha - 1} \\leq \\delta &amp;lt; 2^{\\alpha}</span>  and  <span class="math">\\alpha &amp;lt; \\min(\\nu + 1, \\eta - 2(1 - \\lfloor \\nu / \\eta \\rfloor))</span> . Suppose that the input  <span class="math">h^{(0)}(\\theta)</span>  to reduceSLPMP is the output of either mulSLDCC  <span class="math">(f(\\theta), g(\\theta))</span>  or sqrSLDCC  <span class="math">(f(\\theta))</span>  where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">f(\\theta)</span>  and  <span class="math">g(\\theta)</span>  are  <span class="math">m</span> -bit integers having  <span class="math">(\\kappa, \\eta, \\nu)</span> -representations, if  <span class="math">\\nu = \\eta</span> ;</li>

      <li><span class="math">f(\\theta)</span>  and  <span class="math">g(\\theta)</span>  are  <span class="math">(m + 1)</span> -bit integers having  <span class="math">(\\kappa, \\eta, \\nu + 1)</span> -representations, if  <span class="math">\\nu &amp;lt; \\eta</span> .</li>

    </ul>

    <p class="text-gray-300">Then the following holds.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In the case of partial reduction for  <span class="math">\\nu &amp;lt; \\eta</span> , the output  <span class="math">h^{(3)}(\\theta)</span>  of reduceSLPMP has a  <span class="math">(\\kappa, \\eta, \\nu + 1)</span> -representation and  <span class="math">h^{(3)}(\\theta) \\equiv h^{(0)}(\\theta) \\bmod p</span> .</li>

      <li>In the case of full reduction, the output  <span class="math">h^{(4)}(\\theta)</span>  of reduceSLPMP has a  <span class="math">(\\kappa, \\eta, \\nu)</span> -representation and  <span class="math">h^{(4)}(\\theta) \\equiv h^{(0)}(\\theta) \\mod p</span> .</li>

    </ol>

    <p class="text-gray-300">Proof. Note that since <span class="math">p = 2^m - \\delta</span> is a prime, for <span class="math">\\delta &amp;gt; 1</span>, <span class="math">\\delta</span> cannot be a power of 2. Let <span class="math">\\nu&#x27; = 2(1 - \\lfloor \\nu / \\eta \\rfloor)</span> and so <span class="math">\\nu&#x27; = 0</span> if <span class="math">\\nu = \\eta</span> and <span class="math">\\nu&#x27; = 2</span> for <span class="math">0 &amp;lt; \\nu &amp;lt; \\eta</span>. From <span class="math">\\alpha &amp;lt; \\min(\\nu + 1, \\eta - \\nu&#x27;)</span>, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\alpha \\leq \\alpha + \\nu&#x27; \\leq \\eta - 1. \\tag{24}</span></div>

    <p class="text-gray-300">Also, since <span class="math">\\delta &amp;lt; 2^{\\alpha}</span> and <span class="math">\\alpha \\leq \\nu</span>, we have <span class="math">\\delta &amp;lt; 2^{\\nu}</span>. Using <span class="math">2^{\\alpha - 1} \\leq \\delta &amp;lt; 2^{\\alpha}</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} 2^{\\eta - \\nu + \\alpha - 1} \\leq c_p = 2^{\\eta - \\nu} \\delta &amp;lt; 2^{\\eta - \\nu + \\alpha} \\tag{25} \\\\ \\leq 2^{\\eta} \\text{ (since } \\alpha \\leq \\nu\\text{)}. \\end{array}</span></div>

    <p class="text-gray-300">So, <span class="math">c_p &amp;lt; 2^{\\eta}</span> and hence can be considered to be an <span class="math">\\eta</span>-bit word.</p>

    <p class="text-gray-300">The input <span class="math">h^{(0)}(\\theta)</span> is the product of two <span class="math">m</span>-bit integers each having a <span class="math">(\\kappa, \\eta, \\nu)</span>-representation. As in the proof of Theorem 2, using Proposition 1 we have the following bounds on the coefficients of <span class="math">h^{(0)}(\\theta)</span>.</p>

    <p class="text-gray-300">Case 1: <span class="math">\\nu &amp;lt; \\eta</span></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} 0 \\leq h_0^{(0)}, h_1^{(0)}, \\dots, h_{2\\kappa - 3}^{(0)} &amp;lt; 2^{\\eta}; \\quad \\text{and} \\\\ 0 \\leq h_{2\\kappa - 2}^{(0)} &amp;lt; 2^{2(\\nu + 1)}, \\quad h_{2\\kappa - 1}^{(0)} = 0 \\quad \\text{if} \\quad 1 &amp;lt; \\nu + 1 \\leq \\eta / 2; \\\\ 0 \\leq h_{2\\kappa - 2}^{(0)} &amp;lt; 2^{\\eta}, \\quad 0 \\leq h_{2\\kappa - 1}^{(0)} &amp;lt; 2^{2(\\nu + 1) - \\eta} \\quad \\text{if} \\quad \\eta / 2 &amp;lt; \\nu + 1 \\leq \\eta. \\end{array}</span></div>

    <p class="text-gray-300">Case 2: <span class="math">\\nu = \\eta</span></p>

    <div class="my-4 text-center"><span class="math-block">0 \\leq h_0^{(0)}, h_1^{(0)}, \\dots, h_{2\\kappa - 1}^{(0)} &amp;lt; 2^{\\eta}.</span></div>

    <p class="text-gray-300">For the case <span class="math">0 &amp;lt; \\nu + 1 \\leq \\eta / 2</span>, we have <span class="math">0 \\leq h_{2\\kappa - 2}^{(0)} &amp;lt; 2^{2\\nu + 2} \\leq 2^{\\eta}</span>. The above cases can be merged and the following bounds can be stated for all <span class="math">0 &amp;lt; \\nu \\leq \\eta</span>.</p>

    <div class="my-4 text-center"><span class="math-block">0 \\leq h_0^{(0)}, h_1^{(0)}, \\dots, h_{2\\kappa - 3}^{(0)}, h_{2\\kappa - 2}^{(0)} &amp;lt; 2^{\\eta} \\quad \\text{and} \\quad 0 \\leq h_{2\\kappa - 1}^{(0)} &amp;lt; \\max(1, 2^{2\\nu - \\eta + \\nu&#x27;}). \\tag{26}</span></div>

    <p class="text-gray-300">Using <span class="math">\\theta = 2^{\\eta}</span> and <span class="math">p = 2^m - \\delta</span> we have</p>

    <div class="my-4 text-center"><span class="math-block">\\theta^{\\kappa} = 2^{\\kappa \\eta} = 2^{(\\kappa - 1) \\eta + \\nu} \\cdot 2^{\\eta - \\nu} = 2^m \\cdot 2^{\\eta - \\nu} \\equiv 2^{\\eta - \\nu} \\delta \\bmod p = c_p. \\tag{27}</span></div>

    <p class="text-gray-300">The input <span class="math">h^{(0)}</span> to reduceSLPMP can be written as</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} h^{(0)}(\\theta) = h_0^{(0)} + h_1^{(0)} \\theta + \\dots + h_{\\kappa - 1}^{(0)} \\theta^{\\kappa - 1} + h_{\\kappa}^{(0)} \\theta^{\\kappa} + h_{\\kappa + 1}^{(0)} \\theta^{(\\kappa + 1)} + \\dots + h_{2\\kappa - 1}^{(0)} \\theta^{(2\\kappa - 1)} \\\\ = \\left(h_0^{(0)} + h_1^{(0)} \\theta + \\dots + h_{\\kappa - 1}^{(0)} \\theta^{\\kappa - 1}\\right) + \\left(h_{\\kappa}^{(0)} + h_{\\kappa + 1}^{(0)} \\theta + \\dots + h_{2\\kappa - 1}^{(0)} \\theta^{\\kappa - 1}\\right) \\theta^{\\kappa} \\\\ \\equiv \\left(h_0^{(0)} + h_1^{(0)} \\theta + \\dots + h_{\\kappa - 1}^{(0)} \\theta^{\\kappa - 1}\\right) + \\left(h_{\\kappa}^{(0)} + h_{\\kappa + 1}^{(0)} \\theta + \\dots + h_{2\\kappa - 1}^{(0)} \\theta^{\\kappa - 1}\\right) c_p. \\tag{28} \\end{array}</span></div>

    <p class="text-gray-300">Step 5 computes the product <span class="math">(h_{\\kappa}^{(0)} + h_{\\kappa + 1}^{(0)} \\theta + \\dots + h_{2\\kappa - 1}^{(0)} \\theta^{\\kappa - 1})c_p</span> of (28) using mulSCC, obtaining the output as <span class="math">(h_{\\kappa}^{(1)} + h_{\\kappa + 1}^{(1)} \\theta + \\dots + h_{2\\kappa}^{(1)} \\theta^{\\kappa})</span>. Step 4 simply copies the values of <span class="math">h_i^{(0)}</span> to <span class="math">h_i^{(1)}</span>, for <span class="math">i = 0, 1, \\ldots, \\kappa - 1</span>. This defines the polynomial <span class="math">h^{(1)}(\\theta)</span> and from (28) we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} h^{(0)}(\\theta) \\equiv \\underbrace{(h_0^{(1)} + h_1^{(1)} \\theta + \\cdots + h_{\\kappa - 1}^{(1)} \\theta^{\\kappa - 1})}_{\\text{through Step 4}} + \\underbrace{(h_{\\kappa}^{(1)} + h_{\\kappa + 1}^{(1)} \\theta + \\cdots + h_{2\\kappa}^{(1)} \\theta^{\\kappa})}_{\\text{through Step 5}} \\bmod p \\\\ = h^{(1)}(\\theta). \\tag{29} \\end{array}</span></div>

    <p class="text-gray-300">Limb bounds of <span class="math">h^{(1)}(\\theta)</span>: The bounds on <span class="math">h_j^{(0)}</span> are given in (26). So, by Step 4, <span class="math">0 \\leq h_j^{(1)} &amp;lt; 2^\\eta</span>, <span class="math">j = 0, 1, \\ldots, \\kappa - 1</span>. Let <span class="math">X(\\theta) = h_\\kappa^{(0)} + h_{\\kappa + 1}^{(0)} \\theta + \\dots + h_{2\\kappa - 1}^{(0)} \\theta^{\\kappa - 1}</span> and <span class="math">Y(\\theta) = h_\\kappa^{(1)} + h_{\\kappa + 1}^{(1)} \\theta + \\dots + h_{2\\kappa}^{(1)} \\theta^{\\kappa}</span>. Using (26), the size of the integer represented by <span class="math">X(\\theta)</span> is at most <span class="math">(\\kappa - 1)\\eta + 2\\nu - \\eta + \\nu&#x27;</span> bits. The integer represented by <span class="math">Y(\\theta)</span> is obtained by multiplying <span class="math">X(\\theta)</span> by the constant <span class="math">c_p</span>. From (25), the size of <span class="math">c_p</span> is at most <span class="math">(\\eta - \\nu + \\alpha)</span> bits. Hence, the number of bits in the integer represented by <span class="math">Y(\\theta)</span> is at most</p>

    <div class="my-4 text-center"><span class="math-block">(\\kappa - 1)\\eta + 2\\nu - \\eta + \\nu&#x27; + (\\eta - \\nu + \\alpha) = (\\kappa - 1)\\eta + \\nu + \\alpha + \\nu&#x27;.</span></div>

    <p class="text-gray-300">If <span class="math">\\nu + \\alpha + \\nu&#x27; \\leq \\eta</span>, then <span class="math">Y(\\theta)</span> has a <span class="math">(\\kappa, \\eta, \\nu + \\alpha + \\nu&#x27;)</span>-representation. Suppose that <span class="math">\\nu + \\alpha + \\nu&#x27; &amp;gt; \\eta</span>. Since <span class="math">0 &amp;lt; \\nu \\leq \\eta</span> and from (24), <span class="math">\\alpha + \\nu&#x27; &amp;lt; \\eta</span> we have <span class="math">\\alpha + \\nu&#x27; &amp;lt; \\nu + \\alpha + \\nu&#x27; &amp;lt; 2\\eta</span>. Writing <span class="math">(\\kappa - 1)\\eta + (\\nu + \\alpha + \\nu&#x27;) = \\kappa\\eta + (\\nu + \\alpha + \\nu&#x27; - \\eta)</span>, in this case, <span class="math">Y(\\theta)</span> has a <span class="math">(\\kappa + 1, \\eta, \\nu + \\alpha + \\nu&#x27; - \\eta)</span>-representation. Combining the two</p>

    <p class="text-gray-300">cases, the limb bounds for <span class="math">Y(\\theta) = (h_{\\kappa}^{(1)} + h_{\\kappa + 1}^{(1)}\\theta + \\dots + h_{2\\kappa}^{(1)}\\theta^{\\kappa})</span> are <span class="math">0 \\leq h_{j}^{(1)} &amp;lt; 2^{\\eta}, j = \\kappa, \\kappa + 1, \\ldots, 2\\kappa - 1</span>, <span class="math">0 \\leq h_{2\\kappa}^{(1)} &amp;lt; \\max(1, 2^{\\nu + \\alpha + \\nu&#x27; - \\eta})</span>. Hence, the limb bounds of <span class="math">h^{(1)}(\\theta)</span> can be stated as</p>

    <div class="my-4 text-center"><span class="math-block">0 \\leq h _ {j} ^ {(1)} &amp;lt;   2 ^ {\\eta} \\text{ for } j = 0, 1, \\dots , 2 \\kappa - 1, \\text{ and } 0 \\leq h _ {2 \\kappa} ^ {(1)} &amp;lt;   \\max  \\left(1, 2 ^ {\\nu + \\alpha + \\nu^ {\\prime} - \\eta}\\right). \\tag {30}</span></div>

    <p class="text-gray-300">Through Steps 6 to 10, we pairwise add the coefficients of <span class="math">\\theta^0,\\theta^1,\\ldots ,\\theta^{\\kappa -1}</span> given in (29) sequentially by forwarding the 1-bit carry, and in Step 10 we add the last carry to <span class="math">h_{2\\kappa}^{(1)}</span> producing the <span class="math">(\\kappa +1)</span>-limb polynomial <span class="math">h^{(2)}(\\theta)</span>. Hence, from (29) we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} h ^ {(1)} (\\theta) = \\left(h _ {0} ^ {(1)} + h _ {\\kappa} ^ {(1)}\\right) + \\left(h _ {1} ^ {(1)} + h _ {\\kappa + 1} ^ {(1)}\\right) \\theta + \\dots + \\left(h _ {\\kappa - 1} ^ {(1)} + h _ {2 \\kappa - 1} ^ {(1)}\\right) \\theta^ {\\kappa - 1} + h _ {2 \\kappa} ^ {(1)} \\theta^ {\\kappa}, \\\\ = \\underbrace {h _ {0} ^ {(2)} + h _ {1} ^ {(2)} \\theta + \\cdots + h _ {\\kappa - 1} ^ {(2)} \\theta^ {\\kappa - 1} + h _ {\\kappa} ^ {(2)} \\theta^ {\\kappa}} _ {\\text{through Steps 6 to 10}} = h ^ {(2)} (\\theta). \\tag {31} \\\\ \\end{array}</span></div>

    <p class="text-gray-300"><strong>Limb bounds of <span class="math">h^{(2)}(\\theta)</span>:</strong> Using the bounds in (30), the bounds on the limbs of <span class="math">h^{(2)}(\\theta)</span> defined in (31) are given by</p>

    <div class="my-4 text-center"><span class="math-block">0 \\leq h _ {j} ^ {(2)} &amp;lt;   2 ^ {\\eta} \\text{ for } j = 0, 1, \\dots , \\kappa - 1, \\text{ and } 0 \\leq h _ {\\kappa} ^ {(2)} \\leq \\max  \\left(1, 2 ^ {\\nu + \\alpha + \\nu^ {\\prime} - \\eta}\\right). \\tag {32}</span></div>

    <p class="text-gray-300">In Step 11, <span class="math">r = 2^{\\eta - \\nu} h_{\\kappa}^{(2)} + \\lfloor h_{\\kappa - 1}^{(2)} / 2^{\\nu} \\rfloor</span> is computed and the product <span class="math">\\delta r</span> is used in Step 12. The bounds on <span class="math">r</span> and <span class="math">\\delta r</span> are obtained as follows.</p>

    <p class="text-gray-300"><strong>Bounds on <span class="math">r</span> and <span class="math">\\delta r</span>:</strong> From (32), we have <span class="math">0 \\leq h_{\\kappa - 1}^{(2)} &amp;lt; 2^{\\eta}</span> and so <span class="math">\\lfloor h_{\\kappa - 1}^{(2)} / 2^{\\nu} \\rfloor &amp;lt; 2^{\\eta - \\nu}</span> i.e., <span class="math">\\lfloor h_{\\kappa - 1}^{(2)} / 2^{\\nu} \\rfloor \\leq 2^{\\eta - \\nu} - 1</span>. Also, from (32), we have <span class="math">0 \\leq h_{\\kappa}^{(2)} \\leq \\max(1, 2^{\\nu + \\alpha + \\nu&#x27; - \\eta})</span>. From the definition of <span class="math">r</span>, we obtain</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} 0 \\leq r \\leq \\max  \\left(2 ^ {\\eta - \\nu}, 2 ^ {\\alpha + \\nu^ {\\prime}}\\right) + 2 ^ {\\eta - \\nu} - 1 \\\\ \\Rightarrow \\quad 0 \\leq \\delta r &amp;lt;   \\max  \\left(2 ^ {\\eta - \\nu + \\alpha}, 2 ^ {2 \\alpha + \\nu^ {\\prime}}\\right) + 2 ^ {\\eta - \\nu + \\alpha} - 2 ^ {\\alpha} [ \\text{since } \\delta &amp;lt;   2 ^ {\\alpha} ]. \\tag {33} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">If the boolean condition in Step 22 holds, then</p>

    <div class="my-4 text-center"><span class="math-block">0 \\leq \\delta r &amp;lt;   2 ^ {\\eta - 1}. \\tag {34}</span></div>

    <p class="text-gray-300">Otherwise, a bound on <span class="math">\\delta r</span> is obtained by continuing the computation of (33) as follows.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Rightarrow \\quad 0 \\leq \\delta r &amp;lt;   \\max  \\left(2 ^ {2 \\eta - \\nu - 1}, 2 ^ {2 \\eta - 2}\\right) + 2 ^ {2 \\eta - \\nu - 1} - 2 ^ {\\eta - 1} [ \\text{from (24)} \\alpha , \\alpha + \\nu^ {\\prime} \\leq \\eta - 1 ] \\\\ \\Rightarrow \\quad 0 \\leq \\delta r &amp;lt;   2 ^ {2 \\eta - 2} + 2 ^ {2 \\eta - \\nu - 1} - 2 ^ {\\eta - 1} [ \\text{since } \\nu \\geq 1 ] \\\\ \\Rightarrow \\quad 0 \\leq \\delta r &amp;lt;   2 ^ {2 \\eta - 1} - 2 ^ {\\eta - 1} [ \\text{again since } \\nu \\geq 1 ]. \\tag {35} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">So, (35) holds irrespective of whether the boolean condition in Step 22 holds or not. The variable <span class="math">u</span> is defined in Step 12. From (32) and (35) an upper bound on <span class="math">u</span> is as follows.</p>

    <div class="my-4 text-center"><span class="math-block">u = h _ {0} ^ {(2)} + \\delta r &amp;lt;   2 ^ {\\eta} - 1 + 2 ^ {2 \\eta - 1} - 2 ^ {\\eta - 1}. \\tag {36}</span></div>

    <p class="text-gray-300">Write <span class="math">h_{\\kappa - 1}^{(2)} = h_{\\kappa - 1,0}^{(2)} + h_{\\kappa - 1,1}^{(2)} 2^{\\nu}</span> where <span class="math">h_{\\kappa - 1,0}^{(2)} = h_{\\kappa - 1}^{(2)} \\mod 2^{\\nu}</span> and <span class="math">h_{\\kappa - 1,1}^{(2)} = \\lfloor h_{\\kappa - 1}^{(2)} / 2^{\\nu} \\rfloor</span>. Then</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} h ^ {(2)} (\\theta) = h _ {0} ^ {(2)} + h _ {1} ^ {(2)} \\theta + \\dots + h _ {\\kappa - 1} ^ {(2)} \\theta^ {\\kappa - 1} + h _ {\\kappa} ^ {(2)} \\theta^ {\\kappa} \\\\ = h _ {0} ^ {(2)} + h _ {1} ^ {(2)} \\theta + \\dots + \\left(h _ {\\kappa - 1, 0} ^ {(2)} + h _ {\\kappa - 1, 1} ^ {(2)} 2 ^ {\\nu}\\right) \\theta^ {\\kappa - 1} + h _ {\\kappa} ^ {(2)} \\theta^ {\\kappa} \\\\ = h _ {0} ^ {(2)} + h _ {1} ^ {(2)} \\theta + \\dots + h _ {\\kappa - 1, 0} ^ {(2)} \\theta^ {\\kappa - 1} + h _ {\\kappa - 1, 1} ^ {(2)} 2 ^ {\\eta (\\kappa - 1) + \\nu} + h _ {\\kappa} ^ {(2)} \\theta^ {\\kappa} \\\\ = h _ {0} ^ {(2)} + h _ {1} ^ {(2)} \\theta + \\dots + h _ {\\kappa - 1, 0} ^ {(2)} \\theta^ {\\kappa - 1} + h _ {\\kappa - 1, 1} ^ {(2)} 2 ^ {m} + h _ {\\kappa} ^ {(2)} \\theta^ {\\kappa} \\\\ \\equiv h _ {0} ^ {(2)} + h _ {1} ^ {(2)} \\theta + \\dots + h _ {\\kappa - 1, 0} ^ {(2)} \\theta^ {\\kappa - 1} + h _ {\\kappa - 1, 1} ^ {(2)} \\delta + h _ {\\kappa} ^ {(2)} c _ {p} [ \\text{using } 2 ^ {m} \\equiv \\delta \\bmod p \\text{ and (25)} ] \\\\ = h _ {0} ^ {(2)} + h _ {1} ^ {(2)} \\theta + \\dots + h _ {\\kappa - 1, 0} ^ {(2)} \\theta^ {\\kappa - 1} + \\left(h _ {\\kappa - 1, 1} ^ {(2)} + h _ {\\kappa} ^ {(2)} 2 ^ {\\eta - \\nu}\\right) \\delta [ \\text{using (25)} ] \\\\ = \\left(r \\delta + h _ {0} ^ {(2)}\\right) + h _ {1} ^ {(2)} \\theta + \\dots + h _ {\\kappa - 1, 0} ^ {(2)} \\theta^ {\\kappa - 1} [ \\text{from Step 11} ] \\\\ = u + h _ {1} ^ {(2)} \\theta + \\dots + h _ {\\kappa - 1, 0} ^ {(2)} \\theta^ {\\kappa - 1} [ \\text{from Step 12} ] \\tag {37} \\\\ \\equiv \\underbrace {h _ {0} ^ {(3)} + h _ {1} ^ {(3)} \\theta + \\cdots + h _ {\\kappa} ^ {(3)} \\theta^ {\\kappa}} _ {\\text{through Steps 12 to 19}} \\bmod p = h ^ {(3)} (\\theta). \\tag {38} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">The analysis of the rest of the algorithm, i.e., Steps 12 to 27 is divided into two cases depending on whether <span class="math">u &amp;lt; 2^{\\eta}</span> or <span class="math">u \\geq 2^{\\eta}</span>.</p>

    <p class="text-gray-300">18</p>

    <p class="text-gray-300">Case 1: <span class="math">u&lt;2^{\\eta}</span>. In this case, <span class="math">q=\\lfloor u/2^{\\eta}\\rfloor=0</span>, and so from Steps 13 to 16 we have <span class="math">0\\leq h^{(3)}_{j}=h^{(2)}_{j}&lt;2^{\\eta}</span> for <span class="math">j=1,2,\\ldots,\\kappa-2</span>. Also, <span class="math">0\\leq h^{(3)}_{\\kappa-1}=h^{(2)}_{\\kappa-1}&lt;2^{\\nu}</span>, because in Step 11 we have already updated <span class="math">h^{(2)}_{\\kappa-1}</span> by <span class="math">h^{(2)}_{\\kappa-1}</span> mod <span class="math">2^{\\nu}</span>. By Step 12, we have <span class="math">h^{(3)}_{0}=u</span> mod <span class="math">2^{\\eta}&lt;2^{\\eta}</span>, and Step 19 gives <span class="math">h^{(3)}_{\\kappa}=0</span>. So, in this case, <span class="math">h^{(3)}(\\theta)</span> returned at Step 18 has a <span class="math">(\\kappa,\\eta,\\nu)</span>-representation irrespective of whether <span class="math">\\nu&lt;\\eta</span> or <span class="math">\\nu=\\eta</span>. By (29), (31) and (38) we have <span class="math">h^{(3)}(\\theta)\\equiv h^{(0)}(\\theta)\\bmod p</span>. This proves the statement of the theorem on partial reduction for Case 1.</p>

    <p class="text-gray-300">Further, we have <span class="math">s=0</span> by Step 20, and so by the remaining steps of the algorithm we have <span class="math">0\\leq h^{(4)}_{j}=h^{(3)}_{j}&lt;2^{\\eta}</span> for <span class="math">j=0,1,\\ldots,\\kappa-2</span> and <span class="math">0\\leq h^{(4)}_{\\kappa-1}=h^{(3)}_{\\kappa-1}&lt;2^{\\nu}</span>, i.e., <span class="math">h^{(4)}(\\theta)</span> has a <span class="math">(\\kappa,\\eta,\\nu)</span>-representation. It follows that <span class="math">h^{(4)}(\\theta)=h^{(3)}(\\theta)</span> and using (29), (31) and (38), we have <span class="math">h^{(4)}(\\theta)\\equiv h^{(0)}(\\theta)\\bmod p</span> which proves the statement of the theorem on full reduction for Case 1.</p>

    <p class="text-gray-300">Case 2: <span class="math">u\\geq 2^{\\eta}</span>. Step 12 defines <span class="math">q</span> to be <span class="math">q=\\lfloor u/2^{\\eta}\\rfloor</span>. Since in this case <span class="math">u\\geq 2^{\\eta}</span>, the bounds on <span class="math">q</span> are the following.</p>

    <p class="text-gray-300"><span class="math">1</span> <span class="math">\\leq</span> <span class="math">q\\ \\leq</span> <span class="math">\\left\\lfloor\\frac{2^{\\eta}-1+2^{2\\eta-1}-2^{\\eta-1}}{2^{\\eta}}\\right\\rfloor\\ \\mbox{[using \\eqref{36}]}</span> <span class="math">\\Rightarrow</span> <span class="math">1</span> <span class="math">\\leq</span> <span class="math">q\\ \\leq</span> <span class="math">\\left\\lfloor 1-\\frac{1}{2^{\\eta}}+2^{\\eta-1}-\\frac{1}{2}\\right\\rfloor</span> <span class="math">\\Rightarrow</span> <span class="math">1</span> <span class="math">\\leq</span> <span class="math">q\\ \\leq</span> <span class="math">2^{\\eta-1}+\\left\\lfloor\\frac{1}{2}-\\frac{1}{2^{\\eta}}\\right\\rfloor</span> <span class="math">\\Rightarrow</span> <span class="math">1</span> <span class="math">\\leq</span> <span class="math">q\\ \\leq</span> <span class="math">2^{\\eta-1}\\ &lt;\\ \\ 2^{\\eta}-1.</span> (39)</p>

    <p class="text-gray-300">In Step 13, the algorithm computes <span class="math">v=h^{(2)}_{1}+q</span>. There are two sub cases to consider depending on whether <span class="math">v&lt;2^{\\eta}</span> or <span class="math">v\\geq 2^{\\eta}</span>.</p>

    <p class="text-gray-300">Subcase 2a: <span class="math">v&lt;2^{\\eta}</span>. Step 13 defines <span class="math">\\mathfrak{c}=\\lfloor v/2^{\\eta}\\rfloor</span> and so <span class="math">\\mathfrak{c}=0</span> at this step. This simplifies the analysis and the rest of the proof is similar to that of Case 1.</p>

    <p class="text-gray-300">Subcase 2b: <span class="math">v\\geq 2^{\\eta}</span>. This is the non-trivial case and it is required to argue that there are no overflows. In this case, using (32) and (39), we have</p>

    <p class="text-gray-300"><span class="math">2^{\\eta}\\ \\ \\leq\\ \\ v\\ \\ =\\ \\ h^{(2)}_{1}+q\\ \\ \\ &lt;\\ \\ 2^{\\eta}+2^{\\eta}-1\\ \\ =\\ \\ 2^{\\eta+1}-1.</span> (40)</p>

    <p class="text-gray-300">So, <span class="math">2^{\\eta}\\leq v\\leq 2^{\\eta+1}-2=2^{\\eta}+2^{\\eta}-2</span> implying <span class="math">v</span> mod <span class="math">2^{\\eta}\\leq 2^{\\eta}-2&lt;2^{\\eta}-1</span>. After Step 13,</p>

    <p class="text-gray-300"><span class="math">h^{(3)}_{1}=v\\bmod 2^{\\eta}&lt;2^{\\eta}-1\\ \\mbox{and}\\ 0\\leq\\mathfrak{c}\\leq 1.</span></p>

    <p class="text-gray-300">Consider <span class="math">h^{(3)}(\\theta)</span> as given in (38).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By Step 12, we have <span class="math">0\\leq h^{(3)}_{0}&lt;2^{\\eta}</span>.</li>

      <li>Since <span class="math">\\mathfrak{c}\\leq 1</span>, considering Step 15 for <span class="math">i=2,3,\\ldots,\\kappa-2</span>, shows <span class="math">0\\leq h^{(3)}_{j}&lt;2^{\\eta}</span> for <span class="math">j=2,3,\\ldots,\\kappa-2</span>.</li>

      <li>Recall that <span class="math">h^{(2)}_{\\kappa-1,0}=h^{(2)}_{\\kappa-1}\\bmod 2^{\\nu}\\leq 2^{\\nu}-1</span> and consider Step 15 for <span class="math">i=\\kappa-1</span>. Since <span class="math">\\mathfrak{c}\\leq 1</span>, we have <span class="math">h^{(3)}_{\\kappa-1}\\leq 2^{\\nu}</span> and so <span class="math">h^{(3)}_{\\kappa-1}</span> is a <span class="math">(\\nu+1)</span>-bit integer.</li>

    </ul>

    <p class="text-gray-300">Consequently, if <span class="math">\\nu&lt;\\eta</span>, then <span class="math">h^{(3)}(\\theta)</span> has a <span class="math">(\\kappa,\\eta,\\nu+1)</span>-representation and by (29), (31) and (38) we have <span class="math">h^{(3)}(\\theta)\\equiv h^{(0)}(\\theta)\\bmod p</span>. This proves the statement of the theorem on partial reduction for Subcase 2b.</p>

    <p class="text-gray-300">On the other hand, if <span class="math">\\nu=\\eta</span>, then <span class="math">h^{(3)}_{\\kappa-1}</span> will be an <span class="math">(\\eta+1)</span>-bit string (equivalently, <span class="math">h^{(3)}(\\theta)</span> will be an <span class="math">(m+1)</span>-bit integer) and further reduction is required to ensure that the number of limbs in the final result is <span class="math">\\kappa</span>. So, for <span class="math">\\nu=\\eta</span>, partial reduction is not useful. The general analysis for obtaining the final reduction irrespective of whether <span class="math">\\nu&lt;\\eta</span> or <span class="math">\\nu=\\eta</span> is given below.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">In Steps 20 and 21, the algorithm computes <span class="math">s = 2^{\\eta - \\nu} h_{\\kappa}^{(3)} + \\lfloor h_{\\kappa - 1}^{(3)} / 2^{\\nu} \\rfloor</span> and <span class="math">z = h_0^{(3)} + \\delta s</span> respectively. Write <span class="math">h_{\\kappa - 1}^{(3)} = h_{\\kappa - 1, 0}^{(3)} + h_{\\kappa - 1, 1}^{(3)} 2^{\\nu}</span> where <span class="math">h_{\\kappa - 1, 0}^{(3)} = h_{\\kappa - 1}^{(3)} \\mod 2^{\\nu}</span> and <span class="math">h_{\\kappa - 1, 1}^{(3)} = \\lfloor h_{\\kappa - 1}^{(3)} / 2^{\\nu} \\rfloor</span>. Then</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} h^{(3)}(\\theta) &amp;amp;= h_0^{(3)} + h_1^{(3)} \\theta + \\cdots + h_{\\kappa - 1}^{(3)} \\theta^{\\kappa - 1} + h_{\\kappa}^{(3)} \\theta^{\\kappa} \\\\ &amp;amp;= h_0^{(3)} + h_1^{(3)} \\theta + \\cdots + (h_{\\kappa - 1, 0}^{(3)} + h_{\\kappa - 1, 1}^{(3)} 2^{\\nu}) \\theta^{\\kappa - 1} + h_{\\kappa}^{(3)} \\theta^{\\kappa} \\\\ &amp;amp;= h_0^{(3)} + h_1^{(3)} \\theta + \\cdots + h_{\\kappa - 1, 0}^{(3)} \\theta^{\\kappa - 1} + h_{\\kappa - 1, 1}^{(3)} 2^{\\eta (\\kappa - 1) + \\nu} + h_{\\kappa}^{(3)} \\theta^{\\kappa} \\\\ &amp;amp;= h_0^{(3)} + h_1^{(3)} \\theta + \\cdots + h_{\\kappa - 1, 0}^{(3)} \\theta^{\\kappa - 1} + h_{\\kappa - 1, 1}^{(3)} 2^m + h_{\\kappa}^{(3)} \\theta^{\\kappa} \\\\ &amp;amp;\\equiv h_0^{(3)} + h_1^{(3)} \\theta + \\cdots + h_{\\kappa - 1, 0}^{(3)} \\theta^{\\kappa - 1} + h_{\\kappa - 1, 1}^{(3)} \\delta + h_{\\kappa}^{(3)} c_p \\bmod p \\text{ [using (5) and (25)]} \\\\ &amp;amp;= h_0^{(3)} + h_1^{(3)} \\theta + \\cdots + h_{\\kappa - 1, 0}^{(3)} \\theta^{\\kappa - 1} + (h_{\\kappa - 1, 1}^{(3)} + h_{\\kappa}^{(3)} 2^{\\eta - \\nu}) \\delta \\text{ [using (27)]} \\\\ &amp;amp;= (s \\delta + h_0^{(3)}) + h_1^{(3)} \\theta + \\cdots + h_{\\kappa - 1, 0}^{(3)} \\theta^{\\kappa - 1} \\text{ [from Step 20]} \\\\ &amp;amp;= z + h_1^{(3)} \\theta + \\cdots + h_{\\kappa - 1, 0}^{(3)} \\theta^{\\kappa - 1} \\text{ [from Step 21]}. \\end{aligned} \\tag{41}</span></div>

    <p class="text-gray-300"><strong>Claim 4.</strong> The value of <span class="math">s</span> computed in Step 20 is at most 1.</p>

    <p class="text-gray-300"><strong>Proof.</strong> The value of <span class="math">s</span> is <span class="math">2^{\\eta - \\nu} h_{\\kappa}^{(3)} + \\lfloor h_{\\kappa - 1}^{(3)} / 2^{\\nu} \\rfloor</span>.</p>

    <p class="text-gray-300">In Step 11, <span class="math">h_{\\kappa - 1}^{(2)}</span> is set to <span class="math">h_{\\kappa - 1}^{(2)} \\mod 2^{\\nu}</span> and so after this step <span class="math">0 \\leq h_{\\kappa - 1}^{(2)} &amp;lt; 2^{\\nu}</span>. Consider Steps 17 and 19. We have <span class="math">0 \\leq h_{\\kappa - 1}^{(2)} &amp;lt; 2^{\\nu}</span> and so the value of <span class="math">t</span> at Step 19 is at most <span class="math">2^{\\nu}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The value of <span class="math">h_{\\kappa - 1}^{(3)}</span> is set to be equal to <span class="math">t \\mod 2^{\\eta}</span>. So, if <span class="math">\\nu &amp;lt; \\eta</span> then <span class="math">0 \\leq h_{\\kappa - 1}^{(3)} \\leq 2^{\\nu}</span>, while if <span class="math">\\nu = \\eta</span> then <span class="math">0 \\leq h_{\\kappa - 1}^{(3)} &amp;lt; 2^{\\eta}</span>.</li>

      <li>The updated value of <span class="math">\\mathfrak{c}</span> is <span class="math">\\lfloor t / 2^{\\eta} \\rfloor</span> and this can be equal to 1 only if <span class="math">\\nu = \\eta</span>. This value of <span class="math">\\mathfrak{c}</span> is assigned to <span class="math">h_{\\kappa}^{(3)}</span> in Step 19. So, <span class="math">h_{\\kappa}^{(3)} = 1</span> only if <span class="math">\\nu = \\eta</span>.</li>

    </ul>

    <p class="text-gray-300">If <span class="math">\\nu &amp;lt; \\eta</span>, then <span class="math">h_{\\kappa}^{(3)} = 0</span> and <span class="math">\\lfloor h_{\\kappa - 1}^{(3)} / 2^{\\nu} \\rfloor \\leq 1</span> implying that <span class="math">s \\leq 1</span>. On the other hand, if <span class="math">\\nu = \\eta</span>, then <span class="math">2^{\\eta - \\nu} h_{\\kappa}^{(3)} = h_{\\kappa}^{(3)} \\leq 1</span> and <span class="math">\\lfloor h_{\\kappa - 1}^{(3)} / 2^{\\nu} \\rfloor = \\lfloor h_{\\kappa - 1}^{(3)} / 2^{\\eta} \\rfloor = 0</span> again implying that <span class="math">s \\leq 1</span>.</p>

    <p class="text-gray-300">If <span class="math">s = 0</span>, then <span class="math">z = h_0^{(3)}</span>, implying <span class="math">h_0^{(4)} = h_0^{(3)}</span> and <span class="math">\\mathfrak{c}</span> at Step 25 is 0. So, <span class="math">h_0^{(4)} = h_0^{(3)}</span> and <span class="math">h_1^{(4)} = h_1^{(3)}</span> hold for both branches of the 'if' statement in Step 22. From Step 27 it follows that <span class="math">h^{(4)}(\\theta) = h^{(3)}(\\theta)</span>.</p>

    <p class="text-gray-300">If <span class="math">s = 1</span>, then <span class="math">z = h_0^{(3)} + \\delta</span>. The termination arguments for the two branches of the 'if' statement at Step 22 are different.</p>

    <p class="text-gray-300">First suppose that the boolean condition of the 'if' statement evaluates to true. We apply Lemma 3 with <span class="math">x = h_0^{(2)}</span>, <span class="math">y_1 = \\delta r</span> and <span class="math">y_2 = \\delta</span>. From (34), we have <span class="math">0 \\leq \\delta r &amp;lt; 2^{\\eta - 1}</span> which also implies <span class="math">0 &amp;lt; \\delta &amp;lt; 2^{\\eta - 1}</span>. In Step 12, <span class="math">u</span> is computed as <span class="math">u = h_0^{(2)} + \\delta r = x + y_1</span> and <span class="math">h_0^{(3)} = u \\mod 2^{\\eta} = x + y_1 \\mod 2^{\\eta}</span>. In Step 23, <span class="math">h_4^{(0)} = z = h_0^{(3)} + \\delta = y_2 + (x + y_1 \\mod 2^{\\eta})</span>. In Case 2, <span class="math">u \\geq 2^{\\eta}</span>, i.e., <span class="math">x + y_1 \\geq 2^{\\eta}</span>. Then from Lemma 3, we have <span class="math">h_4^{(0)} = y_2 + (x + y_1 \\mod 2^{\\eta}) &amp;lt; 2^{\\eta}</span>. So, the procedure terminates.</p>

    <p class="text-gray-300">Now consider the case that the boolean condition of the 'if' statement evaluates to false. By Step 20 we have <span class="math">0 \\leq h_{\\kappa - 1}^{(3)} &amp;lt; 2^{\\nu}</span> and <span class="math">0 \\leq h_0^{(4)} &amp;lt; 2^{\\eta}</span> by Step 25. The value of <span class="math">\\mathfrak{c}</span> in Step 25 can be at most 1, and since the bound of <span class="math">h_1^{(3)}</span> is <span class="math">0 \\leq h_1^{(3)} &amp;lt; 2^{\\eta} - 1</span>, hence after Step 25 we have <span class="math">0 \\leq h_1^{(4)} &amp;lt; 2^{\\eta}</span>.</p>

    <p class="text-gray-300">So, after both branches of the 'if' statement in Step 22, the limb bounds of <span class="math">h^{(4)}(\\theta)</span> are <span class="math">0 \\leq h_j^{(4)} &amp;lt; 2^{\\eta}</span> for <span class="math">j = 0,1,\\ldots,\\kappa - 2</span>, and <span class="math">0 \\leq h_{\\kappa - 1}^{(4)} &amp;lt; 2^{\\nu}</span>. From (41) we can write</p>

    <div class="my-4 text-center"><span class="math-block">h^{(3)}(\\theta) \\equiv \\underbrace{h_0^{(4)} + h_1^{(4)} \\theta + \\cdots + h_{\\kappa - 1}^{(4)} \\theta^{\\kappa}}_{\\text{through Steps 20 to 27}} \\bmod p = h^{(4)}(\\theta). \\tag{42}</span></div>

    <p class="text-gray-300">Combining (29), (31), (38) and (42) we have <span class="math">h^{(4)}(\\theta) \\equiv h^{(0)}(\\theta) \\bmod p</span>, which proves the statement of the theorem on full reduction for Subcase 2b.</p>

    <p class="text-gray-300"><strong>Usefulness of partial reduction:</strong> The statement of Theorem 4 identifies two cases. If <span class="math">\\nu &amp;lt; \\eta</span>, then the input to reduceSLPMP is considered to be a <span class="math">(2m + 2)</span>-bit integer, whereas if <span class="math">\\nu = \\eta</span>, then the input to reduceSLPMP is considered to be a <span class="math">2m</span>-bit integer. This is the consequence of whether partial reduction is used or not. In the case of <span class="math">\\nu &amp;lt; \\eta</span>, a partial reduction strategy is used whereas for <span class="math">\\nu = \\eta</span>, such a strategy is not used. For the partial reduction strategy, the output <span class="math">h^{(3)}(\\theta)</span> returned by reduceSLPMP is</p>

    <p class="text-gray-300">an <span class="math">(m+1)</span>-bit integer. So, if partial reduction strategy is used throughout, then the inputs to mulSLDCC and sqrSLDCC will also be <span class="math">(m+1)</span>-bit integers and so their outputs will be <span class="math">(2m+2)</span>-bit integers. Subsequent applications of reduceSLPMP will have to handle <span class="math">(2m+2)</span>-bit integers. This is the reason why the statement of Theorem 4 specifies the input to reduceSLPMP to be a <span class="math">(2m+2)</span>-bit integer for the case <span class="math">\\nu&lt;\\eta</span>. On the other hand, for <span class="math">\\nu=\\eta</span>, partial reduction is not used and so the output <span class="math">h^{(4)}(\\theta)</span> of reduceSLPMP is an <span class="math">m</span>-bit integer and consequently, the outputs of mulSLDCC and sqrSLDCC will be <span class="math">2m</span>-bit integers.</p>

    <p class="text-gray-300">Partial reduction is useful since it avoids the computation required to reduce <span class="math">h^{(3)}(\\theta)</span> to <span class="math">h^{(4)}(\\theta)</span>. All intermediate computations are performed using partially reduced results and the full reduction is invoked only once at the end. This strategy leads to substantial savings in the number of operations and hence on the consequent speed of computation.</p>

    <p class="text-gray-300">There does not seem to be an efficient way in which the partial reduction strategy can be made to work for Mersenne primes. A possible partially reduced result in reduceSLMP would be <span class="math">h^{(2)}(\\theta)</span>. It can be shown that when the input to reduceSLMP is the product of two <span class="math">m</span>-bit integers each having <span class="math">(\\kappa,\\eta,\\nu)</span>-representation, then <span class="math">h^{(2)}(\\theta)</span> has a <span class="math">(\\kappa,\\eta,\\nu+1)</span>-representation, i.e., it is an <span class="math">(m+1)</span>-bit integer. So, mulSLDCC and sqrSLDCC will produce as output <span class="math">(2m+2)</span>-bit integers. Feeding such an integer as the input of reduceSLMP results in <span class="math">h^{(2)}(\\theta)</span> having a <span class="math">(\\kappa,\\eta,\\nu+3)</span>-representation. In other words, the size of the last limb grows. This can be brought down, but, doing this requires additional computation and results in the partial reduction being less efficient than the full reduction that we have described. In the case of pseudo-Mersenne primes, the partial result returned by reduceSLPMP avoids such growth of the last limb.</p>

    <h5 id="sec-18" class="text-base font-semibold mt-4">Remark:</h5>

    <p class="text-gray-300">Step 5 of reduceSLPMP performs a mulSCC call. As described in Section 5, this call can be implemented using a single carry chain by using the mulx and adc instructions. In reduceSLPMP, Steps 6 to 9 add the output of mulSCC to the initial <span class="math">\\kappa</span> limbs of the input <span class="math">h^{(0)}</span>. It is possible to consider a strategy whereby the multiplications and the additions within mulSCC are done simultaneously with the additions in Steps 6 to 9. It is possible to organise the code such that two independent carry chains arise so that one of the addition chains is implemented using adcx and the other using adox. We have implemented this strategy, but, the gain in speed is not significant and so we do not describe the details.</p>

    <h5 id="sec-19" class="text-base font-semibold mt-4">A variant of reduceSLPMP:</h5>

    <p class="text-gray-300">Bernstein et al. <em>[6]</em> have used an algorithm for partial reduction using a 4-limb representation of <span class="math">2^{255}-19</span>. Function reduceSLPMPa in Algorithm 7 provides a generalization of this algorithm which works for a large class of pseudo-Mersenne primes.</p>

    <p class="text-gray-300">Similar to reduceSLPMP, the boolean condition in Step 19 of reduceSLPMPa does not depend on the input <span class="math">h^{(0)}(\\theta)</span> and is determined entirely by <span class="math">\\eta</span>, <span class="math">\\nu</span> and <span class="math">\\alpha</span>. So, either the ‘then’ part of the ‘if’ statement will be required or, the ‘else’ part of the ‘if’ statement will be required. Among the primes considered in Table 3, the ‘else’ part is required only for the prime <span class="math">2^{256}-2^{32}-977</span>.</p>

    <p class="text-gray-300">The following result states the correctness of reduceSLPMPa</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Theorem 5.</h6>

    <p class="text-gray-300">Let <span class="math">p=2^{m}-\\delta</span> be a prime and let <span class="math">\\kappa\\geq 2</span>, <span class="math">\\eta</span> and <span class="math">\\nu</span> be such that, <span class="math">m</span>-bit integers have a <span class="math">(\\kappa,\\eta,\\nu)</span>-representation. Let <span class="math">\\alpha</span> be such that <span class="math">2^{\\alpha-1}\\leq\\delta&lt;2^{\\alpha}</span>. Suppose that the input <span class="math">h^{(0)}(\\theta)</span> to reduceSLPMPa is the output of either mulSLDCC<span class="math">(f(\\theta),g(\\theta))</span> or sqrSLDCC<span class="math">(f(\\theta))</span> where <span class="math">f(\\theta)</span> and <span class="math">g(\\theta)</span> are <span class="math">\\kappa\\eta</span>-bit integers having <span class="math">(\\kappa,\\eta,\\eta)</span>-representations. Then the output <span class="math">h^{(4)}(\\theta)</span> of reduceSLPMPa has a <span class="math">(\\kappa,\\eta,\\eta)</span>-representation and <span class="math">h^{(4)}(\\theta)\\equiv h^{(0)}(\\theta)\\bmod p</span>.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof is similar to the proof of Theorem 4. The inputs to reduceSLPMP and reduceSLPMPa are of different sizes. On the other hand, Steps 4 to 10 of reduceSLPMPa is exactly the same as that of reduceSLPMP. So, the bounds on the limbs of <span class="math">h^{(2)}(\\theta)</span> can be derived in a manner similar to the bounds obtained in (32) and are as follows: <span class="math">0\\leq h^{(2)}_{j}&lt;2^{\\eta}</span> for <span class="math">j=0,1,\\ldots,\\kappa-1</span>, and <span class="math">0\\leq h^{(2)}_{\\kappa}\\leq\\max(1,2^{\\nu+\\alpha-\\eta})</span>. Since <span class="math">r</span> is computed as <span class="math">r=h^{(2)}_{\\kappa}\\cdot c_{p}=h^{(2)}_{\\kappa}\\cdot 2^{\\eta-\\nu}\\delta&lt;2^{\\eta-\\nu+\\alpha}</span>, we have <span class="math">0\\leq r\\leq\\max(2^{\\eta-\\nu+\\alpha},2^{2\\alpha})</span>. The upper bound on <span class="math">r</span> gives rise to the boolean condition in Step 19. The rest of the argument proceeds along the same lines as that of Theorem 4 and is in fact a bit simpler. The ‘if’ statement in Step 19 determines whether the last addition takes place at limb number <span class="math">0</span> (which is the ‘then’ part), or, whether it takes place at limb number <span class="math">1</span> (which is the ‘else’ part). The ‘else’ part is required only if the addition to limb number <span class="math">0</span> can produce a carry. This part of the argument is similar to the argument for termination corresponding to <span class="math">s=1</span> in the proof of Theorem 4. ∎</p>

    <h5 id="sec-22" class="text-base font-semibold mt-4">Comparison of reduceSLPMP and reduceSLPMPa:</h5>

    <p class="text-gray-300">We note the following points.</p>

    <p class="text-gray-300">Algorithm 7 Partial reduction for saturated limb representation. Performs reduction modulo <span class="math">p</span>, where <span class="math">p = 2^m - \\delta</span> is a pseudo-Mersenne prime; <span class="math">c_p = 2^{\\eta - \\nu} \\delta</span> and <span class="math">\\theta = 2^{\\eta}</span>.</p>

    <p class="text-gray-300">1: function reduceSLPMPa(<span class="math">h_0^{(0)}(\\theta)</span>) 2: input: <span class="math">h^{(0)}(\\theta)</span>. 3: output: <span class="math">h^{(4)}(\\theta)</span>. 4: for <span class="math">i \\gets 0</span> to <span class="math">\\kappa - 1</span> do <span class="math">h_i^{(1)} \\gets h_i^{(0)}</span> end for 5: <span class="math">h_{\\kappa}^{(1)} + h_{\\kappa + 1}^{(1)} \\theta + \\cdots + h_{2\\kappa}^{(1)} \\theta^{\\kappa} \\gets \\text{mulSCC}(h_{\\kappa}^{(0)} + h_{\\kappa + 1}^{(0)} \\theta + \\cdots + h_{2\\kappa - 1}^{(0)} \\theta^{\\kappa - 1}, c_p)</span> 6: <span class="math">t \\gets h_0^{(1)} + h_\\kappa^{(1)}; h_0^{(2)} \\gets t \\mod 2^\\eta; \\mathfrak{c} \\gets \\lfloor t / 2^\\eta \\rfloor</span> 7: for <span class="math">i \\gets 1</span> to <span class="math">\\kappa - 1</span> do 8: <span class="math">t \\gets h_i^{(1)} + h_{\\kappa + i}^{(1)} + \\mathfrak{c}; h_i^{(2)} \\gets t \\mod 2^\\eta; \\mathfrak{c} \\gets \\lfloor t / 2^\\eta \\rfloor</span> 9: end for 10: <span class="math">h_{\\kappa}^{(2)} \\gets h_{2\\kappa}^{(1)} + \\mathfrak{c}</span> 11: <span class="math">r \\gets h_{\\kappa}^{(2)} \\cdot c_p</span> 12: <span class="math">u \\gets h_0^{(2)} + r; h_0^{(3)} \\gets u \\mod 2^\\eta; \\mathfrak{c} \\gets \\lfloor u / 2^\\eta \\rfloor</span> 13: for <span class="math">i \\gets 1</span> to <span class="math">\\kappa - 1</span> do 14: <span class="math">t \\gets h_i^{(2)} + \\mathfrak{c}; h_i^{(3)} \\gets t \\mod 2^\\eta; \\mathfrak{c} \\gets \\lfloor t / 2^\\eta \\rfloor</span> 15: end for 16: <span class="math">h_{\\kappa}^{(3)} \\gets \\mathfrak{c}</span> 17: <span class="math">s \\gets h_{\\kappa}^{(3)} \\cdot c_p</span> 18: <span class="math">z = h_0^{(3)} + s</span>; 19: if <span class="math">\\max(2^{\\eta - \\nu + \\alpha}, 2^{2\\alpha + \\nu&#x27;}) \\leq 2^{\\eta - 1}</span> then 20: <span class="math">h_0^{(4)} \\gets z; h_1^{(4)} \\gets h_1^{(3)}</span> 21: else 22: <span class="math">h_0^{(4)} \\gets z \\mod 2^\\eta; \\mathfrak{c} \\gets \\lfloor z / 2^\\eta \\rfloor; h_1^{(4)} = h_1^{(3)} + \\mathfrak{c}</span> 23: end if 24: for <span class="math">i \\gets 2</span> to <span class="math">\\kappa - 1</span> do <span class="math">h_i^{(4)} \\gets h_i^{(3)}</span> end for 25: PARTIAL REDUCTION: return <span class="math">h^{(4)}(\\theta) = h_0^{(4)} + h_1^{(4)} \\theta + \\cdots + h_{\\kappa - 1}^{(4)} \\theta^{\\kappa - 1}</span> 26: end function.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Full reduction can be obtained using reduceSLPMP, but, reduceSLPMPa always performs partial reduction. So, if reduceSLPMPa is used, then the last reduction is to be done by reduceSLPMP, or, the final output of reduceSLPMPa is to be further reduced using some other method. On the other hand, if <span class="math">\\nu &amp;lt; \\eta</span> and reduceSLPMP is used, then partial reduction will be done for all but the last invocation, and the last invocation will perform full reduction. No other code is required to ensure full reduction.</li>

      <li>The computation of <span class="math">r</span> in reduceSLPMP is slightly more expensive than the computation of <span class="math">r</span> in reduceSLPMPa. Using partial reduction for reduceSLPMP avoids generating <span class="math">h^{(4)}(\\theta)</span> from <span class="math">h^{(3)}(\\theta)</span> saving a few instructions. Compared to reduceSLPMPa, saving these instructions more or less balances the extra cost of generating <span class="math">r</span>.</li>

      <li>We have implemented both reduceSLPMP and reduceSLPMPa as part of the various inversion algorithms. It has been found that the assembly implementations using reduceSLPMP performs better than the assembly implementations using reduceSLPMPa in Skylake and Kaby Lake architectures.</li>

    </ol>

    <p class="text-gray-300">Remark: Theorems 2, 4 and 5 also hold if the algorithms mulSL and sqrSL are used instead of mulSLDCC and sqrSLDCC respectively.</p>

    <p class="text-gray-300">The unsaturated limb representation has been very effectively used in the various implementations of Curve25519 [3, 7, 6, 9].</p>

    <p class="text-gray-300">In the case of saturated limb representation, the tasks of integer multiplication/squaring and reduction are completely separate, i.e., the integer multiplication step simply multiplies two integers while the integer squaring step simply squares an integer without any reference to the prime which will be used to perform the reduction step. In the case of unsaturated limb representation, the multiplication/squaring</p>

    <p class="text-gray-300">step is not simply an integer multiplication/squaring. It uses the underlying prime to return an intermediate reduced result which is then provided as input to the reduction algorithm. Two strategies are described below. The first strategy is a generalization to arbitrary pseudo-Mersenne primes of a strategy used for Curve25519 <em>[6]</em>. For some primes, however, this strategy leads to overflow in the intermediate result. To handle such cases, we describe a modified strategy which works for a larger class of primes. To the best of our knowledge, this modified strategy has not appeared earlier in the literature either in its general form or, for any particular prime.</p>

    <p class="text-gray-300">As in Section 3, let <span class="math">p=2^{m}-\\delta</span>, <span class="math">\\theta=2^{\\eta}</span>, and <span class="math">c_{p}=2^{\\eta-\\nu}\\delta</span>. Since we are working with the unsaturated limb representation, <span class="math">\\eta&lt;64</span>. Let <span class="math">f(\\theta)</span> and <span class="math">g(\\theta)</span> be two elements of <span class="math">\\mathbb{F}_{p}</span> written as</p>

    <p class="text-gray-300"><span class="math">f(\\theta)</span> <span class="math">=</span> <span class="math">f_{0}+f_{1}\\theta+\\cdots+f_{\\kappa-1}\\theta^{\\kappa-1},</span> <span class="math">g(\\theta)</span> <span class="math">=</span> <span class="math">g_{0}+g_{1}\\theta+\\cdots+g_{\\kappa-1}\\theta^{\\kappa-1},</span></p>

    <p class="text-gray-300">where <span class="math">0\\leq f_{i},g_{i}&lt;2^{\\eta}</span> for <span class="math">i=0,1,\\ldots,\\kappa-2</span>, and <span class="math">0\\leq f_{\\kappa-1},\\ g_{\\kappa-1}&lt;2^{\\nu}</span>. The product of <span class="math">f(\\theta)</span> and <span class="math">g(\\theta)</span> modulo <span class="math">p</span> can be written as the polynomial <span class="math">h(\\theta)=h_{0}+h_{1}\\theta+\\cdots+h_{\\kappa-1}\\theta^{\\kappa-1}</span> where</p>

    <p class="text-gray-300"><span class="math">h_{0}</span> <span class="math">=</span> <span class="math">f_{0}g_{0}+c_{p}(f_{1}g_{\\kappa-1}+f_{2}g_{\\kappa-2}+\\cdots+f_{\\kappa-2}g_{2}+f_{\\kappa-1}g_{1}),</span> <span class="math">h_{1}</span> <span class="math">=</span> <span class="math">f_{0}g_{1}+f_{1}g_{0}+c_{p}(f_{2}g_{\\kappa-1}+\\cdots+c_{p}f_{\\kappa-2}g_{3}+f_{\\kappa-1}g_{2}),</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> (43) <span class="math">h_{\\kappa-2}</span> <span class="math">=</span> <span class="math">f_{0}g_{\\kappa-2}+f_{1}g_{\\kappa-3}+f_{2}g_{\\kappa-4}+\\cdots+f_{\\kappa-2}g_{0}+c_{p}f_{\\kappa-1}g_{\\kappa-1},</span> <span class="math">h_{\\kappa-1}</span> <span class="math">=</span> <span class="math">f_{0}g_{\\kappa-1}+f_{1}g_{\\kappa-2}+f_{2}g_{\\kappa-3}+\\cdots+f_{\\kappa-2}g_{1}+f_{\\kappa-1}g_{0}.</span></p>

    <p class="text-gray-300">Substituting <span class="math">g=f</span>, we get similar equations for squaring and during the squaring computation, each cross-product term is computed only once. We have</p>

    <p class="text-gray-300"><span class="math">\\mathfrak{h}_{\\max}</span> <span class="math">=</span> <span class="math">\\max(h_{0},h_{1},\\ldots,h_{\\kappa-1}).</span> (44)</p>

    <p class="text-gray-300">If <span class="math">\\mathfrak{h}_{\\max}&lt;2^{128}</span>, then each of the coefficients <span class="math">h_{i}</span>, <span class="math">i=0,1,\\ldots,\\kappa-1</span> fit in two 64-bit words. In such cases, the above strategy for multiplication/squaring is feasible. We denote the resulting algorithm for multiplication (resp. squaring) as mulUSL (resp. sqrUSL). We note that for many primes, <span class="math">\\mathfrak{h}_{\\max}</span> is significantly below <span class="math">2^{128}</span> and this plays a role in the efficient implementation of the subsequent reduction algorithm.</p>

    <h3 id="sec-24" class="text-xl font-semibold mt-8">7.1 Modified Multiplication Strategy</h3>

    <p class="text-gray-300">In the case where <span class="math">\\mathfrak{h}_{\\max}\\geq 2^{128}</span>, the coefficients in (43) do not fit within two 64-bit words. This happens when the value of <span class="math">c_{p}=2^{\\eta-\\nu}\\delta</span> is a bit large. One example of such a prime is <span class="math">2^{256}-2^{32}-977</span> for which <span class="math">\\delta=2^{32}+977</span>, <span class="math">\\kappa=5</span>, <span class="math">\\eta=52</span> and <span class="math">\\nu=48</span> so that <span class="math">c_{p}=16(2^{32}+977)</span> is a 37-bit integer. To handle such primes, we describe a simple modification of the previous strategy. Define</p>

    <p class="text-gray-300"><span class="math">u_{0}</span> <span class="math">=</span> <span class="math">f_{1}g_{\\kappa-1}+f_{2}g_{\\kappa-2}+\\cdots+f_{\\kappa-2}g_{2}+f_{\\kappa-1}g_{1},</span> <span class="math">u_{1}</span> <span class="math">=</span> <span class="math">f_{2}g_{\\kappa-1}+\\cdots+f_{\\kappa-2}g_{3}+f_{\\kappa-1}g_{2},</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> (45) <span class="math">u_{\\kappa-2}</span> <span class="math">=</span> <span class="math">f_{\\kappa-1}g_{\\kappa-1},</span></p>

    <p class="text-gray-300">where <span class="math">\\max(u_{0},u_{1},\\ldots,u_{\\kappa-2})=u_{0}\\leq\\mathfrak{u}_{\\max}</span> with <span class="math">\\mathfrak{u}_{\\max}=(2^{\\eta}-1)^{2}\\,(\\kappa-1)\\,.</span> For <span class="math">i=0,1,\\ldots,\\kappa-2</span>, define</p>

    <p class="text-gray-300"><span class="math">u_{i,0}=u_{i}\\bmod 2^{\\eta},\\ u_{j,1}=\\lfloor u_{j}/2^{\\eta}\\rfloor\\quad\\text{so that}\\quad u_{j}=u_{j,0}+2^{\\eta}u_{j,1}=u_{j,0}+u_{j,1}\\theta.</span> (46)</p>

    <p class="text-gray-300">Then for <span class="math">f(\\theta)\\cdot g(\\theta)=h(\\theta)=h_{0}+h_{1}\\theta+\\cdots+h_{\\kappa-1}\\theta^{\\kappa-1}</span> such that the coefficients <span class="math">h_{0},\\ldots,h_{\\kappa-1}</span> are given by (43), we have <span class="math">h(\\theta)=h^{\\prime}(\\theta)=h_{0}^{\\prime}+h_{1}^{\\prime}\\theta+\\cdots+h_{\\kappa-1}^{\\prime}\\theta</span> where</p>

    <p class="text-gray-300"><span class="math">h_{0}^{\\prime}</span> <span class="math">=</span> <span class="math">f_{0}g_{0}+c_{p}u_{0,0},</span> <span class="math">h_{1}^{\\prime}</span> <span class="math">=</span> <span class="math">f_{0}g_{1}+f_{1}g_{0}+c_{p}(u_{1,0}+u_{0,1}),</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> (47) <span class="math">h_{\\kappa-2}^{\\prime}</span> <span class="math">=</span> <span class="math">f_{0}g_{\\kappa-2}+f_{1}g_{\\kappa-3}+\\cdots+f_{\\kappa-2}g_{0}+c_{p}(u_{\\kappa-2,0}+u_{\\kappa-1,1}),</span> <span class="math">h_{\\kappa-1}^{\\prime}</span> <span class="math">=</span> <span class="math">f_{0}g_{\\kappa-1}+f_{1}g_{\\kappa-2}+\\cdots+f_{\\kappa-1}g_{0}+c_{p}u_{\\kappa-2,1}.</span></p>

    <p class="text-gray-300">Let</p>

    <p class="text-gray-300"><span class="math">\\mathfrak{h}_{\\max}^{\\prime}</span> <span class="math">=</span> <span class="math">\\max(h_{0}^{\\prime},h_{1}^{\\prime},\\ldots,h_{\\kappa-1}^{\\prime}).</span> (48)</p>

    <p class="text-gray-300"><span class="math">\\mathfrak{u}_{\\max}&lt;2^{128}</span> and <span class="math">\\mathfrak{h}^{\\prime}_{\\max}&lt;2^{128}</span>, then each of the coefficients <span class="math">u_{i}</span>, <span class="math">i=0,1,\\ldots,\\kappa-2</span> and also each of the coefficients <span class="math">h_{j}</span>, <span class="math">j=0,1,\\ldots,\\kappa-1</span> fit in two 64-bit words. So, even if some coefficient of <span class="math">h(\\theta)</span> is greater than or equal to <span class="math">2^{128}</span>, it is still feasible to compute <span class="math">h^{\\prime}(\\theta)</span> using 64-bit arithmetic without any overflow. We denote the resulting multiplication and squaring algorithms by mulUSLa and sqrUSLa respectively.</p>

    <p class="text-gray-300">Remarks:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The rationale for obtaining <span class="math">h^{\\prime}_{0},h^{\\prime}_{1},\\ldots,h^{\\prime}_{\\kappa-1}</span> is that <span class="math">h_{0},h_{1},\\ldots,h_{\\kappa-1}</span> are not 128-bit quantities. For certain primes, it may happen that there is an <span class="math">i\\in\\{0,1,\\ldots,\\kappa-1\\}</span> such that <span class="math">h_{0},h_{1},\\ldots,h_{i}</span> are greater than <span class="math">2^{128}-1</span> while <span class="math">h_{i+1},h_{i+2}\\ldots,h_{\\kappa-1}</span> are each at most <span class="math">2^{128}-1</span>. In such cases, it would be sufficient to use <span class="math">h^{\\prime}_{0},h^{\\prime}_{1}\\ldots,h^{\\prime}_{i},h_{i+1},\\ldots,h_{\\kappa-1}</span>.</li>

      <li>In <em>[15]</em>, a different strategy was used to tackle the situation when <span class="math">\\mathfrak{h}_{\\max}\\geq 2^{128}</span>. This strategy consists of ‘expanding’ <span class="math">u_{0},u_{1},\\ldots,u_{\\kappa-2}</span> to <span class="math">\\kappa</span>, <span class="math">\\eta</span>-bit quantities <span class="math">\\mathfrak{u}_{0},\\mathfrak{u}_{1},\\ldots,\\mathfrak{u}_{\\kappa-2}</span> and then adding <span class="math">c_{p}u_{0}</span> to <span class="math">f_{0}g_{0}</span>; <span class="math">c_{p}u_{1}</span> to <span class="math">f_{0}g_{1}+f_{1}g_{0}</span> and so on. In the present case, this strategy turns out to be less efficient than the strategy used to obtain <span class="math">h^{\\prime}_{0},h^{\\prime}_{1},\\ldots,h^{\\prime}_{\\kappa-1}</span>.</li>

    </ol>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">7.2 Dovetailing with Reduction Algorithms</h3>

    <p class="text-gray-300">The outputs of the multiplication/squaring algorithms are fed as inputs into the reduction algorithms and the outputs of the reduction algorithms are fed as inputs to the multiplication/squaring algorithms. In the <span class="math">(\\kappa,\\eta,\\nu)</span>-representation of an <span class="math">m</span>-bit integer, each of the first <span class="math">\\kappa-1</span> limbs is <span class="math">\\eta</span> bits long and the last limb is <span class="math">\\nu</span> bits long. So, one may consider the goal of the reduction algorithms to ensure that the output indeed has a <span class="math">(\\kappa,\\eta,\\nu)</span>-representation. It is, however, more efficient to obtain a partial reduction, where some of the coefficients of the output of the reduction algorithms may have one extra bit. Such a strategy is feasible, if the multiplication/squaring algorithms applied to such inputs do not lead to any overflow. Based on such criterion, we describe three reduction algorithms.</p>

    <p class="text-gray-300">Let <span class="math">f(\\theta)=f_{0}+f_{1}\\theta+\\cdots+f_{\\kappa-1}\\theta^{\\kappa-1}</span> and <span class="math">g(\\theta)=g_{0}+g_{1}\\theta+\\cdots+g_{\\kappa-1}\\theta^{\\kappa-1}</span>.</p>

    <h4 id="sec-26" class="text-lg font-semibold mt-6">General reduction algorithm:</h4>

    <p class="text-gray-300">Let <span class="math">\\mathfrak{f}(\\theta)=\\mathfrak{f}_{0}+\\mathfrak{f}_{1}\\theta+\\cdots+\\mathfrak{f}_{\\kappa-1}\\theta^{\\kappa-1}</span>. Define a predicate genCond(f) to be true if and only if</p>

    <p class="text-gray-300">\\[ \\begin{array}[]{cccccc}0&\\leq&\\mathfrak{f}_{0},\\mathfrak{f}_{2},\\ldots,\\mathfrak{f}_{\\kappa-2}&<&2^{\\eta};\\\\ 0&\\leq&\\mathfrak{f}_{1}&<&2^{\\eta+1};\\\\ 0&\\leq&\\mathfrak{f}_{\\kappa-1}&<&2^{\\nu}.\\end{array} \\] (49)</p>

    <p class="text-gray-300">Consider the following conditions.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The inputs <span class="math">f(\\theta)</span> and <span class="math">g(\\theta)</span> to mulUSL/sqrUSL or mulUSLa/sqrUSLa satisfy genCond<span class="math">(f)</span> and genCond<span class="math">(g)</span>.</li>

      <li>Let the output of mulUSL/sqrUSL or mulUSLa/sqrUSLa on such <span class="math">f(\\theta)</span> and <span class="math">g(\\theta)</span> be <span class="math">h(\\theta)</span> or <span class="math">h^{\\prime}(\\theta)</span> respectively. Suppose that <span class="math">\\mathfrak{h}_{\\max}&lt;2^{127}</span> or <span class="math">\\mathfrak{h}^{\\prime}_{\\max}&lt;2^{127}</span> as the case may be.</li>

      <li><span class="math">\\kappa\\geq 3</span>.</li>

    </ol>

    <p class="text-gray-300">If the above conditions hold, then we describe the reduction algorithm reduceUSL which takes as input either <span class="math">h(\\theta)</span> or <span class="math">h^{\\prime}(\\theta)</span> as the case may be and produces an output for which (49) holds.</p>

    <h4 id="sec-27" class="text-lg font-semibold mt-6">Reduction algorithm for primes of Type A:</h4>

    <p class="text-gray-300">Let <span class="math">\\mathfrak{f}(\\theta)=\\mathfrak{f}_{0}+\\mathfrak{f}_{1}\\theta+\\cdots+\\mathfrak{f}_{\\kappa-1}\\theta^{\\kappa-1}</span>. Define a predicate condA(f) to be true if and only if</p>

    <p class="text-gray-300">\\[ \\begin{array}[]{cccccc}0&\\leq&\\mathfrak{f}_{1},\\mathfrak{f}_{2},\\ldots,\\mathfrak{f}_{\\kappa-2}&<&2^{\\eta};\\\\ 0&\\leq&\\mathfrak{f}_{0}&<&2^{\\eta+1};\\\\ 0&\\leq&\\mathfrak{f}_{\\kappa-1}&<&2^{\\nu}.\\end{array} \\] (50)</p>

    <p class="text-gray-300">Consider the following conditions.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The inputs <span class="math">f(\\theta)</span> and <span class="math">g(\\theta)</span> to mulUSL/sqrUSL or mulUSLa/sqrUSLa satisfy condA<span class="math">(f)</span> and condA<span class="math">(g)</span>.</li>

      <li>Let the output of mulUSL/sqrUSL or mulUSLa/sqrUSLa on such <span class="math">f(\\theta)</span> and <span class="math">g(\\theta)</span> be <span class="math">h(\\theta)</span> or <span class="math">h^{\\prime}(\\theta)</span> respectively. Suppose that <span class="math">\\mathfrak{h}_{\\max}&lt;2^{\\ell}</span> or <span class="math">\\mathfrak{h}^{\\prime}_{\\max}&lt;2^{\\ell}</span> as the case may be and <span class="math">\\ell&lt;63+\\nu</span>.</li>

      <li><span class="math">\\kappa\\geq 3</span>.</li>

    </ol>

    <p class="text-gray-300">If the above three conditions hold, then we describe the reduction algorithm reduceUSLA which takes as input either <span class="math">h(\\theta)</span> or <span class="math">h^{\\prime}(\\theta)</span> as the case may be and produces an output for which (50) holds. *The primes for which reduceUSLA applies have been identified as type A in Table 3</p>

    <p class="text-gray-300">Reduction algorithm for primes of Type B: Let  <span class="math">\\mathfrak{f}(\\theta) = \\mathfrak{f}_0 + \\mathfrak{f}_1\\theta +\\dots +\\mathfrak{f}_{\\kappa -1}\\theta^{\\kappa -1}</span> . Define a predicate  <span class="math">\\operatorname{condB}(\\mathfrak{f})</span>  to be true if and only if</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{r c l c l}0&amp;amp;\\leq&amp;amp;\\mathfrak {f} _ {0}, \\mathfrak {f} _ {1}, \\dots , \\mathfrak {f} _ {\\kappa - 2}&amp;amp;&amp;lt;  &amp;amp;2 ^ {\\eta + 1};\\\\0&amp;amp;\\leq&amp;amp;\\mathfrak {f} _ {\\kappa - 1}&amp;amp;&amp;lt;  &amp;amp;2 ^ {\\nu + 1}.\\end{array}\\tag {51}</span></div>

    <p class="text-gray-300">Consider the following conditions.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The inputs  <span class="math">f(\\theta)</span>  and  <span class="math">g(\\theta)</span>  to mulUSL/sqrUSL or mulUSLa/sqrUSLa satisfy  <span class="math">\\text{condA}(f)</span>  and  <span class="math">\\text{condA}(g)</span> .</li>

      <li>Let the output of mulUSL/sqrUSL or mulUSLa/sqrUSLa on such  <span class="math">f(\\theta)</span>  and  <span class="math">g(\\theta)</span>  be  <span class="math">h(\\theta)</span>  or  <span class="math">h&#x27;(\\theta)</span>  respectively. Suppose that  <span class="math">\\mathfrak{h}_{\\max} &amp;lt; 2^{\\ell}</span>  or  <span class="math">\\mathfrak{h}_{\\max}&#x27; &amp;lt; 2^{\\ell}</span>  as the case may be and  <span class="math">64 + \\nu &amp;lt; \\ell \\leq 128</span> .</li>

      <li><span class="math">\\kappa \\geq 3</span></li>

    </ol>

    <p class="text-gray-300">If the above three conditions hold, then we describe the reduction algorithm reduceUSLB which takes as input either  <span class="math">h(\\theta)</span>  or  <span class="math">h&#x27;(\\theta)</span>  as the case may be and produces an output for which (51) holds. The primes for which reduceUSLB applies have been identified as type  <span class="math">B</span>  in Table 3. There are two such primes. Note that the condition  <span class="math">\\ell &amp;lt; 63 + \\nu</span>  used to identify type A primes and the condition  <span class="math">64 + \\nu &amp;lt; \\ell \\leq 128</span>  used to identify type B primes are non-exhaustive. They do not cover the values of  <span class="math">\\ell = 63 + \\eta</span>  and  <span class="math">\\ell = 64 + \\eta</span> . None of the primes in Table 3 correspond to such values of  <span class="math">\\ell</span>  and so this is not an issue.</p>

    <p class="text-gray-300">For the three primes identified as type G in Table 3, the conditions required to apply either reduceUSLA or reduceUSLB do not hold. It is possible to consider further conditions to develop an algorithm for the type G primes and we have indeed implemented such an algorithm. This algorithm, however, turns out to be slower than the generic reduceUSL and so we do not describe the details of it.</p>

    <p class="text-gray-300">In this section, we describe several reduction algorithms which works with the unsaturated limb representation. The first of this is Function reduceUSL and is shown in Algorithm 8.</p>

    <p class="text-gray-300">Algorithm 8 Reduction for unsaturated limb representation. Performs reduction modulo  <span class="math">p = 2^m - \\delta</span> ;  <span class="math">m</span> -bit integers have a  <span class="math">(\\kappa, \\eta, \\nu)</span> -representation with  <span class="math">\\eta &amp;lt; 64</span> ;  <span class="math">\\theta = 2^\\eta</span> . 1: function reduceUSL  <span class="math">(h^{(0)}(\\theta))</span> 2: input:  <span class="math">h^{(0)}(\\theta)</span> 3: output:  <span class="math">h^{(1)}(\\theta)</span>  or  <span class="math">h^{(2)}(\\theta)</span> 4:  <span class="math">u \\gets h_0^{(0)} \\bmod 2^\\eta</span> ;  <span class="math">r_0 \\gets \\lfloor h_0^{(0)} / 2^\\eta \\rfloor</span> 5:  <span class="math">t_1 \\gets h_1^{(0)} + r_0</span> ;  <span class="math">v \\gets t_1 \\bmod 2^\\eta</span> ;  <span class="math">r_1 \\gets \\lfloor t_1 / 2^\\eta \\rfloor</span> 6: for  <span class="math">i \\gets 2</span>  to  <span class="math">\\kappa - 2</span>  do 7:  <span class="math">t_i \\gets h_i^{(0)} + r_{i-1}</span> ;  <span class="math">h_i^{(1)} \\gets t_i \\bmod 2^\\eta</span> ;  <span class="math">r_i \\gets \\lfloor t_i / 2^\\eta \\rfloor</span> 8: end for 9:  <span class="math">t_{\\kappa-1} \\gets h_{\\kappa-1}^{(0)} + r_{\\kappa-2}</span> ;  <span class="math">h_{\\kappa-1}^{(1)} \\gets t_{\\kappa-1} \\bmod 2^\\nu</span> ;  <span class="math">r_{\\kappa-1} \\gets \\lfloor t_{\\kappa-1} / 2^\\nu \\rfloor</span> 10:  <span class="math">t \\gets u + \\delta r_{\\kappa-1}</span> ;  <span class="math">h_0^{(1)} \\gets t \\bmod 2^\\eta</span> ;  <span class="math">r_0 \\gets \\lfloor t / 2^\\eta \\rfloor</span> 11:  <span class="math">h_1^{(1)} \\gets v + r_0</span> 12: PARTIAL REDUCTION: return  <span class="math">h^{(1)}(\\theta) = h_0^{(1)} + h_1^{(1)}\\theta + \\dots + h_{\\kappa-1}^{(1)}\\theta^{\\kappa-1}</span> 13:  <span class="math">w \\gets h_1^{(1)} \\bmod 2^\\eta</span> ;  <span class="math">\\mathfrak{c}_1 \\gets \\lfloor h_1^{(1)} / 2^\\eta \\rfloor</span> 14: for  <span class="math">i \\gets 2</span>  to  <span class="math">\\kappa - 2</span>  do 15:  <span class="math">t \\gets h_i^{(1)} + \\mathfrak{c}_{i-1}</span> ;  <span class="math">h_i^{(2)} \\gets t \\bmod 2^\\eta</span> ;  <span class="math">\\mathfrak{c}_i \\gets \\lfloor t / 2^\\eta \\rfloor</span> 16: end for 17:  <span class="math">t \\gets h_{\\kappa-1}^{(1)} + \\mathfrak{c}_{\\kappa-2}</span> ;  <span class="math">h_{\\kappa-1}^{(2)} \\gets t \\bmod 2^\\nu</span> ;  <span class="math">\\mathfrak{c}_{\\kappa-1} \\gets \\lfloor t / 2^\\nu \\rfloor</span> 18:  <span class="math">t \\gets h_0^{(1)} + \\delta \\mathfrak{c}_{\\kappa-1}</span> ;  <span class="math">h_0^{(2)} \\gets t \\bmod 2^\\eta</span> ;  <span class="math">\\mathfrak{c}_0 \\gets \\lfloor t / 2^\\eta \\rfloor</span> 19:  <span class="math">t \\gets w + \\mathfrak{c}_0</span> ;  <span class="math">h_1^{(2)} \\gets t \\bmod 2^\\eta</span> ;  <span class="math">\\mathfrak{c} \\gets \\lfloor t / 2^\\eta \\rfloor</span> 20:  <span class="math">h_2^{(2)} \\gets h_2^{(2)} + \\mathfrak{c}</span> 21: FULL REDUCTION: return  <span class="math">h^{(2)}(\\theta) = h_0^{(2)} + h_1^{(2)}\\theta + \\dots + h_{\\kappa-1}^{(2)}\\theta^{\\kappa-1}</span> 22: end function.</p>

    <p class="text-gray-300">Theorem 6 below states the correctness of reduceUSL. The correctness is based on two assumptions both of which are valid for all the primes considered in this work.</p>

    <p class="text-gray-300">Theorem 6. Let <span class="math">p = 2^m - \\delta</span> and <span class="math">m</span> be such that <span class="math">m</span>-bit integers have <span class="math">(\\kappa, \\eta, \\nu)</span>-representation with <span class="math">\\kappa \\geq 3</span> and <span class="math">\\delta &amp;lt; 2^{2\\eta + \\nu - 129}</span>. Suppose the input <span class="math">h^{(0)}(\\theta) = h_0^{(0)} + h_1^{(0)}\\theta + \\dots + h_{\\kappa - 1}^{(0)}\\theta^{\\kappa - 1}</span> to reduceUSL is such that <span class="math">0 \\leq h_i^{(0)} &amp;lt; 2^{128} - 2^{128 - \\eta}</span> for <span class="math">i = 0, 1, \\ldots, \\kappa - 1</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For partial reduction, the output of reduceUSL is <span class="math">h^{(1)}(\\theta) = h_0^{(1)} + h_1^{(1)}\\theta + \\dots + h_{\\kappa - 1}^{(1)}\\theta^{\\kappa - 1}</span>, where <span class="math">0 \\leq h_1^{(1)} &amp;lt; 2^{\\eta + 1}</span>, <span class="math">0 \\leq h_0^{(1)}, h_2^{(1)}, \\ldots, h_{\\kappa - 2}^{(1)} &amp;lt; 2^{\\eta}</span> and <span class="math">0 \\leq h_{\\kappa - 1}^{(1)} &amp;lt; 2^{\\nu}</span> satisfying <span class="math">h^{(1)}(\\theta) \\equiv h^{(0)}(\\theta) \\bmod p</span>.</li>

      <li>For full reduction, the output <span class="math">h^{(2)}(\\theta)</span> of reduceUSL has a <span class="math">(\\kappa, \\eta, \\nu)</span>-representation and <span class="math">h^{(2)}(\\theta) \\equiv h^{(0)}(\\theta) \\bmod p</span>.</li>

    </ol>

    <p class="text-gray-300">Proof. Since <span class="math">0 \\leq h_0^{(0)} &amp;lt; 2^{128} - 2^{128 - \\eta}</span>, after Step 4, the bounds on <span class="math">u</span> and <span class="math">r_0</span> are <span class="math">0 \\leq u &amp;lt; 2^{\\eta}</span> and <span class="math">0 \\leq r_0 &amp;lt; 2^{128 - \\eta}</span> respectively. In Step 5, <span class="math">t</span> is set to <span class="math">h_1^{(0)} + r_0</span> implying <span class="math">0 \\leq t &amp;lt; 2^{128}</span>. Consequently, <span class="math">0 \\leq v &amp;lt; 2^{\\eta}</span> and <span class="math">0 \\leq r_1 &amp;lt; 2^{128 - \\eta}</span> respectively. After Steps 4-5, <span class="math">h^{(0)}(\\theta)</span> can be written as</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} h^{(0)}(\\theta) = h_0^{(0)} + h_1^{(0)}\\theta + \\dots + h_{\\kappa - 1}^{(0)}\\theta^{\\kappa - 1} \\\\ = \\left(u + r_0\\theta\\right) + h_1^{(0)}\\theta + \\dots + h_{\\kappa - 1}^{(0)}\\theta^{\\kappa - 1} \\\\ = u + \\left(h_1^{(0)} + r_0\\right)\\theta + \\dots + h_{\\kappa - 1}^{(0)}\\theta^{\\kappa - 1} \\\\ = u + t_1\\theta + h_2^{(0)}\\theta^2 + \\dots + h_{\\kappa - 1}^{(0)}\\theta^{\\kappa - 1} \\\\ = u + (v + r_1\\theta)\\theta + h_2^{(0)}\\theta^2 + \\dots + h_{\\kappa - 1}^{(0)}\\theta^{\\kappa - 1} \\\\ = u + v\\theta + \\left(h_2^{(0)} + r_1\\right)\\theta^2 + \\dots + h_{\\kappa - 1}^{(0)}\\theta^{\\kappa - 1}. \\tag{52} \\end{array}</span></div>

    <p class="text-gray-300">The coefficients <span class="math">h_2^{(1)}, h_3^{(1)}, \\ldots, h_{\\kappa - 1}^{(1)}</span> are computed in Steps 6 to 9 as follows.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} h_i^{(1)} = \\left(h_i^{(0)} + r_{j-1}\\right) \\bmod 2^{\\eta}, \\quad r_j = \\left\\lfloor \\left(h_i^{(0)} + r_{j-1}\\right) / 2^{\\eta} \\right\\rfloor, \\quad j = 2, 3, \\dots, \\kappa - 2, \\tag{53} \\\\ h_{\\kappa - 1}^{(1)} = \\left(h_{\\kappa - 1}^{(0)} + r_{\\kappa - 2}\\right) \\bmod 2^{\\nu}, \\quad r_{\\kappa - 1} = \\left\\lfloor \\left(h_{\\kappa - 1}^{(0)} + r_{\\kappa - 2}\\right) / 2^{\\nu} \\right\\rfloor \\end{array}</span></div>

    <p class="text-gray-300">where <span class="math">0 \\leq r_j &amp;lt; 2^{128 - \\eta}</span> and <span class="math">0 \\leq r_{\\kappa - 1} &amp;lt; 2^{128 - \\nu}</span>. Starting from (52) and using (53), the effect of Steps 6 to 9 can be written in the following manner.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} h^{(0)}(\\theta) = u + v\\theta + \\left(h_2^{(0)} + r_1\\right)\\theta^2 + \\dots + h_{\\kappa - 1}^{(0)}\\theta^{\\kappa - 1} \\\\ = u + v\\theta + t_1\\theta^2 + h_3^{(0)}\\theta^3 + \\dots + h_{\\kappa - 1}^{(0)}\\theta^{\\kappa - 1} \\\\ = u + v\\theta + \\left(h_2^{(1)} + r_2\\theta\\right)\\theta^2 + h_3^{(0)}\\theta^3 + \\dots + h_{\\kappa - 1}^{(0)}\\theta^{\\kappa - 1} \\\\ = u + v\\theta + h_2^{(1)}\\theta^2 + \\left(h_3^{(0)} + r_2\\right)\\theta^3 + \\dots + h_{\\kappa - 1}^{(0)}\\theta^{\\kappa - 1} \\\\ \\dots \\quad \\dots \\quad \\dots \\quad \\dots \\quad \\dots \\quad \\dots \\quad \\dots \\\\ = u + v\\theta + h_2^{(1)}\\theta^2 + \\dots + h_{\\kappa - 2}^{(1)}\\theta^{\\kappa - 2} + \\left(h_{\\kappa - 1}^{(0)} + r_{\\kappa - 2}\\right)\\theta^{\\kappa - 1} \\\\ = u + v\\theta + h_2^{(1)}\\theta^2 + \\dots + h_{\\kappa - 2}^{(1)}\\theta^{\\kappa - 2} + t_{\\kappa - 1}\\theta^{\\kappa - 1} \\\\ = u + v\\theta + h_2^{(1)}\\theta^2 + \\dots + h_{\\kappa - 2}^{(1)}\\theta^{\\kappa - 2} + \\left(h_{\\kappa - 1}^{(1)} + r_{\\kappa - 1}2^{\\nu}\\right)\\theta^{\\kappa - 1} \\\\ = u + v\\theta + h_2^{(1)}\\theta^2 + \\dots + h_{\\kappa - 1}^{(1)}\\theta^{\\kappa - 1} + r_{\\kappa - 1}2^{(\\kappa - 1)\\eta + \\nu} \\text{ [since } \\theta = 2^{\\eta} ] \\\\ \\equiv u + v\\theta + h_2^{(1)}\\theta^2 + \\dots + h_{\\kappa - 1}^{(1)}\\theta^{\\kappa - 1} + r_{\\kappa - 1}\\delta \\bmod p \\text{ [using (5)]} \\tag{54} \\end{array}</span></div>

    <p class="text-gray-300">where <span class="math">0 \\leq u, v, h_2^{(1)}, h_3^{(1)}, \\ldots, h_{\\kappa - 2}^{(1)} &amp;lt; 2^{\\eta}</span> and <span class="math">0 \\leq h_{\\kappa - 1}^{(1)} &amp;lt; 2^{\\nu}</span>. The bounds on <span class="math">\\delta r_{\\kappa - 1}</span> are <span class="math">0 \\leq \\delta r_{\\kappa - 1} &amp;lt; 2^{2\\eta + \\nu - 129} \\cdot 2^{128 - \\nu} = 2^{2\\eta - 1}</span>. In Step 10, <span class="math">t</span> is assigned to <span class="math">u + \\delta r_{\\kappa - 1}</span> and so <span class="math">0 \\leq t &amp;lt; 2^{2\\eta}</span>. By the remaining two instructions of Step 10, we get <span class="math">0 \\leq h_0^{(1)} &amp;lt; 2^{\\eta}</span> and <span class="math">0 \\leq r_0 &amp;lt; 2^{\\eta}</span>. By Step 11 we have, <span class="math">0 \\leq h_1^{(1)} &amp;lt; 2^{\\eta + 1}</span>. Hence, from (54), through Steps 10 and 11 we obtain</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} h^{(0)}(\\theta) \\equiv (u + \\delta r_{\\kappa - 1}) + v\\theta + h_2^{(1)}\\theta^2 + \\dots + h_{\\kappa - 1}^{(1)}\\theta^{\\kappa - 1} \\bmod p \\\\ = t + v\\theta + h_2^{(1)}\\theta^2 + \\dots + h_{\\kappa - 1}^{(1)}\\theta^{\\kappa - 1} \\\\ = \\left(t \\bmod 2^{\\eta} + \\lfloor t / 2^{\\eta} \\rfloor \\theta\\right) + v\\theta + h_2^{(1)}\\theta^2 + \\dots + h_{\\kappa - 1}^{(1)}\\theta^{\\kappa - 1} \\text{ [since } \\theta = 2^{\\eta} ] \\\\ = h_0^{(1)} + (v + r_0)\\theta + h_2^{(1)}\\theta^2 + \\dots + h_{\\kappa - 1}^{(1)}\\theta^{\\kappa - 1} \\\\ = h_0^{(1)} + h_1^{(1)}\\theta + h_2^{(1)}\\theta^2 + \\dots + h_{\\kappa - 1}^{(1)}\\theta^{\\kappa - 1} = h^{(1)}(\\theta), \\end{array}</span></div>

    <p class="text-gray-300">where <span class="math">0\\leq h_{1}^{(1)}&lt;2^{\\eta+1}</span>, <span class="math">0\\leq h_{0}^{(1)},h_{2}^{(1)},\\ldots,h_{\\kappa-2}^{(1)}&lt;2^{\\eta}</span>, and <span class="math">h_{\\kappa-1}^{(1)}&lt;2^{\\nu}</span>. From (55) we have <span class="math">h^{(1)}(\\theta)\\equiv h^{(0)}(\\theta)\\bmod p</span> which proves the statement on partial reduction.</p>

    <p class="text-gray-300">To ensure full reduction another pass over the limbs is required. This is performed in Steps 13 to 20. First assume that <span class="math">h_{2}^{(2)}</span> computed in Step 20 satisfies <span class="math">0\\leq h_{2}^{(2)}&lt;2^{\\eta}</span>. Then, it is routine to argue in a manner similar to above that the final computed <span class="math">h^{(2)}(\\theta)</span> is such that <span class="math">h^{(2)}(\\theta)\\equiv h^{(0)}(\\theta)\\bmod p</span> and <span class="math">0\\leq h_{1}^{(2)}&lt;2^{\\eta}</span> for <span class="math">i=0,1,\\ldots,\\kappa-2</span> and <span class="math">0\\leq h_{\\kappa-1}^{(2)}&lt;2^{\\nu}</span>.</p>

    <p class="text-gray-300">We now show that <span class="math">h_{2}^{(2)}</span> computed in Step 20 satisfies <span class="math">0\\leq h_{2}^{(2)}&lt;2^{\\eta}</span>. Since <span class="math">h_{1}^{(1)}&lt;2^{\\eta+1}</span>, this implies <span class="math">\\mathfrak{c}_{1}\\leq 1</span>. In the first iteration of the loop in Steps 14 to 17, <span class="math">\\mathfrak{c}_{1}</span> is added to <span class="math">h_{2}^{(1)}</span> to obtain <span class="math">t</span>. From this <span class="math">t</span>, <span class="math">h_{2}^{(2)}</span> is obtained as <span class="math">t\\bmod 2^{\\eta}</span> and <span class="math">\\mathfrak{c}_{2}</span> is obtained as <span class="math">\\mathfrak{c}=\\lfloor t/2^{\\eta}\\rfloor</span>. So, <span class="math">\\mathfrak{c}_{2}\\leq 1</span>. Since <span class="math">h_{2}^{(1)}&lt;2^{\\eta}</span>, <span class="math">\\mathfrak{c}_{2}=1</span> if and only if <span class="math">h_{2}^{(1)}=2^{\\eta}-1</span> and in this case, <span class="math">h_{2}^{(2)}=0</span>. The following observations can be noted.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathfrak{c}_{i},\\mathfrak{c}\\leq 1</span> for <span class="math">i=0,1,\\ldots,\\kappa-1</span>.</li>

      <li>If <span class="math">\\mathfrak{c}_{2}=0</span>, then <span class="math">\\mathfrak{c}_{i}=0</span> for <span class="math">i=3,4,\\ldots,\\kappa-1</span> and <span class="math">\\mathfrak{c}_{0}=\\mathfrak{c}=0</span>.</li>

    </ol>

    <p class="text-gray-300">So, if <span class="math">\\mathfrak{c}_{2}=0</span>, then <span class="math">\\mathfrak{c}=0</span> and so the value of <span class="math">h_{2}^{(2)}</span> computed in Step 20 is equal to the value of <span class="math">h_{2}^{(2)}</span> computed in Step 15. Since the value of <span class="math">h_{2}^{(2)}</span> computed in this step satisfies <span class="math">0\\leq h_{2}^{(2)}&lt;2^{\\eta}</span> so does the value of <span class="math">h_{2}^{(2)}</span> computed in Step 20. On the other hand, if <span class="math">\\mathfrak{c}_{2}=1</span>, then the value of <span class="math">h_{2}^{(2)}</span> computed in Step 15 is <span class="math">0</span> and so, the value of <span class="math">h_{2}^{(2)}</span> computed in Step 20 is equal to <span class="math">\\mathfrak{c}\\leq 1</span>. So, in both cases, the bounds <span class="math">0\\leq h_{2}^{(2)}&lt;2^{\\eta}</span> hold. ∎</p>

    <h5 id="sec-29" class="text-base font-semibold mt-4">An important implementation issue:</h5>

    <p class="text-gray-300">In Steps 4, 5, 7, 9 and 10, the operations <span class="math">w\\bmod 2^{\\tau}</span> and <span class="math">\\lfloor w/2^{\\tau}\\rfloor</span> are performed on a 128-bit quantity <span class="math">w</span> where <span class="math">\\tau</span> is either <span class="math">\\eta</span> or <span class="math">\\nu</span>. The operation <span class="math">\\lfloor w/2^{\\tau}\\rfloor</span> heavily influences the overall performance of the algorithm. We describe the implementation of the operations <span class="math">w\\bmod 2^{\\tau}</span> and <span class="math">\\lfloor w/2^{\\tau}\\rfloor</span> in more details. The 128-bit quantity <span class="math">w</span> is stored in two 64-bit words <span class="math">w_{0}</span> and <span class="math">w_{1}</span> such that <span class="math">w=w_{0}+w_{1}2^{64}</span>. There are two cases to consider.</p>

    <h5 id="sec-30" class="text-base font-semibold mt-4">Case 1:</h5>

    <p class="text-gray-300"><span class="math">0\\leq w&lt;2^{128-\\tau}</span>. In this case, <span class="math">0\\leq w_{1}&lt;2^{64-\\tau}</span>, i.e., <span class="math">w_{1}</span> is at most a <span class="math">(64-\\tau)</span>-bit word. So, it is possible to left shift <span class="math">w_{1}</span> by <span class="math">\\tau</span> bits and at the same time move in the <span class="math">\\tau</span> most significant bits of <span class="math">w_{0}</span> into the <span class="math">\\tau</span> least significant bits of <span class="math">w_{1}</span>. The assembly level Intel instruction for doing this is shld and the two operations <span class="math">w\\bmod 2^{\\tau}</span> and <span class="math">\\lfloor w/2^{\\tau}\\rfloor</span> are executed as follows.</p>

    <p class="text-gray-300">shld <span class="math">64-\\tau</span>, <span class="math">w_{0}</span>, <span class="math">w_{1}</span> and <span class="math">2^{\\tau}-1</span>, <span class="math">w_{0}</span>.</p>

    <p class="text-gray-300">After executing these two steps, <span class="math">w_{1}</span> stores <span class="math">\\lfloor w/2^{\\tau}\\rfloor</span> and <span class="math">w_{0}</span> stores <span class="math">w\\bmod 2^{\\tau}</span>.</p>

    <h5 id="sec-31" class="text-base font-semibold mt-4">Case 2:</h5>

    <p class="text-gray-300"><span class="math">w\\geq 2^{128-\\tau}</span>. In this case, <span class="math">0\\leq w_{1}&lt;2^{64-\\tau}</span> and the length of <span class="math">w_{1}</span> in bits is more than <span class="math">64-\\tau</span> bits. So, left shifting <span class="math">w_{1}</span> by <span class="math">\\tau</span> bits will result in loss of information and the strategy of Case 1 does not work. Further, the result of <span class="math">\\lfloor w/2^{\\tau}\\rfloor</span> is more than 64 bits in length and requires two 64-bit words to be stored. The strategy in this case is the following. First copy <span class="math">w_{0}</span> to another 64-bit location <span class="math">x_{0}</span>. Right shift <span class="math">\\tau</span> bits of <span class="math">w_{0}</span> while moving in <span class="math">\\tau</span> least significant bits of <span class="math">w_{1}</span> into the most significant bits of <span class="math">w_{0}</span>. (The Intel instruction for doing this is shld.) Then, right shift <span class="math">w_{1}</span> by <span class="math">\\tau</span> bits. The two operations <span class="math">w\\bmod 2^{\\tau}</span> and <span class="math">\\lfloor w/2^{\\tau}\\rfloor</span> are executed as follows.</p>

    <p class="text-gray-300">mov <span class="math">w_{0}</span>, <span class="math">x_{0}</span> and <span class="math">2^{\\tau}-1</span>, <span class="math">x_{0}</span> shrd <span class="math">\\tau</span>, <span class="math">w_{1}</span>, <span class="math">w_{0}</span> shr <span class="math">\\tau</span>, <span class="math">w_{1}</span>.</p>

    <p class="text-gray-300">After executing the above steps, <span class="math">x_{0}</span> stores <span class="math">w\\bmod 2^{\\tau}</span>; <span class="math">w_{0}</span> stores the 64 least significant bits of <span class="math">\\lfloor w/2^{\\tau}\\rfloor</span> and the <span class="math">(64-\\tau)</span> least significant bits of <span class="math">w_{1}</span> stores the <span class="math">(64-\\tau)</span> most significant bits of <span class="math">\\lfloor w/2^{\\tau}\\rfloor</span>.</p>

    <p class="text-gray-300">Clearly Case 2 is more time consuming than Case 1. The applicability of Case 1 and Case 2 to the primes that we have considered are as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For primes identified as type A in Table 3, Case 1 can be applied, except for the prime <span class="math">2^{222}-117</span> where Case 2 needs to be applied only for Step 4 of reduceUSL.</li>

      <li>For primes identified as type B in Table 3, Case 2 needs to be applied.</li>

    </ol>

    <p class="text-gray-300">A computational bottleneck: The various computations  <span class="math">\\lfloor \\cdot /2^{\\tau}\\rfloor</span>  in reduceUSL are strictly sequential. Correspondingly, the operations shld or shrd as the case may be, are not independent and have to be executed in sequence. These are relatively high latency operations and so the strict sequential execution of these operations have a negative impact on the overall performance of the algorithm.</p>

    <p class="text-gray-300">We next describe two other reduction algorithms. The main motivation of these algorithms is to try and ensure that the operations shld or shrd are independent. Achieving such independence comes at the cost of increasing the total number of operations. Even then, for certain primes, the independence of these operations result in an overall faster algorithm.</p>

    <p class="text-gray-300">Remark: Steps 13 to 19 also use the operation  <span class="math">\\lfloor \\cdot /2^{\\tau}\\rfloor</span> , but, these are on 64-bit quantities and can be efficiently implemented using the shr instruction.</p>

    <p class="text-gray-300">Function reduceUSLA in Algorithm 9 describes a reduction algorithm which improves upon reduceUSL for primes identified as type A in Table 3.</p>

    <p class="text-gray-300">Algorithm 9 Improved reduction algorithm for primes identified as type A in Table 3 using unsaturated limb representation. Performs reduction modulo  <span class="math">p = 2^m - \\delta</span>  and  <span class="math">m</span> -bit integers have a  <span class="math">(\\kappa, \\eta, \\nu)</span> -representation with  <span class="math">\\eta &amp;lt; 64</span> ;  <span class="math">\\theta = 2^\\eta</span> .</p>

    <p class="text-gray-300">1: function reduceUSLA  <span class="math">(h^{(0)}(\\theta))</span> 2: input:  <span class="math">h^{(0)}(\\theta)</span> . 3: output:  <span class="math">h^{(2)}(\\theta)</span>  or  <span class="math">h^{(3)}(\\theta)</span> . 4:  <span class="math">r \\gets h_0^{(0)} \\mod 2^\\eta</span> 5: for  <span class="math">i \\gets 1</span>  to  <span class="math">\\kappa - 2</span>  do 6:  <span class="math">h_i^{(1)} \\gets h_i^{(0)} \\mod 2^\\eta + \\lfloor h_{i-1}^{(0)} / 2^\\eta \\rfloor</span> 7: end for 8:  <span class="math">h_{\\kappa - 1}^{(1)} \\gets h_{\\kappa - 1}^{(0)} \\mod 2^\\nu + \\lfloor h_{\\kappa - 2}^{(0)} / 2^\\eta \\rfloor</span> 9:  <span class="math">s \\gets \\lfloor h_{\\kappa - 1}^{(0)} / 2^{\\nu} \\rfloor</span> ;  <span class="math">h_0^{(1)} \\gets r + \\delta s</span> 10:  <span class="math">u \\gets h_0^{(1)} \\mod 2^\\eta</span> ;  <span class="math">r_0 \\gets \\lfloor h_0^{(1)} / 2^\\eta \\rfloor</span> 11: for  <span class="math">i \\gets 1</span>  to  <span class="math">\\kappa - 2</span>  do 12:  <span class="math">t_i \\gets h_i^{(1)} + r_{i-1}</span> ;  <span class="math">h_i^{(2)} \\gets t_i \\mod 2^\\eta</span> ;  <span class="math">r_i \\gets \\lfloor t_i / 2^\\eta \\rfloor</span> 13: end for 14:  <span class="math">t_{\\kappa - 1} \\gets h_{\\kappa - 1}^{(1)} + r_{\\kappa - 2}</span> ;  <span class="math">h_{\\kappa - 1}^{(2)} \\gets t_{\\kappa - 1} \\mod 2^\\nu</span> ;  <span class="math">r_{\\kappa - 1} \\gets \\lfloor t_{\\kappa - 1} / 2^\\nu \\rfloor</span> 15:  <span class="math">h_0^{(2)} \\gets u + \\delta r_{\\kappa - 1}</span> 16: PARTIAL REDUCTION: return  <span class="math">h^{(2)}(\\theta) = h_0^{(2)} + h_1^{(2)}\\theta + \\dots + h_{\\kappa - 1}^{(2)}\\theta^{\\kappa - 1}</span> 17:  <span class="math">v \\gets h_0^{(2)} \\mod 2^\\eta</span> ;  <span class="math">\\mathfrak{c}_0 \\gets \\lfloor h_0^{(2)} / 2^\\eta \\rfloor</span> 18: for  <span class="math">i \\gets 1</span>  to  <span class="math">\\kappa - 2</span>  do 19:  <span class="math">t \\gets h_i^{(2)} + \\mathfrak{c}_{i-1}</span> ;  <span class="math">h_i^{(3)} \\gets t \\mod 2^\\eta</span> ;  <span class="math">\\mathfrak{c}_i \\gets \\lfloor t / 2^\\eta \\rfloor</span> 20: end for 21:  <span class="math">t \\gets h_{\\kappa - 1}^{(2)} + \\mathfrak{c}_{\\kappa - 2}</span> ;  <span class="math">h_{\\kappa - 1}^{(3)} \\gets t \\mod 2^\\nu</span> ;  <span class="math">\\mathfrak{c}_{\\kappa - 1} \\gets \\lfloor t / 2^\\nu \\rfloor</span> 22:  <span class="math">t \\gets v + \\delta \\mathfrak{c}_{\\kappa - 1}</span> ;  <span class="math">h_0^{(3)} \\gets t \\mod 2^\\eta</span> ;  <span class="math">\\mathfrak{c} \\gets \\lfloor t / 2^\\eta \\rfloor</span> 23:  <span class="math">h_1^{(3)} \\gets h_1^{(3)} + \\mathfrak{c}</span> 24: FULL REDUCTION: return  <span class="math">h^{(3)}(\\theta) = h_0^{(3)} + h_1^{(3)}\\theta + \\dots + h_{\\kappa - 1}^{(3)}\\theta^{\\kappa - 1}</span> 25: end function.</p>

    <p class="text-gray-300">The following result states the correctness of reduceUSLA</p>

    <p class="text-gray-300">Theorem 7. Let  <span class="math">p = 2^m - \\delta</span>  be a type  <span class="math">A</span>  prime as identified in Table 3;  <span class="math">m</span>  be such that  <span class="math">m</span> -bit integers have  <span class="math">(\\kappa, \\eta, \\nu)</span> -representation; and  <span class="math">\\delta &amp;lt; 2^{2\\eta + \\nu - 130}</span> . Suppose the input  <span class="math">h^{(0)}(\\theta) = h_0^{(0)} + h_1^{(0)}\\theta + \\dots + h_{\\kappa - 1}^{(0)}\\theta^{\\kappa - 1}</span>  to reduceUSLA is such that  <span class="math">0 \\leq h_i^{(0)} &amp;lt; 2^\\ell</span>  for  <span class="math">i = 0, 1, \\ldots, \\kappa - 1</span>  where  <span class="math">\\ell &amp;lt; 63 + \\nu</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For partial reduction, the output of reduceUSLA is  <span class="math">h^{(2)}(\\theta) = h_0^{(2)} + h_1^{(2)}\\theta + \\dots + h_{\\kappa - 1}^{(2)}\\theta^{\\kappa - 1}</span> , where  <span class="math">0 \\leq h_0^{(2)} &amp;lt; 2^{\\eta + 1}</span> ,  <span class="math">0 \\leq h_1^{(2)}, \\ldots, h_{\\kappa - 2}^{(2)} &amp;lt; 2^{\\eta}</span>  and  <span class="math">0 \\leq h_{\\kappa - 1}^{(2)} &amp;lt; 2^{\\nu}</span>  satisfying  <span class="math">h^{(2)}(\\theta) \\equiv h^{(0)}(\\theta) \\mod p</span> .</li>

      <li>For full reduction, the output  <span class="math">h^{(3)}(\\theta)</span>  of reduceUSLA has a  <span class="math">(\\kappa, \\eta, \\nu)</span> -representation and  <span class="math">h^{(3)}(\\theta) \\equiv h^{(0)}(\\theta) \\mod p</span> .</li>

    </ol>

    <p class="text-gray-300">Proof. Note that for all the primes identified as type A in Table 3, we have <span class="math">\\eta &amp;lt; 62</span>, Steps 4 to 9 convert the <span class="math">h^{(0)}(\\theta)</span> to <span class="math">h^{(1)}(\\theta)</span> ensuring <span class="math">h^{(1)}(\\theta) \\equiv h^{(0)}(\\theta) \\bmod p</span> and Steps 10 to 15 convert <span class="math">h^{(1)}(\\theta)</span> to <span class="math">h^{(2)}(\\theta)</span> ensuring <span class="math">h^{(2)}(\\theta) \\equiv h^{(1)}(\\theta) \\bmod p</span>. Write</p>

    <div class="my-4 text-center"><span class="math-block">h _ {j} ^ {(0)} = h _ {j, 0} ^ {(0)} + h _ {j, 1} ^ {(0)} 2 ^ {\\eta} \\quad \\text{where } h _ {j, 0} ^ {(0)} = h _ {j} ^ {(0)} \\bmod 2 ^ {\\eta}, h _ {j, 1} ^ {(0)} = \\lfloor h _ {j} ^ {(0)} / 2 ^ {\\eta} \\rfloor ,</span></div>

    <div class="my-4 text-center"><span class="math-block">\\text{for } j = 0, 1, \\dots , \\kappa - 2; \\text{ and } \\tag{55}</span></div>

    <div class="my-4 text-center"><span class="math-block">h _ {\\kappa - 1} ^ {(0)} = h _ {\\kappa - 1, 0} ^ {(0)} + h _ {\\kappa - 1, 1} ^ {(0)} 2 ^ {\\nu} \\qquad \\text{where } h _ {\\kappa - 1, 0} ^ {(0)} = h _ {\\kappa - 1} ^ {(0)} \\bmod 2 ^ {\\nu}, h _ {\\kappa - 1, 1} ^ {(0)} = \\lfloor h _ {\\kappa - 1} ^ {(0)} / 2 ^ {\\nu} \\rfloor .</span></div>

    <p class="text-gray-300">Clearly, <span class="math">0 \\leq h_{j,0}^{(0)} &amp;lt; 2^{\\eta} &amp;lt; 2^{62}</span> and <span class="math">0 \\leq h_{j,1}^{(0)} &amp;lt; 2^{\\ell - \\eta}</span> for <span class="math">j = 0, 1, \\ldots, \\kappa - 2</span>; <span class="math">0 \\leq h_{\\kappa - 1,0}^{(0)} &amp;lt; 2^{\\nu}</span> and <span class="math">0 \\leq h_{\\kappa - 1,1}^{(0)} &amp;lt; 2^{\\ell - \\nu}</span>. Using <span class="math">\\ell &amp;lt; 63 + \\nu</span> and <span class="math">\\eta \\geq \\nu</span>, we have <span class="math">0 \\leq h_{j,1}^{(0)} &amp;lt; 2^{62}</span> for <span class="math">j = 0, 1, \\ldots, \\kappa - 1</span>.</p>

    <p class="text-gray-300">In Step 4, <span class="math">r</span> is assigned the value <span class="math">h_{0,0}^{(0)}</span>; for <span class="math">i = 1,2,\\ldots ,\\kappa -2</span>, the <span class="math">i</span>-th iteration of the loop in Steps 5 to 7 assigns the value <span class="math">(h_{i,0}^{(0)} + h_{i - 1,1}^{(0)})</span> to <span class="math">h_i^{(1)}</span>; Step 8 assigns the value <span class="math">(h_{\\kappa -1,0}^{(0)} + h_{\\kappa -2,1}^{(0)})</span> to <span class="math">h_{\\kappa -1}^{(1)}</span>; Step 9 assigns the value <span class="math">h_{\\kappa -1,1}^{(0)}</span> to <span class="math">s</span>. So, <span class="math">0\\leq r &amp;lt; 2^{\\eta}</span>, <span class="math">0\\leq s &amp;lt; 2^{\\ell -\\nu}</span>. Note that <span class="math">2^{(\\kappa -1)\\eta +\\nu} = 2^{m}\\equiv \\delta \\bmod p</span> and so <span class="math">0\\leq \\delta s &amp;lt; 2^{2\\eta +\\ell -130} &amp;lt; 2^{2\\eta -2}</span> since <span class="math">\\ell &amp;lt; 128</span>. Step 9 assigns the value <span class="math">r + \\delta s</span> to <span class="math">h_0^{(1)}</span>. The bounds on <span class="math">h_i^{(1)}</span> are</p>

    <div class="my-4 text-center"><span class="math-block">0 \\leq h _ {0} ^ {(1)} &amp;lt;   2 ^ {2 \\eta - 1} \\quad \\text{and} \\quad 0 \\leq h _ {i} ^ {(1)} &amp;lt;   2 ^ {63} \\text{ for } i = 1, 2, \\dots , \\kappa - 1. \\tag{56}</span></div>

    <p class="text-gray-300">Using <span class="math">\\theta = 2^{\\eta}</span>, we can write <span class="math">h^{(0)}(\\theta)</span> as</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} h ^ {(0)} (\\theta) = h _ {0} ^ {(0)} + h _ {1} ^ {(0)} \\theta + \\dots + h _ {\\kappa - 1} ^ {(0)} \\theta^ {\\kappa - 1} \\\\ = \\left(h _ {0, 0} ^ {(0)} + h _ {0, 1} ^ {(0)} \\theta\\right) + \\left(h _ {1, 0} ^ {(0)} + h _ {1, 1} ^ {(0)} \\theta\\right) \\theta + \\dots + \\left(h _ {\\kappa - 1, 0} ^ {(0)} + h _ {\\kappa - 1, 1} ^ {(0)} 2 ^ {\\nu}\\right) \\theta^ {\\kappa - 1} \\\\ = h _ {0, 0} ^ {(0)} + \\left(h _ {0, 1} ^ {(0)} + h _ {1, 0} ^ {(0)}\\right) \\theta + \\dots + \\left(h _ {\\kappa - 2, 1} ^ {(0)} + h _ {\\kappa - 1, 0} ^ {(0)}\\right) \\theta^ {\\kappa - 1} + h _ {\\kappa - 1, 1} ^ {(0)} 2 ^ {(\\kappa - 1) \\eta + \\nu} \\\\ \\equiv \\left(r + \\delta s\\right) + h _ {1} ^ {(1)} \\theta + \\dots + h _ {\\kappa - 1} ^ {(1)} \\theta^ {\\kappa - 1} \\bmod p [\\text{using (5)}] \\\\ = h _ {0} ^ {(1)} + h _ {1} ^ {(1)} \\theta + \\dots + h _ {\\kappa - 1} ^ {(1)} \\theta^ {\\kappa - 1} = h ^ {(1)} (\\theta). \\tag{57} \\end{array}</span></div>

    <p class="text-gray-300">The argument that Steps 10-14 computes <span class="math">h^{(2)}(\\theta)</span> such that <span class="math">h^{(2)}(\\theta) \\equiv h^{(1)}(\\theta) \\mod p</span> and the limbs of <span class="math">h^{(2)}(\\theta)</span> satisfy the stated bounds for partial reduction is similar to the proof of Theorem 6. The points to be noted are the following.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Since <span class="math">0 \\leq h_0^{(1)} &amp;lt; 2^{2\\eta - 1}</span>, the value of <span class="math">u</span> and <span class="math">r_0</span> computed in Step 10 satisfies <span class="math">0 \\leq u &amp;lt; 2^{\\eta}</span> and <span class="math">0 \\leq r_0 &amp;lt; 2^{\\eta - 1}</span> respectively.</li>

      <li>Since <span class="math">0 \\leq h_i^{(1)} &amp;lt; 2^{63}</span> for <span class="math">i = 1, 2, \\ldots, \\kappa - 2</span>, and <span class="math">\\eta &amp;lt; 64</span>, in Step 12 we have <span class="math">0 \\leq t_i &amp;lt; 2^{64}</span>, <span class="math">0 \\leq h_i^{(2)} &amp;lt; 2^{\\eta}</span> and <span class="math">0 \\leq r_i &amp;lt; 2^{64 - \\eta}</span> for <span class="math">i = 1, 2, \\ldots, \\kappa - 2</span>.</li>

      <li>Since <span class="math">0 \\leq h_{\\kappa - 1}^{(1)} &amp;lt; 2^{63}</span>, in Step 14 we have <span class="math">0 \\leq t_{\\kappa - 1} &amp;lt; 2^{64}</span>, <span class="math">0 \\leq h_{\\kappa - 1}^{(2)} &amp;lt; 2^{\\nu}</span> and <span class="math">0 \\leq r_{\\kappa - 1} &amp;lt; 2^{64 - \\nu}</span>.</li>

      <li>Since <span class="math">0 \\leq \\delta &amp;lt; 2^{2\\eta + \\nu - 130}</span> and <span class="math">0 \\leq r_{\\kappa - 1}^{(1)} &amp;lt; 2^{64 - \\nu}</span>, in Step 15 we have <span class="math">0 \\leq \\delta r_{\\kappa - 1} &amp;lt; 2^{2\\eta - 66} &amp;lt; 2^{\\eta}</span> for all the primes identified as type A in Table 3. This, along with <span class="math">0 \\leq u &amp;lt; 2^{\\eta}</span> implies <span class="math">0 \\leq h_0^{(2)} &amp;lt; 2^{\\eta + 1}</span> in Step 15.</li>

    </ol>

    <p class="text-gray-300">29</p>

    <p class="text-gray-300">The effect of Steps 10 to 15 on <span class="math">h_{1}^{(1)}(\\theta)</span> can be written as</p>

    <p class="text-gray-300"><span class="math">h^{(1)}(\\theta)</span> <span class="math">=</span> <span class="math">h_{0}^{(1)}+h_{1}^{(1)}\\theta+\\cdots+h_{\\kappa-1}^{(1)}\\theta^{\\kappa-1}</span> <span class="math">=</span> <span class="math">(u+r_{0}\\theta)+h_{1}^{(1)}\\theta+\\cdots+h_{\\kappa-1}^{(1)}\\theta^{\\kappa-1}</span> <span class="math">=</span> <span class="math">u+(h_{1}^{(1)}+r_{0})\\theta+\\cdots+h_{\\kappa-1}^{(1)}\\theta^{\\kappa-1}</span> <span class="math">=</span> <span class="math">u+t_{1}\\theta+h_{2}^{(1)}\\theta^{2}+\\cdots+h_{\\kappa-1}^{(1)}\\theta^{\\kappa-1}</span> <span class="math">=</span> <span class="math">u+(h_{1}^{(2)}+r_{1}\\theta)\\theta+h_{2}^{(1)}\\theta^{2}+\\cdots+h_{\\kappa-1}^{(1)}\\theta^{\\kappa-1}</span> <span class="math">=</span> <span class="math">u+h_{1}^{(2)}\\theta+(h_{2}^{(1)}+r_{1})\\theta^{2}+\\cdots+h_{\\kappa-1}^{(1)}\\theta^{\\kappa-1}</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> <span class="math">=</span> <span class="math">u+h_{1}^{(2)}\\theta+h_{2}^{(2)}\\theta^{2}+\\cdots+h_{\\kappa-2}^{(1)}\\theta^{\\kappa-2}+(h_{\\kappa-1}^{(0)}+r_{\\kappa-2})\\theta^{\\kappa-1}</span> <span class="math">=</span> <span class="math">u+h_{1}^{(2)}\\theta+h_{2}^{(2)}\\theta^{2}+\\cdots+h_{\\kappa-2}^{(1)}\\theta^{\\kappa-2}+t_{\\kappa-1}\\theta^{\\kappa-1}</span> <span class="math">=</span> <span class="math">u+h_{1}^{(2)}\\theta+h_{2}^{(2)}\\theta^{2}+\\cdots+h_{\\kappa-2}^{(1)}\\theta^{\\kappa-2}+(h_{\\kappa-1}^{(1)}+r_{\\kappa-1}2^{\\nu})\\theta^{\\kappa-1}</span> <span class="math">=</span> <span class="math">u+h_{1}^{(2)}\\theta+h_{2}^{(2)}\\theta^{2}+\\cdots+h_{\\kappa-1}^{(1)}\\theta^{\\kappa-1}+r_{\\kappa-1}2^{(\\kappa-1)\\eta+\\nu}\\ [\\text{since }\\theta=2^{\\eta}]</span> <span class="math">\\equiv</span> <span class="math">(u+r_{\\kappa-1}\\delta)+h_{1}^{(2)}\\theta+h_{2}^{(2)}\\theta^{2}+\\cdots+h_{\\kappa-1}^{(1)}\\theta^{\\kappa-1}\\ \\text{mod}\\ p\\ [\\text{using}\\ (5)]</span> <span class="math">=</span> <span class="math">h_{0}^{(2)}+h_{1}^{(2)}\\theta+h_{2}^{(2)}\\theta^{2}+\\cdots+h_{\\kappa-1}^{(1)}\\theta^{\\kappa-1}=h^{(2)}(\\theta).</span> (58)</p>

    <p class="text-gray-300">Using the points 1-4 mentioned before, we have the desired bounds on the limbs of <span class="math">h^{(2)}(\\theta)</span> as <span class="math">0\\leq h_{0}^{(2)}&lt;2^{\\eta+1}</span>, <span class="math">0\\leq h_{1}^{(2)},h_{2}^{(2)},\\ldots,h_{\\kappa-2}^{(2)}&lt;2^{\\eta}</span> and <span class="math">0\\leq h_{\\kappa-1}^{(2)}&lt;2^{\\nu}</span>. Combining (57) and (58) we have <span class="math">h^{(2)}(\\theta)\\equiv h^{(0)}(\\theta)\\ \\text{mod}\\ p</span> which proves the statement of partial reduction.</p>

    <p class="text-gray-300">The statement on full reduction is proved in a manner which is very similar to that of Theorem 6. ∎</p>

    <p class="text-gray-300">Function reduceUSLA makes two passes over the limbs compared to reduceUSL which makes a single pass over the limbs. So, the total number of operations required by reduceUSLA is more than that of reduceUSL. Even then, for primes of type A, it turns out that reduceUSLA is faster than reduceUSL. The reason is explained below.</p>

    <h5 id="sec-33" class="text-base font-semibold mt-4">Independent double word shifts:</h5>

    <p class="text-gray-300">The computations <span class="math">\\lfloor\\cdot/2^{\\eta}\\rfloor</span> in Steps 6 and 8 are on <span class="math">\\ell</span>-bit quantities with <span class="math">\\ell&lt;63+\\eta</span>. This computation falls under Case 1 discussed after the proof of Theorem 6 and can be completed using a single shld instruction. The important difference between reduceUSL and reduceUSLA is that in the later case, the shld instructions are <em>independent</em>. So, these can be appropriately pipelined and may also be simultaneously scheduled on separate ALUs. It is this feature that leads to the speed up of reduceUSLA over reduceUSL. For example, on the Intel Skylake processor, for <span class="math">p=2^{255}-19</span>, reduceUSLA takes 25 cycles whereas reduceUSL takes 37 cycles.</p>

    <p class="text-gray-300">Function reduceUSLA has another set of shift operations in Step 14. These operations are on 64-bit words and hence can be computed using the shr instruction. This is true for all the primes except for <span class="math">2^{222}-117</span> for which the first two limbs of <span class="math">h^{(1)}(\\theta)</span> have more than 64 bits and hence the shld instruction has to be applied to extract the required leading bits of these limbs. The latency of shr instruction is much smaller than the latency of shld instruction. The independence of the shld instructions in reduceUSLA more than compensates for the extra shr operations.</p>

    <p class="text-gray-300">It is possible to avoid shld instruction and instead implement the desired functionality with the four instructions shl, mov, shr and or. We have implemented this strategy to try and speed up reduceUSL, but, the resulting speed is still slower than that of reduceUSLA.</p>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">8.2 Improved Reduction for Type B Primes</h3>

    <p class="text-gray-300">There are two primes identified as type B in Table 3. If reduceUSLA is applied to these two primes, then the sizes of all the coefficients of <span class="math">h^{(1)}(\\theta)</span> will be more than 64 bits. So, the subsequent steps of reduceUSLA will require application of shld instead of shr. Further, these shld instructions would not be independent. To avoid this situation, it is possible to make an extra pass over the limbs as in Steps 4 to 9 of reduceUSLA. This results in Function reduceUSLB which is given in Algorithm 10. Each limb of the partially reduced output of reduceUSLB has an extra bit. As mentioned in Section 7.2, only those primes are identified as type B for which this does not lead to an overflow in the multiplication and squaring algorithms.</p>

    <p class="text-gray-300">The following result states the correctness of reduceUSLB</p>

    <p class="text-gray-300">Algorithm 10 Improved reduction algorithm for primes identified as type B in Table 3 using unsaturated limb representation. Performs reduction modulo  <span class="math">p = 2^m - \\delta</span>  and  <span class="math">m</span> -bit integers have a  <span class="math">(\\kappa, \\eta, \\nu)</span> -representation with  <span class="math">\\eta &amp;lt; 64</span> ;  <span class="math">\\theta = 2^\\eta</span> . 1: function reduceUSLB  <span class="math">(h^{(0)}(\\theta))</span> 2: input:  <span class="math">h^{(0)}(\\theta)</span> . 3: output:  <span class="math">h^{(2)}(\\theta)</span>  or  <span class="math">h^{(4)}(\\theta)</span> . 4: for  <span class="math">\\lambda \\gets 0</span>  to 1 do 5:  <span class="math">r \\gets h_0^{(\\lambda)} \\mod 2^\\eta</span> 6: for  <span class="math">i \\gets 1</span>  to  <span class="math">\\kappa - 2</span>  do 7:  <span class="math">h_i^{(\\lambda + 1)} \\gets h_i^{(\\lambda)} \\mod 2^\\eta + \\lfloor h_{i - 1}^{(\\lambda)} / 2^\\eta \\rfloor</span> 8: end for 9:  <span class="math">h_{\\kappa - 1}^{(\\lambda + 1)} \\gets h_{\\kappa - 1}^{(\\lambda)} \\mod 2^\\nu + \\lfloor h_{\\kappa - 2}^{(\\lambda)} / 2^\\eta \\rfloor</span> 10:  <span class="math">s \\gets \\lfloor h_{\\kappa - 1}^{(\\lambda)} / 2^\\nu \\rfloor</span> ;  <span class="math">h_0^{(\\lambda + 1)} \\gets r + \\delta s</span> 11: end for 12: PARTIAL REDUCTION: return  <span class="math">h^{(2)}(\\theta) = h_0^{(2)} + h_1^{(2)}\\theta + \\dots + h_{\\kappa - 1}^{(2)}\\theta^{\\kappa - 1}</span> 13: for  <span class="math">\\lambda \\gets 2</span>  to 3 do 14:  <span class="math">h_0^{(\\lambda + 1)} \\gets h_0^{(\\lambda)} \\mod 2^\\eta</span> ;  <span class="math">\\mathfrak{c} \\gets \\lfloor h_0^{(\\lambda)} / 2^\\eta \\rfloor</span> 15: for  <span class="math">i \\gets 1</span>  to  <span class="math">\\kappa - 2</span>  do 16:  <span class="math">t \\gets h_i^{(\\lambda)} + \\mathfrak{c}</span> ;  <span class="math">h_i^{(\\lambda + 1)} \\gets t \\mod 2^\\eta</span> ;  <span class="math">\\mathfrak{c} \\gets \\lfloor t / 2^\\eta \\rfloor</span> 17: end for 18:  <span class="math">t \\gets h_{\\kappa - 1}^{(\\lambda)} + \\mathfrak{c}</span> ;  <span class="math">h_{\\kappa - 1}^{(\\lambda + 1)} \\gets t \\mod 2^\\nu</span> ;  <span class="math">\\mathfrak{c} \\gets \\lfloor t / 2^\\nu \\rfloor</span> 19:  <span class="math">h_0^{(\\lambda + 1)} \\gets h_0^{(\\lambda + 1)} + \\delta \\mathfrak{c}</span> 20: end for 21:  <span class="math">t \\gets h_0^{(4)}</span> ;  <span class="math">h_0^{(4)} \\gets t \\mod 2^\\eta</span> ;  <span class="math">\\mathfrak{c} \\gets \\lfloor t / 2^\\eta \\rfloor</span> 22:  <span class="math">h_1^{(4)} \\gets h_1^{(4)} + \\mathfrak{c}</span> 23: FULL REDUCTION: return  <span class="math">h^{(4)}(\\theta) = h_0^{(4)} + h_1^{(4)}\\theta + \\dots + h_{\\kappa - 1}^{(4)}\\theta^{\\kappa - 1}</span> 24: end function.</p>

    <p class="text-gray-300">Theorem 8. Let  <span class="math">p = 2^m - \\delta</span>  be a type  <span class="math">B</span>  prime as identified in Table 3;  <span class="math">m</span>  be such that  <span class="math">m</span> -bit integers have  <span class="math">(\\kappa, \\eta, \\nu)</span> -representation; and  <span class="math">\\delta &amp;lt; 2^{2\\eta + \\nu - 130}</span> . Suppose the input  <span class="math">h^{(0)}(\\theta) = h_0^{(0)} + h_1^{(0)}\\theta + \\dots + h_{\\kappa - 1}^{(0)}\\theta^{\\kappa - 1}</span>  to reduceUSLA is such that  <span class="math">0 \\leq h_i^{(0)} &amp;lt; 2^{128}</span>  for  <span class="math">i = 0, 1, \\ldots, \\kappa - 1</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For partial reduction, the output of reduceUSLB is  <span class="math">h^{(2)}(\\theta) = h_0^{(2)} + h_1^{(2)}\\theta + \\dots + h_{\\kappa - 1}^{(2)}\\theta^{\\kappa - 1}</span> , where  <span class="math">0 \\leq h_0^{(2)}, h_1^{(2)}, \\ldots, h_{\\kappa - 2}^{(2)} &amp;lt; 2^{\\eta + 1}</span>  and  <span class="math">0 \\leq h_{\\kappa - 1}^{(2)} &amp;lt; 2^{\\nu + 1}</span>  satisfying  <span class="math">h^{(2)}(\\theta) \\equiv h^{(0)}(\\theta) \\mod p</span> .</li>

      <li>For full reduction, the output  <span class="math">h^{(4)}(\\theta)</span>  of reduceUSLB has a  <span class="math">(\\kappa, \\eta, \\nu)</span> -representation and  <span class="math">h^{(4)}(\\theta) \\equiv h^{(0)}(\\theta) \\mod p</span> .</li>

    </ol>

    <p class="text-gray-300">Proof. The first iteration of the loop in Steps 4 to 11 converts  <span class="math">h^{(0)}(\\theta)</span>  to  <span class="math">h^{(1)}(\\theta)</span> . The correctness of this conversion can be argued in a manner similar to the first part of the proof of Theorem 7. In particular, we obtain</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} h ^ {(0)} (\\theta) = h _ {0} ^ {(0)} + h _ {1} ^ {(0)} \\theta + \\dots + h _ {\\kappa - 1} ^ {(0)} \\theta^ {\\kappa - 1} \\\\ \\equiv \\underbrace {h _ {0} ^ {(1)} + h _ {1} ^ {(1)} \\theta + \\cdots + h _ {\\kappa - 1} ^ {(1)} \\theta^ {\\kappa - 1}} _ {\\text {through first iteration of Steps 4 to 11}} \\bmod p = h ^ {(1)} (\\theta). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Proceeding in a manner similar to the first part of the proof of Theorem 7, it can be shown that  <span class="math">0 \\leq h_0^{(1)} &amp;lt; 2^{2\\eta - 1}</span>  and  <span class="math">0 \\leq h_1^{(1)}, h_2^{(1)}, \\ldots, h_{\\kappa - 1}^{(1)} &amp;lt; 2^{129 - \\eta}</span> .</p>

    <p class="text-gray-300">The second iteration of the loop in Steps 4 to 11 converts  <span class="math">h^{(1)}(\\theta)</span>  to  <span class="math">h^{(2)}(\\theta)</span> . The correctness of this argument is also similar to the first part of the proof of Theorem 7. The only thing required is to argue that the coefficients of  <span class="math">h^{(2)}(\\theta)</span>  satisfy the stated bounds.</p>

    <p class="text-gray-300">Step 5 of the second iteration provides  <span class="math">r</span>  satisfying  <span class="math">0 \\leq r &amp;lt; 2^{\\eta}</span> . We have  <span class="math">\\lfloor h_{i-1}^{(1)} / 2^{\\eta} \\rfloor &amp;lt; 2^{129 - 2\\eta}</span> ,  <span class="math">h_i^{(1)} \\mod 2^\\eta &amp;lt; 2^\\eta</span>  for  <span class="math">i = 1, 2, \\ldots, \\kappa - 2</span> , and  <span class="math">h_{\\kappa-1}^{(1)} \\mod 2^\\nu &amp;lt; 2^\\nu &amp;lt; 2^\\eta</span> . The following three observations hold for both the primes identified as type B in Table 3. Their consequences are also mentioned.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">129 - 2\\eta = 129 - 2 \\cdot 55 = 129 - 110 = 19 &amp;lt; \\nu &amp;lt; \\eta</span> . Consequently, after Steps 6 to 9 of the second iteration are  <span class="math">0 \\leq h_1^{(2)}, h_2^{(2)}, \\ldots, h_{\\kappa - 2}^{(2)} &amp;lt; 2^{\\eta + 1}</span>  and  <span class="math">0 \\leq h_{\\kappa - 1}^{(2)} &amp;lt; 2^{\\nu + 1}</span> .</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\delta&lt;2^{8}</span>. Consequently, after Step 10, <span class="math">\\delta s&lt;2^{8}\\cdot 2^{129-2\\nu}=2^{137-2\\nu}</span>.</li>

      <li><span class="math">137-2\\nu\\leq 137-2\\cdot 52=137-104=33&lt;\\eta</span>. Consequently, after Step 10, <span class="math">0\\leq h_{0}^{(2)}&lt;2^{\\eta+1}</span>.</li>

    </ol>

    <p class="text-gray-300">So, we have</p>

    <p class="text-gray-300"><span class="math">h^{(1)}(\\theta)</span> <span class="math">=</span> <span class="math">h_{0}^{(1)}+h_{1}^{(1)}\\theta+\\cdots+h_{\\kappa-1}^{(1)}\\theta^{\\kappa-1}</span> <span class="math">\\equiv</span> <span class="math">\\underbrace{h_{0}^{(2)}+h_{1}^{(2)}\\theta+\\cdots+h_{\\kappa-1}^{(2)}\\theta^{\\kappa-1}}_{\\text{through second iteration of Steps 4 to 11}}\\mod p=h^{(2)}(\\theta),</span></p>

    <p class="text-gray-300">where <span class="math">0\\leq h_{0}^{(2)},h_{1}^{(2)},\\ldots,h_{\\kappa-2}^{(2)}&lt;2^{\\eta+1}</span> and <span class="math">0\\leq h_{\\kappa-1}^{(2)}&lt;2^{\\nu+1}</span>. Combining (59) and (59) we have <span class="math">h^{(2)}(\\theta)\\equiv h^{(0)}(\\theta)\\bmod p</span>, which proves the statement on partial reduction.</p>

    <p class="text-gray-300">The statement on full reduction is proved routinely. The only point to be noted is that a single pass over the limbs is not sufficient to ensure termination and instead two passes are required. ∎</p>

    <h2 id="sec-35" class="text-2xl font-bold">9 Saturated Limb Computation Without Double Carry Chains</h2>

    <p class="text-gray-300">In Section 5, we have described how the saturated limb representation can be exploited in combination with two independent carry chains to obtain fast squaring and multiplication algorithms. Implementation of these algorithms require the use of the instructions mulx, adcx and adox. For processors which do not provide these instructions, the algorithms in Section 5 cannot be implemented. In this section, we describe algorithms for saturated limb representation which do not use double carry chains and can be implemented on previous generation processors. In Section 7, we have already described algorithms using the unsaturated limb representation which do not use double carry chains. For the prime <span class="math">2^{256}-2^{32}-977</span>, it turns out that the implementation using saturated limb representation without double carry chains is more efficient than the implementation using unsaturated limb representation.</p>

    <p class="text-gray-300">As before, let <span class="math">p=2^{m}-\\delta</span> where <span class="math">m</span>-bit integers have <span class="math">(\\kappa,\\eta,\\nu)</span>-representation. Since we consider the saturated limb representation, we have <span class="math">\\eta=64</span>. As before, <span class="math">\\theta=2^{\\eta}</span> and <span class="math">c_{p}=2^{\\eta-\\nu}\\delta</span>. Let <span class="math">f(\\theta)</span> and <span class="math">g(\\theta)</span> be two <span class="math">m</span>-bit integers written as follows.</p>

    <p class="text-gray-300"><span class="math">f(\\theta)</span> <span class="math">=</span> <span class="math">f_{0}+f_{1}\\theta+\\cdots+f_{\\kappa-1}\\theta^{\\kappa-1},</span> <span class="math">g(\\theta)</span> <span class="math">=</span> <span class="math">g_{0}+g_{1}\\theta+\\cdots+g_{\\kappa-1}\\theta^{\\kappa-1},</span></p>

    <p class="text-gray-300">where <span class="math">0\\leq f_{i},\\;g_{i}&lt;2^{\\eta},\\;i=0,1,\\ldots,\\kappa-2</span>, and <span class="math">0\\leq f_{\\kappa-1},\\;g_{\\kappa-1}&lt;2^{\\nu}</span>. The schoolbook product of <span class="math">f(\\theta)</span> and <span class="math">g(\\theta)</span> modulo <span class="math">p</span> can be written as <span class="math">h(\\theta)=h_{0}+h_{1}\\theta+\\cdots+h_{\\kappa-1}\\theta^{\\kappa-1}</span> where the coefficients <span class="math">h_{i}</span> are given by (43). Since we are working with <span class="math">\\eta=64</span>, the coefficients <span class="math">h_{i}</span> are not guaranteed to fit within 128 bits. We show how to tackle this problem. Define</p>

    <p class="text-gray-300"><span class="math">f_{i}\\cdot g_{j}</span> <span class="math">=</span> <span class="math">u_{i,j}+v_{i,j}2^{\\eta}\\;=\\;u_{i,j}+v_{i,j}\\theta\\text{ for }i,j=0,1,\\ldots,\\kappa-1.</span> (59)</p>

    <p class="text-gray-300">Using <span class="math">\\theta^{\\kappa}=2^{\\kappa\\eta}\\equiv 2^{\\eta-\\nu}\\delta\\bmod p=c_{p}</span> and (59) in (43), we have <span class="math">h(\\theta)\\equiv z(\\theta)\\bmod p</span> where <span class="math">z(\\theta)=z_{0}+z_{1}\\theta+\\cdots+z_{\\kappa-1}\\theta^{\\kappa-1}</span> and</p>

    <p class="text-gray-300"><span class="math">z_{0}</span> <span class="math">=</span> <span class="math">u_{0,0}+c_{p}(u_{1,\\kappa-1}+u_{2,\\kappa-2}+\\cdots+c_{p}u_{\\kappa-2,2}+u_{\\kappa-1,1}</span> <span class="math">+v_{0,\\kappa-1}+v_{1,\\kappa-2}+v_{2,\\kappa-3}+\\cdots+v_{\\kappa-2,1}+v_{\\kappa-1,0}),</span> <span class="math">z_{1}</span> <span class="math">=</span> <span class="math">u_{0,1}+u_{1,0}+v_{0,0}+c_{p}(u_{2,\\kappa-1}+\\cdots+u_{\\kappa-2,3}+u_{\\kappa-1,2}</span> <span class="math">+v_{1,\\kappa-1}+v_{2,\\kappa-2}+\\cdots+v_{\\kappa-2,2}+v_{\\kappa-1,1}),</span> <span class="math">z_{2}</span> <span class="math">=</span> <span class="math">u_{0,2}\\quad+\\;u_{1,1}\\quad+\\;u_{2,0}\\quad+\\cdots+v_{0,1}\\quad+\\;v_{1,0}</span> <span class="math">+c_{p}(u_{\\kappa-2,4}+u_{\\kappa-1,3}+v_{2,\\kappa-1}+\\cdots+v_{\\kappa-2,3}+v_{\\kappa-1,2}),</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> <span class="math">\\cdots</span> (60) <span class="math">z_{\\kappa-3}</span> <span class="math">=</span> <span class="math">u_{0,\\kappa-3}+\\;u_{1,\\kappa-4}+\\;u_{2,\\kappa-5}+\\cdots+v_{0,\\kappa-4}+\\;u_{1,\\kappa-5}</span> <span class="math">+c_{p}(u_{\\kappa-2,\\kappa-1}+u_{\\kappa-1,\\kappa-2}+\\cdots+v_{\\kappa-3,\\kappa-1}+v_{\\kappa-2,\\kappa-2}+v_{\\kappa-1,\\kappa-3}),</span> <span class="math">z_{\\kappa-2}</span> <span class="math">=</span> <span class="math">u_{0,\\kappa-2}+\\;u_{1,\\kappa-3}+\\;u_{2,\\kappa-4}+\\cdots+\\;u_{\\kappa-2,0}\\quad+v_{0,\\kappa-3}</span> <span class="math">+\\;v_{1,\\kappa-4}+\\;v_{2,\\kappa-5}+c_{p}(u_{\\kappa-1,\\kappa-1}+\\cdots+\\;v_{\\kappa-2,\\kappa-1}+v_{\\kappa-1,\\kappa-2}),</span> <span class="math">z_{\\kappa-1}</span> <span class="math">=</span> <span class="math">u_{0,\\kappa-1}+\\;u_{1,\\kappa-2}+\\;u_{2,\\kappa-3}+\\cdots+\\;u_{\\kappa-2,1}\\quad+\\;u_{\\kappa-1,0}</span> <span class="math">+v_{0,\\kappa-2}+\\;v_{1,\\kappa-3}+\\;v_{2,\\kappa-4}+\\cdots+\\;v_{\\kappa-2,0}\\quad+c_{p}v_{\\kappa-1,\\kappa-1}.</span></p>

    <p class="text-gray-300">For all the primes in Table 3, it can be ensured that <span class="math">0\\leq z_{0},z_{1},\\ldots,z_{\\kappa-1}&lt;2^{127}</span>. Substituting <span class="math">g=f</span>, we get similar equations for squaring. Denote the resulting multiplication and squaring algorithms by mulSLa and sqrSLa respectively.</p>

    <p class="text-gray-300">Algorithm 11 Generic reduction algorithm using saturated limb representation for the primes in Table 3. Performs reduction modulo  <span class="math">p = 2^m - \\delta</span>  and  <span class="math">m</span> -bit integers have a  <span class="math">(\\kappa, \\eta, \\nu)</span> -representation with  <span class="math">\\eta = 64</span> ;  <span class="math">\\theta = 2^\\eta</span> . 1: function reduceSL(h(0)(θ)) 2: input: h(0)(θ). 3: output: h(2)(θ) or h(3)(θ). 4: h(1)← h(0) mod 2η; r0← [h(0)/2η] 5: for i← 1 to κ-2 do 6: ti← hi(0) + ri-1; hi(1)← ti mod 2η; ri← [ti/2η] 7: end for 8: tκ-1← h(0) + rκ-2; h(1)← tκ-1 mod 2ν; rκ-1← [tκ-1/2ν] 9: t← h(1) + δrκ-1; h(2)← t mod 2η; c0← [t/2η] 10: for i← 1 to κ-2 do 11: t← hi(1) + ci-1; hi(2)← t mod 2η; ci← [t/2η] 12: end for 13: h(2)← h(1) + cκ-2 14: PARTIAL REDUCTION FOR ν&lt;η: return h(2)(θ) = h(2) + h(2)θ + ··· + h(2)κ-1 15: h(3)← h(2) mod 2ν; cκ-1← [h(2)/2ν] 16: t← h(2) + δcκ-1; h(3)← t mod 2η; c0← [t/2η] 17: h(3)← h(2) + c0 18: for i← 2 to κ-2 do h(3)← h(2) end for 19: FULL REDUCTION: return h(3)(θ) = h(3) + h(3)θ + ··· + h(3)κ-1 20: end function.</p>

    <p class="text-gray-300">Next we describe how to reduce  <span class="math">z(\\theta)</span> . Function reduceSL in Algorithm 11 performs the required computation. The following results state the correctness of reduceSL. The proof is similar to the proofs of the previous results and hence we skip the proof.</p>

    <p class="text-gray-300">Theorem 9. Let  <span class="math">p = 2^m - \\delta</span>  be a prime in Table 3 and  <span class="math">m</span>  be such that  <span class="math">m</span> -bit integers have  <span class="math">(\\kappa, \\eta, \\nu)</span> -representation where  <span class="math">\\eta = 64</span> . Suppose the input  <span class="math">h^{(0)}(\\theta) = h_0^{(0)} + h_1^{(0)}\\theta + \\dots + h_{\\kappa - 1}^{(0)}\\theta^{\\kappa - 1}</span>  to reduceSL is such that  <span class="math">0 \\leq h_i^{(0)} &amp;lt; 2^{128}</span>  for  <span class="math">i = 0, 1, \\ldots, \\kappa - 1</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For partial reduction, the output  <span class="math">h^{(2)}(\\theta)</span>  of reduceSL has a  <span class="math">(\\kappa, \\eta, \\nu + 1)</span> -representation and  <span class="math">h^{(2)}(\\theta) \\equiv h^{(0)}(\\theta) \\mod p</span> .</li>

      <li>For full reduction, the output  <span class="math">h^{(3)}(\\theta)</span>  of reduceSL has a  <span class="math">(\\kappa, \\eta, \\nu)</span> -representation and  <span class="math">h^{(3)}(\\theta) \\equiv h^{(0)}(\\theta) \\mod p</span> .</li>

    </ol>

    <p class="text-gray-300">Remark: The squaring algorithm has some disadvantages using the above strategy. For the primes satisfying  <span class="math">\\nu &amp;lt; \\eta - 1</span> , the doubling involved in the squaring operation can take advantage while computing the terms  <span class="math">2f_{\\kappa - 1} \\cdot f_j</span>  for  <span class="math">j = 0, 1, \\ldots, \\kappa - 1</span> , by first computing  <span class="math">2f_{\\kappa - 1}</span> , through a shift and then multiplying to  <span class="math">f_j</span> . For reduction, we can opt for partial reduction, keeping an extra bit in the last limb, but, then we cannot take the advantage in the doubling operation. For the primes satisfying  <span class="math">\\nu = \\eta</span> , we do not get any advantage with the doubling operation in the squaring algorithm and also full reduction is required.</p>

    <p class="text-gray-300">All the implementations of this work have been developed in the Intel x86 64-bit assembly language. The timing experiments were carried out on a single core of Haswell and Skylake processors. During measurement of the cpu-cycles, turbo-boost and hyper-threading features were turned off. An initial cache warming was done with 25000 iterations and then the median of 100000 iterations was recorded. The time stamp counter TSC was read from the CPU to RAX and RDX registers by RDTSC instruction.</p>

    <p class="text-gray-300">Platform specifications: The details of the hardware and software tools used in our software implementations are as follows.</p>

    <p class="text-gray-300">Haswell: Intel®Core™ i7-4790 4-core CPU 3.60 Ghz. The OS was 64-bit Ubuntu 14.04 LTS and the source code was compiled using GCC version 7.3.0.</p>

    <p class="text-gray-300">Skylake: Intel®Core™ i7-6500U 2-core CPU @ 2.50GHz. The OS was 64-bit Ubuntu 14.04 LTS and the source code was compiled using GCC version 7.3.0.</p>

    <p class="text-gray-300">Recall from Section 4 that maa denotes implementations where arithmetic is performed using only mul, imul, add and adc, while maax denotes implementations which also use the instructions mulx, adcx and adox. For the meanings of the various algorithms, we again refer to Section 4.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">field</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">implementation type - maa</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">previous</td>

            <td class="px-3 py-2 border-b border-gray-700">this work</td>

            <td class="px-3 py-2 border-b border-gray-700">algorithm</td>

            <td class="px-3 py-2 border-b border-gray-700">sup</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2127-1</td>

            <td class="px-3 py-2 border-b border-gray-700">(32, 32, 2797) [5]</td>

            <td class="px-3 py-2 border-b border-gray-700">(32, 30, 2503)</td>

            <td class="px-3 py-2 border-b border-gray-700">farith-SLMP</td>

            <td class="px-3 py-2 border-b border-gray-700">(0, 10.3, 10.5)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2221-3</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">(54, 45, 8082) (57, 56, 9957)</td>

            <td class="px-3 py-2 border-b border-gray-700">farith-USLA farith-USL</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2222-117</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">(58, 46, 8385) (64, 55, 10798)</td>

            <td class="px-3 py-2 border-b border-gray-700">farith-USLA farith-USL</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2251-9</td>

            <td class="px-3 py-2 border-b border-gray-700">(72, 55, 12202) [15]</td>

            <td class="px-3 py-2 border-b border-gray-700">(52, 46, 11245) (78, 55, 11803)</td>

            <td class="px-3 py-2 border-b border-gray-700">farith-SLa farith-USLA</td>

            <td class="px-3 py-2 border-b border-gray-700">(27.8, 16.35, 7.8)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2255-19</td>

            <td class="px-3 py-2 border-b border-gray-700">(72, 51, 12359) [6, 5-limb] (77, 64, 15880) [6, 4-limb]</td>

            <td class="px-3 py-2 border-b border-gray-700">(71, 50, 11854) (62, 54, 12393)</td>

            <td class="px-3 py-2 border-b border-gray-700">farith-USLA farith-SLa</td>

            <td class="px-3 py-2 border-b border-gray-700">(1.4, 2.0, 4.1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2256-232-977</td>

            <td class="px-3 py-2 border-b border-gray-700">(86, 62, 20209) [18]</td>

            <td class="px-3 py-2 border-b border-gray-700">(55, 51, 12809) (70, 63, 17202)</td>

            <td class="px-3 py-2 border-b border-gray-700">farith-SLa farith-USL</td>

            <td class="px-3 py-2 border-b border-gray-700">(36.0, 17.7, 36.6)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2266-3</td>

            <td class="px-3 py-2 border-b border-gray-700">(72, 52, 12705) [15]</td>

            <td class="px-3 py-2 border-b border-gray-700">(71, 51, 12413) (85, 50, 14892)</td>

            <td class="px-3 py-2 border-b border-gray-700">farith-USLA farith-USL</td>

            <td class="px-3 py-2 border-b border-gray-700">(1.4, 2.0, 2.3)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2382-105</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">(119, 100, 33437) (127, 102, 39722)</td>

            <td class="px-3 py-2 border-b border-gray-700">farith-USLB farith-USL</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2383-187</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">(119, 101, 33699) (127, 102, 39825)</td>

            <td class="px-3 py-2 border-b border-gray-700">farith-USLB farith-USL</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2414-17</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">(161, 117, 43218) (130, 109, 44239)</td>

            <td class="px-3 py-2 border-b border-gray-700">farith-USLA farith-USLa</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2511-187</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">(199, 144, 72804)</td>

            <td class="px-3 py-2 border-b border-gray-700">farith-USL</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2512-569</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">(199, 144, 73771)</td>

            <td class="px-3 py-2 border-b border-gray-700">farith-USL</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2521-1</td>

            <td class="px-3 py-2 border-b border-gray-700">(210, 166, 76298) [13]</td>

            <td class="px-3 py-2 border-b border-gray-700">(177, 129, 62244) (178, 132, 71546)</td>

            <td class="px-3 py-2 border-b border-gray-700">farith-USLA farith-USL</td>

            <td class="px-3 py-2 border-b border-gray-700">(15.7, 22.3, 18.4)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2607-1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(230, 156, 94149)</td>

            <td class="px-3 py-2 border-b border-gray-700">farith-USL</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 4: Comparison of timings of various field arithmetic algorithms on Haswell.</p>

    <p class="text-gray-300">Timings on Haswell and Skylake are shown in Tables 4, 5 and 6 respectively. The timings in the tables are the numbers of cycles. For comparison, we provide the timings of the most efficient (to the best of our knowledge) and publicly available previous implementations. The timings of the previous implementations were obtained by downloading the relevant software and measuring the required cycles on the same platforms where the present implementations have been measured. A '-' in the columns headed 'previous' indicates that we were unable to find a (reasonably efficient) previous implementation of arithmetic in the corresponding field. The triplet values in the columns headed 'previous' and 'this work' correspond to the measured cpu-cycles for field multiplication, squaring and inverse. The columns headed 'sup' provide the speed-up percentage as a triplet for the three operations. These have been computed using the following formula.</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {s u p} = 1 0 0 \\times \\frac {\\left(\\text {p r e v i o u s c y c l e c o u n t - p r e s e n t c y c l e c o u n t}\\right)}{\\text {p r e v i o u s c y c l e c o u n t}}.</span></div>

    <p class="text-gray-300">For the maa implementations, all applicable algorithms have been implemented and timings recorded. To simplify the presentation, we provide timings for farith-USL. If the algorithm invUSL of farith-USL is not the fastest, then the timing of the triplet is provided which has the fastest time for inversion. The speed-up percentage corresponds to the faster of the two timings.</p>

    <p class="text-gray-300">For the prime  <span class="math">2^{127} - 1</span> , the maa type implementation is done using farith-SLMP. This is basically an optimized version of the implementation by Bernstein et al. [5].</p>

    <p class="text-gray-300">Based on Tables 4 to 6, we make the following observations.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Among the primes considered in this work, only the prime  <span class="math">2^{255} - 19</span>  has a previous maax type implementation. For the other primes, we provide the first maax type implementations.</li>

      <li>For each prime, where a previous maa implementation is available, we report a faster maa implementation. On both processors, the speed-up percentage varies from  <span class="math">2\\%</span>  to about  <span class="math">36\\%</span> .</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In comparison to previous work, we provide the fastest implementations for all the primes that are considered in this work. The speed-up is significant for some important primes. For the latest processors, the max type implementations are faster than max type implementations. Apart from the prime  <span class="math">2^{255} - 19</span> , for all the other primes we provide the first max type implementations.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">field</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">implementation type - maa</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">previous</td>

            <td class="px-3 py-2 border-b border-gray-700">this work</td>

            <td class="px-3 py-2 border-b border-gray-700">algorithm</td>

            <td class="px-3 py-2 border-b border-gray-700">sup</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2127-1</td>

            <td class="px-3 py-2 border-b border-gray-700">(27, 26, 2505) [5]</td>

            <td class="px-3 py-2 border-b border-gray-700">(26, 24, 2263)</td>

            <td class="px-3 py-2 border-b border-gray-700">farith-SLMP</td>

            <td class="px-3 py-2 border-b border-gray-700">(3.7, 7.7, 9.7)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2221-3</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">(58, 41, 7949) (60, 43, 8936)</td>

            <td class="px-3 py-2 border-b border-gray-700">farith-USLA farith-USL</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2222-117</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">(55, 42, 8033) (60, 44, 10067)</td>

            <td class="px-3 py-2 border-b border-gray-700">farith-USLA farith-USL</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2251-9</td>

            <td class="px-3 py-2 border-b border-gray-700">(66, 65, 13632) [15]</td>

            <td class="px-3 py-2 border-b border-gray-700">(50, 46, 11783) (65, 52, 12415)</td>

            <td class="px-3 py-2 border-b border-gray-700">farith-SLa farith-USLA</td>

            <td class="px-3 py-2 border-b border-gray-700">(24.2, 29.2, 13.6)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2255-19</td>

            <td class="px-3 py-2 border-b border-gray-700">(67, 48, 13223) [6, 5-limb] (67, 58, 13901) [6, 4-limb]</td>

            <td class="px-3 py-2 border-b border-gray-700">(65, 47, 12671) (57, 52, 12906)</td>

            <td class="px-3 py-2 border-b border-gray-700">farith-USLA farith-SLa</td>

            <td class="px-3 py-2 border-b border-gray-700">(3.0, 2.1, 4.2)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2256-232-977</td>

            <td class="px-3 py-2 border-b border-gray-700">(74, 54, 18391) [18]</td>

            <td class="px-3 py-2 border-b border-gray-700">(52, 49, 13242) (74, 63, 15565)</td>

            <td class="px-3 py-2 border-b border-gray-700">farith-SLa farith-USLa</td>

            <td class="px-3 py-2 border-b border-gray-700">(29.7, 9.3, 28.0)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2266-3</td>

            <td class="px-3 py-2 border-b border-gray-700">(66, 50, 14472) [15]</td>

            <td class="px-3 py-2 border-b border-gray-700">(65, 48, 13350) (71, 48, 14651)</td>

            <td class="px-3 py-2 border-b border-gray-700">farith-USLA farith-USL</td>

            <td class="px-3 py-2 border-b border-gray-700">(1.51, 4.0, 7.8)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2382-105</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">(107, 92, 30419) (115, 93, 35465)</td>

            <td class="px-3 py-2 border-b border-gray-700">farith-USLB farith-USL</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2383-187</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">(107, 92, 30680) (115, 93, 35552)</td>

            <td class="px-3 py-2 border-b border-gray-700">farith-USLB farith-USL</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2414-17</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">(127, 98, 38096) (126, 97, 39371)</td>

            <td class="px-3 py-2 border-b border-gray-700">farith-USLA farith-USLa</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2511-187</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">(179, 131, 66039)</td>

            <td class="px-3 py-2 border-b border-gray-700">farith-USL</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2512-569</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">(179, 131, 66808)</td>

            <td class="px-3 py-2 border-b border-gray-700">farith-USL</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2521-1</td>

            <td class="px-3 py-2 border-b border-gray-700">(184, 142, 64924) [13]</td>

            <td class="px-3 py-2 border-b border-gray-700">(150, 116, 54790) (162, 121, 63938)</td>

            <td class="px-3 py-2 border-b border-gray-700">farith-USLA farith-USL</td>

            <td class="px-3 py-2 border-b border-gray-700">(18.5, 18.3, 15.6)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2607-1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(202, 137, 83587)</td>

            <td class="px-3 py-2 border-b border-gray-700">farith-USL</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 5: Comparison of maa-timings of various field arithmetic algorithms on Skylake.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">field</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">implementation type - maax</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">previous</td>

            <td class="px-3 py-2 border-b border-gray-700">this work</td>

            <td class="px-3 py-2 border-b border-gray-700">algorithm</td>

            <td class="px-3 py-2 border-b border-gray-700">sup</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2127-1</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">(26, 24, 2154)</td>

            <td class="px-3 py-2 border-b border-gray-700">farithx-SLMP</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2221-3</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">(62, 43, 7728)</td>

            <td class="px-3 py-2 border-b border-gray-700">farithx-SLPMP</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2222-117</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">(64, 40, 7967)</td>

            <td class="px-3 py-2 border-b border-gray-700">farithx-SLPMP</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2251-9</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">(54, 47, 8784)</td>

            <td class="px-3 py-2 border-b border-gray-700">farithx-SLPMP</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2255-19</td>

            <td class="px-3 py-2 border-b border-gray-700">(62, 49, 12170) [21]</td>

            <td class="px-3 py-2 border-b border-gray-700">(54, 42, 9301)</td>

            <td class="px-3 py-2 border-b border-gray-700">farithx-SPLMP</td>

            <td class="px-3 py-2 border-b border-gray-700">(12.9, 14.3, 23.6)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2256-232-977</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">(65, 53, 11501)</td>

            <td class="px-3 py-2 border-b border-gray-700">farithx-SLPMP</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2266-3</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">(65, 53, 12938)</td>

            <td class="px-3 py-2 border-b border-gray-700">farithx-SLPMP</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2382-105</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">(81, 69, 24549)</td>

            <td class="px-3 py-2 border-b border-gray-700">farithx-SLPMP</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2383-187</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">(81, 69, 24628)</td>

            <td class="px-3 py-2 border-b border-gray-700">farithx-SLPMP</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2414-17</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">(97, 80, 30972)</td>

            <td class="px-3 py-2 border-b border-gray-700">farithx-SLPMP</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2511-187</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">(118, 101, 47062)</td>

            <td class="px-3 py-2 border-b border-gray-700">farithx-SLPMP</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2512-569</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">(125, 106, 49713)</td>

            <td class="px-3 py-2 border-b border-gray-700">farithx-SLPMP</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2521-1</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">(128, 108, 53828)</td>

            <td class="px-3 py-2 border-b border-gray-700">farithx-SLMP</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2607-1</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">(159, 129, 74442)</td>

            <td class="px-3 py-2 border-b border-gray-700">farithx-SLMP</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 6: Comparison of maax-timings of various field arithmetic algorithms on Skylake.</p>

    <p class="text-gray-300">In this paper, we have considered efficient algorithms for multiplication and squaring over (pseudo-)Mersenne prime order fields. Our contributions have been two fold. On the theoretical side, we provide various algorithms for multiplication/squaring and reduction. The correctness of the reduction algorithms have been rigorously proven. On the practical side, we provide efficient assembly implementation of the various algorithms for modern Intel processors. For well known primes our implementations are faster than the previous works. We have made all our source codes publicly available so that they can be used to replace the field arithmetic routines in existing softwares.</p>

    <p class="text-gray-300">Acknowledgement. We would like to thank Sumit Kumar Pandey for certain discussions during the early stage of this work. We also express our thanks to Armando Faz Hernández and Jason A. Donenfeld for comments.</p>

    <h2 id="sec-38" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Diego F. Aranha, Paulo S. L. M. Barreto, Geovandro C. C. F. Pereira, and Jefferson E. Ricardini. A note on high-security general-purpose elliptic curves. Cryptology ePrint Archive, Report 2013/647, 2013. https://eprint.iacr.org/2013/647.</li>

      <li>[2] Daniel Bernstein and Bo-Yin Yang. Fast constant-time gcd computation and modular inversion. IACR Transactions on Cryptographic Hardware and Embedded Systems, 2019(3):340–398, May 2019.</li>

      <li>[3] Daniel J. Bernstein. Curve25519: New Diffie-Hellman speed records. In Moti Yung, Yevgeniy Dodis, Aggelos Kiayias, and Tal Malkin, editors, Public Key Cryptography - PKC 2006, 9th International Conference on Theory and Practice of Public-Key Cryptography, New York, NY, USA, April 24-26, 2006, Proceedings, volume 3958 of Lecture Notes in Computer Science, pages 207–228. Springer, 2006.</li>

      <li>[4] Daniel J. Bernstein, Chitchanok Chuengsatiansup, and Tanja Lange. Curve41417: Karatsuba revisited. In Lejla Batina and Matthew Robshaw, editors, Cryptographic Hardware and Embedded Systems - CHES 2014 - 16th International Workshop, Busan, South Korea, September 23-26, 2014. Proceedings, volume 8731 of Lecture Notes in Computer Science, pages 316–334. Springer, 2014.</li>

      <li>[5] Daniel J. Bernstein, Chitchanok Chuengsatiansup, Tanja Lange, and Peter Schwabe. Kummer strikes back: New DH speed records. In Palash Sarkar and Tetsu Iwata, editors, Advances in Cryptology - ASIACRYPT 2014 - 20th International Conference on the Theory and Application of Cryptology and Information Security, Kaoshiung, Taiwan, R.O.C., December 7-11, 2014. Proceedings, Part I, volume 8873 of Lecture Notes in Computer Science, pages 317–337. Springer, 2014. Code available at https://github.com/floodyberry/supercop/tree/master/crypto_scalarmult/kummer/avx2.</li>

      <li>[6] Daniel J. Bernstein, Niels Duif, Tanja Lange, Peter Schwabe, and Bo-Yin Yang. High-speed high-security signatures. J. Cryptographic Engineering, 2(2):77–89, 2012. Code for 5-limb implementation available at https://github.com/floodyberry/supercop/blob/master/crypto_sign/ed25519/amd64-51-30k and the code for 4-limb implementation available at https://github.com/floodyberry/supercop/tree/master/crypto_sign/ed25519/amd64-64-24k.</li>

      <li>[7] Daniel J. Bernstein and Peter Schwabe. NEON crypto. In Emmanuel Prouff and Patrick Schaumont, editors, Cryptographic Hardware and Embedded Systems - CHES 2012 - 14th International Workshop, Leuven, Belgium, September 9-12, 2012. Proceedings, volume 7428 of Lecture Notes in Computer Science, pages 320–339. Springer, 2012.</li>

      <li>[8] Joppe W. Bos, Craig Costello, Hüseyin Hisil, and Kristin E. Lauter. Fast cryptography in genus 2. J. Cryptology, 29(1):28–60, 2016.</li>

      <li>[9] Tung Chou. Sandy2x: New curve25519 speed records. In Orr Dunkelman and Liam Keliher, editors, Selected Areas in Cryptography - SAC 2015 - 22nd International Conference, Sackville, NB, Canada, August 12-14, 2015, Revised Selected Papers, volume 9566 of Lecture Notes in Computer Science, pages 145–160. Springer, 2015. Code available at https://tungchou.github.io/sandy2x/.</li>

      <li>[10] Craig Costello and Patrick Longa. FourQ: Four-dimensional decompositions on a Q-curve over the mersenne prime. In Tetsu Iwata and Jung Hee Cheon, editors, Advances in Cryptology - ASIACRYPT 2015 - 21st International Conference on the Theory and Application of Cryptology and Information Security, Auckland, New Zealand, November 29 - December 3, 2015, Proceedings, Part I, volume 9452 of Lecture Notes in Computer Science, pages 214–235. Springer, 2015. Code available at https://www.microsoft.com/en-us/download/details.aspx?id=52310.</li>

      <li>[11] NIST Curves. Recommended elliptic curves for federal government use. http://csrc.nist.gov/groups/ST/toolkit/documents/dss/NISTReCur.pdf, 1999.</li>

      <li>[12] Pierrick Gaudry and Éric Schost. Genus 2 point counting over prime fields. J. Symb. Comput., 47(4):368–400, 2012.</li>

      <li>[13] Robert Granger and Michael Scott. Faster ECC over <span class="math">\\mathbb{F}_{2^{521}-1}</span>. In Jonathan Katz, editor, Public-Key Cryptography - PKC 2015 - 18th IACR International Conference on Practice and Theory in Public-Key Cryptography, Gaithersburg, MD, USA, March 30 - April 1, 2015, Proceedings, volume 9020 of Lecture Notes in Computer Science, pages 539–553. Springer, 2015. Code available at http://indigo.ie/~mscott/ws521.cpp and http://indigo.ie/~mscott/ed521.cpp.</li>

      <li>[14] Shay Gueron and Vlad Krasnov. Fast prime field elliptic-curve cryptography with 256-bit primes. J. Cryptographic Engineering, 5(2):141–151, 2015.</li>

      <li>[15] Sabyasachi Karati and Palash Sarkar. Kummer for genus one over prime order fields. In Tsuyoshi Takagi and Thomas Peyrin, editors, Advances in Cryptology - ASIACRYPT 2017 - 23rd International Conference</li>

    </ul>

    <p class="text-gray-300">on the Theory and Applications of Cryptology and Information Security, Hong Kong, China, December 3-7, 2017, Proceedings, Part II, volume 10625 of Lecture Notes in Computer Science, pages 3–32. Springer, 2017. Code available at https://github.com/skarati/KummerLineV02.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[16] Neal Koblitz. Elliptic curve cryptosystems. Math. Comp., 48(177):203–209, 1987.</li>

      <li>[17] Neal Koblitz. Hyperelliptic cryptosystems. J. Cryptology, 1(3):139–150, 1989.</li>

      <li>[18] Optimized C library for EC operations on curve secp256k1. https://github.com/bitcoin-core/secp256k1.</li>

      <li>[19] Victor S. Miller. Use of elliptic curves in cryptography. In Advances in Cryptology - CRYPTO’85, Santa Barbara, California, USA, August 18-22, 1985, Proceedings, pages 417–426. Springer Berlin Heidelberg, 1985.</li>

      <li>[20] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system. http://bitcoin.org/bitcoin.pdf, 2009.</li>

      <li>[21] Thomaz Oliveira, Julio López, Hüseyin Hisil, Armando Faz-Hernández, and Francisco Rodríguez-Henríquez. How to (pre-)compute a ladder - improving the performance of X25519 and X448. In Carlisle Adams and Jan Camenisch, editors, Selected Areas in Cryptography - SAC 2017 - 24th International Conference, Ottawa, ON, Canada, August 16-18, 2017, Revised Selected Papers, volume 10719 of Lecture Notes in Computer Science, pages 172–191. Springer, 2017. Code available at https://github.com/armfazh/rfc7748_precomputed.</li>

      <li>[22] E. Ozturk, J. Guilford, and V. Gopal. Large integer squaring on Intel architecture processors, intel white paper. https://www.intel.com/content/dam/www/public/us/en/documents/white-papers/large-integer-squaring-ia-paper.pdf, 2013.</li>

      <li>[23] E. Ozturk, J. Guilford, V. Gopal, and W. Feghali. New instructions supporting large integer arithmetic on Intel architecture processors, intel white paper. https://www.intel.com/content/dam/www/public/us/en/documents/white-papers/ia-large-integer-arithmetic-paper.pdf, 2012.</li>

      <li>[24] Certicom Research. SEC 2: Recommended elliptic curve domain parameters. http://www.secg.org/sec2-v2.pdf, 2010.</li>

    </ul>`;
---

<BaseLayout title="Efficient Arithmetic In (Pseudo-)Mersenne Prime Order Fields (2018/985)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2018 &middot; eprint 2018/985
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
