---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2017/1132';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Doubly-efficient zkSNARKs without trusted setup';
const AUTHORS_HTML = 'Riad S.  Wahby, Ioanna Tzialla, abhi shelat, Justin Thaler, Michael Walfish';

const CONTENT = `    <p class="text-gray-300">Riad S. Wahby^{⋆} rsw@cs.stanford.edu Ioanna Tzialla^{⋄} iontzialla@gmail.com abhi shelat^{†} abhi@neu.edu Justin Thaler^{‡} justin.thaler@georgetown.edu Michael Walfish^{⋄} mwalfish@cs.nyu.edu ^{⋆}Stanford ^{⋄}NYU ^{†}Northeastern ^{‡}Georgetown</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">We present a zero-knowledge argument for NP with low communication complexity, low concrete cost for both the prover and the verifier, and no trusted setup, based on standard cryptographic assumptions. Communication is proportional to <span class="math">d\\cdot\\log G</span> (for <span class="math">d</span> the depth and <span class="math">G</span> the width of the verifying circuit) plus the square root of the witness size. When applied to batched or data-parallel statements, the prover’s runtime is linear and the verifier’s is sub-linear in the verifying circuit size, both with good constants. In addition, witness-related communication can be reduced, at the cost of increased verifier runtime, by leveraging a new commitment scheme for multilinear polynomials, which may be of independent interest. These properties represent a new point in the tradeoffs among setup, complexity assumptions, proof size, and computational cost.</p>

    <p class="text-gray-300">We apply the Fiat-Shamir heuristic to this argument to produce a zero-knowledge succinct non-interactive argument of knowledge (zkSNARK) in the random oracle model, based on the discrete log assumption, which we call Hyrax. We implement Hyrax and evaluate it against five state-of-the-art baseline systems. Our evaluation shows that, even for modest problem sizes, Hyrax gives smaller proofs than all but the most computationally costly baseline, and that its prover and verifier are each faster than three of the five baselines.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">A zero-knowledge proof convinces a verifier of a statement while revealing nothing but its own validity. Since they were introduced by Goldwasser, Micali, and Rackoff <em>[55]</em>, zero-knowledge (ZK) proofs have found applications in domains as diverse as authentication and signature schemes <em>[90, 95]</em>, secure encryption <em>[44, 94]</em>, and emerging blockchain technologies <em>[12]</em>.</p>

    <p class="text-gray-300">A seminal result in the theory of interactive proofs and cryptography is that any problem solvable by an interactive proof (IP) is also solvable by a computational zero-knowledge proof or perfect zero-knowledge argument <em>[8]</em>. This means that, given an interactive proof for any NP-complete problem, one can construct zero-knowledge proofs or arguments for any NP statement. But existing instantiations of this paradigm have large overheads: early techniques <em>[22, 53]</em> require many repetitions to achieve negligible soundness error, and incur polynomial blowups in prover work and communication. More recent work <em>[25, 28, 29, 31, 56, 57, 60]</em> avoids those issues, but generally entails many expensive cryptographic operations.</p>

    <p class="text-gray-300">Several other recent lines of work have sought to avoid these overheads. As detailed in Section 2, however, these works still yield costly protocols or come with significant limitations. In particular, state-of-the-art, general-purpose ZK protocols suffer from one or more of the following problems: (a) they require proof size that is linear or super-linear in the size of the computation verifying an NP witness; (b) they require the prover or verifier to perform work that is super-linear in the time to verify a witness; (c) they require a complex parameter setup to be performed by a trusted party; (d) they rely on non-standard cryptographic assumptions; or (e) they have very high concrete overheads. These issues have limited the use of such general-purpose ZK proof systems in many contexts.</p>

    <p class="text-gray-300">Our goal in this work is to address the limitations of existing general-purpose ZK proofs and arguments. Specifically, we would like to take any computation for verifying an NP statement and turn it into a zero-knowledge proof of the statement’s validity. In addition to concrete efficiency, our desiderata are that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the proof should be <em>succinct</em>, that is, sub-linear in the size of the statement and the witness to the statement’s validity;</li>

      <li>the verifier should run in time linear in input plus proof size;</li>

      <li>the prover, given a witness to the statement’s validity, should run in time linear in the cost of the NP verification procedure;</li>

      <li>the scheme should not require a trusted setup phase or common reference string; and</li>

      <li>soundness and zero-knowledge should each be either statistical or based on standard cryptographic assumptions. Pragmatically, security in the random oracle model <em>[7]</em> suffices.</li>

    </ul>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Our approach</h4>

    <p class="text-gray-300">transforms a state-of-the-art interactive proof for arithmetic circuit (AC) satisfiability into a zero-knowledge argument by composing new ideas with existing techniques.</p>

    <p class="text-gray-300">Ben-Or et al. <em>[8]</em> and Cramer and Damgård <em>[40]</em> show how to transform IPs into computationally ZK proofs or perfectly ZK arguments, using cryptographic commitment schemes. At a high level, rather than sending its messages in the clear, the prover sends cryptographic <em>commitments</em> corresponding to its messages. These commitments are <em>binding</em>, ensuring that the prover cannot cheat by equivocating about its messages. They are also <em>hiding</em>, meaning that the verifier cannot learn the committed value and thus ensuring zero-knowledge. Finally, the commitment scheme has a homomorphism property (§3.1) that allows the verifier to check the prover’s messages “underneath the commitments.”</p>

    <p class="text-gray-300">Accepted wisdom is that such transformations introduce large overheads (e.g., <em>[35, §1.1]</em>). In this paper, we challenge that wisdom by constructing a protocol that meets our desiderata for many cases of interest.</p>

    <p class="text-gray-300">Our starting point is the Giraffe interactive proof <em>[109]</em> with an optimization, adapted from Chiesa et al. <em>[35]</em>, that reduces communication complexity (§3.2). We transform this IP into a ZK argument through a straightforward (but careful) application of Cramer-Damgård techniques (§4). This argument uses cryptographic operations (required by the commitment schemes)</p>

    <p class="text-gray-300">only for the witness and for the prover’s messages, which are sub-linear in the size of the AC. (In contrast, many recent works invoke cryptographic primitives for <em>each gate</em> in the verifying circuit <em>[12, 13, 16, 25, 31, 50, 84]</em>; §2.) But the argument is not succinct, and it has high concrete costs, especially for the verifier.</p>

    <p class="text-gray-300">We slash these costs with two key refinements. First, we exploit the IP’s structure by tightly integrating the verification procedure with a multi-commitment scheme and a Schnorr-style proof <em>[95]</em> (§5); this reduces communication and computational costs by 3–5<span class="math">\\times</span> compared to the naive approach. Second, we devise a new witness commitment scheme (§6), yielding a succinct argument and asymptotically reducing the verifier’s cost associated with the witness.</p>

    <p class="text-gray-300">Our protocol is public coin; we compile it into <em>Hyrax</em>, a zero-knowledge succinct non-interactive argument of knowledge (zkSNARK) <em>[20]</em> in the random oracle model <em>[7]</em>, via the Fiat-Shamir heuristic <em>[45]</em> (§7). We evaluate Hyrax and five state-of-the-art baselines (BCCGP-sqrt <em>[25]</em>, Bulletproofs <em>[31]</em>, Ligero <em>[1]</em>, ZKB++ <em>[33]</em>, and libSTARK <em>[11]</em>; §8). Even for modest problem sizes, Hyrax gives smaller proofs than all but the most computationally costly baseline, its prover and verifier are each faster than three of the five baselines, and its refinements yield multiple-orders-of-magnitude savings in proof size and verifier runtime.</p>

    <p class="text-gray-300">Contributions. We design, implement, and evaluate Hyrax, a “doubly” (meaning for both prover and verifier) concretely efficient zkSNARK. For input <span class="math">x</span>, witness <span class="math">w</span>, an AC <span class="math">\\mathcal{C}</span> of width <span class="math">G</span> and depth <span class="math">d</span>, and a design parameter <span class="math">\\iota\\geq 2</span> that controls a tradeoff between proof length and verifier time:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Hyrax’s proofs are succinct, i.e., sub-linear in $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">: they require </span>\\approx<span class="math">10</span>d\\log G+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{1/\\iota}$ group elements;</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- its prover runs in time linear in $</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathcal{C}</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">, with good constants, if </span>\\mathcal{C}<span class="math"> has sufficient parallelism (practically, a few tens of parallel instances suffices), and it requires only O(</span>d\\log G+</td>

            <td class="px-3 py-2 border-b border-gray-700">w</td>

            <td class="px-3 py-2 border-b border-gray-700">$) cryptographic operations, also with good constants; and</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>it requires no trusted setup, and it is secure under the discrete log assumption in the random oracle model.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We also give a new commitment scheme tailored to multilinear polynomials (§6), which may be of independent interest. This scheme allows the prover to commit to a multilinear polynomial <span class="math">m</span> over <span class="math">\\mathbb{F}</span>, and later to reveal (a commitment to) <span class="math">m(r)</span> for any <span class="math">r</span> chosen by the verifier. For <span class="math">\\iota\\geq 2</span>, if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denotes the number of monomials in </span>m<span class="math">, then the commitment has size O</span>(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{1/\\iota})<span class="math">, and the time to verify a purported evaluation is O</span>(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{(\\iota-1)/\\iota})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-5" class="text-2xl font-bold">2 Related work</h2>

    <p class="text-gray-300">ZK proofs. Over the past several years there has been significant interest in implementing ZK proof systems. In this section, we discuss those efforts, focusing on the theoretical underpinnings and associated cryptographic assumptions; we compare Hyrax with several of these works empirically in Section 8.</p>

    <p class="text-gray-300">Gennaro et al. <em>[50]</em> present a linear probabilistically checkable proof (PCP) and ZK transform that form the basis of many recent zkSNARK implementations <em>[4, 5, 12, 13, 15, 16, 30, 36, 38, 43, 46, 47, 48, 69, 81, 84, 110]</em>, including systems deployed in applications like ZCash <em>[12, 111]</em>. These implementations build on theoretical work by Ishai et al. <em>[64]</em>, Groth <em>[58]</em>, Lipmaa <em>[74]</em>, and Bitansky et al. <em>[21]</em>, as well as implementations and refinements in the non-ZK context <em>[30, 96, 97, 98]</em>. Such zkSNARKs give small, constant-sized proofs (hundreds of bytes), and verifier runtime depends only on input size. But ZK systems in this line rely on non-standard, non-falsifiable cryptographic assumptions, require a trusted setup, and have massive prover overhead: runtime is quasi-linear in the verifying circuit size, including a few public key operations per gate, and memory consumption limits the statement sizes these systems can handle in practice <em>[110]</em>.</p>

    <p class="text-gray-300">A line of work by Ben-Sasson et al. builds non-interactive ZK arguments from short PCPs, following the seminal work of Kilian <em>[67, 68]</em> and Micali <em>[78]</em>, the landmark result of Ben-Sasson and Sudan <em>[17]</em>, and recent generalizations of PCPs <em>[9, 14, 92]</em>. The authors reduce the concrete overheads associated with these approaches <em>[10]</em> and implement zero-knowledge scalable transparent arguments of knowledge (zkSTARKs) <em>[11]</em>. zkSTARKs need no trusted setup and no public-key cryptography, but their soundness rests on a non-standard conjecture related to Reed-Solomon codes <em>[11, Appx. B]</em>. Further, zkSTARKs are heavily optimized for statements whose verifying circuits are expressed as a sequence of state-machine transitions; this captures all of NP, but can introduce significant overhead in practice <em>[110]</em>. Both proof size and verifier runtime are logarithmic in circuit size (hundreds of kilobytes and tens of milliseconds, respectively, in practice), and prover runtime is quasi-linear.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Another approach due to Ishai, Kushilevitz, Ostrovsky, and Sahai <em>[65]</em> (IKOS) transforms a secure multi-party computation protocol into a ZK argument. Giacomelli et al. refine this approach and construct ZKBoo <em>[51]</em>, a ZK argument system for Boolean circuits with no trusted setup from collision-resistant hashes; ZKB++, by Chase et al. <em>[33]</em>, reduces proof size by constant factors. Both schemes are concretely inexpensive for small circuits, but their costs scale linearly with circuit size. Ames et al. <em>[1]</em> further refine the IKOS transform and apply it to a more sophisticated secure computation protocol. Their scheme, Ligero, makes similar security assumptions to ZKBoo but proves an AC <span class="math">\\mathcal{C}</span>’s satisfiability with proof size $\\tilde{\\mathrm{O}}(\\sqrt{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math"> and prover and verifier work quasi-linear in </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> (where </span>\\tilde{\\mathrm{O}}$ ignores polylog factors).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Bootle et al. <em>[25]</em> give two ZK arguments for AC satisfiability from the hardness of discrete logarithms, building on the work of Groth <em>[57]</em> and of Bayer and Groth <em>[6]</em>. The first has proof size O<span class="math">(\\sqrt{\\mathcal{M}})</span> and quasi-linear prover and verifier runtime for an AC with <span class="math">\\mathcal{M}</span> multiplications. The second reduces this to O<span class="math">(\\log\\mathcal{M})</span> at the cost of concretely longer prover and verifier runtimes. Bünz et al. <em>[31]</em> reduce proof size and runtimes in the log scheme by <span class="math">\\approx</span>3<span class="math">\\times</span>. Bootle et al. <em>[26]</em> give a ZK argument with proof size O$(\\sqrt{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math"> whose verifier uses O</span>(\\lvert\\mathcal{C}\\rvert)$ <em>additions</em> (which are less expensive than multiplications), but the authors state that the constants are large and do not recommend implementing as-is.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Most similar to our work, Zhang et al. <em>[112]</em> show how to combine an interactive proof <em>[37, 54, 102]</em> and a verifiable polynomial delegation scheme <em>[66, 83]</em> to construct a succinct, non-ZK interactive argument. A follow-up work <em>[113]</em> (concurrent with and independent from ours) achieves ZK using the same commit-and-prove approach that we use, with several key differences. First, their commitment to the witness <span class="math">w</span> has communication $\\mathrm{O}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, but has a trusted setup phase and relies on non-standard, non-falsifiable assumptions. In contrast, our commitment protocol (§6) has no trusted setup and is based on the discrete log assumption, but has communication </span>\\mathrm{O}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{1/\\iota})<span class="math">, </span>\\iota\\geq 2<span class="math">. Second, their argument uses an IP that requires more communication than ours (§3.2). Finally, our method of compiling the IP into a ZK argument uses additional refinements (§5) that reduce costs. Both our IP and our refinements apply to their work; we estimate that they would reduce proof size by </span>\\approx<span class="math">3</span>\\times<span class="math"> and </span>\\mathcal{V}<span class="math"> runtime by </span>\\approx<span class="math">5</span>\\times$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Polynomial commitment schemes</h4>

    <p class="text-gray-300">were introduced by Kate et al. <em>[66]</em>, who gave a construction for univariate polynomials based on pairing assumptions. Several follow-up works <em>[83, 112, 113, 114]</em> extend this construction to multivariate polynomials; Libert et al. <em>[70]</em> give a construction based on constant-size assumptions; and Fujisaki et al. <em>[49]</em> give a construction for polynomial evaluation based on the RSA problem that can be immediately adapted to polynomial commitment. None of these schemes meet our desiderata (§1) because of some combination of high cost, trusted setup, and non-standard assumptions. Bootle et al. <em>[26]</em> and Bootle and Groth <em>[27]</em> describe univariate polynomial commitment schemes based on the discrete log assumption; our scheme is closely related to these ideas and extends them to multilinear polynomials. The second of these also presents a general framework for proving simple relations between commitments and field elements; exploring these ideas in our context is future work.</p>

    <h2 id="sec-7" class="text-2xl font-bold">3 Background</h2>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">3.1 Definitions</h3>

    <p class="text-gray-300">We use <span class="math">\\langle A(z_{a}),B(z_{b})\\rangle(x)</span> to denote the random variable representing the (local) output of machine <span class="math">B</span> when interacting with machine <span class="math">A</span> on common input <span class="math">x</span>, when the random tapes for each machine are uniformly and independently chosen, and <span class="math">A</span> and <span class="math">B</span> has auxiliary inputs <span class="math">z_{a}</span> and <span class="math">z_{b}</span> respectively. We use <span class="math">\\mathrm{tr}\\langle A(z_{a}),B(z_{b})\\rangle(x)</span> to denote the random variable representing the entire transcript of the interaction between <span class="math">A</span> and <span class="math">B</span>, and <span class="math">\\mathsf{View}\\left(\\langle A(z_{a}),B(z_{b})\\rangle(x)\\right)</span> to denote the distribution of the transcript. The symbol <span class="math">\\approx_{c}</span> denotes that two ensembles are computationally indistinguishable.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">Arithmetic circuits</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Section 3.2 considers the arithmetic circuit (AC) evaluation problem. In this problem, one fixes an arithmetic circuit <span class="math">\\mathcal{C}</span>, consisting of addition and multiplication gates over a finite field <span class="math">\\mathbb{F}</span>. We assume throughout that <span class="math">\\mathcal{C}</span> is layered, with all gates having fan-in at most 2 (any arithmetic circuit can be made layered while increasing the number of gates by a factor of at most the circuit depth). <span class="math">\\mathcal{C}</span> has depth <span class="math">d</span> and input <span class="math">x</span> with length $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. The goal is to evaluate </span>\\mathcal{C}<span class="math"> on input </span>x<span class="math">. In an interactive proof or argument for this problem, the prover sends the claimed outputs </span>y<span class="math"> of </span>\\mathcal{C}<span class="math"> on input </span>x<span class="math">, and must prove that </span>y=\\mathcal{C}(x)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Our end goal in this work is to give efficient protocols for the arithmetic circuit <em>satisfiability</em> problem. Let <span class="math">\\mathcal{C}(\\cdot,\\cdot)</span> be a layered arithmetic circuit of fan-in two. Given an input <span class="math">x</span> and outputs <span class="math">y</span>, the goal is to determine whether there exists a <em>witness</em> <span class="math">w</span> such that <span class="math">C(x,w)=y</span>. The corresponding witness relation for this problem is the natural one: <span class="math">R_{(x,y)}=\\{w\\colon C(x,w)=y\\}</span>.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">Interactive protocols and zero-knowledge</h4>

    <h6 id="sec-11" class="text-base font-medium mt-4">Definition 1 (Interactive arguments and proofs).</h6>

    <p class="text-gray-300">A pair of probabilistic interactive machines <span class="math">\\langle\\mathcal{P},\\mathcal{V}\\rangle</span> is called an interactive argument system for a language <span class="math">L</span> if there exists a negligible function <span class="math">\\eta</span> such that the following two conditions hold:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Completeness: For every <span class="math">x\\in L</span> there exists a string <span class="math">w</span> s.t. for every <span class="math">z\\in\\{0,1\\}^{*}</span>, <span class="math">\\Pr[\\langle\\mathcal{P}(w),\\mathcal{V}(z)\\rangle(x)</span>=1$]\\geq 1-\\eta(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If soundness holds against computationally unbounded cheating provers <span class="math">\\mathcal{P}^{*}</span>, then <span class="math">\\langle\\mathcal{P},\\mathcal{V}\\rangle</span> is called an interactive proof (IP).</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Definition 2 (Zero-knowledge (ZK)).</h6>

    <p class="text-gray-300">Let <span class="math">L\\subset\\{0,1\\}^{<em>}</span> be a language and for each <span class="math">x\\in L</span>, let <span class="math">R_{x}\\subset\\{0,1\\}^{</em>}</span> denote a corresponding set of <em>witnesses</em> for the fact that <span class="math">x\\in L</span>. Let <span class="math">R_{L}</span> denote the corresponding language of valid (input, witness) pairs, i.e., <span class="math">R_{L}=\\{(x,w)\\colon x\\in L\\text{ and }w\\in R_{x}\\}</span>. An interactive proof or argument system <span class="math">\\langle\\mathcal{P},\\mathcal{V}\\rangle</span> for <span class="math">L</span> is computational zero-knowledge (CZK) with respect to an auxiliary input if for every PPT interactive machine <span class="math">\\mathcal{V}^{<em>}</span>, there exists a PPT algorithm <span class="math">S</span>, called the </em>simulator<em>, running in time polynomial in the length of its first input, such that for every <span class="math">x\\in L</span>, <span class="math">w\\in R_{x}</span>, and <span class="math">z\\in\\{0,1\\}^{</em>}</span>,</p>

    <p class="text-gray-300"><span class="math">\\mathsf{View}\\left(\\langle P(w),\\mathcal{V}^{*}(z)\\rangle(x)\\right)\\approx_{c}S(x,z)</span> (1)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">when the distinguishing gap is considered as a function of $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. If the <em>statistical distance</em> between the two distributions is negligible, then the interactive proof or argument system is said to be <em>statistical</em> zero-knowledge (SZK). If the simulator is allowed to abort with probability at most </span>1/2<span class="math">, but the distribution of its output conditioned on not aborting is <em>identically</em> distributed to </span>\\mathsf{View}\\left(\\langle P(w),\\mathcal{V}^{<em>}(z)\\rangle(x)\\right)$, then the interactive proof or argument system is called </em>perfect* zero-knowledge (PZK).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The left term in Equation (1) denotes the distribution of transcripts after <span class="math">\\mathcal{V}^{*}</span> interacts with <span class="math">\\mathcal{P}</span> on common input <span class="math">x</span>; the right term denotes the distribution of simulator <span class="math">S</span>’s output on <span class="math">x</span>. For any CZK (resp., SZK or PZK) protocol, Definition 2 requires the simulator to produce a distribution that is computationally (resp., statistically or perfectly) indistinguishable from the distribution of transcripts of the ZK proof or argument system.</p>

    <p class="text-gray-300">Our zero-knowledge arguments also satisfy a proof of knowledge property. Intuitively, this means that in order to produce a convincing proof of a statement, the prover must <em>know</em> a witness to the validity of the statement. To define this notion formally, we follow Groth and Ishai <em>[59]</em> who borrow the notion of statistical witness-extended emulation from Lindell <em>[73]</em>:</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Definition 3 (Witness-extended emulation <em>[59]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">L</span> be a language and <span class="math">R_{L}</span> corresponding language of valid (input, witness) pairs as in Definition 2. An interactive argument system <span class="math">\\langle\\mathcal{P},\\mathcal{V}\\rangle</span></p>

    <p class="text-gray-300">for <span class="math">L</span> has <em>witness-extended emulation</em> if for all deterministic polynomial time <span class="math">\\mathcal{P}^{<em>}</span> there exists an expected polynomial time emulator <span class="math">E</span> such that for all non-uniform polynomial time adversaries <span class="math">A</span> and all <span class="math">z_{\\mathcal{V}}\\in\\{0,1\\}^{</em>}</span>, the following probabilities differ by at most a negligible function in the security parameter <span class="math">\\lambda</span>:</p>

    <p class="text-gray-300">\\[ \\Pr\\left[(x,z_{\\mathcal{P}})\\leftarrow A(1^{\\lambda});t\\leftarrow\\mathsf{tr}\\langle\\mathcal{P}^{<em>}(z_{\\mathcal{P}}),\\mathcal{V}(z_{\\mathcal{V}})\\rangle(x):A(t)=1\\right]\\right.\\\\ and\\ \\Pr\\left[\\begin{array}[]{c}(x,z_{\\mathcal{P}})\\leftarrow A(1^{\\lambda});(t,w)\\leftarrow E^{\\mathcal{P}^{</em>}(z_{\\mathcal{P}})}(x):A(t)=1\\wedge\\\\ \\text{if }t\\text{ is an accepting transcript, then }(x,w)\\in R_{L}.\\end{array}\\right] \\]</p>

    <p class="text-gray-300">Here, the oracle called by <span class="math">E</span> permits rewinding the prover to a specific point and resuming with fresh randomness for the verifier from this point onwards.</p>

    <p class="text-gray-300">The protocols of Sections 5 and 6 are <em>generalized special sound</em>, which implies witness-extended emulation (Appx. A.6).</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Definition 4 (Generalized special soundness).</h6>

    <p class="text-gray-300">A <span class="math">(2\\mu+1)</span>-move interactive argument <span class="math">\\langle\\mathcal{P},\\mathcal{V}\\rangle</span> is <em>generalized special sound</em> if there exists a PPT algorithm <span class="math">\\mathrm{Ex}_{\\mathrm{GSS}}</span> that extracts a witness except with negligible probability given an <span class="math">(n_{1},\\ldots,n_{\\mu})</span>-tree of accepting transcripts. This tree comprises <span class="math">n_{1}</span> transcripts with fresh randomness in <span class="math">\\mathcal{V}</span>’s first message; and for each such transcript, <span class="math">n_{2}</span> transcripts with fresh randomness in <span class="math">\\mathcal{V}</span>’s second message; etc., for a total of <span class="math">\\prod_{i=1}^{\\mu}n_{i}</span> leaves. The standard notion of special soundness corresponds to <span class="math">\\mu=1,n_{1}=2</span>.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">Commitment schemes</h4>

    <p class="text-gray-300">Informally, a commitment scheme allows a <em>sender</em> to produce a message <span class="math">C=\\mathsf{Com}(m)</span> that hides <span class="math">m</span> from a <em>receiver</em> but binds the sender to the value <span class="math">m</span>. In particular, when the sender <em>opens</em> <span class="math">C</span> and reveals <span class="math">m</span>, the receiver is convinced that this was indeed the sender’s original value. We say that <span class="math">\\mathsf{Com}_{\\mathrm{pp}}(m;r)</span> is a commitment to <span class="math">m</span> with <em>opening</em> <span class="math">r</span> with respect to public parameters <span class="math">\\mathrm{pp}</span>. The sender chooses <span class="math">r</span> at random; to open the commitment, the sender reveals <span class="math">(m,r)</span>. We frequently leave the public parameters implicit, and sometimes do the same for the opening, e.g., <span class="math">\\mathsf{Com}(m)</span>.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Definition 5 (Collection of non-interactive commitments <em>[62]</em>).</h6>

    <p class="text-gray-300">We say that a tuple of PPT algorithms <span class="math">(\\mathsf{Gen},\\mathsf{Com})</span> is a <em>collection of non-interactive commitments</em> if the following conditions hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Computational binding: For every (non-uniform) PPT <span class="math">A</span>, there is a negligible function <span class="math">\\eta</span> such that for every <span class="math">n\\in\\mathbb{N}</span>,</li>

    </ul>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{c}\\mathrm{pp}\\leftarrow\\mathsf{Gen}(1^{n})\\;;\\\\ (m_{0},r_{0}),(m_{1},r_{1})\\leftarrow A(1^{n},\\mathrm{pp})\\;:\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_{0}\\neq m_{1},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=n,\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\mathsf{Com}_{\\mathrm{pp}}(m_{0};r_{0})=\\mathsf{Com}_{\\mathrm{pp}}(m_{1};r_{1})\\end{array}\\right]\\leq\\eta(n) \\]</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Perfect hiding: For any <span class="math">\\mathrm{pp}\\in\\{0,1\\}^{<em>}</span> and <span class="math">m_{0},m_{1}\\in\\{0,1\\}^{</em>}</span> where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, the ensembles </span>\\{\\mathsf{Com}_{\\mathrm{pp}}(m_{0})\\}_{n\\in\\mathbb{N}}<span class="math"> and </span>\\{\\mathsf{Com}_{\\mathrm{pp}}(m_{1})\\}_{n\\in\\mathbb{N}}$ are identically distributed.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We define only the computational variant of binding and the perfect variant of hiding because the commitment schemes used in our implementation satisfy these properties. The use of such commitment schemes in our context yields a PZK argument. If we instead used perfectly (or statistically) binding, computationally hiding commitments, we would obtain a CZK proof.</p>

    <p class="text-gray-300">Collections of non-interactive commitments can be constructed based on any one-way function <em>[61, 80]</em>, but we require a <em>homomorphism</em> property (defined below) that these commitments do not provide. (The Pedersen commitment <em>[85]</em>, described in Appx. A, provides this property.)</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Definition 6 (Additive homomorphism).</h6>

    <p class="text-gray-300">Given <span class="math">\\mathsf{Com}(x;s_{x})</span> and <span class="math">\\mathsf{Com}(y;s_{y})</span>, there is an operator <span class="math">\\odot</span> such that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Com}(x;s_{x})\\odot\\mathsf{Com}(y;s_{y})=\\mathsf{Com}(x+y;s_{x}+s_{y})</span> and <span class="math">\\mathsf{Com}(x;s_{x})^{k}\\triangleq\\mathsf{Com}(x;s_{x})\\odot\\cdots\\odot\\mathsf{Com}(x;s_{x})</span> (k times)</p>

    <p class="text-gray-300">In a <em>multi-commitment</em> scheme, <span class="math">x</span> and <span class="math">y</span> are vectors, and this additive homomorphism is vector-wise.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">3.2. Our starting point: <span class="math">\\mathrm{Gir}^{++}</span> (Giraffe, with a tweak)</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The most efficient known IPs for the AC evaluation problem (§3.1) follow a line of work starting with the breakthrough result of Goldwasser, Kalai, and Rothblum (GKR) <em>[54]</em>. Cormode, Mitzenmacher, and Thaler (CMT) <em>[37]</em> and Vu et al. <em>[107]</em> refine this result, giving $\\mathrm{O}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> prover and </span>\\mathrm{O}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+d\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> verifier runtimes, for AC </span>\\mathcal{C}<span class="math"> with depth </span>d<span class="math">, input </span>x<span class="math">, and output </span>y$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Further refinements are possible in the case where <span class="math">\\mathcal{C}</span> is <em>data parallel</em>, meaning it consists of <span class="math">N</span> identical sub-computations run on different inputs. (We refer to each sub-computation as a <em>sub-AC</em> of <span class="math">\\mathcal{C}</span>, and we assume for simplicity that all layers of the sub-AC have width <span class="math">G</span>, so $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=d\\cdot N\\cdot G<span class="math">.) Thaler <em>[102]</em> reduced the prover’s runtime in the data-parallel case from </span>\\mathrm{O}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> to </span>\\mathrm{O}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log G)<span class="math">. Very recently, Wahby et al. introduced Giraffe <em>[109]</em>, which reduces the prover’s runtime to </span>\\mathrm{O}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+d\\cdot G\\cdot\\log G)<span class="math">. Since </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=d\\cdot N\\cdot G<span class="math">, observe that when </span>N\\geq\\log G<span class="math">, the time reduces to </span>\\mathrm{O}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$, which is asymptotically optimal. That is, for sufficient data parallelism, the prover’s runtime is just a constant factor slower than evaluating the circuit gate-by-gate without providing any proof of correctness.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Our work builds on <em>Gir^{++}</em>, which reduces Giraffe’s communication via an optimization due to Chiesa et al. <em>[35]</em>; our description of <span class="math">\\mathrm{Gir}^{++}</span> borrows notation from Wahby et al. <em>[109]</em>. Assume for simplicity that <span class="math">N</span> and <span class="math">G</span> are powers of <span class="math">2</span>, and let <span class="math">b_{N}=\\log_{2}N</span> and <span class="math">b_{G}=\\log_{2}G</span>. Within a layer of <span class="math">\\mathcal{C}</span>, each gate is labeled with a pair <span class="math">(i,j)\\in\\{0,1\\}^{b_{N}}\\times\\{0,1\\}^{b_{G}}</span>. Number the layers of <span class="math">\\mathcal{C}</span> from <span class="math">0</span> to <span class="math">d</span> in reverse execution order, so that <span class="math">0</span> refers to the output layer, and <span class="math">d</span> refers to the input layer. Each layer <span class="math">i</span> is associated with an evaluator function <span class="math">V_{i}\\colon\\{0,1\\}^{b_{N}}\\times\\{0,1\\}^{b_{G}}\\to\\mathbb{F}</span> that maps a gate’s label to the output of that gate when <span class="math">\\mathcal{C}</span> is evaluated on input <span class="math">x</span>. For example, <span class="math">V_{0}(i,j)</span> is the <span class="math">j</span>’th output of the <span class="math">i</span>’th sub-AC, and <span class="math">V_{d}(i,j)</span> is the <span class="math">j</span>th input to the <span class="math">i</span>th sub-AC.</p>

    <p class="text-gray-300">At a high level, the protocol proceeds in iterations, one for each layer of the circuit. At the start of the protocol, the prover <span class="math">\\mathcal{P}</span> sends the claimed outputs <span class="math">y</span> of <span class="math">\\mathcal{C}</span> (i.e., all the claimed evaluations of <span class="math">V_{0}</span>). The first iteration of the protocol reduces the claim about <span class="math">V_{0}</span> to a claim about <span class="math">V_{1}</span>, in the sense that it is safe for the verifier <span class="math">\\mathcal{V}</span> to believe the former claim as long as <span class="math">\\mathcal{V}</span> is convinced of the latter. But <span class="math">\\mathcal{V}</span> cannot directly check the claim about <span class="math">V_{1}</span>, because doing so would require evaluating all of the gates in <span class="math">\\mathcal{C}</span> other than the outputs themselves. Instead, the second iteration reduces the claim about <span class="math">V_{1}</span> to a claim about <span class="math">V_{2}</span>, and so on, until <span class="math">\\mathcal{P}</span> makes a claim about <span class="math">V_{d}</span> (i.e., the inputs to <span class="math">\\mathcal{C}</span>), which <span class="math">\\mathcal{V}</span> checks itself.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">To describe how the reduction from a claim about <span class="math">V_{i}</span> to a claim about <span class="math">V_{i+1}</span> is performed, we first introduce <em>multilinear extensions</em>, <em>the sum-check protocol</em>, and <em>wiring predicates</em>.</p>

    <p class="text-gray-300">Multilinear extensions. An <em>extension</em> of a function <span class="math">f\\colon\\{0,1\\}^{\\ell}\\to\\mathbb{F}</span> is a <span class="math">\\ell</span>-variate polynomial <span class="math">g</span> over <span class="math">\\mathbb{F}</span> such that <span class="math">g(x)=f(x)</span> for all <span class="math">x\\in\\{0,1\\}^{\\ell}</span>. Any such function <span class="math">f</span> has a unique multilinear extension (MLE)—a multilinear polynomial—denoted <span class="math">\\tilde{f}</span>. Given a vector <span class="math">z\\in\\mathbb{F}^{m}</span> with <span class="math">m=2^{\\ell}</span>, we will often view <span class="math">z</span> as a function <span class="math">z\\colon\\{0,1\\}^{\\ell}\\to\\mathbb{F}</span> mapping indices to vector entries, and use <span class="math">\\tilde{z}</span> to denote the MLE of <span class="math">z</span>.</p>

    <p class="text-gray-300">The sum-check protocol. Fix an <span class="math">\\ell</span>-variate polynomial <span class="math">g</span> over <span class="math">\\mathbb{F}</span>, and let <span class="math">\\deg_{i}(g)</span> denote the degree of <span class="math">g</span> in variable <span class="math">i</span>. The sum-check protocol <em>[75]</em> is an interactive proof that allows <span class="math">\\mathcal{P}</span> to convince <span class="math">\\mathcal{V}</span> of a claim about the value of <span class="math">\\sum_{x\\in\\{0,1\\}^{\\ell}}g(x)</span> by reducing it to a claim about the value of <span class="math">g(r)</span>, where <span class="math">r\\in\\mathbb{F}^{\\ell}</span> is a point randomly chosen by <span class="math">\\mathcal{V}</span>. There are <span class="math">\\ell</span> rounds, and <span class="math">\\mathcal{V}</span>’s runtime is <span class="math">\\mathrm{O}(\\sum_{i=1}^{\\ell}\\deg_{i}(g))</span> plus the cost of evaluating <span class="math">g(r)</span>. The mechanics are detailed in Section 4.</p>

    <p class="text-gray-300">Wiring predicates capture the wiring information of the sub-ACs. Define the wiring predicate <span class="math">\\mathrm{add}_{i}\\colon\\{0,1\\}^{3b_{G}}\\to\\{0,1\\}</span>, where <span class="math">\\mathrm{add}_{i}(g,h_{0},h_{1})</span> returns <span class="math">1</span> if (a) within each sub-AC, gate <span class="math">g</span> at layer <span class="math">i-1</span> is an add gate and (b) the left and right inputs of <span class="math">g</span> are, respectively, <span class="math">h_{0}</span> and <span class="math">h_{1}</span> at layer <span class="math">i</span> (and <span class="math">0</span> otherwise). <span class="math">\\mathrm{mult}_{i}</span> is defined analogously for multiplication gates. Define the equality predicate <span class="math">\\mathrm{eq}:\\{0,1\\}^{2b_{N}}\\to\\{0,1\\}</span> as <span class="math">\\mathrm{eq}(a,b)=1</span> iff <span class="math">a=b</span>.</p>

    <p class="text-gray-300">Thaler <em>[102, 103]</em> and Wahby et al. <em>[109]</em> show how to express <span class="math">\\tilde{V}_{i-1}</span> in terms of <span class="math">\\tilde{V}_{i}</span>: for <span class="math">(q^{\\prime},q)\\in\\mathbb{F}^{b_{N}}\\times\\mathbb{F}^{b_{G}}</span>, let <span class="math">P_{q^{\\prime},q,i}\\colon\\mathbb{F}^{b_{N}}\\times\\mathbb{F}^{b_{G}}\\times\\mathbb{F}^{b_{G}}\\to\\mathbb{F}</span> denote the polynomial</p>

    <p class="text-gray-300"><span class="math">P_{q^{\\prime},q,i}(h^{\\prime},h_{L},h_{R})=</span> <span class="math">\\tilde{\\mathrm{eq}}(q^{\\prime},h^{\\prime})\\cdot\\left[\\tilde{\\mathrm{add}}_{i}(q,h_{L},h_{R})\\left(\\tilde{V}_{i}(h^{\\prime},h_{L})+\\tilde{V}_{i}(h^{\\prime},h_{R})\\right)+\\right.</span> <span class="math">\\left.\\tilde{\\mathrm{mult}}_{i}(q,h_{L},h_{R})\\left(\\tilde{V}_{i}(h^{\\prime},h_{L})\\cdot\\tilde{V}_{i}(h^{\\prime},h_{R})\\right)\\right]</span></p>

    <p class="text-gray-300">Then we have</p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i-1}(q^{\\prime},q)=\\sum_{h^{\\prime}\\in\\{0,1\\}^{b_{N}}}\\sum_{h_{L},h_{R}\\in\\{0,1\\}^{b_{G}}}P_{q^{\\prime},q,i}(h^{\\prime},h_{L},h_{R}).</span> (2)</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">Protocol overview</h4>

    <p class="text-gray-300">Step 1. At the start of the protocol, <span class="math">\\mathcal{P}</span> sends the claimed output <span class="math">y</span>, thereby specifying a function <span class="math">V_{y}\\colon\\{0,1\\}^{b_{G}+b_{N}}\\to\\mathbb{F}</span> mapping the label of each output gate to the corresponding entry of <span class="math">y</span>. The verifier wishes to check that <span class="math">V_{y}=V_{0}</span> (i.e., that the claimed outputs equal the correct outputs of <span class="math">\\mathcal{C}</span> on input <span class="math">x</span>); to accomplish this, it would be enough to check that <span class="math">\\tilde{V}_{y}=\\tilde{V}_{0}</span>. In principle, <span class="math">\\mathcal{V}</span> could do that by choosing a random pair <span class="math">(q^{\\prime},q)\\in\\mathbb{F}^{b_{N}}\\times\\mathbb{F}^{b_{G}}</span> and checking that <span class="math">\\tilde{V}_{y}(q^{\\prime},q)=\\tilde{V}_{0}(q^{\\prime},q)</span>; if that check passes, then <span class="math">\\tilde{V}_{y}=\\tilde{V}_{0}</span> with high probability, by the Schwartz-Zippel lemma. On the one hand, <span class="math">\\mathcal{V}</span> can and does compute <span class="math">\\tilde{V}_{y}(q^{\\prime},q)</span>; this takes <span class="math">\\mathrm{O}(NG)</span> time <em>[109, §3.3]</em>. But on the other hand, <span class="math">\\mathcal{V}</span> cannot compute <span class="math">\\tilde{V}_{0}(q^{\\prime},q)</span> directly—this would require <span class="math">\\mathcal{V}</span> to evaluate <span class="math">\\mathcal{C}</span>.</p>

    <p class="text-gray-300">Step 2 (iterated). Instead, <span class="math">\\mathcal{V}</span> outsources evaluation of <span class="math">\\tilde{V}_{0}(q^{\\prime},q)</span> to <span class="math">\\mathcal{P}</span>, via the sum-check protocol; this is motivated by Equation (2). At the end of the sum-check protocol, <span class="math">\\mathcal{V}</span> must evaluate <span class="math">P_{q^{\\prime},q,1}</span> at a random input <span class="math">(r^{\\prime},r_{L},r_{R})</span>, which requires the values <span class="math">\\tilde{V}_{1}(r^{\\prime},r_{L})</span> and <span class="math">\\tilde{V}_{1}(r^{\\prime},r_{R})</span>. <span class="math">\\mathcal{V}</span> does not evaluate these points directly; that would be too costly. Instead, <span class="math">\\mathcal{P}</span> sends <span class="math">v_{0}</span> and <span class="math">v_{1}</span>, which it claims are the required values. <span class="math">\\mathcal{V}</span> uses these to evaluate <span class="math">P_{q^{\\prime},q,1}</span>, then checks <span class="math">v_{0}</span> and <span class="math">v_{1}</span> using a <em>mini-protocol</em>, which we describe shortly. At a high level, the mini-protocol transforms <span class="math">\\mathcal{P}</span>’s claims about <span class="math">v_{0},v_{1}</span> into a claim about <span class="math">\\tilde{V}_{2}</span>. <span class="math">\\mathcal{V}</span> checks this claim with a sum-check and mini-protocol invocation, yielding a claim about <span class="math">\\tilde{V}_{3}</span>. <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> iterate, layer by layer, until <span class="math">\\mathcal{V}</span> has a claim about <span class="math">\\tilde{V}_{d}</span>.</p>

    <p class="text-gray-300">Final step. <span class="math">\\mathcal{V}</span> checks <span class="math">\\mathcal{P}</span>’s final claim about <span class="math">\\tilde{V}_{d}</span> by evaluating <span class="math">\\tilde{V}_{x}</span> (since <span class="math">\\tilde{V}_{d}=\\tilde{V}_{x}</span>); it can do this in <span class="math">\\mathrm{O}(NG)</span> time <em>[109, §3.3]</em>.</p>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">Mini-protocols: reducing from <span class="math">\\tilde{V}_{i}</span> to <span class="math">\\tilde{V}_{i+1}</span></h4>

    <p class="text-gray-300"><span class="math">\\mathrm{Gir}^{++}</span> differs from Giraffe only in that they use different mini-protocols to reduce <span class="math">\\mathcal{P}</span>’s claims at the end of one sum-check invocation (i.e., <span class="math">v_{0}=\\tilde{V}_{i}(r^{\\prime},r_{L})</span> and <span class="math">v_{1}=\\tilde{V}_{i}(r^{\\prime},r_{R})</span>) into the expression that <span class="math">\\mathcal{V}</span> and <span class="math">\\mathcal{P}</span> use for the next sum-check invocation.</p>

    <p class="text-gray-300">Reducing from two points to one point. This approach is used in Giraffe and prior work <em>[37, 54, 102, 107, 108, 109]</em>. <span class="math">\\mathcal{P}</span> sends <span class="math">\\mathcal{V}</span> the restriction of <span class="math">\\tilde{V}_{i}</span> to the unique line <span class="math">H</span> in <span class="math">\\mathbb{F}^{b_{N}+b_{G}}</span> passing through the points <span class="math">(r^{\\prime},r_{L})</span> and <span class="math">(r^{\\prime},r_{R})</span> by specifying the univariate polynomial <span class="math">f_{H}(t)=\\tilde{V}_{i}(r^{\\prime},(1-t)\\cdot r_{L}+t\\cdot r_{R})</span>, which has degree <span class="math">b_{G}</span>. <span class="math">\\mathcal{V}</span> should believe this claim as long as <span class="math">f_{H}(0)=v_{0}</span>, <span class="math">f_{H}(1)=v_{1}</span>, and <span class="math">f_{H}(\\upsilon)=\\tilde{V}_{i}(r^{\\prime},r_{\\upsilon})</span>, where <span class="math">r_{\\upsilon}=(1-\\upsilon)\\cdot r_{L}+\\upsilon\\cdot r_{R}</span> and <span class="math">\\upsilon</span> is chosen by <span class="math">\\mathcal{V}</span>. By Equation (2), <span class="math">\\mathcal{V}</span> can check this latter equality by engaging <span class="math">\\mathcal{P}</span> in a sum-check protocol over <span class="math">P_{r^{\\prime},r_{\\upsilon},i+1}</span>.</p>

    <p class="text-gray-300">Alternative: Random linear combination. Each invocation of the prior mini-protocol requires <span class="math">\\mathcal{P}</span> to send <span class="math">b_{G}+1</span> field elements specifying <span class="math">f_{H}</span>. The following technique, due to Chiesa et al. <em>[35]</em>, eliminates this requirement. Instead, <span class="math">\\mathcal{V}</span> checks <span class="math">v_{0}</span> and <span class="math">v_{1}</span> by checking a random linear combination, via a sum-check invocation over a polynomial we define below.</p>

    <p class="text-gray-300">In more detail, <span class="math">\\mathcal{V}</span> samples two field elements <span class="math">\\mu_{0}</span> and <span class="math">\\mu_{1}</span>, and sends them to <span class="math">\\mathcal{P}</span>. Mechanically, <span class="math">\\mathcal{V}</span> next checks that</p>

    <p class="text-gray-300"><span class="math">\\mu_{0}\\cdot\\tilde{V}_{i}(r^{\\prime},r_{L})+\\mu_{1}\\cdot\\tilde{V}_{i}(r^{\\prime},r_{R})=\\mu_{0}\\cdot v_{0}+\\mu_{1}\\cdot v_{1}</span> (3)</p>

    <p class="text-gray-300">since, by the Schwartz-Zippel lemma, this implies that <span class="math">v_{0}=\\tilde{V}_{i}(r^{\\prime},r_{L})</span> and <span class="math">v_{1}=\\tilde{V}_{i}(r^{\\prime},r_{R})</span> with high probability (formalized in Thm. 1, below). <span class="math">\\mathcal{V}</span> checks Equation (3) by exploiting the fact that its LHS can be written as</p>

    <p class="text-gray-300"><span class="math">\\mu_{0}\\cdot\\tilde{V}_{i}(q^{\\prime},q_{L})+\\mu_{1}\\cdot\\tilde{V}_{i}(q^{\\prime},q_{R})</span> <span class="math">=\\sum_{h_{L},h_{R}\\in\\{0,1\\}^{b_{G}}}\\sum_{h^{\\prime}\\in\\{0,1\\}^{b_{N}}}\\left[\\mu_{0}\\cdot P_{q^{\\prime},q_{L},i+1}(h^{\\prime},h_{L},h_{R})+\\right.</span> <span class="math">\\left.\\mu_{1}\\cdot P_{q^{\\prime},q_{R},i+1}(h^{\\prime},h_{L},h_{R})\\right]</span> <span class="math">=\\sum_{h_{L},h_{R}\\in\\{0,1\\}^{b_{G}}}\\sum_{h^{\\prime}\\in\\{0,1\\}^{b_{N}}}Q_{q^{\\prime},q_{L},q_{R},\\mu_{0},\\mu_{1},i+1}(h^{\\prime},h_{L},h_{R})</span></p>

    <p class="text-gray-300">where <span class="math">Q_{q^{\\prime},q_{L},q_{R},\\mu_{0},\\mu_{1},i}\\colon\\mathbb{F}^{b_{N}}\\times\\mathbb{F}^{b_{G}}\\times\\mathbb{F}^{b_{G}}\\to\\mathbb{F}</span> is given by:</p>

    <p class="text-gray-300"><span class="math">Q_{q^{\\prime},q_{L},q_{R},\\mu_{0},\\mu_{1},i}(h^{\\prime},h_{L},h_{R})\\triangleq\\tilde{\\mathrm{eq}}(q^{\\prime},h^{\\prime})\\cdot</span> <span class="math">\\left[\\ \\left(\\mu_{0}\\cdot\\tilde{\\mathrm{add}}_{i}(q_{L},h_{L},h_{R})+\\mu_{1}\\cdot\\tilde{\\mathrm{add}}_{i}(q_{R},h_{L},h_{R})\\right)\\cdot\\right.</span> <span class="math">\\left.\\left(\\tilde{V}_{i}(h^{\\prime},h_{L})+\\tilde{V}_{i}(h^{\\prime},h_{R})\\right)\\right.</span> <span class="math">+\\left(\\mu_{0}\\cdot\\tilde{\\mathrm{mult}}_{i}(q_{L},h_{L},h_{R})+\\mu_{1}\\cdot\\tilde{\\mathrm{mult}}_{i}(q_{R},h_{L},h_{R})\\right)\\cdot</span> <span class="math">\\left.\\left(\\tilde{V}_{i}(h^{\\prime},h_{L})\\cdot\\tilde{V}_{i}(h^{\\prime},h_{R})\\right)\\ \\right]</span></p>

    <p class="text-gray-300">This means that <span class="math">\\mathcal{V}</span> can check that Equation (3) holds by engaging <span class="math">\\mathcal{P}</span> in a sum-check protocol over <span class="math">Q_{r^{\\prime},r_{L},r_{R},\\mu_{0},\\mu_{1},i+1}</span>.</p>

    <p class="text-gray-300">Giraffe vs. Gir++ Gir^{++} uses the Alternative above. This reduces communication cost in <span class="math">\\text{Gir}^{++}</span> compared to Giraffe by a small factor that depends on the amount of data parallelism. We are motivated to reduce communication because communication will translate into proof size and more cryptographic cost (§4).</p>

    <p class="text-gray-300">As an exception, <span class="math">\\text{Gir}^{++}</span> uses the “reducing from two points to one point” technique after the final sum-check (i.e., the one over <span class="math">Q_{\\ldots,d-1}</span>); this is to avoid increasing <span class="math">\\mathcal{V}</span>’s computational costs compared to Giraffe. Recall that in the final step of <span class="math">\\text{Gir}^{++}</span>, <span class="math">\\mathcal{V}</span> checks <span class="math">\\mathcal{P}</span>’s claim about <span class="math">\\tilde{V}_{d}</span> by evaluating <span class="math">\\tilde{V}_{y}</span> (which is equal to <span class="math">\\tilde{V}_{d}</span>). Thus, to check the LHS of Equation (3), <span class="math">\\mathcal{V}</span> would require two evaluations of <span class="math">\\tilde{V}_{x}</span>; the “reducing from two points to one point” technique requires only one. Since evaluating <span class="math">\\tilde{V}_{x}</span> is typically a bottleneck for the verifier <em>[109, §3.3]</em>, eliminating the second evaluation is worthwhile even though it slightly increases the size of <span class="math">\\mathcal{P}</span>’s final message (and thus the proof size; see §4).</p>

    <p class="text-gray-300">We give pseudocode for <span class="math">\\text{Gir}^{++}</span> in Appendix E. <span class="math">\\text{Gir}^{++}</span>’s efficiency and security are formalized in the following theorem, which can be proved via a standard analysis <em>[54]</em>.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Theorem 1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The interactive proof <span class="math">\\text{Gir}^{++}</span> satisfies the following properties when applied to a layered arithmetic circuit <span class="math">\\mathcal{C}</span> of fan-in two, consisting of <span class="math">N</span> identical sub-computations, each of depth <span class="math">d</span>, with all layers of each sub-computation having width at most <span class="math">G</span>. It has perfect completeness, and soundness error at most $((1+2\\log G+3\\log N)\\cdot d+\\log G)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. After a pre-processing phase taking time </span>\\text{O}(dG)<span class="math">, the verifier runs in time </span>\\text{O}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+d\\log NG)<span class="math">, and the prover runs in time </span>\\text{O}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+d\\cdot G\\cdot\\log G)$. If the sub-AC has a regular wiring pattern as defined in <em>[37]</em>, then the pre-processing phase is unnecessary.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-22" class="text-2xl font-bold">4 Compiling <span class="math">\\text{Gir}^{++}</span> into a ZK argument</h2>

    <p class="text-gray-300">In this section, we describe a straightforward application of “commit-and-prove” techniques <em>[8, 40]</em> (§1) to <span class="math">\\text{Gir}^{++}</span> (§3.2). The result is a public coin, perfect ZK argument “of knowledge” for AC satisfiability (the knowledge property is formalized via witness-extended emulation; §3.1). In Sections 5 and 6, we develop substantial efficiency improvements; in Section 7, we apply the Fiat-Shamir heuristic <em>[45]</em> to make it non-interactive.</p>

    <p class="text-gray-300">Building blocks. This section uses abstract commitments having a homomorphism property (§3.1). We also make black-box use of three sub-protocols, which operate on commitments:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>proof-of-opening(<span class="math">C</span>) convinces <span class="math">\\mathcal{V}</span> that <span class="math">\\mathcal{P}</span> can open <span class="math">C</span>.</li>

      <li>proof-of-equality(<span class="math">C_{0},C_{1}</span>) convinces <span class="math">\\mathcal{V}</span> that <span class="math">C_{0}</span> and <span class="math">C_{1}</span> commit to the same value, and that <span class="math">\\mathcal{P}</span> can open both.</li>

      <li>proof-of-product(<span class="math">C_{0},C_{1},C_{2}</span>) convinces <span class="math">\\mathcal{V}</span> that <span class="math">C_{2}</span> commits to the product of the values committed in <span class="math">C_{0}</span> and <span class="math">C_{1}</span>, and that <span class="math">\\mathcal{P}</span> can open all three.</li>

    </ul>

    <p class="text-gray-300">In Appendix A, we give concrete definitions of the above protocols in terms of Pedersen commitments <em>[85]</em>.</p>

    <p class="text-gray-300">Protocol overview. This protocol differs from <span class="math">\\text{Gir}^{++}</span> in three ways. First, it adds an initial step in which <span class="math">\\mathcal{P}</span> commits to <span class="math">w</span> such that <span class="math">\\mathcal{C}(x,w)=y</span>. Second, <span class="math">\\mathcal{P}</span> replaces all of its messages in <span class="math">\\text{Gir}^{++}</span> with commitments to those messages. Third, <span class="math">\\mathcal{P}</span> convinces <span class="math">\\mathcal{V}</span> that its committed values pass all of <span class="math">\\mathcal{V}</span>’s checks in <span class="math">\\text{Gir}^{++}</span> using the homomorphism property of the commitments and the above sub-protocols. The steps below correspond to the steps of <span class="math">\\text{Gir}^{++}</span> (§3.2); we describe only how the protocols differ.</p>

    <p class="text-gray-300">Step 0. (This is a new step.) <span class="math">\\mathcal{P}</span> sends commitments to each element of <span class="math">w\\in\\mathbb{P}^{\\ell}</span>. <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> execute proof-of-opening for each.</p>

    <p class="text-gray-300">Step 1. As in <span class="math">\\text{Gir}^{++}</span>, <span class="math">\\mathcal{V}</span> computes <span class="math">\\tilde{V}_{y}(q^{\\prime},q)</span>. Afterwards, <span class="math">\\mathcal{V}</span> computes <span class="math">C_{0}=\\mathsf{Com}(\\tilde{V}_{y}(q^{\\prime},q);0)</span>.</p>

    <p class="text-gray-300">Step 2. As in <span class="math">\\text{Gir}^{++}</span>, this step comprises one sum-check and one mini-protocol per layer of <span class="math">\\mathcal{C}</span>. We now review the sum-check protocol, and then describe how <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> execute the sum-check and mini-protocols “underneath the commitments.”</p>

    <p class="text-gray-300">Review of the sum-check protocol. We begin by describing the first layer sum-check protocol in <span class="math">\\text{Gir}^{++}</span> (others are similar), which reduces <span class="math">\\tilde{V}_{y}(q^{\\prime},q)</span> to a claim about <span class="math">\\tilde{V}_{1}(\\cdot)</span>. In the first round of the sum-check protocol, <span class="math">\\mathcal{P}</span> sends a univariate polynomial <span class="math">s_{1}(\\cdot)</span> of degree <span class="math">3</span>. <span class="math">\\mathcal{V}</span> checks that <span class="math">s_{1}(0)+s_{1}(1)=\\tilde{V}_{y}(q^{\\prime},q)</span>, and then sends a random field element <span class="math">r_{1}</span> to <span class="math">\\mathcal{P}</span>. In general, in round <span class="math">j</span> of the sum-check protocol, <span class="math">\\mathcal{P}</span> sends a univariate polynomial <span class="math">s_{j}</span> (which is degree <span class="math">3</span> in the first <span class="math">b_{N}</span> rounds and degree <span class="math">2</span> in the remaining rounds <em>[102, 109]</em>). <span class="math">\\mathcal{V}</span> checks that <span class="math">s_{j}(0)+s_{j}(1)=s_{j-1}(r_{j-1})</span>, then sends a random field element <span class="math">r_{j}</span> to <span class="math">\\mathcal{P}</span>.</p>

    <p class="text-gray-300">We write the vector of all <span class="math">r_{j}</span>’s chosen by <span class="math">\\mathcal{V}</span> in the <span class="math">j_{\\text{last}}=b_{N}+2b_{G}</span> rounds of the sum-check protocol as <span class="math">(r_{1},\\ldots,r_{j_{\\text{last}}})\\in\\mathbb{P}^{b_{N}+2b_{G}}</span>; let <span class="math">r^{\\prime}</span> denote the first <span class="math">b_{N}</span> entries of this vector, <span class="math">r_{L}</span> denote the next <span class="math">b_{G}</span> entries, and <span class="math">r_{R}</span> denote the final <span class="math">b_{G}</span> entries.</p>

    <p class="text-gray-300">In the last round, <span class="math">\\mathcal{P}</span> sends <span class="math">v_{0}</span> and <span class="math">v_{1}</span> (which it claims are equal to <span class="math">\\tilde{V}_{1}(r^{\\prime},r_{L})</span> and <span class="math">\\tilde{V}_{1}(r^{\\prime},r_{R})</span>; §3.2). <span class="math">\\mathcal{V}</span> first checks that</p>

    <p class="text-gray-300"><span class="math">s_{j_{\\text{last}}}(r_{j_{\\text{last}}})=\\tilde{\\operatorname{eq}}(q^{\\prime},r^{\\prime})\\cdot\\left[\\operatorname{add}_{1}(q,r_{L},r_{R})\\cdot(v_{0}+v_{1})+\\right.</span> <span class="math">\\left.\\max_{1}(q,r_{L},r_{R})\\cdot v_{0}\\cdot v_{1}\\right]</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}</span> then checks <span class="math">\\mathcal{P}</span>’s claims about <span class="math">v_{0}</span> and <span class="math">v_{1}</span> by invoking a mini-protocol (§3.2) and engaging <span class="math">\\mathcal{P}</span> in another sum-check at layer <span class="math">2</span>.</p>

    <p class="text-gray-300">ZK sum-check protocol. In round <span class="math">j</span> of the sum-check, <span class="math">\\mathcal{P}</span> commits to <span class="math">s_{j}(t)=c_{0,j}+c_{1,j}t+c_{2,j}t^{2}+c_{3,j}t^{3}</span>, via <span class="math">\\delta_{c_{0,j}}\\leftarrow\\mathsf{Com}(c_{0,j})</span>, <span class="math">\\delta_{c_{1,j}}\\leftarrow\\mathsf{Com}(c_{1,j})</span>, <span class="math">\\delta_{c_{2,j}}\\leftarrow\\mathsf{Com}(c_{2,j})</span>, and <span class="math">\\delta_{c_{3,j}}\\leftarrow\\mathsf{Com}(c_{3,j})</span>, and <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> execute proof-of-opening for each one. Now <span class="math">\\mathcal{P}</span> convinces <span class="math">\\mathcal{V}</span> that <span class="math">s_{j}(0)+s_{j}(1)=s_{j-1}(r_{j-1})</span>. Notice that if <span class="math">\\mathcal{V}</span> holds commitments <span class="math">\\mathsf{Com}(s_{j-1}(r_{j-1}))</span> and <span class="math">\\mathsf{Com}(s_{j}(0)+s_{j}(1))</span>, <span class="math">\\mathcal{P}</span> can use proof-of-equality to convince <span class="math">\\mathcal{V}</span> that the above equation holds. Further, <span class="math">\\mathcal{V}</span> can use the homomorphism property to compute the required commitments: for <span class="math">s_{j}(0)+s_{j}(1)=2c_{0,j}+c_{1,j}+c_{2,j}+c_{3,j}</span>, <span class="math">\\mathcal{V}</span> computes <span class="math">\\delta_{c_{0,j}}^{2}\\odot\\delta_{c_{1,j}}\\odot\\delta_{c_{2,j}}\\odot\\delta_{c_{3,j}}</span>. Similarly, for <span class="math">s_{j-1}(r_{j-1})</span> <span class="math">\\mathcal{V}</span> computes <span class="math">\\delta_{c_{0,j}}\\odot\\delta_{c_{1,j}}^{r_{j}}\\odot\\delta_{c_{2,j}}^{r_{j}^{2}}\\odot\\delta_{c_{3,j}}^{r_{j}^{2}}</span>.</p>

    <p class="text-gray-300">The first sum-check round (<span class="math">j=1</span>) is an exception to the above: rather than a commitment to <span class="math">s_{0}</span>, <span class="math">\\mathcal{V}</span> holds a commitment to a value that purportedly equals <span class="math">s_{1}(0)+s_{1}(1)</span>. For the sum-check invocation at layer <span class="math">1</span>, this value is <span class="math">C_{0}</span>, which <span class="math">\\mathcal{V}</span> computed in Step 1. For subsequent layers, the value is the result of the preceding mini-protocol invocation, which we discuss below.</p>

    <p class="text-gray-300">In the final round <span class="math">j_{\\text{last}}</span>, <span class="math">\\mathcal{V}</span> computes a commitment <span class="math">W</span> to <span class="math">s_{j_{last}}(r_{j_{\\text{last}}})</span> as described above. <span class="math">\\mathcal{P}</span> sends commitments <span class="math">X</span>, <span class="math">Y</span>, and <span class="math">Z</span> to <span class="math">v_{0}</span>, <span class="math">v_{1}</span>, and <span class="math">v_{0}\\cdot v_{1}</span>, respectively, and</p>

    <p class="text-gray-300">uses proof-of-product to convince <span class="math">\\mathcal{V}</span> that the committed values satisfy this product relation. Finally, <span class="math">\\mathcal{V}</span> computes <span class="math">\\Omega\\longleftarrow(X\\odot Y)^{\\bar{\\mathrm{eq}}(q^{\\prime},r^{\\prime})\\cdot\\mathrm{add}_{1}(q,r_{1},r_{2})}\\odot Z^{\\bar{\\mathrm{eq}}(q^{\\prime},r^{\\prime})\\cdot\\mathrm{midt}_{1}(q,r_{1},r_{2})}</span> and <span class="math">\\mathcal{P}</span> uses proof-of-equality to convince <span class="math">\\mathcal{V}</span> that <span class="math">W</span> and <span class="math">\\Omega</span> commit to the same value.</p>

    <p class="text-gray-300">ZK mini-protocols. For random-linear-combination, <span class="math">\\mathcal{V}</span> computes <span class="math">\\mathsf{Com}(\\mu_{0}v_{0}+\\mu_{1}v_{1})=X^{\\mu_{0}}\\odot Y^{\\mu_{1}}</span>; this is the purported <span class="math">\\mathsf{Com}(s_{1}(0)+s_{1}(1))</span> for the next sum-check invocation.</p>

    <p class="text-gray-300">To execute reducing-from-two-points-to-one-point, <span class="math">\\mathcal{P}</span> commits to the coefficients of <span class="math">f_{H}</span> and invokes proof-of-opening for each; <span class="math">\\mathcal{V}</span> computes commitments to <span class="math">f_{H}(0)</span> and <span class="math">f_{H}(1)</span>, and <span class="math">\\mathcal{P}</span> uses proof-of-equality to show that these commit to the same values as <span class="math">X</span> and <span class="math">Y</span>; and <span class="math">\\mathcal{V}</span> samples <span class="math">\\upsilon</span> and computes a commitment to <span class="math">f_{H}(\\upsilon)</span>, which it uses in the final step.</p>

    <p class="text-gray-300">Final step. <span class="math">\\mathcal{P}</span> now convinces <span class="math">\\mathcal{V}</span> that <span class="math">\\mathsf{Com}(f_{H}(\\upsilon))</span>, the result of the final mini-protocol invocation (which is a commitment to <span class="math">\\tilde{V}_{d}(r^{\\prime},r_{\\upsilon})</span>; §3.2), is consistent with <span class="math">x</span> and <span class="math">w</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We let <span class="math">m=(x,w)</span> denote the concatenation of the input <span class="math">x</span> and the witness <span class="math">w</span>; assume for simplicity that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{\\ell}<span class="math">; interpret </span>x<span class="math">, </span>w<span class="math">, and </span>m<span class="math"> as functions (§3.2, “Multilinear extensions”); and let </span>(r_{0},\\ldots,r_{\\ell})=(r^{\\prime},r_{\\upsilon})<span class="math">. Then by the definitions of </span>\\tilde{m}<span class="math">, </span>\\tilde{x}<span class="math">, and </span>\\tilde{w}$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\tilde{m}(r_{0},\\ldots,r_{\\ell})=(1-r_{0})\\cdot\\tilde{x}(r_{1},\\ldots,r_{\\ell})+r_{0}\\cdot\\tilde{w}(r_{1},\\ldots,r_{\\ell}).</span></p>

    <p class="text-gray-300">By analogy to <span class="math">\\mathrm{Gir}^{++}</span>’s final step, <span class="math">\\mathcal{V}</span>’s task is to check that <span class="math">\\tilde{V}_{d}(r^{\\prime},r_{\\upsilon})</span> is equal to <span class="math">\\tilde{m}(r_{0},\\ldots,r_{\\ell})</span>. <span class="math">\\mathcal{V}</span> does this by first computing <span class="math">\\mathsf{Com}(\\tilde{m}(r_{0},\\ldots,r_{\\ell}))</span> using the commitments to <span class="math">w</span> that <span class="math">\\mathcal{P}</span> sent in Step 0 (above), and then engaging <span class="math">\\mathcal{P}</span> in proof-of-equality on <span class="math">\\mathsf{Com}(f_{H}(\\upsilon))</span> and <span class="math">\\mathsf{Com}(\\tilde{m}(r_{0},\\ldots,r_{\\ell}))</span>.</p>

    <p class="text-gray-300">To compute <span class="math">\\mathsf{Com}(\\tilde{m}(\\cdot))</span>, <span class="math">\\mathcal{V}</span> exploits the following expression <em>[37]</em> for the multilinear extension of <span class="math">w\\colon\\{0,1\\}^{\\ell}\\to\\mathbb{F}</span>:</p>

    <p class="text-gray-300"><span class="math">\\tilde{w}(r_{1},\\ldots,r_{\\ell})</span> <span class="math">=\\sum_{b\\in\\{0,1\\}^{\\ell}}w(b)\\cdot\\prod_{k\\in\\{1,\\ldots,\\ell\\}}\\chi_{b_{k}}(r_{k})</span> <span class="math">=\\sum_{b\\in\\{0,1\\}^{\\ell}}w(b)\\cdot\\chi_{b}</span> (4)</p>

    <p class="text-gray-300">where <span class="math">\\chi_{b_{k}}(r_{k})=r_{k}b_{k}+(1-r_{k})(1-b_{k})</span>, <span class="math">\\chi_{b}=\\prod_{k}\\chi_{b_{k}}(r_{k})</span>, and <span class="math">b_{k}</span> is the (1-indexed) <span class="math">k^{\\mathrm{th}}</span> bit of <span class="math">b</span>. In more detail, <span class="math">\\mathcal{V}</span> first evaluates each <span class="math">\\chi_{b}</span> in linear time <em>[107]</em>, and then computes</p>

    <p class="text-gray-300"><span class="math">F=\\bigodot_{b\\in\\{0,1\\}^{\\ell}}\\mathsf{Com}(w(b))^{r_{0}\\cdot\\chi_{b}(r_{1},\\ldots,r_{\\ell})}</span></p>

    <p class="text-gray-300">which is <span class="math">\\mathsf{Com}(r_{0}\\cdot\\tilde{w}(r_{1},\\ldots,r_{\\ell}))</span>. It then computes, in the clear, <span class="math">F^{\\prime}=(1-r_{0})\\cdot\\tilde{x}(r_{1},\\ldots,r_{\\ell})</span>. Finally, <span class="math">\\mathcal{V}</span> computes <span class="math">\\mathsf{Com}(\\tilde{m}(r_{0},\\ldots,r_{\\ell}))=F\\odot\\mathsf{Com}(F^{\\prime};0)</span>. Invoking proof-of-equality as described above completes the protocol.</p>

    <p class="text-gray-300">The following theorem formalizes the efficiency of the argument of this section. We leave a formal statement of security properties to the final protocol (§7).</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Theorem 2.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathcal{C}(\\cdot,\\cdot)</span> be a layered arithmetic circuit of fan-in two, consisting of <span class="math">N</span> identical sub-computations, each of depth <span class="math">d</span>, with all layers of each sub-computation having width at most <span class="math">G</span>. Assuming the existence of computationally binding, perfectly hiding homomorphic commitment schemes that support proof-of-opening, proof-of-equality, and proof-of-product (Appx. A) with running times upper-bounded by <span class="math">\\kappa</span>, there exists a PZK argument for the NP relation “<span class="math">\\exists w</span> such that <span class="math">\\mathcal{C}(x,w)=y</span>.” The protocol requires <span class="math">d\\log(G)</span> rounds of communication, and has communication complexity $\\Theta(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+d\\log G)\\cdot\\lambda)<span class="math">, where </span>\\lambda<span class="math"> is a security parameter. Given a </span>w<span class="math"> such that </span>\\mathcal{C}(x,w)=y<span class="math">, the prover runs in time </span>\\Theta\\left(dNG+G\\log G+(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+d\\log G)\\cdot\\kappa\\right)<span class="math">. Verifier runtime is </span>\\Theta\\left(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+dG+(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+d\\log(NG))\\cdot\\kappa\\right)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The above follows from the more general Theorem 3.1 of <em>[8]</em>.</p>

    <h2 id="sec-24" class="text-2xl font-bold">5 Reducing the cost of sum-checks</h2>

    <p class="text-gray-300">In the PZK argument from Section 4, the prover sends a separate commitment for every message element of <span class="math">\\mathrm{Gir}^{++}</span> (§3.2), and then independently proves knowledge of how to open each commitment. This leads to long proofs and many expensive cryptographic operations for the verifier.</p>

    <p class="text-gray-300">In this section, we explain how to reduce this communication and the number of cryptographic operations for the verifier by exploiting <em>multi-commitment</em> schemes, in which a commitment to a vector of elements has the same size as a commitment to a single element. The Pedersen commitment <em>[85]</em> (Appx. A) supports multi-commitments.</p>

    <p class="text-gray-300">Dot-product proof protocol. Our starting point is an existing protocol for multi-commitments, which we call proof-of-dot-prod. With this protocol, a prover that knows the openings of two commitments, one to a vector <span class="math">\\vec{x}=(x_{1},\\ldots,x_{n})\\in\\mathbb{F}^{n}</span> and one to a scalar <span class="math">y\\in\\mathbb{F}</span>, can prove in zero-knowledge that <span class="math">y=\\langle\\vec{a},\\vec{x}\\rangle</span> for a public <span class="math">\\vec{a}\\in\\mathbb{F}^{n}</span>. The protocol is defined in Appendix A.2.</p>

    <p class="text-gray-300">Squashing <span class="math">\\mathcal{V}</span>’s checks. To exploit proof-of-dot-prod, we first recall from Section 4 that in each round <span class="math">j</span> of each sum-check invocation in <span class="math">\\mathrm{Gir}^{++}</span>, <span class="math">\\mathcal{P}</span> sends commitments to <span class="math">c_{0,j}</span>, <span class="math">c_{1,j}</span>, <span class="math">c_{2,j}</span>, and (only in the first <span class="math">b_{N}</span> rounds) <span class="math">c_{3,j}</span>. Next, <span class="math">\\mathcal{P}</span> proves to <span class="math">\\mathcal{V}</span> that <span class="math">2c_{0,j}+c_{1,j}+c_{2,j}+c_{3,j}=s_{j-1}(r_{j-1})</span> (i.e., that <span class="math">s_{j}(0)+s_{j}(1)=s_{j-1}(r_{j-1})</span>). Finally, <span class="math">\\mathcal{V}</span> computes a commitment to <span class="math">s_{j}(r_{j})=c_{0,j}+c_{1,j}r_{j}+c_{2,j}r_{j}^{2}+c_{3,j}r_{j}^{3}</span> for the next round.</p>

    <p class="text-gray-300">Combining the above equations yields <span class="math">c_{3,j+1}+c_{2,j+1}+c_{1,j+1}+2c_{0,j+1}-(c_{3,j}r_{j}^{3}+c_{2,j}r_{j}^{2}+c_{1,j}r_{j}+c_{0,j})=0</span>. <span class="math">\\mathcal{V}</span>’s final check can likewise be expressed as a linear equation in terms of <span class="math">v_{0},v_{1},c_{2,n},c_{1,n},c_{0,n}</span>, and wiring predicate evaluations (§3.2) (<span class="math">n=b_{N}+2b_{G}</span>). We can thus write <span class="math">\\mathcal{V}</span>’s checks during the rounds of the sum-check protocol as the matrix-vector product</p>

    <p class="text-gray-300">\\[ \\left[\\begin{array}[]{c}M_{1}\\\\ \\vdots\\\\ M_{b_{N}+2b_{G}+1}\\end{array}\\right]\\cdot\\vec{\\pi}=\\left[\\begin{array}[]{c}s_{0}\\\\ 0\\\\ \\vdots\\end{array}\\right] \\] (5)</p>

    <p class="text-gray-300">Each <span class="math">M_{k}</span> is a row in <span class="math">\\mathbb{F}^{4b_{N}+6b_{G}+3}</span> encoding one of <span class="math">\\mathcal{V}</span>’s checks and <span class="math">\\vec{\\pi}</span> is a column in <span class="math">\\mathbb{F}^{4b_{N}+6b_{G}+3}</span> comprising <span class="math">\\mathcal{P}</span>’s messages. (<span class="math">4b_{N}+6b_{G}+3</span> accounts for <span class="math">b_{N}</span> rounds with cubic <span class="math">s_{j}</span>, <span class="math">2b_{G}</span> rounds with quadratic <span class="math">s_{j}</span>, and the final values <span class="math">v_{0}</span>, <span class="math">v_{1}</span>, and <span class="math">v_{0}v_{1}</span>; §4.)</p>

    <p class="text-gray-300">Now we can combine all of the linear equality checks encoded in Equation (5) into a single check, namely, by multiplying each row <span class="math">k</span> by a random coefficient <span class="math">\\rho_{k}</span> and summing the rows.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Lemma 3.</h6>

    <p class="text-gray-300">For any <span class="math">\\vec{\\pi}\\in\\mathbb{F}^{\\ell}</span>, and any matrix <span class="math">M\\in\\mathbb{F}^{n+1\\times\\ell}</span> with rows <span class="math">M_{1},\\ldots,M_{n+1}</span> for which Eq. (5) does not hold, then</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{\\rho}\\left[\\left\\langle\\left(\\sum\\rho_{k}\\cdot M_{k}\\right),\\vec{\\pi}\\right\\rangle=\\rho_{1}\\cdot s_{0}\\right]\\leq 1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. Observe that  <span class="math">\\langle (\\sum \\rho_k \\cdot M_k), \\vec{\\pi} \\rangle</span>  is a polynomial in  <span class="math">\\rho_1, \\ldots, \\rho_{n+1}</span>  of total degree 1 (i.e., a linear function in  <span class="math">\\rho_1, \\ldots, \\rho_{n+1}</span> ). Call this linear polynomial  <span class="math">\\phi</span> . The coefficients of  <span class="math">\\phi</span>  are the entries of  <span class="math">M \\cdot \\vec{\\pi}</span> . Similarly,  <span class="math">\\rho_1 \\cdot s_0</span>  is a linear polynomial  <span class="math">\\psi</span>  in  <span class="math">\\rho_1, \\ldots, \\rho_{n+1}</span> , whose coefficients are the entries of  <span class="math">[s_0, 0, \\ldots, 0]</span> . Note that if Equation (5) does not hold, then  <span class="math">\\phi</span>  and  <span class="math">\\psi</span>  are distinct polynomials, each of total degree 1. The lemma now follows from the Schwartz-Zippel lemma.</p>

    <p class="text-gray-300">Putting the pieces together. Lemma 3 implies that, once  <span class="math">\\mathcal{P}</span>  has committed to  <span class="math">\\vec{\\pi}</span> , it can use proof-of-dot-proof to convince  <span class="math">\\mathcal{V}</span>  of the sum-check result in one shot. For soundness in  <span class="math">\\mathrm{Gir}^{++}</span> , however,  <span class="math">\\mathcal{P}</span>  must commit to  <span class="math">c_{3,j}, c_{2,j}, c_{1,j}, c_{0,j}</span>  before the Verifier sends  <span class="math">r_j</span> . This means that  <span class="math">\\mathcal{P}</span>  cannot send  <span class="math">\\mathrm{Com}(\\vec{\\pi})</span>  all at once.</p>

    <p class="text-gray-300">Instead, we observe that  <span class="math">\\mathcal{P}</span>  can send the commitment to  <span class="math">\\vec{\\pi}</span>  incrementally, using one group element per round of the sum-check. That is, in each round of the sum-check protocol,  <span class="math">\\mathcal{P}</span>  commits to a vector encoding the coefficients of that round's polynomial, and  <span class="math">\\mathcal{V}</span>  responds with its random coin  <span class="math">r_j</span> . After  <span class="math">\\mathcal{P}</span>  has committed to all of its messages for the sum-check,  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  engage in the protocol of Figure 1, which encodes  <span class="math">\\mathcal{V}</span> 's checks for all rounds of the sum-check protocol at once. This protocol replaces  <span class="math">\\mathcal{V}</span> 's checks in Step 2 of the protocol of Section 4.</p>

    <p class="text-gray-300">Lemma 4. The protocol of Figure 1 is a complete, honest-verifier perfect ZK argument, with generalized special soundness under the discrete log assumption, that its inputs constitute an accepting sum-check relation: on input a commitment  <span class="math">C_0</span> , commitments  <span class="math">\\{\\alpha_j\\}</span>  to polynomials  <span class="math">\\{s_j\\}</span>  in a sum-check invocation, rows  <span class="math">\\{M_k\\}</span>  of the matrix of Equation (5), and commitments  <span class="math">X = \\operatorname{Com}(v_0)</span> ,  <span class="math">Y = \\operatorname{Com}(v_1)</span> , and  <span class="math">Z</span> , where  <span class="math">\\{r_j\\}</span>  are  <span class="math">\\mathcal{V}</span> 's coins from the sum-check and  <span class="math">n = b_N + 2b_G</span> , the protocol proves that  <span class="math">C_0 = \\operatorname{Com}(s_1(0) + s_1(1))</span> ;  <span class="math">s_j(0) + s_j(1) = s_{j-1}(r_{j-1})</span> ,  <span class="math">j \\in \\{2, \\ldots, n\\}</span> ; and  <span class="math">s_n(r_n) = Q_{\\ldots,i}</span>  evaluated with  <span class="math">v_0, v_1</span>  (per §3.2).</p>

    <p class="text-gray-300">Lemma 4 is proved in Appendix A.4. Relative to Step 2 of Section 4, the protocol of Figure 1 reduces sum-check communication by  <span class="math">\\approx 3\\times</span> . It also reduces  <span class="math">\\mathcal{P}</span> 's and  <span class="math">\\mathcal{V}</span> 's cryptographic costs by  <span class="math">\\approx 4\\times</span>  and  <span class="math">\\approx 5\\times</span> , respectively.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the protocol of Section 4,  <span class="math">\\mathcal{P}</span>  sends a separate commitment to each element  <span class="math">w_{1},\\ldots ,w_{\\ell}</span>  of the witness  <span class="math">w</span>  (§4, "Step 0"). This means that handling a circuit relation with  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  witness elements requires a proof whose size is at least proportional to  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . In this section, we describe a new commitment scheme for multilinear polynomials that reduces witness commitment size (and thus proof size) to sub-linear in  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> ; it also reduces  </span>\\mathcal{V}<span class="math"> &#x27;s computation cost to sub-linear in  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  (§6.1). To begin, we require each sub-AC to have separate input and witness elements; we relax this restriction by introducing a redistribution layer that allows input and witness sharing among sub-ACs (§6.2).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In Section 4,  <span class="math">\\mathcal{V}</span> 's final step checks that  <span class="math">\\mathcal{P}</span> 's commitments to  <span class="math">w</span>  are consistent with its other messages by evaluating  <span class="math">\\tilde{w}</span>  (the MLE of  <span class="math">w</span> ; §3.2, "Multilinear extensions"). Zhang et al. [112] show, in the non-ZK setting, that  <span class="math">\\mathcal{V}</span>  can outsource this evaluation to  <span class="math">\\mathcal{P}</span> . We</p>

    <p class="text-gray-300">proof-of-sum-check  <span class="math">(C_0,\\{\\alpha_j\\} ,\\{M_k\\} ,X,Y,Z)</span></p>

    <p class="text-gray-300">Inputs:  <span class="math">C_0 = \\operatorname{Com}(s_0; r_{C_0})</span> .</p>

    <p class="text-gray-300"><span class="math">\\{\\alpha_{j}\\}</span>  are all of  <span class="math">\\mathcal{P}</span> 's messages from a sum-check invocation: at each round  <span class="math">j</span>  of the sum-check protocol,  <span class="math">\\mathcal{P}</span>  has sent</p>

    <div class="my-4 text-center"><span class="math-block">\\alpha_ {j} \\leftarrow \\operatorname {C o m} \\left(\\left(c _ {3, j}, c _ {2, j}, c _ {1, j}, c _ {0, j}\\right); r _ {\\alpha_ {j}}\\right)</span></div>

    <p class="text-gray-300"><span class="math">\\{M_k\\}</span>  is defined as in Equation (5) and Lemma 3. (These vectors encode  <span class="math">\\mathcal{V}</span> 's random coins  <span class="math">\\{r_j\\}</span>  from the sum-check.)</p>

    <p class="text-gray-300"><span class="math">X = \\operatorname{Com}(v_0; r_X), Y = \\operatorname{Com}(v_1; r_Y), Z = \\operatorname{Com}(v_0 v_1; r_Z)</span> .</p>

    <p class="text-gray-300">Definitions:  <span class="math">n = b_{N} + 2b_{G}</span> ;  <span class="math">\\vec{\\pi}</span>  is defined as in Equation (5);  <span class="math">\\{\\rho_k\\}</span>  are chosen by  <span class="math">\\mathcal{V}</span>  (see below);  <span class="math">\\vec{J} = \\sum \\rho_k \\cdot \\vec{M}_k</span> ;  <span class="math">(J_X, J_Y, J_Z)</span>  are the last 3 elements of  <span class="math">\\vec{J}</span> ;  <span class="math">\\vec{\\pi}^<em></span>  and  <span class="math">\\vec{J}^</em></span>  are all but the last three elements of  <span class="math">\\vec{\\pi}</span>  and  <span class="math">\\vec{J}</span> , respectively.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  execute proof-of-product (§4) on  <span class="math">X, Y</span> , and  <span class="math">Z</span> .</li>

      <li><span class="math">\\mathcal{P}</span>  picks  <span class="math">r_{\\delta_1},\\ldots ,r_{\\delta_n}\\in_R\\mathbb{F}</span>  and  <span class="math">\\vec{d}\\in_R\\mathbb{F}^{4b_N + 6b_G}</span>  where  <span class="math">\\vec{d} = (d_{c_{3,1}},d_{c_{2,1}},d_{c_{1,1}},d_{c_{0,1}},\\dots,d_{c_{0,n - 1}},d_{c_{2,n}},d_{c_{1,n}},d_{c_{0,n}})</span> .  <span class="math">\\mathcal{P}</span>  computes and sends</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\delta_ {j} \\leftarrow \\operatorname {C o m} \\left(\\left(d _ {c _ {3, j}}, d _ {c _ {2, j}}, d _ {c _ {1, j}}, d _ {c _ {0, j}}\\right); r _ {\\delta_ {j}}\\right), \\quad j \\in \\{1, \\dots , n \\}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  chooses and sends  <span class="math">\\rho_{1},\\ldots ,\\rho_{n + 1}\\in_{R}\\mathbb{F}</span></li>

      <li><span class="math">\\mathcal{P}</span>  picks  <span class="math">r_C\\in_R\\mathbb{F}</span> , then computes and sends</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">C \\leftarrow \\operatorname {C o m} (\\langle \\vec {J} ^ {*}, \\vec {d} \\rangle ; r _ {C})</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  chooses and sends challenge  <span class="math">c\\in_{R}\\mathbb{F}</span></li>

      <li><span class="math">\\mathcal{P}</span>  computes and sends</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\vec {z} \\leftarrow c \\cdot \\vec {\\pi} ^ {*} + \\vec {d} \\\\ z _ {\\delta_ {j}} \\leftarrow c \\cdot r _ {\\alpha_ {j}} + r _ {\\delta_ {j}}, \\quad j \\in \\{1, \\dots , n \\} \\\\ z _ {C} \\leftarrow c \\cdot \\left(\\rho_ {1} r _ {C _ {0}} - J _ {X} r _ {X} - J _ {Y} r _ {Y} - J _ {Z} r _ {Z}\\right) + r _ {C} \\\\ \\end{array}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  rejects unless the following holds, where we denote  <span class="math">\\vec{z} = (z_{c_{3,1}}, z_{c_{2,1}}, z_{c_{1,1}}, z_{c_{0,1}}, \\ldots, z_{c_{0,n-1}}, z_{c_{2,n}}, z_{c_{1,n}}, z_{c_{0,n}})</span> :</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\operatorname{Com}((z_{c_{3,j}}, z_{c_{2,j}}, z_{c_{1,j}}, z_{c_{0,j}}); z_{\\delta_j}) \\stackrel{!}{=} \\alpha_j^c \\odot \\delta_j \\quad j \\in \\{1, \\dots, n\\}</span></p>

    <p class="text-gray-300"><span class="math">(C_0^{\\rho_1}\\odot X^{-J_X}\\odot Y^{-J_Y}\\odot Z^{-J_Z})^c\\odot C\\stackrel {!}{=}\\mathsf{Com}(\\langle \\vec{J}^*,\\vec{z}\\rangle ;z_C)</span></p>

    <p class="text-gray-300">FIGURE 1—This protocol proves the statement derived by applying Lemma 3 to Equation (5), i.e., that the sum-check whose transcript is encoded in the protocol's inputs is accepting. Values corresponding to  <span class="math">c_{3,j}</span>  are elided for all sum-check rounds  <span class="math">j</span>  having quadratic  <span class="math">s_j</span> .</p>

    <p class="text-gray-300">apply their idea to the ZK setting, <span class="math">^{4}</span>  reducing communication and saving  <span class="math">\\mathcal{V}</span>  computation, by devising a polynomial commitment scheme [66] tailored to multilinear polynomials. Informally, such schemes are hiding and binding (§3.1, Def. 5); they also allow the sender to evaluate a committed polynomial at any point and prove that the evaluation is consistent with the commitment.</p>

    <p class="text-gray-300">Our commitment scheme builds on a matrix commitment idea due to Groth [57] and an inner-product argument due to</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Bünz et al. <em>[31]</em>. We begin by describing a simplified version of the scheme that gives $\\mathrm{O}(\\sqrt{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math"> communication and </span>\\mathcal{V}<span class="math"> runtime; we then generalize this to </span>\\mathrm{O}(\\mathrm{Sp})<span class="math"> communication and </span>\\mathrm{O}(\\mathrm{Ti})<span class="math"> </span>\\mathcal{V}<span class="math"> runtime, </span>\\mathrm{Ti}\\geq\\sqrt{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},\\mathrm{Sp}\\cdot\\mathrm{Ti}=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. We assume WLOG for notational convenience that </span>2^{\\ell}=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Square-root commitment scheme. In its final check, <span class="math">\\mathcal{V}</span> evaluates <span class="math">\\tilde{w}(r_{1},\\ldots,r_{\\ell})</span> by computing a commitment to the dot product <span class="math">\\langle(w_{0},\\ldots,w_{2^{\\ell}-1}),(\\chi_{0},\\ldots,\\chi_{2^{\\ell}-1})\\rangle</span> (Eq. (4), §4). Consider the following strawman protocol for computing this commitment: in Step 0 (§4), <span class="math">\\mathcal{P}</span> sends one multi-commitment to <span class="math">w</span>. Later, <span class="math">\\mathcal{P}</span> sends a commitment <span class="math">\\omega</span>, and <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> execute proof-of-dot-prod (§5) on <span class="math">\\mathsf{Com}(w)</span>, <span class="math">\\omega</span>, and <span class="math">(\\chi_{0},\\ldots)</span>. This protocol convinces <span class="math">\\mathcal{V}</span> that <span class="math">\\omega=\\mathsf{Com}(\\tilde{w}(\\cdot))</span>, but does not reduce communication: proof-of-dot-prod requires <span class="math">\\mathcal{P}</span> to send $\\mathrm{O}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ messages (Appx. A.2).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To reduce communication, we exploit the structure of the polynomial <span class="math">\\tilde{w}</span> and a matrix commitment due to Groth <em>[57]</em>. At a high level, this works as follows (details below). In Step 0, <span class="math">\\mathcal{P}</span> encodes <span class="math">w</span> as a matrix <span class="math">T</span>, then sends commitments <span class="math">\\{T_{k}\\}</span> to the rows of <span class="math">T</span>. Then, in the final step, <span class="math">\\mathcal{P}</span> sends a commitment <span class="math">\\omega</span> that it claims is to <span class="math">\\tilde{w}(r_{1},\\ldots,r_{\\ell})</span>; <span class="math">\\mathcal{V}</span> uses <span class="math">\\{T_{k}\\}</span> to compute one multi-commitment <span class="math">T^{\\prime}</span>; and <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> execute proof-of-dot-prod on <span class="math">T^{\\prime}</span> and <span class="math">\\omega</span>. In total, communication cost is <span class="math">\\mathrm{O}(2^{\\ell/2})</span>.</p>

    <p class="text-gray-300">In more detail: <span class="math">T</span> is the <span class="math">2^{\\ell/2}\\times 2^{\\ell/2}</span> matrix whose column-major order is <span class="math">w</span>, i.e., <span class="math">T_{i+1,j+1}=w_{i+2^{\\ell/2}\\cdot j}</span>. Before defining <span class="math">T^{\\prime}</span> and the proof-of-dot-prod invocation, we define</p>

    <p class="text-gray-300"><span class="math">\\tilde{\\chi}_{b}</span> <span class="math">=\\prod_{k=1}^{\\ell/2}\\chi_{b_{k}}(r_{k})</span> <span class="math">\\quad\\hat{\\chi}_{b}=\\prod_{k=\\ell/2+1}^{\\ell}\\chi_{b_{k}}(r_{k})</span> <span class="math">L</span> <span class="math">=(\\tilde{\\chi}_{0},\\tilde{\\chi}_{1},\\ldots,\\tilde{\\chi}_{2^{\\ell/2}-1})</span> <span class="math">R=(\\hat{\\chi}_{0},\\hat{\\chi}_{2^{\\ell/2}},\\ldots,\\hat{\\chi}_{2^{\\ell/2}\\cdot(2^{\\ell/2}-1)})</span></p>

    <p class="text-gray-300">To compute <span class="math">T^{\\prime}</span> from commitments <span class="math">\\{T_{k}\\}</span> to the rows of <span class="math">T</span>, <span class="math">\\mathcal{V}</span> evaluates <span class="math">L</span> (in time <span class="math">\\mathrm{O}(2^{\\ell/2})</span> <em>[109, §3.3]</em>) and uses it to compute</p>

    <p class="text-gray-300"><span class="math">T^{\\prime}=\\bigodot_{k=0}^{2^{\\ell/2}-1}~{}T_{k+1}^{\\tilde{\\chi}_{k}}=\\mathsf{Com}(L\\cdot T)</span> (6)</p>

    <p class="text-gray-300">Finally, <span class="math">\\mathcal{P}</span> sends a commitment <span class="math">\\omega</span> and uses proof-of-dot-prod to convince <span class="math">\\mathcal{V}</span> that the dot product of <span class="math">R</span> with the vector committed in <span class="math">T^{\\prime}</span> equals the value committed in <span class="math">\\omega</span>.</p>

    <p class="text-gray-300">The above proves to <span class="math">\\mathcal{V}</span> that <span class="math">\\omega=\\mathsf{Com}(\\tilde{w}(r_{0},\\ldots,r_{\\ell}))</span>, as we now argue. For 1-indexed <span class="math">L</span> and <span class="math">R</span>, we have</p>

    <p class="text-gray-300"><span class="math">L_{i+1}\\cdot R_{j+1}=\\hat{\\chi}_{i}\\cdot\\hat{\\chi}_{2^{\\ell/2}\\cdot j}=\\chi_{i+2^{\\ell/2}\\cdot j}</span></p>

    <p class="text-gray-300">This is true because <span class="math">\\tilde{\\chi}_{b}</span> comprehends the lower <span class="math">\\ell/2</span> bits of <span class="math">b</span>, and <span class="math">\\hat{\\chi}_{b}</span> the upper <span class="math">\\ell/2</span> bits. Then by the definition of <span class="math">T</span>, we have</p>

    <p class="text-gray-300"><span class="math">L\\cdot T\\cdot R^{\\mathrm{T}}</span> <span class="math">=\\sum_{i=0}^{2^{\\ell/2}-1}~{}\\sum_{j=0}^{2^{\\ell/2}-1}T_{i+1,j+1}\\cdot L_{i+1}\\cdot R_{j+1}</span> <span class="math">=\\sum_{i=0}^{2^{\\ell/2}-1}~{}\\sum_{j=0}^{2^{\\ell/2}-1}w_{i+2^{\\ell/2}\\cdot j}\\cdot\\chi_{i+2^{\\ell/2}\\cdot j}~{}=\\sum_{k=0}^{2^{\\ell}-1}w_{k}\\cdot\\chi_{k}</span></p>

    <p class="text-gray-300">If <span class="math">\\mathcal{V}</span> accepts <span class="math">\\mathcal{P}</span>’s proof-of-dot-prod on <span class="math">T^{\\prime}</span>, <span class="math">\\omega</span>, and <span class="math">R</span>, then by Equation (6), <span class="math">\\omega=\\mathsf{Com}(L\\cdot T\\cdot R^{\\mathrm{T}})=\\mathsf{Com}(\\sum_{k=0}^{2^{\\ell}-1}w_{k}\\cdot\\chi_{k})</span>, which equals <span class="math">\\mathsf{Com}(\\tilde{w}(r_{0},\\ldots,r_{\\ell}))</span> (Eq. (4), §4) as claimed.</p>

    <p class="text-gray-300">In total, communication is <span class="math">\\mathrm{O}(2^{\\ell/2})</span> (for <span class="math">\\{T_{k}\\}</span> plus the proof-of-dot-prod invocation), and <span class="math">\\mathcal{V}</span>’s computational cost is <span class="math">\\mathrm{O}(2^{\\ell/2})</span> (for computing <span class="math">L</span>, <span class="math">R</span>, and <span class="math">T^{\\prime}</span>, and executing proof-of-dot-prod).</p>

    <p class="text-gray-300">Reducing the cost of proof-of-dot-prod. In the above protocol, proof-of-dot-prod establishes a lower bound on communication cost. To reduce proof-of-dot-prod’s cost, we use an idea due to Bünz et al. <em>[31]</em>, who give a dot-product protocol that has cost logarithmic in the length of the vectors. Their protocol works over two committed vectors; we require one that works over one committed and one public vector. In Appendix A.3, we adapt their protocol to the syntax of proof-of-dot-prod; we refer to the result as proof_{log}-of-dot-prod. Whereas proof-of-dot-prod requires <span class="math">\\mathcal{P}</span> to send <span class="math">4+n</span> elements for vectors of length <span class="math">n</span>, proof_{log}-of-dot-prod requires only <span class="math">4+2\\log n</span>. In both protocols, <span class="math">\\mathcal{V}</span>’s computational cost is dominated by a multi-exponentiation <em>[88]</em> of length <span class="math">n</span>.</p>

    <p class="text-gray-300">The full commitment scheme differs from the square-root one in that <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> invoke proof_{log}-of-dot-prod (rather than proof-of-dot-prod) on <span class="math">T^{\\prime}</span>, <span class="math">R</span>, and <span class="math">\\omega</span>. For <span class="math">T,L,R,\\tilde{\\chi}_{b},\\hat{\\chi}_{b}</span> as defined above, <span class="math">\\mathcal{P}</span> sends <span class="math">4+2^{\\ell/2}+2\\log 2^{\\ell/2}</span> elements, and <span class="math">\\mathcal{V}</span>’s runtime is dominated by two multi-exponentiations of length <span class="math">2^{\\ell/2}</span>, one to compute <span class="math">T^{\\prime}</span> and the other to execute proof_{log}-of-dot-prod. This gives the same asymptotics as the square-root scheme with <span class="math">\\approx</span>2<span class="math">\\times</span> less communication (but with <span class="math">\\approx</span>3<span class="math">\\times</span> more computation for <span class="math">\\mathcal{P}</span>).</p>

    <p class="text-gray-300">More importantly, proof_{log}-of-dot-prod gives the freedom to reduce communication in exchange for increased <span class="math">\\mathcal{V}</span> runtime. For a parameter <span class="math">\\iota</span>, we redefine <span class="math">T</span> to be the <span class="math">2^{\\ell/\\iota}\\times 2^{\\ell-\\ell/\\iota}</span> matrix whose column-major order is <span class="math">w</span>; redefine <span class="math">\\tilde{\\chi}_{b}</span> to comprehend the lower <span class="math">\\ell/\\iota</span> bits of <span class="math">b</span>, and <span class="math">\\hat{\\chi}_{b}</span> the upper <span class="math">\\ell-\\ell/\\iota</span> bits; and redefine</p>

    <p class="text-gray-300"><span class="math">L=(\\tilde{\\chi}_{0},\\tilde{\\chi}_{1},\\ldots,\\tilde{\\chi}_{2^{\\ell/\\iota}-1})~{}~{}~{}~{}R=(\\hat{\\chi}_{0},\\hat{\\chi}_{2^{\\ell/\\iota}},\\ldots,\\hat{\\chi}_{2^{\\ell/\\iota}\\cdot(2^{\\ell-\\ell/\\iota}-1)})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">T</span> has <span class="math">2^{\\ell/\\iota}</span> rows and <span class="math">T^{\\prime}</span> is a vector of <span class="math">2^{\\ell-\\ell/\\iota}</span> elements, so <span class="math">\\mathcal{P}</span> sends <span class="math">2^{\\ell/\\iota}</span> commitments in Step 0 and 4+ log <span class="math">2^{\\ell-\\ell/\\iota}</span> elements for proof_{log}-of-dot-prod, which is <span class="math">\\mathrm{O}(2^{\\ell/\\iota})</span> in total. Computing <span class="math">T^{\\prime}</span> costs <span class="math">\\mathcal{V}</span> one multi-exponentiation of length <span class="math">2^{\\ell/\\iota}</span>, and executing proof_{log}-of-dot-prod costs one of length <span class="math">2^{\\ell-\\ell/\\iota}</span>, which is <span class="math">\\mathrm{O}(2^{\\ell/\\iota}+2^{\\ell-\\ell/\\iota})</span> in total. Since this is at least <span class="math">\\mathrm{O}(2^{\\ell/2})</span>, <span class="math">\\mathcal{V}</span>’s runtime is at least $\\mathrm{O}(\\sqrt{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})$. We formalize immediately below.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-28" class="text-base font-medium mt-4">Lemma 5.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose WLOG that <span class="math">w\\in\\mathbb{F}^{2^{\\iota\\cdot\\ell^{\\prime}}}</span> for <span class="math">\\iota\\geq 2</span>, and that <span class="math">\\mathcal{P}</span> commits to <span class="math">w</span> as described above using $2^{\\ell^{\\prime}}=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{1/\\iota}<span class="math"> multi-commitments. Then for any </span>(r_{1},\\ldots,r_{\\iota\\cdot\\ell^{\\prime}})<span class="math">, </span>\\mathcal{P}<span class="math"> can send a commitment </span>\\omega<span class="math"> and argue that it commits to </span>\\tilde{w}(r_{1},\\ldots,r_{\\iota\\cdot\\ell^{\\prime}})<span class="math"> in communication </span>\\mathrm{O}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{1/\\iota})<span class="math">, where </span>\\mathcal{V}<span class="math"> runs in </span>\\mathrm{O}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{1\\iota-1/\\iota})$ steps. This is a complete, honest-verifier perfect zero-knowledge argument with generalized special soundness under the discrete log assumption.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Completeness and ZK follow from the analysis in Appendix A.3. We provide an analysis for generalized special soundness in Appendix A.5. We have described this protocol in terms of the multilinear extension of <span class="math">w</span>, but it generalizes to any multilinear polynomial <span class="math">f</span> using the fact that <span class="math">T</span> comprises the evaluations of <span class="math">f</span> at all binary inputs.</p>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">6.2 Sharing witness elements in the data-parallel setting</h3>

    <p class="text-gray-300">We have thus far regarded the computation as having one large input and one large witness. When evaluating a data-parallel computation, this means that the sub-ACs’ inputs must be disjoint</p>

    <p class="text-gray-300">slices of the full input (and similarly for the witness). However, this is not sufficient in many cases of interest.</p>

    <p class="text-gray-300">Consider a case where <span class="math">\\mathcal{P}</span> wants to convince <span class="math">\\mathcal{V}</span> that it knows leaves of a Merkle tree corresponding to a supplied root. Verifying a witness with <span class="math">M</span> leaves requires <span class="math">2M-1</span> invocations of a hash function. We encode this as a computation with <span class="math">2M-1</span> sub-ACs laid side-by-side, each encoding the hash function. Then, for sub-AC<span class="math">_{\\mathrm{b}}</span> processing sub-AC<span class="math">_{\\mathrm{a}}</span>'s output, <span class="math">\\mathcal{P}</span> supplies the purported output to both, and sub-AC<span class="math">_{\\mathrm{a}}</span> just checks that value and outputs a bit indicating correctness. This is necessary for zero-knowledge: all AC outputs are public, whereas sub-AC<span class="math">_{\\mathrm{a}}</span>'s output (an intermediate value in the computation) must not be revealed to <span class="math">\\mathcal{V}</span>.</p>

    <p class="text-gray-300">This arrangement requires sub-ACs to share witness elements—but duplicating entries in the matrix <span class="math">T</span> (§6.1) is not a solution, because <span class="math">\\mathcal{V}</span> cannot detect if a cheating <span class="math">\\mathcal{P}</span> produces <span class="math">T</span> that gives different values to different sub-ACs. One possibility is a hybrid vector-scalar scheme: <span class="math">\\mathcal{P}</span> supplies scalar commitments for each shared witness element and matrix commitment <span class="math">\\{T_k\\}</span> for the rest. Then, for a scalar commitment <span class="math">\\delta</span>, <span class="math">\\mathcal{V}</span> "injects" the committed value into input index <span class="math">b</span> by multiplying the commitment to <span class="math">\\tilde{V}_d(r&#x27;, r_\\nu)</span> (§4, "Final step") by <span class="math">\\delta^{-r_0 \\cdot \\chi_b} \\cdot 6</span> (In contrast, the protocol of Section 6.1 maps each entry of <span class="math">T</span> to a fixed input index.)</p>

    <p class="text-gray-300">This approach works when the number of shared witness elements is small, but it is inefficient when there are many shared elements: each shared element requires a separate commitment and proof-of-opening invocation. For such cases, we enable sharing of witness elements by modifying the arithmetic circuit encoding the NP relation. Specifically, after constructing a data-parallel AC corresponding to the computation, we add one non-data-parallel redistribution layer (RDL) whose inputs are the full input and witness, and whose outputs feed the input layers of each sub-AC. Since the RDL is not data parallel, there are no restrictions on how its inputs connect to its outputs, meaning that <span class="math">\\mathcal{V}</span> can use it to ensure that the same witness element feeds multiple sub-ACs: the sum-check protocol forces <span class="math">\\mathcal{P}</span> to respect the wiring of the RDL, so <span class="math">\\mathcal{P}</span> cannot equivocate about <span class="math">w</span>.</p>

    <p class="text-gray-300">Moreover, since the RDL only "re-wires" its inputs, the sum-check invocation corresponding to this layer of the AC can be optimized to require fewer rounds and a simplified final check. Observe that the redistribution layer only requires one-input "pass" gates that copy their input to their output. Thus, following a simplification of the CMT protocol [37, 103], we have that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde {V} _ {d - 1} \\left(q ^ {\\prime}, q\\right) = \\sum_ {h \\in \\{0, 1 \\} ^ {\\log (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}} \\operatorname {p a s s} \\left(\\left(q ^ {\\prime}, q\\right), h\\right) \\cdot \\tilde {V} _ {d} (h)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where <span class="math">\\widehat{\\mathrm{pass}}((q&#x27;, q), h)</span> is the MLE of a wiring predicate (§3.2) that is 1 when the RDL connects from the AC input with index <span class="math">h</span></p>

    <p class="text-gray-300">to input <span class="math">q</span> in sub-AC <span class="math">q&#x27;</span>, and 0 otherwise. A sum-check over</p>

    <div class="my-4 text-center"><span class="math-block">\\mathrm {R D L} _ {(q ^ {\\prime}, q)} (h) = \\widehat {\\mathrm {p a s s}} ((q ^ {\\prime}, q), h) \\cdot \\tilde {V} _ {d} (h)</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">requires $\\log (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) = \\log (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> rounds, at the end of which </span>\\mathcal{V}<span class="math"> evaluates </span>\\mathrm{RDL}_{(q',q)}<span class="math"> at a random point. This requires </span>\\mathcal{V}<span class="math"> to evaluate </span>\\widehat{\\mathrm{pass}}<span class="math">, but in contrast to </span>P_{\\dots,i}<span class="math"> or </span>Q_{\\dots,i}<span class="math"> (§3.2), it only requires one evaluation of </span>\\tilde{V}_d<span class="math">, which </span>\\mathcal{V}$ can check (via the protocol of §6.1) without invoking a mini-protocol (§3.2).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By a standard analysis [37], <span class="math">\\mathcal{P}</span>'s costs are $\\mathrm{O}(NG\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">; </span>\\mathcal{V}<span class="math">&#x27;s primary cost related to the RDL is evaluating </span>\\widehat{\\mathrm{pass}}<span class="math"> at one point, which costs </span>\\mathrm{O}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ NG)$ via known techniques [109, §3.3]. We formalize in Theorem 6 (§7).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We refer to the honest-verifier PZK argument obtained by applying the refinements of Sections 5 and 6 to the protocol of Section 4 as Hyrax-I; pseudocode is given in Appendix D. Since Hyrax-I is a public-coin protocol, we apply the Fiat-Shamir heuristic [45] to produce a zkSNARK that we call Hyrax whose properties we now formalize:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 6. Let <span class="math">\\mathcal{C}(\\cdot, \\cdot)</span> be a layered AC of fan-in two, consisting of <span class="math">N</span> identical sub-computations, each having <span class="math">d</span> layers whose width is at most <span class="math">G</span>. Under the discrete log assumption in the random oracle model, for every <span class="math">\\operatorname{Sp}, \\operatorname{Ti}</span> with $\\operatorname{Ti} \\geq \\sqrt{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> and </span>\\operatorname{Sp} \\cdot \\operatorname{Ti} =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, there exists a perfectly complete, perfect zero-knowledge, non-interactive argument with witness-extended emulation for the NP relation “</span>\\exists w<span class="math"> such that </span>\\mathcal{C}(x, w) = y<span class="math">.” </span>\\mathcal{V}<span class="math"> runs in time </span>\\mathrm{O}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ dG + (\\mathrm{Ti} + d\\log (NG)) \\cdot \\kappa)<span class="math"> for </span>\\kappa<span class="math"> a bound on the time to compute a commitment; when using an RDL (§6.2), </span>\\mathcal{V}<span class="math"> incurs an additional </span>\\mathrm{O}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ NG)<span class="math"> cost. </span>\\mathcal{P}<span class="math">&#x27;s messages have size </span>\\mathrm{O}((\\mathrm{Sp} + d\\log (NG)) \\cdot \\lambda)<span class="math"> for </span>\\lambda$ a security parameter.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We formalize Hyrax-I's properties in Appendix B. Hyrax's security properties follow from these and the properties of the Fiat-Shamir heuristic [7, 45].</p>

    <p class="text-gray-300">We note that it is also possible to compile Hyrax-I into an interactive, malicious-verifier PZK argument in the plain model under the decisional Diffie-Hellman assumption [24] using standard techniques [39, 41].</p>

    <p class="text-gray-300">Implementation. Our implementation of Hyrax is based on Giraffe's code [86, 109]. It uses Pedersen commitments (Appx. A) in an elliptic curve group of order <span class="math">q_{\\mathcal{G}}</span> and works with ACs over <span class="math">\\mathbb{F}_{q_{\\mathcal{G}}}</span>. We instantiate the random oracle with SHA-256.</p>

    <p class="text-gray-300">The prover takes as input a high-level description of an AC (in the format produced by Giraffe's C compiler), the public inputs, and an auxiliary executable that generates the witness from the public inputs; the prover's output is a proof. The verifier takes as input the same computation description and public inputs plus the proof, and outputs "accept" or "reject."</p>

    <p class="text-gray-300">We implement <span class="math">\\mathrm{Gir}^{++}</span>, the techniques of Sections 5 and 6, the random oracle, and proof serialization and deserialization by adding 2800 lines of Python and 300 lines of C to the Giraffe code. We also implemented a library for fast multi-exponentiation comprising 750 lines of C that uses the MIRACL Crypto SDK [79] for elliptic curve operations and selects between Straus's [100] and Pippenger's [19, 88] methods, depending on the problem size. Our library supports Curve25519 [18], M221,</p>

    <p class="text-gray-300">5The sub-ACs could instead be arranged sequentially. This would avoid the issues described in this subsection, but would dramatically increase circuit depth, and thus the proof length and associated costs when applying our argument.</p>

    <p class="text-gray-300">6In fact, this approach works generally for computations over values to which <span class="math">\\mathcal{V}</span> holds a commitment whose opening <span class="math">\\mathcal{P}</span> knows. It also applies to committed vectors: if <span class="math">\\mathcal{V}</span> holds a commitment <span class="math">\\xi = \\mathrm{Com}(\\vec{x})</span>, it can inject the committed values into a list of indices <span class="math">(b_{1},\\ldots)</span> as follows: <span class="math">\\mathcal{P}</span> produces a commitment <span class="math">\\delta</span> and proves to <span class="math">\\mathcal{V}</span> that it commits to <span class="math">\\mathrm{Com}((x_1,\\ldots),(x_{b_1},\\ldots)))</span> with prooflog-of-dot-prod; then <span class="math">\\mathcal{V}</span> multiplies <span class="math">\\mathrm{Com}(\\tilde{V}_d(r&#x27;,r_\\nu))</span> by <span class="math">\\delta^{-r_0}</span>. This approach requires more communication and <span class="math">\\mathcal{V}</span> computation than the protocol of Section 6.1, because it does not assume any particular structure for <span class="math">(b_{1},\\ldots)</span>.</p>

    <p class="text-gray-300">M191, and M159 <em>[2]</em>. Python code calls this library via CFFI <em>[32]</em>. We produce random group elements by hashing, implemented in 200 lines of Sage <em>[93]</em> adapted from a script by Samuel Neves <em>[2]</em>.</p>

    <p class="text-gray-300">We have released full source code <em>[63]</em>.</p>

    <h2 id="sec-31" class="text-2xl font-bold">8 Evaluation</h2>

    <p class="text-gray-300">In this section we ask:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>How does Hyrax compare to several baseline systems, considering proof size and <span class="math">\\mathcal{V}</span> and <span class="math">\\mathcal{P}</span> execution time?</li>

      <li>How do Hyrax’s refinements (§5–6) improve its costs?</li>

      <li>What is the overall effect of trading greater witness-related <span class="math">\\mathcal{V}</span> computation for smaller witness commitments (§6.1)?</li>

    </ul>

    <p class="text-gray-300">A careful comparison of built systems shows that, even for modest problem sizes, Hyrax’s proofs are smaller than all but the most computationally costly of the baselines; and that its <span class="math">\\mathcal{V}</span> and <span class="math">\\mathcal{P}</span> execution times are each faster than three of five baselines. We also find that Hyrax’s refinements yield multiple-orders-of-magnitude savings in proof size and <span class="math">\\mathcal{V}</span> time, and a small constant savings in <span class="math">\\mathcal{P}</span> time. Finally, we find that tuning the witness commitment costs gives much smaller proofs, with little effect on total <span class="math">\\mathcal{V}</span> time for a computation using an RDL (§6.2).</p>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">8.1 Comparison with prior work</h3>

    <p class="text-gray-300">Baselines. We compare Hyrax with five state-of-the-art zero-knowledge argument systems with similar properties, detailed below. We also consider <em>Hyrax-naive</em>, which implements the protocol of Section 4 without our refinements (§5–6). We do not compare to systems that require trusted setup (see §2, second paragraph), but we discuss them briefly in Section 8.3.</p>

    <p class="text-gray-300">Like Hyrax (and Hyrax-naive), two of the baselines rely on elliptic curve primitives; but their existing implementations use a different elliptic curve than Hyrax. To evaluate like-for-like, we re-implemented them using the Python scaffolding, C cryptographic library, and elliptic curves that Hyrax uses (§7).</p>

    <p class="text-gray-300">The other three baselines do not use elliptic curves, so some mismatch in implementations is unavoidable. For those systems, we used existing implementations written in C or C++.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>BCCGP-sqrt</em> is the square-root-communication argument due to Bootle et al. <em>[25]</em>. We implemented this protocol using Hyrax’s libraries, as described above. In addition, this protocol uses polynomial multiplication, for which we used NTL <em>[99]</em>. Finally, we wrote a compiler that converts from Hyrax’s AC description format to the required constraint format, with rudimentary optimizations like constant folding and common subexpression elimination. Our implementation comprises 1200 lines of Python and 160 lines of C, which we include in our released code <em>[63]</em>.</li>

      <li><em>Bulletproofs</em> is the argument due to Bünz et al. <em>[31]</em> (we also adapted the inner-product argument from this work in §6). We implemented this protocol in 300 lines of Python on top of our BCCGP-sqrt code, which we also include in our release.</li>

      <li><em>Ligero</em> <em>[1]</em>: we report on the authors’ C++ implementation.</li>

      <li><em>ZKB++</em> <em>[33]</em>: we report runtime of the C implementation of ZKBoo <em>[51, 115]</em>; per the ZKB++ authors, these systems have similar performance <em>[33, §3.2]</em>. We report extrapolated proof sizes (which are linear with AC size) from ZKB++ <em>[33, §3.2.1]</em>.</li>

      <li><em>libSTARK</em> <em>[11]</em>: we report on the authors’ C++ implementation <em>[72]</em> and SHA-256 primitive <em>[11, Fig. 4]</em>, which we adapt to the Merkle tree benchmark (described below).</li>

    </ul>

    <p class="text-gray-300">This implementation supports multi-threading, but we restrict it to a single thread for consistency with the other baselines and to focus on total prover work; we discuss in Section 8.3.</p>

    <p class="text-gray-300">Benchmarks. We evaluate Hyrax, Hyrax-naive, BCCGP-sqrt, and Bulletproofs on all benchmarks below, but Ligero, ZKB++, and libSTARK only on Merkle trees; we discuss in Section 8.3.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Matrix factoring</em> (i.e., matrix multiplication) proves to <span class="math">\\mathcal{V}</span> that <span class="math">\\mathcal{P}</span> knows two matrices whose product equals the public input. We evaluate on 16<span class="math">\\times</span>16, 32<span class="math">\\times</span>32, 64<span class="math">\\times</span>64, and 128<span class="math">\\times</span>128 matrices, and for each we vary <span class="math">N</span>, the number of parallel executions.</li>

      <li><em>Image scaling</em> establishes that <span class="math">\\mathcal{V}</span>’s input, a low-resolution image, is a scaled version of a high-resolution image that <span class="math">\\mathcal{P}</span> knows. For scaling, we use Lanczos resampling <em>[105]</em>, a standard image transformation in which each output pixel is the result of convolving a two-dimensional windowed sinc function <em>[82]</em> with the input image. We evaluate on 4<span class="math">\\times</span>, 16<span class="math">\\times</span>, 64<span class="math">\\times</span>, and 256<span class="math">\\times</span> scaling, varying the number of pixels.</li>

    </ul>

    <p class="text-gray-300">This is a data-parallel computation where each sub-AC evaluates one pixel of the low-resolution image, but because of the windowed sinc function, sub-ACs for adjacent pixels must share inputs from the high-resolution image. To accommodate this, we use a redistribution layer (RDL; §6.2).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Merkle tree</em> proves to <span class="math">\\mathcal{V}</span> that <span class="math">\\mathcal{P}</span> knows an assignment to the leaves of a Merkle tree <em>[77]</em> corresponding to a root that <span class="math">\\mathcal{V}</span> provides <em>[23]</em>. We use SHA-256 for the hash, varying the number of leaves in the tree; we implement a data-parallel computation in which each sub-computation is one invocation of SHA-256; and we connect outputs at one level of the tree to inputs at the next level using an RDL. For <span class="math">M</span> leaves, the benchmark comprises <span class="math">2M-1</span> sub-computations.</li>

    </ul>

    <p class="text-gray-300">To implement SHA-256 efficiently in an arithmetic circuit, we use an approach from prior work <em>[12]</em> for efficient addition modulo <span class="math">2^{32}</span>. We describe the approach, and an optimization that may be of independent interest, in Appendix C.</p>

    <p class="text-gray-300">Testbed. We run experiments on Amazon EC2 <em>[3]</em>. For Hyrax, Hyrax-naive, Ligero, and ZKB++, we use c3.4xlarge instances (30 GiB of RAM, 8 Xeon E5-2680v2 cores, 2 threads per core, 2.8 GHz). The BCCGP-sqrt, Bulletproofs, and libSTARK provers are memory intensive (“<span class="math">\\mathcal{P}</span> cost,” below), so for these we use c3.8xlarge instances (60 GiB of RAM, 16 cores at 2.8 GHz). Only RAM is relevant because we run all tests single threaded.</p>

    <p class="text-gray-300">All testbed machines run Debian GNU/Linux 9 <em>[42]</em>. We run all Python code using PyPy <em>[91]</em>, a fast JIT-compiling interpreter.</p>

    <p class="text-gray-300">Security parameters. For Hyrax, Hyrax-naive, BCCGP-sqrt, and Bulletproofs, <span class="math">\\mathcal{G}</span> is M191 <em>[2]</em>, an elliptic curve over a base field modulo <span class="math">2^{191}-19</span> with a subgroup of order <span class="math">q_{\\mathcal{G}}=2^{188}+2^{93}+\\ldots</span>, giving <span class="math">\\approx</span>90-bit security. We run Ligero, ZKB++, and libSTARK</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> (a) Proof size:  <span class="math">64 \\times 64</span>  matrix multiplication.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> (d) Proof size:  <span class="math">16 \\times</span>  Lanczos scaling</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> (g) Proof size: SHA-256 Merkle tree</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> (b)  <span class="math">\\mathcal{P}</span>  time:  <span class="math">64\\times 64</span>  matrix multiplication</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> (e)  <span class="math">\\mathcal{P}</span>  time:  <span class="math">16\\times</span>  Lanczos scaling</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> (h)  <span class="math">\\mathcal{P}</span>  time: SHA-256 Merkle tree</p>

    <p class="text-gray-300">(c)  <span class="math">\\mathcal{V}</span>  time:  <span class="math">64\\times 64</span>  matrix multiplication !<a href="img-6.jpeg">img-6.jpeg</a> Hyrax-1/2 -Hyrax-1/3 -Hyrax-naive -BCCGP-sqrt -Bulletproofs -ZKB++ -Ligero -libSTARK</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> (f)  <span class="math">\\mathcal{V}</span>  time:  <span class="math">16\\times</span>  Lanczos scaling</p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a> (i)  <span class="math">\\mathcal{V}</span>  time: SHA-256 Merkle tree</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">FIGURE 2—Comparison of concrete costs between the baseline systems and Hyrax (§8.1). Hyrax-1/2 is Hyrax where  <span class="math">\\mathcal{P}</span> 's witness commitments have size  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{1/2}<span class="math"> , and likewise Hyrax-1/3 has commitments of size  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{1/3}$  (§6.1). Hyrax-naive is Hyrax without our refinements (§5-6). BCCGP-sqrt [25], Bulletproofs [31], ZKB++ [33], Ligero [1], and libSTARK [11] are prior work. Where the BCCGP-sqrt, Bulletproofs, and libSTARK data are truncated, their provers exceeded available RAM (§8.1). We evaluate ZKB++, Ligero, and libSTARK only on Merkle trees (we discuss in §8.3).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">at  <span class="math">2^{-80}</span>  soundness error. <span class="math">^{9}</span>  ACs are over  <span class="math">\\mathbb{F}_{q_{\\mathrm{gl}}}</span>  and group elements and scalars are 24 bytes, except that Ligero and libSTARK work over smaller fields and ZKB++ works over Boolean circuits.</p>

    <p class="text-gray-300">Method. For each benchmark, we construct a set of arithmetic circuits (and, for image scaling and Merkle trees, RDLs) for a range of computation sizes. We then run each system's prover, feeding the resulting proof into its verifier. We record proof size, and measure time using the high-resolution system clock.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For matrix factoring and image scaling, we set Hyrax's communication and  <span class="math">\\mathcal{V}</span>  runtime to  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{1/2}<span class="math">  (§6.1). For Merkle trees, we optimize proof size versus  </span>\\mathcal{V}<span class="math">  runtime by setting witness-related communication to  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{1/3}<span class="math">  and  </span>\\mathcal{V}<span class="math">  runtime to  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{1/2}$ ; we explore the effect of this setting in Section 8.2.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Results. Figure 2 compares costs for the benchmarks. For matrix factoring and image scaling we show only  <span class="math">64 \\times 64</span>  matrices and  <span class="math">16 \\times</span>  scaling, respectively; other values give similar results. For</p>

    <p class="text-gray-300">an AC  <span class="math">C</span> ,  <span class="math">\\mathcal{M}</span>  denotes the number of multiplication gates.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Hyrax has much larger proofs than Bulletproofs, both asymptotically and concretely.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Hyrax's proofs are smaller than BCCGP-sqrt's when the cost of the witness commitment dominates the cost of  <span class="math">\\mathcal{P}</span> 's messages in  <span class="math">\\mathrm{Gir}^{++}</span>  (i.e., for large enough computations). Specifically, Hyrax's cost tracks  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{1/2}<span class="math">  ( </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{1/3}<span class="math">  for Merkle trees; Fig. 2g), while BCCGP-sqrt&#x27;s tracks  </span>\\mathcal{M}^{1/2}<span class="math"> . Thus, on matrix factoring (where  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ll \\mathcal{M}$ ) Hyrax has much smaller proofs.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>libSTARK's proof size is asymptotically smaller than Hyrax's, but its proofs are concretely  <span class="math">\\approx 5 \\times</span>  larger at these problem sizes.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- ZKB++'s cost is linear in the number of AND gates, and Hyrax-naive's cost tracks  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ ; both are large.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>BCCGP-sqrt and Bulletproofs require a number of cryptographic operations proportional to  <span class="math">\\mathcal{M}</span> . Hyrax has lower  <span class="math">\\mathcal{P}</span>  time than these systems because it uses cryptographic operations only</li>

    </ul>

    <p class="text-gray-300">!<a href="img-9.jpeg">img-9.jpeg</a> (a) Proof size: SHA-256 Merkle tree</p>

    <p class="text-gray-300">!<a href="img-10.jpeg">img-10.jpeg</a> (b)  <span class="math">\\mathcal{P}</span>  time: SHA-256 Merkle tree</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">FIGURE 3—Proof size and  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  runtime for different sizes of  <span class="math">\\mathcal{P}</span> 's witness commitment (§6.1; §8.2). Hyrax-1/2 has commitment size  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{1/2}<span class="math"> , Hyrax-1/3 has commitment size  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{1/3}<span class="math"> , and Hyrax-log has commitment size log  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ . Hyrax-1/2 gives the largest proofs but has the fastest runtimes. Hyrax-log gives the smallest proofs but has the longest runtimes. Hyrax-1/3 gets essentially the best of both for this application.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-11.jpeg">img-11.jpeg</a> (c)  <span class="math">\\mathcal{V}</span>  time: SHA-256 Merkle tree</p>

    <p class="text-gray-300">for  <span class="math">\\mathcal{P}</span> 's messages in  <span class="math">\\mathrm{Gir}^{++}</span>  and for  <span class="math">w</span>  ( <span class="math">\\S 4 - \\S 6</span> ).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The provers in both BCCGP-sqrt and Bulletproofs ran out of memory for the largest benchmarks (Figs. 2b and 2h) despite having twice as much RAM as Hyrax ("Testbed," above). This is because they operate, roughly speaking, over all wire values in the AC at once. In contrast, Hyrax's  <span class="math">\\mathcal{P}</span>  works layer-by-layer ( <span class="math">\\S 3.2</span> ).[10]</li>

      <li>Hyrax's  <span class="math">\\mathcal{P}</span>  is more expensive than either ZKB++'s or Ligero's, because those systems do not use any public-key cryptography.</li>

      <li>While Ligero's  <span class="math">\\mathcal{P}</span>  is asymptotically more costly than Hyrax's  <span class="math">\\mathcal{P}</span> , this is not apparent at the problem sizes we consider.</li>

      <li>libSTARK's  <span class="math">\\mathcal{P}</span>  is  <span class="math">12 - 40 \\times</span>  more expensive than Hyrax's for these problem sizes. It is also memory intensive: for the largest problem, it exceeded available RAM despite having twice as much as Hyrax ("Testbed," above).</li>

      <li>Hyrax's refinements compared to Hyrax-naive (§5-6) yield a constant factor lower  <span class="math">\\mathcal{P}</span>  cost, at most  <span class="math">\\approx 3\\times</span> .</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathcal{V}</span>  time (Fig. 2c, 2f, 2i):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For matrix factoring, Hyrax's  <span class="math">\\mathcal{V}</span>  bottleneck is sum-check invocations for small  <span class="math">N</span> , and  <span class="math">\\bar{V}_y</span>  evaluation for large  <span class="math">N</span>  (§3.2). The RDL (§6.2) dominates  <span class="math">\\mathcal{V}</span> 's costs in the other two benchmarks.</li>

      <li>Hyrax's  <span class="math">\\mathcal{V}</span>  cost is lower than BCCGP-sqrt for large enough problems: the latter requires  <span class="math">\\mathrm{O}(\\mathcal{M})</span>  field operations.</li>

      <li>Hyrax's  <span class="math">\\mathcal{V}</span>  cost is much less than Bulletproofs's: the latter requires a multi-exponentiation of length  <span class="math">2\\mathcal{M}</span>  (which can be computed using  <span class="math">\\mathrm{O}(\\mathcal{M} / \\log \\mathcal{M})</span>  cryptographic operations [88]).</li>

      <li>ZKB++ has verification cost linear in the problem size, so Hyrax wins on large enough problems.</li>

      <li>Ligero's  <span class="math">\\mathcal{V}</span>  amortizes its bottleneck computation over repeated SHA-256 instances [1, §5.4], so over this range of problem sizes it has sublinear scaling and concretely fast verification time.</li>

      <li>libSTARK's  <span class="math">\\mathcal{V}</span>  has the best asymptotics among all systems and extremely low concrete costs.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Hyrax-naive requires cryptographic operations proportional to  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> ; Hyrax&#x27;s refinements give more than  </span>100 \\times$  savings.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Method. We run the Merkle tree benchmark using the same setup as in Section 8.1, except that we vary the size of  <span class="math">\\mathcal{P}</span> 's witness commitment (§6.1). We experiment with commitments of size</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{1/3}<span class="math"> , and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{1/2}<span class="math"> .  </span>\\mathcal{V}<span class="math"> &#x27;s witness-related work at these three settings is  </span>\\mathrm{O}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> ,  </span>\\mathrm{O}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2/3})<span class="math"> , and  </span>\\mathrm{O}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{1/2})$ , respectively.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Results. Figure 3 shows proof size and runtime for the specified commitment sizes. For Hyrax-1/2, proof sizes are large but  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  runtimes are small; Hyrax-log is the opposite. Hyrax-1/3 has similar runtimes to Hyrax-1/2:  <span class="math">\\mathcal{P}</span> 's costs are dominated by  <span class="math">\\mathrm{Gir}^{++}</span> ,  <span class="math">\\mathcal{V}</span> 's by the RDL (§6.2). Meanwhile, its proof sizes are not much larger than Hyrax-log, because the  <span class="math">\\mathrm{Gir}^{++}</span> -related proof costs are the same in both cases, and because the constants hidden in the asymptotic notation mean that the log and cube-root protocols have similar concrete costs at these problem sizes. In other words, Hyrax-1/3 gets very nearly the best of both worlds.</p>

    <p class="text-gray-300">Our results show that Hyrax is competitive with the baselines, and that the refinements of Sections 5 and 6 give substantial improvements. Hyrax gives smaller proofs than all but Bulletproofs, which pays for its smaller proofs with very high computational costs. Meanwhile, for problem sizes of practical interest, only Ligero is faster for both  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span> ; ZKB++ has faster  <span class="math">\\mathcal{P}</span>  but often slower  <span class="math">\\mathcal{V}</span> ; libSTARK has faster  <span class="math">\\mathcal{V}</span>  but much slower  <span class="math">\\mathcal{P}</span> ; and all three systems produce larger proofs than Hyrax.</p>

    <p class="text-gray-300">On the other hand, there are several limitations to this analysis. First, because  <span class="math">\\mathrm{Gir}^{++}</span>  is geared to data-parallel computations (§3.2; Thm. 1), Hyrax is competitive with prior work primarily when computations contain sufficient parallelism or are amenable to batching; this is evident in the way Hyrax's performance relative to the baselines improves as parallelism increases in Figure 2. While an RDL (§6.2) lets Hyrax take advantage of parallelism within one computation (as it did in the Merkle tree and image scaling benchmarks), not all applications fit these paradigms. Moreover, the RDL is asymptotically and concretely costly for  <span class="math">\\mathcal{V}</span> ; eliminating this bottleneck is future work.</p>

    <p class="text-gray-300">Second, we compare ZKB++, Ligero, and libSTARK only on the SHA-256 Merkle tree benchmark. This makes sense for ZKB++ because it is geared to Boolean circuits, where SHA-256 is a natural benchmark; similarly, Ligero's primary evaluation is on SHA-256 [1, §6]. For libSTARK, however, a hash function that is more efficient in  <span class="math">\\mathbb{F}_{2^{64}}</span>  would improve performance [11, Fig. 4]; future work is to compare Hyrax and all baselines on Merkle trees using hash functions tailored to each system (e.g., [11, Appx. E; 15, §5.2; 30, §3.2]). Furthermore, Ligero and libSTARK can in principle work over large fields, but the current</p>

    <p class="text-gray-300">implementations do not <em>[11, 106]</em>, so we could not evaluate on matrix factoring or image scaling; future work is to do so.</p>

    <p class="text-gray-300">Third, our comparison does not consider multi-threaded performance because, to our knowledge, libSTARK is the only baseline with a multi-threaded implementation <em>[11, 72]</em>. Prior work <em>[104, 108, 109]</em> suggests that <span class="math">\\text{Gr}^{++}</span> is highly parallelizable; exploring this in Hyrax is future work.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Finally, our comparison does not consider argument systems like libsnark <em>[16, 71]</em> that require trusted setup and non-standard, non-falsifiable assumptions (§2, paragraph 2); Hyrax’s goal is to avoid these requirements. Ignoring this, Hyrax’s proofs are bigger: libsnark’s proofs are a constant <span class="math">\\approx</span>300-bytes, independent of the AC <span class="math">\\mathcal{C}</span>. Hyrax’s <span class="math">\\mathcal{P}</span> cost is concretely and asymptotically smaller: libsnark has a logarithmic overhead in $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and it requires cryptographic operations per AC gate, while Hyrax’s </span>\\mathcal{P}<span class="math"> is essentially linear in computation size and requires cryptographic operations only for </span>\\mathcal{P}<span class="math">’s </span>\\text{Gr}^{++}<span class="math"> messages and for </span>w<span class="math"> (§4–§6). For </span>\\mathcal{V}<span class="math">, libsnark’s offline setup is very expensive <em>[110, §5.4]</em>, and it must be performed by </span>\\mathcal{V}<span class="math"> or someone </span>\\mathcal{V}<span class="math"> trusts; but libsnark’s online </span>\\mathcal{V}$ costs are essentially always cheaper than Hyrax’s (and roughly comparable to libSTARK’s, in practice).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-37" class="text-2xl font-bold">9 Conclusion</h2>

    <p class="text-gray-300">We have described a succinct zero-knowledge argument for NP with no trusted setup and low concrete cost for both the prover and the verifier, based on standard cryptographic assumptions. This scheme is practical because it tightly integrates three components: a state-of-the-art interactive proof (IP), which we tweak to reduce communication complexity; a highly optimized transformation from IPs to zero-knowledge arguments following the approach of Ben-Or et al. <em>[8]</em> and Cramer and Damgård <em>[40]</em>; and a new cryptographic commitment scheme tailored to multilinear polynomials that adapts prior work <em>[31, 57]</em> to allow a sender to commit to a <span class="math">\\log G</span>-variate multilinear polynomial and later to open it at one point, with <span class="math">\\text{O}(G^{1/\\iota})</span> total communication and <span class="math">\\text{O}(G^{(\\iota-1)/\\iota})</span> receiver runtime for any <span class="math">\\iota\\geq 2</span>. A careful comparison with prior work shows that our argument system is competitive on both proof size and computational costs. Key future work is to further reduce proof size without increasing verifier runtime.</p>

    <p class="text-gray-300">More broadly, ours and other recent work <em>[112, 113, 114]</em> suggest that the applicability of the GKR interactive proof <em>[54]</em> has been underestimated. In particular, GKR seemingly requires deterministic arithmetic circuits, and saves work for the verifier (relative to computing the circuit) only when those circuits have low depth. Zhang et al. sidestep these issues, extending GKR to non-deterministic, low-depth computations <em>[112]</em> and more recently to arbitrary RAM programs <em>[114]</em>, in both cases saving work asymptotically for the verifier. But even those enhanced protocols fall short of state-of-the-art work-saving zkSNARKs <em>[4, 5, 12, 13, 15, 16, 30, 36, 38, 43, 46, 47, 48, 69, 81, 84, 110]</em>, because they fail to address zero-knowledge applications. This work (and concurrent work by Zhang et al. <em>[113]</em>) closes that gap—and, in our view, attests to the power and versatility of the GKR protocol. We have released Hyrax’s source code and our BCCGP-sqrt and Bulletproofs implementations as open-source software <em>[63]</em>.</p>

    <p class="text-gray-300">This work was funded by DARPA grant HR0011-15-2-0047 and NSF grants CNS-1423249, TWC-1646671, and TWC-1664445; and by Nest Labs and a Google Research Fellowship. Justin Thaler was supported by a Research Seed Grant from Georgetown University’s Massive Data Institute. The authors thank Muthu Venkitasubramaniam for help with Ligero, and Eli Ben-Sasson, Iddo Bentov, and Michael Riabzev for help with libSTARK.</p>

    <h2 id="sec-38" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] S. Ames, C. Hazay, Y. Ishai, and M. Venkitasubramaniam. Ligero: Lightweight sublinear arguments without a trusted setup. In ACM CCS, Oct. 2017.</li>

      <li>[2] D. F. Aranha, P. S. L. M. Barreto, G. C. C. F. Pereira, and J. E. Ricardini. A note on high-security general-purpose elliptic curves. Cryptology ePrint Archive, Report 2013/647, 2013.</li>

      <li>[3] AWS EC2. https://aws.amazon.com/ec2/instance-types/.</li>

      <li>[4] M. Backes, M. Barbosa, D. Fiore, and R. M. Reischuk. ADSNARK: Nearly practical and privacy-preserving proofs on authenticated data. In IEEE S&P, May 2015.</li>

      <li>[5] M. Backes, D. Fiore, and R. M. Reischuk. Verifiable delegation of computation on outsourced data. In ACM CCS, Nov. 2013.</li>

      <li>[6] S. Bayer and J. Groth. Efficient zero-knowledge argument for correctness of a shuffle. In EUROCRYPT, Apr. 2012.</li>

      <li>[7] M. Bellare and P. Rogaway. Random oracles are practical: a paradigm for designing efficient protocols. In ACM CCS, Nov. 1993.</li>

      <li>[8] M. Ben-Or, O. Goldreich, S. Goldwasser, J. Håstad, J. Kilian, S. Micali, and P. Rogaway. Everything provable is provable in zero-knowledge. In CRYPTO, Aug. 1990.</li>

      <li>[9] E. Ben-Sasson, I. Ben-Tov, A. Chiesa, A. Gabizon, D. Genkin, M. Hamilis, E. Pergament, M. Riabzev, M. Silberstein, E. Tromer, and M. Virza. Computational integrity with a public random string from quasi-linear PCPs. In EUROCRYPT, Apr. 2017.</li>

      <li>[10] E. Ben-Sasson, I. Bentov, Y. Horesh, and M. Riabzev. Fast Reed-Solomon interactive oracle proofs of proximity. Electronic Colloquium on Computational Complexity (ECCC), 24:134, 2017.</li>

      <li>[11] E. Ben-Sasson, I. Bentov, Y. Horesh, and M. Riabzev. Scalable, transparent, and post-quantum secure computational integrity. Cryptology ePrint Archive, Report 2018/046, 2018.</li>

      <li>[12] E. Ben-Sasson, A. Chiesa, C. Garman, M. Green, I. Miers, E. Tromer, and M. Virza. Decentralized anonymous payments from Bitcoin. In IEEE S&P, May 2014.</li>

      <li>[13] E. Ben-Sasson, A. Chiesa, D. Genkin, E. Tromer, and M. Virza. SNARKs for C: Verifying program executions succinctly and in zero knowledge. In CRYPTO, Aug. 2013.</li>

      <li>[14] E. Ben-Sasson, A. Chiesa, and N. Spooner. Interactive oracle proofs. In IACR TCC, Oct. 2016.</li>

      <li>[15] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. Scalable zero knowledge via cycles of elliptic curves. In CRYPTO, Aug. 2014.</li>

      <li>[16] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. Succinct non-interactive zero knowledge for a von Neumann architecture. In USENIX Security, Aug. 2014.</li>

      <li>[17] E. Ben-Sasson and M. Sudan. Short PCPs with polylog query complexity. SIAM J. Computing, 38(2):551–607, May 2008.</li>

      <li>[18] D. J. Bernstein. Curve25519: new Diffie-Hellman speed records. In PKC, Apr. 2006.</li>

      <li>[19] D. J. Bernstein, J. Doumen, T. Lange, and J.-J. Oosterwijk. Faster batch forgery identification. Dec. 2012.</li>

      <li>[20] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer. From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In ITCS, Jan. 2012.</li>

      <li>[21] N. Bitansky, A. Chiesa, Y. Ishai, R. Ostrovsky, and O. Paneth. Succinct non-interactive arguments via linear interactive proofs. In IACR TCC, Mar. 2013.</li>

      <li>[22] M. Blum. How to prove a theorem so no one else can claim it. In ICM, Aug. 1986.</li>

    </ul>

    <p class="text-gray-300">[23] M. Blum, W. Evans, P. Gemmell, S. Kannan, and M. Naor. Checking the correctness of memories. In FOCS, Oct. 1991.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[24] D. Boneh. The decision Diffie-Hellman problem. In ANTS, June 1998.</li>

      <li>[25] J. Bootle, A. Cerulli, P. Chaidos, J. Groth, and C. Petit. Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In EUROCRYPT, Apr. 2016.</li>

      <li>[26] J. Bootle, A. Cerulli, E. Ghadafi, J. Groth, M. Hajiabadi, and S. Jakobsen. Linear-time zero-knowledge proofs for arithmetic circuit satisfiability. In ASIACRYPT, Dec. 2017.</li>

      <li>[27] J. Bootle and J. Groth. Efficient batch zero knowledge arguments for low degree polynomials. In PKC, Mar. 2018.</li>

      <li>[28] X. Boyen and B. Waters. Compact group signatures without random oracles. In EUROCRYPT, May 2006.</li>

      <li>[29] X. Boyen and B. Waters. Full-domain subgroup hiding and constant-size group signatures. In PKC, Apr. 2007.</li>

      <li>[30] B. Braun, A. J. Feldman, Z. Ren, S. Setty, A. J. Blumberg, and M. Walfish. Verifying computations with state. In SOSP, Nov. 2013.</li>

      <li>[31] B. Bünz, J. Bootle, D. Boneh, A. Poelstra, P. Wuille, and G. Maxwell. Bulletproofs: Efficient range proofs for confidential transactions. In IEEE S&P, May 2018.</li>

      <li>[32] Cffi. https://bitbucket.org/cffi/cffi.</li>

      <li>[33] M. Chase, D. Derler, S. Goldfeder, C. Orlandi, S. Ramacher, C. Rechberger, D. Slamanig, and G. Zaverucha. Post-quantum zero-knowledge and signatures from symmetric-key primitives. In ACM CCS, Oct. 2017.</li>

      <li>[34] D. Chaum and T. P. Pedersen. Wallet databases with observers. In CRYPTO, Aug. 1992.</li>

      <li>[35] A. Chiesa, M. A. Forbes, and N. Spooner. A zero knowledge sumcheck and its applications. CoRR, abs/1704.02086, 2017.</li>

      <li>[36] A. Chiesa, E. Tromer, and M. Virza. Cluster computing in zero knowledge. In EUROCRYPT, Apr. 2015.</li>

      <li>[37] G. Cormode, M. Mitzenmacher, and J. Thaler. Practical verified computation with streaming interactive proofs. In ITCS, Jan. 2012.</li>

      <li>[38] C. Costello, C. Fournet, J. Howell, M. Kohlweiss, B. Kreuter, M. Naehrig, B. Parno, and S. Zahur. Geppetto: Versatile verifiable computation. In IEEE S&P, May 2015.</li>

      <li>[39] R. Cramer and I. Damgård. Secure signature schemes based on interactive protocols. In CRYPTO, Aug. 1995.</li>

      <li>[40] R. Cramer and I. Damgård. Zero-knowledge proofs for finite field arithmetic, or: Can zero-knowledge be for free? In CRYPTO, Aug. 1998.</li>

      <li>[41] R. Cramer, I. Damgård, and B. Schoenmakers. Proofs of partial knowledge and simplified design of witness hiding protocols. In CRYPTO, Aug. 1994.</li>

      <li>[42] Debian, the unversal operating system. https://www.debian.org.</li>

      <li>[43] A. Delignat-Lavaud, C. Fournet, M. Kohlweiss, and B. Parno. Cinderella: Turning shabby X.509 certificates into elegant anonymous credentials with the magic of verifiable computation. In IEEE S&P, May 2016.</li>

      <li>[44] D. Dolev, C. Dwork, and M. Naor. Non-malleable cryptography. In STOC, 1991.</li>

      <li>[45] A. Fiat and A. Shamir. How to prove yourself: Practical solutions to identification and signature problems. In CRYPTO, Aug. 1986.</li>

      <li>[46] D. Fiore, C. Fournet, E. Ghosh, M. Kohlweiss, O. Ohrimenko, and B. Parno. Hash first, argue later: Adaptive verifiable computations on outsourced data. In ACM CCS, Oct. 2016.</li>

      <li>[47] D. Fiore, R. Gennaro, and V. Pastro. Efficiently verifiable computation on encrypted data. In ACM CCS, Nov. 2014.</li>

      <li>[48] M. Fredrikson and B. Livshits. ZØ: An optimizing distributing zero-knowledge compiler. In USENIX Security, Aug. 2014.</li>

      <li>[49] E. Fujisaki and T. Okamoto. Statistical zero knowledge protocols to prove modular polynomial relations. In CRYPTO, Aug. 1997.</li>

      <li>[50] R. Gennaro, C. Gentry, B. Parno, and M. Raykova. Quadratic span programs and succinct NIZKs without PCPs. In EUROCRYPT, 2013.</li>

      <li>[51] I. Giacomelli, J. Madsen, and C. Orlandi. ZKBoo: Faster zero-knowledge for Boolean circuits. In USENIX Security, Aug. 2016.</li>

      <li>[52] O. Goldreich and A. Kahan. How to construct constant-round zero-knowledge proof systems for NP. J. Cryptology, 9(3):167–190, 1996.</li>

      <li>[53] O. Goldreich, S. Micali, and A. Wigderson. Proofs that yield nothing but their validity or all languages in NP have zero-knowledge proof systems. J. ACM, 38(3):690–728, 1991.</li>

      <li>[54] S. Goldwasser, Y. T. Kalai, and G. N. Rothblum. Delegating computation: Interactive proofs for muggles. J. ACM, 62(4):27:1–27:64, Aug. 2015. Preliminary version STOC 2008.</li>

      <li>[55] S. Goldwasser, S. Micali, and C. Rackoff. The knowledge complexity of interactive proof systems. SIAM J. Computing, 18(1):186–208, 1989.</li>

      <li>[56] J. Groth. Simulation-sound nizk proofs for a practical language and constant size group signatures. In ASIACRYPT, Dec. 2006.</li>

      <li>[57] J. Groth. Linear algebra with sub-linear zero-knowledge arguments. In CRYPTO, Aug. 2009.</li>

      <li>[58] J. Groth. Short pairing-based non-interactive zero-knowledge arguments. In ASIACRYPT, 2010.</li>

      <li>[59] J. Groth and Y. Ishai. Sub-linear zero-knowledge argument for correctness of a shuffle. In EUROCRYPT, Apr. 2008.</li>

      <li>[60] J. Groth and A. Sahai. Efficient non-interactive proof systems for bilinear groups. In EUROCRYPT, Apr. 2008.</li>

      <li>[61] J. Håstad, R. Impagliazzo, L. A. Levin, and M. Luby. A pseudorandom generator from any one-way function. SIAM J. Computing, 28(4):1364–1396, 1999.</li>

      <li>[62] S. Hohenberger, S. Myers, R. Pass, and abhi shelat. ANONIZE: A large-scale anonymous survey system. In IEEE S&P, May 2014.</li>

      <li>[63] Hyrax reference implementation. https://github.com/hyraxZK.</li>

      <li>[64] Y. Ishai, E. Kushilevitz, and R. Ostrovsky. Efficient arguments without short PCPs. In IEEE CCC, June 2007.</li>

      <li>[65] Y. Ishai, E. Kushilevitz, R. Ostrovsky, and A. Sahai. Zero-knowledge from secure multiparty computation. In STOC, 2007.</li>

      <li>[66] A. Kate, G. M. Zaverucha, and I. Goldberg. Constant-size commitments to polynomials and their applications. In ASIACRYPT, Dec. 2010.</li>

      <li>[67] J. Kilian. A note on efficient zero-knowledge proofs and arguments (extended abstract). In STOC, May 1992.</li>

      <li>[68] J. Kilian. Improved efficient arguments (preliminary version). In CRYPTO, pages 311–324, Aug. 1995.</li>

      <li>[69] A. E. Kosba, D. Papadopoulos, C. Papamanthou, M. F. Sayed, E. Shi, and N. Triandopoulos. TacoSer: Faster verifiable set computations. In USENIX Security, Aug. 2014.</li>

      <li>[70] B. Libert, S. Ramanna, and M. Yung. Functional commitment schemes: From polynomial commitments to pairing-based accumulators from simple assumptions. In ICALP, July 2016.</li>

      <li>[71] libsnark. https://github.com/scipr-lab/libsnark.</li>

      <li>[72] libSTARK. https://github.com/elibensasson/libSTARK.</li>

      <li>[73] Y. Lindell. Parallel coin-tossing and constant-round secure two-party computation. J. Cryptology, 16(3):143–184, 2003.</li>

      <li>[74] H. Lipmaa. Progression-free sets and sublinear pairing-based non-interactive zero-knowledge arguments. In IACR TCC, 2011.</li>

      <li>[75] C. Lund, L. Fortnow, H. J. Karloff, and N. Nisan. Algebraic methods for interactive proof systems. J. ACM, 39(4):859–868, Oct. 1992.</li>

      <li>[76] U. Maurer. Unifying zero-knowledge proofs of knowledge. In AFRICACRYPT, June 2009.</li>

      <li>[77] R. C. Merkle. A digital signature based on a conventional encryption function. In CRYPTO, Aug. 1987.</li>

      <li>[78] S. Micali. Computationally sound proofs. SIAM J. Computing, 30(4):1253–1298, 2000.</li>

      <li>[79] MIRACL crypto SDK. https://libraries.docs.miracl.com/.</li>

      <li>[80] M. Naor. Bit commitment using pseudorandomness. J. Cryptology, 4(2):151–158, 1991.</li>

      <li>[81] A. Naveh and E. Tromer. PhotoProof: Cryptographic image authentication for any set of permissible transformations. In IEEE S&P, May 2016.</li>

      <li>[82] A. V. Oppenheim and A. S. Willsky. Signals and Systems. Pearson, 1996.</li>

      <li>[83] C. Papamanthou, E. Shi, and R. Tamassia. Signatures of correct computation. In IACR TCC, Mar. 2013.</li>

      <li>[84] B. Parno, C. Gentry, J. Howell, and M. Raykova. Pinocchio: Nearly practical verifiable computation. In IEEE S&P, May 2013.</li>

      <li>[85] T. P. Pedersen. Non-interactive and information-theoretic secure verifiable secret sharing. In CRYPTO, Aug. 1991.</li>

      <li>[86] Pepper project. https://github.com/pepper-project.</li>

      <li>[87] Reference implementation of the Picnic post-quantum signature scheme. https://github.com/Microsoft/Picnic.</li>

      <li>[88] N. Pippenger. On the evaluation of powers and monomials. SIAM J. Computing, 9(2):230–250, 1980.</li>

      <li>[89] A. Poelstra. Updates on confidential transactions efficiency. Sent to the bitcoin-dev email list. https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-December/015346.html.</li>

      <li>[90] D. Pointcheval and J. Stern. Security proofs for signature schemes. In</li>

    </ul>

    <p class="text-gray-300">EUROCRYPT, May 1996.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[91] PyPy. https://pypy.org.</li>

      <li>[92] O. Reingold, G. N. Rothblum, and R. D. Rothblum. Constant-round interactive proofs for delegating computation. In STOC, June 2016.</li>

      <li>[93] SageMath. http://www.sagemath.org/.</li>

      <li>[94] A. Sahai. Non-malleable non-interactive zero knowledge and adaptive chosen-ciphertext security. In FOCS, Oct. 1999.</li>

      <li>[95] C. P. Schnorr. Efficient signature generation by smart cards. J. Cryptology, 4(3):161–174, 1991.</li>

      <li>[96] S. Setty, B. Braun, V. Vu, A. J. Blumberg, B. Parno, and M. Walfish. Resolving the conflict between generality and plausibility in verified computation. In EuroSys, Apr. 2013.</li>

      <li>[97] S. Setty, R. McPherson, A. J. Blumberg, and M. Walfish. Making argument systems for outsourced computation practical (sometimes). In NDSS, Feb. 2012.</li>

      <li>[98] S. Setty, V. Vu, N. Panpalia, B. Braun, A. J. Blumberg, and M. Walfish. Taking proof-based verified computation a few steps closer to practicality. In USENIX Security, Aug. 2012.</li>

      <li>[99] V. Shoup. NTL: A library for doing number theory. http://www.shoup.net/ntl/.</li>

      <li>[100] E. G. Straus. Addition chains of vectors (problem 5125). Amer. Math. Monthly, 70:806–808, 1964.</li>

      <li>[101] O. Tange. GNU Parallel: The command-line power tool. ;login: The USENIX Magazine, 36(1):42–47, 2011.</li>

      <li>[102] J. Thaler. Time-optimal interactive proofs for circuit evaluation. In CRYPTO, Aug. 2013. Full version: https://arxiv.org/abs/1304.3812.</li>

      <li>[103] J. Thaler. A note on the GKR protocol. http://people.seas.harvard.edu/~jthaler/GKRNote.pdf, 2015.</li>

      <li>[104] J. Thaler, M. Roberts, M. Mitzenmacher, and H. Pfister. Verifiable computation with massively parallel interactive proofs. In USENIX HotCloud Workshop, June 2012.</li>

      <li>[105] K. Turkowski. Filters for common resampling tasks. In Graphics Gems, pages 147–165. Academic Press, 1990.</li>

      <li>[106] M. Venkitasubramaniam. Personal communication, 2018.</li>

      <li>[107] V. Vu, S. Setty, A. J. Blumberg, and M. Walfish. A hybrid architecture for interactive verifiable computation. In IEEE S&P, May 2013.</li>

      <li>[108] R. S. Wahby, M. Howald, S. Garg, abhi shelat, and M. Walfish. Verifiable ASICs. In IEEE S&P, May 2016.</li>

      <li>[109] R. S. Wahby, Y. Ji, A. J. Blumberg, abhi shelat, J. Thaler, M. Walfish, and T. Wies. Full accounting for verifiable outsourcing. In ACM CCS, Oct. 2017. Full version: https://eprint.iacr.org/2017/242/.</li>

      <li>[110] R. S. Wahby, S. Setty, Z. Ren, A. J. Blumberg, and M. Walfish. Efficient RAM and control flow in verifiable outsourced computation. In NDSS, Feb. 2015.</li>

      <li>[111] ZCash. https://z.cash.</li>

      <li>[112] Y. Zhang, D. Genkin, J. Katz, D. Papadopoulos, and C. Papamanthou. vSQL: Verifying arbitrary SQL queries over dynamic outsourced databases. In IEEE S&P, May 2017.</li>

      <li>[113] Y. Zhang, D. Genkin, J. Katz, D. Papadopoulos, and C. Papamanthou. A zero-knowledge version of vSQL. Cryptology ePrint Archive, Report 2017/1146, 2017.</li>

      <li>[114] Y. Zhang, D. Genkin, J. Katz, D. Papadopoulos, and C. Papamanthou. vRAM: Faster verifiable RAM with program-independent preprocessing. In IEEE S&P, May 2018.</li>

      <li>[115] ZKBoo. https://github.com/Sobuno/ZKBoo.</li>

    </ul>

    <p class="text-gray-300">Definitions: Let  <span class="math">\\mathcal{G}</span>  be a (multiplicative) cyclic group of prime order  <span class="math">q_{\\mathcal{G}}</span>  with group operation  <span class="math">\\odot</span>  and inverse  <span class="math">\\varnothing</span> .  <span class="math">\\mathcal{V}</span>  publishes generators  <span class="math">g, h \\in \\mathcal{G}</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Com}(m)</span> :  <span class="math">\\mathcal{P}</span>  picks  <span class="math">s \\stackrel{\\mathrm{s}}{\\leftarrow} \\{1, \\ldots, q_{\\mathcal{G}}\\}</span>  and sends  <span class="math">g^{m} \\odot h^{s}</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Open}(\\alpha)</span> :  <span class="math">\\mathcal{P}</span>  sends  <span class="math">(m,s)</span> .  <span class="math">\\mathcal{V}</span>  checks  <span class="math">\\alpha \\stackrel{\\mathrm{s}}{=} g^{m} \\odot h^{s}</span> .</p>

    <p class="text-gray-300">Multi-commitments: For commitments to vectors,  <span class="math">\\mathcal{V}</span>  publishes generators  <span class="math">g_{1},\\ldots ,g_{n},h\\in G</span>  and  <span class="math">\\mathcal{P}</span>  sends</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Com}((m_1,\\ldots ,m_n)) = h^s\\odot \\bigodot i g_i^{m_i}</span></p>

    <p class="text-gray-300">FIGURE 4—The Pedersen commitment scheme.</p>

    <p class="text-gray-300">In this section, we review the Pedersen commitment scheme [85] (Fig. 4) and related protocols.</p>

    <p class="text-gray-300">Theorem 7 ([85]). The Pedersen commitment scheme is a non-interactive commitment scheme assuming the hardness of the discrete logarithm problem in  <span class="math">\\mathcal{G}</span> .</p>

    <p class="text-gray-300">Knowledge of opening. Schnorr [95] shows how  <span class="math">\\mathcal{P}</span>  can give a ZK proof that it knows an  <span class="math">x, r</span>  such that  <span class="math">C_0 = \\operatorname{Com}(x; r)</span> .</p>

    <p class="text-gray-300">proof-of-opening  <span class="math">(C_0)</span></p>

    <p class="text-gray-300">Inputs:  <span class="math">C_0 = g^x \\odot h^r</span> .  <span class="math">\\mathcal{P}</span>  knows  <span class="math">x</span>  and  <span class="math">r</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  picks  <span class="math">t_1, t_2 \\stackrel{\\mathrm{s}}{\\leftarrow} \\{1, \\ldots, q_{\\mathcal{G}}\\}</span>  and sends  <span class="math">\\alpha \\gets g^{t_1} \\odot h^{t_2}</span> .</li>

      <li><span class="math">\\mathcal{V}</span>  sends a challenge  <span class="math">c \\stackrel{\\mathrm{s}}{\\leftarrow} \\{1, \\ldots, q_{\\mathcal{G}}\\}</span> .</li>

      <li><span class="math">\\mathcal{P}</span>  sends  <span class="math">z_{1} \\gets xc + t_{1}</span>  and  <span class="math">z_{2} \\gets rc + t_{2}</span> .</li>

      <li><span class="math">\\mathcal{V}</span>  checks that  <span class="math">g^{z_1} \\odot h^{z_2} \\stackrel{\\mathrm{s}}{=} C_0^c \\odot \\alpha</span> .</li>

    </ol>

    <p class="text-gray-300">Theorem 8 ([95]). proof-of-opening is complete, honest-verifier perfect ZK, and special sound under the discrete log assumption.</p>

    <p class="text-gray-300">Commitment to the same value. Using similar ideas,  <span class="math">\\mathcal{P}</span>  can show in ZK that  <span class="math">C_1 = \\operatorname{Com}(\\nu_1; s_1)</span>  and  <span class="math">C_2 = \\operatorname{Com}(\\nu_2; s_2)</span>  are commitments to the same value, i.e.,  <span class="math">\\nu_1 = \\nu_2</span> . Given  <span class="math">C_u = \\operatorname{Com}(u; s_u)</span>  and a value  <span class="math">\\nu</span> ,  <span class="math">\\mathcal{P}</span>  can also convince  <span class="math">\\mathcal{V}</span>  that  <span class="math">u = \\nu</span> .</p>

    <p class="text-gray-300">proof-of-equality  <span class="math">(C_1,C_2)</span></p>

    <p class="text-gray-300">Inputs:  <span class="math">C_1 = g^{v_1} \\odot h^{s_1}</span>  and  <span class="math">C_2 = g^{v_2} \\odot h^{s_2}</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}</span>  knows  <span class="math">\\nu_{1} = \\nu_{2}, s_{1}</span> , and  <span class="math">s_{2}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  picks  <span class="math">r \\stackrel{\\mathrm{s}}{\\leftarrow} \\{1, \\ldots, q_{\\mathcal{G}}\\}</span>  and sends  <span class="math">\\alpha \\gets h^r</span> .</li>

      <li><span class="math">\\mathcal{V}</span>  sends a challenge  <span class="math">c \\stackrel{\\mathrm{s}}{\\leftarrow} \\{1, \\ldots, q_{\\mathcal{G}}\\}</span> .</li>

      <li><span class="math">\\mathcal{P}</span>  sends  <span class="math">z\\gets c\\cdot (s_1 - s_2) + r</span></li>

      <li><span class="math">\\mathcal{V}</span>  checks that  <span class="math">h^z\\stackrel {\\mathrm{s}}{=}(c_1\\varnothing c_2)^c\\odot \\alpha</span></li>

    </ol>

    <p class="text-gray-300">Theorem 9 (Folklore). proof-of-equality is complete, honest-verifier perfect zero-knowledge, and special sound under the discrete log assumption.</p>

    <p class="text-gray-300">Figure 5 gives a protocol in which  <span class="math">\\mathcal{P}</span>  convinces  <span class="math">\\mathcal{V}</span>  that it has openings to three Pedersen commitments having a product rela</p>

    <p class="text-gray-300">proof-of-product(X,Y,Z)</p>

    <p class="text-gray-300">Inputs:  <span class="math">X = g^{x} \\odot h^{r_{X}}</span> ,  <span class="math">Y = g^{y} \\odot h^{r_{Y}}</span> , and  <span class="math">Z = g^{x \\cdot y} \\odot h^{r_{Z}}</span> .  <span class="math">\\mathcal{P}</span>  knows  <span class="math">x, y, r_{X}, r_{Y}</span> , and  <span class="math">r_{Z}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  picks  <span class="math">b_{1},\\ldots ,b_{5}\\stackrel {\\mathrm{s}}{\\leftarrow}\\{1,\\ldots ,q_{\\mathcal{G}}\\}</span>  and sends</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\alpha \\leftarrow g ^ {b _ {1}} \\odot h ^ {b _ {2}} \\quad \\beta \\leftarrow g ^ {b _ {3}} \\odot h ^ {b _ {4}} \\quad \\delta \\leftarrow X ^ {b _ {3}} \\odot h ^ {b _ {5}}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  sends a challenge  <span class="math">c \\stackrel{\\mathrm{s}}{\\leftarrow} \\{1, \\ldots, q_{\\mathcal{G}}\\}</span></li>

      <li><span class="math">\\mathcal{P}</span>  sends</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">z _ {1} \\leftarrow b _ {1} + c \\cdot x \\quad z _ {2} \\leftarrow b _ {2} + c \\cdot r _ {x} \\quad z _ {3} \\leftarrow b _ {3} + c \\cdot y</span></div>

    <div class="my-4 text-center"><span class="math-block">z _ {4} \\leftarrow b _ {4} + c \\cdot r _ {y} \\quad z _ {5} \\leftarrow b _ {5} + c \\left(r _ {z} - r _ {x} y\\right)</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  checks that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\alpha \\odot X ^ {c} \\stackrel {\\mathrm {s}} {=} g ^ {z _ {1}} \\odot h ^ {z _ {2}} \\tag {7}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\beta \\odot Y ^ {c} \\stackrel {\\mathrm {s}} {=} g ^ {z _ {3}} \\odot h ^ {z _ {4}} \\tag {8}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\delta \\odot Z ^ {c} \\stackrel {\\mathrm {s}} {=} X ^ {z _ {3}} \\odot h ^ {z _ {5}} \\tag {9}</span></div>

    <p class="text-gray-300">FIGURE 5—ZK proof of knowledge for a product relationship (§A.1).</p>

    <p class="text-gray-300">tionship. This is folklore; for example, we know that Maurer [76] describes a very similar protocol.</p>

    <p class="text-gray-300">Theorem 10. Given commitments  <span class="math">X, Y</span> , and  <span class="math">Z</span> , proof-of-product proves that  <span class="math">Z</span>  is a commitment to the product of the values committed in  <span class="math">X</span>  and  <span class="math">Y</span> . This protocol is complete, honest-verifier perfect zero-knowledge, and special sound under the discrete log assumption.</p>

    <p class="text-gray-300">Proof. Completeness. It is easy to check that if the prover sends all values as prescribed, then the first two equations hold. Checking that the third equation holds is a straightforward (if slightly tedious) calculation:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\delta \\odot Z ^ {c} = X ^ {b _ {3}} \\odot h ^ {b _ {5}} \\odot \\left(g ^ {x y} \\odot h ^ {r _ {z}}\\right) ^ {c} = X ^ {b _ {3}} \\odot g ^ {x y c} \\odot h ^ {b _ {5} + r _ {z} \\cdot c} \\\\ = X ^ {b _ {3}} \\odot \\left(\\left(g ^ {x} \\odot h ^ {r _ {x}}\\right) ^ {y c} \\odot h ^ {- \\left(r _ {x} \\odot y c\\right)}\\right) \\odot h ^ {b _ {5} + r _ {z} \\cdot c} \\\\ = X ^ {b _ {3}} \\odot X ^ {y c} \\odot h ^ {b _ {5} + c \\left(r _ {z} - r _ {x} y\\right)} \\\\ = X ^ {z _ {3}} \\odot h ^ {z _ {5}}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Special soundness. To show that the protocol is special sound, for a given theorem statement  <span class="math">(X,Y,Z)</span> , let  <span class="math">(\\alpha,\\beta,\\delta)</span>  be a first message, and let  <span class="math">(c,z_1,\\ldots,z_5)</span>  and  <span class="math">(c&#x27;,z_1&#x27;,\\ldots,z_5&#x27;)</span>  be two transcripts such that the verification equations above hold,  <span class="math">c \\neq c&#x27;</span> .</p>

    <p class="text-gray-300">Define the variables</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} x = \\frac {z _ {1} - z _ {1} ^ {\\prime}}{c - c ^ {\\prime}} \\quad r _ {x} = \\frac {z _ {2} - z _ {2} ^ {\\prime}}{c - c ^ {\\prime}} \\\\ y = \\frac {z _ {3} - z _ {3} ^ {\\prime}}{c - c ^ {\\prime}} \\quad r _ {y} = \\frac {z _ {4} - z _ {4} ^ {\\prime}}{c - c ^ {\\prime}} \\quad w = \\frac {z _ {5} - z _ {5} ^ {\\prime}}{c - c ^ {\\prime}} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">We first show that the values  <span class="math">(x, r_x), (y, r_y)</span> , are proper openings of the commitments to  <span class="math">X</span>  and  <span class="math">Y</span> .</p>

    <p class="text-gray-300">Recall the following two equations hold:</p>

    <div class="my-4 text-center"><span class="math-block">\\alpha \\odot X ^ {c} = g ^ {z _ {1}} \\odot h ^ {z _ {2}} \\quad \\alpha \\odot X ^ {c ^ {\\prime}} = g ^ {z _ {1} ^ {\\prime}} \\odot h ^ {z _ {2} ^ {\\prime}}</span></div>

    <p class="text-gray-300">It follows by dividing the two equations, that</p>

    <div class="my-4 text-center"><span class="math-block">X ^ {c - c ^ {\\prime}} = g ^ {z _ {1} - z _ {1} ^ {\\prime}} \\odot h ^ {z _ {2} - z _ {2} ^ {\\prime}}</span></div>

    <p class="text-gray-300">and moreover that</p>

    <div class="my-4 text-center"><span class="math-block">X = g ^ {\\left(z _ {1} - z _ {1} ^ {\\prime}\\right) / \\left(c - c ^ {\\prime}\\right)} \\odot h ^ {\\left(z _ {2} - z _ {2} ^ {\\prime}\\right) / \\left(c - c ^ {\\prime}\\right)} = g ^ {x} \\odot h ^ {r _ {x}} \\tag {10}</span></div>

    <p class="text-gray-300">which shows that  <span class="math">(x, r_x)</span>  is indeed an opening for commitment  <span class="math">X</span> . The same follows for  <span class="math">Y</span> . Finally, since</p>

    <div class="my-4 text-center"><span class="math-block">\\delta \\odot Z ^ {c} = X ^ {z _ {3}} \\odot h ^ {z _ {5}} \\quad \\delta \\odot Z ^ {c ^ {\\prime}} = X ^ {z _ {3} ^ {\\prime}} \\odot h ^ {z _ {5} ^ {\\prime}}</span></div>

    <p class="text-gray-300">it follows again by dividing that</p>

    <div class="my-4 text-center"><span class="math-block">Z = X ^ {\\left(z _ {3} - z _ {3} ^ {\\prime}\\right) / \\left(c - c ^ {\\prime}\\right)} \\odot h ^ {\\left(z _ {5} - z _ {5} ^ {\\prime}\\right) / \\left(c - c ^ {\\prime}\\right)} = X ^ {y} \\odot h ^ {w}</span></div>

    <p class="text-gray-300">Substituting from (10), we have</p>

    <div class="my-4 text-center"><span class="math-block">Z = \\left(g ^ {x} \\odot h ^ {r _ {x}}\\right) ^ {y} \\odot h ^ {w} = g ^ {x y} \\odot h ^ {r _ {x} y + w}</span></div>

    <p class="text-gray-300">which shows that  <span class="math">Z</span>  can be opened as the product  <span class="math">(xy, r_x y + w)</span> .</p>

    <p class="text-gray-300"><strong>Perfect ZK.</strong> Here, we show an honest-verifier simulation. Using Fiat-Shamir [45] or Cramer-Damgård [39] techniques, one can compile the protocol into a malicious-verifier ZK protocol.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The simulator  <span class="math">S(X,Y,Z,c)</span> , on input  <span class="math">X,Y,Z</span>  and a random challenge  <span class="math">c</span>  does the following:</li>

    </ul>

    <p class="text-gray-300">Sample  <span class="math">z_{1},\\ldots ,z_{5}\\stackrel {s}{\\leftarrow}\\{1,\\ldots ,q_{\\mathcal{G}}\\}</span>  , then compute:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\alpha \\leftarrow g ^ {z _ {1}} \\odot h ^ {z _ {2}} \\oslash X ^ {c} \\quad \\beta \\leftarrow g ^ {z _ {3}} \\odot h ^ {z _ {4}} \\oslash Y ^ {c} \\\\ \\delta \\leftarrow X ^ {z _ {3}} \\odot h ^ {z _ {5}} \\oslash Z ^ {c} \\\\ \\end{array}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Then the simulator outputs the transcript</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">(\\alpha , \\beta , \\delta), c, z _ {1}, z _ {2}, z _ {3}, z _ {4}, z _ {5}</span></div>

    <p class="text-gray-300">By inspection, the transcript satisfies equations (7)-(9) above.</p>

    <p class="text-gray-300">It remains to show that the distribution over transcripts produced by  <span class="math">S</span>  and those produced by the honest prover and honest verifier are identical. To show this, we show a one-to-one mapping between every transcript produced by the honest prover and a transcript produced by the Simulator. Fix a theorem statement  <span class="math">(X,Y,Z)</span>  having the correct product relation, a witness, and a challenge  <span class="math">c</span> . The Prover's random coins consist of the 5 values  <span class="math">b_{1}, b_{2}, b_{3}, b_{4}, b_{5}</span> . Given the fixed values, each 5-tuple uniquely defines  <span class="math">(\\alpha, \\beta, \\delta)</span>  and the values  <span class="math">z_{1}, z_{2}, z_{3}, z_{4}, z_{5}</span> . This 5-tuple is chosen uniformly over  <span class="math">\\mathbb{Z}_{q_{\\mathcal{G}}}^{5}</span> . Likewise, the simulator  <span class="math">S</span>  uses random coins  <span class="math">z_{1}&#x27;, z_{2}&#x27;, z_{3}&#x27;, z_{4}&#x27;, z_{5}&#x27;</span> , again chosen uniformly over the same probability space. When  <span class="math">S</span>  picks the random coins  <span class="math">z_{1} = b_{1} + c \\cdot x, \\ldots</span> , then  <span class="math">S</span>  produces exactly the same transcript  <span class="math">(\\alpha, \\beta, \\delta), c, (z_{1}, z_{2}, z_{3}, z_{4}, z_{5})</span> . Thus, for every possible transcript, both the honest prover and simulator produce that transcript with the same probability.</p>

    <p class="text-gray-300">proof-of-dot-prod(  <span class="math">\\xi ,\\tau ,\\vec{a})</span></p>

    <p class="text-gray-300">Inputs: Commitments  <span class="math">\\xi = \\operatorname{Com}(\\vec{x}; r_{\\xi})</span> ,  <span class="math">\\tau = \\operatorname{Com}(y; r_{\\tau})</span> , and a vector  <span class="math">\\vec{a}</span> , where  <span class="math">\\vec{x}, \\vec{a} \\in \\mathbb{Z}_{q_{\\mathcal{G}}}^{n}</span>  and  <span class="math">y = \\langle \\vec{x}, \\vec{a} \\rangle \\in \\mathbb{Z}_{q_{\\mathcal{G}}}</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}</span>  knows  <span class="math">\\vec{x}, r_{\\xi}, y,</span>  and  <span class="math">r_{\\tau}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  samples the vector  <span class="math">\\vec{d} \\stackrel{s}{\\leftarrow} \\{1, \\ldots, q_{\\mathcal{G}}\\}^n</span>  and the values  <span class="math">r_{\\beta}, r_{\\delta} \\stackrel{s}{\\leftarrow} \\{1, \\ldots, q_{\\mathcal{G}}\\}</span>  and sends</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\delta \\leftarrow \\operatorname {C o m} (\\vec {d}; r _ {\\delta}) = h ^ {r _ {\\delta}} \\odot \\bigodot_ {i} g _ {i} ^ {d _ {i}} \\tag {11}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\beta \\leftarrow \\operatorname {C o m} (\\langle \\vec {a}, \\vec {d} \\rangle ; r _ {\\beta}) = g ^ {\\langle \\vec {a}, \\vec {d} \\rangle} \\odot h ^ {r _ {\\beta}} \\tag {12}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  sends a challenge  <span class="math">c \\stackrel{s}{\\leftarrow} \\{1, \\ldots, q_{\\mathcal{G}}\\}</span> .</li>

      <li><span class="math">\\mathcal{P}</span>  sends</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\vec {z} \\leftarrow c \\cdot \\vec {x} + \\vec {d}, \\quad z _ {\\delta} \\leftarrow c \\cdot r _ {\\xi} + r _ {\\delta}, \\quad z _ {\\beta} \\leftarrow c \\cdot r _ {\\tau} + r _ {\\beta}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  checks that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\xi^ {c} \\odot \\delta \\stackrel {s} {=} \\operatorname {C o m} (\\vec {z}; z _ {\\delta}) = h ^ {z _ {\\delta}} \\odot \\bigodot_ {i} g _ {i} ^ {z _ {i}} \\tag {13}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\tau^ {c} \\odot \\beta \\stackrel {\\tau} {=} \\operatorname {C o m} (\\langle \\vec {z}, \\vec {a} \\rangle ; z _ {\\beta}) = g ^ {\\langle \\vec {z}, \\vec {a} \\rangle} \\odot h ^ {z _ {\\beta}} \\tag {14}</span></div>

    <p class="text-gray-300">FIGURE 6—ZK vector dot-product proof (§A.2).</p>

    <h2 id="sec-42" class="text-2xl font-bold">A.2 Proving a dot-product relationship</h2>

    <p class="text-gray-300">In the protocol of Figure 6,  <span class="math">\\mathcal{P}</span>  convinces  <span class="math">\\mathcal{V}</span>  that it has openings to one multi-commitment  <span class="math">\\xi = \\operatorname{Com}(\\vec{x}; r_{\\xi})</span>  and one scalar commitment  <span class="math">\\tau = \\operatorname{Com}(y; r_{\\tau})</span>  such that, for a supplied vector  <span class="math">\\vec{a}</span>  it holds that  <span class="math">y = \\langle \\vec{x}, \\vec{a} \\rangle</span> . Intuitively, this protocol works because</p>

    <div class="my-4 text-center"><span class="math-block">\\langle \\vec {z}, \\vec {a} \\rangle = \\langle c \\vec {x} + \\vec {d}, \\vec {a} \\rangle = c \\langle \\vec {x}, \\vec {a} \\rangle + \\langle \\vec {d}, \\vec {a} \\rangle = c y + \\langle \\vec {d}, \\vec {a} \\rangle</span></div>

    <p class="text-gray-300">The above identity is verified in the exponent in Equation (14).</p>

    <p class="text-gray-300"><strong>Theorem 11.</strong> The protocol of Figure 6 is complete, honest-verifier perfect zero-knowledge, and special sound under the discrete log assumption.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Completeness. If both the prover and the verifier follow the protocol correctly both checks will succeed because</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\xi^ {c} \\odot \\delta = \\left(h ^ {r _ {\\xi}} \\odot \\bigodot_ {i} g _ {i} ^ {x _ {i}}\\right) ^ {c} \\odot h ^ {r _ {\\delta}} \\odot \\bigodot_ {i} g _ {i} ^ {d _ {i}} \\\\ = h ^ {c \\cdot r _ {\\xi} + r _ {\\delta}} \\odot \\bigodot_ {i} g _ {i} ^ {c \\cdot x _ {i} + d _ {i}} = h ^ {z _ {\\delta}} \\odot \\bigodot_ {i} g _ {i} ^ {z _ {i}} \\\\ \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\tau^ {c} \\odot \\beta = \\left(h ^ {r _ {\\tau}} \\odot g ^ {y}\\right) ^ {c} \\odot g ^ {\\vec {a} \\cdot \\vec {d}} \\odot h ^ {r _ {\\beta}} = h ^ {c \\cdot r _ {\\tau} + r _ {\\beta}} \\odot g ^ {c y + \\langle \\vec {a}, \\vec {d} \\rangle} \\\\ = h ^ {z _ {\\beta}} \\odot g ^ {c \\cdot \\langle \\vec {x}, \\vec {a} \\rangle + \\langle \\vec {d}, \\vec {a} \\rangle} = h ^ {z _ {\\beta}} \\odot g ^ {\\vec {z} \\cdot \\vec {a}} \\\\ \\end{array}</span></div>

    <p class="text-gray-300"><strong>Special soundness.</strong> For a given theorem instance  <span class="math">(\\xi, \\tau, \\vec{a})</span> , let  <span class="math">(\\delta, \\beta)</span>  be a first message, and let  <span class="math">(c, \\vec{z}, z_{\\delta}, z_{\\beta})</span>  and  <span class="math">(c&#x27;, \\vec{z}&#x27;, z_{\\delta}&#x27;, z_{\\beta}&#x27;)</span>  be two valid transcripts. Since both transcripts satisfy both of  <span class="math">\\mathcal{V}</span> 's</p>

    <p class="text-gray-300">checks, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\xi^{c} \\odot \\delta = h^{z_{\\delta}} \\odot \\bigodot_{i} g_{i}^{z_{i}} \\\\ \\xi^{c&#x27;} \\odot \\delta = h^{z_{\\delta}&#x27;} \\odot \\bigodot_{i} g_{i}^{z_{i}&#x27;} \\\\ \\tau^{c} \\odot \\beta = h^{z_{\\beta}} \\odot g^{\\langle \\vec{z}, \\vec{a} \\rangle} \\\\ \\tau^{c&#x27;} \\odot \\beta = h^{z_{\\beta}&#x27;} \\odot g^{\\langle \\vec{z}&#x27;, \\vec{a} \\rangle} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Dividing the top by the bottom in each pair yields</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\xi = h^{(z_{\\delta} - z_{\\delta}&#x27;) / (c - c&#x27;)} \\odot \\bigodot_{i} g_{i}^{(z_{i} - z_{i}&#x27;) / (c - c&#x27;)} \\\\ \\tau = h^{z_{\\beta} - z_{\\beta}&#x27; / (c - c&#x27;)} \\odot g^{(\\vec{z} - \\vec{z}&#x27;) \\cdot \\vec{a} / (c - c&#x27;)} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">which implies that <span class="math">\\vec{x} = (\\vec{z} - \\vec{z}&#x27;) / (c - c&#x27;)</span>, that <span class="math">r_{\\xi} = (z_{\\delta} - z_{\\delta}&#x27;) / (c - c&#x27;)</span>, and that <span class="math">r_{\\tau} = (z_{\\beta} - z_{\\beta}&#x27;) / (c - c&#x27;)</span>.</p>

    <p class="text-gray-300"><strong>Honest-verifier perfect zero-knowledge.</strong> (Analogous to the ZK proof for protocol for proving product of commitment.) The zero-knowledge property follows from standard reverse-ordering techniques. In particular, the simulator first picks <span class="math">c</span>, then <span class="math">\\vec{z}, z_{\\delta}, z_{\\beta}</span>, and finally computes an appropriate first message <span class="math">\\delta, \\beta</span> which satisfies check equations (13) and (14).</p>

    <p class="text-gray-300">The simulator <span class="math">S</span>, on input the theorem instance <span class="math">(\\xi, \\tau, \\vec{a})</span> and a challenge <span class="math">c</span> does the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample <span class="math">\\vec{z}&#x27; \\nleftarrow \\mathbb{Z}_{q_{\\mathcal{G}}}^{n}</span> and <span class="math">z_{\\delta}&#x27;, z_{\\beta}&#x27; \\nleftarrow \\mathbb{Z}_{q_{\\mathcal{G}}}</span></li>

      <li>Produce values</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\delta \\leftarrow \\left(h^{z_{\\delta}&#x27;} \\odot \\bigodot_{i} g_{i}^{z_{i}&#x27;}\\right) \\oslash \\xi^{c} \\quad (15) \\\\ \\beta \\leftarrow \\left(g^{\\langle \\vec{z}&#x27;, \\vec{a} \\rangle} \\odot h^{z_{\\beta}&#x27;}\\right) \\oslash \\tau^{c} \\quad (16) \\\\ \\end{array}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output the transcript <span class="math">(\\delta, \\beta), c, (\\vec{z}, z_{\\delta}, z_{\\beta})</span>.</li>

    </ul>

    <p class="text-gray-300">By inspection, one can certify that the transcript passes both checks of the verifier and the verifier will accept it.</p>

    <p class="text-gray-300">It remains to show that the distribution over transcripts produced by <span class="math">S</span> and those produced by the honest verifier and honest prover are identical. To show this, we show a one-to-one mapping between every transcript produced by the honest prover and a transcript produced by the simulator. We fix a theorem statement <span class="math">(\\xi, \\tau, \\vec{a})</span>, a witness <span class="math">w = (\\vec{x}, r_{\\xi}, r_{\\tau})</span> and a challenge <span class="math">c</span>. The prover's random coins consist of the <span class="math">(n + 2)</span>-tuple <span class="math">(\\vec{d}, r_{\\delta}, r_{\\beta})</span>. Given the fixed statement, witness, and challenge, each <span class="math">(n + 2)</span>-tuple uniquely determines <span class="math">(\\delta, \\beta)</span> and the values <span class="math">\\vec{z}, z_{\\delta}, z_{\\beta}</span>. This <span class="math">(n + 2)</span>-tuple is chosen uniformly over <span class="math">\\mathbb{Z}_{q_{\\mathcal{G}}}^{n + 2}</span>.</p>

    <p class="text-gray-300">Likewise, the simulator <span class="math">S</span> uses an <span class="math">(n + 2)</span>-tuple <span class="math">\\vec{z}&#x27;, z_{\\delta}&#x27;, z_{\\beta}&#x27;</span> chosen uniformly at random over the probability space. We show a one-to-one mapping between the prover's coins and the simulator's output. In particular, when</p>

    <div class="my-4 text-center"><span class="math-block">M(\\vec{z}&#x27;) = \\vec{z&#x27;} - c \\cdot \\vec{x} \\quad M(z_{\\delta}&#x27;) = z_{\\delta}&#x27; - c \\cdot r_{\\xi} \\quad M(z_{\\beta}&#x27;) = z_{\\beta}&#x27; - c \\cdot r_{\\tau}</span></div>

    <p class="text-gray-300">By inspection, this mapping is one-to-one, and when the prover runs with coins <span class="math">M(\\vec{z}&#x27;, z_{\\delta}&#x27;, z_{\\beta}&#x27;)</span>, it produces the same transcript as</p>

    <pre><code class="language-text">prooflog-of-dot-prod(ξ, τ, $\\vec{a}$)
Inputs: $\\xi = \\operatorname{Com}_{\\vec{g}}(\\vec{x}; r_{\\xi}) = h^{r_{\\xi}} \\odot \\bigodot_{i=1}^{n} g_i^{x_i}$,
$\\tau = \\operatorname{Com}(y; r_{\\tau}) = g^y \\odot h^{r_{\\tau}}$. $\\vec{x}, \\vec{a} \\in \\mathbb{Z}_{q_{\\mathcal{G}}}^n$, $y, r_{\\xi}, r_{\\tau} \\in \\mathbb{Z}_{q_{\\mathcal{G}}}$.
$\\mathcal{P}$ knows $\\vec{x}, y, r_{\\xi}$, and $r_{\\tau}$.</code></pre>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\Upsilon = \\xi \\odot \\tau = h^{r_{\\Upsilon}} \\odot g^{y} \\odot \\bigodot_{i=1}^{n} g_{i}^{x_{i}}</span> where <span class="math">r_{\\Upsilon} = r_{\\tau} + r_{\\xi}</span>. <span class="math">(\\hat{\\Upsilon}, \\hat{a}, \\hat{g}) \\gets</span> bullet-reduce <span class="math">(\\Upsilon, \\vec{a}, \\vec{g})</span> (see Fig. 8).</li>

    </ol>

    <p class="text-gray-300">At this point, <span class="math">n = 1</span> and <span class="math">\\hat{\\Upsilon} = \\hat{g}^{\\hat{x}} \\odot g^{\\hat{y}} \\odot h^{\\hat{r}_{\\Upsilon}}</span> where <span class="math">\\hat{y} = \\hat{x} \\cdot \\hat{a}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span> samples <span class="math">d, r_{\\delta}, r_{\\beta} \\nleftarrow \\{1, \\dots, q_{\\mathcal{G}}\\}</span> and sends</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\delta \\leftarrow \\operatorname{Com}_{\\hat{g}}(d; r_{\\delta}) = \\hat{g}^{d} \\odot h^{r_{\\delta}} \\\\ \\beta \\leftarrow \\operatorname{Com}_{g}(d; r_{\\beta}) = g^{d} \\odot h^{r_{\\beta}} \\\\ \\end{array}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span> chooses and sends <span class="math">c \\nleftarrow \\{1, \\dots, q_{\\mathcal{G}}\\}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span> sends <span class="math">z_1 \\gets d + c \\cdot \\hat{y}</span> and <span class="math">z_2 \\gets \\hat{a}(c \\cdot \\hat{r}_{\\Upsilon} + r_{\\beta}) + r_{\\delta}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span> checks that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\left(\\hat{\\Upsilon}^{c} \\odot \\beta\\right)^{\\hat{a}} \\odot \\delta \\stackrel{\\circ}{=} \\left(\\hat{g} \\odot g^{\\hat{a}}\\right)^{\\hat{z}_{2}} \\odot h^{z_{2}} \\tag{17}</span></div>

    <p class="text-gray-300">FIGURE 7—Protocol for dot-product relation based on Bulletproofs [31]. <span class="math">\\operatorname{Com}_{\\vec{g}}</span> indicates a multi-commitment over generators <span class="math">\\vec{g}</span>.</p>

    <p class="text-gray-300">the simulator. Thus, the output distribution of <span class="math">S</span> is identical to that of the prover on this instance. This property holds for all instances, and any challenge <span class="math">c</span>, which concludes the proof.</p>

    <h2 id="sec-43" class="text-2xl font-bold">A.3 Dot-product argument from Bulletproofs</h2>

    <p class="text-gray-300">The dot-product argument of Appendix A.2 has communication <span class="math">4 + n</span> elements for a vector of length <span class="math">n</span>. By adapting the Bulletproof recursive reduction of Bünz et al. [31], we reduce this to <span class="math">4 + 2\\log n</span>. Figures 7 and 8 detail this protocol.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As in Appendix A.2, we have <span class="math">\\vec{x}, \\vec{a}</span>, and <span class="math">y = \\langle \\vec{x}, \\vec{a} \\rangle</span>, where $n =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{a}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Given </span>\\vec{a}<span class="math"> and </span>\\Upsilon = \\operatorname{Com}_{\\vec{g}}(\\vec{x}) \\odot \\operatorname{Com}(y)<span class="math">, each recursive call to bullet-reduce produces </span>\\vec{a}'<span class="math"> and </span>\\Upsilon' = \\operatorname{Com}_{\\vec{g}'}(\\vec{x}') \\odot \\operatorname{Com}(y')<span class="math"> such that </span>y' = \\langle \\vec{x}', \\vec{a}' \\rangle$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">After <span class="math">\\log n</span> such recursive calls, we are left with a scalar <span class="math">\\hat{a}</span> and a commitment <span class="math">\\hat{\\Upsilon} = \\hat{g}^{\\hat{x}} g^{\\hat{y}} h^{\\hat{r}_{\\Upsilon}}</span>. <span class="math">\\mathcal{P}</span> can now use a Schnorr proof to convince <span class="math">\\mathcal{V}</span> that <span class="math">\\hat{y} = \\hat{x} \\cdot \\hat{a}</span>. Expanding Equation (17) (Fig. 7),</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left(\\hat{\\Upsilon}^{c} \\odot \\beta\\right)^{\\hat{a}} \\odot \\delta = \\left(\\hat{g}^{c \\cdot \\hat{y}} \\odot g^{c \\cdot \\hat{y}} \\odot h^{c \\cdot \\hat{r}_{\\Upsilon}} \\odot g^{d} \\odot h^{r_{\\beta}}\\right)^{\\vec{a}} \\odot \\delta \\\\ = \\left(\\hat{g}^{c \\cdot \\hat{y}} \\odot g^{c \\cdot \\hat{y} + d} \\odot h^{c \\cdot \\hat{r}_{\\Upsilon} + r_{\\beta}}\\right)^{\\vec{a}} \\odot \\hat{g}^{d} \\odot h^{r_{\\delta}} \\\\ = \\hat{g}^{c \\cdot \\hat{x} \\cdot \\hat{a} + d} \\odot g^{\\hat{a}(c \\cdot \\hat{y} + d)} \\odot h^{\\hat{a}(c \\cdot r_{\\Upsilon} + r_{\\beta}) + r_{\\delta}} \\\\ = \\hat{g}^{c \\cdot \\hat{y} + d} \\odot g^{\\hat{a}(c \\cdot \\hat{y} + d)} \\odot h^{z_{2}} \\\\ = \\left(\\hat{g} \\odot g^{\\hat{a}}\\right)^{\\hat{z}_{1}} \\odot h^{z_{2}} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">In total, <span class="math">\\mathcal{P}</span> sends <span class="math">2\\log n</span> elements during the bullet-reduce calls and 4 elements for the final Schnorr proof. Adapting suggestions by Poelstra [89], <span class="math">\\mathcal{V}</span>'s work computing <span class="math">\\hat{g}</span> can be reduced to one multi-exponentiation of length <span class="math">n</span> and one field inversion, and computing <span class="math">\\hat{\\Upsilon}</span> costs one multi-exponentiation of length <span class="math">1 + 2\\log n</span>.</p>

    <p class="text-gray-300">!<a href="img-12.jpeg">img-12.jpeg</a> FIGURE 8—Reduction step for the protocol of Figure 7.</p>

    <p class="text-gray-300">Lemma 12. The protocol of Figures 7-8 is complete, honest-verifier perfect ZK, and generalized special sound under the discrete log assumption.</p>

    <p class="text-gray-300">Completeness follows from the derivation of Equation (17) above and the completeness of bullet-reduce [31, Thm. 2, Appx. A], and ZK follows from standard reverse-ordering techniques. Generalized special soundness follows from the properties of Schnorr protocols and an argument similar to the proof of [31, Thm. 2, Appx. A]. In total, the extractor requires  <span class="math">n + 2</span>  transcripts.</p>

    <p class="text-gray-300">Proof. Completeness. If the theorem statement</p>

    <div class="my-4 text-center"><span class="math-block">\\left(C _ {0}, \\left(\\alpha_ {1}, \\dots \\alpha_ {n}\\right), \\left(M _ {1}, \\dots , M _ {n + 1}\\right), X, Y, Z\\right)</span></div>

    <p class="text-gray-300">holds, the prover knows openings of the commitments  <span class="math">C_0, (\\alpha_1, \\ldots, \\alpha_n), X, Y, Z</span>  and he sends all values as prescribed, it follows from the correctness of proof-of-product that  <span class="math">X, Y, Z</span></p>

    <p class="text-gray-300">will pass all the checks of that subprocess. Moreover, for all  <span class="math">k</span>  it holds that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Com}((z_{c_{3,k}},z_{c_{2,k}},z_{c_{1,k}},z_{c_{0,k}});z_{\\delta_k})</span></p>

    <div class="my-4 text-center"><span class="math-block">= \\operatorname {C o m} \\left(\\left(c \\cdot c _ {3, k} + d _ {c _ {3, k}}, c \\cdot c _ {2, k} + d _ {c _ {2, k}}, \\right. \\right.</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left. c \\cdot c _ {1, k} + d _ {c _ {1, k}}, c \\cdot c _ {0, k} + d _ {c _ {0, k}}\\right); c \\cdot r _ {\\alpha_ {k}} + r _ {\\delta_ {k}})</span></div>

    <div class="my-4 text-center"><span class="math-block">= \\left(\\operatorname {C o m} \\left(\\left(c _ {3, k}, c _ {2, k}, c _ {1, k}, c _ {0, k}\\right); r _ {\\alpha_ {k}}\\right)\\right) ^ {c} \\odot</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {C o m} \\left(\\left(d _ {c _ {3, k}}, d _ {c _ {2, k}}, d _ {c _ {1, k}}, d _ {c _ {0, k}}\\right); r _ {\\delta_ {k}}\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">= \\alpha_ {k} ^ {c} \\odot \\delta_ {k}</span></div>

    <p class="text-gray-300">It also holds that</p>

    <p class="text-gray-300"><span class="math">(C_0^{\\rho_1}\\odot X^{-J_X}\\odot Y^{-J_Z}\\odot Z^{-J_Z})^c\\odot C</span></p>

    <div class="my-4 text-center"><span class="math-block">= \\operatorname {C o m} \\left(c \\left(\\rho_ {1} \\cdot s _ {0} - J _ {X} \\cdot x - J _ {Y} \\cdot y - J _ {Z} \\cdot z\\right) + \\langle \\vec {J} ^ {*}, \\vec {d} \\rangle ; \\right.</span></div>

    <div class="my-4 text-center"><span class="math-block">c \\left(\\rho_ {1} \\cdot r _ {C _ {0}} - J _ {x} \\cdot r _ {X} - J _ {Y} \\cdot r _ {Y} - J _ {Z} \\cdot r _ {Z}\\right) + r _ {C})</span></div>

    <div class="my-4 text-center"><span class="math-block">= \\operatorname {C o m} \\left(c \\cdot \\langle \\vec {J} ^ {*}, \\vec {\\pi} ^ {*} \\rangle + \\langle \\vec {J} ^ {*}, d \\rangle ; z _ {C}\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">= \\operatorname {C o m} (\\langle \\vec {J} ^ {*}, \\vec {z} \\rangle ; z _ {C})</span></div>

    <p class="text-gray-300">Generalized special soundness. For theorem instance  <span class="math">(C_0, (\\alpha_1, \\ldots, \\alpha_n), (M_1, \\ldots, M_{n+1}), X, Y, Z)</span> , the transcripts:</p>

    <p class="text-gray-300"><span class="math">\\left(\\mathrm{Tr}_{\\mathrm{prod}}, (\\delta_1, \\ldots, \\delta_n), (\\rho_1, \\ldots, \\rho_{n+1}), C, c, (\\vec{z}, \\{z_{\\delta_k}\\}, z_C)\\right)</span></p>

    <p class="text-gray-300"><span class="math">\\left(\\mathrm{Tr}_{\\mathrm{prod}}, (\\delta_1, \\ldots, \\delta_n), (\\rho_1, \\ldots, \\rho_{n+1}), C, c&#x27;, (\\vec{z}&#x27;, \\{z_{\\delta_k}&#x27;\\}, z_C&#x27;)\\right)</span></p>

    <p class="text-gray-300"><span class="math">\\left(\\mathrm{Tr}_{\\mathrm{prod}}^{\\prime}, \\ldots\\right)</span></p>

    <p class="text-gray-300">are sufficient to extract a witness for the statement except with negligible probability, where  <span class="math">\\mathrm{Tr}_{\\mathrm{prod}}</span>  and  <span class="math">\\mathrm{Tr}_{\\mathrm{prod}}^{\\prime}</span>  are transcripts for proof-of-product. In this context, by witness we mean openings to the prover's messages that satisfy the checks that the verifier of  <span class="math">\\mathrm{Gir}^{++}</span>  does during the corresponding invocation of the sum-check protocol.</p>

    <p class="text-gray-300">The extractor proceeds as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Exploiting the first condition checked by the verifier in Figure 1 (Step 7), extract openings for  <span class="math">\\{\\alpha_{k}\\}</span>  via</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\alpha_ {k} ^ {c - c ^ {\\prime}} = \\operatorname {C o m} \\left(\\left(z _ {c _ {3, k}} - z _ {c _ {3, k}} ^ {\\prime}, z _ {c _ {2, k}} - z _ {c _ {2, k}} ^ {\\prime}, \\right. \\right.</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left. z _ {c _ {1, k}} - z _ {c _ {1, k}} ^ {\\prime}, z _ {c _ {0, k}} - z _ {c _ {0, k}} ^ {\\prime}\\right); z _ {\\delta_ {k}} - z _ {\\delta_ {k} ^ {\\prime}})</span></div>

    <p class="text-gray-300">i.e.,  <span class="math">r_{\\alpha_k} = \\frac{z_{\\delta_k} - z_{\\delta_k&#x27;}}{c - c&#x27;}</span>  and  <span class="math">c_{j,k} = \\frac{z_{c_{j,k}} - z_{c_{j,k}}&#x27;}{c - c&#x27;}</span> ,  <span class="math">j \\in \\{0,1,2,3\\}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Use the extractor for proof-of-product and  <span class="math">\\mathrm{Tr}_{\\mathrm{prod}}</span> ,  <span class="math">\\mathrm{Tr}_{\\mathrm{prod}}&#x27;</span>  to extract openings  <span class="math">\\hat{x}, r_X, \\hat{y}, r_Y, \\hat{z}, r_Z</span>  of  <span class="math">X, Y, Z</span> .</li>

      <li>Use the openings from the previous step to extract an opening for  <span class="math">C_0</span> . Specifically, exploiting the second condition checked by the verifier in Figure 1 (Step 7), we have:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">(c - c ^ {\\prime}) \\left(s _ {0} - J _ {X} \\cdot \\hat {x} - J _ {Y} \\cdot \\hat {y} - J _ {Z} \\cdot \\hat {z}\\right) = \\langle \\vec {J} ^ {*}, \\vec {z} - \\vec {z} ^ {\\prime} \\rangle ,</span></div>

    <p class="text-gray-300">from where we can solve for  <span class="math">s_0</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check that Equality (5) holds for the extracted values. If not, reject and output  <span class="math">\\perp</span> .</li>

    </ol>

    <p class="text-gray-300">Note that the extractor aborts only when for the extracted witness,  <span class="math">\\langle (\\sum \\rho_k\\cdot M_k),\\vec{\\pi}\\rangle = \\rho_1\\cdot s_0</span>  but Equality (5) does not hold.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">From Lemma 3 the probability that this happens is at most $1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, which is negligible when the field is of superpolynomial size. Also, note that we are exploiting the fact that proof-of-product ensures that </span>\\hat{z}=\\hat{x}\\cdot\\hat{y}$, since the verifier’s checks in the sum-check protocol require this.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-45" class="text-lg font-semibold mt-6">Honest-verifier perfect zero-knowledge</h4>

    <p class="text-gray-300">The simulator, on input statement <span class="math">(C_{0},(\\alpha_{1},\\ldots\\alpha_{n}),(M_{1},\\ldots,M_{n+1}),X,Y,Z)</span> and messages from <span class="math">\\mathcal{V}</span>, will work as follows. First it uses the simulator for proof-of-product to produce a valid transcript <span class="math">\\mathrm{Tr}_{\\mathrm{prod}}</span> for proof-of-product <span class="math">(X,Y,Z)</span>. Then, it follows the below steps to simulate the rest of the interaction between <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Pick random <span class="math">\\vec{z}</span> and values <span class="math">z_{\\delta_{1}},\\ldots,z_{\\delta_{n}},z_{C}</span>.</li>

      <li>For all <span class="math">k</span>, set <span class="math">\\delta_{k}=\\mathsf{Com}((z_{c_{3,k}},z_{c_{2,k}},z_{c_{1,k}},z_{c_{0,k}});z_{\\delta_{k}})\\oslash\\alpha_{k}^{c}</span> and set <span class="math">C=\\mathsf{Com}(\\langle J^{*},\\vec{z}\\rangle;z_{C})\\oslash(C_{0}^{\\rho_{1}}\\odot X^{-J_{X}}\\odot Y^{-J_{Z}}\\odot Z^{-J_{Z}})^{c}</span>.</li>

      <li>Output the transcript:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\big{(}\\mathrm{Tr}_{\\mathrm{prod}},(\\delta_{1},\\ldots,\\delta_{n}),(\\rho_{1},\\ldots\\rho_{n+1}),C,c,(\\vec{z},\\{z_{\\delta_{i}}\\},z_{C})\\big{)}</span></p>

    <p class="text-gray-300">By construction this passes <span class="math">\\mathcal{V}</span>’s checks. It remains to show that the distribution of transcripts produced by <span class="math">S</span> and those produced by the honest prover and honest verifier are identical. To show this, we show a one-to-one mapping between every transcript produced by the honest prover and a transcript produced by the simulator. We fix a theorem statement, a witness, and <span class="math">\\mathcal{V}</span>’s challenges. Since <span class="math">\\mathrm{Tr}_{\\mathrm{prod}}</span> is produced by the simulator for proof-of-product its distribution is identical to the distribution of the messages of an honest prover.</p>

    <p class="text-gray-300">Now, we analyze the rest of the transcript. <span class="math">\\mathcal{P}</span>’s random coins comprise the <span class="math">(5b_{N}+8b_{G}+1)</span>-tuple <span class="math">(\\vec{d},r_{\\delta_{1}},\\ldots,r_{\\delta_{n}},r_{C})</span>. Given the fixed statement, witness, and challenges, each such tuple uniquely determines <span class="math">(\\delta_{1},\\ldots,\\delta_{n})</span>, <span class="math">C</span> and the values <span class="math">\\vec{z},z_{\\delta_{1}},\\ldots,z_{\\delta_{n}},z_{C}</span>. This <span class="math">(5b_{N}+8b_{G}+1)</span>-tuple is chosen uniformly over <span class="math">\\mathbb{Z}_{q_{Q}}^{5b_{N}+8b_{G}+1}</span>.</p>

    <p class="text-gray-300">Likewise, the simulator <span class="math">S</span> uses a <span class="math">(5b_{N}+8b_{G}+1)</span>-tuple <span class="math">(\\vec{z},z_{\\delta_{1}},\\ldots,z_{\\delta_{n}},z_{C})</span> chosen uniformly at random over the probability space. We show a one-to-one mapping between the prover’s coins and the simulator’s output. We define this mapping as:</p>

    <p class="text-gray-300"><span class="math">M(\\vec{z})</span> <span class="math">=\\vec{z}-c\\cdot\\pi^{*}</span> <span class="math">M(z_{\\delta_{k}})</span> <span class="math">=z_{\\delta_{k}}-c\\cdot r_{\\alpha_{k}},\\quad k\\in\\{1,\\ldots,n\\}</span> <span class="math">M(z_{C})</span> <span class="math">=z_{C}-c\\cdot(\\rho_{1}\\cdot r_{C_{0}}-J_{X}r_{X}-J_{Y}r_{Y}-J_{Z}r_{Z})</span></p>

    <p class="text-gray-300">By inspection, this mapping is one-to-one, and when the prover runs with coins <span class="math">\\big{(}M(\\vec{z}),M(z_{\\delta_{1}}),\\ldots,M(z_{\\delta_{n}}),M(z_{C})\\big{)}</span>, it produces the same transcript as the simulator. Thus, the output distribution of <span class="math">S</span> is identical to that of the prover on this instance. This holds for all instances and any challenge <span class="math">c</span>, which concludes the proof. ∎</p>

    <h3 id="sec-46" class="text-xl font-semibold mt-8">A.5 Proof of Lemma 5</h3>

    <p class="text-gray-300">We now show how the matrix <span class="math">T</span> can be extracted from the prover in the protocol of Section 6.1. That protocol first compresses <span class="math">T</span> into one vector commitment <span class="math">T^{\\prime}</span>, and then uses proof_{log}-of-dot-prod (Appx. A.3) to show the dot-product relation for this vector. By the properties of proof_{log}-of-dot-prod, <span class="math">2^{\\ell-\\ell/\\iota}+2</span> transcripts with the same first message can be used to extract the underlying witness, which is the vector:</p>

    <p class="text-gray-300"><span class="math">\\left(\\sum_{i=0}^{2^{\\ell/\\iota}-1}w_{i}\\hat{\\chi}_{i},\\ \\ \\sum_{i=0}^{2^{\\ell/\\iota}-1}w_{i+2^{\\ell/\\iota}}\\hat{\\chi}_{i},\\ \\ldots,\\ \\ \\sum_{i=0}^{2^{\\ell/\\iota}-1}w_{2^{\\ell}-2^{\\ell/\\iota}+i}\\hat{\\chi}_{i}\\right)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In other words, each term is a weighted sum of one column of <span class="math">T</span>, with weights given by the <span class="math">\\hat{\\chi}_{i}</span> values. For <span class="math">\\iota\\geq 2</span>, given $2^{\\ell/\\iota}\\cdot\\big{(}2^{\\ell-\\ell/\\iota}+2\\big{)}\\leq 2^{\\ell+1}=2\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> transcripts with linearly independent </span>(\\hat{\\chi}_{0},\\ldots,\\hat{\\chi}_{2^{\\ell/\\iota}-1})<span class="math"> (which happens except with negligible probability for randomly selected </span>r_{k}<span class="math">), an extractor can solve the resulting system of linear equations for the values </span>w_{0},\\ldots,w_{2^{\\ell}-1}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-47" class="text-xl font-semibold mt-8">A.6 Witness-extended emulation from perfect generalized special soundness</h3>

    <p class="text-gray-300">We employ a lemma from Bootle et al. <em>[25, Lem. 1]</em> which shows that generalized special soundness implies witness-extended emulation. Bootle et al. analyze the case where the extractor always succeeds, but their argument establishes the statement below directly.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Lemma 13 (Forking lemma <em>[25]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">(P,V)</span> be a <span class="math">(2\\mu+1)</span>-move, public coin interactive protocol. Let <span class="math">\\mathrm{Ex}_{\\mathrm{GSS}}</span> be a witness extraction algorithm that extracts a witness from an <span class="math">(n_{1},\\ldots,n_{\\mu})</span>-tree of accepting transcripts (Def. 4, §3.1) in probabilistic polynomial time with at most negligible failure probability. Assume that <span class="math">\\prod_{i=\\mu}^{n}n_{i}</span> is bounded above by a polynomial in the security parameter <span class="math">\\lambda</span>. Then <span class="math">(P,V)</span> has witness-extended emulation.</p>

    <h2 id="sec-49" class="text-2xl font-bold">Appendix B Proofs of Hyrax-I’s properties</h2>

    <h6 id="sec-50" class="text-base font-medium mt-4">Theorem 14.</h6>

    <p class="text-gray-300">Hyrax-I is complete: if the prover knows a witness <span class="math">w</span> s.t. <span class="math">y=C(x,w)</span> and follows the prescribed steps in the pseudocode (Appx. D), the verifier will accept.</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The completeness of Hyrax-I follows from the completeness of <span class="math">\\mathrm{Gir}^{++}</span> and the completeness of all the ZK sub-protocols used to establish that the verifier’s checks hold. ∎</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Theorem 15.</h6>

    <p class="text-gray-300">Hyrax-I is honest-verifier perfect ZK.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">On input a theorem instance <span class="math">(C,x,y)</span>, and a set of messages <span class="math">(q^{\\prime}_{0},q_{0,0},q^{\\prime}_{1},q_{1,0},q_{1,1},...)</span> of the verifier, the simulator <span class="math">S</span> proceeds as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. For $i=1,\\ldots,\\sqrt{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">, set </span>T_{i}=\\mathsf{Com}(0;r_{T_{i}})<span class="math"> for random </span>r_{T_{i}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">\\tilde{V}_{y}(q^{\\prime}_{0},q_{0,0})</span> and set <span class="math">a_{0}=\\mathsf{Com}(\\mathcal{V}_{y}(q^{\\prime}_{0},q_{0,0});0)</span></li>

      <li>For each layer <span class="math">i=1,\\ldots,d</span>, for all sum-check rounds <span class="math">j</span>, pick <span class="math">r_{i,j}</span> uniformly at random and set <span class="math">\\alpha_{i,j}=\\mathsf{Com}((0,0,0,0);r_{i,j})</span>. At the end of the sum-check, pick <span class="math">r_{X_{i}},r_{Y_{i}},r_{Z_{i}}</span> uniformly at random from <span class="math">\\mathbb{F}</span> and set <span class="math">X_{i}=\\mathsf{Com}(0;r_{X_{i}})</span>, <span class="math">Y_{i}=\\mathsf{Com}(0;r_{Y_{i}})</span> and <span class="math">Z_{i}=\\mathsf{Com}(0;r_{Z_{i}})</span>. Use the simulator of proof-of-sum-check (Fig. 1, §5; Appx. A.4) to get a valid transcript <span class="math">\\mathrm{Tr}_{i}</span> for the theorem statement <span class="math">\\big{(}a_{i-1},(\\alpha_{i,1},\\ldots\\alpha_{i,n}),(M_{1},\\ldots,M_{n+1}),X_{i},Y_{i},Z_{i}\\big{)}</span>. Pick random <span class="math">\\mu_{i,0},\\mu_{i,1}</span> from <span class="math">\\mathbb{F}</span> and set <span class="math">a_{i}=X_{i}^{\\mu_{i,0}}\\odot Y_{i}^{\\mu_{i,1}}</span> (Line 19, Fig. 9).</li>

      <li>For all <span class="math">j=0,\\ldots,b_{G}</span> pick <span class="math">r_{H_{j}}</span> uniformly at random from <span class="math">\\mathbb{F}</span> and set <span class="math">\\mathsf{Com}(H_{j})=\\mathsf{Com}(0;r_{H_{j}})</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run the simulator of proof-of-opening for the values <span class="math">\\mathsf{Com}(H_{0}),\\ldots,\\mathsf{Com}(H_{b_{G}})</span> and get back the accepting transcripts <span class="math">\\mathrm{Tr}_{H_{0}},\\ldots,\\mathrm{Tr}_{H_{b_{G}}}</span></li>

      <li>Run the simulator of proof-of-equality for the input statement <span class="math">(\\mathsf{Com}(H_{0}),X)</span> and get back the accepting transcript <span class="math">\\mathrm{Tr}_{\\mathrm{same},X}</span></li>

      <li>Run the simulator of proof-of-equality for the input statement <span class="math">(\\mathsf{Com}(H_{b_{G}})\\odot\\ldots\\odot\\mathsf{Com}(H_{0}),Y)</span> and get back the accepting transcript <span class="math">\\mathrm{Tr}_{\\mathrm{same},Y}</span></li>

      <li>Compute <span class="math">q_{d}</span>, <span class="math">\\zeta</span> and <span class="math">T^{\\prime}</span> as in Lines 24–26 of Figure 10</li>

      <li>Run the simulator of proof_{log}-of-dot-prod (Appx. A.3) for the input statement <span class="math">(T^{\\prime},\\zeta\\oslash g^{(1-q_{d}[0]\\hat{V}_{x}(q_{d}[1,\\ldots,b_{N}+b_{G}-1])},R)</span> and get back the accepting transcript <span class="math">\\mathrm{Tr}_{\\mathrm{dotProd}}</span></li>

      <li>Output the transcript:</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$(T_{1},\\ldots,T_{\\sqrt{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}},q_{0}^{\\prime},q_{0,0},q_{1,0},\\alpha_{1,0},\\ldots,X_{1},Y_{1},Z_{1},\\mathrm{Tr}_{1},\\ldots,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathrm{Tr}_{d},\\mathsf{Com}(H_{0}),\\ldots,\\mathrm{Tr}_{H_{b_{G}}},\\mathrm{Tr}_{\\mathrm{same},X},\\mathrm{Tr}_{\\mathrm{same},Y},\\tau,\\mathrm{Tr}_{\\mathrm{dotProd}})</span></p>

    <p class="text-gray-300">The above transcript is accepting: The verifier can only reject during one of the ZK subroutines proof_{log}-of-dot-prod, proof-of-opening, etc., but the simulators of these routines produce accepting transcripts for each of the input theorem statements.</p>

    <p class="text-gray-300">By a standard hybrid argument, the distribution of transcripts produced by S and those produced by the honest prover and honest verifier are identical. We fix a theorem statement <span class="math">(C,x,y)</span>, a witness <span class="math">w</span> and verifier’s challenges <span class="math">q_{0}^{\\prime},q_{0,0},\\ldots</span>. Recall <span class="math">\\mathsf{View}\\left(\\langle\\mathcal{P}(w),\\mathcal{V}^{*}(z)\\rangle(x)\\right)</span> denotes the distribution of transcripts that the prover produces when interacting with the honest verifier. In the following we define experiments <span class="math">\\mathsf{Exp}_{1},\\mathsf{Exp}_{2},\\ldots</span> which produce a distribution of transcripts, and show that each is identical to the previous.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathsf{Exp}_{1}</span> be the experiment that outputs a transcript in which the prover behaves as the honest prover except that in Line 28 of Figure 10, instead of executing the protocol proof_{log}-of-dot-prod honestly, the protocol’s simulator is used to produce the transcript for the same theorem. From Theorem 11, since this simulator produces transcripts that are identically distributed to those that an honest prover produces, the distributions <span class="math">\\mathsf{Exp}_{1}</span> and <span class="math">\\mathsf{View}\\left(\\langle\\mathcal{P}(w),\\mathcal{V}^{*}(z)\\rangle(x)\\right)</span> are identical.</li>

      <li>Let <span class="math">\\mathsf{Exp}_{2}</span> be the experiment in which the prover behaves as the prover in <span class="math">\\mathsf{Exp}_{1}</span> except that in Line 3 of Figure 10, a commitment to 0 is used. By Theorem 7 which establishes that the Pedersen commitment scheme is perfectly hiding, each of these commitments to zero is identically distributed to commitment used in <span class="math">\\mathsf{Exp}_{1}</span>. As a result, the distributions <span class="math">\\mathsf{Exp}_{2}</span> and <span class="math">\\mathsf{Exp}_{1}</span> are identically distributed.</li>

      <li>Let <span class="math">\\mathsf{Exp}_{3}</span> be the experiment in which the prover behaves as the prover in <span class="math">\\mathsf{Exp}_{2}</span> except that in each of the Lines 21 and 22 of Figure 10, the simulator of the protocol proof-of-equality is used to generate the transcript instead of executing the protocol. By Theorem 9 this simulator produces transcripts for each of these relations that are identical to those that an honest prover would produce.</li>

      <li>Let <span class="math">\\mathsf{Exp}_{4}</span> be the experiment in which the prover behaves as the prover in <span class="math">\\mathsf{Exp}_{3}</span> except that in the <span class="math">b_{G}</span> iterations of Line 20 of Figure 10, the simulator of the protocol proof-of-opening is used to generate a transcript instead of executing it honestly. From Theorem 8, this simulator produces transcripts that are identically distributed to those that an honest prover produces. So, the distributions <span class="math">H_{4}</span> and <span class="math">H_{3}</span> are identical.</li>

      <li>Let <span class="math">\\mathsf{Exp}_{5}</span> be the experiment in which the prover behaves as the prover in <span class="math">\\mathsf{Exp}_{4}</span> except that in Line 18 of Figure 10, commitments to 0 are used. By Theorem 7 which establishes that the Pedersen commitment scheme is perfectly hiding, the distribution <span class="math">\\mathsf{Exp}_{5}</span> is identical to the distribution <span class="math">\\mathsf{Exp}_{4}</span></li>

      <li>For all sum-check iterations <span class="math">i=d,\\ldots,1</span> :</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathsf{Exp}_{3(d-i)+6}</span> be the experiment in which the prover behaves as the prover of the previous experiment <span class="math">\\mathsf{Exp}_{3(d-i)+5}</span> except that in Line 54 of figure 11, the simulator for the protocol proof-of-sum-check is used to generate the transcript. From Lemma 4 this simulator produces transcripts that are identically distributed to those that an honest prover produces. So, the distributions <span class="math">\\mathsf{Exp}_{3(d-i)+6}</span> and <span class="math">\\mathsf{Exp}_{3(d-i)+5}</span> are identical.</li>

      <li>Let <span class="math">\\mathsf{Exp}_{3(d-i)+7}</span> be the experiment in which the prover behaves as the prover of the previous experiment <span class="math">Exp_{3(d-i)+6}</span> except that in Line 52 of figure 11 produces the commitments <span class="math">X_{i},Y_{i},Z_{i}</span> by committing to 0. By Theorem 7 which establishes that the Pedersen commitment scheme is perfectly hiding, the distribution <span class="math">\\mathsf{Exp}_{3(d-i)+7}</span> is identical to the distribution <span class="math">\\mathsf{Exp}_{3(d-i)+6}</span>.</li>

      <li>Let <span class="math">\\mathsf{Exp}_{3(d-i)+8}</span> be the experiment in which the prover behaves as the prover of the previous experiment <span class="math">\\mathsf{Exp}_{3(d-i)+8}</span> except that for all sum-check rounds <span class="math">j=1=n,\\ldots,1</span>, in Lines 19 and 47 of figure 11 the commitments <span class="math">\\alpha_{i}</span> are produced by committing to the zero vector. By Theorem 7 which establishes that the Pedersen commitment scheme is perfectly hiding, the distribution <span class="math">\\mathsf{Exp}_{3(d-i)+8}</span> is identical to the distribution <span class="math">\\mathsf{Exp}_{3(d-i)+7}</span></li>

    </ul>

    <p class="text-gray-300">Thus, <span class="math">\\mathsf{View}\\left(\\langle\\mathcal{P}(w),\\mathcal{V}^{*}(z)\\rangle(x)\\right)</span> is identically distributed to <span class="math">\\mathsf{Exp}_{3(d-1)+8}</span>. The experiment <span class="math">\\mathsf{Exp}_{3(d-1)+8}</span> is identical to running the Simulator <span class="math">S</span> on the instance <span class="math">(C,x,y)</span> and verifier’s challenges <span class="math">q_{0}^{\\prime},q_{0,0},\\ldots</span>. As a result, <span class="math">\\mathsf{Exp}_{3(d-1)+8}</span> corresponds to the distribution of transcripts that <span class="math">S</span> produces which completes the proof. ∎</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Theorem 16.</h6>

    <p class="text-gray-300">Under the discrete log assumption, Hyrax-I has witness-extended emulation.</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We construct an extractor <span class="math">E</span> that simultaneously outputs a transcript and a witness for a given theorem <span class="math">x</span> with roughly the same probability that prover <span class="math">\\mathcal{P}^{<em>}</span> causes the honest verifier to accept theorem <span class="math">(C,x,y)</span>. At a high level, this extractor <span class="math">E</span> uses <span class="math">\\mathcal{P}^{</em>}</span> as an oracle, and runs the extractor from Lemma 5 in order to find a witness <span class="math">w</span>. It checks the validity of the witness by verifying that <span class="math">C(x,w)=y</span> and outputs <span class="math">w</span> or else aborts by outputting <span class="math">\\bot</span>. We show that when the extractor succeeds in recovering <span class="math">w</span>, then (except with negligible probability) it indeed outputs <span class="math">w</span> and thus satisfies witness-extended emulation. The last condition follows by the soundness of the <span class="math">\\mathrm{Gir}^{++}</span> protocol: a <span class="math">\\mathcal{P}^{*}</span> that succeeds at convincing the verifier to accept with some non-negligible</p>

    <p class="text-gray-300">probability <span class="math">\\epsilon</span>, but which causes <span class="math">E</span> to abort, can be used to break the soundness of <span class="math">\\mathrm{Gir}^{++}</span>. We use a proof technique borrowed from the elegant analysis of various parallel repetition theorems where the same style of soundness reduction (albeit more complicated) is required.</p>

    <p class="text-gray-300">To simplify the presentation, we assume that the Hyrax-I verifier runs all zero-knowledge proofs at the very end of the protocol (even though the pseudocode describes these checks as occurring over the course of the interaction); we refer to this ZK challenge step as Step (<span class="math">\\ast</span>). By moving all sigma protocols to the end in Hyrax-I, and by standard AND composition of sigma protocols <em>[34]</em>, all ZK proofs can use the same verifier challenge <span class="math">c\\in\\mathbb{F}</span> and the combined proof enjoys the same honest-verifier zero-knowledge and special soundness properties (we think of Step (<span class="math">\\ast</span>) as consisting of one giant ZK proof instead of many separate ZK proofs). Similarly, the <span class="math">\\mathrm{Gir}^{++}</span> verifier defers all checks to the end of the interaction. This change to <span class="math">\\mathrm{Gir}^{++}</span> does not affect soundness.</p>

    <p class="text-gray-300">On input theorem statement <span class="math">(C,x,y)</span>, the extractor <span class="math">E^{\\mathcal{P}^{*}}(C,x,y)</span> works as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run the honest Hyrax-I verifier <span class="math">\\mathcal{V}</span> on instance <span class="math">(C,x,y)</span> with prover <span class="math">\\mathcal{P}^{*}(C,x,y)</span> and record the partial transcript <span class="math">\\mathrm{Tr}^{\\prime}</span> until Step (<span class="math">\\ast</span>) when the zero-knowledge proof is given.</li>

      <li>By Lemma 13, there exist witness-extended emulators <span class="math">E^{\\mathcal{P}^{<em>}}_{w}</span> and <span class="math">E^{\\mathcal{P}^{</em>}}_{O}</span> for the protocols of Lemma 5 and Theorem 8, respectively. Run <span class="math">(\\mathrm{Tr}^{\\prime\\prime}_{e},w_{e})\\leftarrow E^{\\mathcal{P}^{<em>}}_{w}(C,x,y)</span> to extract the witness <span class="math">w_{e}</span>. Run <span class="math">(\\mathrm{Tr}^{\\prime\\prime}_{H_{i}},(H_{i},r_{H_{i}}))\\leftarrow E^{\\mathcal{P}^{</em>}}_{O}</span> to extract openings for each <span class="math">\\mathsf{Com}(H_{i})</span> (Fig. 9, Line 26), and use these openings to compute the opening <span class="math">(m_{\\zeta},r_{\\zeta})</span> of <span class="math">\\zeta</span> (Fig. 9, Line 32).</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. Run the rest of the ZK sub-protocols of Step (<span class="math">\\ast</span>) and record the transcript <span class="math">\\mathrm{Tr}^{\\prime\\prime}_{\\mathrm{rest}}</span>. Let $\\mathrm{Tr}^{\\prime\\prime}=\\mathrm{Tr}^{\\prime\\prime}_{e}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{Tr}^{\\prime\\prime}_{H_{0}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{Tr}^{\\prime\\prime}_{H_{1}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{Tr}^{\\prime\\prime}_{\\mathrm{rest}}<span class="math">, and let </span>\\mathrm{Tr}=\\mathrm{Tr}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{Tr}^{\\prime\\prime}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">m_{\\zeta}</span> is not consistent with <span class="math">(x,w_{e})</span> or if <span class="math">\\mathrm{Tr}</span> is rejecting, output <span class="math">(\\mathrm{Tr},0)</span> and halt. Otherwise, if <span class="math">C(x,w_{e})=y</span>, then output <span class="math">(\\mathrm{Tr},w_{e})</span>. Otherwise, output <span class="math">\\bot</span>.</li>

    </ol>

    <p class="text-gray-300">Fix a polynomial-time adversary <span class="math">A</span> and <span class="math">\\mathcal{P}^{<em>}</span>. Without loss of generality, assume that <span class="math">A,\\mathcal{P}^{</em>}</span> are deterministic (i.e., their best random tapes are hard-wired). Thus, the instance and state given by <span class="math">(u_{\\lambda}{=}(C,x,y),s_{\\lambda})\\leftarrow A(1^{\\lambda})</span> are just indexed on the security parameter. We must show that <span class="math">E</span> runs in expected polynomial time (which follows by inspection of each step) and that</p>

    <p class="text-gray-300"><span class="math">\\mathrm{Pr}\\left[\\mathrm{Tr}\\leftarrow\\mathsf{tr}\\langle\\mathcal{P}^{*}(s_{\\lambda}),\\mathcal{V}\\rangle(u_{\\lambda}):A(\\mathrm{Tr})=1\\right]</span> (18)</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300">\\[ \\mathrm{Pr}\\left[\\begin{array}[]{l}(\\mathrm{Tr},w)\\leftarrow E^{\\mathcal{P}^{*}(s_{\\lambda})}(u_{\\lambda}):A(\\mathrm{Tr})=1\\land\\\\ \\text{if <span class="math">\\mathrm{Tr}</span> is an accepting transcript, <span class="math">C(x,w)=y</span>.}\\end{array}\\right] \\] (19)</p>

    <p class="text-gray-300">differ by a negligible amount in the security parameter.</p>

    <p class="text-gray-300">When <span class="math">E</span> outputs a pair, it outputs the transcript <span class="math">\\mathrm{Tr}</span> produced by an honest verifier interacting with <span class="math">\\mathcal{P}^{<em>}</span>, and thus the probability that <span class="math">A(\\mathrm{Tr})=1</span> when <span class="math">E</span> does not abort is identical in (19) and (18). As we show below in Claim 17, the probability that <span class="math">E</span> aborts is a negligible function <span class="math">\\eta(\\cdot)</span>, and thus, it follows that <span class="math">\\mathrm{Pr}\\left[(\\mathrm{Tr},w)\\leftarrow E^{\\mathcal{P}^{</em>}(u,x)}(u):A(\\mathrm{Tr})=1\\right]\\geq(1-\\eta(\\cdot))\\cdot\\mathrm{Eq}</span>. (18). Furthermore, when <span class="math">E</span> does not abort and the transcript is accepting, then because of Step 4, <span class="math">E</span> outputs a pair <span class="math">(\\mathrm{Tr},w)</span> such that <span class="math">C(x,w)=y</span>. Thus, the second condition of Eq. (19) also holds, and equations (18) and (19) differ by at most a negligible function, which completes the proof of the theorem.</p>

    <p class="text-gray-300"><span class="math">E</span> only aborts when <span class="math">\\mathcal{P}^{*}</span> succeeds in creating an accepting transcript, extractor <span class="math">E_{w}</span> succeeds in extracting a witness <span class="math">w_{e}</span>, but <span class="math">C(x,w_{e})\\neq y</span>. Denote this event as badwit.</p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Claim 17.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For every <span class="math">\\mathcal{P}^{*}</span>, there exists a <span class="math">\\hat{\\mathcal{P}}</span> that runs in expected time $\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{\\lambda}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathrm{time}(\\mathcal{P}^{*}))<span class="math"> such that if </span>\\mathrm{Pr}[\\mathsf{badwit}]=\\epsilon(\\lambda)$, then</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathrm{Pr}[\\langle\\hat{\\mathcal{P}}(s_{\\lambda}),\\mathcal{V}_{g}\\rangle(u_{\\lambda})=1]&gt;\\epsilon(\\lambda)^{2}-\\eta(\\lambda)</span></p>

    <p class="text-gray-300">where <span class="math">\\mathcal{V}_{g}</span> is the <span class="math">\\mathrm{Gir}^{++}</span> verifier and <span class="math">\\eta</span> is a negligible function.</p>

    <p class="text-gray-300">By the soundness of <span class="math">\\mathrm{Gir}^{++}</span> from Theorem 1, it follows that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\epsilon(\\lambda)^{2}-\\eta(\\lambda)<\\mathrm{O}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{\\lambda}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and by rearranging, that $\\epsilon(\\lambda)<\\sqrt{\\mathrm{O}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{\\lambda}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)+\\eta(\\lambda)}<span class="math"> which shows that </span>\\epsilon<span class="math"> is a negligible function because </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ is assumed exponential in the security parameter.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The idea of the construction of <span class="math">\\hat{\\mathcal{P}}</span>. Both the <span class="math">\\mathrm{Gir}^{++}</span> verifier’s <span class="math">(\\mathcal{V}_{g})</span> challenge messages and the Hyrax-I verifier’s <span class="math">(\\mathcal{V})</span> challenge messages are <span class="math">(\\mu_{0,0},\\mu_{0,1},r_{1,1},r_{1,2},\\ldots,r_{d,h_{G}},\\tau)</span>, and in addition, the Hyrax-I verifier makes a single challenge <span class="math">c</span> in Step (<span class="math">\\ast</span>). For simplicity, we denote these challenges <span class="math">\\vec{r}=(r_{1},\\ldots,r_{\\ell})\\in\\mathbb{F}^{\\ell}</span> and <span class="math">c\\in\\mathbb{F}</span> and assume that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>2^{\\lambda}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The only difference between <span class="math">\\mathcal{V}_{g}</span> and <span class="math">\\mathcal{V}</span> is that the latter performs its checks “under the commitments” by verifying a ZK proof instead of directly checking the provers responses <span class="math">(m_{1},\\ldots,m_{\\ell})</span> after every step. Thus the job of <span class="math">\\hat{\\mathcal{P}}</span> is to forward the messages “under the commitments” from <span class="math">\\mathcal{P}^{*}</span> to <span class="math">\\mathcal{V}_{g}</span>.</p>

    <p class="text-gray-300">In particular, <span class="math">\\hat{\\mathcal{P}}</span> needs to sample an accepting transcript between <span class="math">\\mathcal{V}</span> and <span class="math">\\mathcal{P}^{<em>}</span>, and then rewind the challenge message of the ZK proof to extract the witness <span class="math">w_{e}</span> from the session and initiate a session of <span class="math">\\mathrm{Gir}^{++}</span> with <span class="math">\\mathcal{V}_{g}</span> on the theorem statement <span class="math">C(x,w_{e})=y</span>. As it receives the challenges from <span class="math">\\mathcal{V}_{g}</span> for the sum-check iterations, it forwards the same challenge to <span class="math">\\mathcal{P}^{</em>}</span>, awaits a response commitment, and then extracts the value from the commitment by completing the execution and extracting a witness from the ZK proof at Step (<span class="math">\\ast</span>) by using the (generalized) special soundness of each sub-protocol along with Lemma 13.</p>

    <p class="text-gray-300">Bounding the probability that <span class="math">\\mathcal{P}^{<em>}</span> aborts. A natural concern is handling provers <span class="math">\\mathcal{P}^{</em>}</span> that abort the Hyrax-I protocol during <span class="math">\\hat{\\mathcal{P}}</span>’s attempts to find a completion of a partial transcript. Intuitively, <span class="math">\\mathcal{P}^{*}</span> succeeds on <span class="math">\\epsilon</span>-fraction of all <span class="math">\\mathcal{V}</span> challenges, and thus sufficient sampling should lead to a success with high probability.</p>

    <p class="text-gray-300">More formally, consider a <span class="math">j</span>-move partial execution between <span class="math">\\mathcal{P}^{<em>}</span> and <span class="math">\\mathcal{V}</span> in which <span class="math">\\mathcal{V}</span>’s challenges are <span class="math">\\vec{r}_{j}=(r_{1},\\ldots,r_{j})</span>. A continuation of <span class="math">\\vec{r}_{j}</span> is a set of challenges <span class="math">(r_{j+1},\\ldots,r_{\\ell},c)</span>, and a good continuation is one in which <span class="math">\\mathcal{P}^{</em>}</span> responses to <span class="math">(r_{1},\\ldots,r_{\\ell},c)</span> causes <span class="math">V</span> to accept. Define the set <span class="math">G_{\\lambda}</span> to be <span class="math">G_{\\lambda}=\\{\\vec{r}=(r_{1},\\ldots,r_{\\ell})\\}</span> the set of <span class="math">\\ell</span>-move challenges such that each prefix <span class="math">\\vec{r}_{j}</span> of <span class="math">\\vec{r}\\in\\mathcal{G}_{\\lambda}</span>, has an <span class="math">\\epsilon/\\ell</span>-fraction of good continuations. These are the “heavy” challenges for which <span class="math">\\mathcal{P}^{*}</span> produces accepting transcripts that facilitate extraction via special-soundness. Let <span class="math">\\nu_{\\lambda}=\\mathrm{Pr}_{\\vec{r}\\xleftarrow{\\lambda}\\mathbb{F}^{\\ell}}[\\vec{r}\\in G_{\\lambda}]</span>. Next we lower bound <span class="math">\\nu_{\\lambda}</span>.</p>

    <p class="text-gray-300">##</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Lemma 18.</h6>

    <p class="text-gray-300"><span class="math">\\nu_{\\lambda}\\geq\\epsilon/8</span> for <span class="math">\\ell\\geq 3,\\ell\\in\\mathbb{N}</span>.</p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider the tree of transcripts with leaves <span class="math">(r_{1},\\ldots,r_{\\ell})\\in\\mathbb{F}^{\\ell}</span> representing the portion of an execution of Hyrax-I right before the challenge <span class="math">c</span> for the ZK proof is given. Level <span class="math">j</span> of this tree contains the internal nodes <span class="math">\\vec{r}_{j}=(r_{1},\\ldots,r_{j})\\in\\mathbb{F}^{j}</span> (so there are $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{j}<span class="math"> nodes at layer j of the tree); we are interested in analyzing good continuations over these leaves. Let </span>\\rho_{\\vec{r}_{j}}<span class="math"> be the fraction of good continuations for prefix </span>\\vec{r}_{j}<span class="math">. Suppose that over all nodes at level </span>i<span class="math">, an </span>\\epsilon_{i}<span class="math"> fraction of continuations are good. Define the heavy set </span>\\mathcal{H}_{i}<span class="math"> as those prefixes for which at least an </span>\\epsilon_{i}/\\ell$-fraction of continuations succeed.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-59" class="text-base font-medium mt-4">Claim 19.</h6>

    <p class="text-gray-300">If an <span class="math">\\epsilon_{i}</span> fraction of continuations of all nodes <span class="math">\\vec{r}_{i}</span> at level <span class="math">i</span> succeed, then at least an <span class="math">\\epsilon_{i}(1-\\nicefrac{{1}}{{\\ell}})</span> fraction of continuations of nodes in <span class="math">\\mathcal{H}_{i}</span> at level <span class="math">i</span> succeed. That is, if <span class="math">\\sum_{\\vec{r}_{i}\\in\\mathbb{F}^{i}}\\rho_{\\vec{r}_{i}}&gt;\\epsilon_{i}</span>, then <span class="math">\\sum_{\\mathcal{H}_{i}}\\rho_{\\vec{r}_{i}}\\geq\\epsilon_{i}(1-\\frac{1}{\\ell-1})</span>.</p>

    <h6 id="sec-60" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Partition the sum</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{(\\ell-i)}\\sum_{\\vec{r}_{i}\\in\\mathbb{F}^{i}}\\rho_{\\vec{r}_{i}}=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{(\\ell-i)}\\left(\\sum_{\\mathcal{H}_{i}}\\rho_{\\vec{r}_{i}}+\\sum_{\\overline{\\mathcal{H}_{i}}}\\rho_{\\vec{r}_{i}}\\right)\\geq\\epsilon_{i}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\ell}$ (20)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Using the fact that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{H}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\overline{\\mathcal{H}_{i}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{i}<span class="math">, we bound </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\overline{\\mathcal{H}_{i}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ by overestimating its weight as follows:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{(\\ell-i)}\\left(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{H}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot 1+\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\overline{\\mathcal{H}_{i}}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left(\\frac{\\epsilon_{i}}{\\ell}\\right)\\right)<span class="math"> </span>\\geq\\epsilon_{i}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\ell}$</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">$</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{F}</td>

            <td class="px-3 py-2 border-b border-gray-700">^{(\\ell-i)}\\left(</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{F}</td>

            <td class="px-3 py-2 border-b border-gray-700">^{i}+\\left</td>

            <td class="px-3 py-2 border-b border-gray-700">\\overline{\\mathcal{H}_{i}}\\right</td>

            <td class="px-3 py-2 border-b border-gray-700">\\left(-1+\\left(\\frac{\\epsilon_{i}}{\\ell}\\right)\\right)\\right)<span class="math"> </span>\\geq\\epsilon_{i}\\cdot</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{F}</td>

            <td class="px-3 py-2 border-b border-gray-700">^{\\ell}$</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">$</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{F}</td>

            <td class="px-3 py-2 border-b border-gray-700">^{(\\ell-i)}\\left</td>

            <td class="px-3 py-2 border-b border-gray-700">\\overline{\\mathcal{H}_{i}}\\right</td>

            <td class="px-3 py-2 border-b border-gray-700">\\left(-1+\\left(\\frac{\\epsilon_{i}}{\\ell}\\right)\\right)<span class="math"> </span>\\geq(-1+\\epsilon_{i})\\cdot</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{F}</td>

            <td class="px-3 py-2 border-b border-gray-700">^{\\ell}$</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">$\\left</td>

            <td class="px-3 py-2 border-b border-gray-700">\\overline{\\mathcal{H}_{i}}\\right</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math"> </span>\\leq\\frac{(1-\\epsilon_{i})}{\\left(1-\\left(\\frac{\\epsilon_{i}}{\\ell}\\right)\\right)}\\cdot</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{F}</td>

            <td class="px-3 py-2 border-b border-gray-700">^{i}$ (21)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Substituting (21) into (20)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\sum_{\\mathcal{H}_{i}}\\rho_{\\vec{r}_{i}}</span> $\\geq\\epsilon_{i}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{i}-\\sum_{\\overline{\\mathcal{H}_{i}}}\\rho_{\\vec{r}_{i}}$</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">$=\\epsilon_{i}\\cdot</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{F}</td>

            <td class="px-3 py-2 border-b border-gray-700">^{i}\\left[1-\\frac{(1-\\epsilon_{i})}{\\ell-\\epsilon_{i}}\\right]$</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">$\\geq\\epsilon_{i}\\cdot</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{F}</td>

            <td class="px-3 py-2 border-b border-gray-700">^{i}\\left[1-\\frac{1}{\\ell-1}\\right]$</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">Thus, at level <span class="math">i</span>, the probability mass over the “heavy” prefixes remains roughly the same. At level <span class="math">\\ell</span> in the tree (i.e., full challenges), we have by assumption that an <span class="math">\\epsilon</span> fraction succeeds, and thus by the calculation above, at least <span class="math">(1-\\nicefrac{{1}}{{\\left(\\ell-1\\right)}})</span> fraction are heavy leaves for which <span class="math">\\epsilon/\\ell</span>-fraction of the continuations (over the ZK challenge <span class="math">c</span>) succeed. Now consider the parents of these heavy leaves at level <span class="math">\\ell-1</span>. At least an <span class="math">\\epsilon_{\\ell-1}=\\epsilon(1-\\nicefrac{{1}}{{\\left(\\ell-1\\right)}})</span> fraction of nodes at this level have children which are heavy. Applying Claim 19, it follows that an <span class="math">\\epsilon_{\\ell-1}\\cdot(1-\\nicefrac{{1}}{{\\left(\\ell-1\\right)}})</span> fraction of the nodes at this level are heavy. By induction, we have that at the top-level of the tree, at least a fraction of all challenges</p>

    <p class="text-gray-300"><span class="math">\\epsilon\\left[1-\\frac{1}{\\ell-1}\\right]^{\\ell}\\geq\\epsilon/8.</span></p>

    <p class="text-gray-300">are heavy, because <span class="math">(1-\\nicefrac{{1}}{{\\left(x-1\\right)}})^{x}\\geq 1/8</span> for <span class="math">x\\geq 3,x\\in\\mathbb{N}</span>. ∎</p>

    <p class="text-gray-300">We now consider the task of sampling an accepting transcript that allows extracting <span class="math">w</span> starting from a partial transcript with challenges <span class="math">\\vec{r}_{j}=(r_{1},\\ldots,r_{j})</span>. Define procedure <span class="math">\\textsc{sam}^{\\mathcal{P}^{*}}_{\\lambda,u}(\\vec{r}_{j})</span> as:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For up to <span class="math">t</span> attempts:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample <span class="math">(r_{j+1}^{\\prime},\\ldots,r_{\\ell}^{\\prime})\\leftarrow\\mathbb{F}^{\\ell-j}</span></li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. Run <span class="math">\\mathcal{V}</span> with <span class="math">\\mathcal{P}^{*}</span> (from its current state) using challenges <span class="math">(r_{j+1}^{\\prime},\\ldots,r_{\\ell}^{\\prime})</span> until <span class="math">\\hat{\\mathcal{P}}</span> generates the first message of the ZK proof, and then sample <span class="math">t</span> transcripts with randomly sampled ZK challenges <span class="math">c\\leftarrow\\mathbb{F}</span>. Succeed if $2\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{\\lambda}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ transcripts accept, and return the accepting transcripts.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{\\lambda}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, </span>2\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{\\lambda}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> transcripts are sufficient to extract </span>w<span class="math"> (Appx. A.5). Further, sam always runs in time polynomial in time(</span>\\mathcal{P}^{*}<span class="math">) and </span>2\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{\\lambda}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> (which are both polynomial in the instance size) and </span>t<span class="math">, which we set below. More importantly, for </span>j\\in\\{1,\\ldots,\\ell\\}<span class="math">, conditioned on </span>\\vec{r}_{j}<span class="math"> being the prefix of some </span>\\vec{r}\\in G_{\\lambda}<span class="math">, then sam succeeds with high probability. In particular, for sam to fail, all </span>t<span class="math"> attempts at sampling </span>(r_{j+1},\\ldots,r_{\\ell})<span class="math"> must fail to yield a candidate </span>\\vec{r}\\in G_{\\lambda}<span class="math"> and more than </span>t-2\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{\\lambda}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> attempts to find good continuations of each such candidate fail. For the first case, because the samples are independent, the failure probability is less than </span>(1-\\nicefrac{{\\epsilon}}{{8}})^{t}<span class="math">. For the second case, failure occurs when there are fewer than </span>2\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{\\lambda}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> accepting transcripts. Conditioned on the prefix being in </span>G_{\\lambda}<span class="math">, an </span>\\nicefrac{{\\epsilon}}{{\\ell}}<span class="math"> fraction of continuations result in accepting transcripts, so sampling </span>2\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{\\lambda}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> accepting transcripts requires an expected </span>2\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{\\lambda}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{\\cdot}^{\\ell}/{\\epsilon}<span class="math"> attempts. Setting </span>t\\geq 20\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{\\lambda}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{\\cdot}^{\\ell}/{\\epsilon}{\\cdot}^{\\lambda}$ makes the first case negligible by inspection and the second case negligible by a Chernoff bound.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Details of <span class="math">\\hat{\\mathcal{P}}</span>. For theorem <span class="math">(\\mathcal{C},x,y)</span>, <span class="math">\\hat{\\mathcal{P}}</span> does the following:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample <span class="math">\\text{Tr}_{\\text{full}}\\leftarrow\\langle\\mathcal{P}^{*},\\mathcal{V}(C,x,y)\\rangle</span>. If <span class="math">\\text{Tr}_{\\text{full}}</span> is not accepting, then abort.</li>

      <li>Rewind <span class="math">\\mathcal{P}^{<em>}</span> to Step <span class="math">(</em>)</span> and sample accepting transcripts until there are enough to extract the witness <span class="math">w_{e}</span> and an opening <span class="math">(m_{\\zeta},r_{\\zeta})</span> of <span class="math">\\zeta</span> via the perfect generalized special soundness of the ZK step (Step <span class="math">(*)</span>) and Lemma 13. Send <span class="math">w_{e}</span> to <span class="math">\\text{Gir}^{++}</span> verifier <span class="math">\\mathcal{V}_{g}</span> (Line 3 of Figure 12), thereby making the claim that <span class="math">\\mathcal{C}(x,w_{e})=y</span>.</li>

    </ol>

    <p class="text-gray-300">Rewind <span class="math">\\mathcal{P}^{<em>}</span> to after it sends its first commitment message (Line 3, Fig. 14). From this point, <span class="math">\\hat{\\mathcal{P}}</span> plays man in the middle between <span class="math">\\mathcal{V}_{g}</span> and <span class="math">\\mathcal{P}^{</em>}</span> as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Repeat to determine each message that the <span class="math">\\text{Gir}^{++}</span> prover <span class="math">\\hat{\\mathcal{P}}</span> sends to the <span class="math">\\text{Gir}^{++}</span> verifier <span class="math">\\mathcal{V}_{g}</span>:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For message <span class="math">j</span>, await the random challenge <span class="math">r_{j}</span> from <span class="math">\\mathcal{V}_{g}</span>, forward <span class="math">r_{j}</span> to <span class="math">\\mathcal{P}^{*}</span>. Run sam to generate enough accepting continuations and ZK transcripts to extract prover messages <span class="math">(m_{1}^{\\prime},\\ldots,m_{\\ell}^{\\prime})</span> for every committed message in the protocol.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For any <span class="math">k&lt;j</span>, if there exists a pair <span class="math">m^{k}_{\\parallel}\\neq m^{j}_{\\parallel}</span>, (i.e., the extracted value of message <span class="math">k</span> differs from a previous extraction of message <span class="math">k</span>), then abort.</li>

      <li>Forward the extracted message <span class="math">m^{j}_{j}</span> to <span class="math">\\mathcal{V}_{g}</span>.</li>

    </ul>

    <p class="text-gray-300">During its execution, <span class="math">\\hat{\\mathcal{P}}</span> samples fresh random challenges on behalf of the Hyrax-I verifier, and it receives challenge messages from <span class="math">\\mathcal{V}_{g}</span>. Let <span class="math">\\mathsf{coll}</span> denote the event that two such samples are equal (over the entire execution including all sampling of continuations). Because both <span class="math">\\hat{\\mathcal{P}}</span> and <span class="math">\\mathcal{V}_{g}</span> choose samples randomly and uniformly from <span class="math">\\mathbb{F}</span>, and because the expected number of samples chosen is <span class="math">\\mathrm{O}(\\mathrm{poly}(d\\log NG))</span> over all rewinds, it follows that <span class="math">\\mathrm{Pr}[\\mathsf{coll}]\\leq\\eta_{1}(\\lambda)</span> for a negligible function <span class="math">\\eta_{1}</span>. For the rest of this argument, we condition on the event <span class="math">\\overline{\\mathsf{coll}}</span>, which implies that every extraction of a witness succeeds by perfect generalized special soundness and Lemma 13.</p>

    <p class="text-gray-300"><span class="math">\\hat{\\mathcal{P}}</span> may abort in Step 3b. Denote this event by <span class="math">\\mathsf{bind}</span>; when this event occurs, <span class="math">\\hat{\\mathcal{P}}</span> can be modified to output a commitment <span class="math">\\alpha_{j}</span> and two different openings of <span class="math">\\alpha_{j}</span>. This event occurs with negligible probability <span class="math">\\eta_{2}</span> by the binding of the Pedersen commitment, and we also condition the rest of the analysis on the event <span class="math">\\overline{\\mathsf{bind}}</span>.</p>

    <p class="text-gray-300">We can view verifier <span class="math">\\mathcal{V}_{g}</span> as sampling all of its challenges <span class="math">\\vec{r}\\in\\mathbb{F}^{\\ell}</span> at the start of the protocol (but only sending them one by one). Let event <span class="math">\\mathsf{good}</span> occur when <span class="math">\\mathcal{V}_{g}</span>’s sampled challenge <span class="math">\\vec{r}\\in G_{\\lambda}</span>. By Lemma 18, this event occurs with probability <span class="math">\\epsilon/8</span>. Even conditioned on <span class="math">\\mathsf{good}</span>, the invocations of <span class="math">\\mathsf{sam}</span> may fail, via the union bound, with negligible probability at most <span class="math">\\eta_{3}\\geq e^{-\\lambda}\\cdot\\mathrm{poly}(d,\\log(NG))</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The first step of <span class="math">\\hat{\\mathcal{P}}</span> succeeds with probability <span class="math">\\epsilon</span>. When this occurs, the second step runs an expected $2\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{\\lambda}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/\\epsilon<span class="math"> times to recover enough transcripts to extract the witness. Conditioned on the four events above, </span>\\hat{\\mathcal{P}}<span class="math"> always succeeds in convincing </span>\\mathcal{V}_{g}$, thus:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathrm{Pr}[\\langle\\hat{\\mathcal{P}}(s_{\\lambda}),V_{g}\\rangle(u_{\\lambda})=1]</span> <span class="math">\\geq\\epsilon\\cdot\\epsilon/8\\cdot(1-\\eta_{1}(\\lambda))</span> <span class="math">\\cdot(1-\\eta_{2}(\\lambda))\\cdot(1-\\eta_{3}(\\lambda))</span> <span class="math">\\geq\\epsilon^{2}/8-\\eta_{4}(\\lambda)</span></p>

    <p class="text-gray-300">where <span class="math">\\eta_{4}</span> is a negligible function and <span class="math">\\eta_{1}</span>, <span class="math">\\eta_{2}</span>, and <span class="math">\\eta_{3}</span> correspond to the events <span class="math">\\mathsf{bind}</span>, <span class="math">\\mathsf{coll}</span> and <span class="math">\\mathsf{sam}</span>.</p>

    <p class="text-gray-300">To compute the running time, there are three cases: (a) when step 1 fails (with probability <span class="math">1-\\epsilon</span>), (b) when step 1 succeeds and events <span class="math">\\mathsf{good}</span>, <span class="math">\\overline{\\mathsf{bind}}</span>, and <span class="math">\\overline{\\mathsf{coll}}</span> all occur, (c) when step 1 succeeds and <span class="math">\\overline{\\mathsf{good}}</span> occurs. In (a), <span class="math">\\hat{\\mathcal{P}}</span> runs one execution of <span class="math">\\hat{\\mathcal{P}}</span>, in (b), <span class="math">\\hat{\\mathcal{P}}</span> makes an expected polynomial number of executions of <span class="math">\\hat{\\mathcal{P}}</span>, and in (c), we use the loop bound <span class="math">t</span> to ensure that the runtime remains polynomial.</p>

    <p class="text-gray-300">Finally, the loop bound <span class="math">t</span> in <span class="math">\\mathsf{sam}</span> relies on <span class="math">\\epsilon</span>. We can either estimate this probability after Step 1 using an analysis technique from Goldreich and Kahan <em>[52]</em>, or we can be given this value as advice for this security parameter. Furthermore, we can use a standard technique of aborting the reduction after <span class="math">2^{\\lambda}</span> steps to catch the unexpected steps that may occur due to sampling errors. ∎</p>

    <h2 id="sec-61" class="text-2xl font-bold">Appendix C Randomized checks “inside the AC”</h2>

    <p class="text-gray-300">We describe a simple technique for running randomized tests “inside the AC.” We use this technique improve the cost of modulo-<span class="math">2^{32}</span> addition in an AC for SHA-256, but it is applicable to many randomized checks. Zhang et al. use a related approach to verify set intersections in vSQL <em>[112]</em>.</p>

    <p class="text-gray-300">Our implementation of SHA-256 uses a prior technique <em>[12]</em> to compute <span class="math">h=f+g\\mod 2^{32}</span> in an AC over a large prime field. Specifically, <span class="math">\\mathcal{P}</span> supplies witness elements <span class="math">\\{b_{i}\\}</span> that are purportedly the binary digits of <span class="math">f+g</span>, i.e., <span class="math">f+g=\\sum_{i}2^{i}b_{i}</span>. The AC computes and outputs the value <span class="math">f+g-\\sum_{i}2^{i}b_{i}</span>, which <span class="math">\\mathcal{V}</span> checks is equal to zero. The AC also encodes “bit tests” that ensure <span class="math">b_{i}\\in\\{0,1\\}</span>, namely, it computes and outputs <span class="math">\\{b_{i}\\cdot(1-b_{i})\\}</span>, which <span class="math">\\mathcal{V}</span> also checks are zero. Finally, the AC uses <span class="math">\\{b_{i}\\}</span> to compute <span class="math">h</span>, i.e., <span class="math">h=\\sum_{i=0}^{31}2^{i}b_{i}=f+g\\mod 2^{32}</span>.</p>

    <p class="text-gray-300">In our implementation, the SHA-256 AC entails more than <span class="math">7\\,000</span> bit tests. Because <span class="math">\\mathrm{Gir}^{++}</span> requires layered ACs (§3.2), the results of these tests must be passed layer-by-layer to the output, meaning that they cost <span class="math">\\approx$$7000d</span> gates in total. As a result, bit tests nearly double the size of the AC.</p>

    <p class="text-gray-300">To avoid this, we observe that it is safe for <span class="math">\\mathcal{V}</span> to believe that all bit tests have passed if <span class="math">\\sum_{i}r_{i}\\cdot b_{i}\\cdot(1-b_{i})=0</span> for <span class="math">r_{i}\\in_{\\bm{R}}\\mathbb{F}</span>—as long as <span class="math">\\mathcal{P}</span> <em>does not know</em> <span class="math">\\{r_{i}\\}</span> when it chooses <span class="math">\\{b_{i}\\}</span>. To ensure this, we introduce a small modification to Hyrax-I. Specifically, <span class="math">\\mathcal{V}</span> first encodes the above check into the AC. Then, during protocol execution, after <span class="math">\\mathcal{V}</span> sends <span class="math">x</span>, <span class="math">\\mathcal{P}</span> commits to the witness (including <span class="math">\\{b_{i}\\}</span>; §6); now <span class="math">\\mathcal{V}</span> chooses and sends <span class="math">\\{r_{i}\\}</span>, after which <span class="math">\\mathcal{P}</span> returns <span class="math">y</span> and the protocol continues as normal. <span class="math">\\mathcal{V}</span> rejects if the output corresponding to the above sum is not <span class="math">0</span>. Informally, since <span class="math">\\mathcal{P}</span> commits to <span class="math">\\{b_{i}\\}</span> before <span class="math">\\mathcal{V}</span> chooses <span class="math">\\{r_{i}\\}</span>, it cannot “fool” the test.</p>

    <p class="text-gray-300">Completeness follows by inspection; soundness follows from the Schwartz-Zippel lemma. This protocol is public coin, so it can be made non-interactive with the Fiat-Shamir heuristic. Finally, we note that in the data-parallel setting <span class="math">\\mathcal{V}</span> can supply a single <span class="math">\\{r_{i}\\}</span> for all <span class="math">N</span> sub-ACs (because <span class="math">\\mathcal{P}</span> commits to the entire witness at once).</p>

    <h2 id="sec-62" class="text-2xl font-bold">Appendix D Hyrax-I pseudocode</h2>

    <p class="text-gray-300">In this section, we provide pseudocode for Hyrax-I. Figure 9 details <span class="math">\\mathcal{V}</span>’s work; Figures 10 and 11 detail <span class="math">\\mathcal{P}</span>’s. Our presentation borrows from Wahby et al. <em>[109]</em>.</p>

    <h2 id="sec-63" class="text-2xl font-bold">Appendix E <span class="math">\\mathrm{Gir}^{++}</span> specification</h2>

    <p class="text-gray-300">In this section, we provide pseudocode for <span class="math">\\mathrm{Gir}^{++}</span>. Figures 12 and 13 detail <span class="math">\\mathcal{V}</span>’s work; Figures 14 and 15 detail <span class="math">\\mathcal{P}</span>’s. Our presentation borrows from Wahby et al. *[109]</p>

    <p class="text-gray-300">1: function HYRAX-VERIFY(ArithCircuit  <span class="math">c</span> , input  <span class="math">x</span> , output  <span class="math">y</span> , parameter  <span class="math">\\iota</span> ) 2: //Receive commitments to the rows of the matrix  <span class="math">T</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3:  $(T_0, \\ldots, T_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^1 / i}) \\gets \\text{ReceiveFromProver()}$  // see Line 3 of Figure 10</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">4:  <span class="math">b_{N}\\gets \\log N,b_{G}\\gets \\log G</span> 5:  <span class="math">(q_0&#x27;, q_{0,L}) \\xleftarrow{R} \\mathbb{P}^{b_N} \\times \\mathbb{P}^{b_G}</span> 6:  <span class="math">\\mu_{0,0} \\gets 1, \\mu_{0,1} \\gets 0, q_{0,R} \\gets q_{0,L}</span> 7:  <span class="math">a_0 \\gets \\operatorname{Com}(\\hat{V}_y(q_0&#x27;, q_{0,0}); 0)</span> 8: SendToProver  <span class="math">(q_0&#x27;, q_{0,0})</span>  // see Line 5 of Figure 10 9:  <span class="math">d\\gets c</span>  .depth 10: 11: for i=1,...,d do 12:  <span class="math">(X,Y,r^{\\prime},r_{L},r_{R})\\gets \\mathrm{ZK - SUMCHECKV}(i,a_{i - 1},q_{i - 1}^{\\prime},q_{i - 1,L},q_{i - 1,R})</span> 13: //  <span class="math">X = \\operatorname{Com}(\\nu_0), Y = \\operatorname{Com}(\\nu_1)</span> 14: 15: if i&lt;d then 16: // Pick the next random  <span class="math">\\mu_{i,0},\\mu_{i,1}</span>  and 17: // compute random linear combination (§3.2) 18:  <span class="math">\\mu_{i,0},\\mu_{i,1}\\xleftarrow{R}\\mathbb{P}</span> 19:  <span class="math">a_{i}\\gets X^{\\mu_{i,0}}\\odot Y^{\\mu_{i,1}}</span> 20:  <span class="math">(q_i&#x27;, q_{i,L}, q_{i,R}) \\gets (r&#x27;, r_L, r_R)</span> 21: SendToProver  <span class="math">(\\mu_{i,0},\\mu_{i,1})</span>  // see Line 14 of Figure 10 22: 23: // For the final check, reduce from two points to one point (§3.2) 24:  <span class="math">(\\operatorname{Com}(H_0), \\ldots, \\operatorname{Com}(H_{b_G})) \\gets \\text{ReceiveFromProver()}</span>  // see Line 18 of Figure 10 25: for  <span class="math">i = 0,\\dots ,b_{G}</span>  do 26: proof-of-opening  <span class="math">(\\operatorname {Com}(H_i))</span> 27: proof-of-equality  <span class="math">(\\operatorname {Com}(H_0),X)</span> 28: proof-of-equality  <span class="math">(\\operatorname {Com}(H_{b_G})\\odot \\ldots \\odot \\operatorname {Com}(H_0),Y)</span> 29:  <span class="math">\\tau \\xleftarrow{R} \\mathbb{P}</span> 30: SendToProver(τ) // see Line 23 of Figure 10 31:  <span class="math">q_{d}\\gets (r^{\\prime},(1 - \\tau)\\cdot r_{L} + \\tau \\cdot r_{R})</span> 32:  <span class="math">\\zeta = \\operatorname{Com}(H_{b_G})^{\\tau^{\\log G}} \\odot \\operatorname{Com}(H_{b_G^{-1}})^{\\tau^{\\log G^{-1}}} \\odot \\ldots \\odot \\operatorname{Com}(H_0)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">33:  $T^{\\prime}\\gets \\bigodot_{i = 0}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{1 / i - 1}}T_{i}^{\\hat{\\chi}_{i}}<span class="math">  //  </span>\\hat{\\chi}_b$  is defined in Section 6</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">35: proof  <span class="math">\\log</span>  -of-dot-prod  <span class="math">(T^{\\prime q_d[0]},\\zeta \\odot g^{(1 - q_d[0] / \\hat{V}_x(q_d[1,\\dots,b_N + b_G^{-1}])},R)</span> 36: return accept 37: 38: function ZK-SUMCHECKV(layer  <span class="math">i,a_{i - 1},q_{i - 1}^{\\prime},q_{i - 1,L},q_{i - 1,R})</span> 39:  <span class="math">(r^{\\prime},r_{L},r_{R})\\xleftarrow{R}\\mathbb{P}^{\\log N}\\times \\mathbb{P}^{\\log G}\\times \\mathbb{P}^{\\log G}</span> 40:  <span class="math">r\\gets (r^{\\prime},r_{L},r_{R})</span> 41: for  <span class="math">j = 1,\\dots ,\\log N + 2\\log G</span>  do 42:  <span class="math">\\alpha_{j}\\gets</span>  ReceiveFromProver() //  <span class="math">\\alpha_{j}</span>  is  <span class="math">\\operatorname {Com}(s_j)</span>  ; see Lines 19,47 of Figure 11 43: SendToProver  <span class="math">(r[j])</span>  // see Lines 20,48 of Figure 11 44:  <span class="math">(X,Y,Z)\\gets</span>  ReceiveFromProver() // see Line 52 of Figure 11 45: //  <span class="math">X = \\operatorname{Com}(\\nu_0), Y = \\operatorname{Com}(\\nu_1), Z = \\operatorname{Com}(\\nu_0\\nu_1)</span> 46: //  <span class="math">\\mathcal{V}</span>  computes  <span class="math">\\{M_j\\}</span>  as defined in Equation (5) 47: proof-of-sum-check  <span class="math">(a_{i - 1},\\{\\alpha_j\\} ,\\{M_j\\} ,X,Y,Z)</span>  // see Figure 1 48: return  <span class="math">(\\operatorname {Com}(\\nu_0),\\operatorname {Com}(\\nu_1),r&#x27;,r_L,r_R)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">FIGURE 9—Pseudocode for  <span class="math">\\mathcal{V}</span>  in Hyrax-I (§7).  <span class="math">\\mathcal{P}</span> 's work is described in Figures 10 and 11. For notational convenience, we assume  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ , as in Section 6.1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">1: function HYRAX-PROVE(ArithCircuit  <span class="math">c</span> , input  <span class="math">x</span> , witness  <span class="math">w</span> , parameter  <span class="math">\\iota</span> )</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2: // Commit to the rows of T via commitments  $T_{1},\\ldots ,T_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{1 / k}}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">4:  <span class="math">b_{N}\\gets \\log N,b_{G}\\gets \\log G</span> 5:  <span class="math">(q_0&#x27;, q_{0,L}) \\gets \\text{ReceiveFromVerifier()}</span>  // see Line 8 of Figure 9 6:  <span class="math">\\mu_{0,0} \\gets 1, \\mu_{0,1} \\gets 0, q_{0,R} \\gets q_{0,L}</span> 7:  <span class="math">a_0 \\gets \\operatorname{Com}(\\hat{V}_y(q_0&#x27;, q_{0,L}); 0)</span> 8:  <span class="math">d\\gets c</span>  .depth 9: 10: for  <span class="math">i = 1,\\dots ,d</span>  do 11:  <span class="math">(X,Y,q_i^{\\prime},q_{i,L},q_{i,R})\\gets \\mathrm{ZK - SUMCHECKP}(c,i,a_{i - 1},\\mu_{i - 1,0},\\mu_{i - 1,1},</span> 12:  <span class="math">q_{i - 1}^{\\prime},q_{i - 1,L},q_{i - 1,R})</span> 13: if i&lt;d then 14:  <span class="math">(\\mu_{i,0},\\mu_{i,1})\\gets</span>  ReceiveFromVerifier() // see Line 21 of Figure 9 15:  <span class="math">a_{i}\\gets X^{\\mu_{i,0}}\\odot Y^{\\mu_{i,1}}</span> 16: 17: // Compute Coefficients of the degree  <span class="math">b_{G}</span>  polynomial H:  <span class="math">H_0, \\ldots, H_{\\log G}</span> 18: SendToVerifier  <span class="math">(\\operatorname{Com}(H_0), \\ldots, \\operatorname{Com}(H_{b_G}))</span>  // see Line 21 of Figure 9 19: for  <span class="math">i = 0,\\dots ,b_{G}</span>  do 20: proof-of-opening  <span class="math">(\\operatorname {Com}(H_i))</span> 21: proof-of-equality  <span class="math">(\\operatorname {Com}(H_0),X)</span> 22: proof-of-equality  <span class="math">(\\operatorname {Com}(H_{b_G})\\odot \\ldots \\odot \\operatorname {Com}(H_0),Y)</span> 23:  <span class="math">\\tau \\gets</span>  ReceiveFromVerifier() // see Line 30 of Figure 9 24:  <span class="math">q_{d}\\gets (q_{d}^{\\prime},(1 - \\tau)\\cdot q_{d,L} + \\tau \\cdot q_{d,R})</span> 25:  <span class="math">\\zeta = \\operatorname{Com}(H_{b_G})^{\\tau^{\\log G}} \\odot \\operatorname{Com}(H_{b_G^{-1}})^{\\tau^{\\log G^{-1}}} \\odot \\ldots \\odot \\operatorname{Com}(H_0)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">26:  $T^{\\prime}\\gets \\bigodot_{i = 0}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{1 / k} - 1}T_{i}^{\\hat{\\chi}_{i}}<span class="math">  //  </span>\\hat{\\chi}_b$  is defined in Section 6</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">28: proof  <span class="math">\\log</span>  -of-dot-prod  <span class="math">(T^{\\prime q_d[0]},\\zeta \\odot g^{(1 - q_d[0] / \\hat{V}_x(q_d[1,\\dots,b_N + b_G^{-1}])},R)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">FIGURE 10—Pseudocode for  <span class="math">\\mathcal{P}</span>  in Hyrax-I (§7). The ZK-SumCheckP subroutine is defined in Figure 11.  <span class="math">\\mathcal{V}</span> 's work is described in Figure 9. For notational convenience, we assume  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ , as in Section 6.1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">1: function ZK-SUMCHECKPI(ArithCircuit  <span class="math">c</span> , layer  <span class="math">i</span> ,  <span class="math">a_{i-1}</span> ) 2:  <span class="math">\\mu_{i-1,0}, \\mu_{i-1,1}, q_{i-1}^{\\prime}, q_{i-1,L}, q_{i-1,R}</span> 3: for  <span class="math">j = 1, \\dots, b_N</span>  do 4: // In these rounds, prover sends commitment to degree-3 polynomial  <span class="math">s_j</span> 5: for all  <span class="math">\\sigma \\in \\{0,1\\}^{b_N - j}</span>  and  <span class="math">g\\in \\{0,1\\} ^b G</span>  and  <span class="math">k\\in \\{-1,0,1,2\\}</span>  do 6:  <span class="math">s\\gets (g,g_L,g_R)</span>  //  <span class="math">g_{L},g_{R}</span>  are labels of  <span class="math">g</span>  's layer-  <span class="math">i</span>  inputs in sub-circuit. 7: termP  <span class="math">\\leftarrow \\widehat{\\omega}_l(q_{i - 1}^{\\prime},r^{\\prime}[1],\\dots ,r^{\\prime}[j - 1],k,\\sigma [1],\\dots ,\\sigma [b_N - j])</span> 8:  <span class="math">(\\mu_{i - 1,0}\\cdot \\chi_X(q_{i - 1,L}) + \\mu_{i - 1,1}\\cdot \\chi_X(q_{i - 1,R}))</span> 9: termL  <span class="math">\\leftarrow \\tilde{V}_i(r&#x27;[1],\\dots ,r&#x27;[j - 1],k,\\sigma [1],\\dots ,\\sigma [b_N - j],g_L)</span> 10: termR  <span class="math">\\leftarrow \\tilde{V}_i(r&#x27;[1],\\dots ,r&#x27;[j - 1],k,\\sigma [1],\\dots ,\\sigma [b_N - j],g_R)</span> 11: 12: if  <span class="math">g</span>  is an add gate then  <span class="math">s_j[\\sigma ,g][k]\\gets \\mathrm{termP}\\cdot (\\mathrm{termL} + \\mathrm{termR})</span> 13: else if  <span class="math">g</span>  is a mult gate then  <span class="math">s_j[\\sigma ,g][k]\\gets \\mathrm{termP}\\cdot \\mathrm{termL}\\cdot \\mathrm{termR}</span> 14: 15: for  <span class="math">k\\in \\{-1,0,1,2\\}</span>  do 16:  <span class="math">s_j[k]\\gets \\sum_{\\sigma \\in \\{0,1\\}^{b_N - j}}\\sum_{g\\in \\{0,1\\}^{b_G}}s_j[\\sigma ,g][k]</span> 17: 18: // Compute coefficients of  <span class="math">s_j</span>  and create a multi-commitment (§5) 19: SendToVerifier(Com(sj)) // see Line 42 of Figure 9 20:  <span class="math">r^{\\prime}[j]\\gets</span>  ReceiveFromVerifier() // see Line 43 of Figure 9 21: 22:  <span class="math">r^{\\prime}\\gets (r^{\\prime}[1],\\dots ,r^{\\prime}[b_N])</span>  // notation 23: 24: for  <span class="math">j = 1,\\dots ,2b_{G}</span>  do 25: // In these rounds, prover sends commitment to degree-2 polynomial  <span class="math">s_{b_N + j}</span> 26: for all gates  <span class="math">g\\in \\{0,1\\} ^b G</span>  and  <span class="math">k\\in \\{-1,0,1\\}</span>  do 27:  <span class="math">s\\gets (g,g_L,g_R)</span>  //  <span class="math">g_{L},g_{R}</span>  are labels of  <span class="math">g</span>  's layer-  <span class="math">i</span>  inputs in subcircuit 28:  <span class="math">u_{k,0}\\gets (q_{i - 1,L}[1],\\dots ,q_{i - 1,L}[b_G],r[1],\\dots ,r[j - 1],k)</span> 29:  <span class="math">u_{k,1}\\gets (q_{i - 1,R}[1],\\dots ,q_{i - 1,R}[b_G],r[1],\\dots ,r[j - 1],k)</span> 30: termP  <span class="math">\\leftarrow \\widehat{\\omega}_l(q_{i - 1}^{\\prime},r^{\\prime})\\cdot (\\mu_{i,0}\\cdot \\prod_{\\ell = 1}^{b_G + j}\\chi_{s[\\ell ]}(u_{k,0}[\\ell ]) +</span> 31:  <span class="math">\\mu_{i,1}\\cdot \\prod_{\\ell = 1}^{b_G + j}\\chi_{s[\\ell ]}(u_{k,1}[\\ell ]))</span> 32: 33: if  <span class="math">j\\leq b_G</span>  then 34: termL  <span class="math">\\leftarrow \\tilde{V}_i(r&#x27;,r[1],\\dots ,r[j - 1],k,g_L[j + 1],\\dots ,g_L[b_G])</span> 35: termR  <span class="math">\\leftarrow \\tilde{V}_i(r&#x27;,g_R)</span> 36: else //  <span class="math">b_{G} &amp;lt;   j\\leq 2b_{G}</span> 37: termL  <span class="math">\\leftarrow \\tilde{V}_i(r&#x27;,r[1],\\dots ,r[b_G])</span> 38: termR  <span class="math">\\leftarrow \\tilde{V}_i(r&#x27;,r[b_G + 1],\\dots ,r[j - 1],k,g_R[j - b_G + 1],\\dots ,g_R[b_G])</span> 39: 40: if  <span class="math">g</span>  is an add gate then  <span class="math">s_{b_N + j}[g][k]\\gets</span>  termP  <span class="math">\\cdot</span>  (termL  <span class="math">^+</span>  termR) 41: else if  <span class="math">g</span>  is a mult gate then  <span class="math">s_{b_N + j}[g][k]\\gets</span>  termP  <span class="math">\\cdot</span>  termL  <span class="math">\\cdot</span>  termR 42: 43: for  <span class="math">k\\in \\{-1,0,1\\}</span>  do 44:  <span class="math">s_{b_N + j}[k]\\gets \\sum_{g\\in \\{0,1\\}^{b_G}}s_{b_N + j}[g][k]</span> 45: 46: // Compute coefficients of  <span class="math">s_{b_N + j}</span>  and create a multi-commitment (§5) 47: SendToVerifier(Com  <span class="math">(s_{b_N + j}))</span>  // see Line 42 of Figure 9 48:  <span class="math">r[j]\\gets</span>  ReceiveFromVerifier() // see Line 43 of Figure 9 49: 50:  <span class="math">r_0\\gets (r[1],\\dots ,r[b_G])</span> <span class="math">r_1\\gets (r[b_G + 1],\\dots ,r[2b_G])</span>  // notation 51:  <span class="math">\\nu_{0}\\gets \\tilde{V}_{i}(r^{\\prime},r_{0})</span> <span class="math">\\nu_{1}\\gets \\tilde{V}_{i}(r^{\\prime},r_{1})</span>  //  <span class="math">X = \\mathrm{Com}(\\nu_0),Y = \\mathrm{Com}(\\nu_1),Z = \\mathrm{Com}(\\nu_0\\nu_1)</span> 52: SendToVerifier(X,Y,Z) // see Line 44 of Figure 9 53: //  <span class="math">\\mathcal{P}</span>  computes  <span class="math">\\{M_k\\}</span>  as defined in Equation (5). 54: proof-of-sum-check  <span class="math">(a_{i - 1},\\{\\mathrm{Com}(s_j)\\} ,\\{M_k\\} ,X,Y,Z)</span>  // see Figure 1 55: 56: return  <span class="math">(\\mathrm{Com}(\\nu_0),\\mathrm{Com}(\\nu_1),r&#x27;,r_0,r_1)</span></p>

    <p class="text-gray-300">1: function VERIFY(ArithCircuit c, input  <span class="math">x</span> , output  <span class="math">y</span> ) 2: //  <span class="math">\\mathcal{P}</span>  sends witness  <span class="math">w</span>  to  <span class="math">\\mathcal{V}</span>  in the clear at start of protocol. 3:  <span class="math">w\\gets</span>  ReceiveFromProver() // see Line 3 of Figure 14 4:  <span class="math">(q_0&#x27;, q_0) \\stackrel{R}{\\leftarrow} \\mathbb{P}^{\\log N} \\times \\mathbb{P}^{\\log G}</span> 5:  <span class="math">a_0 \\gets \\tilde{V}_y(q_0&#x27;, q_0) // \\tilde{V}_y</span>  is the multilin. ext. of the output  <span class="math">y</span> 6: 7: // The first iteration of sum-check only involves a claim about a single 8: // evaluation of  <span class="math">\\tilde{V}_0</span> , rather than a linear combination of two evaluations; 9: // we encode this as a trivial linear combination. 10:  <span class="math">\\mu_{0,0}\\gets 1,\\mu_{0,1}\\gets 0,q_{0,L}\\gets q_0,q_{0,R}\\gets q_0</span> 11: 12: SendToProver  <span class="math">(q_0&#x27;, q_0)</span>  // see Line 4 of Figure 14 13:  <span class="math">d\\gets c.\\mathrm{depth}</span> 14: 15: for  <span class="math">i = 1,\\dots ,d</span>  do 16: // Reduce  <span class="math">\\mu_{i - 1,0}\\cdot \\tilde{V}_{i - 1}(q_{i - 1}^{\\prime},q_{i - 1,L}) + \\mu_{i - 1,1}\\cdot \\tilde{V}_{i - 1}(q_{i - 1}^{\\prime},q_{i - 1,R})\\stackrel {<em>}{-}a_{i - 1}</span>  to 17: //  <span class="math">Q_{i}(r^{\\prime},r_{L},r_{R})\\stackrel {</em>}{=}e</span>  where  <span class="math">Q_{i}</span>  is given in §3.2 18:  <span class="math">(e,r^{\\prime},r_{L},r_{R})\\gets \\mathrm{SUMCHECKV}(i,a_{i - 1})</span> 19: 20: if  <span class="math">i &amp;lt;   d</span>  then 21:  <span class="math">(q_i&#x27;, q_{i,L}, q_{i,R}) \\gets (r&#x27;, r_L, r_R)</span> 22:  <span class="math">\\nu_{0},\\nu_{1}\\gets</span>  ReceiveFromProver() // see Line 53 of Figure 15 23: termA1  <span class="math">\\leftarrow \\mu_{i - 1,0}\\cdot \\mathrm{add}_i(q_{i - 1,L},r_L,r_R)</span> 24: termA2  <span class="math">\\leftarrow \\mu_{i - 1,1}\\cdot \\mathrm{add}_i(q_{i - 1,R},r_L,r_R)</span> 25: termM1  <span class="math">\\leftarrow \\mu_{i - 1,0}\\cdot \\mathrm{mult}_i(q_{i - 1,L},r_L,r_R)</span> 26: termM2  <span class="math">\\leftarrow \\mu_{i - 1,1}\\cdot \\mathrm{mult}_i(q_{i - 1,R},r_L,r_R)</span> 27: 28: if  <span class="math">e\\neq \\widehat{\\omega}_l(q_{i - 1}^{\\prime},r^{\\prime})\\cdot \\left[\\left\\{\\mathrm{termA1 + termA2}\\right\\} \\cdot (\\nu_0 + \\nu_1)\\right.</span> 29:  <span class="math">+\\{\\mathrm{termM1 + termM2}\\} \\cdot \\nu_0\\cdot \\nu_1]</span>  then 30: return reject 31: 32: // Reduce the two  <span class="math">\\nu_{0},\\nu_{1}</span>  questions to a random linear combination thereof 33:  <span class="math">\\mu_{i,0},\\mu_{i,1}\\stackrel {R}{\\leftarrow}\\mathbb{P}</span> 34:  <span class="math">a_{i}\\gets \\mu_{i,0}\\cdot \\nu_{0} + \\mu_{i,1}\\cdot \\nu_{1}</span> 35: 36: SendToProver  <span class="math">(\\mu_{i,0},\\mu_{i,1})</span>  // see Line 12 of Figure 14 37: 38: // For the final layer,  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  reduce two points to one point (§3.2) 39:  <span class="math">(H_0,\\dots ,H_{b_G})\\gets</span>  ReceiveFromProver() // see Line 56 of Figure 15 40:  <span class="math">\\tau \\stackrel {R}{\\leftarrow} \\mathbb{P}</span> 41:  <span class="math">q_d^{\\prime}\\gets r^{\\prime}</span> 42:  <span class="math">q_{d}\\gets (1 - \\tau)\\cdot r_{L} + \\tau \\cdot r_{R}</span> 43:  <span class="math">a_{d}\\gets H_{b_{G}}\\cdot \\tau^{\\log G} + H_{b_{G - 1}}\\cdot \\tau^{\\log G - 1} + \\ldots +H_{0}</span> 44: 45: //  <span class="math">\\tilde{V}_d(\\cdot)</span>  is the multilinear extension of  <span class="math">(x,w)</span>  where  <span class="math">x</span>  is input and  <span class="math">w</span>  is witness 46: if  <span class="math">\\tilde{V}_d(q_d&#x27;,q_d)\\neq a_d</span>  then 47: return reject 48: return accept</p>

    <p class="text-gray-300">FIGURE 12— <span class="math">\\mathcal{V}</span> 's side of our non-zero-knowledge interactive proof  <span class="math">\\mathrm{Gir}^{++}</span> .  <span class="math">\\mathrm{Gir}^{++}</span>  is equivalent to the interactive proof in Giraffe, but incorporates a technique of Chiesa et al. [35] in place of GKR's "reducing from two points to one point" step.  <span class="math">\\mathcal{V}</span> 's side of the sum-check protocol and  <span class="math">\\mathcal{P}</span> 's work are described in Figures 13, 14, and 15.</p>

    <p class="text-gray-300">1: function SumCHECKV(layer  <span class="math">i</span> ,  <span class="math">a_{i-1}</span> ) 2:  <span class="math">e\\gets a_{i - 1}</span> 3: 4:  <span class="math">(r&#x27;, r_L, r_R) \\xleftarrow{R} \\overline{\\mathbb{P}}^{b_N} \\times \\overline{\\mathbb{P}}^{b_G} \\times \\overline{\\mathbb{P}}^{b_G}</span> 5:  <span class="math">r\\gets (r&#x27;,r_L,r_R)</span> 6: 7: for  <span class="math">j = 1,2,\\ldots ,(b_{N} + 2b_{G})</span>  do 8: 9: //  <span class="math">F_{j}</span>  is a degree-2 or degree-3 polynomial 10:  <span class="math">F_{j}\\gets</span>  ReceiveFromProver() // see Lines 18,47 of Figure 15 11: 12: if  <span class="math">F_{j}(0) + F_{j}(1)\\neq e</span>  then 13: return reject 14: 15: SendToProver  <span class="math">(r[j])</span>  // see Lines 19,48 of Figure 15 16: 17:  <span class="math">e\\gets F_j(r[j])</span> 18: 19: return  <span class="math">(e,r^{\\prime},r_{L},r_{R})</span></p>

    <p class="text-gray-300">FIGURE 13— <span class="math">\\mathcal{V}</span> 's side of the sum-check protocol within  <span class="math">\\mathrm{Gir}^{++}</span> . This protocol reduces the claim that  <span class="math">a_{i}</span>  equals the sum  <span class="math">\\sum_{n,h_{L},h_{R}}Q_{i}(n,h_{L},h_{R})</span>  (this sum equals  <span class="math">\\mu_{i - 1,L}\\cdot \\tilde{V}_{i - 1}(q_{i - 1}^{\\prime},q_{i - 1,L}) + \\mu_{i - 1,R}\\cdot \\tilde{V}_{i - 1}(q_{i - 1}^{\\prime},q_{i - 1,R})</span> , per §3.2, "Random linear combination") to the claim  <span class="math">e = Q_{i}(r^{\\prime},r_{L},r_{R})</span> .</p>

    <p class="text-gray-300">1: function PROVE(ArithCircuit c, input  <span class="math">x</span> , output  <span class="math">y</span> ) 2: // Let  <span class="math">w</span>  be a witness such that  <span class="math">c(x, w) = y</span> 3: SendToVerifier(w) // see Line 3 of Figure 12. 4:  <span class="math">(q_0&#x27;, q_0) \\gets \\text{ReceiveFromVerifier()}</span>  // see Line 12 of Figure 12 5:  <span class="math">\\mu_{0,0} \\gets 1, \\mu_{0,1} \\gets 0, q_{0,L} \\gets q_0, q_{0,R} \\gets q_0.</span> 6:  <span class="math">d\\gets \\mathrm{c.depth}</span> 7: 8: // each circuit layer induces one sum-check invocation 9: for  <span class="math">i = 1,\\dots ,d</span>  do 10:  <span class="math">(q_i&#x27;, q_{i,L}, q_{i,R}) \\gets \\text{SUMCHECKP}(c, i, q_{i-1}&#x27;, \\mu_{i-1,0}, q_{i-1,L}, \\mu_{i-1,1}, q_{i-1,R})</span> 11: if  <span class="math">i &amp;lt;   d</span>  then 12:  <span class="math">(\\mu_{i,0},\\mu_{i,1})\\gets</span>  ReceiveFromVerifier() // see Line 36 of Figure 12</p>

    <p class="text-gray-300">FIGURE 14—Pseudocode for  <span class="math">\\mathcal{P}</span>  in  <span class="math">\\mathrm{Gir}^{++}</span> . SumCHECKP is defined in Figure 15.</p>

    <p class="text-gray-300">1: function SumCHECKP(ArithCircuit c, layer  <span class="math">i</span> ,  <span class="math">q_{i-1}^{\\prime}</span> ,  <span class="math">\\mu_{i-1,0}</span> ,  <span class="math">q_{i-1,0}</span> ,  <span class="math">\\mu_{i-1,1}</span> ,  <span class="math">q_{i-1,1}</span> ) 2: for  <span class="math">j = 1,\\dots ,b_{N}</span>  do 3: // Prover sends degree-3 polynomial  <span class="math">F_{j}</span> . Does this by computing  <span class="math">F_{j}(-1), F_{j}(0), F_{j}(1), F_{j}(2)</span>  and then interpolating. 4: 5: for all  <span class="math">\\sigma \\in \\{0,1\\}^{b_N - j}</span>  and  <span class="math">g\\in \\{0,1\\}^{b_G}</span>  and  <span class="math">k\\in \\{-1,0,1,2\\}</span>  do 6:  <span class="math">s\\gets (g,g_L,g_R) / / g_L,g_R</span>  are labels of  <span class="math">g</span>  's layer-  <span class="math">i</span>  inputs in sub-circuit. 7: 8: termP  <span class="math">\\leftarrow \\widehat{\\mathrm{su}} (q_{i - 1}^{\\prime},r^{\\prime}[1],\\ldots ,r^{\\prime}[j - 1],k,\\sigma [1],\\ldots ,\\sigma [b_{N} - j])\\cdot (\\mu_{i - 1,0}\\cdot \\chi_{g}(q_{i - 1,0}) + \\mu_{i - 1,1}\\cdot \\chi_{g}(q_{i - 1,1}))</span> 9: termL  <span class="math">\\leftarrow \\widehat{V}_i(r&#x27;[1],\\ldots ,r&#x27;[j - 1],k,\\sigma [1],\\ldots ,\\sigma [b_N - j],g_L)</span> 10: termR  <span class="math">\\leftarrow \\widehat{V}_i(r&#x27;[1],\\ldots ,r&#x27;[j - 1],k,\\sigma [1],\\ldots ,\\sigma [b_N - j],g_R)</span> 11: 12: if  <span class="math">g</span>  is an add gate then  <span class="math">F_{j}[\\sigma ,g][k]\\gets \\mathrm{termP}\\cdot (\\mathrm{termL} + \\mathrm{termR})</span> 13: else if  <span class="math">g</span>  is a mult gate then  <span class="math">F_{j}[\\sigma ,g][k]\\gets \\mathrm{termP}\\cdot \\mathrm{termL}\\cdot \\mathrm{termR}</span> 14: 15: for  <span class="math">k\\in \\{-1,0,1,2\\}</span>  do 16:  <span class="math">F_{j}[k]\\gets \\sum_{\\sigma \\in \\{0,1\\}^{b_{N} - j}}\\sum_{g\\in \\{0,1\\}^{b_{G}}}F_{j}[\\sigma ,g][k]</span> 17: // Use Lagrange interpolation to compute coefficients of  <span class="math">F_{j}</span>  and send them to  <span class="math">\\mathcal{V}</span> 18: SendToVerifier  <span class="math">(F_j,3)</span>  // see Line 10 of Figure 13 19:  <span class="math">r^{\\prime}[j]\\gets</span>  ReceiveFromVerifier() // see Line 15 of Figure 13 20: 21:  <span class="math">r^{\\prime}\\gets (r^{\\prime}[1],\\ldots ,r^{\\prime}[b_{N}])</span>  // notation 22: 23: for  <span class="math">j = 1,\\dots ,2b_{G}</span>  do 24: // In these rounds, prover sends degree-2 polynomial  <span class="math">F_{b_N + j}</span> 25: for all gates  <span class="math">g\\in \\{0,1\\}^{b_G}</span>  and  <span class="math">k\\in \\{-1,0,1\\}</span>  do 26: 27:  <span class="math">s\\gets (g,g_L,g_R)</span>  //  <span class="math">g_{L},g_{R}</span>  are labels of  <span class="math">g</span>  's layer-  <span class="math">i</span>  inputs in subcircuit 28:  <span class="math">u_{k,0}\\gets (q_{i - 1,0}[1],\\ldots ,q_{i - 1,0}[b_G],r[1],\\ldots ,r[j - 1],k)</span> 29:  <span class="math">u_{k,1}\\gets (q_{i - 1,1}[1],\\ldots ,q_{i - 1,1}[b_G],r[1],\\ldots ,r[j - 1],k)</span> 30: termP  <span class="math">\\leftarrow \\widehat{\\mathrm{su}} (q_{i - 1}^{\\prime},r^{\\prime})\\cdot \\left(\\mu_{i,0}\\cdot \\prod_{\\ell = 1}^{b_{G} + j}\\chi_{s[\\ell ]}(u_{k,0}[\\ell ]) + \\mu_{i,1}\\cdot \\prod_{\\ell = 1}^{b_{G} + j}\\chi_{s[\\ell ]}(u_{k,1}[\\ell ])\\right)</span> 31: 32: if  <span class="math">j\\leq b_G</span>  then 33: termL  <span class="math">\\leftarrow \\widehat{V}_i(r&#x27;,r[1],\\ldots ,r[j - 1],k,g_L[j + 1],\\ldots ,g_L[b_G])</span> 34: termR  <span class="math">\\leftarrow \\widehat{V}_i(r&#x27;,g_R)</span> 35: else //  <span class="math">b_{G} &amp;lt;   j\\leq 2b_{G}</span> 36: termL  <span class="math">\\leftarrow \\widehat{V}_i(r&#x27;,r[1],\\ldots ,r[b_G])</span> 37: termR  <span class="math">\\leftarrow \\widehat{V}_i(r&#x27;,r[b_G + 1],\\ldots ,r[j - 1],k,g_R[j - b_G + 1],\\ldots ,g_R[b_G])</span> 38: 39: if  <span class="math">g</span>  is an add gate then 40:  <span class="math">F_{b_N + j}[g][k]\\gets</span>  termP  <span class="math">\\cdot</span>  (termL  <span class="math">^+</span>  termR) 41: else if  <span class="math">g</span>  is a mult gate then 42:  <span class="math">F_{b_N + j}[g][k]\\gets</span>  termP  <span class="math">\\cdot</span>  termL  <span class="math">\\cdot</span>  termR 43: 44: for  <span class="math">k\\in \\{-1,0,1\\}</span>  do 45:  <span class="math">F_{b_N + j}[k]\\gets \\sum_{g\\in \\{0,1\\}^{b_G}}F_{b_N + j}[g][k]</span> 46: // Use Lagrange interpolation to compute coefficients of  <span class="math">F_{b_N + j}</span>  and send them to verifier 47: SendToVerifier  <span class="math">(F_{b_N + j},2)</span>  // see Line 10 of Figure 13 48:  <span class="math">r[j]\\gets</span>  ReceiveFromVerifier() // see Line 15 of Figure 13 49: 50:  <span class="math">r_0\\gets (r[1],\\ldots ,r[b_G])</span> <span class="math">r_1\\gets (r[b_G + 1],\\ldots ,r[2b_G])</span>  // notation 51: 52: if  <span class="math">i &amp;lt;   c</span>  .depth then 53: SendToVerifier  <span class="math">(\\widehat{V}_i(r&#x27;,r_0),\\widehat{V}_i(r&#x27;,r_1))</span>  // see Line 22 of Figure 12 54: else // in the last sum-check invocation,  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  reduce two points to one point (§3.2) 55: // First, compute coefficients of  <span class="math">H(\\cdot)</span>  , i.e.,  <span class="math">\\widehat{V}_d</span>  restricted to the line passing through  <span class="math">(r^{\\prime},r_0)</span>  and  <span class="math">(r^{\\prime},r_{1})</span> 56: SendToVerifier  <span class="math">((H_0,\\dots ,H_{b_G}))</span>  // see Line 39 of Figure 12 57: 58: return  <span class="math">(r^{\\prime},r_{0},r_{1})</span></p>

    <p class="text-gray-300">FIGURE 15— <span class="math">\\mathcal{P}</span>  pseudocode in our non-zero-knowledge interactive proof  <span class="math">\\mathrm{Gir}^{+ + }</span>  for the layer-  <span class="math">i</span>  sum-check invocation.</p>`;
---

<BaseLayout title="Doubly-efficient zkSNARKs without trusted setup (2017/1132)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2017 &middot; eprint 2017/1132
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
